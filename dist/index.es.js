var hS = (r) => {
  throw TypeError(r);
};
var Jg = (r, e, i) => e.has(r) || hS("Cannot " + i);
var me = (r, e, i) => (Jg(r, e, "read from private field"), i ? i.call(r) : e.get(r)), zt = (r, e, i) => e.has(r) ? hS("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, i), mt = (r, e, i, n) => (Jg(r, e, "write to private field"), n ? n.call(r, i) : e.set(r, i), i), or = (r, e, i) => (Jg(r, e, "access private method"), i);
var sp = (r, e, i, n) => ({
  set _(s) {
    mt(r, e, s, i);
  },
  get _() {
    return me(r, e, n);
  }
});
import * as h2 from "react";
import ni, { useState as Pe, useEffect as si, useRef as yr, forwardRef as b3, useMemo as x3, useCallback as Dr, useImperativeHandle as _3, useLayoutEffect as T3, createContext as S3 } from "react";
import d2 from "3d-force-graph-vr";
var R0 = { exports: {} }, $c = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dS;
function w3() {
  if (dS) return $c;
  dS = 1;
  var r = ni, e = Symbol.for("react.element"), i = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(l, u, c) {
    var h, d = {}, p = null, f = null;
    c !== void 0 && (p = "" + c), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (f = u.ref);
    for (h in u) n.call(u, h) && !a.hasOwnProperty(h) && (d[h] = u[h]);
    if (l && l.defaultProps) for (h in u = l.defaultProps, u) d[h] === void 0 && (d[h] = u[h]);
    return { $$typeof: e, type: l, key: p, ref: f, props: d, _owner: s.current };
  }
  return $c.Fragment = i, $c.jsx = o, $c.jsxs = o, $c;
}
var Yc = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pS;
function E3() {
  return pS || (pS = 1, process.env.NODE_ENV !== "production" && function() {
    var r = ni, e = Symbol.for("react.element"), i = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), m = Symbol.iterator, v = "@@iterator";
    function y(R) {
      if (R === null || typeof R != "object")
        return null;
      var J = m && R[m] || R[v];
      return typeof J == "function" ? J : null;
    }
    var g = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(R) {
      {
        for (var J = arguments.length, ce = new Array(J > 1 ? J - 1 : 0), Ce = 1; Ce < J; Ce++)
          ce[Ce - 1] = arguments[Ce];
        x("error", R, ce);
      }
    }
    function x(R, J, ce) {
      {
        var Ce = g.ReactDebugCurrentFrame, Ze = Ce.getStackAddendum();
        Ze !== "" && (J += "%s", ce = ce.concat([Ze]));
        var st = ce.map(function(We) {
          return String(We);
        });
        st.unshift("Warning: " + J), Function.prototype.apply.call(console[R], console, st);
      }
    }
    var b = !1, T = !1, S = !1, w = !1, A = !1, E;
    E = Symbol.for("react.module.reference");
    function M(R) {
      return !!(typeof R == "string" || typeof R == "function" || R === n || R === a || A || R === s || R === c || R === h || w || R === f || b || T || S || typeof R == "object" && R !== null && (R.$$typeof === p || R.$$typeof === d || R.$$typeof === o || R.$$typeof === l || R.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      R.$$typeof === E || R.getModuleId !== void 0));
    }
    function N(R, J, ce) {
      var Ce = R.displayName;
      if (Ce)
        return Ce;
      var Ze = J.displayName || J.name || "";
      return Ze !== "" ? ce + "(" + Ze + ")" : ce;
    }
    function k(R) {
      return R.displayName || "Context";
    }
    function U(R) {
      if (R == null)
        return null;
      if (typeof R.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof R == "function")
        return R.displayName || R.name || null;
      if (typeof R == "string")
        return R;
      switch (R) {
        case n:
          return "Fragment";
        case i:
          return "Portal";
        case a:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case l:
            var J = R;
            return k(J) + ".Consumer";
          case o:
            var ce = R;
            return k(ce._context) + ".Provider";
          case u:
            return N(R, R.render, "ForwardRef");
          case d:
            var Ce = R.displayName || null;
            return Ce !== null ? Ce : U(R.type) || "Memo";
          case p: {
            var Ze = R, st = Ze._payload, We = Ze._init;
            try {
              return U(We(st));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var C = Object.assign, O = 0, D, H, j, K, L, B, Q;
    function W() {
    }
    W.__reactDisabledLog = !0;
    function z() {
      {
        if (O === 0) {
          D = console.log, H = console.info, j = console.warn, K = console.error, L = console.group, B = console.groupCollapsed, Q = console.groupEnd;
          var R = {
            configurable: !0,
            enumerable: !0,
            value: W,
            writable: !0
          };
          Object.defineProperties(console, {
            info: R,
            log: R,
            warn: R,
            error: R,
            group: R,
            groupCollapsed: R,
            groupEnd: R
          });
        }
        O++;
      }
    }
    function X() {
      {
        if (O--, O === 0) {
          var R = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: C({}, R, {
              value: D
            }),
            info: C({}, R, {
              value: H
            }),
            warn: C({}, R, {
              value: j
            }),
            error: C({}, R, {
              value: K
            }),
            group: C({}, R, {
              value: L
            }),
            groupCollapsed: C({}, R, {
              value: B
            }),
            groupEnd: C({}, R, {
              value: Q
            })
          });
        }
        O < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ae = g.ReactCurrentDispatcher, ue;
    function ge(R, J, ce) {
      {
        if (ue === void 0)
          try {
            throw Error();
          } catch (Ze) {
            var Ce = Ze.stack.trim().match(/\n( *(at )?)/);
            ue = Ce && Ce[1] || "";
          }
        return `
` + ue + R;
      }
    }
    var we = !1, Ne;
    {
      var lt = typeof WeakMap == "function" ? WeakMap : Map;
      Ne = new lt();
    }
    function be(R, J) {
      if (!R || we)
        return "";
      {
        var ce = Ne.get(R);
        if (ce !== void 0)
          return ce;
      }
      var Ce;
      we = !0;
      var Ze = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var st;
      st = ae.current, ae.current = null, z();
      try {
        if (J) {
          var We = function() {
            throw Error();
          };
          if (Object.defineProperty(We.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(We, []);
            } catch (Re) {
              Ce = Re;
            }
            Reflect.construct(R, [], We);
          } else {
            try {
              We.call();
            } catch (Re) {
              Ce = Re;
            }
            R.call(We.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Re) {
            Ce = Re;
          }
          R();
        }
      } catch (Re) {
        if (Re && Ce && typeof Re.stack == "string") {
          for (var Ge = Re.stack.split(`
`), I = Ce.stack.split(`
`), G = Ge.length - 1, te = I.length - 1; G >= 1 && te >= 0 && Ge[G] !== I[te]; )
            te--;
          for (; G >= 1 && te >= 0; G--, te--)
            if (Ge[G] !== I[te]) {
              if (G !== 1 || te !== 1)
                do
                  if (G--, te--, te < 0 || Ge[G] !== I[te]) {
                    var se = `
` + Ge[G].replace(" at new ", " at ");
                    return R.displayName && se.includes("<anonymous>") && (se = se.replace("<anonymous>", R.displayName)), typeof R == "function" && Ne.set(R, se), se;
                  }
                while (G >= 1 && te >= 0);
              break;
            }
        }
      } finally {
        we = !1, ae.current = st, X(), Error.prepareStackTrace = Ze;
      }
      var Z = R ? R.displayName || R.name : "", Ee = Z ? ge(Z) : "";
      return typeof R == "function" && Ne.set(R, Ee), Ee;
    }
    function bt(R, J, ce) {
      return be(R, !1);
    }
    function Y(R) {
      var J = R.prototype;
      return !!(J && J.isReactComponent);
    }
    function Gt(R, J, ce) {
      if (R == null)
        return "";
      if (typeof R == "function")
        return be(R, Y(R));
      if (typeof R == "string")
        return ge(R);
      switch (R) {
        case c:
          return ge("Suspense");
        case h:
          return ge("SuspenseList");
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case u:
            return bt(R.render);
          case d:
            return Gt(R.type, J, ce);
          case p: {
            var Ce = R, Ze = Ce._payload, st = Ce._init;
            try {
              return Gt(st(Ze), J, ce);
            } catch {
            }
          }
        }
      return "";
    }
    var Xe = Object.prototype.hasOwnProperty, yt = {}, rt = g.ReactDebugCurrentFrame;
    function Nt(R) {
      if (R) {
        var J = R._owner, ce = Gt(R.type, R._source, J ? J.type : null);
        rt.setExtraStackFrame(ce);
      } else
        rt.setExtraStackFrame(null);
    }
    function nt(R, J, ce, Ce, Ze) {
      {
        var st = Function.call.bind(Xe);
        for (var We in R)
          if (st(R, We)) {
            var Ge = void 0;
            try {
              if (typeof R[We] != "function") {
                var I = Error((Ce || "React class") + ": " + ce + " type `" + We + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof R[We] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw I.name = "Invariant Violation", I;
              }
              Ge = R[We](J, We, Ce, ce, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (G) {
              Ge = G;
            }
            Ge && !(Ge instanceof Error) && (Nt(Ze), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ce || "React class", ce, We, typeof Ge), Nt(null)), Ge instanceof Error && !(Ge.message in yt) && (yt[Ge.message] = !0, Nt(Ze), _("Failed %s type: %s", ce, Ge.message), Nt(null));
          }
      }
    }
    var F = Array.isArray;
    function P(R) {
      return F(R);
    }
    function le(R) {
      {
        var J = typeof Symbol == "function" && Symbol.toStringTag, ce = J && R[Symbol.toStringTag] || R.constructor.name || "Object";
        return ce;
      }
    }
    function Te(R) {
      try {
        return Ae(R), !1;
      } catch {
        return !0;
      }
    }
    function Ae(R) {
      return "" + R;
    }
    function xe(R) {
      if (Te(R))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", le(R)), Ae(R);
    }
    var Je = g.ReactCurrentOwner, Be = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, qe, Pt;
    function Ie(R) {
      if (Xe.call(R, "ref")) {
        var J = Object.getOwnPropertyDescriptor(R, "ref").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return R.ref !== void 0;
    }
    function $e(R) {
      if (Xe.call(R, "key")) {
        var J = Object.getOwnPropertyDescriptor(R, "key").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return R.key !== void 0;
    }
    function ut(R, J) {
      typeof R.ref == "string" && Je.current;
    }
    function ft(R, J) {
      {
        var ce = function() {
          qe || (qe = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "key", {
          get: ce,
          configurable: !0
        });
      }
    }
    function Ye(R, J) {
      {
        var ce = function() {
          Pt || (Pt = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "ref", {
          get: ce,
          configurable: !0
        });
      }
    }
    var Ot = function(R, J, ce, Ce, Ze, st, We) {
      var Ge = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: R,
        key: J,
        ref: ce,
        props: We,
        // Record the component responsible for creating this element.
        _owner: st
      };
      return Ge._store = {}, Object.defineProperty(Ge._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ge, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ce
      }), Object.defineProperty(Ge, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ze
      }), Object.freeze && (Object.freeze(Ge.props), Object.freeze(Ge)), Ge;
    };
    function xt(R, J, ce, Ce, Ze) {
      {
        var st, We = {}, Ge = null, I = null;
        ce !== void 0 && (xe(ce), Ge = "" + ce), $e(J) && (xe(J.key), Ge = "" + J.key), Ie(J) && (I = J.ref, ut(J, Ze));
        for (st in J)
          Xe.call(J, st) && !Be.hasOwnProperty(st) && (We[st] = J[st]);
        if (R && R.defaultProps) {
          var G = R.defaultProps;
          for (st in G)
            We[st] === void 0 && (We[st] = G[st]);
        }
        if (Ge || I) {
          var te = typeof R == "function" ? R.displayName || R.name || "Unknown" : R;
          Ge && ft(We, te), I && Ye(We, te);
        }
        return Ot(R, Ge, I, Ze, Ce, Je.current, We);
      }
    }
    var Bt = g.ReactCurrentOwner, ee = g.ReactDebugCurrentFrame;
    function Le(R) {
      if (R) {
        var J = R._owner, ce = Gt(R.type, R._source, J ? J.type : null);
        ee.setExtraStackFrame(ce);
      } else
        ee.setExtraStackFrame(null);
    }
    var de;
    de = !1;
    function Se(R) {
      return typeof R == "object" && R !== null && R.$$typeof === e;
    }
    function ze() {
      {
        if (Bt.current) {
          var R = U(Bt.current.type);
          if (R)
            return `

Check the render method of \`` + R + "`.";
        }
        return "";
      }
    }
    function ke(R) {
      return "";
    }
    var At = {};
    function ri(R) {
      {
        var J = ze();
        if (!J) {
          var ce = typeof R == "string" ? R : R.displayName || R.name;
          ce && (J = `

Check the top-level render call using <` + ce + ">.");
        }
        return J;
      }
    }
    function _i(R, J) {
      {
        if (!R._store || R._store.validated || R.key != null)
          return;
        R._store.validated = !0;
        var ce = ri(J);
        if (At[ce])
          return;
        At[ce] = !0;
        var Ce = "";
        R && R._owner && R._owner !== Bt.current && (Ce = " It was passed a child from " + U(R._owner.type) + "."), Le(R), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ce, Ce), Le(null);
      }
    }
    function Ft(R, J) {
      {
        if (typeof R != "object")
          return;
        if (P(R))
          for (var ce = 0; ce < R.length; ce++) {
            var Ce = R[ce];
            Se(Ce) && _i(Ce, J);
          }
        else if (Se(R))
          R._store && (R._store.validated = !0);
        else if (R) {
          var Ze = y(R);
          if (typeof Ze == "function" && Ze !== R.entries)
            for (var st = Ze.call(R), We; !(We = st.next()).done; )
              Se(We.value) && _i(We.value, J);
        }
      }
    }
    function vr(R) {
      {
        var J = R.type;
        if (J == null || typeof J == "string")
          return;
        var ce;
        if (typeof J == "function")
          ce = J.propTypes;
        else if (typeof J == "object" && (J.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        J.$$typeof === d))
          ce = J.propTypes;
        else
          return;
        if (ce) {
          var Ce = U(J);
          nt(ce, R.props, "prop", Ce, R);
        } else if (J.PropTypes !== void 0 && !de) {
          de = !0;
          var Ze = U(J);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ze || "Unknown");
        }
        typeof J.getDefaultProps == "function" && !J.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function $r(R) {
      {
        for (var J = Object.keys(R.props), ce = 0; ce < J.length; ce++) {
          var Ce = J[ce];
          if (Ce !== "children" && Ce !== "key") {
            Le(R), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ce), Le(null);
            break;
          }
        }
        R.ref !== null && (Le(R), _("Invalid attribute `ref` supplied to `React.Fragment`."), Le(null));
      }
    }
    var Ca = {};
    function Ra(R, J, ce, Ce, Ze, st) {
      {
        var We = M(R);
        if (!We) {
          var Ge = "";
          (R === void 0 || typeof R == "object" && R !== null && Object.keys(R).length === 0) && (Ge += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var I = ke();
          I ? Ge += I : Ge += ze();
          var G;
          R === null ? G = "null" : P(R) ? G = "array" : R !== void 0 && R.$$typeof === e ? (G = "<" + (U(R.type) || "Unknown") + " />", Ge = " Did you accidentally export a JSX literal instead of a component?") : G = typeof R, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", G, Ge);
        }
        var te = xt(R, J, ce, Ze, st);
        if (te == null)
          return te;
        if (We) {
          var se = J.children;
          if (se !== void 0)
            if (Ce)
              if (P(se)) {
                for (var Z = 0; Z < se.length; Z++)
                  Ft(se[Z], R);
                Object.freeze && Object.freeze(se);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ft(se, R);
        }
        if (Xe.call(J, "key")) {
          var Ee = U(R), Re = Object.keys(J).filter(function(gt) {
            return gt !== "key";
          }), Ke = Re.length > 0 ? "{key: someKey, " + Re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Ca[Ee + Ke]) {
            var tt = Re.length > 0 ? "{" + Re.join(": ..., ") + ": ...}" : "{}";
            _(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ke, Ee, tt, Ee), Ca[Ee + Ke] = !0;
          }
        }
        return R === n ? $r(te) : vr(te), te;
      }
    }
    function Mn(R, J, ce) {
      return Ra(R, J, ce, !0);
    }
    function Mo(R, J, ce) {
      return Ra(R, J, ce, !1);
    }
    var Ul = Mo, kl = Mn;
    Yc.Fragment = n, Yc.jsx = Ul, Yc.jsxs = kl;
  }()), Yc;
}
process.env.NODE_ENV === "production" ? R0.exports = w3() : R0.exports = E3();
var V = R0.exports;
const p2 = "data:image/svg+xml,%3csvg%20width='300'%20height='50'%20viewBox='0%200%20500%2084'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20width='500'%20height='84'%20fill='url(%23pattern0_10_2)'/%3e%3cdefs%3e%3cpattern%20id='pattern0_10_2'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_10_2'%20transform='scale(0.002%200.0119048)'/%3e%3c/pattern%3e%3cimage%20id='image0_10_2'%20width='500'%20height='84'%20preserveAspectRatio='none'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABUCAYAAAB0vcXQAAAAAXNSR0IArs4c6QAAIABJREFUeF7tXQeYJFW5vfdWro4zw2wgioCoJEUMwDOsGEAFFR/6RFEREAH1IUpQQaIEFcWEiiAGVIKib0URFFBEfQbQJ+CCgODCssvuhE5VXfm+PjVVQ01vz0x3T/eE3arvQ2S6wr3/Def+6fyULPC1YcOGjKZpewiC8JwgCPZkjD07CIIVlNICISRPCMG/JUJImVJa4ZzXov//YBAED3iet0bTtPtVVX2MUore8AXuUvr5VAKpBFIJpBJYaAkADjpGg64eWuieTn4/RMD5vsrl8m6CILyRc/56wsl/EEoEQkhXbclms8S2beL7/oZ6vf6rTCbzy2q1euuyZcs2RO/seEh7Io+lPS96IoIt9SWLeWgXc9u21PmwNPqVzoylMU5za2VXINrNJyuVyrMppScSQt5KCFk+zTtcQsjDhJDHCSElQgg08rLImOdzDk09RwjJEkKWEUKeTQgZEASBQDN3HIcwxggAvlarBZIk/da27Svuv//+H++///4WpXRhgL0bYaXPpBJIJZBKIJVAKoEOJdBXQOecy4Zh/GcQBO8jhLxcEAROOKEBD2LT+AOc819QSv9IKV2TyWTWUEoB6m1d1Wp1med5z1UUZR/XdV8tCMIrGGMZ3/eJ53kEYC8IwngQBN+2bfvr22yzDb5HU3BvS7zpTakEUgmkEghNp6k2tDQmQl8AnXPODMN4G2PsfELILgBYzAhBFIDkd/i+f4PnebcMDAw81ksxcc4Vy7IO9DzvMELIkZIkDQdBwD3PA4jjoHC14zjnDw0NPbFVA3u6Qns57dJ3TfFttTe52rsrFW1/JJBKvz9yXfi39hzQa7XaqznnFxPC9+WchOZwTdVGOeFXm6Z5RaFQeKhVtzdt2pTLZDLPIYQ8k3P+TELIDoQQJTKzi5xzh1I6TiktE0I2BEHwD8YYAuIeb6VxP/TQQ8qKFSveFATBcYyxgxhjOGTSIAjqlmV9yXXdc1euXFlPtfWFn4RpCxa/BBYvBCzels06qku46bP2Lb1hQSTQM0Avl8uDjLEvEkLeEVloKOd8I6X0vGw2eyUhBIA8abnZuHFjVtO0QxhjLyOEHEgI2ZsQwjoNjvN9v+L7/p2MsdsEQbgtm83e26x912q1vSilnyKEHCpJEszx9+i6/oI77rhDXLVqlTdXyafrcq4STJ9PJZBKIJVAKoG5SqAngF6r1V7LOb8qCILt0CDGWKWhWV+azWY/Rwg3KA21YwKfer1eP6yRavY2SunrCCE6Atmmv0KletqfgyD0xYe+crwn8p0/LEkSDhDf13X98SS4V6vVV8iyfKrrul/MZrO3wDVAKZ14SXqlEkglsMQkkB6ll9iApc3tswTmBOgAaNu2P+e67kmKohDDMACs/2NZ1vHLli2Ddh4C+djYWIEx9n7G2AcppTHo96RrUe755Ls47PwTl885/7nv+58qFAp/BLAzSjlv2gOq1eqwIAhfC4IAloT/26p96z0ZkS3kJYsSKxa4UQvw+QX45BYygdNubI0S6BrQOecF0zSv9X3/YKSMqapq+L5/WqFQuDwGRZDGKIpyKmX0I5TQDCLTAMAza+WdDcNmgB7AcT/lHdDAb23cd46u6yGwxwcNBNHZtn1BEAQfJYSMEkJO0nX9ulRz72wM0rtTCcwsgRSW0xmSSmA+JNAVoI+Pjz+DMXaTJEl7oJGyJP/JcZ0jdF1fi/8GaG7cuPFwxtjndF3fMdmRGTTqrvrb7vtgWuecX+O67smFQqEEUOecC7Ztn8A5/1Kk2duO45xXLBYvxG+UUr+rRs36ULrBzSqi9IYF5UXa8sW/BNbgEmjilj9PllYP2wP0xMSqVqugab0d5C6+73NBEG7UNO2dlFIbWL5hw4Zl+Xz+SsbYoa7rclEUN/tGwiwO8J9RYhGoIvCtEGnOUzT8DgA9/A6ldF2DrObDuq7fEGvrlmW9LgiC6wkhGdd1EST3tUKh8MFegXq6LpfWokhbm0oglUAqgaUogfYAPepZvV7fyfO83wmCAD84kPhyTdM+FAeWIWXN87zvSpIEJrfQvN58wdwOf3u1WiW5XA6sbrgFh4E/U0p/Rwj5P9/3/8UYezSXy21MPj86OpoXBGFIFMXdGWNIcXs+53wVIWT7yIwOtXvGcdA0jZTLZV/TtKtWr1594hFHHAEbfLBx48bnZbPZnzRy1XdCRH6Dhe4Luq6f1itQX4qTI21zswTSo1k6J1IJpBJYvBJoG9BHRka203X9TkrpMwOwtXB+Rjab/UxsYq9Wqx9paLifCdngpglNjwEeLG6O4xiiKK5uAPN1uVzuFkqp1Y2YoGU7jrN7EARv5py/mxCye5w2F78vBnlExeP/4x+krzmO8wdZlo/QNO1JHAg2bNiwcz6f/xVy4aM0u0s1Tft4CurdjEz6TCqBVAKpBFIJzKcE2gJ05Jjruv5by7KeyzkPBEH4VCaT+WQE5uKGDRs+VywWEcHOgyCY7Z3ws3++Xq9/c2hoqNpLVkGAe71eP4Axdirn/I0T7vwwrn3StA8gB7BblkWgrQtUeNxyrNcjfx33VSqV3ZHPTgjZjlJaJ4Scoev6F1NQn2ZapkrrfK7X9FupBFIJpBKYVgKzgS+AkNm2/UPHcd4MwBYE4Yu6rp8cgaRcq9WuURTlCPjLZyGFGSGEfELX9asIIUG/Gdocx3keUtE454fiEIJ+oM2u64bsdbIsh8Cuqiqqta13HOcNxWLxHtyDOAEQ1QRBsFwQhDHP896Yz+fv6k30e6cIGN3f6WPppE8lMC8SSCfmvIg5ZVSfHzEv8a/MCOjQbqvV6oc555dCyaWM3pjP5f8TfQbL2gEHHHBlEAQwc4eacNJ/DV85gNO2bT+fz39t7dq1Z+24445hdPl8yQxtMk3zjZTSLxNCto0APfTtx4CONkeuAJRbfaOu63/CfeVy+SXw6cuyjAPNg47jvHCbbbYxQjnMYx/mS1bpd7ZGCfQKjHv1nq1xDNI+b7kSmP91MSOgR6D2W865SAh5NAiCfQcGBkrQVGu12qWe552squqkZh4DOv4d5Zo/6TjOewuFAljZFqzKWalUGpAk6TJK6btgHYgoZjebR5zzfzuO8woUjYGJ3TTNoxtEON/ww+oy5Ke5XA5+epFSOme62C13Eqc9SyWQSiCVwGYSCNENezFjDKWv4drcidKQnwRlsaEQViilcMM+Rjh/SNW0+yilYdR0erUngWkBnXOeaZQ+vS8IgmegoIkkSQdmMpm/ApgrlcpJmqZ9SZIkblnWlHfAhA2zdr1e/61hGIevXLlydDFotADoer2OeuyXRaLZjHMWB5Eg8P9qGOZLV6xYYYBvXlXVy2VZPooQUmtYG84qFAqXzbc/vdNzHudcN03zlYj+B2Ne5AoJXxMVtMEhbU60t/fdd5+84447vkiW5X0453bDvcFAwYsrNNdQqvi+/0Qmk/lJ94e5mXsev9c0zR0YY6+PDl7hQ4IgiEEQoJDPbyMK4Fn7G7+vUqlgwwE1MZ4X4n61t6R6ehcOy4wxhnKBd6mq+uBs43bOOeewc845JxgdHd1eUZSXc87zeD6ymIXvqtfrvykUCg/P9q5OehLLrlarreCcv5wxNgQPVyKZXhIE4Zeqqj7U5XfDcUX/zjjjjNfatr1rIzDXUlUVQAAXXoYx9ntZlv88e7spmXgk5KLI1uv1VzPGtvN9H9k2s7ohZ39/d3f4vo9GyaIoPqiq6u/aDRSO5Wnb9uGc822xHqPOId5JHR0d/eOKFSvu6R+vRuv+xnOxVqs9jzH2XyhxTSndBwuqVQZU01swNmD7vJtzfhvn/Lv5fP6B7iTb/VOJef0aSukzpnsTCodpmnZjv2UMZlPG2JswT5P7EmLCKKU/bDl50YlarXYeIeTMaHP+YC6X+wo6MzIy8iJFUe4KgkDM5XIUL8KFAUL0OnLTGWM/yuVy72wuyNK9WHv3pGVZr25YGlaDD6dZU58A9AB9+Vk2m30DvooNShTFO0VB3K1m1NbWarV9t9tuu/HFaHpPbqqMse8TQpDSB0CfQNqJcbpC07TjQdtLKUV6XkdX/A0ARaVSuViWZRDzuJxzKcEAGFptMMkrlcopy5Yt+9Zf/vIXab/99tus1n2nh5VkY+ODlWVZB3POb/Y8zxcEgWEOSpLEgiBYyxh7n6qqsBDNalmJi/VUKpVjRFG8EhtjVPEvdst0JKse3Bxbv1AV8ERN074FOUelgFu+Pu5nuVx+ra7rV3qeh0NdXK+Acc7rmqYdSyn9/nRj0k27E7I7kFJ6FWMM2SaYezg4A6iEIAiOymaz17QzFhO4+rR3Lp53aPNuu+22WlXVgz3P83Bwi9JM5Qbz40Wapn3i6TPl9O69GATr9fozOOc3CIKwH+ZPEARCksmyDeDpRlyTzzS5KXFwE13Xva7BXIk9d1M7h+F4LVuWdTeldN84Zgjr0nVdKZvNXvjkk09esMMOO9Tbed+cOjQhfHbDDTeIr3zlK4+UZRnxVnvLskxh6OxEnvF+HGctNep//Mn3/cvy+fwPZ1oDc21/qz2mWq3eyBhDHFkr7pTY6ntoJpO5aWKj7WW499MtMgzjhZyQ/6UTB/1QnpATlGjP8/ZpCejlcnk3Qsh9jYkgG4bxx3w+/xK8EuYSURTv4ZyDKW4SyOPPAfwJId/KZDLvnY+JM+1paRZZ1uv1l4LnHcVhpgF1qwF2H89ms5/H0NRqtYMymcwvy+WyA6DM5/NHt7cp9XJqzf6uhQD0fD5/Qr1edz3Pk0RRTC7YcJIHQfBX0zTfMDw8/GSXmtm0HY8BfXR09OBMJnOz67q+KIoMAZqqquLfay3Let/Q0FBHgF6v148RBAFgOAnos0u/L3fMCdBxKGn0Y3ts8FHrmOd59SAIji0UCn0F9Gw2u3u9XofRBBtPoOu6UKlUjioUCm0C+lR5JgF9r732Wi3L8sGWZXlQLHAw1TRNrlarF+Xz+Y4B3XXdGxob8X6I9/F9fzNA79PeHHYwCeiiKIaAXq/XrzNN84MrV67sCNBN07y7kQocAjrk7vu+m81mpWq1emG5XO47oCcOSdj/z0EJ7BiUY/DpdJUkQD0Ul67riIt6pGFN+ditt95641vf+tY+sXlOtDTeYwDogiC8eYb2Y61uaGjpe1NKEQDelwuATgDolIYAHAM6Dkuu624O6BgU0zRvcl33kIaGDl/x/sVi8S9YUIZhXNXwMx8dmW6nHAaik9f/aJoWdnoxmNlnkqhpmijZ+uvoLDWpwSYmEEhtXpHL5dagVjui83VdPyIIgk2lUumNQ0NDf+gYoPq5M0SUu5A7rArTaegNk9wVmUymJxp6uVy+uFAonGCaZgjoSAlsxdzXcNt8K5vN4hA0o3bZ6QpIAno2m70ZG3IUxMgzeobZjt01oEuidKXjOimgtzkosYY+NjZ2oCRJV80HoNfrdS86WHcN6KCxFgThhmw2u59lWf6E0j+5HXSkUbYpqim3NQO6wATRsq3rqtVqx4BuGMbdqqzs6wV+4HleCOi5XK7vgB7vgxs2bNgTAdBROezJAwusnq0UwHbk1QToRNd1YppmkM1m2fj4+K0o+lUsFh9t513d3BPvMZVK5UZRFGcDdPhwrlqzZs0JrayRU77fJRZ0DOgjIyMHybL8K1mWkVP+ZV3XP4SG1Ov1lwVB8Jtm0pbEBv47TdPgt3UXO5jHgjVNExH7NyTN0skFFgTBXblc7qW4v1qtPldTtb+7novVfqemaS/vpcmym8nW/Eyzhk4pXQU/VNLk3ktAh8kdGjoAHaY9ZA40AXqoYQqCMMI5P1lRlO/10rKRBPRcLnczNmRFUZhlWRwL3rKsmQG9aVHFoNSJhh6fkKcxxU07rLGcZmE2XHIa+qICdEZ5wmrfDKRhTEUM6Llcbj9YFJoBvbmQVKvxwj2Rq64llXUrM3Pze/DfgiAg1kF0HGcaQG+NArHJvVqt3q3r+r6e54WA7nmem8/n+wro8RrctGnTkaqqfqmR1jyYFHRzPzsxuTdbMPDfiqyQag1xc4TDtaYoSo1zflQ+n4cbtedXM6DPss4RswC31iGqqv6i540hBBVNO9PQy+XyzfBP+b5fdhxn52KxOI4JY5omcrTDYizJK+rgJvhudF1/oh+d6Nc7oTFalgUSmk9NgDoVnrZOhl81HMc5aWBg4Nucc81xnNNQtc3zvBHHcd5WLBZv71hL71dnWmjojLFVQRAsJKAD4AP4s13XvbtUKr1uxYoVG3slszkDetNYJAGdMXZlFCSlzDRkmP/YzKHVxUyE7WxaKaB3linSyuTeCw0dPvTY5I4DIUzuSQ29HUDH/YgfSgI7TKDxe2YD9Bj0ouDH0Ideq9U61tA7A/QuVcTEYogP57Va7dOiKJ6M/bTVQaUZL6JgyTWEkH8QQtYhsj0IAsT0aBGh13M8z3suBgJyTI4BfMUIvMZag8yjIDSBc35cLpf7ZkxD3qtttkNADy3TjuMAB59XKBTGetWO+D0dAXqtVtuLMfZ3xhg0g0sbJVEBdmBfOwkVyaZpHMxeh2az2b6cSHotkBZabb5er/+UEPKyViltvu8/cPPNN+8JXw247CmliDTGxF2t6zrS2HpqRp5Lf5sijb8vy/JmgB4EQc9M7m1o6OFJmjEWchRwzq/UNO24bmXWvAX1GtDj9zXiRg4RBOEizvmTQRBI041JvNFgY1EUBUE/iPZHENreyX0vChAE6+CaRnAbXDl4ZxjxhY1phgvZAogIRkzHF9sJ7ksGxS2ED31Raegz8EXEh0q4pxqgcJYois/zPK+GbA2MRzy2Sd9vkkI6jiKnlO4niuKAbdsIxAQNNZixmSiKjzLGUJMCAzzpnmw2IcdjH5mlfUTr+77/C9d1vzw4OFhuJxYp1tDL5fLd2Wx2XjT0eJ4ZhoFg6eNjK+A0h9l4kv8MMVaapv0ySk/bbOonMk1Qs+OVnPNjRVE8yLbt8KDVrCFH6ydWWj6QzWa/1stI81aAPuOCnZgkmB5fVVUVdU56muLcDOhxW1r60E3TvIYQ8o4G3SlC13eDxo2a4fV6HSku2Kg2w0Pf96/O5/PHTJ14cz/9zQXY2n92op22bT/H9/2/hZOSEiE200FIQRDYkiR9Utf1T8OXLsvyhaqqfoBzDiKaV0SpRH3PsW9HoklAD4Lg+6qqropSuSadggsA6CGoR3mmALMPRTXnZ406n20cew3os31vloUc9qdaraJs8I8ScZlh6hmlFBv88aqq/rKXbocWB9SwHYhyTwG9PyRWEZ00DlqeaZq3y5K8yqybcPcInuc5uq7LlmVd8Mgjj5y/5557Ou2A8hznXpixUiqV7s7lcn0H9Hj+joyMnK9p2qlxJgj60AToMZD/oHGw+aSqqv/qpJ+x3EZHR587MDBwvmEYb2SMPR3gMPVAHIP6W3O5HNyoPbm6APTwnB6t+YM0TUNl0p5dk4DOKEu6k1oCumEYb2qkGv13o8jJo3Gkummax4BcZZoWbWyYh56Tz+fH5+43bweyeiaXKS/CBK3X6x9tTMyLmtO8wPduGMZD2Wz2WXhobGxsb0VR/k8URQsap6qqKLM6Z3DqRc+aAV3X9FWu504xufcS0Gu12sXZbLalDz3BwBfB+cQkD4LgT4899tghe+yxx9hspvfZZsRSAXSEeWNNpYDe2yj3uZjc57LemgEdB+darearqhoCOiLuOwH02eb5bG2NNfTx8fG7G77kvgJ6vObK5TJKZn+ZUlqILLqhFSIC9DiN65+NctXHNWKr7pytD7MclsN4B6Sn+r7/1YaWP10+eBjxTik9UNf1P7b7zZnk3yWgx/mW/7Zt+/kgY2u3LbPd15GGHr8s7kRExoJk/l1bfAj86CdmMpmv9/sEOlsne/F7tVpdJgjCXyIylnBe4H8cx4E51ajVascODw9fi9Q9ALksy4cLgvCIqqoguEgBfSIoboIOkPN/c87/jzF2WOKAFGrpCJyrVqtfKxaLJ4CcBhpMt+O3KAA92g3iOZDU0CfCF2iYE+/7/qOc8+Oz2WyqoXexXnrtQ+92zuG5dgDdNM0LHn300XnV0PsN6EnSIkmSfpPL5Z5pmuaUGh6xT9v3/Rsx3/P5fE9SuCKZY+8YFEXxes45ArCbr7A4mCAID3ie99K5fzskIIIlxo+j3BMWiNjq+GtUIEWKHhZ7HByZCB7/gqZpH+mVG6ArQI+lVK1WXyEIwh0RiUpzzvq/VVXdZT4Krcxl8bX7LCbr6aef/i7O+dVRup6Y9Jl5nvebgYGBVyCyfeedd37z4ODgda7rbqpWq+8cGhq6dTZts912zOW+djR0PwiuyPYoba2Fhh5omsYQk+D7/scFQbg38iHBTIb5EyA/3LKsDZZlIdgQi77rw9CiAPRowFoBekSkgUhcBAWmgN7jPPRuNPS5asPNgN7I/rk91tA1VRNcz3VUVZUrlcoFjz/++BYF6HHsi2EYq4MgOLQ5YBCHd/ANVKvVq2zb/vDw8HC118oe1jzGoFwug4sAbI5TLrgYZVlGMN1n1q1bd9Zuu+2G1NOOr3iezKChx5U8f8YYu5wQ8kPf9xHUl7xAqISYjP/Qdf134Q9znICtAD2Oy2iZhx63BgNhmuY3KKXHhO2gU/AcDf1vVVW/3OsB61jyPXwgotX7Kwq5RBGrYaejwIuNkiT9B6grx8bGdmwUpXlUEAQwn10xMDDwobkA0/Rd6Gz02wH0zk3urRm7wBTXAtB9TdMEwzRvzWYyrzVN8zMNLma4MqCFg5kvFCdA3ff9Pzz66KMH77rrrtVzzz2Xgq6006FsBnTbsny5k7S1Tj84w/3x+I+Pjx8uy3LoQ4+icLmu6cyyLeTKphp6D4llugH0Xgx5UkOfAuiKJniB5yiKssUBerzWTNMEvSxcsEhPS2rnoWvP9/0fB0FwTJQd1ZfYIrQFe8Zpp52GNOoDmscUwfFIP6xWq3utWLHivrmM+WyAzjn/RaOg1+vq9fqXfd9/f0TVPAmjEW7+U9O0/XrBSz8zoE/DFIfWRHzg6yml+WZAB6WnoiioXgbO4HmrnjaXgZl4dmaAhAl4l112Oc0PgvMFxkIayERUJWgTP5nNZj+L+vCEkG/m8/k3mqa5JpPJoE78gke79wfQp0o9Sf3aDOiiJPkZXQdn/h26rr8SZWglSfpOwPm+NKKgrdfrXNO0kIfY87yv6Lr+gVlN79MMWysNHcQyjuOEeeiGYax1HKdtprju51domtssKA4aOo7xuVwOZE1LEtDbPVIuNWKZ7sd6qsl9Og29XKlc8MQWpKEntHNUo0Qu9BRNFEDGOX/IcZxXDQ4Oru2noheb30dGRlZkMhn4ymHuDpXOaL8OMw0459fCVYq6HN2O90yAjk+6rvvz0dHRt3iex1esWHE/YwxW68krwkcso4s1TTuzG9N7cg1OZ3KHlm7b9gRTXLVaBWe7Aw7zXC53P/5mGMbr8N8JHt3JUwch5GpN05oi27sV2eJ6zrKsXV3XfUiSJM/3fWzSk2QRKJCh6zpoYxXXdY8SBOEbrus+ZVkWaqmDTW/WAiD97O1CA7okSaHJDZucrusHoa+QDeccaYFIbwxN70jlgaxc133Stu33DQ8P/6wbC8fiAfRwk587oLeLnm1YCtIo9/5Vd5xWQ99CTe4J7fwIzvnXCSEDMS7g0CpJEiyVkm3brykWi7/s5x4Xv/v6668XolRiMFCiPDZovAnop23bRtqhp+u6uH79+uduu+22yHnv6moH0HO53OGUUrtWq72qkcYILvdJ7oqmIMGXtBWsN8M+0Bagl8vl9YSQFZIkfVfXdfiR6fj4+CW6riMPfYogOAh6PP+gXC4Hc8cWd3HOC9VqdbWiKC9DTimYfxKHmg3j4+N7bbvttiOVSmV3RVEesG27ZNv2GcPDwwgODAMoFkoorQDdcZ2+EcvEGnqtVnMFQZDgv8pms+Dsvq1QKLwKIPfYY4+JQ0NDZ+dyuTMqlQoOjTK0c1EUA4EJMEX/Znx8/JDtt98+rPLTicWnHUAPguB9Ufnern317Yxn66C4AO4ans/nQw09DYrrbZQ7uNw9zxMFQeiY+rWdMZ3unukAHSlVMa/8YvGhg/q1VqvNics9jqI3TRNVz6YEo6GgDdL1KKXfrtVqHxoaGqr0UztPjkm85iqVyl2NSn4HxnnqcHXBnw8OB8/zPpfL5T7WTSEqvCTeY0ql0o2SJIXFWaIrdDd4nvdzlNWO31+pVL4my/Jx8J0joLqJRvh+VVVfRCk1u51/MaAna5DEhEahhl4qlXaRZflhfMBxnBOLxeJXoT1VKpU/KoqyXzOge543msvltmlv0HqgcnTb8y6fwySpVCof1DTtc7Ztx9Wcwrdxzsu+778zn8/fZBgGXA5/C4JgIAiCbxQKhRPxLKPUmzgCzX/fJ8aE8VqtugJ56EhbmxHQGXWmo8acaTOLyk5O+tCTgA4N3XXd21RVfdWTTz6pb7vttmalUnmWIAjX6rr+fNM0w4WGVJcoIh7z7rP5fP7UWU3vTY1KAX3zUZqWWGbC29n34iybEct4PmNC/4qzpIAe7kthHnqrKPe5AnpsdYzWMHKqt4sVnCi2yBVFUWpUsNwX5bW73Ha7eixuW7lcfp0kSdcxxrIRgVW4XUf/bNQ07TmU0VKne12ngI72rF+/Xi0UCn8XRTE0vcOCkTwANIrmnJfNZs+dYLTrHCOSgB4HMDQD+ltkWf5hBOgvKBaLqKaWN02zFEUxTomGa5wCflwsFhEY0ZeAh65GtscPjY+PPz+Tydxj23Y4WROvBw3UZzKZzJmVSmXI87zv5XP517qeCx77/+gUkHrc7DCdJi7O0hagz7F8arOGjtN6LpeDyf02XdehoatxnAUWnaqqcOGEpnekl8D0HuVow+fWdpnTyRUSWURQbS3mckeKGPxZ8KHXarW1862hR0FDk8QyqPxWKBRSDb1P1dYWG6BDLwKxzJaiocdZq3WfAAAgAElEQVQHxFKpdFqj+BIqqGmxXxjWSKxlz/MQ9f6efgbCTbdXxvU0fNe/16ibe4rilMI6UNVF3/dflc1mb+tmv51NQ4cPPZ/Phxp6vP9Wq9VXMsZ+LoqikgD08HwA/nnf918MF2037Wmloce005Zl7QNa1zMdxzkf0cf5fD4Hc4BpmjAL/DEqh5oEdG7b9n8PDAx8qW1A7/wQ0k0/e/JMYkCWaar2QN2qF0RRRA8mSBMYJb7n35LJZA4Ga1yj3vAnBgcGT3c9d+0ll1yy89lnnw3zPDTQBQkUXMyA/uijj6rDw8PnqIp6uh/4DrJL4OuC6T2TySCV7XZN0+IKfziZzCrDVhp6CugTvvytwYe+GE3uWyCgxyx0N0uSdHBTthPKSaPOx9sHBwev7ckm3OFL4j2gWq2eBUXLtm05YVUOrYG2bV9aKBQ+3o3ZvRNAjzT6MI6qVCp9nVJ6LPajZJcAvo7j/K1UKh2A+vQddneyOEvS5D4F0CuVyncIIQjwAjvcMwEKhmG8UxTF77TgmQZbz8sHBwfv6rQhS+n+0dHRPOhJKaUHJ/jdQwtHEAQP6rr+bJi5KpXKEblc7hrHcdY7jrMqn88/GJMvLER/FwugW5Z1m6ZpoYYOHvLYNGZZ1rMopZDr81AFDoUwoopJ4EHHYfHTxWLxjHYtHSmgd2Byn7h1/k3ufa6Hnmro/TO5x7EC5557bvChD33oHwMDA7ujkmHCn4hUU8+27T2KxeIjbSt5Pdwc429GDJ6/EUWxmDRz43dFVv53vDT+GuTFd/rp2QCdc/5z1PRIHhZi0/vAwMDfBUHYBQVlEKxnWVaY9YK6Dw1r5lnZbPbCTovJzKqhVyqVOwRBeAWlNEw1igD9U6IofiyuHpUQQuD7/rJcLjfWjgbVqfAWy/2PP/64tnLlys+g0hpjLA4qiwF93U033bQTIiwty3qVLMu/bMQebISpdXBw8HcLGem+WAE9OrmG7oBKpXKoIAiroUVGla3w95Aq0vf9xzzPQw7r7XEa1ExzIgX0RQzomezudauOQxu8KgFiKyo9JpZJNfSJ8e+XDz3ey0ql0n6SJP2PKIqIG8JJHBbL0NzeIE35VRAER+ZyuU0LAehR/8OUYcMwHmOMoYDWZNEj3/c9TdUFs24M5/P50U4xpktAD/e6Uqn0almWf0opVSRRIo47ESQXFfJBsa8XDA4O/r2TNs0K6MijJoQ8mxDyA13Xj8QgVqvVb8qy/O4WgD6WyWSGFmrgOun4lHs7NPvDb7Rx48b/Hh4e/qzjOKEfJllgxLbtA3AiXbdu3fNXrlx5j+M4I6ihPTAwsDpOp+i6rW0+2KpLSwHQYXpfuXLlOYqinO44Tmh6b0rt+KWqqjC9h0EtMx0cU0DvDNA5Dk2eVw+C4NhCofD92P/Y5pSb8bZZ89A1XahUt/wo98Vucg84p6wNd1YElGHWjmmab3Uc56uodS6KYlxNDLEwKPV6SS6XQ5BXx+bjXsy7qJ2hm6lULv1YkZU3xeVs8Zvv+66malLdqu+Ry+VQrrWjqxtAj9oUmt4bwdNX+L5/LA5BoL2O0+oa8QgA9r888cQTB3ZCfz0roBuGsYkQgqj1L2SzWdS0RTDRjyRJelMzoKN0aGRu3gIC4mZG+dHR0bcV8oVrPT/MgQgBHYDJGButVquv32abbRBj8AwU3bAsa9y27Y8ODAx8cyFT1xYzoCcnOUzvhBBEpYamdxD4JOI1YAW6MJfLnTWb6T0F9M4APTW5d7SXT3vzTGlrMaCXKpUL1i0CYpm5RLnHAXGWZaGi2jmSJOkIOPU8D/ugSylFqupxuq5f1RuLbYeaVzRCCdC9RBCEU2RZDmm7gV8TGromVqqVwwYHB8GH0dHVLaDH+93dd9+t7rrrrv+QZXknpNOhTYqiEATLwvQuMvFUJrJL25VfO4BeI4RkGtScF2YymU9EgH6bJEmvaOFD/5Ou6y9echp6R0M4cXO5XH490tOQupYEdLDkua77ZuThm6a5g+/7axljtcYJ7Nx8Pv/ZdkzF0zenuwkdv2+xA3o0ycPD4NjY2KGZTGY1fHAA9JjrPTLz/ct13ffk8/nfznRA6j2gdy//ePNLo9zHDpQk6apsNrt7vZ6a3OezfGqv09ZidjjTNC/mnJ8C8hhkPgGYkPuPgDjP8w7OZrO3dLHFTvtIp6sw3gfK5fJJoih+VhRFFdgVFUoJq+CBMS6Xy13dqc96joAe7nXIwpEkCdzzSO9L9pvDSskY2wfxV+3IcFZAr1arYPmBBnoOTCeRyf1/ZVl+YQtAj9ORtgANfWbxlUqlgwqFwq+QuoaJDA0dqVacc5TCOzKTydxsmub2vu8/EqViXZDP5y/qhvGsnYFs556lBOiIDWlUajq7kdb2McZYyPWOU7VpmsHQ0BCsRLdeeumlh5x9Nm5pbXrvJaB3uok0j0cK6HeIq1at8jbLQ0996PNWD71fgG4YxhcJISdFNb6hXcJ0bGuapjTW6QH5fP4P7exP/bonkY/+TlmWEV2ux9gFl0EE6B/KZrOXd0r8NRdAb7JKXmnb9nslSZqSNYYsKtd1f7dmzZpV++23H7BmxmtWQK9UKsdFdJx/ymazf4s09DslSTqwBaDfqev6y7cGDX18fPzlxWLx10lAR7+DIAC5zLsadYdXxxo6IaTWOPmB5/3zc9PQZxvOmX9fCoDeNMl355zfEATBXgg+hKaOaHdMelhGcrncBYIgnDud6X1isTF/dHSkZR56tVZby+eZKS7V0FMNHXnoi4XLfS4m93jdwQ9MCAFOhFzpAHRJkkJAL5VK+w4MDPx1ITEhBnTTNN8CxjpYnIFdsCYAwMFkZxjGGZlMBqbtkEau3WuugB5bJR988MHstttue68oijslvw0XBkDd9/3/zmazX2plem/F5T5t2loLTSPUjiRJOqgFoP9Z1/UXLeTgtTsQc72vUqm8IZfL/bTZ5B4EwXgQBG/J5XJ3mKa5o+/7/4aF3vf9j0UsewtG/7pUAD1pejcMAzXTEUEbRr1H/smwIlsjffLhRsGHdxQKhT+1Mr33UkOf63xJNfQeaugtzCXx3EYg35577bVakeWD0yj3iVnbxyj3OHocXOknxCACk3sM6JVK5SWFQgEFUhbsigG9Xq+/g3OOw0fI6w6LX6yhV6vVk/P5/JfnW0NP7nVPPfXUa3K5HLjeJ8nKIl8/r9frKLs7q+l9Vg29eRSQR33qqaf+BPVu8VuSi5YQ8kAjP/s5WwGg03K5fGQ+n7+mGdBd1x21bfvg4eHhv4yPj+9ULBYfq9Vq457npUFxEVNccx56q5UezyHOuVatVs/XNf0jjuvAPBmWWVVVNfA8j9m2vRpV7aIUGZTtnSScSfjODs7omZuRJgUiB2j5uq6nTHGieKUgCNs3qgTGjrulmYdO4e+aYEEEoO+1117wRy4AoE+cNNoJitsSmOISPvRPN1yNJwdBEAIRQEiSpNCH7rpu1yxsvToBxPuAYRjHU0o/TynVYgrYIAh81KmvGbXjCoXCN+fTh57sX7zfGYaBAMKjGUMQ/EThr8jXj9vvUFX1NTNZEToGdHy4XC5fpSjK0fHgJRpm6LoOvtwt2ocOs/n+++9/kqIolzUDuiAIm+r1+oGFQuEhy7LCAi2NogRjrut+YHBw8AdbXZR7JnNCzTCmFGdpB9CjuRWmdlSr1eeKongd53zPOL8VmzcmPefcbvC+n60oyiXNpvctD9Dn6sl/uupbkiku4DwI38w5Djt9TVurVCoHUko3C4rTNA31qY8q9LAeeqqh91dDj9Maa7Uaipuc5fs+gDJcl6iwhih3UL5qmgYz94JdCUA/v5E+dzraFbPFxVHu1Vr1LQMDAzd22shemNzjbwI3YXpfsWLFvbqu7xQxZU7+HBGXnaDrOuIAWjJldgXotVrtzAYbxHlg3EHeXOJCStHKbDa7qd0w+04FuBjuh9ZYqVQ+qygKCq6E9IFxHnq9Xn8SBW123nlna3R09DWDg4O31Gq1jZ7nvXVgYOA3cyOWmduGvhAm90wmc4LRJaAnzVEjIyOH5/P5HzHKPNux4bagoIUVRRFVi9ZUKpV3LFu2DL66SZfGlgfoc5/9yeIsjLErZVkONfTIfbYggC4IAlwobQD69PM/aXJfOA19EkDRUMxDL1kPHdXWFnseeifKWBwPVKvV3hEEwZcFQSiiemAjroUKghBn/5wry/JFKB8699nb3RviOV+r1b7PGPuvuOgT3pYA9OcPDAz8rdMvzAbolNKfq6o6hSluum/Esi+Xy4dQSuFmhEtjsjx3hDEmpXRPTdMea/UeAHoQBP8Ltqb49ynUr7VaDb5yfCCXy+WOj5jiQDBzDZLfm/zoMIO+AulEnQpmKd0/NjZWyGazNzDKXu16Lsy8k8LjnD+A6j2gNa3VakcjctI0zXX1ev3FQ0NDT6KfC3XYgSI2UW2t1l61tR4UZ9F1/QTTNEMNHYcfaGK2bU+hfp1p7ONJjspsy5cvP58xdoplWa7neWGKDMBAURSQHd2Yz+ffkjS9p4C+uWRnAnQcNoMg6LuGLoriVZqmTaatRWOI1KEJDT3gImUdByctApP71gXoMUkWrC6SJN2gKMpKwzBiQA8ZNBljq+v1+nvBwtbJYaGXeJBwDSD1C/TSkyCJ+rq6pot1qw6GU3CudHT1EtCTCsy6deu+OTg4+J7IfTOlTZzzW3Vdf10rf/+sgF6pVD4my/KF9Xqdj4yMFHfbbbfK6OjoSzRN+wOS35vD7B3HOb1YLH5moQZvsudzU2ZbDmrcp2q1Oqyp2n1+4G+DVLW4OEs0IDfpun4oKtI1ZHa27/unMMYey2QyO8cTq60ZM5f2T/NsJxp6wLnM5gjotm1fLAriCXWr3jWgRzINTe+2bT8XXO9BEOzpum4Y9Q5mKpj4CCF1zvmZuq5/Lja9twJ0aPQLXW2NEDKl2hrqodfr9UcZY8erqvrLfqY2JgGdUnqlqqrbQz3HPAZblWEYnq7rx+bz+W93NF+bJnXzFEzUg18lSdKViqI807Ks8LsYW1mSBcu2jspms9d00//pNHTXdcN66GFkebl8UbFY/ERMAtWvg/VmPnRFXVUzauC4ndTQt4Qo96if9KmnntIYY38dHh7eDTiBAYVsAZyU0hHDMF40MDDw2EJgQgyI9Xp9B0opyrcORntKyASG+aer+t9LldJLUau9rb05cVO8x1QqlRtFUZxSDz3q7+Ya+ix7e2x632677e4jhOyYULbDpkd4c0zDLI+8+Smm9xjQ4wDFSOkJFe+w2trY2NjrFEX5Gf5gmuaBy5cv/z3nXK9UKuMSVPSo0ljcR9/3f4KC7gsxeJ0ORrf3G4YB7uI/gzYwGZFICHE555fpun5auVwelCTpakVRDjNN8w+5XO6A2ZjNum1Pu891AuhxZGy7747vSwSz5QHojLETkNoHDR0WLqSIOI7Ttobe/F6kfTHGftQAbxyuoQGEZVajCXw/TGqKotwXaephFGu5XJ4MiltUgE4JcR2XLwSg12q1VwVBAEDfKQZ0RCdnMhlqWdaJmUzmq3MB9OZ5E4M0uPobmtzXBSasdFwniOdLNC5H6rqOOJOQqrOtuRdtjosa0FV1Va2WAHRNlyvVygWPd8QU1/0Jv19R7hifhx56SNltt91szvntKEAVB5tFYO4ITJAN0zikUCj8oq3x7OVNE8GSoQvO9/2TbNv+LKVUTVRbC8szW5Z1eaFQOKUbt0BXgD5LHxOm99cSQn4mJmu+RkYgQojR2Af3aja9zwroIyMj2ymK8kRUJP3EXC6HhQ4T512SJO0fCicx13zfH8lmsytQhaxfJ+Bejnmn78JmU6/XTxZF8TPwv0SbT/gaznm5QfX67kwm8z+GYayklP5JUZRtDdO4Jp/Lv7uX3Nidtjtpztnc5I4YgImDHtI6MpkMXCthWcTZvzN1o+k3oOMwaRjGBaIofrhRnjZ5oApPro3KTjcUi8W3YlzQ9qhU6OIEdJwA3XkH9HCDq1QqL+WcX5nRM8/yA9/H4QjzGeZHyujHBEG4uJcH0PhwALO6JEmXB0GA4NmQ0Rc+V/AMeJ73Nl3XcVhrH9CjCbqkAH3e6qFPRt2Ha7nXxDLRfhGmrm3cuPF8SZJO0zQNWSjhWmSMxfXGr6xWqx9etmxZbb4VvXjPrVQqqLT2stjcjnmH9iEUp16vHz4wMPDj2fe6KVAX75fxempfQ2/jQ7GcKpXKtymlR8WKc1Jb55zflMlkDkvibLlcfmGjCuj/xm7gzTR0fBt87r7vb0MI+XY+nw/t+q7rfsbzvI80t822bZiWXl8oFLqj++v+INqGmOZ+C+e8UK/X/0dgwssDHkDDgDk4Lkiw3jTN5wwODpYNw3g+pfQe3/dLnPPT8/n8FQsZ4T4zoBOYArsE9KkybQZ0SukJjuOEGjqARBIlwfXcjjX0qP2TUe/gepckaU/45eGrwyYCDukgCIxGyszHdV3/YlyeddFq6AsI6JifnucB0PeNAT0IAheBOJzzr+i6/gHM7dkK4LS7ouIDYr1eP7MRRHo+rAJRVS4uyzLjnCO188hsNvuLbsiXthRAb739zW1T7KeGHgf5btq0ab9MJvNTxhiUuRjQQ6u27/uB67rPLRQK4I3oLgOqCxHEpao3bdq0r6Iot6uqWoAVKtpL0EZY9mxd13eklHZcaS16T18APd6vCSGFWq12LyFke/wtAeihuwCV7AqFwg/iddgWoJdKJQQ8/CfnfKOu68vx8FNPPfVqTdNuFQQhtumH70SUIyHkqlwud1zXg9fuLrEA99m2/Rzf9/+B012sBcbNoJT+TlXV/0AUfBAE76OUXua67nrUiEca20LLYyFM7r0E9OShZHx8/HBoc0EQYIWGXO+R6ZiJongvY+ytSBnEM7Va7WBRFG+Oa3V25UPvYkNJTs8kscwC+9DDQxFoiV3XBaC/1g+gHHsiNHRFUUTTNG8qFovHUEo3zi0rY/KQmIz6/gal9FhYV5C3jDFBhLtt22sEQXhPI9inJUnQbEt9SwH02frZze/9BHS0JxGz8kfLsl6U8POGFrIgCGAtu1jTNFRds7rpQzfPJNw8P5Jl+fCwbKrvT5RpjCOEOf8WAne7bVc/TO4J5WqypLQkST9GzFDMcBdjre/7Y6g3v3z58qfwtxjQYx86ItynRLnjpvHx8aNVVUWlMOI4zguKxeI9mCRI0eKcDzULm1JaMgxjx2222QaUpy3z5boZoIV+BhN3l112Oa0xiMhnjDXDuFmYqOc16A4vgv9cFMVv6rr+xtHR0Xu32WabvbvxR84RQzYT15YE6DC927Z9QWMOTzG9J6qyXavr+tt7BuhznHyLCNAnNaRSqXRlNpM9xg/8MGsAByJBEJC6tk6SJKz5ngToxZveyMjIszOZzNWEkJcgngIHMdd1QzO/WTdvFkXx/bqur+3mELFVAXqHG0O/AT2e2yMjIydkMplPE0KyCVDHksRYwwoDLf6vSRftHJfVtI/HcwhZWqIoIgi1EGdkRQxxobmdc/5iHCK7bUc/AT2pwNTr9e8EQfBOaOVJLd11XZrP528477zz/uucc84J2gL0arW6TBTF9RBSo/73mcVi8VNYQJZlXYHayc3CQJCS4zgfKRQKly20VtrtQLV6DnJolI0Fnz3MSriSRPo4Ib1Y07R/m6a5neM4DzHGRFSW0jTthG78gt20faa1viUAejTJJ03vjLEbGGPPjQEiAejVRs4vTO9fRiCWLMur56ShdzMYiWcWC6BH8gv9nqVS6YxsJnsRNHTf98WoSpYnorKGbX8in89f2It5Gx9mK5XKsZIkgSZUiTd813WdTCYjG4ZxaT6f/2hyE+tE5FsVoHcimD5SvyY1SRzObrjhBn7ooYf+nRCC9Zi03MbKz69d1z0in8+PdIILHZ5fwmYBaO+//35h1113vYcQskccrBeB+UT+Lue3GYbx5uHhYewVXV39BvR4PTz22GOF7bff/l7HcULTe3xBYQbXO2PsCFEUf1gqlfZjjIFqN0ylbqmh44d6vf5nnLAIIX/XdX0f/K1arb6SMXZb0+CFdn7XdR/J5XK7bynBcRi4SqXyflmWsSHFpAlJ2f5S07TXQIvfYYcd3pbP57/DOR91HOe9qqqujnM2u5o1PXpoSwH05KZvmuZbGWOonR6WWY3SCMOod0rpfVbdeqkkSy8QRfFXSxLQu9nNZpkvidS1gxtpa1dyzreDdg4qXUEQfEVWBLNu/r4RDHusoihr5hL7EfsxEc9g2zZS0t6SWD/cdd2QVKZer7+rUCh8t9sDRAro0w96vzX0aD2GgYzIkGi4HC+Blt5gcMT5GmyOuCXcMymln1EU5ewGY1t98xb3ZrLHc2j9+vXXDgwMvC2Oao//jXZG7tKX6rp+11y21/kA9Lh9hmEcQghBzfYw5im2OAC0HccZFUVxD8/zdmgL0E3TRGT35z3Pw2YJQSB9DXzYf2WM7Z04McT/F/edrOv6lzo5jc1FuP18tlarLaeU/rmRuxufkELtXNM0UiqVEIh1Qjab/W6lUhmilF6fzWZfOT4+/uDg4OCzu92ket2fLRHQN2zYkCkWixdJkvRBFyHjnMeFDeJAxUtN0/xJoVD4rWGavhTloWeyWWbUamsR64AAzn6P0SLT0EMLR6lUGtAA6IQcHsUihJkBYPmCT73BAnmOoigomdx1QaFYOx8bGztBUZQvwmqVUADCNEbbtv/i+/4x2Wz2791+a94AvQ3MQVvaY4p74vw999xj3sqnjo2P313I5/fFHo7Dm+d57lyqrTXvT3FEuWEYd+m6HlbjdJynE2UApDBz+76PaPjLYCXqwx4XztVyufxlRVHej3FIpKmFOBiZ/7+naRrinMy5tGG+AD2e36Zp4tD7jtg63ETs9r0gCLDGfh+Dfssod3T40UcfLW6zzTbrwNfLGEO0+9GR2f3oIAiuagHo+NOm9evX7/bMZz6zspR96diUIrrbTzb7zmGm9DwvBG50eGx8bK+B4sDfDcMwfN//fKFQOCsJFm3sB3OZXzM+uyUB+oRWEDBKGQhn9ooIZ8DQNxn1Hk36hx3HuUfTtNc3MjMy0Bq6Coqb06iAmSoINRjk0S9kUFzcjRhoLcuCO+jyUJWi4RkV/xPn9YPd67iGRe7H3Rx4EsQ+LwTNbCaT2RtZMPFmg1QqSqncCKQ9W9O08yIg7IpJcd4AvY150D6gP37+nnvuOW+A3o+0taQ4Yr+14zgvNE1ztaqqKxIusLC0ahwk1zhQnJfNZkEJ27MguWi+cZRzdRznPcjfnqBKmaysNpEnScg4IWS/6ehT2xjiyVvmC9CjPtBSqVQQRfE+xth2SS090ebzG8kzIE8KTe7TAjp+rFQq3yGEHKUoirFhw4Yddtppp3FEdNdqtX9F6QrhoCUubBJX4iTUfy29f1BZrVb3IIQgchq87VPI60VRBFXmqaqqfgXaoizLZw0MDJxeq9UQcwAa3H920/d+9GZLA/R4kuOwWK1W3yYIwrURIUkY9R4v5KhgRPgvzE9oKNlsdsGqrS0SQJ+MdscaJYSAxCLpSgqB13Gch3VdP0aSpDs7SSeLXUylUmlnWZavliUZaZ7wesQpkuH7KaVrGkyK75Fluavo9sQBpSX166Jgimsmlpm3PPQJ6cyHyT0xDuHBtVKpfLxxuD5LlmU1tshEgA5Tcch7EATBTz3PO3FoaOiJTkC0+d54X1u/fv0zMpnMtzzPezksp7Ish7XZE1fMG3KYqqowXc/5mk9AjxtbqVQOEwQBhWTCqPemKz6Mh3+eDdAPlGX5rojeL6RRhDBN0zyGEPINvKAJ0DGZfNu23zQ4OIg6r0vuAm87AqoopS+L4gEmedvRGUmS/vmpT33qOYgwtCxrV8dx7ofWkc1mb6WUvrab6PZ+CWlLBnQcpvL5PE78H0R6N4Ym4TObKEHIWIjyKaBPzLBEtayjKKXfEARBSWpUmO9RkYcNlUrlw8PDw9e2E4Eeb3Ku677M87zLVVXdA77ySqXCsNFGBZ1Csz6l9COg623nvVPWRdOJN9XQp9815hPQowNECOqGYXybMfau+GAdAzrWJaxkWJOc8zFVVc99/PHHrwDjXKd7H+bNr3/9a3nPPfc8qVGs6ZOKouTjXPNcLkdQsSy6QqroRq2C0zOZzOfaZiKcpUHtAzpzYvKuTvuYvD+e55VK5buCIISm9xagPvnIjICOu0ql0q9lWX657/s1y7KeNTw8DE1Usizr7iAI9trsuBAEGLwnZVneT9f1DUvJ9A5aw+XLl58jCMIZcRR104HFqFarxy9fvvx7GzduzEqSdGGxWPygZVkjoigeIUnSrzveqOYy2rNPvlCLma/iLKB+7XUeeqsuJlJU9hIE4XpCCNwfoQYYRbVO1hRuR0Pvk3VkUZnco012wsY+YeH4vKIoJyMXHcFLsZwTAA9T5Q8aVqqzVFX9VyurUzwOqHXQMKWeQSmFjzKZwoTqVkRRlPDA1eB0QEnck6LCHaHFoNvpv7QAXZMrlWqH1K/dSmZ+NfTEvArHs16v39SwvrwOwBqnW8U1vjEXMPfAFOi67kOCIFzNGPuOruvrZuptPNaWZe3SKIb1X5xz1DnfYZq9Afjjy7Ii+L73JdBy98HMD+bFnjLFzdZ/RL0PDQ3d1ziIh6b36a5ZAX18fPxliqL8BoQylNIvyLL8YbwMpUJ1Xb8lIpaZtLvjhZIoEddz/zIyMvKy7bff3poJ1PuxmXa7FEZHR5EKcL0oikm/3+TrfN+/JZfLHRz1fw/4NmRZhqZ+88DAwBsWmuq1ud/NGrqqqqsw2WOfZrQYO6R+nfqV+BsoTjMF0EVBomRuTHEzTvKAU8ooN03zbZTSayPzMQAdh5jNAD2TyTDDMBY8KA6aSi6Xm7fiLC3mRLjx4pAniuIVhBAUFpoE9URAURxk6HPOUWbyds75w0EQlKHJc7Bb0nwAABCXSURBVM5znPNnSJIESlnkmYem1lD40RUdrnwBYbmE/M3zvPciL7nbQLhWmgvWXLJ8ampynwrouWwOzIBhUBxqUWSzWcQHXVguly/YYYcdUOCoOya3pokVxRGwc889lx9//PHXDwwMvEUUROBAeCfmAgAdU6F5jhFC/kEIgQsG1dE2MMYQuIZEjFwEYLtSSl/aYC7dOXatTU6zKTRnIbWyr2u6UK1VL4VFuRu+9lnANcEUJ7054XGOwlLaL5+62XdmAcNKpfJGzvmNyVKpze8A/ka07bBW7DPFIR4NBMjsb/I8DyH0lmVZzxseHn4QA1gul78uSdJxyTS2BKAjze3Hy5YtO7xXk6ZboG7nuVKp9BpBEG5GEFUS8BL70yZBEHC4eQDaeaFQ+IrjOO+SJGnj2NjYIdtuuy3Id+akdbTTzk7uSQI65/z7jYPZvAA6omkppSh36ouCKDiuc1sjXeRVMTVrJ32Y7t7EQSJbr9dhev9AVCwnrCkcmtwngnLCnaERhLWoAN2yrEcppX2vtjaNFhNuSrC4BUEAJje4l8KDXiy32NKRLD0Zb8RJk19TZagpLjgcHJD/6/v+Y/Cba5r2m16AebQvbeZDt23bcxxn4autLSIf+nwBeuIQF84tWIBEUTwpWcyqOZ2sk33g6X14etTDdxs0w4JhGB8dHBz8Qq/M7E0Hyb5Rv85ykAjne7VaRY33t89kdoeLC7+3BHR8BNy4siz/WZIkZtv2XcViEaT3OJHkGlG8IBZ4RrIxSF1AgIKu6wisu64RKHZkrziiO5kE7d6LwhWCINzCGINPEcmUk49GEwk5lGdEfOEoVPP6XC63GnW/GyQn12ua9s62o4Ln0STRDOiyLK9ClFK/NHTXdS/mnJ8wH4AeHzajMqt7+b4/aXrHom4GdFVVmWma/dHQW4zpdGlrvu9zWAts254fQJ9mvsWHz3q9vhMh5GuEEFieQr9jrElNKNZP57+2A+gA+Oi+cJ4pinJ/rVZ7b6FQmFMQXAtLw6IEdMuybsfBOa62hsh+FDCpVDqtttbu7rX5fUkfeiaT2Re0p9DQwd0PDb1cLl9YrVZ7qqE/vWE+XfHM87y3eJ6HGgvbxvMoeUCM/9Z8KGzV8+ZYraZ7Yj19bePw+J5cLndH99Kb+cn2fejtFLrqrJXYz6vV6iD4NhprNiY72+wlWLdYw67rbq6hx6fher2O0pinVatVrmnaKdls9jL8BjCklN4RBAHL6BnquE54So9P+AhYkCTpJw3CirdBg1psPnWYMQRBuA4aZcQmNEVAUYWo67LZbEgrCk5smIdEUVzped6/gyB4SSaTCXl1p+vbPGJ4c9snfejQ0AHoiDiNS41Gbb5C07QOqq1NnT/NJncAOni7EWcB0pJ+aegJjSA+uU5GvUf9S1qbUH+b1a16fwC9xbpsBeiRL5Hrug4GxvkB9Bn2jMTYabZtgyXuZByEkN4PP6eiKOHGkNQGmjWD5s0Y2oFpmr6macg3v85xnFOGh4dBGd1T61XSh/6sZz1rNVxh0NAjAhEkQ6MK2EWaps1rPXTP9W4nhKyyncl0vbA2e6lUumDdunXzmraGOCfG2PwCejTf4pREQkjRtu1PEUKOBZd/xE4Y3oWIdIDPxBxqsp3PgnUJgEccBv65zDCM8+bCAtcOvC4koMftq1arSIW9IU5VizA6/BlyiU3u0wJ69AC4tP8qy/KzKpVKzXXdFwwPD4cpWtVq9RhZlr8hSRJ3HGdqHtvT2u6fG7z+/wnu5nYE1+97MDD1ev0E3/e/BOBJaq3Jb7uu+7exsbH9d955Zwum9lwu93XG2JEonep53knZbPZ7vTIj9rrPzRq6JEmoXzwF0JHD2Qh07Amg12q1UEMXRXHeAR1jgzxXQRA+0KJufYD627ZtLzigY+dSZIW5nrvggJ44FMUpbQcSQj7ted4BiJkBqEeRyZNTcxZABwsc5PwAKg42tMPV0YM9P9P2B9C7a2YyDx2A7npueHBmjOFQ4xQKBbnhCrjgoYcemhbQu/ty6x0j1tA3btx4d6FQ2BeABw0dGKqqqmQYRs996NPtXYmAtmc1SpEj2PjtnuepOCjOrJnPDPCR8mRTSr/FOb+oJa70UqhPH1QWxOTeLF+Y3iHLxBqeBPQY4D3Pa62hxw+Zpnmg7/u/1VSN2o695sknn3zJbrvtVonqpV8ERiBVVaeMRBNrz8YgCN6Nkon98au3N4KIymWMXS4Iwn/Cv5o86TQJ7hFN0w6ilP4boF2tVt8ty/JVoB31PO+HKAbStqm912idfN/0ZtVQe0Uqnqqqx4ADPaopjsUdHrwcx7mzUChc00nOcfLT8Tg+/vjj2rJly94siuJrXdc1okNOIDIx53jO3bquf74XKX2tuhprf+VyeVfG2IdEUZzkDo/XoSAIsud5T/m+f00ul7u/1xpj8/DG70fZUsYYGKzCtB1ciqLIqMrHGPueoij/6Hdb2p168Vi6rnug67of9DwPZvhCssJiC0CP1zvcUncJgvDFhx9++NZ+E6jEbUX++2GHHXZSvV5/kaqq1Qi4EOQ3wDm/Pp/P/6Rfh4qEXOF/xFpD2dBTXNeFVlxF4ZswSEvX85s2bbp+zZo1P1+1atVEPc8+XvFaLpVKn9A0bXfOuRmVrsUhIxsEwY26rv+sH8xtswF7pVJBWW7sE9g794+CKTuRhkEIATPatbZj/2hwYBBBmvN2JTI73i+K4vOjfTQs6BbRT9+rKMpX++G/T3YSckRZ4hC7OD7OJzb0hIbemH/nbRYU17x5VyqVcxog+Mkw+E2SVqPCGO7BJDrggAOu9n3/nTPZT+BDlGX5GhRzyWazI52a4NuD7NbjC57p00477U0wzzRKvu4giii+M8E93LxRcc6fCILgtblcDhGYKFP3WkrpL2BSbORa/qvBjLTvwMAASP6xkreYCnPztjLm40MdTJYObp2Pli/oN5KHtEKhgOIP+zcyCZAauDwIgoGocVWUVxYE4Z9Icbdt5/eDgwPl/hzUF1Qc6cf7JIE77rhDffGLX7xfI3Ib1SkRyQ53ZoEQko+yVqAYlBhjj3POH6GU/p+qaXcz2nv/dJ+6uOCvnRHQ0bqoAhvK070JKWtBEFyYyWTOjH4TTNNEgM2xEcht9r6EqWUUJwxN05A6M2NqWy+kAk2pkSP7Wc75K+P0mmSIf1ydB9+CJsc5P7RQKMBNgPrazwuC4E5CSE4QhDFK6WG6rv9usWhWvZBP+o5UAqkEUgm0JYH09NuWmBbDTbMCegTcecuyfh8EwR4wWTfyWM8Ea1cM6rVa7XMwfTbnpUa/N/dzQ6PW9aeDIPguyuz1UggAXMuykKp1KmMMVJeT7oA4cC8iO5gMzmgQ4T/kuu5h+Xz+gUgz3xU5uBGRQVUURXBdX7cYqqn1Ulbpu1IJTCeBdP9O50YqgaUpgbYAHV0rlUq7MMZ+SwhZGUUZop7yxRFogx72+IYfC7mAYMufQjbRLJrI3G03yrWCLvZ7vu/fMTAwUOpYhDR0VFLX9fYG4UgQBEcIggC/KmeMTelbHCUZR/GiDb7v/8nzvEOXL1++CRaG9evX75HJZH5GCEFqj9Uo1XlusVhE4FfX1ag67lP6wAwS6DHU9Ph16dDNXQKLYUgWQxvmLsn0DVujBNoGdAinUqkg4OI38K0xxhDxc04ul4OjPrzK5fJLGqVWbxQEATlz4bubguTC+2L/deI3BI78JQiCuxhjawgha1zXBaF/eWhoqBK9R/7nP/+ZX7Zs2XaCIIBBCCQZCLI4UBAEBL1NUCBF/vHpCDDANW2apjc2Nvb1crl8yh577BGm1o2MjLxoYGDgZ4ZhIIgDZQC/ksvlTl4yYJ7uQlvj+k373BcJpIupL2JNX9p3CXQE6GhNtVpFCUsk8i8HXsuy/JMHH3zwqH322QfRiPh9mSAIl9m2/XYEoTVrytNo69N2NCa7iG+Ahp0Mq49z8JooBiff10xQ4Pv+esuy3jc8PHxTHNBTLpdfLEnS7b7v65qqOa7nXqJp2ieXDJj3fZosxQ8stk15sbVnKY5p2uZUAqkEZpJAx4CeAHUA4jOhEbuue3cmk3mTruuTZfJc1z2oXq9/DSbwuQxBi+puHb0u8Ty07m+WSqUzV6xYEfru42j1Rm72tg061z8ODQ0NBUHwcZDopGDekZh7cHMKeD0QYvqKVAKpBLZiCXQF6JBXqVQaUBTle5ZlHZLJZBApPo5SiZqmXZ1gpNINwziRUvrRSKPfTNSzUPzNOjStTPrJhwDalNJbkDOfzWbvbZVmg7+Zpvk83/dfkM/nr0yj2WcV+ww3pMA8F+kttWfT0V5qI7ZE25tOtLYGrmtAx9tBHFKtVi+WZfkU0EY2ctZRC/mnpmm+H/SPcQsaUe0A9hMopScTQpB7OHFxQujU2LW2Gp28KU6Liw8GCYB3KaPX8YB/Lqr4FLnYuWqa5qt93/9DFGWfTpWOpb40HkgHdmmM05bSynS+bSkjuXT7MSdAj7sdcc1eHgTBchRp4ZyPNwpeXfLII498ee+99zZj0zbM2IZhHEQIOZpSCoIaNVl+cVoxTrNSwBMMAIcfHQQwEQ/7Pb7v/wBlUXVdB0HBZLlAwzBe6Ps+ige8WJblr2madmJqWl+6kzdteSqBVAKpBFIJPC2BngA6XgcTvCRJn6WUvtdxnDAYznXdjYqiXJzJZC4H62iSYY1znjFNE1XcXtWgkMQ/e0zHrz7TgPm+/ySi40VRvLPBSX1roVB4qNmsDqKYBuif4/s+6suGbHGSJD1Uq9X2HR4eRi3elP1tK1wVqUa1dAe9p2PX05ctXZmmLV/6EugZoMeisCzr9ZzzS0BCI0kSMQyDaJoGJrarbdu+slgsPtJKbA3CfcUwjN0ZY8+JCtsPUErBz1yMABfpa14QBBsZY/8mhPyLc/6viKR/syUZuQMOkSQJhUhQ2x0XtHWHc/7VtWvXnrX77rvXUhrXpT+J0x6kEtgaJJCeO5b4KM/DAPYc0CHyiC72yIZJ/BxCyC4om4cLVc4YY0h5Q/nSW3tdiQ2ad71eh1n9aM75mwVBWI5CEw2CGGpZliOK4reDILi4WCziMDBpiu94mszDwHTcpj49sBV1tU8STF+bSiCVQFsSSDebtsQ00019AfT4gyjrZ1nW213XfR/n/ACUW03UzUU6+T8opTejjq8kSfdls9kH2q1ag/esXbu26HlesMsuu4QVeFABLJ/Pf1UUxXfj7yihGQRBSVEUpKt9ddmyZQ/PCcjnLO70BakEUgmkEkglsPVIYH5PKX0F9OSgVavVPRhjJzRA/K2EkOHI/h0WaMcF9rhGDrjDGHuYUrqRcz5KCEFBl1KjIIxMKdUJIVIjqG2wkU++oyiKuzqOgzq7nxwcHAQ9a/iier3+X5RS1I69pUGCc10QBNcvX758MjBv65lIaU9TCaQSSCWwdUpgfmG0lYwXpgXzBugJrZ0ahrE3pfQNCIjzff+lbOIKA96RhjbbFfGwE9Ri55xfq2nakXG0esN/r61bt25o++23B8nNwkh1tg6kv6cSSCWQSiCVwFYlgafBqH+wNO+A3jyCyFE3TXMPx3H2lCRpz6gO8yDnHJr4UKPgC4LjUCcXjviaKIp1z/PWIijOdd1/EULuKRaLv5rRlN4/+W1VEzLtbCqBVAKpBFIJLF4J/D/xclRhztyp5QAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", M3 = ({
  walletConnected: r,
  walletAddress: e,
  wagmiConfig: i,
  walletHooks: n,
  onClose: s,
  isOpen: a,
  onCreatePlayer: o
}) => {
  r && (e || r.account && r.account.address);
  const l = () => {
    o && o();
  };
  return /* @__PURE__ */ V.jsxs(
    "div",
    {
      style: {
        backgroundColor: "#101020",
        color: "#fff",
        padding: "20px",
        textAlign: "center",
        border: "4px solid #0078D4",
        borderRadius: "5px",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ V.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "0",
              left: "0",
              width: "100%",
              height: "4px",
              backgroundColor: "#0078D4"
            }
          }
        ),
        /* @__PURE__ */ V.jsx(
          "div",
          {
            style: {
              position: "absolute",
              bottom: "0",
              left: "0",
              width: "100%",
              height: "4px",
              backgroundColor: "#0078D4"
            }
          }
        ),
        /* @__PURE__ */ V.jsx(
          "img",
          {
            src: p2,
            alt: "Intuition Logo",
            style: { width: "200px", marginBottom: "10px", marginTop: "20px" }
          }
        ),
        /* @__PURE__ */ V.jsx(
          "h2",
          {
            style: {
              fontSize: "1.2em",
              margin: "0 0 20px 0",
              color: "#FFD32A"
              // Couleur orange pour le texte BOSS FIGHTERS
            },
            children: "BOSS FIGHTERS COMMUNITY PLAYER MAP"
          }
        ),
        /* @__PURE__ */ V.jsxs("div", { style: { maxWidth: "80%", margin: "0 auto" }, children: [
          /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "At first, there was nothing. And then, suddenly, the whole community appeared !" }),
          /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Everything of which the Boss Fighters community would one day be composed, would be born in an instant." }),
          /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "A single species of condensed matter, exploding in a vast universe." }),
          /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Although energy would neither be created nor destroyed, the interaction between these newly-created atoms would continue to create something beautiful..." }),
          /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "What had been separate would become whole again. And what would be created in the process would be even more beautiful than what came before..." }),
          /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Our story begins with the atom. The cornerstone of our ecosystem." }),
          /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: 'And our "atoms" start with you !' }),
          /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Every contribution will help build our ecosystem and make it healthy..." })
        ] }),
        /* @__PURE__ */ V.jsxs(
          "div",
          {
            style: {
              border: "1px solid #FFD32A",
              borderRadius: "10px",
              padding: "15px",
              margin: "20px 0",
              display: "inline-block",
              backgroundColor: "rgba(0, 0, 0, 0.3)",
              width: "80%",
              maxWidth: "700px"
            },
            children: [
              /* @__PURE__ */ V.jsx(
                "p",
                {
                  style: { fontSize: "0.9em", margin: "0 0 10px 0", textAlign: "left" },
                  children: 'Claims in Intuition, also referred to as "Triples" structured in Semantic Triple format :'
                }
              ),
              /* @__PURE__ */ V.jsx(
                "p",
                {
                  style: { fontSize: "0.9em", margin: "0 0 10px 0", textAlign: "left" },
                  children: "[Subject]  [Predicate]  [Object] (For example, a triple could be : [SciFi] [is] [strong Boss])"
                }
              ),
              /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.9em", margin: "0", textAlign: "left" }, children: "This keeps our attestations tidy !" })
            ]
          }
        ),
        /* @__PURE__ */ V.jsx(
          "button",
          {
            onClick: l,
            style: {
              marginTop: "20px",
              marginBottom: "20px",
              padding: "10px 20px",
              backgroundColor: "#FFD32A",
              color: "#000",
              border: "none",
              cursor: "pointer",
              borderRadius: "5px",
              fontSize: "1em",
              fontWeight: "bold"
            },
            children: "CREATE YOUR PLAYER"
          }
        )
      ]
    }
  );
};
function A3(r, e) {
  const i = r.exec(e);
  return i == null ? void 0 : i.groups;
}
const fS = /^tuple(?<array>(\[(\d*)\])*)$/;
function N0(r) {
  let e = r.type;
  if (fS.test(r.type) && "components" in r) {
    e = "(";
    const i = r.components.length;
    for (let s = 0; s < i; s++) {
      const a = r.components[s];
      e += N0(a), s < i - 1 && (e += ", ");
    }
    const n = A3(fS, r.type);
    return e += `)${(n == null ? void 0 : n.array) ?? ""}`, N0({
      ...r,
      type: e
    });
  }
  return "indexed" in r && r.indexed && (e = `${e} indexed`), r.name ? `${e} ${r.name}` : e;
}
function Kc(r) {
  let e = "";
  const i = r.length;
  for (let n = 0; n < i; n++) {
    const s = r[n];
    e += N0(s), n !== i - 1 && (e += ", ");
  }
  return e;
}
function C3(r) {
  var e;
  return r.type === "function" ? `function ${r.name}(${Kc(r.inputs)})${r.stateMutability && r.stateMutability !== "nonpayable" ? ` ${r.stateMutability}` : ""}${(e = r.outputs) != null && e.length ? ` returns (${Kc(r.outputs)})` : ""}` : r.type === "event" ? `event ${r.name}(${Kc(r.inputs)})` : r.type === "error" ? `error ${r.name}(${Kc(r.inputs)})` : r.type === "constructor" ? `constructor(${Kc(r.inputs)})${r.stateMutability === "payable" ? " payable" : ""}` : r.type === "fallback" ? `fallback() external${r.stateMutability === "payable" ? " payable" : ""}` : "receive() external payable";
}
function r_(r, { strict: e = !0 } = {}) {
  return !r || typeof r != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(r) : r.startsWith("0x");
}
function mS(r) {
  return r_(r, { strict: !1 }) ? Math.ceil((r.length - 2) / 2) : r.length;
}
const f2 = "2.37.5";
let Zc = {
  getDocsUrl: ({ docsBaseUrl: r, docsPath: e = "", docsSlug: i }) => e ? `${r ?? "https://viem.sh"}${e}${i ? `#${i}` : ""}` : void 0,
  version: `viem@${f2}`
};
class Sn extends Error {
  constructor(e, i = {}) {
    var l;
    const n = (() => {
      var u;
      return i.cause instanceof Sn ? i.cause.details : (u = i.cause) != null && u.message ? i.cause.message : i.details;
    })(), s = i.cause instanceof Sn && i.cause.docsPath || i.docsPath, a = (l = Zc.getDocsUrl) == null ? void 0 : l.call(Zc, { ...i, docsPath: s }), o = [
      e || "An error occurred.",
      "",
      ...i.metaMessages ? [...i.metaMessages, ""] : [],
      ...a ? [`Docs: ${a}`] : [],
      ...n ? [`Details: ${n}`] : [],
      ...Zc.version ? [`Version: ${Zc.version}`] : []
    ].join(`
`);
    super(o, i.cause ? { cause: i.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = n, this.docsPath = s, this.metaMessages = i.metaMessages, this.name = i.name ?? this.name, this.shortMessage = e, this.version = f2;
  }
  walk(e) {
    return m2(this, e);
  }
}
function m2(r, e) {
  return e != null && e(r) ? r : r && typeof r == "object" && "cause" in r && r.cause !== void 0 ? m2(r.cause, e) : e ? null : r;
}
class R3 extends Sn {
  constructor({ expectedLength: e, givenLength: i }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${i}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class N3 extends Sn {
  constructor({ expectedSize: e, givenSize: i }) {
    super(`Expected bytes${e}, got bytes${i}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class P3 extends Sn {
  constructor(e) {
    super(`Type "${e}" is not supported for packed encoding.`, {
      name: "UnsupportedPackedAbiType"
    });
  }
}
class g2 extends Sn {
  constructor({ size: e, targetSize: i, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${i}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
function la(r, { dir: e, size: i = 32 } = {}) {
  return typeof r == "string" ? I3(r, { dir: e, size: i }) : O3(r, { dir: e, size: i });
}
function I3(r, { dir: e, size: i = 32 } = {}) {
  if (i === null)
    return r;
  const n = r.replace("0x", "");
  if (n.length > i * 2)
    throw new g2({
      size: Math.ceil(n.length / 2),
      targetSize: i,
      type: "hex"
    });
  return `0x${n[e === "right" ? "padEnd" : "padStart"](i * 2, "0")}`;
}
function O3(r, { dir: e, size: i = 32 } = {}) {
  if (i === null)
    return r;
  if (r.length > i)
    throw new g2({
      size: r.length,
      targetSize: i,
      type: "bytes"
    });
  const n = new Uint8Array(i);
  for (let s = 0; s < i; s++) {
    const a = e === "right";
    n[a ? s : i - s - 1] = r[a ? s : r.length - s - 1];
  }
  return n;
}
class D3 extends Sn {
  constructor({ max: e, min: i, signed: n, size: s, value: a }) {
    super(`Number "${a}" is not in safe ${s ? `${s * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${i} to ${e})` : `(above ${i})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class L3 extends Sn {
  constructor({ givenSize: e, maxSize: i }) {
    super(`Size cannot exceed ${i} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function Ud(r, { size: e }) {
  if (mS(r) > e)
    throw new L3({
      givenSize: mS(r),
      maxSize: e
    });
}
const U3 = /* @__PURE__ */ Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function y2(r, e = {}) {
  return typeof r == "number" || typeof r == "bigint" ? n_(r, e) : typeof r == "string" ? x2(r, e) : typeof r == "boolean" ? v2(r, e) : b2(r, e);
}
function v2(r, e = {}) {
  const i = `0x${Number(r)}`;
  return typeof e.size == "number" ? (Ud(i, { size: e.size }), la(i, { size: e.size })) : i;
}
function b2(r, e = {}) {
  let i = "";
  for (let s = 0; s < r.length; s++)
    i += U3[r[s]];
  const n = `0x${i}`;
  return typeof e.size == "number" ? (Ud(n, { size: e.size }), la(n, { dir: "right", size: e.size })) : n;
}
function n_(r, e = {}) {
  const { signed: i, size: n } = e, s = BigInt(r);
  let a;
  n ? i ? a = (1n << BigInt(n) * 8n - 1n) - 1n : a = 2n ** (BigInt(n) * 8n) - 1n : typeof r == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof a == "bigint" && i ? -a - 1n : 0;
  if (a && s > a || s < o) {
    const u = typeof r == "bigint" ? "n" : "";
    throw new D3({
      max: a ? `${a}${u}` : void 0,
      min: `${o}${u}`,
      signed: i,
      size: n,
      value: `${r}${u}`
    });
  }
  const l = `0x${(i && s < 0 ? (1n << BigInt(n * 8)) + BigInt(s) : s).toString(16)}`;
  return n ? la(l, { size: n }) : l;
}
const k3 = /* @__PURE__ */ new TextEncoder();
function x2(r, e = {}) {
  const i = k3.encode(r);
  return b2(i, e);
}
const F3 = /* @__PURE__ */ new TextEncoder();
function _2(r, e = {}) {
  return typeof r == "number" || typeof r == "bigint" ? z3(r, e) : typeof r == "boolean" ? B3(r, e) : r_(r) ? T2(r, e) : S2(r, e);
}
function B3(r, e = {}) {
  const i = new Uint8Array(1);
  return i[0] = Number(r), typeof e.size == "number" ? (Ud(i, { size: e.size }), la(i, { size: e.size })) : i;
}
const As = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function gS(r) {
  if (r >= As.zero && r <= As.nine)
    return r - As.zero;
  if (r >= As.A && r <= As.F)
    return r - (As.A - 10);
  if (r >= As.a && r <= As.f)
    return r - (As.a - 10);
}
function T2(r, e = {}) {
  let i = r;
  e.size && (Ud(i, { size: e.size }), i = la(i, { dir: "right", size: e.size }));
  let n = i.slice(2);
  n.length % 2 && (n = `0${n}`);
  const s = n.length / 2, a = new Uint8Array(s);
  for (let o = 0, l = 0; o < s; o++) {
    const u = gS(n.charCodeAt(l++)), c = gS(n.charCodeAt(l++));
    if (u === void 0 || c === void 0)
      throw new Sn(`Invalid byte sequence ("${n[l - 2]}${n[l - 1]}" in "${n}").`);
    a[o] = u * 16 + c;
  }
  return a;
}
function z3(r, e) {
  const i = n_(r, e);
  return T2(i);
}
function S2(r, e = {}) {
  const i = F3.encode(r);
  return typeof e.size == "number" ? (Ud(i, { size: e.size }), la(i, { dir: "right", size: e.size })) : i;
}
const ap = /* @__PURE__ */ BigInt(2 ** 32 - 1), yS = /* @__PURE__ */ BigInt(32);
function j3(r, e = !1) {
  return e ? { h: Number(r & ap), l: Number(r >> yS & ap) } : { h: Number(r >> yS & ap) | 0, l: Number(r & ap) | 0 };
}
function V3(r, e = !1) {
  const i = r.length;
  let n = new Uint32Array(i), s = new Uint32Array(i);
  for (let a = 0; a < i; a++) {
    const { h: o, l } = j3(r[a], e);
    [n[a], s[a]] = [o, l];
  }
  return [n, s];
}
const G3 = (r, e, i) => r << i | e >>> 32 - i, H3 = (r, e, i) => e << i | r >>> 32 - i, W3 = (r, e, i) => e << i - 32 | r >>> 64 - i, q3 = (r, e, i) => r << i - 32 | e >>> 64 - i;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function X3(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function vS(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error("positive integer expected, got " + r);
}
function fm(r, ...e) {
  if (!X3(r))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function bS(r, e = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function $3(r, e) {
  fm(r);
  const i = e.outputLen;
  if (r.length < i)
    throw new Error("digestInto() expects output buffer of length at least " + i);
}
function Y3(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function w2(...r) {
  for (let e = 0; e < r.length; e++)
    r[e].fill(0);
}
const K3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Z3(r) {
  return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255;
}
function Q3(r) {
  for (let e = 0; e < r.length; e++)
    r[e] = Z3(r[e]);
  return r;
}
const xS = K3 ? (r) => r : Q3;
function J3(r) {
  if (typeof r != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function E2(r) {
  return typeof r == "string" && (r = J3(r)), fm(r), r;
}
class eD {
}
function tD(r) {
  const e = (n) => r().update(E2(n)).digest(), i = r();
  return e.outputLen = i.outputLen, e.blockLen = i.blockLen, e.create = () => r(), e;
}
const iD = BigInt(0), Qc = BigInt(1), rD = BigInt(2), nD = BigInt(7), sD = BigInt(256), aD = BigInt(113), M2 = [], A2 = [], C2 = [];
for (let r = 0, e = Qc, i = 1, n = 0; r < 24; r++) {
  [i, n] = [n, (2 * i + 3 * n) % 5], M2.push(2 * (5 * n + i)), A2.push((r + 1) * (r + 2) / 2 % 64);
  let s = iD;
  for (let a = 0; a < 7; a++)
    e = (e << Qc ^ (e >> nD) * aD) % sD, e & rD && (s ^= Qc << (Qc << /* @__PURE__ */ BigInt(a)) - Qc);
  C2.push(s);
}
const R2 = V3(C2, !0), oD = R2[0], lD = R2[1], _S = (r, e, i) => i > 32 ? W3(r, e, i) : G3(r, e, i), TS = (r, e, i) => i > 32 ? q3(r, e, i) : H3(r, e, i);
function uD(r, e = 24) {
  const i = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      i[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const l = (o + 8) % 10, u = (o + 2) % 10, c = i[u], h = i[u + 1], d = _S(c, h, 1) ^ i[l], p = TS(c, h, 1) ^ i[l + 1];
      for (let f = 0; f < 50; f += 10)
        r[o + f] ^= d, r[o + f + 1] ^= p;
    }
    let s = r[2], a = r[3];
    for (let o = 0; o < 24; o++) {
      const l = A2[o], u = _S(s, a, l), c = TS(s, a, l), h = M2[o];
      s = r[h], a = r[h + 1], r[h] = u, r[h + 1] = c;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let l = 0; l < 10; l++)
        i[l] = r[o + l];
      for (let l = 0; l < 10; l++)
        r[o + l] ^= ~i[(l + 2) % 10] & i[(l + 4) % 10];
    }
    r[0] ^= oD[n], r[1] ^= lD[n];
  }
  w2(i);
}
class s_ extends eD {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, i, n, s = !1, a = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = i, this.outputLen = n, this.enableXOF = s, this.rounds = a, vS(n), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = Y3(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    xS(this.state32), uD(this.state32, this.rounds), xS(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    bS(this), e = E2(e), fm(e);
    const { blockLen: i, state: n } = this, s = e.length;
    for (let a = 0; a < s; ) {
      const o = Math.min(i - this.pos, s - a);
      for (let l = 0; l < o; l++)
        n[this.pos++] ^= e[a++];
      this.pos === i && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: i, pos: n, blockLen: s } = this;
    e[n] ^= i, i & 128 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    bS(this, !1), fm(e), this.finish();
    const i = this.state, { blockLen: n } = this;
    for (let s = 0, a = e.length; s < a; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, a - s);
      e.set(i.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return vS(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if ($3(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, w2(this.state);
  }
  _cloneInto(e) {
    const { blockLen: i, suffix: n, outputLen: s, rounds: a, enableXOF: o } = this;
    return e || (e = new s_(i, n, s, o, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = n, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const cD = (r, e, i) => tD(() => new s_(e, r, i)), hD = cD(1, 136, 256 / 8);
function a_(r, e) {
  const i = e || "hex", n = hD(r_(r, { strict: !1 }) ? _2(r) : r);
  return i === "bytes" ? n : y2(n);
}
const dD = (r) => a_(_2(r));
function pD(r) {
  return dD(r);
}
function fD(r) {
  let e = !0, i = "", n = 0, s = "", a = !1;
  for (let o = 0; o < r.length; o++) {
    const l = r[o];
    if (["(", ")", ","].includes(l) && (e = !0), l === "(" && n++, l === ")" && n--, !!e) {
      if (n === 0) {
        if (l === " " && ["event", "function", ""].includes(s))
          s = "";
        else if (s += l, l === ")") {
          a = !0;
          break;
        }
        continue;
      }
      if (l === " ") {
        r[o - 1] !== "," && i !== "," && i !== ",(" && (i = "", e = !1);
        continue;
      }
      s += l, i += l;
    }
  }
  if (!a)
    throw new Sn("Unable to normalize signature.");
  return s;
}
const mD = (r) => {
  const e = typeof r == "string" ? r : C3(r);
  return fD(e);
};
function gD(r) {
  return pD(mD(r));
}
const yD = gD;
class vD extends Sn {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class N2 extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const i = super.get(e);
    return super.has(e) && i !== void 0 && (this.delete(e), super.set(e, i)), i;
  }
  set(e, i) {
    if (super.set(e, i), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
const ey = /* @__PURE__ */ new N2(8192);
function bD(r, e) {
  if (ey.has(`${r}.${e}`))
    return ey.get(`${r}.${e}`);
  const i = r.substring(2).toLowerCase(), n = a_(S2(i), "bytes"), s = i.split("");
  for (let o = 0; o < 40; o += 2)
    n[o >> 1] >> 4 >= 8 && s[o] && (s[o] = s[o].toUpperCase()), (n[o >> 1] & 15) >= 8 && s[o + 1] && (s[o + 1] = s[o + 1].toUpperCase());
  const a = `0x${s.join("")}`;
  return ey.set(`${r}.${e}`, a), a;
}
const xD = /^0x[a-fA-F0-9]{40}$/, ty = /* @__PURE__ */ new N2(8192);
function _D(r, e) {
  const { strict: i = !0 } = {}, n = `${r}.${i}`;
  if (ty.has(n))
    return ty.get(n);
  const s = xD.test(r) ? r.toLowerCase() === r ? !0 : i ? bD(r) === r : !0 : !1;
  return ty.set(n, s), s;
}
function P2(r) {
  return `0x${r.reduce((e, i) => e + i.replace("0x", ""), "")}`;
}
const TD = /^(.*)\[([0-9]*)\]$/, SD = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, wD = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function ED(r, e) {
  if (r.length !== e.length)
    throw new R3({
      expectedLength: r.length,
      givenLength: e.length
    });
  const i = [];
  for (let n = 0; n < r.length; n++) {
    const s = r[n], a = e[n];
    i.push(I2(s, a));
  }
  return P2(i);
}
function I2(r, e, i = !1) {
  if (r === "address") {
    const o = e;
    if (!_D(o))
      throw new vD({ address: o });
    return la(o.toLowerCase(), {
      size: i ? 32 : null
    });
  }
  if (r === "string")
    return x2(e);
  if (r === "bytes")
    return e;
  if (r === "bool")
    return la(v2(e), { size: i ? 32 : 1 });
  const n = r.match(wD);
  if (n) {
    const [o, l, u = "256"] = n, c = Number.parseInt(u, 10) / 8;
    return n_(e, {
      size: i ? 32 : c,
      signed: l === "int"
    });
  }
  const s = r.match(SD);
  if (s) {
    const [o, l] = s;
    if (Number.parseInt(l, 10) !== (e.length - 2) / 2)
      throw new N3({
        expectedSize: Number.parseInt(l, 10),
        givenSize: (e.length - 2) / 2
      });
    return la(e, { dir: "right", size: i ? 32 : null });
  }
  const a = r.match(TD);
  if (a && Array.isArray(e)) {
    const [o, l] = a, u = [];
    for (let c = 0; c < e.length; c++)
      u.push(I2(l, e[c], !0));
    return u.length === 0 ? "0x" : P2(u);
  }
  throw new P3(r);
}
const pl = "0xB92EA1B47E4ABD0a520E9138BB59dBd1bC6C475B", MD = 13579, iy = BigInt("10000000000000000"), SS = BigInt("10000000000000000"), Wh = [
  {
    type: "function",
    name: "BURN_ADDRESS",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "CONTROLLER_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "COUNTER_SALT",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "DEFAULT_ADMIN_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "MAX_BATCH_SIZE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "MIGRATOR_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "ONE_SHARE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "_maxRedeem",
    inputs: [
      {
        name: "sender",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "accumulatedAtomWalletDepositFees",
    inputs: [
      {
        name: "atomWallet",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "accumulatedFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "accumulatedProtocolFees",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "accumulatedFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "approve",
    inputs: [
      {
        name: "sender",
        type: "address",
        internalType: "address"
      },
      {
        name: "approvalType",
        type: "uint8",
        internalType: "enum IMultiVault.ApprovalTypes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "atom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "atomConfig",
    inputs: [],
    outputs: [
      {
        name: "atomCreationProtocolFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomWalletDepositFee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "atomDepositFractionAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "batchSetAtomData",
    inputs: [
      {
        name: "creators",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "atomDataArray",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetTripleData",
    inputs: [
      {
        name: "creators",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "tripleAtomIds",
        type: "bytes32[3][]",
        internalType: "bytes32[3][]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetUserBalances",
    inputs: [
      {
        name: "params",
        type: "tuple",
        internalType: "struct MultiVaultMigrationMode.BatchSetUserBalancesParams",
        components: [
          {
            name: "termIds",
            type: "bytes32[]",
            internalType: "bytes32[]"
          },
          {
            name: "bondingCurveId",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "user",
            type: "address",
            internalType: "address"
          },
          {
            name: "userBalances",
            type: "uint256[]",
            internalType: "uint256[]"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetVaultTotals",
    inputs: [
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "bondingCurveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "vaultTotals",
        type: "tuple[]",
        internalType: "struct MultiVaultMigrationMode.VaultTotals[]",
        components: [
          {
            name: "totalAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalShares",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "bondingCurveConfig",
    inputs: [],
    outputs: [
      {
        name: "registry",
        type: "address",
        internalType: "address"
      },
      {
        name: "defaultCurveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "calculateAtomId",
    inputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "id",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "calculateCounterTripleId",
    inputs: [
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "calculateTripleId",
    inputs: [
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "claimAtomWalletDepositFees",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "computeAtomWalletAddr",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "convertToAssets",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "bondingCurveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "convertToShares",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "createAtoms",
    inputs: [
      {
        name: "data",
        type: "bytes[]",
        internalType: "bytes[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "createTriples",
    inputs: [
      {
        name: "subjectIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "predicateIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "objectIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "currentEpoch",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "currentSharePrice",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "deposit",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minShares",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "depositBatch",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "curveIds",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "minShares",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "entryFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "exitFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "generalConfig",
    inputs: [],
    outputs: [
      {
        name: "admin",
        type: "address",
        internalType: "address"
      },
      {
        name: "protocolMultisig",
        type: "address",
        internalType: "address"
      },
      {
        name: "feeDenominator",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "trustBonding",
        type: "address",
        internalType: "address"
      },
      {
        name: "minDeposit",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minShare",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomDataMaxLength",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "decimalPrecision",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomCreationCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomWarden",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getBondingCurveConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getCounterIdFromTripleId",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "getDefaultCurveId",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getGeneralConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleAdmin",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getShares",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTotalUtilizationForEpoch",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTriple",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleIdFromCounterId",
    inputs: [
      {
        name: "counterId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserUtilizationForEpoch",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVault",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultFees",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultType",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint8",
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getWalletConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "hasRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      {
        name: "_generalConfig",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_atomConfig",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_tripleConfig",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_walletConfig",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      },
      {
        name: "_vaultFees",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_bondingCurveConfig",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "isAtom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isCounterTriple",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTermCreated",
    inputs: [
      {
        name: "id",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTriple",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "lastActiveEpoch",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "pause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "paused",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "personalUtilization",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "utilizationAmount",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewAtomCreate",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFixedFees",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewDeposit",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewRedeem",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewTripleCreate",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFixedFees",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "protocolFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "redeem",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minAssets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "redeemBatch",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "curveIds",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "shares",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "minAssets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "received",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "renounceRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "callerConfirmation",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setAtomConfig",
    inputs: [
      {
        name: "_atomConfig",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setBondingCurveConfig",
    inputs: [
      {
        name: "_bondingCurveConfig",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setGeneralConfig",
    inputs: [
      {
        name: "_generalConfig",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setTermCount",
    inputs: [
      {
        name: "_termCount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setTripleConfig",
    inputs: [
      {
        name: "_tripleConfig",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setVaultFees",
    inputs: [
      {
        name: "_vaultFees",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setWalletConfig",
    inputs: [
      {
        name: "_walletConfig",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [
      {
        name: "interfaceId",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "totalTermsCreated",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "totalUtilization",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "utilizationAmount",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "triple",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "tripleConfig",
    inputs: [],
    outputs: [
      {
        name: "tripleCreationProtocolFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "totalAtomDepositsOnTripleCreation",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomDepositFractionForTriple",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "unpause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "vaultFees",
    inputs: [],
    outputs: [
      {
        name: "entryFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "exitFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "protocolFee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "walletConfig",
    inputs: [],
    outputs: [
      {
        name: "permit2",
        type: "address",
        internalType: "contract IPermit2"
      },
      {
        name: "entryPoint",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWarden",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWalletBeacon",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWalletFactory",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "ApprovalTypeUpdated",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "approvalType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.ApprovalTypes"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomCreated",
    inputs: [
      {
        name: "creator",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "atomData",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      },
      {
        name: "atomWallet",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomDepositFractionDeposited",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomWalletDepositFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomWalletDepositFeesClaimed",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "atomWalletOwner",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "feesClaimed",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ConfigSynced",
    inputs: [
      {
        name: "caller",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Deposited",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "EntryFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ExitFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Initialized",
    inputs: [
      {
        name: "version",
        type: "uint64",
        indexed: !1,
        internalType: "uint64"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Paused",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "PersonalUtilizationAdded",
    inputs: [
      {
        name: "user",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueAdded",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "personalUtilization",
        type: "int256",
        indexed: !1,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "PersonalUtilizationRemoved",
    inputs: [
      {
        name: "user",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueRemoved",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "personalUtilization",
        type: "int256",
        indexed: !1,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ProtocolFeeAccrued",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ProtocolFeeTransferred",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "destination",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Redeemed",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "fees",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleAdminChanged",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "previousAdminRole",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "newAdminRole",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleGranted",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleRevoked",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "SharePriceChanged",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sharePrice",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalAssets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "SharesPullApproval",
    inputs: [
      {
        name: "accountFrom",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "accountTo",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "status",
        type: "bool",
        indexed: !1,
        internalType: "bool"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TermCountSet",
    inputs: [
      {
        name: "termCount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TokensRecovered",
    inputs: [
      {
        name: "token",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "recipient",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TotalUtilizationAdded",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueAdded",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "totalUtilization",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TotalUtilizationRemoved",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueRemoved",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "totalUtilization",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TripleCreated",
    inputs: [
      {
        name: "creator",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "subjectId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Unpaused",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WalletMigrated",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "oldWallet",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "newWallet",
        type: "address",
        indexed: !1,
        internalType: "address"
      },
      {
        name: "sharesMigrated",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WrappedERC20Registered",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "wrappedERC20",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WrapperTransfer",
    inputs: [
      {
        name: "from",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "to",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "error",
    name: "AccessControlBadConfirmation",
    inputs: []
  },
  {
    type: "error",
    name: "AccessControlUnauthorizedAccount",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      },
      {
        name: "neededRole",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "AtomDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "EnforcedPause",
    inputs: []
  },
  {
    type: "error",
    name: "ExpectedPause",
    inputs: []
  },
  {
    type: "error",
    name: "FailedCall",
    inputs: []
  },
  {
    type: "error",
    name: "InsufficientBalance",
    inputs: [
      {
        name: "balance",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "needed",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "InvalidInitialization",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ActionExceedsMaxAssets",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ArraysNotSameLength",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_AtomDataTooLong",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_AtomDoesNotExist",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_AtomExists",
    inputs: [
      {
        name: "atomData",
        type: "bytes",
        internalType: "bytes"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_BurnFromZeroAddress",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_BurnInsufficientBalance",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_CannotApproveOrRevokeSelf",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_DepositBelowMinimumDeposit",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_DepositOrRedeemZeroShares",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_EmptyArray",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientAssets",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientBalance",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientRemainingSharesInVault",
    inputs: [
      {
        name: "remainingShares",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_InsufficientSharesInVault",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InvalidArrayLength",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InvalidBondingCurveId",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_NoAtomDataProvided",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_OnlyAssociatedAtomWallet",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_RedeemerNotApproved",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_SenderNotApproved",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_SlippageExceeded",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_TermDoesNotExist",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_TripleExists",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_ZeroAddress",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ZeroValue",
    inputs: []
  },
  {
    type: "error",
    name: "NotInitializing",
    inputs: []
  },
  {
    type: "error",
    name: "ReentrancyGuardReentrantCall",
    inputs: []
  },
  {
    type: "error",
    name: "TermDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "TripleDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  }
];
function O2(r, e) {
  return function() {
    return r.apply(e, arguments);
  };
}
const { toString: AD } = Object.prototype, { getPrototypeOf: o_ } = Object, { iterator: sg, toStringTag: D2 } = Symbol, ag = /* @__PURE__ */ ((r) => (e) => {
  const i = AD.call(e);
  return r[i] || (r[i] = i.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), es = (r) => (r = r.toLowerCase(), (e) => ag(e) === r), og = (r) => (e) => typeof e === r, { isArray: Nc } = Array, cc = og("undefined");
function kd(r) {
  return r !== null && !cc(r) && r.constructor !== null && !cc(r.constructor) && jr(r.constructor.isBuffer) && r.constructor.isBuffer(r);
}
const L2 = es("ArrayBuffer");
function CD(r) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(r) : e = r && r.buffer && L2(r.buffer), e;
}
const RD = og("string"), jr = og("function"), U2 = og("number"), Fd = (r) => r !== null && typeof r == "object", ND = (r) => r === !0 || r === !1, kf = (r) => {
  if (ag(r) !== "object")
    return !1;
  const e = o_(r);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(D2 in r) && !(sg in r);
}, PD = (r) => {
  if (!Fd(r) || kd(r))
    return !1;
  try {
    return Object.keys(r).length === 0 && Object.getPrototypeOf(r) === Object.prototype;
  } catch {
    return !1;
  }
}, ID = es("Date"), OD = es("File"), DD = es("Blob"), LD = es("FileList"), UD = (r) => Fd(r) && jr(r.pipe), kD = (r) => {
  let e;
  return r && (typeof FormData == "function" && r instanceof FormData || jr(r.append) && ((e = ag(r)) === "formdata" || // detect form-data instance
  e === "object" && jr(r.toString) && r.toString() === "[object FormData]"));
}, FD = es("URLSearchParams"), [BD, zD, jD, VD] = ["ReadableStream", "Request", "Response", "Headers"].map(es), GD = (r) => r.trim ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Bd(r, e, { allOwnKeys: i = !1 } = {}) {
  if (r === null || typeof r > "u")
    return;
  let n, s;
  if (typeof r != "object" && (r = [r]), Nc(r))
    for (n = 0, s = r.length; n < s; n++)
      e.call(null, r[n], n, r);
  else {
    if (kd(r))
      return;
    const a = i ? Object.getOwnPropertyNames(r) : Object.keys(r), o = a.length;
    let l;
    for (n = 0; n < o; n++)
      l = a[n], e.call(null, r[l], l, r);
  }
}
function k2(r, e) {
  if (kd(r))
    return null;
  e = e.toLowerCase();
  const i = Object.keys(r);
  let n = i.length, s;
  for (; n-- > 0; )
    if (s = i[n], e === s.toLowerCase())
      return s;
  return null;
}
const el = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, F2 = (r) => !cc(r) && r !== el;
function P0() {
  const { caseless: r, skipUndefined: e } = F2(this) && this || {}, i = {}, n = (s, a) => {
    const o = r && k2(i, a) || a;
    kf(i[o]) && kf(s) ? i[o] = P0(i[o], s) : kf(s) ? i[o] = P0({}, s) : Nc(s) ? i[o] = s.slice() : (!e || !cc(s)) && (i[o] = s);
  };
  for (let s = 0, a = arguments.length; s < a; s++)
    arguments[s] && Bd(arguments[s], n);
  return i;
}
const HD = (r, e, i, { allOwnKeys: n } = {}) => (Bd(e, (s, a) => {
  i && jr(s) ? r[a] = O2(s, i) : r[a] = s;
}, { allOwnKeys: n }), r), WD = (r) => (r.charCodeAt(0) === 65279 && (r = r.slice(1)), r), qD = (r, e, i, n) => {
  r.prototype = Object.create(e.prototype, n), r.prototype.constructor = r, Object.defineProperty(r, "super", {
    value: e.prototype
  }), i && Object.assign(r.prototype, i);
}, XD = (r, e, i, n) => {
  let s, a, o;
  const l = {};
  if (e = e || {}, r == null) return e;
  do {
    for (s = Object.getOwnPropertyNames(r), a = s.length; a-- > 0; )
      o = s[a], (!n || n(o, r, e)) && !l[o] && (e[o] = r[o], l[o] = !0);
    r = i !== !1 && o_(r);
  } while (r && (!i || i(r, e)) && r !== Object.prototype);
  return e;
}, $D = (r, e, i) => {
  r = String(r), (i === void 0 || i > r.length) && (i = r.length), i -= e.length;
  const n = r.indexOf(e, i);
  return n !== -1 && n === i;
}, YD = (r) => {
  if (!r) return null;
  if (Nc(r)) return r;
  let e = r.length;
  if (!U2(e)) return null;
  const i = new Array(e);
  for (; e-- > 0; )
    i[e] = r[e];
  return i;
}, KD = /* @__PURE__ */ ((r) => (e) => r && e instanceof r)(typeof Uint8Array < "u" && o_(Uint8Array)), ZD = (r, e) => {
  const n = (r && r[sg]).call(r);
  let s;
  for (; (s = n.next()) && !s.done; ) {
    const a = s.value;
    e.call(r, a[0], a[1]);
  }
}, QD = (r, e) => {
  let i;
  const n = [];
  for (; (i = r.exec(e)) !== null; )
    n.push(i);
  return n;
}, JD = es("HTMLFormElement"), eL = (r) => r.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(i, n, s) {
    return n.toUpperCase() + s;
  }
), wS = (({ hasOwnProperty: r }) => (e, i) => r.call(e, i))(Object.prototype), tL = es("RegExp"), B2 = (r, e) => {
  const i = Object.getOwnPropertyDescriptors(r), n = {};
  Bd(i, (s, a) => {
    let o;
    (o = e(s, a, r)) !== !1 && (n[a] = o || s);
  }), Object.defineProperties(r, n);
}, iL = (r) => {
  B2(r, (e, i) => {
    if (jr(r) && ["arguments", "caller", "callee"].indexOf(i) !== -1)
      return !1;
    const n = r[i];
    if (jr(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + i + "'");
      });
    }
  });
}, rL = (r, e) => {
  const i = {}, n = (s) => {
    s.forEach((a) => {
      i[a] = !0;
    });
  };
  return Nc(r) ? n(r) : n(String(r).split(e)), i;
}, nL = () => {
}, sL = (r, e) => r != null && Number.isFinite(r = +r) ? r : e;
function aL(r) {
  return !!(r && jr(r.append) && r[D2] === "FormData" && r[sg]);
}
const oL = (r) => {
  const e = new Array(10), i = (n, s) => {
    if (Fd(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (kd(n))
        return n;
      if (!("toJSON" in n)) {
        e[s] = n;
        const a = Nc(n) ? [] : {};
        return Bd(n, (o, l) => {
          const u = i(o, s + 1);
          !cc(u) && (a[l] = u);
        }), e[s] = void 0, a;
      }
    }
    return n;
  };
  return i(r, 0);
}, lL = es("AsyncFunction"), uL = (r) => r && (Fd(r) || jr(r)) && jr(r.then) && jr(r.catch), z2 = ((r, e) => r ? setImmediate : e ? ((i, n) => (el.addEventListener("message", ({ source: s, data: a }) => {
  s === el && a === i && n.length && n.shift()();
}, !1), (s) => {
  n.push(s), el.postMessage(i, "*");
}))(`axios@${Math.random()}`, []) : (i) => setTimeout(i))(
  typeof setImmediate == "function",
  jr(el.postMessage)
), cL = typeof queueMicrotask < "u" ? queueMicrotask.bind(el) : typeof process < "u" && process.nextTick || z2, hL = (r) => r != null && jr(r[sg]), he = {
  isArray: Nc,
  isArrayBuffer: L2,
  isBuffer: kd,
  isFormData: kD,
  isArrayBufferView: CD,
  isString: RD,
  isNumber: U2,
  isBoolean: ND,
  isObject: Fd,
  isPlainObject: kf,
  isEmptyObject: PD,
  isReadableStream: BD,
  isRequest: zD,
  isResponse: jD,
  isHeaders: VD,
  isUndefined: cc,
  isDate: ID,
  isFile: OD,
  isBlob: DD,
  isRegExp: tL,
  isFunction: jr,
  isStream: UD,
  isURLSearchParams: FD,
  isTypedArray: KD,
  isFileList: LD,
  forEach: Bd,
  merge: P0,
  extend: HD,
  trim: GD,
  stripBOM: WD,
  inherits: qD,
  toFlatObject: XD,
  kindOf: ag,
  kindOfTest: es,
  endsWith: $D,
  toArray: YD,
  forEachEntry: ZD,
  matchAll: QD,
  isHTMLForm: JD,
  hasOwnProperty: wS,
  hasOwnProp: wS,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: B2,
  freezeMethods: iL,
  toObjectSet: rL,
  toCamelCase: eL,
  noop: nL,
  toFiniteNumber: sL,
  findKey: k2,
  global: el,
  isContextDefined: F2,
  isSpecCompliantForm: aL,
  toJSONObject: oL,
  isAsyncFn: lL,
  isThenable: uL,
  setImmediate: z2,
  asap: cL,
  isIterable: hL
};
function Et(r, e, i, n, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = r, this.name = "AxiosError", e && (this.code = e), i && (this.config = i), n && (this.request = n), s && (this.response = s, this.status = s.status ? s.status : null);
}
he.inherits(Et, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: he.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const j2 = Et.prototype, V2 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((r) => {
  V2[r] = { value: r };
});
Object.defineProperties(Et, V2);
Object.defineProperty(j2, "isAxiosError", { value: !0 });
Et.from = (r, e, i, n, s, a) => {
  const o = Object.create(j2);
  he.toFlatObject(r, o, function(h) {
    return h !== Error.prototype;
  }, (c) => c !== "isAxiosError");
  const l = r && r.message ? r.message : "Error", u = e == null && r ? r.code : e;
  return Et.call(o, l, u, i, n, s), r && o.cause == null && Object.defineProperty(o, "cause", { value: r, configurable: !0 }), o.name = r && r.name || "Error", a && Object.assign(o, a), o;
};
const dL = null;
function I0(r) {
  return he.isPlainObject(r) || he.isArray(r);
}
function G2(r) {
  return he.endsWith(r, "[]") ? r.slice(0, -2) : r;
}
function ES(r, e, i) {
  return r ? r.concat(e).map(function(s, a) {
    return s = G2(s), !i && a ? "[" + s + "]" : s;
  }).join(i ? "." : "") : e;
}
function pL(r) {
  return he.isArray(r) && !r.some(I0);
}
const fL = he.toFlatObject(he, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function lg(r, e, i) {
  if (!he.isObject(r))
    throw new TypeError("target must be an object");
  e = e || new FormData(), i = he.toFlatObject(i, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(v, y) {
    return !he.isUndefined(y[v]);
  });
  const n = i.metaTokens, s = i.visitor || h, a = i.dots, o = i.indexes, u = (i.Blob || typeof Blob < "u" && Blob) && he.isSpecCompliantForm(e);
  if (!he.isFunction(s))
    throw new TypeError("visitor must be a function");
  function c(m) {
    if (m === null) return "";
    if (he.isDate(m))
      return m.toISOString();
    if (he.isBoolean(m))
      return m.toString();
    if (!u && he.isBlob(m))
      throw new Et("Blob is not supported. Use a Buffer instead.");
    return he.isArrayBuffer(m) || he.isTypedArray(m) ? u && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m;
  }
  function h(m, v, y) {
    let g = m;
    if (m && !y && typeof m == "object") {
      if (he.endsWith(v, "{}"))
        v = n ? v : v.slice(0, -2), m = JSON.stringify(m);
      else if (he.isArray(m) && pL(m) || (he.isFileList(m) || he.endsWith(v, "[]")) && (g = he.toArray(m)))
        return v = G2(v), g.forEach(function(x, b) {
          !(he.isUndefined(x) || x === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? ES([v], b, a) : o === null ? v : v + "[]",
            c(x)
          );
        }), !1;
    }
    return I0(m) ? !0 : (e.append(ES(y, v, a), c(m)), !1);
  }
  const d = [], p = Object.assign(fL, {
    defaultVisitor: h,
    convertValue: c,
    isVisitable: I0
  });
  function f(m, v) {
    if (!he.isUndefined(m)) {
      if (d.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + v.join("."));
      d.push(m), he.forEach(m, function(g, _) {
        (!(he.isUndefined(g) || g === null) && s.call(
          e,
          g,
          he.isString(_) ? _.trim() : _,
          v,
          p
        )) === !0 && f(g, v ? v.concat(_) : [_]);
      }), d.pop();
    }
  }
  if (!he.isObject(r))
    throw new TypeError("data must be an object");
  return f(r), e;
}
function MS(r) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(r).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function l_(r, e) {
  this._pairs = [], r && lg(r, this, e);
}
const H2 = l_.prototype;
H2.append = function(e, i) {
  this._pairs.push([e, i]);
};
H2.toString = function(e) {
  const i = e ? function(n) {
    return e.call(this, n, MS);
  } : MS;
  return this._pairs.map(function(s) {
    return i(s[0]) + "=" + i(s[1]);
  }, "").join("&");
};
function mL(r) {
  return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function W2(r, e, i) {
  if (!e)
    return r;
  const n = i && i.encode || mL;
  he.isFunction(i) && (i = {
    serialize: i
  });
  const s = i && i.serialize;
  let a;
  if (s ? a = s(e, i) : a = he.isURLSearchParams(e) ? e.toString() : new l_(e, i).toString(n), a) {
    const o = r.indexOf("#");
    o !== -1 && (r = r.slice(0, o)), r += (r.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return r;
}
class AS {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, i, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: i,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    he.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const q2 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, gL = typeof URLSearchParams < "u" ? URLSearchParams : l_, yL = typeof FormData < "u" ? FormData : null, vL = typeof Blob < "u" ? Blob : null, bL = {
  isBrowser: !0,
  classes: {
    URLSearchParams: gL,
    FormData: yL,
    Blob: vL
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, u_ = typeof window < "u" && typeof document < "u", O0 = typeof navigator == "object" && navigator || void 0, xL = u_ && (!O0 || ["ReactNative", "NativeScript", "NS"].indexOf(O0.product) < 0), _L = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", TL = u_ && window.location.href || "http://localhost", SL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: u_,
  hasStandardBrowserEnv: xL,
  hasStandardBrowserWebWorkerEnv: _L,
  navigator: O0,
  origin: TL
}, Symbol.toStringTag, { value: "Module" })), mr = {
  ...SL,
  ...bL
};
function wL(r, e) {
  return lg(r, new mr.classes.URLSearchParams(), {
    visitor: function(i, n, s, a) {
      return mr.isNode && he.isBuffer(i) ? (this.append(n, i.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    },
    ...e
  });
}
function EL(r) {
  return he.matchAll(/\w+|\[(\w*)]/g, r).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function ML(r) {
  const e = {}, i = Object.keys(r);
  let n;
  const s = i.length;
  let a;
  for (n = 0; n < s; n++)
    a = i[n], e[a] = r[a];
  return e;
}
function X2(r) {
  function e(i, n, s, a) {
    let o = i[a++];
    if (o === "__proto__") return !0;
    const l = Number.isFinite(+o), u = a >= i.length;
    return o = !o && he.isArray(s) ? s.length : o, u ? (he.hasOwnProp(s, o) ? s[o] = [s[o], n] : s[o] = n, !l) : ((!s[o] || !he.isObject(s[o])) && (s[o] = []), e(i, n, s[o], a) && he.isArray(s[o]) && (s[o] = ML(s[o])), !l);
  }
  if (he.isFormData(r) && he.isFunction(r.entries)) {
    const i = {};
    return he.forEachEntry(r, (n, s) => {
      e(EL(n), s, i, 0);
    }), i;
  }
  return null;
}
function AL(r, e, i) {
  if (he.isString(r))
    try {
      return (e || JSON.parse)(r), he.trim(r);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (i || JSON.stringify)(r);
}
const zd = {
  transitional: q2,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, i) {
    const n = i.getContentType() || "", s = n.indexOf("application/json") > -1, a = he.isObject(e);
    if (a && he.isHTMLForm(e) && (e = new FormData(e)), he.isFormData(e))
      return s ? JSON.stringify(X2(e)) : e;
    if (he.isArrayBuffer(e) || he.isBuffer(e) || he.isStream(e) || he.isFile(e) || he.isBlob(e) || he.isReadableStream(e))
      return e;
    if (he.isArrayBufferView(e))
      return e.buffer;
    if (he.isURLSearchParams(e))
      return i.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let l;
    if (a) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return wL(e, this.formSerializer).toString();
      if ((l = he.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const u = this.env && this.env.FormData;
        return lg(
          l ? { "files[]": e } : e,
          u && new u(),
          this.formSerializer
        );
      }
    }
    return a || s ? (i.setContentType("application/json", !1), AL(e)) : e;
  }],
  transformResponse: [function(e) {
    const i = this.transitional || zd.transitional, n = i && i.forcedJSONParsing, s = this.responseType === "json";
    if (he.isResponse(e) || he.isReadableStream(e))
      return e;
    if (e && he.isString(e) && (n && !this.responseType || s)) {
      const o = !(i && i.silentJSONParsing) && s;
      try {
        return JSON.parse(e, this.parseReviver);
      } catch (l) {
        if (o)
          throw l.name === "SyntaxError" ? Et.from(l, Et.ERR_BAD_RESPONSE, this, null, this.response) : l;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: mr.classes.FormData,
    Blob: mr.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
he.forEach(["delete", "get", "head", "post", "put", "patch"], (r) => {
  zd.headers[r] = {};
});
const CL = he.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), RL = (r) => {
  const e = {};
  let i, n, s;
  return r && r.split(`
`).forEach(function(o) {
    s = o.indexOf(":"), i = o.substring(0, s).trim().toLowerCase(), n = o.substring(s + 1).trim(), !(!i || e[i] && CL[i]) && (i === "set-cookie" ? e[i] ? e[i].push(n) : e[i] = [n] : e[i] = e[i] ? e[i] + ", " + n : n);
  }), e;
}, CS = Symbol("internals");
function Jc(r) {
  return r && String(r).trim().toLowerCase();
}
function Ff(r) {
  return r === !1 || r == null ? r : he.isArray(r) ? r.map(Ff) : String(r);
}
function NL(r) {
  const e = /* @__PURE__ */ Object.create(null), i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = i.exec(r); )
    e[n[1]] = n[2];
  return e;
}
const PL = (r) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function ry(r, e, i, n, s) {
  if (he.isFunction(n))
    return n.call(this, e, i);
  if (s && (e = i), !!he.isString(e)) {
    if (he.isString(n))
      return e.indexOf(n) !== -1;
    if (he.isRegExp(n))
      return n.test(e);
  }
}
function IL(r) {
  return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, i, n) => i.toUpperCase() + n);
}
function OL(r, e) {
  const i = he.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(r, n + i, {
      value: function(s, a, o) {
        return this[n].call(this, e, s, a, o);
      },
      configurable: !0
    });
  });
}
let Vr = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, i, n) {
    const s = this;
    function a(l, u, c) {
      const h = Jc(u);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const d = he.findKey(s, h);
      (!d || s[d] === void 0 || c === !0 || c === void 0 && s[d] !== !1) && (s[d || u] = Ff(l));
    }
    const o = (l, u) => he.forEach(l, (c, h) => a(c, h, u));
    if (he.isPlainObject(e) || e instanceof this.constructor)
      o(e, i);
    else if (he.isString(e) && (e = e.trim()) && !PL(e))
      o(RL(e), i);
    else if (he.isObject(e) && he.isIterable(e)) {
      let l = {}, u, c;
      for (const h of e) {
        if (!he.isArray(h))
          throw TypeError("Object iterator must return a key-value pair");
        l[c = h[0]] = (u = l[c]) ? he.isArray(u) ? [...u, h[1]] : [u, h[1]] : h[1];
      }
      o(l, i);
    } else
      e != null && a(i, e, n);
    return this;
  }
  get(e, i) {
    if (e = Jc(e), e) {
      const n = he.findKey(this, e);
      if (n) {
        const s = this[n];
        if (!i)
          return s;
        if (i === !0)
          return NL(s);
        if (he.isFunction(i))
          return i.call(this, s, n);
        if (he.isRegExp(i))
          return i.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, i) {
    if (e = Jc(e), e) {
      const n = he.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!i || ry(this, this[n], n, i)));
    }
    return !1;
  }
  delete(e, i) {
    const n = this;
    let s = !1;
    function a(o) {
      if (o = Jc(o), o) {
        const l = he.findKey(n, o);
        l && (!i || ry(n, n[l], l, i)) && (delete n[l], s = !0);
      }
    }
    return he.isArray(e) ? e.forEach(a) : a(e), s;
  }
  clear(e) {
    const i = Object.keys(this);
    let n = i.length, s = !1;
    for (; n--; ) {
      const a = i[n];
      (!e || ry(this, this[a], a, e, !0)) && (delete this[a], s = !0);
    }
    return s;
  }
  normalize(e) {
    const i = this, n = {};
    return he.forEach(this, (s, a) => {
      const o = he.findKey(n, a);
      if (o) {
        i[o] = Ff(s), delete i[a];
        return;
      }
      const l = e ? IL(a) : String(a).trim();
      l !== a && delete i[a], i[l] = Ff(s), n[l] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const i = /* @__PURE__ */ Object.create(null);
    return he.forEach(this, (n, s) => {
      n != null && n !== !1 && (i[s] = e && he.isArray(n) ? n.join(", ") : n);
    }), i;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, i]) => e + ": " + i).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...i) {
    const n = new this(e);
    return i.forEach((s) => n.set(s)), n;
  }
  static accessor(e) {
    const n = (this[CS] = this[CS] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function a(o) {
      const l = Jc(o);
      n[l] || (OL(s, o), n[l] = !0);
    }
    return he.isArray(e) ? e.forEach(a) : a(e), this;
  }
};
Vr.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
he.reduceDescriptors(Vr.prototype, ({ value: r }, e) => {
  let i = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => r,
    set(n) {
      this[i] = n;
    }
  };
});
he.freezeMethods(Vr);
function ny(r, e) {
  const i = this || zd, n = e || i, s = Vr.from(n.headers);
  let a = n.data;
  return he.forEach(r, function(l) {
    a = l.call(i, a, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), a;
}
function $2(r) {
  return !!(r && r.__CANCEL__);
}
function Pc(r, e, i) {
  Et.call(this, r ?? "canceled", Et.ERR_CANCELED, e, i), this.name = "CanceledError";
}
he.inherits(Pc, Et, {
  __CANCEL__: !0
});
function Y2(r, e, i) {
  const n = i.config.validateStatus;
  !i.status || !n || n(i.status) ? r(i) : e(new Et(
    "Request failed with status code " + i.status,
    [Et.ERR_BAD_REQUEST, Et.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4],
    i.config,
    i.request,
    i
  ));
}
function DL(r) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(r);
  return e && e[1] || "";
}
function LL(r, e) {
  r = r || 10;
  const i = new Array(r), n = new Array(r);
  let s = 0, a = 0, o;
  return e = e !== void 0 ? e : 1e3, function(u) {
    const c = Date.now(), h = n[a];
    o || (o = c), i[s] = u, n[s] = c;
    let d = a, p = 0;
    for (; d !== s; )
      p += i[d++], d = d % r;
    if (s = (s + 1) % r, s === a && (a = (a + 1) % r), c - o < e)
      return;
    const f = h && c - h;
    return f ? Math.round(p * 1e3 / f) : void 0;
  };
}
function UL(r, e) {
  let i = 0, n = 1e3 / e, s, a;
  const o = (c, h = Date.now()) => {
    i = h, s = null, a && (clearTimeout(a), a = null), r(...c);
  };
  return [(...c) => {
    const h = Date.now(), d = h - i;
    d >= n ? o(c, h) : (s = c, a || (a = setTimeout(() => {
      a = null, o(s);
    }, n - d)));
  }, () => s && o(s)];
}
const mm = (r, e, i = 3) => {
  let n = 0;
  const s = LL(50, 250);
  return UL((a) => {
    const o = a.loaded, l = a.lengthComputable ? a.total : void 0, u = o - n, c = s(u), h = o <= l;
    n = o;
    const d = {
      loaded: o,
      total: l,
      progress: l ? o / l : void 0,
      bytes: u,
      rate: c || void 0,
      estimated: c && l && h ? (l - o) / c : void 0,
      event: a,
      lengthComputable: l != null,
      [e ? "download" : "upload"]: !0
    };
    r(d);
  }, i);
}, RS = (r, e) => {
  const i = r != null;
  return [(n) => e[0]({
    lengthComputable: i,
    total: r,
    loaded: n
  }), e[1]];
}, NS = (r) => (...e) => he.asap(() => r(...e)), kL = mr.hasStandardBrowserEnv ? /* @__PURE__ */ ((r, e) => (i) => (i = new URL(i, mr.origin), r.protocol === i.protocol && r.host === i.host && (e || r.port === i.port)))(
  new URL(mr.origin),
  mr.navigator && /(msie|trident)/i.test(mr.navigator.userAgent)
) : () => !0, FL = mr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(r, e, i, n, s, a) {
      const o = [r + "=" + encodeURIComponent(e)];
      he.isNumber(i) && o.push("expires=" + new Date(i).toGMTString()), he.isString(n) && o.push("path=" + n), he.isString(s) && o.push("domain=" + s), a === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(r) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(r) {
      this.write(r, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function BL(r) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(r);
}
function zL(r, e) {
  return e ? r.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : r;
}
function K2(r, e, i) {
  let n = !BL(e);
  return r && (n || i == !1) ? zL(r, e) : e;
}
const PS = (r) => r instanceof Vr ? { ...r } : r;
function vl(r, e) {
  e = e || {};
  const i = {};
  function n(c, h, d, p) {
    return he.isPlainObject(c) && he.isPlainObject(h) ? he.merge.call({ caseless: p }, c, h) : he.isPlainObject(h) ? he.merge({}, h) : he.isArray(h) ? h.slice() : h;
  }
  function s(c, h, d, p) {
    if (he.isUndefined(h)) {
      if (!he.isUndefined(c))
        return n(void 0, c, d, p);
    } else return n(c, h, d, p);
  }
  function a(c, h) {
    if (!he.isUndefined(h))
      return n(void 0, h);
  }
  function o(c, h) {
    if (he.isUndefined(h)) {
      if (!he.isUndefined(c))
        return n(void 0, c);
    } else return n(void 0, h);
  }
  function l(c, h, d) {
    if (d in e)
      return n(c, h);
    if (d in r)
      return n(void 0, c);
  }
  const u = {
    url: a,
    method: a,
    data: a,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: l,
    headers: (c, h, d) => s(PS(c), PS(h), d, !0)
  };
  return he.forEach(Object.keys({ ...r, ...e }), function(h) {
    const d = u[h] || s, p = d(r[h], e[h], h);
    he.isUndefined(p) && d !== l || (i[h] = p);
  }), i;
}
const Z2 = (r) => {
  const e = vl({}, r);
  let { data: i, withXSRFToken: n, xsrfHeaderName: s, xsrfCookieName: a, headers: o, auth: l } = e;
  if (e.headers = o = Vr.from(o), e.url = W2(K2(e.baseURL, e.url, e.allowAbsoluteUrls), r.params, r.paramsSerializer), l && o.set(
    "Authorization",
    "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))
  ), he.isFormData(i)) {
    if (mr.hasStandardBrowserEnv || mr.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if (he.isFunction(i.getHeaders)) {
      const u = i.getHeaders(), c = ["content-type", "content-length"];
      Object.entries(u).forEach(([h, d]) => {
        c.includes(h.toLowerCase()) && o.set(h, d);
      });
    }
  }
  if (mr.hasStandardBrowserEnv && (n && he.isFunction(n) && (n = n(e)), n || n !== !1 && kL(e.url))) {
    const u = s && a && FL.read(a);
    u && o.set(s, u);
  }
  return e;
}, jL = typeof XMLHttpRequest < "u", VL = jL && function(r) {
  return new Promise(function(i, n) {
    const s = Z2(r);
    let a = s.data;
    const o = Vr.from(s.headers).normalize();
    let { responseType: l, onUploadProgress: u, onDownloadProgress: c } = s, h, d, p, f, m;
    function v() {
      f && f(), m && m(), s.cancelToken && s.cancelToken.unsubscribe(h), s.signal && s.signal.removeEventListener("abort", h);
    }
    let y = new XMLHttpRequest();
    y.open(s.method.toUpperCase(), s.url, !0), y.timeout = s.timeout;
    function g() {
      if (!y)
        return;
      const x = Vr.from(
        "getAllResponseHeaders" in y && y.getAllResponseHeaders()
      ), T = {
        data: !l || l === "text" || l === "json" ? y.responseText : y.response,
        status: y.status,
        statusText: y.statusText,
        headers: x,
        config: r,
        request: y
      };
      Y2(function(w) {
        i(w), v();
      }, function(w) {
        n(w), v();
      }, T), y = null;
    }
    "onloadend" in y ? y.onloadend = g : y.onreadystatechange = function() {
      !y || y.readyState !== 4 || y.status === 0 && !(y.responseURL && y.responseURL.indexOf("file:") === 0) || setTimeout(g);
    }, y.onabort = function() {
      y && (n(new Et("Request aborted", Et.ECONNABORTED, r, y)), y = null);
    }, y.onerror = function(b) {
      const T = b && b.message ? b.message : "Network Error", S = new Et(T, Et.ERR_NETWORK, r, y);
      S.event = b || null, n(S), y = null;
    }, y.ontimeout = function() {
      let b = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const T = s.transitional || q2;
      s.timeoutErrorMessage && (b = s.timeoutErrorMessage), n(new Et(
        b,
        T.clarifyTimeoutError ? Et.ETIMEDOUT : Et.ECONNABORTED,
        r,
        y
      )), y = null;
    }, a === void 0 && o.setContentType(null), "setRequestHeader" in y && he.forEach(o.toJSON(), function(b, T) {
      y.setRequestHeader(T, b);
    }), he.isUndefined(s.withCredentials) || (y.withCredentials = !!s.withCredentials), l && l !== "json" && (y.responseType = s.responseType), c && ([p, m] = mm(c, !0), y.addEventListener("progress", p)), u && y.upload && ([d, f] = mm(u), y.upload.addEventListener("progress", d), y.upload.addEventListener("loadend", f)), (s.cancelToken || s.signal) && (h = (x) => {
      y && (n(!x || x.type ? new Pc(null, r, y) : x), y.abort(), y = null);
    }, s.cancelToken && s.cancelToken.subscribe(h), s.signal && (s.signal.aborted ? h() : s.signal.addEventListener("abort", h)));
    const _ = DL(s.url);
    if (_ && mr.protocols.indexOf(_) === -1) {
      n(new Et("Unsupported protocol " + _ + ":", Et.ERR_BAD_REQUEST, r));
      return;
    }
    y.send(a || null);
  });
}, GL = (r, e) => {
  const { length: i } = r = r ? r.filter(Boolean) : [];
  if (e || i) {
    let n = new AbortController(), s;
    const a = function(c) {
      if (!s) {
        s = !0, l();
        const h = c instanceof Error ? c : this.reason;
        n.abort(h instanceof Et ? h : new Pc(h instanceof Error ? h.message : h));
      }
    };
    let o = e && setTimeout(() => {
      o = null, a(new Et(`timeout ${e} of ms exceeded`, Et.ETIMEDOUT));
    }, e);
    const l = () => {
      r && (o && clearTimeout(o), o = null, r.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(a) : c.removeEventListener("abort", a);
      }), r = null);
    };
    r.forEach((c) => c.addEventListener("abort", a));
    const { signal: u } = n;
    return u.unsubscribe = () => he.asap(l), u;
  }
}, HL = function* (r, e) {
  let i = r.byteLength;
  if (i < e) {
    yield r;
    return;
  }
  let n = 0, s;
  for (; n < i; )
    s = n + e, yield r.slice(n, s), n = s;
}, WL = async function* (r, e) {
  for await (const i of qL(r))
    yield* HL(i, e);
}, qL = async function* (r) {
  if (r[Symbol.asyncIterator]) {
    yield* r;
    return;
  }
  const e = r.getReader();
  try {
    for (; ; ) {
      const { done: i, value: n } = await e.read();
      if (i)
        break;
      yield n;
    }
  } finally {
    await e.cancel();
  }
}, IS = (r, e, i, n) => {
  const s = WL(r, e);
  let a = 0, o, l = (u) => {
    o || (o = !0, n && n(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: c, value: h } = await s.next();
        if (c) {
          l(), u.close();
          return;
        }
        let d = h.byteLength;
        if (i) {
          let p = a += d;
          i(p);
        }
        u.enqueue(new Uint8Array(h));
      } catch (c) {
        throw l(c), c;
      }
    },
    cancel(u) {
      return l(u), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, OS = 64 * 1024, { isFunction: op } = he, Q2 = (({ fetch: r, Request: e, Response: i }) => ({
  fetch: r,
  Request: e,
  Response: i
}))(he.global), {
  ReadableStream: DS,
  TextEncoder: LS
} = he.global, US = (r, ...e) => {
  try {
    return !!r(...e);
  } catch {
    return !1;
  }
}, XL = (r) => {
  const { fetch: e, Request: i, Response: n } = Object.assign({}, Q2, r), s = op(e), a = op(i), o = op(n);
  if (!s)
    return !1;
  const l = s && op(DS), u = s && (typeof LS == "function" ? /* @__PURE__ */ ((m) => (v) => m.encode(v))(new LS()) : async (m) => new Uint8Array(await new i(m).arrayBuffer())), c = a && l && US(() => {
    let m = !1;
    const v = new i(mr.origin, {
      body: new DS(),
      method: "POST",
      get duplex() {
        return m = !0, "half";
      }
    }).headers.has("Content-Type");
    return m && !v;
  }), h = o && l && US(() => he.isReadableStream(new n("").body)), d = {
    stream: h && ((m) => m.body)
  };
  s && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((m) => {
    !d[m] && (d[m] = (v, y) => {
      let g = v && v[m];
      if (g)
        return g.call(v);
      throw new Et(`Response type '${m}' is not supported`, Et.ERR_NOT_SUPPORT, y);
    });
  });
  const p = async (m) => {
    if (m == null)
      return 0;
    if (he.isBlob(m))
      return m.size;
    if (he.isSpecCompliantForm(m))
      return (await new i(mr.origin, {
        method: "POST",
        body: m
      }).arrayBuffer()).byteLength;
    if (he.isArrayBufferView(m) || he.isArrayBuffer(m))
      return m.byteLength;
    if (he.isURLSearchParams(m) && (m = m + ""), he.isString(m))
      return (await u(m)).byteLength;
  }, f = async (m, v) => {
    const y = he.toFiniteNumber(m.getContentLength());
    return y ?? p(v);
  };
  return async (m) => {
    let {
      url: v,
      method: y,
      data: g,
      signal: _,
      cancelToken: x,
      timeout: b,
      onDownloadProgress: T,
      onUploadProgress: S,
      responseType: w,
      headers: A,
      withCredentials: E = "same-origin",
      fetchOptions: M
    } = Z2(m);
    w = w ? (w + "").toLowerCase() : "text";
    let N = GL([_, x && x.toAbortSignal()], b), k = null;
    const U = N && N.unsubscribe && (() => {
      N.unsubscribe();
    });
    let C;
    try {
      if (S && c && y !== "get" && y !== "head" && (C = await f(A, g)) !== 0) {
        let L = new i(v, {
          method: "POST",
          body: g,
          duplex: "half"
        }), B;
        if (he.isFormData(g) && (B = L.headers.get("content-type")) && A.setContentType(B), L.body) {
          const [Q, W] = RS(
            C,
            mm(NS(S))
          );
          g = IS(L.body, OS, Q, W);
        }
      }
      he.isString(E) || (E = E ? "include" : "omit");
      const O = a && "credentials" in i.prototype, D = {
        ...M,
        signal: N,
        method: y.toUpperCase(),
        headers: A.normalize().toJSON(),
        body: g,
        duplex: "half",
        credentials: O ? E : void 0
      };
      k = a && new i(v, D);
      let H = await (a ? e(k, M) : e(v, D));
      const j = h && (w === "stream" || w === "response");
      if (h && (T || j && U)) {
        const L = {};
        ["status", "statusText", "headers"].forEach((z) => {
          L[z] = H[z];
        });
        const B = he.toFiniteNumber(H.headers.get("content-length")), [Q, W] = T && RS(
          B,
          mm(NS(T), !0)
        ) || [];
        H = new n(
          IS(H.body, OS, Q, () => {
            W && W(), U && U();
          }),
          L
        );
      }
      w = w || "text";
      let K = await d[he.findKey(d, w) || "text"](H, m);
      return !j && U && U(), await new Promise((L, B) => {
        Y2(L, B, {
          data: K,
          headers: Vr.from(H.headers),
          status: H.status,
          statusText: H.statusText,
          config: m,
          request: k
        });
      });
    } catch (O) {
      throw U && U(), O && O.name === "TypeError" && /Load failed|fetch/i.test(O.message) ? Object.assign(
        new Et("Network Error", Et.ERR_NETWORK, m, k),
        {
          cause: O.cause || O
        }
      ) : Et.from(O, O && O.code, m, k);
    }
  };
}, $L = /* @__PURE__ */ new Map(), J2 = (r) => {
  let e = he.merge.call({
    skipUndefined: !0
  }, Q2, r ? r.env : null);
  const { fetch: i, Request: n, Response: s } = e, a = [
    n,
    s,
    i
  ];
  let o = a.length, l = o, u, c, h = $L;
  for (; l--; )
    u = a[l], c = h.get(u), c === void 0 && h.set(u, c = l ? /* @__PURE__ */ new Map() : XL(e)), h = c;
  return c;
};
J2();
const D0 = {
  http: dL,
  xhr: VL,
  fetch: {
    get: J2
  }
};
he.forEach(D0, (r, e) => {
  if (r) {
    try {
      Object.defineProperty(r, "name", { value: e });
    } catch {
    }
    Object.defineProperty(r, "adapterName", { value: e });
  }
});
const kS = (r) => `- ${r}`, YL = (r) => he.isFunction(r) || r === null || r === !1, eC = {
  getAdapter: (r, e) => {
    r = he.isArray(r) ? r : [r];
    const { length: i } = r;
    let n, s;
    const a = {};
    for (let o = 0; o < i; o++) {
      n = r[o];
      let l;
      if (s = n, !YL(n) && (s = D0[(l = String(n)).toLowerCase()], s === void 0))
        throw new Et(`Unknown adapter '${l}'`);
      if (s && (he.isFunction(s) || (s = s.get(e))))
        break;
      a[l || "#" + o] = s;
    }
    if (!s) {
      const o = Object.entries(a).map(
        ([u, c]) => `adapter ${u} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let l = i ? o.length > 1 ? `since :
` + o.map(kS).join(`
`) : " " + kS(o[0]) : "as no adapter specified";
      throw new Et(
        "There is no suitable adapter to dispatch the request " + l,
        "ERR_NOT_SUPPORT"
      );
    }
    return s;
  },
  adapters: D0
};
function sy(r) {
  if (r.cancelToken && r.cancelToken.throwIfRequested(), r.signal && r.signal.aborted)
    throw new Pc(null, r);
}
function FS(r) {
  return sy(r), r.headers = Vr.from(r.headers), r.data = ny.call(
    r,
    r.transformRequest
  ), ["post", "put", "patch"].indexOf(r.method) !== -1 && r.headers.setContentType("application/x-www-form-urlencoded", !1), eC.getAdapter(r.adapter || zd.adapter, r)(r).then(function(n) {
    return sy(r), n.data = ny.call(
      r,
      r.transformResponse,
      n
    ), n.headers = Vr.from(n.headers), n;
  }, function(n) {
    return $2(n) || (sy(r), n && n.response && (n.response.data = ny.call(
      r,
      r.transformResponse,
      n.response
    ), n.response.headers = Vr.from(n.response.headers))), Promise.reject(n);
  });
}
const tC = "1.12.0", ug = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((r, e) => {
  ug[r] = function(n) {
    return typeof n === r || "a" + (e < 1 ? "n " : " ") + r;
  };
});
const BS = {};
ug.transitional = function(e, i, n) {
  function s(a, o) {
    return "[Axios v" + tC + "] Transitional option '" + a + "'" + o + (n ? ". " + n : "");
  }
  return (a, o, l) => {
    if (e === !1)
      throw new Et(
        s(o, " has been removed" + (i ? " in " + i : "")),
        Et.ERR_DEPRECATED
      );
    return i && !BS[o] && (BS[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + i + " and will be removed in the near future"
      )
    )), e ? e(a, o, l) : !0;
  };
};
ug.spelling = function(e) {
  return (i, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function KL(r, e, i) {
  if (typeof r != "object")
    throw new Et("options must be an object", Et.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(r);
  let s = n.length;
  for (; s-- > 0; ) {
    const a = n[s], o = e[a];
    if (o) {
      const l = r[a], u = l === void 0 || o(l, a, r);
      if (u !== !0)
        throw new Et("option " + a + " must be " + u, Et.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (i !== !0)
      throw new Et("Unknown option " + a, Et.ERR_BAD_OPTION);
  }
}
const Bf = {
  assertOptions: KL,
  validators: ug
}, rs = Bf.validators;
let fl = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new AS(),
      response: new AS()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, i) {
    try {
      return await this._request(e, i);
    } catch (n) {
      if (n instanceof Error) {
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const a = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? a && !String(n.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + a) : n.stack = a;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, i) {
    typeof e == "string" ? (i = i || {}, i.url = e) : i = e || {}, i = vl(this.defaults, i);
    const { transitional: n, paramsSerializer: s, headers: a } = i;
    n !== void 0 && Bf.assertOptions(n, {
      silentJSONParsing: rs.transitional(rs.boolean),
      forcedJSONParsing: rs.transitional(rs.boolean),
      clarifyTimeoutError: rs.transitional(rs.boolean)
    }, !1), s != null && (he.isFunction(s) ? i.paramsSerializer = {
      serialize: s
    } : Bf.assertOptions(s, {
      encode: rs.function,
      serialize: rs.function
    }, !0)), i.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? i.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : i.allowAbsoluteUrls = !0), Bf.assertOptions(i, {
      baseUrl: rs.spelling("baseURL"),
      withXsrfToken: rs.spelling("withXSRFToken")
    }, !0), i.method = (i.method || this.defaults.method || "get").toLowerCase();
    let o = a && he.merge(
      a.common,
      a[i.method]
    );
    a && he.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (m) => {
        delete a[m];
      }
    ), i.headers = Vr.concat(o, a);
    const l = [];
    let u = !0;
    this.interceptors.request.forEach(function(v) {
      typeof v.runWhen == "function" && v.runWhen(i) === !1 || (u = u && v.synchronous, l.unshift(v.fulfilled, v.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(v) {
      c.push(v.fulfilled, v.rejected);
    });
    let h, d = 0, p;
    if (!u) {
      const m = [FS.bind(this), void 0];
      for (m.unshift(...l), m.push(...c), p = m.length, h = Promise.resolve(i); d < p; )
        h = h.then(m[d++], m[d++]);
      return h;
    }
    p = l.length;
    let f = i;
    for (d = 0; d < p; ) {
      const m = l[d++], v = l[d++];
      try {
        f = m(f);
      } catch (y) {
        v.call(this, y);
        break;
      }
    }
    try {
      h = FS.call(this, f);
    } catch (m) {
      return Promise.reject(m);
    }
    for (d = 0, p = c.length; d < p; )
      h = h.then(c[d++], c[d++]);
    return h;
  }
  getUri(e) {
    e = vl(this.defaults, e);
    const i = K2(e.baseURL, e.url, e.allowAbsoluteUrls);
    return W2(i, e.params, e.paramsSerializer);
  }
};
he.forEach(["delete", "get", "head", "options"], function(e) {
  fl.prototype[e] = function(i, n) {
    return this.request(vl(n || {}, {
      method: e,
      url: i,
      data: (n || {}).data
    }));
  };
});
he.forEach(["post", "put", "patch"], function(e) {
  function i(n) {
    return function(a, o, l) {
      return this.request(vl(l || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: o
      }));
    };
  }
  fl.prototype[e] = i(), fl.prototype[e + "Form"] = i(!0);
});
let ZL = class iC {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let i;
    this.promise = new Promise(function(a) {
      i = a;
    });
    const n = this;
    this.promise.then((s) => {
      if (!n._listeners) return;
      let a = n._listeners.length;
      for (; a-- > 0; )
        n._listeners[a](s);
      n._listeners = null;
    }), this.promise.then = (s) => {
      let a;
      const o = new Promise((l) => {
        n.subscribe(l), a = l;
      }).then(s);
      return o.cancel = function() {
        n.unsubscribe(a);
      }, o;
    }, e(function(a, o, l) {
      n.reason || (n.reason = new Pc(a, o, l), i(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const i = this._listeners.indexOf(e);
    i !== -1 && this._listeners.splice(i, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), i = (n) => {
      e.abort(n);
    };
    return this.subscribe(i), e.signal.unsubscribe = () => this.unsubscribe(i), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new iC(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
function QL(r) {
  return function(i) {
    return r.apply(null, i);
  };
}
function JL(r) {
  return he.isObject(r) && r.isAxiosError === !0;
}
const L0 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(L0).forEach(([r, e]) => {
  L0[e] = r;
});
function rC(r) {
  const e = new fl(r), i = O2(fl.prototype.request, e);
  return he.extend(i, fl.prototype, e, { allOwnKeys: !0 }), he.extend(i, e, null, { allOwnKeys: !0 }), i.create = function(s) {
    return rC(vl(r, s));
  }, i;
}
const xi = rC(zd);
xi.Axios = fl;
xi.CanceledError = Pc;
xi.CancelToken = ZL;
xi.isCancel = $2;
xi.VERSION = tC;
xi.toFormData = lg;
xi.AxiosError = Et;
xi.Cancel = xi.CanceledError;
xi.all = function(e) {
  return Promise.all(e);
};
xi.spread = QL;
xi.isAxiosError = JL;
xi.mergeConfig = vl;
xi.AxiosHeaders = Vr;
xi.formToJSON = (r) => X2(he.isHTMLForm(r) ? new FormData(r) : r);
xi.getAdapter = eC.getAdapter;
xi.HttpStatusCode = L0;
xi.default = xi;
const {
  Axios: Hoe,
  AxiosError: Woe,
  CanceledError: qoe,
  isCancel: Xoe,
  CancelToken: $oe,
  VERSION: Yoe,
  all: Koe,
  Cancel: Zoe,
  isAxiosError: Qoe,
  spread: Joe,
  toFormData: ele,
  AxiosHeaders: tle,
  HttpStatusCode: ile,
  formToJSON: rle,
  getAdapter: nle,
  mergeConfig: sle
} = xi, zS = (r) => {
  localStorage.setItem("auth_token", r);
}, c_ = () => localStorage.getItem("auth_token"), cg = () => !!c_(), eU = () => {
  localStorage.removeItem("auth_token");
}, h_ = () => {
  const r = c_();
  return r ? `Bearer ${r}` : "";
};
let U0 = null;
const hg = () => {
  if (!U0)
    throw new Error(
      "Configuration Player-map non initialise. Utilisez PlayerMapConfig.init() pour configurer la bibliothque."
    );
  return { ...U0 };
}, tU = (r) => {
  if (!r.apiUrl)
    throw new Error("L'URL de l'API est requise pour initialiser Player-map");
  U0 = {
    apiUrl: r.apiUrl
  };
}, iU = async (r) => {
  try {
    const e = new FormData();
    if (e.append("file", r), !cg())
      throw new Error("Vous devez tre connect pour tlverser des fichiers");
    const { apiUrl: i } = hg(), n = `${i}/ipfs/upload_file`;
    return (await xi.post(
      n,
      e,
      {
        headers: {
          "Content-Type": "multipart/form-data",
          Authorization: h_()
        }
      }
    )).data.ipfs_url;
  } catch (e) {
    throw e instanceof Error && e.message.includes("Configuration Player-map non initialise") ? (console.error("Erreur de configuration Player-map:", e.message), new Error("Erreur de configuration: Initialisez la bibliothque Player-map avec PlayerMapConfig.init() avant utilisation")) : (console.error("Erreur lors du tlversement vers le serveur:", e), new Error("chec du tlversement de l'image vers IPFS"));
  }
}, nC = (r) => r ? r.startsWith("ipfs://") : !1, rU = async (r) => {
  if (!nC(r)) return r;
  try {
    let e = sessionStorage.getItem("ipfs_gateway");
    if (!e) {
      if (!cg())
        throw new Error("Vous devez tre connect pour accder  la passerelle IPFS");
      const { apiUrl: n } = hg();
      if (e = (await xi.get(
        `${n}/ipfs/gateway_url`,
        {
          headers: {
            Authorization: h_()
          }
        }
      )).data.gateway_url, e)
        sessionStorage.setItem("ipfs_gateway", e);
      else
        throw new Error("Aucune passerelle IPFS configure");
    }
    const i = r.replace("ipfs://", "");
    return `https://${e}/ipfs/${i}`;
  } catch (e) {
    throw e instanceof Error && e.message.includes("Configuration Player-map non initialise") ? (console.error("Erreur de configuration Player-map:", e.message), new Error("Erreur de configuration: Initialisez la bibliothque Player-map avec PlayerMapConfig.init() avant utilisation")) : (console.error("Erreur lors de la rcupration du gateway URL:", e), e);
  }
}, nU = {
  FOLLOWS: "0x8f9b5dc2e7b8bd12f6762c839830672f1d13c08e72b5f09f194cafc153f2df8a"
  // prdicat --> follows
}, ti = {
  IS_PLAYER_GAMES: {
    predicateId: 0x05f1707d8cb50571d01021f09a664826aa1be2ff43504c0cca55eef87142f84fn,
    // predicat --> is player of !!!
    objectId: 0x5dc0a2335c12343d8e0f71b62a73fbf70d06fcbaf647f57d82a189873ad90da3n
    // object --> games (BossFighters)
  },
  IS_FAIRPLAY: {
    predicateId: 0x2af261bce70c2fc3a1abf882e3e89b23066fcd150bfda27fab69f9f55ed2d9d0n,
    // predicat --> is 
    objectId: 0xc9559c712c264e5f94ce450ed9473c451b6fd01ab6a436a726fbae767cd67b9cn
    // object --> fairplay !!!
  },
  IS_STRONG_BOSS: {
    predicateId: 0x2af261bce70c2fc3a1abf882e3e89b23066fcd150bfda27fab69f9f55ed2d9d0n,
    // predicat --> is 
    objectId: 0x56d28a901a7f2617247f1663b0c25c77ba6403a8141bac43b1e94eb32a2de941n
    // object --> strong boss !!!
  },
  IS_STRONG_FIGHTER: {
    predicateId: 0x2af261bce70c2fc3a1abf882e3e89b23066fcd150bfda27fab69f9f55ed2d9d0n,
    // predicat --> is 
    objectId: 0xc8433466cda62c0e8bb4fc5433f3faa51949072d6c7b0df50a595c95fb97f1bbn
    // object --> strong fighter !!!
  },
  IS_PLAYER_GUILD: {
    predicateId: 0x05f1707d8cb50571d01021f09a664826aa1be2ff43504c0cca55eef87142f84fn,
    // predicat --> is player of !!!
    objectId: null
    // Sera dfini dynamiquement en fonction du choix de guilde
  }
}, sU = [
  { id: 0x4320ae619f6a9c9b79ee8e2a9415585aff1c287f0b72b08c049cf7a5780eb08dn, name: "The Alchemists" },
  // id --> The Alchemists !!!
  { id: 0x12d4b4425dcfeaf46af6543e8de0133f22f768a69d56a3aa28662ecb06aa9ca1n, name: "Big Time Warriors" },
  // id --> Big Time Warriors !!!
  { id: 0xd9e1d54c0cb904c23e04caea94f9d0dae00874ec18849ca74a832e94c6de01fan, name: "The NEST" },
  // id --> The NEST !!!
  { id: 0xd473ceacf850609ff8881c398e85e59aadbc315588ca78182313cc1af05a2800n, name: "Clock Work Gamers" },
  // id --> Clock Work Gamers !!!
  { id: 0x14511bc4065a1e7d67ba7d50d4706a8899a148a2e68b55213794c14e347acaaen, name: "Vast Impact Gaming" },
  // id --> Vast Impact Gaming !!!
  { id: 0x93815368a0d207e11be12da396d51dea4e3f8e637fe49f696648feb451f6f9c7n, name: "Kraken Gaming" },
  // id --> Kraken Gaming !!!
  { id: 0x508dee963f045411bd0bf4ab9433f40b72ca4270eb0f31222f299211cffbb0bcn, name: "FAM" }
  // id --> FAM
], aU = ({ src: r }) => {
  const [e, i] = ni.useState(r), [n, s] = ni.useState(!0);
  return ni.useEffect(() => {
    (async () => {
      s(!0);
      try {
        const o = oU(r) ? lU(r) : r;
        i(o);
      } catch (o) {
        console.error("Error loading image:", o);
      } finally {
        s(!1);
      }
    })();
  }, [r]), n ? /* @__PURE__ */ V.jsx("div", { children: "Loading image..." }) : /* @__PURE__ */ V.jsx(
    "img",
    {
      src: e,
      alt: "Preview",
      style: {
        maxWidth: "100%",
        maxHeight: "150px",
        borderRadius: "5px"
      }
    }
  );
}, oU = (r) => r.startsWith("ipfs://"), lU = (r) => r.replace("ipfs://", "https://gateway.pinata.cloud/ipfs/"), uU = ({
  step: r,
  isCreatingAtom: e,
  isCreatingTriples: i,
  creationSuccess: n,
  atomId: s,
  tripleCreated: a,
  walletAddress: o,
  hasExistingAtom: l,
  formData: u,
  handleInputChange: c,
  handleSelectChange: h,
  handleFileUpload: d,
  handleSubmit: p,
  isLoading: f,
  isUploading: m,
  fileInputRef: v
}) => /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
  /* @__PURE__ */ V.jsxs("div", { style: { marginBottom: "20px" }, children: [
    /* @__PURE__ */ V.jsxs(
      "div",
      {
        style: {
          display: "flex",
          justifyContent: "space-between",
          marginBottom: "10px"
        },
        children: [
          /* @__PURE__ */ V.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
            /* @__PURE__ */ V.jsx(
              "div",
              {
                style: {
                  width: "30px",
                  height: "30px",
                  borderRadius: "15px",
                  backgroundColor: e || r > 1 ? "#FFD32A" : "#2e2e40",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  margin: "0 auto",
                  color: e || r > 1 ? "#000" : "#fff"
                },
                children: r > 1 ? "" : "1"
              }
            ),
            /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Atom Creation" })
          ] }),
          /* @__PURE__ */ V.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
            /* @__PURE__ */ V.jsx(
              "div",
              {
                style: {
                  width: "30px",
                  height: "30px",
                  borderRadius: "15px",
                  backgroundColor: i || r > 2 ? "#FFD32A" : "#2e2e40",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  margin: "0 auto",
                  color: i || r > 2 ? "#000" : "#fff"
                },
                children: r > 2 ? "" : "2"
              }
            ),
            /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Triples Creation" })
          ] }),
          /* @__PURE__ */ V.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
            /* @__PURE__ */ V.jsx(
              "div",
              {
                style: {
                  width: "30px",
                  height: "30px",
                  borderRadius: "15px",
                  backgroundColor: r === 3 ? "#4CAF50" : "#2e2e40",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  margin: "0 auto",
                  color: r === 3 ? "#000" : "#fff"
                },
                children: r === 3 ? "" : "3"
              }
            ),
            /* @__PURE__ */ V.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Success" })
          ] })
        ]
      }
    ),
    /* @__PURE__ */ V.jsx(
      "div",
      {
        style: {
          height: "4px",
          backgroundColor: "#2e2e40",
          position: "relative",
          marginBottom: "20px"
        },
        children: /* @__PURE__ */ V.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: 0,
              top: 0,
              height: "100%",
              width: `${(r - 1) * 50}%`,
              backgroundColor: "#FFD32A",
              transition: "width 0.3s ease"
            }
          }
        )
      }
    )
  ] }),
  n ? /* @__PURE__ */ V.jsxs("div", { style: { textAlign: "center", color: "#4CAF50" }, children: [
    /* @__PURE__ */ V.jsx("h3", { style: { color: "#4CAF50", marginBottom: "10px" }, children: "Success!" }),
    /* @__PURE__ */ V.jsx("p", { children: "Your player has been created successfully." }),
    /* @__PURE__ */ V.jsxs("p", { children: [
      "Atom ID: ",
      s
    ] }),
    /* @__PURE__ */ V.jsxs("p", { children: [
      "Triples created: ",
      a ? "Yes" : "No"
    ] }),
    /* @__PURE__ */ V.jsx("p", { children: "This window will close automatically..." })
  ] }) : o ? l ? /* @__PURE__ */ V.jsx("p", { style: { textAlign: "center", color: "#ff4444" }, children: "You already have an atom associated with this wallet" }) : /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
    /* @__PURE__ */ V.jsxs("div", { style: { marginBottom: "15px" }, children: [
      /* @__PURE__ */ V.jsx(
        "label",
        {
          style: {
            display: "block",
            marginBottom: "5px",
            fontSize: "0.9em",
            textAlign: "left"
          },
          children: "Pseudo"
        }
      ),
      /* @__PURE__ */ V.jsx(
        "input",
        {
          type: "text",
          name: "pseudo",
          value: u.pseudo,
          onChange: c,
          placeholder: "Enter your pseudo",
          style: {
            width: "100%",
            padding: "8px",
            backgroundColor: "#1e1e30",
            border: "1px solid #333",
            color: "#fff",
            borderRadius: "4px"
          }
        }
      )
    ] }),
    /* @__PURE__ */ V.jsxs("div", { style: { marginBottom: "15px" }, children: [
      /* @__PURE__ */ V.jsx(
        "label",
        {
          style: {
            display: "block",
            marginBottom: "5px",
            fontSize: "0.9em",
            textAlign: "left"
          },
          children: "User UID"
        }
      ),
      /* @__PURE__ */ V.jsx(
        "input",
        {
          type: "text",
          name: "userId",
          value: u.userId,
          onChange: c,
          placeholder: "Enter your BossFighters UID",
          style: {
            width: "100%",
            padding: "8px",
            backgroundColor: "#1e1e30",
            border: "1px solid #333",
            color: "#fff",
            borderRadius: "4px"
          }
        }
      )
    ] }),
    /* @__PURE__ */ V.jsxs("div", { style: { marginBottom: "15px" }, children: [
      /* @__PURE__ */ V.jsx(
        "label",
        {
          style: {
            display: "block",
            marginBottom: "5px",
            fontSize: "0.9em",
            textAlign: "left"
          },
          children: "Guild (Optional)"
        }
      ),
      /* @__PURE__ */ V.jsxs(
        "select",
        {
          name: "guildId",
          value: u.guildId || "",
          onChange: h,
          style: {
            width: "100%",
            padding: "8px",
            backgroundColor: "#1e1e30",
            border: "1px solid #333",
            color: "#fff",
            borderRadius: "4px"
          },
          children: [
            /* @__PURE__ */ V.jsx("option", { value: "", children: "Select a guild (optional)" }),
            sU.map((y) => /* @__PURE__ */ V.jsx("option", { value: y.id.toString(), children: y.name }, y.id.toString()))
          ]
        }
      )
    ] }),
    /* @__PURE__ */ V.jsxs("div", { style: { marginBottom: "15px" }, children: [
      /* @__PURE__ */ V.jsx(
        "label",
        {
          style: {
            display: "block",
            marginBottom: "5px",
            fontSize: "0.9em",
            textAlign: "left"
          },
          children: "Profile Picture (optional)"
        }
      ),
      /* @__PURE__ */ V.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            gap: "10px"
          },
          children: [
            /* @__PURE__ */ V.jsxs("div", { children: [
              /* @__PURE__ */ V.jsx(
                "button",
                {
                  onClick: () => {
                    var y;
                    return (y = v.current) == null ? void 0 : y.click();
                  },
                  style: {
                    padding: "8px 15px",
                    backgroundColor: "#2e2e40",
                    color: "#fff",
                    border: "1px solid #333",
                    borderRadius: "4px",
                    cursor: "pointer",
                    marginRight: "10px"
                  },
                  disabled: m,
                  children: m ? "Upload in progress..." : "Choose an image"
                }
              ),
              /* @__PURE__ */ V.jsx(
                "input",
                {
                  ref: v,
                  type: "file",
                  accept: "image/*",
                  onChange: d,
                  style: { display: "none" }
                }
              )
            ] }),
            /* @__PURE__ */ V.jsx(
              "p",
              {
                style: { fontSize: "0.8em", color: "#aaa", marginTop: "0px" },
                children: "This image will be used as your player's profile picture."
              }
            ),
            u.image && /* @__PURE__ */ V.jsxs("div", { style: { marginTop: "10px" }, children: [
              /* @__PURE__ */ V.jsx(
                "p",
                {
                  style: {
                    fontSize: "0.8em",
                    color: "#aaa",
                    marginBottom: "5px"
                  },
                  children: "Image preview:"
                }
              ),
              /* @__PURE__ */ V.jsx(aU, { src: u.image })
            ] })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ V.jsx("div", { style: { textAlign: "center" }, children: /* @__PURE__ */ V.jsx(
      "button",
      {
        onClick: p,
        disabled: f || m,
        style: {
          padding: "8px 20px",
          backgroundColor: "#FFD32A",
          color: "#000",
          border: "none",
          borderRadius: "5px",
          cursor: "pointer",
          fontWeight: "bold",
          opacity: f || m ? 0.7 : 1
        },
        children: f ? e ? "Creating atom..." : i ? "Creating triples..." : "Creating in progress..." : "CREATE YOUR PLAYER"
      }
    ) })
  ] }) : /* @__PURE__ */ V.jsx("div", { children: /* @__PURE__ */ V.jsx("p", { style: { textAlign: "center", color: "#ff4444" }, children: "Please connect your wallet first" }) })
] }), cU = async (r) => {
  try {
    if (!cg())
      throw new Error("Vous devez tre connect pour envoyer des donnes  IPFS");
    const { apiUrl: e } = hg(), i = `${e}/ipfs/hash_data`, n = await xi.post(
      i,
      { data: r },
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: h_()
        }
      }
    );
    return {
      ipfsHash: n.data.ipfs_hash,
      httpUrl: n.data.http_url
    };
  } catch (e) {
    throw e instanceof Error && e.message.includes("Configuration Player-map non initialise") ? (console.error("Erreur de configuration Player-map:", e.message), new Error("Erreur de configuration: Initialisez la bibliothque Player-map avec PlayerMapConfig.init() avant utilisation")) : (console.error("Erreur lors du hachage de donnes vers IPFS:", e), e);
  }
}, hU = ({ walletConnected: r, walletAddress: e, publicClient: i }) => ({
  createAtom: async (s) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const a = {
        "@context": "https://schema.org/",
        "@type": "Thing",
        ...s
      };
      a.image && nC(a.image) && (a.image = await rU(a.image));
      const { ipfsHash: o } = await cU(a), l = y2(o);
      console.log("Contract address:", pl), console.log("VALUE_PER_ATOM:", iy.toString()), console.log("Hex data:", l);
      const u = l;
      console.log("Calculating atom ID using keccak256(encodePacked)...");
      const c = a_(ED(["bytes"], [u])), h = BigInt(c);
      console.log("Calculated atom ID:", h.toString()), console.log("Creating atom with createAtoms...");
      const d = await r.writeContract({
        address: pl,
        abi: Wh,
        functionName: "createAtoms",
        args: [
          [u],
          // data: bytes[] - tableau avec un seul lment bytes
          [iy]
          // assets: uint256[] - tableau avec la valeur pour un atome
        ],
        value: iy
      });
      return console.log("Transaction hash:", d), console.log("Atom created successfully with ID:", h.toString()), {
        atomId: h,
        ipfsHash: o
      };
    } catch (a) {
      throw console.error("Error creating atom:", a), a;
    }
  }
}), dU = ({ walletConnected: r, walletAddress: e, publicClient: i }) => {
  const n = async (o, l, u) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const c = i || r;
      return !c || typeof c.readContract != "function" ? (console.warn("No valid read client available to check if triple exists"), !1) : await c.readContract({
        address: pl,
        abi: Wh,
        functionName: "isTriple",
        args: [o, l, u]
      });
    } catch (c) {
      if (console.error("Error checking if triple exists:", c), i && i !== r && typeof i.readContract == "function")
        try {
          return await i.readContract({
            address: pl,
            abi: Wh,
            functionName: "isTriple",
            args: [o, l, u]
          });
        } catch (h) {
          console.error("Second attempt failed when checking if triple exists:", h);
        }
      return !1;
    }
  }, s = async (o) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const l = o.map((f) => `0x${f.subjectId.toString(16).padStart(64, "0")}`), u = o.map((f) => `0x${f.predicateId.toString(16).padStart(64, "0")}`), c = o.map((f) => `0x${f.objectId.toString(16).padStart(64, "0")}`), h = o.map(() => SS), d = await r.writeContract({
        address: pl,
        abi: Wh,
        functionName: "createTriples",
        // Chang de "batchCreateTriple"  "createTriples"
        args: [l, u, c, h],
        // Ajout le paramtre assets
        value: SS * BigInt(o.length)
        // Valeur pour chaque triple
      });
      let p;
      return r.waitForTransactionReceipt ? p = await r.waitForTransactionReceipt({ hash: d }) : d.wait ? p = await d.wait() : await new Promise((f) => setTimeout(f, 3e3)), {
        hash: typeof d == "string" ? d : d.hash,
        receipt: p
      };
    } catch (l) {
      throw console.error("Error batch creating triples:", l), l;
    }
  };
  return {
    checkTripleExists: n,
    batchCreateTriple: s,
    createPlayerTriples: async (o) => {
      const l = [
        {
          subjectId: o,
          predicateId: ti.IS_PLAYER_GAMES.predicateId,
          objectId: ti.IS_PLAYER_GAMES.objectId
        },
        {
          subjectId: o,
          predicateId: ti.IS_FAIRPLAY.predicateId,
          objectId: ti.IS_FAIRPLAY.objectId
        },
        {
          subjectId: o,
          predicateId: ti.IS_STRONG_BOSS.predicateId,
          objectId: ti.IS_STRONG_BOSS.objectId
        },
        {
          subjectId: o,
          predicateId: ti.IS_STRONG_FIGHTER.predicateId,
          objectId: ti.IS_STRONG_FIGHTER.objectId
        }
      ];
      return s(l);
    }
  };
}, pU = (r, e, i) => {
  const { createAtom: n } = hU({ walletConnected: r, walletAddress: e, publicClient: i }), { batchCreateTriple: s } = dU({ walletConnected: r, walletAddress: e, publicClient: i });
  return {
    createPlayer: async (o) => {
      try {
        const l = await n({
          name: o.pseudo,
          description: o.userId,
          image: o.image
        }), u = l.atomId;
        await new Promise((c) => setTimeout(c, 2e3));
        try {
          const c = [
            {
              subjectId: u,
              predicateId: ti.IS_PLAYER_GAMES.predicateId,
              objectId: ti.IS_PLAYER_GAMES.objectId
            },
            {
              subjectId: u,
              predicateId: ti.IS_FAIRPLAY.predicateId,
              objectId: ti.IS_FAIRPLAY.objectId
            },
            {
              subjectId: u,
              predicateId: ti.IS_STRONG_BOSS.predicateId,
              objectId: ti.IS_STRONG_BOSS.objectId
            },
            {
              subjectId: u,
              predicateId: ti.IS_STRONG_FIGHTER.predicateId,
              objectId: ti.IS_STRONG_FIGHTER.objectId
            }
          ];
          o.guildId && c.push({
            subjectId: u,
            predicateId: ti.IS_PLAYER_GUILD.predicateId,
            objectId: o.guildId
          });
          const h = await s(c);
          return {
            atomId: u,
            ipfsHash: l.ipfsHash,
            tripleCreated: !0,
            transactionHash: h.hash
          };
        } catch (c) {
          return console.error("Erreur lors de la cration des triples:", c), {
            atomId: u,
            ipfsHash: l.ipfsHash,
            tripleCreated: !1,
            transactionHash: void 0
          };
        }
      } catch (l) {
        throw console.error("Erreur lors de la cration du joueur:", l), l;
      }
    }
  };
}, sC = ({ walletConnected: r, publicClient: e }) => {
  const [i, n] = Pe(null), s = [13579], a = Number(MD);
  return si(() => {
    (async () => {
      if (!(!r || !e))
        try {
          const l = await e.getChainId();
          n(Number(l));
        } catch (l) {
          console.error("Error checking network:", l), n(null);
        }
    })();
  }, [r, e]), {
    isCorrectNetwork: i !== null && s.includes(i),
    currentChainId: i,
    targetChainId: a,
    allowedChainIds: s
  };
}, aC = ({
  currentChainId: r,
  targetChainId: e,
  allowedChainIds: i = [13579]
}) => {
  const n = (s) => {
    switch (s) {
      case 13579:
        return "Intuition Testnet";
      default:
        return `Chain ID: ${s}`;
    }
  };
  return /* @__PURE__ */ V.jsxs("div", { style: {
    padding: "15px",
    backgroundColor: "#2e2e40",
    borderRadius: "8px",
    margin: "10px 0",
    textAlign: "center"
  }, children: [
    /* @__PURE__ */ V.jsx("p", { style: { color: "#ff4444", marginBottom: "10px" }, children: "You are not on the correct network" }),
    /* @__PURE__ */ V.jsxs("p", { style: { color: "#aaa", fontSize: "0.9em", marginBottom: "10px" }, children: [
      "Current network: ",
      r ? n(r) : "Not connected",
      /* @__PURE__ */ V.jsx("br", {}),
      "Required network: ",
      n(13579)
    ] }),
    /* @__PURE__ */ V.jsx("p", { style: { color: "#fff", fontSize: "0.9em" }, children: "Please switch to Intuition Testnet (13579) in your wallet to continue" })
  ] });
}, oC = ({
  isOpen: r,
  onClose: e,
  walletConnected: i,
  walletAddress: n,
  wagmiConfig: s,
  walletHooks: a
}) => {
  const [o, l] = Pe({
    pseudo: "",
    userId: "",
    image: "",
    guildId: ""
  }), [u, c] = Pe(!1), [h, d] = Pe(!1), [p, f] = Pe(!1), [m, v] = Pe(null), y = s == null ? void 0 : s.publicClient, [g, _] = Pe(!1), x = yr(null), [b, T] = Pe(1), [S, w] = Pe(!1), [A, E] = Pe(!1), [M, N] = Pe(!1), { createPlayer: k } = pU(
    i,
    n || "",
    y
  ), { isCorrectNetwork: U, currentChainId: C, targetChainId: O } = sC({
    walletConnected: i,
    publicClient: s == null ? void 0 : s.publicClient
  });
  si(() => {
    (async () => {
      if (!(!n || !y))
        try {
          const B = yD("AtomCreated(address,address,bytes,uint256)"), z = (await (await fetch("https://testnet.rpc.intuition.systems", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              jsonrpc: "2.0",
              method: "eth_getLogs",
              params: [{
                address: pl,
                topics: [
                  B,
                  n
                ],
                fromBlock: "0x0",
                toBlock: "latest"
              }],
              id: 1
            })
          })).json()).result || [];
          console.log("Found logs:", z.length), c(z.length > 0);
        } catch (B) {
          console.error("Error checking atom ownership:", B), c(!1);
        }
    })();
  }, [n, y]);
  const D = (L) => {
    const { name: B, value: Q } = L.target;
    l((W) => ({
      ...W,
      [B]: Q
    }));
  }, H = (L) => {
    const { name: B, value: Q } = L.target;
    l((W) => ({
      ...W,
      [B]: Q
    }));
  }, j = async (L) => {
    if (!L.target.files || L.target.files.length === 0)
      return;
    const B = L.target.files[0];
    try {
      _(!0);
      const Q = await iU(B);
      l((W) => ({
        ...W,
        image: Q
      })), _(!1);
    } catch (Q) {
      console.error("Error uploading image:", Q), alert("Error uploading image. Please try again."), _(!1);
    }
  }, K = async () => {
    if (!n || !i) {
      alert("Please connect your wallet first");
      return;
    }
    if (u) {
      alert("You already have an atom!");
      return;
    }
    if (!o.pseudo || !o.userId) {
      alert("Please fill in all fields");
      return;
    }
    try {
      d(!0), w(!0), T(1);
      const L = await k({
        pseudo: o.pseudo,
        userId: o.userId,
        image: o.image || void 0,
        guildId: o.guildId ? BigInt(o.guildId) : void 0
      });
      v(L.atomId.toString()), w(!1), T(2), E(!0), await new Promise((B) => setTimeout(B, 1500)), E(!1), N(L.tripleCreated), T(3), f(!0), d(!1), setTimeout(() => {
        e(), window.location.reload();
      }, 3e3);
    } catch (L) {
      console.error("Error creating player:", L), alert("Error creating player. Please try again."), d(!1), w(!1), E(!1);
    }
  };
  return r ? /* @__PURE__ */ V.jsx(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(0, 0, 0, 0.7)",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        zIndex: 1e3
      },
      children: /* @__PURE__ */ V.jsxs(
        "div",
        {
          style: {
            backgroundColor: "#101020",
            color: "#fff",
            padding: "30px",
            borderRadius: "10px",
            maxWidth: "760px",
            width: "90%",
            position: "relative",
            border: "1px solid #FFD32A"
          },
          children: [
            /* @__PURE__ */ V.jsx(
              "div",
              {
                style: {
                  position: "absolute",
                  top: "40px",
                  right: "10px",
                  fontSize: "10px",
                  color: "#666",
                  textAlign: "left",
                  backgroundColor: "rgba(0,0,0,0.3)",
                  padding: "5px",
                  borderRadius: "3px",
                  maxWidth: "200px",
                  overflow: "hidden"
                },
                children: /* @__PURE__ */ V.jsxs("div", { children: [
                  "Wallet:",
                  " ",
                  n ? n.slice(0, 6) + "..." + n.slice(-4) : "Not connected"
                ] })
              }
            ),
            /* @__PURE__ */ V.jsx(
              "button",
              {
                onClick: e,
                style: {
                  position: "absolute",
                  top: "10px",
                  right: "10px",
                  backgroundColor: "transparent",
                  border: "none",
                  fontSize: "20px",
                  color: "#666",
                  cursor: "pointer"
                },
                children: ""
              }
            ),
            /* @__PURE__ */ V.jsx(
              "img",
              {
                src: p2,
                alt: "Intuition Logo",
                style: { width: "100px", marginBottom: "10px" }
              }
            ),
            /* @__PURE__ */ V.jsx(
              "h2",
              {
                style: {
                  fontSize: "1.5em",
                  margin: "0 0 20px 0",
                  textAlign: "center"
                },
                children: "Create Your Player"
              }
            ),
            U ? /* @__PURE__ */ V.jsx(
              uU,
              {
                step: b,
                isCreatingAtom: S,
                isCreatingTriples: A,
                creationSuccess: p,
                atomId: m,
                tripleCreated: M,
                walletAddress: n,
                hasExistingAtom: u,
                formData: o,
                handleInputChange: D,
                handleSelectChange: H,
                handleFileUpload: j,
                handleSubmit: K,
                isLoading: h,
                isUploading: g,
                fileInputRef: x
              }
            ) : /* @__PURE__ */ V.jsx(
              aC,
              {
                currentChainId: C,
                targetChainId: O
              }
            )
          ]
        }
      )
    }
  ) : null;
};
var fU = Object.defineProperty, mU = (r, e, i) => e in r ? fU(r, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : r[e] = i, qh = (r, e, i) => mU(r, typeof e != "symbol" ? e + "" : e, i);
function d_(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var k0 = { exports: {} }, eh = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jS;
function gU() {
  if (jS) return eh;
  jS = 1;
  var r = ni, e = Symbol.for("react.element"), i = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(l, u, c) {
    var h, d = {}, p = null, f = null;
    c !== void 0 && (p = "" + c), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (f = u.ref);
    for (h in u) n.call(u, h) && !a.hasOwnProperty(h) && (d[h] = u[h]);
    if (l && l.defaultProps) for (h in u = l.defaultProps, u) d[h] === void 0 && (d[h] = u[h]);
    return { $$typeof: e, type: l, key: p, ref: f, props: d, _owner: s.current };
  }
  return eh.Fragment = i, eh.jsx = o, eh.jsxs = o, eh;
}
var lp = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VS;
function yU() {
  return VS || (VS = 1, process.env.NODE_ENV !== "production" && function() {
    var r = ni, e = Symbol.for("react.element"), i = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), m = Symbol.iterator, v = "@@iterator";
    function y(R) {
      if (R === null || typeof R != "object")
        return null;
      var J = m && R[m] || R[v];
      return typeof J == "function" ? J : null;
    }
    var g = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(R) {
      {
        for (var J = arguments.length, ce = new Array(J > 1 ? J - 1 : 0), Ce = 1; Ce < J; Ce++)
          ce[Ce - 1] = arguments[Ce];
        x("error", R, ce);
      }
    }
    function x(R, J, ce) {
      {
        var Ce = g.ReactDebugCurrentFrame, Ze = Ce.getStackAddendum();
        Ze !== "" && (J += "%s", ce = ce.concat([Ze]));
        var st = ce.map(function(We) {
          return String(We);
        });
        st.unshift("Warning: " + J), Function.prototype.apply.call(console[R], console, st);
      }
    }
    var b = !1, T = !1, S = !1, w = !1, A = !1, E;
    E = Symbol.for("react.module.reference");
    function M(R) {
      return !!(typeof R == "string" || typeof R == "function" || R === n || R === a || A || R === s || R === c || R === h || w || R === f || b || T || S || typeof R == "object" && R !== null && (R.$$typeof === p || R.$$typeof === d || R.$$typeof === o || R.$$typeof === l || R.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      R.$$typeof === E || R.getModuleId !== void 0));
    }
    function N(R, J, ce) {
      var Ce = R.displayName;
      if (Ce)
        return Ce;
      var Ze = J.displayName || J.name || "";
      return Ze !== "" ? ce + "(" + Ze + ")" : ce;
    }
    function k(R) {
      return R.displayName || "Context";
    }
    function U(R) {
      if (R == null)
        return null;
      if (typeof R.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof R == "function")
        return R.displayName || R.name || null;
      if (typeof R == "string")
        return R;
      switch (R) {
        case n:
          return "Fragment";
        case i:
          return "Portal";
        case a:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case l:
            var J = R;
            return k(J) + ".Consumer";
          case o:
            var ce = R;
            return k(ce._context) + ".Provider";
          case u:
            return N(R, R.render, "ForwardRef");
          case d:
            var Ce = R.displayName || null;
            return Ce !== null ? Ce : U(R.type) || "Memo";
          case p: {
            var Ze = R, st = Ze._payload, We = Ze._init;
            try {
              return U(We(st));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var C = Object.assign, O = 0, D, H, j, K, L, B, Q;
    function W() {
    }
    W.__reactDisabledLog = !0;
    function z() {
      {
        if (O === 0) {
          D = console.log, H = console.info, j = console.warn, K = console.error, L = console.group, B = console.groupCollapsed, Q = console.groupEnd;
          var R = {
            configurable: !0,
            enumerable: !0,
            value: W,
            writable: !0
          };
          Object.defineProperties(console, {
            info: R,
            log: R,
            warn: R,
            error: R,
            group: R,
            groupCollapsed: R,
            groupEnd: R
          });
        }
        O++;
      }
    }
    function X() {
      {
        if (O--, O === 0) {
          var R = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: C({}, R, {
              value: D
            }),
            info: C({}, R, {
              value: H
            }),
            warn: C({}, R, {
              value: j
            }),
            error: C({}, R, {
              value: K
            }),
            group: C({}, R, {
              value: L
            }),
            groupCollapsed: C({}, R, {
              value: B
            }),
            groupEnd: C({}, R, {
              value: Q
            })
          });
        }
        O < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ae = g.ReactCurrentDispatcher, ue;
    function ge(R, J, ce) {
      {
        if (ue === void 0)
          try {
            throw Error();
          } catch (Ze) {
            var Ce = Ze.stack.trim().match(/\n( *(at )?)/);
            ue = Ce && Ce[1] || "";
          }
        return `
` + ue + R;
      }
    }
    var we = !1, Ne;
    {
      var lt = typeof WeakMap == "function" ? WeakMap : Map;
      Ne = new lt();
    }
    function be(R, J) {
      if (!R || we)
        return "";
      {
        var ce = Ne.get(R);
        if (ce !== void 0)
          return ce;
      }
      var Ce;
      we = !0;
      var Ze = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var st;
      st = ae.current, ae.current = null, z();
      try {
        if (J) {
          var We = function() {
            throw Error();
          };
          if (Object.defineProperty(We.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(We, []);
            } catch (Re) {
              Ce = Re;
            }
            Reflect.construct(R, [], We);
          } else {
            try {
              We.call();
            } catch (Re) {
              Ce = Re;
            }
            R.call(We.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Re) {
            Ce = Re;
          }
          R();
        }
      } catch (Re) {
        if (Re && Ce && typeof Re.stack == "string") {
          for (var Ge = Re.stack.split(`
`), I = Ce.stack.split(`
`), G = Ge.length - 1, te = I.length - 1; G >= 1 && te >= 0 && Ge[G] !== I[te]; )
            te--;
          for (; G >= 1 && te >= 0; G--, te--)
            if (Ge[G] !== I[te]) {
              if (G !== 1 || te !== 1)
                do
                  if (G--, te--, te < 0 || Ge[G] !== I[te]) {
                    var se = `
` + Ge[G].replace(" at new ", " at ");
                    return R.displayName && se.includes("<anonymous>") && (se = se.replace("<anonymous>", R.displayName)), typeof R == "function" && Ne.set(R, se), se;
                  }
                while (G >= 1 && te >= 0);
              break;
            }
        }
      } finally {
        we = !1, ae.current = st, X(), Error.prepareStackTrace = Ze;
      }
      var Z = R ? R.displayName || R.name : "", Ee = Z ? ge(Z) : "";
      return typeof R == "function" && Ne.set(R, Ee), Ee;
    }
    function bt(R, J, ce) {
      return be(R, !1);
    }
    function Y(R) {
      var J = R.prototype;
      return !!(J && J.isReactComponent);
    }
    function Gt(R, J, ce) {
      if (R == null)
        return "";
      if (typeof R == "function")
        return be(R, Y(R));
      if (typeof R == "string")
        return ge(R);
      switch (R) {
        case c:
          return ge("Suspense");
        case h:
          return ge("SuspenseList");
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case u:
            return bt(R.render);
          case d:
            return Gt(R.type, J, ce);
          case p: {
            var Ce = R, Ze = Ce._payload, st = Ce._init;
            try {
              return Gt(st(Ze), J, ce);
            } catch {
            }
          }
        }
      return "";
    }
    var Xe = Object.prototype.hasOwnProperty, yt = {}, rt = g.ReactDebugCurrentFrame;
    function Nt(R) {
      if (R) {
        var J = R._owner, ce = Gt(R.type, R._source, J ? J.type : null);
        rt.setExtraStackFrame(ce);
      } else
        rt.setExtraStackFrame(null);
    }
    function nt(R, J, ce, Ce, Ze) {
      {
        var st = Function.call.bind(Xe);
        for (var We in R)
          if (st(R, We)) {
            var Ge = void 0;
            try {
              if (typeof R[We] != "function") {
                var I = Error((Ce || "React class") + ": " + ce + " type `" + We + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof R[We] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw I.name = "Invariant Violation", I;
              }
              Ge = R[We](J, We, Ce, ce, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (G) {
              Ge = G;
            }
            Ge && !(Ge instanceof Error) && (Nt(Ze), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ce || "React class", ce, We, typeof Ge), Nt(null)), Ge instanceof Error && !(Ge.message in yt) && (yt[Ge.message] = !0, Nt(Ze), _("Failed %s type: %s", ce, Ge.message), Nt(null));
          }
      }
    }
    var F = Array.isArray;
    function P(R) {
      return F(R);
    }
    function le(R) {
      {
        var J = typeof Symbol == "function" && Symbol.toStringTag, ce = J && R[Symbol.toStringTag] || R.constructor.name || "Object";
        return ce;
      }
    }
    function Te(R) {
      try {
        return Ae(R), !1;
      } catch {
        return !0;
      }
    }
    function Ae(R) {
      return "" + R;
    }
    function xe(R) {
      if (Te(R))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", le(R)), Ae(R);
    }
    var Je = g.ReactCurrentOwner, Be = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, qe, Pt;
    function Ie(R) {
      if (Xe.call(R, "ref")) {
        var J = Object.getOwnPropertyDescriptor(R, "ref").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return R.ref !== void 0;
    }
    function $e(R) {
      if (Xe.call(R, "key")) {
        var J = Object.getOwnPropertyDescriptor(R, "key").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return R.key !== void 0;
    }
    function ut(R, J) {
      typeof R.ref == "string" && Je.current;
    }
    function ft(R, J) {
      {
        var ce = function() {
          qe || (qe = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "key", {
          get: ce,
          configurable: !0
        });
      }
    }
    function Ye(R, J) {
      {
        var ce = function() {
          Pt || (Pt = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "ref", {
          get: ce,
          configurable: !0
        });
      }
    }
    var Ot = function(R, J, ce, Ce, Ze, st, We) {
      var Ge = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: R,
        key: J,
        ref: ce,
        props: We,
        // Record the component responsible for creating this element.
        _owner: st
      };
      return Ge._store = {}, Object.defineProperty(Ge._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ge, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ce
      }), Object.defineProperty(Ge, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ze
      }), Object.freeze && (Object.freeze(Ge.props), Object.freeze(Ge)), Ge;
    };
    function xt(R, J, ce, Ce, Ze) {
      {
        var st, We = {}, Ge = null, I = null;
        ce !== void 0 && (xe(ce), Ge = "" + ce), $e(J) && (xe(J.key), Ge = "" + J.key), Ie(J) && (I = J.ref, ut(J));
        for (st in J)
          Xe.call(J, st) && !Be.hasOwnProperty(st) && (We[st] = J[st]);
        if (R && R.defaultProps) {
          var G = R.defaultProps;
          for (st in G)
            We[st] === void 0 && (We[st] = G[st]);
        }
        if (Ge || I) {
          var te = typeof R == "function" ? R.displayName || R.name || "Unknown" : R;
          Ge && ft(We, te), I && Ye(We, te);
        }
        return Ot(R, Ge, I, Ze, Ce, Je.current, We);
      }
    }
    var Bt = g.ReactCurrentOwner, ee = g.ReactDebugCurrentFrame;
    function Le(R) {
      if (R) {
        var J = R._owner, ce = Gt(R.type, R._source, J ? J.type : null);
        ee.setExtraStackFrame(ce);
      } else
        ee.setExtraStackFrame(null);
    }
    var de;
    de = !1;
    function Se(R) {
      return typeof R == "object" && R !== null && R.$$typeof === e;
    }
    function ze() {
      {
        if (Bt.current) {
          var R = U(Bt.current.type);
          if (R)
            return `

Check the render method of \`` + R + "`.";
        }
        return "";
      }
    }
    function ke(R) {
      return "";
    }
    var At = {};
    function ri(R) {
      {
        var J = ze();
        if (!J) {
          var ce = typeof R == "string" ? R : R.displayName || R.name;
          ce && (J = `

Check the top-level render call using <` + ce + ">.");
        }
        return J;
      }
    }
    function _i(R, J) {
      {
        if (!R._store || R._store.validated || R.key != null)
          return;
        R._store.validated = !0;
        var ce = ri(J);
        if (At[ce])
          return;
        At[ce] = !0;
        var Ce = "";
        R && R._owner && R._owner !== Bt.current && (Ce = " It was passed a child from " + U(R._owner.type) + "."), Le(R), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ce, Ce), Le(null);
      }
    }
    function Ft(R, J) {
      {
        if (typeof R != "object")
          return;
        if (P(R))
          for (var ce = 0; ce < R.length; ce++) {
            var Ce = R[ce];
            Se(Ce) && _i(Ce, J);
          }
        else if (Se(R))
          R._store && (R._store.validated = !0);
        else if (R) {
          var Ze = y(R);
          if (typeof Ze == "function" && Ze !== R.entries)
            for (var st = Ze.call(R), We; !(We = st.next()).done; )
              Se(We.value) && _i(We.value, J);
        }
      }
    }
    function vr(R) {
      {
        var J = R.type;
        if (J == null || typeof J == "string")
          return;
        var ce;
        if (typeof J == "function")
          ce = J.propTypes;
        else if (typeof J == "object" && (J.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        J.$$typeof === d))
          ce = J.propTypes;
        else
          return;
        if (ce) {
          var Ce = U(J);
          nt(ce, R.props, "prop", Ce, R);
        } else if (J.PropTypes !== void 0 && !de) {
          de = !0;
          var Ze = U(J);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ze || "Unknown");
        }
        typeof J.getDefaultProps == "function" && !J.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function $r(R) {
      {
        for (var J = Object.keys(R.props), ce = 0; ce < J.length; ce++) {
          var Ce = J[ce];
          if (Ce !== "children" && Ce !== "key") {
            Le(R), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ce), Le(null);
            break;
          }
        }
        R.ref !== null && (Le(R), _("Invalid attribute `ref` supplied to `React.Fragment`."), Le(null));
      }
    }
    var Ca = {};
    function Ra(R, J, ce, Ce, Ze, st) {
      {
        var We = M(R);
        if (!We) {
          var Ge = "";
          (R === void 0 || typeof R == "object" && R !== null && Object.keys(R).length === 0) && (Ge += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var I = ke();
          I ? Ge += I : Ge += ze();
          var G;
          R === null ? G = "null" : P(R) ? G = "array" : R !== void 0 && R.$$typeof === e ? (G = "<" + (U(R.type) || "Unknown") + " />", Ge = " Did you accidentally export a JSX literal instead of a component?") : G = typeof R, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", G, Ge);
        }
        var te = xt(R, J, ce, Ze, st);
        if (te == null)
          return te;
        if (We) {
          var se = J.children;
          if (se !== void 0)
            if (Ce)
              if (P(se)) {
                for (var Z = 0; Z < se.length; Z++)
                  Ft(se[Z], R);
                Object.freeze && Object.freeze(se);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ft(se, R);
        }
        if (Xe.call(J, "key")) {
          var Ee = U(R), Re = Object.keys(J).filter(function(gt) {
            return gt !== "key";
          }), Ke = Re.length > 0 ? "{key: someKey, " + Re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Ca[Ee + Ke]) {
            var tt = Re.length > 0 ? "{" + Re.join(": ..., ") + ": ...}" : "{}";
            _(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ke, Ee, tt, Ee), Ca[Ee + Ke] = !0;
          }
        }
        return R === n ? $r(te) : vr(te), te;
      }
    }
    function Mn(R, J, ce) {
      return Ra(R, J, ce, !0);
    }
    function Mo(R, J, ce) {
      return Ra(R, J, ce, !1);
    }
    var Ul = Mo, kl = Mn;
    lp.Fragment = n, lp.jsx = Ul, lp.jsxs = kl;
  }()), lp;
}
process.env.NODE_ENV === "production" ? k0.exports = gU() : k0.exports = yU();
var ne = k0.exports;
const Ei = {
  SUBJECT: "#FFB300",
  // Jaune/orang accessible
  PREDICATE: "#1976D2",
  // Bleu profond accessible
  OBJECT: "#43A047"
  // Vert fonc accessible
}, Pu = (r) => {
  switch (r) {
    case "subject":
      return Ei.SUBJECT;
    case "predicate":
      return Ei.PREDICATE;
    case "object":
      return Ei.OBJECT;
    default:
      return "#444";
  }
}, GS = () => /* @__PURE__ */ ne.jsxs(
  "div",
  {
    style: {
      position: "absolute",
      bottom: 80,
      right: 30,
      zIndex: 1e3,
      background: "#18181b",
      borderRadius: "10px",
      border: "2px solid #ffd32a",
      padding: "16px 24px",
      boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)"
    },
    children: [
      /* @__PURE__ */ ne.jsx(
        "h4",
        {
          style: {
            margin: "0 0 16px 0",
            fontSize: "18px",
            color: "#ffd32a",
            fontWeight: "bold",
            letterSpacing: "0.5px"
          },
          children: "Graph Legend"
        }
      ),
      /* @__PURE__ */ ne.jsxs(
        "ul",
        {
          style: {
            listStyle: "none",
            padding: 0,
            margin: 0,
            display: "flex",
            flexDirection: "column",
            gap: "12px"
          },
          children: [
            /* @__PURE__ */ ne.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ ne.jsx(
                    "span",
                    {
                      style: {
                        width: "20px",
                        height: "20px",
                        backgroundColor: Ei.SUBJECT,
                        borderRadius: "50%",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ ne.jsx("span", { style: { fontSize: "15px" }, children: "Subject" })
                ]
              }
            ),
            /* @__PURE__ */ ne.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ ne.jsx(
                    "span",
                    {
                      style: {
                        width: "20px",
                        height: "20px",
                        backgroundColor: Ei.OBJECT,
                        borderRadius: "4px",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ ne.jsx("span", { style: { fontSize: "15px" }, children: "Object" })
                ]
              }
            ),
            /* @__PURE__ */ ne.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ ne.jsx(
                    "span",
                    {
                      style: {
                        width: "24px",
                        height: "12px",
                        backgroundColor: Ei.PREDICATE,
                        borderRadius: "4px",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ ne.jsx("span", { style: { fontSize: "15px" }, children: "Predicate" })
                ]
              }
            )
          ]
        }
      )
    ]
  }
);
class Vu extends Error {
  constructor(e, i) {
    const n = `${Vu.extractMessage(e)}: ${JSON.stringify({
      response: e,
      request: i
    })}`;
    super(n), qh(this, "response"), qh(this, "request"), Object.setPrototypeOf(this, Vu.prototype), this.response = e, this.request = i, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, Vu);
  }
  static extractMessage(e) {
    var i, n;
    return ((n = (i = e.errors) == null ? void 0 : i[0]) == null ? void 0 : n.message) ?? `GraphQL Error (Code: ${String(e.status)})`;
  }
}
const HS = (r) => r.toUpperCase(), ay = (r) => typeof r == "function" ? r() : r, lC = (r, e) => r.map((i, n) => [i, e[n]]), Bl = (r) => {
  let e = {};
  return r instanceof Headers ? e = vU(r) : Array.isArray(r) ? r.forEach(([i, n]) => {
    i && n !== void 0 && (e[i] = n);
  }) : r && (e = r), e;
}, vU = (r) => {
  const e = {};
  return r.forEach((i, n) => {
    e[n] = i;
  }), e;
}, bU = (r) => {
  try {
    const e = r();
    return xU(e) ? e.catch((i) => WS(i)) : e;
  } catch (e) {
    return WS(e);
  }
}, WS = (r) => r instanceof Error ? r : new Error(String(r)), xU = (r) => typeof r == "object" && r !== null && "then" in r && typeof r.then == "function" && "catch" in r && typeof r.catch == "function" && "finally" in r && typeof r.finally == "function", p_ = (r) => {
  throw new Error(`Unhandled case: ${String(r)}`);
}, zf = (r) => typeof r == "object" && r !== null && !Array.isArray(r), _U = (r, e) => r.documents ? r : {
  documents: r,
  requestHeaders: e,
  signal: void 0
}, TU = (r, e, i) => r.query ? r : {
  query: r,
  variables: e,
  requestHeaders: i,
  signal: void 0
};
function jf(r, e) {
  throw new Error(e);
}
function SU(r) {
  return typeof r == "object" && r !== null;
}
function wU(r, e) {
  throw new Error(
    "Unexpected invariant triggered."
  );
}
const EU = /\r\n|[\n\r]/g;
function F0(r, e) {
  let i = 0, n = 1;
  for (const s of r.body.matchAll(EU)) {
    if (typeof s.index == "number" || wU(), s.index >= e)
      break;
    i = s.index + s[0].length, n += 1;
  }
  return {
    line: n,
    column: e + 1 - i
  };
}
function MU(r) {
  return uC(
    r.source,
    F0(r.source, r.start)
  );
}
function uC(r, e) {
  const i = r.locationOffset.column - 1, n = "".padStart(i) + r.body, s = e.line - 1, a = r.locationOffset.line - 1, o = e.line + a, l = e.line === 1 ? i : 0, u = e.column + l, c = `${r.name}:${o}:${u}
`, h = n.split(/\r\n|[\n\r]/g), d = h[s];
  if (d.length > 120) {
    const p = Math.floor(u / 80), f = u % 80, m = [];
    for (let v = 0; v < d.length; v += 80)
      m.push(d.slice(v, v + 80));
    return c + qS([
      [`${o} |`, m[0]],
      ...m.slice(1, p + 1).map((v) => ["|", v]),
      ["|", "^".padStart(f)],
      ["|", m[p + 1]]
    ]);
  }
  return c + qS([
    // Lines specified like this: ["prefix", "string"],
    [`${o - 1} |`, h[s - 1]],
    [`${o} |`, d],
    ["|", "^".padStart(u)],
    [`${o + 1} |`, h[s + 1]]
  ]);
}
function qS(r) {
  const e = r.filter(([n, s]) => s !== void 0), i = Math.max(...e.map(([n]) => n.length));
  return e.map(([n, s]) => n.padStart(i) + (s ? " " + s : "")).join(`
`);
}
function AU(r) {
  const e = r[0];
  return e == null || "kind" in e || "length" in e ? {
    nodes: e,
    source: r[1],
    positions: r[2],
    path: r[3],
    originalError: r[4],
    extensions: r[5]
  } : e;
}
class f_ extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(e, ...i) {
    var n, s, a;
    const { nodes: o, source: l, positions: u, path: c, originalError: h, extensions: d } = AU(i);
    super(e), this.name = "GraphQLError", this.path = c ?? void 0, this.originalError = h ?? void 0, this.nodes = XS(
      Array.isArray(o) ? o : o ? [o] : void 0
    );
    const p = XS(
      (n = this.nodes) === null || n === void 0 ? void 0 : n.map((m) => m.loc).filter((m) => m != null)
    );
    this.source = l ?? (p == null || (s = p[0]) === null || s === void 0 ? void 0 : s.source), this.positions = u ?? (p == null ? void 0 : p.map((m) => m.start)), this.locations = u && l ? u.map((m) => F0(l, m)) : p == null ? void 0 : p.map((m) => F0(m.source, m.start));
    const f = SU(
      h == null ? void 0 : h.extensions
    ) ? h == null ? void 0 : h.extensions : void 0;
    this.extensions = (a = d ?? f) !== null && a !== void 0 ? a : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), h != null && h.stack ? Object.defineProperty(this, "stack", {
      value: h.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, f_) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let e = this.message;
    if (this.nodes)
      for (const i of this.nodes)
        i.loc && (e += `

` + MU(i.loc));
    else if (this.source && this.locations)
      for (const i of this.locations)
        e += `

` + uC(this.source, i);
    return e;
  }
  toJSON() {
    const e = {
      message: this.message
    };
    return this.locations != null && (e.locations = this.locations), this.path != null && (e.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (e.extensions = this.extensions), e;
  }
}
function XS(r) {
  return r === void 0 || r.length === 0 ? void 0 : r;
}
function Yi(r, e, i) {
  return new f_(`Syntax Error: ${i}`, {
    source: r,
    positions: [e]
  });
}
class CU {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(e, i, n) {
    this.start = e.start, this.end = i.end, this.startToken = e, this.endToken = i, this.source = n;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class cC {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(e, i, n, s, a, o) {
    this.kind = e, this.start = i, this.end = n, this.line = s, this.column = a, this.value = o, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const hC = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, RU = new Set(Object.keys(hC));
function $S(r) {
  const e = r == null ? void 0 : r.kind;
  return typeof e == "string" && RU.has(e);
}
var tl;
(function(r) {
  r.QUERY = "query", r.MUTATION = "mutation", r.SUBSCRIPTION = "subscription";
})(tl || (tl = {}));
var B0;
(function(r) {
  r.QUERY = "QUERY", r.MUTATION = "MUTATION", r.SUBSCRIPTION = "SUBSCRIPTION", r.FIELD = "FIELD", r.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", r.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", r.INLINE_FRAGMENT = "INLINE_FRAGMENT", r.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", r.SCHEMA = "SCHEMA", r.SCALAR = "SCALAR", r.OBJECT = "OBJECT", r.FIELD_DEFINITION = "FIELD_DEFINITION", r.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", r.INTERFACE = "INTERFACE", r.UNION = "UNION", r.ENUM = "ENUM", r.ENUM_VALUE = "ENUM_VALUE", r.INPUT_OBJECT = "INPUT_OBJECT", r.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(B0 || (B0 = {}));
var pt;
(function(r) {
  r.NAME = "Name", r.DOCUMENT = "Document", r.OPERATION_DEFINITION = "OperationDefinition", r.VARIABLE_DEFINITION = "VariableDefinition", r.SELECTION_SET = "SelectionSet", r.FIELD = "Field", r.ARGUMENT = "Argument", r.FRAGMENT_SPREAD = "FragmentSpread", r.INLINE_FRAGMENT = "InlineFragment", r.FRAGMENT_DEFINITION = "FragmentDefinition", r.VARIABLE = "Variable", r.INT = "IntValue", r.FLOAT = "FloatValue", r.STRING = "StringValue", r.BOOLEAN = "BooleanValue", r.NULL = "NullValue", r.ENUM = "EnumValue", r.LIST = "ListValue", r.OBJECT = "ObjectValue", r.OBJECT_FIELD = "ObjectField", r.DIRECTIVE = "Directive", r.NAMED_TYPE = "NamedType", r.LIST_TYPE = "ListType", r.NON_NULL_TYPE = "NonNullType", r.SCHEMA_DEFINITION = "SchemaDefinition", r.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", r.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", r.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", r.FIELD_DEFINITION = "FieldDefinition", r.INPUT_VALUE_DEFINITION = "InputValueDefinition", r.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", r.UNION_TYPE_DEFINITION = "UnionTypeDefinition", r.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", r.ENUM_VALUE_DEFINITION = "EnumValueDefinition", r.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", r.DIRECTIVE_DEFINITION = "DirectiveDefinition", r.SCHEMA_EXTENSION = "SchemaExtension", r.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", r.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", r.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", r.UNION_TYPE_EXTENSION = "UnionTypeExtension", r.ENUM_TYPE_EXTENSION = "EnumTypeExtension", r.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(pt || (pt = {}));
function z0(r) {
  return r === 9 || r === 32;
}
function ld(r) {
  return r >= 48 && r <= 57;
}
function dC(r) {
  return r >= 97 && r <= 122 || // A-Z
  r >= 65 && r <= 90;
}
function pC(r) {
  return dC(r) || r === 95;
}
function NU(r) {
  return dC(r) || ld(r) || r === 95;
}
function PU(r) {
  var e;
  let i = Number.MAX_SAFE_INTEGER, n = null, s = -1;
  for (let o = 0; o < r.length; ++o) {
    var a;
    const l = r[o], u = IU(l);
    u !== l.length && (n = (a = n) !== null && a !== void 0 ? a : o, s = o, o !== 0 && u < i && (i = u));
  }
  return r.map((o, l) => l === 0 ? o : o.slice(i)).slice(
    (e = n) !== null && e !== void 0 ? e : 0,
    s + 1
  );
}
function IU(r) {
  let e = 0;
  for (; e < r.length && z0(r.charCodeAt(e)); )
    ++e;
  return e;
}
function OU(r, e) {
  const i = r.replace(/"""/g, '\\"""'), n = i.split(/\r\n|[\n\r]/g), s = n.length === 1, a = n.length > 1 && n.slice(1).every((f) => f.length === 0 || z0(f.charCodeAt(0))), o = i.endsWith('\\"""'), l = r.endsWith('"') && !o, u = r.endsWith("\\"), c = l || u, h = (
    // add leading and trailing new lines only if it improves readability
    !s || r.length > 70 || c || a || o
  );
  let d = "";
  const p = s && z0(r.charCodeAt(0));
  return (h && !p || a) && (d += `
`), d += i, (h || c) && (d += `
`), '"""' + d + '"""';
}
var _e;
(function(r) {
  r.SOF = "<SOF>", r.EOF = "<EOF>", r.BANG = "!", r.DOLLAR = "$", r.AMP = "&", r.PAREN_L = "(", r.PAREN_R = ")", r.SPREAD = "...", r.COLON = ":", r.EQUALS = "=", r.AT = "@", r.BRACKET_L = "[", r.BRACKET_R = "]", r.BRACE_L = "{", r.PIPE = "|", r.BRACE_R = "}", r.NAME = "Name", r.INT = "Int", r.FLOAT = "Float", r.STRING = "String", r.BLOCK_STRING = "BlockString", r.COMMENT = "Comment";
})(_e || (_e = {}));
class DU {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(e) {
    const i = new cC(_e.SOF, 0, 0, 0, 0);
    this.source = e, this.lastToken = i, this.token = i, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let e = this.token;
    if (e.kind !== _e.EOF)
      do
        if (e.next)
          e = e.next;
        else {
          const i = UU(this, e.end);
          e.next = i, i.prev = e, e = i;
        }
      while (e.kind === _e.COMMENT);
    return e;
  }
}
function LU(r) {
  return r === _e.BANG || r === _e.DOLLAR || r === _e.AMP || r === _e.PAREN_L || r === _e.PAREN_R || r === _e.SPREAD || r === _e.COLON || r === _e.EQUALS || r === _e.AT || r === _e.BRACKET_L || r === _e.BRACKET_R || r === _e.BRACE_L || r === _e.PIPE || r === _e.BRACE_R;
}
function Ic(r) {
  return r >= 0 && r <= 55295 || r >= 57344 && r <= 1114111;
}
function dg(r, e) {
  return fC(r.charCodeAt(e)) && mC(r.charCodeAt(e + 1));
}
function fC(r) {
  return r >= 55296 && r <= 56319;
}
function mC(r) {
  return r >= 56320 && r <= 57343;
}
function bl(r, e) {
  const i = r.source.body.codePointAt(e);
  if (i === void 0)
    return _e.EOF;
  if (i >= 32 && i <= 126) {
    const n = String.fromCodePoint(i);
    return n === '"' ? `'"'` : `"${n}"`;
  }
  return "U+" + i.toString(16).toUpperCase().padStart(4, "0");
}
function Di(r, e, i, n, s) {
  const a = r.line, o = 1 + i - r.lineStart;
  return new cC(e, i, n, a, o, s);
}
function UU(r, e) {
  const i = r.source.body, n = i.length;
  let s = e;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    switch (a) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++s;
        continue;
      case 10:
        ++s, ++r.line, r.lineStart = s;
        continue;
      case 13:
        i.charCodeAt(s + 1) === 10 ? s += 2 : ++s, ++r.line, r.lineStart = s;
        continue;
      case 35:
        return kU(r, s);
      case 33:
        return Di(r, _e.BANG, s, s + 1);
      case 36:
        return Di(r, _e.DOLLAR, s, s + 1);
      case 38:
        return Di(r, _e.AMP, s, s + 1);
      case 40:
        return Di(r, _e.PAREN_L, s, s + 1);
      case 41:
        return Di(r, _e.PAREN_R, s, s + 1);
      case 46:
        if (i.charCodeAt(s + 1) === 46 && i.charCodeAt(s + 2) === 46)
          return Di(r, _e.SPREAD, s, s + 3);
        break;
      case 58:
        return Di(r, _e.COLON, s, s + 1);
      case 61:
        return Di(r, _e.EQUALS, s, s + 1);
      case 64:
        return Di(r, _e.AT, s, s + 1);
      case 91:
        return Di(r, _e.BRACKET_L, s, s + 1);
      case 93:
        return Di(r, _e.BRACKET_R, s, s + 1);
      case 123:
        return Di(r, _e.BRACE_L, s, s + 1);
      case 124:
        return Di(r, _e.PIPE, s, s + 1);
      case 125:
        return Di(r, _e.BRACE_R, s, s + 1);
      case 34:
        return i.charCodeAt(s + 1) === 34 && i.charCodeAt(s + 2) === 34 ? GU(r, s) : BU(r, s);
    }
    if (ld(a) || a === 45)
      return FU(r, s, a);
    if (pC(a))
      return HU(r, s);
    throw Yi(
      r.source,
      s,
      a === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Ic(a) || dg(i, s) ? `Unexpected character: ${bl(r, s)}.` : `Invalid character: ${bl(r, s)}.`
    );
  }
  return Di(r, _e.EOF, n, n);
}
function kU(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    if (a === 10 || a === 13)
      break;
    if (Ic(a))
      ++s;
    else if (dg(i, s))
      s += 2;
    else
      break;
  }
  return Di(
    r,
    _e.COMMENT,
    e,
    s,
    i.slice(e + 1, s)
  );
}
function FU(r, e, i) {
  const n = r.source.body;
  let s = e, a = i, o = !1;
  if (a === 45 && (a = n.charCodeAt(++s)), a === 48) {
    if (a = n.charCodeAt(++s), ld(a))
      throw Yi(
        r.source,
        s,
        `Invalid number, unexpected digit after 0: ${bl(
          r,
          s
        )}.`
      );
  } else
    s = oy(r, s, a), a = n.charCodeAt(s);
  if (a === 46 && (o = !0, a = n.charCodeAt(++s), s = oy(r, s, a), a = n.charCodeAt(s)), (a === 69 || a === 101) && (o = !0, a = n.charCodeAt(++s), (a === 43 || a === 45) && (a = n.charCodeAt(++s)), s = oy(r, s, a), a = n.charCodeAt(s)), a === 46 || pC(a))
    throw Yi(
      r.source,
      s,
      `Invalid number, expected digit but got: ${bl(
        r,
        s
      )}.`
    );
  return Di(
    r,
    o ? _e.FLOAT : _e.INT,
    e,
    s,
    n.slice(e, s)
  );
}
function oy(r, e, i) {
  if (!ld(i))
    throw Yi(
      r.source,
      e,
      `Invalid number, expected digit but got: ${bl(
        r,
        e
      )}.`
    );
  const n = r.source.body;
  let s = e + 1;
  for (; ld(n.charCodeAt(s)); )
    ++s;
  return s;
}
function BU(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1, a = s, o = "";
  for (; s < n; ) {
    const l = i.charCodeAt(s);
    if (l === 34)
      return o += i.slice(a, s), Di(r, _e.STRING, e, s + 1, o);
    if (l === 92) {
      o += i.slice(a, s);
      const u = i.charCodeAt(s + 1) === 117 ? i.charCodeAt(s + 2) === 123 ? zU(r, s) : jU(r, s) : VU(r, s);
      o += u.value, s += u.size, a = s;
      continue;
    }
    if (l === 10 || l === 13)
      break;
    if (Ic(l))
      ++s;
    else if (dg(i, s))
      s += 2;
    else
      throw Yi(
        r.source,
        s,
        `Invalid character within String: ${bl(
          r,
          s
        )}.`
      );
  }
  throw Yi(r.source, s, "Unterminated string.");
}
function zU(r, e) {
  const i = r.source.body;
  let n = 0, s = 3;
  for (; s < 12; ) {
    const a = i.charCodeAt(e + s++);
    if (a === 125) {
      if (s < 5 || !Ic(n))
        break;
      return {
        value: String.fromCodePoint(n),
        size: s
      };
    }
    if (n = n << 4 | Lh(a), n < 0)
      break;
  }
  throw Yi(
    r.source,
    e,
    `Invalid Unicode escape sequence: "${i.slice(
      e,
      e + s
    )}".`
  );
}
function jU(r, e) {
  const i = r.source.body, n = YS(i, e + 2);
  if (Ic(n))
    return {
      value: String.fromCodePoint(n),
      size: 6
    };
  if (fC(n) && i.charCodeAt(e + 6) === 92 && i.charCodeAt(e + 7) === 117) {
    const s = YS(i, e + 8);
    if (mC(s))
      return {
        value: String.fromCodePoint(n, s),
        size: 12
      };
  }
  throw Yi(
    r.source,
    e,
    `Invalid Unicode escape sequence: "${i.slice(e, e + 6)}".`
  );
}
function YS(r, e) {
  return Lh(r.charCodeAt(e)) << 12 | Lh(r.charCodeAt(e + 1)) << 8 | Lh(r.charCodeAt(e + 2)) << 4 | Lh(r.charCodeAt(e + 3));
}
function Lh(r) {
  return r >= 48 && r <= 57 ? r - 48 : r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : -1;
}
function VU(r, e) {
  const i = r.source.body;
  switch (i.charCodeAt(e + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw Yi(
    r.source,
    e,
    `Invalid character escape sequence: "${i.slice(
      e,
      e + 2
    )}".`
  );
}
function GU(r, e) {
  const i = r.source.body, n = i.length;
  let s = r.lineStart, a = e + 3, o = a, l = "";
  const u = [];
  for (; a < n; ) {
    const c = i.charCodeAt(a);
    if (c === 34 && i.charCodeAt(a + 1) === 34 && i.charCodeAt(a + 2) === 34) {
      l += i.slice(o, a), u.push(l);
      const h = Di(
        r,
        _e.BLOCK_STRING,
        e,
        a + 3,
        // Return a string of the lines joined with U+000A.
        PU(u).join(`
`)
      );
      return r.line += u.length - 1, r.lineStart = s, h;
    }
    if (c === 92 && i.charCodeAt(a + 1) === 34 && i.charCodeAt(a + 2) === 34 && i.charCodeAt(a + 3) === 34) {
      l += i.slice(o, a), o = a + 1, a += 4;
      continue;
    }
    if (c === 10 || c === 13) {
      l += i.slice(o, a), u.push(l), c === 13 && i.charCodeAt(a + 1) === 10 ? a += 2 : ++a, l = "", o = a, s = a;
      continue;
    }
    if (Ic(c))
      ++a;
    else if (dg(i, a))
      a += 2;
    else
      throw Yi(
        r.source,
        a,
        `Invalid character within String: ${bl(
          r,
          a
        )}.`
      );
  }
  throw Yi(r.source, a, "Unterminated string.");
}
function HU(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    if (NU(a))
      ++s;
    else
      break;
  }
  return Di(
    r,
    _e.NAME,
    e,
    s,
    i.slice(e, s)
  );
}
const WU = 10, gC = 2;
function m_(r) {
  return pg(r, []);
}
function pg(r, e) {
  switch (typeof r) {
    case "string":
      return JSON.stringify(r);
    case "function":
      return r.name ? `[function ${r.name}]` : "[function]";
    case "object":
      return qU(r, e);
    default:
      return String(r);
  }
}
function qU(r, e) {
  if (r === null)
    return "null";
  if (e.includes(r))
    return "[Circular]";
  const i = [...e, r];
  if (XU(r)) {
    const n = r.toJSON();
    if (n !== r)
      return typeof n == "string" ? n : pg(n, i);
  } else if (Array.isArray(r))
    return YU(r, i);
  return $U(r, i);
}
function XU(r) {
  return typeof r.toJSON == "function";
}
function $U(r, e) {
  const i = Object.entries(r);
  return i.length === 0 ? "{}" : e.length > gC ? "[" + KU(r) + "]" : "{ " + i.map(
    ([n, s]) => n + ": " + pg(s, e)
  ).join(", ") + " }";
}
function YU(r, e) {
  if (r.length === 0)
    return "[]";
  if (e.length > gC)
    return "[Array]";
  const i = Math.min(WU, r.length), n = r.length - i, s = [];
  for (let a = 0; a < i; ++a)
    s.push(pg(r[a], e));
  return n === 1 ? s.push("... 1 more item") : n > 1 && s.push(`... ${n} more items`), "[" + s.join(", ") + "]";
}
function KU(r) {
  const e = Object.prototype.toString.call(r).replace(/^\[object /, "").replace(/]$/, "");
  if (e === "Object" && typeof r.constructor == "function") {
    const i = r.constructor.name;
    if (typeof i == "string" && i !== "")
      return i;
  }
  return e;
}
const ZU = globalThis.process && // eslint-disable-next-line no-undef
process.env.NODE_ENV === "production", QU = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  ZU ? function(r, e) {
    return r instanceof e;
  } : function(r, e) {
    if (r instanceof e)
      return !0;
    if (typeof r == "object" && r !== null) {
      var i;
      const n = e.prototype[Symbol.toStringTag], s = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in r ? r[Symbol.toStringTag] : (i = r.constructor) === null || i === void 0 ? void 0 : i.name
      );
      if (n === s) {
        const a = m_(r);
        throw new Error(`Cannot use ${n} "${a}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
let yC = class {
  constructor(r, e = "GraphQL request", i = {
    line: 1,
    column: 1
  }) {
    typeof r == "string" || jf(!1, `Body must be a string. Received: ${m_(r)}.`), this.body = r, this.name = e, this.locationOffset = i, this.locationOffset.line > 0 || jf(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || jf(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function JU(r) {
  return QU(r, yC);
}
function ek(r, e) {
  const i = new tk(r, e), n = i.parseDocument();
  return Object.defineProperty(n, "tokenCount", {
    enumerable: !1,
    value: i.tokenCount
  }), n;
}
class tk {
  constructor(e, i = {}) {
    const n = JU(e) ? e : new yC(e);
    this._lexer = new DU(n), this._options = i, this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const e = this.expectToken(_e.NAME);
    return this.node(e, {
      kind: pt.NAME,
      value: e.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: pt.DOCUMENT,
      definitions: this.many(
        _e.SOF,
        this.parseDefinition,
        _e.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(_e.BRACE_L))
      return this.parseOperationDefinition();
    const e = this.peekDescription(), i = e ? this._lexer.lookahead() : this._lexer.token;
    if (i.kind === _e.NAME) {
      switch (i.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (e)
        throw Yi(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (i.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(i);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const e = this._lexer.token;
    if (this.peek(_e.BRACE_L))
      return this.node(e, {
        kind: pt.OPERATION_DEFINITION,
        operation: tl.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const i = this.parseOperationType();
    let n;
    return this.peek(_e.NAME) && (n = this.parseName()), this.node(e, {
      kind: pt.OPERATION_DEFINITION,
      operation: i,
      name: n,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const e = this.expectToken(_e.NAME);
    switch (e.value) {
      case "query":
        return tl.QUERY;
      case "mutation":
        return tl.MUTATION;
      case "subscription":
        return tl.SUBSCRIPTION;
    }
    throw this.unexpected(e);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      _e.PAREN_L,
      this.parseVariableDefinition,
      _e.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: pt.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(_e.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(_e.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const e = this._lexer.token;
    return this.expectToken(_e.DOLLAR), this.node(e, {
      kind: pt.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: pt.SELECTION_SET,
      selections: this.many(
        _e.BRACE_L,
        this.parseSelection,
        _e.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(_e.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const e = this._lexer.token, i = this.parseName();
    let n, s;
    return this.expectOptionalToken(_e.COLON) ? (n = i, s = this.parseName()) : s = i, this.node(e, {
      kind: pt.FIELD,
      alias: n,
      name: s,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(_e.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(e) {
    const i = e ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(_e.PAREN_L, i, _e.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(e = !1) {
    const i = this._lexer.token, n = this.parseName();
    return this.expectToken(_e.COLON), this.node(i, {
      kind: pt.ARGUMENT,
      name: n,
      value: this.parseValueLiteral(e)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const e = this._lexer.token;
    this.expectToken(_e.SPREAD);
    const i = this.expectOptionalKeyword("on");
    return !i && this.peek(_e.NAME) ? this.node(e, {
      kind: pt.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(e, {
      kind: pt.INLINE_FRAGMENT,
      typeCondition: i ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const e = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(e, {
      kind: pt.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(e, {
      kind: pt.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(e) {
    const i = this._lexer.token;
    switch (i.kind) {
      case _e.BRACKET_L:
        return this.parseList(e);
      case _e.BRACE_L:
        return this.parseObject(e);
      case _e.INT:
        return this.advanceLexer(), this.node(i, {
          kind: pt.INT,
          value: i.value
        });
      case _e.FLOAT:
        return this.advanceLexer(), this.node(i, {
          kind: pt.FLOAT,
          value: i.value
        });
      case _e.STRING:
      case _e.BLOCK_STRING:
        return this.parseStringLiteral();
      case _e.NAME:
        switch (this.advanceLexer(), i.value) {
          case "true":
            return this.node(i, {
              kind: pt.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(i, {
              kind: pt.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(i, {
              kind: pt.NULL
            });
          default:
            return this.node(i, {
              kind: pt.ENUM,
              value: i.value
            });
        }
      case _e.DOLLAR:
        if (e)
          if (this.expectToken(_e.DOLLAR), this._lexer.token.kind === _e.NAME) {
            const n = this._lexer.token.value;
            throw Yi(
              this._lexer.source,
              i.start,
              `Unexpected variable "$${n}" in constant value.`
            );
          } else
            throw this.unexpected(i);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const e = this._lexer.token;
    return this.advanceLexer(), this.node(e, {
      kind: pt.STRING,
      value: e.value,
      block: e.kind === _e.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(e) {
    const i = () => this.parseValueLiteral(e);
    return this.node(this._lexer.token, {
      kind: pt.LIST,
      values: this.any(_e.BRACKET_L, i, _e.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(e) {
    const i = () => this.parseObjectField(e);
    return this.node(this._lexer.token, {
      kind: pt.OBJECT,
      fields: this.any(_e.BRACE_L, i, _e.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(e) {
    const i = this._lexer.token, n = this.parseName();
    return this.expectToken(_e.COLON), this.node(i, {
      kind: pt.OBJECT_FIELD,
      name: n,
      value: this.parseValueLiteral(e)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(e) {
    const i = [];
    for (; this.peek(_e.AT); )
      i.push(this.parseDirective(e));
    return i;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(e) {
    const i = this._lexer.token;
    return this.expectToken(_e.AT), this.node(i, {
      kind: pt.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(e)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const e = this._lexer.token;
    let i;
    if (this.expectOptionalToken(_e.BRACKET_L)) {
      const n = this.parseTypeReference();
      this.expectToken(_e.BRACKET_R), i = this.node(e, {
        kind: pt.LIST_TYPE,
        type: n
      });
    } else
      i = this.parseNamedType();
    return this.expectOptionalToken(_e.BANG) ? this.node(e, {
      kind: pt.NON_NULL_TYPE,
      type: i
    }) : i;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: pt.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(_e.STRING) || this.peek(_e.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("schema");
    const n = this.parseConstDirectives(), s = this.many(
      _e.BRACE_L,
      this.parseOperationTypeDefinition,
      _e.BRACE_R
    );
    return this.node(e, {
      kind: pt.SCHEMA_DEFINITION,
      description: i,
      directives: n,
      operationTypes: s
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const e = this._lexer.token, i = this.parseOperationType();
    this.expectToken(_e.COLON);
    const n = this.parseNamedType();
    return this.node(e, {
      kind: pt.OPERATION_TYPE_DEFINITION,
      operation: i,
      type: n
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("scalar");
    const n = this.parseName(), s = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.SCALAR_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("type");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(e, {
      kind: pt.OBJECT_TYPE_DEFINITION,
      description: i,
      name: n,
      interfaces: s,
      directives: a,
      fields: o
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(_e.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      _e.BRACE_L,
      this.parseFieldDefinition,
      _e.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseName(), s = this.parseArgumentDefs();
    this.expectToken(_e.COLON);
    const a = this.parseTypeReference(), o = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.FIELD_DEFINITION,
      description: i,
      name: n,
      arguments: s,
      type: a,
      directives: o
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      _e.PAREN_L,
      this.parseInputValueDef,
      _e.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseName();
    this.expectToken(_e.COLON);
    const s = this.parseTypeReference();
    let a;
    this.expectOptionalToken(_e.EQUALS) && (a = this.parseConstValueLiteral());
    const o = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.INPUT_VALUE_DEFINITION,
      description: i,
      name: n,
      type: s,
      defaultValue: a,
      directives: o
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("interface");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(e, {
      kind: pt.INTERFACE_TYPE_DEFINITION,
      description: i,
      name: n,
      interfaces: s,
      directives: a,
      fields: o
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("union");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseUnionMemberTypes();
    return this.node(e, {
      kind: pt.UNION_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      types: a
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(_e.EQUALS) ? this.delimitedMany(_e.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("enum");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseEnumValuesDefinition();
    return this.node(e, {
      kind: pt.ENUM_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      values: a
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      _e.BRACE_L,
      this.parseEnumValueDefinition,
      _e.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseEnumValueName(), s = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.ENUM_VALUE_DEFINITION,
      description: i,
      name: n,
      directives: s
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw Yi(
        this._lexer.source,
        this._lexer.token.start,
        `${up(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("input");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseInputFieldsDefinition();
    return this.node(e, {
      kind: pt.INPUT_OBJECT_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      fields: a
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      _e.BRACE_L,
      this.parseInputValueDef,
      _e.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const e = this._lexer.lookahead();
    if (e.kind === _e.NAME)
      switch (e.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(e);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const i = this.parseConstDirectives(), n = this.optionalMany(
      _e.BRACE_L,
      this.parseOperationTypeDefinition,
      _e.BRACE_R
    );
    if (i.length === 0 && n.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.SCHEMA_EXTENSION,
      directives: i,
      operationTypes: n
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const i = this.parseName(), n = this.parseConstDirectives();
    if (n.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.SCALAR_TYPE_EXTENSION,
      name: i,
      directives: n
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const i = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.OBJECT_TYPE_EXTENSION,
      name: i,
      interfaces: n,
      directives: s,
      fields: a
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const i = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.INTERFACE_TYPE_EXTENSION,
      name: i,
      interfaces: n,
      directives: s,
      fields: a
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseUnionMemberTypes();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.UNION_TYPE_EXTENSION,
      name: i,
      directives: n,
      types: s
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseEnumValuesDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.ENUM_TYPE_EXTENSION,
      name: i,
      directives: n,
      values: s
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseInputFieldsDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.INPUT_OBJECT_TYPE_EXTENSION,
      name: i,
      directives: n,
      fields: s
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(_e.AT);
    const n = this.parseName(), s = this.parseArgumentDefs(), a = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const o = this.parseDirectiveLocations();
    return this.node(e, {
      kind: pt.DIRECTIVE_DEFINITION,
      description: i,
      name: n,
      arguments: s,
      repeatable: a,
      locations: o
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(_e.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const e = this._lexer.token, i = this.parseName();
    if (Object.prototype.hasOwnProperty.call(B0, i.value))
      return i;
    throw this.unexpected(e);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(e, i) {
    return this._options.noLocation !== !0 && (i.loc = new CU(
      e,
      this._lexer.lastToken,
      this._lexer.source
    )), i;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(e) {
    return this._lexer.token.kind === e;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(e) {
    const i = this._lexer.token;
    if (i.kind === e)
      return this.advanceLexer(), i;
    throw Yi(
      this._lexer.source,
      i.start,
      `Expected ${vC(e)}, found ${up(i)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(e) {
    return this._lexer.token.kind === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(e) {
    const i = this._lexer.token;
    if (i.kind === _e.NAME && i.value === e)
      this.advanceLexer();
    else
      throw Yi(
        this._lexer.source,
        i.start,
        `Expected "${e}", found ${up(i)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(e) {
    const i = this._lexer.token;
    return i.kind === _e.NAME && i.value === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(e) {
    const i = e ?? this._lexer.token;
    return Yi(
      this._lexer.source,
      i.start,
      `Unexpected ${up(i)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(e, i, n) {
    this.expectToken(e);
    const s = [];
    for (; !this.expectOptionalToken(n); )
      s.push(i.call(this));
    return s;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(e, i, n) {
    if (this.expectOptionalToken(e)) {
      const s = [];
      do
        s.push(i.call(this));
      while (!this.expectOptionalToken(n));
      return s;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(e, i, n) {
    this.expectToken(e);
    const s = [];
    do
      s.push(i.call(this));
    while (!this.expectOptionalToken(n));
    return s;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(e, i) {
    this.expectOptionalToken(e);
    const n = [];
    do
      n.push(i.call(this));
    while (this.expectOptionalToken(e));
    return n;
  }
  advanceLexer() {
    const { maxTokens: e } = this._options, i = this._lexer.advance();
    if (i.kind !== _e.EOF && (++this._tokenCounter, e !== void 0 && this._tokenCounter > e))
      throw Yi(
        this._lexer.source,
        i.start,
        `Document contains more that ${e} tokens. Parsing aborted.`
      );
  }
}
function up(r) {
  const e = r.value;
  return vC(r.kind) + (e != null ? ` "${e}"` : "");
}
function vC(r) {
  return LU(r) ? `"${r}"` : r;
}
function ik(r) {
  return `"${r.replace(rk, nk)}"`;
}
const rk = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function nk(r) {
  return sk[r.charCodeAt(0)];
}
const sk = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], ak = Object.freeze({});
function ok(r, e, i = hC) {
  const n = /* @__PURE__ */ new Map();
  for (const g of Object.values(pt))
    n.set(g, lk(e, g));
  let s, a = Array.isArray(r), o = [r], l = -1, u = [], c = r, h, d;
  const p = [], f = [];
  do {
    l++;
    const g = l === o.length, _ = g && u.length !== 0;
    if (g) {
      if (h = f.length === 0 ? void 0 : p[p.length - 1], c = d, d = f.pop(), _)
        if (a) {
          c = c.slice();
          let b = 0;
          for (const [T, S] of u) {
            const w = T - b;
            S === null ? (c.splice(w, 1), b++) : c[w] = S;
          }
        } else {
          c = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(c)
          );
          for (const [b, T] of u)
            c[b] = T;
        }
      l = s.index, o = s.keys, u = s.edits, a = s.inArray, s = s.prev;
    } else if (d) {
      if (h = a ? l : o[l], c = d[h], c == null)
        continue;
      p.push(h);
    }
    let x;
    if (!Array.isArray(c)) {
      var m, v;
      $S(c) || jf(!1, `Invalid AST Node: ${m_(c)}.`);
      const b = g ? (m = n.get(c.kind)) === null || m === void 0 ? void 0 : m.leave : (v = n.get(c.kind)) === null || v === void 0 ? void 0 : v.enter;
      if (x = b == null ? void 0 : b.call(e, c, h, d, p, f), x === ak)
        break;
      if (x === !1) {
        if (!g) {
          p.pop();
          continue;
        }
      } else if (x !== void 0 && (u.push([h, x]), !g))
        if ($S(x))
          c = x;
        else {
          p.pop();
          continue;
        }
    }
    if (x === void 0 && _ && u.push([h, c]), g)
      p.pop();
    else {
      var y;
      s = {
        inArray: a,
        index: l,
        keys: o,
        edits: u,
        prev: s
      }, a = Array.isArray(c), o = a ? c : (y = i[c.kind]) !== null && y !== void 0 ? y : [], l = -1, u = [], d && f.push(d), d = c;
    }
  } while (s !== void 0);
  return u.length !== 0 ? u[u.length - 1][1] : r;
}
function lk(r, e) {
  const i = r[e];
  return typeof i == "object" ? i : typeof i == "function" ? {
    enter: i,
    leave: void 0
  } : {
    enter: r.enter,
    leave: r.leave
  };
}
function uk(r) {
  return ok(r, hk);
}
const ck = 80, hk = {
  Name: {
    leave: (r) => r.value
  },
  Variable: {
    leave: (r) => "$" + r.name
  },
  // Document
  Document: {
    leave: (r) => Qe(r.definitions, `

`)
  },
  OperationDefinition: {
    leave(r) {
      const e = Lt("(", Qe(r.variableDefinitions, ", "), ")"), i = Qe(
        [
          r.operation,
          Qe([r.name, e]),
          Qe(r.directives, " ")
        ],
        " "
      );
      return (i === "query" ? "" : i + " ") + r.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: r, type: e, defaultValue: i, directives: n }) => r + ": " + e + Lt(" = ", i) + Lt(" ", Qe(n, " "))
  },
  SelectionSet: {
    leave: ({ selections: r }) => Cn(r)
  },
  Field: {
    leave({ alias: r, name: e, arguments: i, directives: n, selectionSet: s }) {
      const a = Lt("", r, ": ") + e;
      let o = a + Lt("(", Qe(i, ", "), ")");
      return o.length > ck && (o = a + Lt(`(
`, Vf(Qe(i, `
`)), `
)`)), Qe([o, Qe(n, " "), s], " ");
    }
  },
  Argument: {
    leave: ({ name: r, value: e }) => r + ": " + e
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: r, directives: e }) => "..." + r + Lt(" ", Qe(e, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: r, directives: e, selectionSet: i }) => Qe(
      [
        "...",
        Lt("on ", r),
        Qe(e, " "),
        i
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: r, typeCondition: e, variableDefinitions: i, directives: n, selectionSet: s }) => (
      // or removed in the future.
      `fragment ${r}${Lt("(", Qe(i, ", "), ")")} on ${e} ${Lt("", Qe(n, " "), " ")}` + s
    )
  },
  // Value
  IntValue: {
    leave: ({ value: r }) => r
  },
  FloatValue: {
    leave: ({ value: r }) => r
  },
  StringValue: {
    leave: ({ value: r, block: e }) => e ? OU(r) : ik(r)
  },
  BooleanValue: {
    leave: ({ value: r }) => r ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: r }) => r
  },
  ListValue: {
    leave: ({ values: r }) => "[" + Qe(r, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: r }) => "{" + Qe(r, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: r, value: e }) => r + ": " + e
  },
  // Directive
  Directive: {
    leave: ({ name: r, arguments: e }) => "@" + r + Lt("(", Qe(e, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: r }) => r
  },
  ListType: {
    leave: ({ type: r }) => "[" + r + "]"
  },
  NonNullType: {
    leave: ({ type: r }) => r + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: r, directives: e, operationTypes: i }) => Lt("", r, `
`) + Qe(["schema", Qe(e, " "), Cn(i)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: r, type: e }) => r + ": " + e
  },
  ScalarTypeDefinition: {
    leave: ({ description: r, name: e, directives: i }) => Lt("", r, `
`) + Qe(["scalar", e, Qe(i, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: r, name: e, interfaces: i, directives: n, fields: s }) => Lt("", r, `
`) + Qe(
      [
        "type",
        e,
        Lt("implements ", Qe(i, " & ")),
        Qe(n, " "),
        Cn(s)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: r, name: e, arguments: i, type: n, directives: s }) => Lt("", r, `
`) + e + (KS(i) ? Lt(`(
`, Vf(Qe(i, `
`)), `
)`) : Lt("(", Qe(i, ", "), ")")) + ": " + n + Lt(" ", Qe(s, " "))
  },
  InputValueDefinition: {
    leave: ({ description: r, name: e, type: i, defaultValue: n, directives: s }) => Lt("", r, `
`) + Qe(
      [e + ": " + i, Lt("= ", n), Qe(s, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: r, name: e, interfaces: i, directives: n, fields: s }) => Lt("", r, `
`) + Qe(
      [
        "interface",
        e,
        Lt("implements ", Qe(i, " & ")),
        Qe(n, " "),
        Cn(s)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, types: n }) => Lt("", r, `
`) + Qe(
      ["union", e, Qe(i, " "), Lt("= ", Qe(n, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, values: n }) => Lt("", r, `
`) + Qe(["enum", e, Qe(i, " "), Cn(n)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: r, name: e, directives: i }) => Lt("", r, `
`) + Qe([e, Qe(i, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, fields: n }) => Lt("", r, `
`) + Qe(["input", e, Qe(i, " "), Cn(n)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: r, name: e, arguments: i, repeatable: n, locations: s }) => Lt("", r, `
`) + "directive @" + e + (KS(i) ? Lt(`(
`, Vf(Qe(i, `
`)), `
)`) : Lt("(", Qe(i, ", "), ")")) + (n ? " repeatable" : "") + " on " + Qe(s, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: r, operationTypes: e }) => Qe(
      ["extend schema", Qe(r, " "), Cn(e)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: r, directives: e }) => Qe(["extend scalar", r, Qe(e, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: r, interfaces: e, directives: i, fields: n }) => Qe(
      [
        "extend type",
        r,
        Lt("implements ", Qe(e, " & ")),
        Qe(i, " "),
        Cn(n)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: r, interfaces: e, directives: i, fields: n }) => Qe(
      [
        "extend interface",
        r,
        Lt("implements ", Qe(e, " & ")),
        Qe(i, " "),
        Cn(n)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: r, directives: e, types: i }) => Qe(
      [
        "extend union",
        r,
        Qe(e, " "),
        Lt("= ", Qe(i, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: r, directives: e, values: i }) => Qe(["extend enum", r, Qe(e, " "), Cn(i)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: r, directives: e, fields: i }) => Qe(["extend input", r, Qe(e, " "), Cn(i)], " ")
  }
};
function Qe(r, e = "") {
  var i;
  return (i = r == null ? void 0 : r.filter((n) => n).join(e)) !== null && i !== void 0 ? i : "";
}
function Cn(r) {
  return Lt(`{
`, Vf(Qe(r, `
`)), `
}`);
}
function Lt(r, e, i = "") {
  return e != null && e !== "" ? r + e + i : "";
}
function Vf(r) {
  return Lt("  ", r.replace(/\n/g, `
  `));
}
function KS(r) {
  var e;
  return (e = r == null ? void 0 : r.some((i) => i.includes(`
`))) !== null && e !== void 0 ? e : !1;
}
const ZS = "Accept", j0 = "Content-Type", V0 = "application/json", bC = "application/graphql-response+json", QS = (r) => r.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), dk = (r) => {
  const e = r.toLowerCase();
  return e.includes(bC) || e.includes(V0);
}, JS = (r) => {
  try {
    if (Array.isArray(r))
      return {
        _tag: "Batch",
        executionResults: r.map(e1)
      };
    if (zf(r))
      return {
        _tag: "Single",
        executionResult: e1(r)
      };
    throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(r)}`);
  } catch (e) {
    return e;
  }
}, e1 = (r) => {
  if (typeof r != "object" || r === null)
    throw new Error("Invalid execution result: result is not object");
  let e, i, n;
  if ("errors" in r) {
    if (!zf(r.errors) && !Array.isArray(r.errors))
      throw new Error("Invalid execution result: errors is not plain object OR array");
    e = r.errors;
  }
  if ("data" in r) {
    if (!zf(r.data) && r.data !== null)
      throw new Error("Invalid execution result: data is not plain object");
    i = r.data;
  }
  if ("extensions" in r) {
    if (!zf(r.extensions))
      throw new Error("Invalid execution result: extensions is not plain object");
    n = r.extensions;
  }
  return {
    data: i,
    errors: e,
    extensions: n
  };
}, pk = (r) => r._tag === "Batch" ? r.executionResults.some(t1) : t1(r.executionResult), t1 = (r) => Array.isArray(r.errors) ? r.errors.length > 0 : !!r.errors, xC = (r) => typeof r == "object" && r !== null && "kind" in r && r.kind === pt.OPERATION_DEFINITION, fk = (r) => {
  var e;
  let i;
  const n = r.definitions.filter(xC);
  return n.length === 1 && (i = (e = n[0].name) == null ? void 0 : e.value), i;
}, mk = (r) => {
  let e = !1;
  const i = r.definitions.filter(xC);
  return i.length === 1 && (e = i[0].operation === tl.MUTATION), e;
}, ly = (r, e) => {
  const i = typeof r == "string" ? r : uk(r);
  let n = !1, s;
  if (e)
    return { expression: i, isMutation: n, operationName: s };
  const a = bU(() => typeof r == "string" ? ek(r) : r);
  return a instanceof Error ? { expression: i, isMutation: n, operationName: s } : (s = fk(a), n = mk(a), { expression: i, operationName: s, isMutation: n });
}, g_ = JSON, uy = async (r) => {
  const e = {
    ...r,
    method: r.request._tag === "Single" ? r.request.document.isMutation ? "POST" : HS(r.method ?? "post") : r.request.hasMutations ? "POST" : HS(r.method ?? "post"),
    fetchOptions: {
      ...r.fetchOptions,
      errorPolicy: r.fetchOptions.errorPolicy ?? "none"
    }
  }, i = await yk(e.method)(e);
  if (!i.ok)
    return new Vu({ status: i.status, headers: i.headers }, {
      query: r.request._tag === "Single" ? r.request.document.expression : r.request.query,
      variables: r.request.variables
    });
  const n = await gk(i, r.fetchOptions.jsonSerializer ?? g_);
  if (n instanceof Error)
    throw n;
  const s = {
    status: i.status,
    headers: i.headers
  };
  if (pk(n) && e.fetchOptions.errorPolicy === "none") {
    const a = n._tag === "Batch" ? { ...n.executionResults, ...s } : {
      ...n.executionResult,
      ...s
    };
    return new Vu(a, {
      query: r.request._tag === "Single" ? r.request.document.expression : r.request.query,
      variables: r.request.variables
    });
  }
  switch (n._tag) {
    case "Single":
      return {
        ...s,
        ...i1(e)(n.executionResult)
      };
    case "Batch":
      return {
        ...s,
        data: n.executionResults.map(i1(e))
      };
    default:
      p_(n);
  }
}, i1 = (r) => (e) => ({
  extensions: e.extensions,
  data: e.data,
  errors: r.fetchOptions.errorPolicy === "all" ? e.errors : void 0
}), gk = async (r, e) => {
  const i = r.headers.get(j0), n = await r.text();
  return i && dk(i) ? JS(e.parse(n)) : JS(n);
}, yk = (r) => async (e) => {
  const i = new Headers(e.headers);
  let n = null, s;
  i.has(ZS) || i.set(ZS, [bC, V0].join(", ")), r === "POST" ? (s = (e.fetchOptions.jsonSerializer ?? g_).stringify(vk(e)), typeof s == "string" && !i.has(j0) && i.set(j0, V0)) : n = bk(e);
  const a = { method: r, headers: i, body: s, ...e.fetchOptions };
  let o = new URL(e.url), l = a;
  if (e.middleware) {
    const u = await Promise.resolve(e.middleware({
      ...a,
      url: e.url,
      operationName: e.request._tag === "Single" ? e.request.document.operationName : void 0,
      variables: e.request.variables
    })), { url: c, ...h } = u;
    o = new URL(c), l = h;
  }
  return n && n.forEach((u, c) => {
    o.searchParams.append(c, u);
  }), await (e.fetch ?? fetch)(o, l);
}, vk = (r) => {
  switch (r.request._tag) {
    case "Single":
      return {
        query: r.request.document.expression,
        variables: r.request.variables,
        operationName: r.request.document.operationName
      };
    case "Batch":
      return lC(r.request.query, r.request.variables ?? []).map(([e, i]) => ({
        query: e,
        variables: i
      }));
    default:
      throw p_(r.request);
  }
}, bk = (r) => {
  var e;
  const i = r.fetchOptions.jsonSerializer ?? g_, n = new URLSearchParams();
  switch (r.request._tag) {
    case "Single":
      return n.append("query", QS(r.request.document.expression)), r.request.variables && n.append("variables", i.stringify(r.request.variables)), r.request.document.operationName && n.append("operationName", r.request.document.operationName), n;
    case "Batch": {
      const s = ((e = r.request.variables) == null ? void 0 : e.map((l) => i.stringify(l))) ?? [], a = r.request.query.map(QS), o = lC(a, s).map(([l, u]) => ({
        query: l,
        variables: u
      }));
      return n.append("query", i.stringify(o)), n;
    }
    default:
      throw p_(r.request);
  }
};
class _C {
  constructor(e, i = {}) {
    qh(this, "url"), qh(this, "requestConfig"), qh(this, "rawRequest", async (...n) => {
      const [s, a, o] = n, l = TU(s, a, o), { headers: u, fetch: c = globalThis.fetch, method: h = "POST", requestMiddleware: d, responseMiddleware: p, excludeOperationName: f, ...m } = this.requestConfig, { url: v } = this;
      l.signal !== void 0 && (m.signal = l.signal);
      const y = ly(l.query, f), g = await uy({
        url: v,
        request: {
          _tag: "Single",
          document: y,
          variables: l.variables
        },
        headers: {
          ...Bl(ay(u)),
          ...Bl(l.requestHeaders)
        },
        fetch: c,
        method: h,
        fetchOptions: m,
        middleware: d
      });
      if (p && await p(g, {
        operationName: y.operationName,
        variables: a,
        url: this.url
      }), g instanceof Error)
        throw g;
      return g;
    }), this.url = e, this.requestConfig = i;
  }
  async request(e, ...i) {
    const [n, s] = i, a = xk(e, n, s), { headers: o, fetch: l = globalThis.fetch, method: u = "POST", requestMiddleware: c, responseMiddleware: h, excludeOperationName: d, ...p } = this.requestConfig, { url: f } = this;
    a.signal !== void 0 && (p.signal = a.signal);
    const m = ly(a.document, d), v = await uy({
      url: f,
      request: {
        _tag: "Single",
        document: m,
        variables: a.variables
      },
      headers: {
        ...Bl(ay(o)),
        ...Bl(a.requestHeaders)
      },
      fetch: l,
      method: u,
      fetchOptions: p,
      middleware: c
    });
    if (h && await h(v, {
      operationName: m.operationName,
      variables: a.variables,
      url: this.url
    }), v instanceof Error)
      throw v;
    return v.data;
  }
  async batchRequests(e, i) {
    const n = _U(e, i), { headers: s, excludeOperationName: a, ...o } = this.requestConfig;
    n.signal !== void 0 && (o.signal = n.signal);
    const l = n.documents.map(({ document: p }) => ly(p, a)), u = l.map(({ expression: p }) => p), c = l.some(({ isMutation: p }) => p), h = n.documents.map(({ variables: p }) => p), d = await uy({
      url: this.url,
      request: {
        _tag: "Batch",
        operationName: void 0,
        query: u,
        hasMutations: c,
        variables: h
      },
      headers: {
        ...Bl(ay(s)),
        ...Bl(n.requestHeaders)
      },
      fetch: this.requestConfig.fetch ?? globalThis.fetch,
      method: this.requestConfig.method || "POST",
      fetchOptions: o,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware && await this.requestConfig.responseMiddleware(d, {
      operationName: void 0,
      variables: h,
      url: this.url
    }), d instanceof Error)
      throw d;
    return d.data;
  }
  setHeaders(e) {
    return this.requestConfig.headers = e, this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(e, i) {
    const { headers: n } = this.requestConfig;
    return n ? n[e] = i : this.requestConfig.headers = { [e]: i }, this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(e) {
    return this.url = e, this;
  }
}
const xk = (r, e, i) => r.document ? r : {
  document: r,
  variables: e,
  requestHeaders: i,
  signal: void 0
}, vs = (r, ...e) => r.reduce((i, n, s) => `${i}${n}${s in e ? String(e[s]) : ""}`, ""), TC = {
  base: {
    url: " https://prod.base.intuition-api.com/v1/graphql",
    displayName: "Base Mainnet"
  }
}, jd = (r) => new _C(TC[r].url), _k = async (r, e = "baseSepolia") => {
  const i = jd(e);
  let n;
  n = vs`
    query GetAtom($atomId: numeric!) {
      atom(id: $atomId) {
        id
        image
        label
        emoji
        type
        creator_id
        vault {
          total_shares
        }
      }
    }
  `;
  const s = { atomId: r };
  try {
    return (await i.request(n, s)).atom;
  } catch (a) {
    throw console.error("Error fetching atom details:", a), a;
  }
}, Tk = async (r = "baseSepolia") => {
  const e = jd(r);
  let i, n;
  return i = vs`
    query {
      triples(limit: 1000) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, n = await e.request(i), {
    items: n.triples
  }.items;
}, Sk = async (r, e = "baseSepolia") => {
  const i = jd(e);
  let n, s, a;
  return n = vs`
    query Triples($where: triples_bool_exp) {
      triples(where: $where) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, a = {
    where: {
      _or: [
        {
          predicate_id: {
            _eq: r
          }
        },
        {
          subject_id: {
            _eq: r
          }
        },
        {
          object_id: {
            _eq: r
          }
        }
      ]
    }
  }, s = await i.request(n, a), s.triples;
}, wk = async (r, e = "baseSepolia") => {
  const i = jd(e), n = vs`
    query SearchTriples($where: triples_bool_exp) {
      triples(where: $where) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, s = {
    _and: []
  };
  r.subject && s._and.push({
    subject: {
      label: {
        _ilike: `%${r.subject}%`
      }
    }
  }), r.predicate && s._and.push({
    predicate: {
      label: {
        _ilike: `%${r.predicate}%`
      }
    }
  }), r.object && s._and.push({
    object: {
      label: {
        _ilike: `%${r.object}%`
      }
    }
  });
  const a = {
    where: s._and.length > 0 ? s : {}
  };
  console.log("Executing search query with variables:", a);
  try {
    const o = await i.request(n, a);
    return console.log("Search query response:", o), o.triples;
  } catch (o) {
    throw console.error("Error executing search query:", o), o;
  }
}, Ek = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ENDPOINTS: TC,
  createClient: jd,
  fetchAtomDetails: _k,
  fetchTriples: Tk,
  fetchTriplesForNode: Sk,
  searchTriples: wk
}, Symbol.toStringTag, { value: "Module" })), SC = {
  baseSepolia: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Intuition Testnet"
  },
  base: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Intuition Testnet"
  }
}, Oc = (r) => new _C(SC[r].url), y_ = (r) => ({
  id: r.term_id,
  subject: {
    id: r.subject.term_id,
    label: r.subject.label,
    type: r.subject.type,
    image: r.subject.image
  },
  predicate: {
    id: r.predicate.term_id,
    label: r.predicate.label,
    type: r.predicate.type
  },
  object: {
    id: r.object.term_id,
    label: r.object.label,
    type: r.object.type,
    image: r.object.image
  }
}), Mk = async (r, e = "base") => {
  const i = Oc(e);
  let n;
  n = vs`
    query GetAtom($atomId: String!) {
      atoms(where: { term_id: { _eq: $atomId } }) {
        term_id
        image
        label
        emoji
        type
        creator_id
        term {
          total_market_cap
        }
      }
    }
  `;
  const s = { atomId: r };
  try {
    return (await i.request(n, s)).atoms[0];
  } catch (a) {
    throw console.error("Error fetching atom details:", a), a;
  }
}, wC = async (r = "base") => {
  const e = Oc(r);
  let i, n;
  return i = vs`
    query {
      triples(limit: 1000) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, n = await e.request(i), {
    items: n.triples
  }.items;
}, Ak = async (r, e = "base") => {
  const i = Oc(e);
  let n, s, a;
  return n = vs`
    query Triples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, a = {
    where: {
      _or: [
        {
          predicate_id: {
            _eq: r
          }
        },
        {
          subject_id: {
            _eq: r
          }
        },
        {
          object_id: {
            _eq: r
          }
        }
      ]
    }
  }, s = await i.request(n, a), s.triples.map(y_);
}, Ck = async (r, e = "base") => {
  const i = Oc(e), n = vs`
    query SearchTriples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, s = {
    _and: []
  };
  r.subject && s._and.push({
    subject: {
      label: {
        _ilike: `%${r.subject}%`
      }
    }
  }), r.predicate && s._and.push({
    predicate: {
      label: {
        _ilike: `%${r.predicate}%`
      }
    }
  }), r.object && s._and.push({
    object: {
      label: {
        _ilike: `%${r.object}%`
      }
    }
  });
  const a = {
    where: s._and.length > 0 ? s : {}
  };
  try {
    return (await i.request(n, a)).triples.map(y_);
  } catch (o) {
    throw console.error("Error executing search query:", o), o;
  }
}, EC = async (r, e = "base", i = 1e3) => {
  const n = Oc(e), s = vs`
    query Triples_for_Agent($objectId: String!, $batchSize: Int!) {
      triples(limit: $batchSize, where: { object_id: { _eq: $objectId } }) {
        term_id
        subject {
          term_id
          label
          type
          image
        }
        predicate {
          term_id
          label
          type
          image
        }
        object {
          term_id
          label
          type
          image
        }
      }
    }
  `, a = vs`
    query Relations_for_Subject($subjectId: String!) {
      triples(where: { subject_id: { _eq: $subjectId } }) {
        term_id
        subject {
          term_id
          label
          type
          image
        }
        predicate {
          term_id
          label
          type
          image
        }
        object {
          term_id
          label
          type
          image
        }
      }
    }
  `, o = {
    batchSize: i,
    objectId: String(r)
  };
  try {
    const l = (await n.request(s, o)).triples, u = [...new Set(l.map((h) => h.subject.term_id))].map(
      (h) => n.request(a, { subjectId: h })
    ), c = (await Promise.all(u)).flatMap((h) => h.triples);
    return [...l, ...c].map(y_);
  } catch (l) {
    return console.error("Error fetching agent-specific triples:", l), wC(e).then((u) => u.filter(
      (c) => c.subject.term_id === r || c.object.term_id === r || c.predicate.term_id === r
    )).catch((u) => {
      throw console.error("Fallback fetch also failed:", u), l;
    });
  }
}, r1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ENDPOINTS: SC,
  createClient: Oc,
  fetchAtomDetails: Mk,
  fetchTriples: wC,
  fetchTriplesForAgent: EC,
  fetchTriplesForNode: Ak,
  searchTriples: Ck
}, Symbol.toStringTag, { value: "Module" })), cy = {
  railsMockApi: {
    url: "https://api-i7n.thp-lab.org/api/v1/graph",
    displayName: "[OffChain] Playground API",
    module: Ek
    // Default to Base module for railsMockApi
  },
  baseSepolia: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Base Testnet",
    module: r1
  },
  base: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Base Mainnet",
    module: r1
  }
}, fg = (r) => {
  if (!cy[r] || !cy[r].module)
    throw new Error(`No module defined for endpoint '${r}'.`);
  return cy[r].module;
}, v_ = async (r = "base") => {
  const e = fg(r);
  try {
    return e.fetchTriples(r);
  } catch (i) {
    throw console.error(`Error fetching triples for endpoint ${r}:`, i), i;
  }
}, Rk = async (r, e = "base") => {
  const i = fg(e);
  try {
    return i.fetchTriplesForNode(r, e);
  } catch (n) {
    throw console.error(
      `Error fetching triples for node ${r} with endpoint ${e}:`,
      n
    ), n;
  }
}, Nk = async (r, e = "base") => {
  const i = fg(e);
  try {
    return i.fetchAtomDetails(r, e);
  } catch (n) {
    throw console.error(
      `Error fetching atom details for ${r} with endpoint ${e}:`,
      n
    ), n;
  }
}, Iu = async (r, e = "base") => {
  const i = fg(e);
  try {
    return i.searchTriples(r, e);
  } catch (n) {
    throw console.error(`Error searching triples with endpoint ${e}:`, n), n;
  }
}, Pk = async (r, e = "baseSepolia", i = 1e3) => EC(r, e, i), b_ = ({ triple: r, endpoint: e, onClose: i }) => {
  var n;
  const [s, a] = Pe(null), [o, l] = Pe(null), [u, c] = Pe(!1), [h, d] = Pe(null);
  si(() => {
    r && (c(!0), d(null), l(null), (async () => {
      try {
        const v = (await v_(e)).filter(
          (y) => {
            var g, _, x;
            return y.id === r.id || ((g = y.subject) == null ? void 0 : g.id) === r.id || ((_ = y.predicate) == null ? void 0 : _.id) === r.id || ((x = y.object) == null ? void 0 : x.id) === r.id;
          }
        );
        if (a(v), r.id) {
          const y = await Nk(
            r.id,
            e
          );
          l(y);
        }
      } catch (v) {
        console.error("Error fetching sidebar data:", v), d("Failed to fetch data");
      } finally {
        c(!1);
      }
    })());
  }, [r, e]);
  const p = (v) => `${(v / 1e18).toFixed(4)} ETH`;
  if (!r)
    return null;
  const f = (v, y = 4, g = 4) => !v || v.length <= y + g ? v : `${v.slice(0, y)}...${v.slice(-g)}`, m = async (v) => {
    try {
      await navigator.clipboard.writeText(v), console.log("ID copied:", v);
    } catch (y) {
      console.error("Error copying ID:", y);
    }
  };
  return /* @__PURE__ */ ne.jsxs(
    "div",
    {
      style: {
        background: "#18181b",
        borderRadius: "10px",
        border: "2px solid #ffd32a",
        padding: "24px",
        boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
        color: "#fff",
        maxWidth: "400px",
        width: "100%"
      },
      children: [
        /* @__PURE__ */ ne.jsxs(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              marginBottom: "24px"
            },
            children: [
              /* @__PURE__ */ ne.jsx(
                "h2",
                {
                  style: {
                    margin: 0,
                    fontSize: "24px",
                    color: "#ffd32a",
                    fontWeight: "bold",
                    letterSpacing: "0.5px"
                  },
                  children: r.label || "No Label"
                }
              ),
              /* @__PURE__ */ ne.jsx(
                "button",
                {
                  onClick: i,
                  style: {
                    background: "none",
                    border: "none",
                    color: "#ffd32a",
                    fontSize: "24px",
                    cursor: "pointer",
                    padding: "4px",
                    lineHeight: 1
                  },
                  children: ""
                }
              )
            ]
          }
        ),
        o && o.image && /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "center",
              margin: "24px 0"
            },
            children: /* @__PURE__ */ ne.jsx(
              "img",
              {
                src: o.image,
                alt: o.label || "Node image",
                style: {
                  width: "120px",
                  height: "120px",
                  borderRadius: "50%",
                  objectFit: "cover",
                  border: "3px solid #ffd32a",
                  boxShadow: "0 4px 12px rgba(0,0,0,0.2)"
                }
              }
            )
          }
        ),
        u && /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              textAlign: "center",
              padding: "20px",
              color: "#ffd32a"
            },
            children: "Loading..."
          }
        ),
        h && /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              color: "#ff4444",
              padding: "12px",
              background: "rgba(255,68,68,0.1)",
              borderRadius: "8px",
              marginBottom: "16px"
            },
            children: h
          }
        ),
        o && /* @__PURE__ */ ne.jsxs(
          "div",
          {
            style: {
              background: "#232326",
              borderRadius: "8px",
              padding: "16px",
              marginBottom: "24px"
            },
            children: [
              /* @__PURE__ */ ne.jsx(
                "h4",
                {
                  style: {
                    color: "#ffd32a",
                    margin: "0 0 16px 0",
                    fontSize: "18px",
                    fontWeight: "bold"
                  },
                  children: "Atom Info"
                }
              ),
              /* @__PURE__ */ ne.jsxs(
                "div",
                {
                  style: {
                    display: "grid",
                    gap: "12px"
                  },
                  children: [
                    /* @__PURE__ */ ne.jsxs("div", { children: [
                      /* @__PURE__ */ ne.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "ID:" }),
                      " ",
                      /* @__PURE__ */ ne.jsx(
                        "span",
                        {
                          style: {
                            cursor: "pointer",
                            textDecoration: "underline",
                            color: "#ffd32a"
                          },
                          onClick: () => m(o.term_id),
                          title: `Cliquer pour copier: ${o.term_id}`,
                          children: f(o.term_id)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ ne.jsxs("div", { children: [
                      /* @__PURE__ */ ne.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Label:" }),
                      " ",
                      o.label
                    ] }),
                    /* @__PURE__ */ ne.jsxs("div", { children: [
                      /* @__PURE__ */ ne.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Type:" }),
                      " ",
                      o.type
                    ] }),
                    /* @__PURE__ */ ne.jsxs("div", { children: [
                      /* @__PURE__ */ ne.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Creator:" }),
                      " ",
                      /* @__PURE__ */ ne.jsx(
                        "span",
                        {
                          style: {
                            cursor: "pointer",
                            textDecoration: "underline",
                            color: "#ffd32a"
                          },
                          onClick: () => m(o.creator_id),
                          title: `Cliquer pour copier: ${o.creator_id}`,
                          children: f(o.creator_id)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ ne.jsxs("div", { children: [
                      /* @__PURE__ */ ne.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Vault Shares:" }),
                      " ",
                      p(((n = o.vault) == null ? void 0 : n.total_shares) || 0)
                    ] })
                  ]
                }
              )
            ]
          }
        ),
        s && s.length > 0 && /* @__PURE__ */ ne.jsxs(
          "div",
          {
            style: {
              background: "#232326",
              borderRadius: "8px",
              padding: "16px"
            },
            children: [
              /* @__PURE__ */ ne.jsx(
                "h4",
                {
                  style: {
                    color: "#ffd32a",
                    margin: "0 0 16px 0",
                    fontSize: "18px",
                    fontWeight: "bold"
                  },
                  children: "Related Data"
                }
              ),
              /* @__PURE__ */ ne.jsx(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: "12px"
                  },
                  children: s.map((v) => {
                    var y, g, _;
                    return /* @__PURE__ */ ne.jsxs(
                      "div",
                      {
                        style: {
                          padding: "12px",
                          background: "#18181b",
                          borderRadius: "6px",
                          border: "1px solid #ffd32a33"
                        },
                        children: [
                          /* @__PURE__ */ ne.jsxs("div", { children: [
                            /* @__PURE__ */ ne.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Subject:" }),
                            " ",
                            (y = v.subject) == null ? void 0 : y.label
                          ] }),
                          /* @__PURE__ */ ne.jsxs("div", { children: [
                            /* @__PURE__ */ ne.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Predicate:" }),
                            " ",
                            (g = v.predicate) == null ? void 0 : g.label
                          ] }),
                          /* @__PURE__ */ ne.jsxs("div", { children: [
                            /* @__PURE__ */ ne.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Object:" }),
                            " ",
                            (_ = v.object) == null ? void 0 : _.label
                          ] })
                        ]
                      },
                      v.id
                    );
                  })
                }
              )
            ]
          }
        ),
        !u && !(s != null && s.length) && /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              textAlign: "center",
              padding: "20px",
              color: "#888",
              background: "#232326",
              borderRadius: "8px"
            },
            children: "No additional related data found."
          }
        )
      ]
    }
  );
}, Ik = ({ graphData: r, onNodeClick: e, onBack: i, onForward: n, selectedTriple: s, endpoint: a }) => {
  const o = yr(), l = yr(), [u, c] = Pe({ width: 100, height: 100 });
  return si(() => {
    const h = () => {
      o.current && c({
        width: o.current.clientWidth,
        height: o.current.clientHeight
      });
    };
    return h(), window.addEventListener("resize", h), () => window.removeEventListener("resize", h);
  }, []), si(() => {
    if (l.current && u.width > 0 && u.height > 0) {
      const h = d2()(l.current);
      h.width(u.width).height(u.height).graphData(r).nodeLabel((d) => d.label || d.id).nodeAutoColorBy("group"), e && h.onNodeClick((d) => {
        console.log("VR Node clicked inside Graph:", d), e(d);
      });
    }
  }, [r, e, u]), /* @__PURE__ */ ne.jsxs(
    "div",
    {
      ref: o,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ ne.jsx(
          "div",
          {
            ref: l,
            style: { width: "100%", height: "100%" }
          }
        ),
        /* @__PURE__ */ ne.jsxs("div", { style: { position: "absolute", bottom: 20, left: 20, zIndex: 100 }, children: [
          /* @__PURE__ */ ne.jsx(
            "button",
            {
              onClick: i,
              style: {
                background: "#ffd32a",
                color: "#18181b",
                border: "none",
                borderRadius: 8,
                padding: "10px 20px",
                marginRight: 10,
                cursor: "pointer",
                fontWeight: "bold"
              },
              children: "Back"
            }
          ),
          /* @__PURE__ */ ne.jsx(
            "button",
            {
              onClick: n,
              style: {
                background: "#ffd32a",
                color: "#18181b",
                border: "none",
                borderRadius: 8,
                padding: "10px 20px",
                cursor: "pointer",
                fontWeight: "bold"
              },
              children: "Forward"
            }
          )
        ] }),
        s && /* @__PURE__ */ ne.jsx("div", { style: {
          position: "absolute",
          top: 80,
          right: 30,
          width: 350,
          zIndex: 9999,
          maxHeight: "80vh",
          background: "#18181b",
          borderRadius: "10px",
          border: "3px solid #ffd32a",
          boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
          overflowY: "auto"
        }, children: /* @__PURE__ */ ne.jsx(
          b_,
          {
            triple: s,
            endpoint: a,
            onClose: () => e(null)
          }
        ) })
      ]
    }
  );
}, MC = () => {
  const [r, e] = Pe([]), i = 200;
  si(() => {
    let s;
    const a = () => {
      const o = Date.now() / 1e3, l = [];
      for (let u = 0; u < 3; u++) {
        const c = o * 0.8 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 150 + 200,
          y: Math.sin(c) * 150 + 200,
          color: "#00fff2"
        });
      }
      for (let u = 0; u < 3; u++) {
        const c = -o * 1.2 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 100 + 200,
          y: Math.sin(c) * 100 + 200,
          color: "#ff00ff"
        });
      }
      for (let u = 0; u < 3; u++) {
        const c = o * 1.5 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 50 + 200,
          y: Math.sin(c) * 50 + 200,
          color: "#ffff00"
        });
      }
      e(l), s = requestAnimationFrame(a);
    };
    return a(), () => cancelAnimationFrame(s);
  }, []);
  const n = r.flatMap(
    (s, a) => r.slice(a + 1).map((o, l) => {
      const u = o.x - s.x, c = o.y - s.y, h = Math.sqrt(u * u + c * c);
      if (h < i) {
        const d = 1 - h / i;
        return {
          x1: s.x,
          y1: s.y,
          x2: o.x,
          y2: o.y,
          opacity: d * 0.8,
          // Slightly reduce max opacity for subtler effect
          gradient: `link-gradient-${a}-${l}`,
          color1: s.color,
          color2: o.color
        };
      }
      return null;
    }).filter(Boolean)
  );
  return /* @__PURE__ */ ne.jsxs("div", { style: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    alignItems: "center",
    background: "rgba(0, 0, 0, 0.9)",
    zIndex: 1e3,
    overflow: "hidden"
  }, children: [
    /* @__PURE__ */ ne.jsxs("div", { style: {
      position: "relative",
      width: "400px",
      height: "400px",
      display: "flex",
      flexDirection: "column",
      alignItems: "center"
    }, children: [
      /* @__PURE__ */ ne.jsxs("svg", { width: "400", height: "400", children: [
        /* @__PURE__ */ ne.jsx("defs", { children: n.map((s) => /* @__PURE__ */ ne.jsxs(
          "linearGradient",
          {
            id: s.gradient,
            x1: "0%",
            y1: "0%",
            x2: "100%",
            y2: "0%",
            children: [
              /* @__PURE__ */ ne.jsx("stop", { offset: "0%", stopColor: s.color1, stopOpacity: s.opacity }),
              /* @__PURE__ */ ne.jsx("stop", { offset: "100%", stopColor: s.color2, stopOpacity: s.opacity })
            ]
          },
          s.gradient
        )) }),
        n.map((s, a) => /* @__PURE__ */ ne.jsx(
          "line",
          {
            x1: s.x1,
            y1: s.y1,
            x2: s.x2,
            y2: s.y2,
            stroke: `url(#${s.gradient})`,
            strokeWidth: "3",
            style: {
              filter: "brightness(1.5) blur(1px)"
            }
          },
          a
        ))
      ] }),
      /* @__PURE__ */ ne.jsx("div", { style: {
        color: "#00fff2",
        fontSize: "40px",
        fontFamily: "sans-serif",
        letterSpacing: "-2px",
        textShadow: `
            0 0 5px #00fff2,
            0 0 10px #00fff2,
            0 0 20px #00fff2,
            0 0 40px #00fff2
          `,
        animation: "textPulse 1.5s ease-in-out infinite",
        whiteSpace: "nowrap",
        marginTop: "20px"
      }, children: "Connecting I7n Dots..." })
    ] }),
    /* @__PURE__ */ ne.jsx("style", { children: `
          @keyframes textPulse {
            0% { 
              opacity: 0.5;
              transform: scale(0.98) translateY(0);
            }
            50% { 
              opacity: 1;
              transform: scale(1.02) translateY(-5px);
            }
            100% { 
              opacity: 0.5;
              transform: scale(0.98) translateY(0);
            }
          }
        ` })
  ] });
}, Ok = ({
  subjectFilter: r,
  predicateFilter: e,
  objectFilter: i,
  onFilterChange: n,
  onReset: s,
  onClose: a
}) => /* @__PURE__ */ ne.jsxs(
  "div",
  {
    style: {
      display: "flex",
      flexDirection: "column",
      background: "#18181b",
      padding: "16px 24px",
      borderRadius: "10px",
      border: "2px solid #ffd32a",
      boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
      position: "relative"
    },
    children: [
      /* @__PURE__ */ ne.jsx(
        "button",
        {
          onClick: a,
          style: {
            position: "absolute",
            top: 4,
            right: 6,
            background: "none",
            border: "none",
            color: "#ffd32a",
            fontSize: 20,
            cursor: "pointer",
            padding: 0,
            lineHeight: 1,
            width: 24,
            height: 24,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            zIndex: 2
          },
          "aria-label": "Close filters",
          children: ""
        }
      ),
      /* @__PURE__ */ ne.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: [
        /* @__PURE__ */ ne.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ ne.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Subject"
            }
          ),
          /* @__PURE__ */ ne.jsx(
            "input",
            {
              type: "text",
              value: r,
              onChange: (o) => n("subject", o.target.value),
              placeholder: "Filter by subject...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ ne.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ ne.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Predicate"
            }
          ),
          /* @__PURE__ */ ne.jsx(
            "input",
            {
              type: "text",
              value: e,
              onChange: (o) => n("predicate", o.target.value),
              placeholder: "Filter by predicate...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ ne.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ ne.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Object"
            }
          ),
          /* @__PURE__ */ ne.jsx(
            "input",
            {
              type: "text",
              value: i,
              onChange: (o) => n("object", o.target.value),
              placeholder: "Filter by object...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ ne.jsx(
          "button",
          {
            style: {
              background: "#ffd32a",
              color: "#18181b",
              border: "none",
              borderRadius: "8px",
              padding: "8px 24px",
              fontSize: "14px",
              fontWeight: "bold",
              cursor: "pointer",
              textTransform: "uppercase",
              transition: "background 0.2s, transform 0.1s",
              alignSelf: "flex-start",
              marginTop: "8px",
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
            },
            onMouseEnter: (o) => {
              o.currentTarget.style.background = "#ffe066", o.currentTarget.style.transform = "translateY(-1px)";
            },
            onMouseLeave: (o) => {
              o.currentTarget.style.background = "#ffd32a", o.currentTarget.style.transform = "translateY(0)";
            },
            onClick: s,
            children: "Reset"
          }
        )
      ] })
    ]
  }
);
function Dk(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e === 0) {
        if (Object(i) !== i) return;
        u = !1;
      } else for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function Lk(r, e, i) {
  return e = Gk(e), e in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function n1(r, e) {
  return Fk(r) || Dk(r, e) || AC(r, e) || jk();
}
function Uk(r) {
  return kk(r) || Bk(r) || AC(r) || zk();
}
function kk(r) {
  if (Array.isArray(r)) return G0(r);
}
function Fk(r) {
  if (Array.isArray(r)) return r;
}
function Bk(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function AC(r, e) {
  if (r) {
    if (typeof r == "string") return G0(r, e);
    var i = Object.prototype.toString.call(r).slice(8, -1);
    if (i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set") return Array.from(r);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return G0(r, e);
  }
}
function G0(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = new Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function zk() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function jk() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Vk(r, e) {
  if (typeof r != "object" || r === null) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Gk(r) {
  var e = Vk(r, "string");
  return typeof e == "symbol" ? e : String(e);
}
var Hk = function(r, e) {
  var i = new Set(e);
  return Object.assign.apply(Object, [{}].concat(Uk(Object.entries(r).filter(function(n) {
    var s = n1(n, 1), a = s[0];
    return !i.has(a);
  }).map(function(n) {
    var s = n1(n, 2), a = s[0], o = s[1];
    return Lk({}, a, o);
  }))));
};
function H0(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Wk(r) {
  if (Array.isArray(r)) return r;
}
function qk(r) {
  if (Array.isArray(r)) return H0(r);
}
function Xk(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function $k(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function Yk() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Kk() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Zk(r, e) {
  return Wk(r) || $k(r, e) || CC(r, e) || Yk();
}
function s1(r) {
  return qk(r) || Xk(r) || CC(r) || Kk();
}
function CC(r, e) {
  if (r) {
    if (typeof r == "string") return H0(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? H0(r, e) : void 0;
  }
}
function mg(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = e.wrapperElementType, n = i === void 0 ? "div" : i, s = e.nodeMapper, a = s === void 0 ? function(h) {
    return h;
  } : s, o = e.methodNames, l = o === void 0 ? [] : o, u = e.initPropNames, c = u === void 0 ? [] : u;
  return /* @__PURE__ */ b3(function(h, d) {
    var p = yr(), f = x3(function() {
      var y = Object.fromEntries(c.filter(function(g) {
        return h.hasOwnProperty(g);
      }).map(function(g) {
        return [g, h[g]];
      }));
      return r(y);
    }, []);
    a1(function() {
      f(a(p.current));
    }, T3), a1(function() {
      return f._destructor instanceof Function ? f._destructor : void 0;
    });
    var m = Dr(
      function(y) {
        for (var g = arguments.length, _ = new Array(g > 1 ? g - 1 : 0), x = 1; x < g; x++)
          _[x - 1] = arguments[x];
        return f[y] instanceof Function ? f[y].apply(f, _) : void 0;
      },
      [f]
    ), v = yr({});
    return Object.keys(Hk(h, [].concat(s1(l), s1(c)))).filter(function(y) {
      return v.current[y] !== h[y];
    }).forEach(function(y) {
      return m(y, h[y]);
    }), v.current = h, _3(d, function() {
      return Object.fromEntries(l.map(function(y) {
        return [y, function() {
          for (var g = arguments.length, _ = new Array(g), x = 0; x < g; x++)
            _[x] = arguments[x];
          return m.apply(void 0, [y].concat(_));
        }];
      }));
    }, [m]), /* @__PURE__ */ ni.createElement(n, {
      ref: p
    });
  });
}
function a1(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : si, i = yr(), n = yr(!1), s = yr(!1), a = Pe(0), o = Zk(a, 2);
  o[0];
  var l = o[1];
  n.current && (s.current = !0), e(function() {
    return n.current || (i.current = r(), n.current = !0), l(function(u) {
      return u + 1;
    }), function() {
      s.current && i.current && i.current();
    };
  }, []);
}
var W0 = { exports: {} }, hy = { exports: {} }, Xt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var o1;
function Qk() {
  if (o1) return Xt;
  o1 = 1;
  var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, i = r ? Symbol.for("react.portal") : 60106, n = r ? Symbol.for("react.fragment") : 60107, s = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, o = r ? Symbol.for("react.provider") : 60109, l = r ? Symbol.for("react.context") : 60110, u = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, h = r ? Symbol.for("react.forward_ref") : 60112, d = r ? Symbol.for("react.suspense") : 60113, p = r ? Symbol.for("react.suspense_list") : 60120, f = r ? Symbol.for("react.memo") : 60115, m = r ? Symbol.for("react.lazy") : 60116, v = r ? Symbol.for("react.block") : 60121, y = r ? Symbol.for("react.fundamental") : 60117, g = r ? Symbol.for("react.responder") : 60118, _ = r ? Symbol.for("react.scope") : 60119;
  function x(T) {
    if (typeof T == "object" && T !== null) {
      var S = T.$$typeof;
      switch (S) {
        case e:
          switch (T = T.type, T) {
            case u:
            case c:
            case n:
            case a:
            case s:
            case d:
              return T;
            default:
              switch (T = T && T.$$typeof, T) {
                case l:
                case h:
                case m:
                case f:
                case o:
                  return T;
                default:
                  return S;
              }
          }
        case i:
          return S;
      }
    }
  }
  function b(T) {
    return x(T) === c;
  }
  return Xt.AsyncMode = u, Xt.ConcurrentMode = c, Xt.ContextConsumer = l, Xt.ContextProvider = o, Xt.Element = e, Xt.ForwardRef = h, Xt.Fragment = n, Xt.Lazy = m, Xt.Memo = f, Xt.Portal = i, Xt.Profiler = a, Xt.StrictMode = s, Xt.Suspense = d, Xt.isAsyncMode = function(T) {
    return b(T) || x(T) === u;
  }, Xt.isConcurrentMode = b, Xt.isContextConsumer = function(T) {
    return x(T) === l;
  }, Xt.isContextProvider = function(T) {
    return x(T) === o;
  }, Xt.isElement = function(T) {
    return typeof T == "object" && T !== null && T.$$typeof === e;
  }, Xt.isForwardRef = function(T) {
    return x(T) === h;
  }, Xt.isFragment = function(T) {
    return x(T) === n;
  }, Xt.isLazy = function(T) {
    return x(T) === m;
  }, Xt.isMemo = function(T) {
    return x(T) === f;
  }, Xt.isPortal = function(T) {
    return x(T) === i;
  }, Xt.isProfiler = function(T) {
    return x(T) === a;
  }, Xt.isStrictMode = function(T) {
    return x(T) === s;
  }, Xt.isSuspense = function(T) {
    return x(T) === d;
  }, Xt.isValidElementType = function(T) {
    return typeof T == "string" || typeof T == "function" || T === n || T === c || T === a || T === s || T === d || T === p || typeof T == "object" && T !== null && (T.$$typeof === m || T.$$typeof === f || T.$$typeof === o || T.$$typeof === l || T.$$typeof === h || T.$$typeof === y || T.$$typeof === g || T.$$typeof === _ || T.$$typeof === v);
  }, Xt.typeOf = x, Xt;
}
var Zt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l1;
function Jk() {
  return l1 || (l1 = 1, process.env.NODE_ENV !== "production" && function() {
    var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, i = r ? Symbol.for("react.portal") : 60106, n = r ? Symbol.for("react.fragment") : 60107, s = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, o = r ? Symbol.for("react.provider") : 60109, l = r ? Symbol.for("react.context") : 60110, u = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, h = r ? Symbol.for("react.forward_ref") : 60112, d = r ? Symbol.for("react.suspense") : 60113, p = r ? Symbol.for("react.suspense_list") : 60120, f = r ? Symbol.for("react.memo") : 60115, m = r ? Symbol.for("react.lazy") : 60116, v = r ? Symbol.for("react.block") : 60121, y = r ? Symbol.for("react.fundamental") : 60117, g = r ? Symbol.for("react.responder") : 60118, _ = r ? Symbol.for("react.scope") : 60119;
    function x(be) {
      return typeof be == "string" || typeof be == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      be === n || be === c || be === a || be === s || be === d || be === p || typeof be == "object" && be !== null && (be.$$typeof === m || be.$$typeof === f || be.$$typeof === o || be.$$typeof === l || be.$$typeof === h || be.$$typeof === y || be.$$typeof === g || be.$$typeof === _ || be.$$typeof === v);
    }
    function b(be) {
      if (typeof be == "object" && be !== null) {
        var bt = be.$$typeof;
        switch (bt) {
          case e:
            var Y = be.type;
            switch (Y) {
              case u:
              case c:
              case n:
              case a:
              case s:
              case d:
                return Y;
              default:
                var Gt = Y && Y.$$typeof;
                switch (Gt) {
                  case l:
                  case h:
                  case m:
                  case f:
                  case o:
                    return Gt;
                  default:
                    return bt;
                }
            }
          case i:
            return bt;
        }
      }
    }
    var T = u, S = c, w = l, A = o, E = e, M = h, N = n, k = m, U = f, C = i, O = a, D = s, H = d, j = !1;
    function K(be) {
      return j || (j = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), L(be) || b(be) === u;
    }
    function L(be) {
      return b(be) === c;
    }
    function B(be) {
      return b(be) === l;
    }
    function Q(be) {
      return b(be) === o;
    }
    function W(be) {
      return typeof be == "object" && be !== null && be.$$typeof === e;
    }
    function z(be) {
      return b(be) === h;
    }
    function X(be) {
      return b(be) === n;
    }
    function ae(be) {
      return b(be) === m;
    }
    function ue(be) {
      return b(be) === f;
    }
    function ge(be) {
      return b(be) === i;
    }
    function we(be) {
      return b(be) === a;
    }
    function Ne(be) {
      return b(be) === s;
    }
    function lt(be) {
      return b(be) === d;
    }
    Zt.AsyncMode = T, Zt.ConcurrentMode = S, Zt.ContextConsumer = w, Zt.ContextProvider = A, Zt.Element = E, Zt.ForwardRef = M, Zt.Fragment = N, Zt.Lazy = k, Zt.Memo = U, Zt.Portal = C, Zt.Profiler = O, Zt.StrictMode = D, Zt.Suspense = H, Zt.isAsyncMode = K, Zt.isConcurrentMode = L, Zt.isContextConsumer = B, Zt.isContextProvider = Q, Zt.isElement = W, Zt.isForwardRef = z, Zt.isFragment = X, Zt.isLazy = ae, Zt.isMemo = ue, Zt.isPortal = ge, Zt.isProfiler = we, Zt.isStrictMode = Ne, Zt.isSuspense = lt, Zt.isValidElementType = x, Zt.typeOf = b;
  }()), Zt;
}
var u1;
function RC() {
  return u1 || (u1 = 1, process.env.NODE_ENV === "production" ? hy.exports = Qk() : hy.exports = Jk()), hy.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var dy, c1;
function eF() {
  if (c1) return dy;
  c1 = 1;
  var r = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, i = Object.prototype.propertyIsEnumerable;
  function n(a) {
    if (a == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(a);
  }
  function s() {
    try {
      if (!Object.assign)
        return !1;
      var a = new String("abc");
      if (a[5] = "de", Object.getOwnPropertyNames(a)[0] === "5")
        return !1;
      for (var o = {}, l = 0; l < 10; l++)
        o["_" + String.fromCharCode(l)] = l;
      var u = Object.getOwnPropertyNames(o).map(function(h) {
        return o[h];
      });
      if (u.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(h) {
        c[h] = h;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return dy = s() ? Object.assign : function(a, o) {
    for (var l, u = n(a), c, h = 1; h < arguments.length; h++) {
      l = Object(arguments[h]);
      for (var d in l)
        e.call(l, d) && (u[d] = l[d]);
      if (r) {
        c = r(l);
        for (var p = 0; p < c.length; p++)
          i.call(l, c[p]) && (u[c[p]] = l[c[p]]);
      }
    }
    return u;
  }, dy;
}
var py, h1;
function x_() {
  if (h1) return py;
  h1 = 1;
  var r = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return py = r, py;
}
var d1, p1;
function NC() {
  return p1 || (p1 = 1, d1 = Function.call.bind(Object.prototype.hasOwnProperty)), d1;
}
var fy, f1;
function tF() {
  if (f1) return fy;
  f1 = 1;
  var r = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = x_(), i = {}, n = NC();
    r = function(a) {
      var o = "Warning: " + a;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function s(a, o, l, u, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var h in a)
        if (n(a, h)) {
          var d;
          try {
            if (typeof a[h] != "function") {
              var p = Error(
                (u || "React class") + ": " + l + " type `" + h + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[h] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = a[h](o, h, u, l, null, e);
          } catch (m) {
            d = m;
          }
          if (d && !(d instanceof Error) && r(
            (u || "React class") + ": type specification of " + l + " `" + h + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in i)) {
            i[d.message] = !0;
            var f = c ? c() : "";
            r(
              "Failed " + l + " type: " + d.message + (f ?? "")
            );
          }
        }
    }
  }
  return s.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (i = {});
  }, fy = s, fy;
}
var my, m1;
function iF() {
  if (m1) return my;
  m1 = 1;
  var r = RC(), e = eF(), i = x_(), n = NC(), s = tF(), a = function() {
  };
  process.env.NODE_ENV !== "production" && (a = function(l) {
    var u = "Warning: " + l;
    typeof console < "u" && console.error(u);
    try {
      throw new Error(u);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return my = function(l, u) {
    var c = typeof Symbol == "function" && Symbol.iterator, h = "@@iterator";
    function d(L) {
      var B = L && (c && L[c] || L[h]);
      if (typeof B == "function")
        return B;
    }
    var p = "<<anonymous>>", f = {
      array: g("array"),
      bigint: g("bigint"),
      bool: g("boolean"),
      func: g("function"),
      number: g("number"),
      object: g("object"),
      string: g("string"),
      symbol: g("symbol"),
      any: _(),
      arrayOf: x,
      element: b(),
      elementType: T(),
      instanceOf: S,
      node: M(),
      objectOf: A,
      oneOf: w,
      oneOfType: E,
      shape: k,
      exact: U
    };
    function m(L, B) {
      return L === B ? L !== 0 || 1 / L === 1 / B : L !== L && B !== B;
    }
    function v(L, B) {
      this.message = L, this.data = B && typeof B == "object" ? B : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function y(L) {
      if (process.env.NODE_ENV !== "production")
        var B = {}, Q = 0;
      function W(X, ae, ue, ge, we, Ne, lt) {
        if (ge = ge || p, Ne = Ne || ue, lt !== i) {
          if (u) {
            var be = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw be.name = "Invariant Violation", be;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var bt = ge + ":" + ue;
            !B[bt] && // Avoid spamming the console because they are often not actionable except for lib authors
            Q < 3 && (a(
              "You are manually calling a React.PropTypes validation function for the `" + Ne + "` prop on `" + ge + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), B[bt] = !0, Q++);
          }
        }
        return ae[ue] == null ? X ? ae[ue] === null ? new v("The " + we + " `" + Ne + "` is marked as required " + ("in `" + ge + "`, but its value is `null`.")) : new v("The " + we + " `" + Ne + "` is marked as required in " + ("`" + ge + "`, but its value is `undefined`.")) : null : L(ae, ue, ge, we, Ne);
      }
      var z = W.bind(null, !1);
      return z.isRequired = W.bind(null, !0), z;
    }
    function g(L) {
      function B(Q, W, z, X, ae, ue) {
        var ge = Q[W], we = D(ge);
        if (we !== L) {
          var Ne = H(ge);
          return new v(
            "Invalid " + X + " `" + ae + "` of type " + ("`" + Ne + "` supplied to `" + z + "`, expected ") + ("`" + L + "`."),
            { expectedType: L }
          );
        }
        return null;
      }
      return y(B);
    }
    function _() {
      return y(o);
    }
    function x(L) {
      function B(Q, W, z, X, ae) {
        if (typeof L != "function")
          return new v("Property `" + ae + "` of component `" + z + "` has invalid PropType notation inside arrayOf.");
        var ue = Q[W];
        if (!Array.isArray(ue)) {
          var ge = D(ue);
          return new v("Invalid " + X + " `" + ae + "` of type " + ("`" + ge + "` supplied to `" + z + "`, expected an array."));
        }
        for (var we = 0; we < ue.length; we++) {
          var Ne = L(ue, we, z, X, ae + "[" + we + "]", i);
          if (Ne instanceof Error)
            return Ne;
        }
        return null;
      }
      return y(B);
    }
    function b() {
      function L(B, Q, W, z, X) {
        var ae = B[Q];
        if (!l(ae)) {
          var ue = D(ae);
          return new v("Invalid " + z + " `" + X + "` of type " + ("`" + ue + "` supplied to `" + W + "`, expected a single ReactElement."));
        }
        return null;
      }
      return y(L);
    }
    function T() {
      function L(B, Q, W, z, X) {
        var ae = B[Q];
        if (!r.isValidElementType(ae)) {
          var ue = D(ae);
          return new v("Invalid " + z + " `" + X + "` of type " + ("`" + ue + "` supplied to `" + W + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return y(L);
    }
    function S(L) {
      function B(Q, W, z, X, ae) {
        if (!(Q[W] instanceof L)) {
          var ue = L.name || p, ge = K(Q[W]);
          return new v("Invalid " + X + " `" + ae + "` of type " + ("`" + ge + "` supplied to `" + z + "`, expected ") + ("instance of `" + ue + "`."));
        }
        return null;
      }
      return y(B);
    }
    function w(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? a(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : a("Invalid argument supplied to oneOf, expected an array.")), o;
      function B(Q, W, z, X, ae) {
        for (var ue = Q[W], ge = 0; ge < L.length; ge++)
          if (m(ue, L[ge]))
            return null;
        var we = JSON.stringify(L, function(Ne, lt) {
          var be = H(lt);
          return be === "symbol" ? String(lt) : lt;
        });
        return new v("Invalid " + X + " `" + ae + "` of value `" + String(ue) + "` " + ("supplied to `" + z + "`, expected one of " + we + "."));
      }
      return y(B);
    }
    function A(L) {
      function B(Q, W, z, X, ae) {
        if (typeof L != "function")
          return new v("Property `" + ae + "` of component `" + z + "` has invalid PropType notation inside objectOf.");
        var ue = Q[W], ge = D(ue);
        if (ge !== "object")
          return new v("Invalid " + X + " `" + ae + "` of type " + ("`" + ge + "` supplied to `" + z + "`, expected an object."));
        for (var we in ue)
          if (n(ue, we)) {
            var Ne = L(ue, we, z, X, ae + "." + we, i);
            if (Ne instanceof Error)
              return Ne;
          }
        return null;
      }
      return y(B);
    }
    function E(L) {
      if (!Array.isArray(L))
        return process.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var B = 0; B < L.length; B++) {
        var Q = L[B];
        if (typeof Q != "function")
          return a(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + j(Q) + " at index " + B + "."
          ), o;
      }
      function W(z, X, ae, ue, ge) {
        for (var we = [], Ne = 0; Ne < L.length; Ne++) {
          var lt = L[Ne], be = lt(z, X, ae, ue, ge, i);
          if (be == null)
            return null;
          be.data && n(be.data, "expectedType") && we.push(be.data.expectedType);
        }
        var bt = we.length > 0 ? ", expected one of type [" + we.join(", ") + "]" : "";
        return new v("Invalid " + ue + " `" + ge + "` supplied to " + ("`" + ae + "`" + bt + "."));
      }
      return y(W);
    }
    function M() {
      function L(B, Q, W, z, X) {
        return C(B[Q]) ? null : new v("Invalid " + z + " `" + X + "` supplied to " + ("`" + W + "`, expected a ReactNode."));
      }
      return y(L);
    }
    function N(L, B, Q, W, z) {
      return new v(
        (L || "React class") + ": " + B + " type `" + Q + "." + W + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + z + "`."
      );
    }
    function k(L) {
      function B(Q, W, z, X, ae) {
        var ue = Q[W], ge = D(ue);
        if (ge !== "object")
          return new v("Invalid " + X + " `" + ae + "` of type `" + ge + "` " + ("supplied to `" + z + "`, expected `object`."));
        for (var we in L) {
          var Ne = L[we];
          if (typeof Ne != "function")
            return N(z, X, ae, we, H(Ne));
          var lt = Ne(ue, we, z, X, ae + "." + we, i);
          if (lt)
            return lt;
        }
        return null;
      }
      return y(B);
    }
    function U(L) {
      function B(Q, W, z, X, ae) {
        var ue = Q[W], ge = D(ue);
        if (ge !== "object")
          return new v("Invalid " + X + " `" + ae + "` of type `" + ge + "` " + ("supplied to `" + z + "`, expected `object`."));
        var we = e({}, Q[W], L);
        for (var Ne in we) {
          var lt = L[Ne];
          if (n(L, Ne) && typeof lt != "function")
            return N(z, X, ae, Ne, H(lt));
          if (!lt)
            return new v(
              "Invalid " + X + " `" + ae + "` key `" + Ne + "` supplied to `" + z + "`.\nBad object: " + JSON.stringify(Q[W], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(L), null, "  ")
            );
          var be = lt(ue, Ne, z, X, ae + "." + Ne, i);
          if (be)
            return be;
        }
        return null;
      }
      return y(B);
    }
    function C(L) {
      switch (typeof L) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !L;
        case "object":
          if (Array.isArray(L))
            return L.every(C);
          if (L === null || l(L))
            return !0;
          var B = d(L);
          if (B) {
            var Q = B.call(L), W;
            if (B !== L.entries) {
              for (; !(W = Q.next()).done; )
                if (!C(W.value))
                  return !1;
            } else
              for (; !(W = Q.next()).done; ) {
                var z = W.value;
                if (z && !C(z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function O(L, B) {
      return L === "symbol" ? !0 : B ? B["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && B instanceof Symbol : !1;
    }
    function D(L) {
      var B = typeof L;
      return Array.isArray(L) ? "array" : L instanceof RegExp ? "object" : O(B, L) ? "symbol" : B;
    }
    function H(L) {
      if (typeof L > "u" || L === null)
        return "" + L;
      var B = D(L);
      if (B === "object") {
        if (L instanceof Date)
          return "date";
        if (L instanceof RegExp)
          return "regexp";
      }
      return B;
    }
    function j(L) {
      var B = H(L);
      switch (B) {
        case "array":
        case "object":
          return "an " + B;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + B;
        default:
          return B;
      }
    }
    function K(L) {
      return !L.constructor || !L.constructor.name ? p : L.constructor.name;
    }
    return f.checkPropTypes = s, f.resetWarningCache = s.resetWarningCache, f.PropTypes = f, f;
  }, my;
}
var gy, g1;
function rF() {
  if (g1) return gy;
  g1 = 1;
  var r = x_();
  function e() {
  }
  function i() {
  }
  return i.resetWarningCache = e, gy = function() {
    function n(o, l, u, c, h, d) {
      if (d !== r) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    n.isRequired = n;
    function s() {
      return n;
    }
    var a = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: s,
      element: n,
      elementType: n,
      instanceOf: s,
      node: n,
      objectOf: s,
      oneOf: s,
      oneOfType: s,
      shape: s,
      exact: s,
      checkPropTypes: i,
      resetWarningCache: e
    };
    return a.PropTypes = a, a;
  }, gy;
}
if (process.env.NODE_ENV !== "production") {
  var nF = RC(), sF = !0;
  W0.exports = iF()(nF.isElement, sF);
} else
  W0.exports = rF()();
var aF = W0.exports;
const ie = /* @__PURE__ */ d_(aF);
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const gg = "170", ir = { ROTATE: 0, DOLLY: 1, PAN: 2 }, ra = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, oF = 0, y1 = 1, lF = 2, PC = 1, uF = 2, Hs = 3, mo = 0, Ar = 1, Qs = 2, ua = 0, Gu = 1, v1 = 2, b1 = 3, x1 = 4, cF = 5, Xo = 100, hF = 101, dF = 102, pF = 103, fF = 104, mF = 200, gF = 201, yF = 202, vF = 203, q0 = 204, X0 = 205, bF = 206, xF = 207, _F = 208, TF = 209, SF = 210, wF = 211, EF = 212, MF = 213, AF = 214, $0 = 0, Y0 = 1, K0 = 2, hc = 3, Z0 = 4, Q0 = 5, J0 = 6, eb = 7, __ = 0, CF = 1, RF = 2, lo = 0, NF = 1, PF = 2, IF = 3, OF = 4, DF = 5, LF = 6, UF = 7, IC = 300, dc = 301, pc = 302, tb = 303, ib = 304, yg = 306, rb = 1e3, il = 1001, nb = 1002, Kn = 1003, kF = 1004, cp = 1005, ds = 1006, yy = 1007, rl = 1008, xa = 1009, OC = 1010, DC = 1011, ud = 1012, T_ = 1013, xl = 1014, na = 1015, Dc = 1016, S_ = 1017, w_ = 1018, fc = 1020, LC = 35902, UC = 1021, kC = 1022, Xn = 1023, FC = 1024, BC = 1025, Hu = 1026, mc = 1027, zC = 1028, E_ = 1029, jC = 1030, M_ = 1031, A_ = 1033, Gf = 33776, Hf = 33777, Wf = 33778, qf = 33779, sb = 35840, ab = 35841, ob = 35842, lb = 35843, ub = 36196, cb = 37492, hb = 37496, db = 37808, pb = 37809, fb = 37810, mb = 37811, gb = 37812, yb = 37813, vb = 37814, bb = 37815, xb = 37816, _b = 37817, Tb = 37818, Sb = 37819, wb = 37820, Eb = 37821, Xf = 36492, Mb = 36494, Ab = 36495, VC = 36283, Cb = 36284, Rb = 36285, Nb = 36286, FF = 3200, BF = 3201, GC = 0, zF = 1, Ja = "", sn = "srgb", Lc = "srgb-linear", vg = "linear", Jt = "srgb", zl = 7680, _1 = 519, jF = 512, VF = 513, GF = 514, HC = 515, HF = 516, WF = 517, qF = 518, XF = 519, Pb = 35044, T1 = "300 es", sa = 2e3, gm = 2001;
let Cl = class {
  addEventListener(r, e) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[r] === void 0 && (i[r] = []), i[r].indexOf(e) === -1 && i[r].push(e);
  }
  hasEventListener(r, e) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[r] !== void 0 && i[r].indexOf(e) !== -1;
  }
  removeEventListener(r, e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[r];
    if (i !== void 0) {
      const n = i.indexOf(e);
      n !== -1 && i.splice(n, 1);
    }
  }
  dispatchEvent(r) {
    if (this._listeners === void 0) return;
    const e = this._listeners[r.type];
    if (e !== void 0) {
      r.target = this;
      const i = e.slice(0);
      for (let n = 0, s = i.length; n < s; n++)
        i[n].call(this, r);
      r.target = null;
    }
  }
};
const lr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let S1 = 1234567;
const Xh = Math.PI / 180, cd = 180 / Math.PI;
function ca() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (lr[r & 255] + lr[r >> 8 & 255] + lr[r >> 16 & 255] + lr[r >> 24 & 255] + "-" + lr[e & 255] + lr[e >> 8 & 255] + "-" + lr[e >> 16 & 15 | 64] + lr[e >> 24 & 255] + "-" + lr[i & 63 | 128] + lr[i >> 8 & 255] + "-" + lr[i >> 16 & 255] + lr[i >> 24 & 255] + lr[n & 255] + lr[n >> 8 & 255] + lr[n >> 16 & 255] + lr[n >> 24 & 255]).toLowerCase();
}
function Ki(r, e, i) {
  return Math.max(e, Math.min(i, r));
}
function C_(r, e) {
  return (r % e + e) % e;
}
function $F(r, e, i, n, s) {
  return n + (r - e) * (s - n) / (i - e);
}
function YF(r, e, i) {
  return r !== e ? (i - r) / (e - r) : 0;
}
function $h(r, e, i) {
  return (1 - i) * r + i * e;
}
function KF(r, e, i, n) {
  return $h(r, e, 1 - Math.exp(-i * n));
}
function ZF(r, e = 1) {
  return e - Math.abs(C_(r, e * 2) - e);
}
function QF(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * (3 - 2 * r));
}
function JF(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * r * (r * (r * 6 - 15) + 10));
}
function eB(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function tB(r, e) {
  return r + Math.random() * (e - r);
}
function iB(r) {
  return r * (0.5 - Math.random());
}
function rB(r) {
  r !== void 0 && (S1 = r);
  let e = S1 += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function nB(r) {
  return r * Xh;
}
function sB(r) {
  return r * cd;
}
function aB(r) {
  return (r & r - 1) === 0 && r !== 0;
}
function oB(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function lB(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function uB(r, e, i, n, s) {
  const a = Math.cos, o = Math.sin, l = a(i / 2), u = o(i / 2), c = a((e + n) / 2), h = o((e + n) / 2), d = a((e - n) / 2), p = o((e - n) / 2), f = a((n - e) / 2), m = o((n - e) / 2);
  switch (s) {
    case "XYX":
      r.set(l * h, u * d, u * p, l * c);
      break;
    case "YZY":
      r.set(u * p, l * h, u * d, l * c);
      break;
    case "ZXZ":
      r.set(u * d, u * p, l * h, l * c);
      break;
    case "XZX":
      r.set(l * h, u * m, u * f, l * c);
      break;
    case "YXY":
      r.set(u * f, l * h, u * m, l * c);
      break;
    case "ZYZ":
      r.set(u * m, u * f, l * h, l * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function Hn(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Qt(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Ib = {
  DEG2RAD: Xh,
  RAD2DEG: cd,
  generateUUID: ca,
  clamp: Ki,
  euclideanModulo: C_,
  mapLinear: $F,
  inverseLerp: YF,
  lerp: $h,
  damp: KF,
  pingpong: ZF,
  smoothstep: QF,
  smootherstep: JF,
  randInt: eB,
  randFloat: tB,
  randFloatSpread: iB,
  seededRandom: rB,
  degToRad: nB,
  radToDeg: sB,
  isPowerOfTwo: aB,
  ceilPowerOfTwo: oB,
  floorPowerOfTwo: lB,
  setQuaternionFromProperEuler: uB,
  normalize: Qt,
  denormalize: Hn
};
let Ue = class WC {
  constructor(e = 0, i = 0) {
    WC.prototype.isVector2 = !0, this.x = e, this.y = i;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, i) {
    return this.x = e, this.y = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * i + s[3] * n + s[6], this.y = s[1] * i + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(Ki(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y;
    return i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this;
  }
  rotateAround(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = this.x - e.x, o = this.y - e.y;
    return this.x = a * n - o * s + e.x, this.y = a * s + o * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}, It = class qC {
  constructor(e, i, n, s, a, o, l, u, c) {
    qC.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c);
  }
  set(e, i, n, s, a, o, l, u, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = l, h[3] = i, h[4] = a, h[5] = u, h[6] = n, h[7] = o, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrix3Column(this, 0), i.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[4],
      i[8],
      i[1],
      i[5],
      i[9],
      i[2],
      i[6],
      i[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[3], u = n[6], c = n[1], h = n[4], d = n[7], p = n[2], f = n[5], m = n[8], v = s[0], y = s[3], g = s[6], _ = s[1], x = s[4], b = s[7], T = s[2], S = s[5], w = s[8];
    return a[0] = o * v + l * _ + u * T, a[3] = o * y + l * x + u * S, a[6] = o * g + l * b + u * w, a[1] = c * v + h * _ + d * T, a[4] = c * y + h * x + d * S, a[7] = c * g + h * b + d * w, a[2] = p * v + f * _ + m * T, a[5] = p * y + f * x + m * S, a[8] = p * g + f * b + m * w, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= e, i[4] *= e, i[7] *= e, i[2] *= e, i[5] *= e, i[8] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8];
    return i * o * h - i * l * c - n * a * h + n * l * u + s * a * c - s * o * u;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = h * o - l * c, p = l * u - h * a, f = c * a - o * u, m = i * d + n * p + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / m;
    return e[0] = d * v, e[1] = (s * c - h * n) * v, e[2] = (l * n - s * o) * v, e[3] = p * v, e[4] = (h * i - s * u) * v, e[5] = (s * a - l * i) * v, e[6] = f * v, e[7] = (n * u - c * i) * v, e[8] = (o * i - n * a) * v, this;
  }
  transpose() {
    let e;
    const i = this.elements;
    return e = i[1], i[1] = i[3], i[3] = e, e = i[2], i[2] = i[6], i[6] = e, e = i[5], i[5] = i[7], i[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const i = this.elements;
    return e[0] = i[0], e[1] = i[3], e[2] = i[6], e[3] = i[1], e[4] = i[4], e[5] = i[7], e[6] = i[2], e[7] = i[5], e[8] = i[8], this;
  }
  setUvTransform(e, i, n, s, a, o, l) {
    const u = Math.cos(a), c = Math.sin(a);
    return this.set(
      n * u,
      n * c,
      -n * (u * o + c * l) + o + e,
      -s * c,
      s * u,
      -s * (-c * o + u * l) + l + i,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, i) {
    return this.premultiply(vy.makeScale(e, i)), this;
  }
  rotate(e) {
    return this.premultiply(vy.makeRotation(-e)), this;
  }
  translate(e, i) {
    return this.premultiply(vy.makeTranslation(e, i)), this;
  }
  // for 2D Transforms
  makeTranslation(e, i) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      i,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      n,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i) {
    return this.set(
      e,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
const vy = /* @__PURE__ */ new It();
function XC(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function hd(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function cB() {
  const r = hd("canvas");
  return r.style.display = "block", r;
}
const w1 = {};
function Uh(r) {
  r in w1 || (w1[r] = !0, console.warn(r));
}
function hB(r, e, i) {
  return new Promise(function(n, s) {
    function a() {
      switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case r.WAIT_FAILED:
          s();
          break;
        case r.TIMEOUT_EXPIRED:
          setTimeout(a, i);
          break;
        default:
          n();
      }
    }
    setTimeout(a, i);
  });
}
function dB(r) {
  const e = r.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function pB(r) {
  const e = r.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const Vt = {
  enabled: !0,
  workingColorSpace: Lc,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(r, e, i) {
    return this.enabled === !1 || e === i || !e || !i || (this.spaces[e].transfer === Jt && (r.r = ha(r.r), r.g = ha(r.g), r.b = ha(r.b)), this.spaces[e].primaries !== this.spaces[i].primaries && (r.applyMatrix3(this.spaces[e].toXYZ), r.applyMatrix3(this.spaces[i].fromXYZ)), this.spaces[i].transfer === Jt && (r.r = Wu(r.r), r.g = Wu(r.g), r.b = Wu(r.b))), r;
  },
  fromWorkingColorSpace: function(r, e) {
    return this.convert(r, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(r, e) {
    return this.convert(r, e, this.workingColorSpace);
  },
  getPrimaries: function(r) {
    return this.spaces[r].primaries;
  },
  getTransfer: function(r) {
    return r === Ja ? vg : this.spaces[r].transfer;
  },
  getLuminanceCoefficients: function(r, e = this.workingColorSpace) {
    return r.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(r) {
    Object.assign(this.spaces, r);
  },
  // Internal APIs
  _getMatrix: function(r, e, i) {
    return r.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(r) {
    return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(r = this.workingColorSpace) {
    return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
  }
};
function ha(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Wu(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const E1 = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], M1 = [0.2126, 0.7152, 0.0722], A1 = [0.3127, 0.329], C1 = /* @__PURE__ */ new It().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), R1 = /* @__PURE__ */ new It().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
Vt.define({
  [Lc]: {
    primaries: E1,
    whitePoint: A1,
    transfer: vg,
    toXYZ: C1,
    fromXYZ: R1,
    luminanceCoefficients: M1,
    workingColorSpaceConfig: { unpackColorSpace: sn },
    outputColorSpaceConfig: { drawingBufferColorSpace: sn }
  },
  [sn]: {
    primaries: E1,
    whitePoint: A1,
    transfer: Jt,
    toXYZ: C1,
    fromXYZ: R1,
    luminanceCoefficients: M1,
    outputColorSpaceConfig: { drawingBufferColorSpace: sn }
  }
});
let jl, fB = class {
  static getDataURL(r) {
    if (/^data:/i.test(r.src) || typeof HTMLCanvasElement > "u")
      return r.src;
    let e;
    if (r instanceof HTMLCanvasElement)
      e = r;
    else {
      jl === void 0 && (jl = hd("canvas")), jl.width = r.width, jl.height = r.height;
      const i = jl.getContext("2d");
      r instanceof ImageData ? i.putImageData(r, 0, 0) : i.drawImage(r, 0, 0, r.width, r.height), e = jl;
    }
    return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", r), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
  }
  static sRGBToLinear(r) {
    if (typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap) {
      const e = hd("canvas");
      e.width = r.width, e.height = r.height;
      const i = e.getContext("2d");
      i.drawImage(r, 0, 0, r.width, r.height);
      const n = i.getImageData(0, 0, r.width, r.height), s = n.data;
      for (let a = 0; a < s.length; a++)
        s[a] = ha(s[a] / 255) * 255;
      return i.putImageData(n, 0, 0), e;
    } else if (r.data) {
      const e = r.data.slice(0);
      for (let i = 0; i < e.length; i++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[i] = Math.floor(ha(e[i] / 255) * 255) : e[i] = ha(e[i]);
      return {
        data: e,
        width: r.width,
        height: r.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), r;
  }
}, mB = 0, $C = class {
  constructor(r = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: mB++ }), this.uuid = ca(), this.data = r, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  toJSON(r) {
    const e = r === void 0 || typeof r == "string";
    if (!e && r.images[this.uuid] !== void 0)
      return r.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, n = this.data;
    if (n !== null) {
      let s;
      if (Array.isArray(n)) {
        s = [];
        for (let a = 0, o = n.length; a < o; a++)
          n[a].isDataTexture ? s.push(by(n[a].image)) : s.push(by(n[a]));
      } else
        s = by(n);
      i.url = s;
    }
    return e || (r.images[this.uuid] = i), i;
  }
};
function by(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? fB.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let gB = 0, En = class $f extends Cl {
  constructor(e = $f.DEFAULT_IMAGE, i = $f.DEFAULT_MAPPING, n = il, s = il, a = ds, o = rl, l = Xn, u = xa, c = $f.DEFAULT_ANISOTROPY, h = Ja) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: gB++ }), this.uuid = ca(), this.name = "", this.source = new $C(e), this.mipmaps = [], this.mapping = i, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = a, this.minFilter = o, this.anisotropy = c, this.format = l, this.internalFormat = null, this.type = u, this.offset = new Ue(0, 0), this.repeat = new Ue(1, 1), this.center = new Ue(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new It(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), i || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== IC) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case rb:
          e.x = e.x - Math.floor(e.x);
          break;
        case il:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case nb:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case rb:
          e.y = e.y - Math.floor(e.y);
          break;
        case il:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case nb:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
};
En.DEFAULT_IMAGE = null;
En.DEFAULT_MAPPING = IC;
En.DEFAULT_ANISOTROPY = 1;
let Fi = class YC {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    YC.prototype.isVector4 = !0, this.x = e, this.y = i, this.z = n, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, i, n, s) {
    return this.x = e, this.y = i, this.z = n, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      case 3:
        this.w = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this.w = e.w + i.w, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this.w += e.w * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this.w = e.w - i.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = this.w, o = e.elements;
    return this.x = o[0] * i + o[4] * n + o[8] * s + o[12] * a, this.y = o[1] * i + o[5] * n + o[9] * s + o[13] * a, this.z = o[2] * i + o[6] * n + o[10] * s + o[14] * a, this.w = o[3] * i + o[7] * n + o[11] * s + o[15] * a, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const i = Math.sqrt(1 - e.w * e.w);
    return i < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / i, this.y = e.y / i, this.z = e.z / i), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let i, n, s, a;
    const o = e.elements, l = o[0], u = o[4], c = o[8], h = o[1], d = o[5], p = o[9], f = o[2], m = o[6], v = o[10];
    if (Math.abs(u - h) < 0.01 && Math.abs(c - f) < 0.01 && Math.abs(p - m) < 0.01) {
      if (Math.abs(u + h) < 0.1 && Math.abs(c + f) < 0.1 && Math.abs(p + m) < 0.1 && Math.abs(l + d + v - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      i = Math.PI;
      const g = (l + 1) / 2, _ = (d + 1) / 2, x = (v + 1) / 2, b = (u + h) / 4, T = (c + f) / 4, S = (p + m) / 4;
      return g > _ && g > x ? g < 0.01 ? (n = 0, s = 0.707106781, a = 0.707106781) : (n = Math.sqrt(g), s = b / n, a = T / n) : _ > x ? _ < 0.01 ? (n = 0.707106781, s = 0, a = 0.707106781) : (s = Math.sqrt(_), n = b / s, a = S / s) : x < 0.01 ? (n = 0.707106781, s = 0.707106781, a = 0) : (a = Math.sqrt(x), n = T / a, s = S / a), this.set(n, s, a, i), this;
    }
    let y = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (h - u) * (h - u));
    return Math.abs(y) < 1e-3 && (y = 1), this.x = (m - p) / y, this.y = (c - f) / y, this.z = (h - u) / y, this.w = Math.acos((l + d + v - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this.w = i[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this.w = Math.max(e.w, Math.min(i.w, this.w)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this.w = Math.max(e, Math.min(i, this.w)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this.w += (e.w - this.w) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this.w = e.w + (i.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this.w = e[i + 3], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e[i + 3] = this.w, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this.w = e.getW(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}, yB = class extends Cl {
  constructor(r = 1, e = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = r, this.height = e, this.depth = 1, this.scissor = new Fi(0, 0, r, e), this.scissorTest = !1, this.viewport = new Fi(0, 0, r, e);
    const n = { width: r, height: e, depth: 1 };
    i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: ds,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, i);
    const s = new En(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    s.flipY = !1, s.generateMipmaps = i.generateMipmaps, s.internalFormat = i.internalFormat, this.textures = [];
    const a = i.count;
    for (let o = 0; o < a; o++)
      this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = !0;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(r) {
    this.textures[0] = r;
  }
  setSize(r, e, i = 1) {
    if (this.width !== r || this.height !== e || this.depth !== i) {
      this.width = r, this.height = e, this.depth = i;
      for (let n = 0, s = this.textures.length; n < s; n++)
        this.textures[n].image.width = r, this.textures[n].image.height = e, this.textures[n].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, r, e), this.scissor.set(0, 0, r, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    this.width = r.width, this.height = r.height, this.depth = r.depth, this.scissor.copy(r.scissor), this.scissorTest = r.scissorTest, this.viewport.copy(r.viewport), this.textures.length = 0;
    for (let i = 0, n = r.textures.length; i < n; i++)
      this.textures[i] = r.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
    const e = Object.assign({}, r.texture.image);
    return this.texture.source = new $C(e), this.depthBuffer = r.depthBuffer, this.stencilBuffer = r.stencilBuffer, this.resolveDepthBuffer = r.resolveDepthBuffer, this.resolveStencilBuffer = r.resolveStencilBuffer, r.depthTexture !== null && (this.depthTexture = r.depthTexture.clone()), this.samples = r.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}, go = class extends yB {
  constructor(r = 1, e = 1, i = {}) {
    super(r, e, i), this.isWebGLRenderTarget = !0;
  }
}, KC = class extends En {
  constructor(r = null, e = 1, i = 1, n = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: r, width: e, height: i, depth: n }, this.magFilter = Kn, this.minFilter = Kn, this.wrapR = il, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(r) {
    this.layerUpdates.add(r);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
};
class vB extends En {
  constructor(e = null, i = 1, n = 1, s = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: i, height: n, depth: s }, this.magFilter = Kn, this.minFilter = Kn, this.wrapR = il, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
let bs = class {
  constructor(r = 0, e = 0, i = 0, n = 1) {
    this.isQuaternion = !0, this._x = r, this._y = e, this._z = i, this._w = n;
  }
  static slerpFlat(r, e, i, n, s, a, o) {
    let l = i[n + 0], u = i[n + 1], c = i[n + 2], h = i[n + 3];
    const d = s[a + 0], p = s[a + 1], f = s[a + 2], m = s[a + 3];
    if (o === 0) {
      r[e + 0] = l, r[e + 1] = u, r[e + 2] = c, r[e + 3] = h;
      return;
    }
    if (o === 1) {
      r[e + 0] = d, r[e + 1] = p, r[e + 2] = f, r[e + 3] = m;
      return;
    }
    if (h !== m || l !== d || u !== p || c !== f) {
      let v = 1 - o;
      const y = l * d + u * p + c * f + h * m, g = y >= 0 ? 1 : -1, _ = 1 - y * y;
      if (_ > Number.EPSILON) {
        const b = Math.sqrt(_), T = Math.atan2(b, y * g);
        v = Math.sin(v * T) / b, o = Math.sin(o * T) / b;
      }
      const x = o * g;
      if (l = l * v + d * x, u = u * v + p * x, c = c * v + f * x, h = h * v + m * x, v === 1 - o) {
        const b = 1 / Math.sqrt(l * l + u * u + c * c + h * h);
        l *= b, u *= b, c *= b, h *= b;
      }
    }
    r[e] = l, r[e + 1] = u, r[e + 2] = c, r[e + 3] = h;
  }
  static multiplyQuaternionsFlat(r, e, i, n, s, a) {
    const o = i[n], l = i[n + 1], u = i[n + 2], c = i[n + 3], h = s[a], d = s[a + 1], p = s[a + 2], f = s[a + 3];
    return r[e] = o * f + c * h + l * p - u * d, r[e + 1] = l * f + c * d + u * h - o * p, r[e + 2] = u * f + c * p + o * d - l * h, r[e + 3] = c * f - o * h - l * d - u * p, r;
  }
  get x() {
    return this._x;
  }
  set x(r) {
    this._x = r, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(r) {
    this._y = r, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(r) {
    this._z = r, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(r) {
    this._w = r, this._onChangeCallback();
  }
  set(r, e, i, n) {
    return this._x = r, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(r) {
    return this._x = r.x, this._y = r.y, this._z = r.z, this._w = r.w, this._onChangeCallback(), this;
  }
  setFromEuler(r, e = !0) {
    const i = r._x, n = r._y, s = r._z, a = r._order, o = Math.cos, l = Math.sin, u = o(i / 2), c = o(n / 2), h = o(s / 2), d = l(i / 2), p = l(n / 2), f = l(s / 2);
    switch (a) {
      case "XYZ":
        this._x = d * c * h + u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "YXZ":
        this._x = d * c * h + u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h + d * p * f;
        break;
      case "ZXY":
        this._x = d * c * h - u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "ZYX":
        this._x = d * c * h - u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h + d * p * f;
        break;
      case "YZX":
        this._x = d * c * h + u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "XZY":
        this._x = d * c * h - u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h + d * p * f;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(r, e) {
    const i = e / 2, n = Math.sin(i);
    return this._x = r.x * n, this._y = r.y * n, this._z = r.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(r) {
    const e = r.elements, i = e[0], n = e[4], s = e[8], a = e[1], o = e[5], l = e[9], u = e[2], c = e[6], h = e[10], d = i + o + h;
    if (d > 0) {
      const p = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / p, this._x = (c - l) * p, this._y = (s - u) * p, this._z = (a - n) * p;
    } else if (i > o && i > h) {
      const p = 2 * Math.sqrt(1 + i - o - h);
      this._w = (c - l) / p, this._x = 0.25 * p, this._y = (n + a) / p, this._z = (s + u) / p;
    } else if (o > h) {
      const p = 2 * Math.sqrt(1 + o - i - h);
      this._w = (s - u) / p, this._x = (n + a) / p, this._y = 0.25 * p, this._z = (l + c) / p;
    } else {
      const p = 2 * Math.sqrt(1 + h - i - o);
      this._w = (a - n) / p, this._x = (s + u) / p, this._y = (l + c) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(r, e) {
    let i = r.dot(e) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(r.x) > Math.abs(r.z) ? (this._x = -r.y, this._y = r.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -r.z, this._z = r.y, this._w = i)) : (this._x = r.y * e.z - r.z * e.y, this._y = r.z * e.x - r.x * e.z, this._z = r.x * e.y - r.y * e.x, this._w = i), this.normalize();
  }
  angleTo(r) {
    return 2 * Math.acos(Math.abs(Ki(this.dot(r), -1, 1)));
  }
  rotateTowards(r, e) {
    const i = this.angleTo(r);
    if (i === 0) return this;
    const n = Math.min(1, e / i);
    return this.slerp(r, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(r) {
    return this._x * r._x + this._y * r._y + this._z * r._z + this._w * r._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let r = this.length();
    return r === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (r = 1 / r, this._x = this._x * r, this._y = this._y * r, this._z = this._z * r, this._w = this._w * r), this._onChangeCallback(), this;
  }
  multiply(r) {
    return this.multiplyQuaternions(this, r);
  }
  premultiply(r) {
    return this.multiplyQuaternions(r, this);
  }
  multiplyQuaternions(r, e) {
    const i = r._x, n = r._y, s = r._z, a = r._w, o = e._x, l = e._y, u = e._z, c = e._w;
    return this._x = i * c + a * o + n * u - s * l, this._y = n * c + a * l + s * o - i * u, this._z = s * c + a * u + i * l - n * o, this._w = a * c - i * o - n * l - s * u, this._onChangeCallback(), this;
  }
  slerp(r, e) {
    if (e === 0) return this;
    if (e === 1) return this.copy(r);
    const i = this._x, n = this._y, s = this._z, a = this._w;
    let o = a * r._w + i * r._x + n * r._y + s * r._z;
    if (o < 0 ? (this._w = -r._w, this._x = -r._x, this._y = -r._y, this._z = -r._z, o = -o) : this.copy(r), o >= 1)
      return this._w = a, this._x = i, this._y = n, this._z = s, this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const p = 1 - e;
      return this._w = p * a + e * this._w, this._x = p * i + e * this._x, this._y = p * n + e * this._y, this._z = p * s + e * this._z, this.normalize(), this;
    }
    const u = Math.sqrt(l), c = Math.atan2(u, o), h = Math.sin((1 - e) * c) / u, d = Math.sin(e * c) / u;
    return this._w = a * h + this._w * d, this._x = i * h + this._x * d, this._y = n * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(r, e, i) {
    return this.copy(r).slerp(e, i);
  }
  random() {
    const r = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), s = Math.sqrt(i);
    return this.set(
      n * Math.sin(r),
      n * Math.cos(r),
      s * Math.sin(e),
      s * Math.cos(e)
    );
  }
  equals(r) {
    return r._x === this._x && r._y === this._y && r._z === this._z && r._w === this._w;
  }
  fromArray(r, e = 0) {
    return this._x = r[e], this._y = r[e + 1], this._z = r[e + 2], this._w = r[e + 3], this._onChangeCallback(), this;
  }
  toArray(r = [], e = 0) {
    return r[e] = this._x, r[e + 1] = this._y, r[e + 2] = this._z, r[e + 3] = this._w, r;
  }
  fromBufferAttribute(r, e) {
    return this._x = r.getX(e), this._y = r.getY(e), this._z = r.getZ(e), this._w = r.getW(e), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(r) {
    return this._onChangeCallback = r, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}, q = class ZC {
  constructor(e = 0, i = 0, n = 0) {
    ZC.prototype.isVector3 = !0, this.x = e, this.y = i, this.z = n;
  }
  set(e, i, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = i, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, i) {
    return this.x = e.x * i.x, this.y = e.y * i.y, this.z = e.z * i.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(N1.setFromEuler(e));
  }
  applyAxisAngle(e, i) {
    return this.applyQuaternion(N1.setFromAxisAngle(e, i));
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[3] * n + a[6] * s, this.y = a[1] * i + a[4] * n + a[7] * s, this.z = a[2] * i + a[5] * n + a[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements, o = 1 / (a[3] * i + a[7] * n + a[11] * s + a[15]);
    return this.x = (a[0] * i + a[4] * n + a[8] * s + a[12]) * o, this.y = (a[1] * i + a[5] * n + a[9] * s + a[13]) * o, this.z = (a[2] * i + a[6] * n + a[10] * s + a[14]) * o, this;
  }
  applyQuaternion(e) {
    const i = this.x, n = this.y, s = this.z, a = e.x, o = e.y, l = e.z, u = e.w, c = 2 * (o * s - l * n), h = 2 * (l * i - a * s), d = 2 * (a * n - o * i);
    return this.x = i + u * c + o * d - l * h, this.y = n + u * h + l * c - a * d, this.z = s + u * d + a * h - o * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[4] * n + a[8] * s, this.y = a[1] * i + a[5] * n + a[9] * s, this.z = a[2] * i + a[6] * n + a[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, i) {
    const n = e.x, s = e.y, a = e.z, o = i.x, l = i.y, u = i.z;
    return this.x = s * u - a * l, this.y = a * o - n * u, this.z = n * l - s * o, this;
  }
  projectOnVector(e) {
    const i = e.lengthSq();
    if (i === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / i;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return xy.copy(this).projectOnVector(e), this.sub(xy);
  }
  reflect(e) {
    return this.sub(xy.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(Ki(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
    return i * i + n * n + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, i, n) {
    const s = Math.sin(i) * e;
    return this.x = s * Math.sin(n), this.y = Math.cos(i) * e, this.z = s * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, i, n) {
    return this.x = e * Math.sin(i), this.y = n, this.z = e * Math.cos(i), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this;
  }
  setFromMatrixScale(e) {
    const i = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = i, this.y = n, this.z = s, this;
  }
  setFromMatrixColumn(e, i) {
    return this.fromArray(e.elements, i * 4);
  }
  setFromMatrix3Column(e, i) {
    return this.fromArray(e.elements, i * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, i = Math.random() * 2 - 1, n = Math.sqrt(1 - i * i);
    return this.x = n * Math.cos(e), this.y = i, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
};
const xy = /* @__PURE__ */ new q(), N1 = /* @__PURE__ */ new bs();
let Rl = class {
  constructor(r = new q(1 / 0, 1 / 0, 1 / 0), e = new q(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = r, this.max = e;
  }
  set(r, e) {
    return this.min.copy(r), this.max.copy(e), this;
  }
  setFromArray(r) {
    this.makeEmpty();
    for (let e = 0, i = r.length; e < i; e += 3)
      this.expandByPoint(Rn.fromArray(r, e));
    return this;
  }
  setFromBufferAttribute(r) {
    this.makeEmpty();
    for (let e = 0, i = r.count; e < i; e++)
      this.expandByPoint(Rn.fromBufferAttribute(r, e));
    return this;
  }
  setFromPoints(r) {
    this.makeEmpty();
    for (let e = 0, i = r.length; e < i; e++)
      this.expandByPoint(r[e]);
    return this;
  }
  setFromCenterAndSize(r, e) {
    const i = Rn.copy(e).multiplyScalar(0.5);
    return this.min.copy(r).sub(i), this.max.copy(r).add(i), this;
  }
  setFromObject(r, e = !1) {
    return this.makeEmpty(), this.expandByObject(r, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    return this.min.copy(r.min), this.max.copy(r.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(r) {
    return this.isEmpty() ? r.set(0, 0, 0) : r.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(r) {
    return this.isEmpty() ? r.set(0, 0, 0) : r.subVectors(this.max, this.min);
  }
  expandByPoint(r) {
    return this.min.min(r), this.max.max(r), this;
  }
  expandByVector(r) {
    return this.min.sub(r), this.max.add(r), this;
  }
  expandByScalar(r) {
    return this.min.addScalar(-r), this.max.addScalar(r), this;
  }
  expandByObject(r, e = !1) {
    r.updateWorldMatrix(!1, !1);
    const i = r.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (e === !0 && s !== void 0 && r.isInstancedMesh !== !0)
        for (let a = 0, o = s.count; a < o; a++)
          r.isMesh === !0 ? r.getVertexPosition(a, Rn) : Rn.fromBufferAttribute(s, a), Rn.applyMatrix4(r.matrixWorld), this.expandByPoint(Rn);
      else
        r.boundingBox !== void 0 ? (r.boundingBox === null && r.computeBoundingBox(), hp.copy(r.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), hp.copy(i.boundingBox)), hp.applyMatrix4(r.matrixWorld), this.union(hp);
    }
    const n = r.children;
    for (let s = 0, a = n.length; s < a; s++)
      this.expandByObject(n[s], e);
    return this;
  }
  containsPoint(r) {
    return r.x >= this.min.x && r.x <= this.max.x && r.y >= this.min.y && r.y <= this.max.y && r.z >= this.min.z && r.z <= this.max.z;
  }
  containsBox(r) {
    return this.min.x <= r.min.x && r.max.x <= this.max.x && this.min.y <= r.min.y && r.max.y <= this.max.y && this.min.z <= r.min.z && r.max.z <= this.max.z;
  }
  getParameter(r, e) {
    return e.set(
      (r.x - this.min.x) / (this.max.x - this.min.x),
      (r.y - this.min.y) / (this.max.y - this.min.y),
      (r.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(r) {
    return r.max.x >= this.min.x && r.min.x <= this.max.x && r.max.y >= this.min.y && r.min.y <= this.max.y && r.max.z >= this.min.z && r.min.z <= this.max.z;
  }
  intersectsSphere(r) {
    return this.clampPoint(r.center, Rn), Rn.distanceToSquared(r.center) <= r.radius * r.radius;
  }
  intersectsPlane(r) {
    let e, i;
    return r.normal.x > 0 ? (e = r.normal.x * this.min.x, i = r.normal.x * this.max.x) : (e = r.normal.x * this.max.x, i = r.normal.x * this.min.x), r.normal.y > 0 ? (e += r.normal.y * this.min.y, i += r.normal.y * this.max.y) : (e += r.normal.y * this.max.y, i += r.normal.y * this.min.y), r.normal.z > 0 ? (e += r.normal.z * this.min.z, i += r.normal.z * this.max.z) : (e += r.normal.z * this.max.z, i += r.normal.z * this.min.z), e <= -r.constant && i >= -r.constant;
  }
  intersectsTriangle(r) {
    if (this.isEmpty())
      return !1;
    this.getCenter(th), dp.subVectors(this.max, th), Vl.subVectors(r.a, th), Gl.subVectors(r.b, th), Hl.subVectors(r.c, th), Pa.subVectors(Gl, Vl), Ia.subVectors(Hl, Gl), Ro.subVectors(Vl, Hl);
    let e = [
      0,
      -Pa.z,
      Pa.y,
      0,
      -Ia.z,
      Ia.y,
      0,
      -Ro.z,
      Ro.y,
      Pa.z,
      0,
      -Pa.x,
      Ia.z,
      0,
      -Ia.x,
      Ro.z,
      0,
      -Ro.x,
      -Pa.y,
      Pa.x,
      0,
      -Ia.y,
      Ia.x,
      0,
      -Ro.y,
      Ro.x,
      0
    ];
    return !_y(e, Vl, Gl, Hl, dp) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !_y(e, Vl, Gl, Hl, dp)) ? !1 : (pp.crossVectors(Pa, Ia), e = [pp.x, pp.y, pp.z], _y(e, Vl, Gl, Hl, dp));
  }
  clampPoint(r, e) {
    return e.copy(r).clamp(this.min, this.max);
  }
  distanceToPoint(r) {
    return this.clampPoint(r, Rn).distanceTo(r);
  }
  getBoundingSphere(r) {
    return this.isEmpty() ? r.makeEmpty() : (this.getCenter(r.center), r.radius = this.getSize(Rn).length() * 0.5), r;
  }
  intersect(r) {
    return this.min.max(r.min), this.max.min(r.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(r) {
    return this.min.min(r.min), this.max.max(r.max), this;
  }
  applyMatrix4(r) {
    return this.isEmpty() ? this : (Cs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(r), Cs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(r), Cs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(r), Cs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(r), Cs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(r), Cs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(r), Cs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(r), Cs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(r), this.setFromPoints(Cs), this);
  }
  translate(r) {
    return this.min.add(r), this.max.add(r), this;
  }
  equals(r) {
    return r.min.equals(this.min) && r.max.equals(this.max);
  }
};
const Cs = [
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q()
], Rn = /* @__PURE__ */ new q(), hp = /* @__PURE__ */ new Rl(), Vl = /* @__PURE__ */ new q(), Gl = /* @__PURE__ */ new q(), Hl = /* @__PURE__ */ new q(), Pa = /* @__PURE__ */ new q(), Ia = /* @__PURE__ */ new q(), Ro = /* @__PURE__ */ new q(), th = /* @__PURE__ */ new q(), dp = /* @__PURE__ */ new q(), pp = /* @__PURE__ */ new q(), No = /* @__PURE__ */ new q();
function _y(r, e, i, n, s) {
  for (let a = 0, o = r.length - 3; a <= o; a += 3) {
    No.fromArray(r, a);
    const l = s.x * Math.abs(No.x) + s.y * Math.abs(No.y) + s.z * Math.abs(No.z), u = e.dot(No), c = i.dot(No), h = n.dot(No);
    if (Math.max(-Math.max(u, c, h), Math.min(u, c, h)) > l)
      return !1;
  }
  return !0;
}
const bB = /* @__PURE__ */ new Rl(), ih = /* @__PURE__ */ new q(), Ty = /* @__PURE__ */ new q();
let bg = class {
  constructor(r = new q(), e = -1) {
    this.isSphere = !0, this.center = r, this.radius = e;
  }
  set(r, e) {
    return this.center.copy(r), this.radius = e, this;
  }
  setFromPoints(r, e) {
    const i = this.center;
    e !== void 0 ? i.copy(e) : bB.setFromPoints(r).getCenter(i);
    let n = 0;
    for (let s = 0, a = r.length; s < a; s++)
      n = Math.max(n, i.distanceToSquared(r[s]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(r) {
    return this.center.copy(r.center), this.radius = r.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(r) {
    return r.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(r) {
    return r.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(r) {
    const e = this.radius + r.radius;
    return r.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(r) {
    return r.intersectsSphere(this);
  }
  intersectsPlane(r) {
    return Math.abs(r.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(r, e) {
    const i = this.center.distanceToSquared(r);
    return e.copy(r), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  }
  getBoundingBox(r) {
    return this.isEmpty() ? (r.makeEmpty(), r) : (r.set(this.center, this.center), r.expandByScalar(this.radius), r);
  }
  applyMatrix4(r) {
    return this.center.applyMatrix4(r), this.radius = this.radius * r.getMaxScaleOnAxis(), this;
  }
  translate(r) {
    return this.center.add(r), this;
  }
  expandByPoint(r) {
    if (this.isEmpty())
      return this.center.copy(r), this.radius = 0, this;
    ih.subVectors(r, this.center);
    const e = ih.lengthSq();
    if (e > this.radius * this.radius) {
      const i = Math.sqrt(e), n = (i - this.radius) * 0.5;
      this.center.addScaledVector(ih, n / i), this.radius += n;
    }
    return this;
  }
  union(r) {
    return r.isEmpty() ? this : this.isEmpty() ? (this.copy(r), this) : (this.center.equals(r.center) === !0 ? this.radius = Math.max(this.radius, r.radius) : (Ty.subVectors(r.center, this.center).setLength(r.radius), this.expandByPoint(ih.copy(r.center).add(Ty)), this.expandByPoint(ih.copy(r.center).sub(Ty))), this);
  }
  equals(r) {
    return r.center.equals(this.center) && r.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const Rs = /* @__PURE__ */ new q(), Sy = /* @__PURE__ */ new q(), fp = /* @__PURE__ */ new q(), Oa = /* @__PURE__ */ new q(), wy = /* @__PURE__ */ new q(), mp = /* @__PURE__ */ new q(), Ey = /* @__PURE__ */ new q();
let xg = class {
  constructor(r = new q(), e = new q(0, 0, -1)) {
    this.origin = r, this.direction = e;
  }
  set(r, e) {
    return this.origin.copy(r), this.direction.copy(e), this;
  }
  copy(r) {
    return this.origin.copy(r.origin), this.direction.copy(r.direction), this;
  }
  at(r, e) {
    return e.copy(this.origin).addScaledVector(this.direction, r);
  }
  lookAt(r) {
    return this.direction.copy(r).sub(this.origin).normalize(), this;
  }
  recast(r) {
    return this.origin.copy(this.at(r, Rs)), this;
  }
  closestPointToPoint(r, e) {
    e.subVectors(r, this.origin);
    const i = e.dot(this.direction);
    return i < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(r) {
    return Math.sqrt(this.distanceSqToPoint(r));
  }
  distanceSqToPoint(r) {
    const e = Rs.subVectors(r, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(r) : (Rs.copy(this.origin).addScaledVector(this.direction, e), Rs.distanceToSquared(r));
  }
  distanceSqToSegment(r, e, i, n) {
    Sy.copy(r).add(e).multiplyScalar(0.5), fp.copy(e).sub(r).normalize(), Oa.copy(this.origin).sub(Sy);
    const s = r.distanceTo(e) * 0.5, a = -this.direction.dot(fp), o = Oa.dot(this.direction), l = -Oa.dot(fp), u = Oa.lengthSq(), c = Math.abs(1 - a * a);
    let h, d, p, f;
    if (c > 0)
      if (h = a * l - o, d = a * o - l, f = s * c, h >= 0)
        if (d >= -f)
          if (d <= f) {
            const m = 1 / c;
            h *= m, d *= m, p = h * (h + a * d + 2 * o) + d * (a * h + d + 2 * l) + u;
          } else
            d = s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
        else
          d = -s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
      else
        d <= -f ? (h = Math.max(0, -(-a * s + o)), d = h > 0 ? -s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + u) : d <= f ? (h = 0, d = Math.min(Math.max(-s, -l), s), p = d * (d + 2 * l) + u) : (h = Math.max(0, -(a * s + o)), d = h > 0 ? s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + u);
    else
      d = a > 0 ? -s : s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
    return i && i.copy(this.origin).addScaledVector(this.direction, h), n && n.copy(Sy).addScaledVector(fp, d), p;
  }
  intersectSphere(r, e) {
    Rs.subVectors(r.center, this.origin);
    const i = Rs.dot(this.direction), n = Rs.dot(Rs) - i * i, s = r.radius * r.radius;
    if (n > s) return null;
    const a = Math.sqrt(s - n), o = i - a, l = i + a;
    return l < 0 ? null : o < 0 ? this.at(l, e) : this.at(o, e);
  }
  intersectsSphere(r) {
    return this.distanceSqToPoint(r.center) <= r.radius * r.radius;
  }
  distanceToPlane(r) {
    const e = r.normal.dot(this.direction);
    if (e === 0)
      return r.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(r.normal) + r.constant) / e;
    return i >= 0 ? i : null;
  }
  intersectPlane(r, e) {
    const i = this.distanceToPlane(r);
    return i === null ? null : this.at(i, e);
  }
  intersectsPlane(r) {
    const e = r.distanceToPoint(this.origin);
    return e === 0 || r.normal.dot(this.direction) * e < 0;
  }
  intersectBox(r, e) {
    let i, n, s, a, o, l;
    const u = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin;
    return u >= 0 ? (i = (r.min.x - d.x) * u, n = (r.max.x - d.x) * u) : (i = (r.max.x - d.x) * u, n = (r.min.x - d.x) * u), c >= 0 ? (s = (r.min.y - d.y) * c, a = (r.max.y - d.y) * c) : (s = (r.max.y - d.y) * c, a = (r.min.y - d.y) * c), i > a || s > n || ((s > i || isNaN(i)) && (i = s), (a < n || isNaN(n)) && (n = a), h >= 0 ? (o = (r.min.z - d.z) * h, l = (r.max.z - d.z) * h) : (o = (r.max.z - d.z) * h, l = (r.min.z - d.z) * h), i > l || o > n) || ((o > i || i !== i) && (i = o), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(i >= 0 ? i : n, e);
  }
  intersectsBox(r) {
    return this.intersectBox(r, Rs) !== null;
  }
  intersectTriangle(r, e, i, n, s) {
    wy.subVectors(e, r), mp.subVectors(i, r), Ey.crossVectors(wy, mp);
    let a = this.direction.dot(Ey), o;
    if (a > 0) {
      if (n) return null;
      o = 1;
    } else if (a < 0)
      o = -1, a = -a;
    else
      return null;
    Oa.subVectors(this.origin, r);
    const l = o * this.direction.dot(mp.crossVectors(Oa, mp));
    if (l < 0)
      return null;
    const u = o * this.direction.dot(wy.cross(Oa));
    if (u < 0 || l + u > a)
      return null;
    const c = -o * Oa.dot(Ey);
    return c < 0 ? null : this.at(c / a, s);
  }
  applyMatrix4(r) {
    return this.origin.applyMatrix4(r), this.direction.transformDirection(r), this;
  }
  equals(r) {
    return r.origin.equals(this.origin) && r.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}, ui = class Ob {
  constructor(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y) {
    Ob.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y);
  }
  set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y) {
    const g = this.elements;
    return g[0] = e, g[4] = i, g[8] = n, g[12] = s, g[1] = a, g[5] = o, g[9] = l, g[13] = u, g[2] = c, g[6] = h, g[10] = d, g[14] = p, g[3] = f, g[7] = m, g[11] = v, g[15] = y, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Ob().fromArray(this.elements);
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], i[9] = n[9], i[10] = n[10], i[11] = n[11], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15], this;
  }
  copyPosition(e) {
    const i = this.elements, n = e.elements;
    return i[12] = n[12], i[13] = n[13], i[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[3],
      i[6],
      0,
      i[1],
      i[4],
      i[7],
      0,
      i[2],
      i[5],
      i[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrixColumn(this, 0), i.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, i, n) {
    return this.set(
      e.x,
      i.x,
      n.x,
      0,
      e.y,
      i.y,
      n.y,
      0,
      e.z,
      i.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const i = this.elements, n = e.elements, s = 1 / Wl.setFromMatrixColumn(e, 0).length(), a = 1 / Wl.setFromMatrixColumn(e, 1).length(), o = 1 / Wl.setFromMatrixColumn(e, 2).length();
    return i[0] = n[0] * s, i[1] = n[1] * s, i[2] = n[2] * s, i[3] = 0, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[7] = 0, i[8] = n[8] * o, i[9] = n[9] * o, i[10] = n[10] * o, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z, o = Math.cos(n), l = Math.sin(n), u = Math.cos(s), c = Math.sin(s), h = Math.cos(a), d = Math.sin(a);
    if (e.order === "XYZ") {
      const p = o * h, f = o * d, m = l * h, v = l * d;
      i[0] = u * h, i[4] = -u * d, i[8] = c, i[1] = f + m * c, i[5] = p - v * c, i[9] = -l * u, i[2] = v - p * c, i[6] = m + f * c, i[10] = o * u;
    } else if (e.order === "YXZ") {
      const p = u * h, f = u * d, m = c * h, v = c * d;
      i[0] = p + v * l, i[4] = m * l - f, i[8] = o * c, i[1] = o * d, i[5] = o * h, i[9] = -l, i[2] = f * l - m, i[6] = v + p * l, i[10] = o * u;
    } else if (e.order === "ZXY") {
      const p = u * h, f = u * d, m = c * h, v = c * d;
      i[0] = p - v * l, i[4] = -o * d, i[8] = m + f * l, i[1] = f + m * l, i[5] = o * h, i[9] = v - p * l, i[2] = -o * c, i[6] = l, i[10] = o * u;
    } else if (e.order === "ZYX") {
      const p = o * h, f = o * d, m = l * h, v = l * d;
      i[0] = u * h, i[4] = m * c - f, i[8] = p * c + v, i[1] = u * d, i[5] = v * c + p, i[9] = f * c - m, i[2] = -c, i[6] = l * u, i[10] = o * u;
    } else if (e.order === "YZX") {
      const p = o * u, f = o * c, m = l * u, v = l * c;
      i[0] = u * h, i[4] = v - p * d, i[8] = m * d + f, i[1] = d, i[5] = o * h, i[9] = -l * h, i[2] = -c * h, i[6] = f * d + m, i[10] = p - v * d;
    } else if (e.order === "XZY") {
      const p = o * u, f = o * c, m = l * u, v = l * c;
      i[0] = u * h, i[4] = -d, i[8] = c * h, i[1] = p * d + v, i[5] = o * h, i[9] = f * d - m, i[2] = m * d - f, i[6] = l * h, i[10] = v * d + p;
    }
    return i[3] = 0, i[7] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(xB, e, _B);
  }
  lookAt(e, i, n) {
    const s = this.elements;
    return Kr.subVectors(e, i), Kr.lengthSq() === 0 && (Kr.z = 1), Kr.normalize(), Da.crossVectors(n, Kr), Da.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Kr.x += 1e-4 : Kr.z += 1e-4, Kr.normalize(), Da.crossVectors(n, Kr)), Da.normalize(), gp.crossVectors(Kr, Da), s[0] = Da.x, s[4] = gp.x, s[8] = Kr.x, s[1] = Da.y, s[5] = gp.y, s[9] = Kr.y, s[2] = Da.z, s[6] = gp.z, s[10] = Kr.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[4], u = n[8], c = n[12], h = n[1], d = n[5], p = n[9], f = n[13], m = n[2], v = n[6], y = n[10], g = n[14], _ = n[3], x = n[7], b = n[11], T = n[15], S = s[0], w = s[4], A = s[8], E = s[12], M = s[1], N = s[5], k = s[9], U = s[13], C = s[2], O = s[6], D = s[10], H = s[14], j = s[3], K = s[7], L = s[11], B = s[15];
    return a[0] = o * S + l * M + u * C + c * j, a[4] = o * w + l * N + u * O + c * K, a[8] = o * A + l * k + u * D + c * L, a[12] = o * E + l * U + u * H + c * B, a[1] = h * S + d * M + p * C + f * j, a[5] = h * w + d * N + p * O + f * K, a[9] = h * A + d * k + p * D + f * L, a[13] = h * E + d * U + p * H + f * B, a[2] = m * S + v * M + y * C + g * j, a[6] = m * w + v * N + y * O + g * K, a[10] = m * A + v * k + y * D + g * L, a[14] = m * E + v * U + y * H + g * B, a[3] = _ * S + x * M + b * C + T * j, a[7] = _ * w + x * N + b * O + T * K, a[11] = _ * A + x * k + b * D + T * L, a[15] = _ * E + x * U + b * H + T * B, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[4] *= e, i[8] *= e, i[12] *= e, i[1] *= e, i[5] *= e, i[9] *= e, i[13] *= e, i[2] *= e, i[6] *= e, i[10] *= e, i[14] *= e, i[3] *= e, i[7] *= e, i[11] *= e, i[15] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[4], s = e[8], a = e[12], o = e[1], l = e[5], u = e[9], c = e[13], h = e[2], d = e[6], p = e[10], f = e[14], m = e[3], v = e[7], y = e[11], g = e[15];
    return m * (+a * u * d - s * c * d - a * l * p + n * c * p + s * l * f - n * u * f) + v * (+i * u * f - i * c * p + a * o * p - s * o * f + s * c * h - a * u * h) + y * (+i * c * d - i * l * f - a * o * d + n * o * f + a * l * h - n * c * h) + g * (-s * l * h - i * u * d + i * l * p + s * o * d - n * o * p + n * u * h);
  }
  transpose() {
    const e = this.elements;
    let i;
    return i = e[1], e[1] = e[4], e[4] = i, i = e[2], e[2] = e[8], e[8] = i, i = e[6], e[6] = e[9], e[9] = i, i = e[3], e[3] = e[12], e[12] = i, i = e[7], e[7] = e[13], e[13] = i, i = e[11], e[11] = e[14], e[14] = i, this;
  }
  setPosition(e, i, n) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = i, s[14] = n), this;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = e[9], p = e[10], f = e[11], m = e[12], v = e[13], y = e[14], g = e[15], _ = d * y * c - v * p * c + v * u * f - l * y * f - d * u * g + l * p * g, x = m * p * c - h * y * c - m * u * f + o * y * f + h * u * g - o * p * g, b = h * v * c - m * d * c + m * l * f - o * v * f - h * l * g + o * d * g, T = m * d * u - h * v * u - m * l * p + o * v * p + h * l * y - o * d * y, S = i * _ + n * x + s * b + a * T;
    if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / S;
    return e[0] = _ * w, e[1] = (v * p * a - d * y * a - v * s * f + n * y * f + d * s * g - n * p * g) * w, e[2] = (l * y * a - v * u * a + v * s * c - n * y * c - l * s * g + n * u * g) * w, e[3] = (d * u * a - l * p * a - d * s * c + n * p * c + l * s * f - n * u * f) * w, e[4] = x * w, e[5] = (h * y * a - m * p * a + m * s * f - i * y * f - h * s * g + i * p * g) * w, e[6] = (m * u * a - o * y * a - m * s * c + i * y * c + o * s * g - i * u * g) * w, e[7] = (o * p * a - h * u * a + h * s * c - i * p * c - o * s * f + i * u * f) * w, e[8] = b * w, e[9] = (m * d * a - h * v * a - m * n * f + i * v * f + h * n * g - i * d * g) * w, e[10] = (o * v * a - m * l * a + m * n * c - i * v * c - o * n * g + i * l * g) * w, e[11] = (h * l * a - o * d * a - h * n * c + i * d * c + o * n * f - i * l * f) * w, e[12] = T * w, e[13] = (h * v * s - m * d * s + m * n * p - i * v * p - h * n * y + i * d * y) * w, e[14] = (m * l * s - o * v * s - m * n * u + i * v * u + o * n * y - i * l * y) * w, e[15] = (o * d * s - h * l * s + h * n * u - i * d * u - o * n * p + i * l * p) * w, this;
  }
  scale(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z;
    return i[0] *= n, i[4] *= s, i[8] *= a, i[1] *= n, i[5] *= s, i[9] *= a, i[2] *= n, i[6] *= s, i[10] *= a, i[3] *= n, i[7] *= s, i[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(i, n, s));
  }
  makeTranslation(e, i, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      i,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = 1 - n, o = e.x, l = e.y, u = e.z, c = a * o, h = a * l;
    return this.set(
      c * o + n,
      c * l - s * u,
      c * u + s * l,
      0,
      c * l + s * u,
      h * l + n,
      h * u - s * o,
      0,
      c * u - s * l,
      h * u + s * o,
      a * u * u + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, i, n, s, a, o) {
    return this.set(
      1,
      n,
      a,
      0,
      e,
      1,
      o,
      0,
      i,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, i, n) {
    const s = this.elements, a = i._x, o = i._y, l = i._z, u = i._w, c = a + a, h = o + o, d = l + l, p = a * c, f = a * h, m = a * d, v = o * h, y = o * d, g = l * d, _ = u * c, x = u * h, b = u * d, T = n.x, S = n.y, w = n.z;
    return s[0] = (1 - (v + g)) * T, s[1] = (f + b) * T, s[2] = (m - x) * T, s[3] = 0, s[4] = (f - b) * S, s[5] = (1 - (p + g)) * S, s[6] = (y + _) * S, s[7] = 0, s[8] = (m + x) * w, s[9] = (y - _) * w, s[10] = (1 - (p + v)) * w, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, i, n) {
    const s = this.elements;
    let a = Wl.set(s[0], s[1], s[2]).length();
    const o = Wl.set(s[4], s[5], s[6]).length(), l = Wl.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (a = -a), e.x = s[12], e.y = s[13], e.z = s[14], Nn.copy(this);
    const u = 1 / a, c = 1 / o, h = 1 / l;
    return Nn.elements[0] *= u, Nn.elements[1] *= u, Nn.elements[2] *= u, Nn.elements[4] *= c, Nn.elements[5] *= c, Nn.elements[6] *= c, Nn.elements[8] *= h, Nn.elements[9] *= h, Nn.elements[10] *= h, i.setFromRotationMatrix(Nn), n.x = a, n.y = o, n.z = l, this;
  }
  makePerspective(e, i, n, s, a, o, l = sa) {
    const u = this.elements, c = 2 * a / (i - e), h = 2 * a / (n - s), d = (i + e) / (i - e), p = (n + s) / (n - s);
    let f, m;
    if (l === sa)
      f = -(o + a) / (o - a), m = -2 * o * a / (o - a);
    else if (l === gm)
      f = -o / (o - a), m = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return u[0] = c, u[4] = 0, u[8] = d, u[12] = 0, u[1] = 0, u[5] = h, u[9] = p, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = f, u[14] = m, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this;
  }
  makeOrthographic(e, i, n, s, a, o, l = sa) {
    const u = this.elements, c = 1 / (i - e), h = 1 / (n - s), d = 1 / (o - a), p = (i + e) * c, f = (n + s) * h;
    let m, v;
    if (l === sa)
      m = (o + a) * d, v = -2 * d;
    else if (l === gm)
      m = a * d, v = -1 * d;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return u[0] = 2 * c, u[4] = 0, u[8] = 0, u[12] = -p, u[1] = 0, u[5] = 2 * h, u[9] = 0, u[13] = -f, u[2] = 0, u[6] = 0, u[10] = v, u[14] = -m, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this;
  }
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 16; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e[i + 9] = n[9], e[i + 10] = n[10], e[i + 11] = n[11], e[i + 12] = n[12], e[i + 13] = n[13], e[i + 14] = n[14], e[i + 15] = n[15], e;
  }
};
const Wl = /* @__PURE__ */ new q(), Nn = /* @__PURE__ */ new ui(), xB = /* @__PURE__ */ new q(0, 0, 0), _B = /* @__PURE__ */ new q(1, 1, 1), Da = /* @__PURE__ */ new q(), gp = /* @__PURE__ */ new q(), Kr = /* @__PURE__ */ new q(), P1 = /* @__PURE__ */ new ui(), I1 = /* @__PURE__ */ new bs();
let yo = class QC {
  constructor(e = 0, i = 0, n = 0, s = QC.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = i, this._z = n, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, i, n, s = this._order) {
    return this._x = e, this._y = i, this._z = n, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, i = this._order, n = !0) {
    const s = e.elements, a = s[0], o = s[4], l = s[8], u = s[1], c = s[5], h = s[9], d = s[2], p = s[6], f = s[10];
    switch (i) {
      case "XYZ":
        this._y = Math.asin(Ki(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(p, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Ki(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(u, c)) : (this._y = Math.atan2(-d, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Ki(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(u, a));
        break;
      case "ZYX":
        this._y = Math.asin(-Ki(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(u, a)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin(Ki(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-d, a)) : (this._x = 0, this._y = Math.atan2(l, f));
        break;
      case "XZY":
        this._z = Math.asin(-Ki(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + i);
    }
    return this._order = i, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, i, n) {
    return P1.makeRotationFromQuaternion(e), this.setFromRotationMatrix(P1, i, n);
  }
  setFromVector3(e, i = this._order) {
    return this.set(e.x, e.y, e.z, i);
  }
  reorder(e) {
    return I1.setFromEuler(this), this.setFromQuaternion(I1, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
};
yo.DEFAULT_ORDER = "XYZ";
let R_ = class {
  constructor() {
    this.mask = 1;
  }
  set(r) {
    this.mask = (1 << r | 0) >>> 0;
  }
  enable(r) {
    this.mask |= 1 << r | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(r) {
    this.mask ^= 1 << r | 0;
  }
  disable(r) {
    this.mask &= ~(1 << r | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(r) {
    return (this.mask & r.mask) !== 0;
  }
  isEnabled(r) {
    return (this.mask & (1 << r | 0)) !== 0;
  }
}, TB = 0;
const O1 = /* @__PURE__ */ new q(), ql = /* @__PURE__ */ new bs(), Ns = /* @__PURE__ */ new ui(), yp = /* @__PURE__ */ new q(), rh = /* @__PURE__ */ new q(), SB = /* @__PURE__ */ new q(), wB = /* @__PURE__ */ new bs(), D1 = /* @__PURE__ */ new q(1, 0, 0), L1 = /* @__PURE__ */ new q(0, 1, 0), U1 = /* @__PURE__ */ new q(0, 0, 1), k1 = { type: "added" }, EB = { type: "removed" }, Xl = { type: "childadded", child: null }, My = { type: "childremoved", child: null };
let Gr = class Yf extends Cl {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: TB++ }), this.uuid = ca(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Yf.DEFAULT_UP.clone();
    const e = new q(), i = new yo(), n = new bs(), s = new q(1, 1, 1);
    function a() {
      n.setFromEuler(i, !1);
    }
    function o() {
      i.setFromQuaternion(n, void 0, !1);
    }
    i._onChange(a), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      modelViewMatrix: {
        value: new ui()
      },
      normalMatrix: {
        value: new It()
      }
    }), this.matrix = new ui(), this.matrixWorld = new ui(), this.matrixAutoUpdate = Yf.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Yf.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new R_(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, i) {
    this.quaternion.setFromAxisAngle(e, i);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, i) {
    return ql.setFromAxisAngle(e, i), this.quaternion.multiply(ql), this;
  }
  rotateOnWorldAxis(e, i) {
    return ql.setFromAxisAngle(e, i), this.quaternion.premultiply(ql), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(D1, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(L1, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(U1, e);
  }
  translateOnAxis(e, i) {
    return O1.copy(e).applyQuaternion(this.quaternion), this.position.add(O1.multiplyScalar(i)), this;
  }
  translateX(e) {
    return this.translateOnAxis(D1, e);
  }
  translateY(e) {
    return this.translateOnAxis(L1, e);
  }
  translateZ(e) {
    return this.translateOnAxis(U1, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Ns.copy(this.matrixWorld).invert());
  }
  lookAt(e, i, n) {
    e.isVector3 ? yp.copy(e) : yp.set(e, i, n);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), rh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ns.lookAt(rh, yp, this.up) : Ns.lookAt(yp, rh, this.up), this.quaternion.setFromRotationMatrix(Ns), s && (Ns.extractRotation(s.matrixWorld), ql.setFromRotationMatrix(Ns), this.quaternion.premultiply(ql.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.add(arguments[i]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(k1), Xl.child = e, this.dispatchEvent(Xl), Xl.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const i = this.children.indexOf(e);
    return i !== -1 && (e.parent = null, this.children.splice(i, 1), e.dispatchEvent(EB), My.child = e, this.dispatchEvent(My), My.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Ns.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Ns.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ns), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(k1), Xl.child = e, this.dispatchEvent(Xl), Xl.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, i) {
    if (this[e] === i) return this;
    for (let n = 0, s = this.children.length; n < s; n++) {
      const a = this.children[n].getObjectByProperty(e, i);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, i, n = []) {
    this[e] === i && n.push(this);
    const s = this.children;
    for (let a = 0, o = s.length; a < o; a++)
      s[a].getObjectsByProperty(e, i, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(rh, e, SB), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(rh, wB, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const i = this.matrixWorld.elements;
    return e.set(i[8], i[9], i[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const i = this.parent;
    i !== null && (e(i), i.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, i) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), i === !0) {
      const s = this.children;
      for (let a = 0, o = s.length; a < o; a++)
        s[a].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string", n = {};
    i && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
      center: s.boundingSphere.center.toArray(),
      radius: s.boundingSphere.radius
    }), this.boundingBox !== null && (s.boundingBox = {
      min: s.boundingBox.min.toArray(),
      max: s.boundingBox.max.toArray()
    }));
    function a(l, u) {
      return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = a(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const u = l.shapes;
        if (Array.isArray(u))
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c];
            a(e.shapes, d);
          }
        else
          a(e.shapes, u);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let u = 0, c = this.material.length; u < c; u++)
          l.push(a(e.materials, this.material[u]));
        s.material = l;
      } else
        s.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let l = 0; l < this.children.length; l++)
        s.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const u = this.animations[l];
        s.animations.push(a(e.animations, u));
      }
    }
    if (i) {
      const l = o(e.geometries), u = o(e.materials), c = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), f = o(e.animations), m = o(e.nodes);
      l.length > 0 && (n.geometries = l), u.length > 0 && (n.materials = u), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), d.length > 0 && (n.shapes = d), p.length > 0 && (n.skeletons = p), f.length > 0 && (n.animations = f), m.length > 0 && (n.nodes = m);
    }
    return n.object = s, n;
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, i = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), i === !0)
      for (let n = 0; n < e.children.length; n++) {
        const s = e.children[n];
        this.add(s.clone());
      }
    return this;
  }
};
Gr.DEFAULT_UP = /* @__PURE__ */ new q(0, 1, 0);
Gr.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Gr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Pn = /* @__PURE__ */ new q(), Ps = /* @__PURE__ */ new q(), Ay = /* @__PURE__ */ new q(), Is = /* @__PURE__ */ new q(), $l = /* @__PURE__ */ new q(), Yl = /* @__PURE__ */ new q(), F1 = /* @__PURE__ */ new q(), Cy = /* @__PURE__ */ new q(), Ry = /* @__PURE__ */ new q(), Ny = /* @__PURE__ */ new q(), Py = /* @__PURE__ */ new Fi(), Iy = /* @__PURE__ */ new Fi(), Oy = /* @__PURE__ */ new Fi();
let Cu = class Ru {
  constructor(e = new q(), i = new q(), n = new q()) {
    this.a = e, this.b = i, this.c = n;
  }
  static getNormal(e, i, n, s) {
    s.subVectors(n, i), Pn.subVectors(e, i), s.cross(Pn);
    const a = s.lengthSq();
    return a > 0 ? s.multiplyScalar(1 / Math.sqrt(a)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, i, n, s, a) {
    Pn.subVectors(s, i), Ps.subVectors(n, i), Ay.subVectors(e, i);
    const o = Pn.dot(Pn), l = Pn.dot(Ps), u = Pn.dot(Ay), c = Ps.dot(Ps), h = Ps.dot(Ay), d = o * c - l * l;
    if (d === 0)
      return a.set(0, 0, 0), null;
    const p = 1 / d, f = (c * u - l * h) * p, m = (o * h - l * u) * p;
    return a.set(1 - f - m, m, f);
  }
  static containsPoint(e, i, n, s) {
    return this.getBarycoord(e, i, n, s, Is) === null ? !1 : Is.x >= 0 && Is.y >= 0 && Is.x + Is.y <= 1;
  }
  static getInterpolation(e, i, n, s, a, o, l, u) {
    return this.getBarycoord(e, i, n, s, Is) === null ? (u.x = 0, u.y = 0, "z" in u && (u.z = 0), "w" in u && (u.w = 0), null) : (u.setScalar(0), u.addScaledVector(a, Is.x), u.addScaledVector(o, Is.y), u.addScaledVector(l, Is.z), u);
  }
  static getInterpolatedAttribute(e, i, n, s, a, o) {
    return Py.setScalar(0), Iy.setScalar(0), Oy.setScalar(0), Py.fromBufferAttribute(e, i), Iy.fromBufferAttribute(e, n), Oy.fromBufferAttribute(e, s), o.setScalar(0), o.addScaledVector(Py, a.x), o.addScaledVector(Iy, a.y), o.addScaledVector(Oy, a.z), o;
  }
  static isFrontFacing(e, i, n, s) {
    return Pn.subVectors(n, i), Ps.subVectors(e, i), Pn.cross(Ps).dot(s) < 0;
  }
  set(e, i, n) {
    return this.a.copy(e), this.b.copy(i), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, i, n, s) {
    return this.a.copy(e[i]), this.b.copy(e[n]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, i, n, s) {
    return this.a.fromBufferAttribute(e, i), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Pn.subVectors(this.c, this.b), Ps.subVectors(this.a, this.b), Pn.cross(Ps).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ru.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, i) {
    return Ru.getBarycoord(e, this.a, this.b, this.c, i);
  }
  getInterpolation(e, i, n, s, a) {
    return Ru.getInterpolation(e, this.a, this.b, this.c, i, n, s, a);
  }
  containsPoint(e) {
    return Ru.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ru.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, i) {
    const n = this.a, s = this.b, a = this.c;
    let o, l;
    $l.subVectors(s, n), Yl.subVectors(a, n), Cy.subVectors(e, n);
    const u = $l.dot(Cy), c = Yl.dot(Cy);
    if (u <= 0 && c <= 0)
      return i.copy(n);
    Ry.subVectors(e, s);
    const h = $l.dot(Ry), d = Yl.dot(Ry);
    if (h >= 0 && d <= h)
      return i.copy(s);
    const p = u * d - h * c;
    if (p <= 0 && u >= 0 && h <= 0)
      return o = u / (u - h), i.copy(n).addScaledVector($l, o);
    Ny.subVectors(e, a);
    const f = $l.dot(Ny), m = Yl.dot(Ny);
    if (m >= 0 && f <= m)
      return i.copy(a);
    const v = f * c - u * m;
    if (v <= 0 && c >= 0 && m <= 0)
      return l = c / (c - m), i.copy(n).addScaledVector(Yl, l);
    const y = h * m - f * d;
    if (y <= 0 && d - h >= 0 && f - m >= 0)
      return F1.subVectors(a, s), l = (d - h) / (d - h + (f - m)), i.copy(s).addScaledVector(F1, l);
    const g = 1 / (y + v + p);
    return o = v * g, l = p * g, i.copy(n).addScaledVector($l, o).addScaledVector(Yl, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
};
const JC = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, La = { h: 0, s: 0, l: 0 }, vp = { h: 0, s: 0, l: 0 };
function Dy(r, e, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? r + (e - r) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - i) : r;
}
let kt = class {
  constructor(r, e, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(r, e, i);
  }
  set(r, e, i) {
    if (e === void 0 && i === void 0) {
      const n = r;
      n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
    } else
      this.setRGB(r, e, i);
    return this;
  }
  setScalar(r) {
    return this.r = r, this.g = r, this.b = r, this;
  }
  setHex(r, e = sn) {
    return r = Math.floor(r), this.r = (r >> 16 & 255) / 255, this.g = (r >> 8 & 255) / 255, this.b = (r & 255) / 255, Vt.toWorkingColorSpace(this, e), this;
  }
  setRGB(r, e, i, n = Vt.workingColorSpace) {
    return this.r = r, this.g = e, this.b = i, Vt.toWorkingColorSpace(this, n), this;
  }
  setHSL(r, e, i, n = Vt.workingColorSpace) {
    if (r = C_(r, 1), e = Ki(e, 0, 1), i = Ki(i, 0, 1), e === 0)
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + e) : i + e - i * e, a = 2 * i - s;
      this.r = Dy(a, s, r + 1 / 3), this.g = Dy(a, s, r), this.b = Dy(a, s, r - 1 / 3);
    }
    return Vt.toWorkingColorSpace(this, n), this;
  }
  setStyle(r, e = sn) {
    function i(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + r + " will be ignored.");
    }
    let n;
    if (n = /^(\w+)\(([^\)]*)\)/.exec(r)) {
      let s;
      const a = n[1], o = n[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setRGB(
              Math.min(255, parseInt(s[1], 10)) / 255,
              Math.min(255, parseInt(s[2], 10)) / 255,
              Math.min(255, parseInt(s[3], 10)) / 255,
              e
            );
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setRGB(
              Math.min(100, parseInt(s[1], 10)) / 100,
              Math.min(100, parseInt(s[2], 10)) / 100,
              Math.min(100, parseInt(s[3], 10)) / 100,
              e
            );
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setHSL(
              parseFloat(s[1]) / 360,
              parseFloat(s[2]) / 100,
              parseFloat(s[3]) / 100,
              e
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + r);
      }
    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(r)) {
      const s = n[1], a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          e
        );
      if (a === 6)
        return this.setHex(parseInt(s, 16), e);
      console.warn("THREE.Color: Invalid hex color " + r);
    } else if (r && r.length > 0)
      return this.setColorName(r, e);
    return this;
  }
  setColorName(r, e = sn) {
    const i = JC[r.toLowerCase()];
    return i !== void 0 ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + r), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(r) {
    return this.r = r.r, this.g = r.g, this.b = r.b, this;
  }
  copySRGBToLinear(r) {
    return this.r = ha(r.r), this.g = ha(r.g), this.b = ha(r.b), this;
  }
  copyLinearToSRGB(r) {
    return this.r = Wu(r.r), this.g = Wu(r.g), this.b = Wu(r.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(r = sn) {
    return Vt.fromWorkingColorSpace(ur.copy(this), r), Math.round(Ki(ur.r * 255, 0, 255)) * 65536 + Math.round(Ki(ur.g * 255, 0, 255)) * 256 + Math.round(Ki(ur.b * 255, 0, 255));
  }
  getHexString(r = sn) {
    return ("000000" + this.getHex(r).toString(16)).slice(-6);
  }
  getHSL(r, e = Vt.workingColorSpace) {
    Vt.fromWorkingColorSpace(ur.copy(this), e);
    const i = ur.r, n = ur.g, s = ur.b, a = Math.max(i, n, s), o = Math.min(i, n, s);
    let l, u;
    const c = (o + a) / 2;
    if (o === a)
      l = 0, u = 0;
    else {
      const h = a - o;
      switch (u = c <= 0.5 ? h / (a + o) : h / (2 - a - o), a) {
        case i:
          l = (n - s) / h + (n < s ? 6 : 0);
          break;
        case n:
          l = (s - i) / h + 2;
          break;
        case s:
          l = (i - n) / h + 4;
          break;
      }
      l /= 6;
    }
    return r.h = l, r.s = u, r.l = c, r;
  }
  getRGB(r, e = Vt.workingColorSpace) {
    return Vt.fromWorkingColorSpace(ur.copy(this), e), r.r = ur.r, r.g = ur.g, r.b = ur.b, r;
  }
  getStyle(r = sn) {
    Vt.fromWorkingColorSpace(ur.copy(this), r);
    const e = ur.r, i = ur.g, n = ur.b;
    return r !== sn ? `color(${r} ${e.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`;
  }
  offsetHSL(r, e, i) {
    return this.getHSL(La), this.setHSL(La.h + r, La.s + e, La.l + i);
  }
  add(r) {
    return this.r += r.r, this.g += r.g, this.b += r.b, this;
  }
  addColors(r, e) {
    return this.r = r.r + e.r, this.g = r.g + e.g, this.b = r.b + e.b, this;
  }
  addScalar(r) {
    return this.r += r, this.g += r, this.b += r, this;
  }
  sub(r) {
    return this.r = Math.max(0, this.r - r.r), this.g = Math.max(0, this.g - r.g), this.b = Math.max(0, this.b - r.b), this;
  }
  multiply(r) {
    return this.r *= r.r, this.g *= r.g, this.b *= r.b, this;
  }
  multiplyScalar(r) {
    return this.r *= r, this.g *= r, this.b *= r, this;
  }
  lerp(r, e) {
    return this.r += (r.r - this.r) * e, this.g += (r.g - this.g) * e, this.b += (r.b - this.b) * e, this;
  }
  lerpColors(r, e, i) {
    return this.r = r.r + (e.r - r.r) * i, this.g = r.g + (e.g - r.g) * i, this.b = r.b + (e.b - r.b) * i, this;
  }
  lerpHSL(r, e) {
    this.getHSL(La), r.getHSL(vp);
    const i = $h(La.h, vp.h, e), n = $h(La.s, vp.s, e), s = $h(La.l, vp.l, e);
    return this.setHSL(i, n, s), this;
  }
  setFromVector3(r) {
    return this.r = r.x, this.g = r.y, this.b = r.z, this;
  }
  applyMatrix3(r) {
    const e = this.r, i = this.g, n = this.b, s = r.elements;
    return this.r = s[0] * e + s[3] * i + s[6] * n, this.g = s[1] * e + s[4] * i + s[7] * n, this.b = s[2] * e + s[5] * i + s[8] * n, this;
  }
  equals(r) {
    return r.r === this.r && r.g === this.g && r.b === this.b;
  }
  fromArray(r, e = 0) {
    return this.r = r[e], this.g = r[e + 1], this.b = r[e + 2], this;
  }
  toArray(r = [], e = 0) {
    return r[e] = this.r, r[e + 1] = this.g, r[e + 2] = this.b, r;
  }
  fromBufferAttribute(r, e) {
    return this.r = r.getX(e), this.g = r.getY(e), this.b = r.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const ur = /* @__PURE__ */ new kt();
kt.NAMES = JC;
let MB = 0, Nl = class extends Cl {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(r) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: MB++ }), this.uuid = ca(), this.name = "", this.blending = Gu, this.side = mo, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = q0, this.blendDst = X0, this.blendEquation = Xo, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new kt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = hc, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = _1, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = zl, this.stencilZFail = zl, this.stencilZPass = zl, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(r) {
    this._alphaTest > 0 != r > 0 && this.version++, this._alphaTest = r;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(r) {
    if (r !== void 0)
      for (const e in r) {
        const i = r[e];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
          continue;
        }
        const n = this[e];
        if (n === void 0) {
          console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
          continue;
        }
        n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i;
      }
  }
  toJSON(r) {
    const e = r === void 0 || typeof r == "string";
    e && (r = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(r).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(r).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(r).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(r).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(r).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(r).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(r).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(r).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(r).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(r).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(r).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(r).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(r).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(r).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(r).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(r).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(r).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(r).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(r).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(r).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(r).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(r).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(r).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(r).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Gu && (i.blending = this.blending), this.side !== mo && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== q0 && (i.blendSrc = this.blendSrc), this.blendDst !== X0 && (i.blendDst = this.blendDst), this.blendEquation !== Xo && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== hc && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== _1 && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== zl && (i.stencilFail = this.stencilFail), this.stencilZFail !== zl && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== zl && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function n(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (e) {
      const s = n(r.textures), a = n(r.images);
      s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    this.name = r.name, this.blending = r.blending, this.side = r.side, this.vertexColors = r.vertexColors, this.opacity = r.opacity, this.transparent = r.transparent, this.blendSrc = r.blendSrc, this.blendDst = r.blendDst, this.blendEquation = r.blendEquation, this.blendSrcAlpha = r.blendSrcAlpha, this.blendDstAlpha = r.blendDstAlpha, this.blendEquationAlpha = r.blendEquationAlpha, this.blendColor.copy(r.blendColor), this.blendAlpha = r.blendAlpha, this.depthFunc = r.depthFunc, this.depthTest = r.depthTest, this.depthWrite = r.depthWrite, this.stencilWriteMask = r.stencilWriteMask, this.stencilFunc = r.stencilFunc, this.stencilRef = r.stencilRef, this.stencilFuncMask = r.stencilFuncMask, this.stencilFail = r.stencilFail, this.stencilZFail = r.stencilZFail, this.stencilZPass = r.stencilZPass, this.stencilWrite = r.stencilWrite;
    const e = r.clippingPlanes;
    let i = null;
    if (e !== null) {
      const n = e.length;
      i = new Array(n);
      for (let s = 0; s !== n; ++s)
        i[s] = e[s].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = r.clipIntersection, this.clipShadows = r.clipShadows, this.shadowSide = r.shadowSide, this.colorWrite = r.colorWrite, this.precision = r.precision, this.polygonOffset = r.polygonOffset, this.polygonOffsetFactor = r.polygonOffsetFactor, this.polygonOffsetUnits = r.polygonOffsetUnits, this.dithering = r.dithering, this.alphaTest = r.alphaTest, this.alphaHash = r.alphaHash, this.alphaToCoverage = r.alphaToCoverage, this.premultipliedAlpha = r.premultipliedAlpha, this.forceSinglePass = r.forceSinglePass, this.visible = r.visible, this.toneMapped = r.toneMapped, this.userData = JSON.parse(JSON.stringify(r.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}, _g = class extends Nl {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(r) {
    super(), this.isMeshBasicMaterial = !0, this.color = new kt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new yo(), this.combine = __, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.lightMap = r.lightMap, this.lightMapIntensity = r.lightMapIntensity, this.aoMap = r.aoMap, this.aoMapIntensity = r.aoMapIntensity, this.specularMap = r.specularMap, this.alphaMap = r.alphaMap, this.envMap = r.envMap, this.envMapRotation.copy(r.envMapRotation), this.combine = r.combine, this.reflectivity = r.reflectivity, this.refractionRatio = r.refractionRatio, this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.wireframeLinecap = r.wireframeLinecap, this.wireframeLinejoin = r.wireframeLinejoin, this.fog = r.fog, this;
  }
};
const Pi = /* @__PURE__ */ new q(), bp = /* @__PURE__ */ new Ue();
let _n = class {
  constructor(r, e, i = !1) {
    if (Array.isArray(r))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = r, this.itemSize = e, this.count = r !== void 0 ? r.length / e : 0, this.normalized = i, this.usage = Pb, this.updateRanges = [], this.gpuType = na, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  setUsage(r) {
    return this.usage = r, this;
  }
  addUpdateRange(r, e) {
    this.updateRanges.push({ start: r, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(r) {
    return this.name = r.name, this.array = new r.array.constructor(r.array), this.itemSize = r.itemSize, this.count = r.count, this.normalized = r.normalized, this.usage = r.usage, this.gpuType = r.gpuType, this;
  }
  copyAt(r, e, i) {
    r *= this.itemSize, i *= e.itemSize;
    for (let n = 0, s = this.itemSize; n < s; n++)
      this.array[r + n] = e.array[i + n];
    return this;
  }
  copyArray(r) {
    return this.array.set(r), this;
  }
  applyMatrix3(r) {
    if (this.itemSize === 2)
      for (let e = 0, i = this.count; e < i; e++)
        bp.fromBufferAttribute(this, e), bp.applyMatrix3(r), this.setXY(e, bp.x, bp.y);
    else if (this.itemSize === 3)
      for (let e = 0, i = this.count; e < i; e++)
        Pi.fromBufferAttribute(this, e), Pi.applyMatrix3(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  applyMatrix4(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.applyMatrix4(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  applyNormalMatrix(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.applyNormalMatrix(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  transformDirection(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.transformDirection(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  set(r, e = 0) {
    return this.array.set(r, e), this;
  }
  getComponent(r, e) {
    let i = this.array[r * this.itemSize + e];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  setComponent(r, e, i) {
    return this.normalized && (i = Qt(i, this.array)), this.array[r * this.itemSize + e] = i, this;
  }
  getX(r) {
    let e = this.array[r * this.itemSize];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setX(r, e) {
    return this.normalized && (e = Qt(e, this.array)), this.array[r * this.itemSize] = e, this;
  }
  getY(r) {
    let e = this.array[r * this.itemSize + 1];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setY(r, e) {
    return this.normalized && (e = Qt(e, this.array)), this.array[r * this.itemSize + 1] = e, this;
  }
  getZ(r) {
    let e = this.array[r * this.itemSize + 2];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setZ(r, e) {
    return this.normalized && (e = Qt(e, this.array)), this.array[r * this.itemSize + 2] = e, this;
  }
  getW(r) {
    let e = this.array[r * this.itemSize + 3];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setW(r, e) {
    return this.normalized && (e = Qt(e, this.array)), this.array[r * this.itemSize + 3] = e, this;
  }
  setXY(r, e, i) {
    return r *= this.itemSize, this.normalized && (e = Qt(e, this.array), i = Qt(i, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this;
  }
  setXYZ(r, e, i, n) {
    return r *= this.itemSize, this.normalized && (e = Qt(e, this.array), i = Qt(i, this.array), n = Qt(n, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this.array[r + 2] = n, this;
  }
  setXYZW(r, e, i, n, s) {
    return r *= this.itemSize, this.normalized && (e = Qt(e, this.array), i = Qt(i, this.array), n = Qt(n, this.array), s = Qt(s, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this.array[r + 2] = n, this.array[r + 3] = s, this;
  }
  onUpload(r) {
    return this.onUploadCallback = r, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const r = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (r.name = this.name), this.usage !== Pb && (r.usage = this.usage), r;
  }
}, eR = class extends _n {
  constructor(r, e, i) {
    super(new Uint16Array(r), e, i);
  }
}, tR = class extends _n {
  constructor(r, e, i) {
    super(new Uint32Array(r), e, i);
  }
}, Ri = class extends _n {
  constructor(r, e, i) {
    super(new Float32Array(r), e, i);
  }
}, AB = 0;
const dn = /* @__PURE__ */ new ui(), Ly = /* @__PURE__ */ new Gr(), Kl = /* @__PURE__ */ new q(), Zr = /* @__PURE__ */ new Rl(), nh = /* @__PURE__ */ new Rl(), qi = /* @__PURE__ */ new q();
let cn = class iR extends Cl {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: AB++ }), this.uuid = ca(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (XC(e) ? tR : eR)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, i) {
    return this.attributes[e] = i, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, i, n = 0) {
    this.groups.push({
      start: e,
      count: i,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, i) {
    this.drawRange.start = e, this.drawRange.count = i;
  }
  applyMatrix4(e) {
    const i = this.attributes.position;
    i !== void 0 && (i.applyMatrix4(e), i.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const a = new It().getNormalMatrix(e);
      n.applyNormalMatrix(a), n.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return dn.makeRotationFromQuaternion(e), this.applyMatrix4(dn), this;
  }
  rotateX(e) {
    return dn.makeRotationX(e), this.applyMatrix4(dn), this;
  }
  rotateY(e) {
    return dn.makeRotationY(e), this.applyMatrix4(dn), this;
  }
  rotateZ(e) {
    return dn.makeRotationZ(e), this.applyMatrix4(dn), this;
  }
  translate(e, i, n) {
    return dn.makeTranslation(e, i, n), this.applyMatrix4(dn), this;
  }
  scale(e, i, n) {
    return dn.makeScale(e, i, n), this.applyMatrix4(dn), this;
  }
  lookAt(e) {
    return Ly.lookAt(e), Ly.updateMatrix(), this.applyMatrix4(Ly.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Kl).negate(), this.translate(Kl.x, Kl.y, Kl.z), this;
  }
  setFromPoints(e) {
    const i = this.getAttribute("position");
    if (i === void 0) {
      const n = [];
      for (let s = 0, a = e.length; s < a; s++) {
        const o = e[s];
        n.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new Ri(n, 3));
    } else {
      for (let n = 0, s = i.count; n < s; n++) {
        const a = e[n];
        i.setXYZ(n, a.x, a.y, a.z || 0);
      }
      e.length > i.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), i.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Rl());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new q(-1 / 0, -1 / 0, -1 / 0),
        new q(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), i)
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n];
          Zr.setFromBufferAttribute(a), this.morphTargetsRelative ? (qi.addVectors(this.boundingBox.min, Zr.min), this.boundingBox.expandByPoint(qi), qi.addVectors(this.boundingBox.max, Zr.max), this.boundingBox.expandByPoint(qi)) : (this.boundingBox.expandByPoint(Zr.min), this.boundingBox.expandByPoint(Zr.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new bg());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new q(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (Zr.setFromBufferAttribute(e), i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a];
          nh.setFromBufferAttribute(l), this.morphTargetsRelative ? (qi.addVectors(Zr.min, nh.min), Zr.expandByPoint(qi), qi.addVectors(Zr.max, nh.max), Zr.expandByPoint(qi)) : (Zr.expandByPoint(nh.min), Zr.expandByPoint(nh.max));
        }
      Zr.getCenter(n);
      let s = 0;
      for (let a = 0, o = e.count; a < o; a++)
        qi.fromBufferAttribute(e, a), s = Math.max(s, n.distanceToSquared(qi));
      if (i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a], u = this.morphTargetsRelative;
          for (let c = 0, h = l.count; c < h; c++)
            qi.fromBufferAttribute(l, c), u && (Kl.fromBufferAttribute(e, c), qi.add(Kl)), s = Math.max(s, n.distanceToSquared(qi));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, i = this.attributes;
    if (e === null || i.position === void 0 || i.normal === void 0 || i.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = i.position, s = i.normal, a = i.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new _n(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"), l = [], u = [];
    for (let A = 0; A < n.count; A++)
      l[A] = new q(), u[A] = new q();
    const c = new q(), h = new q(), d = new q(), p = new Ue(), f = new Ue(), m = new Ue(), v = new q(), y = new q();
    function g(A, E, M) {
      c.fromBufferAttribute(n, A), h.fromBufferAttribute(n, E), d.fromBufferAttribute(n, M), p.fromBufferAttribute(a, A), f.fromBufferAttribute(a, E), m.fromBufferAttribute(a, M), h.sub(c), d.sub(c), f.sub(p), m.sub(p);
      const N = 1 / (f.x * m.y - m.x * f.y);
      isFinite(N) && (v.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(N), y.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(N), l[A].add(v), l[E].add(v), l[M].add(v), u[A].add(y), u[E].add(y), u[M].add(y));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{
      start: 0,
      count: e.count
    }]);
    for (let A = 0, E = _.length; A < E; ++A) {
      const M = _[A], N = M.start, k = M.count;
      for (let U = N, C = N + k; U < C; U += 3)
        g(
          e.getX(U + 0),
          e.getX(U + 1),
          e.getX(U + 2)
        );
    }
    const x = new q(), b = new q(), T = new q(), S = new q();
    function w(A) {
      T.fromBufferAttribute(s, A), S.copy(T);
      const E = l[A];
      x.copy(E), x.sub(T.multiplyScalar(T.dot(E))).normalize(), b.crossVectors(S, E);
      const M = b.dot(u[A]) < 0 ? -1 : 1;
      o.setXYZW(A, x.x, x.y, x.z, M);
    }
    for (let A = 0, E = _.length; A < E; ++A) {
      const M = _[A], N = M.start, k = M.count;
      for (let U = N, C = N + k; U < C; U += 3)
        w(e.getX(U + 0)), w(e.getX(U + 1)), w(e.getX(U + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, i = this.getAttribute("position");
    if (i !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new _n(new Float32Array(i.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let p = 0, f = n.count; p < f; p++)
          n.setXYZ(p, 0, 0, 0);
      const s = new q(), a = new q(), o = new q(), l = new q(), u = new q(), c = new q(), h = new q(), d = new q();
      if (e)
        for (let p = 0, f = e.count; p < f; p += 3) {
          const m = e.getX(p + 0), v = e.getX(p + 1), y = e.getX(p + 2);
          s.fromBufferAttribute(i, m), a.fromBufferAttribute(i, v), o.fromBufferAttribute(i, y), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, v), c.fromBufferAttribute(n, y), l.add(h), u.add(h), c.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(v, u.x, u.y, u.z), n.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let p = 0, f = i.count; p < f; p += 3)
          s.fromBufferAttribute(i, p + 0), a.fromBufferAttribute(i, p + 1), o.fromBufferAttribute(i, p + 2), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), n.setXYZ(p + 0, h.x, h.y, h.z), n.setXYZ(p + 1, h.x, h.y, h.z), n.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let i = 0, n = e.count; i < n; i++)
      qi.fromBufferAttribute(e, i), qi.normalize(), e.setXYZ(i, qi.x, qi.y, qi.z);
  }
  toNonIndexed() {
    function e(l, u) {
      const c = l.array, h = l.itemSize, d = l.normalized, p = new c.constructor(u.length * h);
      let f = 0, m = 0;
      for (let v = 0, y = u.length; v < y; v++) {
        l.isInterleavedBufferAttribute ? f = u[v] * l.data.stride + l.offset : f = u[v] * h;
        for (let g = 0; g < h; g++)
          p[m++] = c[f++];
      }
      return new _n(p, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const i = new iR(), n = this.index.array, s = this.attributes;
    for (const l in s) {
      const u = s[l], c = e(u, n);
      i.setAttribute(l, c);
    }
    const a = this.morphAttributes;
    for (const l in a) {
      const u = [], c = a[l];
      for (let h = 0, d = c.length; h < d; h++) {
        const p = c[h], f = e(p, n);
        u.push(f);
      }
      i.morphAttributes[l] = u;
    }
    i.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const c = o[l];
      i.addGroup(c.start, c.count, c.materialIndex);
    }
    return i;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const u = this.parameters;
      for (const c in u)
        u[c] !== void 0 && (e[c] = u[c]);
      return e;
    }
    e.data = { attributes: {} };
    const i = this.index;
    i !== null && (e.data.index = {
      type: i.array.constructor.name,
      array: Array.prototype.slice.call(i.array)
    });
    const n = this.attributes;
    for (const u in n) {
      const c = n[u];
      e.data.attributes[u] = c.toJSON(e.data);
    }
    const s = {};
    let a = !1;
    for (const u in this.morphAttributes) {
      const c = this.morphAttributes[u], h = [];
      for (let d = 0, p = c.length; d < p; d++) {
        const f = c[d];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (s[u] = h, a = !0);
    }
    a && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const i = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(i));
    const s = e.attributes;
    for (const c in s) {
      const h = s[c];
      this.setAttribute(c, h.clone(i));
    }
    const a = e.morphAttributes;
    for (const c in a) {
      const h = [], d = a[c];
      for (let p = 0, f = d.length; p < f; p++)
        h.push(d[p].clone(i));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = e.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
const B1 = /* @__PURE__ */ new ui(), Po = /* @__PURE__ */ new xg(), xp = /* @__PURE__ */ new bg(), z1 = /* @__PURE__ */ new q(), _p = /* @__PURE__ */ new q(), Tp = /* @__PURE__ */ new q(), Sp = /* @__PURE__ */ new q(), Uy = /* @__PURE__ */ new q(), wp = /* @__PURE__ */ new q(), j1 = /* @__PURE__ */ new q(), Ep = /* @__PURE__ */ new q();
let Ur = class extends Gr {
  constructor(r = new cn(), e = new _g()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = r, this.material = e, this.updateMorphTargets();
  }
  copy(r, e) {
    return super.copy(r, e), r.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = r.morphTargetInfluences.slice()), r.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, r.morphTargetDictionary)), this.material = Array.isArray(r.material) ? r.material.slice() : r.material, this.geometry = r.geometry, this;
  }
  updateMorphTargets() {
    const r = this.geometry.morphAttributes, e = Object.keys(r);
    if (e.length > 0) {
      const i = r[e[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n].name || String(n);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = n;
        }
      }
    }
  }
  getVertexPosition(r, e) {
    const i = this.geometry, n = i.attributes.position, s = i.morphAttributes.position, a = i.morphTargetsRelative;
    e.fromBufferAttribute(n, r);
    const o = this.morphTargetInfluences;
    if (s && o) {
      wp.set(0, 0, 0);
      for (let l = 0, u = s.length; l < u; l++) {
        const c = o[l], h = s[l];
        c !== 0 && (Uy.fromBufferAttribute(h, r), a ? wp.addScaledVector(Uy, c) : wp.addScaledVector(Uy.sub(e), c));
      }
      e.add(wp);
    }
    return e;
  }
  raycast(r, e) {
    const i = this.geometry, n = this.material, s = this.matrixWorld;
    n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), xp.copy(i.boundingSphere), xp.applyMatrix4(s), Po.copy(r.ray).recast(r.near), !(xp.containsPoint(Po.origin) === !1 && (Po.intersectSphere(xp, z1) === null || Po.origin.distanceToSquared(z1) > (r.far - r.near) ** 2)) && (B1.copy(s).invert(), Po.copy(r.ray).applyMatrix4(B1), !(i.boundingBox !== null && Po.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(r, e, Po)));
  }
  _computeIntersections(r, e, i) {
    let n;
    const s = this.geometry, a = this.material, o = s.index, l = s.attributes.position, u = s.attributes.uv, c = s.attributes.uv1, h = s.attributes.normal, d = s.groups, p = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let f = 0, m = d.length; f < m; f++) {
          const v = d[f], y = a[v.materialIndex], g = Math.max(v.start, p.start), _ = Math.min(o.count, Math.min(v.start + v.count, p.start + p.count));
          for (let x = g, b = _; x < b; x += 3) {
            const T = o.getX(x), S = o.getX(x + 1), w = o.getX(x + 2);
            n = Mp(this, y, r, i, u, c, h, T, S, w), n && (n.faceIndex = Math.floor(x / 3), n.face.materialIndex = v.materialIndex, e.push(n));
          }
        }
      else {
        const f = Math.max(0, p.start), m = Math.min(o.count, p.start + p.count);
        for (let v = f, y = m; v < y; v += 3) {
          const g = o.getX(v), _ = o.getX(v + 1), x = o.getX(v + 2);
          n = Mp(this, a, r, i, u, c, h, g, _, x), n && (n.faceIndex = Math.floor(v / 3), e.push(n));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let f = 0, m = d.length; f < m; f++) {
          const v = d[f], y = a[v.materialIndex], g = Math.max(v.start, p.start), _ = Math.min(l.count, Math.min(v.start + v.count, p.start + p.count));
          for (let x = g, b = _; x < b; x += 3) {
            const T = x, S = x + 1, w = x + 2;
            n = Mp(this, y, r, i, u, c, h, T, S, w), n && (n.faceIndex = Math.floor(x / 3), n.face.materialIndex = v.materialIndex, e.push(n));
          }
        }
      else {
        const f = Math.max(0, p.start), m = Math.min(l.count, p.start + p.count);
        for (let v = f, y = m; v < y; v += 3) {
          const g = v, _ = v + 1, x = v + 2;
          n = Mp(this, a, r, i, u, c, h, g, _, x), n && (n.faceIndex = Math.floor(v / 3), e.push(n));
        }
      }
  }
};
function CB(r, e, i, n, s, a, o, l) {
  let u;
  if (e.side === Ar ? u = n.intersectTriangle(o, a, s, !0, l) : u = n.intersectTriangle(s, a, o, e.side === mo, l), u === null) return null;
  Ep.copy(l), Ep.applyMatrix4(r.matrixWorld);
  const c = i.ray.origin.distanceTo(Ep);
  return c < i.near || c > i.far ? null : {
    distance: c,
    point: Ep.clone(),
    object: r
  };
}
function Mp(r, e, i, n, s, a, o, l, u, c) {
  r.getVertexPosition(l, _p), r.getVertexPosition(u, Tp), r.getVertexPosition(c, Sp);
  const h = CB(r, e, i, n, _p, Tp, Sp, j1);
  if (h) {
    const d = new q();
    Cu.getBarycoord(j1, _p, Tp, Sp, d), s && (h.uv = Cu.getInterpolatedAttribute(s, l, u, c, d, new Ue())), a && (h.uv1 = Cu.getInterpolatedAttribute(a, l, u, c, d, new Ue())), o && (h.normal = Cu.getInterpolatedAttribute(o, l, u, c, d, new q()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const p = {
      a: l,
      b: u,
      c,
      normal: new q(),
      materialIndex: 0
    };
    Cu.getNormal(_p, Tp, Sp, p.normal), h.face = p, h.barycoord = d;
  }
  return h;
}
let N_ = class rR extends cn {
  constructor(e = 1, i = 1, n = 1, s = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: i,
      depth: n,
      widthSegments: s,
      heightSegments: a,
      depthSegments: o
    };
    const l = this;
    s = Math.floor(s), a = Math.floor(a), o = Math.floor(o);
    const u = [], c = [], h = [], d = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, n, i, e, o, a, 0), m("z", "y", "x", 1, -1, n, i, -e, o, a, 1), m("x", "z", "y", 1, 1, e, n, i, s, o, 2), m("x", "z", "y", 1, -1, e, n, -i, s, o, 3), m("x", "y", "z", 1, -1, e, i, n, s, a, 4), m("x", "y", "z", -1, -1, e, i, -n, s, a, 5), this.setIndex(u), this.setAttribute("position", new Ri(c, 3)), this.setAttribute("normal", new Ri(h, 3)), this.setAttribute("uv", new Ri(d, 2));
    function m(v, y, g, _, x, b, T, S, w, A, E) {
      const M = b / w, N = T / A, k = b / 2, U = T / 2, C = S / 2, O = w + 1, D = A + 1;
      let H = 0, j = 0;
      const K = new q();
      for (let L = 0; L < D; L++) {
        const B = L * N - U;
        for (let Q = 0; Q < O; Q++) {
          const W = Q * M - k;
          K[v] = W * _, K[y] = B * x, K[g] = C, c.push(K.x, K.y, K.z), K[v] = 0, K[y] = 0, K[g] = S > 0 ? 1 : -1, h.push(K.x, K.y, K.z), d.push(Q / w), d.push(1 - L / A), H += 1;
        }
      }
      for (let L = 0; L < A; L++)
        for (let B = 0; B < w; B++) {
          const Q = p + B + O * L, W = p + B + O * (L + 1), z = p + (B + 1) + O * (L + 1), X = p + (B + 1) + O * L;
          u.push(Q, W, X), u.push(W, z, X), j += 6;
        }
      l.addGroup(f, j, E), f += j, p += H;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new rR(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
};
function gc(r) {
  const e = {};
  for (const i in r) {
    e[i] = {};
    for (const n in r[i]) {
      const s = r[i][n];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][n] = null) : e[i][n] = s.clone() : Array.isArray(s) ? e[i][n] = s.slice() : e[i][n] = s;
    }
  }
  return e;
}
function _r(r) {
  const e = {};
  for (let i = 0; i < r.length; i++) {
    const n = gc(r[i]);
    for (const s in n)
      e[s] = n[s];
  }
  return e;
}
function RB(r) {
  const e = [];
  for (let i = 0; i < r.length; i++)
    e.push(r[i].clone());
  return e;
}
function nR(r) {
  const e = r.getRenderTarget();
  return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Vt.workingColorSpace;
}
const sR = { clone: gc, merge: _r };
var NB = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, PB = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
let xs = class extends Nl {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(r) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = NB, this.fragmentShader = PB, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, r !== void 0 && this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.fragmentShader = r.fragmentShader, this.vertexShader = r.vertexShader, this.uniforms = gc(r.uniforms), this.uniformsGroups = RB(r.uniformsGroups), this.defines = Object.assign({}, r.defines), this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.fog = r.fog, this.lights = r.lights, this.clipping = r.clipping, this.extensions = Object.assign({}, r.extensions), this.glslVersion = r.glslVersion, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    e.glslVersion = this.glslVersion, e.uniforms = {};
    for (const n in this.uniforms) {
      const s = this.uniforms[n].value;
      s && s.isTexture ? e.uniforms[n] = {
        type: "t",
        value: s.toJSON(r).uuid
      } : s && s.isColor ? e.uniforms[n] = {
        type: "c",
        value: s.getHex()
      } : s && s.isVector2 ? e.uniforms[n] = {
        type: "v2",
        value: s.toArray()
      } : s && s.isVector3 ? e.uniforms[n] = {
        type: "v3",
        value: s.toArray()
      } : s && s.isVector4 ? e.uniforms[n] = {
        type: "v4",
        value: s.toArray()
      } : s && s.isMatrix3 ? e.uniforms[n] = {
        type: "m3",
        value: s.toArray()
      } : s && s.isMatrix4 ? e.uniforms[n] = {
        type: "m4",
        value: s.toArray()
      } : e.uniforms[n] = {
        value: s
      };
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
    const i = {};
    for (const n in this.extensions)
      this.extensions[n] === !0 && (i[n] = !0);
    return Object.keys(i).length > 0 && (e.extensions = i), e;
  }
}, aR = class extends Gr {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ui(), this.projectionMatrix = new ui(), this.projectionMatrixInverse = new ui(), this.coordinateSystem = sa;
  }
  copy(r, e) {
    return super.copy(r, e), this.matrixWorldInverse.copy(r.matrixWorldInverse), this.projectionMatrix.copy(r.projectionMatrix), this.projectionMatrixInverse.copy(r.projectionMatrixInverse), this.coordinateSystem = r.coordinateSystem, this;
  }
  getWorldDirection(r) {
    return super.getWorldDirection(r).negate();
  }
  updateMatrixWorld(r) {
    super.updateMatrixWorld(r), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(r, e) {
    super.updateWorldMatrix(r, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const Ua = /* @__PURE__ */ new q(), V1 = /* @__PURE__ */ new Ue(), G1 = /* @__PURE__ */ new Ue();
let vn = class extends aR {
  constructor(r = 50, e = 1, i = 0.1, n = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = r, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(r, e) {
    return super.copy(r, e), this.fov = r.fov, this.zoom = r.zoom, this.near = r.near, this.far = r.far, this.focus = r.focus, this.aspect = r.aspect, this.view = r.view === null ? null : Object.assign({}, r.view), this.filmGauge = r.filmGauge, this.filmOffset = r.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(r) {
    const e = 0.5 * this.getFilmHeight() / r;
    this.fov = cd * 2 * Math.atan(e), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const r = Math.tan(Xh * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / r;
  }
  getEffectiveFOV() {
    return cd * 2 * Math.atan(
      Math.tan(Xh * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(r, e, i) {
    Ua.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), e.set(Ua.x, Ua.y).multiplyScalar(-r / Ua.z), Ua.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Ua.x, Ua.y).multiplyScalar(-r / Ua.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(r, e) {
    return this.getViewBounds(r, V1, G1), e.subVectors(G1, V1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(r, e, i, n, s, a) {
    this.aspect = r / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = r, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const r = this.near;
    let e = r * Math.tan(Xh * 0.5 * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, s = -0.5 * n;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth, u = a.fullHeight;
      s += a.offsetX * n / l, e -= a.offsetY * i / u, n *= a.width / l, i *= a.height / u;
    }
    const o = this.filmOffset;
    o !== 0 && (s += r * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + n, e, e - i, r, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
};
const Zl = -90, Ql = 1;
let IB = class extends Gr {
  constructor(r, e, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const n = new vn(Zl, Ql, r, e);
    n.layers = this.layers, this.add(n);
    const s = new vn(Zl, Ql, r, e);
    s.layers = this.layers, this.add(s);
    const a = new vn(Zl, Ql, r, e);
    a.layers = this.layers, this.add(a);
    const o = new vn(Zl, Ql, r, e);
    o.layers = this.layers, this.add(o);
    const l = new vn(Zl, Ql, r, e);
    l.layers = this.layers, this.add(l);
    const u = new vn(Zl, Ql, r, e);
    u.layers = this.layers, this.add(u);
  }
  updateCoordinateSystem() {
    const r = this.coordinateSystem, e = this.children.concat(), [i, n, s, a, o, l] = e;
    for (const u of e) this.remove(u);
    if (r === sa)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (r === gm)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + r);
    for (const u of e)
      this.add(u), u.updateMatrixWorld();
  }
  update(r, e) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: n } = this;
    this.coordinateSystem !== r.coordinateSystem && (this.coordinateSystem = r.coordinateSystem, this.updateCoordinateSystem());
    const [s, a, o, l, u, c] = this.children, h = r.getRenderTarget(), d = r.getActiveCubeFace(), p = r.getActiveMipmapLevel(), f = r.xr.enabled;
    r.xr.enabled = !1;
    const m = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, r.setRenderTarget(i, 0, n), r.render(e, s), r.setRenderTarget(i, 1, n), r.render(e, a), r.setRenderTarget(i, 2, n), r.render(e, o), r.setRenderTarget(i, 3, n), r.render(e, l), r.setRenderTarget(i, 4, n), r.render(e, u), i.texture.generateMipmaps = m, r.setRenderTarget(i, 5, n), r.render(e, c), r.setRenderTarget(h, d, p), r.xr.enabled = f, i.texture.needsPMREMUpdate = !0;
  }
}, oR = class extends En {
  constructor(r, e, i, n, s, a, o, l, u, c) {
    r = r !== void 0 ? r : [], e = e !== void 0 ? e : dc, super(r, e, i, n, s, a, o, l, u, c), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(r) {
    this.image = r;
  }
}, OB = class extends go {
  constructor(r = 1, e = {}) {
    super(r, r, e), this.isWebGLCubeRenderTarget = !0;
    const i = { width: r, height: r, depth: 1 }, n = [i, i, i, i, i, i];
    this.texture = new oR(n, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : ds;
  }
  fromEquirectangularTexture(r, e) {
    this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, n = new N_(5, 5, 5), s = new xs({
      name: "CubemapFromEquirect",
      uniforms: gc(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: Ar,
      blending: ua
    });
    s.uniforms.tEquirect.value = e;
    const a = new Ur(n, s), o = e.minFilter;
    return e.minFilter === rl && (e.minFilter = ds), new IB(1, 10, this).update(r, a), e.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(r, e, i, n) {
    const s = r.getRenderTarget();
    for (let a = 0; a < 6; a++)
      r.setRenderTarget(this, a), r.clear(e, i, n);
    r.setRenderTarget(s);
  }
};
const ky = /* @__PURE__ */ new q(), DB = /* @__PURE__ */ new q(), LB = /* @__PURE__ */ new It();
let Xs = class {
  constructor(r = new q(1, 0, 0), e = 0) {
    this.isPlane = !0, this.normal = r, this.constant = e;
  }
  set(r, e) {
    return this.normal.copy(r), this.constant = e, this;
  }
  setComponents(r, e, i, n) {
    return this.normal.set(r, e, i), this.constant = n, this;
  }
  setFromNormalAndCoplanarPoint(r, e) {
    return this.normal.copy(r), this.constant = -e.dot(this.normal), this;
  }
  setFromCoplanarPoints(r, e, i) {
    const n = ky.subVectors(i, e).cross(DB.subVectors(r, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, r), this;
  }
  copy(r) {
    return this.normal.copy(r.normal), this.constant = r.constant, this;
  }
  normalize() {
    const r = 1 / this.normal.length();
    return this.normal.multiplyScalar(r), this.constant *= r, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(r) {
    return this.normal.dot(r) + this.constant;
  }
  distanceToSphere(r) {
    return this.distanceToPoint(r.center) - r.radius;
  }
  projectPoint(r, e) {
    return e.copy(r).addScaledVector(this.normal, -this.distanceToPoint(r));
  }
  intersectLine(r, e) {
    const i = r.delta(ky), n = this.normal.dot(i);
    if (n === 0)
      return this.distanceToPoint(r.start) === 0 ? e.copy(r.start) : null;
    const s = -(r.start.dot(this.normal) + this.constant) / n;
    return s < 0 || s > 1 ? null : e.copy(r.start).addScaledVector(i, s);
  }
  intersectsLine(r) {
    const e = this.distanceToPoint(r.start), i = this.distanceToPoint(r.end);
    return e < 0 && i > 0 || i < 0 && e > 0;
  }
  intersectsBox(r) {
    return r.intersectsPlane(this);
  }
  intersectsSphere(r) {
    return r.intersectsPlane(this);
  }
  coplanarPoint(r) {
    return r.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(r, e) {
    const i = e || LB.getNormalMatrix(r), n = this.coplanarPoint(ky).applyMatrix4(r), s = this.normal.applyMatrix3(i).normalize();
    return this.constant = -n.dot(s), this;
  }
  translate(r) {
    return this.constant -= r.dot(this.normal), this;
  }
  equals(r) {
    return r.normal.equals(this.normal) && r.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const Io = /* @__PURE__ */ new bg(), Ap = /* @__PURE__ */ new q();
let P_ = class {
  constructor(r = new Xs(), e = new Xs(), i = new Xs(), n = new Xs(), s = new Xs(), a = new Xs()) {
    this.planes = [r, e, i, n, s, a];
  }
  set(r, e, i, n, s, a) {
    const o = this.planes;
    return o[0].copy(r), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(s), o[5].copy(a), this;
  }
  copy(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++)
      e[i].copy(r.planes[i]);
    return this;
  }
  setFromProjectionMatrix(r, e = sa) {
    const i = this.planes, n = r.elements, s = n[0], a = n[1], o = n[2], l = n[3], u = n[4], c = n[5], h = n[6], d = n[7], p = n[8], f = n[9], m = n[10], v = n[11], y = n[12], g = n[13], _ = n[14], x = n[15];
    if (i[0].setComponents(l - s, d - u, v - p, x - y).normalize(), i[1].setComponents(l + s, d + u, v + p, x + y).normalize(), i[2].setComponents(l + a, d + c, v + f, x + g).normalize(), i[3].setComponents(l - a, d - c, v - f, x - g).normalize(), i[4].setComponents(l - o, d - h, v - m, x - _).normalize(), e === sa)
      i[5].setComponents(l + o, d + h, v + m, x + _).normalize();
    else if (e === gm)
      i[5].setComponents(o, h, m, _).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
    return this;
  }
  intersectsObject(r) {
    if (r.boundingSphere !== void 0)
      r.boundingSphere === null && r.computeBoundingSphere(), Io.copy(r.boundingSphere).applyMatrix4(r.matrixWorld);
    else {
      const e = r.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(), Io.copy(e.boundingSphere).applyMatrix4(r.matrixWorld);
    }
    return this.intersectsSphere(Io);
  }
  intersectsSprite(r) {
    return Io.center.set(0, 0, 0), Io.radius = 0.7071067811865476, Io.applyMatrix4(r.matrixWorld), this.intersectsSphere(Io);
  }
  intersectsSphere(r) {
    const e = this.planes, i = r.center, n = -r.radius;
    for (let s = 0; s < 6; s++)
      if (e[s].distanceToPoint(i) < n)
        return !1;
    return !0;
  }
  intersectsBox(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = e[i];
      if (Ap.x = n.normal.x > 0 ? r.max.x : r.min.x, Ap.y = n.normal.y > 0 ? r.max.y : r.min.y, Ap.z = n.normal.z > 0 ? r.max.z : r.min.z, n.distanceToPoint(Ap) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++)
      if (e[i].distanceToPoint(r) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function lR() {
  let r = null, e = !1, i = null, n = null;
  function s(a, o) {
    i(a, o), n = r.requestAnimationFrame(s);
  }
  return {
    start: function() {
      e !== !0 && i !== null && (n = r.requestAnimationFrame(s), e = !0);
    },
    stop: function() {
      r.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(a) {
      i = a;
    },
    setContext: function(a) {
      r = a;
    }
  };
}
function UB(r) {
  const e = /* @__PURE__ */ new WeakMap();
  function i(l, u) {
    const c = l.array, h = l.usage, d = c.byteLength, p = r.createBuffer();
    r.bindBuffer(u, p), r.bufferData(u, c, h), l.onUploadCallback();
    let f;
    if (c instanceof Float32Array)
      f = r.FLOAT;
    else if (c instanceof Uint16Array)
      l.isFloat16BufferAttribute ? f = r.HALF_FLOAT : f = r.UNSIGNED_SHORT;
    else if (c instanceof Int16Array)
      f = r.SHORT;
    else if (c instanceof Uint32Array)
      f = r.UNSIGNED_INT;
    else if (c instanceof Int32Array)
      f = r.INT;
    else if (c instanceof Int8Array)
      f = r.BYTE;
    else if (c instanceof Uint8Array)
      f = r.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray)
      f = r.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
    return {
      buffer: p,
      type: f,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: l.version,
      size: d
    };
  }
  function n(l, u, c) {
    const h = u.array, d = u.updateRanges;
    if (r.bindBuffer(c, l), d.length === 0)
      r.bufferSubData(c, 0, h);
    else {
      d.sort((f, m) => f.start - m.start);
      let p = 0;
      for (let f = 1; f < d.length; f++) {
        const m = d[p], v = d[f];
        v.start <= m.start + m.count + 1 ? m.count = Math.max(
          m.count,
          v.start + v.count - m.start
        ) : (++p, d[p] = v);
      }
      d.length = p + 1;
      for (let f = 0, m = d.length; f < m; f++) {
        const v = d[f];
        r.bufferSubData(
          c,
          v.start * h.BYTES_PER_ELEMENT,
          h,
          v.start,
          v.count
        );
      }
      u.clearUpdateRanges();
    }
    u.onUploadCallback();
  }
  function s(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function a(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const u = e.get(l);
    u && (r.deleteBuffer(u.buffer), e.delete(l));
  }
  function o(l, u) {
    if (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute) {
      const h = e.get(l);
      (!h || h.version < l.version) && e.set(l, {
        buffer: l.buffer,
        type: l.type,
        bytesPerElement: l.elementSize,
        version: l.version
      });
      return;
    }
    const c = e.get(l);
    if (c === void 0)
      e.set(l, i(l, u));
    else if (c.version < l.version) {
      if (c.size !== l.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n(c.buffer, l, u), c.version = l.version;
    }
  }
  return {
    get: s,
    remove: a,
    update: o
  };
}
class Vd extends cn {
  constructor(e = 1, i = 1, n = 1, s = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: i,
      widthSegments: n,
      heightSegments: s
    };
    const a = e / 2, o = i / 2, l = Math.floor(n), u = Math.floor(s), c = l + 1, h = u + 1, d = e / l, p = i / u, f = [], m = [], v = [], y = [];
    for (let g = 0; g < h; g++) {
      const _ = g * p - o;
      for (let x = 0; x < c; x++) {
        const b = x * d - a;
        m.push(b, -_, 0), v.push(0, 0, 1), y.push(x / l), y.push(1 - g / u);
      }
    }
    for (let g = 0; g < u; g++)
      for (let _ = 0; _ < l; _++) {
        const x = _ + c * g, b = _ + c * (g + 1), T = _ + 1 + c * (g + 1), S = _ + 1 + c * g;
        f.push(x, b, S), f.push(b, T, S);
      }
    this.setIndex(f), this.setAttribute("position", new Ri(m, 3)), this.setAttribute("normal", new Ri(v, 3)), this.setAttribute("uv", new Ri(y, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Vd(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var kB = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, FB = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, BB = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, zB = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, jB = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, VB = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, GB = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, HB = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, WB = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, qB = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, XB = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, $B = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, YB = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, KB = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, ZB = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, QB = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, JB = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, e5 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, t5 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, i5 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, r5 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, n5 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, s5 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, a5 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, o5 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, l5 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, u5 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, c5 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, h5 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, d5 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, p5 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", f5 = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, m5 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, g5 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, y5 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, v5 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, b5 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, x5 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, _5 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, T5 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, S5 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, w5 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, E5 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, M5 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, A5 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, C5 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, R5 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, N5 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, P5 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, I5 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, O5 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, D5 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, L5 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, U5 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, k5 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, F5 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, B5 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, z5 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, j5 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, V5 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, G5 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, H5 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, W5 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, q5 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, X5 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, $5 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Y5 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, K5 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Z5 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Q5 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, J5 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, ez = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, tz = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, iz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, rz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, nz = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, sz = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, az = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, oz = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, lz = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, uz = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, cz = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, hz = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, dz = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, pz = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, fz = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, mz = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, gz = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, yz = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, vz = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, bz = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, xz = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, _z = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Tz = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Sz = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, wz = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Ez = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Mz = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Az = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Cz = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Rz = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, Nz = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, Pz = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Iz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Oz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Dz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Lz = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Uz = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, kz = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Fz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Bz = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, zz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, jz = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Vz = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Gz = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, Hz = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Wz = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, qz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Xz = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, $z = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Yz = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Kz = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Zz = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Qz = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Jz = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, e4 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, t4 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, i4 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, r4 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, n4 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, s4 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, a4 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, o4 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, l4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, u4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, c4 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, h4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, d4 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, p4 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, f4 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, m4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Ct = {
  alphahash_fragment: kB,
  alphahash_pars_fragment: FB,
  alphamap_fragment: BB,
  alphamap_pars_fragment: zB,
  alphatest_fragment: jB,
  alphatest_pars_fragment: VB,
  aomap_fragment: GB,
  aomap_pars_fragment: HB,
  batching_pars_vertex: WB,
  batching_vertex: qB,
  begin_vertex: XB,
  beginnormal_vertex: $B,
  bsdfs: YB,
  iridescence_fragment: KB,
  bumpmap_pars_fragment: ZB,
  clipping_planes_fragment: QB,
  clipping_planes_pars_fragment: JB,
  clipping_planes_pars_vertex: e5,
  clipping_planes_vertex: t5,
  color_fragment: i5,
  color_pars_fragment: r5,
  color_pars_vertex: n5,
  color_vertex: s5,
  common: a5,
  cube_uv_reflection_fragment: o5,
  defaultnormal_vertex: l5,
  displacementmap_pars_vertex: u5,
  displacementmap_vertex: c5,
  emissivemap_fragment: h5,
  emissivemap_pars_fragment: d5,
  colorspace_fragment: p5,
  colorspace_pars_fragment: f5,
  envmap_fragment: m5,
  envmap_common_pars_fragment: g5,
  envmap_pars_fragment: y5,
  envmap_pars_vertex: v5,
  envmap_physical_pars_fragment: R5,
  envmap_vertex: b5,
  fog_vertex: x5,
  fog_pars_vertex: _5,
  fog_fragment: T5,
  fog_pars_fragment: S5,
  gradientmap_pars_fragment: w5,
  lightmap_pars_fragment: E5,
  lights_lambert_fragment: M5,
  lights_lambert_pars_fragment: A5,
  lights_pars_begin: C5,
  lights_toon_fragment: N5,
  lights_toon_pars_fragment: P5,
  lights_phong_fragment: I5,
  lights_phong_pars_fragment: O5,
  lights_physical_fragment: D5,
  lights_physical_pars_fragment: L5,
  lights_fragment_begin: U5,
  lights_fragment_maps: k5,
  lights_fragment_end: F5,
  logdepthbuf_fragment: B5,
  logdepthbuf_pars_fragment: z5,
  logdepthbuf_pars_vertex: j5,
  logdepthbuf_vertex: V5,
  map_fragment: G5,
  map_pars_fragment: H5,
  map_particle_fragment: W5,
  map_particle_pars_fragment: q5,
  metalnessmap_fragment: X5,
  metalnessmap_pars_fragment: $5,
  morphinstance_vertex: Y5,
  morphcolor_vertex: K5,
  morphnormal_vertex: Z5,
  morphtarget_pars_vertex: Q5,
  morphtarget_vertex: J5,
  normal_fragment_begin: ez,
  normal_fragment_maps: tz,
  normal_pars_fragment: iz,
  normal_pars_vertex: rz,
  normal_vertex: nz,
  normalmap_pars_fragment: sz,
  clearcoat_normal_fragment_begin: az,
  clearcoat_normal_fragment_maps: oz,
  clearcoat_pars_fragment: lz,
  iridescence_pars_fragment: uz,
  opaque_fragment: cz,
  packing: hz,
  premultiplied_alpha_fragment: dz,
  project_vertex: pz,
  dithering_fragment: fz,
  dithering_pars_fragment: mz,
  roughnessmap_fragment: gz,
  roughnessmap_pars_fragment: yz,
  shadowmap_pars_fragment: vz,
  shadowmap_pars_vertex: bz,
  shadowmap_vertex: xz,
  shadowmask_pars_fragment: _z,
  skinbase_vertex: Tz,
  skinning_pars_vertex: Sz,
  skinning_vertex: wz,
  skinnormal_vertex: Ez,
  specularmap_fragment: Mz,
  specularmap_pars_fragment: Az,
  tonemapping_fragment: Cz,
  tonemapping_pars_fragment: Rz,
  transmission_fragment: Nz,
  transmission_pars_fragment: Pz,
  uv_pars_fragment: Iz,
  uv_pars_vertex: Oz,
  uv_vertex: Dz,
  worldpos_vertex: Lz,
  background_vert: Uz,
  background_frag: kz,
  backgroundCube_vert: Fz,
  backgroundCube_frag: Bz,
  cube_vert: zz,
  cube_frag: jz,
  depth_vert: Vz,
  depth_frag: Gz,
  distanceRGBA_vert: Hz,
  distanceRGBA_frag: Wz,
  equirect_vert: qz,
  equirect_frag: Xz,
  linedashed_vert: $z,
  linedashed_frag: Yz,
  meshbasic_vert: Kz,
  meshbasic_frag: Zz,
  meshlambert_vert: Qz,
  meshlambert_frag: Jz,
  meshmatcap_vert: e4,
  meshmatcap_frag: t4,
  meshnormal_vert: i4,
  meshnormal_frag: r4,
  meshphong_vert: n4,
  meshphong_frag: s4,
  meshphysical_vert: a4,
  meshphysical_frag: o4,
  meshtoon_vert: l4,
  meshtoon_frag: u4,
  points_vert: c4,
  points_frag: h4,
  shadow_vert: d4,
  shadow_frag: p4,
  sprite_vert: f4,
  sprite_frag: m4
}, je = {
  common: {
    diffuse: { value: /* @__PURE__ */ new kt(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new It() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new It() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new It() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new It() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new It() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new It() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new It() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new It() },
    normalScale: { value: /* @__PURE__ */ new Ue(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new It() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new It() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new It() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new It() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new kt(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new kt(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new It() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new It() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new kt(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Ue(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new It() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new It() },
    alphaTest: { value: 0 }
  }
}, hs = {
  basic: {
    uniforms: /* @__PURE__ */ _r([
      je.common,
      je.specularmap,
      je.envmap,
      je.aomap,
      je.lightmap,
      je.fog
    ]),
    vertexShader: Ct.meshbasic_vert,
    fragmentShader: Ct.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ _r([
      je.common,
      je.specularmap,
      je.envmap,
      je.aomap,
      je.lightmap,
      je.emissivemap,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      je.fog,
      je.lights,
      {
        emissive: { value: /* @__PURE__ */ new kt(0) }
      }
    ]),
    vertexShader: Ct.meshlambert_vert,
    fragmentShader: Ct.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ _r([
      je.common,
      je.specularmap,
      je.envmap,
      je.aomap,
      je.lightmap,
      je.emissivemap,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      je.fog,
      je.lights,
      {
        emissive: { value: /* @__PURE__ */ new kt(0) },
        specular: { value: /* @__PURE__ */ new kt(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Ct.meshphong_vert,
    fragmentShader: Ct.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ _r([
      je.common,
      je.envmap,
      je.aomap,
      je.lightmap,
      je.emissivemap,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      je.roughnessmap,
      je.metalnessmap,
      je.fog,
      je.lights,
      {
        emissive: { value: /* @__PURE__ */ new kt(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Ct.meshphysical_vert,
    fragmentShader: Ct.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ _r([
      je.common,
      je.aomap,
      je.lightmap,
      je.emissivemap,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      je.gradientmap,
      je.fog,
      je.lights,
      {
        emissive: { value: /* @__PURE__ */ new kt(0) }
      }
    ]),
    vertexShader: Ct.meshtoon_vert,
    fragmentShader: Ct.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ _r([
      je.common,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      je.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Ct.meshmatcap_vert,
    fragmentShader: Ct.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ _r([
      je.points,
      je.fog
    ]),
    vertexShader: Ct.points_vert,
    fragmentShader: Ct.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ _r([
      je.common,
      je.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Ct.linedashed_vert,
    fragmentShader: Ct.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ _r([
      je.common,
      je.displacementmap
    ]),
    vertexShader: Ct.depth_vert,
    fragmentShader: Ct.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ _r([
      je.common,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ct.meshnormal_vert,
    fragmentShader: Ct.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ _r([
      je.sprite,
      je.fog
    ]),
    vertexShader: Ct.sprite_vert,
    fragmentShader: Ct.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new It() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Ct.background_vert,
    fragmentShader: Ct.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new It() }
    },
    vertexShader: Ct.backgroundCube_vert,
    fragmentShader: Ct.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Ct.cube_vert,
    fragmentShader: Ct.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Ct.equirect_vert,
    fragmentShader: Ct.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ _r([
      je.common,
      je.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new q() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Ct.distanceRGBA_vert,
    fragmentShader: Ct.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ _r([
      je.lights,
      je.fog,
      {
        color: { value: /* @__PURE__ */ new kt(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Ct.shadow_vert,
    fragmentShader: Ct.shadow_frag
  }
};
hs.physical = {
  uniforms: /* @__PURE__ */ _r([
    hs.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new It() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new It() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Ue(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new It() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new It() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new It() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new kt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new It() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new It() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new It() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Ue() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new It() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new kt(0) },
      specularColor: { value: /* @__PURE__ */ new kt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new It() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new It() },
      anisotropyVector: { value: /* @__PURE__ */ new Ue() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new It() }
    }
  ]),
  vertexShader: Ct.meshphysical_vert,
  fragmentShader: Ct.meshphysical_frag
};
const Cp = { r: 0, b: 0, g: 0 }, Oo = /* @__PURE__ */ new yo(), g4 = /* @__PURE__ */ new ui();
function y4(r, e, i, n, s, a, o) {
  const l = new kt(0);
  let u = a === !0 ? 0 : 1, c, h, d = null, p = 0, f = null;
  function m(_) {
    let x = _.isScene === !0 ? _.background : null;
    return x && x.isTexture && (x = (_.backgroundBlurriness > 0 ? i : e).get(x)), x;
  }
  function v(_) {
    let x = !1;
    const b = m(_);
    b === null ? g(l, u) : b && b.isColor && (g(b, 1), x = !0);
    const T = r.xr.getEnvironmentBlendMode();
    T === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : T === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (r.autoClear || x) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil));
  }
  function y(_, x) {
    const b = m(x);
    b && (b.isCubeTexture || b.mapping === yg) ? (h === void 0 && (h = new Ur(
      new N_(1, 1, 1),
      new xs({
        name: "BackgroundCubeMaterial",
        uniforms: gc(hs.backgroundCube.uniforms),
        vertexShader: hs.backgroundCube.vertexShader,
        fragmentShader: hs.backgroundCube.fragmentShader,
        side: Ar,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(T, S, w) {
      this.matrixWorld.copyPosition(w.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), s.update(h)), Oo.copy(x.backgroundRotation), Oo.x *= -1, Oo.y *= -1, Oo.z *= -1, b.isCubeTexture && b.isRenderTargetTexture === !1 && (Oo.y *= -1, Oo.z *= -1), h.material.uniforms.envMap.value = b, h.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = x.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(g4.makeRotationFromEuler(Oo)), h.material.toneMapped = Vt.getTransfer(b.colorSpace) !== Jt, (d !== b || p !== b.version || f !== r.toneMapping) && (h.material.needsUpdate = !0, d = b, p = b.version, f = r.toneMapping), h.layers.enableAll(), _.unshift(h, h.geometry, h.material, 0, 0, null)) : b && b.isTexture && (c === void 0 && (c = new Ur(
      new Vd(2, 2),
      new xs({
        name: "BackgroundMaterial",
        uniforms: gc(hs.background.uniforms),
        vertexShader: hs.background.vertexShader,
        fragmentShader: hs.background.fragmentShader,
        side: mo,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), s.update(c)), c.material.uniforms.t2D.value = b, c.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, c.material.toneMapped = Vt.getTransfer(b.colorSpace) !== Jt, b.matrixAutoUpdate === !0 && b.updateMatrix(), c.material.uniforms.uvTransform.value.copy(b.matrix), (d !== b || p !== b.version || f !== r.toneMapping) && (c.material.needsUpdate = !0, d = b, p = b.version, f = r.toneMapping), c.layers.enableAll(), _.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function g(_, x) {
    _.getRGB(Cp, nR(r)), n.buffers.color.setClear(Cp.r, Cp.g, Cp.b, x, o);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(_, x = 1) {
      l.set(_), u = x, g(l, u);
    },
    getClearAlpha: function() {
      return u;
    },
    setClearAlpha: function(_) {
      u = _, g(l, u);
    },
    render: v,
    addToRenderList: y
  };
}
function v4(r, e) {
  const i = r.getParameter(r.MAX_VERTEX_ATTRIBS), n = {}, s = p(null);
  let a = s, o = !1;
  function l(M, N, k, U, C) {
    let O = !1;
    const D = d(U, k, N);
    a !== D && (a = D, c(a.object)), O = f(M, U, k, C), O && m(M, U, k, C), C !== null && e.update(C, r.ELEMENT_ARRAY_BUFFER), (O || o) && (o = !1, b(M, N, k, U), C !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(C).buffer));
  }
  function u() {
    return r.createVertexArray();
  }
  function c(M) {
    return r.bindVertexArray(M);
  }
  function h(M) {
    return r.deleteVertexArray(M);
  }
  function d(M, N, k) {
    const U = k.wireframe === !0;
    let C = n[M.id];
    C === void 0 && (C = {}, n[M.id] = C);
    let O = C[N.id];
    O === void 0 && (O = {}, C[N.id] = O);
    let D = O[U];
    return D === void 0 && (D = p(u()), O[U] = D), D;
  }
  function p(M) {
    const N = [], k = [], U = [];
    for (let C = 0; C < i; C++)
      N[C] = 0, k[C] = 0, U[C] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: N,
      enabledAttributes: k,
      attributeDivisors: U,
      object: M,
      attributes: {},
      index: null
    };
  }
  function f(M, N, k, U) {
    const C = a.attributes, O = N.attributes;
    let D = 0;
    const H = k.getAttributes();
    for (const j in H)
      if (H[j].location >= 0) {
        const K = C[j];
        let L = O[j];
        if (L === void 0 && (j === "instanceMatrix" && M.instanceMatrix && (L = M.instanceMatrix), j === "instanceColor" && M.instanceColor && (L = M.instanceColor)), K === void 0 || K.attribute !== L || L && K.data !== L.data) return !0;
        D++;
      }
    return a.attributesNum !== D || a.index !== U;
  }
  function m(M, N, k, U) {
    const C = {}, O = N.attributes;
    let D = 0;
    const H = k.getAttributes();
    for (const j in H)
      if (H[j].location >= 0) {
        let K = O[j];
        K === void 0 && (j === "instanceMatrix" && M.instanceMatrix && (K = M.instanceMatrix), j === "instanceColor" && M.instanceColor && (K = M.instanceColor));
        const L = {};
        L.attribute = K, K && K.data && (L.data = K.data), C[j] = L, D++;
      }
    a.attributes = C, a.attributesNum = D, a.index = U;
  }
  function v() {
    const M = a.newAttributes;
    for (let N = 0, k = M.length; N < k; N++)
      M[N] = 0;
  }
  function y(M) {
    g(M, 0);
  }
  function g(M, N) {
    const k = a.newAttributes, U = a.enabledAttributes, C = a.attributeDivisors;
    k[M] = 1, U[M] === 0 && (r.enableVertexAttribArray(M), U[M] = 1), C[M] !== N && (r.vertexAttribDivisor(M, N), C[M] = N);
  }
  function _() {
    const M = a.newAttributes, N = a.enabledAttributes;
    for (let k = 0, U = N.length; k < U; k++)
      N[k] !== M[k] && (r.disableVertexAttribArray(k), N[k] = 0);
  }
  function x(M, N, k, U, C, O, D) {
    D === !0 ? r.vertexAttribIPointer(M, N, k, C, O) : r.vertexAttribPointer(M, N, k, U, C, O);
  }
  function b(M, N, k, U) {
    v();
    const C = U.attributes, O = k.getAttributes(), D = N.defaultAttributeValues;
    for (const H in O) {
      const j = O[H];
      if (j.location >= 0) {
        let K = C[H];
        if (K === void 0 && (H === "instanceMatrix" && M.instanceMatrix && (K = M.instanceMatrix), H === "instanceColor" && M.instanceColor && (K = M.instanceColor)), K !== void 0) {
          const L = K.normalized, B = K.itemSize, Q = e.get(K);
          if (Q === void 0) continue;
          const W = Q.buffer, z = Q.type, X = Q.bytesPerElement, ae = z === r.INT || z === r.UNSIGNED_INT || K.gpuType === T_;
          if (K.isInterleavedBufferAttribute) {
            const ue = K.data, ge = ue.stride, we = K.offset;
            if (ue.isInstancedInterleavedBuffer) {
              for (let Ne = 0; Ne < j.locationSize; Ne++)
                g(j.location + Ne, ue.meshPerAttribute);
              M.isInstancedMesh !== !0 && U._maxInstanceCount === void 0 && (U._maxInstanceCount = ue.meshPerAttribute * ue.count);
            } else
              for (let Ne = 0; Ne < j.locationSize; Ne++)
                y(j.location + Ne);
            r.bindBuffer(r.ARRAY_BUFFER, W);
            for (let Ne = 0; Ne < j.locationSize; Ne++)
              x(
                j.location + Ne,
                B / j.locationSize,
                z,
                L,
                ge * X,
                (we + B / j.locationSize * Ne) * X,
                ae
              );
          } else {
            if (K.isInstancedBufferAttribute) {
              for (let ue = 0; ue < j.locationSize; ue++)
                g(j.location + ue, K.meshPerAttribute);
              M.isInstancedMesh !== !0 && U._maxInstanceCount === void 0 && (U._maxInstanceCount = K.meshPerAttribute * K.count);
            } else
              for (let ue = 0; ue < j.locationSize; ue++)
                y(j.location + ue);
            r.bindBuffer(r.ARRAY_BUFFER, W);
            for (let ue = 0; ue < j.locationSize; ue++)
              x(
                j.location + ue,
                B / j.locationSize,
                z,
                L,
                B * X,
                B / j.locationSize * ue * X,
                ae
              );
          }
        } else if (D !== void 0) {
          const L = D[H];
          if (L !== void 0)
            switch (L.length) {
              case 2:
                r.vertexAttrib2fv(j.location, L);
                break;
              case 3:
                r.vertexAttrib3fv(j.location, L);
                break;
              case 4:
                r.vertexAttrib4fv(j.location, L);
                break;
              default:
                r.vertexAttrib1fv(j.location, L);
            }
        }
      }
    }
    _();
  }
  function T() {
    A();
    for (const M in n) {
      const N = n[M];
      for (const k in N) {
        const U = N[k];
        for (const C in U)
          h(U[C].object), delete U[C];
        delete N[k];
      }
      delete n[M];
    }
  }
  function S(M) {
    if (n[M.id] === void 0) return;
    const N = n[M.id];
    for (const k in N) {
      const U = N[k];
      for (const C in U)
        h(U[C].object), delete U[C];
      delete N[k];
    }
    delete n[M.id];
  }
  function w(M) {
    for (const N in n) {
      const k = n[N];
      if (k[M.id] === void 0) continue;
      const U = k[M.id];
      for (const C in U)
        h(U[C].object), delete U[C];
      delete k[M.id];
    }
  }
  function A() {
    E(), o = !0, a !== s && (a = s, c(a.object));
  }
  function E() {
    s.geometry = null, s.program = null, s.wireframe = !1;
  }
  return {
    setup: l,
    reset: A,
    resetDefaultState: E,
    dispose: T,
    releaseStatesOfGeometry: S,
    releaseStatesOfProgram: w,
    initAttributes: v,
    enableAttribute: y,
    disableUnusedAttributes: _
  };
}
function b4(r, e, i) {
  let n;
  function s(c) {
    n = c;
  }
  function a(c, h) {
    r.drawArrays(n, c, h), i.update(h, n, 1);
  }
  function o(c, h, d) {
    d !== 0 && (r.drawArraysInstanced(n, c, h, d), i.update(h, n, d));
  }
  function l(c, h, d) {
    if (d === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, h, 0, d);
    let p = 0;
    for (let f = 0; f < d; f++)
      p += h[f];
    i.update(p, n, 1);
  }
  function u(c, h, d, p) {
    if (d === 0) return;
    const f = e.get("WEBGL_multi_draw");
    if (f === null)
      for (let m = 0; m < c.length; m++)
        o(c[m], h[m], p[m]);
    else {
      f.multiDrawArraysInstancedWEBGL(n, c, 0, h, 0, p, 0, d);
      let m = 0;
      for (let v = 0; v < d; v++)
        m += h[v] * p[v];
      i.update(m, n, 1);
    }
  }
  this.setMode = s, this.render = a, this.renderInstances = o, this.renderMultiDraw = l, this.renderMultiDrawInstances = u;
}
function x4(r, e, i, n) {
  let s;
  function a() {
    if (s !== void 0) return s;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const w = e.get("EXT_texture_filter_anisotropic");
      s = r.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      s = 0;
    return s;
  }
  function o(w) {
    return !(w !== Xn && n.convert(w) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function l(w) {
    const A = w === Dc && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(w !== xa && n.convert(w) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    w !== na && !A);
  }
  function u(w) {
    if (w === "highp") {
      if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
        return "highp";
      w = "mediump";
    }
    return w === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let c = i.precision !== void 0 ? i.precision : "highp";
  const h = u(c);
  h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
  const d = i.logarithmicDepthBuffer === !0, p = i.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), f = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), m = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), v = r.getParameter(r.MAX_TEXTURE_SIZE), y = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), g = r.getParameter(r.MAX_VERTEX_ATTRIBS), _ = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), x = r.getParameter(r.MAX_VARYING_VECTORS), b = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), T = m > 0, S = r.getParameter(r.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: a,
    getMaxPrecision: u,
    textureFormatReadable: o,
    textureTypeReadable: l,
    precision: c,
    logarithmicDepthBuffer: d,
    reverseDepthBuffer: p,
    maxTextures: f,
    maxVertexTextures: m,
    maxTextureSize: v,
    maxCubemapSize: y,
    maxAttributes: g,
    maxVertexUniforms: _,
    maxVaryings: x,
    maxFragmentUniforms: b,
    vertexTextures: T,
    maxSamples: S
  };
}
function _4(r) {
  const e = this;
  let i = null, n = 0, s = !1, a = !1;
  const o = new Xs(), l = new It(), u = { value: null, needsUpdate: !1 };
  this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, p) {
    const f = d.length !== 0 || p || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || s;
    return s = p, n = d.length, f;
  }, this.beginShadows = function() {
    a = !0, h(null);
  }, this.endShadows = function() {
    a = !1;
  }, this.setGlobalState = function(d, p) {
    i = h(d, p, 0);
  }, this.setState = function(d, p, f) {
    const m = d.clippingPlanes, v = d.clipIntersection, y = d.clipShadows, g = r.get(d);
    if (!s || m === null || m.length === 0 || a && !y)
      a ? h(null) : c();
    else {
      const _ = a ? 0 : n, x = _ * 4;
      let b = g.clippingState || null;
      u.value = b, b = h(m, p, x, f);
      for (let T = 0; T !== x; ++T)
        b[T] = i[T];
      g.clippingState = b, this.numIntersection = v ? this.numPlanes : 0, this.numPlanes += _;
    }
  };
  function c() {
    u.value !== i && (u.value = i, u.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function h(d, p, f, m) {
    const v = d !== null ? d.length : 0;
    let y = null;
    if (v !== 0) {
      if (y = u.value, m !== !0 || y === null) {
        const g = f + v * 4, _ = p.matrixWorldInverse;
        l.getNormalMatrix(_), (y === null || y.length < g) && (y = new Float32Array(g));
        for (let x = 0, b = f; x !== v; ++x, b += 4)
          o.copy(d[x]).applyMatrix4(_, l), o.normal.toArray(y, b), y[b + 3] = o.constant;
      }
      u.value = y, u.needsUpdate = !0;
    }
    return e.numPlanes = v, e.numIntersection = 0, y;
  }
}
function T4(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function i(o, l) {
    return l === tb ? o.mapping = dc : l === ib && (o.mapping = pc), o;
  }
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping;
      if (l === tb || l === ib)
        if (e.has(o)) {
          const u = e.get(o).texture;
          return i(u, o.mapping);
        } else {
          const u = o.image;
          if (u && u.height > 0) {
            const c = new OB(u.height);
            return c.fromEquirectangularTexture(r, o), e.set(o, c), o.addEventListener("dispose", s), i(c.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function s(o) {
    const l = o.target;
    l.removeEventListener("dispose", s);
    const u = e.get(l);
    u !== void 0 && (e.delete(l), u.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: a
  };
}
let I_ = class extends aR {
  constructor(r = -1, e = 1, i = 1, n = -1, s = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = r, this.right = e, this.top = i, this.bottom = n, this.near = s, this.far = a, this.updateProjectionMatrix();
  }
  copy(r, e) {
    return super.copy(r, e), this.left = r.left, this.right = r.right, this.top = r.top, this.bottom = r.bottom, this.near = r.near, this.far = r.far, this.zoom = r.zoom, this.view = r.view === null ? null : Object.assign({}, r.view), this;
  }
  setViewOffset(r, e, i, n, s, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = r, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const r = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
    let s = i - r, a = i + r, o = n + e, l = n - e;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += u * this.view.offsetX, a = s + u * this.view.width, o -= c * this.view.offsetY, l = o - c * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
};
const Ou = 4, H1 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], $o = 20, Fy = /* @__PURE__ */ new I_(), W1 = /* @__PURE__ */ new kt();
let By = null, zy = 0, jy = 0, Vy = !1;
const Vo = (1 + Math.sqrt(5)) / 2, Jl = 1 / Vo, q1 = [
  /* @__PURE__ */ new q(-Vo, Jl, 0),
  /* @__PURE__ */ new q(Vo, Jl, 0),
  /* @__PURE__ */ new q(-Jl, 0, Vo),
  /* @__PURE__ */ new q(Jl, 0, Vo),
  /* @__PURE__ */ new q(0, Vo, -Jl),
  /* @__PURE__ */ new q(0, Vo, Jl),
  /* @__PURE__ */ new q(-1, 1, -1),
  /* @__PURE__ */ new q(1, 1, -1),
  /* @__PURE__ */ new q(-1, 1, 1),
  /* @__PURE__ */ new q(1, 1, 1)
];
let X1 = class {
  constructor(r) {
    this._renderer = r, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(r, e = 0, i = 0.1, n = 100) {
    By = this._renderer.getRenderTarget(), zy = this._renderer.getActiveCubeFace(), jy = this._renderer.getActiveMipmapLevel(), Vy = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(r, i, n, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(r, e = null) {
    return this._fromTexture(r, e);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(r, e = null) {
    return this._fromTexture(r, e);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = K1(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = Y1(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(r) {
    this._lodMax = Math.floor(Math.log2(r)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let r = 0; r < this._lodPlanes.length; r++)
      this._lodPlanes[r].dispose();
  }
  _cleanup(r) {
    this._renderer.setRenderTarget(By, zy, jy), this._renderer.xr.enabled = Vy, r.scissorTest = !1, Rp(r, 0, 0, r.width, r.height);
  }
  _fromTexture(r, e) {
    r.mapping === dc || r.mapping === pc ? this._setSize(r.image.length === 0 ? 16 : r.image[0].width || r.image[0].image.width) : this._setSize(r.image.width / 4), By = this._renderer.getRenderTarget(), zy = this._renderer.getActiveCubeFace(), jy = this._renderer.getActiveMipmapLevel(), Vy = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const i = e || this._allocateTargets();
    return this._textureToCubeUV(r, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const r = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, i = {
      magFilter: ds,
      minFilter: ds,
      generateMipmaps: !1,
      type: Dc,
      format: Xn,
      colorSpace: Lc,
      depthBuffer: !1
    }, n = $1(r, e, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== r || this._pingPongRenderTarget.height !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = $1(r, e, i);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = S4(s)), this._blurMaterial = w4(s, r, e);
    }
    return n;
  }
  _compileMaterial(r) {
    const e = new Ur(this._lodPlanes[0], r);
    this._renderer.compile(e, Fy);
  }
  _sceneToCubeUV(r, e, i, n) {
    const s = new vn(90, 1, e, i), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], l = this._renderer, u = l.autoClear, c = l.toneMapping;
    l.getClearColor(W1), l.toneMapping = lo, l.autoClear = !1;
    const h = new _g({
      name: "PMREM.Background",
      side: Ar,
      depthWrite: !1,
      depthTest: !1
    }), d = new Ur(new N_(), h);
    let p = !1;
    const f = r.background;
    f ? f.isColor && (h.color.copy(f), r.background = null, p = !0) : (h.color.copy(W1), p = !0);
    for (let m = 0; m < 6; m++) {
      const v = m % 3;
      v === 0 ? (s.up.set(0, a[m], 0), s.lookAt(o[m], 0, 0)) : v === 1 ? (s.up.set(0, 0, a[m]), s.lookAt(0, o[m], 0)) : (s.up.set(0, a[m], 0), s.lookAt(0, 0, o[m]));
      const y = this._cubeSize;
      Rp(n, v * y, m > 2 ? y : 0, y, y), l.setRenderTarget(n), p && l.render(d, s), l.render(r, s);
    }
    d.geometry.dispose(), d.material.dispose(), l.toneMapping = c, l.autoClear = u, r.background = f;
  }
  _textureToCubeUV(r, e) {
    const i = this._renderer, n = r.mapping === dc || r.mapping === pc;
    n ? (this._cubemapMaterial === null && (this._cubemapMaterial = K1()), this._cubemapMaterial.uniforms.flipEnvMap.value = r.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Y1());
    const s = n ? this._cubemapMaterial : this._equirectMaterial, a = new Ur(this._lodPlanes[0], s), o = s.uniforms;
    o.envMap.value = r;
    const l = this._cubeSize;
    Rp(e, 0, 0, 3 * l, 2 * l), i.setRenderTarget(e), i.render(a, Fy);
  }
  _applyPMREM(r) {
    const e = this._renderer, i = e.autoClear;
    e.autoClear = !1;
    const n = this._lodPlanes.length;
    for (let s = 1; s < n; s++) {
      const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]), o = q1[(n - s - 1) % q1.length];
      this._blur(r, s - 1, s, a, o);
    }
    e.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(r, e, i, n, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      r,
      a,
      e,
      i,
      n,
      "latitudinal",
      s
    ), this._halfBlur(
      a,
      r,
      i,
      i,
      n,
      "longitudinal",
      s
    );
  }
  _halfBlur(r, e, i, n, s, a, o) {
    const l = this._renderer, u = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const c = 3, h = new Ur(this._lodPlanes[n], u), d = u.uniforms, p = this._sizeLods[i] - 1, f = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * $o - 1), m = s / f, v = isFinite(s) ? 1 + Math.floor(c * m) : $o;
    v > $o && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${$o}`);
    const y = [];
    let g = 0;
    for (let S = 0; S < $o; ++S) {
      const w = S / m, A = Math.exp(-w * w / 2);
      y.push(A), S === 0 ? g += A : S < v && (g += 2 * A);
    }
    for (let S = 0; S < y.length; S++)
      y[S] = y[S] / g;
    d.envMap.value = r.texture, d.samples.value = v, d.weights.value = y, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
    const { _lodMax: _ } = this;
    d.dTheta.value = f, d.mipInt.value = _ - i;
    const x = this._sizeLods[n], b = 3 * x * (n > _ - Ou ? n - _ + Ou : 0), T = 4 * (this._cubeSize - x);
    Rp(e, b, T, 3 * x, 2 * x), l.setRenderTarget(e), l.render(h, Fy);
  }
};
function S4(r) {
  const e = [], i = [], n = [];
  let s = r;
  const a = r - Ou + 1 + H1.length;
  for (let o = 0; o < a; o++) {
    const l = Math.pow(2, s);
    i.push(l);
    let u = 1 / l;
    o > r - Ou ? u = H1[o - r + Ou - 1] : o === 0 && (u = 0), n.push(u);
    const c = 1 / (l - 2), h = -c, d = 1 + c, p = [h, h, d, h, d, d, h, h, d, d, h, d], f = 6, m = 6, v = 3, y = 2, g = 1, _ = new Float32Array(v * m * f), x = new Float32Array(y * m * f), b = new Float32Array(g * m * f);
    for (let S = 0; S < f; S++) {
      const w = S % 3 * 2 / 3 - 1, A = S > 2 ? 0 : -1, E = [
        w,
        A,
        0,
        w + 2 / 3,
        A,
        0,
        w + 2 / 3,
        A + 1,
        0,
        w,
        A,
        0,
        w + 2 / 3,
        A + 1,
        0,
        w,
        A + 1,
        0
      ];
      _.set(E, v * m * S), x.set(p, y * m * S);
      const M = [S, S, S, S, S, S];
      b.set(M, g * m * S);
    }
    const T = new cn();
    T.setAttribute("position", new _n(_, v)), T.setAttribute("uv", new _n(x, y)), T.setAttribute("faceIndex", new _n(b, g)), e.push(T), s > Ou && s--;
  }
  return { lodPlanes: e, sizeLods: i, sigmas: n };
}
function $1(r, e, i) {
  const n = new go(r, e, i);
  return n.texture.mapping = yg, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function Rp(r, e, i, n, s) {
  r.viewport.set(e, i, n, s), r.scissor.set(e, i, n, s);
}
function w4(r, e, i) {
  const n = new Float32Array($o), s = new q(0, 1, 0);
  return new xs({
    name: "SphericalGaussianBlur",
    defines: {
      n: $o,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / i,
      CUBEUV_MAX_MIP: `${r}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: s }
    },
    vertexShader: O_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: ua,
    depthTest: !1,
    depthWrite: !1
  });
}
function Y1() {
  return new xs({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: O_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: ua,
    depthTest: !1,
    depthWrite: !1
  });
}
function K1() {
  return new xs({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: O_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: ua,
    depthTest: !1,
    depthWrite: !1
  });
}
function O_() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function E4(r) {
  let e = /* @__PURE__ */ new WeakMap(), i = null;
  function n(l) {
    if (l && l.isTexture) {
      const u = l.mapping, c = u === tb || u === ib, h = u === dc || u === pc;
      if (c || h) {
        let d = e.get(l);
        const p = d !== void 0 ? d.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== p)
          return i === null && (i = new X1(r)), d = c ? i.fromEquirectangular(l, d) : i.fromCubemap(l, d), d.texture.pmremVersion = l.pmremVersion, e.set(l, d), d.texture;
        if (d !== void 0)
          return d.texture;
        {
          const f = l.image;
          return c && f && f.height > 0 || h && f && s(f) ? (i === null && (i = new X1(r)), d = c ? i.fromEquirectangular(l) : i.fromCubemap(l), d.texture.pmremVersion = l.pmremVersion, e.set(l, d), l.addEventListener("dispose", a), d.texture) : null;
        }
      }
    }
    return l;
  }
  function s(l) {
    let u = 0;
    const c = 6;
    for (let h = 0; h < c; h++)
      l[h] !== void 0 && u++;
    return u === c;
  }
  function a(l) {
    const u = l.target;
    u.removeEventListener("dispose", a);
    const c = e.get(u);
    c !== void 0 && (e.delete(u), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), i !== null && (i.dispose(), i = null);
  }
  return {
    get: n,
    dispose: o
  };
}
function M4(r) {
  const e = {};
  function i(n) {
    if (e[n] !== void 0)
      return e[n];
    let s;
    switch (n) {
      case "WEBGL_depth_texture":
        s = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        s = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        s = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        s = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        s = r.getExtension(n);
    }
    return e[n] = s, s;
  }
  return {
    has: function(n) {
      return i(n) !== null;
    },
    init: function() {
      i("EXT_color_buffer_float"), i("WEBGL_clip_cull_distance"), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float"), i("WEBGL_multisampled_render_to_texture"), i("WEBGL_render_shared_exponent");
    },
    get: function(n) {
      const s = i(n);
      return s === null && Uh("THREE.WebGLRenderer: " + n + " extension not supported."), s;
    }
  };
}
function A4(r, e, i, n) {
  const s = {}, a = /* @__PURE__ */ new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const m in p.attributes)
      e.remove(p.attributes[m]);
    for (const m in p.morphAttributes) {
      const v = p.morphAttributes[m];
      for (let y = 0, g = v.length; y < g; y++)
        e.remove(v[y]);
    }
    p.removeEventListener("dispose", o), delete s[p.id];
    const f = a.get(p);
    f && (e.remove(f), a.delete(p)), n.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, i.memory.geometries--;
  }
  function l(d, p) {
    return s[p.id] === !0 || (p.addEventListener("dispose", o), s[p.id] = !0, i.memory.geometries++), p;
  }
  function u(d) {
    const p = d.attributes;
    for (const m in p)
      e.update(p[m], r.ARRAY_BUFFER);
    const f = d.morphAttributes;
    for (const m in f) {
      const v = f[m];
      for (let y = 0, g = v.length; y < g; y++)
        e.update(v[y], r.ARRAY_BUFFER);
    }
  }
  function c(d) {
    const p = [], f = d.index, m = d.attributes.position;
    let v = 0;
    if (f !== null) {
      const _ = f.array;
      v = f.version;
      for (let x = 0, b = _.length; x < b; x += 3) {
        const T = _[x + 0], S = _[x + 1], w = _[x + 2];
        p.push(T, S, S, w, w, T);
      }
    } else if (m !== void 0) {
      const _ = m.array;
      v = m.version;
      for (let x = 0, b = _.length / 3 - 1; x < b; x += 3) {
        const T = x + 0, S = x + 1, w = x + 2;
        p.push(T, S, S, w, w, T);
      }
    } else
      return;
    const y = new (XC(p) ? tR : eR)(p, 1);
    y.version = v;
    const g = a.get(d);
    g && e.remove(g), a.set(d, y);
  }
  function h(d) {
    const p = a.get(d);
    if (p) {
      const f = d.index;
      f !== null && p.version < f.version && c(d);
    } else
      c(d);
    return a.get(d);
  }
  return {
    get: l,
    update: u,
    getWireframeAttribute: h
  };
}
function C4(r, e, i) {
  let n;
  function s(p) {
    n = p;
  }
  let a, o;
  function l(p) {
    a = p.type, o = p.bytesPerElement;
  }
  function u(p, f) {
    r.drawElements(n, f, a, p * o), i.update(f, n, 1);
  }
  function c(p, f, m) {
    m !== 0 && (r.drawElementsInstanced(n, f, a, p * o, m), i.update(f, n, m));
  }
  function h(p, f, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, f, 0, a, p, 0, m);
    let v = 0;
    for (let y = 0; y < m; y++)
      v += f[y];
    i.update(v, n, 1);
  }
  function d(p, f, m, v) {
    if (m === 0) return;
    const y = e.get("WEBGL_multi_draw");
    if (y === null)
      for (let g = 0; g < p.length; g++)
        c(p[g] / o, f[g], v[g]);
    else {
      y.multiDrawElementsInstancedWEBGL(n, f, 0, a, p, 0, v, 0, m);
      let g = 0;
      for (let _ = 0; _ < m; _++)
        g += f[_] * v[_];
      i.update(g, n, 1);
    }
  }
  this.setMode = s, this.setIndex = l, this.render = u, this.renderInstances = c, this.renderMultiDraw = h, this.renderMultiDrawInstances = d;
}
function R4(r) {
  const e = {
    geometries: 0,
    textures: 0
  }, i = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(a, o, l) {
    switch (i.calls++, o) {
      case r.TRIANGLES:
        i.triangles += l * (a / 3);
        break;
      case r.LINES:
        i.lines += l * (a / 2);
        break;
      case r.LINE_STRIP:
        i.lines += l * (a - 1);
        break;
      case r.LINE_LOOP:
        i.lines += l * a;
        break;
      case r.POINTS:
        i.points += l * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function s() {
    i.calls = 0, i.triangles = 0, i.points = 0, i.lines = 0;
  }
  return {
    memory: e,
    render: i,
    programs: null,
    autoReset: !0,
    reset: s,
    update: n
  };
}
function N4(r, e, i) {
  const n = /* @__PURE__ */ new WeakMap(), s = new Fi();
  function a(o, l, u) {
    const c = o.morphTargetInfluences, h = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color, d = h !== void 0 ? h.length : 0;
    let p = n.get(l);
    if (p === void 0 || p.count !== d) {
      let f = function() {
        A.dispose(), n.delete(l), l.removeEventListener("dispose", f);
      };
      p !== void 0 && p.texture.dispose();
      const m = l.morphAttributes.position !== void 0, v = l.morphAttributes.normal !== void 0, y = l.morphAttributes.color !== void 0, g = l.morphAttributes.position || [], _ = l.morphAttributes.normal || [], x = l.morphAttributes.color || [];
      let b = 0;
      m === !0 && (b = 1), v === !0 && (b = 2), y === !0 && (b = 3);
      let T = l.attributes.position.count * b, S = 1;
      T > e.maxTextureSize && (S = Math.ceil(T / e.maxTextureSize), T = e.maxTextureSize);
      const w = new Float32Array(T * S * 4 * d), A = new KC(w, T, S, d);
      A.type = na, A.needsUpdate = !0;
      const E = b * 4;
      for (let M = 0; M < d; M++) {
        const N = g[M], k = _[M], U = x[M], C = T * S * 4 * M;
        for (let O = 0; O < N.count; O++) {
          const D = O * E;
          m === !0 && (s.fromBufferAttribute(N, O), w[C + D + 0] = s.x, w[C + D + 1] = s.y, w[C + D + 2] = s.z, w[C + D + 3] = 0), v === !0 && (s.fromBufferAttribute(k, O), w[C + D + 4] = s.x, w[C + D + 5] = s.y, w[C + D + 6] = s.z, w[C + D + 7] = 0), y === !0 && (s.fromBufferAttribute(U, O), w[C + D + 8] = s.x, w[C + D + 9] = s.y, w[C + D + 10] = s.z, w[C + D + 11] = U.itemSize === 4 ? s.w : 1);
        }
      }
      p = {
        count: d,
        texture: A,
        size: new Ue(T, S)
      }, n.set(l, p), l.addEventListener("dispose", f);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      u.getUniforms().setValue(r, "morphTexture", o.morphTexture, i);
    else {
      let f = 0;
      for (let v = 0; v < c.length; v++)
        f += c[v];
      const m = l.morphTargetsRelative ? 1 : 1 - f;
      u.getUniforms().setValue(r, "morphTargetBaseInfluence", m), u.getUniforms().setValue(r, "morphTargetInfluences", c);
    }
    u.getUniforms().setValue(r, "morphTargetsTexture", p.texture, i), u.getUniforms().setValue(r, "morphTargetsTextureSize", p.size);
  }
  return {
    update: a
  };
}
function P4(r, e, i, n) {
  let s = /* @__PURE__ */ new WeakMap();
  function a(u) {
    const c = n.render.frame, h = u.geometry, d = e.get(u, h);
    if (s.get(d) !== c && (e.update(d), s.set(d, c)), u.isInstancedMesh && (u.hasEventListener("dispose", l) === !1 && u.addEventListener("dispose", l), s.get(u) !== c && (i.update(u.instanceMatrix, r.ARRAY_BUFFER), u.instanceColor !== null && i.update(u.instanceColor, r.ARRAY_BUFFER), s.set(u, c))), u.isSkinnedMesh) {
      const p = u.skeleton;
      s.get(p) !== c && (p.update(), s.set(p, c));
    }
    return d;
  }
  function o() {
    s = /* @__PURE__ */ new WeakMap();
  }
  function l(u) {
    const c = u.target;
    c.removeEventListener("dispose", l), i.remove(c.instanceMatrix), c.instanceColor !== null && i.remove(c.instanceColor);
  }
  return {
    update: a,
    dispose: o
  };
}
let uR = class extends En {
  constructor(r, e, i, n, s, a, o, l, u, c = Hu) {
    if (c !== Hu && c !== mc)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && c === Hu && (i = xl), i === void 0 && c === mc && (i = fc), super(null, n, s, a, o, l, c, i, u), this.isDepthTexture = !0, this.image = { width: r, height: e }, this.magFilter = o !== void 0 ? o : Kn, this.minFilter = l !== void 0 ? l : Kn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(r) {
    return super.copy(r), this.compareFunction = r.compareFunction, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
  }
};
const cR = /* @__PURE__ */ new En(), Z1 = /* @__PURE__ */ new uR(1, 1), hR = /* @__PURE__ */ new KC(), dR = /* @__PURE__ */ new vB(), pR = /* @__PURE__ */ new oR(), Q1 = [], J1 = [], ew = new Float32Array(16), tw = new Float32Array(9), iw = new Float32Array(4);
function Uc(r, e, i) {
  const n = r[0];
  if (n <= 0 || n > 0) return r;
  const s = e * i;
  let a = Q1[s];
  if (a === void 0 && (a = new Float32Array(s), Q1[s] = a), e !== 0) {
    n.toArray(a, 0);
    for (let o = 1, l = 0; o !== e; ++o)
      l += i, r[o].toArray(a, l);
  }
  return a;
}
function Hi(r, e) {
  if (r.length !== e.length) return !1;
  for (let i = 0, n = r.length; i < n; i++)
    if (r[i] !== e[i]) return !1;
  return !0;
}
function Wi(r, e) {
  for (let i = 0, n = e.length; i < n; i++)
    r[i] = e[i];
}
function Tg(r, e) {
  let i = J1[e];
  i === void 0 && (i = new Int32Array(e), J1[e] = i);
  for (let n = 0; n !== e; ++n)
    i[n] = r.allocateTextureUnit();
  return i;
}
function I4(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1f(this.addr, e), i[0] = e);
}
function O4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Hi(i, e)) return;
    r.uniform2fv(this.addr, e), Wi(i, e);
  }
}
function D4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else if (e.r !== void 0)
    (i[0] !== e.r || i[1] !== e.g || i[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
  else {
    if (Hi(i, e)) return;
    r.uniform3fv(this.addr, e), Wi(i, e);
  }
}
function L4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Hi(i, e)) return;
    r.uniform4fv(this.addr, e), Wi(i, e);
  }
}
function U4(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Hi(i, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), Wi(i, e);
  } else {
    if (Hi(i, n)) return;
    iw.set(n), r.uniformMatrix2fv(this.addr, !1, iw), Wi(i, n);
  }
}
function k4(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Hi(i, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), Wi(i, e);
  } else {
    if (Hi(i, n)) return;
    tw.set(n), r.uniformMatrix3fv(this.addr, !1, tw), Wi(i, n);
  }
}
function F4(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Hi(i, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), Wi(i, e);
  } else {
    if (Hi(i, n)) return;
    ew.set(n), r.uniformMatrix4fv(this.addr, !1, ew), Wi(i, n);
  }
}
function B4(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1i(this.addr, e), i[0] = e);
}
function z4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Hi(i, e)) return;
    r.uniform2iv(this.addr, e), Wi(i, e);
  }
}
function j4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else {
    if (Hi(i, e)) return;
    r.uniform3iv(this.addr, e), Wi(i, e);
  }
}
function V4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Hi(i, e)) return;
    r.uniform4iv(this.addr, e), Wi(i, e);
  }
}
function G4(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1ui(this.addr, e), i[0] = e);
}
function H4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Hi(i, e)) return;
    r.uniform2uiv(this.addr, e), Wi(i, e);
  }
}
function W4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else {
    if (Hi(i, e)) return;
    r.uniform3uiv(this.addr, e), Wi(i, e);
  }
}
function q4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Hi(i, e)) return;
    r.uniform4uiv(this.addr, e), Wi(i, e);
  }
}
function X4(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s);
  let a;
  this.type === r.SAMPLER_2D_SHADOW ? (Z1.compareFunction = HC, a = Z1) : a = cR, i.setTexture2D(e || a, s);
}
function $4(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTexture3D(e || dR, s);
}
function Y4(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTextureCube(e || pR, s);
}
function K4(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTexture2DArray(e || hR, s);
}
function Z4(r) {
  switch (r) {
    case 5126:
      return I4;
    case 35664:
      return O4;
    case 35665:
      return D4;
    case 35666:
      return L4;
    case 35674:
      return U4;
    case 35675:
      return k4;
    case 35676:
      return F4;
    case 5124:
    case 35670:
      return B4;
    case 35667:
    case 35671:
      return z4;
    case 35668:
    case 35672:
      return j4;
    case 35669:
    case 35673:
      return V4;
    case 5125:
      return G4;
    case 36294:
      return H4;
    case 36295:
      return W4;
    case 36296:
      return q4;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return X4;
    case 35679:
    case 36299:
    case 36307:
      return $4;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Y4;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return K4;
  }
}
function Q4(r, e) {
  r.uniform1fv(this.addr, e);
}
function J4(r, e) {
  const i = Uc(e, this.size, 2);
  r.uniform2fv(this.addr, i);
}
function e6(r, e) {
  const i = Uc(e, this.size, 3);
  r.uniform3fv(this.addr, i);
}
function t6(r, e) {
  const i = Uc(e, this.size, 4);
  r.uniform4fv(this.addr, i);
}
function i6(r, e) {
  const i = Uc(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, i);
}
function r6(r, e) {
  const i = Uc(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, i);
}
function n6(r, e) {
  const i = Uc(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, i);
}
function s6(r, e) {
  r.uniform1iv(this.addr, e);
}
function a6(r, e) {
  r.uniform2iv(this.addr, e);
}
function o6(r, e) {
  r.uniform3iv(this.addr, e);
}
function l6(r, e) {
  r.uniform4iv(this.addr, e);
}
function u6(r, e) {
  r.uniform1uiv(this.addr, e);
}
function c6(r, e) {
  r.uniform2uiv(this.addr, e);
}
function h6(r, e) {
  r.uniform3uiv(this.addr, e);
}
function d6(r, e) {
  r.uniform4uiv(this.addr, e);
}
function p6(r, e, i) {
  const n = this.cache, s = e.length, a = Tg(i, s);
  Hi(n, a) || (r.uniform1iv(this.addr, a), Wi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture2D(e[o] || cR, a[o]);
}
function f6(r, e, i) {
  const n = this.cache, s = e.length, a = Tg(i, s);
  Hi(n, a) || (r.uniform1iv(this.addr, a), Wi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture3D(e[o] || dR, a[o]);
}
function m6(r, e, i) {
  const n = this.cache, s = e.length, a = Tg(i, s);
  Hi(n, a) || (r.uniform1iv(this.addr, a), Wi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTextureCube(e[o] || pR, a[o]);
}
function g6(r, e, i) {
  const n = this.cache, s = e.length, a = Tg(i, s);
  Hi(n, a) || (r.uniform1iv(this.addr, a), Wi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture2DArray(e[o] || hR, a[o]);
}
function y6(r) {
  switch (r) {
    case 5126:
      return Q4;
    case 35664:
      return J4;
    case 35665:
      return e6;
    case 35666:
      return t6;
    case 35674:
      return i6;
    case 35675:
      return r6;
    case 35676:
      return n6;
    case 5124:
    case 35670:
      return s6;
    case 35667:
    case 35671:
      return a6;
    case 35668:
    case 35672:
      return o6;
    case 35669:
    case 35673:
      return l6;
    case 5125:
      return u6;
    case 36294:
      return c6;
    case 36295:
      return h6;
    case 36296:
      return d6;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return p6;
    case 35679:
    case 36299:
    case 36307:
      return f6;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return m6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return g6;
  }
}
class v6 {
  constructor(e, i, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = i.type, this.setValue = Z4(i.type);
  }
}
class b6 {
  constructor(e, i, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = i.type, this.size = i.size, this.setValue = y6(i.type);
  }
}
class x6 {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, i, n) {
    const s = this.seq;
    for (let a = 0, o = s.length; a !== o; ++a) {
      const l = s[a];
      l.setValue(e, i[l.id], n);
    }
  }
}
const Gy = /(\w+)(\])?(\[|\.)?/g;
function rw(r, e) {
  r.seq.push(e), r.map[e.id] = e;
}
function _6(r, e, i) {
  const n = r.name, s = n.length;
  for (Gy.lastIndex = 0; ; ) {
    const a = Gy.exec(n), o = Gy.lastIndex;
    let l = a[1];
    const u = a[2] === "]", c = a[3];
    if (u && (l = l | 0), c === void 0 || c === "[" && o + 2 === s) {
      rw(i, c === void 0 ? new v6(l, r, e) : new b6(l, r, e));
      break;
    } else {
      let h = i.map[l];
      h === void 0 && (h = new x6(l), rw(i, h)), i = h;
    }
  }
}
class Kf {
  constructor(e, i) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(i, e.ACTIVE_UNIFORMS);
    for (let s = 0; s < n; ++s) {
      const a = e.getActiveUniform(i, s), o = e.getUniformLocation(i, a.name);
      _6(a, o, this);
    }
  }
  setValue(e, i, n, s) {
    const a = this.map[i];
    a !== void 0 && a.setValue(e, n, s);
  }
  setOptional(e, i, n) {
    const s = i[n];
    s !== void 0 && this.setValue(e, n, s);
  }
  static upload(e, i, n, s) {
    for (let a = 0, o = i.length; a !== o; ++a) {
      const l = i[a], u = n[l.id];
      u.needsUpdate !== !1 && l.setValue(e, u.value, s);
    }
  }
  static seqWithValue(e, i) {
    const n = [];
    for (let s = 0, a = e.length; s !== a; ++s) {
      const o = e[s];
      o.id in i && n.push(o);
    }
    return n;
  }
}
function nw(r, e, i) {
  const n = r.createShader(e);
  return r.shaderSource(n, i), r.compileShader(n), n;
}
const T6 = 37297;
let S6 = 0;
function w6(r, e) {
  const i = r.split(`
`), n = [], s = Math.max(e - 6, 0), a = Math.min(e + 6, i.length);
  for (let o = s; o < a; o++) {
    const l = o + 1;
    n.push(`${l === e ? ">" : " "} ${l}: ${i[o]}`);
  }
  return n.join(`
`);
}
const sw = /* @__PURE__ */ new It();
function E6(r) {
  Vt._getMatrix(sw, Vt.workingColorSpace, r);
  const e = `mat3( ${sw.elements.map((i) => i.toFixed(4))} )`;
  switch (Vt.getTransfer(r)) {
    case vg:
      return [e, "LinearTransferOETF"];
    case Jt:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", r), [e, "LinearTransferOETF"];
  }
}
function aw(r, e, i) {
  const n = r.getShaderParameter(e, r.COMPILE_STATUS), s = r.getShaderInfoLog(e).trim();
  if (n && s === "") return "";
  const a = /ERROR: 0:(\d+)/.exec(s);
  if (a) {
    const o = parseInt(a[1]);
    return i.toUpperCase() + `

` + s + `

` + w6(r.getShaderSource(e), o);
  } else
    return s;
}
function M6(r, e) {
  const i = E6(e);
  return [
    `vec4 ${r}( vec4 value ) {`,
    `	return ${i[1]}( vec4( value.rgb * ${i[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function A6(r, e) {
  let i;
  switch (e) {
    case NF:
      i = "Linear";
      break;
    case PF:
      i = "Reinhard";
      break;
    case IF:
      i = "Cineon";
      break;
    case OF:
      i = "ACESFilmic";
      break;
    case LF:
      i = "AgX";
      break;
    case UF:
      i = "Neutral";
      break;
    case DF:
      i = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), i = "Linear";
  }
  return "vec3 " + r + "( vec3 color ) { return " + i + "ToneMapping( color ); }";
}
const Np = /* @__PURE__ */ new q();
function C6() {
  Vt.getLuminanceCoefficients(Np);
  const r = Np.x.toFixed(4), e = Np.y.toFixed(4), i = Np.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r}, ${e}, ${i} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function R6(r) {
  return [
    r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(kh).join(`
`);
}
function N6(r) {
  const e = [];
  for (const i in r) {
    const n = r[i];
    n !== !1 && e.push("#define " + i + " " + n);
  }
  return e.join(`
`);
}
function P6(r, e) {
  const i = {}, n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
  for (let s = 0; s < n; s++) {
    const a = r.getActiveAttrib(e, s), o = a.name;
    let l = 1;
    a.type === r.FLOAT_MAT2 && (l = 2), a.type === r.FLOAT_MAT3 && (l = 3), a.type === r.FLOAT_MAT4 && (l = 4), i[o] = {
      type: a.type,
      location: r.getAttribLocation(e, o),
      locationSize: l
    };
  }
  return i;
}
function kh(r) {
  return r !== "";
}
function ow(r, e) {
  const i = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function lw(r, e) {
  return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const I6 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Db(r) {
  return r.replace(I6, D6);
}
const O6 = /* @__PURE__ */ new Map();
function D6(r, e) {
  let i = Ct[e];
  if (i === void 0) {
    const n = O6.get(e);
    if (n !== void 0)
      i = Ct[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return Db(i);
}
const L6 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function uw(r) {
  return r.replace(L6, U6);
}
function U6(r, e, i, n) {
  let s = "";
  for (let a = parseInt(e); a < parseInt(i); a++)
    s += n.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
  return s;
}
function cw(r) {
  let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
  return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function k6(r) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return r.shadowMapType === PC ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === uF ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === Hs && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function F6(r) {
  let e = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case dc:
      case pc:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case yg:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function B6(r) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case pc:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function z6(r) {
  let e = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case __:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case CF:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case RF:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function j6(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const i = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 7 * 16)), texelHeight: n, maxMip: i };
}
function V6(r, e, i, n) {
  const s = r.getContext(), a = i.defines;
  let o = i.vertexShader, l = i.fragmentShader;
  const u = k6(i), c = F6(i), h = B6(i), d = z6(i), p = j6(i), f = R6(i), m = N6(a), v = s.createProgram();
  let y, g, _ = i.glslVersion ? "#version " + i.glslVersion + `
` : "";
  i.isRawShaderMaterial ? (y = [
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m
  ].filter(kh).join(`
`), y.length > 0 && (y += `
`), g = [
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m
  ].filter(kh).join(`
`), g.length > 0 && (g += `
`)) : (y = [
    cw(i),
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m,
    i.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    i.batching ? "#define USE_BATCHING" : "",
    i.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    i.instancing ? "#define USE_INSTANCING" : "",
    i.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    i.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    i.useFog && i.fog ? "#define USE_FOG" : "",
    i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
    i.map ? "#define USE_MAP" : "",
    i.envMap ? "#define USE_ENVMAP" : "",
    i.envMap ? "#define " + h : "",
    i.lightMap ? "#define USE_LIGHTMAP" : "",
    i.aoMap ? "#define USE_AOMAP" : "",
    i.bumpMap ? "#define USE_BUMPMAP" : "",
    i.normalMap ? "#define USE_NORMALMAP" : "",
    i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    i.anisotropy ? "#define USE_ANISOTROPY" : "",
    i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    i.specularMap ? "#define USE_SPECULARMAP" : "",
    i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    i.metalnessMap ? "#define USE_METALNESSMAP" : "",
    i.alphaMap ? "#define USE_ALPHAMAP" : "",
    i.alphaHash ? "#define USE_ALPHAHASH" : "",
    i.transmission ? "#define USE_TRANSMISSION" : "",
    i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    i.mapUv ? "#define MAP_UV " + i.mapUv : "",
    i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "",
    i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "",
    i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "",
    i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "",
    i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "",
    i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "",
    i.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv : "",
    i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "",
    i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "",
    i.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv : "",
    i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "",
    i.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv : "",
    i.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv : "",
    i.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv : "",
    i.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i.iridescenceThicknessMapUv : "",
    i.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv : "",
    i.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv : "",
    i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "",
    i.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv : "",
    i.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv : "",
    i.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv : "",
    i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "",
    //
    i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "",
    i.vertexColors ? "#define USE_COLOR" : "",
    i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    i.vertexUv1s ? "#define USE_UV1" : "",
    i.vertexUv2s ? "#define USE_UV2" : "",
    i.vertexUv3s ? "#define USE_UV3" : "",
    i.pointsUvs ? "#define USE_POINTS_UV" : "",
    i.flatShading ? "#define FLAT_SHADED" : "",
    i.skinning ? "#define USE_SKINNING" : "",
    i.morphTargets ? "#define USE_MORPHTARGETS" : "",
    i.morphNormals && i.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    i.morphColors ? "#define USE_MORPHCOLORS" : "",
    i.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "",
    i.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "",
    i.doubleSided ? "#define DOUBLE_SIDED" : "",
    i.flipSided ? "#define FLIP_SIDED" : "",
    i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    i.shadowMapEnabled ? "#define " + u : "",
    i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(kh).join(`
`), g = [
    cw(i),
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m,
    i.useFog && i.fog ? "#define USE_FOG" : "",
    i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
    i.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    i.map ? "#define USE_MAP" : "",
    i.matcap ? "#define USE_MATCAP" : "",
    i.envMap ? "#define USE_ENVMAP" : "",
    i.envMap ? "#define " + c : "",
    i.envMap ? "#define " + h : "",
    i.envMap ? "#define " + d : "",
    p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
    p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
    p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
    i.lightMap ? "#define USE_LIGHTMAP" : "",
    i.aoMap ? "#define USE_AOMAP" : "",
    i.bumpMap ? "#define USE_BUMPMAP" : "",
    i.normalMap ? "#define USE_NORMALMAP" : "",
    i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    i.anisotropy ? "#define USE_ANISOTROPY" : "",
    i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    i.clearcoat ? "#define USE_CLEARCOAT" : "",
    i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    i.dispersion ? "#define USE_DISPERSION" : "",
    i.iridescence ? "#define USE_IRIDESCENCE" : "",
    i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    i.specularMap ? "#define USE_SPECULARMAP" : "",
    i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    i.metalnessMap ? "#define USE_METALNESSMAP" : "",
    i.alphaMap ? "#define USE_ALPHAMAP" : "",
    i.alphaTest ? "#define USE_ALPHATEST" : "",
    i.alphaHash ? "#define USE_ALPHAHASH" : "",
    i.sheen ? "#define USE_SHEEN" : "",
    i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    i.transmission ? "#define USE_TRANSMISSION" : "",
    i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "",
    i.vertexColors || i.instancingColor || i.batchingColor ? "#define USE_COLOR" : "",
    i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    i.vertexUv1s ? "#define USE_UV1" : "",
    i.vertexUv2s ? "#define USE_UV2" : "",
    i.vertexUv3s ? "#define USE_UV3" : "",
    i.pointsUvs ? "#define USE_POINTS_UV" : "",
    i.gradientMap ? "#define USE_GRADIENTMAP" : "",
    i.flatShading ? "#define FLAT_SHADED" : "",
    i.doubleSided ? "#define DOUBLE_SIDED" : "",
    i.flipSided ? "#define FLIP_SIDED" : "",
    i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    i.shadowMapEnabled ? "#define " + u : "",
    i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    i.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    i.toneMapping !== lo ? "#define TONE_MAPPING" : "",
    i.toneMapping !== lo ? Ct.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    i.toneMapping !== lo ? A6("toneMapping", i.toneMapping) : "",
    i.dithering ? "#define DITHERING" : "",
    i.opaque ? "#define OPAQUE" : "",
    Ct.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    M6("linearToOutputTexel", i.outputColorSpace),
    C6(),
    i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
    `
`
  ].filter(kh).join(`
`)), o = Db(o), o = ow(o, i), o = lw(o, i), l = Db(l), l = ow(l, i), l = lw(l, i), o = uw(o), l = uw(l), i.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, y = [
    f,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + y, g = [
    "#define varying in",
    i.glslVersion === T1 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    i.glslVersion === T1 ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + g);
  const x = _ + y + o, b = _ + g + l, T = nw(s, s.VERTEX_SHADER, x), S = nw(s, s.FRAGMENT_SHADER, b);
  s.attachShader(v, T), s.attachShader(v, S), i.index0AttributeName !== void 0 ? s.bindAttribLocation(v, 0, i.index0AttributeName) : i.morphTargets === !0 && s.bindAttribLocation(v, 0, "position"), s.linkProgram(v);
  function w(N) {
    if (r.debug.checkShaderErrors) {
      const k = s.getProgramInfoLog(v).trim(), U = s.getShaderInfoLog(T).trim(), C = s.getShaderInfoLog(S).trim();
      let O = !0, D = !0;
      if (s.getProgramParameter(v, s.LINK_STATUS) === !1)
        if (O = !1, typeof r.debug.onShaderError == "function")
          r.debug.onShaderError(s, v, T, S);
        else {
          const H = aw(s, T, "vertex"), j = aw(s, S, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(v, s.VALIDATE_STATUS) + `

Material Name: ` + N.name + `
Material Type: ` + N.type + `

Program Info Log: ` + k + `
` + H + `
` + j
          );
        }
      else k !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", k) : (U === "" || C === "") && (D = !1);
      D && (N.diagnostics = {
        runnable: O,
        programLog: k,
        vertexShader: {
          log: U,
          prefix: y
        },
        fragmentShader: {
          log: C,
          prefix: g
        }
      });
    }
    s.deleteShader(T), s.deleteShader(S), A = new Kf(s, v), E = P6(s, v);
  }
  let A;
  this.getUniforms = function() {
    return A === void 0 && w(this), A;
  };
  let E;
  this.getAttributes = function() {
    return E === void 0 && w(this), E;
  };
  let M = i.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return M === !1 && (M = s.getProgramParameter(v, T6)), M;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), s.deleteProgram(v), this.program = void 0;
  }, this.type = i.shaderType, this.name = i.shaderName, this.id = S6++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = T, this.fragmentShader = S, this;
}
let G6 = 0;
class H6 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const i = e.vertexShader, n = e.fragmentShader, s = this._getShaderStage(i), a = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e);
    return o.has(s) === !1 && (o.add(s), s.usedTimes++), o.has(a) === !1 && (o.add(a), a.usedTimes++), this;
  }
  remove(e) {
    const i = this.materialCache.get(e);
    for (const n of i)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const i = this.materialCache;
    let n = i.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), i.set(e, n)), n;
  }
  _getShaderStage(e) {
    const i = this.shaderCache;
    let n = i.get(e);
    return n === void 0 && (n = new W6(e), i.set(e, n)), n;
  }
}
class W6 {
  constructor(e) {
    this.id = G6++, this.code = e, this.usedTimes = 0;
  }
}
function q6(r, e, i, n, s, a, o) {
  const l = new R_(), u = new H6(), c = /* @__PURE__ */ new Set(), h = [], d = s.logarithmicDepthBuffer, p = s.vertexTextures;
  let f = s.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function v(E) {
    return c.add(E), E === 0 ? "uv" : `uv${E}`;
  }
  function y(E, M, N, k, U) {
    const C = k.fog, O = U.geometry, D = E.isMeshStandardMaterial ? k.environment : null, H = (E.isMeshStandardMaterial ? i : e).get(E.envMap || D), j = H && H.mapping === yg ? H.image.height : null, K = m[E.type];
    E.precision !== null && (f = s.getMaxPrecision(E.precision), f !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", f, "instead."));
    const L = O.morphAttributes.position || O.morphAttributes.normal || O.morphAttributes.color, B = L !== void 0 ? L.length : 0;
    let Q = 0;
    O.morphAttributes.position !== void 0 && (Q = 1), O.morphAttributes.normal !== void 0 && (Q = 2), O.morphAttributes.color !== void 0 && (Q = 3);
    let W, z, X, ae;
    if (K) {
      const Ft = hs[K];
      W = Ft.vertexShader, z = Ft.fragmentShader;
    } else
      W = E.vertexShader, z = E.fragmentShader, u.update(E), X = u.getVertexShaderID(E), ae = u.getFragmentShaderID(E);
    const ue = r.getRenderTarget(), ge = r.state.buffers.depth.getReversed(), we = U.isInstancedMesh === !0, Ne = U.isBatchedMesh === !0, lt = !!E.map, be = !!E.matcap, bt = !!H, Y = !!E.aoMap, Gt = !!E.lightMap, Xe = !!E.bumpMap, yt = !!E.normalMap, rt = !!E.displacementMap, Nt = !!E.emissiveMap, nt = !!E.metalnessMap, F = !!E.roughnessMap, P = E.anisotropy > 0, le = E.clearcoat > 0, Te = E.dispersion > 0, Ae = E.iridescence > 0, xe = E.sheen > 0, Je = E.transmission > 0, Be = P && !!E.anisotropyMap, qe = le && !!E.clearcoatMap, Pt = le && !!E.clearcoatNormalMap, Ie = le && !!E.clearcoatRoughnessMap, $e = Ae && !!E.iridescenceMap, ut = Ae && !!E.iridescenceThicknessMap, ft = xe && !!E.sheenColorMap, Ye = xe && !!E.sheenRoughnessMap, Ot = !!E.specularMap, xt = !!E.specularColorMap, Bt = !!E.specularIntensityMap, ee = Je && !!E.transmissionMap, Le = Je && !!E.thicknessMap, de = !!E.gradientMap, Se = !!E.alphaMap, ze = E.alphaTest > 0, ke = !!E.alphaHash, At = !!E.extensions;
    let ri = lo;
    E.toneMapped && (ue === null || ue.isXRRenderTarget === !0) && (ri = r.toneMapping);
    const _i = {
      shaderID: K,
      shaderType: E.type,
      shaderName: E.name,
      vertexShader: W,
      fragmentShader: z,
      defines: E.defines,
      customVertexShaderID: X,
      customFragmentShaderID: ae,
      isRawShaderMaterial: E.isRawShaderMaterial === !0,
      glslVersion: E.glslVersion,
      precision: f,
      batching: Ne,
      batchingColor: Ne && U._colorsTexture !== null,
      instancing: we,
      instancingColor: we && U.instanceColor !== null,
      instancingMorph: we && U.morphTexture !== null,
      supportsVertexTextures: p,
      outputColorSpace: ue === null ? r.outputColorSpace : ue.isXRRenderTarget === !0 ? ue.texture.colorSpace : Lc,
      alphaToCoverage: !!E.alphaToCoverage,
      map: lt,
      matcap: be,
      envMap: bt,
      envMapMode: bt && H.mapping,
      envMapCubeUVHeight: j,
      aoMap: Y,
      lightMap: Gt,
      bumpMap: Xe,
      normalMap: yt,
      displacementMap: p && rt,
      emissiveMap: Nt,
      normalMapObjectSpace: yt && E.normalMapType === zF,
      normalMapTangentSpace: yt && E.normalMapType === GC,
      metalnessMap: nt,
      roughnessMap: F,
      anisotropy: P,
      anisotropyMap: Be,
      clearcoat: le,
      clearcoatMap: qe,
      clearcoatNormalMap: Pt,
      clearcoatRoughnessMap: Ie,
      dispersion: Te,
      iridescence: Ae,
      iridescenceMap: $e,
      iridescenceThicknessMap: ut,
      sheen: xe,
      sheenColorMap: ft,
      sheenRoughnessMap: Ye,
      specularMap: Ot,
      specularColorMap: xt,
      specularIntensityMap: Bt,
      transmission: Je,
      transmissionMap: ee,
      thicknessMap: Le,
      gradientMap: de,
      opaque: E.transparent === !1 && E.blending === Gu && E.alphaToCoverage === !1,
      alphaMap: Se,
      alphaTest: ze,
      alphaHash: ke,
      combine: E.combine,
      //
      mapUv: lt && v(E.map.channel),
      aoMapUv: Y && v(E.aoMap.channel),
      lightMapUv: Gt && v(E.lightMap.channel),
      bumpMapUv: Xe && v(E.bumpMap.channel),
      normalMapUv: yt && v(E.normalMap.channel),
      displacementMapUv: rt && v(E.displacementMap.channel),
      emissiveMapUv: Nt && v(E.emissiveMap.channel),
      metalnessMapUv: nt && v(E.metalnessMap.channel),
      roughnessMapUv: F && v(E.roughnessMap.channel),
      anisotropyMapUv: Be && v(E.anisotropyMap.channel),
      clearcoatMapUv: qe && v(E.clearcoatMap.channel),
      clearcoatNormalMapUv: Pt && v(E.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ie && v(E.clearcoatRoughnessMap.channel),
      iridescenceMapUv: $e && v(E.iridescenceMap.channel),
      iridescenceThicknessMapUv: ut && v(E.iridescenceThicknessMap.channel),
      sheenColorMapUv: ft && v(E.sheenColorMap.channel),
      sheenRoughnessMapUv: Ye && v(E.sheenRoughnessMap.channel),
      specularMapUv: Ot && v(E.specularMap.channel),
      specularColorMapUv: xt && v(E.specularColorMap.channel),
      specularIntensityMapUv: Bt && v(E.specularIntensityMap.channel),
      transmissionMapUv: ee && v(E.transmissionMap.channel),
      thicknessMapUv: Le && v(E.thicknessMap.channel),
      alphaMapUv: Se && v(E.alphaMap.channel),
      //
      vertexTangents: !!O.attributes.tangent && (yt || P),
      vertexColors: E.vertexColors,
      vertexAlphas: E.vertexColors === !0 && !!O.attributes.color && O.attributes.color.itemSize === 4,
      pointsUvs: U.isPoints === !0 && !!O.attributes.uv && (lt || Se),
      fog: !!C,
      useFog: E.fog === !0,
      fogExp2: !!C && C.isFogExp2,
      flatShading: E.flatShading === !0,
      sizeAttenuation: E.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      reverseDepthBuffer: ge,
      skinning: U.isSkinnedMesh === !0,
      morphTargets: O.morphAttributes.position !== void 0,
      morphNormals: O.morphAttributes.normal !== void 0,
      morphColors: O.morphAttributes.color !== void 0,
      morphTargetsCount: B,
      morphTextureStride: Q,
      numDirLights: M.directional.length,
      numPointLights: M.point.length,
      numSpotLights: M.spot.length,
      numSpotLightMaps: M.spotLightMap.length,
      numRectAreaLights: M.rectArea.length,
      numHemiLights: M.hemi.length,
      numDirLightShadows: M.directionalShadowMap.length,
      numPointLightShadows: M.pointShadowMap.length,
      numSpotLightShadows: M.spotShadowMap.length,
      numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps,
      numLightProbes: M.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: E.dithering,
      shadowMapEnabled: r.shadowMap.enabled && N.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: ri,
      decodeVideoTexture: lt && E.map.isVideoTexture === !0 && Vt.getTransfer(E.map.colorSpace) === Jt,
      decodeVideoTextureEmissive: Nt && E.emissiveMap.isVideoTexture === !0 && Vt.getTransfer(E.emissiveMap.colorSpace) === Jt,
      premultipliedAlpha: E.premultipliedAlpha,
      doubleSided: E.side === Qs,
      flipSided: E.side === Ar,
      useDepthPacking: E.depthPacking >= 0,
      depthPacking: E.depthPacking || 0,
      index0AttributeName: E.index0AttributeName,
      extensionClipCullDistance: At && E.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (At && E.extensions.multiDraw === !0 || Ne) && n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: E.customProgramCacheKey()
    };
    return _i.vertexUv1s = c.has(1), _i.vertexUv2s = c.has(2), _i.vertexUv3s = c.has(3), c.clear(), _i;
  }
  function g(E) {
    const M = [];
    if (E.shaderID ? M.push(E.shaderID) : (M.push(E.customVertexShaderID), M.push(E.customFragmentShaderID)), E.defines !== void 0)
      for (const N in E.defines)
        M.push(N), M.push(E.defines[N]);
    return E.isRawShaderMaterial === !1 && (_(M, E), x(M, E), M.push(r.outputColorSpace)), M.push(E.customProgramCacheKey), M.join();
  }
  function _(E, M) {
    E.push(M.precision), E.push(M.outputColorSpace), E.push(M.envMapMode), E.push(M.envMapCubeUVHeight), E.push(M.mapUv), E.push(M.alphaMapUv), E.push(M.lightMapUv), E.push(M.aoMapUv), E.push(M.bumpMapUv), E.push(M.normalMapUv), E.push(M.displacementMapUv), E.push(M.emissiveMapUv), E.push(M.metalnessMapUv), E.push(M.roughnessMapUv), E.push(M.anisotropyMapUv), E.push(M.clearcoatMapUv), E.push(M.clearcoatNormalMapUv), E.push(M.clearcoatRoughnessMapUv), E.push(M.iridescenceMapUv), E.push(M.iridescenceThicknessMapUv), E.push(M.sheenColorMapUv), E.push(M.sheenRoughnessMapUv), E.push(M.specularMapUv), E.push(M.specularColorMapUv), E.push(M.specularIntensityMapUv), E.push(M.transmissionMapUv), E.push(M.thicknessMapUv), E.push(M.combine), E.push(M.fogExp2), E.push(M.sizeAttenuation), E.push(M.morphTargetsCount), E.push(M.morphAttributeCount), E.push(M.numDirLights), E.push(M.numPointLights), E.push(M.numSpotLights), E.push(M.numSpotLightMaps), E.push(M.numHemiLights), E.push(M.numRectAreaLights), E.push(M.numDirLightShadows), E.push(M.numPointLightShadows), E.push(M.numSpotLightShadows), E.push(M.numSpotLightShadowsWithMaps), E.push(M.numLightProbes), E.push(M.shadowMapType), E.push(M.toneMapping), E.push(M.numClippingPlanes), E.push(M.numClipIntersection), E.push(M.depthPacking);
  }
  function x(E, M) {
    l.disableAll(), M.supportsVertexTextures && l.enable(0), M.instancing && l.enable(1), M.instancingColor && l.enable(2), M.instancingMorph && l.enable(3), M.matcap && l.enable(4), M.envMap && l.enable(5), M.normalMapObjectSpace && l.enable(6), M.normalMapTangentSpace && l.enable(7), M.clearcoat && l.enable(8), M.iridescence && l.enable(9), M.alphaTest && l.enable(10), M.vertexColors && l.enable(11), M.vertexAlphas && l.enable(12), M.vertexUv1s && l.enable(13), M.vertexUv2s && l.enable(14), M.vertexUv3s && l.enable(15), M.vertexTangents && l.enable(16), M.anisotropy && l.enable(17), M.alphaHash && l.enable(18), M.batching && l.enable(19), M.dispersion && l.enable(20), M.batchingColor && l.enable(21), E.push(l.mask), l.disableAll(), M.fog && l.enable(0), M.useFog && l.enable(1), M.flatShading && l.enable(2), M.logarithmicDepthBuffer && l.enable(3), M.reverseDepthBuffer && l.enable(4), M.skinning && l.enable(5), M.morphTargets && l.enable(6), M.morphNormals && l.enable(7), M.morphColors && l.enable(8), M.premultipliedAlpha && l.enable(9), M.shadowMapEnabled && l.enable(10), M.doubleSided && l.enable(11), M.flipSided && l.enable(12), M.useDepthPacking && l.enable(13), M.dithering && l.enable(14), M.transmission && l.enable(15), M.sheen && l.enable(16), M.opaque && l.enable(17), M.pointsUvs && l.enable(18), M.decodeVideoTexture && l.enable(19), M.decodeVideoTextureEmissive && l.enable(20), M.alphaToCoverage && l.enable(21), E.push(l.mask);
  }
  function b(E) {
    const M = m[E.type];
    let N;
    if (M) {
      const k = hs[M];
      N = sR.clone(k.uniforms);
    } else
      N = E.uniforms;
    return N;
  }
  function T(E, M) {
    let N;
    for (let k = 0, U = h.length; k < U; k++) {
      const C = h[k];
      if (C.cacheKey === M) {
        N = C, ++N.usedTimes;
        break;
      }
    }
    return N === void 0 && (N = new V6(r, M, E, a), h.push(N)), N;
  }
  function S(E) {
    if (--E.usedTimes === 0) {
      const M = h.indexOf(E);
      h[M] = h[h.length - 1], h.pop(), E.destroy();
    }
  }
  function w(E) {
    u.remove(E);
  }
  function A() {
    u.dispose();
  }
  return {
    getParameters: y,
    getProgramCacheKey: g,
    getUniforms: b,
    acquireProgram: T,
    releaseProgram: S,
    releaseShaderCache: w,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: h,
    dispose: A
  };
}
function X6() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(o) {
    return r.has(o);
  }
  function i(o) {
    let l = r.get(o);
    return l === void 0 && (l = {}, r.set(o, l)), l;
  }
  function n(o) {
    r.delete(o);
  }
  function s(o, l, u) {
    r.get(o)[l] = u;
  }
  function a() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: i,
    remove: n,
    update: s,
    dispose: a
  };
}
function $6(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
}
function hw(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
}
function dw() {
  const r = [];
  let e = 0;
  const i = [], n = [], s = [];
  function a() {
    e = 0, i.length = 0, n.length = 0, s.length = 0;
  }
  function o(d, p, f, m, v, y) {
    let g = r[e];
    return g === void 0 ? (g = {
      id: d.id,
      object: d,
      geometry: p,
      material: f,
      groupOrder: m,
      renderOrder: d.renderOrder,
      z: v,
      group: y
    }, r[e] = g) : (g.id = d.id, g.object = d, g.geometry = p, g.material = f, g.groupOrder = m, g.renderOrder = d.renderOrder, g.z = v, g.group = y), e++, g;
  }
  function l(d, p, f, m, v, y) {
    const g = o(d, p, f, m, v, y);
    f.transmission > 0 ? n.push(g) : f.transparent === !0 ? s.push(g) : i.push(g);
  }
  function u(d, p, f, m, v, y) {
    const g = o(d, p, f, m, v, y);
    f.transmission > 0 ? n.unshift(g) : f.transparent === !0 ? s.unshift(g) : i.unshift(g);
  }
  function c(d, p) {
    i.length > 1 && i.sort(d || $6), n.length > 1 && n.sort(p || hw), s.length > 1 && s.sort(p || hw);
  }
  function h() {
    for (let d = e, p = r.length; d < p; d++) {
      const f = r[d];
      if (f.id === null) break;
      f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
    }
  }
  return {
    opaque: i,
    transmissive: n,
    transparent: s,
    init: a,
    push: l,
    unshift: u,
    finish: h,
    sort: c
  };
}
function Y6() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(n, s) {
    const a = r.get(n);
    let o;
    return a === void 0 ? (o = new dw(), r.set(n, [o])) : s >= a.length ? (o = new dw(), a.push(o)) : o = a[s], o;
  }
  function i() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: i
  };
}
function K6() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let i;
      switch (e.type) {
        case "DirectionalLight":
          i = {
            direction: new q(),
            color: new kt()
          };
          break;
        case "SpotLight":
          i = {
            position: new q(),
            direction: new q(),
            color: new kt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          i = {
            position: new q(),
            color: new kt(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          i = {
            direction: new q(),
            skyColor: new kt(),
            groundColor: new kt()
          };
          break;
        case "RectAreaLight":
          i = {
            color: new kt(),
            position: new q(),
            halfWidth: new q(),
            halfHeight: new q()
          };
          break;
      }
      return r[e.id] = i, i;
    }
  };
}
function Z6() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let i;
      switch (e.type) {
        case "DirectionalLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ue()
          };
          break;
        case "SpotLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ue()
          };
          break;
        case "PointLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ue(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return r[e.id] = i, i;
    }
  };
}
let Q6 = 0;
function J6(r, e) {
  return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0);
}
function ej(r) {
  const e = new K6(), i = Z6(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let c = 0; c < 9; c++) n.probe.push(new q());
  const s = new q(), a = new ui(), o = new ui();
  function l(c) {
    let h = 0, d = 0, p = 0;
    for (let E = 0; E < 9; E++) n.probe[E].set(0, 0, 0);
    let f = 0, m = 0, v = 0, y = 0, g = 0, _ = 0, x = 0, b = 0, T = 0, S = 0, w = 0;
    c.sort(J6);
    for (let E = 0, M = c.length; E < M; E++) {
      const N = c[E], k = N.color, U = N.intensity, C = N.distance, O = N.shadow && N.shadow.map ? N.shadow.map.texture : null;
      if (N.isAmbientLight)
        h += k.r * U, d += k.g * U, p += k.b * U;
      else if (N.isLightProbe) {
        for (let D = 0; D < 9; D++)
          n.probe[D].addScaledVector(N.sh.coefficients[D], U);
        w++;
      } else if (N.isDirectionalLight) {
        const D = e.get(N);
        if (D.color.copy(N.color).multiplyScalar(N.intensity), N.castShadow) {
          const H = N.shadow, j = i.get(N);
          j.shadowIntensity = H.intensity, j.shadowBias = H.bias, j.shadowNormalBias = H.normalBias, j.shadowRadius = H.radius, j.shadowMapSize = H.mapSize, n.directionalShadow[f] = j, n.directionalShadowMap[f] = O, n.directionalShadowMatrix[f] = N.shadow.matrix, _++;
        }
        n.directional[f] = D, f++;
      } else if (N.isSpotLight) {
        const D = e.get(N);
        D.position.setFromMatrixPosition(N.matrixWorld), D.color.copy(k).multiplyScalar(U), D.distance = C, D.coneCos = Math.cos(N.angle), D.penumbraCos = Math.cos(N.angle * (1 - N.penumbra)), D.decay = N.decay, n.spot[v] = D;
        const H = N.shadow;
        if (N.map && (n.spotLightMap[T] = N.map, T++, H.updateMatrices(N), N.castShadow && S++), n.spotLightMatrix[v] = H.matrix, N.castShadow) {
          const j = i.get(N);
          j.shadowIntensity = H.intensity, j.shadowBias = H.bias, j.shadowNormalBias = H.normalBias, j.shadowRadius = H.radius, j.shadowMapSize = H.mapSize, n.spotShadow[v] = j, n.spotShadowMap[v] = O, b++;
        }
        v++;
      } else if (N.isRectAreaLight) {
        const D = e.get(N);
        D.color.copy(k).multiplyScalar(U), D.halfWidth.set(N.width * 0.5, 0, 0), D.halfHeight.set(0, N.height * 0.5, 0), n.rectArea[y] = D, y++;
      } else if (N.isPointLight) {
        const D = e.get(N);
        if (D.color.copy(N.color).multiplyScalar(N.intensity), D.distance = N.distance, D.decay = N.decay, N.castShadow) {
          const H = N.shadow, j = i.get(N);
          j.shadowIntensity = H.intensity, j.shadowBias = H.bias, j.shadowNormalBias = H.normalBias, j.shadowRadius = H.radius, j.shadowMapSize = H.mapSize, j.shadowCameraNear = H.camera.near, j.shadowCameraFar = H.camera.far, n.pointShadow[m] = j, n.pointShadowMap[m] = O, n.pointShadowMatrix[m] = N.shadow.matrix, x++;
        }
        n.point[m] = D, m++;
      } else if (N.isHemisphereLight) {
        const D = e.get(N);
        D.skyColor.copy(N.color).multiplyScalar(U), D.groundColor.copy(N.groundColor).multiplyScalar(U), n.hemi[g] = D, g++;
      }
    }
    y > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = je.LTC_FLOAT_1, n.rectAreaLTC2 = je.LTC_FLOAT_2) : (n.rectAreaLTC1 = je.LTC_HALF_1, n.rectAreaLTC2 = je.LTC_HALF_2)), n.ambient[0] = h, n.ambient[1] = d, n.ambient[2] = p;
    const A = n.hash;
    (A.directionalLength !== f || A.pointLength !== m || A.spotLength !== v || A.rectAreaLength !== y || A.hemiLength !== g || A.numDirectionalShadows !== _ || A.numPointShadows !== x || A.numSpotShadows !== b || A.numSpotMaps !== T || A.numLightProbes !== w) && (n.directional.length = f, n.spot.length = v, n.rectArea.length = y, n.point.length = m, n.hemi.length = g, n.directionalShadow.length = _, n.directionalShadowMap.length = _, n.pointShadow.length = x, n.pointShadowMap.length = x, n.spotShadow.length = b, n.spotShadowMap.length = b, n.directionalShadowMatrix.length = _, n.pointShadowMatrix.length = x, n.spotLightMatrix.length = b + T - S, n.spotLightMap.length = T, n.numSpotLightShadowsWithMaps = S, n.numLightProbes = w, A.directionalLength = f, A.pointLength = m, A.spotLength = v, A.rectAreaLength = y, A.hemiLength = g, A.numDirectionalShadows = _, A.numPointShadows = x, A.numSpotShadows = b, A.numSpotMaps = T, A.numLightProbes = w, n.version = Q6++);
  }
  function u(c, h) {
    let d = 0, p = 0, f = 0, m = 0, v = 0;
    const y = h.matrixWorldInverse;
    for (let g = 0, _ = c.length; g < _; g++) {
      const x = c[g];
      if (x.isDirectionalLight) {
        const b = n.directional[d];
        b.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(y), d++;
      } else if (x.isSpotLight) {
        const b = n.spot[f];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(y), b.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(y), f++;
      } else if (x.isRectAreaLight) {
        const b = n.rectArea[m];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(y), o.identity(), a.copy(x.matrixWorld), a.premultiply(y), o.extractRotation(a), b.halfWidth.set(x.width * 0.5, 0, 0), b.halfHeight.set(0, x.height * 0.5, 0), b.halfWidth.applyMatrix4(o), b.halfHeight.applyMatrix4(o), m++;
      } else if (x.isPointLight) {
        const b = n.point[p];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(y), p++;
      } else if (x.isHemisphereLight) {
        const b = n.hemi[v];
        b.direction.setFromMatrixPosition(x.matrixWorld), b.direction.transformDirection(y), v++;
      }
    }
  }
  return {
    setup: l,
    setupView: u,
    state: n
  };
}
function pw(r) {
  const e = new ej(r), i = [], n = [];
  function s(h) {
    c.camera = h, i.length = 0, n.length = 0;
  }
  function a(h) {
    i.push(h);
  }
  function o(h) {
    n.push(h);
  }
  function l() {
    e.setup(i);
  }
  function u(h) {
    e.setupView(i, h);
  }
  const c = {
    lightsArray: i,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: s,
    state: c,
    setupLights: l,
    setupLightsView: u,
    pushLight: a,
    pushShadow: o
  };
}
function tj(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function i(s, a = 0) {
    const o = e.get(s);
    let l;
    return o === void 0 ? (l = new pw(r), e.set(s, [l])) : a >= o.length ? (l = new pw(r), o.push(l)) : l = o[a], l;
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: n
  };
}
class ij extends Nl {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.depthPacking = FF, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class rj extends Nl {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const nj = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, sj = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function aj(r, e, i) {
  let n = new P_();
  const s = new Ue(), a = new Ue(), o = new Fi(), l = new ij({ depthPacking: BF }), u = new rj(), c = {}, h = i.maxTextureSize, d = { [mo]: Ar, [Ar]: mo, [Qs]: Qs }, p = new xs({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Ue() },
      radius: { value: 4 }
    },
    vertexShader: nj,
    fragmentShader: sj
  }), f = p.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new cn();
  m.setAttribute(
    "position",
    new _n(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const v = new Ur(m, p), y = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PC;
  let g = this.type;
  this.render = function(S, w, A) {
    if (y.enabled === !1 || y.autoUpdate === !1 && y.needsUpdate === !1 || S.length === 0) return;
    const E = r.getRenderTarget(), M = r.getActiveCubeFace(), N = r.getActiveMipmapLevel(), k = r.state;
    k.setBlending(ua), k.buffers.color.setClear(1, 1, 1, 1), k.buffers.depth.setTest(!0), k.setScissorTest(!1);
    const U = g !== Hs && this.type === Hs, C = g === Hs && this.type !== Hs;
    for (let O = 0, D = S.length; O < D; O++) {
      const H = S[O], j = H.shadow;
      if (j === void 0) {
        console.warn("THREE.WebGLShadowMap:", H, "has no shadow.");
        continue;
      }
      if (j.autoUpdate === !1 && j.needsUpdate === !1) continue;
      s.copy(j.mapSize);
      const K = j.getFrameExtents();
      if (s.multiply(K), a.copy(j.mapSize), (s.x > h || s.y > h) && (s.x > h && (a.x = Math.floor(h / K.x), s.x = a.x * K.x, j.mapSize.x = a.x), s.y > h && (a.y = Math.floor(h / K.y), s.y = a.y * K.y, j.mapSize.y = a.y)), j.map === null || U === !0 || C === !0) {
        const B = this.type !== Hs ? { minFilter: Kn, magFilter: Kn } : {};
        j.map !== null && j.map.dispose(), j.map = new go(s.x, s.y, B), j.map.texture.name = H.name + ".shadowMap", j.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(j.map), r.clear();
      const L = j.getViewportCount();
      for (let B = 0; B < L; B++) {
        const Q = j.getViewport(B);
        o.set(
          a.x * Q.x,
          a.y * Q.y,
          a.x * Q.z,
          a.y * Q.w
        ), k.viewport(o), j.updateMatrices(H, B), n = j.getFrustum(), b(w, A, j.camera, H, this.type);
      }
      j.isPointLightShadow !== !0 && this.type === Hs && _(j, A), j.needsUpdate = !1;
    }
    g = this.type, y.needsUpdate = !1, r.setRenderTarget(E, M, N);
  };
  function _(S, w) {
    const A = e.update(v);
    p.defines.VSM_SAMPLES !== S.blurSamples && (p.defines.VSM_SAMPLES = S.blurSamples, f.defines.VSM_SAMPLES = S.blurSamples, p.needsUpdate = !0, f.needsUpdate = !0), S.mapPass === null && (S.mapPass = new go(s.x, s.y)), p.uniforms.shadow_pass.value = S.map.texture, p.uniforms.resolution.value = S.mapSize, p.uniforms.radius.value = S.radius, r.setRenderTarget(S.mapPass), r.clear(), r.renderBufferDirect(w, null, A, p, v, null), f.uniforms.shadow_pass.value = S.mapPass.texture, f.uniforms.resolution.value = S.mapSize, f.uniforms.radius.value = S.radius, r.setRenderTarget(S.map), r.clear(), r.renderBufferDirect(w, null, A, f, v, null);
  }
  function x(S, w, A, E) {
    let M = null;
    const N = A.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
    if (N !== void 0)
      M = N;
    else if (M = A.isPointLight === !0 ? u : l, r.localClippingEnabled && w.clipShadows === !0 && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
      const k = M.uuid, U = w.uuid;
      let C = c[k];
      C === void 0 && (C = {}, c[k] = C);
      let O = C[U];
      O === void 0 && (O = M.clone(), C[U] = O, w.addEventListener("dispose", T)), M = O;
    }
    if (M.visible = w.visible, M.wireframe = w.wireframe, E === Hs ? M.side = w.shadowSide !== null ? w.shadowSide : w.side : M.side = w.shadowSide !== null ? w.shadowSide : d[w.side], M.alphaMap = w.alphaMap, M.alphaTest = w.alphaTest, M.map = w.map, M.clipShadows = w.clipShadows, M.clippingPlanes = w.clippingPlanes, M.clipIntersection = w.clipIntersection, M.displacementMap = w.displacementMap, M.displacementScale = w.displacementScale, M.displacementBias = w.displacementBias, M.wireframeLinewidth = w.wireframeLinewidth, M.linewidth = w.linewidth, A.isPointLight === !0 && M.isMeshDistanceMaterial === !0) {
      const k = r.properties.get(M);
      k.light = A;
    }
    return M;
  }
  function b(S, w, A, E, M) {
    if (S.visible === !1) return;
    if (S.layers.test(w.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && M === Hs) && (!S.frustumCulled || n.intersectsObject(S))) {
      S.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse, S.matrixWorld);
      const k = e.update(S), U = S.material;
      if (Array.isArray(U)) {
        const C = k.groups;
        for (let O = 0, D = C.length; O < D; O++) {
          const H = C[O], j = U[H.materialIndex];
          if (j && j.visible) {
            const K = x(S, j, E, M);
            S.onBeforeShadow(r, S, w, A, k, K, H), r.renderBufferDirect(A, null, k, K, S, H), S.onAfterShadow(r, S, w, A, k, K, H);
          }
        }
      } else if (U.visible) {
        const C = x(S, U, E, M);
        S.onBeforeShadow(r, S, w, A, k, C, null), r.renderBufferDirect(A, null, k, C, S, null), S.onAfterShadow(r, S, w, A, k, C, null);
      }
    }
    const N = S.children;
    for (let k = 0, U = N.length; k < U; k++)
      b(N[k], w, A, E, M);
  }
  function T(S) {
    S.target.removeEventListener("dispose", T);
    for (const w in c) {
      const A = c[w], E = S.target.uuid;
      E in A && (A[E].dispose(), delete A[E]);
    }
  }
}
const oj = {
  [$0]: Y0,
  [K0]: J0,
  [Z0]: eb,
  [hc]: Q0,
  [Y0]: $0,
  [J0]: K0,
  [eb]: Z0,
  [Q0]: hc
};
function lj(r, e) {
  function i() {
    let ee = !1;
    const Le = new Fi();
    let de = null;
    const Se = new Fi(0, 0, 0, 0);
    return {
      setMask: function(ze) {
        de !== ze && !ee && (r.colorMask(ze, ze, ze, ze), de = ze);
      },
      setLocked: function(ze) {
        ee = ze;
      },
      setClear: function(ze, ke, At, ri, _i) {
        _i === !0 && (ze *= ri, ke *= ri, At *= ri), Le.set(ze, ke, At, ri), Se.equals(Le) === !1 && (r.clearColor(ze, ke, At, ri), Se.copy(Le));
      },
      reset: function() {
        ee = !1, de = null, Se.set(-1, 0, 0, 0);
      }
    };
  }
  function n() {
    let ee = !1, Le = !1, de = null, Se = null, ze = null;
    return {
      setReversed: function(ke) {
        if (Le !== ke) {
          const At = e.get("EXT_clip_control");
          Le ? At.clipControlEXT(At.LOWER_LEFT_EXT, At.ZERO_TO_ONE_EXT) : At.clipControlEXT(At.LOWER_LEFT_EXT, At.NEGATIVE_ONE_TO_ONE_EXT);
          const ri = ze;
          ze = null, this.setClear(ri);
        }
        Le = ke;
      },
      getReversed: function() {
        return Le;
      },
      setTest: function(ke) {
        ke ? ue(r.DEPTH_TEST) : ge(r.DEPTH_TEST);
      },
      setMask: function(ke) {
        de !== ke && !ee && (r.depthMask(ke), de = ke);
      },
      setFunc: function(ke) {
        if (Le && (ke = oj[ke]), Se !== ke) {
          switch (ke) {
            case $0:
              r.depthFunc(r.NEVER);
              break;
            case Y0:
              r.depthFunc(r.ALWAYS);
              break;
            case K0:
              r.depthFunc(r.LESS);
              break;
            case hc:
              r.depthFunc(r.LEQUAL);
              break;
            case Z0:
              r.depthFunc(r.EQUAL);
              break;
            case Q0:
              r.depthFunc(r.GEQUAL);
              break;
            case J0:
              r.depthFunc(r.GREATER);
              break;
            case eb:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          Se = ke;
        }
      },
      setLocked: function(ke) {
        ee = ke;
      },
      setClear: function(ke) {
        ze !== ke && (Le && (ke = 1 - ke), r.clearDepth(ke), ze = ke);
      },
      reset: function() {
        ee = !1, de = null, Se = null, ze = null, Le = !1;
      }
    };
  }
  function s() {
    let ee = !1, Le = null, de = null, Se = null, ze = null, ke = null, At = null, ri = null, _i = null;
    return {
      setTest: function(Ft) {
        ee || (Ft ? ue(r.STENCIL_TEST) : ge(r.STENCIL_TEST));
      },
      setMask: function(Ft) {
        Le !== Ft && !ee && (r.stencilMask(Ft), Le = Ft);
      },
      setFunc: function(Ft, vr, $r) {
        (de !== Ft || Se !== vr || ze !== $r) && (r.stencilFunc(Ft, vr, $r), de = Ft, Se = vr, ze = $r);
      },
      setOp: function(Ft, vr, $r) {
        (ke !== Ft || At !== vr || ri !== $r) && (r.stencilOp(Ft, vr, $r), ke = Ft, At = vr, ri = $r);
      },
      setLocked: function(Ft) {
        ee = Ft;
      },
      setClear: function(Ft) {
        _i !== Ft && (r.clearStencil(Ft), _i = Ft);
      },
      reset: function() {
        ee = !1, Le = null, de = null, Se = null, ze = null, ke = null, At = null, ri = null, _i = null;
      }
    };
  }
  const a = new i(), o = new n(), l = new s(), u = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
  let h = {}, d = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, v = !1, y = null, g = null, _ = null, x = null, b = null, T = null, S = null, w = new kt(0, 0, 0), A = 0, E = !1, M = null, N = null, k = null, U = null, C = null;
  const O = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let D = !1, H = 0;
  const j = r.getParameter(r.VERSION);
  j.indexOf("WebGL") !== -1 ? (H = parseFloat(/^WebGL (\d)/.exec(j)[1]), D = H >= 1) : j.indexOf("OpenGL ES") !== -1 && (H = parseFloat(/^OpenGL ES (\d)/.exec(j)[1]), D = H >= 2);
  let K = null, L = {};
  const B = r.getParameter(r.SCISSOR_BOX), Q = r.getParameter(r.VIEWPORT), W = new Fi().fromArray(B), z = new Fi().fromArray(Q);
  function X(ee, Le, de, Se) {
    const ze = new Uint8Array(4), ke = r.createTexture();
    r.bindTexture(ee, ke), r.texParameteri(ee, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(ee, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let At = 0; At < de; At++)
      ee === r.TEXTURE_3D || ee === r.TEXTURE_2D_ARRAY ? r.texImage3D(Le, 0, r.RGBA, 1, 1, Se, 0, r.RGBA, r.UNSIGNED_BYTE, ze) : r.texImage2D(Le + At, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, ze);
    return ke;
  }
  const ae = {};
  ae[r.TEXTURE_2D] = X(r.TEXTURE_2D, r.TEXTURE_2D, 1), ae[r.TEXTURE_CUBE_MAP] = X(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ae[r.TEXTURE_2D_ARRAY] = X(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), ae[r.TEXTURE_3D] = X(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), a.setClear(0, 0, 0, 1), o.setClear(1), l.setClear(0), ue(r.DEPTH_TEST), o.setFunc(hc), Xe(!1), yt(y1), ue(r.CULL_FACE), Y(ua);
  function ue(ee) {
    h[ee] !== !0 && (r.enable(ee), h[ee] = !0);
  }
  function ge(ee) {
    h[ee] !== !1 && (r.disable(ee), h[ee] = !1);
  }
  function we(ee, Le) {
    return d[ee] !== Le ? (r.bindFramebuffer(ee, Le), d[ee] = Le, ee === r.DRAW_FRAMEBUFFER && (d[r.FRAMEBUFFER] = Le), ee === r.FRAMEBUFFER && (d[r.DRAW_FRAMEBUFFER] = Le), !0) : !1;
  }
  function Ne(ee, Le) {
    let de = f, Se = !1;
    if (ee) {
      de = p.get(Le), de === void 0 && (de = [], p.set(Le, de));
      const ze = ee.textures;
      if (de.length !== ze.length || de[0] !== r.COLOR_ATTACHMENT0) {
        for (let ke = 0, At = ze.length; ke < At; ke++)
          de[ke] = r.COLOR_ATTACHMENT0 + ke;
        de.length = ze.length, Se = !0;
      }
    } else
      de[0] !== r.BACK && (de[0] = r.BACK, Se = !0);
    Se && r.drawBuffers(de);
  }
  function lt(ee) {
    return m !== ee ? (r.useProgram(ee), m = ee, !0) : !1;
  }
  const be = {
    [Xo]: r.FUNC_ADD,
    [hF]: r.FUNC_SUBTRACT,
    [dF]: r.FUNC_REVERSE_SUBTRACT
  };
  be[pF] = r.MIN, be[fF] = r.MAX;
  const bt = {
    [mF]: r.ZERO,
    [gF]: r.ONE,
    [yF]: r.SRC_COLOR,
    [q0]: r.SRC_ALPHA,
    [SF]: r.SRC_ALPHA_SATURATE,
    [_F]: r.DST_COLOR,
    [bF]: r.DST_ALPHA,
    [vF]: r.ONE_MINUS_SRC_COLOR,
    [X0]: r.ONE_MINUS_SRC_ALPHA,
    [TF]: r.ONE_MINUS_DST_COLOR,
    [xF]: r.ONE_MINUS_DST_ALPHA,
    [wF]: r.CONSTANT_COLOR,
    [EF]: r.ONE_MINUS_CONSTANT_COLOR,
    [MF]: r.CONSTANT_ALPHA,
    [AF]: r.ONE_MINUS_CONSTANT_ALPHA
  };
  function Y(ee, Le, de, Se, ze, ke, At, ri, _i, Ft) {
    if (ee === ua) {
      v === !0 && (ge(r.BLEND), v = !1);
      return;
    }
    if (v === !1 && (ue(r.BLEND), v = !0), ee !== cF) {
      if (ee !== y || Ft !== E) {
        if ((g !== Xo || b !== Xo) && (r.blendEquation(r.FUNC_ADD), g = Xo, b = Xo), Ft)
          switch (ee) {
            case Gu:
              r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case v1:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case b1:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case x1:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ee);
              break;
          }
        else
          switch (ee) {
            case Gu:
              r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case v1:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case b1:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case x1:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ee);
              break;
          }
        _ = null, x = null, T = null, S = null, w.set(0, 0, 0), A = 0, y = ee, E = Ft;
      }
      return;
    }
    ze = ze || Le, ke = ke || de, At = At || Se, (Le !== g || ze !== b) && (r.blendEquationSeparate(be[Le], be[ze]), g = Le, b = ze), (de !== _ || Se !== x || ke !== T || At !== S) && (r.blendFuncSeparate(bt[de], bt[Se], bt[ke], bt[At]), _ = de, x = Se, T = ke, S = At), (ri.equals(w) === !1 || _i !== A) && (r.blendColor(ri.r, ri.g, ri.b, _i), w.copy(ri), A = _i), y = ee, E = !1;
  }
  function Gt(ee, Le) {
    ee.side === Qs ? ge(r.CULL_FACE) : ue(r.CULL_FACE);
    let de = ee.side === Ar;
    Le && (de = !de), Xe(de), ee.blending === Gu && ee.transparent === !1 ? Y(ua) : Y(ee.blending, ee.blendEquation, ee.blendSrc, ee.blendDst, ee.blendEquationAlpha, ee.blendSrcAlpha, ee.blendDstAlpha, ee.blendColor, ee.blendAlpha, ee.premultipliedAlpha), o.setFunc(ee.depthFunc), o.setTest(ee.depthTest), o.setMask(ee.depthWrite), a.setMask(ee.colorWrite);
    const Se = ee.stencilWrite;
    l.setTest(Se), Se && (l.setMask(ee.stencilWriteMask), l.setFunc(ee.stencilFunc, ee.stencilRef, ee.stencilFuncMask), l.setOp(ee.stencilFail, ee.stencilZFail, ee.stencilZPass)), Nt(ee.polygonOffset, ee.polygonOffsetFactor, ee.polygonOffsetUnits), ee.alphaToCoverage === !0 ? ue(r.SAMPLE_ALPHA_TO_COVERAGE) : ge(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Xe(ee) {
    M !== ee && (ee ? r.frontFace(r.CW) : r.frontFace(r.CCW), M = ee);
  }
  function yt(ee) {
    ee !== oF ? (ue(r.CULL_FACE), ee !== N && (ee === y1 ? r.cullFace(r.BACK) : ee === lF ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : ge(r.CULL_FACE), N = ee;
  }
  function rt(ee) {
    ee !== k && (D && r.lineWidth(ee), k = ee);
  }
  function Nt(ee, Le, de) {
    ee ? (ue(r.POLYGON_OFFSET_FILL), (U !== Le || C !== de) && (r.polygonOffset(Le, de), U = Le, C = de)) : ge(r.POLYGON_OFFSET_FILL);
  }
  function nt(ee) {
    ee ? ue(r.SCISSOR_TEST) : ge(r.SCISSOR_TEST);
  }
  function F(ee) {
    ee === void 0 && (ee = r.TEXTURE0 + O - 1), K !== ee && (r.activeTexture(ee), K = ee);
  }
  function P(ee, Le, de) {
    de === void 0 && (K === null ? de = r.TEXTURE0 + O - 1 : de = K);
    let Se = L[de];
    Se === void 0 && (Se = { type: void 0, texture: void 0 }, L[de] = Se), (Se.type !== ee || Se.texture !== Le) && (K !== de && (r.activeTexture(de), K = de), r.bindTexture(ee, Le || ae[ee]), Se.type = ee, Se.texture = Le);
  }
  function le() {
    const ee = L[K];
    ee !== void 0 && ee.type !== void 0 && (r.bindTexture(ee.type, null), ee.type = void 0, ee.texture = void 0);
  }
  function Te() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Ae() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function xe() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Je() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Be() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function qe() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Pt() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Ie() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function $e() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function ut() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function ft(ee) {
    W.equals(ee) === !1 && (r.scissor(ee.x, ee.y, ee.z, ee.w), W.copy(ee));
  }
  function Ye(ee) {
    z.equals(ee) === !1 && (r.viewport(ee.x, ee.y, ee.z, ee.w), z.copy(ee));
  }
  function Ot(ee, Le) {
    let de = c.get(Le);
    de === void 0 && (de = /* @__PURE__ */ new WeakMap(), c.set(Le, de));
    let Se = de.get(ee);
    Se === void 0 && (Se = r.getUniformBlockIndex(Le, ee.name), de.set(ee, Se));
  }
  function xt(ee, Le) {
    const de = c.get(Le).get(ee);
    u.get(Le) !== de && (r.uniformBlockBinding(Le, de, ee.__bindingPointIndex), u.set(Le, de));
  }
  function Bt() {
    r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), o.setReversed(!1), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), h = {}, K = null, L = {}, d = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, v = !1, y = null, g = null, _ = null, x = null, b = null, T = null, S = null, w = new kt(0, 0, 0), A = 0, E = !1, M = null, N = null, k = null, U = null, C = null, W.set(0, 0, r.canvas.width, r.canvas.height), z.set(0, 0, r.canvas.width, r.canvas.height), a.reset(), o.reset(), l.reset();
  }
  return {
    buffers: {
      color: a,
      depth: o,
      stencil: l
    },
    enable: ue,
    disable: ge,
    bindFramebuffer: we,
    drawBuffers: Ne,
    useProgram: lt,
    setBlending: Y,
    setMaterial: Gt,
    setFlipSided: Xe,
    setCullFace: yt,
    setLineWidth: rt,
    setPolygonOffset: Nt,
    setScissorTest: nt,
    activeTexture: F,
    bindTexture: P,
    unbindTexture: le,
    compressedTexImage2D: Te,
    compressedTexImage3D: Ae,
    texImage2D: $e,
    texImage3D: ut,
    updateUBOMapping: Ot,
    uniformBlockBinding: xt,
    texStorage2D: Pt,
    texStorage3D: Ie,
    texSubImage2D: xe,
    texSubImage3D: Je,
    compressedTexSubImage2D: Be,
    compressedTexSubImage3D: qe,
    scissor: ft,
    viewport: Ye,
    reset: Bt
  };
}
function fw(r, e, i, n) {
  const s = uj(n);
  switch (i) {
    case UC:
      return r * e;
    case FC:
      return r * e;
    case BC:
      return r * e * 2;
    case zC:
      return r * e / s.components * s.byteLength;
    case E_:
      return r * e / s.components * s.byteLength;
    case jC:
      return r * e * 2 / s.components * s.byteLength;
    case M_:
      return r * e * 2 / s.components * s.byteLength;
    case kC:
      return r * e * 3 / s.components * s.byteLength;
    case Xn:
      return r * e * 4 / s.components * s.byteLength;
    case A_:
      return r * e * 4 / s.components * s.byteLength;
    case Gf:
    case Hf:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Wf:
    case qf:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case ab:
    case lb:
      return Math.max(r, 16) * Math.max(e, 8) / 4;
    case sb:
    case ob:
      return Math.max(r, 8) * Math.max(e, 8) / 2;
    case ub:
    case cb:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case hb:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case db:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case pb:
      return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case fb:
      return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case mb:
      return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case gb:
      return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case yb:
      return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case vb:
      return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case bb:
      return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case xb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case _b:
      return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Tb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Sb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case wb:
      return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Eb:
      return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Xf:
    case Mb:
    case Ab:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
    case VC:
    case Cb:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
    case Rb:
    case Nb:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${i} format.`
  );
}
function uj(r) {
  switch (r) {
    case xa:
    case OC:
      return { byteLength: 1, components: 1 };
    case ud:
    case DC:
    case Dc:
      return { byteLength: 2, components: 1 };
    case S_:
    case w_:
      return { byteLength: 2, components: 4 };
    case xl:
    case T_:
    case na:
      return { byteLength: 4, components: 1 };
    case LC:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${r}.`);
}
function cj(r, e, i, n, s, a, o) {
  const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, u = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), c = new Ue(), h = /* @__PURE__ */ new WeakMap();
  let d;
  const p = /* @__PURE__ */ new WeakMap();
  let f = !1;
  try {
    f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function m(F, P) {
    return f ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(F, P)
    ) : hd("canvas");
  }
  function v(F, P, le) {
    let Te = 1;
    const Ae = nt(F);
    if ((Ae.width > le || Ae.height > le) && (Te = le / Math.max(Ae.width, Ae.height)), Te < 1)
      if (typeof HTMLImageElement < "u" && F instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && F instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && F instanceof ImageBitmap || typeof VideoFrame < "u" && F instanceof VideoFrame) {
        const xe = Math.floor(Te * Ae.width), Je = Math.floor(Te * Ae.height);
        d === void 0 && (d = m(xe, Je));
        const Be = P ? m(xe, Je) : d;
        return Be.width = xe, Be.height = Je, Be.getContext("2d").drawImage(F, 0, 0, xe, Je), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Ae.width + "x" + Ae.height + ") to (" + xe + "x" + Je + ")."), Be;
      } else
        return "data" in F && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Ae.width + "x" + Ae.height + ")."), F;
    return F;
  }
  function y(F) {
    return F.generateMipmaps;
  }
  function g(F) {
    r.generateMipmap(F);
  }
  function _(F) {
    return F.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : F.isWebGL3DRenderTarget ? r.TEXTURE_3D : F.isWebGLArrayRenderTarget || F.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D;
  }
  function x(F, P, le, Te, Ae = !1) {
    if (F !== null) {
      if (r[F] !== void 0) return r[F];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + F + "'");
    }
    let xe = P;
    if (P === r.RED && (le === r.FLOAT && (xe = r.R32F), le === r.HALF_FLOAT && (xe = r.R16F), le === r.UNSIGNED_BYTE && (xe = r.R8)), P === r.RED_INTEGER && (le === r.UNSIGNED_BYTE && (xe = r.R8UI), le === r.UNSIGNED_SHORT && (xe = r.R16UI), le === r.UNSIGNED_INT && (xe = r.R32UI), le === r.BYTE && (xe = r.R8I), le === r.SHORT && (xe = r.R16I), le === r.INT && (xe = r.R32I)), P === r.RG && (le === r.FLOAT && (xe = r.RG32F), le === r.HALF_FLOAT && (xe = r.RG16F), le === r.UNSIGNED_BYTE && (xe = r.RG8)), P === r.RG_INTEGER && (le === r.UNSIGNED_BYTE && (xe = r.RG8UI), le === r.UNSIGNED_SHORT && (xe = r.RG16UI), le === r.UNSIGNED_INT && (xe = r.RG32UI), le === r.BYTE && (xe = r.RG8I), le === r.SHORT && (xe = r.RG16I), le === r.INT && (xe = r.RG32I)), P === r.RGB_INTEGER && (le === r.UNSIGNED_BYTE && (xe = r.RGB8UI), le === r.UNSIGNED_SHORT && (xe = r.RGB16UI), le === r.UNSIGNED_INT && (xe = r.RGB32UI), le === r.BYTE && (xe = r.RGB8I), le === r.SHORT && (xe = r.RGB16I), le === r.INT && (xe = r.RGB32I)), P === r.RGBA_INTEGER && (le === r.UNSIGNED_BYTE && (xe = r.RGBA8UI), le === r.UNSIGNED_SHORT && (xe = r.RGBA16UI), le === r.UNSIGNED_INT && (xe = r.RGBA32UI), le === r.BYTE && (xe = r.RGBA8I), le === r.SHORT && (xe = r.RGBA16I), le === r.INT && (xe = r.RGBA32I)), P === r.RGB && le === r.UNSIGNED_INT_5_9_9_9_REV && (xe = r.RGB9_E5), P === r.RGBA) {
      const Je = Ae ? vg : Vt.getTransfer(Te);
      le === r.FLOAT && (xe = r.RGBA32F), le === r.HALF_FLOAT && (xe = r.RGBA16F), le === r.UNSIGNED_BYTE && (xe = Je === Jt ? r.SRGB8_ALPHA8 : r.RGBA8), le === r.UNSIGNED_SHORT_4_4_4_4 && (xe = r.RGBA4), le === r.UNSIGNED_SHORT_5_5_5_1 && (xe = r.RGB5_A1);
    }
    return (xe === r.R16F || xe === r.R32F || xe === r.RG16F || xe === r.RG32F || xe === r.RGBA16F || xe === r.RGBA32F) && e.get("EXT_color_buffer_float"), xe;
  }
  function b(F, P) {
    let le;
    return F ? P === null || P === xl || P === fc ? le = r.DEPTH24_STENCIL8 : P === na ? le = r.DEPTH32F_STENCIL8 : P === ud && (le = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : P === null || P === xl || P === fc ? le = r.DEPTH_COMPONENT24 : P === na ? le = r.DEPTH_COMPONENT32F : P === ud && (le = r.DEPTH_COMPONENT16), le;
  }
  function T(F, P) {
    return y(F) === !0 || F.isFramebufferTexture && F.minFilter !== Kn && F.minFilter !== ds ? Math.log2(Math.max(P.width, P.height)) + 1 : F.mipmaps !== void 0 && F.mipmaps.length > 0 ? F.mipmaps.length : F.isCompressedTexture && Array.isArray(F.image) ? P.mipmaps.length : 1;
  }
  function S(F) {
    const P = F.target;
    P.removeEventListener("dispose", S), A(P), P.isVideoTexture && h.delete(P);
  }
  function w(F) {
    const P = F.target;
    P.removeEventListener("dispose", w), M(P);
  }
  function A(F) {
    const P = n.get(F);
    if (P.__webglInit === void 0) return;
    const le = F.source, Te = p.get(le);
    if (Te) {
      const Ae = Te[P.__cacheKey];
      Ae.usedTimes--, Ae.usedTimes === 0 && E(F), Object.keys(Te).length === 0 && p.delete(le);
    }
    n.remove(F);
  }
  function E(F) {
    const P = n.get(F);
    r.deleteTexture(P.__webglTexture);
    const le = F.source, Te = p.get(le);
    delete Te[P.__cacheKey], o.memory.textures--;
  }
  function M(F) {
    const P = n.get(F);
    if (F.depthTexture && (F.depthTexture.dispose(), n.remove(F.depthTexture)), F.isWebGLCubeRenderTarget)
      for (let Te = 0; Te < 6; Te++) {
        if (Array.isArray(P.__webglFramebuffer[Te]))
          for (let Ae = 0; Ae < P.__webglFramebuffer[Te].length; Ae++) r.deleteFramebuffer(P.__webglFramebuffer[Te][Ae]);
        else
          r.deleteFramebuffer(P.__webglFramebuffer[Te]);
        P.__webglDepthbuffer && r.deleteRenderbuffer(P.__webglDepthbuffer[Te]);
      }
    else {
      if (Array.isArray(P.__webglFramebuffer))
        for (let Te = 0; Te < P.__webglFramebuffer.length; Te++) r.deleteFramebuffer(P.__webglFramebuffer[Te]);
      else
        r.deleteFramebuffer(P.__webglFramebuffer);
      if (P.__webglDepthbuffer && r.deleteRenderbuffer(P.__webglDepthbuffer), P.__webglMultisampledFramebuffer && r.deleteFramebuffer(P.__webglMultisampledFramebuffer), P.__webglColorRenderbuffer)
        for (let Te = 0; Te < P.__webglColorRenderbuffer.length; Te++)
          P.__webglColorRenderbuffer[Te] && r.deleteRenderbuffer(P.__webglColorRenderbuffer[Te]);
      P.__webglDepthRenderbuffer && r.deleteRenderbuffer(P.__webglDepthRenderbuffer);
    }
    const le = F.textures;
    for (let Te = 0, Ae = le.length; Te < Ae; Te++) {
      const xe = n.get(le[Te]);
      xe.__webglTexture && (r.deleteTexture(xe.__webglTexture), o.memory.textures--), n.remove(le[Te]);
    }
    n.remove(F);
  }
  let N = 0;
  function k() {
    N = 0;
  }
  function U() {
    const F = N;
    return F >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + F + " texture units while this GPU supports only " + s.maxTextures), N += 1, F;
  }
  function C(F) {
    const P = [];
    return P.push(F.wrapS), P.push(F.wrapT), P.push(F.wrapR || 0), P.push(F.magFilter), P.push(F.minFilter), P.push(F.anisotropy), P.push(F.internalFormat), P.push(F.format), P.push(F.type), P.push(F.generateMipmaps), P.push(F.premultiplyAlpha), P.push(F.flipY), P.push(F.unpackAlignment), P.push(F.colorSpace), P.join();
  }
  function O(F, P) {
    const le = n.get(F);
    if (F.isVideoTexture && rt(F), F.isRenderTargetTexture === !1 && F.version > 0 && le.__version !== F.version) {
      const Te = F.image;
      if (Te === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (Te.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        z(le, F, P);
        return;
      }
    }
    i.bindTexture(r.TEXTURE_2D, le.__webglTexture, r.TEXTURE0 + P);
  }
  function D(F, P) {
    const le = n.get(F);
    if (F.version > 0 && le.__version !== F.version) {
      z(le, F, P);
      return;
    }
    i.bindTexture(r.TEXTURE_2D_ARRAY, le.__webglTexture, r.TEXTURE0 + P);
  }
  function H(F, P) {
    const le = n.get(F);
    if (F.version > 0 && le.__version !== F.version) {
      z(le, F, P);
      return;
    }
    i.bindTexture(r.TEXTURE_3D, le.__webglTexture, r.TEXTURE0 + P);
  }
  function j(F, P) {
    const le = n.get(F);
    if (F.version > 0 && le.__version !== F.version) {
      X(le, F, P);
      return;
    }
    i.bindTexture(r.TEXTURE_CUBE_MAP, le.__webglTexture, r.TEXTURE0 + P);
  }
  const K = {
    [rb]: r.REPEAT,
    [il]: r.CLAMP_TO_EDGE,
    [nb]: r.MIRRORED_REPEAT
  }, L = {
    [Kn]: r.NEAREST,
    [kF]: r.NEAREST_MIPMAP_NEAREST,
    [cp]: r.NEAREST_MIPMAP_LINEAR,
    [ds]: r.LINEAR,
    [yy]: r.LINEAR_MIPMAP_NEAREST,
    [rl]: r.LINEAR_MIPMAP_LINEAR
  }, B = {
    [jF]: r.NEVER,
    [XF]: r.ALWAYS,
    [VF]: r.LESS,
    [HC]: r.LEQUAL,
    [GF]: r.EQUAL,
    [qF]: r.GEQUAL,
    [HF]: r.GREATER,
    [WF]: r.NOTEQUAL
  };
  function Q(F, P) {
    if (P.type === na && e.has("OES_texture_float_linear") === !1 && (P.magFilter === ds || P.magFilter === yy || P.magFilter === cp || P.magFilter === rl || P.minFilter === ds || P.minFilter === yy || P.minFilter === cp || P.minFilter === rl) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(F, r.TEXTURE_WRAP_S, K[P.wrapS]), r.texParameteri(F, r.TEXTURE_WRAP_T, K[P.wrapT]), (F === r.TEXTURE_3D || F === r.TEXTURE_2D_ARRAY) && r.texParameteri(F, r.TEXTURE_WRAP_R, K[P.wrapR]), r.texParameteri(F, r.TEXTURE_MAG_FILTER, L[P.magFilter]), r.texParameteri(F, r.TEXTURE_MIN_FILTER, L[P.minFilter]), P.compareFunction && (r.texParameteri(F, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(F, r.TEXTURE_COMPARE_FUNC, B[P.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (P.magFilter === Kn || P.minFilter !== cp && P.minFilter !== rl || P.type === na && e.has("OES_texture_float_linear") === !1) return;
      if (P.anisotropy > 1 || n.get(P).__currentAnisotropy) {
        const le = e.get("EXT_texture_filter_anisotropic");
        r.texParameterf(F, le.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(P.anisotropy, s.getMaxAnisotropy())), n.get(P).__currentAnisotropy = P.anisotropy;
      }
    }
  }
  function W(F, P) {
    let le = !1;
    F.__webglInit === void 0 && (F.__webglInit = !0, P.addEventListener("dispose", S));
    const Te = P.source;
    let Ae = p.get(Te);
    Ae === void 0 && (Ae = {}, p.set(Te, Ae));
    const xe = C(P);
    if (xe !== F.__cacheKey) {
      Ae[xe] === void 0 && (Ae[xe] = {
        texture: r.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, le = !0), Ae[xe].usedTimes++;
      const Je = Ae[F.__cacheKey];
      Je !== void 0 && (Ae[F.__cacheKey].usedTimes--, Je.usedTimes === 0 && E(P)), F.__cacheKey = xe, F.__webglTexture = Ae[xe].texture;
    }
    return le;
  }
  function z(F, P, le) {
    let Te = r.TEXTURE_2D;
    (P.isDataArrayTexture || P.isCompressedArrayTexture) && (Te = r.TEXTURE_2D_ARRAY), P.isData3DTexture && (Te = r.TEXTURE_3D);
    const Ae = W(F, P), xe = P.source;
    i.bindTexture(Te, F.__webglTexture, r.TEXTURE0 + le);
    const Je = n.get(xe);
    if (xe.version !== Je.__version || Ae === !0) {
      i.activeTexture(r.TEXTURE0 + le);
      const Be = Vt.getPrimaries(Vt.workingColorSpace), qe = P.colorSpace === Ja ? null : Vt.getPrimaries(P.colorSpace), Pt = P.colorSpace === Ja || Be === qe ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, P.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, P.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, P.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Pt);
      let Ie = v(P.image, !1, s.maxTextureSize);
      Ie = Nt(P, Ie);
      const $e = a.convert(P.format, P.colorSpace), ut = a.convert(P.type);
      let ft = x(P.internalFormat, $e, ut, P.colorSpace, P.isVideoTexture);
      Q(Te, P);
      let Ye;
      const Ot = P.mipmaps, xt = P.isVideoTexture !== !0, Bt = Je.__version === void 0 || Ae === !0, ee = xe.dataReady, Le = T(P, Ie);
      if (P.isDepthTexture)
        ft = b(P.format === mc, P.type), Bt && (xt ? i.texStorage2D(r.TEXTURE_2D, 1, ft, Ie.width, Ie.height) : i.texImage2D(r.TEXTURE_2D, 0, ft, Ie.width, Ie.height, 0, $e, ut, null));
      else if (P.isDataTexture)
        if (Ot.length > 0) {
          xt && Bt && i.texStorage2D(r.TEXTURE_2D, Le, ft, Ot[0].width, Ot[0].height);
          for (let de = 0, Se = Ot.length; de < Se; de++)
            Ye = Ot[de], xt ? ee && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, Ye.width, Ye.height, $e, ut, Ye.data) : i.texImage2D(r.TEXTURE_2D, de, ft, Ye.width, Ye.height, 0, $e, ut, Ye.data);
          P.generateMipmaps = !1;
        } else
          xt ? (Bt && i.texStorage2D(r.TEXTURE_2D, Le, ft, Ie.width, Ie.height), ee && i.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ie.width, Ie.height, $e, ut, Ie.data)) : i.texImage2D(r.TEXTURE_2D, 0, ft, Ie.width, Ie.height, 0, $e, ut, Ie.data);
      else if (P.isCompressedTexture)
        if (P.isCompressedArrayTexture) {
          xt && Bt && i.texStorage3D(r.TEXTURE_2D_ARRAY, Le, ft, Ot[0].width, Ot[0].height, Ie.depth);
          for (let de = 0, Se = Ot.length; de < Se; de++)
            if (Ye = Ot[de], P.format !== Xn)
              if ($e !== null)
                if (xt) {
                  if (ee)
                    if (P.layerUpdates.size > 0) {
                      const ze = fw(Ye.width, Ye.height, P.format, P.type);
                      for (const ke of P.layerUpdates) {
                        const At = Ye.data.subarray(
                          ke * ze / Ye.data.BYTES_PER_ELEMENT,
                          (ke + 1) * ze / Ye.data.BYTES_PER_ELEMENT
                        );
                        i.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, ke, Ye.width, Ye.height, 1, $e, At);
                      }
                      P.clearLayerUpdates();
                    } else
                      i.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, 0, Ye.width, Ye.height, Ie.depth, $e, Ye.data);
                } else
                  i.compressedTexImage3D(r.TEXTURE_2D_ARRAY, de, ft, Ye.width, Ye.height, Ie.depth, 0, Ye.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              xt ? ee && i.texSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, 0, Ye.width, Ye.height, Ie.depth, $e, ut, Ye.data) : i.texImage3D(r.TEXTURE_2D_ARRAY, de, ft, Ye.width, Ye.height, Ie.depth, 0, $e, ut, Ye.data);
        } else {
          xt && Bt && i.texStorage2D(r.TEXTURE_2D, Le, ft, Ot[0].width, Ot[0].height);
          for (let de = 0, Se = Ot.length; de < Se; de++)
            Ye = Ot[de], P.format !== Xn ? $e !== null ? xt ? ee && i.compressedTexSubImage2D(r.TEXTURE_2D, de, 0, 0, Ye.width, Ye.height, $e, Ye.data) : i.compressedTexImage2D(r.TEXTURE_2D, de, ft, Ye.width, Ye.height, 0, Ye.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : xt ? ee && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, Ye.width, Ye.height, $e, ut, Ye.data) : i.texImage2D(r.TEXTURE_2D, de, ft, Ye.width, Ye.height, 0, $e, ut, Ye.data);
        }
      else if (P.isDataArrayTexture)
        if (xt) {
          if (Bt && i.texStorage3D(r.TEXTURE_2D_ARRAY, Le, ft, Ie.width, Ie.height, Ie.depth), ee)
            if (P.layerUpdates.size > 0) {
              const de = fw(Ie.width, Ie.height, P.format, P.type);
              for (const Se of P.layerUpdates) {
                const ze = Ie.data.subarray(
                  Se * de / Ie.data.BYTES_PER_ELEMENT,
                  (Se + 1) * de / Ie.data.BYTES_PER_ELEMENT
                );
                i.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, Se, Ie.width, Ie.height, 1, $e, ut, ze);
              }
              P.clearLayerUpdates();
            } else
              i.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Ie.width, Ie.height, Ie.depth, $e, ut, Ie.data);
        } else
          i.texImage3D(r.TEXTURE_2D_ARRAY, 0, ft, Ie.width, Ie.height, Ie.depth, 0, $e, ut, Ie.data);
      else if (P.isData3DTexture)
        xt ? (Bt && i.texStorage3D(r.TEXTURE_3D, Le, ft, Ie.width, Ie.height, Ie.depth), ee && i.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, Ie.width, Ie.height, Ie.depth, $e, ut, Ie.data)) : i.texImage3D(r.TEXTURE_3D, 0, ft, Ie.width, Ie.height, Ie.depth, 0, $e, ut, Ie.data);
      else if (P.isFramebufferTexture) {
        if (Bt)
          if (xt)
            i.texStorage2D(r.TEXTURE_2D, Le, ft, Ie.width, Ie.height);
          else {
            let de = Ie.width, Se = Ie.height;
            for (let ze = 0; ze < Le; ze++)
              i.texImage2D(r.TEXTURE_2D, ze, ft, de, Se, 0, $e, ut, null), de >>= 1, Se >>= 1;
          }
      } else if (Ot.length > 0) {
        if (xt && Bt) {
          const de = nt(Ot[0]);
          i.texStorage2D(r.TEXTURE_2D, Le, ft, de.width, de.height);
        }
        for (let de = 0, Se = Ot.length; de < Se; de++)
          Ye = Ot[de], xt ? ee && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, $e, ut, Ye) : i.texImage2D(r.TEXTURE_2D, de, ft, $e, ut, Ye);
        P.generateMipmaps = !1;
      } else if (xt) {
        if (Bt) {
          const de = nt(Ie);
          i.texStorage2D(r.TEXTURE_2D, Le, ft, de.width, de.height);
        }
        ee && i.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, $e, ut, Ie);
      } else
        i.texImage2D(r.TEXTURE_2D, 0, ft, $e, ut, Ie);
      y(P) && g(Te), Je.__version = xe.version, P.onUpdate && P.onUpdate(P);
    }
    F.__version = P.version;
  }
  function X(F, P, le) {
    if (P.image.length !== 6) return;
    const Te = W(F, P), Ae = P.source;
    i.bindTexture(r.TEXTURE_CUBE_MAP, F.__webglTexture, r.TEXTURE0 + le);
    const xe = n.get(Ae);
    if (Ae.version !== xe.__version || Te === !0) {
      i.activeTexture(r.TEXTURE0 + le);
      const Je = Vt.getPrimaries(Vt.workingColorSpace), Be = P.colorSpace === Ja ? null : Vt.getPrimaries(P.colorSpace), qe = P.colorSpace === Ja || Je === Be ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, P.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, P.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, P.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, qe);
      const Pt = P.isCompressedTexture || P.image[0].isCompressedTexture, Ie = P.image[0] && P.image[0].isDataTexture, $e = [];
      for (let Se = 0; Se < 6; Se++)
        !Pt && !Ie ? $e[Se] = v(P.image[Se], !0, s.maxCubemapSize) : $e[Se] = Ie ? P.image[Se].image : P.image[Se], $e[Se] = Nt(P, $e[Se]);
      const ut = $e[0], ft = a.convert(P.format, P.colorSpace), Ye = a.convert(P.type), Ot = x(P.internalFormat, ft, Ye, P.colorSpace), xt = P.isVideoTexture !== !0, Bt = xe.__version === void 0 || Te === !0, ee = Ae.dataReady;
      let Le = T(P, ut);
      Q(r.TEXTURE_CUBE_MAP, P);
      let de;
      if (Pt) {
        xt && Bt && i.texStorage2D(r.TEXTURE_CUBE_MAP, Le, Ot, ut.width, ut.height);
        for (let Se = 0; Se < 6; Se++) {
          de = $e[Se].mipmaps;
          for (let ze = 0; ze < de.length; ze++) {
            const ke = de[ze];
            P.format !== Xn ? ft !== null ? xt ? ee && i.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, ze, 0, 0, ke.width, ke.height, ft, ke.data) : i.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, ze, Ot, ke.width, ke.height, 0, ke.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : xt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, ze, 0, 0, ke.width, ke.height, ft, Ye, ke.data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, ze, Ot, ke.width, ke.height, 0, ft, Ye, ke.data);
          }
        }
      } else {
        if (de = P.mipmaps, xt && Bt) {
          de.length > 0 && Le++;
          const Se = nt($e[0]);
          i.texStorage2D(r.TEXTURE_CUBE_MAP, Le, Ot, Se.width, Se.height);
        }
        for (let Se = 0; Se < 6; Se++)
          if (Ie) {
            xt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, 0, 0, 0, $e[Se].width, $e[Se].height, ft, Ye, $e[Se].data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, 0, Ot, $e[Se].width, $e[Se].height, 0, ft, Ye, $e[Se].data);
            for (let ze = 0; ze < de.length; ze++) {
              const ke = de[ze].image[Se].image;
              xt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, ze + 1, 0, 0, ke.width, ke.height, ft, Ye, ke.data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, ze + 1, Ot, ke.width, ke.height, 0, ft, Ye, ke.data);
            }
          } else {
            xt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, 0, 0, 0, ft, Ye, $e[Se]) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, 0, Ot, ft, Ye, $e[Se]);
            for (let ze = 0; ze < de.length; ze++) {
              const ke = de[ze];
              xt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, ze + 1, 0, 0, ft, Ye, ke.image[Se]) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, ze + 1, Ot, ft, Ye, ke.image[Se]);
            }
          }
      }
      y(P) && g(r.TEXTURE_CUBE_MAP), xe.__version = Ae.version, P.onUpdate && P.onUpdate(P);
    }
    F.__version = P.version;
  }
  function ae(F, P, le, Te, Ae, xe) {
    const Je = a.convert(le.format, le.colorSpace), Be = a.convert(le.type), qe = x(le.internalFormat, Je, Be, le.colorSpace), Pt = n.get(P), Ie = n.get(le);
    if (Ie.__renderTarget = P, !Pt.__hasExternalTextures) {
      const $e = Math.max(1, P.width >> xe), ut = Math.max(1, P.height >> xe);
      Ae === r.TEXTURE_3D || Ae === r.TEXTURE_2D_ARRAY ? i.texImage3D(Ae, xe, qe, $e, ut, P.depth, 0, Je, Be, null) : i.texImage2D(Ae, xe, qe, $e, ut, 0, Je, Be, null);
    }
    i.bindFramebuffer(r.FRAMEBUFFER, F), yt(P) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, Te, Ae, Ie.__webglTexture, 0, Xe(P)) : (Ae === r.TEXTURE_2D || Ae >= r.TEXTURE_CUBE_MAP_POSITIVE_X && Ae <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, Te, Ae, Ie.__webglTexture, xe), i.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function ue(F, P, le) {
    if (r.bindRenderbuffer(r.RENDERBUFFER, F), P.depthBuffer) {
      const Te = P.depthTexture, Ae = Te && Te.isDepthTexture ? Te.type : null, xe = b(P.stencilBuffer, Ae), Je = P.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Be = Xe(P);
      yt(P) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, Be, xe, P.width, P.height) : le ? r.renderbufferStorageMultisample(r.RENDERBUFFER, Be, xe, P.width, P.height) : r.renderbufferStorage(r.RENDERBUFFER, xe, P.width, P.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, Je, r.RENDERBUFFER, F);
    } else {
      const Te = P.textures;
      for (let Ae = 0; Ae < Te.length; Ae++) {
        const xe = Te[Ae], Je = a.convert(xe.format, xe.colorSpace), Be = a.convert(xe.type), qe = x(xe.internalFormat, Je, Be, xe.colorSpace), Pt = Xe(P);
        le && yt(P) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, Pt, qe, P.width, P.height) : yt(P) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, Pt, qe, P.width, P.height) : r.renderbufferStorage(r.RENDERBUFFER, qe, P.width, P.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function ge(F, P) {
    if (P && P.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (i.bindFramebuffer(r.FRAMEBUFFER, F), !(P.depthTexture && P.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const le = n.get(P.depthTexture);
    le.__renderTarget = P, (!le.__webglTexture || P.depthTexture.image.width !== P.width || P.depthTexture.image.height !== P.height) && (P.depthTexture.image.width = P.width, P.depthTexture.image.height = P.height, P.depthTexture.needsUpdate = !0), O(P.depthTexture, 0);
    const Te = le.__webglTexture, Ae = Xe(P);
    if (P.depthTexture.format === Hu)
      yt(P) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Te, 0, Ae) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Te, 0);
    else if (P.depthTexture.format === mc)
      yt(P) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Te, 0, Ae) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Te, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function we(F) {
    const P = n.get(F), le = F.isWebGLCubeRenderTarget === !0;
    if (P.__boundDepthTexture !== F.depthTexture) {
      const Te = F.depthTexture;
      if (P.__depthDisposeCallback && P.__depthDisposeCallback(), Te) {
        const Ae = () => {
          delete P.__boundDepthTexture, delete P.__depthDisposeCallback, Te.removeEventListener("dispose", Ae);
        };
        Te.addEventListener("dispose", Ae), P.__depthDisposeCallback = Ae;
      }
      P.__boundDepthTexture = Te;
    }
    if (F.depthTexture && !P.__autoAllocateDepthBuffer) {
      if (le) throw new Error("target.depthTexture not supported in Cube render targets");
      ge(P.__webglFramebuffer, F);
    } else if (le) {
      P.__webglDepthbuffer = [];
      for (let Te = 0; Te < 6; Te++)
        if (i.bindFramebuffer(r.FRAMEBUFFER, P.__webglFramebuffer[Te]), P.__webglDepthbuffer[Te] === void 0)
          P.__webglDepthbuffer[Te] = r.createRenderbuffer(), ue(P.__webglDepthbuffer[Te], F, !1);
        else {
          const Ae = F.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, xe = P.__webglDepthbuffer[Te];
          r.bindRenderbuffer(r.RENDERBUFFER, xe), r.framebufferRenderbuffer(r.FRAMEBUFFER, Ae, r.RENDERBUFFER, xe);
        }
    } else if (i.bindFramebuffer(r.FRAMEBUFFER, P.__webglFramebuffer), P.__webglDepthbuffer === void 0)
      P.__webglDepthbuffer = r.createRenderbuffer(), ue(P.__webglDepthbuffer, F, !1);
    else {
      const Te = F.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Ae = P.__webglDepthbuffer;
      r.bindRenderbuffer(r.RENDERBUFFER, Ae), r.framebufferRenderbuffer(r.FRAMEBUFFER, Te, r.RENDERBUFFER, Ae);
    }
    i.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function Ne(F, P, le) {
    const Te = n.get(F);
    P !== void 0 && ae(Te.__webglFramebuffer, F, F.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), le !== void 0 && we(F);
  }
  function lt(F) {
    const P = F.texture, le = n.get(F), Te = n.get(P);
    F.addEventListener("dispose", w);
    const Ae = F.textures, xe = F.isWebGLCubeRenderTarget === !0, Je = Ae.length > 1;
    if (Je || (Te.__webglTexture === void 0 && (Te.__webglTexture = r.createTexture()), Te.__version = P.version, o.memory.textures++), xe) {
      le.__webglFramebuffer = [];
      for (let Be = 0; Be < 6; Be++)
        if (P.mipmaps && P.mipmaps.length > 0) {
          le.__webglFramebuffer[Be] = [];
          for (let qe = 0; qe < P.mipmaps.length; qe++)
            le.__webglFramebuffer[Be][qe] = r.createFramebuffer();
        } else
          le.__webglFramebuffer[Be] = r.createFramebuffer();
    } else {
      if (P.mipmaps && P.mipmaps.length > 0) {
        le.__webglFramebuffer = [];
        for (let Be = 0; Be < P.mipmaps.length; Be++)
          le.__webglFramebuffer[Be] = r.createFramebuffer();
      } else
        le.__webglFramebuffer = r.createFramebuffer();
      if (Je)
        for (let Be = 0, qe = Ae.length; Be < qe; Be++) {
          const Pt = n.get(Ae[Be]);
          Pt.__webglTexture === void 0 && (Pt.__webglTexture = r.createTexture(), o.memory.textures++);
        }
      if (F.samples > 0 && yt(F) === !1) {
        le.__webglMultisampledFramebuffer = r.createFramebuffer(), le.__webglColorRenderbuffer = [], i.bindFramebuffer(r.FRAMEBUFFER, le.__webglMultisampledFramebuffer);
        for (let Be = 0; Be < Ae.length; Be++) {
          const qe = Ae[Be];
          le.__webglColorRenderbuffer[Be] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, le.__webglColorRenderbuffer[Be]);
          const Pt = a.convert(qe.format, qe.colorSpace), Ie = a.convert(qe.type), $e = x(qe.internalFormat, Pt, Ie, qe.colorSpace, F.isXRRenderTarget === !0), ut = Xe(F);
          r.renderbufferStorageMultisample(r.RENDERBUFFER, ut, $e, F.width, F.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Be, r.RENDERBUFFER, le.__webglColorRenderbuffer[Be]);
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null), F.depthBuffer && (le.__webglDepthRenderbuffer = r.createRenderbuffer(), ue(le.__webglDepthRenderbuffer, F, !0)), i.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (xe) {
      i.bindTexture(r.TEXTURE_CUBE_MAP, Te.__webglTexture), Q(r.TEXTURE_CUBE_MAP, P);
      for (let Be = 0; Be < 6; Be++)
        if (P.mipmaps && P.mipmaps.length > 0)
          for (let qe = 0; qe < P.mipmaps.length; qe++)
            ae(le.__webglFramebuffer[Be][qe], F, P, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Be, qe);
        else
          ae(le.__webglFramebuffer[Be], F, P, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0);
      y(P) && g(r.TEXTURE_CUBE_MAP), i.unbindTexture();
    } else if (Je) {
      for (let Be = 0, qe = Ae.length; Be < qe; Be++) {
        const Pt = Ae[Be], Ie = n.get(Pt);
        i.bindTexture(r.TEXTURE_2D, Ie.__webglTexture), Q(r.TEXTURE_2D, Pt), ae(le.__webglFramebuffer, F, Pt, r.COLOR_ATTACHMENT0 + Be, r.TEXTURE_2D, 0), y(Pt) && g(r.TEXTURE_2D);
      }
      i.unbindTexture();
    } else {
      let Be = r.TEXTURE_2D;
      if ((F.isWebGL3DRenderTarget || F.isWebGLArrayRenderTarget) && (Be = F.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), i.bindTexture(Be, Te.__webglTexture), Q(Be, P), P.mipmaps && P.mipmaps.length > 0)
        for (let qe = 0; qe < P.mipmaps.length; qe++)
          ae(le.__webglFramebuffer[qe], F, P, r.COLOR_ATTACHMENT0, Be, qe);
      else
        ae(le.__webglFramebuffer, F, P, r.COLOR_ATTACHMENT0, Be, 0);
      y(P) && g(Be), i.unbindTexture();
    }
    F.depthBuffer && we(F);
  }
  function be(F) {
    const P = F.textures;
    for (let le = 0, Te = P.length; le < Te; le++) {
      const Ae = P[le];
      if (y(Ae)) {
        const xe = _(F), Je = n.get(Ae).__webglTexture;
        i.bindTexture(xe, Je), g(xe), i.unbindTexture();
      }
    }
  }
  const bt = [], Y = [];
  function Gt(F) {
    if (F.samples > 0) {
      if (yt(F) === !1) {
        const P = F.textures, le = F.width, Te = F.height;
        let Ae = r.COLOR_BUFFER_BIT;
        const xe = F.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Je = n.get(F), Be = P.length > 1;
        if (Be)
          for (let qe = 0; qe < P.length; qe++)
            i.bindFramebuffer(r.FRAMEBUFFER, Je.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + qe, r.RENDERBUFFER, null), i.bindFramebuffer(r.FRAMEBUFFER, Je.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + qe, r.TEXTURE_2D, null, 0);
        i.bindFramebuffer(r.READ_FRAMEBUFFER, Je.__webglMultisampledFramebuffer), i.bindFramebuffer(r.DRAW_FRAMEBUFFER, Je.__webglFramebuffer);
        for (let qe = 0; qe < P.length; qe++) {
          if (F.resolveDepthBuffer && (F.depthBuffer && (Ae |= r.DEPTH_BUFFER_BIT), F.stencilBuffer && F.resolveStencilBuffer && (Ae |= r.STENCIL_BUFFER_BIT)), Be) {
            r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, Je.__webglColorRenderbuffer[qe]);
            const Pt = n.get(P[qe]).__webglTexture;
            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, Pt, 0);
          }
          r.blitFramebuffer(0, 0, le, Te, 0, 0, le, Te, Ae, r.NEAREST), u === !0 && (bt.length = 0, Y.length = 0, bt.push(r.COLOR_ATTACHMENT0 + qe), F.depthBuffer && F.resolveDepthBuffer === !1 && (bt.push(xe), Y.push(xe), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, Y)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, bt));
        }
        if (i.bindFramebuffer(r.READ_FRAMEBUFFER, null), i.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), Be)
          for (let qe = 0; qe < P.length; qe++) {
            i.bindFramebuffer(r.FRAMEBUFFER, Je.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + qe, r.RENDERBUFFER, Je.__webglColorRenderbuffer[qe]);
            const Pt = n.get(P[qe]).__webglTexture;
            i.bindFramebuffer(r.FRAMEBUFFER, Je.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + qe, r.TEXTURE_2D, Pt, 0);
          }
        i.bindFramebuffer(r.DRAW_FRAMEBUFFER, Je.__webglMultisampledFramebuffer);
      } else if (F.depthBuffer && F.resolveDepthBuffer === !1 && u) {
        const P = F.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
        r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [P]);
      }
    }
  }
  function Xe(F) {
    return Math.min(s.maxSamples, F.samples);
  }
  function yt(F) {
    const P = n.get(F);
    return F.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && P.__useRenderToTexture !== !1;
  }
  function rt(F) {
    const P = o.render.frame;
    h.get(F) !== P && (h.set(F, P), F.update());
  }
  function Nt(F, P) {
    const le = F.colorSpace, Te = F.format, Ae = F.type;
    return F.isCompressedTexture === !0 || F.isVideoTexture === !0 || le !== Lc && le !== Ja && (Vt.getTransfer(le) === Jt ? (Te !== Xn || Ae !== xa) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", le)), P;
  }
  function nt(F) {
    return typeof HTMLImageElement < "u" && F instanceof HTMLImageElement ? (c.width = F.naturalWidth || F.width, c.height = F.naturalHeight || F.height) : typeof VideoFrame < "u" && F instanceof VideoFrame ? (c.width = F.displayWidth, c.height = F.displayHeight) : (c.width = F.width, c.height = F.height), c;
  }
  this.allocateTextureUnit = U, this.resetTextureUnits = k, this.setTexture2D = O, this.setTexture2DArray = D, this.setTexture3D = H, this.setTextureCube = j, this.rebindTextures = Ne, this.setupRenderTarget = lt, this.updateRenderTargetMipmap = be, this.updateMultisampleRenderTarget = Gt, this.setupDepthRenderbuffer = we, this.setupFrameBufferTexture = ae, this.useMultisampledRTT = yt;
}
function hj(r, e) {
  function i(n, s = Ja) {
    let a;
    const o = Vt.getTransfer(s);
    if (n === xa) return r.UNSIGNED_BYTE;
    if (n === S_) return r.UNSIGNED_SHORT_4_4_4_4;
    if (n === w_) return r.UNSIGNED_SHORT_5_5_5_1;
    if (n === LC) return r.UNSIGNED_INT_5_9_9_9_REV;
    if (n === OC) return r.BYTE;
    if (n === DC) return r.SHORT;
    if (n === ud) return r.UNSIGNED_SHORT;
    if (n === T_) return r.INT;
    if (n === xl) return r.UNSIGNED_INT;
    if (n === na) return r.FLOAT;
    if (n === Dc) return r.HALF_FLOAT;
    if (n === UC) return r.ALPHA;
    if (n === kC) return r.RGB;
    if (n === Xn) return r.RGBA;
    if (n === FC) return r.LUMINANCE;
    if (n === BC) return r.LUMINANCE_ALPHA;
    if (n === Hu) return r.DEPTH_COMPONENT;
    if (n === mc) return r.DEPTH_STENCIL;
    if (n === zC) return r.RED;
    if (n === E_) return r.RED_INTEGER;
    if (n === jC) return r.RG;
    if (n === M_) return r.RG_INTEGER;
    if (n === A_) return r.RGBA_INTEGER;
    if (n === Gf || n === Hf || n === Wf || n === qf)
      if (o === Jt)
        if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (n === Gf) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === Hf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === Wf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === qf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (n === Gf) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === Hf) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === Wf) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === qf) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === sb || n === ab || n === ob || n === lb)
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (n === sb) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === ab) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === ob) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === lb) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === ub || n === cb || n === hb)
      if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (n === ub || n === cb) return o === Jt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (n === hb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (n === db || n === pb || n === fb || n === mb || n === gb || n === yb || n === vb || n === bb || n === xb || n === _b || n === Tb || n === Sb || n === wb || n === Eb)
      if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (n === db) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === pb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === fb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === mb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === gb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === yb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === vb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === bb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === xb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === _b) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === Tb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === Sb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === wb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === Eb) return o === Jt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === Xf || n === Mb || n === Ab)
      if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
        if (n === Xf) return o === Jt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === Mb) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === Ab) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (n === VC || n === Cb || n === Rb || n === Nb)
      if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
        if (n === Xf) return a.COMPRESSED_RED_RGTC1_EXT;
        if (n === Cb) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === Rb) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === Nb) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === fc ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null;
  }
  return { convert: i };
}
class dj extends vn {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
let nl = class extends Gr {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
};
const pj = { type: "move" };
class Hy {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new nl(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new nl(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new q(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new q()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new nl(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new q(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new q()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const i = this._hand;
      if (i)
        for (const n of e.hand.values())
          this._getHandJoint(i, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, i, n) {
    let s = null, a = null, o = null;
    const l = this._targetRay, u = this._grip, c = this._hand;
    if (e && i.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const v of e.hand.values()) {
          const y = i.getJointPose(v, n), g = this._getHandJoint(c, v);
          y !== null && (g.matrix.fromArray(y.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, g.jointRadius = y.radius), g.visible = y !== null;
        }
        const h = c.joints["index-finger-tip"], d = c.joints["thumb-tip"], p = h.position.distanceTo(d.position), f = 0.02, m = 5e-3;
        c.inputState.pinching && p > f + m ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && p <= f - m && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        u !== null && e.gripSpace && (a = i.getPose(e.gripSpace, n), a !== null && (u.matrix.fromArray(a.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (u.hasLinearVelocity = !0, u.linearVelocity.copy(a.linearVelocity)) : u.hasLinearVelocity = !1, a.angularVelocity ? (u.hasAngularVelocity = !0, u.angularVelocity.copy(a.angularVelocity)) : u.hasAngularVelocity = !1));
      l !== null && (s = i.getPose(e.targetRaySpace, n), s === null && a !== null && (s = a), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent(pj)));
    }
    return l !== null && (l.visible = s !== null), u !== null && (u.visible = a !== null), c !== null && (c.visible = o !== null), this;
  }
  // private method
  _getHandJoint(e, i) {
    if (e.joints[i.jointName] === void 0) {
      const n = new nl();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[i.jointName] = n, e.add(n);
    }
    return e.joints[i.jointName];
  }
}
const fj = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, mj = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class gj {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, i, n) {
    if (this.texture === null) {
      const s = new En(), a = e.properties.get(s);
      a.__webglTexture = i.texture, (i.depthNear != n.depthNear || i.depthFar != n.depthFar) && (this.depthNear = i.depthNear, this.depthFar = i.depthFar), this.texture = s;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const i = e.cameras[0].viewport, n = new xs({
        vertexShader: fj,
        fragmentShader: mj,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: i.z },
          depthHeight: { value: i.w }
        }
      });
      this.mesh = new Ur(new Vd(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class yj extends Cl {
  constructor(e, i) {
    super();
    const n = this;
    let s = null, a = 1, o = null, l = "local-floor", u = 1, c = null, h = null, d = null, p = null, f = null, m = null;
    const v = new gj(), y = i.getContextAttributes();
    let g = null, _ = null;
    const x = [], b = [], T = new Ue();
    let S = null;
    const w = new vn();
    w.viewport = new Fi();
    const A = new vn();
    A.viewport = new Fi();
    const E = [w, A], M = new dj();
    let N = null, k = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(z) {
      let X = x[z];
      return X === void 0 && (X = new Hy(), x[z] = X), X.getTargetRaySpace();
    }, this.getControllerGrip = function(z) {
      let X = x[z];
      return X === void 0 && (X = new Hy(), x[z] = X), X.getGripSpace();
    }, this.getHand = function(z) {
      let X = x[z];
      return X === void 0 && (X = new Hy(), x[z] = X), X.getHandSpace();
    };
    function U(z) {
      const X = b.indexOf(z.inputSource);
      if (X === -1)
        return;
      const ae = x[X];
      ae !== void 0 && (ae.update(z.inputSource, z.frame, c || o), ae.dispatchEvent({ type: z.type, data: z.inputSource }));
    }
    function C() {
      s.removeEventListener("select", U), s.removeEventListener("selectstart", U), s.removeEventListener("selectend", U), s.removeEventListener("squeeze", U), s.removeEventListener("squeezestart", U), s.removeEventListener("squeezeend", U), s.removeEventListener("end", C), s.removeEventListener("inputsourceschange", O);
      for (let z = 0; z < x.length; z++) {
        const X = b[z];
        X !== null && (b[z] = null, x[z].disconnect(X));
      }
      N = null, k = null, v.reset(), e.setRenderTarget(g), f = null, p = null, d = null, s = null, _ = null, W.stop(), n.isPresenting = !1, e.setPixelRatio(S), e.setSize(T.width, T.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(z) {
      a = z, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(z) {
      l = z, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || o;
    }, this.setReferenceSpace = function(z) {
      c = z;
    }, this.getBaseLayer = function() {
      return p !== null ? p : f;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return s;
    }, this.setSession = async function(z) {
      if (s = z, s !== null) {
        if (g = e.getRenderTarget(), s.addEventListener("select", U), s.addEventListener("selectstart", U), s.addEventListener("selectend", U), s.addEventListener("squeeze", U), s.addEventListener("squeezestart", U), s.addEventListener("squeezeend", U), s.addEventListener("end", C), s.addEventListener("inputsourceschange", O), y.xrCompatible !== !0 && await i.makeXRCompatible(), S = e.getPixelRatio(), e.getSize(T), s.renderState.layers === void 0) {
          const X = {
            antialias: y.antialias,
            alpha: !0,
            depth: y.depth,
            stencil: y.stencil,
            framebufferScaleFactor: a
          };
          f = new XRWebGLLayer(s, i, X), s.updateRenderState({ baseLayer: f }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), _ = new go(
            f.framebufferWidth,
            f.framebufferHeight,
            {
              format: Xn,
              type: xa,
              colorSpace: e.outputColorSpace,
              stencilBuffer: y.stencil
            }
          );
        } else {
          let X = null, ae = null, ue = null;
          y.depth && (ue = y.stencil ? i.DEPTH24_STENCIL8 : i.DEPTH_COMPONENT24, X = y.stencil ? mc : Hu, ae = y.stencil ? fc : xl);
          const ge = {
            colorFormat: i.RGBA8,
            depthFormat: ue,
            scaleFactor: a
          };
          d = new XRWebGLBinding(s, i), p = d.createProjectionLayer(ge), s.updateRenderState({ layers: [p] }), e.setPixelRatio(1), e.setSize(p.textureWidth, p.textureHeight, !1), _ = new go(
            p.textureWidth,
            p.textureHeight,
            {
              format: Xn,
              type: xa,
              depthTexture: new uR(p.textureWidth, p.textureHeight, ae, void 0, void 0, void 0, void 0, void 0, void 0, X),
              stencilBuffer: y.stencil,
              colorSpace: e.outputColorSpace,
              samples: y.antialias ? 4 : 0,
              resolveDepthBuffer: p.ignoreDepthValues === !1
            }
          );
        }
        _.isXRRenderTarget = !0, this.setFoveation(u), c = null, o = await s.requestReferenceSpace(l), W.setContext(s), W.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (s !== null)
        return s.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return v.getDepthTexture();
    };
    function O(z) {
      for (let X = 0; X < z.removed.length; X++) {
        const ae = z.removed[X], ue = b.indexOf(ae);
        ue >= 0 && (b[ue] = null, x[ue].disconnect(ae));
      }
      for (let X = 0; X < z.added.length; X++) {
        const ae = z.added[X];
        let ue = b.indexOf(ae);
        if (ue === -1) {
          for (let we = 0; we < x.length; we++)
            if (we >= b.length) {
              b.push(ae), ue = we;
              break;
            } else if (b[we] === null) {
              b[we] = ae, ue = we;
              break;
            }
          if (ue === -1) break;
        }
        const ge = x[ue];
        ge && ge.connect(ae);
      }
    }
    const D = new q(), H = new q();
    function j(z, X, ae) {
      D.setFromMatrixPosition(X.matrixWorld), H.setFromMatrixPosition(ae.matrixWorld);
      const ue = D.distanceTo(H), ge = X.projectionMatrix.elements, we = ae.projectionMatrix.elements, Ne = ge[14] / (ge[10] - 1), lt = ge[14] / (ge[10] + 1), be = (ge[9] + 1) / ge[5], bt = (ge[9] - 1) / ge[5], Y = (ge[8] - 1) / ge[0], Gt = (we[8] + 1) / we[0], Xe = Ne * Y, yt = Ne * Gt, rt = ue / (-Y + Gt), Nt = rt * -Y;
      if (X.matrixWorld.decompose(z.position, z.quaternion, z.scale), z.translateX(Nt), z.translateZ(rt), z.matrixWorld.compose(z.position, z.quaternion, z.scale), z.matrixWorldInverse.copy(z.matrixWorld).invert(), ge[10] === -1)
        z.projectionMatrix.copy(X.projectionMatrix), z.projectionMatrixInverse.copy(X.projectionMatrixInverse);
      else {
        const nt = Ne + rt, F = lt + rt, P = Xe - Nt, le = yt + (ue - Nt), Te = be * lt / F * nt, Ae = bt * lt / F * nt;
        z.projectionMatrix.makePerspective(P, le, Te, Ae, nt, F), z.projectionMatrixInverse.copy(z.projectionMatrix).invert();
      }
    }
    function K(z, X) {
      X === null ? z.matrixWorld.copy(z.matrix) : z.matrixWorld.multiplyMatrices(X.matrixWorld, z.matrix), z.matrixWorldInverse.copy(z.matrixWorld).invert();
    }
    this.updateCamera = function(z) {
      if (s === null) return;
      let X = z.near, ae = z.far;
      v.texture !== null && (v.depthNear > 0 && (X = v.depthNear), v.depthFar > 0 && (ae = v.depthFar)), M.near = A.near = w.near = X, M.far = A.far = w.far = ae, (N !== M.near || k !== M.far) && (s.updateRenderState({
        depthNear: M.near,
        depthFar: M.far
      }), N = M.near, k = M.far), w.layers.mask = z.layers.mask | 2, A.layers.mask = z.layers.mask | 4, M.layers.mask = w.layers.mask | A.layers.mask;
      const ue = z.parent, ge = M.cameras;
      K(M, ue);
      for (let we = 0; we < ge.length; we++)
        K(ge[we], ue);
      ge.length === 2 ? j(M, w, A) : M.projectionMatrix.copy(w.projectionMatrix), L(z, M, ue);
    };
    function L(z, X, ae) {
      ae === null ? z.matrix.copy(X.matrixWorld) : (z.matrix.copy(ae.matrixWorld), z.matrix.invert(), z.matrix.multiply(X.matrixWorld)), z.matrix.decompose(z.position, z.quaternion, z.scale), z.updateMatrixWorld(!0), z.projectionMatrix.copy(X.projectionMatrix), z.projectionMatrixInverse.copy(X.projectionMatrixInverse), z.isPerspectiveCamera && (z.fov = cd * 2 * Math.atan(1 / z.projectionMatrix.elements[5]), z.zoom = 1);
    }
    this.getCamera = function() {
      return M;
    }, this.getFoveation = function() {
      if (!(p === null && f === null))
        return u;
    }, this.setFoveation = function(z) {
      u = z, p !== null && (p.fixedFoveation = z), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = z);
    }, this.hasDepthSensing = function() {
      return v.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return v.getMesh(M);
    };
    let B = null;
    function Q(z, X) {
      if (h = X.getViewerPose(c || o), m = X, h !== null) {
        const ae = h.views;
        f !== null && (e.setRenderTargetFramebuffer(_, f.framebuffer), e.setRenderTarget(_));
        let ue = !1;
        ae.length !== M.cameras.length && (M.cameras.length = 0, ue = !0);
        for (let we = 0; we < ae.length; we++) {
          const Ne = ae[we];
          let lt = null;
          if (f !== null)
            lt = f.getViewport(Ne);
          else {
            const bt = d.getViewSubImage(p, Ne);
            lt = bt.viewport, we === 0 && (e.setRenderTargetTextures(
              _,
              bt.colorTexture,
              p.ignoreDepthValues ? void 0 : bt.depthStencilTexture
            ), e.setRenderTarget(_));
          }
          let be = E[we];
          be === void 0 && (be = new vn(), be.layers.enable(we), be.viewport = new Fi(), E[we] = be), be.matrix.fromArray(Ne.transform.matrix), be.matrix.decompose(be.position, be.quaternion, be.scale), be.projectionMatrix.fromArray(Ne.projectionMatrix), be.projectionMatrixInverse.copy(be.projectionMatrix).invert(), be.viewport.set(lt.x, lt.y, lt.width, lt.height), we === 0 && (M.matrix.copy(be.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)), ue === !0 && M.cameras.push(be);
        }
        const ge = s.enabledFeatures;
        if (ge && ge.includes("depth-sensing")) {
          const we = d.getDepthInformation(ae[0]);
          we && we.isValid && we.texture && v.init(e, we, s.renderState);
        }
      }
      for (let ae = 0; ae < x.length; ae++) {
        const ue = b[ae], ge = x[ae];
        ue !== null && ge !== void 0 && ge.update(ue, X, c || o);
      }
      B && B(z, X), X.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: X }), m = null;
    }
    const W = new lR();
    W.setAnimationLoop(Q), this.setAnimationLoop = function(z) {
      B = z;
    }, this.dispose = function() {
    };
  }
}
const Do = /* @__PURE__ */ new yo(), vj = /* @__PURE__ */ new ui();
function bj(r, e) {
  function i(y, g) {
    y.matrixAutoUpdate === !0 && y.updateMatrix(), g.value.copy(y.matrix);
  }
  function n(y, g) {
    g.color.getRGB(y.fogColor.value, nR(r)), g.isFog ? (y.fogNear.value = g.near, y.fogFar.value = g.far) : g.isFogExp2 && (y.fogDensity.value = g.density);
  }
  function s(y, g, _, x, b) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial ? a(y, g) : g.isMeshToonMaterial ? (a(y, g), d(y, g)) : g.isMeshPhongMaterial ? (a(y, g), h(y, g)) : g.isMeshStandardMaterial ? (a(y, g), p(y, g), g.isMeshPhysicalMaterial && f(y, g, b)) : g.isMeshMatcapMaterial ? (a(y, g), m(y, g)) : g.isMeshDepthMaterial ? a(y, g) : g.isMeshDistanceMaterial ? (a(y, g), v(y, g)) : g.isMeshNormalMaterial ? a(y, g) : g.isLineBasicMaterial ? (o(y, g), g.isLineDashedMaterial && l(y, g)) : g.isPointsMaterial ? u(y, g, _, x) : g.isSpriteMaterial ? c(y, g) : g.isShadowMaterial ? (y.color.value.copy(g.color), y.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function a(y, g) {
    y.opacity.value = g.opacity, g.color && y.diffuse.value.copy(g.color), g.emissive && y.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (y.map.value = g.map, i(g.map, y.mapTransform)), g.alphaMap && (y.alphaMap.value = g.alphaMap, i(g.alphaMap, y.alphaMapTransform)), g.bumpMap && (y.bumpMap.value = g.bumpMap, i(g.bumpMap, y.bumpMapTransform), y.bumpScale.value = g.bumpScale, g.side === Ar && (y.bumpScale.value *= -1)), g.normalMap && (y.normalMap.value = g.normalMap, i(g.normalMap, y.normalMapTransform), y.normalScale.value.copy(g.normalScale), g.side === Ar && y.normalScale.value.negate()), g.displacementMap && (y.displacementMap.value = g.displacementMap, i(g.displacementMap, y.displacementMapTransform), y.displacementScale.value = g.displacementScale, y.displacementBias.value = g.displacementBias), g.emissiveMap && (y.emissiveMap.value = g.emissiveMap, i(g.emissiveMap, y.emissiveMapTransform)), g.specularMap && (y.specularMap.value = g.specularMap, i(g.specularMap, y.specularMapTransform)), g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
    const _ = e.get(g), x = _.envMap, b = _.envMapRotation;
    x && (y.envMap.value = x, Do.copy(b), Do.x *= -1, Do.y *= -1, Do.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === !1 && (Do.y *= -1, Do.z *= -1), y.envMapRotation.value.setFromMatrix4(vj.makeRotationFromEuler(Do)), y.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, y.reflectivity.value = g.reflectivity, y.ior.value = g.ior, y.refractionRatio.value = g.refractionRatio), g.lightMap && (y.lightMap.value = g.lightMap, y.lightMapIntensity.value = g.lightMapIntensity, i(g.lightMap, y.lightMapTransform)), g.aoMap && (y.aoMap.value = g.aoMap, y.aoMapIntensity.value = g.aoMapIntensity, i(g.aoMap, y.aoMapTransform));
  }
  function o(y, g) {
    y.diffuse.value.copy(g.color), y.opacity.value = g.opacity, g.map && (y.map.value = g.map, i(g.map, y.mapTransform));
  }
  function l(y, g) {
    y.dashSize.value = g.dashSize, y.totalSize.value = g.dashSize + g.gapSize, y.scale.value = g.scale;
  }
  function u(y, g, _, x) {
    y.diffuse.value.copy(g.color), y.opacity.value = g.opacity, y.size.value = g.size * _, y.scale.value = x * 0.5, g.map && (y.map.value = g.map, i(g.map, y.uvTransform)), g.alphaMap && (y.alphaMap.value = g.alphaMap, i(g.alphaMap, y.alphaMapTransform)), g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
  }
  function c(y, g) {
    y.diffuse.value.copy(g.color), y.opacity.value = g.opacity, y.rotation.value = g.rotation, g.map && (y.map.value = g.map, i(g.map, y.mapTransform)), g.alphaMap && (y.alphaMap.value = g.alphaMap, i(g.alphaMap, y.alphaMapTransform)), g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
  }
  function h(y, g) {
    y.specular.value.copy(g.specular), y.shininess.value = Math.max(g.shininess, 1e-4);
  }
  function d(y, g) {
    g.gradientMap && (y.gradientMap.value = g.gradientMap);
  }
  function p(y, g) {
    y.metalness.value = g.metalness, g.metalnessMap && (y.metalnessMap.value = g.metalnessMap, i(g.metalnessMap, y.metalnessMapTransform)), y.roughness.value = g.roughness, g.roughnessMap && (y.roughnessMap.value = g.roughnessMap, i(g.roughnessMap, y.roughnessMapTransform)), g.envMap && (y.envMapIntensity.value = g.envMapIntensity);
  }
  function f(y, g, _) {
    y.ior.value = g.ior, g.sheen > 0 && (y.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), y.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (y.sheenColorMap.value = g.sheenColorMap, i(g.sheenColorMap, y.sheenColorMapTransform)), g.sheenRoughnessMap && (y.sheenRoughnessMap.value = g.sheenRoughnessMap, i(g.sheenRoughnessMap, y.sheenRoughnessMapTransform))), g.clearcoat > 0 && (y.clearcoat.value = g.clearcoat, y.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (y.clearcoatMap.value = g.clearcoatMap, i(g.clearcoatMap, y.clearcoatMapTransform)), g.clearcoatRoughnessMap && (y.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap, i(g.clearcoatRoughnessMap, y.clearcoatRoughnessMapTransform)), g.clearcoatNormalMap && (y.clearcoatNormalMap.value = g.clearcoatNormalMap, i(g.clearcoatNormalMap, y.clearcoatNormalMapTransform), y.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === Ar && y.clearcoatNormalScale.value.negate())), g.dispersion > 0 && (y.dispersion.value = g.dispersion), g.iridescence > 0 && (y.iridescence.value = g.iridescence, y.iridescenceIOR.value = g.iridescenceIOR, y.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], y.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (y.iridescenceMap.value = g.iridescenceMap, i(g.iridescenceMap, y.iridescenceMapTransform)), g.iridescenceThicknessMap && (y.iridescenceThicknessMap.value = g.iridescenceThicknessMap, i(g.iridescenceThicknessMap, y.iridescenceThicknessMapTransform))), g.transmission > 0 && (y.transmission.value = g.transmission, y.transmissionSamplerMap.value = _.texture, y.transmissionSamplerSize.value.set(_.width, _.height), g.transmissionMap && (y.transmissionMap.value = g.transmissionMap, i(g.transmissionMap, y.transmissionMapTransform)), y.thickness.value = g.thickness, g.thicknessMap && (y.thicknessMap.value = g.thicknessMap, i(g.thicknessMap, y.thicknessMapTransform)), y.attenuationDistance.value = g.attenuationDistance, y.attenuationColor.value.copy(g.attenuationColor)), g.anisotropy > 0 && (y.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && (y.anisotropyMap.value = g.anisotropyMap, i(g.anisotropyMap, y.anisotropyMapTransform))), y.specularIntensity.value = g.specularIntensity, y.specularColor.value.copy(g.specularColor), g.specularColorMap && (y.specularColorMap.value = g.specularColorMap, i(g.specularColorMap, y.specularColorMapTransform)), g.specularIntensityMap && (y.specularIntensityMap.value = g.specularIntensityMap, i(g.specularIntensityMap, y.specularIntensityMapTransform));
  }
  function m(y, g) {
    g.matcap && (y.matcap.value = g.matcap);
  }
  function v(y, g) {
    const _ = e.get(g).light;
    y.referencePosition.value.setFromMatrixPosition(_.matrixWorld), y.nearDistance.value = _.shadow.camera.near, y.farDistance.value = _.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: s
  };
}
function xj(r, e, i, n) {
  let s = {}, a = {}, o = [];
  const l = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
  function u(_, x) {
    const b = x.program;
    n.uniformBlockBinding(_, b);
  }
  function c(_, x) {
    let b = s[_.id];
    b === void 0 && (m(_), b = h(_), s[_.id] = b, _.addEventListener("dispose", y));
    const T = x.program;
    n.updateUBOMapping(_, T);
    const S = e.render.frame;
    a[_.id] !== S && (p(_), a[_.id] = S);
  }
  function h(_) {
    const x = d();
    _.__bindingPointIndex = x;
    const b = r.createBuffer(), T = _.__size, S = _.usage;
    return r.bindBuffer(r.UNIFORM_BUFFER, b), r.bufferData(r.UNIFORM_BUFFER, T, S), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, x, b), b;
  }
  function d() {
    for (let _ = 0; _ < l; _++)
      if (o.indexOf(_) === -1)
        return o.push(_), _;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function p(_) {
    const x = s[_.id], b = _.uniforms, T = _.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, x);
    for (let S = 0, w = b.length; S < w; S++) {
      const A = Array.isArray(b[S]) ? b[S] : [b[S]];
      for (let E = 0, M = A.length; E < M; E++) {
        const N = A[E];
        if (f(N, S, E, T) === !0) {
          const k = N.__offset, U = Array.isArray(N.value) ? N.value : [N.value];
          let C = 0;
          for (let O = 0; O < U.length; O++) {
            const D = U[O], H = v(D);
            typeof D == "number" || typeof D == "boolean" ? (N.__data[0] = D, r.bufferSubData(r.UNIFORM_BUFFER, k + C, N.__data)) : D.isMatrix3 ? (N.__data[0] = D.elements[0], N.__data[1] = D.elements[1], N.__data[2] = D.elements[2], N.__data[3] = 0, N.__data[4] = D.elements[3], N.__data[5] = D.elements[4], N.__data[6] = D.elements[5], N.__data[7] = 0, N.__data[8] = D.elements[6], N.__data[9] = D.elements[7], N.__data[10] = D.elements[8], N.__data[11] = 0) : (D.toArray(N.__data, C), C += H.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          r.bufferSubData(r.UNIFORM_BUFFER, k, N.__data);
        }
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function f(_, x, b, T) {
    const S = _.value, w = x + "_" + b;
    if (T[w] === void 0)
      return typeof S == "number" || typeof S == "boolean" ? T[w] = S : T[w] = S.clone(), !0;
    {
      const A = T[w];
      if (typeof S == "number" || typeof S == "boolean") {
        if (A !== S)
          return T[w] = S, !0;
      } else if (A.equals(S) === !1)
        return A.copy(S), !0;
    }
    return !1;
  }
  function m(_) {
    const x = _.uniforms;
    let b = 0;
    const T = 16;
    for (let w = 0, A = x.length; w < A; w++) {
      const E = Array.isArray(x[w]) ? x[w] : [x[w]];
      for (let M = 0, N = E.length; M < N; M++) {
        const k = E[M], U = Array.isArray(k.value) ? k.value : [k.value];
        for (let C = 0, O = U.length; C < O; C++) {
          const D = U[C], H = v(D), j = b % T, K = j % H.boundary, L = j + K;
          b += K, L !== 0 && T - L < H.storage && (b += T - L), k.__data = new Float32Array(H.storage / Float32Array.BYTES_PER_ELEMENT), k.__offset = b, b += H.storage;
        }
      }
    }
    const S = b % T;
    return S > 0 && (b += T - S), _.__size = b, _.__cache = {}, this;
  }
  function v(_) {
    const x = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof _ == "number" || typeof _ == "boolean" ? (x.boundary = 4, x.storage = 4) : _.isVector2 ? (x.boundary = 8, x.storage = 8) : _.isVector3 || _.isColor ? (x.boundary = 16, x.storage = 12) : _.isVector4 ? (x.boundary = 16, x.storage = 16) : _.isMatrix3 ? (x.boundary = 48, x.storage = 48) : _.isMatrix4 ? (x.boundary = 64, x.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), x;
  }
  function y(_) {
    const x = _.target;
    x.removeEventListener("dispose", y);
    const b = o.indexOf(x.__bindingPointIndex);
    o.splice(b, 1), r.deleteBuffer(s[x.id]), delete s[x.id], delete a[x.id];
  }
  function g() {
    for (const _ in s)
      r.deleteBuffer(s[_]);
    o = [], s = {}, a = {};
  }
  return {
    bind: u,
    update: c,
    dispose: g
  };
}
class _j {
  constructor(e = {}) {
    const {
      canvas: i = cB(),
      context: n = null,
      depth: s = !0,
      stencil: a = !1,
      alpha: o = !1,
      antialias: l = !1,
      premultipliedAlpha: u = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: d = !1,
      reverseDepthBuffer: p = !1
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    if (n !== null) {
      if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      f = n.getContextAttributes().alpha;
    } else
      f = o;
    const m = new Uint32Array(4), v = new Int32Array(4);
    let y = null, g = null;
    const _ = [], x = [];
    this.domElement = i, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = sn, this.toneMapping = lo, this.toneMappingExposure = 1;
    const b = this;
    let T = !1, S = 0, w = 0, A = null, E = -1, M = null;
    const N = new Fi(), k = new Fi();
    let U = null;
    const C = new kt(0);
    let O = 0, D = i.width, H = i.height, j = 1, K = null, L = null;
    const B = new Fi(0, 0, D, H), Q = new Fi(0, 0, D, H);
    let W = !1;
    const z = new P_();
    let X = !1, ae = !1;
    const ue = new ui(), ge = new ui(), we = new q(), Ne = new Fi(), lt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let be = !1;
    function bt() {
      return A === null ? j : 1;
    }
    let Y = n;
    function Gt(I, G) {
      return i.getContext(I, G);
    }
    try {
      const I = {
        alpha: !0,
        depth: s,
        stencil: a,
        antialias: l,
        premultipliedAlpha: u,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: d
      };
      if ("setAttribute" in i && i.setAttribute("data-engine", `three.js r${gg}`), i.addEventListener("webglcontextlost", Se, !1), i.addEventListener("webglcontextrestored", ze, !1), i.addEventListener("webglcontextcreationerror", ke, !1), Y === null) {
        const G = "webgl2";
        if (Y = Gt(G, I), Y === null)
          throw Gt(G) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (I) {
      throw console.error("THREE.WebGLRenderer: " + I.message), I;
    }
    let Xe, yt, rt, Nt, nt, F, P, le, Te, Ae, xe, Je, Be, qe, Pt, Ie, $e, ut, ft, Ye, Ot, xt, Bt, ee;
    function Le() {
      Xe = new M4(Y), Xe.init(), xt = new hj(Y, Xe), yt = new x4(Y, Xe, e, xt), rt = new lj(Y, Xe), yt.reverseDepthBuffer && p && rt.buffers.depth.setReversed(!0), Nt = new R4(Y), nt = new X6(), F = new cj(Y, Xe, rt, nt, yt, xt, Nt), P = new T4(b), le = new E4(b), Te = new UB(Y), Bt = new v4(Y, Te), Ae = new A4(Y, Te, Nt, Bt), xe = new P4(Y, Ae, Te, Nt), ft = new N4(Y, yt, F), Ie = new _4(nt), Je = new q6(b, P, le, Xe, yt, Bt, Ie), Be = new bj(b, nt), qe = new Y6(), Pt = new tj(Xe), ut = new y4(b, P, le, rt, xe, f, u), $e = new aj(b, xe, yt), ee = new xj(Y, Nt, yt, rt), Ye = new b4(Y, Xe, Nt), Ot = new C4(Y, Xe, Nt), Nt.programs = Je.programs, b.capabilities = yt, b.extensions = Xe, b.properties = nt, b.renderLists = qe, b.shadowMap = $e, b.state = rt, b.info = Nt;
    }
    Le();
    const de = new yj(b, Y);
    this.xr = de, this.getContext = function() {
      return Y;
    }, this.getContextAttributes = function() {
      return Y.getContextAttributes();
    }, this.forceContextLoss = function() {
      const I = Xe.get("WEBGL_lose_context");
      I && I.loseContext();
    }, this.forceContextRestore = function() {
      const I = Xe.get("WEBGL_lose_context");
      I && I.restoreContext();
    }, this.getPixelRatio = function() {
      return j;
    }, this.setPixelRatio = function(I) {
      I !== void 0 && (j = I, this.setSize(D, H, !1));
    }, this.getSize = function(I) {
      return I.set(D, H);
    }, this.setSize = function(I, G, te = !0) {
      if (de.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      D = I, H = G, i.width = Math.floor(I * j), i.height = Math.floor(G * j), te === !0 && (i.style.width = I + "px", i.style.height = G + "px"), this.setViewport(0, 0, I, G);
    }, this.getDrawingBufferSize = function(I) {
      return I.set(D * j, H * j).floor();
    }, this.setDrawingBufferSize = function(I, G, te) {
      D = I, H = G, j = te, i.width = Math.floor(I * te), i.height = Math.floor(G * te), this.setViewport(0, 0, I, G);
    }, this.getCurrentViewport = function(I) {
      return I.copy(N);
    }, this.getViewport = function(I) {
      return I.copy(B);
    }, this.setViewport = function(I, G, te, se) {
      I.isVector4 ? B.set(I.x, I.y, I.z, I.w) : B.set(I, G, te, se), rt.viewport(N.copy(B).multiplyScalar(j).round());
    }, this.getScissor = function(I) {
      return I.copy(Q);
    }, this.setScissor = function(I, G, te, se) {
      I.isVector4 ? Q.set(I.x, I.y, I.z, I.w) : Q.set(I, G, te, se), rt.scissor(k.copy(Q).multiplyScalar(j).round());
    }, this.getScissorTest = function() {
      return W;
    }, this.setScissorTest = function(I) {
      rt.setScissorTest(W = I);
    }, this.setOpaqueSort = function(I) {
      K = I;
    }, this.setTransparentSort = function(I) {
      L = I;
    }, this.getClearColor = function(I) {
      return I.copy(ut.getClearColor());
    }, this.setClearColor = function() {
      ut.setClearColor.apply(ut, arguments);
    }, this.getClearAlpha = function() {
      return ut.getClearAlpha();
    }, this.setClearAlpha = function() {
      ut.setClearAlpha.apply(ut, arguments);
    }, this.clear = function(I = !0, G = !0, te = !0) {
      let se = 0;
      if (I) {
        let Z = !1;
        if (A !== null) {
          const Ee = A.texture.format;
          Z = Ee === A_ || Ee === M_ || Ee === E_;
        }
        if (Z) {
          const Ee = A.texture.type, Re = Ee === xa || Ee === xl || Ee === ud || Ee === fc || Ee === S_ || Ee === w_, Ke = ut.getClearColor(), tt = ut.getClearAlpha(), gt = Ke.r, St = Ke.g, ht = Ke.b;
          Re ? (m[0] = gt, m[1] = St, m[2] = ht, m[3] = tt, Y.clearBufferuiv(Y.COLOR, 0, m)) : (v[0] = gt, v[1] = St, v[2] = ht, v[3] = tt, Y.clearBufferiv(Y.COLOR, 0, v));
        } else
          se |= Y.COLOR_BUFFER_BIT;
      }
      G && (se |= Y.DEPTH_BUFFER_BIT), te && (se |= Y.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Y.clear(se);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      i.removeEventListener("webglcontextlost", Se, !1), i.removeEventListener("webglcontextrestored", ze, !1), i.removeEventListener("webglcontextcreationerror", ke, !1), qe.dispose(), Pt.dispose(), nt.dispose(), P.dispose(), le.dispose(), xe.dispose(), Bt.dispose(), ee.dispose(), Je.dispose(), de.dispose(), de.removeEventListener("sessionstart", Ca), de.removeEventListener("sessionend", Ra), Mn.stop();
    };
    function Se(I) {
      I.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), T = !0;
    }
    function ze() {
      console.log("THREE.WebGLRenderer: Context Restored."), T = !1;
      const I = Nt.autoReset, G = $e.enabled, te = $e.autoUpdate, se = $e.needsUpdate, Z = $e.type;
      Le(), Nt.autoReset = I, $e.enabled = G, $e.autoUpdate = te, $e.needsUpdate = se, $e.type = Z;
    }
    function ke(I) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", I.statusMessage);
    }
    function At(I) {
      const G = I.target;
      G.removeEventListener("dispose", At), ri(G);
    }
    function ri(I) {
      _i(I), nt.remove(I);
    }
    function _i(I) {
      const G = nt.get(I).programs;
      G !== void 0 && (G.forEach(function(te) {
        Je.releaseProgram(te);
      }), I.isShaderMaterial && Je.releaseShaderCache(I));
    }
    this.renderBufferDirect = function(I, G, te, se, Z, Ee) {
      G === null && (G = lt);
      const Re = Z.isMesh && Z.matrixWorld.determinant() < 0, Ke = st(I, G, te, se, Z);
      rt.setMaterial(se, Re);
      let tt = te.index, gt = 1;
      if (se.wireframe === !0) {
        if (tt = Ae.getWireframeAttribute(te), tt === void 0) return;
        gt = 2;
      }
      const St = te.drawRange, ht = te.attributes.position;
      let Ht = St.start * gt, ci = (St.start + St.count) * gt;
      Ee !== null && (Ht = Math.max(Ht, Ee.start * gt), ci = Math.min(ci, (Ee.start + Ee.count) * gt)), tt !== null ? (Ht = Math.max(Ht, 0), ci = Math.min(ci, tt.count)) : ht != null && (Ht = Math.max(Ht, 0), ci = Math.min(ci, ht.count));
      const hi = ci - Ht;
      if (hi < 0 || hi === 1 / 0) return;
      Bt.setup(Z, se, Ke, te, tt);
      let Ni, di = Ye;
      if (tt !== null && (Ni = Te.get(tt), di = Ot, di.setIndex(Ni)), Z.isMesh)
        se.wireframe === !0 ? (rt.setLineWidth(se.wireframeLinewidth * bt()), di.setMode(Y.LINES)) : di.setMode(Y.TRIANGLES);
      else if (Z.isLine) {
        let ot = se.linewidth;
        ot === void 0 && (ot = 1), rt.setLineWidth(ot * bt()), Z.isLineSegments ? di.setMode(Y.LINES) : Z.isLineLoop ? di.setMode(Y.LINE_LOOP) : di.setMode(Y.LINE_STRIP);
      } else Z.isPoints ? di.setMode(Y.POINTS) : Z.isSprite && di.setMode(Y.TRIANGLES);
      if (Z.isBatchedMesh)
        if (Z._multiDrawInstances !== null)
          di.renderMultiDrawInstances(Z._multiDrawStarts, Z._multiDrawCounts, Z._multiDrawCount, Z._multiDrawInstances);
        else if (Xe.get("WEBGL_multi_draw"))
          di.renderMultiDraw(Z._multiDrawStarts, Z._multiDrawCounts, Z._multiDrawCount);
        else {
          const ot = Z._multiDrawStarts, Ao = Z._multiDrawCounts, Co = Z._multiDrawCount, An = tt ? Te.get(tt).bytesPerElement : 1, Fl = nt.get(se).currentProgram.getUniforms();
          for (let Yr = 0; Yr < Co; Yr++)
            Fl.setValue(Y, "_gl_DrawID", Yr), di.render(ot[Yr] / An, Ao[Yr]);
        }
      else if (Z.isInstancedMesh)
        di.renderInstances(Ht, hi, Z.count);
      else if (te.isInstancedBufferGeometry) {
        const ot = te._maxInstanceCount !== void 0 ? te._maxInstanceCount : 1 / 0, Ao = Math.min(te.instanceCount, ot);
        di.renderInstances(Ht, hi, Ao);
      } else
        di.render(Ht, hi);
    };
    function Ft(I, G, te) {
      I.transparent === !0 && I.side === Qs && I.forceSinglePass === !1 ? (I.side = Ar, I.needsUpdate = !0, ce(I, G, te), I.side = mo, I.needsUpdate = !0, ce(I, G, te), I.side = Qs) : ce(I, G, te);
    }
    this.compile = function(I, G, te = null) {
      te === null && (te = I), g = Pt.get(te), g.init(G), x.push(g), te.traverseVisible(function(Z) {
        Z.isLight && Z.layers.test(G.layers) && (g.pushLight(Z), Z.castShadow && g.pushShadow(Z));
      }), I !== te && I.traverseVisible(function(Z) {
        Z.isLight && Z.layers.test(G.layers) && (g.pushLight(Z), Z.castShadow && g.pushShadow(Z));
      }), g.setupLights();
      const se = /* @__PURE__ */ new Set();
      return I.traverse(function(Z) {
        if (!(Z.isMesh || Z.isPoints || Z.isLine || Z.isSprite))
          return;
        const Ee = Z.material;
        if (Ee)
          if (Array.isArray(Ee))
            for (let Re = 0; Re < Ee.length; Re++) {
              const Ke = Ee[Re];
              Ft(Ke, te, Z), se.add(Ke);
            }
          else
            Ft(Ee, te, Z), se.add(Ee);
      }), x.pop(), g = null, se;
    }, this.compileAsync = function(I, G, te = null) {
      const se = this.compile(I, G, te);
      return new Promise((Z) => {
        function Ee() {
          if (se.forEach(function(Re) {
            nt.get(Re).currentProgram.isReady() && se.delete(Re);
          }), se.size === 0) {
            Z(I);
            return;
          }
          setTimeout(Ee, 10);
        }
        Xe.get("KHR_parallel_shader_compile") !== null ? Ee() : setTimeout(Ee, 10);
      });
    };
    let vr = null;
    function $r(I) {
      vr && vr(I);
    }
    function Ca() {
      Mn.stop();
    }
    function Ra() {
      Mn.start();
    }
    const Mn = new lR();
    Mn.setAnimationLoop($r), typeof self < "u" && Mn.setContext(self), this.setAnimationLoop = function(I) {
      vr = I, de.setAnimationLoop(I), I === null ? Mn.stop() : Mn.start();
    }, de.addEventListener("sessionstart", Ca), de.addEventListener("sessionend", Ra), this.render = function(I, G) {
      if (G !== void 0 && G.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (T === !0) return;
      if (I.matrixWorldAutoUpdate === !0 && I.updateMatrixWorld(), G.parent === null && G.matrixWorldAutoUpdate === !0 && G.updateMatrixWorld(), de.enabled === !0 && de.isPresenting === !0 && (de.cameraAutoUpdate === !0 && de.updateCamera(G), G = de.getCamera()), I.isScene === !0 && I.onBeforeRender(b, I, G, A), g = Pt.get(I, x.length), g.init(G), x.push(g), ge.multiplyMatrices(G.projectionMatrix, G.matrixWorldInverse), z.setFromProjectionMatrix(ge), ae = this.localClippingEnabled, X = Ie.init(this.clippingPlanes, ae), y = qe.get(I, _.length), y.init(), _.push(y), de.enabled === !0 && de.isPresenting === !0) {
        const Ee = b.xr.getDepthSensingMesh();
        Ee !== null && Mo(Ee, G, -1 / 0, b.sortObjects);
      }
      Mo(I, G, 0, b.sortObjects), y.finish(), b.sortObjects === !0 && y.sort(K, L), be = de.enabled === !1 || de.isPresenting === !1 || de.hasDepthSensing() === !1, be && ut.addToRenderList(y, I), this.info.render.frame++, X === !0 && Ie.beginShadows();
      const te = g.state.shadowsArray;
      $e.render(te, I, G), X === !0 && Ie.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const se = y.opaque, Z = y.transmissive;
      if (g.setupLights(), G.isArrayCamera) {
        const Ee = G.cameras;
        if (Z.length > 0)
          for (let Re = 0, Ke = Ee.length; Re < Ke; Re++) {
            const tt = Ee[Re];
            kl(se, Z, I, tt);
          }
        be && ut.render(I);
        for (let Re = 0, Ke = Ee.length; Re < Ke; Re++) {
          const tt = Ee[Re];
          Ul(y, I, tt, tt.viewport);
        }
      } else
        Z.length > 0 && kl(se, Z, I, G), be && ut.render(I), Ul(y, I, G);
      A !== null && (F.updateMultisampleRenderTarget(A), F.updateRenderTargetMipmap(A)), I.isScene === !0 && I.onAfterRender(b, I, G), Bt.resetDefaultState(), E = -1, M = null, x.pop(), x.length > 0 ? (g = x[x.length - 1], X === !0 && Ie.setGlobalState(b.clippingPlanes, g.state.camera)) : g = null, _.pop(), _.length > 0 ? y = _[_.length - 1] : y = null;
    };
    function Mo(I, G, te, se) {
      if (I.visible === !1) return;
      if (I.layers.test(G.layers)) {
        if (I.isGroup)
          te = I.renderOrder;
        else if (I.isLOD)
          I.autoUpdate === !0 && I.update(G);
        else if (I.isLight)
          g.pushLight(I), I.castShadow && g.pushShadow(I);
        else if (I.isSprite) {
          if (!I.frustumCulled || z.intersectsSprite(I)) {
            se && Ne.setFromMatrixPosition(I.matrixWorld).applyMatrix4(ge);
            const Ee = xe.update(I), Re = I.material;
            Re.visible && y.push(I, Ee, Re, te, Ne.z, null);
          }
        } else if ((I.isMesh || I.isLine || I.isPoints) && (!I.frustumCulled || z.intersectsObject(I))) {
          const Ee = xe.update(I), Re = I.material;
          if (se && (I.boundingSphere !== void 0 ? (I.boundingSphere === null && I.computeBoundingSphere(), Ne.copy(I.boundingSphere.center)) : (Ee.boundingSphere === null && Ee.computeBoundingSphere(), Ne.copy(Ee.boundingSphere.center)), Ne.applyMatrix4(I.matrixWorld).applyMatrix4(ge)), Array.isArray(Re)) {
            const Ke = Ee.groups;
            for (let tt = 0, gt = Ke.length; tt < gt; tt++) {
              const St = Ke[tt], ht = Re[St.materialIndex];
              ht && ht.visible && y.push(I, Ee, ht, te, Ne.z, St);
            }
          } else Re.visible && y.push(I, Ee, Re, te, Ne.z, null);
        }
      }
      const Z = I.children;
      for (let Ee = 0, Re = Z.length; Ee < Re; Ee++)
        Mo(Z[Ee], G, te, se);
    }
    function Ul(I, G, te, se) {
      const Z = I.opaque, Ee = I.transmissive, Re = I.transparent;
      g.setupLightsView(te), X === !0 && Ie.setGlobalState(b.clippingPlanes, te), se && rt.viewport(N.copy(se)), Z.length > 0 && R(Z, G, te), Ee.length > 0 && R(Ee, G, te), Re.length > 0 && R(Re, G, te), rt.buffers.depth.setTest(!0), rt.buffers.depth.setMask(!0), rt.buffers.color.setMask(!0), rt.setPolygonOffset(!1);
    }
    function kl(I, G, te, se) {
      if ((te.isScene === !0 ? te.overrideMaterial : null) !== null)
        return;
      g.state.transmissionRenderTarget[se.id] === void 0 && (g.state.transmissionRenderTarget[se.id] = new go(1, 1, {
        generateMipmaps: !0,
        type: Xe.has("EXT_color_buffer_half_float") || Xe.has("EXT_color_buffer_float") ? Dc : xa,
        minFilter: rl,
        samples: 4,
        stencilBuffer: a,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: Vt.workingColorSpace
      }));
      const Z = g.state.transmissionRenderTarget[se.id], Ee = se.viewport || N;
      Z.setSize(Ee.z, Ee.w);
      const Re = b.getRenderTarget();
      b.setRenderTarget(Z), b.getClearColor(C), O = b.getClearAlpha(), O < 1 && b.setClearColor(16777215, 0.5), b.clear(), be && ut.render(te);
      const Ke = b.toneMapping;
      b.toneMapping = lo;
      const tt = se.viewport;
      if (se.viewport !== void 0 && (se.viewport = void 0), g.setupLightsView(se), X === !0 && Ie.setGlobalState(b.clippingPlanes, se), R(I, te, se), F.updateMultisampleRenderTarget(Z), F.updateRenderTargetMipmap(Z), Xe.has("WEBGL_multisampled_render_to_texture") === !1) {
        let gt = !1;
        for (let St = 0, ht = G.length; St < ht; St++) {
          const Ht = G[St], ci = Ht.object, hi = Ht.geometry, Ni = Ht.material, di = Ht.group;
          if (Ni.side === Qs && ci.layers.test(se.layers)) {
            const ot = Ni.side;
            Ni.side = Ar, Ni.needsUpdate = !0, J(ci, te, se, hi, Ni, di), Ni.side = ot, Ni.needsUpdate = !0, gt = !0;
          }
        }
        gt === !0 && (F.updateMultisampleRenderTarget(Z), F.updateRenderTargetMipmap(Z));
      }
      b.setRenderTarget(Re), b.setClearColor(C, O), tt !== void 0 && (se.viewport = tt), b.toneMapping = Ke;
    }
    function R(I, G, te) {
      const se = G.isScene === !0 ? G.overrideMaterial : null;
      for (let Z = 0, Ee = I.length; Z < Ee; Z++) {
        const Re = I[Z], Ke = Re.object, tt = Re.geometry, gt = se === null ? Re.material : se, St = Re.group;
        Ke.layers.test(te.layers) && J(Ke, G, te, tt, gt, St);
      }
    }
    function J(I, G, te, se, Z, Ee) {
      I.onBeforeRender(b, G, te, se, Z, Ee), I.modelViewMatrix.multiplyMatrices(te.matrixWorldInverse, I.matrixWorld), I.normalMatrix.getNormalMatrix(I.modelViewMatrix), Z.onBeforeRender(b, G, te, se, I, Ee), Z.transparent === !0 && Z.side === Qs && Z.forceSinglePass === !1 ? (Z.side = Ar, Z.needsUpdate = !0, b.renderBufferDirect(te, G, se, Z, I, Ee), Z.side = mo, Z.needsUpdate = !0, b.renderBufferDirect(te, G, se, Z, I, Ee), Z.side = Qs) : b.renderBufferDirect(te, G, se, Z, I, Ee), I.onAfterRender(b, G, te, se, Z, Ee);
    }
    function ce(I, G, te) {
      G.isScene !== !0 && (G = lt);
      const se = nt.get(I), Z = g.state.lights, Ee = g.state.shadowsArray, Re = Z.state.version, Ke = Je.getParameters(I, Z.state, Ee, G, te), tt = Je.getProgramCacheKey(Ke);
      let gt = se.programs;
      se.environment = I.isMeshStandardMaterial ? G.environment : null, se.fog = G.fog, se.envMap = (I.isMeshStandardMaterial ? le : P).get(I.envMap || se.environment), se.envMapRotation = se.environment !== null && I.envMap === null ? G.environmentRotation : I.envMapRotation, gt === void 0 && (I.addEventListener("dispose", At), gt = /* @__PURE__ */ new Map(), se.programs = gt);
      let St = gt.get(tt);
      if (St !== void 0) {
        if (se.currentProgram === St && se.lightsStateVersion === Re)
          return Ze(I, Ke), St;
      } else
        Ke.uniforms = Je.getUniforms(I), I.onBeforeCompile(Ke, b), St = Je.acquireProgram(Ke, tt), gt.set(tt, St), se.uniforms = Ke.uniforms;
      const ht = se.uniforms;
      return (!I.isShaderMaterial && !I.isRawShaderMaterial || I.clipping === !0) && (ht.clippingPlanes = Ie.uniform), Ze(I, Ke), se.needsLights = Ge(I), se.lightsStateVersion = Re, se.needsLights && (ht.ambientLightColor.value = Z.state.ambient, ht.lightProbe.value = Z.state.probe, ht.directionalLights.value = Z.state.directional, ht.directionalLightShadows.value = Z.state.directionalShadow, ht.spotLights.value = Z.state.spot, ht.spotLightShadows.value = Z.state.spotShadow, ht.rectAreaLights.value = Z.state.rectArea, ht.ltc_1.value = Z.state.rectAreaLTC1, ht.ltc_2.value = Z.state.rectAreaLTC2, ht.pointLights.value = Z.state.point, ht.pointLightShadows.value = Z.state.pointShadow, ht.hemisphereLights.value = Z.state.hemi, ht.directionalShadowMap.value = Z.state.directionalShadowMap, ht.directionalShadowMatrix.value = Z.state.directionalShadowMatrix, ht.spotShadowMap.value = Z.state.spotShadowMap, ht.spotLightMatrix.value = Z.state.spotLightMatrix, ht.spotLightMap.value = Z.state.spotLightMap, ht.pointShadowMap.value = Z.state.pointShadowMap, ht.pointShadowMatrix.value = Z.state.pointShadowMatrix), se.currentProgram = St, se.uniformsList = null, St;
    }
    function Ce(I) {
      if (I.uniformsList === null) {
        const G = I.currentProgram.getUniforms();
        I.uniformsList = Kf.seqWithValue(G.seq, I.uniforms);
      }
      return I.uniformsList;
    }
    function Ze(I, G) {
      const te = nt.get(I);
      te.outputColorSpace = G.outputColorSpace, te.batching = G.batching, te.batchingColor = G.batchingColor, te.instancing = G.instancing, te.instancingColor = G.instancingColor, te.instancingMorph = G.instancingMorph, te.skinning = G.skinning, te.morphTargets = G.morphTargets, te.morphNormals = G.morphNormals, te.morphColors = G.morphColors, te.morphTargetsCount = G.morphTargetsCount, te.numClippingPlanes = G.numClippingPlanes, te.numIntersection = G.numClipIntersection, te.vertexAlphas = G.vertexAlphas, te.vertexTangents = G.vertexTangents, te.toneMapping = G.toneMapping;
    }
    function st(I, G, te, se, Z) {
      G.isScene !== !0 && (G = lt), F.resetTextureUnits();
      const Ee = G.fog, Re = se.isMeshStandardMaterial ? G.environment : null, Ke = A === null ? b.outputColorSpace : A.isXRRenderTarget === !0 ? A.texture.colorSpace : Lc, tt = (se.isMeshStandardMaterial ? le : P).get(se.envMap || Re), gt = se.vertexColors === !0 && !!te.attributes.color && te.attributes.color.itemSize === 4, St = !!te.attributes.tangent && (!!se.normalMap || se.anisotropy > 0), ht = !!te.morphAttributes.position, Ht = !!te.morphAttributes.normal, ci = !!te.morphAttributes.color;
      let hi = lo;
      se.toneMapped && (A === null || A.isXRRenderTarget === !0) && (hi = b.toneMapping);
      const Ni = te.morphAttributes.position || te.morphAttributes.normal || te.morphAttributes.color, di = Ni !== void 0 ? Ni.length : 0, ot = nt.get(se), Ao = g.state.lights;
      if (X === !0 && (ae === !0 || I !== M)) {
        const Ir = I === M && se.id === E;
        Ie.setState(se, I, Ir);
      }
      let Co = !1;
      se.version === ot.__version ? (ot.needsLights && ot.lightsStateVersion !== Ao.state.version || ot.outputColorSpace !== Ke || Z.isBatchedMesh && ot.batching === !1 || !Z.isBatchedMesh && ot.batching === !0 || Z.isBatchedMesh && ot.batchingColor === !0 && Z.colorTexture === null || Z.isBatchedMesh && ot.batchingColor === !1 && Z.colorTexture !== null || Z.isInstancedMesh && ot.instancing === !1 || !Z.isInstancedMesh && ot.instancing === !0 || Z.isSkinnedMesh && ot.skinning === !1 || !Z.isSkinnedMesh && ot.skinning === !0 || Z.isInstancedMesh && ot.instancingColor === !0 && Z.instanceColor === null || Z.isInstancedMesh && ot.instancingColor === !1 && Z.instanceColor !== null || Z.isInstancedMesh && ot.instancingMorph === !0 && Z.morphTexture === null || Z.isInstancedMesh && ot.instancingMorph === !1 && Z.morphTexture !== null || ot.envMap !== tt || se.fog === !0 && ot.fog !== Ee || ot.numClippingPlanes !== void 0 && (ot.numClippingPlanes !== Ie.numPlanes || ot.numIntersection !== Ie.numIntersection) || ot.vertexAlphas !== gt || ot.vertexTangents !== St || ot.morphTargets !== ht || ot.morphNormals !== Ht || ot.morphColors !== ci || ot.toneMapping !== hi || ot.morphTargetsCount !== di) && (Co = !0) : (Co = !0, ot.__version = se.version);
      let An = ot.currentProgram;
      Co === !0 && (An = ce(se, G, Z));
      let Fl = !1, Yr = !1, Wc = !1;
      const ai = An.getUniforms(), is = ot.uniforms;
      if (rt.useProgram(An.program) && (Fl = !0, Yr = !0, Wc = !0), se.id !== E && (E = se.id, Yr = !0), Fl || M !== I) {
        rt.buffers.depth.getReversed() ? (ue.copy(I.projectionMatrix), dB(ue), pB(ue), ai.setValue(Y, "projectionMatrix", ue)) : ai.setValue(Y, "projectionMatrix", I.projectionMatrix), ai.setValue(Y, "viewMatrix", I.matrixWorldInverse);
        const Ir = ai.map.cameraPosition;
        Ir !== void 0 && Ir.setValue(Y, we.setFromMatrixPosition(I.matrixWorld)), yt.logarithmicDepthBuffer && ai.setValue(
          Y,
          "logDepthBufFC",
          2 / (Math.log(I.far + 1) / Math.LN2)
        ), (se.isMeshPhongMaterial || se.isMeshToonMaterial || se.isMeshLambertMaterial || se.isMeshBasicMaterial || se.isMeshStandardMaterial || se.isShaderMaterial) && ai.setValue(Y, "isOrthographic", I.isOrthographicCamera === !0), M !== I && (M = I, Yr = !0, Wc = !0);
      }
      if (Z.isSkinnedMesh) {
        ai.setOptional(Y, Z, "bindMatrix"), ai.setOptional(Y, Z, "bindMatrixInverse");
        const Ir = Z.skeleton;
        Ir && (Ir.boneTexture === null && Ir.computeBoneTexture(), ai.setValue(Y, "boneTexture", Ir.boneTexture, F));
      }
      Z.isBatchedMesh && (ai.setOptional(Y, Z, "batchingTexture"), ai.setValue(Y, "batchingTexture", Z._matricesTexture, F), ai.setOptional(Y, Z, "batchingIdTexture"), ai.setValue(Y, "batchingIdTexture", Z._indirectTexture, F), ai.setOptional(Y, Z, "batchingColorTexture"), Z._colorsTexture !== null && ai.setValue(Y, "batchingColorTexture", Z._colorsTexture, F));
      const qc = te.morphAttributes;
      if ((qc.position !== void 0 || qc.normal !== void 0 || qc.color !== void 0) && ft.update(Z, te, An), (Yr || ot.receiveShadow !== Z.receiveShadow) && (ot.receiveShadow = Z.receiveShadow, ai.setValue(Y, "receiveShadow", Z.receiveShadow)), se.isMeshGouraudMaterial && se.envMap !== null && (is.envMap.value = tt, is.flipEnvMap.value = tt.isCubeTexture && tt.isRenderTargetTexture === !1 ? -1 : 1), se.isMeshStandardMaterial && se.envMap === null && G.environment !== null && (is.envMapIntensity.value = G.environmentIntensity), Yr && (ai.setValue(Y, "toneMappingExposure", b.toneMappingExposure), ot.needsLights && We(is, Wc), Ee && se.fog === !0 && Be.refreshFogUniforms(is, Ee), Be.refreshMaterialUniforms(is, se, j, H, g.state.transmissionRenderTarget[I.id]), Kf.upload(Y, Ce(ot), is, F)), se.isShaderMaterial && se.uniformsNeedUpdate === !0 && (Kf.upload(Y, Ce(ot), is, F), se.uniformsNeedUpdate = !1), se.isSpriteMaterial && ai.setValue(Y, "center", Z.center), ai.setValue(Y, "modelViewMatrix", Z.modelViewMatrix), ai.setValue(Y, "normalMatrix", Z.normalMatrix), ai.setValue(Y, "modelMatrix", Z.matrixWorld), se.isShaderMaterial || se.isRawShaderMaterial) {
        const Ir = se.uniformsGroups;
        for (let Xc = 0, Na = Ir.length; Xc < Na; Xc++) {
          const cS = Ir[Xc];
          ee.update(cS, An), ee.bind(cS, An);
        }
      }
      return An;
    }
    function We(I, G) {
      I.ambientLightColor.needsUpdate = G, I.lightProbe.needsUpdate = G, I.directionalLights.needsUpdate = G, I.directionalLightShadows.needsUpdate = G, I.pointLights.needsUpdate = G, I.pointLightShadows.needsUpdate = G, I.spotLights.needsUpdate = G, I.spotLightShadows.needsUpdate = G, I.rectAreaLights.needsUpdate = G, I.hemisphereLights.needsUpdate = G;
    }
    function Ge(I) {
      return I.isMeshLambertMaterial || I.isMeshToonMaterial || I.isMeshPhongMaterial || I.isMeshStandardMaterial || I.isShadowMaterial || I.isShaderMaterial && I.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return S;
    }, this.getActiveMipmapLevel = function() {
      return w;
    }, this.getRenderTarget = function() {
      return A;
    }, this.setRenderTargetTextures = function(I, G, te) {
      nt.get(I.texture).__webglTexture = G, nt.get(I.depthTexture).__webglTexture = te;
      const se = nt.get(I);
      se.__hasExternalTextures = !0, se.__autoAllocateDepthBuffer = te === void 0, se.__autoAllocateDepthBuffer || Xe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), se.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(I, G) {
      const te = nt.get(I);
      te.__webglFramebuffer = G, te.__useDefaultFramebuffer = G === void 0;
    }, this.setRenderTarget = function(I, G = 0, te = 0) {
      A = I, S = G, w = te;
      let se = !0, Z = null, Ee = !1, Re = !1;
      if (I) {
        const Ke = nt.get(I);
        if (Ke.__useDefaultFramebuffer !== void 0)
          rt.bindFramebuffer(Y.FRAMEBUFFER, null), se = !1;
        else if (Ke.__webglFramebuffer === void 0)
          F.setupRenderTarget(I);
        else if (Ke.__hasExternalTextures)
          F.rebindTextures(I, nt.get(I.texture).__webglTexture, nt.get(I.depthTexture).__webglTexture);
        else if (I.depthBuffer) {
          const St = I.depthTexture;
          if (Ke.__boundDepthTexture !== St) {
            if (St !== null && nt.has(St) && (I.width !== St.image.width || I.height !== St.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            F.setupDepthRenderbuffer(I);
          }
        }
        const tt = I.texture;
        (tt.isData3DTexture || tt.isDataArrayTexture || tt.isCompressedArrayTexture) && (Re = !0);
        const gt = nt.get(I).__webglFramebuffer;
        I.isWebGLCubeRenderTarget ? (Array.isArray(gt[G]) ? Z = gt[G][te] : Z = gt[G], Ee = !0) : I.samples > 0 && F.useMultisampledRTT(I) === !1 ? Z = nt.get(I).__webglMultisampledFramebuffer : Array.isArray(gt) ? Z = gt[te] : Z = gt, N.copy(I.viewport), k.copy(I.scissor), U = I.scissorTest;
      } else
        N.copy(B).multiplyScalar(j).floor(), k.copy(Q).multiplyScalar(j).floor(), U = W;
      if (rt.bindFramebuffer(Y.FRAMEBUFFER, Z) && se && rt.drawBuffers(I, Z), rt.viewport(N), rt.scissor(k), rt.setScissorTest(U), Ee) {
        const Ke = nt.get(I.texture);
        Y.framebufferTexture2D(Y.FRAMEBUFFER, Y.COLOR_ATTACHMENT0, Y.TEXTURE_CUBE_MAP_POSITIVE_X + G, Ke.__webglTexture, te);
      } else if (Re) {
        const Ke = nt.get(I.texture), tt = G || 0;
        Y.framebufferTextureLayer(Y.FRAMEBUFFER, Y.COLOR_ATTACHMENT0, Ke.__webglTexture, te || 0, tt);
      }
      E = -1;
    }, this.readRenderTargetPixels = function(I, G, te, se, Z, Ee, Re) {
      if (!(I && I.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Ke = nt.get(I).__webglFramebuffer;
      if (I.isWebGLCubeRenderTarget && Re !== void 0 && (Ke = Ke[Re]), Ke) {
        rt.bindFramebuffer(Y.FRAMEBUFFER, Ke);
        try {
          const tt = I.texture, gt = tt.format, St = tt.type;
          if (!yt.textureFormatReadable(gt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!yt.textureTypeReadable(St)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          G >= 0 && G <= I.width - se && te >= 0 && te <= I.height - Z && Y.readPixels(G, te, se, Z, xt.convert(gt), xt.convert(St), Ee);
        } finally {
          const tt = A !== null ? nt.get(A).__webglFramebuffer : null;
          rt.bindFramebuffer(Y.FRAMEBUFFER, tt);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(I, G, te, se, Z, Ee, Re) {
      if (!(I && I.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Ke = nt.get(I).__webglFramebuffer;
      if (I.isWebGLCubeRenderTarget && Re !== void 0 && (Ke = Ke[Re]), Ke) {
        const tt = I.texture, gt = tt.format, St = tt.type;
        if (!yt.textureFormatReadable(gt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!yt.textureTypeReadable(St))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (G >= 0 && G <= I.width - se && te >= 0 && te <= I.height - Z) {
          rt.bindFramebuffer(Y.FRAMEBUFFER, Ke);
          const ht = Y.createBuffer();
          Y.bindBuffer(Y.PIXEL_PACK_BUFFER, ht), Y.bufferData(Y.PIXEL_PACK_BUFFER, Ee.byteLength, Y.STREAM_READ), Y.readPixels(G, te, se, Z, xt.convert(gt), xt.convert(St), 0);
          const Ht = A !== null ? nt.get(A).__webglFramebuffer : null;
          rt.bindFramebuffer(Y.FRAMEBUFFER, Ht);
          const ci = Y.fenceSync(Y.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return Y.flush(), await hB(Y, ci, 4), Y.bindBuffer(Y.PIXEL_PACK_BUFFER, ht), Y.getBufferSubData(Y.PIXEL_PACK_BUFFER, 0, Ee), Y.deleteBuffer(ht), Y.deleteSync(ci), Ee;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(I, G = null, te = 0) {
      I.isTexture !== !0 && (Uh("WebGLRenderer: copyFramebufferToTexture function signature has changed."), G = arguments[0] || null, I = arguments[1]);
      const se = Math.pow(2, -te), Z = Math.floor(I.image.width * se), Ee = Math.floor(I.image.height * se), Re = G !== null ? G.x : 0, Ke = G !== null ? G.y : 0;
      F.setTexture2D(I, 0), Y.copyTexSubImage2D(Y.TEXTURE_2D, te, 0, 0, Re, Ke, Z, Ee), rt.unbindTexture();
    }, this.copyTextureToTexture = function(I, G, te = null, se = null, Z = 0) {
      I.isTexture !== !0 && (Uh("WebGLRenderer: copyTextureToTexture function signature has changed."), se = arguments[0] || null, I = arguments[1], G = arguments[2], Z = arguments[3] || 0, te = null);
      let Ee, Re, Ke, tt, gt, St, ht, Ht, ci;
      const hi = I.isCompressedTexture ? I.mipmaps[Z] : I.image;
      te !== null ? (Ee = te.max.x - te.min.x, Re = te.max.y - te.min.y, Ke = te.isBox3 ? te.max.z - te.min.z : 1, tt = te.min.x, gt = te.min.y, St = te.isBox3 ? te.min.z : 0) : (Ee = hi.width, Re = hi.height, Ke = hi.depth || 1, tt = 0, gt = 0, St = 0), se !== null ? (ht = se.x, Ht = se.y, ci = se.z) : (ht = 0, Ht = 0, ci = 0);
      const Ni = xt.convert(G.format), di = xt.convert(G.type);
      let ot;
      G.isData3DTexture ? (F.setTexture3D(G, 0), ot = Y.TEXTURE_3D) : G.isDataArrayTexture || G.isCompressedArrayTexture ? (F.setTexture2DArray(G, 0), ot = Y.TEXTURE_2D_ARRAY) : (F.setTexture2D(G, 0), ot = Y.TEXTURE_2D), Y.pixelStorei(Y.UNPACK_FLIP_Y_WEBGL, G.flipY), Y.pixelStorei(Y.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), Y.pixelStorei(Y.UNPACK_ALIGNMENT, G.unpackAlignment);
      const Ao = Y.getParameter(Y.UNPACK_ROW_LENGTH), Co = Y.getParameter(Y.UNPACK_IMAGE_HEIGHT), An = Y.getParameter(Y.UNPACK_SKIP_PIXELS), Fl = Y.getParameter(Y.UNPACK_SKIP_ROWS), Yr = Y.getParameter(Y.UNPACK_SKIP_IMAGES);
      Y.pixelStorei(Y.UNPACK_ROW_LENGTH, hi.width), Y.pixelStorei(Y.UNPACK_IMAGE_HEIGHT, hi.height), Y.pixelStorei(Y.UNPACK_SKIP_PIXELS, tt), Y.pixelStorei(Y.UNPACK_SKIP_ROWS, gt), Y.pixelStorei(Y.UNPACK_SKIP_IMAGES, St);
      const Wc = I.isDataArrayTexture || I.isData3DTexture, ai = G.isDataArrayTexture || G.isData3DTexture;
      if (I.isRenderTargetTexture || I.isDepthTexture) {
        const is = nt.get(I), qc = nt.get(G), Ir = nt.get(is.__renderTarget), Xc = nt.get(qc.__renderTarget);
        rt.bindFramebuffer(Y.READ_FRAMEBUFFER, Ir.__webglFramebuffer), rt.bindFramebuffer(Y.DRAW_FRAMEBUFFER, Xc.__webglFramebuffer);
        for (let Na = 0; Na < Ke; Na++)
          Wc && Y.framebufferTextureLayer(Y.READ_FRAMEBUFFER, Y.COLOR_ATTACHMENT0, nt.get(I).__webglTexture, Z, St + Na), I.isDepthTexture ? (ai && Y.framebufferTextureLayer(Y.DRAW_FRAMEBUFFER, Y.COLOR_ATTACHMENT0, nt.get(G).__webglTexture, Z, ci + Na), Y.blitFramebuffer(tt, gt, Ee, Re, ht, Ht, Ee, Re, Y.DEPTH_BUFFER_BIT, Y.NEAREST)) : ai ? Y.copyTexSubImage3D(ot, Z, ht, Ht, ci + Na, tt, gt, Ee, Re) : Y.copyTexSubImage2D(ot, Z, ht, Ht, ci + Na, tt, gt, Ee, Re);
        rt.bindFramebuffer(Y.READ_FRAMEBUFFER, null), rt.bindFramebuffer(Y.DRAW_FRAMEBUFFER, null);
      } else
        ai ? I.isDataTexture || I.isData3DTexture ? Y.texSubImage3D(ot, Z, ht, Ht, ci, Ee, Re, Ke, Ni, di, hi.data) : G.isCompressedArrayTexture ? Y.compressedTexSubImage3D(ot, Z, ht, Ht, ci, Ee, Re, Ke, Ni, hi.data) : Y.texSubImage3D(ot, Z, ht, Ht, ci, Ee, Re, Ke, Ni, di, hi) : I.isDataTexture ? Y.texSubImage2D(Y.TEXTURE_2D, Z, ht, Ht, Ee, Re, Ni, di, hi.data) : I.isCompressedTexture ? Y.compressedTexSubImage2D(Y.TEXTURE_2D, Z, ht, Ht, hi.width, hi.height, Ni, hi.data) : Y.texSubImage2D(Y.TEXTURE_2D, Z, ht, Ht, Ee, Re, Ni, di, hi);
      Y.pixelStorei(Y.UNPACK_ROW_LENGTH, Ao), Y.pixelStorei(Y.UNPACK_IMAGE_HEIGHT, Co), Y.pixelStorei(Y.UNPACK_SKIP_PIXELS, An), Y.pixelStorei(Y.UNPACK_SKIP_ROWS, Fl), Y.pixelStorei(Y.UNPACK_SKIP_IMAGES, Yr), Z === 0 && G.generateMipmaps && Y.generateMipmap(ot), rt.unbindTexture();
    }, this.copyTextureToTexture3D = function(I, G, te = null, se = null, Z = 0) {
      return I.isTexture !== !0 && (Uh("WebGLRenderer: copyTextureToTexture3D function signature has changed."), te = arguments[0] || null, se = arguments[1] || null, I = arguments[2], G = arguments[3], Z = arguments[4] || 0), Uh('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(I, G, te, se, Z);
    }, this.initRenderTarget = function(I) {
      nt.get(I).__webglFramebuffer === void 0 && F.setupRenderTarget(I);
    }, this.initTexture = function(I) {
      I.isCubeTexture ? F.setTextureCube(I, 0) : I.isData3DTexture ? F.setTexture3D(I, 0) : I.isDataArrayTexture || I.isCompressedArrayTexture ? F.setTexture2DArray(I, 0) : F.setTexture2D(I, 0), rt.unbindTexture();
    }, this.resetState = function() {
      S = 0, w = 0, A = null, rt.reset(), Bt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return sa;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const i = this.getContext();
    i.drawingBufferColorspace = Vt._getDrawingBufferColorSpace(e), i.unpackColorSpace = Vt._getUnpackColorSpace();
  }
}
let Tj = class extends Gr {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new yo(), this.environmentIntensity = 1, this.environmentRotation = new yo(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(r, e) {
    return super.copy(r, e), r.background !== null && (this.background = r.background.clone()), r.environment !== null && (this.environment = r.environment.clone()), r.fog !== null && (this.fog = r.fog.clone()), this.backgroundBlurriness = r.backgroundBlurriness, this.backgroundIntensity = r.backgroundIntensity, this.backgroundRotation.copy(r.backgroundRotation), this.environmentIntensity = r.environmentIntensity, this.environmentRotation.copy(r.environmentRotation), r.overrideMaterial !== null && (this.overrideMaterial = r.overrideMaterial.clone()), this.matrixAutoUpdate = r.matrixAutoUpdate, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
  }
}, Sj = class {
  constructor(r, e) {
    this.isInterleavedBuffer = !0, this.array = r, this.stride = e, this.count = r !== void 0 ? r.length / e : 0, this.usage = Pb, this.updateRanges = [], this.version = 0, this.uuid = ca();
  }
  onUploadCallback() {
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  setUsage(r) {
    return this.usage = r, this;
  }
  addUpdateRange(r, e) {
    this.updateRanges.push({ start: r, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(r) {
    return this.array = new r.array.constructor(r.array), this.count = r.count, this.stride = r.stride, this.usage = r.usage, this;
  }
  copyAt(r, e, i) {
    r *= this.stride, i *= e.stride;
    for (let n = 0, s = this.stride; n < s; n++)
      this.array[r + n] = e.array[i + n];
    return this;
  }
  set(r, e = 0) {
    return this.array.set(r, e), this;
  }
  clone(r) {
    r.arrayBuffers === void 0 && (r.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ca()), r.arrayBuffers[this.array.buffer._uuid] === void 0 && (r.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(r.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(e, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(r) {
    return this.onUploadCallback = r, this;
  }
  toJSON(r) {
    return r.arrayBuffers === void 0 && (r.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ca()), r.arrayBuffers[this.array.buffer._uuid] === void 0 && (r.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
};
const br = /* @__PURE__ */ new q();
let mw = class fR {
  constructor(e, i, n, s = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = i, this.offset = n, this.normalized = s;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.data.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.applyMatrix4(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.applyNormalMatrix(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.transformDirection(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.data.stride + this.offset + i];
    return this.normalized && (n = Hn(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = Qt(n, this.array)), this.data.array[e * this.data.stride + this.offset + i] = n, this;
  }
  setX(e, i) {
    return this.normalized && (i = Qt(i, this.array)), this.data.array[e * this.data.stride + this.offset] = i, this;
  }
  setY(e, i) {
    return this.normalized && (i = Qt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = i, this;
  }
  setZ(e, i) {
    return this.normalized && (i = Qt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = i, this;
  }
  setW(e, i) {
    return this.normalized && (i = Qt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = i, this;
  }
  getX(e) {
    let i = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  getY(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  getZ(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  getW(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  setXY(e, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Qt(i, this.array), n = Qt(n, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Qt(i, this.array), n = Qt(n, this.array), s = Qt(s, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Qt(i, this.array), n = Qt(n, this.array), s = Qt(s, this.array), a = Qt(a, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = a, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return new _n(new this.array.constructor(i), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new fR(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: i,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}, wj = class extends Nl {
  static get type() {
    return "SpriteMaterial";
  }
  constructor(r) {
    super(), this.isSpriteMaterial = !0, this.color = new kt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.alphaMap = r.alphaMap, this.rotation = r.rotation, this.sizeAttenuation = r.sizeAttenuation, this.fog = r.fog, this;
  }
}, eu;
const sh = /* @__PURE__ */ new q(), tu = /* @__PURE__ */ new q(), iu = /* @__PURE__ */ new q(), ru = /* @__PURE__ */ new Ue(), ah = /* @__PURE__ */ new Ue(), mR = /* @__PURE__ */ new ui(), Pp = /* @__PURE__ */ new q(), oh = /* @__PURE__ */ new q(), Ip = /* @__PURE__ */ new q(), gw = /* @__PURE__ */ new Ue(), Wy = /* @__PURE__ */ new Ue(), yw = /* @__PURE__ */ new Ue();
class Ej extends Gr {
  constructor(e = new wj()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", eu === void 0) {
      eu = new cn();
      const i = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new Sj(i, 5);
      eu.setIndex([0, 1, 2, 0, 2, 3]), eu.setAttribute("position", new mw(n, 3, 0, !1)), eu.setAttribute("uv", new mw(n, 2, 3, !1));
    }
    this.geometry = eu, this.material = e, this.center = new Ue(0.5, 0.5);
  }
  raycast(e, i) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), tu.setFromMatrixScale(this.matrixWorld), mR.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), iu.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && tu.multiplyScalar(-iu.z);
    const n = this.material.rotation;
    let s, a;
    n !== 0 && (a = Math.cos(n), s = Math.sin(n));
    const o = this.center;
    Op(Pp.set(-0.5, -0.5, 0), iu, o, tu, s, a), Op(oh.set(0.5, -0.5, 0), iu, o, tu, s, a), Op(Ip.set(0.5, 0.5, 0), iu, o, tu, s, a), gw.set(0, 0), Wy.set(1, 0), yw.set(1, 1);
    let l = e.ray.intersectTriangle(Pp, oh, Ip, !1, sh);
    if (l === null && (Op(oh.set(-0.5, 0.5, 0), iu, o, tu, s, a), Wy.set(0, 1), l = e.ray.intersectTriangle(Pp, Ip, oh, !1, sh), l === null))
      return;
    const u = e.ray.origin.distanceTo(sh);
    u < e.near || u > e.far || i.push({
      distance: u,
      point: sh.clone(),
      uv: Cu.getInterpolation(sh, Pp, oh, Ip, gw, Wy, yw, new Ue()),
      face: null,
      object: this
    });
  }
  copy(e, i) {
    return super.copy(e, i), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Op(r, e, i, n, s, a) {
  ru.subVectors(r, i).addScalar(0.5).multiply(n), s !== void 0 ? (ah.x = a * ru.x - s * ru.y, ah.y = s * ru.x + a * ru.y) : ah.copy(ru), r.copy(e), r.x += ah.x, r.y += ah.y, r.applyMatrix4(mR);
}
let gR = class extends Nl {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(r) {
    super(), this.isLineBasicMaterial = !0, this.color = new kt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.linewidth = r.linewidth, this.linecap = r.linecap, this.linejoin = r.linejoin, this.fog = r.fog, this;
  }
};
const ym = /* @__PURE__ */ new q(), vm = /* @__PURE__ */ new q(), vw = /* @__PURE__ */ new ui(), lh = /* @__PURE__ */ new xg(), Dp = /* @__PURE__ */ new bg(), qy = /* @__PURE__ */ new q(), bw = /* @__PURE__ */ new q();
class Mj extends Gr {
  constructor(e = new cn(), i = new gR()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = i, this.updateMorphTargets();
  }
  copy(e, i) {
    return super.copy(e, i), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const i = e.attributes.position, n = [0];
      for (let s = 1, a = i.count; s < a; s++)
        ym.fromBufferAttribute(i, s - 1), vm.fromBufferAttribute(i, s), n[s] = n[s - 1], n[s] += ym.distanceTo(vm);
      e.setAttribute("lineDistance", new Ri(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, i) {
    const n = this.geometry, s = this.matrixWorld, a = e.params.Line.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Dp.copy(n.boundingSphere), Dp.applyMatrix4(s), Dp.radius += a, e.ray.intersectsSphere(Dp) === !1) return;
    vw.copy(s).invert(), lh.copy(e.ray).applyMatrix4(vw);
    const l = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), u = l * l, c = this.isLineSegments ? 2 : 1, h = n.index, d = n.attributes.position;
    if (h !== null) {
      const p = Math.max(0, o.start), f = Math.min(h.count, o.start + o.count);
      for (let m = p, v = f - 1; m < v; m += c) {
        const y = h.getX(m), g = h.getX(m + 1), _ = Lp(this, e, lh, u, y, g);
        _ && i.push(_);
      }
      if (this.isLineLoop) {
        const m = h.getX(f - 1), v = h.getX(p), y = Lp(this, e, lh, u, m, v);
        y && i.push(y);
      }
    } else {
      const p = Math.max(0, o.start), f = Math.min(d.count, o.start + o.count);
      for (let m = p, v = f - 1; m < v; m += c) {
        const y = Lp(this, e, lh, u, m, m + 1);
        y && i.push(y);
      }
      if (this.isLineLoop) {
        const m = Lp(this, e, lh, u, f - 1, p);
        m && i.push(m);
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, i = Object.keys(e);
    if (i.length > 0) {
      const n = e[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
        }
      }
    }
  }
}
function Lp(r, e, i, n, s, a) {
  const o = r.geometry.attributes.position;
  if (ym.fromBufferAttribute(o, s), vm.fromBufferAttribute(o, a), i.distanceSqToSegment(ym, vm, qy, bw) > n) return;
  qy.applyMatrix4(r.matrixWorld);
  const l = e.ray.origin.distanceTo(qy);
  if (!(l < e.near || l > e.far))
    return {
      distance: l,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: bw.clone().applyMatrix4(r.matrixWorld),
      index: s,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: r
    };
}
class wa {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, i) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, i);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const i = [];
    for (let n = 0; n <= e; n++)
      i.push(this.getPoint(n / e));
    return i;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const i = [];
    for (let n = 0; n <= e; n++)
      i.push(this.getPointAt(n / e));
    return i;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const i = [];
    let n, s = this.getPoint(0), a = 0;
    i.push(0);
    for (let o = 1; o <= e; o++)
      n = this.getPoint(o / e), a += n.distanceTo(s), i.push(a), s = n;
    return this.cacheArcLengths = i, i;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, i) {
    const n = this.getLengths();
    let s = 0;
    const a = n.length;
    let o;
    i ? o = i : o = e * n[a - 1];
    let l = 0, u = a - 1, c;
    for (; l <= u; )
      if (s = Math.floor(l + (u - l) / 2), c = n[s] - o, c < 0)
        l = s + 1;
      else if (c > 0)
        u = s - 1;
      else {
        u = s;
        break;
      }
    if (s = u, n[s] === o)
      return s / (a - 1);
    const h = n[s], d = n[s + 1] - h, p = (o - h) / d;
    return (s + p) / (a - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, i) {
    let n = e - 1e-4, s = e + 1e-4;
    n < 0 && (n = 0), s > 1 && (s = 1);
    const a = this.getPoint(n), o = this.getPoint(s), l = i || (a.isVector2 ? new Ue() : new q());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(e, i) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, i);
  }
  computeFrenetFrames(e, i) {
    const n = new q(), s = [], a = [], o = [], l = new q(), u = new ui();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      s[f] = this.getTangentAt(m, new q());
    }
    a[0] = new q(), o[0] = new q();
    let c = Number.MAX_VALUE;
    const h = Math.abs(s[0].x), d = Math.abs(s[0].y), p = Math.abs(s[0].z);
    h <= c && (c = h, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), p <= c && n.set(0, 0, 1), l.crossVectors(s[0], n).normalize(), a[0].crossVectors(s[0], l), o[0].crossVectors(s[0], a[0]);
    for (let f = 1; f <= e; f++) {
      if (a[f] = a[f - 1].clone(), o[f] = o[f - 1].clone(), l.crossVectors(s[f - 1], s[f]), l.length() > Number.EPSILON) {
        l.normalize();
        const m = Math.acos(Ki(s[f - 1].dot(s[f]), -1, 1));
        a[f].applyMatrix4(u.makeRotationAxis(l, m));
      }
      o[f].crossVectors(s[f], a[f]);
    }
    if (i === !0) {
      let f = Math.acos(Ki(a[0].dot(a[e]), -1, 1));
      f /= e, s[0].dot(l.crossVectors(a[0], a[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++)
        a[m].applyMatrix4(u.makeRotationAxis(s[m], f * m)), o[m].crossVectors(s[m], a[m]);
    }
    return {
      tangents: s,
      normals: a,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class yR extends wa {
  constructor(e = 0, i = 0, n = 1, s = 1, a = 0, o = Math.PI * 2, l = !1, u = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = i, this.xRadius = n, this.yRadius = s, this.aStartAngle = a, this.aEndAngle = o, this.aClockwise = l, this.aRotation = u;
  }
  getPoint(e, i = new Ue()) {
    const n = i, s = Math.PI * 2;
    let a = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(a) < Number.EPSILON;
    for (; a < 0; ) a += s;
    for (; a > s; ) a -= s;
    a < Number.EPSILON && (o ? a = 0 : a = s), this.aClockwise === !0 && !o && (a === s ? a = -s : a = a - s);
    const l = this.aStartAngle + e * a;
    let u = this.aX + this.xRadius * Math.cos(l), c = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = u - this.aX, f = c - this.aY;
      u = p * h - f * d + this.aX, c = p * d + f * h + this.aY;
    }
    return n.set(u, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class Aj extends yR {
  constructor(e, i, n, s, a, o) {
    super(e, i, n, n, s, a, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function D_() {
  let r = 0, e = 0, i = 0, n = 0;
  function s(a, o, l, u) {
    r = a, e = l, i = -3 * a + 3 * o - 2 * l - u, n = 2 * a - 2 * o + l + u;
  }
  return {
    initCatmullRom: function(a, o, l, u, c) {
      s(o, l, c * (l - a), c * (u - o));
    },
    initNonuniformCatmullRom: function(a, o, l, u, c, h, d) {
      let p = (o - a) / c - (l - a) / (c + h) + (l - o) / h, f = (l - o) / h - (u - o) / (h + d) + (u - l) / d;
      p *= h, f *= h, s(o, l, p, f);
    },
    calc: function(a) {
      const o = a * a, l = o * a;
      return r + e * a + i * o + n * l;
    }
  };
}
const Up = /* @__PURE__ */ new q(), Xy = /* @__PURE__ */ new D_(), $y = /* @__PURE__ */ new D_(), Yy = /* @__PURE__ */ new D_();
class Cj extends wa {
  constructor(e = [], i = !1, n = "centripetal", s = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = i, this.curveType = n, this.tension = s;
  }
  getPoint(e, i = new q()) {
    const n = i, s = this.points, a = s.length, o = (a - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(o), u = o - l;
    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / a) + 1) * a : u === 0 && l === a - 1 && (l = a - 2, u = 1);
    let c, h;
    this.closed || l > 0 ? c = s[(l - 1) % a] : (Up.subVectors(s[0], s[1]).add(s[0]), c = Up);
    const d = s[l % a], p = s[(l + 1) % a];
    if (this.closed || l + 2 < a ? h = s[(l + 2) % a] : (Up.subVectors(s[a - 1], s[a - 2]).add(s[a - 1]), h = Up), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(c.distanceToSquared(d), f), v = Math.pow(d.distanceToSquared(p), f), y = Math.pow(p.distanceToSquared(h), f);
      v < 1e-4 && (v = 1), m < 1e-4 && (m = v), y < 1e-4 && (y = v), Xy.initNonuniformCatmullRom(c.x, d.x, p.x, h.x, m, v, y), $y.initNonuniformCatmullRom(c.y, d.y, p.y, h.y, m, v, y), Yy.initNonuniformCatmullRom(c.z, d.z, p.z, h.z, m, v, y);
    } else this.curveType === "catmullrom" && (Xy.initCatmullRom(c.x, d.x, p.x, h.x, this.tension), $y.initCatmullRom(c.y, d.y, p.y, h.y, this.tension), Yy.initCatmullRom(c.z, d.z, p.z, h.z, this.tension));
    return n.set(
      Xy.calc(u),
      $y.calc(u),
      Yy.calc(u)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(s.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let i = 0, n = this.points.length; i < n; i++) {
      const s = this.points[i];
      e.points.push(s.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(new q().fromArray(s));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function xw(r, e, i, n, s) {
  const a = (n - e) * 0.5, o = (s - i) * 0.5, l = r * r, u = r * l;
  return (2 * i - 2 * n + a + o) * u + (-3 * i + 3 * n - 2 * a - o) * l + a * r + i;
}
function Rj(r, e) {
  const i = 1 - r;
  return i * i * e;
}
function Nj(r, e) {
  return 2 * (1 - r) * r * e;
}
function Pj(r, e) {
  return r * r * e;
}
function Yh(r, e, i, n) {
  return Rj(r, e) + Nj(r, i) + Pj(r, n);
}
function Ij(r, e) {
  const i = 1 - r;
  return i * i * i * e;
}
function Oj(r, e) {
  const i = 1 - r;
  return 3 * i * i * r * e;
}
function Dj(r, e) {
  return 3 * (1 - r) * r * r * e;
}
function Lj(r, e) {
  return r * r * r * e;
}
function Kh(r, e, i, n, s) {
  return Ij(r, e) + Oj(r, i) + Dj(r, n) + Lj(r, s);
}
class Uj extends wa {
  constructor(e = new Ue(), i = new Ue(), n = new Ue(), s = new Ue()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = i, this.v2 = n, this.v3 = s;
  }
  getPoint(e, i = new Ue()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2, l = this.v3;
    return n.set(
      Kh(e, s.x, a.x, o.x, l.x),
      Kh(e, s.y, a.y, o.y, l.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class vR extends wa {
  constructor(e = new q(), i = new q(), n = new q(), s = new q()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = i, this.v2 = n, this.v3 = s;
  }
  getPoint(e, i = new q()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2, l = this.v3;
    return n.set(
      Kh(e, s.x, a.x, o.x, l.x),
      Kh(e, s.y, a.y, o.y, l.y),
      Kh(e, s.z, a.z, o.z, l.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class kj extends wa {
  constructor(e = new Ue(), i = new Ue()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = i;
  }
  getPoint(e, i = new Ue()) {
    const n = i;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, i) {
    return this.getPoint(e, i);
  }
  getTangent(e, i = new Ue()) {
    return i.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, i) {
    return this.getTangent(e, i);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Fj extends wa {
  constructor(e = new q(), i = new q()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = i;
  }
  getPoint(e, i = new q()) {
    const n = i;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, i) {
    return this.getPoint(e, i);
  }
  getTangent(e, i = new q()) {
    return i.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, i) {
    return this.getTangent(e, i);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Bj extends wa {
  constructor(e = new Ue(), i = new Ue(), n = new Ue()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = i, this.v2 = n;
  }
  getPoint(e, i = new Ue()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2;
    return n.set(
      Yh(e, s.x, a.x, o.x),
      Yh(e, s.y, a.y, o.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class L_ extends wa {
  constructor(e = new q(), i = new q(), n = new q()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = i, this.v2 = n;
  }
  getPoint(e, i = new q()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2;
    return n.set(
      Yh(e, s.x, a.x, o.x),
      Yh(e, s.y, a.y, o.y),
      Yh(e, s.z, a.z, o.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class zj extends wa {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, i = new Ue()) {
    const n = i, s = this.points, a = (s.length - 1) * e, o = Math.floor(a), l = a - o, u = s[o === 0 ? o : o - 1], c = s[o], h = s[o > s.length - 2 ? s.length - 1 : o + 1], d = s[o > s.length - 3 ? s.length - 1 : o + 2];
    return n.set(
      xw(l, u.x, c.x, h.x, d.x),
      xw(l, u.y, c.y, h.y, d.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let i = 0, n = this.points.length; i < n; i++) {
      const s = this.points[i];
      e.points.push(s.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(new Ue().fromArray(s));
    }
    return this;
  }
}
var jj = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: Aj,
  CatmullRomCurve3: Cj,
  CubicBezierCurve: Uj,
  CubicBezierCurve3: vR,
  EllipseCurve: yR,
  LineCurve: kj,
  LineCurve3: Fj,
  QuadraticBezierCurve: Bj,
  QuadraticBezierCurve3: L_,
  SplineCurve: zj
});
class U_ extends cn {
  constructor(e = 1, i = 32, n = 0, s = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: i,
      thetaStart: n,
      thetaLength: s
    }, i = Math.max(3, i);
    const a = [], o = [], l = [], u = [], c = new q(), h = new Ue();
    o.push(0, 0, 0), l.push(0, 0, 1), u.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= i; d++, p += 3) {
      const f = n + d / i * s;
      c.x = e * Math.cos(f), c.y = e * Math.sin(f), o.push(c.x, c.y, c.z), l.push(0, 0, 1), h.x = (o[p] / e + 1) / 2, h.y = (o[p + 1] / e + 1) / 2, u.push(h.x, h.y);
    }
    for (let d = 1; d <= i; d++)
      a.push(d, d + 1, 0);
    this.setIndex(a), this.setAttribute("position", new Ri(o, 3)), this.setAttribute("normal", new Ri(l, 3)), this.setAttribute("uv", new Ri(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new U_(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Sg extends cn {
  constructor(e = 1, i = 1, n = 1, s = 32, a = 1, o = !1, l = 0, u = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: i,
      height: n,
      radialSegments: s,
      heightSegments: a,
      openEnded: o,
      thetaStart: l,
      thetaLength: u
    };
    const c = this;
    s = Math.floor(s), a = Math.floor(a);
    const h = [], d = [], p = [], f = [];
    let m = 0;
    const v = [], y = n / 2;
    let g = 0;
    _(), o === !1 && (e > 0 && x(!0), i > 0 && x(!1)), this.setIndex(h), this.setAttribute("position", new Ri(d, 3)), this.setAttribute("normal", new Ri(p, 3)), this.setAttribute("uv", new Ri(f, 2));
    function _() {
      const b = new q(), T = new q();
      let S = 0;
      const w = (i - e) / n;
      for (let A = 0; A <= a; A++) {
        const E = [], M = A / a, N = M * (i - e) + e;
        for (let k = 0; k <= s; k++) {
          const U = k / s, C = U * u + l, O = Math.sin(C), D = Math.cos(C);
          T.x = N * O, T.y = -M * n + y, T.z = N * D, d.push(T.x, T.y, T.z), b.set(O, w, D).normalize(), p.push(b.x, b.y, b.z), f.push(U, 1 - M), E.push(m++);
        }
        v.push(E);
      }
      for (let A = 0; A < s; A++)
        for (let E = 0; E < a; E++) {
          const M = v[E][A], N = v[E + 1][A], k = v[E + 1][A + 1], U = v[E][A + 1];
          (e > 0 || E !== 0) && (h.push(M, N, U), S += 3), (i > 0 || E !== a - 1) && (h.push(N, k, U), S += 3);
        }
      c.addGroup(g, S, 0), g += S;
    }
    function x(b) {
      const T = m, S = new Ue(), w = new q();
      let A = 0;
      const E = b === !0 ? e : i, M = b === !0 ? 1 : -1;
      for (let k = 1; k <= s; k++)
        d.push(0, y * M, 0), p.push(0, M, 0), f.push(0.5, 0.5), m++;
      const N = m;
      for (let k = 0; k <= s; k++) {
        const U = k / s * u + l, C = Math.cos(U), O = Math.sin(U);
        w.x = E * O, w.y = y * M, w.z = E * C, d.push(w.x, w.y, w.z), p.push(0, M, 0), S.x = C * 0.5 + 0.5, S.y = O * 0.5 * M + 0.5, f.push(S.x, S.y), m++;
      }
      for (let k = 0; k < s; k++) {
        const U = T + k, C = N + k;
        b === !0 ? h.push(C, C + 1, U) : h.push(C + 1, C, U), A += 3;
      }
      c.addGroup(g, A, b === !0 ? 1 : 2), g += A;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Sg(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class k_ extends Sg {
  constructor(e = 1, i = 1, n = 32, s = 1, a = !1, o = 0, l = Math.PI * 2) {
    super(0, e, i, n, s, a, o, l), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: i,
      radialSegments: n,
      heightSegments: s,
      openEnded: a,
      thetaStart: o,
      thetaLength: l
    };
  }
  static fromJSON(e) {
    return new k_(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
let bR = class xR extends cn {
  constructor(e = 1, i = 32, n = 16, s = 0, a = Math.PI * 2, o = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: i,
      heightSegments: n,
      phiStart: s,
      phiLength: a,
      thetaStart: o,
      thetaLength: l
    }, i = Math.max(3, Math.floor(i)), n = Math.max(2, Math.floor(n));
    const u = Math.min(o + l, Math.PI);
    let c = 0;
    const h = [], d = new q(), p = new q(), f = [], m = [], v = [], y = [];
    for (let g = 0; g <= n; g++) {
      const _ = [], x = g / n;
      let b = 0;
      g === 0 && o === 0 ? b = 0.5 / i : g === n && u === Math.PI && (b = -0.5 / i);
      for (let T = 0; T <= i; T++) {
        const S = T / i;
        d.x = -e * Math.cos(s + S * a) * Math.sin(o + x * l), d.y = e * Math.cos(o + x * l), d.z = e * Math.sin(s + S * a) * Math.sin(o + x * l), m.push(d.x, d.y, d.z), p.copy(d).normalize(), v.push(p.x, p.y, p.z), y.push(S + b, 1 - x), _.push(c++);
      }
      h.push(_);
    }
    for (let g = 0; g < n; g++)
      for (let _ = 0; _ < i; _++) {
        const x = h[g][_ + 1], b = h[g][_], T = h[g + 1][_], S = h[g + 1][_ + 1];
        (g !== 0 || o > 0) && f.push(x, b, S), (g !== n - 1 || u < Math.PI) && f.push(b, T, S);
      }
    this.setIndex(f), this.setAttribute("position", new Ri(m, 3)), this.setAttribute("normal", new Ri(v, 3)), this.setAttribute("uv", new Ri(y, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new xR(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
};
class F_ extends cn {
  constructor(e = new L_(new q(-1, -1, 0), new q(-1, 1, 0), new q(1, 1, 0)), i = 64, n = 1, s = 8, a = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: i,
      radius: n,
      radialSegments: s,
      closed: a
    };
    const o = e.computeFrenetFrames(i, a);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const l = new q(), u = new q(), c = new Ue();
    let h = new q();
    const d = [], p = [], f = [], m = [];
    v(), this.setIndex(m), this.setAttribute("position", new Ri(d, 3)), this.setAttribute("normal", new Ri(p, 3)), this.setAttribute("uv", new Ri(f, 2));
    function v() {
      for (let x = 0; x < i; x++)
        y(x);
      y(a === !1 ? i : 0), _(), g();
    }
    function y(x) {
      h = e.getPointAt(x / i, h);
      const b = o.normals[x], T = o.binormals[x];
      for (let S = 0; S <= s; S++) {
        const w = S / s * Math.PI * 2, A = Math.sin(w), E = -Math.cos(w);
        u.x = E * b.x + A * T.x, u.y = E * b.y + A * T.y, u.z = E * b.z + A * T.z, u.normalize(), p.push(u.x, u.y, u.z), l.x = h.x + n * u.x, l.y = h.y + n * u.y, l.z = h.z + n * u.z, d.push(l.x, l.y, l.z);
      }
    }
    function g() {
      for (let x = 1; x <= i; x++)
        for (let b = 1; b <= s; b++) {
          const T = (s + 1) * (x - 1) + (b - 1), S = (s + 1) * x + (b - 1), w = (s + 1) * x + b, A = (s + 1) * (x - 1) + b;
          m.push(T, S, A), m.push(S, w, A);
        }
    }
    function _() {
      for (let x = 0; x <= i; x++)
        for (let b = 0; b <= s; b++)
          c.x = x / i, c.y = b / s, f.push(c.x, c.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new F_(
      new jj[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
let Vj = class extends Nl {
  static get type() {
    return "MeshLambertMaterial";
  }
  constructor(r) {
    super(), this.isMeshLambertMaterial = !0, this.color = new kt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = GC, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new yo(), this.combine = __, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.lightMap = r.lightMap, this.lightMapIntensity = r.lightMapIntensity, this.aoMap = r.aoMap, this.aoMapIntensity = r.aoMapIntensity, this.emissive.copy(r.emissive), this.emissiveMap = r.emissiveMap, this.emissiveIntensity = r.emissiveIntensity, this.bumpMap = r.bumpMap, this.bumpScale = r.bumpScale, this.normalMap = r.normalMap, this.normalMapType = r.normalMapType, this.normalScale.copy(r.normalScale), this.displacementMap = r.displacementMap, this.displacementScale = r.displacementScale, this.displacementBias = r.displacementBias, this.specularMap = r.specularMap, this.alphaMap = r.alphaMap, this.envMap = r.envMap, this.envMapRotation.copy(r.envMapRotation), this.combine = r.combine, this.reflectivity = r.reflectivity, this.refractionRatio = r.refractionRatio, this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.wireframeLinecap = r.wireframeLinecap, this.wireframeLinejoin = r.wireframeLinejoin, this.flatShading = r.flatShading, this.fog = r.fog, this;
  }
};
const _w = {
  enabled: !1,
  files: {},
  add: function(r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function(r) {
    if (this.enabled !== !1)
      return this.files[r];
  },
  remove: function(r) {
    delete this.files[r];
  },
  clear: function() {
    this.files = {};
  }
};
class Gj {
  constructor(e, i, n) {
    const s = this;
    let a = !1, o = 0, l = 0, u;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = i, this.onError = n, this.itemStart = function(h) {
      l++, a === !1 && s.onStart !== void 0 && s.onStart(h, o, l), a = !0;
    }, this.itemEnd = function(h) {
      o++, s.onProgress !== void 0 && s.onProgress(h, o, l), o === l && (a = !1, s.onLoad !== void 0 && s.onLoad());
    }, this.itemError = function(h) {
      s.onError !== void 0 && s.onError(h);
    }, this.resolveURL = function(h) {
      return u ? u(h) : h;
    }, this.setURLModifier = function(h) {
      return u = h, this;
    }, this.addHandler = function(h, d) {
      return c.push(h, d), this;
    }, this.removeHandler = function(h) {
      const d = c.indexOf(h);
      return d !== -1 && c.splice(d, 2), this;
    }, this.getHandler = function(h) {
      for (let d = 0, p = c.length; d < p; d += 2) {
        const f = c[d], m = c[d + 1];
        if (f.global && (f.lastIndex = 0), f.test(h))
          return m;
      }
      return null;
    };
  }
}
const Hj = /* @__PURE__ */ new Gj();
class B_ {
  constructor(e) {
    this.manager = e !== void 0 ? e : Hj, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, i) {
    const n = this;
    return new Promise(function(s, a) {
      n.load(e, s, i, a);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
B_.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class Wj extends B_ {
  constructor(e) {
    super(e);
  }
  load(e, i, n, s) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const a = this, o = _w.get(e);
    if (o !== void 0)
      return a.manager.itemStart(e), setTimeout(function() {
        i && i(o), a.manager.itemEnd(e);
      }, 0), o;
    const l = hd("img");
    function u() {
      h(), _w.add(e, this), i && i(this), a.manager.itemEnd(e);
    }
    function c(d) {
      h(), s && s(d), a.manager.itemError(e), a.manager.itemEnd(e);
    }
    function h() {
      l.removeEventListener("load", u, !1), l.removeEventListener("error", c, !1);
    }
    return l.addEventListener("load", u, !1), l.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), a.manager.itemStart(e), l.src = e, l;
  }
}
class qj extends B_ {
  constructor(e) {
    super(e);
  }
  load(e, i, n, s) {
    const a = new En(), o = new Wj(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(l) {
      a.image = l, a.needsUpdate = !0, i !== void 0 && i(a);
    }, n, s), a;
  }
}
let _R = class extends Gr {
  constructor(r, e = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new kt(r), this.intensity = e;
  }
  dispose() {
  }
  copy(r, e) {
    return super.copy(r, e), this.color.copy(r.color), this.intensity = r.intensity, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (e.object.target = this.target.uuid), e;
  }
};
const Ky = /* @__PURE__ */ new ui(), Tw = /* @__PURE__ */ new q(), Sw = /* @__PURE__ */ new q();
let Xj = class {
  constructor(r) {
    this.camera = r, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ue(512, 512), this.map = null, this.mapPass = null, this.matrix = new ui(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new P_(), this._frameExtents = new Ue(1, 1), this._viewportCount = 1, this._viewports = [
      new Fi(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(r) {
    const e = this.camera, i = this.matrix;
    Tw.setFromMatrixPosition(r.matrixWorld), e.position.copy(Tw), Sw.setFromMatrixPosition(r.target.matrixWorld), e.lookAt(Sw), e.updateMatrixWorld(), Ky.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ky), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(Ky);
  }
  getViewport(r) {
    return this._viewports[r];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(r) {
    return this.camera = r.camera.clone(), this.intensity = r.intensity, this.bias = r.bias, this.radius = r.radius, this.mapSize.copy(r.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const r = {};
    return this.intensity !== 1 && (r.intensity = this.intensity), this.bias !== 0 && (r.bias = this.bias), this.normalBias !== 0 && (r.normalBias = this.normalBias), this.radius !== 1 && (r.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (r.mapSize = this.mapSize.toArray()), r.camera = this.camera.toJSON(!1).object, delete r.camera.matrix, r;
  }
}, $j = class extends Xj {
  constructor() {
    super(new I_(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}, Yj = class extends _R {
  constructor(r, e) {
    super(r, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Gr.DEFAULT_UP), this.updateMatrix(), this.target = new Gr(), this.shadow = new $j();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(r) {
    return super.copy(r), this.target = r.target.clone(), this.shadow = r.shadow.clone(), this;
  }
}, Kj = class extends _R {
  constructor(r, e) {
    super(r, e), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
};
class TR {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = ww(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const i = ww();
      e = (i - this.oldTime) / 1e3, this.oldTime = i, this.elapsedTime += e;
    }
    return e;
  }
}
function ww() {
  return performance.now();
}
const Ew = /* @__PURE__ */ new ui();
class SR {
  constructor(e, i, n = 0, s = 1 / 0) {
    this.ray = new xg(e, i), this.near = n, this.far = s, this.camera = null, this.layers = new R_(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, i) {
    this.ray.set(e, i);
  }
  setFromCamera(e, i) {
    i.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(i.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(i).sub(this.ray.origin).normalize(), this.camera = i) : i.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (i.near + i.far) / (i.near - i.far)).unproject(i), this.ray.direction.set(0, 0, -1).transformDirection(i.matrixWorld), this.camera = i) : console.error("THREE.Raycaster: Unsupported camera type: " + i.type);
  }
  setFromXRController(e) {
    return Ew.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Ew), this;
  }
  intersectObject(e, i = !0, n = []) {
    return Lb(e, this, n, i), n.sort(Mw), n;
  }
  intersectObjects(e, i = !0, n = []) {
    for (let s = 0, a = e.length; s < a; s++)
      Lb(e[s], this, n, i);
    return n.sort(Mw), n;
  }
}
function Mw(r, e) {
  return r.distance - e.distance;
}
function Lb(r, e, i, n) {
  let s = !0;
  if (r.layers.test(e.layers) && r.raycast(e, i) === !1 && (s = !1), s === !0 && n === !0) {
    const a = r.children;
    for (let o = 0, l = a.length; o < l; o++)
      Lb(a[o], e, i, !0);
  }
}
class Aw {
  constructor(e = 1, i = 0, n = 0) {
    return this.radius = e, this.phi = i, this.theta = n, this;
  }
  set(e, i, n) {
    return this.radius = e, this.phi = i, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, i, n) {
    return this.radius = Math.sqrt(e * e + i * i + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Ki(i / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class wg extends Cl {
  constructor(e, i = null) {
    super(), this.object = e, this.domElement = i, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: gg
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = gg);
function wR(r, e, i) {
  var n, s = 1;
  r == null && (r = 0), e == null && (e = 0), i == null && (i = 0);
  function a() {
    var o, l = n.length, u, c = 0, h = 0, d = 0;
    for (o = 0; o < l; ++o)
      u = n[o], c += u.x || 0, h += u.y || 0, d += u.z || 0;
    for (c = (c / l - r) * s, h = (h / l - e) * s, d = (d / l - i) * s, o = 0; o < l; ++o)
      u = n[o], c && (u.x -= c), h && (u.y -= h), d && (u.z -= d);
  }
  return a.initialize = function(o) {
    n = o;
  }, a.x = function(o) {
    return arguments.length ? (r = +o, a) : r;
  }, a.y = function(o) {
    return arguments.length ? (e = +o, a) : e;
  }, a.z = function(o) {
    return arguments.length ? (i = +o, a) : i;
  }, a.strength = function(o) {
    return arguments.length ? (s = +o, a) : s;
  }, a;
}
function Zj(r) {
  const e = +this._x.call(null, r);
  return ER(this.cover(e), e, r);
}
function ER(r, e, i) {
  if (isNaN(e)) return r;
  var n, s = r._root, a = { data: i }, o = r._x0, l = r._x1, u, c, h, d, p;
  if (!s) return r._root = a, r;
  for (; s.length; )
    if ((h = e >= (u = (o + l) / 2)) ? o = u : l = u, n = s, !(s = s[d = +h])) return n[d] = a, r;
  if (c = +r._x.call(null, s.data), e === c) return a.next = s, n ? n[d] = a : r._root = a, r;
  do
    n = n ? n[d] = new Array(2) : r._root = new Array(2), (h = e >= (u = (o + l) / 2)) ? o = u : l = u;
  while ((d = +h) == (p = +(c >= u)));
  return n[p] = s, n[d] = a, r;
}
function Qj(r) {
  Array.isArray(r) || (r = Array.from(r));
  const e = r.length, i = new Float64Array(e);
  let n = 1 / 0, s = -1 / 0;
  for (let a = 0, o; a < e; ++a)
    isNaN(o = +this._x.call(null, r[a])) || (i[a] = o, o < n && (n = o), o > s && (s = o));
  if (n > s) return this;
  this.cover(n).cover(s);
  for (let a = 0; a < e; ++a)
    ER(this, i[a], r[a]);
  return this;
}
function Jj(r) {
  if (isNaN(r = +r)) return this;
  var e = this._x0, i = this._x1;
  if (isNaN(e))
    i = (e = Math.floor(r)) + 1;
  else {
    for (var n = i - e || 1, s = this._root, a, o; e > r || r >= i; )
      switch (o = +(r < e), a = new Array(2), a[o] = s, s = a, n *= 2, o) {
        case 0:
          i = e + n;
          break;
        case 1:
          e = i - n;
          break;
      }
    this._root && this._root.length && (this._root = s);
  }
  return this._x0 = e, this._x1 = i, this;
}
function eV() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function tV(r) {
  return arguments.length ? this.cover(+r[0][0]).cover(+r[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
}
function da(r, e, i) {
  this.node = r, this.x0 = e, this.x1 = i;
}
function iV(r, e) {
  var i, n = this._x0, s, a, o = this._x1, l = [], u = this._root, c, h;
  for (u && l.push(new da(u, n, o)), e == null ? e = 1 / 0 : (n = r - e, o = r + e); c = l.pop(); )
    if (!(!(u = c.node) || (s = c.x0) > o || (a = c.x1) < n))
      if (u.length) {
        var d = (s + a) / 2;
        l.push(
          new da(u[1], d, a),
          new da(u[0], s, d)
        ), (h = +(r >= d)) && (c = l[l.length - 1], l[l.length - 1] = l[l.length - 1 - h], l[l.length - 1 - h] = c);
      } else {
        var p = Math.abs(r - +this._x.call(null, u.data));
        p < e && (e = p, n = r - p, o = r + p, i = u.data);
      }
  return i;
}
function rV(r) {
  if (isNaN(u = +this._x.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._x1, u, c, h, d, p;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((h = u >= (c = (o + l) / 2)) ? o = c : l = c, e = i, !(i = i[d = +h])) return this;
    if (!i.length) break;
    e[d + 1 & 1] && (n = e, p = d);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[d] = a : delete e[d], (i = e[0] || e[1]) && i === (e[1] || e[0]) && !i.length && (n ? n[p] = i : this._root = i), this) : (this._root = a, this);
}
function nV(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function sV() {
  return this._root;
}
function aV() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function oV(r) {
  var e = [], i, n = this._root, s, a, o;
  for (n && e.push(new da(n, this._x0, this._x1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.x1) && n.length) {
      var l = (a + o) / 2;
      (s = n[1]) && e.push(new da(s, l, o)), (s = n[0]) && e.push(new da(s, a, l));
    }
  return this;
}
function lV(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new da(this._root, this._x0, this._x1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.x1, u = (o + l) / 2;
      (a = s[0]) && e.push(new da(a, o, u)), (a = s[1]) && e.push(new da(a, u, l));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.x1);
  return this;
}
function uV(r) {
  return r[0];
}
function cV(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function MR(r, e) {
  var i = new z_(e ?? uV, NaN, NaN);
  return r == null ? i : i.addAll(r);
}
function z_(r, e, i) {
  this._x = r, this._x0 = e, this._x1 = i, this._root = void 0;
}
function Cw(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var qr = MR.prototype = z_.prototype;
qr.copy = function() {
  var r = new z_(this._x, this._x0, this._x1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = Cw(e), r;
  for (i = [{ source: e, target: r._root = new Array(2) }]; e = i.pop(); )
    for (var s = 0; s < 2; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(2) }) : e.target[s] = Cw(n));
  return r;
};
qr.add = Zj;
qr.addAll = Qj;
qr.cover = Jj;
qr.data = eV;
qr.extent = tV;
qr.find = iV;
qr.remove = rV;
qr.removeAll = nV;
qr.root = sV;
qr.size = aV;
qr.visit = oV;
qr.visitAfter = lV;
qr.x = cV;
function hV(r) {
  const e = +this._x.call(null, r), i = +this._y.call(null, r);
  return AR(this.cover(e, i), e, i, r);
}
function AR(r, e, i, n) {
  if (isNaN(e) || isNaN(i)) return r;
  var s, a = r._root, o = { data: n }, l = r._x0, u = r._y0, c = r._x1, h = r._y1, d, p, f, m, v, y, g, _;
  if (!a) return r._root = o, r;
  for (; a.length; )
    if ((v = e >= (d = (l + c) / 2)) ? l = d : c = d, (y = i >= (p = (u + h) / 2)) ? u = p : h = p, s = a, !(a = a[g = y << 1 | v])) return s[g] = o, r;
  if (f = +r._x.call(null, a.data), m = +r._y.call(null, a.data), e === f && i === m) return o.next = a, s ? s[g] = o : r._root = o, r;
  do
    s = s ? s[g] = new Array(4) : r._root = new Array(4), (v = e >= (d = (l + c) / 2)) ? l = d : c = d, (y = i >= (p = (u + h) / 2)) ? u = p : h = p;
  while ((g = y << 1 | v) === (_ = (m >= p) << 1 | f >= d));
  return s[_] = a, s[g] = o, r;
}
function dV(r) {
  var e, i, n = r.length, s, a, o = new Array(n), l = new Array(n), u = 1 / 0, c = 1 / 0, h = -1 / 0, d = -1 / 0;
  for (i = 0; i < n; ++i)
    isNaN(s = +this._x.call(null, e = r[i])) || isNaN(a = +this._y.call(null, e)) || (o[i] = s, l[i] = a, s < u && (u = s), s > h && (h = s), a < c && (c = a), a > d && (d = a));
  if (u > h || c > d) return this;
  for (this.cover(u, c).cover(h, d), i = 0; i < n; ++i)
    AR(this, o[i], l[i], r[i]);
  return this;
}
function pV(r, e) {
  if (isNaN(r = +r) || isNaN(e = +e)) return this;
  var i = this._x0, n = this._y0, s = this._x1, a = this._y1;
  if (isNaN(i))
    s = (i = Math.floor(r)) + 1, a = (n = Math.floor(e)) + 1;
  else {
    for (var o = s - i || 1, l = this._root, u, c; i > r || r >= s || n > e || e >= a; )
      switch (c = (e < n) << 1 | r < i, u = new Array(4), u[c] = l, l = u, o *= 2, c) {
        case 0:
          s = i + o, a = n + o;
          break;
        case 1:
          i = s - o, a = n + o;
          break;
        case 2:
          s = i + o, n = a - o;
          break;
        case 3:
          i = s - o, n = a - o;
          break;
      }
    this._root && this._root.length && (this._root = l);
  }
  return this._x0 = i, this._y0 = n, this._x1 = s, this._y1 = a, this;
}
function fV() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function mV(r) {
  return arguments.length ? this.cover(+r[0][0], +r[0][1]).cover(+r[1][0], +r[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function Er(r, e, i, n, s) {
  this.node = r, this.x0 = e, this.y0 = i, this.x1 = n, this.y1 = s;
}
function gV(r, e, i) {
  var n, s = this._x0, a = this._y0, o, l, u, c, h = this._x1, d = this._y1, p = [], f = this._root, m, v;
  for (f && p.push(new Er(f, s, a, h, d)), i == null ? i = 1 / 0 : (s = r - i, a = e - i, h = r + i, d = e + i, i *= i); m = p.pop(); )
    if (!(!(f = m.node) || (o = m.x0) > h || (l = m.y0) > d || (u = m.x1) < s || (c = m.y1) < a))
      if (f.length) {
        var y = (o + u) / 2, g = (l + c) / 2;
        p.push(
          new Er(f[3], y, g, u, c),
          new Er(f[2], o, g, y, c),
          new Er(f[1], y, l, u, g),
          new Er(f[0], o, l, y, g)
        ), (v = (e >= g) << 1 | r >= y) && (m = p[p.length - 1], p[p.length - 1] = p[p.length - 1 - v], p[p.length - 1 - v] = m);
      } else {
        var _ = r - +this._x.call(null, f.data), x = e - +this._y.call(null, f.data), b = _ * _ + x * x;
        if (b < i) {
          var T = Math.sqrt(i = b);
          s = r - T, a = e - T, h = r + T, d = e + T, n = f.data;
        }
      }
  return n;
}
function yV(r) {
  if (isNaN(h = +this._x.call(null, r)) || isNaN(d = +this._y.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._y0, u = this._x1, c = this._y1, h, d, p, f, m, v, y, g;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((m = h >= (p = (o + u) / 2)) ? o = p : u = p, (v = d >= (f = (l + c) / 2)) ? l = f : c = f, e = i, !(i = i[y = v << 1 | m])) return this;
    if (!i.length) break;
    (e[y + 1 & 3] || e[y + 2 & 3] || e[y + 3 & 3]) && (n = e, g = y);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[y] = a : delete e[y], (i = e[0] || e[1] || e[2] || e[3]) && i === (e[3] || e[2] || e[1] || e[0]) && !i.length && (n ? n[g] = i : this._root = i), this) : (this._root = a, this);
}
function vV(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function bV() {
  return this._root;
}
function xV() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function _V(r) {
  var e = [], i, n = this._root, s, a, o, l, u;
  for (n && e.push(new Er(n, this._x0, this._y0, this._x1, this._y1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.y0, l = i.x1, u = i.y1) && n.length) {
      var c = (a + l) / 2, h = (o + u) / 2;
      (s = n[3]) && e.push(new Er(s, c, h, l, u)), (s = n[2]) && e.push(new Er(s, a, h, c, u)), (s = n[1]) && e.push(new Er(s, c, o, l, h)), (s = n[0]) && e.push(new Er(s, a, o, c, h));
    }
  return this;
}
function TV(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new Er(this._root, this._x0, this._y0, this._x1, this._y1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.y0, u = n.x1, c = n.y1, h = (o + u) / 2, d = (l + c) / 2;
      (a = s[0]) && e.push(new Er(a, o, l, h, d)), (a = s[1]) && e.push(new Er(a, h, l, u, d)), (a = s[2]) && e.push(new Er(a, o, d, h, c)), (a = s[3]) && e.push(new Er(a, h, d, u, c));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.y0, n.x1, n.y1);
  return this;
}
function SV(r) {
  return r[0];
}
function wV(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function EV(r) {
  return r[1];
}
function MV(r) {
  return arguments.length ? (this._y = r, this) : this._y;
}
function CR(r, e, i) {
  var n = new j_(e ?? SV, i ?? EV, NaN, NaN, NaN, NaN);
  return r == null ? n : n.addAll(r);
}
function j_(r, e, i, n, s, a) {
  this._x = r, this._y = e, this._x0 = i, this._y0 = n, this._x1 = s, this._y1 = a, this._root = void 0;
}
function Rw(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var Pr = CR.prototype = j_.prototype;
Pr.copy = function() {
  var r = new j_(this._x, this._y, this._x0, this._y0, this._x1, this._y1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = Rw(e), r;
  for (i = [{ source: e, target: r._root = new Array(4) }]; e = i.pop(); )
    for (var s = 0; s < 4; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(4) }) : e.target[s] = Rw(n));
  return r;
};
Pr.add = hV;
Pr.addAll = dV;
Pr.cover = pV;
Pr.data = fV;
Pr.extent = mV;
Pr.find = gV;
Pr.remove = yV;
Pr.removeAll = vV;
Pr.root = bV;
Pr.size = xV;
Pr.visit = _V;
Pr.visitAfter = TV;
Pr.x = wV;
Pr.y = MV;
function AV(r) {
  const e = +this._x.call(null, r), i = +this._y.call(null, r), n = +this._z.call(null, r);
  return RR(this.cover(e, i, n), e, i, n, r);
}
function RR(r, e, i, n, s) {
  if (isNaN(e) || isNaN(i) || isNaN(n)) return r;
  var a, o = r._root, l = { data: s }, u = r._x0, c = r._y0, h = r._z0, d = r._x1, p = r._y1, f = r._z1, m, v, y, g, _, x, b, T, S, w, A;
  if (!o) return r._root = l, r;
  for (; o.length; )
    if ((b = e >= (m = (u + d) / 2)) ? u = m : d = m, (T = i >= (v = (c + p) / 2)) ? c = v : p = v, (S = n >= (y = (h + f) / 2)) ? h = y : f = y, a = o, !(o = o[w = S << 2 | T << 1 | b])) return a[w] = l, r;
  if (g = +r._x.call(null, o.data), _ = +r._y.call(null, o.data), x = +r._z.call(null, o.data), e === g && i === _ && n === x) return l.next = o, a ? a[w] = l : r._root = l, r;
  do
    a = a ? a[w] = new Array(8) : r._root = new Array(8), (b = e >= (m = (u + d) / 2)) ? u = m : d = m, (T = i >= (v = (c + p) / 2)) ? c = v : p = v, (S = n >= (y = (h + f) / 2)) ? h = y : f = y;
  while ((w = S << 2 | T << 1 | b) === (A = (x >= y) << 2 | (_ >= v) << 1 | g >= m));
  return a[A] = o, a[w] = l, r;
}
function CV(r) {
  Array.isArray(r) || (r = Array.from(r));
  const e = r.length, i = new Float64Array(e), n = new Float64Array(e), s = new Float64Array(e);
  let a = 1 / 0, o = 1 / 0, l = 1 / 0, u = -1 / 0, c = -1 / 0, h = -1 / 0;
  for (let d = 0, p, f, m, v; d < e; ++d)
    isNaN(f = +this._x.call(null, p = r[d])) || isNaN(m = +this._y.call(null, p)) || isNaN(v = +this._z.call(null, p)) || (i[d] = f, n[d] = m, s[d] = v, f < a && (a = f), f > u && (u = f), m < o && (o = m), m > c && (c = m), v < l && (l = v), v > h && (h = v));
  if (a > u || o > c || l > h) return this;
  this.cover(a, o, l).cover(u, c, h);
  for (let d = 0; d < e; ++d)
    RR(this, i[d], n[d], s[d], r[d]);
  return this;
}
function RV(r, e, i) {
  if (isNaN(r = +r) || isNaN(e = +e) || isNaN(i = +i)) return this;
  var n = this._x0, s = this._y0, a = this._z0, o = this._x1, l = this._y1, u = this._z1;
  if (isNaN(n))
    o = (n = Math.floor(r)) + 1, l = (s = Math.floor(e)) + 1, u = (a = Math.floor(i)) + 1;
  else {
    for (var c = o - n || 1, h = this._root, d, p; n > r || r >= o || s > e || e >= l || a > i || i >= u; )
      switch (p = (i < a) << 2 | (e < s) << 1 | r < n, d = new Array(8), d[p] = h, h = d, c *= 2, p) {
        case 0:
          o = n + c, l = s + c, u = a + c;
          break;
        case 1:
          n = o - c, l = s + c, u = a + c;
          break;
        case 2:
          o = n + c, s = l - c, u = a + c;
          break;
        case 3:
          n = o - c, s = l - c, u = a + c;
          break;
        case 4:
          o = n + c, l = s + c, a = u - c;
          break;
        case 5:
          n = o - c, l = s + c, a = u - c;
          break;
        case 6:
          o = n + c, s = l - c, a = u - c;
          break;
        case 7:
          n = o - c, s = l - c, a = u - c;
          break;
      }
    this._root && this._root.length && (this._root = h);
  }
  return this._x0 = n, this._y0 = s, this._z0 = a, this._x1 = o, this._y1 = l, this._z1 = u, this;
}
function NV() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function PV(r) {
  return arguments.length ? this.cover(+r[0][0], +r[0][1], +r[0][2]).cover(+r[1][0], +r[1][1], +r[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
}
function ii(r, e, i, n, s, a, o) {
  this.node = r, this.x0 = e, this.y0 = i, this.z0 = n, this.x1 = s, this.y1 = a, this.z1 = o;
}
function IV(r, e, i, n) {
  var s, a = this._x0, o = this._y0, l = this._z0, u, c, h, d, p, f, m = this._x1, v = this._y1, y = this._z1, g = [], _ = this._root, x, b;
  for (_ && g.push(new ii(_, a, o, l, m, v, y)), n == null ? n = 1 / 0 : (a = r - n, o = e - n, l = i - n, m = r + n, v = e + n, y = i + n, n *= n); x = g.pop(); )
    if (!(!(_ = x.node) || (u = x.x0) > m || (c = x.y0) > v || (h = x.z0) > y || (d = x.x1) < a || (p = x.y1) < o || (f = x.z1) < l))
      if (_.length) {
        var T = (u + d) / 2, S = (c + p) / 2, w = (h + f) / 2;
        g.push(
          new ii(_[7], T, S, w, d, p, f),
          new ii(_[6], u, S, w, T, p, f),
          new ii(_[5], T, c, w, d, S, f),
          new ii(_[4], u, c, w, T, S, f),
          new ii(_[3], T, S, h, d, p, w),
          new ii(_[2], u, S, h, T, p, w),
          new ii(_[1], T, c, h, d, S, w),
          new ii(_[0], u, c, h, T, S, w)
        ), (b = (i >= w) << 2 | (e >= S) << 1 | r >= T) && (x = g[g.length - 1], g[g.length - 1] = g[g.length - 1 - b], g[g.length - 1 - b] = x);
      } else {
        var A = r - +this._x.call(null, _.data), E = e - +this._y.call(null, _.data), M = i - +this._z.call(null, _.data), N = A * A + E * E + M * M;
        if (N < n) {
          var k = Math.sqrt(n = N);
          a = r - k, o = e - k, l = i - k, m = r + k, v = e + k, y = i + k, s = _.data;
        }
      }
  return s;
}
const OV = (r, e, i, n, s, a) => Math.sqrt((r - n) ** 2 + (e - s) ** 2 + (i - a) ** 2);
function DV(r, e, i, n) {
  const s = [], a = r - n, o = e - n, l = i - n, u = r + n, c = e + n, h = i + n;
  return this.visit((d, p, f, m, v, y, g) => {
    if (!d.length)
      do {
        const _ = d.data;
        OV(r, e, i, this._x(_), this._y(_), this._z(_)) <= n && s.push(_);
      } while (d = d.next);
    return p > u || f > c || m > h || v < a || y < o || g < l;
  }), s;
}
function LV(r) {
  if (isNaN(p = +this._x.call(null, r)) || isNaN(f = +this._y.call(null, r)) || isNaN(m = +this._z.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._y0, u = this._z0, c = this._x1, h = this._y1, d = this._z1, p, f, m, v, y, g, _, x, b, T, S;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((_ = p >= (v = (o + c) / 2)) ? o = v : c = v, (x = f >= (y = (l + h) / 2)) ? l = y : h = y, (b = m >= (g = (u + d) / 2)) ? u = g : d = g, e = i, !(i = i[T = b << 2 | x << 1 | _])) return this;
    if (!i.length) break;
    (e[T + 1 & 7] || e[T + 2 & 7] || e[T + 3 & 7] || e[T + 4 & 7] || e[T + 5 & 7] || e[T + 6 & 7] || e[T + 7 & 7]) && (n = e, S = T);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[T] = a : delete e[T], (i = e[0] || e[1] || e[2] || e[3] || e[4] || e[5] || e[6] || e[7]) && i === (e[7] || e[6] || e[5] || e[4] || e[3] || e[2] || e[1] || e[0]) && !i.length && (n ? n[S] = i : this._root = i), this) : (this._root = a, this);
}
function UV(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function kV() {
  return this._root;
}
function FV() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function BV(r) {
  var e = [], i, n = this._root, s, a, o, l, u, c, h;
  for (n && e.push(new ii(n, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.y0, l = i.z0, u = i.x1, c = i.y1, h = i.z1) && n.length) {
      var d = (a + u) / 2, p = (o + c) / 2, f = (l + h) / 2;
      (s = n[7]) && e.push(new ii(s, d, p, f, u, c, h)), (s = n[6]) && e.push(new ii(s, a, p, f, d, c, h)), (s = n[5]) && e.push(new ii(s, d, o, f, u, p, h)), (s = n[4]) && e.push(new ii(s, a, o, f, d, p, h)), (s = n[3]) && e.push(new ii(s, d, p, l, u, c, f)), (s = n[2]) && e.push(new ii(s, a, p, l, d, c, f)), (s = n[1]) && e.push(new ii(s, d, o, l, u, p, f)), (s = n[0]) && e.push(new ii(s, a, o, l, d, p, f));
    }
  return this;
}
function zV(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new ii(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.y0, u = n.z0, c = n.x1, h = n.y1, d = n.z1, p = (o + c) / 2, f = (l + h) / 2, m = (u + d) / 2;
      (a = s[0]) && e.push(new ii(a, o, l, u, p, f, m)), (a = s[1]) && e.push(new ii(a, p, l, u, c, f, m)), (a = s[2]) && e.push(new ii(a, o, f, u, p, h, m)), (a = s[3]) && e.push(new ii(a, p, f, u, c, h, m)), (a = s[4]) && e.push(new ii(a, o, l, m, p, f, d)), (a = s[5]) && e.push(new ii(a, p, l, m, c, f, d)), (a = s[6]) && e.push(new ii(a, o, f, m, p, h, d)), (a = s[7]) && e.push(new ii(a, p, f, m, c, h, d));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.y0, n.z0, n.x1, n.y1, n.z1);
  return this;
}
function jV(r) {
  return r[0];
}
function VV(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function GV(r) {
  return r[1];
}
function HV(r) {
  return arguments.length ? (this._y = r, this) : this._y;
}
function WV(r) {
  return r[2];
}
function qV(r) {
  return arguments.length ? (this._z = r, this) : this._z;
}
function NR(r, e, i, n) {
  var s = new V_(e ?? jV, i ?? GV, n ?? WV, NaN, NaN, NaN, NaN, NaN, NaN);
  return r == null ? s : s.addAll(r);
}
function V_(r, e, i, n, s, a, o, l, u) {
  this._x = r, this._y = e, this._z = i, this._x0 = n, this._y0 = s, this._z0 = a, this._x1 = o, this._y1 = l, this._z1 = u, this._root = void 0;
}
function Nw(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var ar = NR.prototype = V_.prototype;
ar.copy = function() {
  var r = new V_(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = Nw(e), r;
  for (i = [{ source: e, target: r._root = new Array(8) }]; e = i.pop(); )
    for (var s = 0; s < 8; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(8) }) : e.target[s] = Nw(n));
  return r;
};
ar.add = AV;
ar.addAll = CV;
ar.cover = RV;
ar.data = NV;
ar.extent = PV;
ar.find = IV;
ar.findAllWithinRadius = DV;
ar.remove = LV;
ar.removeAll = UV;
ar.root = kV;
ar.size = FV;
ar.visit = BV;
ar.visitAfter = zV;
ar.x = VV;
ar.y = HV;
ar.z = qV;
function aa(r) {
  return function() {
    return r;
  };
}
function $s(r) {
  return (r() - 0.5) * 1e-6;
}
function XV(r) {
  return r.index;
}
function Pw(r, e) {
  var i = r.get(e);
  if (!i) throw new Error("node not found: " + e);
  return i;
}
function PR(r) {
  var e = XV, i = p, n, s = aa(30), a, o, l, u, c, h, d = 1;
  r == null && (r = []);
  function p(g) {
    return 1 / Math.min(u[g.source.index], u[g.target.index]);
  }
  function f(g) {
    for (var _ = 0, x = r.length; _ < d; ++_)
      for (var b = 0, T, S, w, A = 0, E = 0, M = 0, N, k; b < x; ++b)
        T = r[b], S = T.source, w = T.target, A = w.x + w.vx - S.x - S.vx || $s(h), l > 1 && (E = w.y + w.vy - S.y - S.vy || $s(h)), l > 2 && (M = w.z + w.vz - S.z - S.vz || $s(h)), N = Math.sqrt(A * A + E * E + M * M), N = (N - a[b]) / N * g * n[b], A *= N, E *= N, M *= N, w.vx -= A * (k = c[b]), l > 1 && (w.vy -= E * k), l > 2 && (w.vz -= M * k), S.vx += A * (k = 1 - k), l > 1 && (S.vy += E * k), l > 2 && (S.vz += M * k);
  }
  function m() {
    if (o) {
      var g, _ = o.length, x = r.length, b = new Map(o.map((S, w) => [e(S, w, o), S])), T;
      for (g = 0, u = new Array(_); g < x; ++g)
        T = r[g], T.index = g, typeof T.source != "object" && (T.source = Pw(b, T.source)), typeof T.target != "object" && (T.target = Pw(b, T.target)), u[T.source.index] = (u[T.source.index] || 0) + 1, u[T.target.index] = (u[T.target.index] || 0) + 1;
      for (g = 0, c = new Array(x); g < x; ++g)
        T = r[g], c[g] = u[T.source.index] / (u[T.source.index] + u[T.target.index]);
      n = new Array(x), v(), a = new Array(x), y();
    }
  }
  function v() {
    if (o)
      for (var g = 0, _ = r.length; g < _; ++g)
        n[g] = +i(r[g], g, r);
  }
  function y() {
    if (o)
      for (var g = 0, _ = r.length; g < _; ++g)
        a[g] = +s(r[g], g, r);
  }
  return f.initialize = function(g, ..._) {
    o = g, h = _.find((x) => typeof x == "function") || Math.random, l = _.find((x) => [1, 2, 3].includes(x)) || 2, m();
  }, f.links = function(g) {
    return arguments.length ? (r = g, m(), f) : r;
  }, f.id = function(g) {
    return arguments.length ? (e = g, f) : e;
  }, f.iterations = function(g) {
    return arguments.length ? (d = +g, f) : d;
  }, f.strength = function(g) {
    return arguments.length ? (i = typeof g == "function" ? g : aa(+g), v(), f) : i;
  }, f.distance = function(g) {
    return arguments.length ? (s = typeof g == "function" ? g : aa(+g), y(), f) : s;
  }, f;
}
var $V = { value: () => {
} };
function Gd() {
  for (var r = 0, e = arguments.length, i = {}, n; r < e; ++r) {
    if (!(n = arguments[r] + "") || n in i || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    i[n] = [];
  }
  return new Zf(i);
}
function Zf(r) {
  this._ = r;
}
function YV(r, e) {
  return r.trim().split(/^|\s+/).map(function(i) {
    var n = "", s = i.indexOf(".");
    if (s >= 0 && (n = i.slice(s + 1), i = i.slice(0, s)), i && !e.hasOwnProperty(i)) throw new Error("unknown type: " + i);
    return { type: i, name: n };
  });
}
Zf.prototype = Gd.prototype = {
  constructor: Zf,
  on: function(r, e) {
    var i = this._, n = YV(r + "", i), s, a = -1, o = n.length;
    if (arguments.length < 2) {
      for (; ++a < o; ) if ((s = (r = n[a]).type) && (s = KV(i[s], r.name))) return s;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++a < o; )
      if (s = (r = n[a]).type) i[s] = Iw(i[s], r.name, e);
      else if (e == null) for (s in i) i[s] = Iw(i[s], r.name, null);
    return this;
  },
  copy: function() {
    var r = {}, e = this._;
    for (var i in e) r[i] = e[i].slice();
    return new Zf(r);
  },
  call: function(r, e) {
    if ((s = arguments.length - 2) > 0) for (var i = new Array(s), n = 0, s, a; n < s; ++n) i[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    for (a = this._[r], n = 0, s = a.length; n < s; ++n) a[n].value.apply(e, i);
  },
  apply: function(r, e, i) {
    if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    for (var n = this._[r], s = 0, a = n.length; s < a; ++s) n[s].value.apply(e, i);
  }
};
function KV(r, e) {
  for (var i = 0, n = r.length, s; i < n; ++i)
    if ((s = r[i]).name === e)
      return s.value;
}
function Iw(r, e, i) {
  for (var n = 0, s = r.length; n < s; ++n)
    if (r[n].name === e) {
      r[n] = $V, r = r.slice(0, n).concat(r.slice(n + 1));
      break;
    }
  return i != null && r.push({ name: e, value: i }), r;
}
var yc = 0, Fh = 0, uh = 0, IR = 1e3, bm, Bh, xm = 0, _l = 0, Eg = 0, dd = typeof performance == "object" && performance.now ? performance : Date, OR = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(r) {
  setTimeout(r, 17);
};
function G_() {
  return _l || (OR(ZV), _l = dd.now() + Eg);
}
function ZV() {
  _l = 0;
}
function _m() {
  this._call = this._time = this._next = null;
}
_m.prototype = H_.prototype = {
  constructor: _m,
  restart: function(r, e, i) {
    if (typeof r != "function") throw new TypeError("callback is not a function");
    i = (i == null ? G_() : +i) + (e == null ? 0 : +e), !this._next && Bh !== this && (Bh ? Bh._next = this : bm = this, Bh = this), this._call = r, this._time = i, Ub();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Ub());
  }
};
function H_(r, e, i) {
  var n = new _m();
  return n.restart(r, e, i), n;
}
function QV() {
  G_(), ++yc;
  for (var r = bm, e; r; )
    (e = _l - r._time) >= 0 && r._call.call(void 0, e), r = r._next;
  --yc;
}
function Ow() {
  _l = (xm = dd.now()) + Eg, yc = Fh = 0;
  try {
    QV();
  } finally {
    yc = 0, e8(), _l = 0;
  }
}
function JV() {
  var r = dd.now(), e = r - xm;
  e > IR && (Eg -= e, xm = r);
}
function e8() {
  for (var r, e = bm, i, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), r = e, e = e._next) : (i = e._next, e._next = null, e = r ? r._next = i : bm = i);
  Bh = r, Ub(n);
}
function Ub(r) {
  if (!yc) {
    Fh && (Fh = clearTimeout(Fh));
    var e = r - _l;
    e > 24 ? (r < 1 / 0 && (Fh = setTimeout(Ow, r - dd.now() - Eg)), uh && (uh = clearInterval(uh))) : (uh || (xm = dd.now(), uh = setInterval(JV, IR)), yc = 1, OR(Ow));
  }
}
function Dw(r, e, i) {
  var n = new _m();
  return e = e == null ? 0 : +e, n.restart((s) => {
    n.stop(), r(s + e);
  }, e, i), n;
}
const t8 = 1664525, i8 = 1013904223, Lw = 4294967296;
function r8() {
  let r = 1;
  return () => (r = (t8 * r + i8) % Lw) / Lw;
}
var Uw = 3;
function Zy(r) {
  return r.x;
}
function kw(r) {
  return r.y;
}
function n8(r) {
  return r.z;
}
var s8 = 10, a8 = Math.PI * (3 - Math.sqrt(5)), o8 = Math.PI * 20 / (9 + Math.sqrt(221));
function DR(r, e) {
  e = e || 2;
  var i = Math.min(Uw, Math.max(1, Math.round(e))), n, s = 1, a = 1e-3, o = 1 - Math.pow(a, 1 / 300), l = 0, u = 0.6, c = /* @__PURE__ */ new Map(), h = H_(f), d = Gd("tick", "end"), p = r8();
  r == null && (r = []);
  function f() {
    m(), d.call("tick", n), s < a && (h.stop(), d.call("end", n));
  }
  function m(g) {
    var _, x = r.length, b;
    g === void 0 && (g = 1);
    for (var T = 0; T < g; ++T)
      for (s += (l - s) * o, c.forEach(function(S) {
        S(s);
      }), _ = 0; _ < x; ++_)
        b = r[_], b.fx == null ? b.x += b.vx *= u : (b.x = b.fx, b.vx = 0), i > 1 && (b.fy == null ? b.y += b.vy *= u : (b.y = b.fy, b.vy = 0)), i > 2 && (b.fz == null ? b.z += b.vz *= u : (b.z = b.fz, b.vz = 0));
    return n;
  }
  function v() {
    for (var g = 0, _ = r.length, x; g < _; ++g) {
      if (x = r[g], x.index = g, x.fx != null && (x.x = x.fx), x.fy != null && (x.y = x.fy), x.fz != null && (x.z = x.fz), isNaN(x.x) || i > 1 && isNaN(x.y) || i > 2 && isNaN(x.z)) {
        var b = s8 * (i > 2 ? Math.cbrt(0.5 + g) : i > 1 ? Math.sqrt(0.5 + g) : g), T = g * a8, S = g * o8;
        i === 1 ? x.x = b : i === 2 ? (x.x = b * Math.cos(T), x.y = b * Math.sin(T)) : (x.x = b * Math.sin(T) * Math.cos(S), x.y = b * Math.cos(T), x.z = b * Math.sin(T) * Math.sin(S));
      }
      (isNaN(x.vx) || i > 1 && isNaN(x.vy) || i > 2 && isNaN(x.vz)) && (x.vx = 0, i > 1 && (x.vy = 0), i > 2 && (x.vz = 0));
    }
  }
  function y(g) {
    return g.initialize && g.initialize(r, p, i), g;
  }
  return v(), n = {
    tick: m,
    restart: function() {
      return h.restart(f), n;
    },
    stop: function() {
      return h.stop(), n;
    },
    numDimensions: function(g) {
      return arguments.length ? (i = Math.min(Uw, Math.max(1, Math.round(g))), c.forEach(y), n) : i;
    },
    nodes: function(g) {
      return arguments.length ? (r = g, v(), c.forEach(y), n) : r;
    },
    alpha: function(g) {
      return arguments.length ? (s = +g, n) : s;
    },
    alphaMin: function(g) {
      return arguments.length ? (a = +g, n) : a;
    },
    alphaDecay: function(g) {
      return arguments.length ? (o = +g, n) : +o;
    },
    alphaTarget: function(g) {
      return arguments.length ? (l = +g, n) : l;
    },
    velocityDecay: function(g) {
      return arguments.length ? (u = 1 - g, n) : 1 - u;
    },
    randomSource: function(g) {
      return arguments.length ? (p = g, c.forEach(y), n) : p;
    },
    force: function(g, _) {
      return arguments.length > 1 ? (_ == null ? c.delete(g) : c.set(g, y(_)), n) : c.get(g);
    },
    find: function() {
      var g = Array.prototype.slice.call(arguments), _ = g.shift() || 0, x = (i > 1 ? g.shift() : null) || 0, b = (i > 2 ? g.shift() : null) || 0, T = g.shift() || 1 / 0, S = 0, w = r.length, A, E, M, N, k, U;
      for (T *= T, S = 0; S < w; ++S)
        k = r[S], A = _ - k.x, E = x - (k.y || 0), M = b - (k.z || 0), N = A * A + E * E + M * M, N < T && (U = k, T = N);
      return U;
    },
    on: function(g, _) {
      return arguments.length > 1 ? (d.on(g, _), n) : d.on(g);
    }
  };
}
function LR() {
  var r, e, i, n, s, a = aa(-30), o, l = 1, u = 1 / 0, c = 0.81;
  function h(m) {
    var v, y = r.length, g = (e === 1 ? MR(r, Zy) : e === 2 ? CR(r, Zy, kw) : e === 3 ? NR(r, Zy, kw, n8) : null).visitAfter(p);
    for (s = m, v = 0; v < y; ++v) i = r[v], g.visit(f);
  }
  function d() {
    if (r) {
      var m, v = r.length, y;
      for (o = new Array(v), m = 0; m < v; ++m) y = r[m], o[y.index] = +a(y, m, r);
    }
  }
  function p(m) {
    var v = 0, y, g, _ = 0, x, b, T, S, w = m.length;
    if (w) {
      for (x = b = T = S = 0; S < w; ++S)
        (y = m[S]) && (g = Math.abs(y.value)) && (v += y.value, _ += g, x += g * (y.x || 0), b += g * (y.y || 0), T += g * (y.z || 0));
      v *= Math.sqrt(4 / w), m.x = x / _, e > 1 && (m.y = b / _), e > 2 && (m.z = T / _);
    } else {
      y = m, y.x = y.data.x, e > 1 && (y.y = y.data.y), e > 2 && (y.z = y.data.z);
      do
        v += o[y.data.index];
      while (y = y.next);
    }
    m.value = v;
  }
  function f(m, v, y, g, _) {
    if (!m.value) return !0;
    var x = [y, g, _][e - 1], b = m.x - i.x, T = e > 1 ? m.y - i.y : 0, S = e > 2 ? m.z - i.z : 0, w = x - v, A = b * b + T * T + S * S;
    if (w * w / c < A)
      return A < u && (b === 0 && (b = $s(n), A += b * b), e > 1 && T === 0 && (T = $s(n), A += T * T), e > 2 && S === 0 && (S = $s(n), A += S * S), A < l && (A = Math.sqrt(l * A)), i.vx += b * m.value * s / A, e > 1 && (i.vy += T * m.value * s / A), e > 2 && (i.vz += S * m.value * s / A)), !0;
    if (!(m.length || A >= u)) {
      (m.data !== i || m.next) && (b === 0 && (b = $s(n), A += b * b), e > 1 && T === 0 && (T = $s(n), A += T * T), e > 2 && S === 0 && (S = $s(n), A += S * S), A < l && (A = Math.sqrt(l * A)));
      do
        m.data !== i && (w = o[m.data.index] * s / A, i.vx += b * w, e > 1 && (i.vy += T * w), e > 2 && (i.vz += S * w));
      while (m = m.next);
    }
  }
  return h.initialize = function(m, ...v) {
    r = m, n = v.find((y) => typeof y == "function") || Math.random, e = v.find((y) => [1, 2, 3].includes(y)) || 2, d();
  }, h.strength = function(m) {
    return arguments.length ? (a = typeof m == "function" ? m : aa(+m), d(), h) : a;
  }, h.distanceMin = function(m) {
    return arguments.length ? (l = m * m, h) : Math.sqrt(l);
  }, h.distanceMax = function(m) {
    return arguments.length ? (u = m * m, h) : Math.sqrt(u);
  }, h.theta = function(m) {
    return arguments.length ? (c = m * m, h) : Math.sqrt(c);
  }, h;
}
function UR(r, e, i, n) {
  var s, a, o = aa(0.1), l, u;
  typeof r != "function" && (r = aa(+r)), e == null && (e = 0), i == null && (i = 0), n == null && (n = 0);
  function c(d) {
    for (var p = 0, f = s.length; p < f; ++p) {
      var m = s[p], v = m.x - e || 1e-6, y = (m.y || 0) - i || 1e-6, g = (m.z || 0) - n || 1e-6, _ = Math.sqrt(v * v + y * y + g * g), x = (u[p] - _) * l[p] * d / _;
      m.vx += v * x, a > 1 && (m.vy += y * x), a > 2 && (m.vz += g * x);
    }
  }
  function h() {
    if (s) {
      var d, p = s.length;
      for (l = new Array(p), u = new Array(p), d = 0; d < p; ++d)
        u[d] = +r(s[d], d, s), l[d] = isNaN(u[d]) ? 0 : +o(s[d], d, s);
    }
  }
  return c.initialize = function(d, ...p) {
    s = d, a = p.find((f) => [1, 2, 3].includes(f)) || 2, h();
  }, c.strength = function(d) {
    return arguments.length ? (o = typeof d == "function" ? d : aa(+d), h(), c) : o;
  }, c.radius = function(d) {
    return arguments.length ? (r = typeof d == "function" ? d : aa(+d), h(), c) : r;
  }, c.x = function(d) {
    return arguments.length ? (e = +d, c) : e;
  }, c.y = function(d) {
    return arguments.length ? (i = +d, c) : i;
  }, c.z = function(d) {
    return arguments.length ? (n = +d, c) : n;
  }, c;
}
var W_ = function(r) {
  u8(r);
  var e = l8(r);
  return r.on = e.on, r.off = e.off, r.fire = e.fire, r;
};
function l8(r) {
  var e = /* @__PURE__ */ Object.create(null);
  return {
    on: function(i, n, s) {
      if (typeof n != "function")
        throw new Error("callback is expected to be a function");
      var a = e[i];
      return a || (a = e[i] = []), a.push({ callback: n, ctx: s }), r;
    },
    off: function(i, n) {
      var s = typeof i > "u";
      if (s)
        return e = /* @__PURE__ */ Object.create(null), r;
      if (e[i]) {
        var a = typeof n != "function";
        if (a)
          delete e[i];
        else
          for (var o = e[i], l = 0; l < o.length; ++l)
            o[l].callback === n && o.splice(l, 1);
      }
      return r;
    },
    fire: function(i) {
      var n = e[i];
      if (!n)
        return r;
      var s;
      arguments.length > 1 && (s = Array.prototype.splice.call(arguments, 1));
      for (var a = 0; a < n.length; ++a) {
        var o = n[a];
        o.callback.apply(o.ctx, s);
      }
      return r;
    }
  };
}
function u8(r) {
  if (!r)
    throw new Error("Eventify cannot use falsy object as events subject");
  for (var e = ["on", "fire", "off"], i = 0; i < e.length; ++i)
    if (r.hasOwnProperty(e[i]))
      throw new Error("Subject cannot be eventified, since it already has property '" + e[i] + "'");
}
var c8 = d8, h8 = W_;
function d8(r) {
  if (r = r || {}, "uniqueLinkId" in r && (console.warn(
    "ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\nUse `multigraph` option instead\n",
    `
`,
    `Note: there is also change in default behavior: From now on each graph
is considered to be not a multigraph by default (each edge is unique).`
  ), r.multigraph = r.uniqueLinkId), r.multigraph === void 0 && (r.multigraph = !1), typeof Map != "function")
    throw new Error("ngraph.graph requires `Map` to be defined. Please polyfill it before using ngraph");
  var e = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = {}, s = 0, a = r.multigraph ? b : x, o = [], l = D, u = D, c = D, h = D, d = {
    /**
     * Sometimes duck typing could be slow. Giving clients a hint about data structure
     * via explicit version number here:
     */
    version: 20,
    /**
     * Adds node to the graph. If node with given id already exists in the graph
     * its data is extended with whatever comes in 'data' argument.
     *
     * @param nodeId the node's identifier. A string or number is preferred.
     * @param [data] additional data for the node being added. If node already
     *   exists its data object is augmented with the new one.
     *
     * @return {node} The newly added node or node with given id if it already exists.
     */
    addNode: v,
    /**
     * Adds a link to the graph. The function always create a new
     * link between two nodes. If one of the nodes does not exists
     * a new node is created.
     *
     * @param fromId link start node id;
     * @param toId link end node id;
     * @param [data] additional data to be set on the new link;
     *
     * @return {link} The newly created link
     */
    addLink: _,
    /**
     * Removes link from the graph. If link does not exist does nothing.
     *
     * @param link - object returned by addLink() or getLinks() methods.
     *
     * @returns true if link was removed; false otherwise.
     */
    removeLink: A,
    /**
     * Removes node with given id from the graph. If node does not exist in the graph
     * does nothing.
     *
     * @param nodeId node's identifier passed to addNode() function.
     *
     * @returns true if node was removed; false otherwise.
     */
    removeNode: g,
    /**
     * Gets node with given identifier. If node does not exist undefined value is returned.
     *
     * @param nodeId requested node identifier;
     *
     * @return {node} in with requested identifier or undefined if no such node exists.
     */
    getNode: y,
    /**
     * Gets number of nodes in this graph.
     *
     * @return number of nodes in the graph.
     */
    getNodeCount: T,
    /**
     * Gets total number of links in the graph.
     */
    getLinkCount: S,
    /**
     * Gets total number of links in the graph.
     */
    getEdgeCount: S,
    /**
     * Synonym for `getLinkCount()`
     */
    getLinksCount: S,
    /**
     * Synonym for `getNodeCount()`
     */
    getNodesCount: T,
    /**
     * Gets all links (inbound and outbound) from the node with given id.
     * If node with given id is not found null is returned.
     *
     * @param nodeId requested node identifier.
     *
     * @return Set of links from and to requested node if such node exists;
     *   otherwise null is returned.
     */
    getLinks: w,
    /**
     * Invokes callback on each node of the graph.
     *
     * @param {Function(node)} callback Function to be invoked. The function
     *   is passed one argument: visited node.
     */
    forEachNode: K,
    /**
     * Invokes callback on every linked (adjacent) node to the given one.
     *
     * @param nodeId Identifier of the requested node.
     * @param {Function(node, link)} callback Function to be called on all linked nodes.
     *   The function is passed two parameters: adjacent node and link object itself.
     * @param oriented if true graph treated as oriented.
     */
    forEachLinkedNode: U,
    /**
     * Enumerates all links in the graph
     *
     * @param {Function(link)} callback Function to be called on all links in the graph.
     *   The function is passed one parameter: graph's link object.
     *
     * Link object contains at least the following fields:
     *  fromId - node id where link starts;
     *  toId - node id where link ends,
     *  data - additional data passed to graph.addLink() method.
     */
    forEachLink: k,
    /**
     * Suspend all notifications about graph changes until
     * endUpdate is called.
     */
    beginUpdate: c,
    /**
     * Resumes all notifications about graph changes and fires
     * graph 'changed' event in case there are any pending changes.
     */
    endUpdate: h,
    /**
     * Removes all nodes and links from the graph.
     */
    clear: N,
    /**
     * Detects whether there is a link between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     * NOTE: this function is synonym for getLink()
     *
     * @returns link if there is one. null otherwise.
     */
    hasLink: M,
    /**
     * Detects whether there is a node with given id
     * 
     * Operation complexity is O(1)
     * NOTE: this function is synonym for getNode()
     *
     * @returns node if there is one; Falsy value otherwise.
     */
    hasNode: y,
    /**
     * Gets an edge between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     *
     * @param {string} fromId link start identifier
     * @param {string} toId link end identifier
     *
     * @returns link if there is one; undefined otherwise.
     */
    getLink: M
  };
  return h8(d), p(), d;
  function p() {
    var L = d.on;
    d.on = B;
    function B() {
      return d.beginUpdate = c = H, d.endUpdate = h = j, l = f, u = m, d.on = L, L.apply(d, arguments);
    }
  }
  function f(L, B) {
    o.push({
      link: L,
      changeType: B
    });
  }
  function m(L, B) {
    o.push({
      node: L,
      changeType: B
    });
  }
  function v(L, B) {
    if (L === void 0)
      throw new Error("Invalid node identifier");
    c();
    var Q = y(L);
    return Q ? (Q.data = B, u(Q, "update")) : (Q = new p8(L, B), u(Q, "add")), e.set(L, Q), h(), Q;
  }
  function y(L) {
    return e.get(L);
  }
  function g(L) {
    var B = y(L);
    if (!B)
      return !1;
    c();
    var Q = B.links;
    return Q && (Q.forEach(E), B.links = null), e.delete(L), u(B, "remove"), h(), !0;
  }
  function _(L, B, Q) {
    c();
    var W = y(L) || v(L), z = y(B) || v(B), X = a(L, B, Q), ae = i.has(X.id);
    return i.set(X.id, X), Fw(W, X), L !== B && Fw(z, X), l(X, ae ? "update" : "add"), h(), X;
  }
  function x(L, B, Q) {
    var W = kp(L, B), z = i.get(W);
    return z ? (z.data = Q, z) : new Bw(L, B, Q, W);
  }
  function b(L, B, Q) {
    var W = kp(L, B), z = n.hasOwnProperty(W);
    if (z || M(L, B)) {
      z || (n[W] = 0);
      var X = "@" + ++n[W];
      W = kp(L + X, B + X);
    }
    return new Bw(L, B, Q, W);
  }
  function T() {
    return e.size;
  }
  function S() {
    return i.size;
  }
  function w(L) {
    var B = y(L);
    return B ? B.links : null;
  }
  function A(L, B) {
    return B !== void 0 && (L = M(L, B)), E(L);
  }
  function E(L) {
    if (!L || !i.get(L.id)) return !1;
    c(), i.delete(L.id);
    var B = y(L.fromId), Q = y(L.toId);
    return B && B.links.delete(L), Q && Q.links.delete(L), l(L, "remove"), h(), !0;
  }
  function M(L, B) {
    if (!(L === void 0 || B === void 0))
      return i.get(kp(L, B));
  }
  function N() {
    c(), K(function(L) {
      g(L.id);
    }), h();
  }
  function k(L) {
    if (typeof L == "function")
      for (var B = i.values(), Q = B.next(); !Q.done; ) {
        if (L(Q.value))
          return !0;
        Q = B.next();
      }
  }
  function U(L, B, Q) {
    var W = y(L);
    if (W && W.links && typeof B == "function")
      return Q ? O(W.links, L, B) : C(W.links, L, B);
  }
  function C(L, B, Q) {
    for (var W, z = L.values(), X = z.next(); !X.done; ) {
      var ae = X.value, ue = ae.fromId === B ? ae.toId : ae.fromId;
      if (W = Q(e.get(ue), ae), W)
        return !0;
      X = z.next();
    }
  }
  function O(L, B, Q) {
    for (var W, z = L.values(), X = z.next(); !X.done; ) {
      var ae = X.value;
      if (ae.fromId === B && (W = Q(e.get(ae.toId), ae), W))
        return !0;
      X = z.next();
    }
  }
  function D() {
  }
  function H() {
    s += 1;
  }
  function j() {
    s -= 1, s === 0 && o.length > 0 && (d.fire("changed", o), o.length = 0);
  }
  function K(L) {
    if (typeof L != "function")
      throw new Error("Function is expected to iterate over graph nodes. You passed " + L);
    for (var B = e.values(), Q = B.next(); !Q.done; ) {
      if (L(Q.value))
        return !0;
      Q = B.next();
    }
  }
}
function p8(r, e) {
  this.id = r, this.links = null, this.data = e;
}
function Fw(r, e) {
  r.links ? r.links.add(e) : r.links = /* @__PURE__ */ new Set([e]);
}
function Bw(r, e, i, n) {
  this.fromId = r, this.toId = e, this.data = i, this.id = n;
}
function kp(r, e) {
  return r.toString() + " " + e.toString();
}
const f8 = /* @__PURE__ */ d_(c8);
var q_ = { exports: {} }, Hd = { exports: {} }, kR = function(r) {
  return r === 0 ? "x" : r === 1 ? "y" : r === 2 ? "z" : "c" + (r + 1);
};
const m8 = kR;
var kc = function(r) {
  return e;
  function e(i, n) {
    let s = n && n.indent || 0, a = n && n.join !== void 0 ? n.join : `
`, o = Array(s + 1).join(" "), l = [];
    for (let u = 0; u < r; ++u) {
      let c = m8(u), h = u === 0 ? "" : o;
      l.push(h + i.replace(/{var}/g, c));
    }
    return l.join(a);
  }
};
const FR = kc;
Hd.exports = g8;
Hd.exports.generateCreateBodyFunctionBody = BR;
Hd.exports.getVectorCode = jR;
Hd.exports.getBodyCode = zR;
function g8(r, e) {
  let i = BR(r, e), { Body: n } = new Function(i)();
  return n;
}
function BR(r, e) {
  return `
${jR(r, e)}
${zR(r)}
return {Body: Body, Vector: Vector};
`;
}
function zR(r) {
  let e = FR(r), i = e("{var}", { join: ", " });
  return `
function Body(${i}) {
  this.isPinned = false;
  this.pos = new Vector(${i});
  this.force = new Vector();
  this.velocity = new Vector();
  this.mass = 1;

  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.reset = function() {
  this.force.reset();
  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.setPosition = function (${i}) {
  ${e("this.pos.{var} = {var} || 0;", { indent: 2 })}
};`;
}
function jR(r, e) {
  let i = FR(r), n = "";
  return e && (n = `${i(`
   var v{var};
Object.defineProperty(this, '{var}', {
  set: function(v) { 
    if (!Number.isFinite(v)) throw new Error('Cannot set non-numbers to {var}');
    v{var} = v; 
  },
  get: function() { return v{var}; }
});`)}`), `function Vector(${i("{var}", { join: ", " })}) {
  ${n}
    if (typeof arguments[0] === 'object') {
      // could be another vector
      let v = arguments[0];
      ${i('if (!Number.isFinite(v.{var})) throw new Error("Expected value is not a finite number at Vector constructor ({var})");', { indent: 4 })}
      ${i("this.{var} = v.{var};", { indent: 4 })}
    } else {
      ${i('this.{var} = typeof {var} === "number" ? {var} : 0;', { indent: 4 })}
    }
  }
  
  Vector.prototype.reset = function () {
    ${i("this.{var} = ", { join: "" })}0;
  };`;
}
var y8 = Hd.exports, _o = { exports: {} };
const X_ = kc, ka = kR;
_o.exports = v8;
_o.exports.generateQuadTreeFunctionBody = VR;
_o.exports.getInsertStackCode = XR;
_o.exports.getQuadNodeCode = qR;
_o.exports.isSamePosition = GR;
_o.exports.getChildBodyCode = WR;
_o.exports.setChildBodyCode = HR;
function v8(r) {
  let e = VR(r);
  return new Function(e)();
}
function VR(r) {
  let e = X_(r), i = Math.pow(2, r);
  return `
${XR()}
${qR(r)}
${GR(r)}
${WR(r)}
${HR(r)}

function createQuadTree(options, random) {
  options = options || {};
  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;
  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;

  var gravity = options.gravity;
  var updateQueue = [];
  var insertStack = new InsertStack();
  var theta = options.theta;

  var nodesCache = [];
  var currentInCache = 0;
  var root = newNode();

  return {
    insertBodies: insertBodies,

    /**
     * Gets root node if it is present
     */
    getRoot: function() {
      return root;
    },

    updateBodyForce: update,

    options: function(newOptions) {
      if (newOptions) {
        if (typeof newOptions.gravity === 'number') {
          gravity = newOptions.gravity;
        }
        if (typeof newOptions.theta === 'number') {
          theta = newOptions.theta;
        }

        return this;
      }

      return {
        gravity: gravity,
        theta: theta
      };
    }
  };

  function newNode() {
    // To avoid pressure on GC we reuse nodes.
    var node = nodesCache[currentInCache];
    if (node) {
${a("      node.")}
      node.body = null;
      node.mass = ${e("node.mass_{var} = ", { join: "" })}0;
      ${e("node.min_{var} = node.max_{var} = ", { join: "" })}0;
    } else {
      node = new QuadNode();
      nodesCache[currentInCache] = node;
    }

    ++currentInCache;
    return node;
  }

  function update(sourceBody) {
    var queue = updateQueue;
    var v;
    ${e("var d{var};", { indent: 4 })}
    var r; 
    ${e("var f{var} = 0;", { indent: 4 })}
    var queueLength = 1;
    var shiftIdx = 0;
    var pushIdx = 1;

    queue[0] = root;

    while (queueLength) {
      var node = queue[shiftIdx];
      var body = node.body;

      queueLength -= 1;
      shiftIdx += 1;
      var differentBody = (body !== sourceBody);
      if (body && differentBody) {
        // If the current node is a leaf node (and it is not source body),
        // calculate the force exerted by the current node on body, and add this
        // amount to body's net force.
        ${e("d{var} = body.pos.{var} - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Poor man's protection against zero distance.
          ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
        }

        // This is standard gravitation force calculation but we divide
        // by r^3 to save two operations when normalizing force vector.
        v = gravity * body.mass * sourceBody.mass / (r * r * r);
        ${e("f{var} += v * d{var};", { indent: 8 })}
      } else if (differentBody) {
        // Otherwise, calculate the ratio s / r,  where s is the width of the region
        // represented by the internal node, and r is the distance between the body
        // and the node's center-of-mass
        ${e("d{var} = node.mass_{var} / node.mass - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Sorry about code duplication. I don't want to create many functions
          // right away. Just want to see performance first.
          ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
        }
        // If s / r < , treat this internal node as a single body, and calculate the
        // force it exerts on sourceBody, and add this amount to sourceBody's net force.
        if ((node.max_${ka(0)} - node.min_${ka(0)}) / r < theta) {
          // in the if statement above we consider node's width only
          // because the region was made into square during tree creation.
          // Thus there is no difference between using width or height.
          v = gravity * node.mass * sourceBody.mass / (r * r * r);
          ${e("f{var} += v * d{var};", { indent: 10 })}
        } else {
          // Otherwise, run the procedure recursively on each of the current node's children.

          // I intentionally unfolded this loop, to save several CPU cycles.
${s()}
        }
      }
    }

    ${e("sourceBody.force.{var} += f{var};", { indent: 4 })}
  }

  function insertBodies(bodies) {
    ${e("var {var}min = Number.MAX_VALUE;", { indent: 4 })}
    ${e("var {var}max = Number.MIN_VALUE;", { indent: 4 })}
    var i = bodies.length;

    // To reduce quad tree depth we are looking for exact bounding box of all particles.
    while (i--) {
      var pos = bodies[i].pos;
      ${e("if (pos.{var} < {var}min) {var}min = pos.{var};", { indent: 6 })}
      ${e("if (pos.{var} > {var}max) {var}max = pos.{var};", { indent: 6 })}
    }

    // Makes the bounds square.
    var maxSideLength = -Infinity;
    ${e("if ({var}max - {var}min > maxSideLength) maxSideLength = {var}max - {var}min ;", { indent: 4 })}

    currentInCache = 0;
    root = newNode();
    ${e("root.min_{var} = {var}min;", { indent: 4 })}
    ${e("root.max_{var} = {var}min + maxSideLength;", { indent: 4 })}

    i = bodies.length - 1;
    if (i >= 0) {
      root.body = bodies[i];
    }
    while (i--) {
      insert(bodies[i], root);
    }
  }

  function insert(newBody) {
    insertStack.reset();
    insertStack.push(root, newBody);

    while (!insertStack.isEmpty()) {
      var stackItem = insertStack.pop();
      var node = stackItem.node;
      var body = stackItem.body;

      if (!node.body) {
        // This is internal node. Update the total mass of the node and center-of-mass.
        ${e("var {var} = body.pos.{var};", { indent: 8 })}
        node.mass += body.mass;
        ${e("node.mass_{var} += body.mass * {var};", { indent: 8 })}

        // Recursively insert the body in the appropriate quadrant.
        // But first find the appropriate quadrant.
        var quadIdx = 0; // Assume we are in the 0's quad.
        ${e("var min_{var} = node.min_{var};", { indent: 8 })}
        ${e("var max_{var} = (min_{var} + node.max_{var}) / 2;", { indent: 8 })}

${n(8)}

        var child = getChild(node, quadIdx);

        if (!child) {
          // The node is internal but this quadrant is not taken. Add
          // subnode to it.
          child = newNode();
          ${e("child.min_{var} = min_{var};", { indent: 10 })}
          ${e("child.max_{var} = max_{var};", { indent: 10 })}
          child.body = body;

          setChild(node, quadIdx, child);
        } else {
          // continue searching in this quadrant.
          insertStack.push(child, body);
        }
      } else {
        // We are trying to add to the leaf node.
        // We have to convert current leaf into internal node
        // and continue adding two nodes.
        var oldBody = node.body;
        node.body = null; // internal nodes do not cary bodies

        if (isSamePosition(oldBody.pos, body.pos)) {
          // Prevent infinite subdivision by bumping one node
          // anywhere in this quadrant
          var retriesCount = 3;
          do {
            var offset = random.nextDouble();
            ${e("var d{var} = (node.max_{var} - node.min_{var}) * offset;", { indent: 12 })}

            ${e("oldBody.pos.{var} = node.min_{var} + d{var};", { indent: 12 })}
            retriesCount -= 1;
            // Make sure we don't bump it out of the box. If we do, next iteration should fix it
          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));

          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {
            // This is very bad, we ran out of precision.
            // if we do not return from the method we'll get into
            // infinite loop here. So we sacrifice correctness of layout, and keep the app running
            // Next layout iteration should get larger bounding box in the first step and fix this
            return;
          }
        }
        // Next iteration should subdivide node further.
        insertStack.push(node, oldBody);
        insertStack.push(node, body);
      }
    }
  }
}
return createQuadTree;

`;
  function n(o) {
    let l = [], u = Array(o + 1).join(" ");
    for (let c = 0; c < r; ++c)
      l.push(u + `if (${ka(c)} > max_${ka(c)}) {`), l.push(u + `  quadIdx = quadIdx + ${Math.pow(2, c)};`), l.push(u + `  min_${ka(c)} = max_${ka(c)};`), l.push(u + `  max_${ka(c)} = node.max_${ka(c)};`), l.push(u + "}");
    return l.join(`
`);
  }
  function s() {
    let o = Array(11).join(" "), l = [];
    for (let u = 0; u < i; ++u)
      l.push(o + `if (node.quad${u}) {`), l.push(o + `  queue[pushIdx] = node.quad${u};`), l.push(o + "  queueLength += 1;"), l.push(o + "  pushIdx += 1;"), l.push(o + "}");
    return l.join(`
`);
  }
  function a(o) {
    let l = [];
    for (let u = 0; u < i; ++u)
      l.push(`${o}quad${u} = null;`);
    return l.join(`
`);
  }
}
function GR(r) {
  let e = X_(r);
  return `
  function isSamePosition(point1, point2) {
    ${e("var d{var} = Math.abs(point1.{var} - point2.{var});", { indent: 2 })}
  
    return ${e("d{var} < 1e-8", { join: " && " })};
  }  
`;
}
function HR(r) {
  var e = Math.pow(2, r);
  return `
function setChild(node, idx, child) {
  ${i()}
}`;
  function i() {
    let n = [];
    for (let s = 0; s < e; ++s) {
      let a = s === 0 ? "  " : "  else ";
      n.push(`${a}if (idx === ${s}) node.quad${s} = child;`);
    }
    return n.join(`
`);
  }
}
function WR(r) {
  return `function getChild(node, idx) {
${e()}
  return null;
}`;
  function e() {
    let i = [], n = Math.pow(2, r);
    for (let s = 0; s < n; ++s)
      i.push(`  if (idx === ${s}) return node.quad${s};`);
    return i.join(`
`);
  }
}
function qR(r) {
  let e = X_(r), i = Math.pow(2, r);
  var n = `
function QuadNode() {
  // body stored inside this node. In quad tree only leaf nodes (by construction)
  // contain bodies:
  this.body = null;

  // Child nodes are stored in quads. Each quad is presented by number:
  // 0 | 1
  // -----
  // 2 | 3
${s("  this.")}

  // Total mass of current node
  this.mass = 0;

  // Center of mass coordinates
  ${e("this.mass_{var} = 0;", { indent: 2 })}

  // bounding box coordinates
  ${e("this.min_{var} = 0;", { indent: 2 })}
  ${e("this.max_{var} = 0;", { indent: 2 })}
}
`;
  return n;
  function s(a) {
    let o = [];
    for (let l = 0; l < i; ++l)
      o.push(`${a}quad${l} = null;`);
    return o.join(`
`);
  }
}
function XR() {
  return `
/**
 * Our implementation of QuadTree is non-recursive to avoid GC hit
 * This data structure represent stack of elements
 * which we are trying to insert into quad tree.
 */
function InsertStack () {
    this.stack = [];
    this.popIdx = 0;
}

InsertStack.prototype = {
    isEmpty: function() {
        return this.popIdx === 0;
    },
    push: function (node, body) {
        var item = this.stack[this.popIdx];
        if (!item) {
            // we are trying to avoid memory pressure: create new element
            // only when absolutely necessary
            this.stack[this.popIdx] = new InsertStackElement(node, body);
        } else {
            item.node = node;
            item.body = body;
        }
        ++this.popIdx;
    },
    pop: function () {
        if (this.popIdx > 0) {
            return this.stack[--this.popIdx];
        }
    },
    reset: function () {
        this.popIdx = 0;
    }
};

function InsertStackElement(node, body) {
    this.node = node; // QuadTree node
    this.body = body; // physical body which needs to be inserted to node
}
`;
}
var b8 = _o.exports, $_ = { exports: {} };
$_.exports = _8;
$_.exports.generateFunctionBody = $R;
const x8 = kc;
function _8(r) {
  let e = $R(r);
  return new Function("bodies", "settings", "random", e);
}
function $R(r) {
  let e = x8(r);
  return `
  var boundingBox = {
    ${e("min_{var}: 0, max_{var}: 0,", { indent: 4 })}
  };

  return {
    box: boundingBox,

    update: updateBoundingBox,

    reset: resetBoundingBox,

    getBestNewPosition: function (neighbors) {
      var ${e("base_{var} = 0", { join: ", " })};

      if (neighbors.length) {
        for (var i = 0; i < neighbors.length; ++i) {
          let neighborPos = neighbors[i].pos;
          ${e("base_{var} += neighborPos.{var};", { indent: 10 })}
        }

        ${e("base_{var} /= neighbors.length;", { indent: 8 })}
      } else {
        ${e("base_{var} = (boundingBox.min_{var} + boundingBox.max_{var}) / 2;", { indent: 8 })}
      }

      var springLength = settings.springLength;
      return {
        ${e("{var}: base_{var} + (random.nextDouble() - 0.5) * springLength,", { indent: 8 })}
      };
    }
  };

  function updateBoundingBox() {
    var i = bodies.length;
    if (i === 0) return; // No bodies - no borders.

    ${e("var max_{var} = -Infinity;", { indent: 4 })}
    ${e("var min_{var} = Infinity;", { indent: 4 })}

    while(i--) {
      // this is O(n), it could be done faster with quadtree, if we check the root node bounds
      var bodyPos = bodies[i].pos;
      ${e("if (bodyPos.{var} < min_{var}) min_{var} = bodyPos.{var};", { indent: 6 })}
      ${e("if (bodyPos.{var} > max_{var}) max_{var} = bodyPos.{var};", { indent: 6 })}
    }

    ${e("boundingBox.min_{var} = min_{var};", { indent: 4 })}
    ${e("boundingBox.max_{var} = max_{var};", { indent: 4 })}
  }

  function resetBoundingBox() {
    ${e("boundingBox.min_{var} = boundingBox.max_{var} = 0;", { indent: 4 })}
  }
`;
}
var T8 = $_.exports, Y_ = { exports: {} };
const S8 = kc;
Y_.exports = w8;
Y_.exports.generateCreateDragForceFunctionBody = YR;
function w8(r) {
  let e = YR(r);
  return new Function("options", e);
}
function YR(r) {
  return `
  if (!Number.isFinite(options.dragCoefficient)) throw new Error('dragCoefficient is not a finite number');

  return {
    update: function(body) {
      ${S8(r)("body.force.{var} -= options.dragCoefficient * body.velocity.{var};", { indent: 6 })}
    }
  };
`;
}
var E8 = Y_.exports, K_ = { exports: {} };
const M8 = kc;
K_.exports = A8;
K_.exports.generateCreateSpringForceFunctionBody = KR;
function A8(r) {
  let e = KR(r);
  return new Function("options", "random", e);
}
function KR(r) {
  let e = M8(r);
  return `
  if (!Number.isFinite(options.springCoefficient)) throw new Error('Spring coefficient is not a number');
  if (!Number.isFinite(options.springLength)) throw new Error('Spring length is not a number');

  return {
    /**
     * Updates forces acting on a spring
     */
    update: function (spring) {
      var body1 = spring.from;
      var body2 = spring.to;
      var length = spring.length < 0 ? options.springLength : spring.length;
      ${e("var d{var} = body2.pos.{var} - body1.pos.{var};", { indent: 6 })}
      var r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

      if (r === 0) {
        ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
      }

      var d = r - length;
      var coefficient = ((spring.coefficient > 0) ? spring.coefficient : options.springCoefficient) * d / r;

      ${e("body1.force.{var} += coefficient * d{var}", { indent: 6 })};
      body1.springCount += 1;
      body1.springLength += r;

      ${e("body2.force.{var} -= coefficient * d{var}", { indent: 6 })};
      body2.springCount += 1;
      body2.springLength += r;
    }
  };
`;
}
var C8 = K_.exports, Z_ = { exports: {} };
const R8 = kc;
Z_.exports = N8;
Z_.exports.generateIntegratorFunctionBody = ZR;
function N8(r) {
  let e = ZR(r);
  return new Function("bodies", "timeStep", "adaptiveTimeStepWeight", e);
}
function ZR(r) {
  let e = R8(r);
  return `
  var length = bodies.length;
  if (length === 0) return 0;

  ${e("var d{var} = 0, t{var} = 0;", { indent: 2 })}

  for (var i = 0; i < length; ++i) {
    var body = bodies[i];
    if (body.isPinned) continue;

    if (adaptiveTimeStepWeight && body.springCount) {
      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);
    }

    var coeff = timeStep / body.mass;

    ${e("body.velocity.{var} += coeff * body.force.{var};", { indent: 4 })}
    ${e("var v{var} = body.velocity.{var};", { indent: 4 })}
    var v = Math.sqrt(${e("v{var} * v{var}", { join: " + " })});

    if (v > 1) {
      // We normalize it so that we move within timeStep range. 
      // for the case when v <= 1 - we let velocity to fade out.
      ${e("body.velocity.{var} = v{var} / v;", { indent: 6 })}
    }

    ${e("d{var} = timeStep * body.velocity.{var};", { indent: 4 })}

    ${e("body.pos.{var} += d{var};", { indent: 4 })}

    ${e("t{var} += Math.abs(d{var});", { indent: 4 })}
  }

  return (${e("t{var} * t{var}", { join: " + " })})/length;
`;
}
var P8 = Z_.exports, Qy, zw;
function I8() {
  if (zw) return Qy;
  zw = 1, Qy = r;
  function r(e, i, n, s) {
    this.from = e, this.to = i, this.length = n, this.coefficient = s;
  }
  return Qy;
}
var Jy, jw;
function O8() {
  if (jw) return Jy;
  jw = 1, Jy = r;
  function r(e, i) {
    var n;
    if (e || (e = {}), i) {
      for (n in i)
        if (i.hasOwnProperty(n)) {
          var s = e.hasOwnProperty(n), a = typeof i[n], o = !s || typeof e[n] !== a;
          o ? e[n] = i[n] : a === "object" && (e[n] = r(e[n], i[n]));
        }
    }
    return e;
  }
  return Jy;
}
var ch = { exports: {} }, Vw;
function D8() {
  if (Vw) return ch.exports;
  Vw = 1, ch.exports = r, ch.exports.random = r, ch.exports.randomIterator = l;
  function r(u) {
    var c = typeof u == "number" ? u : +/* @__PURE__ */ new Date();
    return new e(c);
  }
  function e(u) {
    this.seed = u;
  }
  e.prototype.next = o, e.prototype.nextDouble = a, e.prototype.uniform = a, e.prototype.gaussian = i;
  function i() {
    var u, c, h;
    do
      c = this.nextDouble() * 2 - 1, h = this.nextDouble() * 2 - 1, u = c * c + h * h;
    while (u >= 1 || u === 0);
    return c * Math.sqrt(-2 * Math.log(u) / u);
  }
  e.prototype.levy = n;
  function n() {
    var u = 1.5, c = Math.pow(
      s(1 + u) * Math.sin(Math.PI * u / 2) / (s((1 + u) / 2) * u * Math.pow(2, (u - 1) / 2)),
      1 / u
    );
    return this.gaussian() * c / Math.pow(Math.abs(this.gaussian()), 1 / u);
  }
  function s(u) {
    return Math.sqrt(2 * Math.PI / u) * Math.pow(1 / Math.E * (u + 1 / (12 * u - 1 / (10 * u))), u);
  }
  function a() {
    var u = this.seed;
    return u = u + 2127912214 + (u << 12) & 4294967295, u = (u ^ 3345072700 ^ u >>> 19) & 4294967295, u = u + 374761393 + (u << 5) & 4294967295, u = (u + 3550635116 ^ u << 9) & 4294967295, u = u + 4251993797 + (u << 3) & 4294967295, u = (u ^ 3042594569 ^ u >>> 16) & 4294967295, this.seed = u, (u & 268435455) / 268435456;
  }
  function o(u) {
    return Math.floor(this.nextDouble() * u);
  }
  function l(u, c) {
    var h = c || r();
    if (typeof h.next != "function")
      throw new Error("customRandom does not match expected API: next() function is missing");
    return {
      forEach: p,
      /**
       * Shuffles array randomly, in place.
       */
      shuffle: d
    };
    function d() {
      var f, m, v;
      for (f = u.length - 1; f > 0; --f)
        m = h.next(f + 1), v = u[m], u[m] = u[f], u[f] = v;
      return u;
    }
    function p(f) {
      var m, v, y;
      for (m = u.length - 1; m > 0; --m)
        v = h.next(m + 1), y = u[v], u[v] = u[m], u[m] = y, f(y);
      u.length && f(u[0]);
    }
  }
  return ch.exports;
}
var QR = j8, L8 = y8, U8 = b8, k8 = T8, F8 = E8, B8 = C8, z8 = P8, Gw = {};
function j8(r) {
  var e = I8(), i = O8(), n = W_;
  if (r) {
    if (r.springCoeff !== void 0) throw new Error("springCoeff was renamed to springCoefficient");
    if (r.dragCoeff !== void 0) throw new Error("dragCoeff was renamed to dragCoefficient");
  }
  r = i(r, {
    /**
     * Ideal length for links (springs in physical model).
     */
    springLength: 10,
    /**
     * Hook's law coefficient. 1 - solid spring.
     */
    springCoefficient: 0.8,
    /**
     * Coulomb's law coefficient. It's used to repel nodes thus should be negative
     * if you make it positive nodes start attract each other :).
     */
    gravity: -12,
    /**
     * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).
     * The closer it's to 1 the more nodes algorithm will have to go through.
     * Setting it to one makes Barnes Hut simulation no different from
     * brute-force forces calculation (each node is considered).
     */
    theta: 0.8,
    /**
     * Drag force coefficient. Used to slow down system, thus should be less than 1.
     * The closer it is to 0 the less tight system will be.
     */
    dragCoefficient: 0.9,
    // TODO: Need to rename this to something better. E.g. `dragCoefficient`
    /**
     * Default time step (dt) for forces integration
     */
    timeStep: 0.5,
    /**
     * Adaptive time step uses average spring length to compute actual time step:
     * See: https://twitter.com/anvaka/status/1293067160755957760
     */
    adaptiveTimeStepWeight: 0,
    /**
     * This parameter defines number of dimensions of the space where simulation
     * is performed. 
     */
    dimensions: 2,
    /**
     * In debug mode more checks are performed, this will help you catch errors
     * quickly, however for production build it is recommended to turn off this flag
     * to speed up computation.
     */
    debug: !1
  });
  var s = Gw[r.dimensions];
  if (!s) {
    var a = r.dimensions;
    s = {
      Body: L8(a, r.debug),
      createQuadTree: U8(a),
      createBounds: k8(a),
      createDragForce: F8(a),
      createSpringForce: B8(a),
      integrate: z8(a)
    }, Gw[a] = s;
  }
  var o = s.Body, l = s.createQuadTree, u = s.createBounds, c = s.createDragForce, h = s.createSpringForce, d = s.integrate, p = (O) => new o(O), f = D8().random(42), m = [], v = [], y = l(r, f), g = u(m, r, f), _ = h(r, f), x = c(r), b = 0, T = [], S = /* @__PURE__ */ new Map(), w = 0;
  M("nbody", U), M("spring", C);
  var A = {
    /**
     * Array of bodies, registered with current simulator
     *
     * Note: To add new body, use addBody() method. This property is only
     * exposed for testing/performance purposes.
     */
    bodies: m,
    quadTree: y,
    /**
     * Array of springs, registered with current simulator
     *
     * Note: To add new spring, use addSpring() method. This property is only
     * exposed for testing/performance purposes.
     */
    springs: v,
    /**
     * Returns settings with which current simulator was initialized
     */
    settings: r,
    /**
     * Adds a new force to simulation
     */
    addForce: M,
    /**
     * Removes a force from the simulation.
     */
    removeForce: N,
    /**
     * Returns a map of all registered forces.
     */
    getForces: k,
    /**
     * Performs one step of force simulation.
     *
     * @returns {boolean} true if system is considered stable; False otherwise.
     */
    step: function() {
      for (var O = 0; O < T.length; ++O)
        T[O](w);
      var D = d(m, r.timeStep, r.adaptiveTimeStepWeight);
      return w += 1, D;
    },
    /**
     * Adds body to the system
     *
     * @param {ngraph.physics.primitives.Body} body physical body
     *
     * @returns {ngraph.physics.primitives.Body} added body
     */
    addBody: function(O) {
      if (!O)
        throw new Error("Body is required");
      return m.push(O), O;
    },
    /**
     * Adds body to the system at given position
     *
     * @param {Object} pos position of a body
     *
     * @returns {ngraph.physics.primitives.Body} added body
     */
    addBodyAt: function(O) {
      if (!O)
        throw new Error("Body position is required");
      var D = p(O);
      return m.push(D), D;
    },
    /**
     * Removes body from the system
     *
     * @param {ngraph.physics.primitives.Body} body to remove
     *
     * @returns {Boolean} true if body found and removed. falsy otherwise;
     */
    removeBody: function(O) {
      if (O) {
        var D = m.indexOf(O);
        if (!(D < 0))
          return m.splice(D, 1), m.length === 0 && g.reset(), !0;
      }
    },
    /**
     * Adds a spring to this simulation.
     *
     * @returns {Object} - a handle for a spring. If you want to later remove
     * spring pass it to removeSpring() method.
     */
    addSpring: function(O, D, H, j) {
      if (!O || !D)
        throw new Error("Cannot add null spring to force simulator");
      typeof H != "number" && (H = -1);
      var K = new e(O, D, H, j >= 0 ? j : -1);
      return v.push(K), K;
    },
    /**
     * Returns amount of movement performed on last step() call
     */
    getTotalMovement: function() {
      return b;
    },
    /**
     * Removes spring from the system
     *
     * @param {Object} spring to remove. Spring is an object returned by addSpring
     *
     * @returns {Boolean} true if spring found and removed. falsy otherwise;
     */
    removeSpring: function(O) {
      if (O) {
        var D = v.indexOf(O);
        if (D > -1)
          return v.splice(D, 1), !0;
      }
    },
    getBestNewBodyPosition: function(O) {
      return g.getBestNewPosition(O);
    },
    /**
     * Returns bounding box which covers all bodies
     */
    getBBox: E,
    getBoundingBox: E,
    invalidateBBox: function() {
      console.warn("invalidateBBox() is deprecated, bounds always recomputed on `getBBox()` call");
    },
    // TODO: Move the force specific stuff to force
    gravity: function(O) {
      return O !== void 0 ? (r.gravity = O, y.options({ gravity: O }), this) : r.gravity;
    },
    theta: function(O) {
      return O !== void 0 ? (r.theta = O, y.options({ theta: O }), this) : r.theta;
    },
    /**
     * Returns pseudo-random number generator instance.
     */
    random: f
  };
  return V8(r, A), n(A), A;
  function E() {
    return g.update(), g.box;
  }
  function M(O, D) {
    if (S.has(O)) throw new Error("Force " + O + " is already added");
    S.set(O, D), T.push(D);
  }
  function N(O) {
    var D = T.indexOf(S.get(O));
    D < 0 || (T.splice(D, 1), S.delete(O));
  }
  function k() {
    return S;
  }
  function U() {
    if (m.length !== 0) {
      y.insertBodies(m);
      for (var O = m.length; O--; ) {
        var D = m[O];
        D.isPinned || (D.reset(), y.updateBodyForce(D), x.update(D));
      }
    }
  }
  function C() {
    for (var O = v.length; O--; )
      _.update(v[O]);
  }
}
function V8(r, e) {
  for (var i in r)
    G8(r, e, i);
}
function G8(r, e, i) {
  if (r.hasOwnProperty(i) && typeof e[i] != "function") {
    var n = Number.isFinite(r[i]);
    n ? e[i] = function(s) {
      if (s !== void 0) {
        if (!Number.isFinite(s)) throw new Error("Value of " + i + " should be a valid number.");
        return r[i] = s, e;
      }
      return r[i];
    } : e[i] = function(s) {
      return s !== void 0 ? (r[i] = s, e) : r[i];
    };
  }
}
q_.exports = W8;
q_.exports.simulator = QR;
var H8 = W_;
function W8(r, e) {
  if (!r)
    throw new Error("Graph structure cannot be undefined");
  var i = e && e.createSimulator || QR, n = i(e);
  if (Array.isArray(e)) throw new Error("Physics settings is expected to be an object");
  var s = r.version > 19 ? U : k;
  e && typeof e.nodeMass == "function" && (s = e.nodeMass);
  var a = /* @__PURE__ */ new Map(), o = {}, l = 0, u = n.settings.springTransform || q8;
  x(), y();
  var c = !1, h = {
    /**
     * Performs one step of iterative layout algorithm
     *
     * @returns {boolean} true if the system should be considered stable; False otherwise.
     * The system is stable if no further call to `step()` can improve the layout.
     */
    step: function() {
      if (l === 0)
        return d(!0), !0;
      var C = n.step();
      h.lastMove = C, h.fire("step");
      var O = C / l, D = O <= 0.01;
      return d(D), D;
    },
    /**
     * For a given `nodeId` returns position
     */
    getNodePosition: function(C) {
      return N(C).pos;
    },
    /**
     * Sets position of a node to a given coordinates
     * @param {string} nodeId node identifier
     * @param {number} x position of a node
     * @param {number} y position of a node
     * @param {number=} z position of node (only if applicable to body)
     */
    setNodePosition: function(C) {
      var O = N(C);
      O.setPosition.apply(O, Array.prototype.slice.call(arguments, 1));
    },
    /**
     * @returns {Object} Link position by link id
     * @returns {Object.from} {x, y} coordinates of link start
     * @returns {Object.to} {x, y} coordinates of link end
     */
    getLinkPosition: function(C) {
      var O = o[C];
      if (O)
        return {
          from: O.from.pos,
          to: O.to.pos
        };
    },
    /**
     * @returns {Object} area required to fit in the graph. Object contains
     * `x1`, `y1` - top left coordinates
     * `x2`, `y2` - bottom right coordinates
     */
    getGraphRect: function() {
      return n.getBBox();
    },
    /**
     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)
     */
    forEachBody: p,
    /*
     * Requests layout algorithm to pin/unpin node to its current position
     * Pinned nodes should not be affected by layout algorithm and always
     * remain at their position
     */
    pinNode: function(C, O) {
      var D = N(C.id);
      D.isPinned = !!O;
    },
    /**
     * Checks whether given graph's node is currently pinned
     */
    isNodePinned: function(C) {
      return N(C.id).isPinned;
    },
    /**
     * Request to release all resources
     */
    dispose: function() {
      r.off("changed", _), h.fire("disposed");
    },
    /**
     * Gets physical body for a given node id. If node is not found undefined
     * value is returned.
     */
    getBody: v,
    /**
     * Gets spring for a given edge.
     *
     * @param {string} linkId link identifer. If two arguments are passed then
     * this argument is treated as formNodeId
     * @param {string=} toId when defined this parameter denotes head of the link
     * and first argument is treated as tail of the link (fromId)
     */
    getSpring: m,
    /**
     * Returns length of cumulative force vector. The closer this to zero - the more stable the system is
     */
    getForceVectorLength: f,
    /**
     * [Read only] Gets current physics simulator
     */
    simulator: n,
    /**
     * Gets the graph that was used for layout
     */
    graph: r,
    /**
     * Gets amount of movement performed during last step operation
     */
    lastMove: 0
  };
  return H8(h), h;
  function d(C) {
    c !== C && (c = C, g(C));
  }
  function p(C) {
    a.forEach(C);
  }
  function f() {
    var C = 0, O = 0;
    return p(function(D) {
      C += Math.abs(D.force.x), O += Math.abs(D.force.y);
    }), Math.sqrt(C * C + O * O);
  }
  function m(C, O) {
    var D;
    if (O === void 0)
      typeof C != "object" ? D = C : D = C.id;
    else {
      var H = r.hasLink(C, O);
      if (!H) return;
      D = H.id;
    }
    return o[D];
  }
  function v(C) {
    return a.get(C);
  }
  function y() {
    r.on("changed", _);
  }
  function g(C) {
    h.fire("stable", C);
  }
  function _(C) {
    for (var O = 0; O < C.length; ++O) {
      var D = C[O];
      D.changeType === "add" ? (D.node && b(D.node.id), D.link && S(D.link)) : D.changeType === "remove" && (D.node && T(D.node), D.link && w(D.link));
    }
    l = r.getNodesCount();
  }
  function x() {
    l = 0, r.forEachNode(function(C) {
      b(C.id), l += 1;
    }), r.forEachLink(S);
  }
  function b(C) {
    var O = a.get(C);
    if (!O) {
      var D = r.getNode(C);
      if (!D)
        throw new Error("initBody() was called with unknown node id");
      var H = D.position;
      if (!H) {
        var j = A(D);
        H = n.getBestNewBodyPosition(j);
      }
      O = n.addBodyAt(H), O.id = C, a.set(C, O), E(C), M(D) && (O.isPinned = !0);
    }
  }
  function T(C) {
    var O = C.id, D = a.get(O);
    D && (a.delete(O), n.removeBody(D));
  }
  function S(C) {
    E(C.fromId), E(C.toId);
    var O = a.get(C.fromId), D = a.get(C.toId), H = n.addSpring(O, D, C.length);
    u(C, H), o[C.id] = H;
  }
  function w(C) {
    var O = o[C.id];
    if (O) {
      var D = r.getNode(C.fromId), H = r.getNode(C.toId);
      D && E(D.id), H && E(H.id), delete o[C.id], n.removeSpring(O);
    }
  }
  function A(C) {
    var O = [];
    if (!C.links)
      return O;
    for (var D = Math.min(C.links.length, 2), H = 0; H < D; ++H) {
      var j = C.links[H], K = j.fromId !== C.id ? a.get(j.fromId) : a.get(j.toId);
      K && K.pos && O.push(K);
    }
    return O;
  }
  function E(C) {
    var O = a.get(C);
    if (O.mass = s(C), Number.isNaN(O.mass))
      throw new Error("Node mass should be a number");
  }
  function M(C) {
    return C && (C.isPinned || C.data && C.data.isPinned);
  }
  function N(C) {
    var O = a.get(C);
    return O || (b(C), O = a.get(C)), O;
  }
  function k(C) {
    var O = r.getLinks(C);
    return O ? 1 + O.length / 3 : 1;
  }
  function U(C) {
    var O = r.getLinks(C);
    return O ? 1 + O.size / 3 : 1;
  }
}
function q8() {
}
var X8 = q_.exports;
const $8 = /* @__PURE__ */ d_(X8);
function Tm(r) {
  var e = typeof r;
  return r != null && (e == "object" || e == "function");
}
var Y8 = typeof global == "object" && global && global.Object === Object && global, K8 = typeof self == "object" && self && self.Object === Object && self, JR = Y8 || K8 || Function("return this")(), ev = function() {
  return JR.Date.now();
}, Z8 = /\s/;
function Q8(r) {
  for (var e = r.length; e-- && Z8.test(r.charAt(e)); )
    ;
  return e;
}
var J8 = /^\s+/;
function eG(r) {
  return r && r.slice(0, Q8(r) + 1).replace(J8, "");
}
var Sm = JR.Symbol, eN = Object.prototype, tG = eN.hasOwnProperty, iG = eN.toString, hh = Sm ? Sm.toStringTag : void 0;
function rG(r) {
  var e = tG.call(r, hh), i = r[hh];
  try {
    r[hh] = void 0;
    var n = !0;
  } catch {
  }
  var s = iG.call(r);
  return n && (e ? r[hh] = i : delete r[hh]), s;
}
var nG = Object.prototype, sG = nG.toString;
function aG(r) {
  return sG.call(r);
}
var oG = "[object Null]", lG = "[object Undefined]", Hw = Sm ? Sm.toStringTag : void 0;
function uG(r) {
  return r == null ? r === void 0 ? lG : oG : Hw && Hw in Object(r) ? rG(r) : aG(r);
}
function cG(r) {
  return r != null && typeof r == "object";
}
var hG = "[object Symbol]";
function dG(r) {
  return typeof r == "symbol" || cG(r) && uG(r) == hG;
}
var Ww = NaN, pG = /^[-+]0x[0-9a-f]+$/i, fG = /^0b[01]+$/i, mG = /^0o[0-7]+$/i, gG = parseInt;
function qw(r) {
  if (typeof r == "number")
    return r;
  if (dG(r))
    return Ww;
  if (Tm(r)) {
    var e = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = Tm(e) ? e + "" : e;
  }
  if (typeof r != "string")
    return r === 0 ? r : +r;
  r = eG(r);
  var i = fG.test(r);
  return i || mG.test(r) ? gG(r.slice(2), i ? 2 : 8) : pG.test(r) ? Ww : +r;
}
var yG = "Expected a function", vG = Math.max, bG = Math.min;
function tN(r, e, i) {
  var n, s, a, o, l, u, c = 0, h = !1, d = !1, p = !0;
  if (typeof r != "function")
    throw new TypeError(yG);
  e = qw(e) || 0, Tm(i) && (h = !!i.leading, d = "maxWait" in i, a = d ? vG(qw(i.maxWait) || 0, e) : a, p = "trailing" in i ? !!i.trailing : p);
  function f(S) {
    var w = n, A = s;
    return n = s = void 0, c = S, o = r.apply(A, w), o;
  }
  function m(S) {
    return c = S, l = setTimeout(g, e), h ? f(S) : o;
  }
  function v(S) {
    var w = S - u, A = S - c, E = e - w;
    return d ? bG(E, a - A) : E;
  }
  function y(S) {
    var w = S - u, A = S - c;
    return u === void 0 || w >= e || w < 0 || d && A >= a;
  }
  function g() {
    var S = ev();
    if (y(S))
      return _(S);
    l = setTimeout(g, v(S));
  }
  function _(S) {
    return l = void 0, p && n ? f(S) : (n = s = void 0, o);
  }
  function x() {
    l !== void 0 && clearTimeout(l), c = 0, n = u = s = l = void 0;
  }
  function b() {
    return l === void 0 ? o : _(ev());
  }
  function T() {
    var S = ev(), w = y(S);
    if (n = arguments, s = this, u = S, w) {
      if (l === void 0)
        return m(u);
      if (d)
        return clearTimeout(l), l = setTimeout(g, e), f(u);
    }
    return l === void 0 && (l = setTimeout(g, e)), o;
  }
  return T.cancel = x, T.flush = b, T;
}
function Xw(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function xG(r) {
  if (Array.isArray(r)) return r;
}
function _G(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function TG(r, e, i) {
  return Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function SG(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function wG() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function EG(r, e) {
  return xG(r) || SG(r, e) || MG(r, e) || wG();
}
function MG(r, e) {
  if (r) {
    if (typeof r == "string") return Xw(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Xw(r, e) : void 0;
  }
}
var AG = /* @__PURE__ */ TG(function r(e, i) {
  var n = i.default, s = n === void 0 ? null : n, a = i.triggerUpdate, o = a === void 0 ? !0 : a, l = i.onChange, u = l === void 0 ? function(c, h) {
  } : l;
  _G(this, r), this.name = e, this.defaultVal = s, this.triggerUpdate = o, this.onChange = u;
});
function Pl(r) {
  var e = r.stateInit, i = e === void 0 ? function() {
    return {};
  } : e, n = r.props, s = n === void 0 ? {} : n, a = r.methods, o = a === void 0 ? {} : a, l = r.aliases, u = l === void 0 ? {} : l, c = r.init, h = c === void 0 ? function() {
  } : c, d = r.update, p = d === void 0 ? function() {
  } : d, f = Object.keys(s).map(function(m) {
    return new AG(m, s[m]);
  });
  return function m() {
    for (var v = arguments.length, y = new Array(v), g = 0; g < v; g++)
      y[g] = arguments[g];
    var _ = !!(this instanceof m && this.constructor), x = _ ? y.shift() : void 0, b = y[0], T = b === void 0 ? {} : b, S = Object.assign(
      {},
      i instanceof Function ? i(T) : i,
      // Support plain objects for backwards compatibility
      {
        initialised: !1
      }
    ), w = {};
    function A(N) {
      return E(N, T), M(), A;
    }
    var E = function(N, k) {
      h.call(A, N, S, k), S.initialised = !0;
    }, M = tN(function() {
      S.initialised && (p.call(A, S, w), w = {});
    }, 1);
    return f.forEach(function(N) {
      A[N.name] = k(N);
      function k(U) {
        var C = U.name, O = U.triggerUpdate, D = O === void 0 ? !1 : O, H = U.onChange, j = H === void 0 ? function(B, Q) {
        } : H, K = U.defaultVal, L = K === void 0 ? null : K;
        return function(B) {
          var Q = S[C];
          if (!arguments.length)
            return Q;
          var W = B === void 0 ? L : B;
          return S[C] = W, j.call(A, W, S, Q), !w.hasOwnProperty(C) && (w[C] = Q), D && M(), A;
        };
      }
    }), Object.keys(o).forEach(function(N) {
      A[N] = function() {
        for (var k, U = arguments.length, C = new Array(U), O = 0; O < U; O++)
          C[O] = arguments[O];
        return (k = o[N]).call.apply(k, [A, S].concat(C));
      };
    }), Object.entries(u).forEach(function(N) {
      var k = EG(N, 2), U = k[0], C = k[1];
      return A[U] = A[C];
    }), A.resetProps = function() {
      return f.forEach(function(N) {
        A[N.name](N.defaultVal);
      }), A;
    }, A.resetProps(), S._rerender = M, _ && x && A(x), A;
  };
}
var et = function(r) {
  return typeof r == "function" ? r : typeof r == "string" ? function(e) {
    return e[r];
  } : function(e) {
    return r;
  };
};
class $w extends Map {
  constructor(e, i = NG) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: i } }), e != null) for (const [n, s] of e) this.set(n, s);
  }
  get(e) {
    return super.get(Yw(this, e));
  }
  has(e) {
    return super.has(Yw(this, e));
  }
  set(e, i) {
    return super.set(CG(this, e), i);
  }
  delete(e) {
    return super.delete(RG(this, e));
  }
}
function Yw({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) ? r.get(n) : i;
}
function CG({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) ? r.get(n) : (r.set(n, i), i);
}
function RG({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) && (i = r.get(n), r.delete(n)), i;
}
function NG(r) {
  return r !== null && typeof r == "object" ? r.valueOf() : r;
}
function kb(r, e) {
  let i;
  if (e === void 0)
    for (const n of r)
      n != null && (i < n || i === void 0 && n >= n) && (i = n);
  else {
    let n = -1;
    for (let s of r)
      (s = e(s, ++n, r)) != null && (i < s || i === void 0 && s >= s) && (i = s);
  }
  return i;
}
function Fb(r, e) {
  let i;
  if (e === void 0)
    for (const n of r)
      n != null && (i > n || i === void 0 && n >= n) && (i = n);
  else {
    let n = -1;
    for (let s of r)
      (s = e(s, ++n, r)) != null && (i > s || i === void 0 && s >= s) && (i = s);
  }
  return i;
}
function PG(r, e) {
  let i = 0;
  for (let n of r)
    (n = +n) && (i += n);
  return i;
}
function Bb(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function IG(r) {
  if (Array.isArray(r)) return r;
}
function OG(r) {
  if (Array.isArray(r)) return Bb(r);
}
function iN(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function DG(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function LG(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function cr(r, e) {
  return r.get(iN(r, e));
}
function nu(r, e, i) {
  DG(r, e), e.set(r, i);
}
function Fp(r, e, i) {
  return r.set(iN(r, e), i), i;
}
function UG(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, WG(n.key), n);
  }
}
function kG(r, e, i) {
  return e && UG(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function FG(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function BG(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function zG() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function jG() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function VG(r, e) {
  return IG(r) || BG(r, e) || rN(r, e) || zG();
}
function GG(r) {
  return OG(r) || FG(r) || rN(r) || jG();
}
function HG(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function WG(r) {
  var e = HG(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function rN(r, e) {
  if (r) {
    if (typeof r == "string") return Bb(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Bb(r, e) : void 0;
  }
}
var su = /* @__PURE__ */ new WeakMap(), dh = /* @__PURE__ */ new WeakMap(), au = /* @__PURE__ */ new WeakMap(), tv = /* @__PURE__ */ new WeakMap(), iv = /* @__PURE__ */ new WeakMap(), rv = /* @__PURE__ */ new WeakMap(), qG = /* @__PURE__ */ function() {
  function r() {
    LG(this, r), nu(this, su, /* @__PURE__ */ new Map()), nu(this, dh, /* @__PURE__ */ new Map()), nu(this, au, function(e) {
      return e;
    }), nu(this, tv, function() {
      return {};
    }), nu(this, iv, function() {
    }), nu(this, rv, function() {
    });
  }
  return kG(r, [{
    key: "getObj",
    value: function(e) {
      return cr(su, this).get(cr(au, this).call(this, e));
    }
  }, {
    key: "getData",
    value: function(e) {
      return cr(dh, this).get(e);
    }
  }, {
    key: "entries",
    value: function() {
      return GG(cr(dh, this).entries()).map(function(e) {
        var i = VG(e, 2), n = i[0], s = i[1];
        return [s, n];
      });
    }
  }, {
    key: "id",
    value: function(e) {
      return Fp(au, this, et(e)), this;
    }
  }, {
    key: "onCreateObj",
    value: function(e) {
      return Fp(tv, this, e), this;
    }
  }, {
    key: "onUpdateObj",
    value: function(e) {
      return Fp(iv, this, e), this;
    }
  }, {
    key: "onRemoveObj",
    value: function(e) {
      return Fp(rv, this, e), this;
    }
  }, {
    key: "digest",
    value: function(e) {
      var i = this;
      e.filter(function(s) {
        return !cr(su, i).has(cr(au, i).call(i, s));
      }).forEach(function(s) {
        var a = cr(tv, i).call(i, s);
        cr(su, i).set(cr(au, i).call(i, s), a), cr(dh, i).set(a, s);
      });
      var n = new Map(e.map(function(s) {
        return [cr(au, i).call(i, s), s];
      }));
      return cr(su, this).forEach(function(s, a) {
        n.has(a) ? cr(iv, i).call(i, s, n.get(a)) : (cr(rv, i).call(i, s, a), cr(su, i).delete(a), cr(dh, i).delete(s));
      }), this;
    }
  }, {
    key: "clear",
    value: function() {
      return this.digest([]), this;
    }
  }]);
}();
function XG(r, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(r);
      break;
    default:
      this.range(e).domain(r);
      break;
  }
  return this;
}
const Kw = Symbol("implicit");
function Q_() {
  var r = new $w(), e = [], i = [], n = Kw;
  function s(a) {
    let o = r.get(a);
    if (o === void 0) {
      if (n !== Kw) return n;
      r.set(a, o = e.push(a) - 1);
    }
    return i[o % i.length];
  }
  return s.domain = function(a) {
    if (!arguments.length) return e.slice();
    e = [], r = new $w();
    for (const o of a)
      r.has(o) || r.set(o, e.push(o) - 1);
    return s;
  }, s.range = function(a) {
    return arguments.length ? (i = Array.from(a), s) : i.slice();
  }, s.unknown = function(a) {
    return arguments.length ? (n = a, s) : n;
  }, s.copy = function() {
    return Q_(e, i).unknown(n);
  }, XG.apply(s, arguments), s;
}
function J_(r, e, i) {
  r.prototype = e.prototype = i, i.constructor = r;
}
function nN(r, e) {
  var i = Object.create(r.prototype);
  for (var n in e) i[n] = e[n];
  return i;
}
function Wd() {
}
var pd = 0.7, wm = 1 / pd, qu = "\\s*([+-]?\\d+)\\s*", fd = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", ys = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", $G = /^#([0-9a-f]{3,8})$/, YG = new RegExp(`^rgb\\(${qu},${qu},${qu}\\)$`), KG = new RegExp(`^rgb\\(${ys},${ys},${ys}\\)$`), ZG = new RegExp(`^rgba\\(${qu},${qu},${qu},${fd}\\)$`), QG = new RegExp(`^rgba\\(${ys},${ys},${ys},${fd}\\)$`), JG = new RegExp(`^hsl\\(${fd},${ys},${ys}\\)$`), eH = new RegExp(`^hsla\\(${fd},${ys},${ys},${fd}\\)$`), Zw = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
J_(Wd, md, {
  copy(r) {
    return Object.assign(new this.constructor(), this, r);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Qw,
  // Deprecated! Use color.formatHex.
  formatHex: Qw,
  formatHex8: tH,
  formatHsl: iH,
  formatRgb: Jw,
  toString: Jw
});
function Qw() {
  return this.rgb().formatHex();
}
function tH() {
  return this.rgb().formatHex8();
}
function iH() {
  return sN(this).formatHsl();
}
function Jw() {
  return this.rgb().formatRgb();
}
function md(r) {
  var e, i;
  return r = (r + "").trim().toLowerCase(), (e = $G.exec(r)) ? (i = e[1].length, e = parseInt(e[1], 16), i === 6 ? eE(e) : i === 3 ? new kr(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : i === 8 ? Bp(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : i === 4 ? Bp(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = YG.exec(r)) ? new kr(e[1], e[2], e[3], 1) : (e = KG.exec(r)) ? new kr(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = ZG.exec(r)) ? Bp(e[1], e[2], e[3], e[4]) : (e = QG.exec(r)) ? Bp(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = JG.exec(r)) ? rE(e[1], e[2] / 100, e[3] / 100, 1) : (e = eH.exec(r)) ? rE(e[1], e[2] / 100, e[3] / 100, e[4]) : Zw.hasOwnProperty(r) ? eE(Zw[r]) : r === "transparent" ? new kr(NaN, NaN, NaN, 0) : null;
}
function eE(r) {
  return new kr(r >> 16 & 255, r >> 8 & 255, r & 255, 1);
}
function Bp(r, e, i, n) {
  return n <= 0 && (r = e = i = NaN), new kr(r, e, i, n);
}
function rH(r) {
  return r instanceof Wd || (r = md(r)), r ? (r = r.rgb(), new kr(r.r, r.g, r.b, r.opacity)) : new kr();
}
function zb(r, e, i, n) {
  return arguments.length === 1 ? rH(r) : new kr(r, e, i, n ?? 1);
}
function kr(r, e, i, n) {
  this.r = +r, this.g = +e, this.b = +i, this.opacity = +n;
}
J_(kr, zb, nN(Wd, {
  brighter(r) {
    return r = r == null ? wm : Math.pow(wm, r), new kr(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? pd : Math.pow(pd, r), new kr(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new kr(ml(this.r), ml(this.g), ml(this.b), Em(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: tE,
  // Deprecated! Use color.formatHex.
  formatHex: tE,
  formatHex8: nH,
  formatRgb: iE,
  toString: iE
}));
function tE() {
  return `#${sl(this.r)}${sl(this.g)}${sl(this.b)}`;
}
function nH() {
  return `#${sl(this.r)}${sl(this.g)}${sl(this.b)}${sl((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function iE() {
  const r = Em(this.opacity);
  return `${r === 1 ? "rgb(" : "rgba("}${ml(this.r)}, ${ml(this.g)}, ${ml(this.b)}${r === 1 ? ")" : `, ${r})`}`;
}
function Em(r) {
  return isNaN(r) ? 1 : Math.max(0, Math.min(1, r));
}
function ml(r) {
  return Math.max(0, Math.min(255, Math.round(r) || 0));
}
function sl(r) {
  return r = ml(r), (r < 16 ? "0" : "") + r.toString(16);
}
function rE(r, e, i, n) {
  return n <= 0 ? r = e = i = NaN : i <= 0 || i >= 1 ? r = e = NaN : e <= 0 && (r = NaN), new Wn(r, e, i, n);
}
function sN(r) {
  if (r instanceof Wn) return new Wn(r.h, r.s, r.l, r.opacity);
  if (r instanceof Wd || (r = md(r)), !r) return new Wn();
  if (r instanceof Wn) return r;
  r = r.rgb();
  var e = r.r / 255, i = r.g / 255, n = r.b / 255, s = Math.min(e, i, n), a = Math.max(e, i, n), o = NaN, l = a - s, u = (a + s) / 2;
  return l ? (e === a ? o = (i - n) / l + (i < n) * 6 : i === a ? o = (n - e) / l + 2 : o = (e - i) / l + 4, l /= u < 0.5 ? a + s : 2 - a - s, o *= 60) : l = u > 0 && u < 1 ? 0 : o, new Wn(o, l, u, r.opacity);
}
function sH(r, e, i, n) {
  return arguments.length === 1 ? sN(r) : new Wn(r, e, i, n ?? 1);
}
function Wn(r, e, i, n) {
  this.h = +r, this.s = +e, this.l = +i, this.opacity = +n;
}
J_(Wn, sH, nN(Wd, {
  brighter(r) {
    return r = r == null ? wm : Math.pow(wm, r), new Wn(this.h, this.s, this.l * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? pd : Math.pow(pd, r), new Wn(this.h, this.s, this.l * r, this.opacity);
  },
  rgb() {
    var r = this.h % 360 + (this.h < 0) * 360, e = isNaN(r) || isNaN(this.s) ? 0 : this.s, i = this.l, n = i + (i < 0.5 ? i : 1 - i) * e, s = 2 * i - n;
    return new kr(
      nv(r >= 240 ? r - 240 : r + 120, s, n),
      nv(r, s, n),
      nv(r < 120 ? r + 240 : r - 120, s, n),
      this.opacity
    );
  },
  clamp() {
    return new Wn(nE(this.h), zp(this.s), zp(this.l), Em(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const r = Em(this.opacity);
    return `${r === 1 ? "hsl(" : "hsla("}${nE(this.h)}, ${zp(this.s) * 100}%, ${zp(this.l) * 100}%${r === 1 ? ")" : `, ${r})`}`;
  }
}));
function nE(r) {
  return r = (r || 0) % 360, r < 0 ? r + 360 : r;
}
function zp(r) {
  return Math.max(0, Math.min(1, r || 0));
}
function nv(r, e, i) {
  return (r < 60 ? e + (i - e) * r / 60 : r < 180 ? i : r < 240 ? e + (i - e) * (240 - r) / 60 : e) * 255;
}
const aN = (r) => () => r;
function aH(r, e) {
  return function(i) {
    return r + i * e;
  };
}
function oH(r, e, i) {
  return r = Math.pow(r, i), e = Math.pow(e, i) - r, i = 1 / i, function(n) {
    return Math.pow(r + n * e, i);
  };
}
function lH(r) {
  return (r = +r) == 1 ? oN : function(e, i) {
    return i - e ? oH(e, i, r) : aN(isNaN(e) ? i : e);
  };
}
function oN(r, e) {
  var i = e - r;
  return i ? aH(r, i) : aN(isNaN(r) ? e : r);
}
const sE = function r(e) {
  var i = lH(e);
  function n(s, a) {
    var o = i((s = zb(s)).r, (a = zb(a)).r), l = i(s.g, a.g), u = i(s.b, a.b), c = oN(s.opacity, a.opacity);
    return function(h) {
      return s.r = o(h), s.g = l(h), s.b = u(h), s.opacity = c(h), s + "";
    };
  }
  return n.gamma = r, n;
}(1);
function Ka(r, e) {
  return r = +r, e = +e, function(i) {
    return r * (1 - i) + e * i;
  };
}
var jb = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, sv = new RegExp(jb.source, "g");
function uH(r) {
  return function() {
    return r;
  };
}
function cH(r) {
  return function(e) {
    return r(e) + "";
  };
}
function hH(r, e) {
  var i = jb.lastIndex = sv.lastIndex = 0, n, s, a, o = -1, l = [], u = [];
  for (r = r + "", e = e + ""; (n = jb.exec(r)) && (s = sv.exec(e)); )
    (a = s.index) > i && (a = e.slice(i, a), l[o] ? l[o] += a : l[++o] = a), (n = n[0]) === (s = s[0]) ? l[o] ? l[o] += s : l[++o] = s : (l[++o] = null, u.push({ i: o, x: Ka(n, s) })), i = sv.lastIndex;
  return i < e.length && (a = e.slice(i), l[o] ? l[o] += a : l[++o] = a), l.length < 2 ? u[0] ? cH(u[0].x) : uH(e) : (e = u.length, function(c) {
    for (var h = 0, d; h < e; ++h) l[(d = u[h]).i] = d.x(c);
    return l.join("");
  });
}
var aE = 180 / Math.PI, lN = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function uN(r, e, i, n, s, a) {
  var o, l, u;
  return (o = Math.sqrt(r * r + e * e)) && (r /= o, e /= o), (u = r * i + e * n) && (i -= r * u, n -= e * u), (l = Math.sqrt(i * i + n * n)) && (i /= l, n /= l, u /= l), r * n < e * i && (r = -r, e = -e, u = -u, o = -o), {
    translateX: s,
    translateY: a,
    rotate: Math.atan2(e, r) * aE,
    skewX: Math.atan(u) * aE,
    scaleX: o,
    scaleY: l
  };
}
var jp;
function dH(r) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(r + "");
  return e.isIdentity ? lN : uN(e.a, e.b, e.c, e.d, e.e, e.f);
}
function pH(r) {
  return r == null || (jp || (jp = document.createElementNS("http://www.w3.org/2000/svg", "g")), jp.setAttribute("transform", r), !(r = jp.transform.baseVal.consolidate())) ? lN : (r = r.matrix, uN(r.a, r.b, r.c, r.d, r.e, r.f));
}
function cN(r, e, i, n) {
  function s(c) {
    return c.length ? c.pop() + " " : "";
  }
  function a(c, h, d, p, f, m) {
    if (c !== d || h !== p) {
      var v = f.push("translate(", null, e, null, i);
      m.push({ i: v - 4, x: Ka(c, d) }, { i: v - 2, x: Ka(h, p) });
    } else (d || p) && f.push("translate(" + d + e + p + i);
  }
  function o(c, h, d, p) {
    c !== h ? (c - h > 180 ? h += 360 : h - c > 180 && (c += 360), p.push({ i: d.push(s(d) + "rotate(", null, n) - 2, x: Ka(c, h) })) : h && d.push(s(d) + "rotate(" + h + n);
  }
  function l(c, h, d, p) {
    c !== h ? p.push({ i: d.push(s(d) + "skewX(", null, n) - 2, x: Ka(c, h) }) : h && d.push(s(d) + "skewX(" + h + n);
  }
  function u(c, h, d, p, f, m) {
    if (c !== d || h !== p) {
      var v = f.push(s(f) + "scale(", null, ",", null, ")");
      m.push({ i: v - 4, x: Ka(c, d) }, { i: v - 2, x: Ka(h, p) });
    } else (d !== 1 || p !== 1) && f.push(s(f) + "scale(" + d + "," + p + ")");
  }
  return function(c, h) {
    var d = [], p = [];
    return c = r(c), h = r(h), a(c.translateX, c.translateY, h.translateX, h.translateY, d, p), o(c.rotate, h.rotate, d, p), l(c.skewX, h.skewX, d, p), u(c.scaleX, c.scaleY, h.scaleX, h.scaleY, d, p), c = h = null, function(f) {
      for (var m = -1, v = p.length, y; ++m < v; ) d[(y = p[m]).i] = y.x(f);
      return d.join("");
    };
  };
}
var fH = cN(dH, "px, ", "px)", "deg)"), mH = cN(pH, ", ", ")", ")"), gH = 1e-12;
function oE(r) {
  return ((r = Math.exp(r)) + 1 / r) / 2;
}
function yH(r) {
  return ((r = Math.exp(r)) - 1 / r) / 2;
}
function vH(r) {
  return ((r = Math.exp(2 * r)) - 1) / (r + 1);
}
const bH = function r(e, i, n) {
  function s(a, o) {
    var l = a[0], u = a[1], c = a[2], h = o[0], d = o[1], p = o[2], f = h - l, m = d - u, v = f * f + m * m, y, g;
    if (v < gH)
      g = Math.log(p / c) / e, y = function(w) {
        return [
          l + w * f,
          u + w * m,
          c * Math.exp(e * w * g)
        ];
      };
    else {
      var _ = Math.sqrt(v), x = (p * p - c * c + n * v) / (2 * c * i * _), b = (p * p - c * c - n * v) / (2 * p * i * _), T = Math.log(Math.sqrt(x * x + 1) - x), S = Math.log(Math.sqrt(b * b + 1) - b);
      g = (S - T) / e, y = function(w) {
        var A = w * g, E = oE(T), M = c / (i * _) * (E * vH(e * A + T) - yH(T));
        return [
          l + M * f,
          u + M * m,
          c * E / oE(e * A + T)
        ];
      };
    }
    return y.duration = g * 1e3 * e / Math.SQRT2, y;
  }
  return s.rho = function(a) {
    var o = Math.max(1e-3, +a), l = o * o, u = l * l;
    return r(o, l, u);
  }, s;
}(Math.SQRT2, 2, 4);
function xH(r) {
  for (var e = r.length / 6 | 0, i = new Array(e), n = 0; n < e; ) i[n] = "#" + r.slice(n * 6, ++n * 6);
  return i;
}
const hN = xH("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
function Mm(r) {
  "@babel/helpers - typeof";
  return Mm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Mm(r);
}
var _H = /^\s+/, TH = /\s+$/;
function it(r, e) {
  if (r = r || "", e = e || {}, r instanceof it)
    return r;
  if (!(this instanceof it))
    return new it(r, e);
  var i = SH(r);
  this._originalInput = r, this._r = i.r, this._g = i.g, this._b = i.b, this._a = i.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e.format || i.format, this._gradientType = e.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = i.ok;
}
it.prototype = {
  isDark: function() {
    return this.getBrightness() < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  isValid: function() {
    return this._ok;
  },
  getOriginalInput: function() {
    return this._originalInput;
  },
  getFormat: function() {
    return this._format;
  },
  getAlpha: function() {
    return this._a;
  },
  getBrightness: function() {
    var r = this.toRgb();
    return (r.r * 299 + r.g * 587 + r.b * 114) / 1e3;
  },
  getLuminance: function() {
    var r = this.toRgb(), e, i, n, s, a, o;
    return e = r.r / 255, i = r.g / 255, n = r.b / 255, e <= 0.03928 ? s = e / 12.92 : s = Math.pow((e + 0.055) / 1.055, 2.4), i <= 0.03928 ? a = i / 12.92 : a = Math.pow((i + 0.055) / 1.055, 2.4), n <= 0.03928 ? o = n / 12.92 : o = Math.pow((n + 0.055) / 1.055, 2.4), 0.2126 * s + 0.7152 * a + 0.0722 * o;
  },
  setAlpha: function(r) {
    return this._a = dN(r), this._roundA = Math.round(100 * this._a) / 100, this;
  },
  toHsv: function() {
    var r = uE(this._r, this._g, this._b);
    return {
      h: r.h * 360,
      s: r.s,
      v: r.v,
      a: this._a
    };
  },
  toHsvString: function() {
    var r = uE(this._r, this._g, this._b), e = Math.round(r.h * 360), i = Math.round(r.s * 100), n = Math.round(r.v * 100);
    return this._a == 1 ? "hsv(" + e + ", " + i + "%, " + n + "%)" : "hsva(" + e + ", " + i + "%, " + n + "%, " + this._roundA + ")";
  },
  toHsl: function() {
    var r = lE(this._r, this._g, this._b);
    return {
      h: r.h * 360,
      s: r.s,
      l: r.l,
      a: this._a
    };
  },
  toHslString: function() {
    var r = lE(this._r, this._g, this._b), e = Math.round(r.h * 360), i = Math.round(r.s * 100), n = Math.round(r.l * 100);
    return this._a == 1 ? "hsl(" + e + ", " + i + "%, " + n + "%)" : "hsla(" + e + ", " + i + "%, " + n + "%, " + this._roundA + ")";
  },
  toHex: function(r) {
    return cE(this._r, this._g, this._b, r);
  },
  toHexString: function(r) {
    return "#" + this.toHex(r);
  },
  toHex8: function(r) {
    return AH(this._r, this._g, this._b, this._a, r);
  },
  toHex8String: function(r) {
    return "#" + this.toHex8(r);
  },
  toRgb: function() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function() {
    return {
      r: Math.round(fi(this._r, 255) * 100) + "%",
      g: Math.round(fi(this._g, 255) * 100) + "%",
      b: Math.round(fi(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(fi(this._r, 255) * 100) + "%, " + Math.round(fi(this._g, 255) * 100) + "%, " + Math.round(fi(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(fi(this._r, 255) * 100) + "%, " + Math.round(fi(this._g, 255) * 100) + "%, " + Math.round(fi(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function() {
    return this._a === 0 ? "transparent" : this._a < 1 ? !1 : BH[cE(this._r, this._g, this._b, !0)] || !1;
  },
  toFilter: function(r) {
    var e = "#" + hE(this._r, this._g, this._b, this._a), i = e, n = this._gradientType ? "GradientType = 1, " : "";
    if (r) {
      var s = it(r);
      i = "#" + hE(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + n + "startColorstr=" + e + ",endColorstr=" + i + ")";
  },
  toString: function(r) {
    var e = !!r;
    r = r || this._format;
    var i = !1, n = this._a < 1 && this._a >= 0, s = !e && n && (r === "hex" || r === "hex6" || r === "hex3" || r === "hex4" || r === "hex8" || r === "name");
    return s ? r === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (r === "rgb" && (i = this.toRgbString()), r === "prgb" && (i = this.toPercentageRgbString()), (r === "hex" || r === "hex6") && (i = this.toHexString()), r === "hex3" && (i = this.toHexString(!0)), r === "hex4" && (i = this.toHex8String(!0)), r === "hex8" && (i = this.toHex8String()), r === "name" && (i = this.toName()), r === "hsl" && (i = this.toHslString()), r === "hsv" && (i = this.toHsvString()), i || this.toHexString());
  },
  clone: function() {
    return it(this.toString());
  },
  _applyModification: function(r, e) {
    var i = r.apply(null, [this].concat([].slice.call(e)));
    return this._r = i._r, this._g = i._g, this._b = i._b, this.setAlpha(i._a), this;
  },
  lighten: function() {
    return this._applyModification(PH, arguments);
  },
  brighten: function() {
    return this._applyModification(IH, arguments);
  },
  darken: function() {
    return this._applyModification(OH, arguments);
  },
  desaturate: function() {
    return this._applyModification(CH, arguments);
  },
  saturate: function() {
    return this._applyModification(RH, arguments);
  },
  greyscale: function() {
    return this._applyModification(NH, arguments);
  },
  spin: function() {
    return this._applyModification(DH, arguments);
  },
  _applyCombination: function(r, e) {
    return r.apply(null, [this].concat([].slice.call(e)));
  },
  analogous: function() {
    return this._applyCombination(kH, arguments);
  },
  complement: function() {
    return this._applyCombination(LH, arguments);
  },
  monochromatic: function() {
    return this._applyCombination(FH, arguments);
  },
  splitcomplement: function() {
    return this._applyCombination(UH, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function() {
    return this._applyCombination(dE, [3]);
  },
  tetrad: function() {
    return this._applyCombination(dE, [4]);
  }
};
it.fromRatio = function(r, e) {
  if (Mm(r) == "object") {
    var i = {};
    for (var n in r)
      r.hasOwnProperty(n) && (n === "a" ? i[n] = r[n] : i[n] = zh(r[n]));
    r = i;
  }
  return it(r, e);
};
function SH(r) {
  var e = {
    r: 0,
    g: 0,
    b: 0
  }, i = 1, n = null, s = null, a = null, o = !1, l = !1;
  return typeof r == "string" && (r = GH(r)), Mm(r) == "object" && (Os(r.r) && Os(r.g) && Os(r.b) ? (e = wH(r.r, r.g, r.b), o = !0, l = String(r.r).substr(-1) === "%" ? "prgb" : "rgb") : Os(r.h) && Os(r.s) && Os(r.v) ? (n = zh(r.s), s = zh(r.v), e = MH(r.h, n, s), o = !0, l = "hsv") : Os(r.h) && Os(r.s) && Os(r.l) && (n = zh(r.s), a = zh(r.l), e = EH(r.h, n, a), o = !0, l = "hsl"), r.hasOwnProperty("a") && (i = r.a)), i = dN(i), {
    ok: o,
    format: r.format || l,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: i
  };
}
function wH(r, e, i) {
  return {
    r: fi(r, 255) * 255,
    g: fi(e, 255) * 255,
    b: fi(i, 255) * 255
  };
}
function lE(r, e, i) {
  r = fi(r, 255), e = fi(e, 255), i = fi(i, 255);
  var n = Math.max(r, e, i), s = Math.min(r, e, i), a, o, l = (n + s) / 2;
  if (n == s)
    a = o = 0;
  else {
    var u = n - s;
    switch (o = l > 0.5 ? u / (2 - n - s) : u / (n + s), n) {
      case r:
        a = (e - i) / u + (e < i ? 6 : 0);
        break;
      case e:
        a = (i - r) / u + 2;
        break;
      case i:
        a = (r - e) / u + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s: o,
    l
  };
}
function EH(r, e, i) {
  var n, s, a;
  r = fi(r, 360), e = fi(e, 100), i = fi(i, 100);
  function o(c, h, d) {
    return d < 0 && (d += 1), d > 1 && (d -= 1), d < 1 / 6 ? c + (h - c) * 6 * d : d < 1 / 2 ? h : d < 2 / 3 ? c + (h - c) * (2 / 3 - d) * 6 : c;
  }
  if (e === 0)
    n = s = a = i;
  else {
    var l = i < 0.5 ? i * (1 + e) : i + e - i * e, u = 2 * i - l;
    n = o(u, l, r + 1 / 3), s = o(u, l, r), a = o(u, l, r - 1 / 3);
  }
  return {
    r: n * 255,
    g: s * 255,
    b: a * 255
  };
}
function uE(r, e, i) {
  r = fi(r, 255), e = fi(e, 255), i = fi(i, 255);
  var n = Math.max(r, e, i), s = Math.min(r, e, i), a, o, l = n, u = n - s;
  if (o = n === 0 ? 0 : u / n, n == s)
    a = 0;
  else {
    switch (n) {
      case r:
        a = (e - i) / u + (e < i ? 6 : 0);
        break;
      case e:
        a = (i - r) / u + 2;
        break;
      case i:
        a = (r - e) / u + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s: o,
    v: l
  };
}
function MH(r, e, i) {
  r = fi(r, 360) * 6, e = fi(e, 100), i = fi(i, 100);
  var n = Math.floor(r), s = r - n, a = i * (1 - e), o = i * (1 - s * e), l = i * (1 - (1 - s) * e), u = n % 6, c = [i, o, a, a, l, i][u], h = [l, i, i, o, a, a][u], d = [a, a, l, i, i, o][u];
  return {
    r: c * 255,
    g: h * 255,
    b: d * 255
  };
}
function cE(r, e, i, n) {
  var s = [$n(Math.round(r).toString(16)), $n(Math.round(e).toString(16)), $n(Math.round(i).toString(16))];
  return n && s[0].charAt(0) == s[0].charAt(1) && s[1].charAt(0) == s[1].charAt(1) && s[2].charAt(0) == s[2].charAt(1) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) : s.join("");
}
function AH(r, e, i, n, s) {
  var a = [$n(Math.round(r).toString(16)), $n(Math.round(e).toString(16)), $n(Math.round(i).toString(16)), $n(pN(n))];
  return s && a[0].charAt(0) == a[0].charAt(1) && a[1].charAt(0) == a[1].charAt(1) && a[2].charAt(0) == a[2].charAt(1) && a[3].charAt(0) == a[3].charAt(1) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("");
}
function hE(r, e, i, n) {
  var s = [$n(pN(n)), $n(Math.round(r).toString(16)), $n(Math.round(e).toString(16)), $n(Math.round(i).toString(16))];
  return s.join("");
}
it.equals = function(r, e) {
  return !r || !e ? !1 : it(r).toRgbString() == it(e).toRgbString();
};
it.random = function() {
  return it.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function CH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = it(r).toHsl();
  return i.s -= e / 100, i.s = Mg(i.s), it(i);
}
function RH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = it(r).toHsl();
  return i.s += e / 100, i.s = Mg(i.s), it(i);
}
function NH(r) {
  return it(r).desaturate(100);
}
function PH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = it(r).toHsl();
  return i.l += e / 100, i.l = Mg(i.l), it(i);
}
function IH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = it(r).toRgb();
  return i.r = Math.max(0, Math.min(255, i.r - Math.round(255 * -(e / 100)))), i.g = Math.max(0, Math.min(255, i.g - Math.round(255 * -(e / 100)))), i.b = Math.max(0, Math.min(255, i.b - Math.round(255 * -(e / 100)))), it(i);
}
function OH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = it(r).toHsl();
  return i.l -= e / 100, i.l = Mg(i.l), it(i);
}
function DH(r, e) {
  var i = it(r).toHsl(), n = (i.h + e) % 360;
  return i.h = n < 0 ? 360 + n : n, it(i);
}
function LH(r) {
  var e = it(r).toHsl();
  return e.h = (e.h + 180) % 360, it(e);
}
function dE(r, e) {
  if (isNaN(e) || e <= 0)
    throw new Error("Argument to polyad must be a positive number");
  for (var i = it(r).toHsl(), n = [it(r)], s = 360 / e, a = 1; a < e; a++)
    n.push(it({
      h: (i.h + a * s) % 360,
      s: i.s,
      l: i.l
    }));
  return n;
}
function UH(r) {
  var e = it(r).toHsl(), i = e.h;
  return [it(r), it({
    h: (i + 72) % 360,
    s: e.s,
    l: e.l
  }), it({
    h: (i + 216) % 360,
    s: e.s,
    l: e.l
  })];
}
function kH(r, e, i) {
  e = e || 6, i = i || 30;
  var n = it(r).toHsl(), s = 360 / i, a = [it(r)];
  for (n.h = (n.h - (s * e >> 1) + 720) % 360; --e; )
    n.h = (n.h + s) % 360, a.push(it(n));
  return a;
}
function FH(r, e) {
  e = e || 6;
  for (var i = it(r).toHsv(), n = i.h, s = i.s, a = i.v, o = [], l = 1 / e; e--; )
    o.push(it({
      h: n,
      s,
      v: a
    })), a = (a + l) % 1;
  return o;
}
it.mix = function(r, e, i) {
  i = i === 0 ? 0 : i || 50;
  var n = it(r).toRgb(), s = it(e).toRgb(), a = i / 100, o = {
    r: (s.r - n.r) * a + n.r,
    g: (s.g - n.g) * a + n.g,
    b: (s.b - n.b) * a + n.b,
    a: (s.a - n.a) * a + n.a
  };
  return it(o);
};
it.readability = function(r, e) {
  var i = it(r), n = it(e);
  return (Math.max(i.getLuminance(), n.getLuminance()) + 0.05) / (Math.min(i.getLuminance(), n.getLuminance()) + 0.05);
};
it.isReadable = function(r, e, i) {
  var n = it.readability(r, e), s, a;
  switch (a = !1, s = HH(i), s.level + s.size) {
    case "AAsmall":
    case "AAAlarge":
      a = n >= 4.5;
      break;
    case "AAlarge":
      a = n >= 3;
      break;
    case "AAAsmall":
      a = n >= 7;
      break;
  }
  return a;
};
it.mostReadable = function(r, e, i) {
  var n = null, s = 0, a, o, l, u;
  i = i || {}, o = i.includeFallbackColors, l = i.level, u = i.size;
  for (var c = 0; c < e.length; c++)
    a = it.readability(r, e[c]), a > s && (s = a, n = it(e[c]));
  return it.isReadable(r, n, {
    level: l,
    size: u
  }) || !o ? n : (i.includeFallbackColors = !1, it.mostReadable(r, ["#fff", "#000"], i));
};
var Vb = it.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
}, BH = it.hexNames = zH(Vb);
function zH(r) {
  var e = {};
  for (var i in r)
    r.hasOwnProperty(i) && (e[r[i]] = i);
  return e;
}
function dN(r) {
  return r = parseFloat(r), (isNaN(r) || r < 0 || r > 1) && (r = 1), r;
}
function fi(r, e) {
  jH(r) && (r = "100%");
  var i = VH(r);
  return r = Math.min(e, Math.max(0, parseFloat(r))), i && (r = parseInt(r * e, 10) / 100), Math.abs(r - e) < 1e-6 ? 1 : r % e / parseFloat(e);
}
function Mg(r) {
  return Math.min(1, Math.max(0, r));
}
function rn(r) {
  return parseInt(r, 16);
}
function jH(r) {
  return typeof r == "string" && r.indexOf(".") != -1 && parseFloat(r) === 1;
}
function VH(r) {
  return typeof r == "string" && r.indexOf("%") != -1;
}
function $n(r) {
  return r.length == 1 ? "0" + r : "" + r;
}
function zh(r) {
  return r <= 1 && (r = r * 100 + "%"), r;
}
function pN(r) {
  return Math.round(parseFloat(r) * 255).toString(16);
}
function pE(r) {
  return rn(r) / 255;
}
var Ln = function() {
  var r = "[-\\+]?\\d+%?", e = "[-\\+]?\\d*\\.\\d+%?", i = "(?:" + e + ")|(?:" + r + ")", n = "[\\s|\\(]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")\\s*\\)?", s = "[\\s|\\(]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(i),
    rgb: new RegExp("rgb" + n),
    rgba: new RegExp("rgba" + s),
    hsl: new RegExp("hsl" + n),
    hsla: new RegExp("hsla" + s),
    hsv: new RegExp("hsv" + n),
    hsva: new RegExp("hsva" + s),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function Os(r) {
  return !!Ln.CSS_UNIT.exec(r);
}
function GH(r) {
  r = r.replace(_H, "").replace(TH, "").toLowerCase();
  var e = !1;
  if (Vb[r])
    r = Vb[r], e = !0;
  else if (r == "transparent")
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  var i;
  return (i = Ln.rgb.exec(r)) ? {
    r: i[1],
    g: i[2],
    b: i[3]
  } : (i = Ln.rgba.exec(r)) ? {
    r: i[1],
    g: i[2],
    b: i[3],
    a: i[4]
  } : (i = Ln.hsl.exec(r)) ? {
    h: i[1],
    s: i[2],
    l: i[3]
  } : (i = Ln.hsla.exec(r)) ? {
    h: i[1],
    s: i[2],
    l: i[3],
    a: i[4]
  } : (i = Ln.hsv.exec(r)) ? {
    h: i[1],
    s: i[2],
    v: i[3]
  } : (i = Ln.hsva.exec(r)) ? {
    h: i[1],
    s: i[2],
    v: i[3],
    a: i[4]
  } : (i = Ln.hex8.exec(r)) ? {
    r: rn(i[1]),
    g: rn(i[2]),
    b: rn(i[3]),
    a: pE(i[4]),
    format: e ? "name" : "hex8"
  } : (i = Ln.hex6.exec(r)) ? {
    r: rn(i[1]),
    g: rn(i[2]),
    b: rn(i[3]),
    format: e ? "name" : "hex"
  } : (i = Ln.hex4.exec(r)) ? {
    r: rn(i[1] + "" + i[1]),
    g: rn(i[2] + "" + i[2]),
    b: rn(i[3] + "" + i[3]),
    a: pE(i[4] + "" + i[4]),
    format: e ? "name" : "hex8"
  } : (i = Ln.hex3.exec(r)) ? {
    r: rn(i[1] + "" + i[1]),
    g: rn(i[2] + "" + i[2]),
    b: rn(i[3] + "" + i[3]),
    format: e ? "name" : "hex"
  } : !1;
}
function HH(r) {
  var e, i;
  return r = r || {
    level: "AA",
    size: "small"
  }, e = (r.level || "AA").toUpperCase(), i = (r.size || "small").toLowerCase(), e !== "AA" && e !== "AAA" && (e = "AA"), i !== "small" && i !== "large" && (i = "small"), {
    level: e,
    size: i
  };
}
function Gb(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function WH(r) {
  if (Array.isArray(r)) return r;
}
function qH(r) {
  if (Array.isArray(r)) return Gb(r);
}
function fN(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function XH(r) {
  if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function mN(r, e, i) {
  return e = vc(e), t9(r, eT() ? Reflect.construct(e, i || [], vc(r).constructor) : e.apply(r, i));
}
function $H(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function gN(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function av(r, e) {
  return r.get(fN(r, e));
}
function fE(r, e, i) {
  $H(r, e), e.set(r, i);
}
function mE(r, e, i) {
  return r.set(fN(r, e), i), i;
}
function yN(r, e, i) {
  if (eT()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return s;
}
function YH(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, xN(n.key), n);
  }
}
function vN(r, e, i) {
  return e && YH(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function Ag(r, e, i) {
  return (e = xN(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function Hb() {
  return Hb = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(r, e, i) {
    var n = i9(r, e);
    if (n) {
      var s = Object.getOwnPropertyDescriptor(n, e);
      return s.get ? s.get.call(arguments.length < 3 ? r : i) : s.value;
    }
  }, Hb.apply(null, arguments);
}
function vc(r) {
  return vc = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, vc(r);
}
function bN(r, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  r.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: r,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(r, "prototype", {
    writable: !1
  }), e && Wb(r, e);
}
function eT() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (eT = function() {
    return !!r;
  })();
}
function KH(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function ZH(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function QH() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function JH() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function gE(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function e9(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? gE(Object(i), !0).forEach(function(n) {
      Ag(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : gE(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function t9(r, e) {
  if (e && (typeof e == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return XH(r);
}
function Wb(r, e) {
  return Wb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Wb(r, e);
}
function Zh(r, e) {
  return WH(r) || ZH(r, e) || _N(r, e) || QH();
}
function i9(r, e) {
  for (; !{}.hasOwnProperty.call(r, e) && (r = vc(r)) !== null; ) ;
  return r;
}
function ov(r, e, i, n) {
  var s = Hb(vc(r.prototype), e, i);
  return typeof s == "function" ? function(a) {
    return s.apply(i, a);
  } : s;
}
function jn(r) {
  return qH(r) || KH(r) || _N(r) || JH();
}
function r9(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function xN(r) {
  var e = r9(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function qb(r) {
  "@babel/helpers - typeof";
  return qb = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, qb(r);
}
function _N(r, e) {
  if (r) {
    if (typeof r == "string") return Gb(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Gb(r, e) : void 0;
  }
}
var TN = function(r) {
  r instanceof Array ? r.forEach(TN) : (r.map && r.map.dispose(), r.dispose());
}, SN = function(r) {
  r.geometry && r.geometry.dispose(), r.material && TN(r.material), r.texture && r.texture.dispose(), r.children && r.children.forEach(SN);
}, Xb = function(r) {
  for (; r.children.length; ) {
    var e = r.children[0];
    r.remove(e), SN(e);
  }
}, lv = /* @__PURE__ */ new WeakMap(), Vp = /* @__PURE__ */ new WeakMap(), ph = /* @__PURE__ */ function(r) {
  function e(i) {
    var n, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = s.dataBindAttr, o = a === void 0 ? "__data" : a, l = s.objBindAttr, u = l === void 0 ? "__threeObj" : l;
    return gN(this, e), n = mN(this, e), Ag(n, "scene", void 0), fE(n, lv, void 0), fE(n, Vp, void 0), n.scene = i, mE(lv, n, o), mE(Vp, n, u), n.onRemoveObj(function() {
    }), n;
  }
  return bN(e, r), vN(e, [{
    key: "onCreateObj",
    value: function(i) {
      var n = this;
      return ov(e, "onCreateObj", this)([function(s) {
        var a = i(s);
        return s[av(Vp, n)] = a, a[av(lv, n)] = s, n.scene.add(a), a;
      }]), this;
    }
  }, {
    key: "onRemoveObj",
    value: function(i) {
      var n = this;
      return ov(e, "onRemoveObj", this)([function(s, a) {
        var o = ov(e, "getData", n)([s]);
        i(s, a), n.scene.remove(s), Xb(s), delete o[av(Vp, n)];
      }]), this;
    }
  }]);
}(qG), fh = function(r) {
  return isNaN(r) ? parseInt(it(r).toHex(), 16) : r;
}, uv = function(r) {
  return isNaN(r) ? it(r).getAlpha() : 1;
}, n9 = Q_(hN);
function yE(r, e, i) {
  !e || typeof i != "string" || r.filter(function(n) {
    return !n[i];
  }).forEach(function(n) {
    n[i] = n9(e(n));
  });
}
function s9(r, e) {
  var i = r.nodes, n = r.links, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = s.nodeFilter, o = a === void 0 ? function() {
    return !0;
  } : a, l = s.onLoopError, u = l === void 0 ? function(f) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(f.join(" -> "), ".");
  } : l, c = {};
  i.forEach(function(f) {
    return c[e(f)] = {
      data: f,
      out: [],
      depth: -1,
      skip: !o(f)
    };
  }), n.forEach(function(f) {
    var m = f.source, v = f.target, y = b(m), g = b(v);
    if (!c.hasOwnProperty(y)) throw "Missing source node with id: ".concat(y);
    if (!c.hasOwnProperty(g)) throw "Missing target node with id: ".concat(g);
    var _ = c[y], x = c[g];
    _.out.push(x);
    function b(T) {
      return qb(T) === "object" ? e(T) : T;
    }
  });
  var h = [];
  p(Object.values(c));
  var d = Object.assign.apply(Object, [{}].concat(jn(Object.entries(c).filter(function(f) {
    var m = Zh(f, 2), v = m[1];
    return !v.skip;
  }).map(function(f) {
    var m = Zh(f, 2), v = m[0], y = m[1];
    return Ag({}, v, y.depth);
  }))));
  return d;
  function p(f) {
    for (var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, y = function() {
      var x = f[g];
      if (m.indexOf(x) !== -1) {
        var b = [].concat(jn(m.slice(m.indexOf(x))), [x]).map(function(T) {
          return e(T.data);
        });
        return h.some(function(T) {
          return T.length === b.length && T.every(function(S, w) {
            return S === b[w];
          });
        }) || (h.push(b), u(b)), 1;
      }
      v > x.depth && (x.depth = v, p(x.out, [].concat(jn(m), [x]), v + (x.skip ? 0 : 1)));
    }, g = 0, _ = f.length; g < _; g++)
      y();
  }
}
var dt = window.THREE ? window.THREE : {
  Group: nl,
  Mesh: Ur,
  MeshLambertMaterial: Vj,
  Color: kt,
  BufferGeometry: cn,
  BufferAttribute: _n,
  Matrix4: ui,
  Vector3: q,
  SphereGeometry: bR,
  CylinderGeometry: Sg,
  TubeGeometry: F_,
  ConeGeometry: k_,
  Line: Mj,
  LineBasicMaterial: gR,
  QuadraticBezierCurve3: L_,
  CubicBezierCurve3: vR,
  Box3: Rl
}, vE = {
  graph: f8,
  forcelayout: $8
}, a9 = 2, cv = new dt.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute", Gp = new dt.BufferGeometry().applyMatrix4 ? "applyMatrix4" : "applyMatrix", o9 = Pl({
  props: {
    jsonUrl: {
      onChange: function(r, e) {
        var i = this;
        r && !e.fetchingJson && (e.fetchingJson = !0, e.onLoading(), fetch(r).then(function(n) {
          return n.json();
        }).then(function(n) {
          e.fetchingJson = !1, e.onFinishLoading(n), i.graphData(n);
        }));
      },
      triggerUpdate: !1
    },
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        e.engineRunning = !1;
      }
    },
    numDimensions: {
      default: 3,
      onChange: function(r, e) {
        var i = e.d3ForceLayout.force("charge");
        i && i.strength(r > 2 ? -60 : -30), r < 3 && n(e.graphData.nodes, "z"), r < 2 && n(e.graphData.nodes, "y");
        function n(s, a) {
          s.forEach(function(o) {
            delete o[a], delete o["v".concat(a)];
          });
        }
      }
    },
    dagMode: {
      onChange: function(r, e) {
        !r && e.forceEngine === "d3" && (e.graphData.nodes || []).forEach(function(i) {
          return i.fx = i.fy = i.fz = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function(r) {
        return !0;
      }
    },
    onDagError: {
      triggerUpdate: !1
    },
    nodeRelSize: {
      default: 4
    },
    // volume per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val"
    },
    nodeResolution: {
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeColor: {
      default: "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      default: 0.75
    },
    nodeVisibility: {
      default: !0
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      default: !1
    },
    nodePositionUpdate: {
      triggerUpdate: !1
    },
    // custom function to call for updating the node's position. Signature: (threeObj, { x, y, z}, node). If the function returns a truthy value, the regular node position update will not run.
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0
    },
    linkColor: {
      default: "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      default: 0.2
    },
    linkWidth: {},
    // Rounded to nearest decimal. For falsy values use dimensionless line with 1px regardless of distance.
    linkResolution: {
      default: 6
    },
    // how many radial segments in each line tube's geometry
    linkCurvature: {
      default: 0,
      triggerUpdate: !1
    },
    // line curvature radius (0: straight, 1: semi-circle)
    linkCurveRotation: {
      default: 0,
      triggerUpdate: !1
    },
    // line curve rotation along the line axis (0: interection with XY plane, PI: upside down)
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      default: !1
    },
    linkPositionUpdate: {
      triggerUpdate: !1
    },
    // custom function to call for updating the link's position. Signature: (threeObj, { start: { x, y, z},  end: { x, y, z }}, link). If the function returns a truthy value, the regular link position update will not run.
    linkDirectionalArrowLength: {
      default: 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      default: 0.5,
      triggerUpdate: !1
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01,
      triggerUpdate: !1
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    forceEngine: {
      default: "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      default: 0
    },
    d3AlphaDecay: {
      default: 0.0228,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.alphaDecay(r);
      }
    },
    d3AlphaTarget: {
      default: 0,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.alphaTarget(r);
      }
    },
    d3VelocityDecay: {
      default: 0.4,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.velocityDecay(r);
      }
    },
    ngraphPhysics: {
      default: {
        // defaults from https://github.com/anvaka/ngraph.physics.simulator/blob/master/index.js
        timeStep: 20,
        gravity: -1.2,
        theta: 0.8,
        springLength: 30,
        springCoefficient: 8e-4,
        dragCoefficient: 0.02
      }
    },
    warmupTicks: {
      default: 0,
      triggerUpdate: !1
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      default: 1 / 0,
      triggerUpdate: !1
    },
    cooldownTime: {
      default: 15e3,
      triggerUpdate: !1
    },
    // ms
    onLoading: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishLoading: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineTick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineStop: {
      default: function() {
      },
      triggerUpdate: !1
    }
  },
  methods: {
    refresh: function(r) {
      return r._flushObjects = !0, r._rerender(), this;
    },
    // Expose d3 forces for external manipulation
    d3Force: function(r, e, i) {
      return i === void 0 ? r.d3ForceLayout.force(e) : (r.d3ForceLayout.force(e, i), this);
    },
    d3ReheatSimulation: function(r) {
      return r.d3ForceLayout.alpha(1), this.resetCountdown(), this;
    },
    // reset cooldown state
    resetCountdown: function(r) {
      return r.cntTicks = 0, r.startTickTime = /* @__PURE__ */ new Date(), r.engineRunning = !0, this;
    },
    tickFrame: function(r) {
      var e = r.forceEngine !== "ngraph";
      return r.engineRunning && i(), n(), s(), this;
      function i() {
        ++r.cntTicks > r.cooldownTicks || /* @__PURE__ */ new Date() - r.startTickTime > r.cooldownTime || e && r.d3AlphaMin > 0 && r.d3ForceLayout.alpha() < r.d3AlphaMin ? (r.engineRunning = !1, r.onEngineStop()) : (r.layout[e ? "tick" : "step"](), r.onEngineTick());
        var a = et(r.nodeThreeObjectExtend);
        r.nodeDataMapper.entries().forEach(function(d) {
          var p = Zh(d, 2), f = p[0], m = p[1];
          if (m) {
            var v = e ? f : r.layout.getNodePosition(f[r.nodeId]), y = a(f);
            (!r.nodePositionUpdate || !r.nodePositionUpdate(y ? m.children[0] : m, {
              x: v.x,
              y: v.y,
              z: v.z
            }, f) || y) && (m.position.x = v.x, m.position.y = v.y || 0, m.position.z = v.z || 0);
          }
        });
        var o = et(r.linkWidth), l = et(r.linkCurvature), u = et(r.linkCurveRotation), c = et(r.linkThreeObjectExtend);
        r.linkDataMapper.entries().forEach(function(d) {
          var p = Zh(d, 2), f = p[0], m = p[1];
          if (m) {
            var v = e ? f : r.layout.getLinkPosition(r.layout.graph.getLink(f.source, f.target).id), y = v[e ? "source" : "from"], g = v[e ? "target" : "to"];
            if (!(!y || !g || !y.hasOwnProperty("x") || !g.hasOwnProperty("x"))) {
              h(f);
              var _ = c(f);
              if (!(r.linkPositionUpdate && r.linkPositionUpdate(
                _ ? m.children[1] : m,
                // pass child custom object if extending the default
                {
                  start: {
                    x: y.x,
                    y: y.y,
                    z: y.z
                  },
                  end: {
                    x: g.x,
                    y: g.y,
                    z: g.z
                  }
                },
                f
              ) && !_)) {
                var x = 30, b = f.__curve, T = m.children.length ? m.children[0] : m;
                if (T.type === "Line") {
                  if (b) {
                    var S = b.getPoints(x);
                    T.geometry.getAttribute("position").array.length !== S.length * 3 && T.geometry[cv]("position", new dt.BufferAttribute(new Float32Array(S.length * 3), 3)), T.geometry.setFromPoints(S);
                  } else {
                    var w = T.geometry.getAttribute("position");
                    (!w || !w.array || w.array.length !== 6) && T.geometry[cv]("position", w = new dt.BufferAttribute(new Float32Array(2 * 3), 3)), w.array[0] = y.x, w.array[1] = y.y || 0, w.array[2] = y.z || 0, w.array[3] = g.x, w.array[4] = g.y || 0, w.array[5] = g.z || 0, w.needsUpdate = !0;
                  }
                  T.geometry.computeBoundingSphere();
                } else if (T.type === "Mesh")
                  if (b) {
                    T.geometry.type.match(/^Tube(Buffer)?Geometry$/) || (T.position.set(0, 0, 0), T.rotation.set(0, 0, 0), T.scale.set(1, 1, 1));
                    var A = Math.ceil(o(f) * 10) / 10, E = A / 2, M = new dt.TubeGeometry(b, x, E, r.linkResolution, !1);
                    T.geometry.dispose(), T.geometry = M;
                  } else {
                    if (!T.geometry.type.match(/^Cylinder(Buffer)?Geometry$/)) {
                      var N = Math.ceil(o(f) * 10) / 10, k = N / 2, U = new dt.CylinderGeometry(k, k, 1, r.linkResolution, 1, !1);
                      U[Gp](new dt.Matrix4().makeTranslation(0, 1 / 2, 0)), U[Gp](new dt.Matrix4().makeRotationX(Math.PI / 2)), T.geometry.dispose(), T.geometry = U;
                    }
                    var C = new dt.Vector3(y.x, y.y || 0, y.z || 0), O = new dt.Vector3(g.x, g.y || 0, g.z || 0), D = C.distanceTo(O);
                    T.position.x = C.x, T.position.y = C.y, T.position.z = C.z, T.scale.z = D, T.parent.localToWorld(O), T.lookAt(O);
                  }
              }
            }
          }
        });
        function h(d) {
          var p = e ? d : r.layout.getLinkPosition(r.layout.graph.getLink(d.source, d.target).id), f = p[e ? "source" : "from"], m = p[e ? "target" : "to"];
          if (!(!f || !m || !f.hasOwnProperty("x") || !m.hasOwnProperty("x"))) {
            var v = l(d);
            if (!v)
              d.__curve = null;
            else {
              var y = new dt.Vector3(f.x, f.y || 0, f.z || 0), g = new dt.Vector3(m.x, m.y || 0, m.z || 0), _ = y.distanceTo(g), x, b = u(d);
              if (_ > 0) {
                var T = m.x - f.x, S = m.y - f.y || 0, w = new dt.Vector3().subVectors(g, y), A = w.clone().multiplyScalar(v).cross(T !== 0 || S !== 0 ? new dt.Vector3(0, 0, 1) : new dt.Vector3(0, 1, 0)).applyAxisAngle(w.normalize(), b).add(new dt.Vector3().addVectors(y, g).divideScalar(2));
                x = new dt.QuadraticBezierCurve3(y, A, g);
              } else {
                var E = v * 70, M = -b, N = M + Math.PI / 2;
                x = new dt.CubicBezierCurve3(y, new dt.Vector3(E * Math.cos(N), E * Math.sin(N), 0).add(y), new dt.Vector3(E * Math.cos(M), E * Math.sin(M), 0).add(y), g);
              }
              d.__curve = x;
            }
          }
        }
      }
      function n() {
        var a = et(r.linkDirectionalArrowRelPos), o = et(r.linkDirectionalArrowLength), l = et(r.nodeVal);
        r.arrowDataMapper.entries().forEach(function(u) {
          var c = Zh(u, 2), h = c[0], d = c[1];
          if (d) {
            var p = e ? h : r.layout.getLinkPosition(r.layout.graph.getLink(h.source, h.target).id), f = p[e ? "source" : "from"], m = p[e ? "target" : "to"];
            if (!(!f || !m || !f.hasOwnProperty("x") || !m.hasOwnProperty("x"))) {
              var v = Math.cbrt(Math.max(0, l(f) || 1)) * r.nodeRelSize, y = Math.cbrt(Math.max(0, l(m) || 1)) * r.nodeRelSize, g = o(h), _ = a(h), x = h.__curve ? function(E) {
                return h.__curve.getPoint(E);
              } : function(E) {
                var M = function(N, k, U, C) {
                  return k[N] + (U[N] - k[N]) * C || 0;
                };
                return {
                  x: M("x", f, m, E),
                  y: M("y", f, m, E),
                  z: M("z", f, m, E)
                };
              }, b = h.__curve ? h.__curve.getLength() : Math.sqrt(["x", "y", "z"].map(function(E) {
                return Math.pow((m[E] || 0) - (f[E] || 0), 2);
              }).reduce(function(E, M) {
                return E + M;
              }, 0)), T = v + g + (b - v - y - g) * _, S = x(T / b), w = x((T - g) / b);
              ["x", "y", "z"].forEach(function(E) {
                return d.position[E] = w[E];
              });
              var A = yN(dt.Vector3, jn(["x", "y", "z"].map(function(E) {
                return S[E];
              })));
              d.parent.localToWorld(A), d.lookAt(A);
            }
          }
        });
      }
      function s() {
        var a = et(r.linkDirectionalParticleSpeed);
        r.graphData.links.forEach(function(o) {
          var l = r.particlesDataMapper.getObj(o), u = l && l.children, c = o.__singleHopPhotonsObj && o.__singleHopPhotonsObj.children;
          if (!((!c || !c.length) && (!u || !u.length))) {
            var h = e ? o : r.layout.getLinkPosition(r.layout.graph.getLink(o.source, o.target).id), d = h[e ? "source" : "from"], p = h[e ? "target" : "to"];
            if (!(!d || !p || !d.hasOwnProperty("x") || !p.hasOwnProperty("x"))) {
              var f = a(o), m = o.__curve ? function(y) {
                return o.__curve.getPoint(y);
              } : function(y) {
                var g = function(_, x, b, T) {
                  return x[_] + (b[_] - x[_]) * T || 0;
                };
                return {
                  x: g("x", d, p, y),
                  y: g("y", d, p, y),
                  z: g("z", d, p, y)
                };
              }, v = [].concat(jn(u || []), jn(c || []));
              v.forEach(function(y, g) {
                var _ = y.parent.__linkThreeObjType === "singleHopPhotons";
                if (y.hasOwnProperty("__progressRatio") || (y.__progressRatio = _ ? 0 : g / u.length), y.__progressRatio += f, y.__progressRatio >= 1)
                  if (!_)
                    y.__progressRatio = y.__progressRatio % 1;
                  else {
                    y.parent.remove(y), Xb(y);
                    return;
                  }
                var x = y.__progressRatio, b = m(x);
                ["x", "y", "z"].forEach(function(T) {
                  return y.position[T] = b[T];
                });
              });
            }
          }
        });
      }
    },
    emitParticle: function(r, e) {
      if (e && r.graphData.links.includes(e)) {
        if (!e.__singleHopPhotonsObj) {
          var i = new dt.Group();
          i.__linkThreeObjType = "singleHopPhotons", e.__singleHopPhotonsObj = i, r.graphScene.add(i);
        }
        var n = et(r.linkDirectionalParticleWidth), s = Math.ceil(n(e) * 10) / 10 / 2, a = r.linkDirectionalParticleResolution, o = new dt.SphereGeometry(s, a, a), l = et(r.linkColor), u = et(r.linkDirectionalParticleColor), c = u(e) || l(e) || "#f0f0f0", h = new dt.Color(fh(c)), d = r.linkOpacity * 3, p = new dt.MeshLambertMaterial({
          color: h,
          transparent: !0,
          opacity: d
        });
        e.__singleHopPhotonsObj.add(new dt.Mesh(o, p));
      }
      return this;
    },
    getGraphBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      };
      if (!r.initialised) return null;
      var i = function n(s) {
        var a = [];
        if (s.geometry) {
          s.geometry.computeBoundingBox();
          var o = new dt.Box3();
          o.copy(s.geometry.boundingBox).applyMatrix4(s.matrixWorld), a.push(o);
        }
        return a.concat.apply(a, jn((s.children || []).filter(
          function(l) {
            return !l.hasOwnProperty("__graphObjType") || l.__graphObjType === "node" && e(l.__data);
          }
          // exclude filtered out nodes
        ).map(n)));
      }(r.graphScene);
      return i.length ? Object.assign.apply(Object, jn(["x", "y", "z"].map(function(n) {
        return Ag({}, n, [Fb(i, function(s) {
          return s.min[n];
        }), kb(i, function(s) {
          return s.max[n];
        })]);
      }))) : null;
    }
  },
  stateInit: function() {
    return {
      d3ForceLayout: DR().force("link", PR()).force("charge", LR()).force("center", wR()).force("dagRadial", null).stop(),
      engineRunning: !1
    };
  },
  init: function(r, e) {
    e.graphScene = r, e.nodeDataMapper = new ph(r, {
      objBindAttr: "__threeObj"
    }), e.linkDataMapper = new ph(r, {
      objBindAttr: "__lineObj"
    }), e.arrowDataMapper = new ph(r, {
      objBindAttr: "__arrowObj"
    }), e.particlesDataMapper = new ph(r, {
      objBindAttr: "__photonsObj"
    });
  },
  update: function(r, e) {
    var i = function(W) {
      return W.some(function(z) {
        return e.hasOwnProperty(z);
      });
    };
    if (r.engineRunning = !1, typeof r.onUpdate == "function" && r.onUpdate(), r.nodeAutoColorBy !== null && i(["nodeAutoColorBy", "graphData", "nodeColor"]) && yE(r.graphData.nodes, et(r.nodeAutoColorBy), r.nodeColor), r.linkAutoColorBy !== null && i(["linkAutoColorBy", "graphData", "linkColor"]) && yE(r.graphData.links, et(r.linkAutoColorBy), r.linkColor), r._flushObjects || i(["graphData", "nodeThreeObject", "nodeThreeObjectExtend", "nodeVal", "nodeColor", "nodeVisibility", "nodeRelSize", "nodeResolution", "nodeOpacity"])) {
      var n = et(r.nodeThreeObject), s = et(r.nodeThreeObjectExtend), a = et(r.nodeVal), o = et(r.nodeColor), l = et(r.nodeVisibility), u = {}, c = {};
      (r._flushObjects || i([
        // recreate objects if any of these props have changed
        "nodeThreeObject",
        "nodeThreeObjectExtend"
      ])) && r.nodeDataMapper.clear(), r.nodeDataMapper.onCreateObj(function(W) {
        var z = n(W), X = s(W);
        z && r.nodeThreeObject === z && (z = z.clone());
        var ae;
        return z && !X ? ae = z : (ae = new dt.Mesh(), ae.__graphDefaultObj = !0, z && X && ae.add(z)), ae.__graphObjType = "node", ae;
      }).onUpdateObj(function(W, z) {
        if (W.__graphDefaultObj) {
          var X = a(z) || 1, ae = Math.cbrt(X) * r.nodeRelSize, ue = r.nodeResolution;
          (!W.geometry.type.match(/^Sphere(Buffer)?Geometry$/) || W.geometry.parameters.radius !== ae || W.geometry.parameters.widthSegments !== ue) && (u.hasOwnProperty(X) || (u[X] = new dt.SphereGeometry(ae, ue, ue)), W.geometry.dispose(), W.geometry = u[X]);
          var ge = o(z), we = new dt.Color(fh(ge || "#ffffaa")), Ne = r.nodeOpacity * uv(ge);
          (W.material.type !== "MeshLambertMaterial" || !W.material.color.equals(we) || W.material.opacity !== Ne) && (c.hasOwnProperty(ge) || (c[ge] = new dt.MeshLambertMaterial({
            color: we,
            transparent: !0,
            opacity: Ne
          })), W.material.dispose(), W.material = c[ge]);
        }
      }).digest(r.graphData.nodes.filter(l));
    }
    if (r._flushObjects || i(["graphData", "linkThreeObject", "linkThreeObjectExtend", "linkMaterial", "linkColor", "linkWidth", "linkVisibility", "linkResolution", "linkOpacity", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution"])) {
      var h = et(r.linkThreeObject), d = et(r.linkThreeObjectExtend), p = et(r.linkMaterial), f = et(r.linkVisibility), m = et(r.linkColor), v = et(r.linkWidth), y = {}, g = {}, _ = {}, x = r.graphData.links.filter(f);
      if ((r._flushObjects || i([
        // recreate objects if any of these props have changed
        "linkThreeObject",
        "linkThreeObjectExtend",
        "linkWidth"
      ])) && r.linkDataMapper.clear(), r.linkDataMapper.onRemoveObj(function(W) {
        var z = W.__data && W.__data.__singleHopPhotonsObj;
        z && (z.parent.remove(z), Xb(z), delete W.__data.__singleHopPhotonsObj);
      }).onCreateObj(function(W) {
        var z = h(W), X = d(W);
        z && r.linkThreeObject === z && (z = z.clone());
        var ae;
        if (!z || X) {
          var ue = !!v(W);
          if (ue)
            ae = new dt.Mesh();
          else {
            var ge = new dt.BufferGeometry();
            ge[cv]("position", new dt.BufferAttribute(new Float32Array(2 * 3), 3)), ae = new dt.Line(ge);
          }
        }
        var we;
        return z ? X ? (we = new dt.Group(), we.__graphDefaultObj = !0, we.add(ae), we.add(z)) : we = z : (we = ae, we.__graphDefaultObj = !0), we.renderOrder = 10, we.__graphObjType = "link", we;
      }).onUpdateObj(function(W, z) {
        if (W.__graphDefaultObj) {
          var X = W.children.length ? W.children[0] : W, ae = Math.ceil(v(z) * 10) / 10, ue = !!ae;
          if (ue) {
            var ge = ae / 2, we = r.linkResolution;
            if (!X.geometry.type.match(/^Cylinder(Buffer)?Geometry$/) || X.geometry.parameters.radiusTop !== ge || X.geometry.parameters.radialSegments !== we) {
              if (!y.hasOwnProperty(ae)) {
                var Ne = new dt.CylinderGeometry(ge, ge, 1, we, 1, !1);
                Ne[Gp](new dt.Matrix4().makeTranslation(0, 1 / 2, 0)), Ne[Gp](new dt.Matrix4().makeRotationX(Math.PI / 2)), y[ae] = Ne;
              }
              X.geometry.dispose(), X.geometry = y[ae];
            }
          }
          var lt = p(z);
          if (lt)
            X.material = lt;
          else {
            var be = m(z), bt = new dt.Color(fh(be || "#f0f0f0")), Y = r.linkOpacity * uv(be), Gt = ue ? "MeshLambertMaterial" : "LineBasicMaterial";
            if (X.material.type !== Gt || !X.material.color.equals(bt) || X.material.opacity !== Y) {
              var Xe = ue ? g : _;
              Xe.hasOwnProperty(be) || (Xe[be] = new dt[Gt]({
                color: bt,
                transparent: Y < 1,
                opacity: Y,
                depthWrite: Y >= 1
                // Prevent transparency issues
              })), X.material.dispose(), X.material = Xe[be];
            }
          }
        }
      }).digest(x), r.linkDirectionalArrowLength || e.hasOwnProperty("linkDirectionalArrowLength")) {
        var b = et(r.linkDirectionalArrowLength), T = et(r.linkDirectionalArrowColor);
        r.arrowDataMapper.onCreateObj(function() {
          var W = new dt.Mesh(void 0, new dt.MeshLambertMaterial({
            transparent: !0
          }));
          return W.__linkThreeObjType = "arrow", W;
        }).onUpdateObj(function(W, z) {
          var X = b(z), ae = r.linkDirectionalArrowResolution;
          if (!W.geometry.type.match(/^Cone(Buffer)?Geometry$/) || W.geometry.parameters.height !== X || W.geometry.parameters.radialSegments !== ae) {
            var ue = new dt.ConeGeometry(X * 0.25, X, ae);
            ue.translate(0, X / 2, 0), ue.rotateX(Math.PI / 2), W.geometry.dispose(), W.geometry = ue;
          }
          var ge = T(z) || m(z) || "#f0f0f0";
          W.material.color = new dt.Color(fh(ge)), W.material.opacity = r.linkOpacity * 3 * uv(ge);
        }).digest(x.filter(b));
      }
      if (r.linkDirectionalParticles || e.hasOwnProperty("linkDirectionalParticles")) {
        var S = et(r.linkDirectionalParticles), w = et(r.linkDirectionalParticleWidth), A = et(r.linkDirectionalParticleColor), E = {}, M = {};
        r.particlesDataMapper.onCreateObj(function() {
          var W = new dt.Group();
          return W.__linkThreeObjType = "photons", W.__photonDataMapper = new ph(W), W;
        }).onUpdateObj(function(W, z) {
          var X = Math.round(Math.abs(S(z))), ae = !!W.children.length && W.children[0], ue = Math.ceil(w(z) * 10) / 10 / 2, ge = r.linkDirectionalParticleResolution, we;
          ae && ae.geometry.parameters.radius === ue && ae.geometry.parameters.widthSegments === ge ? we = ae.geometry : (M.hasOwnProperty(ue) || (M[ue] = new dt.SphereGeometry(ue, ge, ge)), we = M[ue], ae && ae.geometry.dispose());
          var Ne = A(z) || m(z) || "#f0f0f0", lt = new dt.Color(fh(Ne)), be = r.linkOpacity * 3, bt;
          ae && ae.material.color.equals(lt) && ae.material.opacity === be ? bt = ae.material : (E.hasOwnProperty(Ne) || (E[Ne] = new dt.MeshLambertMaterial({
            color: lt,
            transparent: !0,
            opacity: be
          })), bt = E[Ne], ae && ae.material.dispose()), W.__photonDataMapper.id(function(Y) {
            return Y.idx;
          }).onCreateObj(function() {
            return new dt.Mesh(we, bt);
          }).onUpdateObj(function(Y) {
            Y.geometry = we, Y.material = bt;
          }).digest(jn(new Array(X)).map(function(Y, Gt) {
            return {
              idx: Gt
            };
          }));
        }).digest(x.filter(S));
      }
    }
    if (r._flushObjects = !1, i(["graphData", "nodeId", "linkSource", "linkTarget", "numDimensions", "forceEngine", "dagMode", "dagNodeFilter", "dagLevelDistance"])) {
      r.engineRunning = !1, r.graphData.links.forEach(function(W) {
        W.source = W[r.linkSource], W.target = W[r.linkTarget];
      });
      var N = r.forceEngine !== "ngraph", k;
      if (N) {
        (k = r.d3ForceLayout).stop().alpha(1).numDimensions(r.numDimensions).nodes(r.graphData.nodes);
        var U = r.d3ForceLayout.force("link");
        U && U.id(function(W) {
          return W[r.nodeId];
        }).links(r.graphData.links);
        var C = r.dagMode && s9(r.graphData, function(W) {
          return W[r.nodeId];
        }, {
          nodeFilter: r.dagNodeFilter,
          onLoopError: r.onDagError || void 0
        }), O = Math.max.apply(Math, jn(Object.values(C || []))), D = r.dagLevelDistance || r.graphData.nodes.length / (O || 1) * a9 * (["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? 0.7 : 1);
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(e.dagMode)) {
          var H = ["lr", "rl"].includes(e.dagMode) ? "fx" : ["td", "bu"].includes(e.dagMode) ? "fy" : "fz";
          r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(W) {
            return delete W[H];
          });
        }
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(r.dagMode)) {
          var j = ["rl", "td", "zout"].includes(r.dagMode), K = function(W) {
            return (C[W[r.nodeId]] - O / 2) * D * (j ? -1 : 1);
          }, L = ["lr", "rl"].includes(r.dagMode) ? "fx" : ["td", "bu"].includes(r.dagMode) ? "fy" : "fz";
          r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(W) {
            return W[L] = K(W);
          });
        }
        r.d3ForceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? UR(function(W) {
          var z = C[W[r.nodeId]] || -1;
          return (r.dagMode === "radialin" ? O - z : z) * D;
        }).strength(function(W) {
          return r.dagNodeFilter(W) ? 1 : 0;
        }) : null);
      } else {
        var B = vE.graph();
        r.graphData.nodes.forEach(function(W) {
          B.addNode(W[r.nodeId]);
        }), r.graphData.links.forEach(function(W) {
          B.addLink(W.source, W.target);
        }), k = vE.forcelayout(B, e9({
          dimensions: r.numDimensions
        }, r.ngraphPhysics)), k.graph = B;
      }
      for (var Q = 0; Q < r.warmupTicks && !(N && r.d3AlphaMin > 0 && r.d3ForceLayout.alpha() < r.d3AlphaMin); Q++)
        k[N ? "tick" : "step"]();
      r.layout = k, this.resetCountdown();
    }
    r.engineRunning = !0, r.onFinishUpdate();
  }
});
function l9(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = /* @__PURE__ */ function(s) {
    function a() {
      var o;
      gN(this, a);
      for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
        u[c] = arguments[c];
      return o = mN(this, a, [].concat(u)), o.__kapsuleInstance = yN(r, [].concat(jn(i ? [o] : []), u)), o;
    }
    return bN(a, s), vN(a);
  }(e);
  return Object.keys(r()).forEach(function(s) {
    return n.prototype[s] = function() {
      var a, o = (a = this.__kapsuleInstance)[s].apply(a, arguments);
      return o === this.__kapsuleInstance ? this : o;
    };
  }), n;
}
var u9 = window.THREE ? window.THREE : {
  Group: nl
}, Du = l9(o9, u9.Group, !0);
if (typeof AFRAME > "u")
  throw new Error("Component attempted to register before AFRAME was available.");
var hv = function(r) {
  return typeof r == "string" ? JSON.parse(r) : r;
}, Un = function(r) {
  if (typeof r == "function") return r;
  var e = eval;
  try {
    var i = e("(" + r + ")");
    return i;
  } catch {
  }
  return null;
}, Ti = function(r) {
  return isNaN(parseFloat(r)) ? Un(r) ? Un(r) : r : parseFloat(r);
};
AFRAME.components.hasOwnProperty("forcegraph") || AFRAME.registerComponent("forcegraph", {
  schema: {
    jsonUrl: {
      type: "string",
      default: ""
    },
    nodes: {
      parse: hv,
      default: []
    },
    links: {
      parse: hv,
      default: []
    },
    numDimensions: {
      type: "number",
      default: 3
    },
    dagMode: {
      type: "string",
      default: ""
    },
    dagLevelDistance: {
      type: "number",
      default: 0
    },
    dagNodeFilter: {
      parse: Un,
      default: function() {
        return !0;
      }
    },
    onDagError: {
      parse: Un,
      default: void 0
    },
    nodeRelSize: {
      type: "number",
      default: 4
    },
    // volume per val unit
    nodeId: {
      type: "string",
      default: "id"
    },
    nodeVal: {
      parse: Ti,
      default: "val"
    },
    nodeResolution: {
      type: "number",
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeVisibility: {
      parse: Ti,
      default: !0
    },
    nodeColor: {
      parse: Ti,
      default: "color"
    },
    nodeAutoColorBy: {
      parse: Ti,
      default: ""
    },
    // color nodes with the same field equally
    nodeOpacity: {
      type: "number",
      default: 0.75
    },
    nodeThreeObject: {
      parse: Ti,
      default: null
    },
    nodeThreeObjectExtend: {
      parse: Ti,
      default: !1
    },
    linkSource: {
      type: "string",
      default: "source"
    },
    linkTarget: {
      type: "string",
      default: "target"
    },
    linkVisibility: {
      parse: Ti,
      default: !0
    },
    linkColor: {
      parse: Ti,
      default: "color"
    },
    linkAutoColorBy: {
      parse: Ti,
      default: ""
    },
    // color links with the same field equally
    linkOpacity: {
      type: "number",
      default: 0.2
    },
    linkWidth: {
      parse: Ti,
      default: 0
    },
    linkResolution: {
      type: "number",
      default: 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      parse: Ti,
      default: 0
    },
    linkCurveRotation: {
      parse: Ti,
      default: 0
    },
    linkMaterial: {
      parse: Ti,
      default: null
    },
    linkThreeObject: {
      parse: Ti,
      default: null
    },
    linkThreeObjectExtend: {
      parse: Ti,
      default: !1
    },
    linkPositionUpdate: {
      parse: Un,
      default: null
    },
    linkDirectionalArrowLength: {
      parse: Ti,
      default: 0
    },
    linkDirectionalArrowColor: {
      parse: Ti,
      default: null
    },
    linkDirectionalArrowRelPos: {
      parse: Ti,
      default: 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      type: "number",
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      parse: Ti,
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      parse: Ti,
      default: 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      parse: Ti,
      default: 0.5
    },
    linkDirectionalParticleColor: {
      parse: Ti,
      default: null
    },
    linkDirectionalParticleResolution: {
      type: "number",
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    onNodeHover: {
      parse: Un,
      default: function() {
      }
    },
    onLinkHover: {
      parse: Un,
      default: function() {
      }
    },
    onNodeClick: {
      parse: Un,
      default: function() {
      }
    },
    onLinkClick: {
      parse: Un,
      default: function() {
      }
    },
    forceEngine: {
      type: "string",
      default: "d3"
    },
    // 'd3' or 'ngraph'
    d3AlphaMin: {
      type: "number",
      default: 0
    },
    d3AlphaDecay: {
      type: "number",
      default: 0.0228
    },
    d3VelocityDecay: {
      type: "number",
      default: 0.4
    },
    ngraphPhysics: {
      parse: hv,
      default: null
    },
    warmupTicks: {
      type: "int",
      default: 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      type: "int",
      default: 1e18
    },
    // Simulate infinity (int parser doesn't accept Infinity object)
    cooldownTime: {
      type: "int",
      default: 15e3
    },
    // ms
    onEngineTick: {
      parse: Un,
      default: function() {
      }
    },
    onEngineStop: {
      parse: Un,
      default: function() {
      }
    }
  },
  // Bind component methods
  getGraphBbox: function(r) {
    return this.forceGraph || (this.forceGraph = new Du()), this.forceGraph.getGraphBbox(r);
  },
  emitParticle: function() {
    this.forceGraph || (this.forceGraph = new Du());
    var r = this.forceGraph, e = r.emitParticle.apply(r, arguments);
    return e === r ? this : e;
  },
  d3Force: function() {
    this.forceGraph || (this.forceGraph = new Du());
    var r = this.forceGraph, e = r.d3Force.apply(r, arguments);
    return e === r ? this : e;
  },
  d3ReheatSimulation: function() {
    return this.forceGraph && this.forceGraph.d3ReheatSimulation(), this;
  },
  refresh: function() {
    return this.forceGraph && this.forceGraph.refresh(), this;
  },
  init: function() {
    var r = this, e = this.state = {};
    e.infoEl = document.createElement("a-text"), e.infoEl.setAttribute("position", "0 -0.1 -1"), e.infoEl.setAttribute("width", 1), e.infoEl.setAttribute("align", "center"), e.infoEl.setAttribute("color", "lavender");
    var i = document.querySelector("a-entity[camera], a-camera");
    i.appendChild(e.infoEl), e.cameraObj = i.object3D.children.filter(function(n) {
      return n.type === "PerspectiveCamera";
    })[0], this.el.sceneEl.addEventListener("camera-set-active", function(n) {
      e.cameraObj = n.detail.cameraEl.components.camera.camera;
    }), this.forceGraph || (this.forceGraph = new Du()), this.forceGraph.onFinishUpdate(function() {
      return r.el.setObject3D("forcegraphGroup", r.forceGraph);
    }).onLoading(function() {
      return e.infoEl.setAttribute("value", "Loading...");
    }).onFinishLoading(function() {
      return e.infoEl.setAttribute("value", "");
    }), this.el.addEventListener("raycaster-intersected", function(n) {
      return e.hoverDetail = n.detail;
    }), this.el.addEventListener("raycaster-intersected-cleared", function(n) {
      return e.hoverDetail = n.detail;
    }), this.el.addEventListener("click", function() {
      return e.hoverObj && r.data["on" + (e.hoverObj.__graphObjType === "node" ? "Node" : "Link") + "Click"](e.hoverObj.__data);
    });
  },
  remove: function() {
    this.state.infoEl.remove(), this.el.removeObject3D("forcegraphGroup");
  },
  update: function(r) {
    var e = this, i = this.data, n = AFRAME.utils.diff(i, r), s = ["jsonUrl", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeVisibility", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "forceEngine", "d3AlphaMin", "d3AphaDecay", "d3VelocityDecay", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"];
    s.filter(function(a) {
      return a in n;
    }).forEach(function(a) {
      e.forceGraph[a](i[a] !== "" ? i[a] : null);
    }), ("nodes" in n || "links" in n) && e.forceGraph.graphData({
      nodes: i.nodes,
      links: i.links
    });
  },
  tick: function(r, e) {
    for (var i = this.state, n = this.data, s = i.hoverDetail ? i.hoverDetail.getIntersection ? i.hoverDetail.getIntersection(this.el) : i.hoverDetail.intersection || void 0 : void 0, a = s ? s.object : void 0; a && !a.hasOwnProperty("__graphObjType"); ) a = a.parent;
    if (a !== i.hoverObj) {
      var o = i.hoverObj ? i.hoverObj.__graphObjType : null, l = i.hoverObj ? i.hoverObj.__data : null, u = a ? a.__graphObjType : null, c = a ? a.__data : null;
      o && o !== u && n["on" + (o === "node" ? "Node" : "Link") + "Hover"](null, l), u && n["on" + (u === "node" ? "Node" : "Link") + "Hover"](c, o === u ? l : null), i.hoverObj = a;
    }
    this.forceGraph.tickFrame();
  }
});
function $b(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function c9(r) {
  if (Array.isArray(r)) return r;
}
function h9(r) {
  if (Array.isArray(r)) return $b(r);
}
function Qf(r, e, i) {
  return (e = y9(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function d9(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function p9(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function f9() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function m9() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function bE(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function xE(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? bE(Object(i), !0).forEach(function(n) {
      Qf(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : bE(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function Hp(r, e) {
  return c9(r) || p9(r, e) || wN(r, e) || f9();
}
function Wp(r) {
  return h9(r) || d9(r) || wN(r) || m9();
}
function g9(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function y9(r) {
  var e = g9(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function wN(r, e) {
  if (r) {
    if (typeof r == "string") return $b(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? $b(r, e) : void 0;
  }
}
var v9 = Pl({
  props: {
    width: {},
    height: {},
    yOffset: {
      default: 1.5
    },
    // marker size units
    glScale: {
      default: 200
    },
    // gl units per marker width
    jsonUrl: {},
    graphData: {
      default: {
        nodes: [],
        links: []
      }
    },
    numDimensions: {
      default: 3
    },
    dagMode: {},
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function() {
        return !0;
      }
    },
    onDagError: {
      default: void 0
    },
    nodeRelSize: {
      default: 4
    },
    // volume per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val"
    },
    nodeResolution: {
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeVisibility: {
      default: !0
    },
    nodeColor: {
      default: "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      default: 0.75
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      default: !1
    },
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0
    },
    linkColor: {
      default: "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      default: 0.2
    },
    linkWidth: {
      default: 0
    },
    linkResolution: {
      default: 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      default: 0
    },
    linkCurveRotation: {
      default: 0
    },
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      default: !1
    },
    linkPositionUpdate: {},
    linkDirectionalArrowLength: {
      default: 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      default: 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    onNodeHover: {},
    onNodeClick: {},
    onLinkHover: {},
    onLinkClick: {},
    forceEngine: {
      default: "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      default: 0
    },
    d3AlphaDecay: {
      default: 0.0228
    },
    d3VelocityDecay: {
      default: 0.4
    },
    ngraphPhysics: {},
    warmupTicks: {
      default: 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {},
    cooldownTime: {
      default: 15e3
    },
    // ms
    onEngineTick: {},
    onEngineStop: {}
  },
  methods: xE(xE({}, Object.assign.apply(Object, [{}].concat(Wp(["getGraphBbox", "emitParticle", "d3Force", "d3ReheatSimulation", "refresh"].map(function(r) {
    return Qf({}, r, function(e) {
      for (var i = e.forcegraph.components.forcegraph, n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
        s[a - 1] = arguments[a];
      var o = i[r].apply(i, s);
      return o === i ? this : o;
    });
  }))))), {}, {
    _destructor: function() {
      this.graphData({
        nodes: [],
        links: []
      });
    }
  }),
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.markerAttrs, s = n === void 0 ? {
      preset: "hiro"
    } : n;
    r.innerHTML = "", e.container = document.createElement("div"), r.appendChild(e.container);
    var a = document.createElement("a-scene");
    a.setAttribute("embedded", ""), a.setAttribute("vr-mode-ui", "enabled: false"), a.setAttribute("arjs", "debugUIEnabled: false;");
    var o = document.createElement("a-marker");
    Object.entries(s).forEach(function(c) {
      var h = Hp(c, 2), d = h[0], p = h[1];
      return o.setAttribute(d, p);
    }), a.appendChild(o);
    var l;
    a.appendChild(l = document.createElement("a-entity")), l.setAttribute(
      "cursor"
      /*, 'rayOrigin: mouse'*/
    ), l.setAttribute("raycaster", "objects: [forcegraph]"), e.forcegraph = document.createElement("a-entity"), e.forcegraph.setAttribute("forcegraph", null), o.appendChild(e.forcegraph);
    var u = document.createElement("a-entity");
    u.setAttribute("camera", ""), a.appendChild(u), e.container.appendChild(a);
  },
  update: function(r, e) {
    e.hasOwnProperty("width") && r.width && (r.container.style.width = "".concat(r.width, "px")), e.hasOwnProperty("height") && r.height && (r.container.style.height = "".concat(r.height, "px")), e.hasOwnProperty("glScale") && r.forcegraph.setAttribute("scale", Wp(new Array(3)).map(function() {
      return 1 / r.glScale;
    }).join(" ")), e.hasOwnProperty("yOffset") && r.forcegraph.setAttribute("position", "0 ".concat(r.yOffset, " 0"));
    var i = ["jsonUrl", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeVisibility", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "onNodeHover", "onNodeClick", "onLinkHover", "onLinkClick", "forceEngine", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"], n = Object.assign.apply(Object, [{}].concat(Wp(Object.entries(r).filter(function(s) {
      var a = Hp(s, 2), o = a[0], l = a[1];
      return e.hasOwnProperty(o) && i.indexOf(o) !== -1 && l !== void 0 && l !== null;
    }).map(function(s) {
      var a = Hp(s, 2), o = a[0], l = a[1];
      return Qf({}, o, l);
    })), Wp(Object.entries(r.graphData).map(function(s) {
      var a = Hp(s, 2), o = a[0], l = a[1];
      return Qf({}, o, l);
    }))));
    r.forcegraph.setAttribute("forcegraph", n);
  }
});
const Xu = new Xs(), Js = new Ue(), EN = new q(), dv = new Ue(), Jf = new Ue(), Am = new q(), Yb = new q(), MN = new ui(), AN = new q(), CN = new q();
let Lr = null, ns = null;
const ea = [], uo = {
  NONE: -1,
  PAN: 0,
  ROTATE: 1
};
class b9 extends wg {
  constructor(e, i, n = null) {
    super(i, n), this.objects = e, this.recursive = !0, this.transformGroup = !1, this.rotateSpeed = 1, this.raycaster = new SR(), this.mouseButtons = { LEFT: ir.PAN, MIDDLE: ir.PAN, RIGHT: ir.ROTATE }, this.touches = { ONE: ra.PAN }, this._onPointerMove = x9.bind(this), this._onPointerDown = _9.bind(this), this._onPointerCancel = T9.bind(this), this._onContextMenu = S9.bind(this), n !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointerup", this._onPointerCancel), this.domElement.addEventListener("pointerleave", this._onPointerCancel), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointerup", this._onPointerCancel), this.domElement.removeEventListener("pointerleave", this._onPointerCancel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "auto", this.domElement.style.cursor = "";
  }
  dispose() {
    this.disconnect();
  }
  _updatePointer(e) {
    const i = this.domElement.getBoundingClientRect();
    Js.x = (e.clientX - i.left) / i.width * 2 - 1, Js.y = -(e.clientY - i.top) / i.height * 2 + 1;
  }
  _updateState(e) {
    let i;
    if (e.pointerType === "touch")
      i = this.touches.ONE;
    else
      switch (e.button) {
        case 0:
          i = this.mouseButtons.LEFT;
          break;
        case 1:
          i = this.mouseButtons.MIDDLE;
          break;
        case 2:
          i = this.mouseButtons.RIGHT;
          break;
        default:
          i = null;
      }
    switch (i) {
      case ir.PAN:
      case ra.PAN:
        this.state = uo.PAN;
        break;
      case ir.ROTATE:
      case ra.ROTATE:
        this.state = uo.ROTATE;
        break;
      default:
        this.state = uo.NONE;
    }
  }
  getRaycaster() {
    return console.warn("THREE.DragControls: getRaycaster() has been deprecated. Use controls.raycaster instead."), this.raycaster;
  }
  setObjects(e) {
    console.warn("THREE.DragControls: setObjects() has been deprecated. Use controls.objects instead."), this.objects = e;
  }
  getObjects() {
    return console.warn("THREE.DragControls: getObjects() has been deprecated. Use controls.objects instead."), this.objects;
  }
  activate() {
    console.warn("THREE.DragControls: activate() has been renamed to connect()."), this.connect();
  }
  deactivate() {
    console.warn("THREE.DragControls: deactivate() has been renamed to disconnect()."), this.disconnect();
  }
  set mode(e) {
    console.warn("THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.");
  }
  get mode() {
    console.warn("THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.");
  }
}
function x9(r) {
  const e = this.object, i = this.domElement, n = this.raycaster;
  if (this.enabled !== !1) {
    if (this._updatePointer(r), n.setFromCamera(Js, e), Lr)
      this.state === uo.PAN ? n.ray.intersectPlane(Xu, Am) && Lr.position.copy(Am.sub(EN).applyMatrix4(MN)) : this.state === uo.ROTATE && (dv.subVectors(Js, Jf).multiplyScalar(this.rotateSpeed), Lr.rotateOnWorldAxis(AN, dv.x), Lr.rotateOnWorldAxis(CN.normalize(), -dv.y)), this.dispatchEvent({ type: "drag", object: Lr }), Jf.copy(Js);
    else if (r.pointerType === "mouse" || r.pointerType === "pen")
      if (ea.length = 0, n.setFromCamera(Js, e), n.intersectObjects(this.objects, this.recursive, ea), ea.length > 0) {
        const s = ea[0].object;
        Xu.setFromNormalAndCoplanarPoint(e.getWorldDirection(Xu.normal), Yb.setFromMatrixPosition(s.matrixWorld)), ns !== s && ns !== null && (this.dispatchEvent({ type: "hoveroff", object: ns }), i.style.cursor = "auto", ns = null), ns !== s && (this.dispatchEvent({ type: "hoveron", object: s }), i.style.cursor = "pointer", ns = s);
      } else
        ns !== null && (this.dispatchEvent({ type: "hoveroff", object: ns }), i.style.cursor = "auto", ns = null);
    Jf.copy(Js);
  }
}
function _9(r) {
  const e = this.object, i = this.domElement, n = this.raycaster;
  this.enabled !== !1 && (this._updatePointer(r), this._updateState(r), ea.length = 0, n.setFromCamera(Js, e), n.intersectObjects(this.objects, this.recursive, ea), ea.length > 0 && (this.transformGroup === !0 ? Lr = RN(ea[0].object) : Lr = ea[0].object, Xu.setFromNormalAndCoplanarPoint(e.getWorldDirection(Xu.normal), Yb.setFromMatrixPosition(Lr.matrixWorld)), n.ray.intersectPlane(Xu, Am) && (this.state === uo.PAN ? (MN.copy(Lr.parent.matrixWorld).invert(), EN.copy(Am).sub(Yb.setFromMatrixPosition(Lr.matrixWorld))) : this.state === uo.ROTATE && (AN.set(0, 1, 0).applyQuaternion(e.quaternion).normalize(), CN.set(1, 0, 0).applyQuaternion(e.quaternion).normalize())), i.style.cursor = "move", this.dispatchEvent({ type: "dragstart", object: Lr })), Jf.copy(Js));
}
function T9() {
  this.enabled !== !1 && (Lr && (this.dispatchEvent({ type: "dragend", object: Lr }), Lr = null), this.domElement.style.cursor = ns ? "pointer" : "auto", this.state = uo.NONE);
}
function S9(r) {
  this.enabled !== !1 && r.preventDefault();
}
function RN(r, e = null) {
  return r.isGroup && (e = r), r.parent === null ? e : RN(r.parent, e);
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Cg = "170", w9 = 0, E9 = 1, M9 = 2, A9 = 1, qp = 3, bc = 0, Zn = 1, $u = 2, xc = 0, co = 1, Cm = 2, Rm = 3, Nm = 4, NN = 5, eo = 100, PN = 101, IN = 102, C9 = 103, R9 = 104, ON = 200, DN = 201, LN = 202, UN = 203, Pm = 204, Im = 205, kN = 206, FN = 207, BN = 208, zN = 209, jN = 210, VN = 0, GN = 1, HN = 2, Om = 3, WN = 4, qN = 5, XN = 6, $N = 7, Rg = 0, N9 = 1, P9 = 2, Yu = 0, I9 = 1, O9 = 2, D9 = 3, L9 = 4, U9 = 6, k9 = 7, tT = 300, Tl = 301, _c = 302, qd = 303, Xd = 304, Kb = 306, Dm = 1e3, Lu = 1001, Lm = 1002, gr = 1003, Zb = 1004, Ku = 1005, ln = 1006, Qb = 1007, pa = 1008, ho = 1009, Qh = 1010, Jh = 1011, Uu = 1012, Sr = 1013, er = 1014, on = 1015, fa = 1016, F9 = 1017, B9 = 1018, $d = 1020, YN = 35902, z9 = 1021, iT = 1022, Fc = 1023, j9 = 1024, V9 = 1025, gl = 1026, Tc = 1027, rT = 1028, nT = 1029, gd = 1030, sT = 1031, G9 = 1032, aT = 1033, pv = 33776, em = 33777, tm = 33778, im = 33779, _E = 35840, TE = 35841, SE = 35842, wE = 35843, EE = 36196, Jb = 37492, ex = 37496, tx = 37808, ix = 37809, rx = 37810, nx = 37811, sx = 37812, ax = 37813, ox = 37814, lx = 37815, ux = 37816, cx = 37817, hx = 37818, dx = 37819, px = 37820, fx = 37821, fv = 36492, H9 = 36283, ME = 36284, AE = 36285, CE = 36286, vo = 0, W9 = 1, Sl = "", ct = "srgb", po = "srgb-linear", KN = "linear", yd = "srgb", q9 = 0, Go = 7680, X9 = 7681, $9 = 7682, Y9 = 7683, K9 = 34055, Z9 = 34056, Q9 = 5386, J9 = 512, e7 = 513, t7 = 514, i7 = 515, r7 = 516, n7 = 517, s7 = 518, mx = 519, ZN = 512, oT = 513, QN = 514, JN = 515, eP = 516, tP = 517, iP = 518, rP = 519, Um = 35044, ku = 35048, Yn = 2e3, wl = 2001;
class Bc {
  addEventListener(e, i) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(i) === -1 && n[e].push(i);
  }
  hasEventListener(e, i) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(i) !== -1;
  }
  removeEventListener(e, i) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const s = n.indexOf(i);
      s !== -1 && n.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const n = i.slice(0);
      for (let s = 0, a = n.length; s < a; s++)
        n[s].call(this, e);
      e.target = null;
    }
  }
}
const hr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let RE = 1234567;
const ed = Math.PI / 180, vd = 180 / Math.PI;
function ma() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (hr[r & 255] + hr[r >> 8 & 255] + hr[r >> 16 & 255] + hr[r >> 24 & 255] + "-" + hr[e & 255] + hr[e >> 8 & 255] + "-" + hr[e >> 16 & 15 | 64] + hr[e >> 24 & 255] + "-" + hr[i & 63 | 128] + hr[i >> 8 & 255] + "-" + hr[i >> 16 & 255] + hr[i >> 24 & 255] + hr[n & 255] + hr[n >> 8 & 255] + hr[n >> 16 & 255] + hr[n >> 24 & 255]).toLowerCase();
}
function tr(r, e, i) {
  return Math.max(e, Math.min(i, r));
}
function lT(r, e) {
  return (r % e + e) % e;
}
function a7(r, e, i, n, s) {
  return n + (r - e) * (s - n) / (i - e);
}
function o7(r, e, i) {
  return r !== e ? (i - r) / (e - r) : 0;
}
function td(r, e, i) {
  return (1 - i) * r + i * e;
}
function l7(r, e, i, n) {
  return td(r, e, 1 - Math.exp(-i * n));
}
function u7(r, e = 1) {
  return e - Math.abs(lT(r, e * 2) - e);
}
function c7(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * (3 - 2 * r));
}
function h7(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * r * (r * (r * 6 - 15) + 10));
}
function d7(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function p7(r, e) {
  return r + Math.random() * (e - r);
}
function f7(r) {
  return r * (0.5 - Math.random());
}
function m7(r) {
  r !== void 0 && (RE = r);
  let e = RE += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function g7(r) {
  return r * ed;
}
function y7(r) {
  return r * vd;
}
function v7(r) {
  return (r & r - 1) === 0 && r !== 0;
}
function b7(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function x7(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function _7(r, e, i, n, s) {
  const a = Math.cos, o = Math.sin, l = a(i / 2), u = o(i / 2), c = a((e + n) / 2), h = o((e + n) / 2), d = a((e - n) / 2), p = o((e - n) / 2), f = a((n - e) / 2), m = o((n - e) / 2);
  switch (s) {
    case "XYX":
      r.set(l * h, u * d, u * p, l * c);
      break;
    case "YZY":
      r.set(u * p, l * h, u * d, l * c);
      break;
    case "ZXZ":
      r.set(u * d, u * p, l * h, l * c);
      break;
    case "XZX":
      r.set(l * h, u * m, u * f, l * c);
      break;
    case "YXY":
      r.set(u * f, l * h, u * m, l * c);
      break;
    case "ZYZ":
      r.set(u * m, u * f, l * h, l * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function Mr(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function wt(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const T7 = {
  DEG2RAD: ed,
  RAD2DEG: vd,
  generateUUID: ma,
  clamp: tr,
  euclideanModulo: lT,
  mapLinear: a7,
  inverseLerp: o7,
  lerp: td,
  damp: l7,
  pingpong: u7,
  smoothstep: c7,
  smootherstep: h7,
  randInt: d7,
  randFloat: p7,
  randFloatSpread: f7,
  seededRandom: m7,
  degToRad: g7,
  radToDeg: y7,
  isPowerOfTwo: v7,
  ceilPowerOfTwo: b7,
  floorPowerOfTwo: x7,
  setQuaternionFromProperEuler: _7,
  normalize: wt,
  denormalize: Mr
};
class jt {
  constructor(e = 0, i = 0) {
    jt.prototype.isVector2 = !0, this.x = e, this.y = i;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, i) {
    return this.x = e, this.y = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * i + s[3] * n + s[6], this.y = s[1] * i + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(tr(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y;
    return i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this;
  }
  rotateAround(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = this.x - e.x, o = this.y - e.y;
    return this.x = a * n - o * s + e.x, this.y = a * s + o * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Xr {
  constructor(e, i, n, s, a, o, l, u, c) {
    Xr.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c);
  }
  set(e, i, n, s, a, o, l, u, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = l, h[3] = i, h[4] = a, h[5] = u, h[6] = n, h[7] = o, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrix3Column(this, 0), i.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[4],
      i[8],
      i[1],
      i[5],
      i[9],
      i[2],
      i[6],
      i[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[3], u = n[6], c = n[1], h = n[4], d = n[7], p = n[2], f = n[5], m = n[8], v = s[0], y = s[3], g = s[6], _ = s[1], x = s[4], b = s[7], T = s[2], S = s[5], w = s[8];
    return a[0] = o * v + l * _ + u * T, a[3] = o * y + l * x + u * S, a[6] = o * g + l * b + u * w, a[1] = c * v + h * _ + d * T, a[4] = c * y + h * x + d * S, a[7] = c * g + h * b + d * w, a[2] = p * v + f * _ + m * T, a[5] = p * y + f * x + m * S, a[8] = p * g + f * b + m * w, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= e, i[4] *= e, i[7] *= e, i[2] *= e, i[5] *= e, i[8] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8];
    return i * o * h - i * l * c - n * a * h + n * l * u + s * a * c - s * o * u;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = h * o - l * c, p = l * u - h * a, f = c * a - o * u, m = i * d + n * p + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / m;
    return e[0] = d * v, e[1] = (s * c - h * n) * v, e[2] = (l * n - s * o) * v, e[3] = p * v, e[4] = (h * i - s * u) * v, e[5] = (s * a - l * i) * v, e[6] = f * v, e[7] = (n * u - c * i) * v, e[8] = (o * i - n * a) * v, this;
  }
  transpose() {
    let e;
    const i = this.elements;
    return e = i[1], i[1] = i[3], i[3] = e, e = i[2], i[2] = i[6], i[6] = e, e = i[5], i[5] = i[7], i[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const i = this.elements;
    return e[0] = i[0], e[1] = i[3], e[2] = i[6], e[3] = i[1], e[4] = i[4], e[5] = i[7], e[6] = i[2], e[7] = i[5], e[8] = i[8], this;
  }
  setUvTransform(e, i, n, s, a, o, l) {
    const u = Math.cos(a), c = Math.sin(a);
    return this.set(
      n * u,
      n * c,
      -n * (u * o + c * l) + o + e,
      -s * c,
      s * u,
      -s * (-c * o + u * l) + l + i,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, i) {
    return this.premultiply(mv.makeScale(e, i)), this;
  }
  rotate(e) {
    return this.premultiply(mv.makeRotation(-e)), this;
  }
  translate(e, i) {
    return this.premultiply(mv.makeTranslation(e, i)), this;
  }
  // for 2D Transforms
  makeTranslation(e, i) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      i,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      n,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i) {
    return this.set(
      e,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const mv = /* @__PURE__ */ new Xr();
function S7(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function gx(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function w7() {
  const r = gx("canvas");
  return r.style.display = "block", r;
}
const NE = {};
function E7(r) {
  r in NE || (NE[r] = !0, console.warn(r));
}
const Li = {
  enabled: !0,
  workingColorSpace: po,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(r, e, i) {
    return this.enabled === !1 || e === i || !e || !i || (this.spaces[e].transfer === yd && (r.r = ga(r.r), r.g = ga(r.g), r.b = ga(r.b)), this.spaces[e].primaries !== this.spaces[i].primaries && (r.applyMatrix3(this.spaces[e].toXYZ), r.applyMatrix3(this.spaces[i].fromXYZ)), this.spaces[i].transfer === yd && (r.r = Zu(r.r), r.g = Zu(r.g), r.b = Zu(r.b))), r;
  },
  fromWorkingColorSpace: function(r, e) {
    return this.convert(r, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(r, e) {
    return this.convert(r, e, this.workingColorSpace);
  },
  getPrimaries: function(r) {
    return this.spaces[r].primaries;
  },
  getTransfer: function(r) {
    return r === Sl ? KN : this.spaces[r].transfer;
  },
  getLuminanceCoefficients: function(r, e = this.workingColorSpace) {
    return r.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(r) {
    Object.assign(this.spaces, r);
  },
  // Internal APIs
  _getMatrix: function(r, e, i) {
    return r.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(r) {
    return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(r = this.workingColorSpace) {
    return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
  }
};
function ga(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Zu(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const PE = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], IE = [0.2126, 0.7152, 0.0722], OE = [0.3127, 0.329], DE = /* @__PURE__ */ new Xr().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), LE = /* @__PURE__ */ new Xr().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
Li.define({
  [po]: {
    primaries: PE,
    whitePoint: OE,
    transfer: KN,
    toXYZ: DE,
    fromXYZ: LE,
    luminanceCoefficients: IE,
    workingColorSpaceConfig: { unpackColorSpace: ct },
    outputColorSpaceConfig: { drawingBufferColorSpace: ct }
  },
  [ct]: {
    primaries: PE,
    whitePoint: OE,
    transfer: yd,
    toXYZ: DE,
    fromXYZ: LE,
    luminanceCoefficients: IE,
    outputColorSpaceConfig: { drawingBufferColorSpace: ct }
  }
});
let ou;
class M7 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let i;
    if (e instanceof HTMLCanvasElement)
      i = e;
    else {
      ou === void 0 && (ou = gx("canvas")), ou.width = e.width, ou.height = e.height;
      const n = ou.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), i = ou;
    }
    return i.width > 2048 || i.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), i.toDataURL("image/jpeg", 0.6)) : i.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const i = gx("canvas");
      i.width = e.width, i.height = e.height;
      const n = i.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const s = n.getImageData(0, 0, e.width, e.height), a = s.data;
      for (let o = 0; o < a.length; o++)
        a[o] = ga(a[o] / 255) * 255;
      return n.putImageData(s, 0, 0), i;
    } else if (e.data) {
      const i = e.data.slice(0);
      for (let n = 0; n < i.length; n++)
        i instanceof Uint8Array || i instanceof Uint8ClampedArray ? i[n] = Math.floor(ga(i[n] / 255) * 255) : i[n] = ga(i[n]);
      return {
        data: i,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let A7 = 0;
class nP {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: A7++ }), this.uuid = ma(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, s = this.data;
    if (s !== null) {
      let a;
      if (Array.isArray(s)) {
        a = [];
        for (let o = 0, l = s.length; o < l; o++)
          s[o].isDataTexture ? a.push(gv(s[o].image)) : a.push(gv(s[o]));
      } else
        a = gv(s);
      n.url = a;
    }
    return i || (e.images[this.uuid] = n), n;
  }
}
function gv(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? M7.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let C7 = 0;
class Cr extends Bc {
  constructor(e = Cr.DEFAULT_IMAGE, i = Cr.DEFAULT_MAPPING, n = Lu, s = Lu, a = ln, o = pa, l = Fc, u = ho, c = Cr.DEFAULT_ANISOTROPY, h = Sl) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: C7++ }), this.uuid = ma(), this.name = "", this.source = new nP(e), this.mipmaps = [], this.mapping = i, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = a, this.minFilter = o, this.anisotropy = c, this.format = l, this.internalFormat = null, this.type = u, this.offset = new jt(0, 0), this.repeat = new jt(1, 1), this.center = new jt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Xr(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), i || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== tT) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Dm:
          e.x = e.x - Math.floor(e.x);
          break;
        case Lu:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Lm:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Dm:
          e.y = e.y - Math.floor(e.y);
          break;
        case Lu:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Lm:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Cr.DEFAULT_IMAGE = null;
Cr.DEFAULT_MAPPING = tT;
Cr.DEFAULT_ANISOTROPY = 1;
class $t {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    $t.prototype.isVector4 = !0, this.x = e, this.y = i, this.z = n, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, i, n, s) {
    return this.x = e, this.y = i, this.z = n, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      case 3:
        this.w = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this.w = e.w + i.w, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this.w += e.w * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this.w = e.w - i.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = this.w, o = e.elements;
    return this.x = o[0] * i + o[4] * n + o[8] * s + o[12] * a, this.y = o[1] * i + o[5] * n + o[9] * s + o[13] * a, this.z = o[2] * i + o[6] * n + o[10] * s + o[14] * a, this.w = o[3] * i + o[7] * n + o[11] * s + o[15] * a, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const i = Math.sqrt(1 - e.w * e.w);
    return i < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / i, this.y = e.y / i, this.z = e.z / i), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let i, n, s, a;
    const o = e.elements, l = o[0], u = o[4], c = o[8], h = o[1], d = o[5], p = o[9], f = o[2], m = o[6], v = o[10];
    if (Math.abs(u - h) < 0.01 && Math.abs(c - f) < 0.01 && Math.abs(p - m) < 0.01) {
      if (Math.abs(u + h) < 0.1 && Math.abs(c + f) < 0.1 && Math.abs(p + m) < 0.1 && Math.abs(l + d + v - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      i = Math.PI;
      const g = (l + 1) / 2, _ = (d + 1) / 2, x = (v + 1) / 2, b = (u + h) / 4, T = (c + f) / 4, S = (p + m) / 4;
      return g > _ && g > x ? g < 0.01 ? (n = 0, s = 0.707106781, a = 0.707106781) : (n = Math.sqrt(g), s = b / n, a = T / n) : _ > x ? _ < 0.01 ? (n = 0.707106781, s = 0, a = 0.707106781) : (s = Math.sqrt(_), n = b / s, a = S / s) : x < 0.01 ? (n = 0.707106781, s = 0.707106781, a = 0) : (a = Math.sqrt(x), n = T / a, s = S / a), this.set(n, s, a, i), this;
    }
    let y = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (h - u) * (h - u));
    return Math.abs(y) < 1e-3 && (y = 1), this.x = (m - p) / y, this.y = (c - f) / y, this.z = (h - u) / y, this.w = Math.acos((l + d + v - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this.w = i[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this.w = Math.max(e.w, Math.min(i.w, this.w)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this.w = Math.max(e, Math.min(i, this.w)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this.w += (e.w - this.w) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this.w = e.w + (i.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this.w = e[i + 3], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e[i + 3] = this.w, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this.w = e.getW(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class zc extends Bc {
  constructor(e = 1, i = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = i, this.depth = 1, this.scissor = new $t(0, 0, e, i), this.scissorTest = !1, this.viewport = new $t(0, 0, e, i);
    const s = { width: e, height: i, depth: 1 };
    n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: ln,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, n);
    const a = new Cr(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
    a.flipY = !1, a.generateMipmaps = n.generateMipmaps, a.internalFormat = n.internalFormat, this.textures = [];
    const o = n.count;
    for (let l = 0; l < o; l++)
      this.textures[l] = a.clone(), this.textures[l].isRenderTargetTexture = !0;
    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, i, n = 1) {
    if (this.width !== e || this.height !== i || this.depth !== n) {
      this.width = e, this.height = i, this.depth = n;
      for (let s = 0, a = this.textures.length; s < a; s++)
        this.textures[s].image.width = e, this.textures[s].image.height = i, this.textures[s].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, i), this.scissor.set(0, 0, e, i);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let n = 0, s = e.textures.length; n < s; n++)
      this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
    const i = Object.assign({}, e.texture.image);
    return this.texture.source = new nP(i), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class R7 extends zc {
  constructor(e = 1, i = 1, n = {}) {
    super(e, i, n), this.isWebGLRenderTarget = !0;
  }
}
class N7 extends Cr {
  constructor(e = null, i = 1, n = 1, s = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: i, height: n, depth: s }, this.magFilter = gr, this.minFilter = gr, this.wrapR = Lu, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Yd {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    this.isQuaternion = !0, this._x = e, this._y = i, this._z = n, this._w = s;
  }
  static slerpFlat(e, i, n, s, a, o, l) {
    let u = n[s + 0], c = n[s + 1], h = n[s + 2], d = n[s + 3];
    const p = a[o + 0], f = a[o + 1], m = a[o + 2], v = a[o + 3];
    if (l === 0) {
      e[i + 0] = u, e[i + 1] = c, e[i + 2] = h, e[i + 3] = d;
      return;
    }
    if (l === 1) {
      e[i + 0] = p, e[i + 1] = f, e[i + 2] = m, e[i + 3] = v;
      return;
    }
    if (d !== v || u !== p || c !== f || h !== m) {
      let y = 1 - l;
      const g = u * p + c * f + h * m + d * v, _ = g >= 0 ? 1 : -1, x = 1 - g * g;
      if (x > Number.EPSILON) {
        const T = Math.sqrt(x), S = Math.atan2(T, g * _);
        y = Math.sin(y * S) / T, l = Math.sin(l * S) / T;
      }
      const b = l * _;
      if (u = u * y + p * b, c = c * y + f * b, h = h * y + m * b, d = d * y + v * b, y === 1 - l) {
        const T = 1 / Math.sqrt(u * u + c * c + h * h + d * d);
        u *= T, c *= T, h *= T, d *= T;
      }
    }
    e[i] = u, e[i + 1] = c, e[i + 2] = h, e[i + 3] = d;
  }
  static multiplyQuaternionsFlat(e, i, n, s, a, o) {
    const l = n[s], u = n[s + 1], c = n[s + 2], h = n[s + 3], d = a[o], p = a[o + 1], f = a[o + 2], m = a[o + 3];
    return e[i] = l * m + h * d + u * f - c * p, e[i + 1] = u * m + h * p + c * d - l * f, e[i + 2] = c * m + h * f + l * p - u * d, e[i + 3] = h * m - l * d - u * p - c * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, i, n, s) {
    return this._x = e, this._y = i, this._z = n, this._w = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, i = !0) {
    const n = e._x, s = e._y, a = e._z, o = e._order, l = Math.cos, u = Math.sin, c = l(n / 2), h = l(s / 2), d = l(a / 2), p = u(n / 2), f = u(s / 2), m = u(a / 2);
    switch (o) {
      case "XYZ":
        this._x = p * h * d + c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "YXZ":
        this._x = p * h * d + c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d + p * f * m;
        break;
      case "ZXY":
        this._x = p * h * d - c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "ZYX":
        this._x = p * h * d - c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d + p * f * m;
        break;
      case "YZX":
        this._x = p * h * d + c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "XZY":
        this._x = p * h * d - c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d + p * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return i === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, i) {
    const n = i / 2, s = Math.sin(n);
    return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const i = e.elements, n = i[0], s = i[4], a = i[8], o = i[1], l = i[5], u = i[9], c = i[2], h = i[6], d = i[10], p = n + l + d;
    if (p > 0) {
      const f = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / f, this._x = (h - u) * f, this._y = (a - c) * f, this._z = (o - s) * f;
    } else if (n > l && n > d) {
      const f = 2 * Math.sqrt(1 + n - l - d);
      this._w = (h - u) / f, this._x = 0.25 * f, this._y = (s + o) / f, this._z = (a + c) / f;
    } else if (l > d) {
      const f = 2 * Math.sqrt(1 + l - n - d);
      this._w = (a - c) / f, this._x = (s + o) / f, this._y = 0.25 * f, this._z = (u + h) / f;
    } else {
      const f = 2 * Math.sqrt(1 + d - n - l);
      this._w = (o - s) / f, this._x = (a + c) / f, this._y = (u + h) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, i) {
    let n = e.dot(i) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * i.z - e.z * i.y, this._y = e.z * i.x - e.x * i.z, this._z = e.x * i.y - e.y * i.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(tr(this.dot(e), -1, 1)));
  }
  rotateTowards(e, i) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const s = Math.min(1, i / n);
    return this.slerp(e, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, i) {
    const n = e._x, s = e._y, a = e._z, o = e._w, l = i._x, u = i._y, c = i._z, h = i._w;
    return this._x = n * h + o * l + s * c - a * u, this._y = s * h + o * u + a * l - n * c, this._z = a * h + o * c + n * u - s * l, this._w = o * h - n * l - s * u - a * c, this._onChangeCallback(), this;
  }
  slerp(e, i) {
    if (i === 0) return this;
    if (i === 1) return this.copy(e);
    const n = this._x, s = this._y, a = this._z, o = this._w;
    let l = o * e._w + n * e._x + s * e._y + a * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = o, this._x = n, this._y = s, this._z = a, this;
    const u = 1 - l * l;
    if (u <= Number.EPSILON) {
      const f = 1 - i;
      return this._w = f * o + i * this._w, this._x = f * n + i * this._x, this._y = f * s + i * this._y, this._z = f * a + i * this._z, this.normalize(), this;
    }
    const c = Math.sqrt(u), h = Math.atan2(c, l), d = Math.sin((1 - i) * h) / c, p = Math.sin(i * h) / c;
    return this._w = o * d + this._w * p, this._x = n * d + this._x * p, this._y = s * d + this._y * p, this._z = a * d + this._z * p, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, i, n) {
    return this.copy(e).slerp(i, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), i = 2 * Math.PI * Math.random(), n = Math.random(), s = Math.sqrt(1 - n), a = Math.sqrt(n);
    return this.set(
      s * Math.sin(e),
      s * Math.cos(e),
      a * Math.sin(i),
      a * Math.cos(i)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, i = 0) {
    return this._x = e[i], this._y = e[i + 1], this._z = e[i + 2], this._w = e[i + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._w, e;
  }
  fromBufferAttribute(e, i) {
    return this._x = e.getX(i), this._y = e.getY(i), this._z = e.getZ(i), this._w = e.getW(i), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class oe {
  constructor(e = 0, i = 0, n = 0) {
    oe.prototype.isVector3 = !0, this.x = e, this.y = i, this.z = n;
  }
  set(e, i, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = i, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, i) {
    return this.x = e.x * i.x, this.y = e.y * i.y, this.z = e.z * i.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(UE.setFromEuler(e));
  }
  applyAxisAngle(e, i) {
    return this.applyQuaternion(UE.setFromAxisAngle(e, i));
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[3] * n + a[6] * s, this.y = a[1] * i + a[4] * n + a[7] * s, this.z = a[2] * i + a[5] * n + a[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements, o = 1 / (a[3] * i + a[7] * n + a[11] * s + a[15]);
    return this.x = (a[0] * i + a[4] * n + a[8] * s + a[12]) * o, this.y = (a[1] * i + a[5] * n + a[9] * s + a[13]) * o, this.z = (a[2] * i + a[6] * n + a[10] * s + a[14]) * o, this;
  }
  applyQuaternion(e) {
    const i = this.x, n = this.y, s = this.z, a = e.x, o = e.y, l = e.z, u = e.w, c = 2 * (o * s - l * n), h = 2 * (l * i - a * s), d = 2 * (a * n - o * i);
    return this.x = i + u * c + o * d - l * h, this.y = n + u * h + l * c - a * d, this.z = s + u * d + a * h - o * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[4] * n + a[8] * s, this.y = a[1] * i + a[5] * n + a[9] * s, this.z = a[2] * i + a[6] * n + a[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, i) {
    const n = e.x, s = e.y, a = e.z, o = i.x, l = i.y, u = i.z;
    return this.x = s * u - a * l, this.y = a * o - n * u, this.z = n * l - s * o, this;
  }
  projectOnVector(e) {
    const i = e.lengthSq();
    if (i === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / i;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return yv.copy(this).projectOnVector(e), this.sub(yv);
  }
  reflect(e) {
    return this.sub(yv.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(tr(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
    return i * i + n * n + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, i, n) {
    const s = Math.sin(i) * e;
    return this.x = s * Math.sin(n), this.y = Math.cos(i) * e, this.z = s * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, i, n) {
    return this.x = e * Math.sin(i), this.y = n, this.z = e * Math.cos(i), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this;
  }
  setFromMatrixScale(e) {
    const i = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = i, this.y = n, this.z = s, this;
  }
  setFromMatrixColumn(e, i) {
    return this.fromArray(e.elements, i * 4);
  }
  setFromMatrix3Column(e, i) {
    return this.fromArray(e.elements, i * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, i = Math.random() * 2 - 1, n = Math.sqrt(1 - i * i);
    return this.x = n * Math.cos(e), this.y = i, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const yv = /* @__PURE__ */ new oe(), UE = /* @__PURE__ */ new Yd();
class Kd {
  constructor(e = new oe(1 / 0, 1 / 0, 1 / 0), i = new oe(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = i;
  }
  set(e, i) {
    return this.min.copy(e), this.max.copy(i), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let i = 0, n = e.length; i < n; i += 3)
      this.expandByPoint(In.fromArray(e, i));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let i = 0, n = e.count; i < n; i++)
      this.expandByPoint(In.fromBufferAttribute(e, i));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let i = 0, n = e.length; i < n; i++)
      this.expandByPoint(e[i]);
    return this;
  }
  setFromCenterAndSize(e, i) {
    const n = In.copy(i).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, i = !1) {
    return this.makeEmpty(), this.expandByObject(e, i);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, i = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const a = n.getAttribute("position");
      if (i === !0 && a !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, l = a.count; o < l; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, In) : In.fromBufferAttribute(a, o), In.applyMatrix4(e.matrixWorld), this.expandByPoint(In);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Xp.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Xp.copy(n.boundingBox)), Xp.applyMatrix4(e.matrixWorld), this.union(Xp);
    }
    const s = e.children;
    for (let a = 0, o = s.length; a < o; a++)
      this.expandByObject(s[a], i);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, i) {
    return i.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, In), In.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let i, n;
    return e.normal.x > 0 ? (i = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (i = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (i += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (i += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (i += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (i += e.normal.z * this.max.z, n += e.normal.z * this.min.z), i <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(mh), $p.subVectors(this.max, mh), lu.subVectors(e.a, mh), uu.subVectors(e.b, mh), cu.subVectors(e.c, mh), Fa.subVectors(uu, lu), Ba.subVectors(cu, uu), Lo.subVectors(lu, cu);
    let i = [
      0,
      -Fa.z,
      Fa.y,
      0,
      -Ba.z,
      Ba.y,
      0,
      -Lo.z,
      Lo.y,
      Fa.z,
      0,
      -Fa.x,
      Ba.z,
      0,
      -Ba.x,
      Lo.z,
      0,
      -Lo.x,
      -Fa.y,
      Fa.x,
      0,
      -Ba.y,
      Ba.x,
      0,
      -Lo.y,
      Lo.x,
      0
    ];
    return !vv(i, lu, uu, cu, $p) || (i = [1, 0, 0, 0, 1, 0, 0, 0, 1], !vv(i, lu, uu, cu, $p)) ? !1 : (Yp.crossVectors(Fa, Ba), i = [Yp.x, Yp.y, Yp.z], vv(i, lu, uu, cu, $p));
  }
  clampPoint(e, i) {
    return i.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, In).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(In).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Ds[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ds[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ds[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ds[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ds[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ds[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ds[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ds[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ds), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ds = [
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe()
], In = /* @__PURE__ */ new oe(), Xp = /* @__PURE__ */ new Kd(), lu = /* @__PURE__ */ new oe(), uu = /* @__PURE__ */ new oe(), cu = /* @__PURE__ */ new oe(), Fa = /* @__PURE__ */ new oe(), Ba = /* @__PURE__ */ new oe(), Lo = /* @__PURE__ */ new oe(), mh = /* @__PURE__ */ new oe(), $p = /* @__PURE__ */ new oe(), Yp = /* @__PURE__ */ new oe(), Uo = /* @__PURE__ */ new oe();
function vv(r, e, i, n, s) {
  for (let a = 0, o = r.length - 3; a <= o; a += 3) {
    Uo.fromArray(r, a);
    const l = s.x * Math.abs(Uo.x) + s.y * Math.abs(Uo.y) + s.z * Math.abs(Uo.z), u = e.dot(Uo), c = i.dot(Uo), h = n.dot(Uo);
    if (Math.max(-Math.max(u, c, h), Math.min(u, c, h)) > l)
      return !1;
  }
  return !0;
}
const P7 = /* @__PURE__ */ new Kd(), gh = /* @__PURE__ */ new oe(), bv = /* @__PURE__ */ new oe();
class uT {
  constructor(e = new oe(), i = -1) {
    this.isSphere = !0, this.center = e, this.radius = i;
  }
  set(e, i) {
    return this.center.copy(e), this.radius = i, this;
  }
  setFromPoints(e, i) {
    const n = this.center;
    i !== void 0 ? n.copy(i) : P7.setFromPoints(e).getCenter(n);
    let s = 0;
    for (let a = 0, o = e.length; a < o; a++)
      s = Math.max(s, n.distanceToSquared(e[a]));
    return this.radius = Math.sqrt(s), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const i = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= i * i;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, i) {
    const n = this.center.distanceToSquared(e);
    return i.copy(e), n > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)), i;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    gh.subVectors(e, this.center);
    const i = gh.lengthSq();
    if (i > this.radius * this.radius) {
      const n = Math.sqrt(i), s = (n - this.radius) * 0.5;
      this.center.addScaledVector(gh, s / n), this.radius += s;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (bv.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(gh.copy(e.center).add(bv)), this.expandByPoint(gh.copy(e.center).sub(bv))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ls = /* @__PURE__ */ new oe(), xv = /* @__PURE__ */ new oe(), Kp = /* @__PURE__ */ new oe(), za = /* @__PURE__ */ new oe(), _v = /* @__PURE__ */ new oe(), Zp = /* @__PURE__ */ new oe(), Tv = /* @__PURE__ */ new oe();
class I7 {
  constructor(e = new oe(), i = new oe(0, 0, -1)) {
    this.origin = e, this.direction = i;
  }
  set(e, i) {
    return this.origin.copy(e), this.direction.copy(i), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, i) {
    return i.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ls)), this;
  }
  closestPointToPoint(e, i) {
    i.subVectors(e, this.origin);
    const n = i.dot(this.direction);
    return n < 0 ? i.copy(this.origin) : i.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const i = Ls.subVectors(e, this.origin).dot(this.direction);
    return i < 0 ? this.origin.distanceToSquared(e) : (Ls.copy(this.origin).addScaledVector(this.direction, i), Ls.distanceToSquared(e));
  }
  distanceSqToSegment(e, i, n, s) {
    xv.copy(e).add(i).multiplyScalar(0.5), Kp.copy(i).sub(e).normalize(), za.copy(this.origin).sub(xv);
    const a = e.distanceTo(i) * 0.5, o = -this.direction.dot(Kp), l = za.dot(this.direction), u = -za.dot(Kp), c = za.lengthSq(), h = Math.abs(1 - o * o);
    let d, p, f, m;
    if (h > 0)
      if (d = o * u - l, p = o * l - u, m = a * h, d >= 0)
        if (p >= -m)
          if (p <= m) {
            const v = 1 / h;
            d *= v, p *= v, f = d * (d + o * p + 2 * l) + p * (o * d + p + 2 * u) + c;
          } else
            p = a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
        else
          p = -a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
      else
        p <= -m ? (d = Math.max(0, -(-o * a + l)), p = d > 0 ? -a : Math.min(Math.max(-a, -u), a), f = -d * d + p * (p + 2 * u) + c) : p <= m ? (d = 0, p = Math.min(Math.max(-a, -u), a), f = p * (p + 2 * u) + c) : (d = Math.max(0, -(o * a + l)), p = d > 0 ? a : Math.min(Math.max(-a, -u), a), f = -d * d + p * (p + 2 * u) + c);
    else
      p = o > 0 ? -a : a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
    return n && n.copy(this.origin).addScaledVector(this.direction, d), s && s.copy(xv).addScaledVector(Kp, p), f;
  }
  intersectSphere(e, i) {
    Ls.subVectors(e.center, this.origin);
    const n = Ls.dot(this.direction), s = Ls.dot(Ls) - n * n, a = e.radius * e.radius;
    if (s > a) return null;
    const o = Math.sqrt(a - s), l = n - o, u = n + o;
    return u < 0 ? null : l < 0 ? this.at(u, i) : this.at(l, i);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const i = e.normal.dot(this.direction);
    if (i === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / i;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, i) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, i);
  }
  intersectsPlane(e) {
    const i = e.distanceToPoint(this.origin);
    return i === 0 || e.normal.dot(this.direction) * i < 0;
  }
  intersectBox(e, i) {
    let n, s, a, o, l, u;
    const c = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin;
    return c >= 0 ? (n = (e.min.x - p.x) * c, s = (e.max.x - p.x) * c) : (n = (e.max.x - p.x) * c, s = (e.min.x - p.x) * c), h >= 0 ? (a = (e.min.y - p.y) * h, o = (e.max.y - p.y) * h) : (a = (e.max.y - p.y) * h, o = (e.min.y - p.y) * h), n > o || a > s || ((a > n || isNaN(n)) && (n = a), (o < s || isNaN(s)) && (s = o), d >= 0 ? (l = (e.min.z - p.z) * d, u = (e.max.z - p.z) * d) : (l = (e.max.z - p.z) * d, u = (e.min.z - p.z) * d), n > u || l > s) || ((l > n || n !== n) && (n = l), (u < s || s !== s) && (s = u), s < 0) ? null : this.at(n >= 0 ? n : s, i);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Ls) !== null;
  }
  intersectTriangle(e, i, n, s, a) {
    _v.subVectors(i, e), Zp.subVectors(n, e), Tv.crossVectors(_v, Zp);
    let o = this.direction.dot(Tv), l;
    if (o > 0) {
      if (s) return null;
      l = 1;
    } else if (o < 0)
      l = -1, o = -o;
    else
      return null;
    za.subVectors(this.origin, e);
    const u = l * this.direction.dot(Zp.crossVectors(za, Zp));
    if (u < 0)
      return null;
    const c = l * this.direction.dot(_v.cross(za));
    if (c < 0 || u + c > o)
      return null;
    const h = -l * za.dot(Tv);
    return h < 0 ? null : this.at(h / o, a);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class gi {
  constructor(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y) {
    gi.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y);
  }
  set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y) {
    const g = this.elements;
    return g[0] = e, g[4] = i, g[8] = n, g[12] = s, g[1] = a, g[5] = o, g[9] = l, g[13] = u, g[2] = c, g[6] = h, g[10] = d, g[14] = p, g[3] = f, g[7] = m, g[11] = v, g[15] = y, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new gi().fromArray(this.elements);
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], i[9] = n[9], i[10] = n[10], i[11] = n[11], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15], this;
  }
  copyPosition(e) {
    const i = this.elements, n = e.elements;
    return i[12] = n[12], i[13] = n[13], i[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[3],
      i[6],
      0,
      i[1],
      i[4],
      i[7],
      0,
      i[2],
      i[5],
      i[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrixColumn(this, 0), i.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, i, n) {
    return this.set(
      e.x,
      i.x,
      n.x,
      0,
      e.y,
      i.y,
      n.y,
      0,
      e.z,
      i.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const i = this.elements, n = e.elements, s = 1 / hu.setFromMatrixColumn(e, 0).length(), a = 1 / hu.setFromMatrixColumn(e, 1).length(), o = 1 / hu.setFromMatrixColumn(e, 2).length();
    return i[0] = n[0] * s, i[1] = n[1] * s, i[2] = n[2] * s, i[3] = 0, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[7] = 0, i[8] = n[8] * o, i[9] = n[9] * o, i[10] = n[10] * o, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z, o = Math.cos(n), l = Math.sin(n), u = Math.cos(s), c = Math.sin(s), h = Math.cos(a), d = Math.sin(a);
    if (e.order === "XYZ") {
      const p = o * h, f = o * d, m = l * h, v = l * d;
      i[0] = u * h, i[4] = -u * d, i[8] = c, i[1] = f + m * c, i[5] = p - v * c, i[9] = -l * u, i[2] = v - p * c, i[6] = m + f * c, i[10] = o * u;
    } else if (e.order === "YXZ") {
      const p = u * h, f = u * d, m = c * h, v = c * d;
      i[0] = p + v * l, i[4] = m * l - f, i[8] = o * c, i[1] = o * d, i[5] = o * h, i[9] = -l, i[2] = f * l - m, i[6] = v + p * l, i[10] = o * u;
    } else if (e.order === "ZXY") {
      const p = u * h, f = u * d, m = c * h, v = c * d;
      i[0] = p - v * l, i[4] = -o * d, i[8] = m + f * l, i[1] = f + m * l, i[5] = o * h, i[9] = v - p * l, i[2] = -o * c, i[6] = l, i[10] = o * u;
    } else if (e.order === "ZYX") {
      const p = o * h, f = o * d, m = l * h, v = l * d;
      i[0] = u * h, i[4] = m * c - f, i[8] = p * c + v, i[1] = u * d, i[5] = v * c + p, i[9] = f * c - m, i[2] = -c, i[6] = l * u, i[10] = o * u;
    } else if (e.order === "YZX") {
      const p = o * u, f = o * c, m = l * u, v = l * c;
      i[0] = u * h, i[4] = v - p * d, i[8] = m * d + f, i[1] = d, i[5] = o * h, i[9] = -l * h, i[2] = -c * h, i[6] = f * d + m, i[10] = p - v * d;
    } else if (e.order === "XZY") {
      const p = o * u, f = o * c, m = l * u, v = l * c;
      i[0] = u * h, i[4] = -d, i[8] = c * h, i[1] = p * d + v, i[5] = o * h, i[9] = f * d - m, i[2] = m * d - f, i[6] = l * h, i[10] = v * d + p;
    }
    return i[3] = 0, i[7] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(O7, e, D7);
  }
  lookAt(e, i, n) {
    const s = this.elements;
    return Qr.subVectors(e, i), Qr.lengthSq() === 0 && (Qr.z = 1), Qr.normalize(), ja.crossVectors(n, Qr), ja.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Qr.x += 1e-4 : Qr.z += 1e-4, Qr.normalize(), ja.crossVectors(n, Qr)), ja.normalize(), Qp.crossVectors(Qr, ja), s[0] = ja.x, s[4] = Qp.x, s[8] = Qr.x, s[1] = ja.y, s[5] = Qp.y, s[9] = Qr.y, s[2] = ja.z, s[6] = Qp.z, s[10] = Qr.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[4], u = n[8], c = n[12], h = n[1], d = n[5], p = n[9], f = n[13], m = n[2], v = n[6], y = n[10], g = n[14], _ = n[3], x = n[7], b = n[11], T = n[15], S = s[0], w = s[4], A = s[8], E = s[12], M = s[1], N = s[5], k = s[9], U = s[13], C = s[2], O = s[6], D = s[10], H = s[14], j = s[3], K = s[7], L = s[11], B = s[15];
    return a[0] = o * S + l * M + u * C + c * j, a[4] = o * w + l * N + u * O + c * K, a[8] = o * A + l * k + u * D + c * L, a[12] = o * E + l * U + u * H + c * B, a[1] = h * S + d * M + p * C + f * j, a[5] = h * w + d * N + p * O + f * K, a[9] = h * A + d * k + p * D + f * L, a[13] = h * E + d * U + p * H + f * B, a[2] = m * S + v * M + y * C + g * j, a[6] = m * w + v * N + y * O + g * K, a[10] = m * A + v * k + y * D + g * L, a[14] = m * E + v * U + y * H + g * B, a[3] = _ * S + x * M + b * C + T * j, a[7] = _ * w + x * N + b * O + T * K, a[11] = _ * A + x * k + b * D + T * L, a[15] = _ * E + x * U + b * H + T * B, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[4] *= e, i[8] *= e, i[12] *= e, i[1] *= e, i[5] *= e, i[9] *= e, i[13] *= e, i[2] *= e, i[6] *= e, i[10] *= e, i[14] *= e, i[3] *= e, i[7] *= e, i[11] *= e, i[15] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[4], s = e[8], a = e[12], o = e[1], l = e[5], u = e[9], c = e[13], h = e[2], d = e[6], p = e[10], f = e[14], m = e[3], v = e[7], y = e[11], g = e[15];
    return m * (+a * u * d - s * c * d - a * l * p + n * c * p + s * l * f - n * u * f) + v * (+i * u * f - i * c * p + a * o * p - s * o * f + s * c * h - a * u * h) + y * (+i * c * d - i * l * f - a * o * d + n * o * f + a * l * h - n * c * h) + g * (-s * l * h - i * u * d + i * l * p + s * o * d - n * o * p + n * u * h);
  }
  transpose() {
    const e = this.elements;
    let i;
    return i = e[1], e[1] = e[4], e[4] = i, i = e[2], e[2] = e[8], e[8] = i, i = e[6], e[6] = e[9], e[9] = i, i = e[3], e[3] = e[12], e[12] = i, i = e[7], e[7] = e[13], e[13] = i, i = e[11], e[11] = e[14], e[14] = i, this;
  }
  setPosition(e, i, n) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = i, s[14] = n), this;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = e[9], p = e[10], f = e[11], m = e[12], v = e[13], y = e[14], g = e[15], _ = d * y * c - v * p * c + v * u * f - l * y * f - d * u * g + l * p * g, x = m * p * c - h * y * c - m * u * f + o * y * f + h * u * g - o * p * g, b = h * v * c - m * d * c + m * l * f - o * v * f - h * l * g + o * d * g, T = m * d * u - h * v * u - m * l * p + o * v * p + h * l * y - o * d * y, S = i * _ + n * x + s * b + a * T;
    if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / S;
    return e[0] = _ * w, e[1] = (v * p * a - d * y * a - v * s * f + n * y * f + d * s * g - n * p * g) * w, e[2] = (l * y * a - v * u * a + v * s * c - n * y * c - l * s * g + n * u * g) * w, e[3] = (d * u * a - l * p * a - d * s * c + n * p * c + l * s * f - n * u * f) * w, e[4] = x * w, e[5] = (h * y * a - m * p * a + m * s * f - i * y * f - h * s * g + i * p * g) * w, e[6] = (m * u * a - o * y * a - m * s * c + i * y * c + o * s * g - i * u * g) * w, e[7] = (o * p * a - h * u * a + h * s * c - i * p * c - o * s * f + i * u * f) * w, e[8] = b * w, e[9] = (m * d * a - h * v * a - m * n * f + i * v * f + h * n * g - i * d * g) * w, e[10] = (o * v * a - m * l * a + m * n * c - i * v * c - o * n * g + i * l * g) * w, e[11] = (h * l * a - o * d * a - h * n * c + i * d * c + o * n * f - i * l * f) * w, e[12] = T * w, e[13] = (h * v * s - m * d * s + m * n * p - i * v * p - h * n * y + i * d * y) * w, e[14] = (m * l * s - o * v * s - m * n * u + i * v * u + o * n * y - i * l * y) * w, e[15] = (o * d * s - h * l * s + h * n * u - i * d * u - o * n * p + i * l * p) * w, this;
  }
  scale(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z;
    return i[0] *= n, i[4] *= s, i[8] *= a, i[1] *= n, i[5] *= s, i[9] *= a, i[2] *= n, i[6] *= s, i[10] *= a, i[3] *= n, i[7] *= s, i[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(i, n, s));
  }
  makeTranslation(e, i, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      i,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = 1 - n, o = e.x, l = e.y, u = e.z, c = a * o, h = a * l;
    return this.set(
      c * o + n,
      c * l - s * u,
      c * u + s * l,
      0,
      c * l + s * u,
      h * l + n,
      h * u - s * o,
      0,
      c * u - s * l,
      h * u + s * o,
      a * u * u + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, i, n, s, a, o) {
    return this.set(
      1,
      n,
      a,
      0,
      e,
      1,
      o,
      0,
      i,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, i, n) {
    const s = this.elements, a = i._x, o = i._y, l = i._z, u = i._w, c = a + a, h = o + o, d = l + l, p = a * c, f = a * h, m = a * d, v = o * h, y = o * d, g = l * d, _ = u * c, x = u * h, b = u * d, T = n.x, S = n.y, w = n.z;
    return s[0] = (1 - (v + g)) * T, s[1] = (f + b) * T, s[2] = (m - x) * T, s[3] = 0, s[4] = (f - b) * S, s[5] = (1 - (p + g)) * S, s[6] = (y + _) * S, s[7] = 0, s[8] = (m + x) * w, s[9] = (y - _) * w, s[10] = (1 - (p + v)) * w, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, i, n) {
    const s = this.elements;
    let a = hu.set(s[0], s[1], s[2]).length();
    const o = hu.set(s[4], s[5], s[6]).length(), l = hu.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (a = -a), e.x = s[12], e.y = s[13], e.z = s[14], On.copy(this);
    const u = 1 / a, c = 1 / o, h = 1 / l;
    return On.elements[0] *= u, On.elements[1] *= u, On.elements[2] *= u, On.elements[4] *= c, On.elements[5] *= c, On.elements[6] *= c, On.elements[8] *= h, On.elements[9] *= h, On.elements[10] *= h, i.setFromRotationMatrix(On), n.x = a, n.y = o, n.z = l, this;
  }
  makePerspective(e, i, n, s, a, o, l = Yn) {
    const u = this.elements, c = 2 * a / (i - e), h = 2 * a / (n - s), d = (i + e) / (i - e), p = (n + s) / (n - s);
    let f, m;
    if (l === Yn)
      f = -(o + a) / (o - a), m = -2 * o * a / (o - a);
    else if (l === wl)
      f = -o / (o - a), m = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return u[0] = c, u[4] = 0, u[8] = d, u[12] = 0, u[1] = 0, u[5] = h, u[9] = p, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = f, u[14] = m, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this;
  }
  makeOrthographic(e, i, n, s, a, o, l = Yn) {
    const u = this.elements, c = 1 / (i - e), h = 1 / (n - s), d = 1 / (o - a), p = (i + e) * c, f = (n + s) * h;
    let m, v;
    if (l === Yn)
      m = (o + a) * d, v = -2 * d;
    else if (l === wl)
      m = a * d, v = -1 * d;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return u[0] = 2 * c, u[4] = 0, u[8] = 0, u[12] = -p, u[1] = 0, u[5] = 2 * h, u[9] = 0, u[13] = -f, u[2] = 0, u[6] = 0, u[10] = v, u[14] = -m, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this;
  }
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 16; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e[i + 9] = n[9], e[i + 10] = n[10], e[i + 11] = n[11], e[i + 12] = n[12], e[i + 13] = n[13], e[i + 14] = n[14], e[i + 15] = n[15], e;
  }
}
const hu = /* @__PURE__ */ new oe(), On = /* @__PURE__ */ new gi(), O7 = /* @__PURE__ */ new oe(0, 0, 0), D7 = /* @__PURE__ */ new oe(1, 1, 1), ja = /* @__PURE__ */ new oe(), Qp = /* @__PURE__ */ new oe(), Qr = /* @__PURE__ */ new oe(), kE = /* @__PURE__ */ new gi(), FE = /* @__PURE__ */ new Yd();
class Qn {
  constructor(e = 0, i = 0, n = 0, s = Qn.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = i, this._z = n, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, i, n, s = this._order) {
    return this._x = e, this._y = i, this._z = n, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, i = this._order, n = !0) {
    const s = e.elements, a = s[0], o = s[4], l = s[8], u = s[1], c = s[5], h = s[9], d = s[2], p = s[6], f = s[10];
    switch (i) {
      case "XYZ":
        this._y = Math.asin(tr(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(p, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-tr(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(u, c)) : (this._y = Math.atan2(-d, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(tr(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(u, a));
        break;
      case "ZYX":
        this._y = Math.asin(-tr(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(u, a)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin(tr(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-d, a)) : (this._x = 0, this._y = Math.atan2(l, f));
        break;
      case "XZY":
        this._z = Math.asin(-tr(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + i);
    }
    return this._order = i, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, i, n) {
    return kE.makeRotationFromQuaternion(e), this.setFromRotationMatrix(kE, i, n);
  }
  setFromVector3(e, i = this._order) {
    return this.set(e.x, e.y, e.z, i);
  }
  reorder(e) {
    return FE.setFromEuler(this), this.setFromQuaternion(FE, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Qn.DEFAULT_ORDER = "XYZ";
class L7 {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let U7 = 0;
const BE = /* @__PURE__ */ new oe(), du = /* @__PURE__ */ new Yd(), Us = /* @__PURE__ */ new gi(), Jp = /* @__PURE__ */ new oe(), yh = /* @__PURE__ */ new oe(), k7 = /* @__PURE__ */ new oe(), F7 = /* @__PURE__ */ new Yd(), zE = /* @__PURE__ */ new oe(1, 0, 0), jE = /* @__PURE__ */ new oe(0, 1, 0), VE = /* @__PURE__ */ new oe(0, 0, 1), GE = { type: "added" }, B7 = { type: "removed" }, pu = { type: "childadded", child: null }, Sv = { type: "childremoved", child: null };
class Zi extends Bc {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: U7++ }), this.uuid = ma(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Zi.DEFAULT_UP.clone();
    const e = new oe(), i = new Qn(), n = new Yd(), s = new oe(1, 1, 1);
    function a() {
      n.setFromEuler(i, !1);
    }
    function o() {
      i.setFromQuaternion(n, void 0, !1);
    }
    i._onChange(a), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      modelViewMatrix: {
        value: new gi()
      },
      normalMatrix: {
        value: new Xr()
      }
    }), this.matrix = new gi(), this.matrixWorld = new gi(), this.matrixAutoUpdate = Zi.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Zi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new L7(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, i) {
    this.quaternion.setFromAxisAngle(e, i);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, i) {
    return du.setFromAxisAngle(e, i), this.quaternion.multiply(du), this;
  }
  rotateOnWorldAxis(e, i) {
    return du.setFromAxisAngle(e, i), this.quaternion.premultiply(du), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(zE, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(jE, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(VE, e);
  }
  translateOnAxis(e, i) {
    return BE.copy(e).applyQuaternion(this.quaternion), this.position.add(BE.multiplyScalar(i)), this;
  }
  translateX(e) {
    return this.translateOnAxis(zE, e);
  }
  translateY(e) {
    return this.translateOnAxis(jE, e);
  }
  translateZ(e) {
    return this.translateOnAxis(VE, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Us.copy(this.matrixWorld).invert());
  }
  lookAt(e, i, n) {
    e.isVector3 ? Jp.copy(e) : Jp.set(e, i, n);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), yh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Us.lookAt(yh, Jp, this.up) : Us.lookAt(Jp, yh, this.up), this.quaternion.setFromRotationMatrix(Us), s && (Us.extractRotation(s.matrixWorld), du.setFromRotationMatrix(Us), this.quaternion.premultiply(du.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.add(arguments[i]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(GE), pu.child = e, this.dispatchEvent(pu), pu.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const i = this.children.indexOf(e);
    return i !== -1 && (e.parent = null, this.children.splice(i, 1), e.dispatchEvent(B7), Sv.child = e, this.dispatchEvent(Sv), Sv.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Us.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Us.multiply(e.parent.matrixWorld)), e.applyMatrix4(Us), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(GE), pu.child = e, this.dispatchEvent(pu), pu.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, i) {
    if (this[e] === i) return this;
    for (let n = 0, s = this.children.length; n < s; n++) {
      const a = this.children[n].getObjectByProperty(e, i);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, i, n = []) {
    this[e] === i && n.push(this);
    const s = this.children;
    for (let a = 0, o = s.length; a < o; a++)
      s[a].getObjectsByProperty(e, i, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(yh, e, k7), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(yh, F7, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const i = this.matrixWorld.elements;
    return e.set(i[8], i[9], i[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const i = this.parent;
    i !== null && (e(i), i.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, i) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), i === !0) {
      const s = this.children;
      for (let a = 0, o = s.length; a < o; a++)
        s[a].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string", n = {};
    i && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
      center: s.boundingSphere.center.toArray(),
      radius: s.boundingSphere.radius
    }), this.boundingBox !== null && (s.boundingBox = {
      min: s.boundingBox.min.toArray(),
      max: s.boundingBox.max.toArray()
    }));
    function a(l, u) {
      return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = a(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const u = l.shapes;
        if (Array.isArray(u))
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c];
            a(e.shapes, d);
          }
        else
          a(e.shapes, u);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let u = 0, c = this.material.length; u < c; u++)
          l.push(a(e.materials, this.material[u]));
        s.material = l;
      } else
        s.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let l = 0; l < this.children.length; l++)
        s.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const u = this.animations[l];
        s.animations.push(a(e.animations, u));
      }
    }
    if (i) {
      const l = o(e.geometries), u = o(e.materials), c = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), f = o(e.animations), m = o(e.nodes);
      l.length > 0 && (n.geometries = l), u.length > 0 && (n.materials = u), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), d.length > 0 && (n.shapes = d), p.length > 0 && (n.skeletons = p), f.length > 0 && (n.animations = f), m.length > 0 && (n.nodes = m);
    }
    return n.object = s, n;
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, i = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), i === !0)
      for (let n = 0; n < e.children.length; n++) {
        const s = e.children[n];
        this.add(s.clone());
      }
    return this;
  }
}
Zi.DEFAULT_UP = /* @__PURE__ */ new oe(0, 1, 0);
Zi.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Zi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Dn = /* @__PURE__ */ new oe(), ks = /* @__PURE__ */ new oe(), wv = /* @__PURE__ */ new oe(), Fs = /* @__PURE__ */ new oe(), fu = /* @__PURE__ */ new oe(), mu = /* @__PURE__ */ new oe(), HE = /* @__PURE__ */ new oe(), Ev = /* @__PURE__ */ new oe(), Mv = /* @__PURE__ */ new oe(), Av = /* @__PURE__ */ new oe(), Cv = /* @__PURE__ */ new $t(), Rv = /* @__PURE__ */ new $t(), Nv = /* @__PURE__ */ new $t();
class qn {
  constructor(e = new oe(), i = new oe(), n = new oe()) {
    this.a = e, this.b = i, this.c = n;
  }
  static getNormal(e, i, n, s) {
    s.subVectors(n, i), Dn.subVectors(e, i), s.cross(Dn);
    const a = s.lengthSq();
    return a > 0 ? s.multiplyScalar(1 / Math.sqrt(a)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, i, n, s, a) {
    Dn.subVectors(s, i), ks.subVectors(n, i), wv.subVectors(e, i);
    const o = Dn.dot(Dn), l = Dn.dot(ks), u = Dn.dot(wv), c = ks.dot(ks), h = ks.dot(wv), d = o * c - l * l;
    if (d === 0)
      return a.set(0, 0, 0), null;
    const p = 1 / d, f = (c * u - l * h) * p, m = (o * h - l * u) * p;
    return a.set(1 - f - m, m, f);
  }
  static containsPoint(e, i, n, s) {
    return this.getBarycoord(e, i, n, s, Fs) === null ? !1 : Fs.x >= 0 && Fs.y >= 0 && Fs.x + Fs.y <= 1;
  }
  static getInterpolation(e, i, n, s, a, o, l, u) {
    return this.getBarycoord(e, i, n, s, Fs) === null ? (u.x = 0, u.y = 0, "z" in u && (u.z = 0), "w" in u && (u.w = 0), null) : (u.setScalar(0), u.addScaledVector(a, Fs.x), u.addScaledVector(o, Fs.y), u.addScaledVector(l, Fs.z), u);
  }
  static getInterpolatedAttribute(e, i, n, s, a, o) {
    return Cv.setScalar(0), Rv.setScalar(0), Nv.setScalar(0), Cv.fromBufferAttribute(e, i), Rv.fromBufferAttribute(e, n), Nv.fromBufferAttribute(e, s), o.setScalar(0), o.addScaledVector(Cv, a.x), o.addScaledVector(Rv, a.y), o.addScaledVector(Nv, a.z), o;
  }
  static isFrontFacing(e, i, n, s) {
    return Dn.subVectors(n, i), ks.subVectors(e, i), Dn.cross(ks).dot(s) < 0;
  }
  set(e, i, n) {
    return this.a.copy(e), this.b.copy(i), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, i, n, s) {
    return this.a.copy(e[i]), this.b.copy(e[n]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, i, n, s) {
    return this.a.fromBufferAttribute(e, i), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Dn.subVectors(this.c, this.b), ks.subVectors(this.a, this.b), Dn.cross(ks).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return qn.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, i) {
    return qn.getBarycoord(e, this.a, this.b, this.c, i);
  }
  getInterpolation(e, i, n, s, a) {
    return qn.getInterpolation(e, this.a, this.b, this.c, i, n, s, a);
  }
  containsPoint(e) {
    return qn.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return qn.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, i) {
    const n = this.a, s = this.b, a = this.c;
    let o, l;
    fu.subVectors(s, n), mu.subVectors(a, n), Ev.subVectors(e, n);
    const u = fu.dot(Ev), c = mu.dot(Ev);
    if (u <= 0 && c <= 0)
      return i.copy(n);
    Mv.subVectors(e, s);
    const h = fu.dot(Mv), d = mu.dot(Mv);
    if (h >= 0 && d <= h)
      return i.copy(s);
    const p = u * d - h * c;
    if (p <= 0 && u >= 0 && h <= 0)
      return o = u / (u - h), i.copy(n).addScaledVector(fu, o);
    Av.subVectors(e, a);
    const f = fu.dot(Av), m = mu.dot(Av);
    if (m >= 0 && f <= m)
      return i.copy(a);
    const v = f * c - u * m;
    if (v <= 0 && c >= 0 && m <= 0)
      return l = c / (c - m), i.copy(n).addScaledVector(mu, l);
    const y = h * m - f * d;
    if (y <= 0 && d - h >= 0 && f - m >= 0)
      return HE.subVectors(a, s), l = (d - h) / (d - h + (f - m)), i.copy(s).addScaledVector(HE, l);
    const g = 1 / (y + v + p);
    return o = v * g, l = p * g, i.copy(n).addScaledVector(fu, o).addScaledVector(mu, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const sP = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Va = { h: 0, s: 0, l: 0 }, ef = { h: 0, s: 0, l: 0 };
function Pv(r, e, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? r + (e - r) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - i) : r;
}
class Yt {
  constructor(e, i, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, i, n);
  }
  set(e, i, n) {
    if (i === void 0 && n === void 0) {
      const s = e;
      s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
    } else
      this.setRGB(e, i, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, i = ct) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Li.toWorkingColorSpace(this, i), this;
  }
  setRGB(e, i, n, s = Li.workingColorSpace) {
    return this.r = e, this.g = i, this.b = n, Li.toWorkingColorSpace(this, s), this;
  }
  setHSL(e, i, n, s = Li.workingColorSpace) {
    if (e = lT(e, 1), i = tr(i, 0, 1), n = tr(n, 0, 1), i === 0)
      this.r = this.g = this.b = n;
    else {
      const a = n <= 0.5 ? n * (1 + i) : n + i - n * i, o = 2 * n - a;
      this.r = Pv(o, a, e + 1 / 3), this.g = Pv(o, a, e), this.b = Pv(o, a, e - 1 / 3);
    }
    return Li.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, i = ct) {
    function n(a) {
      a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let a;
      const o = s[1], l = s[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setRGB(
              Math.min(255, parseInt(a[1], 10)) / 255,
              Math.min(255, parseInt(a[2], 10)) / 255,
              Math.min(255, parseInt(a[3], 10)) / 255,
              i
            );
          if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setRGB(
              Math.min(100, parseInt(a[1], 10)) / 100,
              Math.min(100, parseInt(a[2], 10)) / 100,
              Math.min(100, parseInt(a[3], 10)) / 100,
              i
            );
          break;
        case "hsl":
        case "hsla":
          if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setHSL(
              parseFloat(a[1]) / 360,
              parseFloat(a[2]) / 100,
              parseFloat(a[3]) / 100,
              i
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const a = s[1], o = a.length;
      if (o === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          i
        );
      if (o === 6)
        return this.setHex(parseInt(a, 16), i);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, i);
    return this;
  }
  setColorName(e, i = ct) {
    const n = sP[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, i) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = ga(e.r), this.g = ga(e.g), this.b = ga(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Zu(e.r), this.g = Zu(e.g), this.b = Zu(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = ct) {
    return Li.fromWorkingColorSpace(dr.copy(this), e), Math.round(tr(dr.r * 255, 0, 255)) * 65536 + Math.round(tr(dr.g * 255, 0, 255)) * 256 + Math.round(tr(dr.b * 255, 0, 255));
  }
  getHexString(e = ct) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, i = Li.workingColorSpace) {
    Li.fromWorkingColorSpace(dr.copy(this), i);
    const n = dr.r, s = dr.g, a = dr.b, o = Math.max(n, s, a), l = Math.min(n, s, a);
    let u, c;
    const h = (l + o) / 2;
    if (l === o)
      u = 0, c = 0;
    else {
      const d = o - l;
      switch (c = h <= 0.5 ? d / (o + l) : d / (2 - o - l), o) {
        case n:
          u = (s - a) / d + (s < a ? 6 : 0);
          break;
        case s:
          u = (a - n) / d + 2;
          break;
        case a:
          u = (n - s) / d + 4;
          break;
      }
      u /= 6;
    }
    return e.h = u, e.s = c, e.l = h, e;
  }
  getRGB(e, i = Li.workingColorSpace) {
    return Li.fromWorkingColorSpace(dr.copy(this), i), e.r = dr.r, e.g = dr.g, e.b = dr.b, e;
  }
  getStyle(e = ct) {
    Li.fromWorkingColorSpace(dr.copy(this), e);
    const i = dr.r, n = dr.g, s = dr.b;
    return e !== ct ? `color(${e} ${i.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(i * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
  }
  offsetHSL(e, i, n) {
    return this.getHSL(Va), this.setHSL(Va.h + e, Va.s + i, Va.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, i) {
    return this.r = e.r + i.r, this.g = e.g + i.g, this.b = e.b + i.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, i) {
    return this.r += (e.r - this.r) * i, this.g += (e.g - this.g) * i, this.b += (e.b - this.b) * i, this;
  }
  lerpColors(e, i, n) {
    return this.r = e.r + (i.r - e.r) * n, this.g = e.g + (i.g - e.g) * n, this.b = e.b + (i.b - e.b) * n, this;
  }
  lerpHSL(e, i) {
    this.getHSL(Va), e.getHSL(ef);
    const n = td(Va.h, ef.h, i), s = td(Va.s, ef.s, i), a = td(Va.l, ef.l, i);
    return this.setHSL(n, s, a), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const i = this.r, n = this.g, s = this.b, a = e.elements;
    return this.r = a[0] * i + a[3] * n + a[6] * s, this.g = a[1] * i + a[4] * n + a[7] * s, this.b = a[2] * i + a[5] * n + a[8] * s, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, i = 0) {
    return this.r = e[i], this.g = e[i + 1], this.b = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.r, e[i + 1] = this.g, e[i + 2] = this.b, e;
  }
  fromBufferAttribute(e, i) {
    return this.r = e.getX(i), this.g = e.getY(i), this.b = e.getZ(i), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const dr = /* @__PURE__ */ new Yt();
Yt.NAMES = sP;
let z7 = 0;
class Hr extends Bc {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(e) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: z7++ }), this.uuid = ma(), this.name = "", this.blending = co, this.side = bc, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Pm, this.blendDst = Im, this.blendEquation = eo, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Yt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Om, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = mx, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Go, this.stencilZFail = Go, this.stencilZPass = Go, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const i in e) {
        const n = e[i];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${i}' has value of undefined.`);
          continue;
        }
        const s = this[i];
        if (s === void 0) {
          console.warn(`THREE.Material: '${i}' is not a property of THREE.${this.type}.`);
          continue;
        }
        s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[i] = n;
      }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    i && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== co && (n.blending = this.blending), this.side !== bc && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Pm && (n.blendSrc = this.blendSrc), this.blendDst !== Im && (n.blendDst = this.blendDst), this.blendEquation !== eo && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== Om && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== mx && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Go && (n.stencilFail = this.stencilFail), this.stencilZFail !== Go && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Go && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function s(a) {
      const o = [];
      for (const l in a) {
        const u = a[l];
        delete u.metadata, o.push(u);
      }
      return o;
    }
    if (i) {
      const a = s(e.textures), o = s(e.images);
      a.length > 0 && (n.textures = a), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const i = e.clippingPlanes;
    let n = null;
    if (i !== null) {
      const s = i.length;
      n = new Array(s);
      for (let a = 0; a !== s; ++a)
        n[a] = i[a].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class Ng extends Hr {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Yt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qn(), this.combine = Rg, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const ta = /* @__PURE__ */ j7();
function j7() {
  const r = new ArrayBuffer(4), e = new Float32Array(r), i = new Uint32Array(r), n = new Uint32Array(512), s = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    const c = u - 127;
    c < -27 ? (n[u] = 0, n[u | 256] = 32768, s[u] = 24, s[u | 256] = 24) : c < -14 ? (n[u] = 1024 >> -c - 14, n[u | 256] = 1024 >> -c - 14 | 32768, s[u] = -c - 1, s[u | 256] = -c - 1) : c <= 15 ? (n[u] = c + 15 << 10, n[u | 256] = c + 15 << 10 | 32768, s[u] = 13, s[u | 256] = 13) : c < 128 ? (n[u] = 31744, n[u | 256] = 64512, s[u] = 24, s[u | 256] = 24) : (n[u] = 31744, n[u | 256] = 64512, s[u] = 13, s[u | 256] = 13);
  }
  const a = new Uint32Array(2048), o = new Uint32Array(64), l = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let c = u << 13, h = 0;
    for (; !(c & 8388608); )
      c <<= 1, h -= 8388608;
    c &= -8388609, h += 947912704, a[u] = c | h;
  }
  for (let u = 1024; u < 2048; ++u)
    a[u] = 939524096 + (u - 1024 << 13);
  for (let u = 1; u < 31; ++u)
    o[u] = u << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let u = 33; u < 63; ++u)
    o[u] = 2147483648 + (u - 32 << 23);
  o[63] = 3347054592;
  for (let u = 1; u < 64; ++u)
    u !== 32 && (l[u] = 1024);
  return {
    floatView: e,
    uint32View: i,
    baseTable: n,
    shiftTable: s,
    mantissaTable: a,
    exponentTable: o,
    offsetTable: l
  };
}
function Jr(r) {
  Math.abs(r) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), r = tr(r, -65504, 65504), ta.floatView[0] = r;
  const e = ta.uint32View[0], i = e >> 23 & 511;
  return ta.baseTable[i] + ((e & 8388607) >> ta.shiftTable[i]);
}
function tf(r) {
  const e = r >> 10;
  return ta.uint32View[0] = ta.mantissaTable[ta.offsetTable[e] + (r & 1023)] + ta.exponentTable[e], ta.floatView[0];
}
const Ii = /* @__PURE__ */ new oe(), rf = /* @__PURE__ */ new jt();
class Tn {
  constructor(e, i, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = i, this.count = e !== void 0 ? e.length / i : 0, this.normalized = n, this.usage = Um, this.updateRanges = [], this.gpuType = on, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, i) {
    this.updateRanges.push({ start: e, count: i });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, i, n) {
    e *= this.itemSize, n *= i.itemSize;
    for (let s = 0, a = this.itemSize; s < a; s++)
      this.array[e + s] = i.array[n + s];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let i = 0, n = this.count; i < n; i++)
        rf.fromBufferAttribute(this, i), rf.applyMatrix3(e), this.setXY(i, rf.x, rf.y);
    else if (this.itemSize === 3)
      for (let i = 0, n = this.count; i < n; i++)
        Ii.fromBufferAttribute(this, i), Ii.applyMatrix3(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Ii.fromBufferAttribute(this, i), Ii.applyMatrix4(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Ii.fromBufferAttribute(this, i), Ii.applyNormalMatrix(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Ii.fromBufferAttribute(this, i), Ii.transformDirection(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  set(e, i = 0) {
    return this.array.set(e, i), this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.itemSize + i];
    return this.normalized && (n = Mr(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = wt(n, this.array)), this.array[e * this.itemSize + i] = n, this;
  }
  getX(e) {
    let i = this.array[e * this.itemSize];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setX(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize] = i, this;
  }
  getY(e) {
    let i = this.array[e * this.itemSize + 1];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setY(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 1] = i, this;
  }
  getZ(e) {
    let i = this.array[e * this.itemSize + 2];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setZ(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 2] = i, this;
  }
  getW(e) {
    let i = this.array[e * this.itemSize + 3];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setW(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 3] = i, this;
  }
  setXY(e, i, n) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array), a = wt(a, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this.array[e + 2] = s, this.array[e + 3] = a, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Um && (e.usage = this.usage), e;
  }
}
class aP extends Tn {
  constructor(e, i, n) {
    super(new Uint16Array(e), i, n);
  }
}
class oP extends Tn {
  constructor(e, i, n) {
    super(new Uint32Array(e), i, n);
  }
}
class lP extends Tn {
  constructor(e, i, n) {
    super(new Uint16Array(e), i, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let i = tf(this.array[e * this.itemSize]);
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setX(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize] = Jr(i), this;
  }
  getY(e) {
    let i = tf(this.array[e * this.itemSize + 1]);
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setY(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 1] = Jr(i), this;
  }
  getZ(e) {
    let i = tf(this.array[e * this.itemSize + 2]);
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setZ(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 2] = Jr(i), this;
  }
  getW(e) {
    let i = tf(this.array[e * this.itemSize + 3]);
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setW(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 3] = Jr(i), this;
  }
  setXY(e, i, n) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array)), this.array[e + 0] = Jr(i), this.array[e + 1] = Jr(n), this;
  }
  setXYZ(e, i, n, s) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array)), this.array[e + 0] = Jr(i), this.array[e + 1] = Jr(n), this.array[e + 2] = Jr(s), this;
  }
  setXYZW(e, i, n, s, a) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array), a = wt(a, this.array)), this.array[e + 0] = Jr(i), this.array[e + 1] = Jr(n), this.array[e + 2] = Jr(s), this.array[e + 3] = Jr(a), this;
  }
}
class ya extends Tn {
  constructor(e, i, n) {
    super(new Float32Array(e), i, n);
  }
}
let V7 = 0;
const pn = /* @__PURE__ */ new gi(), Iv = /* @__PURE__ */ new Zi(), gu = /* @__PURE__ */ new oe(), en = /* @__PURE__ */ new Kd(), vh = /* @__PURE__ */ new Kd(), Xi = /* @__PURE__ */ new oe();
class Il extends Bc {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: V7++ }), this.uuid = ma(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (S7(e) ? oP : aP)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, i) {
    return this.attributes[e] = i, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, i, n = 0) {
    this.groups.push({
      start: e,
      count: i,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, i) {
    this.drawRange.start = e, this.drawRange.count = i;
  }
  applyMatrix4(e) {
    const i = this.attributes.position;
    i !== void 0 && (i.applyMatrix4(e), i.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const a = new Xr().getNormalMatrix(e);
      n.applyNormalMatrix(a), n.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return pn.makeRotationFromQuaternion(e), this.applyMatrix4(pn), this;
  }
  rotateX(e) {
    return pn.makeRotationX(e), this.applyMatrix4(pn), this;
  }
  rotateY(e) {
    return pn.makeRotationY(e), this.applyMatrix4(pn), this;
  }
  rotateZ(e) {
    return pn.makeRotationZ(e), this.applyMatrix4(pn), this;
  }
  translate(e, i, n) {
    return pn.makeTranslation(e, i, n), this.applyMatrix4(pn), this;
  }
  scale(e, i, n) {
    return pn.makeScale(e, i, n), this.applyMatrix4(pn), this;
  }
  lookAt(e) {
    return Iv.lookAt(e), Iv.updateMatrix(), this.applyMatrix4(Iv.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(gu).negate(), this.translate(gu.x, gu.y, gu.z), this;
  }
  setFromPoints(e) {
    const i = this.getAttribute("position");
    if (i === void 0) {
      const n = [];
      for (let s = 0, a = e.length; s < a; s++) {
        const o = e[s];
        n.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new ya(n, 3));
    } else {
      for (let n = 0, s = i.count; n < s; n++) {
        const a = e[n];
        i.setXYZ(n, a.x, a.y, a.z || 0);
      }
      e.length > i.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), i.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Kd());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new oe(-1 / 0, -1 / 0, -1 / 0),
        new oe(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), i)
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n];
          en.setFromBufferAttribute(a), this.morphTargetsRelative ? (Xi.addVectors(this.boundingBox.min, en.min), this.boundingBox.expandByPoint(Xi), Xi.addVectors(this.boundingBox.max, en.max), this.boundingBox.expandByPoint(Xi)) : (this.boundingBox.expandByPoint(en.min), this.boundingBox.expandByPoint(en.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new uT());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new oe(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (en.setFromBufferAttribute(e), i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a];
          vh.setFromBufferAttribute(l), this.morphTargetsRelative ? (Xi.addVectors(en.min, vh.min), en.expandByPoint(Xi), Xi.addVectors(en.max, vh.max), en.expandByPoint(Xi)) : (en.expandByPoint(vh.min), en.expandByPoint(vh.max));
        }
      en.getCenter(n);
      let s = 0;
      for (let a = 0, o = e.count; a < o; a++)
        Xi.fromBufferAttribute(e, a), s = Math.max(s, n.distanceToSquared(Xi));
      if (i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a], u = this.morphTargetsRelative;
          for (let c = 0, h = l.count; c < h; c++)
            Xi.fromBufferAttribute(l, c), u && (gu.fromBufferAttribute(e, c), Xi.add(gu)), s = Math.max(s, n.distanceToSquared(Xi));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, i = this.attributes;
    if (e === null || i.position === void 0 || i.normal === void 0 || i.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = i.position, s = i.normal, a = i.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Tn(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"), l = [], u = [];
    for (let A = 0; A < n.count; A++)
      l[A] = new oe(), u[A] = new oe();
    const c = new oe(), h = new oe(), d = new oe(), p = new jt(), f = new jt(), m = new jt(), v = new oe(), y = new oe();
    function g(A, E, M) {
      c.fromBufferAttribute(n, A), h.fromBufferAttribute(n, E), d.fromBufferAttribute(n, M), p.fromBufferAttribute(a, A), f.fromBufferAttribute(a, E), m.fromBufferAttribute(a, M), h.sub(c), d.sub(c), f.sub(p), m.sub(p);
      const N = 1 / (f.x * m.y - m.x * f.y);
      isFinite(N) && (v.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(N), y.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(N), l[A].add(v), l[E].add(v), l[M].add(v), u[A].add(y), u[E].add(y), u[M].add(y));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{
      start: 0,
      count: e.count
    }]);
    for (let A = 0, E = _.length; A < E; ++A) {
      const M = _[A], N = M.start, k = M.count;
      for (let U = N, C = N + k; U < C; U += 3)
        g(
          e.getX(U + 0),
          e.getX(U + 1),
          e.getX(U + 2)
        );
    }
    const x = new oe(), b = new oe(), T = new oe(), S = new oe();
    function w(A) {
      T.fromBufferAttribute(s, A), S.copy(T);
      const E = l[A];
      x.copy(E), x.sub(T.multiplyScalar(T.dot(E))).normalize(), b.crossVectors(S, E);
      const M = b.dot(u[A]) < 0 ? -1 : 1;
      o.setXYZW(A, x.x, x.y, x.z, M);
    }
    for (let A = 0, E = _.length; A < E; ++A) {
      const M = _[A], N = M.start, k = M.count;
      for (let U = N, C = N + k; U < C; U += 3)
        w(e.getX(U + 0)), w(e.getX(U + 1)), w(e.getX(U + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, i = this.getAttribute("position");
    if (i !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Tn(new Float32Array(i.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let p = 0, f = n.count; p < f; p++)
          n.setXYZ(p, 0, 0, 0);
      const s = new oe(), a = new oe(), o = new oe(), l = new oe(), u = new oe(), c = new oe(), h = new oe(), d = new oe();
      if (e)
        for (let p = 0, f = e.count; p < f; p += 3) {
          const m = e.getX(p + 0), v = e.getX(p + 1), y = e.getX(p + 2);
          s.fromBufferAttribute(i, m), a.fromBufferAttribute(i, v), o.fromBufferAttribute(i, y), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, v), c.fromBufferAttribute(n, y), l.add(h), u.add(h), c.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(v, u.x, u.y, u.z), n.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let p = 0, f = i.count; p < f; p += 3)
          s.fromBufferAttribute(i, p + 0), a.fromBufferAttribute(i, p + 1), o.fromBufferAttribute(i, p + 2), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), n.setXYZ(p + 0, h.x, h.y, h.z), n.setXYZ(p + 1, h.x, h.y, h.z), n.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let i = 0, n = e.count; i < n; i++)
      Xi.fromBufferAttribute(e, i), Xi.normalize(), e.setXYZ(i, Xi.x, Xi.y, Xi.z);
  }
  toNonIndexed() {
    function e(l, u) {
      const c = l.array, h = l.itemSize, d = l.normalized, p = new c.constructor(u.length * h);
      let f = 0, m = 0;
      for (let v = 0, y = u.length; v < y; v++) {
        l.isInterleavedBufferAttribute ? f = u[v] * l.data.stride + l.offset : f = u[v] * h;
        for (let g = 0; g < h; g++)
          p[m++] = c[f++];
      }
      return new Tn(p, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const i = new Il(), n = this.index.array, s = this.attributes;
    for (const l in s) {
      const u = s[l], c = e(u, n);
      i.setAttribute(l, c);
    }
    const a = this.morphAttributes;
    for (const l in a) {
      const u = [], c = a[l];
      for (let h = 0, d = c.length; h < d; h++) {
        const p = c[h], f = e(p, n);
        u.push(f);
      }
      i.morphAttributes[l] = u;
    }
    i.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const c = o[l];
      i.addGroup(c.start, c.count, c.materialIndex);
    }
    return i;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const u = this.parameters;
      for (const c in u)
        u[c] !== void 0 && (e[c] = u[c]);
      return e;
    }
    e.data = { attributes: {} };
    const i = this.index;
    i !== null && (e.data.index = {
      type: i.array.constructor.name,
      array: Array.prototype.slice.call(i.array)
    });
    const n = this.attributes;
    for (const u in n) {
      const c = n[u];
      e.data.attributes[u] = c.toJSON(e.data);
    }
    const s = {};
    let a = !1;
    for (const u in this.morphAttributes) {
      const c = this.morphAttributes[u], h = [];
      for (let d = 0, p = c.length; d < p; d++) {
        const f = c[d];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (s[u] = h, a = !0);
    }
    a && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const i = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(i));
    const s = e.attributes;
    for (const c in s) {
      const h = s[c];
      this.setAttribute(c, h.clone(i));
    }
    const a = e.morphAttributes;
    for (const c in a) {
      const h = [], d = a[c];
      for (let p = 0, f = d.length; p < f; p++)
        h.push(d[p].clone(i));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = e.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const WE = /* @__PURE__ */ new gi(), ko = /* @__PURE__ */ new I7(), nf = /* @__PURE__ */ new uT(), qE = /* @__PURE__ */ new oe(), sf = /* @__PURE__ */ new oe(), af = /* @__PURE__ */ new oe(), of = /* @__PURE__ */ new oe(), Ov = /* @__PURE__ */ new oe(), lf = /* @__PURE__ */ new oe(), XE = /* @__PURE__ */ new oe(), uf = /* @__PURE__ */ new oe();
class El extends Zi {
  constructor(e = new Il(), i = new Ng()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = i, this.updateMorphTargets();
  }
  copy(e, i) {
    return super.copy(e, i), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, i = Object.keys(e);
    if (i.length > 0) {
      const n = e[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
        }
      }
    }
  }
  getVertexPosition(e, i) {
    const n = this.geometry, s = n.attributes.position, a = n.morphAttributes.position, o = n.morphTargetsRelative;
    i.fromBufferAttribute(s, e);
    const l = this.morphTargetInfluences;
    if (a && l) {
      lf.set(0, 0, 0);
      for (let u = 0, c = a.length; u < c; u++) {
        const h = l[u], d = a[u];
        h !== 0 && (Ov.fromBufferAttribute(d, e), o ? lf.addScaledVector(Ov, h) : lf.addScaledVector(Ov.sub(i), h));
      }
      i.add(lf);
    }
    return i;
  }
  raycast(e, i) {
    const n = this.geometry, s = this.material, a = this.matrixWorld;
    s !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), nf.copy(n.boundingSphere), nf.applyMatrix4(a), ko.copy(e.ray).recast(e.near), !(nf.containsPoint(ko.origin) === !1 && (ko.intersectSphere(nf, qE) === null || ko.origin.distanceToSquared(qE) > (e.far - e.near) ** 2)) && (WE.copy(a).invert(), ko.copy(e.ray).applyMatrix4(WE), !(n.boundingBox !== null && ko.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, i, ko)));
  }
  _computeIntersections(e, i, n) {
    let s;
    const a = this.geometry, o = this.material, l = a.index, u = a.attributes.position, c = a.attributes.uv, h = a.attributes.uv1, d = a.attributes.normal, p = a.groups, f = a.drawRange;
    if (l !== null)
      if (Array.isArray(o))
        for (let m = 0, v = p.length; m < v; m++) {
          const y = p[m], g = o[y.materialIndex], _ = Math.max(y.start, f.start), x = Math.min(l.count, Math.min(y.start + y.count, f.start + f.count));
          for (let b = _, T = x; b < T; b += 3) {
            const S = l.getX(b), w = l.getX(b + 1), A = l.getX(b + 2);
            s = cf(this, g, e, n, c, h, d, S, w, A), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = y.materialIndex, i.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), v = Math.min(l.count, f.start + f.count);
        for (let y = m, g = v; y < g; y += 3) {
          const _ = l.getX(y), x = l.getX(y + 1), b = l.getX(y + 2);
          s = cf(this, o, e, n, c, h, d, _, x, b), s && (s.faceIndex = Math.floor(y / 3), i.push(s));
        }
      }
    else if (u !== void 0)
      if (Array.isArray(o))
        for (let m = 0, v = p.length; m < v; m++) {
          const y = p[m], g = o[y.materialIndex], _ = Math.max(y.start, f.start), x = Math.min(u.count, Math.min(y.start + y.count, f.start + f.count));
          for (let b = _, T = x; b < T; b += 3) {
            const S = b, w = b + 1, A = b + 2;
            s = cf(this, g, e, n, c, h, d, S, w, A), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = y.materialIndex, i.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), v = Math.min(u.count, f.start + f.count);
        for (let y = m, g = v; y < g; y += 3) {
          const _ = y, x = y + 1, b = y + 2;
          s = cf(this, o, e, n, c, h, d, _, x, b), s && (s.faceIndex = Math.floor(y / 3), i.push(s));
        }
      }
  }
}
function G7(r, e, i, n, s, a, o, l) {
  let u;
  if (e.side === Zn ? u = n.intersectTriangle(o, a, s, !0, l) : u = n.intersectTriangle(s, a, o, e.side === bc, l), u === null) return null;
  uf.copy(l), uf.applyMatrix4(r.matrixWorld);
  const c = i.ray.origin.distanceTo(uf);
  return c < i.near || c > i.far ? null : {
    distance: c,
    point: uf.clone(),
    object: r
  };
}
function cf(r, e, i, n, s, a, o, l, u, c) {
  r.getVertexPosition(l, sf), r.getVertexPosition(u, af), r.getVertexPosition(c, of);
  const h = G7(r, e, i, n, sf, af, of, XE);
  if (h) {
    const d = new oe();
    qn.getBarycoord(XE, sf, af, of, d), s && (h.uv = qn.getInterpolatedAttribute(s, l, u, c, d, new jt())), a && (h.uv1 = qn.getInterpolatedAttribute(a, l, u, c, d, new jt())), o && (h.normal = qn.getInterpolatedAttribute(o, l, u, c, d, new oe()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const p = {
      a: l,
      b: u,
      c,
      normal: new oe(),
      materialIndex: 0
    };
    qn.getNormal(sf, af, of, p.normal), h.face = p, h.barycoord = d;
  }
  return h;
}
class Zd extends Il {
  constructor(e = 1, i = 1, n = 1, s = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: i,
      depth: n,
      widthSegments: s,
      heightSegments: a,
      depthSegments: o
    };
    const l = this;
    s = Math.floor(s), a = Math.floor(a), o = Math.floor(o);
    const u = [], c = [], h = [], d = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, n, i, e, o, a, 0), m("z", "y", "x", 1, -1, n, i, -e, o, a, 1), m("x", "z", "y", 1, 1, e, n, i, s, o, 2), m("x", "z", "y", 1, -1, e, n, -i, s, o, 3), m("x", "y", "z", 1, -1, e, i, n, s, a, 4), m("x", "y", "z", -1, -1, e, i, -n, s, a, 5), this.setIndex(u), this.setAttribute("position", new ya(c, 3)), this.setAttribute("normal", new ya(h, 3)), this.setAttribute("uv", new ya(d, 2));
    function m(v, y, g, _, x, b, T, S, w, A, E) {
      const M = b / w, N = T / A, k = b / 2, U = T / 2, C = S / 2, O = w + 1, D = A + 1;
      let H = 0, j = 0;
      const K = new oe();
      for (let L = 0; L < D; L++) {
        const B = L * N - U;
        for (let Q = 0; Q < O; Q++) {
          const W = Q * M - k;
          K[v] = W * _, K[y] = B * x, K[g] = C, c.push(K.x, K.y, K.z), K[v] = 0, K[y] = 0, K[g] = S > 0 ? 1 : -1, h.push(K.x, K.y, K.z), d.push(Q / w), d.push(1 - L / A), H += 1;
        }
      }
      for (let L = 0; L < A; L++)
        for (let B = 0; B < w; B++) {
          const Q = p + B + O * L, W = p + B + O * (L + 1), z = p + (B + 1) + O * (L + 1), X = p + (B + 1) + O * L;
          u.push(Q, W, X), u.push(W, z, X), j += 6;
        }
      l.addGroup(f, j, E), f += j, p += H;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Zd(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function uP(r) {
  const e = {};
  for (const i in r) {
    e[i] = {};
    for (const n in r[i]) {
      const s = r[i][n];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][n] = null) : e[i][n] = s.clone() : Array.isArray(s) ? e[i][n] = s.slice() : e[i][n] = s;
    }
  }
  return e;
}
function H7(r) {
  const e = [];
  for (let i = 0; i < r.length; i++)
    e.push(r[i].clone());
  return e;
}
var W7 = (
  /* glsl */
  `
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`
), q7 = (
  /* glsl */
  `
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`
);
class X7 extends Hr {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = W7, this.fragmentShader = q7, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = uP(e.uniforms), this.uniformsGroups = H7(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    i.glslVersion = this.glslVersion, i.uniforms = {};
    for (const s in this.uniforms) {
      const a = this.uniforms[s].value;
      a && a.isTexture ? i.uniforms[s] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? i.uniforms[s] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? i.uniforms[s] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? i.uniforms[s] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? i.uniforms[s] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? i.uniforms[s] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? i.uniforms[s] = {
        type: "m4",
        value: a.toArray()
      } : i.uniforms[s] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (i.defines = this.defines), i.vertexShader = this.vertexShader, i.fragmentShader = this.fragmentShader, i.lights = this.lights, i.clipping = this.clipping;
    const n = {};
    for (const s in this.extensions)
      this.extensions[s] === !0 && (n[s] = !0);
    return Object.keys(n).length > 0 && (i.extensions = n), i;
  }
}
class cP extends Zi {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new gi(), this.projectionMatrix = new gi(), this.projectionMatrixInverse = new gi(), this.coordinateSystem = Yn;
  }
  copy(e, i) {
    return super.copy(e, i), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, i) {
    super.updateWorldMatrix(e, i), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ga = /* @__PURE__ */ new oe(), $E = /* @__PURE__ */ new jt(), YE = /* @__PURE__ */ new jt();
class Ys extends cP {
  constructor(e = 50, i = 1, n = 0.1, s = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = s, this.focus = 10, this.aspect = i, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, i) {
    return super.copy(e, i), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const i = 0.5 * this.getFilmHeight() / e;
    this.fov = vd * 2 * Math.atan(i), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(ed * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return vd * 2 * Math.atan(
      Math.tan(ed * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, i, n) {
    Ga.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Ga.x, Ga.y).multiplyScalar(-e / Ga.z), Ga.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Ga.x, Ga.y).multiplyScalar(-e / Ga.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, i) {
    return this.getViewBounds(e, $E, YE), i.subVectors(YE, $E);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, i, n, s, a, o) {
    this.aspect = e / i, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = i, this.view.offsetX = n, this.view.offsetY = s, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let i = e * Math.tan(ed * 0.5 * this.fov) / this.zoom, n = 2 * i, s = this.aspect * n, a = -0.5 * s;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = o.fullWidth, c = o.fullHeight;
      a += o.offsetX * s / u, i -= o.offsetY * n / c, s *= o.width / u, n *= o.height / c;
    }
    const l = this.filmOffset;
    l !== 0 && (a += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + s, i, i - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.fov = this.fov, i.object.zoom = this.zoom, i.object.near = this.near, i.object.far = this.far, i.object.focus = this.focus, i.object.aspect = this.aspect, this.view !== null && (i.object.view = Object.assign({}, this.view)), i.object.filmGauge = this.filmGauge, i.object.filmOffset = this.filmOffset, i;
  }
}
const yu = -90, vu = 1;
class hP extends Zi {
  constructor(e, i, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const s = new Ys(yu, vu, e, i);
    s.layers = this.layers, this.add(s);
    const a = new Ys(yu, vu, e, i);
    a.layers = this.layers, this.add(a);
    const o = new Ys(yu, vu, e, i);
    o.layers = this.layers, this.add(o);
    const l = new Ys(yu, vu, e, i);
    l.layers = this.layers, this.add(l);
    const u = new Ys(yu, vu, e, i);
    u.layers = this.layers, this.add(u);
    const c = new Ys(yu, vu, e, i);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, i = this.children.concat(), [n, s, a, o, l, u] = i;
    for (const c of i) this.remove(c);
    if (e === Yn)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), a.up.set(0, 0, -1), a.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), u.up.set(0, 1, 0), u.lookAt(0, 0, -1);
    else if (e === wl)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), a.up.set(0, 0, 1), a.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), u.up.set(0, -1, 0), u.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const c of i)
      this.add(c), c.updateMatrixWorld();
  }
  update(e, i) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: s } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [a, o, l, u, c, h] = this.children, d = e.getRenderTarget(), p = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = !1;
    const v = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, s), e.render(i, a), e.setRenderTarget(n, 1, s), e.render(i, o), e.setRenderTarget(n, 2, s), e.render(i, l), e.setRenderTarget(n, 3, s), e.render(i, u), e.setRenderTarget(n, 4, s), e.render(i, c), n.texture.generateMipmaps = v, e.setRenderTarget(n, 5, s), e.render(i, h), e.setRenderTarget(d, p, f), e.xr.enabled = m, n.texture.needsPMREMUpdate = !0;
  }
}
class cT extends Cr {
  constructor(e, i, n, s, a, o, l, u, c, h) {
    e = e !== void 0 ? e : [], i = i !== void 0 ? i : Tl, super(e, i, n, s, a, o, l, u, c, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class $7 extends R7 {
  constructor(e = 1, i = {}) {
    super(e, e, i), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, s = [n, n, n, n, n, n];
    this.texture = new cT(s, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : ln;
  }
  fromEquirectangularTexture(e, i) {
    this.texture.type = i.type, this.texture.colorSpace = i.colorSpace, this.texture.generateMipmaps = i.generateMipmaps, this.texture.minFilter = i.minFilter, this.texture.magFilter = i.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, s = new Zd(5, 5, 5), a = new X7({
      name: "CubemapFromEquirect",
      uniforms: uP(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: Zn,
      blending: xc
    });
    a.uniforms.tEquirect.value = i;
    const o = new El(s, a), l = i.minFilter;
    return i.minFilter === pa && (i.minFilter = ln), new hP(1, 10, this).update(e, o), i.minFilter = l, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, i, n, s) {
    const a = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(i, n, s);
    e.setRenderTarget(a);
  }
}
class dP extends Zi {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Qn(), this.environmentIntensity = 1, this.environmentRotation = new Qn(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, i) {
    return super.copy(e, i), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return this.fog !== null && (i.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (i.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (i.object.backgroundIntensity = this.backgroundIntensity), i.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (i.object.environmentIntensity = this.environmentIntensity), i.object.environmentRotation = this.environmentRotation.toArray(), i;
  }
}
class pP {
  constructor(e, i) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = i, this.count = e !== void 0 ? e.length / i : 0, this.usage = Um, this.updateRanges = [], this.version = 0, this.uuid = ma();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, i) {
    this.updateRanges.push({ start: e, count: i });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, i, n) {
    e *= this.stride, n *= i.stride;
    for (let s = 0, a = this.stride; s < a; s++)
      this.array[e + s] = i.array[n + s];
    return this;
  }
  set(e, i = 0) {
    return this.array.set(e, i), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ma()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const i = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(i, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ma()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const xr = /* @__PURE__ */ new oe();
class hT {
  constructor(e, i, n, s = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = i, this.offset = n, this.normalized = s;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.data.count; i < n; i++)
      xr.fromBufferAttribute(this, i), xr.applyMatrix4(e), this.setXYZ(i, xr.x, xr.y, xr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      xr.fromBufferAttribute(this, i), xr.applyNormalMatrix(e), this.setXYZ(i, xr.x, xr.y, xr.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      xr.fromBufferAttribute(this, i), xr.transformDirection(e), this.setXYZ(i, xr.x, xr.y, xr.z);
    return this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.data.stride + this.offset + i];
    return this.normalized && (n = Mr(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = wt(n, this.array)), this.data.array[e * this.data.stride + this.offset + i] = n, this;
  }
  setX(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.data.array[e * this.data.stride + this.offset] = i, this;
  }
  setY(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = i, this;
  }
  setZ(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = i, this;
  }
  setW(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = i, this;
  }
  getX(e) {
    let i = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  getY(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  getZ(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  getW(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setXY(e, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = wt(i, this.array), n = wt(n, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array), a = wt(a, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = a, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return new Tn(new this.array.constructor(i), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new hT(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: i,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class fP extends Hr {
  static get type() {
    return "SpriteMaterial";
  }
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.color = new Yt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
class Y7 extends Cr {
  constructor(e = null, i = 1, n = 1, s, a, o, l, u, c = gr, h = gr, d, p) {
    super(null, o, l, u, c, h, s, a, d, p), this.isDataTexture = !0, this.image = { data: e, width: i, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class K7 extends Tn {
  constructor(e, i, n, s = 1) {
    super(e, i, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const Dv = /* @__PURE__ */ new oe(), Z7 = /* @__PURE__ */ new oe(), Q7 = /* @__PURE__ */ new Xr();
class Za {
  constructor(e = new oe(1, 0, 0), i = 0) {
    this.isPlane = !0, this.normal = e, this.constant = i;
  }
  set(e, i) {
    return this.normal.copy(e), this.constant = i, this;
  }
  setComponents(e, i, n, s) {
    return this.normal.set(e, i, n), this.constant = s, this;
  }
  setFromNormalAndCoplanarPoint(e, i) {
    return this.normal.copy(e), this.constant = -i.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, i, n) {
    const s = Dv.subVectors(n, i).cross(Z7.subVectors(e, i)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, i) {
    return i.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, i) {
    const n = e.delta(Dv), s = this.normal.dot(n);
    if (s === 0)
      return this.distanceToPoint(e.start) === 0 ? i.copy(e.start) : null;
    const a = -(e.start.dot(this.normal) + this.constant) / s;
    return a < 0 || a > 1 ? null : i.copy(e.start).addScaledVector(n, a);
  }
  intersectsLine(e) {
    const i = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return i < 0 && n > 0 || n < 0 && i > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, i) {
    const n = i || Q7.getNormalMatrix(e), s = this.coplanarPoint(Dv).applyMatrix4(e), a = this.normal.applyMatrix3(n).normalize();
    return this.constant = -s.dot(a), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Fo = /* @__PURE__ */ new uT(), hf = /* @__PURE__ */ new oe();
class mP {
  constructor(e = new Za(), i = new Za(), n = new Za(), s = new Za(), a = new Za(), o = new Za()) {
    this.planes = [e, i, n, s, a, o];
  }
  set(e, i, n, s, a, o) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(i), l[2].copy(n), l[3].copy(s), l[4].copy(a), l[5].copy(o), this;
  }
  copy(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++)
      i[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, i = Yn) {
    const n = this.planes, s = e.elements, a = s[0], o = s[1], l = s[2], u = s[3], c = s[4], h = s[5], d = s[6], p = s[7], f = s[8], m = s[9], v = s[10], y = s[11], g = s[12], _ = s[13], x = s[14], b = s[15];
    if (n[0].setComponents(u - a, p - c, y - f, b - g).normalize(), n[1].setComponents(u + a, p + c, y + f, b + g).normalize(), n[2].setComponents(u + o, p + h, y + m, b + _).normalize(), n[3].setComponents(u - o, p - h, y - m, b - _).normalize(), n[4].setComponents(u - l, p - d, y - v, b - x).normalize(), i === Yn)
      n[5].setComponents(u + l, p + d, y + v, b + x).normalize();
    else if (i === wl)
      n[5].setComponents(l, d, v, x).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + i);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Fo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const i = e.geometry;
      i.boundingSphere === null && i.computeBoundingSphere(), Fo.copy(i.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Fo);
  }
  intersectsSprite(e) {
    return Fo.center.set(0, 0, 0), Fo.radius = 0.7071067811865476, Fo.applyMatrix4(e.matrixWorld), this.intersectsSphere(Fo);
  }
  intersectsSphere(e) {
    const i = this.planes, n = e.center, s = -e.radius;
    for (let a = 0; a < 6; a++)
      if (i[a].distanceToPoint(n) < s)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++) {
      const s = i[n];
      if (hf.x = s.normal.x > 0 ? e.max.x : e.min.x, hf.y = s.normal.y > 0 ? e.max.y : e.min.y, hf.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(hf) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++)
      if (i[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class dT extends Hr {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.color = new Yt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
class gP extends Hr {
  static get type() {
    return "PointsMaterial";
  }
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.color = new Yt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
class J7 extends Cr {
  constructor(e, i) {
    super({ width: e, height: i }), this.isFramebufferTexture = !0, this.magFilter = gr, this.minFilter = gr, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class jc extends Cr {
  constructor(e, i, n, s, a, o, l, u, c, h = gl) {
    if (h !== gl && h !== Tc)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && h === gl && (n = er), n === void 0 && h === Tc && (n = $d), super(null, s, a, o, l, u, h, n, c), this.isDepthTexture = !0, this.image = { width: e, height: i }, this.magFilter = l !== void 0 ? l : gr, this.minFilter = u !== void 0 ? u : gr, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return this.compareFunction !== null && (i.compareFunction = this.compareFunction), i;
  }
}
class pT extends Il {
  constructor(e = 1, i = 32, n = 16, s = 0, a = Math.PI * 2, o = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: i,
      heightSegments: n,
      phiStart: s,
      phiLength: a,
      thetaStart: o,
      thetaLength: l
    }, i = Math.max(3, Math.floor(i)), n = Math.max(2, Math.floor(n));
    const u = Math.min(o + l, Math.PI);
    let c = 0;
    const h = [], d = new oe(), p = new oe(), f = [], m = [], v = [], y = [];
    for (let g = 0; g <= n; g++) {
      const _ = [], x = g / n;
      let b = 0;
      g === 0 && o === 0 ? b = 0.5 / i : g === n && u === Math.PI && (b = -0.5 / i);
      for (let T = 0; T <= i; T++) {
        const S = T / i;
        d.x = -e * Math.cos(s + S * a) * Math.sin(o + x * l), d.y = e * Math.cos(o + x * l), d.z = e * Math.sin(s + S * a) * Math.sin(o + x * l), m.push(d.x, d.y, d.z), p.copy(d).normalize(), v.push(p.x, p.y, p.z), y.push(S + b, 1 - x), _.push(c++);
      }
      h.push(_);
    }
    for (let g = 0; g < n; g++)
      for (let _ = 0; _ < i; _++) {
        const x = h[g][_ + 1], b = h[g][_], T = h[g + 1][_], S = h[g + 1][_ + 1];
        (g !== 0 || o > 0) && f.push(x, b, S), (g !== n - 1 || u < Math.PI) && f.push(b, T, S);
      }
    this.setIndex(f), this.setAttribute("position", new ya(m, 3)), this.setAttribute("normal", new ya(v, 3)), this.setAttribute("uv", new ya(y, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new pT(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class yP extends Hr {
  static get type() {
    return "ShadowMaterial";
  }
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.color = new Yt(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class fT extends Hr {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.color = new Yt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Yt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qn(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class vP extends fT {
  static get type() {
    return "MeshPhysicalMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new jt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return tr(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(i) {
        this.ior = (1 + 0.4 * i) / (1 - 0.4 * i);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Yt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Yt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Yt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class bP extends Hr {
  static get type() {
    return "MeshPhongMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.color = new Yt(16777215), this.specular = new Yt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Yt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qn(), this.combine = Rg, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class xP extends Hr {
  static get type() {
    return "MeshToonMaterial";
  }
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.color = new Yt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Yt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class _P extends Hr {
  static get type() {
    return "MeshNormalMaterial";
  }
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class TP extends Hr {
  static get type() {
    return "MeshLambertMaterial";
  }
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.color = new Yt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Yt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qn(), this.combine = Rg, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class SP extends Hr {
  static get type() {
    return "MeshMatcapMaterial";
  }
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.color = new Yt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class wP extends dT {
  static get type() {
    return "LineDashedMaterial";
  }
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
class Ol extends Zi {
  constructor(e, i = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Yt(e), this.intensity = i;
  }
  dispose() {
  }
  copy(e, i) {
    return super.copy(e, i), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.color = this.color.getHex(), i.object.intensity = this.intensity, this.groundColor !== void 0 && (i.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (i.object.distance = this.distance), this.angle !== void 0 && (i.object.angle = this.angle), this.decay !== void 0 && (i.object.decay = this.decay), this.penumbra !== void 0 && (i.object.penumbra = this.penumbra), this.shadow !== void 0 && (i.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (i.object.target = this.target.uuid), i;
  }
}
class eW extends Ol {
  constructor(e, i, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Zi.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Yt(i);
  }
  copy(e, i) {
    return super.copy(e, i), this.groundColor.copy(e.groundColor), this;
  }
}
const Lv = /* @__PURE__ */ new gi(), KE = /* @__PURE__ */ new oe(), ZE = /* @__PURE__ */ new oe();
class mT {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new jt(512, 512), this.map = null, this.mapPass = null, this.matrix = new gi(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new mP(), this._frameExtents = new jt(1, 1), this._viewportCount = 1, this._viewports = [
      new $t(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const i = this.camera, n = this.matrix;
    KE.setFromMatrixPosition(e.matrixWorld), i.position.copy(KE), ZE.setFromMatrixPosition(e.target.matrixWorld), i.lookAt(ZE), i.updateMatrixWorld(), Lv.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Lv), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(Lv);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class tW extends mT {
  constructor() {
    super(new Ys(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const i = this.camera, n = vd * 2 * e.angle * this.focus, s = this.mapSize.width / this.mapSize.height, a = e.distance || i.far;
    (n !== i.fov || s !== i.aspect || a !== i.far) && (i.fov = n, i.aspect = s, i.far = a, i.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class EP extends Ol {
  constructor(e, i, n = 0, s = Math.PI / 3, a = 0, o = 2) {
    super(e, i), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Zi.DEFAULT_UP), this.updateMatrix(), this.target = new Zi(), this.distance = n, this.angle = s, this.penumbra = a, this.decay = o, this.map = null, this.shadow = new tW();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, i) {
    return super.copy(e, i), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const QE = /* @__PURE__ */ new gi(), bh = /* @__PURE__ */ new oe(), Uv = /* @__PURE__ */ new oe();
class iW extends mT {
  constructor() {
    super(new Ys(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new jt(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new $t(2, 1, 1, 1),
      // negative X
      new $t(0, 1, 1, 1),
      // positive Z
      new $t(3, 1, 1, 1),
      // negative Z
      new $t(1, 1, 1, 1),
      // positive Y
      new $t(3, 0, 1, 1),
      // negative Y
      new $t(1, 0, 1, 1)
    ], this._cubeDirections = [
      new oe(1, 0, 0),
      new oe(-1, 0, 0),
      new oe(0, 0, 1),
      new oe(0, 0, -1),
      new oe(0, 1, 0),
      new oe(0, -1, 0)
    ], this._cubeUps = [
      new oe(0, 1, 0),
      new oe(0, 1, 0),
      new oe(0, 1, 0),
      new oe(0, 1, 0),
      new oe(0, 0, 1),
      new oe(0, 0, -1)
    ];
  }
  updateMatrices(e, i = 0) {
    const n = this.camera, s = this.matrix, a = e.distance || n.far;
    a !== n.far && (n.far = a, n.updateProjectionMatrix()), bh.setFromMatrixPosition(e.matrixWorld), n.position.copy(bh), Uv.copy(n.position), Uv.add(this._cubeDirections[i]), n.up.copy(this._cubeUps[i]), n.lookAt(Uv), n.updateMatrixWorld(), s.makeTranslation(-bh.x, -bh.y, -bh.z), QE.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(QE);
  }
}
class rW extends Ol {
  constructor(e, i, n = 0, s = 2) {
    super(e, i), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = s, this.shadow = new iW();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, i) {
    return super.copy(e, i), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class gT extends cP {
  constructor(e = -1, i = 1, n = 1, s = -1, a = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = i, this.top = n, this.bottom = s, this.near = a, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, i) {
    return super.copy(e, i), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, i, n, s, a, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = i, this.view.offsetX = n, this.view.offsetY = s, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), i = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
    let a = n - e, o = n + e, l = s + i, u = s - i;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      a += c * this.view.offsetX, o = a + c * this.view.width, l -= h * this.view.offsetY, u = l - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(a, o, l, u, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.zoom = this.zoom, i.object.left = this.left, i.object.right = this.right, i.object.top = this.top, i.object.bottom = this.bottom, i.object.near = this.near, i.object.far = this.far, this.view !== null && (i.object.view = Object.assign({}, this.view)), i;
  }
}
class nW extends mT {
  constructor() {
    super(new gT(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class sW extends Ol {
  constructor(e, i) {
    super(e, i), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Zi.DEFAULT_UP), this.updateMatrix(), this.target = new Zi(), this.shadow = new nW();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class aW extends Ol {
  constructor(e, i) {
    super(e, i), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class oW extends Ol {
  constructor(e, i, n = 10, s = 10) {
    super(e, i), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = s;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.width = this.width, i.object.height = this.height, i;
  }
}
class lW {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new oe());
  }
  set(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].copy(e[i]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, i) {
    const n = e.x, s = e.y, a = e.z, o = this.coefficients;
    return i.copy(o[0]).multiplyScalar(0.282095), i.addScaledVector(o[1], 0.488603 * s), i.addScaledVector(o[2], 0.488603 * a), i.addScaledVector(o[3], 0.488603 * n), i.addScaledVector(o[4], 1.092548 * (n * s)), i.addScaledVector(o[5], 1.092548 * (s * a)), i.addScaledVector(o[6], 0.315392 * (3 * a * a - 1)), i.addScaledVector(o[7], 1.092548 * (n * a)), i.addScaledVector(o[8], 0.546274 * (n * n - s * s)), i;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, i) {
    const n = e.x, s = e.y, a = e.z, o = this.coefficients;
    return i.copy(o[0]).multiplyScalar(0.886227), i.addScaledVector(o[1], 2 * 0.511664 * s), i.addScaledVector(o[2], 2 * 0.511664 * a), i.addScaledVector(o[3], 2 * 0.511664 * n), i.addScaledVector(o[4], 2 * 0.429043 * n * s), i.addScaledVector(o[5], 2 * 0.429043 * s * a), i.addScaledVector(o[6], 0.743125 * a * a - 0.247708), i.addScaledVector(o[7], 2 * 0.429043 * n * a), i.addScaledVector(o[8], 0.429043 * (n * n - s * s)), i;
  }
  add(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].add(e.coefficients[i]);
    return this;
  }
  addScaledSH(e, i) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], i);
    return this;
  }
  scale(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].multiplyScalar(e);
    return this;
  }
  lerp(e, i) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], i);
    return this;
  }
  equals(e) {
    for (let i = 0; i < 9; i++)
      if (!this.coefficients[i].equals(e.coefficients[i]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, i = 0) {
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].fromArray(e, i + s * 3);
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].toArray(e, i + s * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, i) {
    const n = e.x, s = e.y, a = e.z;
    i[0] = 0.282095, i[1] = 0.488603 * s, i[2] = 0.488603 * a, i[3] = 0.488603 * n, i[4] = 1.092548 * n * s, i[5] = 1.092548 * s * a, i[6] = 0.315392 * (3 * a * a - 1), i[7] = 1.092548 * n * a, i[8] = 0.546274 * (n * n - s * s);
  }
}
class uW extends Ol {
  constructor(e = new lW(), i = 1) {
    super(void 0, i), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.sh = this.sh.toArray(), i;
  }
}
class cW extends pP {
  constructor(e, i, n = 1) {
    super(e, i), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const i = super.clone(e);
    return i.meshPerAttribute = this.meshPerAttribute, i;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.isInstancedInterleavedBuffer = !0, i.meshPerAttribute = this.meshPerAttribute, i;
  }
}
const hW = [
  "alphaMap",
  "alphaTest",
  "anisotropy",
  "anisotropyMap",
  "anisotropyRotation",
  "aoMap",
  "attenuationColor",
  "attenuationDistance",
  "bumpMap",
  "clearcoat",
  "clearcoatMap",
  "clearcoatNormalMap",
  "clearcoatNormalScale",
  "clearcoatRoughness",
  "color",
  "dispersion",
  "displacementMap",
  "emissive",
  "emissiveMap",
  "envMap",
  "gradientMap",
  "ior",
  "iridescence",
  "iridescenceIOR",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "lightMap",
  "map",
  "matcap",
  "metalness",
  "metalnessMap",
  "normalMap",
  "normalScale",
  "opacity",
  "roughness",
  "roughnessMap",
  "sheen",
  "sheenColor",
  "sheenColorMap",
  "sheenRoughnessMap",
  "shininess",
  "specular",
  "specularColor",
  "specularColorMap",
  "specularIntensity",
  "specularIntensityMap",
  "specularMap",
  "thickness",
  "transmission",
  "transmissionMap"
];
class dW {
  constructor(e) {
    this.renderObjects = /* @__PURE__ */ new WeakMap(), this.hasNode = this.containsNode(e), this.hasAnimation = e.object.isSkinnedMesh === !0, this.refreshUniforms = hW, this.renderId = 0;
  }
  firstInitialization(e) {
    return this.renderObjects.has(e) === !1 ? (this.getRenderObjectData(e), !0) : !1;
  }
  getRenderObjectData(e) {
    let i = this.renderObjects.get(e);
    if (i === void 0) {
      const { geometry: n, material: s } = e;
      if (i = {
        material: this.getMaterialData(s),
        geometry: {
          attributes: this.getAttributesData(n.attributes),
          indexVersion: n.index ? n.index.version : null,
          drawRange: { start: n.drawRange.start, count: n.drawRange.count }
        },
        worldMatrix: e.object.matrixWorld.clone()
      }, e.object.center && (i.center = e.object.center.clone()), e.object.morphTargetInfluences && (i.morphTargetInfluences = e.object.morphTargetInfluences.slice()), e.bundle !== null && (i.version = e.bundle.version), i.material.transmission > 0) {
        const { width: a, height: o } = e.context;
        i.bufferWidth = a, i.bufferHeight = o;
      }
      this.renderObjects.set(e, i);
    }
    return i;
  }
  getAttributesData(e) {
    const i = {};
    for (const n in e) {
      const s = e[n];
      i[n] = {
        version: s.version
      };
    }
    return i;
  }
  containsNode(e) {
    const i = e.material;
    for (const n in i)
      if (i[n] && i[n].isNode)
        return !0;
    return e.renderer.nodes.modelViewMatrix !== null || e.renderer.nodes.modelNormalViewMatrix !== null;
  }
  getMaterialData(e) {
    const i = {};
    for (const n of this.refreshUniforms) {
      const s = e[n];
      s != null && (typeof s == "object" && s.clone !== void 0 ? s.isTexture === !0 ? i[n] = { id: s.id, version: s.version } : i[n] = s.clone() : i[n] = s);
    }
    return i;
  }
  equals(e) {
    const { object: i, material: n, geometry: s } = e, a = this.getRenderObjectData(e);
    if (a.worldMatrix.equals(i.matrixWorld) !== !0)
      return a.worldMatrix.copy(i.matrixWorld), !1;
    const o = a.material;
    for (const v in o) {
      const y = o[v], g = n[v];
      if (y.equals !== void 0) {
        if (y.equals(g) === !1)
          return y.copy(g), !1;
      } else if (g.isTexture === !0) {
        if (y.id !== g.id || y.version !== g.version)
          return y.id = g.id, y.version = g.version, !1;
      } else if (y !== g)
        return o[v] = g, !1;
    }
    if (o.transmission > 0) {
      const { width: v, height: y } = e.context;
      if (a.bufferWidth !== v || a.bufferHeight !== y)
        return a.bufferWidth = v, a.bufferHeight = y, !1;
    }
    const l = a.geometry, u = s.attributes, c = l.attributes, h = Object.keys(c), d = Object.keys(u);
    if (h.length !== d.length)
      return a.geometry.attributes = this.getAttributesData(u), !1;
    for (const v of h) {
      const y = c[v], g = u[v];
      if (g === void 0)
        return delete c[v], !1;
      if (y.version !== g.version)
        return y.version = g.version, !1;
    }
    const p = s.index, f = l.indexVersion, m = p ? p.version : null;
    if (f !== m)
      return l.indexVersion = m, !1;
    if (l.drawRange.start !== s.drawRange.start || l.drawRange.count !== s.drawRange.count)
      return l.drawRange.start = s.drawRange.start, l.drawRange.count = s.drawRange.count, !1;
    if (a.morphTargetInfluences) {
      let v = !1;
      for (let y = 0; y < a.morphTargetInfluences.length; y++)
        a.morphTargetInfluences[y] !== i.morphTargetInfluences[y] && (v = !0);
      if (v) return !0;
    }
    return a.center && a.center.equals(i.center) === !1 ? (a.center.copy(i.center), !0) : (e.bundle !== null && (a.version = e.bundle.version), !0);
  }
  needsRefresh(e, i) {
    if (this.hasNode || this.hasAnimation || this.firstInitialization(e))
      return !0;
    const { renderId: n } = i;
    if (this.renderId !== n)
      return this.renderId = n, !0;
    const s = e.object.static === !0, a = e.bundle !== null && e.bundle.static === !0 && this.getRenderObjectData(e).version === e.bundle.version;
    return s || a ? !1 : this.equals(e) !== !0;
  }
}
function bd(r, e = 0) {
  let i = 3735928559 ^ e, n = 1103547991 ^ e;
  if (r instanceof Array)
    for (let s = 0, a; s < r.length; s++)
      a = r[s], i = Math.imul(i ^ a, 2654435761), n = Math.imul(n ^ a, 1597334677);
  else
    for (let s = 0, a; s < r.length; s++)
      a = r.charCodeAt(s), i = Math.imul(i ^ a, 2654435761), n = Math.imul(n ^ a, 1597334677);
  return i = Math.imul(i ^ i >>> 16, 2246822507), i ^= Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507), n ^= Math.imul(i ^ i >>> 13, 3266489909), 4294967296 * (2097151 & n) + (i >>> 0);
}
const pW = (r) => bd(r), MP = (r) => bd(r), km = (...r) => bd(r);
function AP(r, e = !1) {
  const i = [];
  r.isNode === !0 && (i.push(r.id), r = r.getSelf());
  for (const { property: n, childNode: s } of Fm(r))
    i.push(i, bd(n.slice(0, -4)), s.getCacheKey(e));
  return bd(i);
}
function* Fm(r, e = !1) {
  for (const i in r) {
    if (i.startsWith("_") === !0) continue;
    const n = r[i];
    if (Array.isArray(n) === !0)
      for (let s = 0; s < n.length; s++) {
        const a = n[s];
        a && (a.isNode === !0 || e && typeof a.toJSON == "function") && (yield { property: i, index: s, childNode: a });
      }
    else if (n && n.isNode === !0)
      yield { property: i, childNode: n };
    else if (typeof n == "object")
      for (const s in n) {
        const a = n[s];
        a && (a.isNode === !0 || e && typeof a.toJSON == "function") && (yield { property: i, index: s, childNode: a });
      }
  }
}
function Bm(r) {
  if (r == null) return null;
  const e = typeof r;
  return r.isNode === !0 ? "node" : e === "number" ? "float" : e === "boolean" ? "bool" : e === "string" ? "string" : e === "function" ? "shader" : r.isVector2 === !0 ? "vec2" : r.isVector3 === !0 ? "vec3" : r.isVector4 === !0 ? "vec4" : r.isMatrix3 === !0 ? "mat3" : r.isMatrix4 === !0 ? "mat4" : r.isColor === !0 ? "color" : r instanceof ArrayBuffer ? "ArrayBuffer" : null;
}
function CP(r, ...e) {
  const i = r ? r.slice(-4) : void 0;
  return e.length === 1 && (i === "vec2" ? e = [e[0], e[0]] : i === "vec3" ? e = [e[0], e[0], e[0]] : i === "vec4" && (e = [e[0], e[0], e[0], e[0]])), r === "color" ? new Yt(...e) : i === "vec2" ? new jt(...e) : i === "vec3" ? new oe(...e) : i === "vec4" ? new $t(...e) : i === "mat3" ? new Xr(...e) : i === "mat4" ? new gi(...e) : r === "bool" ? e[0] || !1 : r === "float" || r === "int" || r === "uint" ? e[0] || 0 : r === "string" ? e[0] || "" : r === "ArrayBuffer" ? mW(e[0]) : null;
}
function fW(r) {
  let e = "";
  const i = new Uint8Array(r);
  for (let n = 0; n < i.length; n++)
    e += String.fromCharCode(i[n]);
  return btoa(e);
}
function mW(r) {
  return Uint8Array.from(atob(r), (e) => e.charCodeAt(0)).buffer;
}
const JE = {
  VERTEX: "vertex"
}, Rt = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
}, gW = ["fragment", "vertex"], eM = ["setup", "analyze", "generate"], tM = [...gW, "compute"], Vc = ["x", "y", "z", "w"];
let yW = 0;
class Mt extends Bc {
  static get type() {
    return "Node";
  }
  constructor(e = null) {
    super(), this.nodeType = e, this.updateType = Rt.NONE, this.updateBeforeType = Rt.NONE, this.updateAfterType = Rt.NONE, this.uuid = T7.generateUUID(), this.version = 0, this._cacheKey = null, this._cacheKeyVersion = 0, this.global = !1, this.isNode = !0, Object.defineProperty(this, "id", { value: yW++ });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get type() {
    return this.constructor.type;
  }
  onUpdate(e, i) {
    return this.updateType = i, this.update = e.bind(this.getSelf()), this;
  }
  onFrameUpdate(e) {
    return this.onUpdate(e, Rt.FRAME);
  }
  onRenderUpdate(e) {
    return this.onUpdate(e, Rt.RENDER);
  }
  onObjectUpdate(e) {
    return this.onUpdate(e, Rt.OBJECT);
  }
  onReference(e) {
    return this.updateReference = e.bind(this.getSelf()), this;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return this.global;
  }
  *getChildren() {
    for (const { childNode: e } of Fm(this))
      yield e;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(e) {
    e(this);
    for (const i of this.getChildren())
      i.traverse(e);
  }
  getCacheKey(e = !1) {
    return e = e || this.version !== this._cacheKeyVersion, (e === !0 || this._cacheKey === null) && (this._cacheKey = AP(this, e), this._cacheKeyVersion = this.version), this._cacheKey;
  }
  getScope() {
    return this;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  getElementType(e) {
    const i = this.getNodeType(e);
    return e.getElementType(i);
  }
  getNodeType(e) {
    const i = e.getNodeProperties(this);
    return i.outputNode ? i.outputNode.getNodeType(e) : this.nodeType;
  }
  getShared(e) {
    const i = this.getHash(e);
    return e.getNodeFromHash(i) || this;
  }
  setup(e) {
    const i = e.getNodeProperties(this);
    let n = 0;
    for (const s of this.getChildren())
      i["node" + n++] = s;
    return null;
  }
  analyze(e) {
    if (e.increaseUsage(this) === 1) {
      const i = e.getNodeProperties(this);
      for (const n of Object.values(i))
        n && n.isNode === !0 && n.build(e);
    }
  }
  generate(e, i) {
    const { outputNode: n } = e.getNodeProperties(this);
    if (n && n.isNode === !0)
      return n.build(e, i);
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  updateAfter() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(e, i = null) {
    const n = this.getShared(e);
    if (this !== n)
      return n.build(e, i);
    e.addNode(this), e.addChain(this);
    let s = null;
    const a = e.getBuildStage();
    if (a === "setup") {
      this.updateReference(e);
      const o = e.getNodeProperties(this);
      if (o.initialized !== !0) {
        e.stack.nodes.length, o.initialized = !0, o.outputNode = this.setup(e), o.outputNode !== null && e.stack.nodes.length;
        for (const l of Object.values(o))
          l && l.isNode === !0 && l.build(e);
      }
    } else if (a === "analyze")
      this.analyze(e);
    else if (a === "generate")
      if (this.generate.length === 1) {
        const o = this.getNodeType(e), l = e.getDataFromNode(this);
        s = l.snippet, s === void 0 ? (s = this.generate(e) || "", l.snippet = s) : l.flowCodes !== void 0 && e.context.nodeBlock !== void 0 && e.addFlowCodeHierarchy(this, e.context.nodeBlock), s = e.format(s, o, i);
      } else
        s = this.generate(e, i) || "";
    return e.removeChain(this), e.addSequentialNode(this), s;
  }
  getSerializeChildren() {
    return Fm(this);
  }
  serialize(e) {
    const i = this.getSerializeChildren(), n = {};
    for (const { property: s, index: a, childNode: o } of i)
      a !== void 0 ? (n[s] === void 0 && (n[s] = Number.isInteger(a) ? [] : {}), n[s][a] = o.toJSON(e.meta).uuid) : n[s] = o.toJSON(e.meta).uuid;
    Object.keys(n).length > 0 && (e.inputNodes = n);
  }
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const i = e.meta.nodes;
      for (const n in e.inputNodes)
        if (Array.isArray(e.inputNodes[n])) {
          const s = [];
          for (const a of e.inputNodes[n])
            s.push(i[a]);
          this[n] = s;
        } else if (typeof e.inputNodes[n] == "object") {
          const s = {};
          for (const a in e.inputNodes[n]) {
            const o = e.inputNodes[n][a];
            s[a] = i[o];
          }
          this[n] = s;
        } else {
          const s = e.inputNodes[n];
          this[n] = i[s];
        }
    }
  }
  toJSON(e) {
    const { uuid: i, type: n } = this, s = e === void 0 || typeof e == "string";
    s && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    let a = e.nodes[i];
    a === void 0 && (a = {
      uuid: i,
      type: n,
      meta: e,
      metadata: {
        version: 4.6,
        type: "Node",
        generator: "Node.toJSON"
      }
    }, s !== !0 && (e.nodes[a.uuid] = a), this.serialize(a), delete a.meta);
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
    if (s) {
      const l = o(e.textures), u = o(e.images), c = o(e.nodes);
      l.length > 0 && (a.textures = l), u.length > 0 && (a.images = u), c.length > 0 && (a.nodes = c);
    }
    return a;
  }
}
class Qd extends Mt {
  static get type() {
    return "ArrayElementNode";
  }
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(e, i) {
    super(), this.node = e, this.indexNode = i, this.isArrayElementNode = !0;
  }
  getNodeType(e) {
    return this.node.getElementType(e);
  }
  generate(e) {
    const i = this.node.build(e), n = this.indexNode.build(e, "uint");
    return `${i}[ ${n} ]`;
  }
}
class RP extends Mt {
  static get type() {
    return "ConvertNode";
  }
  constructor(e, i) {
    super(), this.node = e, this.convertTo = i;
  }
  getNodeType(e) {
    const i = this.node.getNodeType(e);
    let n = null;
    for (const s of this.convertTo.split("|"))
      (n === null || e.getTypeLength(i) === e.getTypeLength(s)) && (n = s);
    return n;
  }
  serialize(e) {
    super.serialize(e), e.convertTo = this.convertTo;
  }
  deserialize(e) {
    super.deserialize(e), this.convertTo = e.convertTo;
  }
  generate(e, i) {
    const n = this.node, s = this.getNodeType(e), a = n.build(e, s);
    return e.format(a, s, i);
  }
}
class zi extends Mt {
  static get type() {
    return "TempNode";
  }
  constructor(e) {
    super(e), this.isTempNode = !0;
  }
  hasDependencies(e) {
    return e.getDataFromNode(this).usageCount > 1;
  }
  build(e, i) {
    if (e.getBuildStage() === "generate") {
      const n = e.getVectorType(this.getNodeType(e, i)), s = e.getDataFromNode(this);
      if (s.propertyName !== void 0)
        return e.format(s.propertyName, n, i);
      if (n !== "void" && i !== "void" && this.hasDependencies(e)) {
        const a = super.build(e, n), o = e.getVarFromNode(this, null, n), l = e.getPropertyName(o);
        return e.addLineFlowCode(`${l} = ${a}`, this), s.snippet = a, s.propertyName = l, e.format(s.propertyName, n, i);
      }
    }
    return super.build(e, i);
  }
}
class vW extends zi {
  static get type() {
    return "JoinNode";
  }
  constructor(e = [], i = null) {
    super(i), this.nodes = e;
  }
  getNodeType(e) {
    return this.nodeType !== null ? e.getVectorType(this.nodeType) : e.getTypeFromLength(this.nodes.reduce((i, n) => i + e.getTypeLength(n.getNodeType(e)), 0));
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.nodes, a = e.getComponentType(n), o = [];
    for (const u of s) {
      let c = u.build(e);
      const h = e.getComponentType(u.getNodeType(e));
      h !== a && (c = e.format(c, h, a)), o.push(c);
    }
    const l = `${e.getType(n)}( ${o.join(", ")} )`;
    return e.format(l, n, i);
  }
}
const bW = Vc.join("");
class iM extends Mt {
  static get type() {
    return "SplitNode";
  }
  constructor(e, i = "x") {
    super(), this.node = e, this.components = i, this.isSplitNode = !0;
  }
  getVectorLength() {
    let e = this.components.length;
    for (const i of this.components)
      e = Math.max(Vc.indexOf(i) + 1, e);
    return e;
  }
  getComponentType(e) {
    return e.getComponentType(this.node.getNodeType(e));
  }
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length, this.getComponentType(e));
  }
  generate(e, i) {
    const n = this.node, s = e.getTypeLength(n.getNodeType(e));
    let a = null;
    if (s > 1) {
      let o = null;
      this.getVectorLength() >= s && (o = e.getTypeFromLength(this.getVectorLength(), this.getComponentType(e)));
      const l = n.build(e, o);
      this.components.length === s && this.components === bW.slice(0, this.components.length) ? a = e.format(l, o, i) : a = e.format(`${l}.${this.components}`, this.getNodeType(e), i);
    } else
      a = n.build(e, i);
    return a;
  }
  serialize(e) {
    super.serialize(e), e.components = this.components;
  }
  deserialize(e) {
    super.deserialize(e), this.components = e.components;
  }
}
class xW extends zi {
  static get type() {
    return "SetNode";
  }
  constructor(e, i, n) {
    super(), this.sourceNode = e, this.components = i, this.targetNode = n;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { sourceNode: i, components: n, targetNode: s } = this, a = this.getNodeType(e), o = e.getTypeFromLength(n.length, s.getNodeType(e)), l = s.build(e, o), u = i.build(e, a), c = e.getTypeLength(a), h = [];
    for (let d = 0; d < c; d++) {
      const p = Vc[d];
      p === n[0] ? (h.push(l), d += n.length - 1) : h.push(u + "." + p);
    }
    return `${e.getType(a)}( ${h.join(", ")} )`;
  }
}
class _W extends zi {
  static get type() {
    return "FlipNode";
  }
  constructor(e, i) {
    super(), this.sourceNode = e, this.components = i;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { components: i, sourceNode: n } = this, s = this.getNodeType(e), a = n.build(e), o = e.getVarFromNode(this), l = e.getPropertyName(o);
    e.addLineFlowCode(l + " = " + a, this);
    const u = e.getTypeLength(s), c = [];
    let h = 0;
    for (let d = 0; d < u; d++) {
      const p = Vc[d];
      p === i[h] ? (c.push("1.0 - " + (l + "." + p)), h++) : c.push(l + "." + p);
    }
    return `${e.getType(s)}( ${c.join(", ")} )`;
  }
}
class yT extends Mt {
  static get type() {
    return "InputNode";
  }
  constructor(e, i = null) {
    super(i), this.isInputNode = !0, this.value = e, this.precision = null;
  }
  getNodeType() {
    return this.nodeType === null ? Bm(this.value) : this.nodeType;
  }
  getInputType(e) {
    return this.getNodeType(e);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  serialize(e) {
    super.serialize(e), e.value = this.value, this.value && this.value.toArray && (e.value = this.value.toArray()), e.valueType = Bm(this.value), e.nodeType = this.nodeType, e.valueType === "ArrayBuffer" && (e.value = fW(e.value)), e.precision = this.precision;
  }
  deserialize(e) {
    super.deserialize(e), this.nodeType = e.nodeType, this.value = Array.isArray(e.value) ? CP(e.valueType, ...e.value) : e.value, this.precision = e.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
class Ea extends yT {
  static get type() {
    return "ConstNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isConstNode = !0;
  }
  generateConst(e) {
    return e.generateConst(this.getNodeType(e), this.value);
  }
  generate(e, i) {
    const n = this.getNodeType(e);
    return e.format(this.generateConst(e), n, i);
  }
}
let Sc = null;
const Fu = /* @__PURE__ */ new Map();
function fe(r, e) {
  if (Fu.has(r)) {
    console.warn(`Redefinition of method chaining ${r}`);
    return;
  }
  if (typeof e != "function") throw new Error(`Node element ${r} is not a function`);
  Fu.set(r, e);
}
const NP = (r) => r.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), rM = (r) => NP(r).split("").sort().join(""), PP = {
  setup(r, e) {
    const i = e.shift();
    return r(Og(i), ...e);
  },
  get(r, e, i) {
    if (typeof e == "string" && r[e] === void 0) {
      if (r.isStackNode !== !0 && e === "assign")
        return (...n) => (Sc.assign(i, ...n), i);
      if (Fu.has(e)) {
        const n = Fu.get(e);
        return r.isStackNode ? (...s) => i.add(n(...s)) : (...s) => n(i, ...s);
      } else {
        if (e === "self")
          return r;
        if (e.endsWith("Assign") && Fu.has(e.slice(0, e.length - 6))) {
          const n = Fu.get(e.slice(0, e.length - 6));
          return r.isStackNode ? (...s) => i.assign(s[0], n(...s)) : (...s) => i.assign(n(i, ...s));
        } else {
          if (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0)
            return e = NP(e), De(new iM(i, e));
          if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = rM(e.slice(3).toLowerCase()), (n) => De(new xW(r, e, n));
          if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = rM(e.slice(4).toLowerCase()), () => De(new _W(De(r), e));
          if (e === "width" || e === "height" || e === "depth")
            return e === "width" ? e = "x" : e === "height" ? e = "y" : e === "depth" && (e = "z"), De(new iM(r, e));
          if (/^\d+$/.test(e) === !0)
            return De(new Qd(i, new Ea(Number(e), "uint")));
        }
      }
    }
    return Reflect.get(r, e, i);
  },
  set(r, e, i, n) {
    return typeof e == "string" && r[e] === void 0 && (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0 || e === "width" || e === "height" || e === "depth" || /^\d+$/.test(e) === !0) ? (n[e].assign(i), !0) : Reflect.set(r, e, i, n);
  }
}, kv = /* @__PURE__ */ new WeakMap(), nM = /* @__PURE__ */ new WeakMap(), TW = function(r, e = null) {
  const i = Bm(r);
  if (i === "node") {
    let n = kv.get(r);
    return n === void 0 && (n = new Proxy(r, PP), kv.set(r, n), kv.set(n, n)), n;
  } else {
    if (e === null && (i === "float" || i === "boolean") || i && i !== "shader" && i !== "string")
      return De(yx(r, e));
    if (i === "shader")
      return Fe(r);
  }
  return r;
}, SW = function(r, e = null) {
  for (const i in r)
    r[i] = De(r[i], e);
  return r;
}, wW = function(r, e = null) {
  const i = r.length;
  for (let n = 0; n < i; n++)
    r[n] = De(r[n], e);
  return r;
}, EW = function(r, e = null, i = null, n = null) {
  const s = (a) => De(n !== null ? Object.assign(a, n) : a);
  return e === null ? (...a) => s(new r(...Qu(a))) : i !== null ? (i = De(i), (...a) => s(new r(e, ...Qu(a), i))) : (...a) => s(new r(e, ...Qu(a)));
}, MW = function(r, ...e) {
  return De(new r(...Qu(e)));
};
class AW extends Mt {
  constructor(e, i) {
    super(), this.shaderNode = e, this.inputNodes = i;
  }
  getNodeType(e) {
    return this.shaderNode.nodeType || this.getOutputNode(e).getNodeType(e);
  }
  call(e) {
    const { shaderNode: i, inputNodes: n } = this, s = e.getNodeProperties(i);
    if (s.onceOutput) return s.onceOutput;
    let a = null;
    if (i.layout) {
      let o = nM.get(e.constructor);
      o === void 0 && (o = /* @__PURE__ */ new WeakMap(), nM.set(e.constructor, o));
      let l = o.get(i);
      l === void 0 && (l = De(e.buildFunctionNode(i)), o.set(i, l)), e.currentFunctionNode !== null && e.currentFunctionNode.includes.push(l), a = De(l.call(n));
    } else {
      const o = i.jsFunc, l = n !== null ? o(n, e) : o(e);
      a = De(l);
    }
    return i.once && (s.onceOutput = a), a;
  }
  getOutputNode(e) {
    const i = e.getNodeProperties(this);
    return i.outputNode === null && (i.outputNode = this.setupOutput(e)), i.outputNode;
  }
  setup(e) {
    return this.getOutputNode(e);
  }
  setupOutput(e) {
    return e.addStack(), e.stack.outputNode = this.call(e), e.removeStack();
  }
  generate(e, i) {
    return this.getOutputNode(e).build(e, i);
  }
}
class CW extends Mt {
  constructor(e, i) {
    super(i), this.jsFunc = e, this.layout = null, this.global = !0, this.once = !1;
  }
  setLayout(e) {
    return this.layout = e, this;
  }
  call(e = null) {
    return Og(e), De(new AW(this, e));
  }
  setup() {
    return this.call();
  }
}
const RW = [!1, !0], NW = [0, 1, 2, 3], PW = [-1, -2], IP = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2], vT = /* @__PURE__ */ new Map();
for (const r of RW) vT.set(r, new Ea(r));
const bT = /* @__PURE__ */ new Map();
for (const r of NW) bT.set(r, new Ea(r, "uint"));
const xT = new Map([...bT].map((r) => new Ea(r.value, "int")));
for (const r of PW) xT.set(r, new Ea(r, "int"));
const Pg = new Map([...xT].map((r) => new Ea(r.value)));
for (const r of IP) Pg.set(r, new Ea(r));
for (const r of IP) Pg.set(-r, new Ea(-r));
const Ig = { bool: vT, uint: bT, ints: xT, float: Pg }, sM = new Map([...vT, ...Pg]), yx = (r, e) => sM.has(r) ? sM.get(r) : r.isNode === !0 ? r : new Ea(r, e), IW = (r) => {
  try {
    return r.getNodeType();
  } catch {
    return;
  }
}, ji = function(r, e = null) {
  return (...i) => {
    if ((i.length === 0 || !["bool", "float", "int", "uint"].includes(r) && i.every((s) => typeof s != "object")) && (i = [CP(r, ...i)]), i.length === 1 && e !== null && e.has(i[0]))
      return De(e.get(i[0]));
    if (i.length === 1) {
      const s = yx(i[0], r);
      return IW(s) === r ? De(s) : De(new RP(s, r));
    }
    const n = i.map((s) => yx(s));
    return De(new vW(n, r));
  };
}, aM = (r) => typeof r == "object" && r !== null ? r.value : r, OW = (r) => r != null ? r.nodeType || r.convertTo || (typeof r == "string" ? r : null) : null;
function rm(r, e) {
  return new Proxy(new CW(r, e), PP);
}
const De = (r, e = null) => (
  /* new */
  TW(r, e)
), Og = (r, e = null) => new SW(r, e), Qu = (r, e = null) => new wW(r, e), Me = (...r) => new EW(...r), Ve = (...r) => new MW(...r), Fe = (r, e) => {
  const i = new rm(r, e), n = (...s) => {
    let a;
    return Og(s), s[0] && s[0].isNode ? a = [...s] : a = s[0], i.call(a);
  };
  return n.shaderNode = i, n.setLayout = (s) => (i.setLayout(s), n), n.once = () => (i.once = !0, n), n;
};
fe("toGlobal", (r) => (r.global = !0, r));
const zm = (r) => {
  Sc = r;
}, OP = () => Sc, nr = (...r) => Sc.If(...r);
function DW(r) {
  return Sc && Sc.add(r), r;
}
fe("append", DW);
const LW = new ji("color"), ve = new ji("float", Ig.float), Mi = new ji("int", Ig.ints), UW = new ji("uint", Ig.uint), kW = new ji("bool", Ig.bool), He = new ji("vec2"), Ks = new ji("ivec2"), FW = new ji("uvec2"), BW = new ji("bvec2"), ye = new ji("vec3"), zW = new ji("ivec3"), jW = new ji("uvec3"), VW = new ji("bvec3"), _t = new ji("vec4"), GW = new ji("ivec4"), HW = new ji("uvec4"), WW = new ji("bvec4"), _T = new ji("mat2"), Rr = new ji("mat3"), Ju = new ji("mat4");
fe("toColor", LW);
fe("toFloat", ve);
fe("toInt", Mi);
fe("toUint", UW);
fe("toBool", kW);
fe("toVec2", He);
fe("toIVec2", Ks);
fe("toUVec2", FW);
fe("toBVec2", BW);
fe("toVec3", ye);
fe("toIVec3", zW);
fe("toUVec3", jW);
fe("toBVec3", VW);
fe("toVec4", _t);
fe("toIVec4", GW);
fe("toUVec4", HW);
fe("toBVec4", WW);
fe("toMat2", _T);
fe("toMat3", Rr);
fe("toMat4", Ju);
const qW = /* @__PURE__ */ Me(Qd), XW = (r, e) => De(new RP(De(r), e));
fe("element", qW);
fe("convert", XW);
class DP extends Mt {
  static get type() {
    return "UniformGroupNode";
  }
  constructor(e, i = !1, n = 1) {
    super("string"), this.name = e, this.version = 0, this.shared = i, this.order = n, this.isUniformGroup = !0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  serialize(e) {
    super.serialize(e), e.name = this.name, e.version = this.version, e.shared = this.shared;
  }
  deserialize(e) {
    super.deserialize(e), this.name = e.name, this.version = e.version, this.shared = e.shared;
  }
}
const $W = (r) => new DP(r), LP = (r, e = 0) => new DP(r, !0, e), YW = /* @__PURE__ */ LP("frame"), Ut = /* @__PURE__ */ LP("render"), UP = /* @__PURE__ */ $W("object");
class Jd extends yT {
  static get type() {
    return "UniformNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isUniformNode = !0, this.name = "", this.groupNode = UP;
  }
  label(e) {
    return this.name = e, this;
  }
  setGroup(e) {
    return this.groupNode = e, this;
  }
  getGroup() {
    return this.groupNode;
  }
  getUniformHash(e) {
    return this.getHash(e);
  }
  onUpdate(e, i) {
    const n = this.getSelf();
    return e = e.bind(n), super.onUpdate((s) => {
      const a = e(s, n);
      a !== void 0 && (this.value = a);
    }, i);
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.getUniformHash(e);
    let a = e.getNodeFromHash(s);
    a === void 0 && (e.setHashNode(this, s), a = this);
    const o = a.getInputType(e), l = e.getUniformFromNode(a, o, e.shaderStage, this.name || e.context.label), u = e.getPropertyName(l);
    return e.context.label !== void 0 && delete e.context.label, e.format(u, n, i);
  }
}
const Tt = (r, e) => {
  const i = OW(e || r), n = r && r.isNode === !0 ? r.node && r.node.value || r.value : r;
  return De(new Jd(n, i));
};
class Kt extends Mt {
  static get type() {
    return "PropertyNode";
  }
  constructor(e, i = null, n = !1) {
    super(e), this.name = i, this.varying = n, this.isPropertyNode = !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  isGlobal() {
    return !0;
  }
  generate(e) {
    let i;
    return this.varying === !0 ? (i = e.getVaryingFromNode(this, this.name), i.needsInterpolation = !0) : i = e.getVarFromNode(this, this.name), e.getPropertyName(i);
  }
}
const Nu = (r, e) => De(new Kt(r, e)), jm = (r, e) => De(new Kt(r, e, !0)), Wt = /* @__PURE__ */ Ve(Kt, "vec4", "DiffuseColor"), oM = /* @__PURE__ */ Ve(Kt, "vec3", "EmissiveColor"), ia = /* @__PURE__ */ Ve(Kt, "float", "Roughness"), Vm = /* @__PURE__ */ Ve(Kt, "float", "Metalness"), vx = /* @__PURE__ */ Ve(Kt, "float", "Clearcoat"), Gm = /* @__PURE__ */ Ve(Kt, "float", "ClearcoatRoughness"), Bu = /* @__PURE__ */ Ve(Kt, "vec3", "Sheen"), TT = /* @__PURE__ */ Ve(Kt, "float", "SheenRoughness"), ST = /* @__PURE__ */ Ve(Kt, "float", "Iridescence"), kP = /* @__PURE__ */ Ve(Kt, "float", "IridescenceIOR"), FP = /* @__PURE__ */ Ve(Kt, "float", "IridescenceThickness"), bx = /* @__PURE__ */ Ve(Kt, "float", "AlphaT"), Ho = /* @__PURE__ */ Ve(Kt, "float", "Anisotropy"), nm = /* @__PURE__ */ Ve(Kt, "vec3", "AnisotropyT"), ec = /* @__PURE__ */ Ve(Kt, "vec3", "AnisotropyB"), nn = /* @__PURE__ */ Ve(Kt, "color", "SpecularColor"), Hm = /* @__PURE__ */ Ve(Kt, "float", "SpecularF90"), xx = /* @__PURE__ */ Ve(Kt, "float", "Shininess"), KW = /* @__PURE__ */ Ve(Kt, "vec4", "Output"), Fv = /* @__PURE__ */ Ve(Kt, "float", "dashSize"), lM = /* @__PURE__ */ Ve(Kt, "float", "gapSize"), sm = /* @__PURE__ */ Ve(Kt, "float", "IOR"), _x = /* @__PURE__ */ Ve(Kt, "float", "Transmission"), BP = /* @__PURE__ */ Ve(Kt, "float", "Thickness"), zP = /* @__PURE__ */ Ve(Kt, "float", "AttenuationDistance"), jP = /* @__PURE__ */ Ve(Kt, "color", "AttenuationColor"), VP = /* @__PURE__ */ Ve(Kt, "float", "Dispersion");
class ZW extends zi {
  static get type() {
    return "AssignNode";
  }
  constructor(e, i) {
    super(), this.targetNode = e, this.sourceNode = i;
  }
  hasDependencies() {
    return !1;
  }
  getNodeType(e, i) {
    return i !== "void" ? this.targetNode.getNodeType(e) : "void";
  }
  needsSplitAssign(e) {
    const { targetNode: i } = this;
    if (e.isAvailable("swizzleAssign") === !1 && i.isSplitNode && i.components.length > 1) {
      const n = e.getTypeLength(i.node.getNodeType(e));
      return Vc.join("").slice(0, n) !== i.components;
    }
    return !1;
  }
  generate(e, i) {
    const { targetNode: n, sourceNode: s } = this, a = this.needsSplitAssign(e), o = n.getNodeType(e), l = n.context({ assign: !0 }).build(e), u = s.build(e, o), c = s.getNodeType(e), h = e.getDataFromNode(this);
    let d;
    if (h.initialized === !0)
      i !== "void" && (d = l);
    else if (a) {
      const p = e.getVarFromNode(this, null, o), f = e.getPropertyName(p);
      e.addLineFlowCode(`${f} = ${u}`, this);
      const m = n.node.context({ assign: !0 }).build(e);
      for (let v = 0; v < n.components.length; v++) {
        const y = n.components[v];
        e.addLineFlowCode(`${m}.${y} = ${f}[ ${v} ]`, this);
      }
      i !== "void" && (d = l);
    } else
      d = `${l} = ${u}`, (i === "void" || c === "void") && (e.addLineFlowCode(d, this), i !== "void" && (d = l));
    return h.initialized = !0, e.format(d, o, i);
  }
}
const QW = /* @__PURE__ */ Me(ZW);
fe("assign", QW);
class JW extends zi {
  static get type() {
    return "FunctionCallNode";
  }
  constructor(e = null, i = {}) {
    super(), this.functionNode = e, this.parameters = i;
  }
  setParameters(e) {
    return this.parameters = e, this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(e) {
    return this.functionNode.getNodeType(e);
  }
  generate(e) {
    const i = [], n = this.functionNode, s = n.getInputs(e), a = this.parameters, o = (l, u) => {
      const c = u.type, h = c === "pointer";
      let d;
      return h ? d = "&" + l.build(e) : d = l.build(e, c), d;
    };
    if (Array.isArray(a))
      for (let l = 0; l < a.length; l++)
        i.push(o(a[l], s[l]));
    else
      for (const l of s) {
        const u = a[l.name];
        if (u !== void 0)
          i.push(o(u, l));
        else
          throw new Error(`FunctionCallNode: Input '${l.name}' not found in FunctionNode.`);
      }
    return `${n.build(e, "property")}( ${i.join(", ")} )`;
  }
}
const eq = (r, ...e) => (e = e.length > 1 || e[0] && e[0].isNode === !0 ? Qu(e) : Og(e[0]), De(new JW(De(r), e)));
fe("call", eq);
class yi extends zi {
  static get type() {
    return "OperatorNode";
  }
  constructor(e, i, n, ...s) {
    if (super(), s.length > 0) {
      let a = new yi(e, i, n);
      for (let o = 0; o < s.length - 1; o++)
        a = new yi(e, a, s[o]);
      i = a, n = s[s.length - 1];
    }
    this.op = e, this.aNode = i, this.bNode = n;
  }
  getNodeType(e, i) {
    const n = this.op, s = this.aNode, a = this.bNode, o = s.getNodeType(e), l = typeof a < "u" ? a.getNodeType(e) : null;
    if (o === "void" || l === "void")
      return "void";
    if (n === "%")
      return o;
    if (n === "~" || n === "&" || n === "|" || n === "^" || n === ">>" || n === "<<")
      return e.getIntegerType(o);
    if (n === "!" || n === "==" || n === "&&" || n === "||" || n === "^^")
      return "bool";
    if (n === "<" || n === ">" || n === "<=" || n === ">=") {
      const u = i ? e.getTypeLength(i) : Math.max(e.getTypeLength(o), e.getTypeLength(l));
      return u > 1 ? `bvec${u}` : "bool";
    } else
      return o === "float" && e.isMatrix(l) ? l : e.isMatrix(o) && e.isVector(l) ? e.getVectorFromMatrix(o) : e.isVector(o) && e.isMatrix(l) ? e.getVectorFromMatrix(l) : e.getTypeLength(l) > e.getTypeLength(o) ? l : o;
  }
  generate(e, i) {
    const n = this.op, s = this.aNode, a = this.bNode, o = this.getNodeType(e, i);
    let l = null, u = null;
    o !== "void" ? (l = s.getNodeType(e), u = typeof a < "u" ? a.getNodeType(e) : null, n === "<" || n === ">" || n === "<=" || n === ">=" || n === "==" ? e.isVector(l) ? u = l : l !== u && (l = u = "float") : n === ">>" || n === "<<" ? (l = o, u = e.changeComponentType(u, "uint")) : e.isMatrix(l) && e.isVector(u) ? u = e.getVectorFromMatrix(l) : e.isVector(l) && e.isMatrix(u) ? l = e.getVectorFromMatrix(u) : l = u = o) : l = u = o;
    const c = s.build(e, l), h = typeof a < "u" ? a.build(e, u) : null, d = e.getTypeLength(i), p = e.getFunctionOperator(n);
    if (i !== "void")
      return n === "<" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("lessThan", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} < ${h} )`, o, i) : n === "<=" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("lessThanEqual", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} <= ${h} )`, o, i) : n === ">" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("greaterThan", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} > ${h} )`, o, i) : n === ">=" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("greaterThanEqual", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} >= ${h} )`, o, i) : n === "!" || n === "~" ? e.format(`(${n}${c})`, l, i) : p ? e.format(`${p}( ${c}, ${h} )`, o, i) : e.format(`( ${c} ${n} ${h} )`, o, i);
    if (l !== "void")
      return p ? e.format(`${p}( ${c}, ${h} )`, o, i) : e.format(`${c} ${n} ${h}`, o, i);
  }
  serialize(e) {
    super.serialize(e), e.op = this.op;
  }
  deserialize(e) {
    super.deserialize(e), this.op = e.op;
  }
}
const Nr = /* @__PURE__ */ Me(yi, "+"), an = /* @__PURE__ */ Me(yi, "-"), Dt = /* @__PURE__ */ Me(yi, "*"), bo = /* @__PURE__ */ Me(yi, "/"), GP = /* @__PURE__ */ Me(yi, "%"), tq = /* @__PURE__ */ Me(yi, "=="), iq = /* @__PURE__ */ Me(yi, "!="), rq = /* @__PURE__ */ Me(yi, "<"), nq = /* @__PURE__ */ Me(yi, ">"), sq = /* @__PURE__ */ Me(yi, "<="), aq = /* @__PURE__ */ Me(yi, ">="), oq = /* @__PURE__ */ Me(yi, "&&"), lq = /* @__PURE__ */ Me(yi, "||"), uq = /* @__PURE__ */ Me(yi, "!"), cq = /* @__PURE__ */ Me(yi, "^^"), hq = /* @__PURE__ */ Me(yi, "&"), dq = /* @__PURE__ */ Me(yi, "~"), pq = /* @__PURE__ */ Me(yi, "|"), fq = /* @__PURE__ */ Me(yi, "^"), mq = /* @__PURE__ */ Me(yi, "<<"), gq = /* @__PURE__ */ Me(yi, ">>");
fe("add", Nr);
fe("sub", an);
fe("mul", Dt);
fe("div", bo);
fe("modInt", GP);
fe("equal", tq);
fe("notEqual", iq);
fe("lessThan", rq);
fe("greaterThan", nq);
fe("lessThanEqual", sq);
fe("greaterThanEqual", aq);
fe("and", oq);
fe("or", lq);
fe("not", uq);
fe("xor", cq);
fe("bitAnd", hq);
fe("bitNot", dq);
fe("bitOr", pq);
fe("bitXor", fq);
fe("shiftLeft", mq);
fe("shiftRight", gq);
const yq = (...r) => (console.warn("TSL.OperatorNode: .remainder() has been renamed to .modInt()."), GP(...r));
fe("remainder", yq);
class re extends zi {
  static get type() {
    return "MathNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.method = e, this.aNode = i, this.bNode = n, this.cNode = s;
  }
  getInputType(e) {
    const i = this.aNode.getNodeType(e), n = this.bNode ? this.bNode.getNodeType(e) : null, s = this.cNode ? this.cNode.getNodeType(e) : null, a = e.isMatrix(i) ? 0 : e.getTypeLength(i), o = e.isMatrix(n) ? 0 : e.getTypeLength(n), l = e.isMatrix(s) ? 0 : e.getTypeLength(s);
    return a > o && a > l ? i : o > l ? n : l > a ? s : i;
  }
  getNodeType(e) {
    const i = this.method;
    return i === re.LENGTH || i === re.DISTANCE || i === re.DOT ? "float" : i === re.CROSS ? "vec3" : i === re.ALL ? "bool" : i === re.EQUALS ? e.changeComponentType(this.aNode.getNodeType(e), "bool") : i === re.MOD ? this.aNode.getNodeType(e) : this.getInputType(e);
  }
  generate(e, i) {
    const n = this.method, s = this.getNodeType(e), a = this.getInputType(e), o = this.aNode, l = this.bNode, u = this.cNode, c = e.renderer.isWebGLRenderer === !0;
    if (n === re.TRANSFORM_DIRECTION) {
      let h = o, d = l;
      e.isMatrix(h.getNodeType(e)) ? d = _t(ye(d), 0) : h = _t(ye(h), 0);
      const p = Dt(h, d).xyz;
      return _d(p).build(e, i);
    } else {
      if (n === re.NEGATE)
        return e.format("( - " + o.build(e, a) + " )", s, i);
      if (n === re.ONE_MINUS)
        return an(1, o).build(e, i);
      if (n === re.RECIPROCAL)
        return bo(1, o).build(e, i);
      if (n === re.DIFFERENCE)
        return Gn(an(o, l)).build(e, i);
      {
        const h = [];
        return n === re.CROSS || n === re.MOD ? h.push(
          o.build(e, s),
          l.build(e, s)
        ) : c && n === re.STEP ? h.push(
          o.build(e, e.getTypeLength(o.getNodeType(e)) === 1 ? "float" : a),
          l.build(e, a)
        ) : c && (n === re.MIN || n === re.MAX) || n === re.MOD ? h.push(
          o.build(e, a),
          l.build(e, e.getTypeLength(l.getNodeType(e)) === 1 ? "float" : a)
        ) : n === re.REFRACT ? h.push(
          o.build(e, a),
          l.build(e, a),
          u.build(e, "float")
        ) : n === re.MIX ? h.push(
          o.build(e, a),
          l.build(e, a),
          u.build(e, e.getTypeLength(u.getNodeType(e)) === 1 ? "float" : a)
        ) : (h.push(o.build(e, a)), l !== null && h.push(l.build(e, a)), u !== null && h.push(u.build(e, a))), e.format(`${e.getMethod(n, s)}( ${h.join(", ")} )`, s, i);
      }
    }
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
re.ALL = "all";
re.ANY = "any";
re.EQUALS = "equals";
re.RADIANS = "radians";
re.DEGREES = "degrees";
re.EXP = "exp";
re.EXP2 = "exp2";
re.LOG = "log";
re.LOG2 = "log2";
re.SQRT = "sqrt";
re.INVERSE_SQRT = "inversesqrt";
re.FLOOR = "floor";
re.CEIL = "ceil";
re.NORMALIZE = "normalize";
re.FRACT = "fract";
re.SIN = "sin";
re.COS = "cos";
re.TAN = "tan";
re.ASIN = "asin";
re.ACOS = "acos";
re.ATAN = "atan";
re.ABS = "abs";
re.SIGN = "sign";
re.LENGTH = "length";
re.NEGATE = "negate";
re.ONE_MINUS = "oneMinus";
re.DFDX = "dFdx";
re.DFDY = "dFdy";
re.ROUND = "round";
re.RECIPROCAL = "reciprocal";
re.TRUNC = "trunc";
re.FWIDTH = "fwidth";
re.BITCAST = "bitcast";
re.TRANSPOSE = "transpose";
re.ATAN2 = "atan2";
re.MIN = "min";
re.MAX = "max";
re.MOD = "mod";
re.STEP = "step";
re.REFLECT = "reflect";
re.DISTANCE = "distance";
re.DIFFERENCE = "difference";
re.DOT = "dot";
re.CROSS = "cross";
re.POW = "pow";
re.TRANSFORM_DIRECTION = "transformDirection";
re.MIX = "mix";
re.CLAMP = "clamp";
re.REFRACT = "refract";
re.SMOOTHSTEP = "smoothstep";
re.FACEFORWARD = "faceforward";
const vq = /* @__PURE__ */ ve(1e-6), bq = /* @__PURE__ */ ve(Math.PI), HP = /* @__PURE__ */ Me(re, re.ALL), xq = /* @__PURE__ */ Me(re, re.ANY), _q = /* @__PURE__ */ Me(re, re.EQUALS), Tq = /* @__PURE__ */ Me(re, re.RADIANS), Sq = /* @__PURE__ */ Me(re, re.DEGREES), WP = /* @__PURE__ */ Me(re, re.EXP), xd = /* @__PURE__ */ Me(re, re.EXP2), qP = /* @__PURE__ */ Me(re, re.LOG), va = /* @__PURE__ */ Me(re, re.LOG2), wT = /* @__PURE__ */ Me(re, re.SQRT), wq = /* @__PURE__ */ Me(re, re.INVERSE_SQRT), yl = /* @__PURE__ */ Me(re, re.FLOOR), ET = /* @__PURE__ */ Me(re, re.CEIL), _d = /* @__PURE__ */ Me(re, re.NORMALIZE), To = /* @__PURE__ */ Me(re, re.FRACT), Vn = /* @__PURE__ */ Me(re, re.SIN), Qa = /* @__PURE__ */ Me(re, re.COS), Eq = /* @__PURE__ */ Me(re, re.TAN), Mq = /* @__PURE__ */ Me(re, re.ASIN), Aq = /* @__PURE__ */ Me(re, re.ACOS), Cq = /* @__PURE__ */ Me(re, re.ATAN), Gn = /* @__PURE__ */ Me(re, re.ABS), XP = /* @__PURE__ */ Me(re, re.SIGN), fo = /* @__PURE__ */ Me(re, re.LENGTH), Rq = /* @__PURE__ */ Me(re, re.NEGATE), Nq = /* @__PURE__ */ Me(re, re.ONE_MINUS), $P = /* @__PURE__ */ Me(re, re.DFDX), YP = /* @__PURE__ */ Me(re, re.DFDY), Pq = /* @__PURE__ */ Me(re, re.ROUND), Iq = /* @__PURE__ */ Me(re, re.RECIPROCAL), Oq = /* @__PURE__ */ Me(re, re.TRUNC), Dq = /* @__PURE__ */ Me(re, re.FWIDTH);
re.BITCAST;
const Lq = /* @__PURE__ */ Me(re, re.TRANSPOSE), Uq = /* @__PURE__ */ Me(re, re.ATAN2), Td = /* @__PURE__ */ Me(re, re.MIN), wn = /* @__PURE__ */ Me(re, re.MAX), KP = /* @__PURE__ */ Me(re, re.MOD), ZP = /* @__PURE__ */ Me(re, re.STEP), kq = /* @__PURE__ */ Me(re, re.REFLECT), Fq = /* @__PURE__ */ Me(re, re.DISTANCE), Bq = /* @__PURE__ */ Me(re, re.DIFFERENCE), MT = /* @__PURE__ */ Me(re, re.DOT), QP = /* @__PURE__ */ Me(re, re.CROSS), Dg = /* @__PURE__ */ Me(re, re.POW), JP = /* @__PURE__ */ Me(re, re.POW, 2), zq = /* @__PURE__ */ Me(re, re.POW, 3), jq = /* @__PURE__ */ Me(re, re.POW, 4), Vq = /* @__PURE__ */ Me(re, re.TRANSFORM_DIRECTION), Gq = (r) => Dt(XP(r), Dg(Gn(r), 1 / 3)), Hq = (r) => MT(r, r), li = /* @__PURE__ */ Me(re, re.MIX), _a = (r, e = 0, i = 1) => De(new re(re.CLAMP, De(r), De(e), De(i))), Wq = (r) => _a(r), eI = /* @__PURE__ */ Me(re, re.REFRACT), Ml = /* @__PURE__ */ Me(re, re.SMOOTHSTEP), qq = /* @__PURE__ */ Me(re, re.FACEFORWARD), Xq = /* @__PURE__ */ Fe(([r]) => {
  const e = 43758.5453, i = MT(r.xy, He(12.9898, 78.233)), n = KP(i, bq);
  return To(Vn(n).mul(e));
}), $q = (r, e, i) => li(e, i, r), Yq = (r, e, i) => Ml(e, i, r);
fe("all", HP);
fe("any", xq);
fe("equals", _q);
fe("radians", Tq);
fe("degrees", Sq);
fe("exp", WP);
fe("exp2", xd);
fe("log", qP);
fe("log2", va);
fe("sqrt", wT);
fe("inverseSqrt", wq);
fe("floor", yl);
fe("ceil", ET);
fe("normalize", _d);
fe("fract", To);
fe("sin", Vn);
fe("cos", Qa);
fe("tan", Eq);
fe("asin", Mq);
fe("acos", Aq);
fe("atan", Cq);
fe("abs", Gn);
fe("sign", XP);
fe("length", fo);
fe("lengthSq", Hq);
fe("negate", Rq);
fe("oneMinus", Nq);
fe("dFdx", $P);
fe("dFdy", YP);
fe("round", Pq);
fe("reciprocal", Iq);
fe("trunc", Oq);
fe("fwidth", Dq);
fe("atan2", Uq);
fe("min", Td);
fe("max", wn);
fe("mod", KP);
fe("step", ZP);
fe("reflect", kq);
fe("distance", Fq);
fe("dot", MT);
fe("cross", QP);
fe("pow", Dg);
fe("pow2", JP);
fe("pow3", zq);
fe("pow4", jq);
fe("transformDirection", Vq);
fe("mix", $q);
fe("clamp", _a);
fe("refract", eI);
fe("smoothstep", Yq);
fe("faceForward", qq);
fe("difference", Bq);
fe("saturate", Wq);
fe("cbrt", Gq);
fe("transpose", Lq);
fe("rand", Xq);
class Kq extends Mt {
  static get type() {
    return "ConditionalNode";
  }
  constructor(e, i, n = null) {
    super(), this.condNode = e, this.ifNode = i, this.elseNode = n;
  }
  getNodeType(e) {
    const i = this.ifNode.getNodeType(e);
    if (this.elseNode !== null) {
      const n = this.elseNode.getNodeType(e);
      if (e.getTypeLength(n) > e.getTypeLength(i))
        return n;
    }
    return i;
  }
  setup(e) {
    const i = this.condNode.cache(), n = this.ifNode.cache(), s = this.elseNode ? this.elseNode.cache() : null, a = e.context.nodeBlock;
    e.getDataFromNode(n).parentNodeBlock = a, s !== null && (e.getDataFromNode(s).parentNodeBlock = a);
    const o = e.getNodeProperties(this);
    o.condNode = i, o.ifNode = n.context({ nodeBlock: n }), o.elseNode = s ? s.context({ nodeBlock: s }) : null;
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = e.getDataFromNode(this);
    if (s.nodeProperty !== void 0)
      return s.nodeProperty;
    const { condNode: a, ifNode: o, elseNode: l } = e.getNodeProperties(this), u = i !== "void", c = u ? Nu(n).build(e) : "";
    s.nodeProperty = c;
    const h = a.build(e, "bool");
    e.addFlowCode(`
${e.tab}if ( ${h} ) {

`).addFlowTab();
    let d = o.build(e, n);
    if (d && (u ? d = c + " = " + d + ";" : d = "return " + d + ";"), e.removeFlowTab().addFlowCode(e.tab + "	" + d + `

` + e.tab + "}"), l !== null) {
      e.addFlowCode(` else {

`).addFlowTab();
      let p = l.build(e, n);
      p && (u ? p = c + " = " + p + ";" : p = "return " + p + ";"), e.removeFlowTab().addFlowCode(e.tab + "	" + p + `

` + e.tab + `}

`);
    } else
      e.addFlowCode(`

`);
    return e.format(c, n, i);
  }
}
const Fr = /* @__PURE__ */ Me(Kq);
fe("select", Fr);
const Zq = (...r) => (console.warn("TSL.ConditionalNode: cond() has been renamed to select()."), Fr(...r));
fe("cond", Zq);
class tI extends Mt {
  static get type() {
    return "ContextNode";
  }
  constructor(e, i = {}) {
    super(), this.isContextNode = !0, this.node = e, this.value = i;
  }
  getScope() {
    return this.node.getScope();
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  analyze(e) {
    this.node.build(e);
  }
  setup(e) {
    const i = e.getContext();
    e.setContext({ ...e.context, ...this.value });
    const n = this.node.build(e);
    return e.setContext(i), n;
  }
  generate(e, i) {
    const n = e.getContext();
    e.setContext({ ...e.context, ...this.value });
    const s = this.node.build(e, i);
    return e.setContext(n), s;
  }
}
const AT = /* @__PURE__ */ Me(tI), Qq = (r, e) => AT(r, { label: e });
fe("context", AT);
fe("label", Qq);
class Jq extends Mt {
  static get type() {
    return "VarNode";
  }
  constructor(e, i = null) {
    super(), this.node = e, this.name = i, this.global = !0, this.isVarNode = !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { node: i, name: n } = this, s = e.getVarFromNode(this, n, e.getVectorType(this.getNodeType(e))), a = e.getPropertyName(s), o = i.build(e, s.type);
    return e.addLineFlowCode(`${a} = ${o}`, this), a;
  }
}
const iI = /* @__PURE__ */ Me(Jq);
fe("toVar", (...r) => iI(...r).append());
const eX = (r) => (console.warn('TSL: "temp" is deprecated. Use ".toVar()" instead.'), iI(r));
fe("temp", eX);
class tX extends Mt {
  static get type() {
    return "VaryingNode";
  }
  constructor(e, i = null) {
    super(), this.node = e, this.name = i, this.isVaryingNode = !0;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setupVarying(e) {
    const i = e.getNodeProperties(this);
    let n = i.varying;
    if (n === void 0) {
      const s = this.name, a = this.getNodeType(e);
      i.varying = n = e.getVaryingFromNode(this, s, a), i.node = this.node;
    }
    return n.needsInterpolation || (n.needsInterpolation = e.shaderStage === "fragment"), n;
  }
  setup(e) {
    this.setupVarying(e);
  }
  analyze(e) {
    return this.setupVarying(e), this.node.analyze(e);
  }
  generate(e) {
    const i = e.getNodeProperties(this), n = this.setupVarying(e);
    if (i.propertyName === void 0) {
      const s = this.getNodeType(e), a = e.getPropertyName(n, JE.VERTEX);
      e.flowNodeFromShaderStage(JE.VERTEX, this.node, s, a), i.propertyName = a;
    }
    return e.getPropertyName(n);
  }
}
const Ma = /* @__PURE__ */ Me(tX);
fe("varying", Ma);
const iX = /* @__PURE__ */ Fe(([r]) => {
  const e = r.mul(0.9478672986).add(0.0521327014).pow(2.4), i = r.mul(0.0773993808), n = r.lessThanEqual(0.04045);
  return li(e, i, n);
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), rX = /* @__PURE__ */ Fe(([r]) => {
  const e = r.pow(0.41666).mul(1.055).sub(0.055), i = r.mul(12.92), n = r.lessThanEqual(31308e-7);
  return li(e, i, n);
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), ep = "WorkingColorSpace", CT = "OutputColorSpace";
class Lg extends zi {
  static get type() {
    return "ColorSpaceNode";
  }
  constructor(e, i, n) {
    super("vec4"), this.colorNode = e, this.source = i, this.target = n;
  }
  resolveColorSpace(e, i) {
    return i === ep ? Li.workingColorSpace : i === CT ? e.context.outputColorSpace || e.renderer.outputColorSpace : i;
  }
  setup(e) {
    const { colorNode: i } = this, n = this.resolveColorSpace(e, this.source), s = this.resolveColorSpace(e, this.target);
    let a = i;
    return Li.enabled === !1 || n === s || !n || !s || (Li.getTransfer(n) === yd && (a = _t(iX(a.rgb), a.a)), Li.getPrimaries(n) !== Li.getPrimaries(s) && (a = _t(
      Rr(Li._getMatrix(new Xr(), n, s)).mul(a.rgb),
      a.a
    )), Li.getTransfer(s) === yd && (a = _t(rX(a.rgb), a.a))), a;
  }
}
const nX = (r) => De(new Lg(De(r), ep, CT)), sX = (r) => De(new Lg(De(r), CT, ep)), aX = (r, e) => De(new Lg(De(r), ep, e)), rI = (r, e) => De(new Lg(De(r), e, ep));
fe("toOutputColorSpace", nX);
fe("toWorkingColorSpace", sX);
fe("workingToColorSpace", aX);
fe("colorSpaceToWorking", rI);
let oX = class extends Qd {
  static get type() {
    return "ReferenceElementNode";
  }
  constructor(r, e) {
    super(r, e), this.referenceNode = r, this.isReferenceElementNode = !0;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(r) {
    const e = super.generate(r), i = this.referenceNode.getNodeType(), n = this.getNodeType();
    return r.format(e, i, n);
  }
};
class nI extends Mt {
  static get type() {
    return "ReferenceBaseNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.property = e, this.uniformType = i, this.object = n, this.count = s, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.updateType = Rt.OBJECT;
  }
  setGroup(e) {
    return this.group = e, this;
  }
  element(e) {
    return De(new oX(this, De(e)));
  }
  setNodeType(e) {
    const i = Tt(null, e).getSelf();
    this.group !== null && i.setGroup(this.group), this.node = i;
  }
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  getValueFromReference(e = this.reference) {
    const { properties: i } = this;
    let n = e[i[0]];
    for (let s = 1; s < i.length; s++)
      n = n[i[s]];
    return n;
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setup() {
    return this.updateValue(), this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const lX = (r, e, i) => De(new nI(r, e, i));
class uX extends nI {
  static get type() {
    return "RendererReferenceNode";
  }
  constructor(e, i, n = null) {
    super(e, i, n), this.renderer = n, this.setGroup(Ut);
  }
  updateReference(e) {
    return this.reference = this.renderer !== null ? this.renderer : e.renderer, this.reference;
  }
}
const cX = (r, e, i) => De(new uX(r, e, i));
class hX extends zi {
  static get type() {
    return "ToneMappingNode";
  }
  constructor(e, i = pX, n = null) {
    super("vec3"), this.toneMapping = e, this.exposureNode = i, this.colorNode = n;
  }
  getCacheKey() {
    return km(super.getCacheKey(), this.toneMapping);
  }
  setup(e) {
    const i = this.colorNode || e.context.color, n = this.toneMapping;
    if (n === Yu) return i;
    let s = null;
    const a = e.renderer.library.getToneMappingFunction(n);
    return a !== null ? s = _t(a(i.rgb, this.exposureNode), i.a) : (console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", n), s = i), s;
  }
}
const dX = (r, e, i) => De(new hX(r, De(e), De(i))), pX = /* @__PURE__ */ cX("toneMappingExposure", "float");
fe("toneMapping", (r, e, i) => dX(e, i, r));
class fX extends yT {
  static get type() {
    return "BufferAttributeNode";
  }
  constructor(e, i = null, n = 0, s = 0) {
    super(e, i), this.isBufferNode = !0, this.bufferType = i, this.bufferStride = n, this.bufferOffset = s, this.usage = Um, this.instanced = !1, this.attribute = null, this.global = !0, e && e.isBufferAttribute === !0 && (this.attribute = e, this.usage = e.usage, this.instanced = e.isInstancedBufferAttribute);
  }
  getHash(e) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let i = e.globalCache.getData(this.value);
      return i === void 0 && (i = {
        node: this
      }, e.globalCache.setData(this.value, i)), i.node.uuid;
    }
    return this.uuid;
  }
  getNodeType(e) {
    return this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)), this.bufferType;
  }
  setup(e) {
    if (this.attribute !== null) return;
    const i = this.getNodeType(e), n = this.value, s = e.getTypeLength(i), a = this.bufferStride || s, o = this.bufferOffset, l = n.isInterleavedBuffer === !0 ? n : new pP(n, a), u = new hT(l, s, o);
    l.setUsage(this.usage), this.attribute = u, this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(e) {
    const i = this.getNodeType(e), n = e.getBufferAttributeFromNode(this, i), s = e.getPropertyName(n);
    let a = null;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? (this.name = s, a = s) : a = Ma(this).build(e, i), a;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(e) {
    return this.usage = e, this.attribute && this.attribute.isBufferAttribute === !0 && (this.attribute.usage = e), this;
  }
  setInstanced(e) {
    return this.instanced = e, this;
  }
}
const RT = (r, e, i, n) => De(new fX(r, e, i, n)), mX = (r, e, i, n) => RT(r, e, i, n).setUsage(ku), uM = (r, e, i, n) => RT(r, e, i, n).setInstanced(!0), cM = (r, e, i, n) => mX(r, e, i, n).setInstanced(!0);
fe("toAttribute", (r) => RT(r.value));
class gX extends Mt {
  static get type() {
    return "ComputeNode";
  }
  constructor(e, i, n = [64]) {
    super("void"), this.isComputeNode = !0, this.computeNode = e, this.count = i, this.workgroupSize = n, this.dispatchCount = 0, this.version = 1, this.updateBeforeType = Rt.OBJECT, this.onInitFunction = null, this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  updateDispatchCount() {
    const { count: e, workgroupSize: i } = this;
    let n = i[0];
    for (let s = 1; s < i.length; s++)
      n *= i[s];
    this.dispatchCount = Math.ceil(e / n);
  }
  onInit(e) {
    return this.onInitFunction = e, this;
  }
  updateBefore({ renderer: e }) {
    e.compute(this);
  }
  generate(e) {
    const { shaderStage: i } = e;
    if (i === "compute") {
      const n = this.computeNode.build(e, "void");
      n !== "" && e.addLineFlowCode(n, this);
    }
  }
}
const yX = (r, e, i) => De(new gX(De(r), e, i));
fe("compute", yX);
class vX extends Mt {
  static get type() {
    return "CacheNode";
  }
  constructor(e, i = !0) {
    super(), this.node = e, this.parent = i, this.isCacheNode = !0;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  build(e, ...i) {
    const n = e.getCache(), s = e.getCacheFromNode(this, this.parent);
    e.setCache(s);
    const a = this.node.build(e, ...i);
    return e.setCache(n), a;
  }
}
const am = (r, ...e) => De(new vX(De(r), ...e));
fe("cache", am);
class bX extends Mt {
  static get type() {
    return "BypassNode";
  }
  constructor(e, i) {
    super(), this.isBypassNode = !0, this.outputNode = e, this.callNode = i;
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const i = this.callNode.build(e, "void");
    return i !== "" && e.addLineFlowCode(i, this), this.outputNode.build(e);
  }
}
const xX = /* @__PURE__ */ Me(bX);
fe("bypass", xX);
class sI extends Mt {
  static get type() {
    return "RemapNode";
  }
  constructor(e, i, n, s = ve(0), a = ve(1)) {
    super(), this.node = e, this.inLowNode = i, this.inHighNode = n, this.outLowNode = s, this.outHighNode = a, this.doClamp = !0;
  }
  setup() {
    const { node: e, inLowNode: i, inHighNode: n, outLowNode: s, outHighNode: a, doClamp: o } = this;
    let l = e.sub(i).div(n.sub(i));
    return o === !0 && (l = l.clamp()), l.mul(a.sub(s)).add(s);
  }
}
const _X = /* @__PURE__ */ Me(sI, null, null, { doClamp: !1 }), TX = /* @__PURE__ */ Me(sI);
fe("remap", _X);
fe("remapClamp", TX);
class SX extends Mt {
  static get type() {
    return "ExpressionNode";
  }
  constructor(e = "", i = "void") {
    super(i), this.snippet = e;
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.snippet;
    if (n === "void")
      e.addLineFlowCode(s, this);
    else
      return e.format(`( ${s} )`, n, i);
  }
}
const Sd = /* @__PURE__ */ Me(SX), wX = (r) => (r ? Fr(r, Sd("discard")) : Sd("discard")).append();
fe("discard", wX);
class EX extends zi {
  static get type() {
    return "RenderOutputNode";
  }
  constructor(e, i, n) {
    super("vec4"), this.colorNode = e, this.toneMapping = i, this.outputColorSpace = n, this.isRenderOutput = !0;
  }
  setup({ context: e }) {
    let i = this.colorNode || e.color;
    const n = (this.toneMapping !== null ? this.toneMapping : e.toneMapping) || Yu, s = (this.outputColorSpace !== null ? this.outputColorSpace : e.outputColorSpace) || Sl;
    return n !== Yu && (i = i.toneMapping(n)), s !== Sl && s !== Li.workingColorSpace && (i = i.workingToColorSpace(s)), i;
  }
}
const MX = (r, e = null, i = null) => De(new EX(De(r), e, i));
fe("renderOutput", MX);
class AX extends Mt {
  static get type() {
    return "AttributeNode";
  }
  constructor(e, i = null) {
    super(i), this.global = !0, this._attributeName = e;
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let i = this.nodeType;
    if (i === null) {
      const n = this.getAttributeName(e);
      if (e.hasGeometryAttribute(n)) {
        const s = e.geometry.getAttribute(n);
        i = e.getTypeFromAttribute(s);
      } else
        i = "float";
    }
    return i;
  }
  setAttributeName(e) {
    return this._attributeName = e, this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const i = this.getAttributeName(e), n = this.getNodeType(e);
    if (e.hasGeometryAttribute(i) === !0) {
      const s = e.geometry.getAttribute(i), a = e.getTypeFromAttribute(s), o = e.getAttribute(i, a);
      return e.shaderStage === "vertex" ? e.format(o.name, a, n) : Ma(this).build(e, n);
    } else
      return console.warn(`AttributeNode: Vertex attribute "${i}" not found on geometry.`), e.generateConst(n);
  }
  serialize(e) {
    super.serialize(e), e.global = this.global, e._attributeName = this._attributeName;
  }
  deserialize(e) {
    super.deserialize(e), this.global = e.global, this._attributeName = e._attributeName;
  }
}
const Ta = (r, e) => De(new AX(r, e)), Ug = (r) => Ta("uv" + (r > 0 ? r : ""), "vec2");
class CX extends Mt {
  static get type() {
    return "TextureSizeNode";
  }
  constructor(e, i = null) {
    super("uvec2"), this.isTextureSizeNode = !0, this.textureNode = e, this.levelNode = i;
  }
  generate(e, i) {
    const n = this.textureNode.build(e, "property"), s = this.levelNode === null ? "0" : this.levelNode.build(e, "int");
    return e.format(`${e.getMethod("textureDimensions")}( ${n}, ${s} )`, this.getNodeType(e), i);
  }
}
const id = /* @__PURE__ */ Me(CX);
class RX extends Jd {
  static get type() {
    return "MaxMipLevelNode";
  }
  constructor(e) {
    super(0), this._textureNode = e, this.updateType = Rt.FRAME;
  }
  get textureNode() {
    return this._textureNode;
  }
  get texture() {
    return this._textureNode.value;
  }
  update() {
    const e = this.texture, i = e.images, n = i && i.length > 0 ? i[0] && i[0].image || i[0] : e.image;
    if (n && n.width !== void 0) {
      const { width: s, height: a } = n;
      this.value = Math.log2(Math.max(s, a));
    }
  }
}
const NX = /* @__PURE__ */ Me(RX);
class tp extends Jd {
  static get type() {
    return "TextureNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e), this.isTextureNode = !0, this.uvNode = i, this.levelNode = n, this.biasNode = s, this.compareNode = null, this.depthNode = null, this.gradNode = null, this.sampler = !0, this.updateMatrix = !1, this.updateType = Rt.NONE, this.referenceNode = null, this._value = e, this._matrixUniform = null, this.setUpdateMatrix(i === null);
  }
  set value(e) {
    this.referenceNode ? this.referenceNode.value = e : this._value = e;
  }
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : this.value.type === er ? "uvec4" : this.value.type === Sr ? "ivec4" : "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return Ug(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(e) {
    return this._matrixUniform === null && (this._matrixUniform = Tt(this.value.matrix)), this._matrixUniform.mul(ye(e, 1)).xy;
  }
  setUpdateMatrix(e) {
    return this.updateMatrix = e, this.updateType = e ? Rt.FRAME : Rt.NONE, this;
  }
  setupUV(e, i) {
    const n = this.value;
    return e.isFlipY() && (n.isRenderTargetTexture === !0 || n.isFramebufferTexture === !0 || n.isDepthTexture === !0) && (this.sampler ? i = i.flipY() : i = i.setY(Mi(id(this, this.levelNode).y).sub(i.y).sub(1))), i;
  }
  setup(e) {
    const i = e.getNodeProperties(this);
    i.referenceNode = this.referenceNode;
    let n = this.uvNode;
    (n === null || e.context.forceUVContext === !0) && e.context.getUV && (n = e.context.getUV(this)), n || (n = this.getDefaultUV()), this.updateMatrix === !0 && (n = this.getTransformedUV(n)), n = this.setupUV(e, n);
    let s = this.levelNode;
    s === null && e.context.getTextureLevel && (s = e.context.getTextureLevel(this)), i.uvNode = n, i.levelNode = s, i.biasNode = this.biasNode, i.compareNode = this.compareNode, i.gradNode = this.gradNode, i.depthNode = this.depthNode;
  }
  generateUV(e, i) {
    return i.build(e, this.sampler === !0 ? "vec2" : "ivec2");
  }
  generateSnippet(e, i, n, s, a, o, l, u) {
    const c = this.value;
    let h;
    return s ? h = e.generateTextureLevel(c, i, n, s, o) : a ? h = e.generateTextureBias(c, i, n, a, o) : u ? h = e.generateTextureGrad(c, i, n, u, o) : l ? h = e.generateTextureCompare(c, i, n, l, o) : this.sampler === !1 ? h = e.generateTextureLoad(c, i, n, o) : h = e.generateTexture(c, i, n, o), h;
  }
  generate(e, i) {
    const n = e.getNodeProperties(this), s = this.value;
    if (!s || s.isTexture !== !0)
      throw new Error("TextureNode: Need a three.js texture.");
    const a = super.generate(e, "property");
    if (i === "sampler")
      return a + "_sampler";
    if (e.isReference(i))
      return a;
    {
      const o = e.getDataFromNode(this);
      let l = o.propertyName;
      if (l === void 0) {
        const { uvNode: h, levelNode: d, biasNode: p, compareNode: f, depthNode: m, gradNode: v } = n, y = this.generateUV(e, h), g = d ? d.build(e, "float") : null, _ = p ? p.build(e, "float") : null, x = m ? m.build(e, "int") : null, b = f ? f.build(e, "float") : null, T = v ? [v[0].build(e, "vec2"), v[1].build(e, "vec2")] : null, S = e.getVarFromNode(this);
        l = e.getPropertyName(S);
        const w = this.generateSnippet(e, a, y, g, _, x, b, T);
        e.addLineFlowCode(`${l} = ${w}`, this), o.snippet = w, o.propertyName = l;
      }
      let u = l;
      const c = this.getNodeType(e);
      return e.needsToWorkingColorSpace(s) && (u = rI(Sd(u, c), s.colorSpace).setup(e).build(e, c)), e.format(u, c, i);
    }
  }
  setSampler(e) {
    return this.sampler = e, this;
  }
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  uv(e) {
    const i = this.clone();
    return i.uvNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  blur(e) {
    const i = this.clone();
    return i.biasNode = De(e).mul(NX(i)), i.referenceNode = this.getSelf(), De(i);
  }
  level(e) {
    const i = this.clone();
    return i.levelNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  size(e) {
    return id(this, e);
  }
  bias(e) {
    const i = this.clone();
    return i.biasNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  compare(e) {
    const i = this.clone();
    return i.compareNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  grad(e, i) {
    const n = this.clone();
    return n.gradNode = [De(e), De(i)], n.referenceNode = this.getSelf(), De(n);
  }
  depth(e) {
    const i = this.clone();
    return i.depthNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  // --
  serialize(e) {
    super.serialize(e), e.value = this.value.toJSON(e.meta).uuid, e.sampler = this.sampler, e.updateMatrix = this.updateMatrix, e.updateType = this.updateType;
  }
  deserialize(e) {
    super.deserialize(e), this.value = e.meta.textures[e.value], this.sampler = e.sampler, this.updateMatrix = e.updateMatrix, this.updateType = e.updateType;
  }
  update() {
    const e = this.value, i = this._matrixUniform;
    i !== null && (i.value = e.matrix), e.matrixAutoUpdate === !0 && e.updateMatrix();
  }
  clone() {
    const e = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
    return e.sampler = this.sampler, e;
  }
}
const Ci = /* @__PURE__ */ Me(tp), kn = (...r) => Ci(...r).setSampler(!1), Yo = /* @__PURE__ */ Tt("float").label("cameraNear").setGroup(Ut).onRenderUpdate(({ camera: r }) => r.near), Ko = /* @__PURE__ */ Tt("float").label("cameraFar").setGroup(Ut).onRenderUpdate(({ camera: r }) => r.far), Wm = /* @__PURE__ */ Tt("mat4").label("cameraProjectionMatrix").setGroup(Ut).onRenderUpdate(({ camera: r }) => r.projectionMatrix), Aa = /* @__PURE__ */ Tt("mat4").label("cameraViewMatrix").setGroup(Ut).onRenderUpdate(({ camera: r }) => r.matrixWorldInverse), PX = /* @__PURE__ */ Tt(new oe()).label("cameraPosition").setGroup(Ut).onRenderUpdate(({ camera: r }, e) => e.value.setFromMatrixPosition(r.matrixWorld));
class wi extends Mt {
  static get type() {
    return "Object3DNode";
  }
  constructor(e, i = null) {
    super(), this.scope = e, this.object3d = i, this.updateType = Rt.OBJECT, this._uniformNode = new Jd(null);
  }
  getNodeType() {
    const e = this.scope;
    if (e === wi.WORLD_MATRIX)
      return "mat4";
    if (e === wi.POSITION || e === wi.VIEW_POSITION || e === wi.DIRECTION || e === wi.SCALE)
      return "vec3";
  }
  update(e) {
    const i = this.object3d, n = this._uniformNode, s = this.scope;
    if (s === wi.WORLD_MATRIX)
      n.value = i.matrixWorld;
    else if (s === wi.POSITION)
      n.value = n.value || new oe(), n.value.setFromMatrixPosition(i.matrixWorld);
    else if (s === wi.SCALE)
      n.value = n.value || new oe(), n.value.setFromMatrixScale(i.matrixWorld);
    else if (s === wi.DIRECTION)
      n.value = n.value || new oe(), i.getWorldDirection(n.value);
    else if (s === wi.VIEW_POSITION) {
      const a = e.camera;
      n.value = n.value || new oe(), n.value.setFromMatrixPosition(i.matrixWorld), n.value.applyMatrix4(a.matrixWorldInverse);
    }
  }
  generate(e) {
    const i = this.scope;
    return i === wi.WORLD_MATRIX ? this._uniformNode.nodeType = "mat4" : (i === wi.POSITION || i === wi.VIEW_POSITION || i === wi.DIRECTION || i === wi.SCALE) && (this._uniformNode.nodeType = "vec3"), this._uniformNode.build(e);
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
wi.WORLD_MATRIX = "worldMatrix";
wi.POSITION = "position";
wi.SCALE = "scale";
wi.VIEW_POSITION = "viewPosition";
wi.DIRECTION = "direction";
class wc extends wi {
  static get type() {
    return "ModelNode";
  }
  constructor(e) {
    super(e);
  }
  update(e) {
    this.object3d = e.object, super.update(e);
  }
}
wc.DIRECTION;
const Al = /* @__PURE__ */ Ve(wc, wc.WORLD_MATRIX);
wc.POSITION;
wc.SCALE;
wc.VIEW_POSITION;
const IX = /* @__PURE__ */ Tt(new Xr()).onObjectUpdate(({ object: r }, e) => e.value.getNormalMatrix(r.matrixWorld)), kg = /* @__PURE__ */ Aa.mul(Al).toVar("modelViewMatrix"), aI = /* @__PURE__ */ Ta("position", "vec3"), sr = /* @__PURE__ */ aI.varying("positionLocal"), hM = /* @__PURE__ */ aI.varying("positionPrevious"), Tx = /* @__PURE__ */ Al.mul(sr).xyz.varying("v_positionWorld"), oI = /* @__PURE__ */ sr.transformDirection(Al).varying("v_positionWorldDirection").normalize().toVar("positionWorldDirection"), rr = /* @__PURE__ */ kg.mul(sr).xyz.varying("v_positionView"), vi = /* @__PURE__ */ rr.negate().varying("v_positionViewDirection").normalize().toVar("positionViewDirection");
class OX extends Mt {
  static get type() {
    return "FrontFacingNode";
  }
  constructor() {
    super("bool"), this.isFrontFacingNode = !0;
  }
  generate(e) {
    const { renderer: i, material: n } = e;
    return i.coordinateSystem === Yn && n.side === Zn ? "false" : e.getFrontFacing();
  }
}
const DX = /* @__PURE__ */ Ve(OX), Fg = /* @__PURE__ */ ve(DX).mul(2).sub(1), lI = /* @__PURE__ */ Ta("normal", "vec3"), _s = /* @__PURE__ */ Fe((r) => r.geometry.hasAttribute("normal") === !1 ? (console.warn('TSL.NormalNode: Vertex attribute "normal" not found on geometry.'), ye(0, 1, 0)) : lI, "vec3").once()().toVar("normalLocal"), LX = /* @__PURE__ */ rr.dFdx().cross(rr.dFdy()).normalize().toVar("normalFlat"), Jn = /* @__PURE__ */ Fe((r) => {
  let e;
  return r.material.flatShading === !0 ? e = LX : e = Ma(cI(_s), "v_normalView").normalize(), e;
}, "vec3").once()().toVar("normalView"), uI = /* @__PURE__ */ Ma(Jn.transformDirection(Aa), "v_normalWorld").normalize().toVar("normalWorld"), ki = /* @__PURE__ */ Fe((r) => r.context.setupNormal(), "vec3").once()().mul(Fg).toVar("transformedNormalView"), NT = /* @__PURE__ */ ki.transformDirection(Aa).toVar("transformedNormalWorld"), jh = /* @__PURE__ */ Fe((r) => r.context.setupClearcoatNormal(), "vec3").once()().mul(Fg).toVar("transformedClearcoatNormalView"), UX = /* @__PURE__ */ Fe(([r, e = Al]) => {
  const i = Rr(e), n = r.div(ye(i[0].dot(i[0]), i[1].dot(i[1]), i[2].dot(i[2])));
  return i.mul(n).xyz;
}), cI = /* @__PURE__ */ Fe(([r], e) => {
  const i = e.renderer.nodes.modelNormalViewMatrix;
  if (i !== null)
    return i.transformDirection(r);
  const n = IX.mul(r);
  return Aa.transformDirection(n);
}), kX = /* @__PURE__ */ Tt(0).onReference(({ material: r }) => r).onRenderUpdate(({ material: r }) => r.refractionRatio), FX = /* @__PURE__ */ vi.negate().reflect(ki), BX = /* @__PURE__ */ vi.negate().refract(ki, kX), zX = /* @__PURE__ */ FX.transformDirection(Aa).toVar("reflectVector"), jX = /* @__PURE__ */ BX.transformDirection(Aa).toVar("reflectVector");
class VX extends tp {
  static get type() {
    return "CubeTextureNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e, i, n, s), this.isCubeTextureNode = !0;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    const e = this.value;
    return e.mapping === Tl ? zX : e.mapping === _c ? jX : (console.error('THREE.CubeTextureNode: Mapping "%s" not supported.', e.mapping), ye(0, 0, 0));
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  setupUV(e, i) {
    const n = this.value;
    return e.renderer.coordinateSystem === wl || !n.isRenderTargetTexture ? ye(i.x.negate(), i.yz) : i;
  }
  generateUV(e, i) {
    return i.build(e, "vec3");
  }
}
const wd = /* @__PURE__ */ Me(VX);
class hI extends Jd {
  static get type() {
    return "BufferNode";
  }
  constructor(e, i, n = 0) {
    super(e, i), this.isBufferNode = !0, this.bufferType = i, this.bufferCount = n;
  }
  getElementType(e) {
    return this.getNodeType(e);
  }
  getInputType() {
    return "buffer";
  }
}
const PT = (r, e, i) => De(new hI(r, e, i));
class GX extends Qd {
  static get type() {
    return "UniformArrayElementNode";
  }
  constructor(e, i) {
    super(e, i), this.isArrayBufferElementNode = !0;
  }
  generate(e) {
    const i = super.generate(e), n = this.getNodeType();
    return e.format(i, "vec4", n);
  }
}
class HX extends hI {
  static get type() {
    return "UniformArrayNode";
  }
  constructor(e, i = null) {
    super(null, "vec4"), this.array = e, this.elementType = i, this._elementType = null, this._elementLength = 0, this.updateType = Rt.RENDER, this.isArrayBufferNode = !0;
  }
  getElementType() {
    return this.elementType || this._elementType;
  }
  getElementLength() {
    return this._elementLength;
  }
  update() {
    const { array: e, value: i } = this, n = this.getElementLength(), s = this.getElementType();
    if (n === 1)
      for (let a = 0; a < e.length; a++) {
        const o = a * 4;
        i[o] = e[a];
      }
    else if (s === "color")
      for (let a = 0; a < e.length; a++) {
        const o = a * 4, l = e[a];
        i[o] = l.r, i[o + 1] = l.g, i[o + 2] = l.b || 0;
      }
    else
      for (let a = 0; a < e.length; a++) {
        const o = a * 4, l = e[a];
        i[o] = l.x, i[o + 1] = l.y, i[o + 2] = l.z || 0, i[o + 3] = l.w || 0;
      }
  }
  setup(e) {
    const i = this.array.length;
    this._elementType = this.elementType === null ? Bm(this.array[0]) : this.elementType, this._elementLength = e.getTypeLength(this._elementType);
    let n = Float32Array;
    return this._elementType.charAt(0) === "i" ? n = Int32Array : this._elementType.charAt(0) === "u" && (n = Uint32Array), this.value = new n(i * 4), this.bufferCount = i, this.bufferType = e.changeComponentType("vec4", e.getComponentType(this._elementType)), super.setup(e);
  }
  element(e) {
    return De(new GX(this, De(e)));
  }
}
const Ed = (r, e) => De(new HX(r, e));
class WX extends Qd {
  static get type() {
    return "ReferenceElementNode";
  }
  constructor(e, i) {
    super(e, i), this.referenceNode = e, this.isReferenceElementNode = !0;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(e) {
    const i = super.generate(e), n = this.referenceNode.getNodeType(), s = this.getNodeType();
    return e.format(i, n, s);
  }
}
class IT extends Mt {
  static get type() {
    return "ReferenceNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.property = e, this.uniformType = i, this.object = n, this.count = s, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.name = null, this.updateType = Rt.OBJECT;
  }
  element(e) {
    return De(new WX(this, De(e)));
  }
  setGroup(e) {
    return this.group = e, this;
  }
  label(e) {
    return this.name = e, this;
  }
  setNodeType(e) {
    let i = null;
    this.count !== null ? i = PT(null, e, this.count) : Array.isArray(this.getValueFromReference()) ? i = Ed(null, e) : e === "texture" ? i = Ci(null) : e === "cubeTexture" ? i = wd(null) : i = Tt(null, e), this.group !== null && i.setGroup(this.group), this.name !== null && i.label(this.name), this.node = i.getSelf();
  }
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  getValueFromReference(e = this.reference) {
    const { properties: i } = this;
    let n = e[i[0]];
    for (let s = 1; s < i.length; s++)
      n = n[i[s]];
    return n;
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setup() {
    return this.updateValue(), this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const bi = (r, e, i) => De(new IT(r, e, i)), dM = (r, e, i, n) => De(new IT(r, e, n, i));
class qX extends IT {
  static get type() {
    return "MaterialReferenceNode";
  }
  constructor(e, i, n = null) {
    super(e, i, n), this.material = n, this.isMaterialReferenceNode = !0;
  }
  /*setNodeType( node ) {
  
  		super.setNodeType( node );
  
  		this.node.groupNode = renderGroup;
  
  	}*/
  updateReference(e) {
    return this.reference = this.material !== null ? this.material : e.material, this.reference;
  }
}
const to = (r, e, i) => De(new qX(r, e, i)), dI = /* @__PURE__ */ Fe((r) => (r.geometry.hasAttribute("tangent") === !1 && r.geometry.computeTangents(), Ta("tangent", "vec4")))(), OT = /* @__PURE__ */ dI.xyz.toVar("tangentLocal"), pI = /* @__PURE__ */ kg.mul(_t(OT, 0)).xyz.varying("v_tangentView").normalize().toVar("tangentView"), XX = (r) => r.mul(dI.w).xyz, $X = /* @__PURE__ */ Ma(XX(Jn.cross(pI)), "v_bitangentView").normalize().toVar("bitangentView"), Vh = /* @__PURE__ */ Rr(pI, $X, Jn), YX = /* @__PURE__ */ (() => {
  let r = ec.cross(vi);
  return r = r.cross(ec).normalize(), r = li(r, ki, Ho.mul(ia.oneMinus()).oneMinus().pow2().pow2()).normalize(), r;
})(), KX = /* @__PURE__ */ Fe((r) => {
  const { eye_pos: e, surf_norm: i, mapN: n, uv: s } = r, a = e.dFdx(), o = e.dFdy(), l = s.dFdx(), u = s.dFdy(), c = i, h = o.cross(c), d = c.cross(a), p = h.mul(l.x).add(d.mul(u.x)), f = h.mul(l.y).add(d.mul(u.y)), m = p.dot(p).max(f.dot(f)), v = Fg.mul(m.inverseSqrt());
  return Nr(p.mul(n.x, v), f.mul(n.y, v), c.mul(n.z)).normalize();
});
class ZX extends zi {
  static get type() {
    return "NormalMapNode";
  }
  constructor(e, i = null) {
    super("vec3"), this.node = e, this.scaleNode = i, this.normalMapType = vo;
  }
  setup(e) {
    const { normalMapType: i, scaleNode: n } = this;
    let s = this.node.mul(2).sub(1);
    n !== null && (s = ye(s.xy.mul(n), s.z));
    let a = null;
    return i === W9 ? a = cI(s) : i === vo && (e.hasGeometryAttribute("tangent") === !0 ? a = Vh.mul(s).normalize() : a = KX({
      eye_pos: rr,
      surf_norm: Jn,
      mapN: s,
      uv: Ug()
    })), a;
  }
}
const pM = /* @__PURE__ */ Me(ZX), QX = Fe(({ textureNode: r, bumpScale: e }) => {
  const i = (s) => r.cache().context({ getUV: (a) => s(a.uvNode || Ug()), forceUVContext: !0 }), n = ve(i((s) => s));
  return He(
    ve(i((s) => s.add(s.dFdx()))).sub(n),
    ve(i((s) => s.add(s.dFdy()))).sub(n)
  ).mul(e);
}), JX = Fe((r) => {
  const { surf_pos: e, surf_norm: i, dHdxy: n } = r, s = e.dFdx().normalize(), a = e.dFdy().normalize(), o = i, l = a.cross(o), u = o.cross(s), c = s.dot(l).mul(Fg), h = c.sign().mul(n.x.mul(l).add(n.y.mul(u)));
  return c.abs().mul(i).sub(h).normalize();
});
class e$ extends zi {
  static get type() {
    return "BumpMapNode";
  }
  constructor(e, i = null) {
    super("vec3"), this.textureNode = e, this.scaleNode = i;
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1, i = QX({ textureNode: this.textureNode, bumpScale: e });
    return JX({
      surf_pos: rr,
      surf_norm: Jn,
      dHdxy: i
    });
  }
}
const t$ = /* @__PURE__ */ Me(e$), fM = /* @__PURE__ */ new Map();
class pe extends Mt {
  static get type() {
    return "MaterialNode";
  }
  constructor(e) {
    super(), this.scope = e;
  }
  getCache(e, i) {
    let n = fM.get(e);
    return n === void 0 && (n = to(e, i), fM.set(e, n)), n;
  }
  getFloat(e) {
    return this.getCache(e, "float");
  }
  getColor(e) {
    return this.getCache(e, "color");
  }
  getTexture(e) {
    return this.getCache(e === "map" ? "map" : e + "Map", "texture");
  }
  setup(e) {
    const i = e.context.material, n = this.scope;
    let s = null;
    if (n === pe.COLOR) {
      const a = i.color !== void 0 ? this.getColor(n) : ye();
      i.map && i.map.isTexture === !0 ? s = a.mul(this.getTexture("map")) : s = a;
    } else if (n === pe.OPACITY) {
      const a = this.getFloat(n);
      i.alphaMap && i.alphaMap.isTexture === !0 ? s = a.mul(this.getTexture("alpha")) : s = a;
    } else if (n === pe.SPECULAR_STRENGTH)
      i.specularMap && i.specularMap.isTexture === !0 ? s = this.getTexture("specular").r : s = ve(1);
    else if (n === pe.SPECULAR_INTENSITY) {
      const a = this.getFloat(n);
      i.specularMap ? s = a.mul(this.getTexture(n).a) : s = a;
    } else if (n === pe.SPECULAR_COLOR) {
      const a = this.getColor(n);
      i.specularColorMap && i.specularColorMap.isTexture === !0 ? s = a.mul(this.getTexture(n).rgb) : s = a;
    } else if (n === pe.ROUGHNESS) {
      const a = this.getFloat(n);
      i.roughnessMap && i.roughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).g) : s = a;
    } else if (n === pe.METALNESS) {
      const a = this.getFloat(n);
      i.metalnessMap && i.metalnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).b) : s = a;
    } else if (n === pe.EMISSIVE) {
      const a = this.getFloat("emissiveIntensity"), o = this.getColor(n).mul(a);
      i.emissiveMap && i.emissiveMap.isTexture === !0 ? s = o.mul(this.getTexture(n)) : s = o;
    } else if (n === pe.NORMAL)
      i.normalMap ? (s = pM(this.getTexture("normal"), this.getCache("normalScale", "vec2")), s.normalMapType = i.normalMapType) : i.bumpMap ? s = t$(this.getTexture("bump").r, this.getFloat("bumpScale")) : s = Jn;
    else if (n === pe.CLEARCOAT) {
      const a = this.getFloat(n);
      i.clearcoatMap && i.clearcoatMap.isTexture === !0 ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === pe.CLEARCOAT_ROUGHNESS) {
      const a = this.getFloat(n);
      i.clearcoatRoughnessMap && i.clearcoatRoughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === pe.CLEARCOAT_NORMAL)
      i.clearcoatNormalMap ? s = pM(this.getTexture(n), this.getCache(n + "Scale", "vec2")) : s = Jn;
    else if (n === pe.SHEEN) {
      const a = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      i.sheenColorMap && i.sheenColorMap.isTexture === !0 ? s = a.mul(this.getTexture("sheenColor").rgb) : s = a;
    } else if (n === pe.SHEEN_ROUGHNESS) {
      const a = this.getFloat(n);
      i.sheenRoughnessMap && i.sheenRoughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).a) : s = a, s = s.clamp(0.07, 1);
    } else if (n === pe.ANISOTROPY)
      if (i.anisotropyMap && i.anisotropyMap.isTexture === !0) {
        const a = this.getTexture(n);
        s = _T(xh.x, xh.y, xh.y.negate(), xh.x).mul(a.rg.mul(2).sub(He(1)).normalize().mul(a.b));
      } else
        s = xh;
    else if (n === pe.IRIDESCENCE_THICKNESS) {
      const a = bi("1", "float", i.iridescenceThicknessRange);
      if (i.iridescenceThicknessMap) {
        const o = bi("0", "float", i.iridescenceThicknessRange);
        s = a.sub(o).mul(this.getTexture(n).g).add(o);
      } else
        s = a;
    } else if (n === pe.TRANSMISSION) {
      const a = this.getFloat(n);
      i.transmissionMap ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === pe.THICKNESS) {
      const a = this.getFloat(n);
      i.thicknessMap ? s = a.mul(this.getTexture(n).g) : s = a;
    } else if (n === pe.IOR)
      s = this.getFloat(n);
    else if (n === pe.LIGHT_MAP)
      s = this.getTexture(n).rgb.mul(this.getFloat("lightMapIntensity"));
    else if (n === pe.AO_MAP)
      s = this.getTexture(n).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
    else {
      const a = this.getNodeType(e);
      s = this.getCache(n, a);
    }
    return s;
  }
}
pe.ALPHA_TEST = "alphaTest";
pe.COLOR = "color";
pe.OPACITY = "opacity";
pe.SHININESS = "shininess";
pe.SPECULAR = "specular";
pe.SPECULAR_STRENGTH = "specularStrength";
pe.SPECULAR_INTENSITY = "specularIntensity";
pe.SPECULAR_COLOR = "specularColor";
pe.REFLECTIVITY = "reflectivity";
pe.ROUGHNESS = "roughness";
pe.METALNESS = "metalness";
pe.NORMAL = "normal";
pe.CLEARCOAT = "clearcoat";
pe.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
pe.CLEARCOAT_NORMAL = "clearcoatNormal";
pe.EMISSIVE = "emissive";
pe.ROTATION = "rotation";
pe.SHEEN = "sheen";
pe.SHEEN_ROUGHNESS = "sheenRoughness";
pe.ANISOTROPY = "anisotropy";
pe.IRIDESCENCE = "iridescence";
pe.IRIDESCENCE_IOR = "iridescenceIOR";
pe.IRIDESCENCE_THICKNESS = "iridescenceThickness";
pe.IOR = "ior";
pe.TRANSMISSION = "transmission";
pe.THICKNESS = "thickness";
pe.ATTENUATION_DISTANCE = "attenuationDistance";
pe.ATTENUATION_COLOR = "attenuationColor";
pe.LINE_SCALE = "scale";
pe.LINE_DASH_SIZE = "dashSize";
pe.LINE_GAP_SIZE = "gapSize";
pe.LINE_WIDTH = "linewidth";
pe.LINE_DASH_OFFSET = "dashOffset";
pe.POINT_WIDTH = "pointWidth";
pe.DISPERSION = "dispersion";
pe.LIGHT_MAP = "light";
pe.AO_MAP = "ao";
const i$ = /* @__PURE__ */ Ve(pe, pe.ALPHA_TEST), r$ = /* @__PURE__ */ Ve(pe, pe.COLOR), n$ = /* @__PURE__ */ Ve(pe, pe.SHININESS), s$ = /* @__PURE__ */ Ve(pe, pe.EMISSIVE), fI = /* @__PURE__ */ Ve(pe, pe.OPACITY), a$ = /* @__PURE__ */ Ve(pe, pe.SPECULAR), mM = /* @__PURE__ */ Ve(pe, pe.SPECULAR_INTENSITY), o$ = /* @__PURE__ */ Ve(pe, pe.SPECULAR_COLOR), om = /* @__PURE__ */ Ve(pe, pe.SPECULAR_STRENGTH), Bv = /* @__PURE__ */ Ve(pe, pe.REFLECTIVITY), l$ = /* @__PURE__ */ Ve(pe, pe.ROUGHNESS), u$ = /* @__PURE__ */ Ve(pe, pe.METALNESS), c$ = /* @__PURE__ */ Ve(pe, pe.NORMAL).context({ getUV: null }), h$ = /* @__PURE__ */ Ve(pe, pe.CLEARCOAT), d$ = /* @__PURE__ */ Ve(pe, pe.CLEARCOAT_ROUGHNESS), p$ = /* @__PURE__ */ Ve(pe, pe.CLEARCOAT_NORMAL).context({ getUV: null }), f$ = /* @__PURE__ */ Ve(pe, pe.ROTATION), m$ = /* @__PURE__ */ Ve(pe, pe.SHEEN), g$ = /* @__PURE__ */ Ve(pe, pe.SHEEN_ROUGHNESS), y$ = /* @__PURE__ */ Ve(pe, pe.ANISOTROPY), v$ = /* @__PURE__ */ Ve(pe, pe.IRIDESCENCE), b$ = /* @__PURE__ */ Ve(pe, pe.IRIDESCENCE_IOR), x$ = /* @__PURE__ */ Ve(pe, pe.IRIDESCENCE_THICKNESS), _$ = /* @__PURE__ */ Ve(pe, pe.TRANSMISSION), T$ = /* @__PURE__ */ Ve(pe, pe.THICKNESS), S$ = /* @__PURE__ */ Ve(pe, pe.IOR), w$ = /* @__PURE__ */ Ve(pe, pe.ATTENUATION_DISTANCE), E$ = /* @__PURE__ */ Ve(pe, pe.ATTENUATION_COLOR), M$ = /* @__PURE__ */ Ve(pe, pe.LINE_SCALE), A$ = /* @__PURE__ */ Ve(pe, pe.LINE_DASH_SIZE), C$ = /* @__PURE__ */ Ve(pe, pe.LINE_GAP_SIZE);
pe.LINE_WIDTH;
pe.LINE_DASH_OFFSET;
pe.POINT_WIDTH;
const R$ = /* @__PURE__ */ Ve(pe, pe.DISPERSION), mI = /* @__PURE__ */ Ve(pe, pe.LIGHT_MAP), N$ = /* @__PURE__ */ Ve(pe, pe.AO_MAP), xh = /* @__PURE__ */ Tt(new jt()).onReference(function(r) {
  return r.material;
}).onRenderUpdate(function({ material: r }) {
  this.value.set(r.anisotropy * Math.cos(r.anisotropyRotation), r.anisotropy * Math.sin(r.anisotropyRotation));
});
class P$ extends zi {
  static get type() {
    return "ModelViewProjectionNode";
  }
  constructor(e = null) {
    super("vec4"), this.positionNode = e;
  }
  setup(e) {
    if (e.shaderStage === "fragment")
      return Ma(e.context.mvp);
    const i = this.positionNode || sr, n = e.renderer.nodes.modelViewMatrix || kg;
    return Wm.mul(n).mul(i);
  }
}
const Sx = /* @__PURE__ */ Me(P$);
class Ai extends Mt {
  static get type() {
    return "IndexNode";
  }
  constructor(e) {
    super("uint"), this.scope = e, this.isInstanceIndexNode = !0;
  }
  generate(e) {
    const i = this.getNodeType(e), n = this.scope;
    let s;
    if (n === Ai.VERTEX)
      s = e.getVertexIndex();
    else if (n === Ai.INSTANCE)
      s = e.getInstanceIndex();
    else if (n === Ai.DRAW)
      s = e.getDrawIndex();
    else if (n === Ai.INVOCATION_LOCAL)
      s = e.getInvocationLocalIndex();
    else if (n === Ai.INVOCATION_SUBGROUP)
      s = e.getInvocationSubgroupIndex();
    else if (n === Ai.SUBGROUP)
      s = e.getSubgroupIndex();
    else
      throw new Error("THREE.IndexNode: Unknown scope: " + n);
    let a;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? a = s : a = Ma(this).build(e, i), a;
  }
}
Ai.VERTEX = "vertex";
Ai.INSTANCE = "instance";
Ai.SUBGROUP = "subgroup";
Ai.INVOCATION_LOCAL = "invocationLocal";
Ai.INVOCATION_SUBGROUP = "invocationSubgroup";
Ai.DRAW = "draw";
const I$ = /* @__PURE__ */ Ve(Ai, Ai.VERTEX), DT = /* @__PURE__ */ Ve(Ai, Ai.INSTANCE);
Ai.SUBGROUP;
Ai.INVOCATION_SUBGROUP;
Ai.INVOCATION_LOCAL;
const O$ = /* @__PURE__ */ Ve(Ai, Ai.DRAW);
class D$ extends Mt {
  static get type() {
    return "InstanceNode";
  }
  constructor(e) {
    super("void"), this.instanceMesh = e, this.instanceMatrixNode = null, this.instanceColorNode = null, this.updateType = Rt.FRAME, this.buffer = null, this.bufferColor = null;
  }
  setup(e) {
    let i = this.instanceMatrixNode, n = this.instanceColorNode;
    const s = this.instanceMesh;
    if (i === null) {
      const l = s.instanceMatrix;
      if (s.count <= 1e3)
        i = PT(l.array, "mat4", Math.max(s.count, 1)).element(DT);
      else {
        const u = new cW(l.array, 16, 1);
        this.buffer = u;
        const c = l.usage === ku ? cM : uM, h = [
          // F.Signature -> bufferAttribute( array, type, stride, offset )
          c(u, "vec4", 16, 0),
          c(u, "vec4", 16, 4),
          c(u, "vec4", 16, 8),
          c(u, "vec4", 16, 12)
        ];
        i = Ju(...h);
      }
      this.instanceMatrixNode = i;
    }
    const a = s.instanceColor;
    if (a && n === null) {
      const l = new K7(a.array, 3), u = a.usage === ku ? cM : uM;
      this.bufferColor = l, n = ye(u(l, "vec3", 3, 0)), this.instanceColorNode = n;
    }
    const o = i.mul(sr).xyz;
    if (sr.assign(o), e.hasGeometryAttribute("normal")) {
      const l = UX(_s, i);
      _s.assign(l);
    }
    this.instanceColorNode !== null && jm("vec3", "vInstanceColor").assign(this.instanceColorNode);
  }
  update() {
    this.instanceMesh.instanceMatrix.usage !== ku && this.buffer != null && this.instanceMesh.instanceMatrix.version !== this.buffer.version && (this.buffer.version = this.instanceMesh.instanceMatrix.version), this.instanceMesh.instanceColor && this.instanceMesh.instanceColor.usage !== ku && this.bufferColor != null && this.instanceMesh.instanceColor.version !== this.bufferColor.version && (this.bufferColor.version = this.instanceMesh.instanceColor.version);
  }
}
const L$ = /* @__PURE__ */ Me(D$);
class U$ extends Mt {
  static get type() {
    return "BatchNode";
  }
  constructor(e) {
    super("void"), this.batchMesh = e, this.batchingIdNode = null;
  }
  setup(e) {
    this.batchingIdNode === null && (e.getDrawIndex() === null ? this.batchingIdNode = DT : this.batchingIdNode = O$);
    const i = Fe(([f]) => {
      const m = id(kn(this.batchMesh._indirectTexture), 0), v = Mi(f).modInt(Mi(m)), y = Mi(f).div(Mi(m));
      return kn(this.batchMesh._indirectTexture, Ks(v, y)).x;
    }).setLayout({
      name: "getIndirectIndex",
      type: "uint",
      inputs: [
        { name: "id", type: "int" }
      ]
    })(Mi(this.batchingIdNode)), n = this.batchMesh._matricesTexture, s = id(kn(n), 0), a = ve(i).mul(4).toInt().toVar(), o = a.modInt(s), l = a.div(Mi(s)), u = Ju(
      kn(n, Ks(o, l)),
      kn(n, Ks(o.add(1), l)),
      kn(n, Ks(o.add(2), l)),
      kn(n, Ks(o.add(3), l))
    ), c = this.batchMesh._colorsTexture;
    if (c !== null) {
      const f = Fe(([m]) => {
        const v = id(kn(c), 0).x, y = m, g = y.modInt(v), _ = y.div(v);
        return kn(c, Ks(g, _)).rgb;
      }).setLayout({
        name: "getBatchingColor",
        type: "vec3",
        inputs: [
          { name: "id", type: "int" }
        ]
      })(i);
      jm("vec3", "vBatchColor").assign(f);
    }
    const h = Rr(u);
    sr.assign(u.mul(sr));
    const d = _s.div(ye(h[0].dot(h[0]), h[1].dot(h[1]), h[2].dot(h[2]))), p = h.mul(d).xyz;
    _s.assign(p), e.hasGeometryAttribute("tangent") && OT.mulAssign(h);
  }
}
const k$ = /* @__PURE__ */ Me(U$), gM = /* @__PURE__ */ new WeakMap();
class F$ extends Mt {
  static get type() {
    return "SkinningNode";
  }
  constructor(e, i = !1) {
    super("void"), this.skinnedMesh = e, this.useReference = i, this.updateType = Rt.OBJECT, this.skinIndexNode = Ta("skinIndex", "uvec4"), this.skinWeightNode = Ta("skinWeight", "vec4");
    let n, s, a;
    i ? (n = bi("bindMatrix", "mat4"), s = bi("bindMatrixInverse", "mat4"), a = dM("skeleton.boneMatrices", "mat4", e.skeleton.bones.length)) : (n = Tt(e.bindMatrix, "mat4"), s = Tt(e.bindMatrixInverse, "mat4"), a = PT(e.skeleton.boneMatrices, "mat4", e.skeleton.bones.length)), this.bindMatrixNode = n, this.bindMatrixInverseNode = s, this.boneMatricesNode = a, this.previousBoneMatricesNode = null;
  }
  getSkinnedPosition(e = this.boneMatricesNode, i = sr) {
    const { skinIndexNode: n, skinWeightNode: s, bindMatrixNode: a, bindMatrixInverseNode: o } = this, l = e.element(n.x), u = e.element(n.y), c = e.element(n.z), h = e.element(n.w), d = a.mul(i), p = Nr(
      l.mul(s.x).mul(d),
      u.mul(s.y).mul(d),
      c.mul(s.z).mul(d),
      h.mul(s.w).mul(d)
    );
    return o.mul(p).xyz;
  }
  getSkinnedNormal(e = this.boneMatricesNode, i = _s) {
    const { skinIndexNode: n, skinWeightNode: s, bindMatrixNode: a, bindMatrixInverseNode: o } = this, l = e.element(n.x), u = e.element(n.y), c = e.element(n.z), h = e.element(n.w);
    let d = Nr(
      s.x.mul(l),
      s.y.mul(u),
      s.z.mul(c),
      s.w.mul(h)
    );
    return d = o.mul(d).mul(a), d.transformDirection(i).xyz;
  }
  getPreviousSkinnedPosition(e) {
    const i = e.object;
    return this.previousBoneMatricesNode === null && (i.skeleton.previousBoneMatrices = new Float32Array(i.skeleton.boneMatrices), this.previousBoneMatricesNode = dM("skeleton.previousBoneMatrices", "mat4", i.skeleton.bones.length)), this.getSkinnedPosition(this.previousBoneMatricesNode, hM);
  }
  needsPreviousBoneMatrices(e) {
    const i = e.renderer.getMRT();
    return i && i.has("velocity");
  }
  setup(e) {
    this.needsPreviousBoneMatrices(e) && hM.assign(this.getPreviousSkinnedPosition(e));
    const i = this.getSkinnedPosition();
    if (sr.assign(i), e.hasGeometryAttribute("normal")) {
      const n = this.getSkinnedNormal();
      _s.assign(n), e.hasGeometryAttribute("tangent") && OT.assign(n);
    }
  }
  generate(e, i) {
    if (i !== "void")
      return sr.build(e, i);
  }
  update(e) {
    const i = (this.useReference ? e.object : this.skinnedMesh).skeleton;
    gM.get(i) !== e.frameId && (gM.set(i, e.frameId), this.previousBoneMatricesNode !== null && i.previousBoneMatrices.set(i.boneMatrices), i.update());
  }
}
const B$ = (r) => De(new F$(r, !0));
class z$ extends Mt {
  static get type() {
    return "LoopNode";
  }
  constructor(e = []) {
    super(), this.params = e;
  }
  getVarName(e) {
    return String.fromCharCode(105 + e);
  }
  getProperties(e) {
    const i = e.getNodeProperties(this);
    if (i.stackNode !== void 0) return i;
    const n = {};
    for (let a = 0, o = this.params.length - 1; a < o; a++) {
      const l = this.params[a], u = l.isNode !== !0 && l.name || this.getVarName(a), c = l.isNode !== !0 && l.type || "int";
      n[u] = Sd(u, c);
    }
    const s = e.addStack();
    return i.returnsNode = this.params[this.params.length - 1](n, s, e), i.stackNode = s, e.removeStack(), i;
  }
  getNodeType(e) {
    const { returnsNode: i } = this.getProperties(e);
    return i ? i.getNodeType(e) : "void";
  }
  setup(e) {
    this.getProperties(e);
  }
  generate(e) {
    const i = this.getProperties(e), n = this.params, s = i.stackNode;
    for (let l = 0, u = n.length - 1; l < u; l++) {
      const c = n[l];
      let h = null, d = null, p = null, f = null, m = null, v = null;
      c.isNode ? (f = "int", p = this.getVarName(l), h = "0", d = c.build(e, f), m = "<") : (f = c.type || "int", p = c.name || this.getVarName(l), h = c.start, d = c.end, m = c.condition, v = c.update, typeof h == "number" ? h = e.generateConst(f, h) : h && h.isNode && (h = h.build(e, f)), typeof d == "number" ? d = e.generateConst(f, d) : d && d.isNode && (d = d.build(e, f)), h !== void 0 && d === void 0 ? (h = h + " - 1", d = "0", m = ">=") : d !== void 0 && h === void 0 && (h = "0", m = "<"), m === void 0 && (Number(h) > Number(d) ? m = ">=" : m = "<"));
      const y = { start: h, end: d }, g = y.start, _ = y.end;
      let x = "", b = "", T = "";
      v || (f === "int" || f === "uint" ? m.includes("<") ? v = "++" : v = "--" : m.includes("<") ? v = "+= 1." : v = "-= 1."), x += e.getVar(f, p) + " = " + g, b += p + " " + m + " " + _, T += p + " " + v;
      const S = `for ( ${x}; ${b}; ${T} )`;
      e.addFlowCode((l === 0 ? `
` : "") + e.tab + S + ` {

`).addFlowTab();
    }
    const a = s.build(e, "void"), o = i.returnsNode ? i.returnsNode.build(e) : "";
    e.removeFlowTab().addFlowCode(`
` + e.tab + a);
    for (let l = 0, u = this.params.length - 1; l < u; l++)
      e.addFlowCode((l === 0 ? "" : e.tab) + `}

`).removeFlowTab();
    return e.addFlowTab(), o;
  }
}
const ps = (...r) => De(new z$(Qu(r, "int"))).append(), j$ = () => Sd("break").append(), zv = /* @__PURE__ */ new WeakMap(), tn = /* @__PURE__ */ new $t(), yM = /* @__PURE__ */ Fe(({ bufferMap: r, influence: e, stride: i, width: n, depth: s, offset: a }) => {
  const o = Mi(I$).mul(i).add(a), l = o.div(n), u = o.sub(l.mul(n));
  return kn(r, Ks(u, l)).depth(s).mul(e);
});
function V$(r) {
  const e = r.morphAttributes.position !== void 0, i = r.morphAttributes.normal !== void 0, n = r.morphAttributes.color !== void 0, s = r.morphAttributes.position || r.morphAttributes.normal || r.morphAttributes.color, a = s !== void 0 ? s.length : 0;
  let o = zv.get(r);
  if (o === void 0 || o.count !== a) {
    let l = function() {
      y.dispose(), zv.delete(r), r.removeEventListener("dispose", l);
    };
    o !== void 0 && o.texture.dispose();
    const u = r.morphAttributes.position || [], c = r.morphAttributes.normal || [], h = r.morphAttributes.color || [];
    let d = 0;
    e === !0 && (d = 1), i === !0 && (d = 2), n === !0 && (d = 3);
    let p = r.attributes.position.count * d, f = 1;
    const m = 4096;
    p > m && (f = Math.ceil(p / m), p = m);
    const v = new Float32Array(p * f * 4 * a), y = new N7(v, p, f, a);
    y.type = on, y.needsUpdate = !0;
    const g = d * 4;
    for (let _ = 0; _ < a; _++) {
      const x = u[_], b = c[_], T = h[_], S = p * f * 4 * _;
      for (let w = 0; w < x.count; w++) {
        const A = w * g;
        e === !0 && (tn.fromBufferAttribute(x, w), v[S + A + 0] = tn.x, v[S + A + 1] = tn.y, v[S + A + 2] = tn.z, v[S + A + 3] = 0), i === !0 && (tn.fromBufferAttribute(b, w), v[S + A + 4] = tn.x, v[S + A + 5] = tn.y, v[S + A + 6] = tn.z, v[S + A + 7] = 0), n === !0 && (tn.fromBufferAttribute(T, w), v[S + A + 8] = tn.x, v[S + A + 9] = tn.y, v[S + A + 10] = tn.z, v[S + A + 11] = T.itemSize === 4 ? tn.w : 1);
      }
    }
    o = {
      count: a,
      texture: y,
      stride: d,
      size: new jt(p, f)
    }, zv.set(r, o), r.addEventListener("dispose", l);
  }
  return o;
}
class G$ extends Mt {
  static get type() {
    return "MorphNode";
  }
  constructor(e) {
    super("void"), this.mesh = e, this.morphBaseInfluence = Tt(1), this.updateType = Rt.OBJECT;
  }
  setup(e) {
    const { geometry: i } = e, n = i.morphAttributes.position !== void 0, s = i.hasAttribute("normal") && i.morphAttributes.normal !== void 0, a = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color, o = a !== void 0 ? a.length : 0, { texture: l, stride: u, size: c } = V$(i);
    n === !0 && sr.mulAssign(this.morphBaseInfluence), s === !0 && _s.mulAssign(this.morphBaseInfluence);
    const h = Mi(c.width);
    ps(o, ({ i: d }) => {
      const p = ve(0).toVar();
      this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0 ? p.assign(kn(this.mesh.morphTexture, Ks(Mi(d).add(1), Mi(DT))).r) : p.assign(bi("morphTargetInfluences", "float").element(d).toVar()), n === !0 && sr.addAssign(yM({
        bufferMap: l,
        influence: p,
        stride: u,
        width: h,
        depth: d,
        offset: Mi(0)
      })), s === !0 && _s.addAssign(yM({
        bufferMap: l,
        influence: p,
        stride: u,
        width: h,
        depth: d,
        offset: Mi(1)
      }));
    });
  }
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative ? e.value = 1 : e.value = 1 - this.mesh.morphTargetInfluences.reduce((i, n) => i + n, 0);
  }
}
const H$ = /* @__PURE__ */ Me(G$);
class Gc extends Mt {
  static get type() {
    return "LightingNode";
  }
  constructor() {
    super("vec3"), this.isLightingNode = !0;
  }
  generate() {
    console.warn("Abstract function.");
  }
}
class W$ extends Gc {
  static get type() {
    return "AONode";
  }
  constructor(e = null) {
    super(), this.aoNode = e;
  }
  setup(e) {
    e.context.ambientOcclusion.mulAssign(this.aoNode);
  }
}
class q$ extends tI {
  static get type() {
    return "LightingContextNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e), this.lightingModel = i, this.backdropNode = n, this.backdropAlphaNode = s, this._value = null;
  }
  getContext() {
    const { backdropNode: e, backdropAlphaNode: i } = this, n = ye().toVar("directDiffuse"), s = ye().toVar("directSpecular"), a = ye().toVar("indirectDiffuse"), o = ye().toVar("indirectSpecular"), l = {
      directDiffuse: n,
      directSpecular: s,
      indirectDiffuse: a,
      indirectSpecular: o
    };
    return {
      radiance: ye().toVar("radiance"),
      irradiance: ye().toVar("irradiance"),
      iblIrradiance: ye().toVar("iblIrradiance"),
      ambientOcclusion: ve(1).toVar("ambientOcclusion"),
      reflectedLight: l,
      backdrop: e,
      backdropAlpha: i
    };
  }
  setup(e) {
    return this.value = this._value || (this._value = this.getContext()), this.value.lightingModel = this.lightingModel || e.context.lightingModel, super.setup(e);
  }
}
const X$ = /* @__PURE__ */ Me(q$);
class $$ extends Gc {
  static get type() {
    return "IrradianceNode";
  }
  constructor(e) {
    super(), this.node = e;
  }
  setup(e) {
    e.context.irradiance.addAssign(this.node);
  }
}
let _h, Th;
class Ui extends Mt {
  static get type() {
    return "ScreenNode";
  }
  constructor(e) {
    super(), this.scope = e, this.isViewportNode = !0;
  }
  getNodeType() {
    return this.scope === Ui.VIEWPORT ? "vec4" : "vec2";
  }
  getUpdateType() {
    let e = Rt.NONE;
    return (this.scope === Ui.SIZE || this.scope === Ui.VIEWPORT) && (e = Rt.RENDER), this.updateType = e, e;
  }
  update({ renderer: e }) {
    const i = e.getRenderTarget();
    this.scope === Ui.VIEWPORT ? i !== null ? Th.copy(i.viewport) : (e.getViewport(Th), Th.multiplyScalar(e.getPixelRatio())) : i !== null ? (_h.width = i.width, _h.height = i.height) : e.getDrawingBufferSize(_h);
  }
  setup() {
    const e = this.scope;
    let i = null;
    return e === Ui.SIZE ? i = Tt(_h || (_h = new jt())) : e === Ui.VIEWPORT ? i = Tt(Th || (Th = new $t())) : i = He(LT.div(wx)), i;
  }
  generate(e) {
    if (this.scope === Ui.COORDINATE) {
      let i = e.getFragCoord();
      if (e.isFlipY()) {
        const n = e.getNodeProperties(wx).outputNode.build(e);
        i = `${e.getType("vec2")}( ${i}.x, ${n}.y - ${i}.y )`;
      }
      return i;
    }
    return super.generate(e);
  }
}
Ui.COORDINATE = "coordinate";
Ui.VIEWPORT = "viewport";
Ui.SIZE = "size";
Ui.UV = "uv";
const Md = /* @__PURE__ */ Ve(Ui, Ui.UV), wx = /* @__PURE__ */ Ve(Ui, Ui.SIZE), LT = /* @__PURE__ */ Ve(Ui, Ui.COORDINATE), gI = /* @__PURE__ */ Ve(Ui, Ui.VIEWPORT);
gI.zw;
gI.xy;
const Sh = /* @__PURE__ */ new jt();
class yI extends tp {
  static get type() {
    return "ViewportTextureNode";
  }
  constructor(e = Md, i = null, n = null) {
    n === null && (n = new J7(), n.minFilter = pa), super(n, e, i), this.generateMipmaps = !1, this.isOutputTextureNode = !0, this.updateBeforeType = Rt.FRAME;
  }
  updateBefore(e) {
    const i = e.renderer;
    i.getDrawingBufferSize(Sh);
    const n = this.value;
    (n.image.width !== Sh.width || n.image.height !== Sh.height) && (n.image.width = Sh.width, n.image.height = Sh.height, n.needsUpdate = !0);
    const s = n.generateMipmaps;
    n.generateMipmaps = this.generateMipmaps, i.copyFramebufferToTexture(n), n.generateMipmaps = s;
  }
  clone() {
    const e = new this.constructor(this.uvNode, this.levelNode, this.value);
    return e.generateMipmaps = this.generateMipmaps, e;
  }
}
const vI = /* @__PURE__ */ Me(yI, null, null, { generateMipmaps: !0 });
let jv = null;
class Y$ extends yI {
  static get type() {
    return "ViewportDepthTextureNode";
  }
  constructor(e = Md, i = null) {
    jv === null && (jv = new jc()), super(e, i, jv);
  }
}
const K$ = /* @__PURE__ */ Me(Y$);
class Br extends Mt {
  static get type() {
    return "ViewportDepthNode";
  }
  constructor(e, i = null) {
    super("float"), this.scope = e, this.valueNode = i, this.isViewportDepthNode = !0;
  }
  generate(e) {
    const { scope: i } = this;
    return i === Br.DEPTH_BASE ? e.getFragDepth() : super.generate(e);
  }
  setup({ camera: e }) {
    const { scope: i } = this, n = this.valueNode;
    let s = null;
    if (i === Br.DEPTH_BASE)
      n !== null && (s = _I().assign(n));
    else if (i === Br.DEPTH)
      e.isPerspectiveCamera ? s = Z$(rr.z, Yo, Ko) : s = rd(rr.z, Yo, Ko);
    else if (i === Br.LINEAR_DEPTH)
      if (n !== null)
        if (e.isPerspectiveCamera) {
          const a = bI(n, Yo, Ko);
          s = rd(a, Yo, Ko);
        } else
          s = n;
      else
        s = rd(rr.z, Yo, Ko);
    return s;
  }
}
Br.DEPTH_BASE = "depthBase";
Br.DEPTH = "depth";
Br.LINEAR_DEPTH = "linearDepth";
const rd = (r, e, i) => r.add(e).div(e.sub(i)), Z$ = (r, e, i) => e.add(r).mul(i).div(i.sub(e).mul(r)), bI = (r, e, i) => e.mul(i).div(i.sub(e).mul(r).sub(i)), xI = (r, e, i) => {
  e = e.max(1e-6).toVar();
  const n = va(r.div(e).add(1)), s = va(i.div(e).add(1));
  return n.div(s);
}, _I = /* @__PURE__ */ Me(Br, Br.DEPTH_BASE), TI = /* @__PURE__ */ Ve(Br, Br.DEPTH);
Br.LINEAR_DEPTH;
K$();
TI.assign = (r) => _I(r);
class xo extends Mt {
  static get type() {
    return "ClippingNode";
  }
  constructor(e = xo.DEFAULT) {
    super(), this.scope = e;
  }
  setup(e) {
    super.setup(e);
    const i = e.clippingContext, { localClipIntersection: n, localClippingCount: s, globalClippingCount: a } = i, o = a + s, l = n ? o - s : o;
    return this.scope === xo.ALPHA_TO_COVERAGE ? this.setupAlphaToCoverage(i.planes, o, l) : this.setupDefault(i.planes, o, l);
  }
  setupAlphaToCoverage(e, i, n) {
    return Fe(() => {
      const s = Ed(e), a = Nu("float", "distanceToPlane"), o = Nu("float", "distanceToGradient"), l = Nu("float", "clipOpacity");
      l.assign(1);
      let u;
      if (ps(n, ({ i: c }) => {
        u = s.element(c), a.assign(rr.dot(u.xyz).negate().add(u.w)), o.assign(a.fwidth().div(2)), l.mulAssign(Ml(o.negate(), o, a)), l.equal(0).discard();
      }), n < i) {
        const c = Nu("float", "unionclipOpacity");
        c.assign(1), ps({ start: n, end: i }, ({ i: h }) => {
          u = s.element(h), a.assign(rr.dot(u.xyz).negate().add(u.w)), o.assign(a.fwidth().div(2)), c.mulAssign(Ml(o.negate(), o, a).oneMinus());
        }), l.mulAssign(c.oneMinus());
      }
      Wt.a.mulAssign(l), Wt.a.equal(0).discard();
    })();
  }
  setupDefault(e, i, n) {
    return Fe(() => {
      const s = Ed(e);
      let a;
      if (ps(n, ({ i: o }) => {
        a = s.element(o), rr.dot(a.xyz).greaterThan(a.w).discard();
      }), n < i) {
        const o = Nu("bool", "clipped");
        o.assign(!0), ps({ start: n, end: i }, ({ i: l }) => {
          a = s.element(l), o.assign(rr.dot(a.xyz).greaterThan(a.w).and(o));
        }), o.discard();
      }
    })();
  }
}
xo.ALPHA_TO_COVERAGE = "alphaToCoverage";
xo.DEFAULT = "default";
const Q$ = () => De(new xo()), J$ = () => De(new xo(xo.ALPHA_TO_COVERAGE)), eY = 0.05, vM = /* @__PURE__ */ Fe(([r]) => To(Dt(1e4, Vn(Dt(17, r.x).add(Dt(0.1, r.y)))).mul(Nr(0.1, Gn(Vn(Dt(13, r.y).add(r.x))))))), bM = /* @__PURE__ */ Fe(([r]) => vM(He(vM(r.xy), r.z))), tY = /* @__PURE__ */ Fe(([r]) => {
  const e = wn(
    fo($P(r.xyz)),
    fo(YP(r.xyz))
  ).toVar("maxDeriv"), i = ve(1).div(ve(eY).mul(e)).toVar("pixScale"), n = He(
    xd(yl(va(i))),
    xd(ET(va(i)))
  ).toVar("pixScales"), s = He(
    bM(yl(n.x.mul(r.xyz))),
    bM(yl(n.y.mul(r.xyz)))
  ).toVar("alpha"), a = To(va(i)).toVar("lerpFactor"), o = Nr(Dt(a.oneMinus(), s.x), Dt(a, s.y)).toVar("x"), l = Td(a, a.oneMinus()).toVar("a"), u = ye(
    o.mul(o).div(Dt(2, l).mul(an(1, l))),
    o.sub(Dt(0.5, l)).div(an(1, l)),
    an(1, an(1, o).mul(an(1, o)).div(Dt(2, l).mul(an(1, l))))
  ).toVar("cases"), c = o.lessThan(l.oneMinus()).select(o.lessThan(l).select(u.x, u.y), u.z);
  return _a(c, 1e-6, 1);
});
class Bi extends Hr {
  static get type() {
    return "NodeMaterial";
  }
  constructor() {
    super(), this.isNodeMaterial = !0, this.type = this.constructor.type, this.forceSinglePass = !1, this.fog = !0, this.lights = !1, this.lightsNode = null, this.envNode = null, this.aoNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.positionNode = null, this.geometryNode = null, this.depthNode = null, this.shadowNode = null, this.shadowPositionNode = null, this.outputNode = null, this.mrtNode = null, this.fragmentNode = null, this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + AP(this);
  }
  build(e) {
    this.setup(e);
  }
  setupObserver(e) {
    return new dW(e);
  }
  setup(e) {
    e.context.setupNormal = () => this.setupNormal(e), e.addStack(), e.stack.outputNode = this.vertexNode || this.setupPosition(e), this.geometryNode !== null && (e.stack.outputNode = e.stack.outputNode.bypass(this.geometryNode)), e.addFlow("vertex", e.removeStack()), e.addStack();
    let i;
    const n = this.setupClipping(e);
    if (this.depthWrite === !0 && this.setupDepth(e), this.fragmentNode === null) {
      this.setupDiffuseColor(e), this.setupVariants(e);
      const s = this.setupLighting(e);
      n !== null && e.stack.add(n);
      const a = _t(s, Wt.a).max(0);
      if (i = this.setupOutput(e, a), KW.assign(i), this.outputNode !== null && (i = this.outputNode), e.renderer.getRenderTarget() !== null) {
        const o = e.renderer.getMRT(), l = this.mrtNode;
        o !== null ? (i = o, l !== null && (i = o.merge(l))) : l !== null && (i = l);
      }
    } else {
      let s = this.fragmentNode;
      s.isOutputStructNode !== !0 && (s = _t(s)), i = this.setupOutput(e, s);
    }
    e.stack.outputNode = i, e.addFlow("fragment", e.removeStack()), e.monitor = this.setupObserver(e);
  }
  setupClipping(e) {
    if (e.clippingContext === null) return null;
    const { globalClippingCount: i, localClippingCount: n } = e.clippingContext;
    let s = null;
    if (i || n) {
      const a = e.renderer.samples;
      this.alphaToCoverage && a > 1 ? s = J$() : e.stack.add(Q$());
    }
    return s;
  }
  setupDepth(e) {
    const { renderer: i, camera: n } = e;
    let s = this.depthNode;
    if (s === null) {
      const a = i.getMRT();
      a && a.has("depth") ? s = a.get("depth") : i.logarithmicDepthBuffer === !0 && (n.isPerspectiveCamera ? s = xI(Sx().w, Yo, Ko) : s = rd(rr.z, Yo, Ko));
    }
    s !== null && TI.assign(s).append();
  }
  setupPosition(e) {
    const { object: i } = e, n = i.geometry;
    if (e.addStack(), (n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color) && H$(i).append(), i.isSkinnedMesh === !0 && B$(i).append(), this.displacementMap) {
      const a = to("displacementMap", "texture"), o = to("displacementScale", "float"), l = to("displacementBias", "float");
      sr.addAssign(_s.normalize().mul(a.x.mul(o).add(l)));
    }
    i.isBatchedMesh && k$(i).append(), i.instanceMatrix && i.instanceMatrix.isInstancedBufferAttribute === !0 && L$(i).append(), this.positionNode !== null && sr.assign(this.positionNode);
    const s = Sx();
    return e.context.vertex = e.removeStack(), e.context.mvp = s, s;
  }
  setupDiffuseColor({ object: e, geometry: i }) {
    let n = this.colorNode ? _t(this.colorNode) : r$;
    this.vertexColors === !0 && i.hasAttribute("color") && (n = _t(n.xyz.mul(Ta("color", "vec3")), n.a)), e.instanceColor && (n = jm("vec3", "vInstanceColor").mul(n)), e.isBatchedMesh && e._colorsTexture && (n = jm("vec3", "vBatchColor").mul(n)), Wt.assign(n);
    const s = this.opacityNode ? ve(this.opacityNode) : fI;
    if (Wt.a.assign(Wt.a.mul(s)), this.alphaTestNode !== null || this.alphaTest > 0) {
      const a = this.alphaTestNode !== null ? ve(this.alphaTestNode) : i$;
      Wt.a.lessThanEqual(a).discard();
    }
    this.alphaHash === !0 && Wt.a.lessThan(tY(sr)).discard(), this.transparent === !1 && this.blending === co && this.alphaToCoverage === !1 && Wt.a.assign(1);
  }
  setupVariants() {
  }
  setupOutgoingLight() {
    return this.lights === !0 ? ye(0) : Wt.rgb;
  }
  setupNormal() {
    return this.normalNode ? ye(this.normalNode) : c$;
  }
  setupEnvironment() {
    let e = null;
    return this.envNode ? e = this.envNode : this.envMap && (e = this.envMap.isCubeTexture ? to("envMap", "cubeTexture") : to("envMap", "texture")), e;
  }
  setupLightMap(e) {
    let i = null;
    return e.material.lightMap && (i = new $$(mI)), i;
  }
  setupLights(e) {
    const i = [], n = this.setupEnvironment(e);
    n && n.isLightingNode && i.push(n);
    const s = this.setupLightMap(e);
    if (s && s.isLightingNode && i.push(s), this.aoNode !== null || e.material.aoMap) {
      const o = this.aoNode !== null ? this.aoNode : N$;
      i.push(new W$(o));
    }
    let a = this.lightsNode || e.lightsNode;
    return i.length > 0 && (a = e.renderer.lighting.createNode([...a.getLights(), ...i])), a;
  }
  setupLightingModel() {
  }
  setupLighting(e) {
    const { material: i } = e, { backdropNode: n, backdropAlphaNode: s, emissiveNode: a } = this, o = this.lights === !0 || this.lightsNode !== null ? this.setupLights(e) : null;
    let l = this.setupOutgoingLight(e);
    if (o && o.getScope().hasLights) {
      const u = this.setupLightingModel(e);
      l = X$(o, u, n, s);
    } else n !== null && (l = ye(s !== null ? li(l, n, s) : n));
    return (a && a.isNode === !0 || i.emissive && i.emissive.isColor === !0) && (oM.assign(ye(a || s$)), l = l.add(oM)), l;
  }
  setupOutput(e, i) {
    if (this.fog === !0) {
      const n = e.fogNode;
      n && (i = _t(n.mix(i.rgb, n.colorNode), i.a));
    }
    return i;
  }
  setDefaultValues(e) {
    for (const n in e) {
      const s = e[n];
      this[n] === void 0 && (this[n] = s, s && s.clone && (this[n] = s.clone()));
    }
    const i = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const n in i)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, n) === void 0 && i[n].get !== void 0 && Object.defineProperty(this.constructor.prototype, n, i[n]);
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    i && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    const n = Hr.prototype.toJSON.call(this, e), s = Fm(this);
    n.inputNodes = {};
    for (const { property: o, childNode: l } of s)
      n.inputNodes[o] = l.toJSON(e).uuid;
    function a(o) {
      const l = [];
      for (const u in o) {
        const c = o[u];
        delete c.metadata, l.push(c);
      }
      return l;
    }
    if (i) {
      const o = a(e.textures), l = a(e.images), u = a(e.nodes);
      o.length > 0 && (n.textures = o), l.length > 0 && (n.images = l), u.length > 0 && (n.nodes = u);
    }
    return n;
  }
  copy(e) {
    return this.lightsNode = e.lightsNode, this.envNode = e.envNode, this.colorNode = e.colorNode, this.normalNode = e.normalNode, this.opacityNode = e.opacityNode, this.backdropNode = e.backdropNode, this.backdropAlphaNode = e.backdropAlphaNode, this.alphaTestNode = e.alphaTestNode, this.positionNode = e.positionNode, this.geometryNode = e.geometryNode, this.depthNode = e.depthNode, this.shadowNode = e.shadowNode, this.shadowPositionNode = e.shadowPositionNode, this.outputNode = e.outputNode, this.mrtNode = e.mrtNode, this.fragmentNode = e.fragmentNode, this.vertexNode = e.vertexNode, super.copy(e);
  }
}
const iY = /* @__PURE__ */ new dT();
class rY extends Bi {
  static get type() {
    return "LineBasicNodeMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicNodeMaterial = !0, this.lights = !1, this.setDefaultValues(iY), this.setValues(e);
  }
}
const nY = /* @__PURE__ */ new wP();
class sY extends Bi {
  static get type() {
    return "LineDashedNodeMaterial";
  }
  constructor(e) {
    super(), this.isLineDashedNodeMaterial = !0, this.lights = !1, this.setDefaultValues(nY), this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setValues(e);
  }
  setupVariants() {
    const e = this.offsetNode, i = this.dashScaleNode ? ve(this.dashScaleNode) : M$, n = this.dashSizeNode ? ve(this.dashSizeNode) : A$, s = this.dashSizeNode ? ve(this.dashGapNode) : C$;
    Fv.assign(n), lM.assign(s);
    const a = Ma(Ta("lineDistance").mul(i));
    (e ? a.add(e) : a).mod(Fv.add(lM)).greaterThan(Fv).discard();
  }
}
const aY = (r) => De(r).mul(0.5).add(0.5), oY = /* @__PURE__ */ new _P();
class lY extends Bi {
  static get type() {
    return "MeshNormalNodeMaterial";
  }
  constructor(e) {
    super(), this.lights = !1, this.isMeshNormalNodeMaterial = !0, this.setDefaultValues(oY), this.setValues(e);
  }
  setupDiffuseColor() {
    const e = this.opacityNode ? ve(this.opacityNode) : fI;
    Wt.assign(_t(aY(ki), e));
  }
}
class uY extends zi {
  static get type() {
    return "EquirectUVNode";
  }
  constructor(e = oI) {
    super("vec2"), this.dirNode = e;
  }
  setup() {
    const e = this.dirNode, i = e.z.atan2(e.x).mul(1 / (Math.PI * 2)).add(0.5), n = e.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return He(i, n);
  }
}
const SI = /* @__PURE__ */ Me(uY);
class wI extends $7 {
  constructor(e = 1, i = {}) {
    super(e, i), this.isCubeRenderTarget = !0;
  }
  fromEquirectangularTexture(e, i) {
    const n = i.minFilter, s = i.generateMipmaps;
    i.generateMipmaps = !0, this.texture.type = i.type, this.texture.colorSpace = i.colorSpace, this.texture.generateMipmaps = i.generateMipmaps, this.texture.minFilter = i.minFilter, this.texture.magFilter = i.magFilter;
    const a = new Zd(5, 5, 5), o = SI(oI), l = new Bi();
    l.colorNode = Ci(i, o, 0), l.side = Zn, l.blending = xc;
    const u = new El(a, l), c = new dP();
    c.add(u), i.minFilter === pa && (i.minFilter = ln);
    const h = new hP(1, 10, this), d = e.getMRT();
    return e.setMRT(null), h.update(e, c), e.setMRT(d), i.minFilter = n, i.currentGenerateMipmaps = s, u.geometry.dispose(), u.material.dispose(), this;
  }
}
const nd = /* @__PURE__ */ new WeakMap();
class cY extends zi {
  static get type() {
    return "CubeMapNode";
  }
  constructor(e) {
    super("vec3"), this.envNode = e, this._cubeTexture = null, this._cubeTextureNode = wd();
    const i = new cT();
    i.isRenderTargetTexture = !0, this._defaultTexture = i, this.updateBeforeType = Rt.RENDER;
  }
  updateBefore(e) {
    const { renderer: i, material: n } = e, s = this.envNode;
    if (s.isTextureNode || s.isMaterialReferenceNode) {
      const a = s.isTextureNode ? s.value : n[s.property];
      if (a && a.isTexture) {
        const o = a.mapping;
        if (o === qd || o === Xd) {
          if (nd.has(a)) {
            const l = nd.get(a);
            xM(l, a.mapping), this._cubeTexture = l;
          } else {
            const l = a.image;
            if (hY(l)) {
              const u = new wI(l.height);
              u.fromEquirectangularTexture(i, a), xM(u.texture, a.mapping), this._cubeTexture = u.texture, nd.set(a, u.texture), a.addEventListener("dispose", EI);
            } else
              this._cubeTexture = this._defaultTexture;
          }
          this._cubeTextureNode.value = this._cubeTexture;
        } else
          this._cubeTextureNode = this.envNode;
      }
    }
  }
  setup(e) {
    return this.updateBefore(e), this._cubeTextureNode;
  }
}
function hY(r) {
  return r == null ? !1 : r.height > 0;
}
function EI(r) {
  const e = r.target;
  e.removeEventListener("dispose", EI);
  const i = nd.get(e);
  i !== void 0 && (nd.delete(e), i.dispose());
}
function xM(r, e) {
  e === qd ? r.mapping = Tl : e === Xd && (r.mapping = _c);
}
const MI = /* @__PURE__ */ Me(cY);
class UT extends Gc {
  static get type() {
    return "BasicEnvironmentNode";
  }
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    e.context.environment = MI(this.envNode);
  }
}
class dY extends Gc {
  static get type() {
    return "BasicLightMapNode";
  }
  constructor(e = null) {
    super(), this.lightMapNode = e;
  }
  setup(e) {
    const i = ve(1 / Math.PI);
    e.context.irradianceLightMap = this.lightMapNode.mul(i);
  }
}
class Bg {
  start() {
  }
  finish() {
  }
  direct() {
  }
  directRectArea() {
  }
  indirect() {
  }
  ambientOcclusion() {
  }
}
class AI extends Bg {
  constructor() {
    super();
  }
  indirect(e, i, n) {
    const s = e.ambientOcclusion, a = e.reflectedLight, o = n.context.irradianceLightMap;
    a.indirectDiffuse.assign(_t(0)), o ? a.indirectDiffuse.addAssign(o) : a.indirectDiffuse.addAssign(_t(1, 1, 1, 0)), a.indirectDiffuse.mulAssign(s), a.indirectDiffuse.mulAssign(Wt.rgb);
  }
  finish(e, i, n) {
    const s = n.material, a = e.outgoingLight, o = n.context.environment;
    if (o)
      switch (s.combine) {
        case Rg:
          a.rgb.assign(li(a.rgb, a.rgb.mul(o.rgb), om.mul(Bv)));
          break;
        case N9:
          a.rgb.assign(li(a.rgb, o.rgb, om.mul(Bv)));
          break;
        case P9:
          a.rgb.addAssign(o.rgb.mul(om.mul(Bv)));
          break;
        default:
          console.warn("THREE.BasicLightingModel: Unsupported .combine value:", s.combine);
          break;
      }
  }
}
const pY = /* @__PURE__ */ new Ng();
class fY extends Bi {
  static get type() {
    return "MeshBasicNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicNodeMaterial = !0, this.lights = !0, this.setDefaultValues(pY), this.setValues(e);
  }
  setupNormal() {
    return Jn;
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new UT(i) : null;
  }
  setupLightMap(e) {
    let i = null;
    return e.material.lightMap && (i = new dY(mI)), i;
  }
  setupOutgoingLight() {
    return Wt.rgb;
  }
  setupLightingModel() {
    return new AI();
  }
}
const Ad = /* @__PURE__ */ Fe(({ f0: r, f90: e, dotVH: i }) => {
  const n = i.mul(-5.55473).sub(6.98316).mul(i).exp2();
  return r.mul(n.oneMinus()).add(e.mul(n));
}), Ec = /* @__PURE__ */ Fe((r) => r.diffuseColor.mul(1 / Math.PI)), mY = () => ve(0.25), gY = /* @__PURE__ */ Fe(({ dotNH: r }) => xx.mul(ve(0.5)).add(1).mul(ve(1 / Math.PI)).mul(r.pow(xx))), yY = /* @__PURE__ */ Fe(({ lightDirection: r }) => {
  const e = r.add(vi).normalize(), i = ki.dot(e).clamp(), n = vi.dot(e).clamp(), s = Ad({ f0: nn, f90: 1, dotVH: n }), a = mY(), o = gY({ dotNH: i });
  return s.mul(a).mul(o);
});
class CI extends AI {
  constructor(e = !0) {
    super(), this.specular = e;
  }
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }) {
    const s = ki.dot(e).clamp().mul(i);
    n.directDiffuse.addAssign(s.mul(Ec({ diffuseColor: Wt.rgb }))), this.specular === !0 && n.directSpecular.addAssign(s.mul(yY({ lightDirection: e })).mul(om));
  }
  indirect({ ambientOcclusion: e, irradiance: i, reflectedLight: n }) {
    n.indirectDiffuse.addAssign(i.mul(Ec({ diffuseColor: Wt }))), n.indirectDiffuse.mulAssign(e);
  }
}
const vY = /* @__PURE__ */ new TP();
class bY extends Bi {
  static get type() {
    return "MeshLambertNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshLambertNodeMaterial = !0, this.lights = !0, this.setDefaultValues(vY), this.setValues(e);
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new UT(i) : null;
  }
  setupLightingModel() {
    return new CI(!1);
  }
}
const xY = /* @__PURE__ */ new bP();
class _Y extends Bi {
  static get type() {
    return "MeshPhongNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhongNodeMaterial = !0, this.lights = !0, this.shininessNode = null, this.specularNode = null, this.setDefaultValues(xY), this.setValues(e);
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new UT(i) : null;
  }
  setupLightingModel() {
    return new CI();
  }
  setupVariants() {
    const e = (this.shininessNode ? ve(this.shininessNode) : n$).max(1e-4);
    xx.assign(e);
    const i = this.specularNode || a$;
    nn.assign(i);
  }
  copy(e) {
    return this.shininessNode = e.shininessNode, this.specularNode = e.specularNode, super.copy(e);
  }
}
const TY = /* @__PURE__ */ Fe((r) => {
  if (r.geometry.hasAttribute("normal") === !1)
    return ve(0);
  const e = Jn.dFdx().abs().max(Jn.dFdy().abs());
  return e.x.max(e.y).max(e.z);
}), RI = /* @__PURE__ */ Fe((r) => {
  const { roughness: e } = r, i = TY();
  let n = e.max(0.0525);
  return n = n.add(i), n = n.min(1), n;
}), SY = /* @__PURE__ */ Fe(({ alpha: r, dotNL: e, dotNV: i }) => {
  const n = r.pow2(), s = e.mul(n.add(n.oneMinus().mul(i.pow2())).sqrt()), a = i.mul(n.add(n.oneMinus().mul(e.pow2())).sqrt());
  return bo(0.5, s.add(a).max(vq));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
}), wY = /* @__PURE__ */ Fe(({ alphaT: r, alphaB: e, dotTV: i, dotBV: n, dotTL: s, dotBL: a, dotNV: o, dotNL: l }) => {
  const u = l.mul(ye(r.mul(i), e.mul(n), o).length()), c = o.mul(ye(r.mul(s), e.mul(a), l).length());
  return bo(0.5, u.add(c)).saturate();
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
}), EY = /* @__PURE__ */ Fe(({ alpha: r, dotNH: e }) => {
  const i = r.pow2(), n = e.pow2().mul(i.oneMinus()).oneMinus();
  return i.div(n.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), MY = /* @__PURE__ */ ve(1 / Math.PI), AY = /* @__PURE__ */ Fe(({ alphaT: r, alphaB: e, dotNH: i, dotTH: n, dotBH: s }) => {
  const a = r.mul(e), o = ye(e.mul(n), r.mul(s), a.mul(i)), l = o.dot(o), u = a.div(l);
  return MY.mul(a.mul(u.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
}), _M = /* @__PURE__ */ Fe((r) => {
  const { lightDirection: e, f0: i, f90: n, roughness: s, f: a, USE_IRIDESCENCE: o, USE_ANISOTROPY: l } = r, u = r.normalView || ki, c = s.pow2(), h = e.add(vi).normalize(), d = u.dot(e).clamp(), p = u.dot(vi).clamp(), f = u.dot(h).clamp(), m = vi.dot(h).clamp();
  let v = Ad({ f0: i, f90: n, dotVH: m }), y, g;
  if (aM(o) && (v = ST.mix(v, a)), aM(l)) {
    const _ = nm.dot(e), x = nm.dot(vi), b = nm.dot(h), T = ec.dot(e), S = ec.dot(vi), w = ec.dot(h);
    y = wY({ alphaT: bx, alphaB: c, dotTV: x, dotBV: S, dotTL: _, dotBL: T, dotNV: p, dotNL: d }), g = AY({ alphaT: bx, alphaB: c, dotNH: f, dotTH: b, dotBH: w });
  } else
    y = SY({ alpha: c, dotNL: d, dotNV: p }), g = EY({ alpha: c, dotNH: f });
  return v.mul(y).mul(g);
}), NI = /* @__PURE__ */ Fe(({ roughness: r, dotNV: e }) => {
  const i = _t(-1, -0.0275, -0.572, 0.022), n = _t(1, 0.0425, 1.04, -0.04), s = r.mul(i).add(n), a = s.x.mul(s.x).min(e.mul(-9.28).exp2()).mul(s.x).add(s.y);
  return He(-1.04, 1.04).mul(a).add(s.zw);
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
}), PI = /* @__PURE__ */ Fe((r) => {
  const { dotNV: e, specularColor: i, specularF90: n, roughness: s } = r, a = NI({ dotNV: e, roughness: s });
  return i.mul(a.x).add(n.mul(a.y));
}), CY = /* @__PURE__ */ Fe(({ f: r, f90: e, dotVH: i }) => {
  const n = i.oneMinus().saturate(), s = n.mul(n), a = n.mul(s, s).clamp(0, 0.9999);
  return r.sub(ye(e).mul(a)).div(a.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
}), RY = /* @__PURE__ */ Fe(({ roughness: r, dotNH: e }) => {
  const i = r.pow2(), n = ve(1).div(i), s = e.pow2().oneMinus().max(78125e-7);
  return ve(2).add(n).mul(s.pow(n.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), NY = /* @__PURE__ */ Fe(({ dotNV: r, dotNL: e }) => ve(1).div(ve(4).mul(e.add(r).sub(e.mul(r))))).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
}), PY = /* @__PURE__ */ Fe(({ lightDirection: r }) => {
  const e = r.add(vi).normalize(), i = ki.dot(r).clamp(), n = ki.dot(vi).clamp(), s = ki.dot(e).clamp(), a = RY({ roughness: TT, dotNH: s }), o = NY({ dotNV: n, dotNL: i });
  return Bu.mul(a).mul(o);
}), IY = /* @__PURE__ */ Fe(({ N: r, V: e, roughness: i }) => {
  const n = 78125e-7, s = r.dot(e).saturate(), a = He(i, s.oneMinus().sqrt());
  return a.assign(a.mul(0.984375).add(n)), a;
}).setLayout({
  name: "LTC_Uv",
  type: "vec2",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "roughness", type: "float" }
  ]
}), OY = /* @__PURE__ */ Fe(({ f: r }) => {
  const e = r.length();
  return wn(e.mul(e).add(r.z).div(e.add(1)), 0);
}).setLayout({
  name: "LTC_ClippedSphereFormFactor",
  type: "float",
  inputs: [
    { name: "f", type: "vec3" }
  ]
}), df = /* @__PURE__ */ Fe(({ v1: r, v2: e }) => {
  const i = r.dot(e), n = i.abs().toVar(), s = n.mul(0.0145206).add(0.4965155).mul(n).add(0.8543985).toVar(), a = n.add(4.1616724).mul(n).add(3.417594).toVar(), o = s.div(a), l = i.greaterThan(0).select(o, wn(i.mul(i).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(o));
  return r.cross(e).mul(l);
}).setLayout({
  name: "LTC_EdgeVectorFormFactor",
  type: "vec3",
  inputs: [
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" }
  ]
}), TM = /* @__PURE__ */ Fe(({ N: r, V: e, P: i, mInv: n, p0: s, p1: a, p2: o, p3: l }) => {
  const u = a.sub(s).toVar(), c = l.sub(s).toVar(), h = u.cross(c), d = ye().toVar();
  return nr(h.dot(i.sub(s)).greaterThanEqual(0), () => {
    const p = e.sub(r.mul(e.dot(r))).normalize(), f = r.cross(p).negate(), m = n.mul(Rr(p, f, r).transpose()).toVar(), v = m.mul(s.sub(i)).normalize().toVar(), y = m.mul(a.sub(i)).normalize().toVar(), g = m.mul(o.sub(i)).normalize().toVar(), _ = m.mul(l.sub(i)).normalize().toVar(), x = ye(0).toVar();
    x.addAssign(df({ v1: v, v2: y })), x.addAssign(df({ v1: y, v2: g })), x.addAssign(df({ v1: g, v2: _ })), x.addAssign(df({ v1: _, v2: v })), d.assign(ye(OY({ f: x })));
  }), d;
}).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "P", type: "vec3" },
    { name: "mInv", type: "mat3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" }
  ]
}), zg = 1 / 6, II = (r) => Dt(zg, Dt(r, Dt(r, r.negate().add(3)).sub(3)).add(1)), Ex = (r) => Dt(zg, Dt(r, Dt(r, Dt(3, r).sub(6))).add(4)), OI = (r) => Dt(zg, Dt(r, Dt(r, Dt(-3, r).add(3)).add(3)).add(1)), Mx = (r) => Dt(zg, Dg(r, 3)), SM = (r) => II(r).add(Ex(r)), wM = (r) => OI(r).add(Mx(r)), EM = (r) => Nr(-1, Ex(r).div(II(r).add(Ex(r)))), MM = (r) => Nr(1, Mx(r).div(OI(r).add(Mx(r)))), AM = (r, e, i) => {
  const n = r.uvNode, s = Dt(n, e.zw).add(0.5), a = yl(s), o = To(s), l = SM(o.x), u = wM(o.x), c = EM(o.x), h = MM(o.x), d = EM(o.y), p = MM(o.y), f = He(a.x.add(c), a.y.add(d)).sub(0.5).mul(e.xy), m = He(a.x.add(h), a.y.add(d)).sub(0.5).mul(e.xy), v = He(a.x.add(c), a.y.add(p)).sub(0.5).mul(e.xy), y = He(a.x.add(h), a.y.add(p)).sub(0.5).mul(e.xy), g = SM(o.y).mul(Nr(l.mul(r.uv(f).level(i)), u.mul(r.uv(m).level(i)))), _ = wM(o.y).mul(Nr(l.mul(r.uv(v).level(i)), u.mul(r.uv(y).level(i))));
  return g.add(_);
}, DY = /* @__PURE__ */ Fe(([r, e = ve(3)]) => {
  const i = He(r.size(Mi(e))), n = He(r.size(Mi(e.add(1)))), s = bo(1, i), a = bo(1, n), o = AM(r, _t(s, i), yl(e)), l = AM(r, _t(a, n), ET(e));
  return To(e).mix(o, l);
}), CM = /* @__PURE__ */ Fe(([r, e, i, n, s]) => {
  const a = ye(eI(e.negate(), _d(r), bo(1, n))), o = ye(
    fo(s[0].xyz),
    fo(s[1].xyz),
    fo(s[2].xyz)
  );
  return _d(a).mul(i.mul(o));
}).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" }
  ]
}), LY = /* @__PURE__ */ Fe(([r, e]) => r.mul(_a(e.mul(2).sub(2), 0, 1))).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" }
  ]
}), UY = /* @__PURE__ */ vI(), kY = /* @__PURE__ */ vI(), RM = /* @__PURE__ */ Fe(([r, e, i], { material: n }) => {
  const s = (n.side == Zn ? UY : kY).uv(r), a = va(wx.x).mul(LY(e, i));
  return DY(s, a);
}), NM = /* @__PURE__ */ Fe(([r, e, i]) => (nr(i.notEqual(0), () => {
  const n = qP(e).negate().div(i);
  return WP(n.negate().mul(r));
}), ye(1))).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" }
  ]
}), FY = /* @__PURE__ */ Fe(([r, e, i, n, s, a, o, l, u, c, h, d, p, f, m]) => {
  let v, y;
  if (m) {
    v = _t().toVar(), y = ye().toVar();
    const T = h.sub(1).mul(m.mul(0.025)), S = ye(h.sub(T), h, h.add(T));
    ps({ start: 0, end: 3 }, ({ i: w }) => {
      const A = S.element(w), E = CM(r, e, d, A, l), M = o.add(E), N = c.mul(u.mul(_t(M, 1))), k = He(N.xy.div(N.w)).toVar();
      k.addAssign(1), k.divAssign(2), k.assign(He(k.x, k.y.oneMinus()));
      const U = RM(k, i, A);
      v.element(w).assign(U.element(w)), v.a.addAssign(U.a), y.element(w).assign(n.element(w).mul(NM(fo(E), p, f).element(w)));
    }), v.a.divAssign(3);
  } else {
    const T = CM(r, e, d, h, l), S = o.add(T), w = c.mul(u.mul(_t(S, 1))), A = He(w.xy.div(w.w)).toVar();
    A.addAssign(1), A.divAssign(2), A.assign(He(A.x, A.y.oneMinus())), v = RM(A, i, h), y = n.mul(NM(fo(T), p, f));
  }
  const g = y.rgb.mul(v.rgb), _ = r.dot(e).clamp(), x = ye(PI({
    // n, v, specularColor, specularF90, roughness
    dotNV: _,
    specularColor: s,
    specularF90: a,
    roughness: i
  })), b = y.r.add(y.g, y.b).div(3);
  return _t(x.oneMinus().mul(g), v.a.oneMinus().mul(b).oneMinus());
}), BY = /* @__PURE__ */ Rr(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
), zY = (r) => {
  const e = r.sqrt();
  return ye(1).add(e).div(ye(1).sub(e));
}, PM = (r, e) => r.sub(e).div(r.add(e)).pow2(), jY = (r, e) => {
  const i = r.mul(2 * Math.PI * 1e-9), n = ye(54856e-17, 44201e-17, 52481e-17), s = ye(1681e3, 1795300, 2208400), a = ye(43278e5, 93046e5, 66121e5), o = ve(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(i.mul(2239900).add(e.x).cos()).mul(i.pow2().mul(-45282e5).exp());
  let l = n.mul(a.mul(2 * Math.PI).sqrt()).mul(s.mul(i).add(e).cos()).mul(i.pow2().negate().mul(a).exp());
  return l = ye(l.x.add(o), l.y, l.z).div(10685e-11), BY.mul(l);
}, VY = /* @__PURE__ */ Fe(({ outsideIOR: r, eta2: e, cosTheta1: i, thinFilmThickness: n, baseF0: s }) => {
  const a = li(r, e, Ml(0, 0.03, n)), o = r.div(a).pow2().mul(i.pow2().oneMinus()).oneMinus();
  nr(o.lessThan(0), () => ye(1));
  const l = o.sqrt(), u = PM(a, r), c = Ad({ f0: u, f90: 1, dotVH: i }), h = c.oneMinus(), d = a.lessThan(r).select(Math.PI, 0), p = ve(Math.PI).sub(d), f = zY(s.clamp(0, 0.9999)), m = PM(f, a.toVec3()), v = Ad({ f0: m, f90: 1, dotVH: l }), y = ye(
    f.x.lessThan(a).select(Math.PI, 0),
    f.y.lessThan(a).select(Math.PI, 0),
    f.z.lessThan(a).select(Math.PI, 0)
  ), g = a.mul(n, l, 2), _ = ye(p).add(y), x = c.mul(v).clamp(1e-5, 0.9999), b = x.sqrt(), T = h.pow2().mul(v).div(ye(1).sub(x)), S = c.add(T).toVar(), w = T.sub(h).toVar();
  return ps({ start: 1, end: 2, condition: "<=", name: "m" }, ({ m: A }) => {
    w.mulAssign(b);
    const E = jY(ve(A).mul(g), ve(A).mul(_)).mul(2);
    S.addAssign(w.mul(E));
  }), S.max(ye(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
}), GY = /* @__PURE__ */ Fe(({ normal: r, viewDir: e, roughness: i }) => {
  const n = r.dot(e).saturate(), s = i.pow2(), a = Fr(
    i.lessThan(0.25),
    ve(-339.2).mul(s).add(ve(161.4).mul(i)).sub(25.9),
    ve(-8.48).mul(s).add(ve(14.3).mul(i)).sub(9.95)
  ), o = Fr(
    i.lessThan(0.25),
    ve(44).mul(s).sub(ve(23.7).mul(i)).add(3.26),
    ve(1.97).mul(s).sub(ve(3.27).mul(i)).add(0.72)
  );
  return Fr(i.lessThan(0.25), 0, ve(0.1).mul(i).sub(0.025)).add(a.mul(n).add(o).exp()).mul(1 / Math.PI).saturate();
}), Vv = ye(0.04), Gv = ve(1);
class DI extends Bg {
  constructor(e = !1, i = !1, n = !1, s = !1, a = !1, o = !1) {
    super(), this.clearcoat = e, this.sheen = i, this.iridescence = n, this.anisotropy = s, this.transmission = a, this.dispersion = o, this.clearcoatRadiance = null, this.clearcoatSpecularDirect = null, this.clearcoatSpecularIndirect = null, this.sheenSpecularDirect = null, this.sheenSpecularIndirect = null, this.iridescenceFresnel = null, this.iridescenceF0 = null;
  }
  start(e) {
    if (this.clearcoat === !0 && (this.clearcoatRadiance = ye().toVar("clearcoatRadiance"), this.clearcoatSpecularDirect = ye().toVar("clearcoatSpecularDirect"), this.clearcoatSpecularIndirect = ye().toVar("clearcoatSpecularIndirect")), this.sheen === !0 && (this.sheenSpecularDirect = ye().toVar("sheenSpecularDirect"), this.sheenSpecularIndirect = ye().toVar("sheenSpecularIndirect")), this.iridescence === !0) {
      const i = ki.dot(vi).clamp();
      this.iridescenceFresnel = VY({
        outsideIOR: ve(1),
        eta2: kP,
        cosTheta1: i,
        thinFilmThickness: FP,
        baseF0: nn
      }), this.iridescenceF0 = CY({ f: this.iridescenceFresnel, f90: 1, dotVH: i });
    }
    if (this.transmission === !0) {
      const i = Tx, n = PX.sub(Tx).normalize(), s = NT;
      e.backdrop = FY(
        s,
        n,
        ia,
        Wt,
        nn,
        Hm,
        // specularF90
        i,
        // positionWorld
        Al,
        // modelMatrix
        Aa,
        // viewMatrix
        Wm,
        // projMatrix
        sm,
        BP,
        jP,
        zP,
        this.dispersion ? VP : null
      ), e.backdropAlpha = _x, Wt.a.mulAssign(li(1, e.backdrop.a, _x));
    }
  }
  // Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(e, i, n) {
    const s = ki.dot(vi).clamp(), a = NI({ roughness: ia, dotNV: s }), o = (this.iridescenceF0 ? ST.mix(nn, this.iridescenceF0) : nn).mul(a.x).add(n.mul(a.y)), l = a.x.add(a.y).oneMinus(), u = nn.add(nn.oneMinus().mul(0.047619)), c = o.mul(u).div(l.mul(u).oneMinus());
    e.addAssign(o), i.addAssign(c.mul(l));
  }
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }) {
    const s = ki.dot(e).clamp().mul(i);
    if (this.sheen === !0 && this.sheenSpecularDirect.addAssign(s.mul(PY({ lightDirection: e }))), this.clearcoat === !0) {
      const a = jh.dot(e).clamp().mul(i);
      this.clearcoatSpecularDirect.addAssign(a.mul(_M({ lightDirection: e, f0: Vv, f90: Gv, roughness: Gm, normalView: jh })));
    }
    n.directDiffuse.addAssign(s.mul(Ec({ diffuseColor: Wt.rgb }))), n.directSpecular.addAssign(s.mul(_M({ lightDirection: e, f0: nn, f90: 1, roughness: ia, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy })));
  }
  directRectArea({ lightColor: e, lightPosition: i, halfWidth: n, halfHeight: s, reflectedLight: a, ltc_1: o, ltc_2: l }) {
    const u = i.add(n).sub(s), c = i.sub(n).sub(s), h = i.sub(n).add(s), d = i.add(n).add(s), p = ki, f = vi, m = rr.toVar(), v = IY({ N: p, V: f, roughness: ia }), y = o.uv(v).toVar(), g = l.uv(v).toVar(), _ = Rr(
      ye(y.x, 0, y.y),
      ye(0, 1, 0),
      ye(y.z, 0, y.w)
    ).toVar(), x = nn.mul(g.x).add(nn.oneMinus().mul(g.y)).toVar();
    a.directSpecular.addAssign(e.mul(x).mul(TM({ N: p, V: f, P: m, mInv: _, p0: u, p1: c, p2: h, p3: d }))), a.directDiffuse.addAssign(e.mul(Wt).mul(TM({ N: p, V: f, P: m, mInv: Rr(1, 0, 0, 0, 1, 0, 0, 0, 1), p0: u, p1: c, p2: h, p3: d })));
  }
  indirect(e, i, n) {
    this.indirectDiffuse(e, i, n), this.indirectSpecular(e, i, n), this.ambientOcclusion(e, i, n);
  }
  indirectDiffuse({ irradiance: e, reflectedLight: i }) {
    i.indirectDiffuse.addAssign(e.mul(Ec({ diffuseColor: Wt })));
  }
  indirectSpecular({ radiance: e, iblIrradiance: i, reflectedLight: n }) {
    if (this.sheen === !0 && this.sheenSpecularIndirect.addAssign(i.mul(
      Bu,
      GY({
        normal: ki,
        viewDir: vi,
        roughness: TT
      })
    )), this.clearcoat === !0) {
      const c = jh.dot(vi).clamp(), h = PI({
        dotNV: c,
        specularColor: Vv,
        specularF90: Gv,
        roughness: Gm
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(h));
    }
    const s = ye().toVar("singleScattering"), a = ye().toVar("multiScattering"), o = i.mul(1 / Math.PI);
    this.computeMultiscattering(s, a, Hm);
    const l = s.add(a), u = Wt.mul(l.r.max(l.g).max(l.b).oneMinus());
    n.indirectSpecular.addAssign(e.mul(s)), n.indirectSpecular.addAssign(a.mul(o)), n.indirectDiffuse.addAssign(u.mul(o));
  }
  ambientOcclusion({ ambientOcclusion: e, reflectedLight: i }) {
    const n = ki.dot(vi).clamp().add(e), s = ia.mul(-16).oneMinus().negate().exp2(), a = e.sub(n.pow(s).oneMinus()).clamp();
    this.clearcoat === !0 && this.clearcoatSpecularIndirect.mulAssign(e), this.sheen === !0 && this.sheenSpecularIndirect.mulAssign(e), i.indirectDiffuse.mulAssign(e), i.indirectSpecular.mulAssign(a);
  }
  finish(e) {
    const { outgoingLight: i } = e;
    if (this.clearcoat === !0) {
      const n = jh.dot(vi).clamp(), s = Ad({
        dotVH: n,
        f0: Vv,
        f90: Gv
      }), a = i.mul(vx.mul(s).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(vx));
      i.assign(a);
    }
    if (this.sheen === !0) {
      const n = Bu.r.max(Bu.g).max(Bu.b).mul(0.157).oneMinus(), s = i.mul(n).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      i.assign(s);
    }
  }
}
const IM = /* @__PURE__ */ ve(1), Ax = /* @__PURE__ */ ve(-2), pf = /* @__PURE__ */ ve(0.8), Hv = /* @__PURE__ */ ve(-1), ff = /* @__PURE__ */ ve(0.4), Wv = /* @__PURE__ */ ve(2), mf = /* @__PURE__ */ ve(0.305), qv = /* @__PURE__ */ ve(3), OM = /* @__PURE__ */ ve(0.21), HY = /* @__PURE__ */ ve(4), DM = /* @__PURE__ */ ve(4), WY = /* @__PURE__ */ ve(16), qY = /* @__PURE__ */ Fe(([r]) => {
  const e = ye(Gn(r)).toVar(), i = ve(-1).toVar();
  return nr(e.x.greaterThan(e.z), () => {
    nr(e.x.greaterThan(e.y), () => {
      i.assign(Fr(r.x.greaterThan(0), 0, 3));
    }).Else(() => {
      i.assign(Fr(r.y.greaterThan(0), 1, 4));
    });
  }).Else(() => {
    nr(e.z.greaterThan(e.y), () => {
      i.assign(Fr(r.z.greaterThan(0), 2, 5));
    }).Else(() => {
      i.assign(Fr(r.y.greaterThan(0), 1, 4));
    });
  }), i;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
}), XY = /* @__PURE__ */ Fe(([r, e]) => {
  const i = He().toVar();
  return nr(e.equal(0), () => {
    i.assign(He(r.z, r.y).div(Gn(r.x)));
  }).ElseIf(e.equal(1), () => {
    i.assign(He(r.x.negate(), r.z.negate()).div(Gn(r.y)));
  }).ElseIf(e.equal(2), () => {
    i.assign(He(r.x.negate(), r.y).div(Gn(r.z)));
  }).ElseIf(e.equal(3), () => {
    i.assign(He(r.z.negate(), r.y).div(Gn(r.x)));
  }).ElseIf(e.equal(4), () => {
    i.assign(He(r.x.negate(), r.z).div(Gn(r.y)));
  }).Else(() => {
    i.assign(He(r.x, r.y).div(Gn(r.z)));
  }), Dt(0.5, i.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
}), $Y = /* @__PURE__ */ Fe(([r]) => {
  const e = ve(0).toVar();
  return nr(r.greaterThanEqual(pf), () => {
    e.assign(IM.sub(r).mul(Hv.sub(Ax)).div(IM.sub(pf)).add(Ax));
  }).ElseIf(r.greaterThanEqual(ff), () => {
    e.assign(pf.sub(r).mul(Wv.sub(Hv)).div(pf.sub(ff)).add(Hv));
  }).ElseIf(r.greaterThanEqual(mf), () => {
    e.assign(ff.sub(r).mul(qv.sub(Wv)).div(ff.sub(mf)).add(Wv));
  }).ElseIf(r.greaterThanEqual(OM), () => {
    e.assign(mf.sub(r).mul(HY.sub(qv)).div(mf.sub(OM)).add(qv));
  }).Else(() => {
    e.assign(ve(-2).mul(va(Dt(1.16, r))));
  }), e;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
}), YY = /* @__PURE__ */ Fe(([r, e]) => {
  const i = r.toVar();
  i.assign(Dt(2, i).sub(1));
  const n = ye(i, 1).toVar();
  return nr(e.equal(0), () => {
    n.assign(n.zyx);
  }).ElseIf(e.equal(1), () => {
    n.assign(n.xzy), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(2), () => {
    n.x.mulAssign(-1);
  }).ElseIf(e.equal(3), () => {
    n.assign(n.zyx), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(4), () => {
    n.assign(n.xzy), n.xy.mulAssign(-1);
  }).ElseIf(e.equal(5), () => {
    n.z.mulAssign(-1);
  }), n;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
}), KY = /* @__PURE__ */ Fe(([r, e, i, n, s, a]) => {
  const o = ve(i), l = ye(e), u = _a($Y(o), Ax, a), c = To(u), h = yl(u), d = ye(Cx(r, l, h, n, s, a)).toVar();
  return nr(c.notEqual(0), () => {
    const p = ye(Cx(r, l, h.add(1), n, s, a)).toVar();
    d.assign(li(d, p, c));
  }), d;
}), Cx = /* @__PURE__ */ Fe(([r, e, i, n, s, a]) => {
  const o = ve(i).toVar(), l = ye(e), u = ve(qY(l)).toVar(), c = ve(wn(DM.sub(o), 0)).toVar();
  o.assign(wn(o, DM));
  const h = ve(xd(o)).toVar(), d = He(XY(l, u).mul(h.sub(2)).add(1)).toVar();
  return nr(u.greaterThan(2), () => {
    d.y.addAssign(h), u.subAssign(3);
  }), d.x.addAssign(u.mul(h)), d.x.addAssign(c.mul(Dt(3, WY))), d.y.addAssign(Dt(4, xd(a).sub(h))), d.x.mulAssign(n), d.y.mulAssign(s), r.uv(d).grad(He(), He());
}), Xv = /* @__PURE__ */ Fe(({ envMap: r, mipInt: e, outputDirection: i, theta: n, axis: s, CUBEUV_TEXEL_WIDTH: a, CUBEUV_TEXEL_HEIGHT: o, CUBEUV_MAX_MIP: l }) => {
  const u = Qa(n), c = i.mul(u).add(s.cross(i).mul(Vn(n))).add(s.mul(s.dot(i).mul(u.oneMinus())));
  return Cx(r, c, e, a, o, l);
}), ZY = /* @__PURE__ */ Fe(({ n: r, latitudinal: e, poleAxis: i, outputDirection: n, weights: s, samples: a, dTheta: o, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }) => {
  const p = ye(Fr(e, i, QP(i, n))).toVar();
  nr(HP(p.equals(ye(0))), () => {
    p.assign(ye(n.z, 0, n.x.negate()));
  }), p.assign(_d(p));
  const f = ye().toVar();
  return f.addAssign(s.element(Mi(0)).mul(Xv({ theta: 0, axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }))), ps({ start: Mi(1), end: r }, ({ i: m }) => {
    nr(m.greaterThanEqual(a), () => {
      j$();
    });
    const v = ve(o.mul(ve(m))).toVar();
    f.addAssign(s.element(m).mul(Xv({ theta: v.mul(-1), axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }))), f.addAssign(s.element(m).mul(Xv({ theta: v, axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d })));
  }), _t(f, 1);
});
let qm = null;
const LM = /* @__PURE__ */ new WeakMap();
function QY(r) {
  const e = Math.log2(r) - 2, i = 1 / r;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: i, maxMip: e };
}
function JY(r) {
  let e = LM.get(r);
  if ((e !== void 0 ? e.pmremVersion : -1) !== r.pmremVersion) {
    const i = r.image;
    if (r.isCubeTexture)
      if (tK(i))
        e = qm.fromCubemap(r, e);
      else
        return null;
    else if (iK(i))
      e = qm.fromEquirectangular(r, e);
    else
      return null;
    e.pmremVersion = r.pmremVersion, LM.set(r, e);
  }
  return e.texture;
}
class eK extends zi {
  static get type() {
    return "PMREMNode";
  }
  constructor(e, i = null, n = null) {
    super("vec3"), this._value = e, this._pmrem = null, this.uvNode = i, this.levelNode = n, this._generator = null;
    const s = new Cr();
    s.isRenderTargetTexture = !0, this._texture = Ci(s), this._width = Tt(0), this._height = Tt(0), this._maxMip = Tt(0), this.updateBeforeType = Rt.RENDER;
  }
  set value(e) {
    this._value = e, this._pmrem = null;
  }
  get value() {
    return this._value;
  }
  updateFromTexture(e) {
    const i = QY(e.image.height);
    this._texture.value = e, this._width.value = i.texelWidth, this._height.value = i.texelHeight, this._maxMip.value = i.maxMip;
  }
  updateBefore() {
    let e = this._pmrem;
    const i = e ? e.pmremVersion : -1, n = this._value;
    i !== n.pmremVersion && (n.isPMREMTexture === !0 ? e = n : e = JY(n), e !== null && (this._pmrem = e, this.updateFromTexture(e)));
  }
  setup(e) {
    qm === null && (qm = e.createPMREMGenerator()), this.updateBefore(e);
    let i = this.uvNode;
    i === null && e.context.getUV && (i = e.context.getUV(this));
    const n = this.value;
    e.renderer.coordinateSystem === Yn && n.isPMREMTexture !== !0 && n.isRenderTargetTexture === !0 && (i = ye(i.x.negate(), i.yz));
    let s = this.levelNode;
    return s === null && e.context.getTextureLevel && (s = e.context.getTextureLevel(this)), KY(this._texture, i, s, this._width, this._height, this._maxMip);
  }
}
function tK(r) {
  if (r == null) return !1;
  let e = 0;
  const i = 6;
  for (let n = 0; n < i; n++)
    r[n] !== void 0 && e++;
  return e === i;
}
function iK(r) {
  return r == null ? !1 : r.height > 0;
}
const LI = /* @__PURE__ */ Me(eK), UM = /* @__PURE__ */ new WeakMap();
class rK extends Gc {
  static get type() {
    return "EnvironmentNode";
  }
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    const { material: i } = e;
    let n = this.envNode;
    if (n.isTextureNode || n.isMaterialReferenceNode) {
      const d = n.isTextureNode ? n.value : i[n.property];
      let p = UM.get(d);
      p === void 0 && (p = LI(d), UM.set(d, p)), n = p;
    }
    const s = i.envMap ? bi("envMapIntensity", "float", e.material) : bi("environmentIntensity", "float", e.scene), a = i.useAnisotropy === !0 || i.anisotropy > 0 ? YX : ki, o = n.context(kM(ia, a)).mul(s), l = n.context(nK(NT)).mul(Math.PI).mul(s), u = am(o), c = am(l);
    e.context.radiance.addAssign(u), e.context.iblIrradiance.addAssign(c);
    const h = e.context.lightingModel.clearcoatRadiance;
    if (h) {
      const d = n.context(kM(Gm, jh)).mul(s), p = am(d);
      h.addAssign(p);
    }
  }
}
const kM = (r, e) => {
  let i = null;
  return {
    getUV: () => (i === null && (i = vi.negate().reflect(e), i = r.mul(r).mix(i, e).normalize(), i = i.transformDirection(Aa)), i),
    getTextureLevel: () => r
  };
}, nK = (r) => ({
  getUV: () => r,
  getTextureLevel: () => ve(1)
}), sK = /* @__PURE__ */ new fT();
class UI extends Bi {
  static get type() {
    return "MeshStandardNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardNodeMaterial = !0, this.lights = !0, this.emissiveNode = null, this.metalnessNode = null, this.roughnessNode = null, this.setDefaultValues(sK), this.setValues(e);
  }
  setupEnvironment(e) {
    let i = super.setupEnvironment(e);
    return i === null && e.environmentNode && (i = e.environmentNode), i ? new rK(i) : null;
  }
  setupLightingModel() {
    return new DI();
  }
  setupSpecular() {
    const e = li(ye(0.04), Wt.rgb, Vm);
    nn.assign(e), Hm.assign(1);
  }
  setupVariants() {
    const e = this.metalnessNode ? ve(this.metalnessNode) : u$;
    Vm.assign(e);
    let i = this.roughnessNode ? ve(this.roughnessNode) : l$;
    i = RI({ roughness: i }), ia.assign(i), this.setupSpecular(), Wt.assign(_t(Wt.rgb.mul(e.oneMinus()), Wt.a));
  }
  copy(e) {
    return this.emissiveNode = e.emissiveNode, this.metalnessNode = e.metalnessNode, this.roughnessNode = e.roughnessNode, super.copy(e);
  }
}
const aK = /* @__PURE__ */ new vP();
class oK extends UI {
  static get type() {
    return "MeshPhysicalNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhysicalNodeMaterial = !0, this.clearcoatNode = null, this.clearcoatRoughnessNode = null, this.clearcoatNormalNode = null, this.sheenNode = null, this.sheenRoughnessNode = null, this.iridescenceNode = null, this.iridescenceIORNode = null, this.iridescenceThicknessNode = null, this.specularIntensityNode = null, this.specularColorNode = null, this.iorNode = null, this.transmissionNode = null, this.thicknessNode = null, this.attenuationDistanceNode = null, this.attenuationColorNode = null, this.dispersionNode = null, this.anisotropyNode = null, this.setDefaultValues(aK), this.setValues(e);
  }
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  get useDispersion() {
    return this.dispersion > 0 || this.dispersionNode !== null;
  }
  setupSpecular() {
    const e = this.iorNode ? ve(this.iorNode) : S$;
    sm.assign(e), nn.assign(li(Td(JP(sm.sub(1).div(sm.add(1))).mul(o$), ye(1)).mul(mM), Wt.rgb, Vm)), Hm.assign(li(mM, 1, Vm));
  }
  setupLightingModel() {
    return new DI(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
  }
  setupVariants(e) {
    if (super.setupVariants(e), this.useClearcoat) {
      const i = this.clearcoatNode ? ve(this.clearcoatNode) : h$, n = this.clearcoatRoughnessNode ? ve(this.clearcoatRoughnessNode) : d$;
      vx.assign(i), Gm.assign(RI({ roughness: n }));
    }
    if (this.useSheen) {
      const i = this.sheenNode ? ye(this.sheenNode) : m$, n = this.sheenRoughnessNode ? ve(this.sheenRoughnessNode) : g$;
      Bu.assign(i), TT.assign(n);
    }
    if (this.useIridescence) {
      const i = this.iridescenceNode ? ve(this.iridescenceNode) : v$, n = this.iridescenceIORNode ? ve(this.iridescenceIORNode) : b$, s = this.iridescenceThicknessNode ? ve(this.iridescenceThicknessNode) : x$;
      ST.assign(i), kP.assign(n), FP.assign(s);
    }
    if (this.useAnisotropy) {
      const i = (this.anisotropyNode ? He(this.anisotropyNode) : y$).toVar();
      Ho.assign(i.length()), nr(Ho.equal(0), () => {
        i.assign(He(1, 0));
      }).Else(() => {
        i.divAssign(He(Ho)), Ho.assign(Ho.saturate());
      }), bx.assign(Ho.pow2().mix(ia.pow2(), 1)), nm.assign(Vh[0].mul(i.x).add(Vh[1].mul(i.y))), ec.assign(Vh[1].mul(i.x).sub(Vh[0].mul(i.y)));
    }
    if (this.useTransmission) {
      const i = this.transmissionNode ? ve(this.transmissionNode) : _$, n = this.thicknessNode ? ve(this.thicknessNode) : T$, s = this.attenuationDistanceNode ? ve(this.attenuationDistanceNode) : w$, a = this.attenuationColorNode ? ye(this.attenuationColorNode) : E$;
      if (_x.assign(i), BP.assign(n), zP.assign(s), jP.assign(a), this.useDispersion) {
        const o = this.dispersionNode ? ve(this.dispersionNode) : R$;
        VP.assign(o);
      }
    }
  }
  setupClearcoatNormal() {
    return this.clearcoatNormalNode ? ye(this.clearcoatNormalNode) : p$;
  }
  setup(e) {
    e.context.setupClearcoatNormal = () => this.setupClearcoatNormal(e), super.setup(e);
  }
  copy(e) {
    return this.clearcoatNode = e.clearcoatNode, this.clearcoatRoughnessNode = e.clearcoatRoughnessNode, this.clearcoatNormalNode = e.clearcoatNormalNode, this.sheenNode = e.sheenNode, this.sheenRoughnessNode = e.sheenRoughnessNode, this.iridescenceNode = e.iridescenceNode, this.iridescenceIORNode = e.iridescenceIORNode, this.iridescenceThicknessNode = e.iridescenceThicknessNode, this.specularIntensityNode = e.specularIntensityNode, this.specularColorNode = e.specularColorNode, this.transmissionNode = e.transmissionNode, this.thicknessNode = e.thicknessNode, this.attenuationDistanceNode = e.attenuationDistanceNode, this.attenuationColorNode = e.attenuationColorNode, this.dispersionNode = e.dispersionNode, this.anisotropyNode = e.anisotropyNode, super.copy(e);
  }
}
const lK = /* @__PURE__ */ Fe(({ normal: r, lightDirection: e, builder: i }) => {
  const n = r.dot(e), s = He(n.mul(0.5).add(0.5), 0);
  if (i.material.gradientMap) {
    const a = to("gradientMap", "texture").context({ getUV: () => s });
    return ye(a.r);
  } else {
    const a = s.fwidth().mul(0.5);
    return li(ye(0.7), ye(1), Ml(ve(0.7).sub(a.x), ve(0.7).add(a.x), s.x));
  }
});
class uK extends Bg {
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }, s, a) {
    const o = lK({ normal: lI, lightDirection: e, builder: a }).mul(i);
    n.directDiffuse.addAssign(o.mul(Ec({ diffuseColor: Wt.rgb })));
  }
  indirect({ ambientOcclusion: e, irradiance: i, reflectedLight: n }) {
    n.indirectDiffuse.addAssign(i.mul(Ec({ diffuseColor: Wt }))), n.indirectDiffuse.mulAssign(e);
  }
}
const cK = /* @__PURE__ */ new xP();
class hK extends Bi {
  static get type() {
    return "MeshToonNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshToonNodeMaterial = !0, this.lights = !0, this.setDefaultValues(cK), this.setValues(e);
  }
  setupLightingModel() {
    return new uK();
  }
}
class dK extends zi {
  static get type() {
    return "MatcapUVNode";
  }
  constructor() {
    super("vec2");
  }
  setup() {
    const e = ye(vi.z, 0, vi.x.negate()).normalize(), i = vi.cross(e);
    return He(e.dot(ki), i.dot(ki)).mul(0.495).add(0.5);
  }
}
const pK = /* @__PURE__ */ Ve(dK), fK = /* @__PURE__ */ new SP();
class mK extends Bi {
  static get type() {
    return "MeshMatcapNodeMaterial";
  }
  constructor(e) {
    super(), this.lights = !1, this.isMeshMatcapNodeMaterial = !0, this.setDefaultValues(fK), this.setValues(e);
  }
  setupVariants(e) {
    const i = pK;
    let n;
    e.material.matcap ? n = to("matcap", "texture").context({ getUV: () => i }) : n = ye(li(0.2, 0.8, i.y)), Wt.rgb.mulAssign(n.rgb);
  }
}
const gK = /* @__PURE__ */ new gP();
class yK extends Bi {
  static get type() {
    return "PointsNodeMaterial";
  }
  constructor(e) {
    super(), this.isPointsNodeMaterial = !0, this.lights = !1, this.transparent = !0, this.sizeNode = null, this.setDefaultValues(gK), this.setValues(e);
  }
  copy(e) {
    return this.sizeNode = e.sizeNode, super.copy(e);
  }
}
class vK extends zi {
  static get type() {
    return "RotateNode";
  }
  constructor(e, i) {
    super(), this.positionNode = e, this.rotationNode = i;
  }
  getNodeType(e) {
    return this.positionNode.getNodeType(e);
  }
  setup(e) {
    const { rotationNode: i, positionNode: n } = this;
    if (this.getNodeType(e) === "vec2") {
      const s = i.cos(), a = i.sin();
      return _T(
        s,
        a,
        a.negate(),
        s
      ).mul(n);
    } else {
      const s = i, a = Ju(_t(1, 0, 0, 0), _t(0, Qa(s.x), Vn(s.x).negate(), 0), _t(0, Vn(s.x), Qa(s.x), 0), _t(0, 0, 0, 1)), o = Ju(_t(Qa(s.y), 0, Vn(s.y), 0), _t(0, 1, 0, 0), _t(Vn(s.y).negate(), 0, Qa(s.y), 0), _t(0, 0, 0, 1)), l = Ju(_t(Qa(s.z), Vn(s.z).negate(), 0, 0), _t(Vn(s.z), Qa(s.z), 0, 0), _t(0, 0, 1, 0), _t(0, 0, 0, 1));
      return a.mul(o).mul(l).mul(_t(n, 1)).xyz;
    }
  }
}
const bK = /* @__PURE__ */ Me(vK), xK = /* @__PURE__ */ new fP();
class _K extends Bi {
  static get type() {
    return "SpriteNodeMaterial";
  }
  constructor(e) {
    super(), this.isSpriteNodeMaterial = !0, this.lights = !1, this._useSizeAttenuation = !0, this.positionNode = null, this.rotationNode = null, this.scaleNode = null, this.setDefaultValues(xK), this.setValues(e);
  }
  setupPosition({ object: e, camera: i, context: n }) {
    const s = this.sizeAttenuation, { positionNode: a, rotationNode: o, scaleNode: l } = this, u = sr;
    let c = kg.mul(ye(a || 0)), h = He(Al[0].xyz.length(), Al[1].xyz.length());
    if (l !== null && (h = h.mul(l)), !s)
      if (i.isPerspectiveCamera)
        h = h.mul(c.z.negate());
      else {
        const v = ve(2).div(Wm.element(1).element(1));
        h = h.mul(v.mul(2));
      }
    let d = u.xy;
    if (e.center && e.center.isVector2 === !0) {
      const v = lX("center", "vec2");
      d = d.sub(v.sub(0.5));
    }
    d = d.mul(h);
    const p = ve(o || f$), f = bK(d, p);
    c = _t(c.xy.add(f), c.zw);
    const m = Wm.mul(c);
    return n.vertex = u, m;
  }
  copy(e) {
    return this.positionNode = e.positionNode, this.rotationNode = e.rotationNode, this.scaleNode = e.scaleNode, super.copy(e);
  }
  get sizeAttenuation() {
    return this._useSizeAttenuation;
  }
  set sizeAttenuation(e) {
    this._useSizeAttenuation !== e && (this._useSizeAttenuation = e, this.needsUpdate = !0);
  }
}
class TK extends Bg {
  constructor() {
    super(), this.shadowNode = ve(1).toVar("shadowMask");
  }
  direct({ shadowMask: e }) {
    this.shadowNode.mulAssign(e);
  }
  finish(e) {
    Wt.a.mulAssign(this.shadowNode.oneMinus()), e.outgoingLight.rgb.assign(Wt.rgb);
  }
}
const SK = /* @__PURE__ */ new yP();
class wK extends Bi {
  static get type() {
    return "ShadowNodeMaterial";
  }
  constructor(e) {
    super(), this.isShadowNodeMaterial = !0, this.lights = !0, this.setDefaultValues(SK), this.setValues(e);
  }
  setupLightingModel() {
    return new TK();
  }
}
Fe(({ texture: r, uv: e }) => {
  const i = ye().toVar();
  return nr(e.x.lessThan(1e-4), () => {
    i.assign(ye(1, 0, 0));
  }).ElseIf(e.y.lessThan(1e-4), () => {
    i.assign(ye(0, 1, 0));
  }).ElseIf(e.z.lessThan(1e-4), () => {
    i.assign(ye(0, 0, 1));
  }).ElseIf(e.x.greaterThan(1 - 1e-4), () => {
    i.assign(ye(-1, 0, 0));
  }).ElseIf(e.y.greaterThan(1 - 1e-4), () => {
    i.assign(ye(0, -1, 0));
  }).ElseIf(e.z.greaterThan(1 - 1e-4), () => {
    i.assign(ye(0, 0, -1));
  }).Else(() => {
    const n = r.uv(e.add(ye(-0.01, 0, 0))).r.sub(r.uv(e.add(ye(0.01, 0, 0))).r), s = r.uv(e.add(ye(0, -0.01, 0))).r.sub(r.uv(e.add(ye(0, 0.01, 0))).r), a = r.uv(e.add(ye(0, 0, -0.01))).r.sub(r.uv(e.add(ye(0, 0, 0.01))).r);
    i.assign(ye(n, s, a));
  }), i.normalize();
});
class EK {
  constructor(e, i) {
    this.nodes = e, this.info = i, this.animationLoop = null, this.requestId = null, this._init();
  }
  _init() {
    const e = (i, n) => {
      this.requestId = self.requestAnimationFrame(e), this.info.autoReset === !0 && this.info.reset(), this.nodes.nodeFrame.update(), this.info.frame = this.nodes.nodeFrame.frameId, this.animationLoop !== null && this.animationLoop(i, n);
    };
    e();
  }
  dispose() {
    self.cancelAnimationFrame(this.requestId), this.requestId = null;
  }
  setAnimationLoop(e) {
    this.animationLoop = e;
  }
}
class Ts {
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
  }
  get(e) {
    let i = this.weakMap;
    for (let n = 0; n < e.length; n++)
      if (i = i.get(e[n]), i === void 0) return;
    return i.get(e[e.length - 1]);
  }
  set(e, i) {
    let n = this.weakMap;
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      n.has(a) === !1 && n.set(a, /* @__PURE__ */ new WeakMap()), n = n.get(a);
    }
    return n.set(e[e.length - 1], i);
  }
  delete(e) {
    let i = this.weakMap;
    for (let n = 0; n < e.length; n++)
      if (i = i.get(e[n]), i === void 0) return !1;
    return i.delete(e[e.length - 1]);
  }
}
const $v = /* @__PURE__ */ new Za();
class Rx {
  constructor() {
    this.version = 0, this.globalClippingCount = 0, this.localClippingCount = 0, this.localClippingEnabled = !1, this.localClipIntersection = !1, this.planes = [], this.parentVersion = 0, this.viewNormalMatrix = new Xr(), this.cacheKey = 0;
  }
  projectPlanes(e, i) {
    const n = e.length, s = this.planes;
    for (let a = 0; a < n; a++) {
      $v.copy(e[a]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
      const o = s[i + a], l = $v.normal;
      o.x = -l.x, o.y = -l.y, o.z = -l.z, o.w = $v.constant;
    }
  }
  updateGlobal(e, i) {
    const n = e.clippingPlanes;
    this.viewMatrix = i.matrixWorldInverse, this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
    let s = !1;
    if (Array.isArray(n) && n.length !== 0) {
      const a = n.length;
      if (a !== this.globalClippingCount) {
        const o = [];
        for (let l = 0; l < a; l++)
          o.push(new $t());
        this.globalClippingCount = a, this.planes = o, s = !0;
      }
      this.projectPlanes(n, 0);
    } else this.globalClippingCount !== 0 && (this.globalClippingCount = 0, this.planes = [], s = !0);
    e.localClippingEnabled !== this.localClippingEnabled && (this.localClippingEnabled = e.localClippingEnabled, s = !0), s && (this.version++, this.cacheKey = km(this.globalClippingCount, this.localClippingEnabled === !0 ? 1 : 0));
  }
  update(e, i) {
    let n = !1;
    if (this !== e && e.version !== this.parentVersion && (this.globalClippingCount = i.isShadowNodeMaterial ? 0 : e.globalClippingCount, this.localClippingEnabled = e.localClippingEnabled, this.planes = Array.from(e.planes), this.parentVersion = e.version, this.viewMatrix = e.viewMatrix, this.viewNormalMatrix = e.viewNormalMatrix, n = !0), this.localClippingEnabled) {
      const s = i.clippingPlanes;
      if (Array.isArray(s) && s.length !== 0) {
        const a = s.length, o = this.planes, l = this.globalClippingCount;
        if (n || a !== this.localClippingCount) {
          o.length = l + a;
          for (let u = 0; u < a; u++)
            o[l + u] = new $t();
          this.localClippingCount = a, n = !0;
        }
        this.projectPlanes(s, l);
      } else this.localClippingCount !== 0 && (this.localClippingCount = 0, n = !0);
      this.localClipIntersection !== i.clipIntersection && (this.localClipIntersection = i.clipIntersection, n = !0);
    }
    n && (this.version += e.version, this.cacheKey = km(e.cacheKey, this.localClippingCount, this.localClipIntersection === !0 ? 1 : 0));
  }
}
let MK = 0;
function AK(r) {
  const e = Object.keys(r);
  let i = Object.getPrototypeOf(r);
  for (; i; ) {
    const n = Object.getOwnPropertyDescriptors(i);
    for (const s in n)
      if (n[s] !== void 0) {
        const a = n[s];
        a && typeof a.get == "function" && e.push(s);
      }
    i = Object.getPrototypeOf(i);
  }
  return e;
}
class CK {
  constructor(e, i, n, s, a, o, l, u, c) {
    this._nodes = e, this._geometries = i, this.id = MK++, this.renderer = n, this.object = s, this.material = a, this.scene = o, this.camera = l, this.lightsNode = u, this.context = c, this.geometry = s.geometry, this.version = a.version, this.drawRange = null, this.attributes = null, this.pipeline = null, this.vertexBuffers = null, this.drawParams = null, this.bundle = null, this.updateClipping(c.clippingContext), this.clippingContextVersion = this.clippingContext.version, this.initialNodesCacheKey = this.getDynamicCacheKey(), this.initialCacheKey = this.getCacheKey(), this._nodeBuilderState = null, this._bindings = null, this._monitor = null, this.onDispose = null, this.isRenderObject = !0, this.onMaterialDispose = () => {
      this.dispose();
    }, this.material.addEventListener("dispose", this.onMaterialDispose);
  }
  updateClipping(e) {
    const i = this.material;
    let n = this.clippingContext;
    Array.isArray(i.clippingPlanes) ? ((n === e || !n) && (n = new Rx(), this.clippingContext = n), n.update(e, i)) : this.clippingContext !== e && (this.clippingContext = e);
  }
  get clippingNeedsUpdate() {
    return this.clippingContext.version === this.clippingContextVersion ? !1 : (this.clippingContextVersion = this.clippingContext.version, !0);
  }
  getNodeBuilderState() {
    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
  }
  getMonitor() {
    return this._monitor || (this._monitor = this.getNodeBuilderState().monitor);
  }
  getBindings() {
    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
  }
  getIndex() {
    return this._geometries.getIndex(this);
  }
  getIndirect() {
    return this._geometries.getIndirect(this);
  }
  getChainArray() {
    return [this.object, this.material, this.context, this.lightsNode];
  }
  getAttributes() {
    if (this.attributes !== null) return this.attributes;
    const e = this.getNodeBuilderState().nodeAttributes, i = this.geometry, n = [], s = /* @__PURE__ */ new Set();
    for (const a of e) {
      const o = a.node && a.node.attribute ? a.node.attribute : i.getAttribute(a.name);
      if (o === void 0) continue;
      n.push(o);
      const l = o.isInterleavedBufferAttribute ? o.data : o;
      s.add(l);
    }
    return this.attributes = n, this.vertexBuffers = Array.from(s.values()), n;
  }
  getVertexBuffers() {
    return this.vertexBuffers === null && this.getAttributes(), this.vertexBuffers;
  }
  getDrawParameters() {
    const { object: e, material: i, geometry: n, group: s, drawRange: a } = this, o = this.drawParams || (this.drawParams = {
      vertexCount: 0,
      firstVertex: 0,
      instanceCount: 0,
      firstInstance: 0
    }), l = this.getIndex(), u = l !== null, c = n.isInstancedBufferGeometry ? n.instanceCount : e.count > 1 ? e.count : 1;
    if (c === 0) return null;
    if (o.instanceCount = c, e.isBatchedMesh === !0) return o;
    let h = 1;
    i.wireframe === !0 && !e.isPoints && !e.isLineSegments && !e.isLine && !e.isLineLoop && (h = 2);
    let d = a.start * h, p = (a.start + a.count) * h;
    s !== null && (d = Math.max(d, s.start * h), p = Math.min(p, (s.start + s.count) * h));
    const f = n.attributes.position;
    let m = 1 / 0;
    u ? m = l.count : f != null && (m = f.count), d = Math.max(d, 0), p = Math.min(p, m);
    const v = p - d;
    return v < 0 || v === 1 / 0 ? null : (o.vertexCount = v, o.firstVertex = d, o);
  }
  getGeometryCacheKey() {
    const { geometry: e } = this;
    let i = "";
    for (const n of Object.keys(e.attributes).sort()) {
      const s = e.attributes[n];
      i += n + ",", s.data && (i += s.data.stride + ","), s.offset && (i += s.offset + ","), s.itemSize && (i += s.itemSize + ","), s.normalized && (i += "n,");
    }
    return e.index && (i += "index,"), i;
  }
  getMaterialCacheKey() {
    const { object: e, material: i } = this;
    let n = i.customProgramCacheKey();
    for (const s of AK(i)) {
      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(s)) continue;
      const a = i[s];
      let o;
      if (a !== null) {
        const l = typeof a;
        l === "number" ? o = a !== 0 ? "1" : "0" : l === "object" ? (o = "{", a.isTexture && (o += a.mapping), o += "}") : o = String(a);
      } else
        o = String(a);
      n += /*property + ':' +*/
      o + ",";
    }
    return n += this.clippingContext.cacheKey + ",", e.geometry && (n += this.getGeometryCacheKey()), e.skeleton && (n += e.skeleton.bones.length + ","), e.morphTargetInfluences && (n += e.morphTargetInfluences.length + ","), e.isBatchedMesh && (n += e._matricesTexture.uuid + ",", e._colorsTexture !== null && (n += e._colorsTexture.uuid + ",")), e.count > 1 && (n += e.uuid + ","), pW(n);
  }
  get needsUpdate() {
    return (
      /*this.object.static !== true &&*/
      this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate
    );
  }
  getDynamicCacheKey() {
    let e = this._nodes.getCacheKey(this.scene, this.lightsNode);
    return this.object.receiveShadow && (e += 1), e;
  }
  getCacheKey() {
    return this.getMaterialCacheKey() + this.getDynamicCacheKey();
  }
  dispose() {
    this.material.removeEventListener("dispose", this.onMaterialDispose), this.onDispose();
  }
}
const bu = [];
class RK {
  constructor(e, i, n, s, a, o) {
    this.renderer = e, this.nodes = i, this.geometries = n, this.pipelines = s, this.bindings = a, this.info = o, this.chainMaps = {};
  }
  get(e, i, n, s, a, o, l) {
    const u = this.getChainMap(l);
    bu[0] = e, bu[1] = i, bu[2] = o, bu[3] = a;
    let c = u.get(bu);
    return c === void 0 ? (c = this.createRenderObject(this.nodes, this.geometries, this.renderer, e, i, n, s, a, o, l), u.set(bu, c)) : (c.updateClipping(o.clippingContext), (c.version !== i.version || c.needsUpdate) && (c.initialCacheKey !== c.getCacheKey() ? (c.dispose(), c = this.get(e, i, n, s, a, o, l)) : c.version = i.version)), c;
  }
  getChainMap(e = "default") {
    return this.chainMaps[e] || (this.chainMaps[e] = new Ts());
  }
  dispose() {
    this.chainMaps = {};
  }
  createRenderObject(e, i, n, s, a, o, l, u, c, h) {
    const d = this.getChainMap(h), p = new CK(e, i, n, s, a, o, l, u, c);
    return p.onDispose = () => {
      this.pipelines.delete(p), this.bindings.delete(p), this.nodes.delete(p), d.delete(p.getChainArray());
    }, p;
  }
}
class So {
  constructor() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
  get(e) {
    let i = this.data.get(e);
    return i === void 0 && (i = {}, this.data.set(e, i)), i;
  }
  delete(e) {
    let i;
    return this.data.has(e) && (i = this.data.get(e), this.data.delete(e)), i;
  }
  has(e) {
    return this.data.has(e);
  }
  dispose() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
}
const fs = {
  VERTEX: 1,
  INDEX: 2,
  STORAGE: 3,
  INDIRECT: 4
}, io = 16, NK = 211, PK = 212;
class IK extends So {
  constructor(e) {
    super(), this.backend = e;
  }
  delete(e) {
    const i = super.delete(e);
    return i !== void 0 && this.backend.destroyAttribute(e), i;
  }
  update(e, i) {
    const n = this.get(e);
    if (n.version === void 0)
      i === fs.VERTEX ? this.backend.createAttribute(e) : i === fs.INDEX ? this.backend.createIndexAttribute(e) : i === fs.STORAGE ? this.backend.createStorageAttribute(e) : i === fs.INDIRECT && this.backend.createIndirectStorageAttribute(e), n.version = this._getBufferAttribute(e).version;
    else {
      const s = this._getBufferAttribute(e);
      (n.version < s.version || s.usage === ku) && (this.backend.updateAttribute(e), n.version = s.version);
    }
  }
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
function OK(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function kI(r) {
  return r.index !== null ? r.index.version : r.attributes.position.version;
}
function FM(r) {
  const e = [], i = r.index, n = r.attributes.position;
  if (i !== null) {
    const a = i.array;
    for (let o = 0, l = a.length; o < l; o += 3) {
      const u = a[o + 0], c = a[o + 1], h = a[o + 2];
      e.push(u, c, c, h, h, u);
    }
  } else {
    const a = n.array;
    for (let o = 0, l = a.length / 3 - 1; o < l; o += 3) {
      const u = o + 0, c = o + 1, h = o + 2;
      e.push(u, c, c, h, h, u);
    }
  }
  const s = new (OK(e) ? oP : aP)(e, 1);
  return s.version = kI(r), s;
}
class DK extends So {
  constructor(e, i) {
    super(), this.attributes = e, this.info = i, this.wireframes = /* @__PURE__ */ new WeakMap(), this.attributeCall = /* @__PURE__ */ new WeakMap();
  }
  has(e) {
    const i = e.geometry;
    return super.has(i) && this.get(i).initialized === !0;
  }
  updateForRender(e) {
    this.has(e) === !1 && this.initGeometry(e), this.updateAttributes(e);
  }
  initGeometry(e) {
    const i = e.geometry, n = this.get(i);
    n.initialized = !0, this.info.memory.geometries++;
    const s = () => {
      this.info.memory.geometries--;
      const a = i.index, o = e.getAttributes();
      a !== null && this.attributes.delete(a);
      for (const u of o)
        this.attributes.delete(u);
      const l = this.wireframes.get(i);
      l !== void 0 && this.attributes.delete(l), i.removeEventListener("dispose", s);
    };
    i.addEventListener("dispose", s);
  }
  updateAttributes(e) {
    const i = e.getAttributes();
    for (const a of i)
      a.isStorageBufferAttribute || a.isStorageInstancedBufferAttribute ? this.updateAttribute(a, fs.STORAGE) : this.updateAttribute(a, fs.VERTEX);
    const n = this.getIndex(e);
    n !== null && this.updateAttribute(n, fs.INDEX);
    const s = e.geometry.indirect;
    s !== null && this.updateAttribute(s, fs.INDIRECT);
  }
  updateAttribute(e, i) {
    const n = this.info.render.calls;
    e.isInterleavedBufferAttribute ? this.attributeCall.get(e) === void 0 ? (this.attributes.update(e, i), this.attributeCall.set(e, n)) : this.attributeCall.get(e.data) !== n && (this.attributes.update(e, i), this.attributeCall.set(e.data, n), this.attributeCall.set(e, n)) : this.attributeCall.get(e) !== n && (this.attributes.update(e, i), this.attributeCall.set(e, n));
  }
  getIndirect(e) {
    return e.geometry.indirect;
  }
  getIndex(e) {
    const { geometry: i, material: n } = e;
    let s = i.index;
    if (n.wireframe === !0) {
      const a = this.wireframes;
      let o = a.get(i);
      o === void 0 ? (o = FM(i), a.set(i, o)) : o.version !== kI(i) && (this.attributes.delete(o), o = FM(i), a.set(i, o)), s = o;
    }
    return s;
  }
}
class LK {
  constructor() {
    this.autoReset = !0, this.frame = 0, this.calls = 0, this.render = {
      calls: 0,
      frameCalls: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
      timestamp: 0,
      previousFrameCalls: 0,
      timestampCalls: 0
    }, this.compute = {
      calls: 0,
      frameCalls: 0,
      timestamp: 0,
      previousFrameCalls: 0,
      timestampCalls: 0
    }, this.memory = {
      geometries: 0,
      textures: 0
    };
  }
  update(e, i, n) {
    this.render.drawCalls++, e.isMesh || e.isSprite ? this.render.triangles += n * (i / 3) : e.isPoints ? this.render.points += n * i : e.isLineSegments ? this.render.lines += n * (i / 2) : e.isLine ? this.render.lines += n * (i - 1) : console.error("THREE.WebGPUInfo: Unknown object type.");
  }
  updateTimestamp(e, i) {
    this[e].timestampCalls === 0 && (this[e].timestamp = 0), this[e].timestamp += i, this[e].timestampCalls++, this[e].timestampCalls >= this[e].previousFrameCalls && (this[e].timestampCalls = 0);
  }
  reset() {
    const e = this.render.frameCalls;
    this.render.previousFrameCalls = e;
    const i = this.compute.frameCalls;
    this.compute.previousFrameCalls = i, this.render.drawCalls = 0, this.render.frameCalls = 0, this.compute.frameCalls = 0, this.render.triangles = 0, this.render.points = 0, this.render.lines = 0;
  }
  dispose() {
    this.reset(), this.calls = 0, this.render.calls = 0, this.compute.calls = 0, this.render.timestamp = 0, this.compute.timestamp = 0, this.memory.geometries = 0, this.memory.textures = 0;
  }
}
class FI {
  constructor(e) {
    this.cacheKey = e, this.usedTimes = 0;
  }
}
class UK extends FI {
  constructor(e, i, n) {
    super(e), this.vertexProgram = i, this.fragmentProgram = n;
  }
}
class kK extends FI {
  constructor(e, i) {
    super(e), this.computeProgram = i, this.isComputePipeline = !0;
  }
}
let FK = 0;
class Yv {
  constructor(e, i, n = null, s = null) {
    this.id = FK++, this.code = e, this.stage = i, this.transforms = n, this.attributes = s, this.usedTimes = 0;
  }
}
class BK extends So {
  constructor(e, i) {
    super(), this.backend = e, this.nodes = i, this.bindings = null, this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  getForCompute(e, i) {
    const { backend: n } = this, s = this.get(e);
    if (this._needsComputeUpdate(e)) {
      const a = s.pipeline;
      a && (a.usedTimes--, a.computeProgram.usedTimes--);
      const o = this.nodes.getForCompute(e);
      let l = this.programs.compute.get(o.computeShader);
      l === void 0 && (a && a.computeProgram.usedTimes === 0 && this._releaseProgram(a.computeProgram), l = new Yv(o.computeShader, "compute", o.transforms, o.nodeAttributes), this.programs.compute.set(o.computeShader, l), n.createProgram(l));
      const u = this._getComputeCacheKey(e, l);
      let c = this.caches.get(u);
      c === void 0 && (a && a.usedTimes === 0 && this._releasePipeline(a), c = this._getComputePipeline(e, l, u, i)), c.usedTimes++, l.usedTimes++, s.version = e.version, s.pipeline = c;
    }
    return s.pipeline;
  }
  getForRender(e, i = null) {
    const { backend: n } = this, s = this.get(e);
    if (this._needsRenderUpdate(e)) {
      const a = s.pipeline;
      a && (a.usedTimes--, a.vertexProgram.usedTimes--, a.fragmentProgram.usedTimes--);
      const o = e.getNodeBuilderState();
      let l = this.programs.vertex.get(o.vertexShader);
      l === void 0 && (a && a.vertexProgram.usedTimes === 0 && this._releaseProgram(a.vertexProgram), l = new Yv(o.vertexShader, "vertex"), this.programs.vertex.set(o.vertexShader, l), n.createProgram(l));
      let u = this.programs.fragment.get(o.fragmentShader);
      u === void 0 && (a && a.fragmentProgram.usedTimes === 0 && this._releaseProgram(a.fragmentProgram), u = new Yv(o.fragmentShader, "fragment"), this.programs.fragment.set(o.fragmentShader, u), n.createProgram(u));
      const c = this._getRenderCacheKey(e, l, u);
      let h = this.caches.get(c);
      h === void 0 ? (a && a.usedTimes === 0 && this._releasePipeline(a), h = this._getRenderPipeline(e, l, u, c, i)) : e.pipeline = h, h.usedTimes++, l.usedTimes++, u.usedTimes++, s.pipeline = h;
    }
    return s.pipeline;
  }
  delete(e) {
    const i = this.get(e).pipeline;
    return i && (i.usedTimes--, i.usedTimes === 0 && this._releasePipeline(i), i.isComputePipeline ? (i.computeProgram.usedTimes--, i.computeProgram.usedTimes === 0 && this._releaseProgram(i.computeProgram)) : (i.fragmentProgram.usedTimes--, i.vertexProgram.usedTimes--, i.vertexProgram.usedTimes === 0 && this._releaseProgram(i.vertexProgram), i.fragmentProgram.usedTimes === 0 && this._releaseProgram(i.fragmentProgram))), super.delete(e);
  }
  dispose() {
    super.dispose(), this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  updateForRender(e) {
    this.getForRender(e);
  }
  _getComputePipeline(e, i, n, s) {
    n = n || this._getComputeCacheKey(e, i);
    let a = this.caches.get(n);
    return a === void 0 && (a = new kK(n, i), this.caches.set(n, a), this.backend.createComputePipeline(a, s)), a;
  }
  _getRenderPipeline(e, i, n, s, a) {
    s = s || this._getRenderCacheKey(e, i, n);
    let o = this.caches.get(s);
    return o === void 0 && (o = new UK(s, i, n), this.caches.set(s, o), e.pipeline = o, this.backend.createRenderPipeline(e, a)), o;
  }
  _getComputeCacheKey(e, i) {
    return e.id + "," + i.id;
  }
  _getRenderCacheKey(e, i, n) {
    return i.id + "," + n.id + "," + this.backend.getRenderCacheKey(e);
  }
  _releasePipeline(e) {
    this.caches.delete(e.cacheKey);
  }
  _releaseProgram(e) {
    const i = e.code, n = e.stage;
    this.programs[n].delete(i);
  }
  _needsComputeUpdate(e) {
    const i = this.get(e);
    return i.pipeline === void 0 || i.version !== e.version;
  }
  _needsRenderUpdate(e) {
    return this.get(e).pipeline === void 0 || this.backend.needsRenderUpdate(e);
  }
}
class zK extends So {
  constructor(e, i, n, s, a, o) {
    super(), this.backend = e, this.textures = n, this.pipelines = a, this.attributes = s, this.nodes = i, this.info = o, this.pipelines.bindings = this;
  }
  getForRender(e) {
    const i = e.getBindings();
    for (const n of i) {
      const s = this.get(n);
      s.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, i), s.bindGroup = n);
    }
    return i;
  }
  getForCompute(e) {
    const i = this.nodes.getForCompute(e).bindings;
    for (const n of i) {
      const s = this.get(n);
      s.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, i), s.bindGroup = n);
    }
    return i;
  }
  updateForCompute(e) {
    this._updateBindings(this.getForCompute(e));
  }
  updateForRender(e) {
    this._updateBindings(this.getForRender(e));
  }
  _updateBindings(e) {
    for (const i of e)
      this._update(i, e);
  }
  _init(e) {
    for (const i of e.bindings)
      if (i.isSampledTexture)
        this.textures.updateTexture(i.texture);
      else if (i.isStorageBuffer) {
        const n = i.attribute, s = n.isIndirectStorageBufferAttribute ? fs.INDIRECT : fs.STORAGE;
        this.attributes.update(n, s);
      }
  }
  _update(e, i) {
    const { backend: n } = this;
    let s = !1;
    for (const a of e.bindings)
      if (!(a.isNodeUniformsGroup && !this.nodes.updateGroup(a))) {
        if (a.isUniformBuffer)
          a.update() && n.updateBinding(a);
        else if (a.isSampler)
          a.update();
        else if (a.isSampledTexture) {
          a.needsBindingsUpdate(this.textures.get(a.texture).generation) && (s = !0);
          const o = a.update(), l = a.texture;
          o && this.textures.updateTexture(l);
          const u = n.get(l);
          if (n.isWebGPUBackend === !0 && u.texture === void 0 && u.externalTexture === void 0 && (console.error("Bindings._update: binding should be available:", a, o, l, a.textureNode.value, s), this.textures.updateTexture(l), s = !0), l.isStorageTexture === !0) {
            const c = this.get(l);
            a.store === !0 ? c.needsMipmap = !0 : this.textures.needsMipmaps(l) && c.needsMipmap === !0 && (this.backend.generateMipmaps(l), c.needsMipmap = !1);
          }
        }
      }
    s === !0 && this.backend.updateBindings(e, i);
  }
}
function jK(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
}
function BM(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
}
function zM(r) {
  return (r.transmission > 0 || r.transmissionNode) && r.side === $u && r.forceSinglePass === !1;
}
class VK {
  constructor(e, i, n) {
    this.renderItems = [], this.renderItemsIndex = 0, this.opaque = [], this.transparentDoublePass = [], this.transparent = [], this.bundles = [], this.lightsNode = e.getNode(i, n), this.lightsArray = [], this.scene = i, this.camera = n, this.occlusionQueryCount = 0;
  }
  begin() {
    return this.renderItemsIndex = 0, this.opaque.length = 0, this.transparentDoublePass.length = 0, this.transparent.length = 0, this.bundles.length = 0, this.lightsArray.length = 0, this.occlusionQueryCount = 0, this;
  }
  getNextRenderItem(e, i, n, s, a, o) {
    let l = this.renderItems[this.renderItemsIndex];
    return l === void 0 ? (l = {
      id: e.id,
      object: e,
      geometry: i,
      material: n,
      groupOrder: s,
      renderOrder: e.renderOrder,
      z: a,
      group: o
    }, this.renderItems[this.renderItemsIndex] = l) : (l.id = e.id, l.object = e, l.geometry = i, l.material = n, l.groupOrder = s, l.renderOrder = e.renderOrder, l.z = a, l.group = o), this.renderItemsIndex++, l;
  }
  push(e, i, n, s, a, o) {
    const l = this.getNextRenderItem(e, i, n, s, a, o);
    e.occlusionTest === !0 && this.occlusionQueryCount++, n.transparent === !0 || n.transmission > 0 ? (zM(n) && this.transparentDoublePass.push(l), this.transparent.push(l)) : this.opaque.push(l);
  }
  unshift(e, i, n, s, a, o) {
    const l = this.getNextRenderItem(e, i, n, s, a, o);
    n.transparent === !0 || n.transmission > 0 ? (zM(n) && this.transparentDoublePass.unshift(l), this.transparent.unshift(l)) : this.opaque.unshift(l);
  }
  pushBundle(e) {
    this.bundles.push(e);
  }
  pushLight(e) {
    this.lightsArray.push(e);
  }
  sort(e, i) {
    this.opaque.length > 1 && this.opaque.sort(e || jK), this.transparentDoublePass.length > 1 && this.transparentDoublePass.sort(i || BM), this.transparent.length > 1 && this.transparent.sort(i || BM);
  }
  finish() {
    this.lightsNode.setLights(this.lightsArray);
    for (let e = this.renderItemsIndex, i = this.renderItems.length; e < i; e++) {
      const n = this.renderItems[e];
      if (n.id === null) break;
      n.id = null, n.object = null, n.geometry = null, n.material = null, n.groupOrder = null, n.renderOrder = null, n.z = null, n.group = null;
    }
  }
}
class GK {
  constructor(e) {
    this.lighting = e, this.lists = new Ts();
  }
  get(e, i) {
    const n = this.lists, s = [e, i];
    let a = n.get(s);
    return a === void 0 && (a = new VK(this.lighting, e, i), n.set(s, a)), a;
  }
  dispose() {
    this.lists = new Ts();
  }
}
let HK = 0;
class WK {
  constructor() {
    this.id = HK++, this.color = !0, this.clearColor = !0, this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 }, this.depth = !0, this.clearDepth = !0, this.clearDepthValue = 1, this.stencil = !1, this.clearStencil = !0, this.clearStencilValue = 1, this.viewport = !1, this.viewportValue = new $t(), this.scissor = !1, this.scissorValue = new $t(), this.textures = null, this.depthTexture = null, this.activeCubeFace = 0, this.sampleCount = 1, this.width = 0, this.height = 0, this.isRenderContext = !0;
  }
  getCacheKey() {
    return BI(this);
  }
}
function BI(r) {
  const { textures: e, activeCubeFace: i } = r, n = [i];
  for (const s of e)
    n.push(s.id);
  return MP(n);
}
class qK {
  constructor() {
    this.chainMaps = {};
  }
  get(e, i, n = null) {
    const s = [e, i];
    let a;
    if (n === null)
      a = "default";
    else {
      const u = n.texture.format;
      a = `${n.textures.length}:${u}:${n.samples}:${n.depthBuffer}:${n.stencilBuffer}`;
    }
    const o = this.getChainMap(a);
    let l = o.get(s);
    return l === void 0 && (l = new WK(), o.set(s, l)), n !== null && (l.sampleCount = n.samples === 0 ? 1 : n.samples), l;
  }
  getChainMap(e) {
    return this.chainMaps[e] || (this.chainMaps[e] = new Ts());
  }
  dispose() {
    this.chainMaps = {};
  }
}
const XK = /* @__PURE__ */ new oe();
class $K extends So {
  constructor(e, i, n) {
    super(), this.renderer = e, this.backend = i, this.info = n;
  }
  updateRenderTarget(e, i = 0) {
    const n = this.get(e), s = e.samples === 0 ? 1 : e.samples, a = n.depthTextureMips || (n.depthTextureMips = {}), o = e.textures, l = this.getSize(o[0]), u = l.width >> i, c = l.height >> i;
    let h = e.depthTexture || a[i];
    const d = e.depthBuffer === !0 || e.stencilBuffer === !0;
    let p = !1;
    h === void 0 && d && (h = new jc(), h.format = e.stencilBuffer ? Tc : gl, h.type = e.stencilBuffer ? $d : er, h.image.width = u, h.image.height = c, a[i] = h), (n.width !== l.width || l.height !== n.height) && (p = !0, h && (h.needsUpdate = !0, h.image.width = u, h.image.height = c)), n.width = l.width, n.height = l.height, n.textures = o, n.depthTexture = h || null, n.depth = e.depthBuffer, n.stencil = e.stencilBuffer, n.renderTarget = e, n.sampleCount !== s && (p = !0, h && (h.needsUpdate = !0), n.sampleCount = s);
    const f = { sampleCount: s };
    for (let m = 0; m < o.length; m++) {
      const v = o[m];
      p && (v.needsUpdate = !0), this.updateTexture(v, f);
    }
    if (h && this.updateTexture(h, f), n.initialized !== !0) {
      n.initialized = !0;
      const m = () => {
        e.removeEventListener("dispose", m);
        for (let v = 0; v < o.length; v++)
          this._destroyTexture(o[v]);
        h && this._destroyTexture(h), this.delete(e);
      };
      e.addEventListener("dispose", m);
    }
  }
  updateTexture(e, i = {}) {
    const n = this.get(e);
    if (n.initialized === !0 && n.version === e.version) return;
    const s = e.isRenderTargetTexture || e.isDepthTexture || e.isFramebufferTexture, a = this.backend;
    if (s && n.initialized === !0 && (a.destroySampler(e), a.destroyTexture(e)), e.isFramebufferTexture) {
      const c = this.renderer.getRenderTarget();
      c ? e.type = c.texture.type : e.type = ho;
    }
    const { width: o, height: l, depth: u } = this.getSize(e);
    if (i.width = o, i.height = l, i.depth = u, i.needsMipmaps = this.needsMipmaps(e), i.levels = i.needsMipmaps ? this.getMipLevels(e, o, l) : 1, s || e.isStorageTexture === !0)
      a.createSampler(e), a.createTexture(e, i), n.generation = e.version;
    else if (n.initialized !== !0 && a.createSampler(e), e.version > 0) {
      const c = e.image;
      if (c === void 0)
        console.warn("THREE.Renderer: Texture marked for update but image is undefined.");
      else if (c.complete === !1)
        console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");
      else {
        if (e.images) {
          const h = [];
          for (const d of e.images)
            h.push(d);
          i.images = h;
        } else
          i.image = c;
        (n.isDefaultTexture === void 0 || n.isDefaultTexture === !0) && (a.createTexture(e, i), n.isDefaultTexture = !1, n.generation = e.version), e.source.dataReady === !0 && a.updateTexture(e, i), i.needsMipmaps && e.mipmaps.length === 0 && a.generateMipmaps(e);
      }
    } else
      a.createDefaultTexture(e), n.isDefaultTexture = !0, n.generation = e.version;
    if (n.initialized !== !0) {
      n.initialized = !0, n.generation = e.version, this.info.memory.textures++;
      const c = () => {
        e.removeEventListener("dispose", c), this._destroyTexture(e), this.info.memory.textures--;
      };
      e.addEventListener("dispose", c);
    }
    n.version = e.version;
  }
  getSize(e, i = XK) {
    let n = e.images ? e.images[0] : e.image;
    return n ? (n.image !== void 0 && (n = n.image), i.width = n.width, i.height = n.height, i.depth = e.isCubeTexture ? 6 : n.depth || 1) : i.width = i.height = i.depth = 1, i;
  }
  getMipLevels(e, i, n) {
    let s;
    return e.isCompressedTexture ? s = e.mipmaps.length : s = Math.floor(Math.log2(Math.max(i, n))) + 1, s;
  }
  needsMipmaps(e) {
    return this.isEnvironmentTexture(e) || e.isCompressedTexture === !0 || e.generateMipmaps;
  }
  isEnvironmentTexture(e) {
    const i = e.mapping;
    return i === qd || i === Xd || i === Tl || i === _c;
  }
  _destroyTexture(e) {
    this.backend.destroySampler(e), this.backend.destroyTexture(e), this.delete(e);
  }
}
class kT extends Yt {
  constructor(e, i, n, s = 1) {
    super(e, i, n), this.a = s;
  }
  set(e, i, n, s = 1) {
    return this.a = s, super.set(e, i, n);
  }
  copy(e) {
    return e.a !== void 0 && (this.a = e.a), super.copy(e);
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
}
class YK extends Kt {
  static get type() {
    return "ParameterNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isParameterNode = !0;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
class KK extends Mt {
  static get type() {
    return "StackNode";
  }
  constructor(e = null) {
    super(), this.nodes = [], this.outputNode = null, this.parent = e, this._currentCond = null, this.isStackNode = !0;
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : "void";
  }
  add(e) {
    return this.nodes.push(e), this;
  }
  If(e, i) {
    const n = new rm(i);
    return this._currentCond = Fr(e, n), this.add(this._currentCond);
  }
  ElseIf(e, i) {
    const n = new rm(i), s = Fr(e, n);
    return this._currentCond.elseNode = s, this._currentCond = s, this;
  }
  Else(e) {
    return this._currentCond.elseNode = new rm(e), this;
  }
  build(e, ...i) {
    const n = OP();
    zm(this);
    for (const s of this.nodes)
      s.build(e, "void");
    return zm(n), this.outputNode ? this.outputNode.build(e, ...i) : super.build(e, ...i);
  }
  //
  else(...e) {
    return console.warn("TSL.StackNode: .else() has been renamed to .Else()."), this.Else(...e);
  }
  elseif(...e) {
    return console.warn("TSL.StackNode: .elseif() has been renamed to .ElseIf()."), this.ElseIf(...e);
  }
}
const Kv = /* @__PURE__ */ Me(KK);
new Za();
new oe();
new oe();
new oe();
new gi();
new oe(0, 0, -1);
new $t();
new oe();
new oe();
new $t();
new jt();
const ZK = new zc();
Md.flipX();
ZK.depthTexture = new jc(1, 1);
const Zv = /* @__PURE__ */ new gT(-1, 1, 1, -1, 0, 1);
class QK extends Il {
  constructor(e = !1) {
    super();
    const i = e === !1 ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new ya([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new ya(i, 2));
  }
}
const JK = /* @__PURE__ */ new QK();
class zI extends El {
  constructor(e = null) {
    super(JK, e), this.camera = Zv, this.isQuadMesh = !0;
  }
  renderAsync(e) {
    return e.renderAsync(this, Zv);
  }
  render(e) {
    e.render(this, Zv);
  }
}
const wh = /* @__PURE__ */ new Qn(), Qv = /* @__PURE__ */ new gi();
class zr extends Mt {
  static get type() {
    return "SceneNode";
  }
  constructor(e = zr.BACKGROUND_BLURRINESS, i = null) {
    super(), this.scope = e, this.scene = i;
  }
  setup(e) {
    const i = this.scope, n = this.scene !== null ? this.scene : e.scene;
    let s;
    return i === zr.BACKGROUND_BLURRINESS ? s = bi("backgroundBlurriness", "float", n) : i === zr.BACKGROUND_INTENSITY ? s = bi("backgroundIntensity", "float", n) : i === zr.BACKGROUND_ROTATION ? s = Tt("mat4").label("backgroundRotation").setGroup(Ut).onRenderUpdate(() => {
      const a = n.background;
      return a !== null && a.isTexture && a.mapping !== tT ? (wh.copy(n.backgroundRotation), wh.x *= -1, wh.y *= -1, wh.z *= -1, Qv.makeRotationFromEuler(wh)) : Qv.identity(), Qv;
    }) : console.error("THREE.SceneNode: Unknown scope:", i), s;
  }
}
zr.BACKGROUND_BLURRINESS = "backgroundBlurriness";
zr.BACKGROUND_INTENSITY = "backgroundIntensity";
zr.BACKGROUND_ROTATION = "backgroundRotation";
const eZ = /* @__PURE__ */ Ve(zr, zr.BACKGROUND_BLURRINESS), jM = /* @__PURE__ */ Ve(zr, zr.BACKGROUND_INTENSITY), tZ = /* @__PURE__ */ Ve(zr, zr.BACKGROUND_ROTATION), zu = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
}, Qi = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
}, Ji = {
  Store: "store"
}, Oi = {
  Load: "load",
  Clear: "clear"
}, Jv = {
  CCW: "ccw"
}, e0 = {
  None: "none",
  Front: "front",
  Back: "back"
}, Mc = {
  Uint16: "uint16",
  Uint32: "uint32"
}, $ = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
}, t0 = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
}, Zo = {
  Linear: "linear",
  Nearest: "nearest"
}, vt = {
  Zero: "zero",
  One: "one",
  Src: "src",
  OneMinusSrc: "one-minus-src",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  Dst: "dst",
  OneMinusDstColor: "one-minus-dst",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  Constant: "constant",
  OneMinusConstant: "one-minus-constant"
}, Bo = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
}, VM = {
  None: 0,
  All: 15
}, Ha = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
}, Nx = {
  Storage: "storage",
  ReadOnlyStorage: "read-only-storage"
}, GM = {
  WriteOnly: "write-only",
  ReadOnly: "read-only"
}, Eh = {
  Float: "float",
  UnfilterableFloat: "unfilterable-float",
  Depth: "depth",
  SInt: "sint",
  UInt: "uint"
}, HM = {
  TwoD: "2d",
  ThreeD: "3d"
}, yn = {
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  ThreeD: "3d"
}, iZ = {
  All: "all"
}, gf = {
  Vertex: "vertex",
  Instance: "instance"
}, Px = {
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable",
  ClipDistances: "clip-distances",
  DualSourceBlending: "dual-source-blending",
  Subgroups: "subgroups"
}, rZ = /* @__PURE__ */ new jt();
class nZ extends tp {
  static get type() {
    return "PassTextureNode";
  }
  constructor(e, i) {
    super(i), this.passNode = e, this.setUpdateMatrix(!1);
  }
  setup(e) {
    return e.object.isQuadMesh && this.passNode.build(e), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
}
class WM extends nZ {
  static get type() {
    return "PassMultipleTextureNode";
  }
  constructor(e, i, n = !1) {
    super(e, null), this.textureName = i, this.previousTexture = n;
  }
  updateTexture() {
    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
  }
  setup(e) {
    return this.updateTexture(), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.textureName, this.previousTexture);
  }
}
class jg extends zi {
  static get type() {
    return "PassNode";
  }
  constructor(e, i, n, s = {}) {
    super("vec4"), this.scope = e, this.scene = i, this.camera = n, this.options = s, this._pixelRatio = 1, this._width = 1, this._height = 1;
    const a = new jc();
    a.isRenderTargetTexture = !0, a.name = "depth";
    const o = new zc(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: fa, ...s });
    o.texture.name = "output", o.depthTexture = a, this.renderTarget = o, this.updateBeforeType = Rt.FRAME, this._textures = {
      output: o.texture,
      depth: a
    }, this._textureNodes = {}, this._linearDepthNodes = {}, this._viewZNodes = {}, this._previousTextures = {}, this._previousTextureNodes = {}, this._cameraNear = Tt(0), this._cameraFar = Tt(0), this._mrt = null, this.isPassNode = !0;
  }
  setMRT(e) {
    return this._mrt = e, this;
  }
  getMRT() {
    return this._mrt;
  }
  isGlobal() {
    return !0;
  }
  getTexture(e) {
    let i = this._textures[e];
    return i === void 0 && (i = this.renderTarget.texture.clone(), i.isRenderTargetTexture = !0, i.name = e, this._textures[e] = i, this.renderTarget.textures.push(i)), i;
  }
  getPreviousTexture(e) {
    let i = this._previousTextures[e];
    return i === void 0 && (i = this.getTexture(e).clone(), i.isRenderTargetTexture = !0, this._previousTextures[e] = i), i;
  }
  toggleTexture(e) {
    const i = this._previousTextures[e];
    if (i !== void 0) {
      const n = this._textures[e], s = this.renderTarget.textures.indexOf(n);
      this.renderTarget.textures[s] = i, this._textures[e] = i, this._previousTextures[e] = n, this._textureNodes[e].updateTexture(), this._previousTextureNodes[e].updateTexture();
    }
  }
  getTextureNode(e = "output") {
    let i = this._textureNodes[e];
    return i === void 0 && (i = De(new WM(this, e)), i.updateTexture(), this._textureNodes[e] = i), i;
  }
  getPreviousTextureNode(e = "output") {
    let i = this._previousTextureNodes[e];
    return i === void 0 && (this._textureNodes[e] === void 0 && this.getTextureNode(e), i = De(new WM(this, e, !0)), i.updateTexture(), this._previousTextureNodes[e] = i), i;
  }
  getViewZNode(e = "depth") {
    let i = this._viewZNodes[e];
    if (i === void 0) {
      const n = this._cameraNear, s = this._cameraFar;
      this._viewZNodes[e] = i = bI(this.getTextureNode(e), n, s);
    }
    return i;
  }
  getLinearDepthNode(e = "depth") {
    let i = this._linearDepthNodes[e];
    if (i === void 0) {
      const n = this._cameraNear, s = this._cameraFar, a = this.getViewZNode(e);
      this._linearDepthNodes[e] = i = rd(a, n, s);
    }
    return i;
  }
  setup({ renderer: e }) {
    return this.renderTarget.samples = this.options.samples === void 0 ? e.samples : this.options.samples, e.backend.isWebGLBackend === !0 && (this.renderTarget.samples = 0), this.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1, this.scope === jg.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
  }
  updateBefore(e) {
    const { renderer: i } = e, { scene: n, camera: s } = this;
    this._pixelRatio = i.getPixelRatio();
    const a = i.getSize(rZ);
    this.setSize(a.width, a.height);
    const o = i.getRenderTarget(), l = i.getMRT();
    this._cameraNear.value = s.near, this._cameraFar.value = s.far;
    for (const u in this._previousTextures)
      this.toggleTexture(u);
    i.setRenderTarget(this.renderTarget), i.setMRT(this._mrt), i.render(n, s), i.setRenderTarget(o), i.setMRT(l);
  }
  setSize(e, i) {
    this._width = e, this._height = i;
    const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget.setSize(n, s);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget.dispose();
  }
}
jg.COLOR = "color";
jg.DEPTH = "depth";
const sZ = /* @__PURE__ */ Fe(([r, e]) => r.mul(e).clamp()).setLayout({
  name: "linearToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), aZ = /* @__PURE__ */ Fe(([r, e]) => (r = r.mul(e), r.div(r.add(1)).clamp())).setLayout({
  name: "reinhardToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), oZ = /* @__PURE__ */ Fe(([r, e]) => {
  r = r.mul(e), r = r.sub(4e-3).max(0);
  const i = r.mul(r.mul(6.2).add(0.5)), n = r.mul(r.mul(6.2).add(1.7)).add(0.06);
  return i.div(n).pow(2.2);
}).setLayout({
  name: "cineonToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), lZ = /* @__PURE__ */ Fe(([r]) => {
  const e = r.mul(r.add(0.0245786)).sub(90537e-9), i = r.mul(r.add(0.432951).mul(0.983729)).add(0.238081);
  return e.div(i);
}), uZ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = Rr(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  ), n = Rr(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  return r = r.mul(e).div(0.6), r = i.mul(r), r = lZ(r), r = n.mul(r), r.clamp();
}).setLayout({
  name: "acesFilmicToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), cZ = /* @__PURE__ */ Rr(ye(1.6605, -0.1246, -0.0182), ye(-0.5876, 1.1329, -0.1006), ye(-0.0728, -83e-4, 1.1187)), hZ = /* @__PURE__ */ Rr(ye(0.6274, 0.0691, 0.0164), ye(0.3293, 0.9195, 0.088), ye(0.0433, 0.0113, 0.8956)), dZ = /* @__PURE__ */ Fe(([r]) => {
  const e = ye(r).toVar(), i = ye(e.mul(e)).toVar(), n = ye(i.mul(i)).toVar();
  return ve(15.5).mul(n.mul(i)).sub(Dt(40.14, n.mul(e))).add(Dt(31.96, n).sub(Dt(6.868, i.mul(e))).add(Dt(0.4298, i).add(Dt(0.1191, e).sub(232e-5))));
}), pZ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = ye(r).toVar(), n = Rr(ye(0.856627153315983, 0.137318972929847, 0.11189821299995), ye(0.0951212405381588, 0.761241990602591, 0.0767994186031903), ye(0.0482516061458583, 0.101439036467562, 0.811302368396859)), s = Rr(ye(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), ye(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), ye(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405)), a = ve(-12.47393), o = ve(4.026069);
  return i.mulAssign(e), i.assign(hZ.mul(i)), i.assign(n.mul(i)), i.assign(wn(i, 1e-10)), i.assign(va(i)), i.assign(i.sub(a).div(o.sub(a))), i.assign(_a(i, 0, 1)), i.assign(dZ(i)), i.assign(s.mul(i)), i.assign(Dg(wn(ye(0), i), ye(2.2))), i.assign(cZ.mul(i)), i.assign(_a(i, 0, 1)), i;
}).setLayout({
  name: "agxToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), fZ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = ve(0.76), n = ve(0.15);
  r = r.mul(e);
  const s = Td(r.r, Td(r.g, r.b)), a = Fr(s.lessThan(0.08), s.sub(Dt(6.25, s.mul(s))), 0.04);
  r.subAssign(a);
  const o = wn(r.r, wn(r.g, r.b));
  nr(o.lessThan(i), () => r);
  const l = an(1, i), u = an(1, l.mul(l).div(o.add(l.sub(i))));
  r.mulAssign(u.div(o));
  const c = an(1, bo(1, n.mul(o.sub(u)).add(1)));
  return li(r, ye(u), c);
}).setLayout({
  name: "neutralToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
class fr extends Mt {
  static get type() {
    return "CodeNode";
  }
  constructor(e = "", i = [], n = "") {
    super("code"), this.isCodeNode = !0, this.code = e, this.language = n, this.includes = i;
  }
  isGlobal() {
    return !0;
  }
  setIncludes(e) {
    return this.includes = e, this;
  }
  getIncludes() {
    return this.includes;
  }
  generate(e) {
    const i = this.getIncludes(e);
    for (const s of i)
      s.build(e);
    const n = e.getCodeFromNode(this, this.getNodeType(e));
    return n.code = this.code, n.code;
  }
  serialize(e) {
    super.serialize(e), e.code = this.code, e.language = this.language;
  }
  deserialize(e) {
    super.deserialize(e), this.code = e.code, this.language = e.language;
  }
}
class mZ extends fr {
  static get type() {
    return "FunctionNode";
  }
  constructor(e = "", i = [], n = "") {
    super(e, i, n);
  }
  getNodeType(e) {
    return this.getNodeFunction(e).type;
  }
  getInputs(e) {
    return this.getNodeFunction(e).inputs;
  }
  getNodeFunction(e) {
    const i = e.getDataFromNode(this);
    let n = i.nodeFunction;
    return n === void 0 && (n = e.parser.parseFunction(this.code), i.nodeFunction = n), n;
  }
  generate(e, i) {
    super.generate(e);
    const n = this.getNodeFunction(e), s = n.name, a = n.type, o = e.getCodeFromNode(this, a);
    s !== "" && (o.name = s);
    const l = e.getPropertyName(o), u = this.getNodeFunction(e).getCode(l);
    return o.code = u + `
`, i === "property" ? l : e.format(`${l}()`, a, i);
  }
}
class jI extends Mt {
  static get type() {
    return "FogNode";
  }
  constructor(e, i) {
    super("float"), this.isFogNode = !0, this.colorNode = e, this.factorNode = i;
  }
  getViewZNode(e) {
    let i;
    const n = e.context.getViewZ;
    return n !== void 0 && (i = n(this)), (i || rr.z).negate();
  }
  setup() {
    return this.factorNode;
  }
}
class gZ extends jI {
  static get type() {
    return "FogRangeNode";
  }
  constructor(e, i, n) {
    super(e), this.isFogRangeNode = !0, this.nearNode = i, this.farNode = n;
  }
  setup(e) {
    const i = this.getViewZNode(e);
    return Ml(this.nearNode, this.farNode, i);
  }
}
const yZ = /* @__PURE__ */ Me(gZ);
class vZ extends jI {
  static get type() {
    return "FogExp2Node";
  }
  constructor(e, i) {
    super(e), this.isFogExp2Node = !0, this.densityNode = i;
  }
  setup(e) {
    const i = this.getViewZNode(e), n = this.densityNode;
    return n.mul(n, i, i).negate().exp().oneMinus();
  }
}
const bZ = /* @__PURE__ */ Me(vZ);
class xZ extends Mt {
  constructor(e) {
    super(), this.scope = e;
  }
  generate(e) {
    const { scope: i } = this, { renderer: n } = e;
    n.backend.isWebGLBackend === !0 ? e.addFlowCode(`	// ${i}Barrier 
`) : e.addLineFlowCode(`${i}Barrier()`, this);
  }
}
Me(xZ);
class ws extends zi {
  static get type() {
    return "AtomicFunctionNode";
  }
  constructor(e, i, n, s = null) {
    super("uint"), this.method = e, this.pointerNode = i, this.valueNode = n, this.storeNode = s;
  }
  getInputType(e) {
    return this.pointerNode.getNodeType(e);
  }
  getNodeType(e) {
    return this.getInputType(e);
  }
  generate(e) {
    const i = this.method, n = this.getNodeType(e), s = this.getInputType(e), a = this.pointerNode, o = this.valueNode, l = [];
    l.push(`&${a.build(e, s)}`), l.push(o.build(e, s));
    const u = `${e.getMethod(i, n)}( ${l.join(", ")} )`;
    if (this.storeNode !== null) {
      const c = this.storeNode.build(e, s);
      e.addLineFlowCode(`${c} = ${u}`, this);
    } else
      e.addLineFlowCode(u, this);
  }
}
ws.ATOMIC_LOAD = "atomicLoad";
ws.ATOMIC_STORE = "atomicStore";
ws.ATOMIC_ADD = "atomicAdd";
ws.ATOMIC_SUB = "atomicSub";
ws.ATOMIC_MAX = "atomicMax";
ws.ATOMIC_MIN = "atomicMin";
ws.ATOMIC_AND = "atomicAnd";
ws.ATOMIC_OR = "atomicOr";
ws.ATOMIC_XOR = "atomicXor";
Me(ws);
let yf;
function FT(r) {
  yf = yf || /* @__PURE__ */ new WeakMap();
  let e = yf.get(r);
  return e === void 0 && yf.set(r, e = {}), e;
}
function VI(r) {
  const e = FT(r);
  return e.position || (e.position = Tt(new oe()).setGroup(Ut).onRenderUpdate((i, n) => n.value.setFromMatrixPosition(r.matrixWorld)));
}
function _Z(r) {
  const e = FT(r);
  return e.targetPosition || (e.targetPosition = Tt(new oe()).setGroup(Ut).onRenderUpdate((i, n) => n.value.setFromMatrixPosition(r.target.matrixWorld)));
}
function BT(r) {
  const e = FT(r);
  return e.viewPosition || (e.viewPosition = Tt(new oe()).setGroup(Ut).onRenderUpdate(({ camera: i }, n) => {
    n.value = n.value || new oe(), n.value.setFromMatrixPosition(r.matrixWorld), n.value.applyMatrix4(i.matrixWorldInverse);
  }));
}
const GI = (r) => Aa.transformDirection(VI(r).sub(_Z(r))), TZ = (r) => r.sort((e, i) => e.id - i.id), SZ = (r, e) => {
  for (const i of e)
    if (i.isAnalyticLightNode && i.light.id === r)
      return i;
  return null;
}, i0 = /* @__PURE__ */ new WeakMap();
class HI extends Mt {
  static get type() {
    return "LightsNode";
  }
  constructor() {
    super("vec3"), this.totalDiffuseNode = ye().toVar("totalDiffuse"), this.totalSpecularNode = ye().toVar("totalSpecular"), this.outgoingLightNode = ye().toVar("outgoingLight"), this._lights = [], this._lightNodes = null, this._lightNodesHash = null, this.global = !0;
  }
  getHash(e) {
    if (this._lightNodesHash === null) {
      this._lightNodes === null && this.setupLightsNode(e);
      const i = [];
      for (const n of this._lightNodes)
        i.push(n.getSelf().getHash());
      this._lightNodesHash = "lights-" + i.join(",");
    }
    return this._lightNodesHash;
  }
  analyze(e) {
    const i = e.getDataFromNode(this);
    for (const n of i.nodes)
      n.build(e);
  }
  setupLightsNode(e) {
    const i = [], n = this._lightNodes, s = TZ(this._lights), a = e.renderer.library;
    for (const o of s)
      if (o.isNode)
        i.push(De(o));
      else {
        let l = null;
        if (n !== null && (l = SZ(o.id, n)), l === null) {
          const u = a.getLightNodeClass(o.constructor);
          if (u === null) {
            console.warn(`LightsNode.setupNodeLights: Light node not found for ${o.constructor.name}`);
            continue;
          }
          let c = null;
          i0.has(o) ? c = i0.get(o) : (c = De(new u(o)), i0.set(o, c)), i.push(c);
        }
      }
    this._lightNodes = i;
  }
  setupLights(e, i) {
    for (const n of i)
      n.build(e);
  }
  setup(e) {
    this._lightNodes === null && this.setupLightsNode(e);
    const i = e.context, n = i.lightingModel;
    let s = this.outgoingLightNode;
    if (n) {
      const { _lightNodes: a, totalDiffuseNode: o, totalSpecularNode: l } = this;
      i.outgoingLight = s;
      const u = e.addStack(), c = e.getDataFromNode(this);
      c.nodes = u.nodes, n.start(i, u, e), this.setupLights(e, a), n.indirect(i, u, e);
      const { backdrop: h, backdropAlpha: d } = i, { directDiffuse: p, directSpecular: f, indirectDiffuse: m, indirectSpecular: v } = i.reflectedLight;
      let y = p.add(m);
      h !== null && (d !== null ? y = ye(d.mix(y, h)) : y = ye(h), i.material.transparent = !0), o.assign(y), l.assign(f.add(v)), s.assign(o.add(l)), n.finish(i, u, e), s = s.bypass(e.removeStack());
    }
    return s;
  }
  setLights(e) {
    return this._lights = e, this._lightNodes = null, this._lightNodesHash = null, this;
  }
  getLights() {
    return this._lights;
  }
  get hasLights() {
    return this._lights.length > 0;
  }
}
const wZ = Fe(({ depthTexture: r, shadowCoord: e }) => Ci(r, e.xy).compare(e.z)), EZ = Fe(({ depthTexture: r, shadowCoord: e, shadow: i }) => {
  const n = (v, y) => Ci(r, v).compare(y), s = bi("mapSize", "vec2", i).setGroup(Ut), a = bi("radius", "float", i).setGroup(Ut), o = He(1).div(s), l = o.x.negate().mul(a), u = o.y.negate().mul(a), c = o.x.mul(a), h = o.y.mul(a), d = l.div(2), p = u.div(2), f = c.div(2), m = h.div(2);
  return Nr(
    n(e.xy.add(He(l, u)), e.z),
    n(e.xy.add(He(0, u)), e.z),
    n(e.xy.add(He(c, u)), e.z),
    n(e.xy.add(He(d, p)), e.z),
    n(e.xy.add(He(0, p)), e.z),
    n(e.xy.add(He(f, p)), e.z),
    n(e.xy.add(He(l, 0)), e.z),
    n(e.xy.add(He(d, 0)), e.z),
    n(e.xy, e.z),
    n(e.xy.add(He(f, 0)), e.z),
    n(e.xy.add(He(c, 0)), e.z),
    n(e.xy.add(He(d, m)), e.z),
    n(e.xy.add(He(0, m)), e.z),
    n(e.xy.add(He(f, m)), e.z),
    n(e.xy.add(He(l, h)), e.z),
    n(e.xy.add(He(0, h)), e.z),
    n(e.xy.add(He(c, h)), e.z)
  ).mul(1 / 17);
}), MZ = Fe(({ depthTexture: r, shadowCoord: e, shadow: i }) => {
  const n = (h, d) => Ci(r, h).compare(d), s = bi("mapSize", "vec2", i).setGroup(Ut), a = He(1).div(s), o = a.x, l = a.y, u = e.xy, c = To(u.mul(s).add(0.5));
  return u.subAssign(c.mul(a)), Nr(
    n(u, e.z),
    n(u.add(He(o, 0)), e.z),
    n(u.add(He(0, l)), e.z),
    n(u.add(a), e.z),
    li(
      n(u.add(He(o.negate(), 0)), e.z),
      n(u.add(He(o.mul(2), 0)), e.z),
      c.x
    ),
    li(
      n(u.add(He(o.negate(), l)), e.z),
      n(u.add(He(o.mul(2), l)), e.z),
      c.x
    ),
    li(
      n(u.add(He(0, l.negate())), e.z),
      n(u.add(He(0, l.mul(2))), e.z),
      c.y
    ),
    li(
      n(u.add(He(o, l.negate())), e.z),
      n(u.add(He(o, l.mul(2))), e.z),
      c.y
    ),
    li(
      li(
        n(u.add(He(o.negate(), l.negate())), e.z),
        n(u.add(He(o.mul(2), l.negate())), e.z),
        c.x
      ),
      li(
        n(u.add(He(o.negate(), l.mul(2))), e.z),
        n(u.add(He(o.mul(2), l.mul(2))), e.z),
        c.x
      ),
      c.y
    )
  ).mul(1 / 9);
}), AZ = Fe(({ depthTexture: r, shadowCoord: e }) => {
  const i = ve(1).toVar(), n = Ci(r).uv(e.xy).rg, s = ZP(e.z, n.x);
  return nr(s.notEqual(ve(1)), () => {
    const a = e.z.sub(n.x), o = wn(0, n.y.mul(n.y));
    let l = o.div(o.add(a.mul(a)));
    l = _a(an(l, 0.3).div(0.95 - 0.3)), i.assign(_a(wn(s, l)));
  }), i;
}), CZ = Fe(({ samples: r, radius: e, size: i, shadowPass: n }) => {
  const s = ve(0).toVar(), a = ve(0).toVar(), o = r.lessThanEqual(ve(1)).select(ve(0), ve(2).div(r.sub(1))), l = r.lessThanEqual(ve(1)).select(ve(0), ve(-1));
  ps({ start: Mi(0), end: Mi(r), type: "int", condition: "<" }, ({ i: c }) => {
    const h = l.add(ve(c).mul(o)), d = n.uv(Nr(LT.xy, He(0, h).mul(e)).div(i)).x;
    s.addAssign(d), a.addAssign(d.mul(d));
  }), s.divAssign(r), a.divAssign(r);
  const u = wT(a.sub(s.mul(s)));
  return He(s, u);
}), RZ = Fe(({ samples: r, radius: e, size: i, shadowPass: n }) => {
  const s = ve(0).toVar(), a = ve(0).toVar(), o = r.lessThanEqual(ve(1)).select(ve(0), ve(2).div(r.sub(1))), l = r.lessThanEqual(ve(1)).select(ve(0), ve(-1));
  ps({ start: Mi(0), end: Mi(r), type: "int", condition: "<" }, ({ i: c }) => {
    const h = l.add(ve(c).mul(o)), d = n.uv(Nr(LT.xy, He(h, 0).mul(e)).div(i));
    s.addAssign(d.x), a.addAssign(Nr(d.y.mul(d.y), d.x.mul(d.x)));
  }), s.divAssign(r), a.divAssign(r);
  const u = wT(a.sub(s.mul(s)));
  return He(s, u);
}), NZ = [wZ, EZ, MZ, AZ];
let xu = null;
const vf = /* @__PURE__ */ new zI();
class PZ extends Mt {
  static get type() {
    return "ShadowNode";
  }
  constructor(e, i = null) {
    super(), this.light = e, this.shadow = i || e.shadow, this.shadowMap = null, this.vsmShadowMapVertical = null, this.vsmShadowMapHorizontal = null, this.vsmMaterialVertical = null, this.vsmMaterialHorizontal = null, this.updateBeforeType = Rt.RENDER, this._node = null, this.isShadowNode = !0;
  }
  setupShadow(e) {
    const { object: i, renderer: n } = e;
    xu === null && (xu = new Bi(), xu.fragmentNode = _t(0, 0, 0, 1), xu.isShadowNodeMaterial = !0, xu.name = "ShadowMaterial");
    const s = this.shadow, a = n.shadowMap.type, o = new jc(s.mapSize.width, s.mapSize.height);
    o.compareFunction = oT;
    const l = e.createRenderTarget(s.mapSize.width, s.mapSize.height);
    if (l.depthTexture = o, s.camera.updateProjectionMatrix(), a === qp) {
      o.compareFunction = null, this.vsmShadowMapVertical = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: gd, type: fa }), this.vsmShadowMapHorizontal = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: gd, type: fa });
      const _ = Ci(o), x = Ci(this.vsmShadowMapVertical.texture), b = bi("blurSamples", "float", s).setGroup(Ut), T = bi("radius", "float", s).setGroup(Ut), S = bi("mapSize", "vec2", s).setGroup(Ut);
      let w = this.vsmMaterialVertical || (this.vsmMaterialVertical = new Bi());
      w.fragmentNode = CZ({ samples: b, radius: T, size: S, shadowPass: _ }).context(e.getSharedContext()), w.name = "VSMVertical", w = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new Bi()), w.fragmentNode = RZ({ samples: b, radius: T, size: S, shadowPass: x }).context(e.getSharedContext()), w.name = "VSMHorizontal";
    }
    const u = bi("intensity", "float", s).setGroup(Ut), c = bi("bias", "float", s).setGroup(Ut), h = bi("normalBias", "float", s).setGroup(Ut), d = i.material.shadowPositionNode || Tx;
    let p = Tt(s.matrix).setGroup(Ut).mul(d.add(NT.mul(h))), f;
    if (s.camera.isOrthographicCamera || n.logarithmicDepthBuffer !== !0)
      p = p.xyz.div(p.w), f = p.z, n.coordinateSystem === wl && (f = f.mul(2).sub(1));
    else {
      const _ = p.w;
      p = p.xy.div(_);
      const x = Tt("float").onRenderUpdate(() => s.camera.near), b = Tt("float").onRenderUpdate(() => s.camera.far);
      f = xI(_, x, b);
    }
    p = ye(
      p.x,
      p.y.oneMinus(),
      // follow webgpu standards
      f.add(c)
    );
    const m = p.x.greaterThanEqual(0).and(p.x.lessThanEqual(1)).and(p.y.greaterThanEqual(0)).and(p.y.lessThanEqual(1)).and(p.z.lessThanEqual(1)), v = s.filterNode || NZ[n.shadowMap.type] || null;
    if (v === null)
      throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
    const y = Ci(l.texture, p), g = m.select(v({ depthTexture: a === qp ? this.vsmShadowMapHorizontal.texture : o, shadowCoord: p, shadow: s }), ve(1));
    return this.shadowMap = l, this.shadow.map = l, li(1, g.rgb.mix(y, 1), u.mul(y.a));
  }
  setup(e) {
    if (e.renderer.shadowMap.enabled !== !1)
      return this._node !== null ? this._node : this._node = this.setupShadow(e);
  }
  updateShadow(e) {
    const { shadowMap: i, light: n, shadow: s } = this, { renderer: a, scene: o, camera: l } = e, u = a.shadowMap.type, c = i.depthTexture.version;
    this._depthVersionCached = c;
    const h = o.overrideMaterial;
    o.overrideMaterial = xu, i.setSize(s.mapSize.width, s.mapSize.height), s.updateMatrices(n), s.camera.layers.mask = l.layers.mask;
    const d = a.getRenderTarget(), p = a.getRenderObjectFunction();
    a.setRenderObjectFunction((f, ...m) => {
      (f.castShadow === !0 || f.receiveShadow && u === qp) && a.renderObject(f, ...m);
    }), a.setRenderTarget(i), a.render(o, s.camera), a.setRenderObjectFunction(p), n.isPointLight !== !0 && u === qp && this.vsmPass(a), a.setRenderTarget(d), o.overrideMaterial = h;
  }
  vsmPass(e) {
    const { shadow: i } = this;
    this.vsmShadowMapVertical.setSize(i.mapSize.width, i.mapSize.height), this.vsmShadowMapHorizontal.setSize(i.mapSize.width, i.mapSize.height), e.setRenderTarget(this.vsmShadowMapVertical), vf.material = this.vsmMaterialVertical, vf.render(e), e.setRenderTarget(this.vsmShadowMapHorizontal), vf.material = this.vsmMaterialHorizontal, vf.render(e);
  }
  dispose() {
    this.shadowMap.dispose(), this.shadowMap = null, this.vsmShadowMapVertical !== null && (this.vsmShadowMapVertical.dispose(), this.vsmShadowMapVertical = null, this.vsmMaterialVertical.dispose(), this.vsmMaterialVertical = null), this.vsmShadowMapHorizontal !== null && (this.vsmShadowMapHorizontal.dispose(), this.vsmShadowMapHorizontal = null, this.vsmMaterialHorizontal.dispose(), this.vsmMaterialHorizontal = null), this.updateBeforeType = Rt.NONE;
  }
  updateBefore(e) {
    const { shadow: i } = this;
    (i.needsUpdate || i.autoUpdate) && (this.updateShadow(e), this.shadowMap.depthTexture.version === this._depthVersionCached && (i.needsUpdate = !1));
  }
}
const IZ = (r, e) => De(new PZ(r, e));
class Dl extends Gc {
  static get type() {
    return "AnalyticLightNode";
  }
  constructor(e = null) {
    super(), this.updateType = Rt.FRAME, this.light = e, this.color = new Yt(), this.colorNode = Tt(this.color).setGroup(Ut), this.baseColorNode = null, this.shadowNode = null, this.shadowColorNode = null, this.isAnalyticLightNode = !0;
  }
  getCacheKey() {
    return km(super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0);
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(e) {
    const { renderer: i } = e;
    if (i.shadowMap.enabled === !1) return;
    let n = this.shadowColorNode;
    if (n === null) {
      const s = this.light.shadow.shadowNode;
      let a;
      s !== void 0 ? a = De(s) : a = IZ(this.light), this.shadowNode = a, this.shadowColorNode = n = this.colorNode.mul(a), this.baseColorNode = this.colorNode;
    }
    this.colorNode = n;
  }
  setup(e) {
    this.colorNode = this.baseColorNode || this.colorNode, this.light.castShadow ? e.object.receiveShadow && this.setupShadow(e) : this.shadowNode !== null && this.shadowNode.dispose();
  }
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
const WI = /* @__PURE__ */ Fe((r) => {
  const { lightDistance: e, cutoffDistance: i, decayExponent: n } = r, s = e.pow(n).max(0.01).reciprocal();
  return i.greaterThan(0).select(
    s.mul(e.div(i).pow4().oneMinus().clamp().pow2()),
    s
  );
}), OZ = Fe(({ color: r, lightViewPosition: e, cutoffDistance: i, decayExponent: n }, s) => {
  const a = s.context.lightingModel, o = e.sub(rr), l = o.normalize(), u = o.length(), c = WI({
    lightDistance: u,
    cutoffDistance: i,
    decayExponent: n
  }), h = r.mul(c), d = s.context.reflectedLight;
  a.direct({
    lightDirection: l,
    lightColor: h,
    reflectedLight: d
  }, s.stack, s);
});
class DZ extends Dl {
  static get type() {
    return "PointLightNode";
  }
  constructor(e = null) {
    super(e), this.cutoffDistanceNode = Tt(0).setGroup(Ut), this.decayExponentNode = Tt(0).setGroup(Ut);
  }
  update(e) {
    const { light: i } = this;
    super.update(e), this.cutoffDistanceNode.value = i.distance, this.decayExponentNode.value = i.decay;
  }
  setup() {
    OZ({
      color: this.colorNode,
      lightViewPosition: BT(this.light),
      cutoffDistance: this.cutoffDistanceNode,
      decayExponent: this.decayExponentNode
    }).append();
  }
}
const LZ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = r.x, n = r.y, s = r.z;
  let a = e.element(0).mul(0.886227);
  return a = a.add(e.element(1).mul(2 * 0.511664).mul(n)), a = a.add(e.element(2).mul(2 * 0.511664).mul(s)), a = a.add(e.element(3).mul(2 * 0.511664).mul(i)), a = a.add(e.element(4).mul(2 * 0.429043).mul(i).mul(n)), a = a.add(e.element(5).mul(2 * 0.429043).mul(n).mul(s)), a = a.add(e.element(6).mul(s.mul(s).mul(0.743125).sub(0.247708))), a = a.add(e.element(7).mul(2 * 0.429043).mul(i).mul(s)), a = a.add(e.element(8).mul(0.429043).mul(Dt(i, i).sub(Dt(n, n)))), a;
}), Bs = /* @__PURE__ */ new kT();
class UZ extends So {
  constructor(e, i) {
    super(), this.renderer = e, this.nodes = i;
  }
  update(e, i, n) {
    const s = this.renderer, a = this.nodes.getBackgroundNode(e) || e.background;
    let o = !1;
    if (a === null)
      s._clearColor.getRGB(Bs, po), Bs.a = s._clearColor.a;
    else if (a.isColor === !0)
      a.getRGB(Bs, po), Bs.a = 1, o = !0;
    else if (a.isNode === !0) {
      const l = this.get(e), u = a;
      Bs.copy(s._clearColor);
      let c = l.backgroundMesh;
      if (c === void 0) {
        const d = AT(_t(u).mul(jM), {
          // @TODO: Add Texture2D support using node context
          getUV: () => tZ.mul(uI),
          getTextureLevel: () => eZ
        });
        let p = Sx();
        p = p.setZ(p.w);
        const f = new Bi();
        f.name = "Background.material", f.side = Zn, f.depthTest = !1, f.depthWrite = !1, f.fog = !1, f.lights = !1, f.vertexNode = p, f.colorNode = d, l.backgroundMeshNode = d, l.backgroundMesh = c = new El(new pT(1, 32, 32), f), c.frustumCulled = !1, c.name = "Background.mesh", c.onBeforeRender = function(m, v, y) {
          this.matrixWorld.copyPosition(y.matrixWorld);
        };
      }
      const h = u.getCacheKey();
      l.backgroundCacheKey !== h && (l.backgroundMeshNode.node = _t(u).mul(jM), l.backgroundMeshNode.needsUpdate = !0, c.material.needsUpdate = !0, l.backgroundCacheKey = h), i.unshift(c, c.geometry, c.material, 0, 0, null);
    } else
      console.error("THREE.Renderer: Unsupported background configuration.", a);
    if (s.autoClear === !0 || o === !0) {
      const l = n.clearColorValue;
      l.r = Bs.r, l.g = Bs.g, l.b = Bs.b, l.a = Bs.a, (s.backend.isWebGLBackend === !0 || s.alpha === !0) && (l.r *= l.a, l.g *= l.a, l.b *= l.a), n.depthClearValue = s._clearDepth, n.stencilClearValue = s._clearStencil, n.clearColor = s.autoClearColor === !0, n.clearDepth = s.autoClearDepth === !0, n.clearStencil = s.autoClearStencil === !0;
    } else
      n.clearColor = !1, n.clearDepth = !1, n.clearStencil = !1;
  }
}
let kZ = 0;
class Ix {
  constructor(e = "", i = [], n = 0, s = []) {
    this.name = e, this.bindings = i, this.index = n, this.bindingsReference = s, this.id = kZ++;
  }
}
class FZ {
  constructor(e, i, n, s, a, o, l, u, c, h = []) {
    this.vertexShader = e, this.fragmentShader = i, this.computeShader = n, this.transforms = h, this.nodeAttributes = s, this.bindings = a, this.updateNodes = o, this.updateBeforeNodes = l, this.updateAfterNodes = u, this.monitor = c, this.usedTimes = 0;
  }
  createBindings() {
    const e = [];
    for (const i of this.bindings)
      if (i.bindings[0].groupNode.shared !== !0) {
        const n = new Ix(i.name, [], i.index, i);
        e.push(n);
        for (const s of i.bindings)
          n.bindings.push(s.clone());
      } else
        e.push(i);
    return e;
  }
}
class qM {
  constructor(e, i, n = null) {
    this.isNodeAttribute = !0, this.name = e, this.type = i, this.node = n;
  }
}
class BZ {
  constructor(e, i, n) {
    this.isNodeUniform = !0, this.name = e, this.type = i, this.node = n.getSelf();
  }
  get value() {
    return this.node.value;
  }
  set value(e) {
    this.node.value = e;
  }
  get id() {
    return this.node.id;
  }
  get groupNode() {
    return this.node.groupNode;
  }
}
class qI {
  constructor(e, i) {
    this.isNodeVar = !0, this.name = e, this.type = i;
  }
}
class zZ extends qI {
  constructor(e, i) {
    super(e, i), this.needsInterpolation = !1, this.isNodeVarying = !0;
  }
}
class jZ {
  constructor(e, i, n = "") {
    this.name = e, this.type = i, this.code = n, Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
}
let VZ = 0;
class r0 {
  constructor(e = null) {
    this.id = VZ++, this.nodesData = /* @__PURE__ */ new WeakMap(), this.parent = e;
  }
  getData(e) {
    let i = this.nodesData.get(e);
    return i === void 0 && this.parent !== null && (i = this.parent.getData(e)), i;
  }
  setData(e, i) {
    this.nodesData.set(e, i);
  }
}
class Ll {
  constructor(e, i) {
    this.name = e, this.value = i, this.boundary = 0, this.itemSize = 0, this.offset = 0;
  }
  setValue(e) {
    this.value = e;
  }
  getValue() {
    return this.value;
  }
}
class GZ extends Ll {
  constructor(e, i = 0) {
    super(e, i), this.isNumberUniform = !0, this.boundary = 4, this.itemSize = 1;
  }
}
class HZ extends Ll {
  constructor(e, i = new jt()) {
    super(e, i), this.isVector2Uniform = !0, this.boundary = 8, this.itemSize = 2;
  }
}
class WZ extends Ll {
  constructor(e, i = new oe()) {
    super(e, i), this.isVector3Uniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class qZ extends Ll {
  constructor(e, i = new $t()) {
    super(e, i), this.isVector4Uniform = !0, this.boundary = 16, this.itemSize = 4;
  }
}
class XZ extends Ll {
  constructor(e, i = new Yt()) {
    super(e, i), this.isColorUniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class $Z extends Ll {
  constructor(e, i = new Xr()) {
    super(e, i), this.isMatrix3Uniform = !0, this.boundary = 48, this.itemSize = 12;
  }
}
class YZ extends Ll {
  constructor(e, i = new gi()) {
    super(e, i), this.isMatrix4Uniform = !0, this.boundary = 64, this.itemSize = 16;
  }
}
class KZ extends GZ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class ZZ extends HZ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class QZ extends WZ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class JZ extends qZ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class eQ extends XZ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class tQ extends $Z {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class iQ extends YZ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
const ju = 4, XM = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Qo = 20, n0 = /* @__PURE__ */ new gT(-1, 1, 1, -1, 0, 1), rQ = /* @__PURE__ */ new Ys(90, 1), $M = /* @__PURE__ */ new Yt();
let s0 = null, a0 = 0, o0 = 0;
const Wo = (1 + Math.sqrt(5)) / 2, _u = 1 / Wo, YM = [
  /* @__PURE__ */ new oe(-Wo, _u, 0),
  /* @__PURE__ */ new oe(Wo, _u, 0),
  /* @__PURE__ */ new oe(-_u, 0, Wo),
  /* @__PURE__ */ new oe(_u, 0, Wo),
  /* @__PURE__ */ new oe(0, Wo, -_u),
  /* @__PURE__ */ new oe(0, Wo, _u),
  /* @__PURE__ */ new oe(-1, 1, -1),
  /* @__PURE__ */ new oe(1, 1, -1),
  /* @__PURE__ */ new oe(-1, 1, 1),
  /* @__PURE__ */ new oe(1, 1, 1)
], nQ = [
  3,
  1,
  5,
  0,
  4,
  2
], l0 = YY(Ug(), Ta("faceIndex")).normalize(), zT = ye(l0.x, l0.y.negate(), l0.z);
class sQ {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._lodMeshes = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._backgroundBox = null;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, i = 0, n = 0.1, s = 100) {
    s0 = this._renderer.getRenderTarget(), a0 = this._renderer.getActiveCubeFace(), o0 = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const a = this._allocateTargets();
    return a.depthBuffer = !0, this._sceneToCubeUV(e, n, s, a), i > 0 && this._blur(a, 0, 0, i), this._applyPMREM(a), this._cleanup(a), a;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, i = null) {
    return this._fromTexture(e, i);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, i = null) {
    return this._fromTexture(e, i);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  async compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = ZM(), await this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  async compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = QM(), await this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose(), this._backgroundBox !== null && (this._backgroundBox.geometry.dispose(), this._backgroundBox.material.dispose());
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(s0, a0, o0), e.scissorTest = !1, bf(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, i) {
    e.mapping === Tl || e.mapping === _c ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), s0 = this._renderer.getRenderTarget(), a0 = this._renderer.getActiveCubeFace(), o0 = this._renderer.getActiveMipmapLevel();
    const n = i || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), i = 4 * this._cubeSize, n = {
      magFilter: ln,
      minFilter: ln,
      generateMipmaps: !1,
      type: fa,
      format: Fc,
      colorSpace: po
      //depthBuffer: false
    }, s = KM(e, i, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== i) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = KM(e, i, n);
      const { _lodMax: a } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = aQ(a)), this._blurMaterial = oQ(a, e, i);
    }
    return s;
  }
  async _compileMaterial(e) {
    const i = new El(this._lodPlanes[0], e);
    await this._renderer.compile(i, n0);
  }
  _sceneToCubeUV(e, i, n, s) {
    const a = rQ;
    a.near = i, a.far = n;
    const o = [-1, 1, -1, -1, -1, -1], l = [1, 1, 1, -1, -1, -1], u = this._renderer, c = u.autoClear;
    u.getClearColor($M), u.autoClear = !1;
    let h = this._backgroundBox;
    if (h === null) {
      const f = new Ng({
        name: "PMREM.Background",
        side: Zn,
        depthWrite: !1,
        depthTest: !1
      });
      h = new El(new Zd(), f);
    }
    let d = !1;
    const p = e.background;
    p ? p.isColor && (h.material.color.copy(p), e.background = null, d = !0) : (h.material.color.copy($M), d = !0), u.setRenderTarget(s), u.clear(), d && u.render(h, a);
    for (let f = 0; f < 6; f++) {
      const m = f % 3;
      m === 0 ? (a.up.set(0, o[f], 0), a.lookAt(l[f], 0, 0)) : m === 1 ? (a.up.set(0, 0, o[f]), a.lookAt(0, l[f], 0)) : (a.up.set(0, o[f], 0), a.lookAt(0, 0, l[f]));
      const v = this._cubeSize;
      bf(s, m * v, f > 2 ? v : 0, v, v), u.render(e, a);
    }
    u.autoClear = c, e.background = p;
  }
  _textureToCubeUV(e, i) {
    const n = this._renderer, s = e.mapping === Tl || e.mapping === _c;
    s ? this._cubemapMaterial === null && (this._cubemapMaterial = ZM(e)) : this._equirectMaterial === null && (this._equirectMaterial = QM(e));
    const a = s ? this._cubemapMaterial : this._equirectMaterial;
    a.fragmentNode.value = e;
    const o = this._lodMeshes[0];
    o.material = a;
    const l = this._cubeSize;
    bf(i, 0, 0, 3 * l, 2 * l), n.setRenderTarget(i), n.render(o, n0);
  }
  _applyPMREM(e) {
    const i = this._renderer, n = i.autoClear;
    i.autoClear = !1;
    const s = this._lodPlanes.length;
    for (let a = 1; a < s; a++) {
      const o = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1]), l = YM[(s - a - 1) % YM.length];
      this._blur(e, a - 1, a, o, l);
    }
    i.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, i, n, s, a) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      i,
      n,
      s,
      "latitudinal",
      a
    ), this._halfBlur(
      o,
      e,
      n,
      n,
      s,
      "longitudinal",
      a
    );
  }
  _halfBlur(e, i, n, s, a, o, l) {
    const u = this._renderer, c = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const h = 3, d = this._lodMeshes[s];
    d.material = c;
    const p = c.uniforms, f = this._sizeLods[n] - 1, m = isFinite(a) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * Qo - 1), v = a / m, y = isFinite(a) ? 1 + Math.floor(h * v) : Qo;
    y > Qo && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${Qo}`);
    const g = [];
    let _ = 0;
    for (let w = 0; w < Qo; ++w) {
      const A = w / v, E = Math.exp(-A * A / 2);
      g.push(E), w === 0 ? _ += E : w < y && (_ += 2 * E);
    }
    for (let w = 0; w < g.length; w++)
      g[w] = g[w] / _;
    e.texture.frame = (e.texture.frame || 0) + 1, p.envMap.value = e.texture, p.samples.value = y, p.weights.array = g, p.latitudinal.value = o === "latitudinal" ? 1 : 0, l && (p.poleAxis.value = l);
    const { _lodMax: x } = this;
    p.dTheta.value = m, p.mipInt.value = x - n;
    const b = this._sizeLods[s], T = 3 * b * (s > x - ju ? s - x + ju : 0), S = 4 * (this._cubeSize - b);
    bf(i, T, S, 3 * b, 2 * b), u.setRenderTarget(i), u.render(d, n0);
  }
}
function aQ(r) {
  const e = [], i = [], n = [], s = [];
  let a = r;
  const o = r - ju + 1 + XM.length;
  for (let l = 0; l < o; l++) {
    const u = Math.pow(2, a);
    i.push(u);
    let c = 1 / u;
    l > r - ju ? c = XM[l - r + ju - 1] : l === 0 && (c = 0), n.push(c);
    const h = 1 / (u - 2), d = -h, p = 1 + h, f = [d, d, p, d, p, p, d, d, p, p, d, p], m = 6, v = 6, y = 3, g = 2, _ = 1, x = new Float32Array(y * v * m), b = new Float32Array(g * v * m), T = new Float32Array(_ * v * m);
    for (let w = 0; w < m; w++) {
      const A = w % 3 * 2 / 3 - 1, E = w > 2 ? 0 : -1, M = [
        A,
        E,
        0,
        A + 2 / 3,
        E,
        0,
        A + 2 / 3,
        E + 1,
        0,
        A,
        E,
        0,
        A + 2 / 3,
        E + 1,
        0,
        A,
        E + 1,
        0
      ], N = nQ[w];
      x.set(M, y * v * N), b.set(f, g * v * N);
      const k = [N, N, N, N, N, N];
      T.set(k, _ * v * N);
    }
    const S = new Il();
    S.setAttribute("position", new Tn(x, y)), S.setAttribute("uv", new Tn(b, g)), S.setAttribute("faceIndex", new Tn(T, _)), e.push(S), s.push(new El(S, null)), a > ju && a--;
  }
  return { lodPlanes: e, sizeLods: i, sigmas: n, lodMeshes: s };
}
function KM(r, e, i) {
  const n = new zc(r, e, i);
  return n.texture.mapping = Kb, n.texture.name = "PMREM.cubeUv", n.texture.isPMREMTexture = !0, n.scissorTest = !0, n;
}
function bf(r, e, i, n, s) {
  r.viewport.set(e, i, n, s), r.scissor.set(e, i, n, s);
}
function jT(r) {
  const e = new Bi();
  return e.depthTest = !1, e.depthWrite = !1, e.blending = xc, e.name = `PMREM_${r}`, e;
}
function oQ(r, e, i) {
  const n = Ed(new Array(Qo).fill(0)), s = Tt(new oe(0, 1, 0)), a = Tt(0), o = ve(Qo), l = Tt(0), u = Tt(1), c = Ci(null), h = Tt(0), d = ve(1 / e), p = ve(1 / i), f = ve(r), m = {
    n: o,
    latitudinal: l,
    weights: n,
    poleAxis: s,
    outputDirection: zT,
    dTheta: a,
    samples: u,
    envMap: c,
    mipInt: h,
    CUBEUV_TEXEL_WIDTH: d,
    CUBEUV_TEXEL_HEIGHT: p,
    CUBEUV_MAX_MIP: f
  }, v = jT("blur");
  return v.uniforms = m, v.fragmentNode = ZY({ ...m, latitudinal: l.equal(1) }), v;
}
function ZM(r) {
  const e = jT("cubemap");
  return e.fragmentNode = wd(r, zT), e;
}
function QM(r) {
  const e = jT("equirect");
  return e.fragmentNode = Ci(r, SI(zT), 0), e;
}
const JM = /* @__PURE__ */ new WeakMap(), lQ = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]), uQ = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]), xf = (r) => /e/g.test(r) ? String(r).replace(/\+/g, "") : (r = Number(r), r + (r % 1 ? "" : ".0"));
class XI {
  constructor(e, i, n) {
    this.object = e, this.material = e && e.material || null, this.geometry = e && e.geometry || null, this.renderer = i, this.parser = n, this.scene = null, this.camera = null, this.nodes = [], this.sequentialNodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.updateAfterNodes = [], this.hashNodes = {}, this.monitor = null, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.clippingContext = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = { vertex: [], fragment: [], compute: [] }, this.flowCode = { vertex: "", fragment: "", compute: "" }, this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }, this.structs = { vertex: [], fragment: [], compute: [], index: 0 }, this.bindings = { vertex: {}, fragment: {}, compute: {} }, this.bindingsIndexes = {}, this.bindGroups = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.codes = {}, this.vars = {}, this.flow = { code: "" }, this.chaining = [], this.stack = Kv(), this.stacks = [], this.tab = "	", this.currentFunctionNode = null, this.context = {
      material: this.material
    }, this.cache = new r0(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null, this.useComparisonMethod = !1;
  }
  getBindGroupsCache() {
    let e = JM.get(this.renderer);
    return e === void 0 && (e = new Ts(), JM.set(this.renderer, e)), e;
  }
  createRenderTarget(e, i, n) {
    return new zc(e, i, n);
  }
  createCubeRenderTarget(e, i) {
    return new wI(e, i);
  }
  createPMREMGenerator() {
    return new sQ(this.renderer);
  }
  includes(e) {
    return this.nodes.includes(e);
  }
  _getBindGroup(e, i) {
    const n = this.getBindGroupsCache(), s = [];
    let a = !0;
    for (const l of i)
      s.push(l), a = a && l.groupNode.shared !== !0;
    let o;
    return a ? (o = n.get(s), o === void 0 && (o = new Ix(e, s, this.bindingsIndexes[e].group, s), n.set(s, o))) : o = new Ix(e, s, this.bindingsIndexes[e].group, s), o;
  }
  getBindGroupArray(e, i) {
    const n = this.bindings[i];
    let s = n[e];
    return s === void 0 && (this.bindingsIndexes[e] === void 0 && (this.bindingsIndexes[e] = { binding: 0, group: Object.keys(this.bindingsIndexes).length }), n[e] = s = []), s;
  }
  getBindings() {
    let e = this.bindGroups;
    if (e === null) {
      const i = {}, n = this.bindings;
      for (const s of tM)
        for (const a in n[s]) {
          const o = n[s][a];
          (i[a] || (i[a] = [])).push(...o);
        }
      e = [];
      for (const s in i) {
        const a = i[s], o = this._getBindGroup(s, a);
        e.push(o);
      }
      this.bindGroups = e;
    }
    return e;
  }
  sortBindingGroups() {
    const e = this.getBindings();
    e.sort((i, n) => i.bindings[0].groupNode.order - n.bindings[0].groupNode.order);
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      this.bindingsIndexes[n.name].group = i, n.index = i;
    }
  }
  setHashNode(e, i) {
    this.hashNodes[i] = e;
  }
  addNode(e) {
    this.nodes.includes(e) === !1 && (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
  }
  addSequentialNode(e) {
    this.sequentialNodes.includes(e) === !1 && this.sequentialNodes.push(e);
  }
  buildUpdateNodes() {
    for (const e of this.nodes)
      e.getUpdateType() !== Rt.NONE && this.updateNodes.push(e.getSelf());
    for (const e of this.sequentialNodes) {
      const i = e.getUpdateBeforeType(), n = e.getUpdateAfterType();
      i !== Rt.NONE && this.updateBeforeNodes.push(e.getSelf()), n !== Rt.NONE && this.updateAfterNodes.push(e.getSelf());
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  isFilteredTexture(e) {
    return e.magFilter === ln || e.magFilter === Qb || e.magFilter === Ku || e.magFilter === pa || e.minFilter === ln || e.minFilter === Qb || e.minFilter === Ku || e.minFilter === pa;
  }
  addChain(e) {
    this.chaining.push(e);
  }
  removeChain(e) {
    if (this.chaining.pop() !== e)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  getMethod(e) {
    return e;
  }
  getNodeFromHash(e) {
    return this.hashNodes[e];
  }
  addFlow(e, i) {
    return this.flowNodes[e].push(i), i;
  }
  setContext(e) {
    this.context = e;
  }
  getContext() {
    return this.context;
  }
  getSharedContext() {
    return { ...this.context }, this.context;
  }
  setCache(e) {
    this.cache = e;
  }
  getCache() {
    return this.cache;
  }
  getCacheFromNode(e, i = !0) {
    const n = this.getDataFromNode(e);
    return n.cache === void 0 && (n.cache = new r0(i ? this.getCache() : null)), n.cache;
  }
  isAvailable() {
    return !1;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getDrawIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return !1;
  }
  increaseUsage(e) {
    const i = this.getDataFromNode(e);
    return i.usageCount = i.usageCount === void 0 ? 1 : i.usageCount + 1, i.usageCount;
  }
  generateTexture() {
    console.warn("Abstract function.");
  }
  generateTextureLod() {
    console.warn("Abstract function.");
  }
  generateConst(e, i = null) {
    if (i === null && (e === "float" || e === "int" || e === "uint" ? i = 0 : e === "bool" ? i = !1 : e === "color" ? i = new Yt() : e === "vec2" ? i = new jt() : e === "vec3" ? i = new oe() : e === "vec4" && (i = new $t())), e === "float") return xf(i);
    if (e === "int") return `${Math.round(i)}`;
    if (e === "uint") return i >= 0 ? `${Math.round(i)}u` : "0u";
    if (e === "bool") return i ? "true" : "false";
    if (e === "color") return `${this.getType("vec3")}( ${xf(i.r)}, ${xf(i.g)}, ${xf(i.b)} )`;
    const n = this.getTypeLength(e), s = this.getComponentType(e), a = (o) => this.generateConst(s, o);
    if (n === 2)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)} )`;
    if (n === 3)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)}, ${a(i.z)} )`;
    if (n === 4)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)}, ${a(i.z)}, ${a(i.w)} )`;
    if (n > 4 && i && (i.isMatrix3 || i.isMatrix4))
      return `${this.getType(e)}( ${i.elements.map(a).join(", ")} )`;
    if (n > 4)
      return `${this.getType(e)}()`;
    throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`);
  }
  getType(e) {
    return e === "color" ? "vec3" : e;
  }
  hasGeometryAttribute(e) {
    return this.geometry && this.geometry.getAttribute(e) !== void 0;
  }
  getAttribute(e, i) {
    const n = this.attributes;
    for (const a of n)
      if (a.name === e)
        return a;
    const s = new qM(e, i);
    return n.push(s), s;
  }
  getPropertyName(e) {
    return e.name;
  }
  isVector(e) {
    return /vec\d/.test(e);
  }
  isMatrix(e) {
    return /mat\d/.test(e);
  }
  isReference(e) {
    return e === "void" || e === "property" || e === "sampler" || e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "depthTexture" || e === "texture3D";
  }
  needsToWorkingColorSpace() {
    return !1;
  }
  getComponentTypeFromTexture(e) {
    const i = e.type;
    if (e.isDataTexture) {
      if (i === Sr) return "int";
      if (i === er) return "uint";
    }
    return "float";
  }
  getElementType(e) {
    return e === "mat2" ? "vec2" : e === "mat3" ? "vec3" : e === "mat4" ? "vec4" : this.getComponentType(e);
  }
  getComponentType(e) {
    if (e = this.getVectorType(e), e === "float" || e === "bool" || e === "int" || e === "uint") return e;
    const i = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
    return i === null ? null : i[1] === "b" ? "bool" : i[1] === "i" ? "int" : i[1] === "u" ? "uint" : "float";
  }
  getVectorType(e) {
    return e === "color" ? "vec3" : e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "texture3D" ? "vec4" : e;
  }
  getTypeFromLength(e, i = "float") {
    if (e === 1) return i;
    const n = lQ.get(e);
    return (i === "float" ? "" : i[0]) + n;
  }
  getTypeFromArray(e) {
    return uQ.get(e.constructor);
  }
  getTypeFromAttribute(e) {
    let i = e;
    e.isInterleavedBufferAttribute && (i = e.data);
    const n = i.array, s = e.itemSize, a = e.normalized;
    let o;
    return !(e instanceof lP) && a !== !0 && (o = this.getTypeFromArray(n)), this.getTypeFromLength(s, o);
  }
  getTypeLength(e) {
    const i = this.getVectorType(e), n = /vec([2-4])/.exec(i);
    return n !== null ? Number(n[1]) : i === "float" || i === "bool" || i === "int" || i === "uint" ? 1 : /mat2/.test(e) === !0 ? 4 : /mat3/.test(e) === !0 ? 9 : /mat4/.test(e) === !0 ? 16 : 0;
  }
  getVectorFromMatrix(e) {
    return e.replace("mat", "vec");
  }
  changeComponentType(e, i) {
    return this.getTypeFromLength(this.getTypeLength(e), i);
  }
  getIntegerType(e) {
    const i = this.getComponentType(e);
    return i === "int" || i === "uint" ? e : this.changeComponentType(e, "int");
  }
  addStack() {
    return this.stack = Kv(this.stack), this.stacks.push(OP() || this.stack), zm(this.stack), this.stack;
  }
  removeStack() {
    const e = this.stack;
    return this.stack = e.parent, zm(this.stacks.pop()), e;
  }
  getDataFromNode(e, i = this.shaderStage, n = null) {
    n = n === null ? e.isGlobal(this) ? this.globalCache : this.cache : n;
    let s = n.getData(e);
    return s === void 0 && (s = {}, n.setData(e, s)), s[i] === void 0 && (s[i] = {}), s[i];
  }
  getNodeProperties(e, i = "any") {
    const n = this.getDataFromNode(e, i);
    return n.properties || (n.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(e, i) {
    const n = this.getDataFromNode(e);
    let s = n.bufferAttribute;
    if (s === void 0) {
      const a = this.uniforms.index++;
      s = new qM("nodeAttribute" + a, i, e), this.bufferAttributes.push(s), n.bufferAttribute = s;
    }
    return s;
  }
  getStructTypeFromNode(e, i = this.shaderStage) {
    const n = this.getDataFromNode(e, i);
    if (n.structType === void 0) {
      const s = this.structs.index++;
      e.name = `StructType${s}`, this.structs[i].push(e), n.structType = e;
    }
    return e;
  }
  getUniformFromNode(e, i, n = this.shaderStage, s = null) {
    const a = this.getDataFromNode(e, n, this.globalCache);
    let o = a.uniform;
    if (o === void 0) {
      const l = this.uniforms.index++;
      o = new BZ(s || "nodeUniform" + l, i, e), this.uniforms[n].push(o), a.uniform = o;
    }
    return o;
  }
  getVarFromNode(e, i = null, n = e.getNodeType(this), s = this.shaderStage) {
    const a = this.getDataFromNode(e, s);
    let o = a.variable;
    if (o === void 0) {
      const l = this.vars[s] || (this.vars[s] = []);
      i === null && (i = "nodeVar" + l.length), o = new qI(i, n), l.push(o), a.variable = o;
    }
    return o;
  }
  getVaryingFromNode(e, i = null, n = e.getNodeType(this)) {
    const s = this.getDataFromNode(e, "any");
    let a = s.varying;
    if (a === void 0) {
      const o = this.varyings, l = o.length;
      i === null && (i = "nodeVarying" + l), a = new zZ(i, n), o.push(a), s.varying = a;
    }
    return a;
  }
  getCodeFromNode(e, i, n = this.shaderStage) {
    const s = this.getDataFromNode(e);
    let a = s.code;
    if (a === void 0) {
      const o = this.codes[n] || (this.codes[n] = []), l = o.length;
      a = new jZ("nodeCode" + l, i), o.push(a), s.code = a;
    }
    return a;
  }
  addFlowCodeHierarchy(e, i) {
    const { flowCodes: n, flowCodeBlock: s } = this.getDataFromNode(e);
    let a = !0, o = i;
    for (; o; ) {
      if (s.get(o) === !0) {
        a = !1;
        break;
      }
      o = this.getDataFromNode(o).parentNodeBlock;
    }
    if (a)
      for (const l of n)
        this.addLineFlowCode(l);
  }
  addLineFlowCodeBlock(e, i, n) {
    const s = this.getDataFromNode(e), a = s.flowCodes || (s.flowCodes = []), o = s.flowCodeBlock || (s.flowCodeBlock = /* @__PURE__ */ new WeakMap());
    a.push(i), o.set(n, !0);
  }
  addLineFlowCode(e, i = null) {
    return e === "" ? this : (i !== null && this.context.nodeBlock && this.addLineFlowCodeBlock(i, e, this.context.nodeBlock), e = this.tab + e, /;\s*$/.test(e) || (e = e + `;
`), this.flow.code += e, this);
  }
  addFlowCode(e) {
    return this.flow.code += e, this;
  }
  addFlowTab() {
    return this.tab += "	", this;
  }
  removeFlowTab() {
    return this.tab = this.tab.slice(0, -1), this;
  }
  getFlowData(e) {
    return this.flowsData.get(e);
  }
  flowNode(e) {
    const i = e.getNodeType(this), n = this.flowChildNode(e, i);
    return this.flowsData.set(e, n), n;
  }
  buildFunctionNode(e) {
    const i = new mZ(), n = this.currentFunctionNode;
    return this.currentFunctionNode = i, i.code = this.buildFunctionCode(e), this.currentFunctionNode = n, i;
  }
  flowShaderNode(e) {
    const i = e.layout, n = {
      [Symbol.iterator]() {
        let o = 0;
        const l = Object.values(this);
        return {
          next: () => ({
            value: l[o],
            done: o++ >= l.length
          })
        };
      }
    };
    for (const o of i.inputs)
      n[o.name] = new YK(o.type, o.name);
    e.layout = null;
    const s = e.call(n), a = this.flowStagesNode(s, i.type);
    return e.layout = i, a;
  }
  flowStagesNode(e, i = null) {
    const n = this.flow, s = this.vars, a = this.cache, o = this.buildStage, l = this.stack, u = {
      code: ""
    };
    this.flow = u, this.vars = {}, this.cache = new r0(), this.stack = Kv();
    for (const c of eM)
      this.setBuildStage(c), u.result = e.build(this, i);
    return u.vars = this.getVars(this.shaderStage), this.flow = n, this.vars = s, this.cache = a, this.stack = l, this.setBuildStage(o), u;
  }
  getFunctionOperator() {
    return null;
  }
  flowChildNode(e, i = null) {
    const n = this.flow, s = {
      code: ""
    };
    return this.flow = s, s.result = e.build(this, i), this.flow = n, s;
  }
  flowNodeFromShaderStage(e, i, n = null, s = null) {
    const a = this.shaderStage;
    this.setShaderStage(e);
    const o = this.flowChildNode(i, n);
    return s !== null && (o.code += `${this.tab + s} = ${o.result};
`), this.flowCode[e] = this.flowCode[e] + o.code, this.setShaderStage(a), o;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(e, i) {
    return `${this.getType(e)} ${i}`;
  }
  getVars(e) {
    let i = "";
    const n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i += `${this.getVar(s.type, s.name)}; `;
    return i;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(e) {
    const i = this.codes[e];
    let n = "";
    if (i !== void 0)
      for (const s of i)
        n += s.code + `
`;
    return n;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(e) {
    this.shaderStage = e;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(e) {
    this.buildStage = e;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    const { object: e, material: i, renderer: n } = this;
    if (i !== null) {
      let s = n.library.fromMaterial(i);
      s === null && (console.error(`NodeMaterial: Material "${i.type}" is not compatible.`), s = new Bi()), s.build(this);
    } else
      this.addFlow("compute", e);
    for (const s of eM) {
      this.setBuildStage(s), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const a of tM) {
        this.setShaderStage(a);
        const o = this.flowNodes[a];
        for (const l of o)
          s === "generate" ? this.flowNode(l) : l.build(this);
      }
    }
    return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
  }
  getNodeUniform(e, i) {
    if (i === "float" || i === "int" || i === "uint") return new KZ(e);
    if (i === "vec2" || i === "ivec2" || i === "uvec2") return new ZZ(e);
    if (i === "vec3" || i === "ivec3" || i === "uvec3") return new QZ(e);
    if (i === "vec4" || i === "ivec4" || i === "uvec4") return new JZ(e);
    if (i === "color") return new eQ(e);
    if (i === "mat3") return new tQ(e);
    if (i === "mat4") return new iQ(e);
    throw new Error(`Uniform "${i}" not declared.`);
  }
  createNodeMaterial(e = "NodeMaterial") {
    throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${e}() instead.`);
  }
  format(e, i, n) {
    if (i = this.getVectorType(i), n = this.getVectorType(n), i === n || n === null || this.isReference(n))
      return e;
    const s = this.getTypeLength(i), a = this.getTypeLength(n);
    return s === 16 && a === 9 ? `${this.getType(n)}(${e}[0].xyz, ${e}[1].xyz, ${e}[2].xyz)` : s === 9 && a === 4 ? `${this.getType(n)}(${e}[0].xy, ${e}[1].xy)` : s > 4 || a > 4 || a === 0 ? e : s === a ? `${this.getType(n)}( ${e} )` : s > a ? this.format(`${e}.${"xyz".slice(0, a)}`, this.getTypeFromLength(a, this.getComponentType(i)), n) : a === 4 && s > 1 ? `${this.getType(n)}( ${this.format(e, i, "vec3")}, 1.0 )` : s === 2 ? `${this.getType(n)}( ${this.format(e, i, "vec2")}, 0.0 )` : (s === 1 && a > 1 && i !== this.getComponentType(n) && (e = `${this.getType(this.getComponentType(n))}( ${e} )`), `${this.getType(n)}( ${e} )`);
  }
  getSignature() {
    return `// Three.js r${Cg} - Node System
`;
  }
}
class eA {
  constructor() {
    this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.startTime = null, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.updateAfterMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
  }
  _getMaps(e, i) {
    let n = e.get(i);
    return n === void 0 && (n = {
      renderMap: /* @__PURE__ */ new WeakMap(),
      frameMap: /* @__PURE__ */ new WeakMap()
    }, e.set(i, n)), n;
  }
  updateBeforeNode(e) {
    const i = e.getUpdateBeforeType(), n = e.updateReference(this);
    if (i === Rt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateBeforeMap, n);
      s.get(n) !== this.frameId && e.updateBefore(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Rt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateBeforeMap, n);
      s.get(n) !== this.renderId && e.updateBefore(this) !== !1 && s.set(n, this.renderId);
    } else i === Rt.OBJECT && e.updateBefore(this);
  }
  updateAfterNode(e) {
    const i = e.getUpdateAfterType(), n = e.updateReference(this);
    if (i === Rt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateAfterMap, n);
      s.get(n) !== this.frameId && e.updateAfter(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Rt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateAfterMap, n);
      s.get(n) !== this.renderId && e.updateAfter(this) !== !1 && s.set(n, this.renderId);
    } else i === Rt.OBJECT && e.updateAfter(this);
  }
  updateNode(e) {
    const i = e.getUpdateType(), n = e.updateReference(this);
    if (i === Rt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateMap, n);
      s.get(n) !== this.frameId && e.update(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Rt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateMap, n);
      s.get(n) !== this.renderId && e.update(this) !== !1 && s.set(n, this.renderId);
    } else i === Rt.OBJECT && e.update(this);
  }
  update() {
    this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
  }
}
class VT {
  constructor(e, i, n = null, s = "", a = !1) {
    this.type = e, this.name = i, this.count = n, this.qualifier = s, this.isConst = a;
  }
}
VT.isNodeFunctionInput = !0;
class cQ extends Dl {
  static get type() {
    return "DirectionalLightNode";
  }
  constructor(e = null) {
    super(e);
  }
  setup(e) {
    super.setup(e);
    const i = e.context.lightingModel, n = this.colorNode, s = GI(this.light), a = e.context.reflectedLight;
    i.direct({
      lightDirection: s,
      lightColor: n,
      reflectedLight: a
    }, e.stack, e);
  }
}
const u0 = /* @__PURE__ */ new gi(), _f = /* @__PURE__ */ new gi();
let Mh = null;
class hQ extends Dl {
  static get type() {
    return "RectAreaLightNode";
  }
  constructor(e = null) {
    super(e), this.halfHeight = Tt(new oe()).setGroup(Ut), this.halfWidth = Tt(new oe()).setGroup(Ut), this.updateType = Rt.RENDER;
  }
  update(e) {
    super.update(e);
    const { light: i } = this, n = e.camera.matrixWorldInverse;
    _f.identity(), u0.copy(i.matrixWorld), u0.premultiply(n), _f.extractRotation(u0), this.halfWidth.value.set(i.width * 0.5, 0, 0), this.halfHeight.value.set(0, i.height * 0.5, 0), this.halfWidth.value.applyMatrix4(_f), this.halfHeight.value.applyMatrix4(_f);
  }
  setup(e) {
    super.setup(e);
    let i, n;
    e.isAvailable("float32Filterable") ? (i = Ci(Mh.LTC_FLOAT_1), n = Ci(Mh.LTC_FLOAT_2)) : (i = Ci(Mh.LTC_HALF_1), n = Ci(Mh.LTC_HALF_2));
    const { colorNode: s, light: a } = this, o = e.context.lightingModel, l = BT(a), u = e.context.reflectedLight;
    o.directRectArea({
      lightColor: s,
      lightPosition: l,
      halfWidth: this.halfWidth,
      halfHeight: this.halfHeight,
      reflectedLight: u,
      ltc_1: i,
      ltc_2: n
    }, e.stack, e);
  }
  static setLTC(e) {
    Mh = e;
  }
}
class $I extends Dl {
  static get type() {
    return "SpotLightNode";
  }
  constructor(e = null) {
    super(e), this.coneCosNode = Tt(0).setGroup(Ut), this.penumbraCosNode = Tt(0).setGroup(Ut), this.cutoffDistanceNode = Tt(0).setGroup(Ut), this.decayExponentNode = Tt(0).setGroup(Ut);
  }
  update(e) {
    super.update(e);
    const { light: i } = this;
    this.coneCosNode.value = Math.cos(i.angle), this.penumbraCosNode.value = Math.cos(i.angle * (1 - i.penumbra)), this.cutoffDistanceNode.value = i.distance, this.decayExponentNode.value = i.decay;
  }
  getSpotAttenuation(e) {
    const { coneCosNode: i, penumbraCosNode: n } = this;
    return Ml(i, n, e);
  }
  setup(e) {
    super.setup(e);
    const i = e.context.lightingModel, { colorNode: n, cutoffDistanceNode: s, decayExponentNode: a, light: o } = this, l = BT(o).sub(rr), u = l.normalize(), c = u.dot(GI(o)), h = this.getSpotAttenuation(c), d = l.length(), p = WI({
      lightDistance: d,
      cutoffDistance: s,
      decayExponent: a
    }), f = n.mul(h).mul(p), m = e.context.reflectedLight;
    i.direct({
      lightDirection: u,
      lightColor: f,
      reflectedLight: m
    }, e.stack, e);
  }
}
class dQ extends $I {
  static get type() {
    return "IESSpotLightNode";
  }
  getSpotAttenuation(e) {
    const i = this.light.iesMap;
    let n = null;
    if (i && i.isTexture === !0) {
      const s = e.acos().mul(1 / Math.PI);
      n = Ci(i, He(s, 0), 0).r;
    } else
      n = super.getSpotAttenuation(e);
    return n;
  }
}
class pQ extends Dl {
  static get type() {
    return "AmbientLightNode";
  }
  constructor(e = null) {
    super(e);
  }
  setup({ context: e }) {
    e.irradiance.addAssign(this.colorNode);
  }
}
class fQ extends Dl {
  static get type() {
    return "HemisphereLightNode";
  }
  constructor(e = null) {
    super(e), this.lightPositionNode = VI(e), this.lightDirectionNode = this.lightPositionNode.normalize(), this.groundColorNode = Tt(new Yt()).setGroup(Ut);
  }
  update(e) {
    const { light: i } = this;
    super.update(e), this.lightPositionNode.object3d = i, this.groundColorNode.value.copy(i.groundColor).multiplyScalar(i.intensity);
  }
  setup(e) {
    const { colorNode: i, groundColorNode: n, lightDirectionNode: s } = this, a = Jn.dot(s).mul(0.5).add(0.5), o = li(n, i, a);
    e.context.irradiance.addAssign(o);
  }
}
class mQ extends Dl {
  static get type() {
    return "LightProbeNode";
  }
  constructor(e = null) {
    super(e);
    const i = [];
    for (let n = 0; n < 9; n++) i.push(new oe());
    this.lightProbe = Ed(i);
  }
  update(e) {
    const { light: i } = this;
    super.update(e);
    for (let n = 0; n < 9; n++)
      this.lightProbe.array[n].copy(i.sh.coefficients[n]).multiplyScalar(i.intensity);
  }
  setup(e) {
    const i = LZ(uI, this.lightProbe);
    e.context.irradiance.addAssign(i);
  }
}
class YI {
  parseFunction() {
    console.warn("Abstract function.");
  }
}
class GT {
  constructor(e, i, n = "", s = "") {
    this.type = e, this.inputs = i, this.name = n, this.precision = s;
  }
  getCode() {
    console.warn("Abstract function.");
  }
}
GT.isNodeFunction = !0;
const gQ = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, yQ = /[a-z_0-9]+/ig, tA = "#pragma main", vQ = (r) => {
  r = r.trim();
  const e = r.indexOf(tA), i = e !== -1 ? r.slice(e + tA.length) : r, n = i.match(gQ);
  if (n !== null && n.length === 5) {
    const s = n[4], a = [];
    let o = null;
    for (; (o = yQ.exec(s)) !== null; )
      a.push(o);
    const l = [];
    let u = 0;
    for (; u < a.length; ) {
      const m = a[u][0] === "const";
      m === !0 && u++;
      let v = a[u][0];
      v === "in" || v === "out" || v === "inout" ? u++ : v = "";
      const y = a[u++][0];
      let g = Number.parseInt(a[u][0]);
      Number.isNaN(g) === !1 ? u++ : g = null;
      const _ = a[u++][0];
      l.push(new VT(y, _, g, v, m));
    }
    const c = i.substring(n[0].length), h = n[3] !== void 0 ? n[3] : "", d = n[2], p = n[1] !== void 0 ? n[1] : "", f = e !== -1 ? r.slice(0, e) : "";
    return {
      type: d,
      inputs: l,
      name: h,
      precision: p,
      inputsCode: s,
      blockCode: c,
      headerCode: f
    };
  } else
    throw new Error("FunctionNode: Function is not a GLSL code.");
};
class bQ extends GT {
  constructor(e) {
    const { type: i, inputs: n, name: s, precision: a, inputsCode: o, blockCode: l, headerCode: u } = vQ(e);
    super(i, n, s, a), this.inputsCode = o, this.blockCode = l, this.headerCode = u;
  }
  getCode(e = this.name) {
    let i;
    const n = this.blockCode;
    if (n !== "") {
      const { type: s, inputsCode: a, headerCode: o, precision: l } = this;
      let u = `${s} ${e} ( ${a.trim()} )`;
      l !== "" && (u = `${l} ${u}`), i = o + u + n;
    } else
      i = "";
    return i;
  }
}
class xQ extends YI {
  parseFunction(e) {
    return new bQ(e);
  }
}
const iA = /* @__PURE__ */ new WeakMap();
class _Q extends So {
  constructor(e, i) {
    super(), this.renderer = e, this.backend = i, this.nodeFrame = new eA(), this.nodeBuilderCache = /* @__PURE__ */ new Map(), this.callHashCache = new Ts(), this.groupsData = new Ts();
  }
  updateGroup(e) {
    const i = e.groupNode, n = i.name;
    if (n === UP.name) return !0;
    if (n === Ut.name) {
      const o = this.get(e), l = this.nodeFrame.renderId;
      return o.renderId !== l ? (o.renderId = l, !0) : !1;
    }
    if (n === YW.name) {
      const o = this.get(e), l = this.nodeFrame.frameId;
      return o.frameId !== l ? (o.frameId = l, !0) : !1;
    }
    const s = [i, e];
    let a = this.groupsData.get(s);
    return a === void 0 && this.groupsData.set(s, a = {}), a.version !== i.version ? (a.version = i.version, !0) : !1;
  }
  getForRenderCacheKey(e) {
    return e.initialCacheKey;
  }
  getForRender(e) {
    const i = this.get(e);
    let n = i.nodeBuilderState;
    if (n === void 0) {
      const { nodeBuilderCache: s } = this, a = this.getForRenderCacheKey(e);
      if (n = s.get(a), n === void 0) {
        const o = this.backend.createNodeBuilder(e.object, this.renderer);
        o.scene = e.scene, o.material = e.material, o.camera = e.camera, o.context.material = e.material, o.lightsNode = e.lightsNode, o.environmentNode = this.getEnvironmentNode(e.scene), o.fogNode = this.getFogNode(e.scene), o.clippingContext = e.clippingContext, o.build(), n = this._createNodeBuilderState(o), s.set(a, n);
      }
      n.usedTimes++, i.nodeBuilderState = n;
    }
    return n;
  }
  delete(e) {
    if (e.isRenderObject) {
      const i = this.get(e).nodeBuilderState;
      i.usedTimes--, i.usedTimes === 0 && this.nodeBuilderCache.delete(this.getForRenderCacheKey(e));
    }
    return super.delete(e);
  }
  getForCompute(e) {
    const i = this.get(e);
    let n = i.nodeBuilderState;
    if (n === void 0) {
      const s = this.backend.createNodeBuilder(e, this.renderer);
      s.build(), n = this._createNodeBuilderState(s), i.nodeBuilderState = n;
    }
    return n;
  }
  _createNodeBuilderState(e) {
    return new FZ(
      e.vertexShader,
      e.fragmentShader,
      e.computeShader,
      e.getAttributesArray(),
      e.getBindings(),
      e.updateNodes,
      e.updateBeforeNodes,
      e.updateAfterNodes,
      e.monitor,
      e.transforms
    );
  }
  getEnvironmentNode(e) {
    return e.environmentNode || this.get(e).environmentNode || null;
  }
  getBackgroundNode(e) {
    return e.backgroundNode || this.get(e).backgroundNode || null;
  }
  getFogNode(e) {
    return e.fogNode || this.get(e).fogNode || null;
  }
  getCacheKey(e, i) {
    const n = [e, i], s = this.renderer.info.calls;
    let a = this.callHashCache.get(n);
    if (a === void 0 || a.callId !== s) {
      const o = this.getEnvironmentNode(e), l = this.getFogNode(e), u = [];
      i && u.push(i.getCacheKey(!0)), o && u.push(o.getCacheKey()), l && u.push(l.getCacheKey()), u.push(this.renderer.shadowMap.enabled ? 1 : 0), a = {
        callId: s,
        cacheKey: MP(u)
      }, this.callHashCache.set(n, a);
    }
    return a.cacheKey;
  }
  updateScene(e) {
    this.updateEnvironment(e), this.updateFog(e), this.updateBackground(e);
  }
  get isToneMappingState() {
    return !this.renderer.getRenderTarget();
  }
  updateBackground(e) {
    const i = this.get(e), n = e.background;
    if (n) {
      const s = e.backgroundBlurriness === 0 && i.backgroundBlurriness > 0 || e.backgroundBlurriness > 0 && i.backgroundBlurriness === 0;
      if (i.background !== n || s) {
        let a = null;
        if (n.isCubeTexture === !0 || n.mapping === qd || n.mapping === Xd || n.mapping === Kb)
          if (e.backgroundBlurriness > 0 || n.mapping === Kb)
            a = LI(n);
          else {
            let o;
            n.isCubeTexture === !0 ? o = wd(n) : o = Ci(n), a = MI(o);
          }
        else n.isTexture === !0 ? a = Ci(n, Md.flipY()).setUpdateMatrix(!0) : n.isColor !== !0 && console.error("WebGPUNodes: Unsupported background configuration.", n);
        i.backgroundNode = a, i.background = n, i.backgroundBlurriness = e.backgroundBlurriness;
      }
    } else i.backgroundNode && (delete i.backgroundNode, delete i.background);
  }
  updateFog(e) {
    const i = this.get(e), n = e.fog;
    if (n) {
      if (i.fog !== n) {
        let s = null;
        if (n.isFogExp2) {
          const a = bi("color", "color", n).setGroup(Ut), o = bi("density", "float", n).setGroup(Ut);
          s = bZ(a, o);
        } else if (n.isFog) {
          const a = bi("color", "color", n).setGroup(Ut), o = bi("near", "float", n).setGroup(Ut), l = bi("far", "float", n).setGroup(Ut);
          s = yZ(a, o, l);
        } else
          console.error("WebGPUNodes: Unsupported fog configuration.", n);
        i.fogNode = s, i.fog = n;
      }
    } else
      delete i.fogNode, delete i.fog;
  }
  updateEnvironment(e) {
    const i = this.get(e), n = e.environment;
    if (n) {
      if (i.environment !== n) {
        let s = null;
        n.isCubeTexture === !0 ? s = wd(n) : n.isTexture === !0 ? s = Ci(n) : console.error("Nodes: Unsupported environment configuration.", n), i.environmentNode = s, i.environment = n;
      }
    } else i.environmentNode && (delete i.environmentNode, delete i.environment);
  }
  getNodeFrame(e = this.renderer, i = null, n = null, s = null, a = null) {
    const o = this.nodeFrame;
    return o.renderer = e, o.scene = i, o.object = n, o.camera = s, o.material = a, o;
  }
  getNodeFrameForRender(e) {
    return this.getNodeFrame(e.renderer, e.scene, e.object, e.camera, e.material);
  }
  getOutputCacheKey() {
    const e = this.renderer;
    return e.toneMapping + "," + e.currentColorSpace;
  }
  hasOutputChange(e) {
    return iA.get(e) !== this.getOutputCacheKey();
  }
  getOutputNode(e) {
    const i = this.renderer, n = this.getOutputCacheKey(), s = Ci(e, Md).renderOutput(i.toneMapping, i.currentColorSpace);
    return iA.set(e, n), s;
  }
  updateBefore(e) {
    const i = e.getNodeBuilderState();
    for (const n of i.updateBeforeNodes)
      this.getNodeFrameForRender(e).updateBeforeNode(n);
  }
  updateAfter(e) {
    const i = e.getNodeBuilderState();
    for (const n of i.updateAfterNodes)
      this.getNodeFrameForRender(e).updateAfterNode(n);
  }
  updateForCompute(e) {
    const i = this.getNodeFrame(), n = this.getForCompute(e);
    for (const s of n.updateNodes)
      i.updateNode(s);
  }
  updateForRender(e) {
    const i = this.getNodeFrameForRender(e), n = e.getNodeBuilderState();
    for (const s of n.updateNodes)
      i.updateNode(s);
  }
  needsRefresh(e) {
    const i = this.getNodeFrameForRender(e);
    return e.getMonitor().needsRefresh(e, i);
  }
  dispose() {
    super.dispose(), this.nodeFrame = new eA(), this.nodeBuilderCache = /* @__PURE__ */ new Map();
  }
}
class TQ {
  constructor(e, i) {
    this.scene = e, this.camera = i;
  }
  clone() {
    return Object.assign(new this.constructor(), this);
  }
}
class SQ {
  constructor() {
    this.lists = new Ts();
  }
  get(e, i) {
    const n = this.lists, s = [e, i];
    let a = n.get(s);
    return a === void 0 && (a = new TQ(e, i), n.set(s, a)), a;
  }
  dispose() {
    this.lists = new Ts();
  }
}
class KI {
  constructor() {
    this.lightNodes = /* @__PURE__ */ new WeakMap(), this.materialNodes = /* @__PURE__ */ new Map(), this.toneMappingNodes = /* @__PURE__ */ new Map();
  }
  fromMaterial(e) {
    if (e.isNodeMaterial) return e;
    let i = null;
    const n = this.getMaterialNodeClass(e.type);
    if (n !== null) {
      i = new n();
      for (const s in e)
        i[s] = e[s];
    }
    return i;
  }
  addToneMapping(e, i) {
    this.addType(e, i, this.toneMappingNodes);
  }
  getToneMappingFunction(e) {
    return this.toneMappingNodes.get(e) || null;
  }
  getMaterialNodeClass(e) {
    return this.materialNodes.get(e) || null;
  }
  addMaterial(e, i) {
    this.addType(e, i.type, this.materialNodes);
  }
  getLightNodeClass(e) {
    return this.lightNodes.get(e) || null;
  }
  addLight(e, i) {
    this.addClass(e, i, this.lightNodes);
  }
  addType(e, i, n) {
    if (n.has(i)) {
      console.warn(`Redefinition of node ${i}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof i == "function" || typeof i == "object") throw new Error(`Base class ${i} is not a class.`);
    n.set(i, e);
  }
  addClass(e, i, n) {
    if (n.has(i)) {
      console.warn(`Redefinition of node ${i.name}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof i != "function") throw new Error(`Base class ${i.name} is not a class.`);
    n.set(i, e);
  }
}
const wQ = /* @__PURE__ */ new HI();
class EQ extends Ts {
  constructor() {
    super();
  }
  createNode(e = []) {
    return new HI().setLights(e);
  }
  getNode(e, i) {
    if (e.isQuadMesh) return wQ;
    const n = [e, i];
    let s = this.get(n);
    return s === void 0 && (s = this.createNode(), this.set(n, s)), s;
  }
}
const rA = /* @__PURE__ */ new dP(), Tf = /* @__PURE__ */ new jt(), c0 = /* @__PURE__ */ new $t(), h0 = /* @__PURE__ */ new mP(), Sf = /* @__PURE__ */ new gi(), Wa = /* @__PURE__ */ new $t();
class MQ {
  constructor(e, i = {}) {
    this.isRenderer = !0;
    const {
      logarithmicDepthBuffer: n = !1,
      alpha: s = !0,
      depth: a = !0,
      stencil: o = !1,
      antialias: l = !1,
      samples: u = 0,
      getFallback: c = null
    } = i;
    this.domElement = e.getDomElement(), this.backend = e, this.samples = u || l === !0 ? 4 : 0, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.alpha = s, this.logarithmicDepthBuffer = n, this.outputColorSpace = ct, this.toneMapping = Yu, this.toneMappingExposure = 1, this.sortObjects = !0, this.depth = a, this.stencil = o, this.clippingPlanes = [], this.info = new LK(), this.nodes = {
      modelViewMatrix: null,
      modelNormalViewMatrix: null
    }, this.library = new KI(), this.lighting = new EQ(), this._getFallback = c, this._pixelRatio = 1, this._width = this.domElement.width, this._height = this.domElement.height, this._viewport = new $t(0, 0, this._width, this._height), this._scissor = new $t(0, 0, this._width, this._height), this._scissorTest = !1, this._attributes = null, this._geometries = null, this._nodes = null, this._animation = null, this._bindings = null, this._objects = null, this._pipelines = null, this._bundles = null, this._renderLists = null, this._renderContexts = null, this._textures = null, this._background = null, this._quad = new zI(new Bi()), this._quad.material.type = "Renderer_output", this._currentRenderContext = null, this._opaqueSort = null, this._transparentSort = null, this._frameBufferTarget = null;
    const h = this.alpha === !0 ? 0 : 1;
    this._clearColor = new kT(0, 0, 0, h), this._clearDepth = 1, this._clearStencil = 0, this._renderTarget = null, this._activeCubeFace = 0, this._activeMipmapLevel = 0, this._mrt = null, this._renderObjectFunction = null, this._currentRenderObjectFunction = null, this._currentRenderBundle = null, this._handleObjectFunction = this._renderObjectDirect, this._isDeviceLost = !1, this.onDeviceLost = this._onDeviceLost, this._initialized = !1, this._initPromise = null, this._compilationPromises = null, this.transparent = !0, this.opaque = !0, this.shadowMap = {
      enabled: !1,
      type: A9
    }, this.xr = {
      enabled: !1
    }, this.debug = {
      checkShaderErrors: !0,
      onShaderError: null,
      getShaderAsync: async (d, p, f) => {
        await this.compileAsync(d, p);
        const m = this._renderLists.get(d, p), v = this._renderContexts.get(d, p, this._renderTarget), y = d.overrideMaterial || f.material, g = this._objects.get(f, y, d, p, m.lightsNode, v), { fragmentShader: _, vertexShader: x } = g.getNodeBuilderState();
        return { fragmentShader: _, vertexShader: x };
      }
    };
  }
  async init() {
    if (this._initialized)
      throw new Error("Renderer: Backend has already been initialized.");
    return this._initPromise !== null ? this._initPromise : (this._initPromise = new Promise(async (e, i) => {
      let n = this.backend;
      try {
        await n.init(this);
      } catch (s) {
        if (this._getFallback !== null)
          try {
            this.backend = n = this._getFallback(s), await n.init(this);
          } catch (a) {
            i(a);
            return;
          }
        else {
          i(s);
          return;
        }
      }
      this._nodes = new _Q(this, n), this._animation = new EK(this._nodes, this.info), this._attributes = new IK(n), this._background = new UZ(this, this._nodes), this._geometries = new DK(this._attributes, this.info), this._textures = new $K(this, n, this.info), this._pipelines = new BK(n, this._nodes), this._bindings = new zK(n, this._nodes, this._textures, this._attributes, this._pipelines, this.info), this._objects = new RK(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info), this._renderLists = new GK(this.lighting), this._bundles = new SQ(), this._renderContexts = new qK(), this._initialized = !0, e();
    }), this._initPromise);
  }
  get coordinateSystem() {
    return this.backend.coordinateSystem;
  }
  async compileAsync(e, i, n = null) {
    if (this._isDeviceLost === !0) return;
    this._initialized === !1 && await this.init();
    const s = this._nodes.nodeFrame, a = s.renderId, o = this._currentRenderContext, l = this._currentRenderObjectFunction, u = this._compilationPromises, c = e.isScene === !0 ? e : rA;
    n === null && (n = e);
    const h = this._renderTarget, d = this._renderContexts.get(n, i, h), p = this._activeMipmapLevel, f = [];
    this._currentRenderContext = d, this._currentRenderObjectFunction = this.renderObject, this._handleObjectFunction = this._createObjectPipeline, this._compilationPromises = f, s.renderId++, s.update(), d.depth = this.depth, d.stencil = this.stencil, d.clippingContext || (d.clippingContext = new Rx()), d.clippingContext.updateGlobal(this, i), c.onBeforeRender(this, e, i, h);
    const m = this._renderLists.get(e, i);
    if (m.begin(), this._projectObject(e, i, 0, m), n !== e && n.traverseVisible(function(_) {
      _.isLight && _.layers.test(i.layers) && m.pushLight(_);
    }), m.finish(), h !== null) {
      this._textures.updateRenderTarget(h, p);
      const _ = this._textures.get(h);
      d.textures = _.textures, d.depthTexture = _.depthTexture;
    } else
      d.textures = null, d.depthTexture = null;
    this._nodes.updateScene(c), this._background.update(c, m, d);
    const v = m.opaque, y = m.transparent, g = m.lightsNode;
    this.opaque === !0 && v.length > 0 && this._renderObjects(v, i, c, g), this.transparent === !0 && y.length > 0 && this._renderTransparents(y, i, c, g), s.renderId = a, this._currentRenderContext = o, this._currentRenderObjectFunction = l, this._compilationPromises = u, this._handleObjectFunction = this._renderObjectDirect, await Promise.all(f);
  }
  async renderAsync(e, i) {
    this._initialized === !1 && await this.init();
    const n = this._renderScene(e, i);
    await this.backend.resolveTimestampAsync(n, "render");
  }
  async waitForGPU() {
    await this.backend.waitForGPU();
  }
  setMRT(e) {
    return this._mrt = e, this;
  }
  getMRT() {
    return this._mrt;
  }
  _onDeviceLost(e) {
    let i = `THREE.WebGPURenderer: ${e.api} Device Lost:

Message: ${e.message}`;
    e.reason && (i += `
Reason: ${e.reason}`), console.error(i), this._isDeviceLost = !0;
  }
  _renderBundle(e, i, n) {
    const { bundleGroup: s, camera: a, renderList: o } = e, l = this._currentRenderContext, u = this._bundles.get(s, a), c = this.backend.get(u);
    c.renderContexts === void 0 && (c.renderContexts = /* @__PURE__ */ new Set());
    const h = s.version !== c.version, d = c.renderContexts.has(l) === !1 || h;
    if (c.renderContexts.add(l), d) {
      this.backend.beginBundle(l), (c.renderObjects === void 0 || h) && (c.renderObjects = []), this._currentRenderBundle = u;
      const p = o.opaque;
      this.opaque === !0 && p.length > 0 && this._renderObjects(p, a, i, n), this._currentRenderBundle = null, this.backend.finishBundle(l, u), c.version = s.version;
    } else {
      const { renderObjects: p } = c;
      for (let f = 0, m = p.length; f < m; f++) {
        const v = p[f];
        this._nodes.needsRefresh(v) && (this._nodes.updateBefore(v), this._nodes.updateForRender(v), this._bindings.updateForRender(v), this._nodes.updateAfter(v));
      }
    }
    this.backend.addBundle(l, u);
  }
  render(e, i) {
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."), this.renderAsync(e, i);
    this._renderScene(e, i);
  }
  _getFrameBufferTarget() {
    const { currentToneMapping: e, currentColorSpace: i } = this;
    if (e === Yu && i === po) return null;
    const { width: n, height: s } = this.getDrawingBufferSize(Tf), { depth: a, stencil: o } = this;
    let l = this._frameBufferTarget;
    return l === null && (l = new zc(n, s, {
      depthBuffer: a,
      stencilBuffer: o,
      type: fa,
      // FloatType
      format: Fc,
      colorSpace: po,
      generateMipmaps: !1,
      minFilter: ln,
      magFilter: ln,
      samples: this.samples
    }), l.isPostProcessingRenderTarget = !0, this._frameBufferTarget = l), l.depthBuffer = a, l.stencilBuffer = o, l.setSize(n, s), l.viewport.copy(this._viewport), l.scissor.copy(this._scissor), l.viewport.multiplyScalar(this._pixelRatio), l.scissor.multiplyScalar(this._pixelRatio), l.scissorTest = this._scissorTest, l;
  }
  _renderScene(e, i, n = !0) {
    if (this._isDeviceLost === !0) return;
    const s = n ? this._getFrameBufferTarget() : null, a = this._nodes.nodeFrame, o = a.renderId, l = this._currentRenderContext, u = this._currentRenderObjectFunction, c = e.isScene === !0 ? e : rA, h = this._renderTarget, d = this._activeCubeFace, p = this._activeMipmapLevel;
    let f;
    s !== null ? (f = s, this.setRenderTarget(f)) : f = h;
    const m = this._renderContexts.get(e, i, f);
    this._currentRenderContext = m, this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject, this.info.calls++, this.info.render.calls++, this.info.render.frameCalls++, a.renderId = this.info.calls;
    const v = this.coordinateSystem;
    i.coordinateSystem !== v && (i.coordinateSystem = v, i.updateProjectionMatrix()), e.matrixWorldAutoUpdate === !0 && e.updateMatrixWorld(), i.parent === null && i.matrixWorldAutoUpdate === !0 && i.updateMatrixWorld();
    let y = this._viewport, g = this._scissor, _ = this._pixelRatio;
    f !== null && (y = f.viewport, g = f.scissor, _ = 1), this.getDrawingBufferSize(Tf), c0.set(0, 0, Tf.width, Tf.height);
    const x = y.minDepth === void 0 ? 0 : y.minDepth, b = y.maxDepth === void 0 ? 1 : y.maxDepth;
    m.viewportValue.copy(y).multiplyScalar(_).floor(), m.viewportValue.width >>= p, m.viewportValue.height >>= p, m.viewportValue.minDepth = x, m.viewportValue.maxDepth = b, m.viewport = m.viewportValue.equals(c0) === !1, m.scissorValue.copy(g).multiplyScalar(_).floor(), m.scissor = this._scissorTest && m.scissorValue.equals(c0) === !1, m.scissorValue.width >>= p, m.scissorValue.height >>= p, m.clippingContext || (m.clippingContext = new Rx()), m.clippingContext.updateGlobal(this, i), c.onBeforeRender(this, e, i, f), Sf.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), h0.setFromProjectionMatrix(Sf, v);
    const T = this._renderLists.get(e, i);
    if (T.begin(), this._projectObject(e, i, 0, T), T.finish(), this.sortObjects === !0 && T.sort(this._opaqueSort, this._transparentSort), f !== null) {
      this._textures.updateRenderTarget(f, p);
      const N = this._textures.get(f);
      m.textures = N.textures, m.depthTexture = N.depthTexture, m.width = N.width, m.height = N.height, m.renderTarget = f, m.depth = f.depthBuffer, m.stencil = f.stencilBuffer;
    } else
      m.textures = null, m.depthTexture = null, m.width = this.domElement.width, m.height = this.domElement.height, m.depth = this.depth, m.stencil = this.stencil;
    m.width >>= p, m.height >>= p, m.activeCubeFace = d, m.activeMipmapLevel = p, m.occlusionQueryCount = T.occlusionQueryCount, this._nodes.updateScene(c), this._background.update(c, T, m), this.backend.beginRender(m);
    const {
      bundles: S,
      lightsNode: w,
      transparentDoublePass: A,
      transparent: E,
      opaque: M
    } = T;
    if (S.length > 0 && this._renderBundles(S, c, w), this.opaque === !0 && M.length > 0 && this._renderObjects(M, i, c, w), this.transparent === !0 && E.length > 0 && this._renderTransparents(E, A, i, c, w), this.backend.finishRender(m), a.renderId = o, this._currentRenderContext = l, this._currentRenderObjectFunction = u, s !== null) {
      this.setRenderTarget(h, d, p);
      const N = this._quad;
      this._nodes.hasOutputChange(f.texture) && (N.material.fragmentNode = this._nodes.getOutputNode(f.texture), N.material.needsUpdate = !0), this._renderScene(N, N.camera, !1);
    }
    return c.onAfterRender(this, e, i, f), m;
  }
  getMaxAnisotropy() {
    return this.backend.getMaxAnisotropy();
  }
  getActiveCubeFace() {
    return this._activeCubeFace;
  }
  getActiveMipmapLevel() {
    return this._activeMipmapLevel;
  }
  async setAnimationLoop(e) {
    this._initialized === !1 && await this.init(), this._animation.setAnimationLoop(e);
  }
  async getArrayBufferAsync(e) {
    return await this.backend.getArrayBufferAsync(e);
  }
  getContext() {
    return this.backend.getContext();
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  getDrawingBufferSize(e) {
    return e.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
  }
  getSize(e) {
    return e.set(this._width, this._height);
  }
  setPixelRatio(e = 1) {
    this._pixelRatio !== e && (this._pixelRatio = e, this.setSize(this._width, this._height, !1));
  }
  setDrawingBufferSize(e, i, n) {
    this._width = e, this._height = i, this._pixelRatio = n, this.domElement.width = Math.floor(e * n), this.domElement.height = Math.floor(i * n), this.setViewport(0, 0, e, i), this._initialized && this.backend.updateSize();
  }
  setSize(e, i, n = !0) {
    this._width = e, this._height = i, this.domElement.width = Math.floor(e * this._pixelRatio), this.domElement.height = Math.floor(i * this._pixelRatio), n === !0 && (this.domElement.style.width = e + "px", this.domElement.style.height = i + "px"), this.setViewport(0, 0, e, i), this._initialized && this.backend.updateSize();
  }
  setOpaqueSort(e) {
    this._opaqueSort = e;
  }
  setTransparentSort(e) {
    this._transparentSort = e;
  }
  getScissor(e) {
    const i = this._scissor;
    return e.x = i.x, e.y = i.y, e.width = i.width, e.height = i.height, e;
  }
  setScissor(e, i, n, s) {
    const a = this._scissor;
    e.isVector4 ? a.copy(e) : a.set(e, i, n, s);
  }
  getScissorTest() {
    return this._scissorTest;
  }
  setScissorTest(e) {
    this._scissorTest = e, this.backend.setScissorTest(e);
  }
  getViewport(e) {
    return e.copy(this._viewport);
  }
  setViewport(e, i, n, s, a = 0, o = 1) {
    const l = this._viewport;
    e.isVector4 ? l.copy(e) : l.set(e, i, n, s), l.minDepth = a, l.maxDepth = o;
  }
  getClearColor(e) {
    return e.copy(this._clearColor);
  }
  setClearColor(e, i = 1) {
    this._clearColor.set(e), this._clearColor.a = i;
  }
  getClearAlpha() {
    return this._clearColor.a;
  }
  setClearAlpha(e) {
    this._clearColor.a = e;
  }
  getClearDepth() {
    return this._clearDepth;
  }
  setClearDepth(e) {
    this._clearDepth = e;
  }
  getClearStencil() {
    return this._clearStencil;
  }
  setClearStencil(e) {
    this._clearStencil = e;
  }
  isOccluded(e) {
    const i = this._currentRenderContext;
    return i && this.backend.isOccluded(i, e);
  }
  clear(e = !0, i = !0, n = !0) {
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."), this.clearAsync(e, i, n);
    const s = this._renderTarget || this._getFrameBufferTarget();
    let a = null;
    if (s !== null && (this._textures.updateRenderTarget(s), a = this._textures.get(s)), this.backend.clear(e, i, n, a), s !== null && this._renderTarget === null) {
      const o = this._quad;
      this._nodes.hasOutputChange(s.texture) && (o.material.fragmentNode = this._nodes.getOutputNode(s.texture), o.material.needsUpdate = !0), this._renderScene(o, o.camera, !1);
    }
  }
  clearColor() {
    return this.clear(!0, !1, !1);
  }
  clearDepth() {
    return this.clear(!1, !0, !1);
  }
  clearStencil() {
    return this.clear(!1, !1, !0);
  }
  async clearAsync(e = !0, i = !0, n = !0) {
    this._initialized === !1 && await this.init(), this.clear(e, i, n);
  }
  clearColorAsync() {
    return this.clearAsync(!0, !1, !1);
  }
  clearDepthAsync() {
    return this.clearAsync(!1, !0, !1);
  }
  clearStencilAsync() {
    return this.clearAsync(!1, !1, !0);
  }
  get currentToneMapping() {
    return this._renderTarget !== null ? Yu : this.toneMapping;
  }
  get currentColorSpace() {
    return this._renderTarget !== null ? po : this.outputColorSpace;
  }
  dispose() {
    this.info.dispose(), this.backend.dispose(), this._animation.dispose(), this._objects.dispose(), this._pipelines.dispose(), this._nodes.dispose(), this._bindings.dispose(), this._renderLists.dispose(), this._renderContexts.dispose(), this._textures.dispose(), this.setRenderTarget(null), this.setAnimationLoop(null);
  }
  setRenderTarget(e, i = 0, n = 0) {
    this._renderTarget = e, this._activeCubeFace = i, this._activeMipmapLevel = n;
  }
  getRenderTarget() {
    return this._renderTarget;
  }
  setRenderObjectFunction(e) {
    this._renderObjectFunction = e;
  }
  getRenderObjectFunction() {
    return this._renderObjectFunction;
  }
  compute(e) {
    if (this.isDeviceLost === !0) return;
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."), this.computeAsync(e);
    const i = this._nodes.nodeFrame, n = i.renderId;
    this.info.calls++, this.info.compute.calls++, this.info.compute.frameCalls++, i.renderId = this.info.calls;
    const s = this.backend, a = this._pipelines, o = this._bindings, l = this._nodes, u = Array.isArray(e) ? e : [e];
    if (u[0] === void 0 || u[0].isComputeNode !== !0)
      throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
    s.beginCompute(e);
    for (const c of u) {
      if (a.has(c) === !1) {
        const p = () => {
          c.removeEventListener("dispose", p), a.delete(c), o.delete(c), l.delete(c);
        };
        c.addEventListener("dispose", p);
        const f = c.onInitFunction;
        f !== null && f.call(c, { renderer: this });
      }
      l.updateForCompute(c), o.updateForCompute(c);
      const h = o.getForCompute(c), d = a.getForCompute(c, h);
      s.compute(e, c, h, d);
    }
    s.finishCompute(e), i.renderId = n;
  }
  async computeAsync(e) {
    this._initialized === !1 && await this.init(), this.compute(e), await this.backend.resolveTimestampAsync(e, "compute");
  }
  async hasFeatureAsync(e) {
    return this._initialized === !1 && await this.init(), this.backend.hasFeature(e);
  }
  hasFeature(e) {
    return this._initialized === !1 ? (console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."), !1) : this.backend.hasFeature(e);
  }
  copyFramebufferToTexture(e, i = null) {
    if (i !== null)
      if (i.isVector2)
        i = Wa.set(i.x, i.y, e.image.width, e.image.height).floor();
      else if (i.isVector4)
        i = Wa.copy(i).floor();
      else {
        console.error("THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.");
        return;
      }
    else
      i = Wa.set(0, 0, e.image.width, e.image.height);
    let n = this._currentRenderContext, s;
    n !== null ? s = n.renderTarget : (s = this._renderTarget || this._getFrameBufferTarget(), s !== null && (this._textures.updateRenderTarget(s), n = this._textures.get(s))), this._textures.updateTexture(e, { renderTarget: s }), this.backend.copyFramebufferToTexture(e, n, i);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    this._textures.updateTexture(e), this._textures.updateTexture(i), this.backend.copyTextureToTexture(e, i, n, s, a);
  }
  readRenderTargetPixelsAsync(e, i, n, s, a, o = 0, l = 0) {
    return this.backend.copyTextureToBuffer(e.textures[o], i, n, s, a, l);
  }
  _projectObject(e, i, n, s) {
    if (e.visible === !1) return;
    if (e.layers.test(i.layers)) {
      if (e.isGroup)
        n = e.renderOrder;
      else if (e.isLOD)
        e.autoUpdate === !0 && e.update(i);
      else if (e.isLight)
        s.pushLight(e);
      else if (e.isSprite) {
        if (!e.frustumCulled || h0.intersectsSprite(e)) {
          this.sortObjects === !0 && Wa.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Sf);
          const { geometry: o, material: l } = e;
          l.visible && s.push(e, o, l, n, Wa.z, null);
        }
      } else if (e.isLineLoop)
        console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
      else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || h0.intersectsObject(e))) {
        const { geometry: o, material: l } = e;
        if (this.sortObjects === !0 && (o.boundingSphere === null && o.computeBoundingSphere(), Wa.copy(o.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(Sf)), Array.isArray(l)) {
          const u = o.groups;
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c], p = l[d.materialIndex];
            p && p.visible && s.push(e, o, p, n, Wa.z, d);
          }
        } else l.visible && s.push(e, o, l, n, Wa.z, null);
      }
    }
    if (e.isBundleGroup === !0 && this.backend.beginBundle !== void 0) {
      const o = s;
      s = this._renderLists.get(e, i), s.begin(), o.pushBundle({
        bundleGroup: e,
        camera: i,
        renderList: s
      }), s.finish();
    }
    const a = e.children;
    for (let o = 0, l = a.length; o < l; o++)
      this._projectObject(a[o], i, n, s);
  }
  _renderBundles(e, i, n) {
    for (const s of e)
      this._renderBundle(s, i, n);
  }
  _renderTransparents(e, i, n, s, a) {
    if (i.length > 0) {
      for (const { material: o } of i)
        o.side = Zn;
      this._renderObjects(i, n, s, a, "backSide");
      for (const { material: o } of i)
        o.side = bc;
      this._renderObjects(e, n, s, a);
      for (const { material: o } of i)
        o.side = $u;
    } else
      this._renderObjects(e, n, s, a);
  }
  _renderObjects(e, i, n, s, a = null) {
    for (let o = 0, l = e.length; o < l; o++) {
      const u = e[o], { object: c, geometry: h, material: d, group: p } = u;
      if (i.isArrayCamera) {
        const f = i.cameras;
        for (let m = 0, v = f.length; m < v; m++) {
          const y = f[m];
          if (c.layers.test(y.layers)) {
            const g = y.viewport, _ = g.minDepth === void 0 ? 0 : g.minDepth, x = g.maxDepth === void 0 ? 1 : g.maxDepth, b = this._currentRenderContext.viewportValue;
            b.copy(g).multiplyScalar(this._pixelRatio).floor(), b.minDepth = _, b.maxDepth = x, this.backend.updateViewport(this._currentRenderContext), this._currentRenderObjectFunction(c, n, y, h, d, p, s, a);
          }
        }
      } else
        this._currentRenderObjectFunction(c, n, i, h, d, p, s, a);
    }
  }
  renderObject(e, i, n, s, a, o, l, u = null) {
    let c, h, d;
    if (e.onBeforeRender(this, i, n, s, a, o), i.overrideMaterial !== null) {
      const p = i.overrideMaterial;
      a.positionNode && a.positionNode.isNode && (c = p.positionNode, p.positionNode = a.positionNode), p.isShadowNodeMaterial && (p.side = a.shadowSide === null ? a.side : a.shadowSide, a.depthNode && a.depthNode.isNode && (d = p.depthNode, p.depthNode = a.depthNode), a.shadowNode && a.shadowNode.isNode && (h = p.fragmentNode, p.fragmentNode = a.shadowNode), this.localClippingEnabled && (a.clipShadows ? (p.clippingPlanes !== a.clippingPlanes && (p.clippingPlanes = a.clippingPlanes, p.needsUpdate = !0), p.clipIntersection !== a.clipIntersection && (p.clipIntersection = a.clipIntersection)) : Array.isArray(p.clippingPlanes) && (p.clippingPlanes = null, p.needsUpdate = !0))), a = p;
    }
    a.transparent === !0 && a.side === $u && a.forceSinglePass === !1 ? (a.side = Zn, this._handleObjectFunction(e, a, i, n, l, o, "backSide"), a.side = bc, this._handleObjectFunction(e, a, i, n, l, o, u), a.side = $u) : this._handleObjectFunction(e, a, i, n, l, o, u), c !== void 0 && (i.overrideMaterial.positionNode = c), d !== void 0 && (i.overrideMaterial.depthNode = d), h !== void 0 && (i.overrideMaterial.fragmentNode = h), e.onAfterRender(this, i, n, s, a, o);
  }
  _renderObjectDirect(e, i, n, s, a, o, l) {
    const u = this._objects.get(e, i, n, s, a, this._currentRenderContext, l);
    u.drawRange = e.geometry.drawRange, u.group = o;
    const c = this._nodes.needsRefresh(u);
    c && (this._nodes.updateBefore(u), this._geometries.updateForRender(u), this._nodes.updateForRender(u), this._bindings.updateForRender(u)), this._pipelines.updateForRender(u), this._currentRenderBundle !== null && (this.backend.get(this._currentRenderBundle).renderObjects.push(u), u.bundle = this._currentRenderBundle.scene), this.backend.draw(u, this.info), c && this._nodes.updateAfter(u);
  }
  _createObjectPipeline(e, i, n, s, a, o) {
    const l = this._objects.get(e, i, n, s, a, this._currentRenderContext, o);
    this._nodes.updateBefore(l), this._geometries.updateForRender(l), this._nodes.updateForRender(l), this._bindings.updateForRender(l), this._pipelines.getForRender(l, this._compilationPromises), this._nodes.updateAfter(l);
  }
  get compile() {
    return this.compileAsync;
  }
}
class HT {
  constructor(e = "") {
    this.name = e, this.visibility = 0;
  }
  setVisibility(e) {
    this.visibility |= e;
  }
  clone() {
    return Object.assign(new this.constructor(), this);
  }
}
function AQ(r) {
  return r + (io - r % io) % io;
}
class ZI extends HT {
  constructor(e, i = null) {
    super(e), this.isBuffer = !0, this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT, this._buffer = i;
  }
  get byteLength() {
    return AQ(this._buffer.byteLength);
  }
  get buffer() {
    return this._buffer;
  }
  update() {
    return !0;
  }
}
class QI extends ZI {
  constructor(e, i = null) {
    super(e, i), this.isUniformBuffer = !0;
  }
}
let CQ = 0;
class JI extends QI {
  constructor(e, i) {
    super("UniformBuffer_" + CQ++, e ? e.value : null), this.nodeUniform = e, this.groupNode = i;
  }
  get buffer() {
    return this.nodeUniform.value;
  }
}
class RQ extends QI {
  constructor(e) {
    super(e), this.isUniformsGroup = !0, this._values = null, this.uniforms = [];
  }
  addUniform(e) {
    return this.uniforms.push(e), this;
  }
  removeUniform(e) {
    const i = this.uniforms.indexOf(e);
    return i !== -1 && this.uniforms.splice(i, 1), this;
  }
  get values() {
    return this._values === null && (this._values = Array.from(this.buffer)), this._values;
  }
  get buffer() {
    let e = this._buffer;
    if (e === null) {
      const i = this.byteLength;
      e = new Float32Array(new ArrayBuffer(i)), this._buffer = e;
    }
    return e;
  }
  get byteLength() {
    let e = 0;
    for (let i = 0, n = this.uniforms.length; i < n; i++) {
      const s = this.uniforms[i], { boundary: a, itemSize: o } = s, l = e % io, u = io - l;
      l !== 0 && u - a < 0 ? e += io - l : l % a !== 0 && (e += l % a), s.offset = e / this.bytesPerElement, e += o * this.bytesPerElement;
    }
    return Math.ceil(e / io) * io;
  }
  update() {
    let e = !1;
    for (const i of this.uniforms)
      this.updateByType(i) === !0 && (e = !0);
    return e;
  }
  updateByType(e) {
    if (e.isNumberUniform) return this.updateNumber(e);
    if (e.isVector2Uniform) return this.updateVector2(e);
    if (e.isVector3Uniform) return this.updateVector3(e);
    if (e.isVector4Uniform) return this.updateVector4(e);
    if (e.isColorUniform) return this.updateColor(e);
    if (e.isMatrix3Uniform) return this.updateMatrix3(e);
    if (e.isMatrix4Uniform) return this.updateMatrix4(e);
    console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.", e);
  }
  updateNumber(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a] !== s) {
      const o = this.buffer;
      o[a] = n[a] = s, i = !0;
    }
    return i;
  }
  updateVector2(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, i = !0;
    }
    return i;
  }
  updateVector3(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y || n[a + 2] !== s.z) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, o[a + 2] = n[a + 2] = s.z, i = !0;
    }
    return i;
  }
  updateVector4(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y || n[a + 2] !== s.z || n[a + 4] !== s.w) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, o[a + 2] = n[a + 2] = s.z, o[a + 3] = n[a + 3] = s.w, i = !0;
    }
    return i;
  }
  updateColor(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.r || n[a + 1] !== s.g || n[a + 2] !== s.b) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.r, o[a + 1] = n[a + 1] = s.g, o[a + 2] = n[a + 2] = s.b, i = !0;
    }
    return i;
  }
  updateMatrix3(e) {
    let i = !1;
    const n = this.values, s = e.getValue().elements, a = e.offset;
    if (n[a + 0] !== s[0] || n[a + 1] !== s[1] || n[a + 2] !== s[2] || n[a + 4] !== s[3] || n[a + 5] !== s[4] || n[a + 6] !== s[5] || n[a + 8] !== s[6] || n[a + 9] !== s[7] || n[a + 10] !== s[8]) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s[0], o[a + 1] = n[a + 1] = s[1], o[a + 2] = n[a + 2] = s[2], o[a + 4] = n[a + 4] = s[3], o[a + 5] = n[a + 5] = s[4], o[a + 6] = n[a + 6] = s[5], o[a + 8] = n[a + 8] = s[6], o[a + 9] = n[a + 9] = s[7], o[a + 10] = n[a + 10] = s[8], i = !0;
    }
    return i;
  }
  updateMatrix4(e) {
    let i = !1;
    const n = this.values, s = e.getValue().elements, a = e.offset;
    return PQ(n, s, a) === !1 && (this.buffer.set(s, a), NQ(n, s, a), i = !0), i;
  }
}
function NQ(r, e, i) {
  for (let n = 0, s = e.length; n < s; n++)
    r[i + n] = e[n];
}
function PQ(r, e, i) {
  for (let n = 0, s = e.length; n < s; n++)
    if (r[i + n] !== e[n]) return !1;
  return !0;
}
let IQ = 0;
class eO extends RQ {
  constructor(e, i) {
    super(e), this.id = IQ++, this.groupNode = i, this.isNodeUniformsGroup = !0;
  }
  getNodes() {
    const e = [];
    for (const i of this.uniforms) {
      const n = i.nodeUniform.node;
      if (!n) throw new Error("NodeUniformsGroup: Uniform has no node.");
      e.push(n);
    }
    return e;
  }
}
let OQ = 0;
class DQ extends HT {
  constructor(e, i) {
    super(e), this.id = OQ++, this.texture = i, this.version = i ? i.version : 0, this.store = !1, this.generation = null, this.isSampledTexture = !0;
  }
  needsBindingsUpdate(e) {
    const { texture: i } = this;
    return e !== this.generation ? (this.generation = e, !0) : i.isVideoTexture;
  }
  update() {
    const { texture: e, version: i } = this;
    return i !== e.version ? (this.version = e.version, !0) : !1;
  }
}
class Vg extends DQ {
  constructor(e, i, n, s = null) {
    super(e, i ? i.value : null), this.textureNode = i, this.groupNode = n, this.access = s;
  }
  needsBindingsUpdate(e) {
    return this.textureNode.value !== this.texture || super.needsBindingsUpdate(e);
  }
  update() {
    const { textureNode: e } = this;
    return this.texture !== e.value ? (this.texture = e.value, !0) : super.update();
  }
}
class tO extends Vg {
  constructor(e, i, n, s) {
    super(e, i, n, s), this.isSampledCubeTexture = !0;
  }
}
class iO extends Vg {
  constructor(e, i, n, s) {
    super(e, i, n, s), this.isSampledTexture3D = !0;
  }
}
const LQ = {
  atan2: "atan",
  textureDimensions: "textureSize",
  equals: "equal"
}, UQ = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
}, nA = {
  swizzleAssign: !0,
  storageBuffer: !1
}, sA = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;
class kQ extends XI {
  constructor(e, i) {
    super(e, i, new xQ()), this.uniformGroups = {}, this.transforms = [], this.extensions = {}, this.useComparisonMethod = !0;
  }
  needsColorSpaceToLinearSRGB(e) {
    return e.isVideoTexture === !0 && e.colorSpace !== Sl;
  }
  getMethod(e) {
    return LQ[e] || e;
  }
  getOutputStructName() {
    return "";
  }
  buildFunctionCode(e) {
    const i = e.layout, n = this.flowShaderNode(e), s = [];
    for (const a of i.inputs)
      s.push(this.getType(a.type) + " " + a.name);
    return `${this.getType(i.type)} ${i.name}( ${s.join(", ")} ) {

	${n.vars}

${n.code}
	return ${n.result};

}`;
  }
  setupPBO(e) {
    const i = e.value;
    if (i.pbo === void 0) {
      const n = i.array, s = i.count * i.itemSize, { itemSize: a } = i, o = i.array.constructor.name.toLowerCase().includes("int");
      let l = o ? nT : rT;
      a === 2 ? l = o ? sT : gd : a === 3 ? l = o ? G9 : iT : a === 4 && (l = o ? aT : Fc);
      const u = {
        Float32Array: on,
        Uint8Array: ho,
        Uint16Array: Uu,
        Uint32Array: er,
        Int8Array: Qh,
        Int16Array: Jh,
        Int32Array: Sr,
        Uint8ClampedArray: ho
      }, c = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(s / a))));
      let h = Math.ceil(s / a / c);
      c * h * a < s && h++;
      const d = c * h * a, p = new n.constructor(d);
      p.set(n, 0), i.array = p;
      const f = new Y7(i.array, c, h, l, u[i.array.constructor.name] || on);
      f.needsUpdate = !0, f.isPBOTexture = !0;
      const m = new tp(f, null, null);
      m.setPrecision("high"), i.pboNode = m, i.pbo = m.value, this.getUniformFromNode(i.pboNode, "texture", this.shaderStage, this.context.label);
    }
  }
  getPropertyName(e, i = this.shaderStage) {
    return e.isNodeUniform && e.node.isTextureNode !== !0 && e.node.isBufferNode !== !0 ? i.charAt(0) + "_" + e.name : super.getPropertyName(e, i);
  }
  generatePBO(e) {
    const { node: i, indexNode: n } = e, s = i.value;
    if (this.renderer.backend.has(s)) {
      const h = this.renderer.backend.get(s);
      h.pbo = s.pbo;
    }
    const a = this.getUniformFromNode(s.pboNode, "texture", this.shaderStage, this.context.label), o = this.getPropertyName(a);
    this.increaseUsage(n);
    const l = n.build(this, "uint"), u = this.getDataFromNode(e);
    let c = u.propertyName;
    if (c === void 0) {
      const h = this.getVarFromNode(e);
      c = this.getPropertyName(h);
      const d = this.getDataFromNode(i);
      let p = d.propertySizeName;
      p === void 0 && (p = c + "Size", this.getVarFromNode(i, p, "uint"), this.addLineFlowCode(`${p} = uint( textureSize( ${o}, 0 ).x )`, e), d.propertySizeName = p);
      const { itemSize: f } = s, m = "." + Vc.join("").slice(0, f), v = `ivec2(${l} % ${p}, ${l} / ${p})`, y = this.generateTextureLoad(null, o, v, null, "0");
      let g = "vec4";
      s.pbo.type === er ? g = "uvec4" : s.pbo.type === Sr && (g = "ivec4"), this.addLineFlowCode(`${c} = ${g}(${y})${m}`, e), u.propertyName = c;
    }
    return c;
  }
  generateTextureLoad(e, i, n, s, a = "0") {
    return s ? `texelFetch( ${i}, ivec3( ${n}, ${s} ), ${a} )` : `texelFetch( ${i}, ${n}, ${a} )`;
  }
  generateTexture(e, i, n, s) {
    return e.isDepthTexture ? `texture( ${i}, ${n} ).x` : (s && (n = `vec3( ${n}, ${s} )`), `texture( ${i}, ${n} )`);
  }
  generateTextureLevel(e, i, n, s) {
    return `textureLod( ${i}, ${n}, ${s} )`;
  }
  generateTextureBias(e, i, n, s) {
    return `texture( ${i}, ${n}, ${s} )`;
  }
  generateTextureGrad(e, i, n, s) {
    return `textureGrad( ${i}, ${n}, ${s[0]}, ${s[1]} )`;
  }
  generateTextureCompare(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `texture( ${i}, vec3( ${n}, ${s} ) )`;
    console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${o} shader.`);
  }
  getVars(e) {
    const i = [], n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`${this.getVar(s.type, s.name)};`);
    return i.join(`
	`);
  }
  getUniforms(e) {
    const i = this.uniforms[e], n = [], s = {};
    for (const o of i) {
      let l = null, u = !1;
      if (o.type === "texture") {
        const h = o.node.value;
        let d = "";
        h.isDataTexture === !0 && (h.type === er ? d = "u" : h.type === Sr && (d = "i")), h.compareFunction ? l = `sampler2DShadow ${o.name};` : h.isDataArrayTexture === !0 || h.isCompressedArrayTexture === !0 ? l = `${d}sampler2DArray ${o.name};` : l = `${d}sampler2D ${o.name};`;
      } else if (o.type === "cubeTexture")
        l = `samplerCube ${o.name};`;
      else if (o.type === "texture3D")
        l = `sampler3D ${o.name};`;
      else if (o.type === "buffer") {
        const h = o.node, d = this.getType(h.bufferType), p = h.bufferCount, f = p > 0 ? p : "";
        l = `${h.name} {
	${d} ${o.name}[${f}];
};
`;
      } else
        l = `${this.getVectorType(o.type)} ${this.getPropertyName(o, e)};`, u = !0;
      const c = o.node.precision;
      if (c !== null && (l = UQ[c] + " " + l), u) {
        l = "	" + l;
        const h = o.groupNode.name;
        (s[h] || (s[h] = [])).push(l);
      } else
        l = "uniform " + l, n.push(l);
    }
    let a = "";
    for (const o in s) {
      const l = s[o];
      a += this._getGLSLUniformStruct(e + "_" + o, l.join(`
`)) + `
`;
    }
    return a += n.join(`
`), a;
  }
  getTypeFromAttribute(e) {
    let i = super.getTypeFromAttribute(e);
    if (/^[iu]/.test(i) && e.gpuType !== Sr) {
      let n = e;
      e.isInterleavedBufferAttribute && (n = e.data);
      const s = n.array;
      s instanceof Uint32Array || s instanceof Int32Array || (i = i.slice(1));
    }
    return i;
  }
  getAttributes(e) {
    let i = "";
    if (e === "vertex" || e === "compute") {
      const n = this.getAttributesArray();
      let s = 0;
      for (const a of n)
        i += `layout( location = ${s++} ) in ${a.type} ${a.name};
`;
    }
    return i;
  }
  getStructMembers(e) {
    const i = [], n = e.getMemberTypes();
    for (let s = 0; s < n.length; s++) {
      const a = n[s];
      i.push(`layout( location = ${s} ) out ${a} m${s};`);
    }
    return i.join(`
`);
  }
  getStructs(e) {
    const i = [], n = this.structs[e];
    if (n.length === 0)
      return `layout( location = 0 ) out vec4 fragColor;
`;
    for (let s = 0, a = n.length; s < a; s++) {
      const o = n[s];
      let l = `
`;
      l += this.getStructMembers(o), l += `
`, i.push(l);
    }
    return i.join(`

`);
  }
  getVaryings(e) {
    let i = "";
    const n = this.varyings;
    if (e === "vertex" || e === "compute")
      for (const s of n) {
        e === "compute" && (s.needsInterpolation = !0);
        const a = s.type, o = a.includes("int") || a.includes("uv") || a.includes("iv") ? "flat " : "";
        i += `${o}${s.needsInterpolation ? "out" : "/*out*/"} ${a} ${s.name};
`;
      }
    else if (e === "fragment") {
      for (const s of n)
        if (s.needsInterpolation) {
          const a = s.type, o = a.includes("int") || a.includes("uv") || a.includes("iv") ? "flat " : "";
          i += `${o}in ${a} ${s.name};
`;
        }
    }
    return i;
  }
  getVertexIndex() {
    return "uint( gl_VertexID )";
  }
  getInstanceIndex() {
    return "uint( gl_InstanceID )";
  }
  getInvocationLocalIndex() {
    return `uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce((e, i) => e * i, 1)}u`;
  }
  getDrawIndex() {
    return this.renderer.backend.extensions.has("WEBGL_multi_draw") ? "uint( gl_DrawID )" : null;
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord.xy";
  }
  getFragDepth() {
    return "gl_FragDepth";
  }
  enableExtension(e, i, n = this.shaderStage) {
    const s = this.extensions[n] || (this.extensions[n] = /* @__PURE__ */ new Map());
    s.has(e) === !1 && s.set(e, {
      name: e,
      behavior: i
    });
  }
  getExtensions(e) {
    const i = [];
    if (e === "vertex") {
      const s = this.renderer.backend.extensions;
      this.object.isBatchedMesh && s.has("WEBGL_multi_draw") && this.enableExtension("GL_ANGLE_multi_draw", "require", e);
    }
    const n = this.extensions[e];
    if (n !== void 0)
      for (const { name: s, behavior: a } of n.values())
        i.push(`#extension ${s} : ${a}`);
    return i.join(`
`);
  }
  isAvailable(e) {
    let i = nA[e];
    if (i === void 0) {
      if (e === "float32Filterable") {
        const n = this.renderer.backend.extensions;
        n.has("OES_texture_float_linear") ? (n.get("OES_texture_float_linear"), i = !0) : i = !1;
      }
      nA[e] = i;
    }
    return i;
  }
  isFlipY() {
    return !0;
  }
  registerTransform(e, i) {
    this.transforms.push({ varyingName: e, attributeNode: i });
  }
  getTransforms() {
    const e = this.transforms;
    let i = "";
    for (let n = 0; n < e.length; n++) {
      const s = e[n], a = this.getPropertyName(s.attributeNode);
      i += `${s.varyingName} = ${a};
	`;
    }
    return i;
  }
  _getGLSLUniformStruct(e, i) {
    return `
layout( std140 ) uniform ${e} {
${i}
};`;
  }
  _getGLSLVertexCode(e) {
    return `#version 300 es

${this.getSignature()}

// extensions 
${e.extensions}

// precision
${sA}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// attributes
${e.attributes}

// codes
${e.codes}

void main() {

	// vars
	${e.vars}

	// transforms
	${e.transforms}

	// flow
	${e.flow}

	gl_PointSize = 1.0;

}
`;
  }
  _getGLSLFragmentCode(e) {
    return `#version 300 es

${this.getSignature()}

// precision
${sA}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// codes
${e.codes}

${e.structs}

void main() {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const i in e) {
      let n = `// code

`;
      n += this.flowCode[i];
      const s = this.flowNodes[i], a = s[s.length - 1];
      for (const l of s) {
        const u = this.getFlowData(
          l
          /*, shaderStage*/
        ), c = l.name;
        c && (n.length > 0 && (n += `
`), n += `	// flow -> ${c}
	`), n += `${u.code}
	`, l === a && i !== "compute" && (n += `// result
	`, i === "vertex" ? (n += "gl_Position = ", n += `${u.result};`) : i === "fragment" && (l.outputNode.isOutputStructNode || (n += "fragColor = ", n += `${u.result};`)));
      }
      const o = e[i];
      o.extensions = this.getExtensions(i), o.uniforms = this.getUniforms(i), o.attributes = this.getAttributes(i), o.varyings = this.getVaryings(i), o.vars = this.getVars(i), o.structs = this.getStructs(i), o.codes = this.getCodes(i), o.transforms = this.getTransforms(i), o.flow = n;
    }
    this.material !== null ? (this.vertexShader = this._getGLSLVertexCode(e.vertex), this.fragmentShader = this._getGLSLFragmentCode(e.fragment)) : this.computeShader = this._getGLSLVertexCode(e.compute);
  }
  getUniformFromNode(e, i, n, s = null) {
    const a = super.getUniformFromNode(e, i, n, s), o = this.getDataFromNode(e, n, this.globalCache);
    let l = o.uniformGPU;
    if (l === void 0) {
      const u = e.groupNode, c = u.name, h = this.getBindGroupArray(c, n);
      if (i === "texture")
        l = new Vg(a.name, a.node, u), h.push(l);
      else if (i === "cubeTexture")
        l = new tO(a.name, a.node, u), h.push(l);
      else if (i === "texture3D")
        l = new iO(a.name, a.node, u), h.push(l);
      else if (i === "buffer") {
        e.name = `NodeBuffer_${e.id}`, a.name = `buffer${e.id}`;
        const d = new JI(e, u);
        d.name = e.name, h.push(d), l = d;
      } else {
        const d = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let p = d[c];
        p === void 0 && (p = new eO(n + "_" + c, u), d[c] = p, h.push(p)), l = this.getNodeUniform(a, i), p.addUniform(l);
      }
      o.uniformGPU = l;
    }
    return a;
  }
}
let d0 = null, p0 = null, Tu = null;
class rO {
  constructor(e = {}) {
    this.parameters = Object.assign({}, e), this.data = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.domElement = null;
  }
  async init(e) {
    this.renderer = e;
  }
  // render context
  begin() {
  }
  finish() {
  }
  // render object
  draw() {
  }
  // program
  createProgram() {
  }
  destroyProgram() {
  }
  // bindings
  createBindings() {
  }
  updateBindings() {
  }
  // pipeline
  createRenderPipeline() {
  }
  createComputePipeline() {
  }
  destroyPipeline() {
  }
  // cache key
  needsRenderUpdate() {
  }
  // return Boolean ( fast test )
  getRenderCacheKey() {
  }
  // return String
  // node builder
  createNodeBuilder() {
  }
  // return NodeBuilder (ADD IT)
  // textures
  createSampler() {
  }
  createDefaultTexture() {
  }
  createTexture() {
  }
  copyTextureToBuffer() {
  }
  // attributes
  createAttribute() {
  }
  createIndexAttribute() {
  }
  updateAttribute() {
  }
  destroyAttribute() {
  }
  // canvas
  getContext() {
  }
  updateSize() {
  }
  // utils
  resolveTimestampAsync() {
  }
  hasFeatureAsync() {
  }
  // return Boolean
  hasFeature() {
  }
  // return Boolean
  getInstanceCount(e) {
    const { object: i, geometry: n } = e;
    return n.isInstancedBufferGeometry ? n.instanceCount : i.count > 1 ? i.count : 1;
  }
  getDrawingBufferSize() {
    return d0 = d0 || new jt(), this.renderer.getDrawingBufferSize(d0);
  }
  getScissor() {
    return p0 = p0 || new $t(), this.renderer.getScissor(p0);
  }
  setScissorTest() {
  }
  getClearColor() {
    const e = this.renderer;
    return Tu = Tu || new kT(), e.getClearColor(Tu), Tu.getRGB(Tu, this.renderer.currentColorSpace), Tu;
  }
  getDomElement() {
    let e = this.domElement;
    return e === null && (e = this.parameters.canvas !== void 0 ? this.parameters.canvas : w7(), "setAttribute" in e && e.setAttribute("data-engine", `three.js r${Cg} webgpu`), this.domElement = e), e;
  }
  // resource properties
  set(e, i) {
    this.data.set(e, i);
  }
  get(e) {
    let i = this.data.get(e);
    return i === void 0 && (i = {}, this.data.set(e, i)), i;
  }
  has(e) {
    return this.data.has(e);
  }
  delete(e) {
    this.data.delete(e);
  }
  dispose() {
  }
}
let FQ = 0;
class BQ {
  constructor(e, i) {
    this.buffers = [e.bufferGPU, i], this.type = e.type, this.bufferType = e.bufferType, this.pbo = e.pbo, this.byteLength = e.byteLength, this.bytesPerElement = e.BYTES_PER_ELEMENT, this.version = e.version, this.isInteger = e.isInteger, this.activeBufferIndex = 0, this.baseId = e.id;
  }
  get id() {
    return `${this.baseId}|${this.activeBufferIndex}`;
  }
  get bufferGPU() {
    return this.buffers[this.activeBufferIndex];
  }
  get transformBuffer() {
    return this.buffers[this.activeBufferIndex ^ 1];
  }
  switchBuffers() {
    this.activeBufferIndex ^= 1;
  }
}
class zQ {
  constructor(e) {
    this.backend = e;
  }
  createAttribute(e, i) {
    const n = this.backend, { gl: s } = n, a = e.array, o = e.usage || s.STATIC_DRAW, l = e.isInterleavedBufferAttribute ? e.data : e, u = n.get(l);
    let c = u.bufferGPU;
    c === void 0 && (c = this._createBuffer(s, i, a, o), u.bufferGPU = c, u.bufferType = i, u.version = l.version);
    let h;
    if (a instanceof Float32Array)
      h = s.FLOAT;
    else if (a instanceof Uint16Array)
      e.isFloat16BufferAttribute ? h = s.HALF_FLOAT : h = s.UNSIGNED_SHORT;
    else if (a instanceof Int16Array)
      h = s.SHORT;
    else if (a instanceof Uint32Array)
      h = s.UNSIGNED_INT;
    else if (a instanceof Int32Array)
      h = s.INT;
    else if (a instanceof Int8Array)
      h = s.BYTE;
    else if (a instanceof Uint8Array)
      h = s.UNSIGNED_BYTE;
    else if (a instanceof Uint8ClampedArray)
      h = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + a);
    let d = {
      bufferGPU: c,
      bufferType: i,
      type: h,
      byteLength: a.byteLength,
      bytesPerElement: a.BYTES_PER_ELEMENT,
      version: e.version,
      pbo: e.pbo,
      isInteger: h === s.INT || h === s.UNSIGNED_INT || e.gpuType === Sr,
      id: FQ++
    };
    if (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute) {
      const p = this._createBuffer(s, i, a, o);
      d = new BQ(d, p);
    }
    n.set(e, d);
  }
  updateAttribute(e) {
    const i = this.backend, { gl: n } = i, s = e.array, a = e.isInterleavedBufferAttribute ? e.data : e, o = i.get(a), l = o.bufferType, u = e.isInterleavedBufferAttribute ? e.data.updateRanges : e.updateRanges;
    if (n.bindBuffer(l, o.bufferGPU), u.length === 0)
      n.bufferSubData(l, 0, s);
    else {
      for (let c = 0, h = u.length; c < h; c++) {
        const d = u[c];
        n.bufferSubData(
          l,
          d.start * s.BYTES_PER_ELEMENT,
          s,
          d.start,
          d.count
        );
      }
      a.clearUpdateRanges();
    }
    n.bindBuffer(l, null), o.version = a.version;
  }
  destroyAttribute(e) {
    const i = this.backend, { gl: n } = i;
    e.isInterleavedBufferAttribute && i.delete(e.data);
    const s = i.get(e);
    n.deleteBuffer(s.bufferGPU), i.delete(e);
  }
  async getArrayBufferAsync(e) {
    const i = this.backend, { gl: n } = i, s = e.isInterleavedBufferAttribute ? e.data : e, { bufferGPU: a } = i.get(s), o = e.array, l = o.byteLength;
    n.bindBuffer(n.COPY_READ_BUFFER, a);
    const u = n.createBuffer();
    n.bindBuffer(n.COPY_WRITE_BUFFER, u), n.bufferData(n.COPY_WRITE_BUFFER, l, n.STREAM_READ), n.copyBufferSubData(n.COPY_READ_BUFFER, n.COPY_WRITE_BUFFER, 0, 0, l), await i.utils._clientWaitAsync();
    const c = new e.array.constructor(o.length);
    return n.bindBuffer(n.COPY_WRITE_BUFFER, u), n.getBufferSubData(n.COPY_WRITE_BUFFER, 0, c), n.deleteBuffer(u), n.bindBuffer(n.COPY_READ_BUFFER, null), n.bindBuffer(n.COPY_WRITE_BUFFER, null), c.buffer;
  }
  _createBuffer(e, i, n, s) {
    const a = e.createBuffer();
    return e.bindBuffer(i, a), e.bufferData(i, n, s), e.bindBuffer(i, null), a;
  }
}
let aA = !1, f0, Ah;
class jQ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.enabled = {}, this.currentFlipSided = null, this.currentCullFace = null, this.currentProgram = null, this.currentBlendingEnabled = !1, this.currentBlending = null, this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentPremultipledAlpha = null, this.currentPolygonOffsetFactor = null, this.currentPolygonOffsetUnits = null, this.currentColorMask = null, this.currentDepthFunc = null, this.currentDepthMask = null, this.currentStencilFunc = null, this.currentStencilRef = null, this.currentStencilFuncMask = null, this.currentStencilFail = null, this.currentStencilZFail = null, this.currentStencilZPass = null, this.currentStencilMask = null, this.currentLineWidth = null, this.currentBoundFramebuffers = {}, this.currentDrawbuffers = /* @__PURE__ */ new WeakMap(), this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), this.currentTextureSlot = null, this.currentBoundTextures = {}, this.currentBoundBufferBases = {}, aA === !1 && (this._init(this.gl), aA = !0);
  }
  _init(e) {
    f0 = {
      [eo]: e.FUNC_ADD,
      [PN]: e.FUNC_SUBTRACT,
      [IN]: e.FUNC_REVERSE_SUBTRACT
    }, Ah = {
      [ON]: e.ZERO,
      [DN]: e.ONE,
      [LN]: e.SRC_COLOR,
      [Pm]: e.SRC_ALPHA,
      [jN]: e.SRC_ALPHA_SATURATE,
      [BN]: e.DST_COLOR,
      [kN]: e.DST_ALPHA,
      [UN]: e.ONE_MINUS_SRC_COLOR,
      [Im]: e.ONE_MINUS_SRC_ALPHA,
      [zN]: e.ONE_MINUS_DST_COLOR,
      [FN]: e.ONE_MINUS_DST_ALPHA
    };
  }
  enable(e) {
    const { enabled: i } = this;
    i[e] !== !0 && (this.gl.enable(e), i[e] = !0);
  }
  disable(e) {
    const { enabled: i } = this;
    i[e] !== !1 && (this.gl.disable(e), i[e] = !1);
  }
  setFlipSided(e) {
    if (this.currentFlipSided !== e) {
      const { gl: i } = this;
      e ? i.frontFace(i.CW) : i.frontFace(i.CCW), this.currentFlipSided = e;
    }
  }
  setCullFace(e) {
    const { gl: i } = this;
    e !== w9 ? (this.enable(i.CULL_FACE), e !== this.currentCullFace && (e === E9 ? i.cullFace(i.BACK) : e === M9 ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : this.disable(i.CULL_FACE), this.currentCullFace = e;
  }
  setLineWidth(e) {
    const { currentLineWidth: i, gl: n } = this;
    e !== i && (n.lineWidth(e), this.currentLineWidth = e);
  }
  setBlending(e, i, n, s, a, o, l, u) {
    const { gl: c } = this;
    if (e === xc) {
      this.currentBlendingEnabled === !0 && (this.disable(c.BLEND), this.currentBlendingEnabled = !1);
      return;
    }
    if (this.currentBlendingEnabled === !1 && (this.enable(c.BLEND), this.currentBlendingEnabled = !0), e !== NN) {
      if (e !== this.currentBlending || u !== this.currentPremultipledAlpha) {
        if ((this.currentBlendEquation !== eo || this.currentBlendEquationAlpha !== eo) && (c.blendEquation(c.FUNC_ADD), this.currentBlendEquation = eo, this.currentBlendEquationAlpha = eo), u)
          switch (e) {
            case co:
              c.blendFuncSeparate(c.ONE, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA);
              break;
            case Cm:
              c.blendFunc(c.ONE, c.ONE);
              break;
            case Rm:
              c.blendFuncSeparate(c.ZERO, c.ONE_MINUS_SRC_COLOR, c.ZERO, c.ONE);
              break;
            case Nm:
              c.blendFuncSeparate(c.ZERO, c.SRC_COLOR, c.ZERO, c.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
              break;
          }
        else
          switch (e) {
            case co:
              c.blendFuncSeparate(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA);
              break;
            case Cm:
              c.blendFunc(c.SRC_ALPHA, c.ONE);
              break;
            case Rm:
              c.blendFuncSeparate(c.ZERO, c.ONE_MINUS_SRC_COLOR, c.ZERO, c.ONE);
              break;
            case Nm:
              c.blendFunc(c.ZERO, c.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
              break;
          }
        this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentBlending = e, this.currentPremultipledAlpha = u;
      }
      return;
    }
    a = a || i, o = o || n, l = l || s, (i !== this.currentBlendEquation || a !== this.currentBlendEquationAlpha) && (c.blendEquationSeparate(f0[i], f0[a]), this.currentBlendEquation = i, this.currentBlendEquationAlpha = a), (n !== this.currentBlendSrc || s !== this.currentBlendDst || o !== this.currentBlendSrcAlpha || l !== this.currentBlendDstAlpha) && (c.blendFuncSeparate(Ah[n], Ah[s], Ah[o], Ah[l]), this.currentBlendSrc = n, this.currentBlendDst = s, this.currentBlendSrcAlpha = o, this.currentBlendDstAlpha = l), this.currentBlending = e, this.currentPremultipledAlpha = !1;
  }
  setColorMask(e) {
    this.currentColorMask !== e && (this.gl.colorMask(e, e, e, e), this.currentColorMask = e);
  }
  setDepthTest(e) {
    const { gl: i } = this;
    e ? this.enable(i.DEPTH_TEST) : this.disable(i.DEPTH_TEST);
  }
  setDepthMask(e) {
    this.currentDepthMask !== e && (this.gl.depthMask(e), this.currentDepthMask = e);
  }
  setDepthFunc(e) {
    if (this.currentDepthFunc !== e) {
      const { gl: i } = this;
      switch (e) {
        case VN:
          i.depthFunc(i.NEVER);
          break;
        case GN:
          i.depthFunc(i.ALWAYS);
          break;
        case HN:
          i.depthFunc(i.LESS);
          break;
        case Om:
          i.depthFunc(i.LEQUAL);
          break;
        case WN:
          i.depthFunc(i.EQUAL);
          break;
        case qN:
          i.depthFunc(i.GEQUAL);
          break;
        case XN:
          i.depthFunc(i.GREATER);
          break;
        case $N:
          i.depthFunc(i.NOTEQUAL);
          break;
        default:
          i.depthFunc(i.LEQUAL);
      }
      this.currentDepthFunc = e;
    }
  }
  setStencilTest(e) {
    const { gl: i } = this;
    e ? this.enable(i.STENCIL_TEST) : this.disable(i.STENCIL_TEST);
  }
  setStencilMask(e) {
    this.currentStencilMask !== e && (this.gl.stencilMask(e), this.currentStencilMask = e);
  }
  setStencilFunc(e, i, n) {
    (this.currentStencilFunc !== e || this.currentStencilRef !== i || this.currentStencilFuncMask !== n) && (this.gl.stencilFunc(e, i, n), this.currentStencilFunc = e, this.currentStencilRef = i, this.currentStencilFuncMask = n);
  }
  setStencilOp(e, i, n) {
    (this.currentStencilFail !== e || this.currentStencilZFail !== i || this.currentStencilZPass !== n) && (this.gl.stencilOp(e, i, n), this.currentStencilFail = e, this.currentStencilZFail = i, this.currentStencilZPass = n);
  }
  setMaterial(e, i) {
    const { gl: n } = this;
    e.side === $u ? this.disable(n.CULL_FACE) : this.enable(n.CULL_FACE);
    let s = e.side === Zn;
    i && (s = !s), this.setFlipSided(s), e.blending === co && e.transparent === !1 ? this.setBlending(xc) : this.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), this.setDepthFunc(e.depthFunc), this.setDepthTest(e.depthTest), this.setDepthMask(e.depthWrite), this.setColorMask(e.colorWrite);
    const a = e.stencilWrite;
    this.setStencilTest(a), a && (this.setStencilMask(e.stencilWriteMask), this.setStencilFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), this.setStencilOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), this.setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), e.alphaToCoverage === !0 && this.backend.renderer.samples > 1 ? this.enable(n.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  setPolygonOffset(e, i, n) {
    const { gl: s } = this;
    e ? (this.enable(s.POLYGON_OFFSET_FILL), (this.currentPolygonOffsetFactor !== i || this.currentPolygonOffsetUnits !== n) && (s.polygonOffset(i, n), this.currentPolygonOffsetFactor = i, this.currentPolygonOffsetUnits = n)) : this.disable(s.POLYGON_OFFSET_FILL);
  }
  useProgram(e) {
    return this.currentProgram !== e ? (this.gl.useProgram(e), this.currentProgram = e, !0) : !1;
  }
  // framebuffer
  bindFramebuffer(e, i) {
    const { gl: n, currentBoundFramebuffers: s } = this;
    return s[e] !== i ? (n.bindFramebuffer(e, i), s[e] = i, e === n.DRAW_FRAMEBUFFER && (s[n.FRAMEBUFFER] = i), e === n.FRAMEBUFFER && (s[n.DRAW_FRAMEBUFFER] = i), !0) : !1;
  }
  drawBuffers(e, i) {
    const { gl: n } = this;
    let s = [], a = !1;
    if (e.textures !== null) {
      s = this.currentDrawbuffers.get(i), s === void 0 && (s = [], this.currentDrawbuffers.set(i, s));
      const o = e.textures;
      if (s.length !== o.length || s[0] !== n.COLOR_ATTACHMENT0) {
        for (let l = 0, u = o.length; l < u; l++)
          s[l] = n.COLOR_ATTACHMENT0 + l;
        s.length = o.length, a = !0;
      }
    } else
      s[0] !== n.BACK && (s[0] = n.BACK, a = !0);
    a && n.drawBuffers(s);
  }
  // texture
  activeTexture(e) {
    const { gl: i, currentTextureSlot: n, maxTextures: s } = this;
    e === void 0 && (e = i.TEXTURE0 + s - 1), n !== e && (i.activeTexture(e), this.currentTextureSlot = e);
  }
  bindTexture(e, i, n) {
    const { gl: s, currentTextureSlot: a, currentBoundTextures: o, maxTextures: l } = this;
    n === void 0 && (a === null ? n = s.TEXTURE0 + l - 1 : n = a);
    let u = o[n];
    u === void 0 && (u = { type: void 0, texture: void 0 }, o[n] = u), (u.type !== e || u.texture !== i) && (a !== n && (s.activeTexture(n), this.currentTextureSlot = n), s.bindTexture(e, i), u.type = e, u.texture = i);
  }
  bindBufferBase(e, i, n) {
    const { gl: s } = this, a = `${e}-${i}`;
    return this.currentBoundBufferBases[a] !== n ? (s.bindBufferBase(e, i, n), this.currentBoundBufferBases[a] = n, !0) : !1;
  }
  unbindTexture() {
    const { gl: e, currentTextureSlot: i, currentBoundTextures: n } = this, s = n[i];
    s !== void 0 && s.type !== void 0 && (e.bindTexture(s.type, null), s.type = void 0, s.texture = void 0);
  }
}
class VQ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.extensions = e.extensions;
  }
  convert(e, i = Sl) {
    const { gl: n, extensions: s } = this;
    let a;
    if (e === ho) return n.UNSIGNED_BYTE;
    if (e === F9) return n.UNSIGNED_SHORT_4_4_4_4;
    if (e === B9) return n.UNSIGNED_SHORT_5_5_5_1;
    if (e === YN) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (e === Qh) return n.BYTE;
    if (e === Jh) return n.SHORT;
    if (e === Uu) return n.UNSIGNED_SHORT;
    if (e === Sr) return n.INT;
    if (e === er) return n.UNSIGNED_INT;
    if (e === on) return n.FLOAT;
    if (e === fa)
      return n.HALF_FLOAT;
    if (e === z9) return n.ALPHA;
    if (e === iT) return n.RGB;
    if (e === Fc) return n.RGBA;
    if (e === j9) return n.LUMINANCE;
    if (e === V9) return n.LUMINANCE_ALPHA;
    if (e === gl) return n.DEPTH_COMPONENT;
    if (e === Tc) return n.DEPTH_STENCIL;
    if (e === rT) return n.RED;
    if (e === nT) return n.RED_INTEGER;
    if (e === gd) return n.RG;
    if (e === sT) return n.RG_INTEGER;
    if (e === aT) return n.RGBA_INTEGER;
    if (e === pv || e === em || e === tm || e === im)
      if (i === ct)
        if (a = s.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (e === pv) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (e === em) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (e === tm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (e === im) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = s.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (e === pv) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (e === em) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (e === tm) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (e === im) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (e === _E || e === TE || e === SE || e === wE)
      if (a = s.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (e === _E) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (e === TE) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (e === SE) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (e === wE) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (e === EE || e === Jb || e === ex)
      if (a = s.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (e === EE || e === Jb) return i === ct ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (e === ex) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (e === tx || e === ix || e === rx || e === nx || e === sx || e === ax || e === ox || e === lx || e === ux || e === cx || e === hx || e === dx || e === px || e === fx)
      if (a = s.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (e === tx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (e === ix) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (e === rx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (e === nx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (e === sx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (e === ax) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (e === ox) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (e === lx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (e === ux) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (e === cx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (e === hx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (e === dx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (e === px) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (e === fx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (e === fv)
      if (a = s.get("EXT_texture_compression_bptc"), a !== null) {
        if (e === fv) return i === ct ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    if (e === H9 || e === ME || e === AE || e === CE)
      if (a = s.get("EXT_texture_compression_rgtc"), a !== null) {
        if (e === fv) return a.COMPRESSED_RED_RGTC1_EXT;
        if (e === ME) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (e === AE) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (e === CE) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return e === $d ? n.UNSIGNED_INT_24_8 : n[e] !== void 0 ? n[e] : null;
  }
  _clientWaitAsync() {
    const { gl: e } = this, i = e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE, 0);
    return e.flush(), new Promise((n, s) => {
      function a() {
        const o = e.clientWaitSync(i, e.SYNC_FLUSH_COMMANDS_BIT, 0);
        if (o === e.WAIT_FAILED) {
          e.deleteSync(i), s();
          return;
        }
        if (o === e.TIMEOUT_EXPIRED) {
          requestAnimationFrame(a);
          return;
        }
        e.deleteSync(i), n();
      }
      a();
    });
  }
}
let oA = !1, wf, m0, lA;
class GQ {
  constructor(e) {
    this.backend = e, this.gl = e.gl, this.extensions = e.extensions, this.defaultTextures = {}, oA === !1 && (this._init(this.gl), oA = !0);
  }
  _init(e) {
    wf = {
      [Dm]: e.REPEAT,
      [Lu]: e.CLAMP_TO_EDGE,
      [Lm]: e.MIRRORED_REPEAT
    }, m0 = {
      [gr]: e.NEAREST,
      [Zb]: e.NEAREST_MIPMAP_NEAREST,
      [Ku]: e.NEAREST_MIPMAP_LINEAR,
      [ln]: e.LINEAR,
      [Qb]: e.LINEAR_MIPMAP_NEAREST,
      [pa]: e.LINEAR_MIPMAP_LINEAR
    }, lA = {
      [ZN]: e.NEVER,
      [rP]: e.ALWAYS,
      [oT]: e.LESS,
      [JN]: e.LEQUAL,
      [QN]: e.EQUAL,
      [iP]: e.GEQUAL,
      [eP]: e.GREATER,
      [tP]: e.NOTEQUAL
    };
  }
  filterFallback(e) {
    const { gl: i } = this;
    return e === gr || e === Zb || e === Ku ? i.NEAREST : i.LINEAR;
  }
  getGLTextureType(e) {
    const { gl: i } = this;
    let n;
    return e.isCubeTexture === !0 ? n = i.TEXTURE_CUBE_MAP : e.isDataArrayTexture === !0 || e.isCompressedArrayTexture === !0 ? n = i.TEXTURE_2D_ARRAY : e.isData3DTexture === !0 ? n = i.TEXTURE_3D : n = i.TEXTURE_2D, n;
  }
  getInternalFormat(e, i, n, s, a = !1) {
    const { gl: o, extensions: l } = this;
    if (e !== null) {
      if (o[e] !== void 0) return o[e];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e + "'");
    }
    let u = i;
    return i === o.RED && (n === o.FLOAT && (u = o.R32F), n === o.HALF_FLOAT && (u = o.R16F), n === o.UNSIGNED_BYTE && (u = o.R8), n === o.UNSIGNED_SHORT && (u = o.R16), n === o.UNSIGNED_INT && (u = o.R32UI), n === o.BYTE && (u = o.R8I), n === o.SHORT && (u = o.R16I), n === o.INT && (u = o.R32I)), i === o.RED_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.R8UI), n === o.UNSIGNED_SHORT && (u = o.R16UI), n === o.UNSIGNED_INT && (u = o.R32UI), n === o.BYTE && (u = o.R8I), n === o.SHORT && (u = o.R16I), n === o.INT && (u = o.R32I)), i === o.RG && (n === o.FLOAT && (u = o.RG32F), n === o.HALF_FLOAT && (u = o.RG16F), n === o.UNSIGNED_BYTE && (u = o.RG8), n === o.UNSIGNED_SHORT && (u = o.RG16), n === o.UNSIGNED_INT && (u = o.RG32UI), n === o.BYTE && (u = o.RG8I), n === o.SHORT && (u = o.RG16I), n === o.INT && (u = o.RG32I)), i === o.RG_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RG8UI), n === o.UNSIGNED_SHORT && (u = o.RG16UI), n === o.UNSIGNED_INT && (u = o.RG32UI), n === o.BYTE && (u = o.RG8I), n === o.SHORT && (u = o.RG16I), n === o.INT && (u = o.RG32I)), i === o.RGB && (n === o.FLOAT && (u = o.RGB32F), n === o.HALF_FLOAT && (u = o.RGB16F), n === o.UNSIGNED_BYTE && (u = o.RGB8), n === o.UNSIGNED_SHORT && (u = o.RGB16), n === o.UNSIGNED_INT && (u = o.RGB32UI), n === o.BYTE && (u = o.RGB8I), n === o.SHORT && (u = o.RGB16I), n === o.INT && (u = o.RGB32I), n === o.UNSIGNED_BYTE && (u = s === ct && a === !1 ? o.SRGB8 : o.RGB8), n === o.UNSIGNED_SHORT_5_6_5 && (u = o.RGB565), n === o.UNSIGNED_SHORT_5_5_5_1 && (u = o.RGB5_A1), n === o.UNSIGNED_SHORT_4_4_4_4 && (u = o.RGB4), n === o.UNSIGNED_INT_5_9_9_9_REV && (u = o.RGB9_E5)), i === o.RGB_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RGB8UI), n === o.UNSIGNED_SHORT && (u = o.RGB16UI), n === o.UNSIGNED_INT && (u = o.RGB32UI), n === o.BYTE && (u = o.RGB8I), n === o.SHORT && (u = o.RGB16I), n === o.INT && (u = o.RGB32I)), i === o.RGBA && (n === o.FLOAT && (u = o.RGBA32F), n === o.HALF_FLOAT && (u = o.RGBA16F), n === o.UNSIGNED_BYTE && (u = o.RGBA8), n === o.UNSIGNED_SHORT && (u = o.RGBA16), n === o.UNSIGNED_INT && (u = o.RGBA32UI), n === o.BYTE && (u = o.RGBA8I), n === o.SHORT && (u = o.RGBA16I), n === o.INT && (u = o.RGBA32I), n === o.UNSIGNED_BYTE && (u = s === ct && a === !1 ? o.SRGB8_ALPHA8 : o.RGBA8), n === o.UNSIGNED_SHORT_4_4_4_4 && (u = o.RGBA4), n === o.UNSIGNED_SHORT_5_5_5_1 && (u = o.RGB5_A1)), i === o.RGBA_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RGBA8UI), n === o.UNSIGNED_SHORT && (u = o.RGBA16UI), n === o.UNSIGNED_INT && (u = o.RGBA32UI), n === o.BYTE && (u = o.RGBA8I), n === o.SHORT && (u = o.RGBA16I), n === o.INT && (u = o.RGBA32I)), i === o.DEPTH_COMPONENT && (n === o.UNSIGNED_INT && (u = o.DEPTH24_STENCIL8), n === o.FLOAT && (u = o.DEPTH_COMPONENT32F)), i === o.DEPTH_STENCIL && n === o.UNSIGNED_INT_24_8 && (u = o.DEPTH24_STENCIL8), (u === o.R16F || u === o.R32F || u === o.RG16F || u === o.RG32F || u === o.RGBA16F || u === o.RGBA32F) && l.get("EXT_color_buffer_float"), u;
  }
  setTextureParameters(e, i) {
    const { gl: n, extensions: s, backend: a } = this;
    n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, i.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, i.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE), n.texParameteri(e, n.TEXTURE_WRAP_S, wf[i.wrapS]), n.texParameteri(e, n.TEXTURE_WRAP_T, wf[i.wrapT]), (e === n.TEXTURE_3D || e === n.TEXTURE_2D_ARRAY) && n.texParameteri(e, n.TEXTURE_WRAP_R, wf[i.wrapR]), n.texParameteri(e, n.TEXTURE_MAG_FILTER, m0[i.magFilter]);
    const o = i.mipmaps !== void 0 && i.mipmaps.length > 0, l = i.minFilter === ln && o ? pa : i.minFilter;
    if (n.texParameteri(e, n.TEXTURE_MIN_FILTER, m0[l]), i.compareFunction && (n.texParameteri(e, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(e, n.TEXTURE_COMPARE_FUNC, lA[i.compareFunction])), s.has("EXT_texture_filter_anisotropic") === !0) {
      if (i.magFilter === gr || i.minFilter !== Ku && i.minFilter !== pa || i.type === on && s.has("OES_texture_float_linear") === !1) return;
      if (i.anisotropy > 1) {
        const u = s.get("EXT_texture_filter_anisotropic");
        n.texParameterf(e, u.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i.anisotropy, a.getMaxAnisotropy()));
      }
    }
  }
  createDefaultTexture(e) {
    const { gl: i, backend: n, defaultTextures: s } = this, a = this.getGLTextureType(e);
    let o = s[a];
    o === void 0 && (o = i.createTexture(), n.state.bindTexture(a, o), i.texParameteri(a, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(a, i.TEXTURE_MAG_FILTER, i.NEAREST), s[a] = o), n.set(e, {
      textureGPU: o,
      glTextureType: a,
      isDefault: !0
    });
  }
  createTexture(e, i) {
    const { gl: n, backend: s } = this, { levels: a, width: o, height: l, depth: u } = i, c = s.utils.convert(e.format, e.colorSpace), h = s.utils.convert(e.type), d = this.getInternalFormat(e.internalFormat, c, h, e.colorSpace, e.isVideoTexture), p = n.createTexture(), f = this.getGLTextureType(e);
    s.state.bindTexture(f, p), this.setTextureParameters(f, e), e.isDataArrayTexture || e.isCompressedArrayTexture ? n.texStorage3D(n.TEXTURE_2D_ARRAY, a, d, o, l, u) : e.isData3DTexture ? n.texStorage3D(n.TEXTURE_3D, a, d, o, l, u) : e.isVideoTexture || n.texStorage2D(f, a, d, o, l), s.set(e, {
      textureGPU: p,
      glTextureType: f,
      glFormat: c,
      glType: h,
      glInternalFormat: d
    });
  }
  copyBufferToTexture(e, i) {
    const { gl: n, backend: s } = this, { textureGPU: a, glTextureType: o, glFormat: l, glType: u } = s.get(i), { width: c, height: h } = i.source.data;
    n.bindBuffer(n.PIXEL_UNPACK_BUFFER, e), s.state.bindTexture(o, a), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), n.texSubImage2D(o, 0, 0, 0, c, h, l, u, 0), n.bindBuffer(n.PIXEL_UNPACK_BUFFER, null), s.state.unbindTexture();
  }
  updateTexture(e, i) {
    const { gl: n } = this, { width: s, height: a } = i, { textureGPU: o, glTextureType: l, glFormat: u, glType: c, glInternalFormat: h } = this.backend.get(e);
    if (e.isRenderTargetTexture || o === void 0)
      return;
    const d = (p) => p.isDataTexture ? p.image.data : p instanceof ImageBitmap || p instanceof OffscreenCanvas || p instanceof HTMLImageElement || p instanceof HTMLCanvasElement ? p : p.data;
    if (this.backend.state.bindTexture(l, o), this.setTextureParameters(l, e), e.isCompressedTexture) {
      const p = e.mipmaps, f = i.image;
      for (let m = 0; m < p.length; m++) {
        const v = p[m];
        e.isCompressedArrayTexture ? e.format !== n.RGBA ? u !== null ? n.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, m, 0, 0, 0, v.width, v.height, f.depth, u, v.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texSubImage3D(n.TEXTURE_2D_ARRAY, m, 0, 0, 0, v.width, v.height, f.depth, u, c, v.data) : u !== null ? n.compressedTexSubImage2D(n.TEXTURE_2D, m, 0, 0, v.width, v.height, u, v.data) : console.warn("Unsupported compressed texture format");
      }
    } else if (e.isCubeTexture) {
      const p = i.images;
      for (let f = 0; f < 6; f++) {
        const m = d(p[f]);
        n.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, 0, 0, s, a, u, c, m);
      }
    } else if (e.isDataArrayTexture) {
      const p = i.image;
      n.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, u, c, p.data);
    } else if (e.isData3DTexture) {
      const p = i.image;
      n.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, u, c, p.data);
    } else if (e.isVideoTexture)
      e.update(), n.texImage2D(l, 0, h, u, c, i.image);
    else {
      const p = d(i.image);
      n.texSubImage2D(l, 0, 0, 0, s, a, u, c, p);
    }
  }
  generateMipmaps(e) {
    const { gl: i, backend: n } = this, { textureGPU: s, glTextureType: a } = n.get(e);
    n.state.bindTexture(a, s), i.generateMipmap(a);
  }
  deallocateRenderBuffers(e) {
    const { gl: i, backend: n } = this;
    if (e) {
      const s = n.get(e);
      if (s.renderBufferStorageSetup = void 0, s.framebuffers) {
        for (const a in s.framebuffers)
          i.deleteFramebuffer(s.framebuffers[a]);
        delete s.framebuffers;
      }
      if (s.depthRenderbuffer && (i.deleteRenderbuffer(s.depthRenderbuffer), delete s.depthRenderbuffer), s.stencilRenderbuffer && (i.deleteRenderbuffer(s.stencilRenderbuffer), delete s.stencilRenderbuffer), s.msaaFrameBuffer && (i.deleteFramebuffer(s.msaaFrameBuffer), delete s.msaaFrameBuffer), s.msaaRenderbuffers) {
        for (let a = 0; a < s.msaaRenderbuffers.length; a++)
          i.deleteRenderbuffer(s.msaaRenderbuffers[a]);
        delete s.msaaRenderbuffers;
      }
    }
  }
  destroyTexture(e) {
    const { gl: i, backend: n } = this, { textureGPU: s, renderTarget: a } = n.get(e);
    this.deallocateRenderBuffers(a), i.deleteTexture(s), n.delete(e);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    const { gl: o, backend: l } = this, { state: u } = this.backend, { textureGPU: c, glTextureType: h, glType: d, glFormat: p } = l.get(i);
    let f, m, v, y, g, _;
    n !== null ? (f = n.max.x - n.min.x, m = n.max.y - n.min.y, v = n.min.x, y = n.min.y) : (f = e.image.width, m = e.image.height, v = 0, y = 0), s !== null ? (g = s.x, _ = s.y) : (g = 0, _ = 0), u.bindTexture(h, c), o.pixelStorei(o.UNPACK_ALIGNMENT, i.unpackAlignment), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, i.flipY), o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), o.pixelStorei(o.UNPACK_ALIGNMENT, i.unpackAlignment);
    const x = o.getParameter(o.UNPACK_ROW_LENGTH), b = o.getParameter(o.UNPACK_IMAGE_HEIGHT), T = o.getParameter(o.UNPACK_SKIP_PIXELS), S = o.getParameter(o.UNPACK_SKIP_ROWS), w = o.getParameter(o.UNPACK_SKIP_IMAGES), A = e.isCompressedTexture ? e.mipmaps[a] : e.image;
    if (o.pixelStorei(o.UNPACK_ROW_LENGTH, A.width), o.pixelStorei(o.UNPACK_IMAGE_HEIGHT, A.height), o.pixelStorei(o.UNPACK_SKIP_PIXELS, v), o.pixelStorei(o.UNPACK_SKIP_ROWS, y), e.isRenderTargetTexture || e.isDepthTexture) {
      const E = l.get(e), M = l.get(i), N = l.get(E.renderTarget), k = l.get(M.renderTarget), U = N.framebuffers[E.cacheKey], C = k.framebuffers[M.cacheKey];
      u.bindFramebuffer(o.READ_FRAMEBUFFER, U), u.bindFramebuffer(o.DRAW_FRAMEBUFFER, C);
      let O = o.COLOR_BUFFER_BIT;
      e.isDepthTexture && (O = o.DEPTH_BUFFER_BIT), o.blitFramebuffer(v, y, f, m, g, _, f, m, O, o.NEAREST), u.bindFramebuffer(o.READ_FRAMEBUFFER, null), u.bindFramebuffer(o.DRAW_FRAMEBUFFER, null);
    } else
      e.isDataTexture ? o.texSubImage2D(o.TEXTURE_2D, a, g, _, f, m, p, d, A.data) : e.isCompressedTexture ? o.compressedTexSubImage2D(o.TEXTURE_2D, a, g, _, A.width, A.height, p, A.data) : o.texSubImage2D(o.TEXTURE_2D, a, g, _, f, m, p, d, A);
    o.pixelStorei(o.UNPACK_ROW_LENGTH, x), o.pixelStorei(o.UNPACK_IMAGE_HEIGHT, b), o.pixelStorei(o.UNPACK_SKIP_PIXELS, T), o.pixelStorei(o.UNPACK_SKIP_ROWS, S), o.pixelStorei(o.UNPACK_SKIP_IMAGES, w), a === 0 && i.generateMipmaps && o.generateMipmap(o.TEXTURE_2D), u.unbindTexture();
  }
  copyFramebufferToTexture(e, i, n) {
    const { gl: s } = this, { state: a } = this.backend, { textureGPU: o } = this.backend.get(e), { x: l, y: u, z: c, w: h } = n, d = e.isDepthTexture === !0 || i.renderTarget && i.renderTarget.samples > 0, p = i.renderTarget ? i.renderTarget.height : this.backend.gerDrawingBufferSize().y;
    if (d) {
      const f = l !== 0 || u !== 0;
      let m, v;
      if (e.isDepthTexture === !0 ? (m = s.DEPTH_BUFFER_BIT, v = s.DEPTH_ATTACHMENT, i.stencil && (m |= s.STENCIL_BUFFER_BIT)) : (m = s.COLOR_BUFFER_BIT, v = s.COLOR_ATTACHMENT0), f) {
        const y = this.backend.get(i.renderTarget), g = y.framebuffers[i.getCacheKey()], _ = y.msaaFrameBuffer;
        a.bindFramebuffer(s.DRAW_FRAMEBUFFER, g), a.bindFramebuffer(s.READ_FRAMEBUFFER, _);
        const x = p - u - h;
        s.blitFramebuffer(l, x, l + c, x + h, l, x, l + c, x + h, m, s.NEAREST), a.bindFramebuffer(s.READ_FRAMEBUFFER, g), a.bindTexture(s.TEXTURE_2D, o), s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, l, x, c, h), a.unbindTexture();
      } else {
        const y = s.createFramebuffer();
        a.bindFramebuffer(s.DRAW_FRAMEBUFFER, y), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, v, s.TEXTURE_2D, o, 0), s.blitFramebuffer(0, 0, c, h, 0, 0, c, h, m, s.NEAREST), s.deleteFramebuffer(y);
      }
    } else
      a.bindTexture(s.TEXTURE_2D, o), s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, l, p - h - u, c, h), a.unbindTexture();
    e.generateMipmaps && this.generateMipmaps(e), this.backend._setFramebuffer(i);
  }
  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  setupRenderBufferStorage(e, i) {
    const { gl: n } = this, s = i.renderTarget, { samples: a, depthTexture: o, depthBuffer: l, stencilBuffer: u, width: c, height: h } = s;
    if (n.bindRenderbuffer(n.RENDERBUFFER, e), l && !u) {
      let d = n.DEPTH_COMPONENT24;
      a > 0 ? (o && o.isDepthTexture && o.type === n.FLOAT && (d = n.DEPTH_COMPONENT32F), n.renderbufferStorageMultisample(n.RENDERBUFFER, a, d, c, h)) : n.renderbufferStorage(n.RENDERBUFFER, d, c, h), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, e);
    } else l && u && (a > 0 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, a, n.DEPTH24_STENCIL8, c, h) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, c, h), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, e));
  }
  async copyTextureToBuffer(e, i, n, s, a, o) {
    const { backend: l, gl: u } = this, { textureGPU: c, glFormat: h, glType: d } = this.backend.get(e), p = u.createFramebuffer();
    u.bindFramebuffer(u.READ_FRAMEBUFFER, p);
    const f = e.isCubeTexture ? u.TEXTURE_CUBE_MAP_POSITIVE_X + o : u.TEXTURE_2D;
    u.framebufferTexture2D(u.READ_FRAMEBUFFER, u.COLOR_ATTACHMENT0, f, c, 0);
    const m = this._getTypedArrayType(d), v = this._getBytesPerTexel(d, h), y = s * a * v, g = u.createBuffer();
    u.bindBuffer(u.PIXEL_PACK_BUFFER, g), u.bufferData(u.PIXEL_PACK_BUFFER, y, u.STREAM_READ), u.readPixels(i, n, s, a, h, d, 0), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), await l.utils._clientWaitAsync();
    const _ = new m(y / m.BYTES_PER_ELEMENT);
    return u.bindBuffer(u.PIXEL_PACK_BUFFER, g), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, _), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), u.deleteFramebuffer(p), _;
  }
  _getTypedArrayType(e) {
    const { gl: i } = this;
    if (e === i.UNSIGNED_BYTE) return Uint8Array;
    if (e === i.UNSIGNED_SHORT_4_4_4_4 || e === i.UNSIGNED_SHORT_5_5_5_1 || e === i.UNSIGNED_SHORT_5_6_5 || e === i.UNSIGNED_SHORT) return Uint16Array;
    if (e === i.UNSIGNED_INT) return Uint32Array;
    if (e === i.HALF_FLOAT) return Uint16Array;
    if (e === i.FLOAT) return Float32Array;
    throw new Error(`Unsupported WebGL type: ${e}`);
  }
  _getBytesPerTexel(e, i) {
    const { gl: n } = this;
    let s = 0;
    if (e === n.UNSIGNED_BYTE && (s = 1), (e === n.UNSIGNED_SHORT_4_4_4_4 || e === n.UNSIGNED_SHORT_5_5_5_1 || e === n.UNSIGNED_SHORT_5_6_5 || e === n.UNSIGNED_SHORT || e === n.HALF_FLOAT) && (s = 2), (e === n.UNSIGNED_INT || e === n.FLOAT) && (s = 4), i === n.RGBA) return s * 4;
    if (i === n.RGB) return s * 3;
    if (i === n.ALPHA) return s;
  }
}
class HQ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.availableExtensions = this.gl.getSupportedExtensions(), this.extensions = {};
  }
  get(e) {
    let i = this.extensions[e];
    return i === void 0 && (i = this.gl.getExtension(e), this.extensions[e] = i), i;
  }
  has(e) {
    return this.availableExtensions.includes(e);
  }
}
class WQ {
  constructor(e) {
    this.backend = e, this.maxAnisotropy = null;
  }
  getMaxAnisotropy() {
    if (this.maxAnisotropy !== null) return this.maxAnisotropy;
    const e = this.backend.gl, i = this.backend.extensions;
    if (i.has("EXT_texture_filter_anisotropic") === !0) {
      const n = i.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      this.maxAnisotropy = 0;
    return this.maxAnisotropy;
  }
}
const uA = {
  WEBGL_multi_draw: "WEBGL_multi_draw",
  WEBGL_compressed_texture_astc: "texture-compression-astc",
  WEBGL_compressed_texture_etc: "texture-compression-etc2",
  WEBGL_compressed_texture_etc1: "texture-compression-etc1",
  WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBKIT_WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBGL_compressed_texture_s3tc: "texture-compression-bc",
  EXT_texture_compression_bptc: "texture-compression-bptc",
  EXT_disjoint_timer_query_webgl2: "timestamp-query"
};
class qQ {
  constructor(e) {
    this.gl = e.gl, this.extensions = e.extensions, this.info = e.renderer.info, this.mode = null, this.index = 0, this.type = null, this.object = null;
  }
  render(e, i) {
    const { gl: n, mode: s, object: a, type: o, info: l, index: u } = this;
    u !== 0 ? n.drawElements(s, i, o, e) : n.drawArrays(s, e, i), l.update(a, i, s, 1);
  }
  renderInstances(e, i, n) {
    const { gl: s, mode: a, type: o, index: l, object: u, info: c } = this;
    n !== 0 && (l !== 0 ? s.drawElementsInstanced(a, i, o, e, n) : s.drawArraysInstanced(a, e, i, n), c.update(u, i, a, n));
  }
  renderMultiDraw(e, i, n) {
    const { extensions: s, mode: a, object: o, info: l } = this;
    if (n === 0) return;
    const u = s.get("WEBGL_multi_draw");
    if (u === null)
      for (let c = 0; c < n; c++)
        this.render(e[c], i[c]);
    else {
      this.index !== 0 ? u.multiDrawElementsWEBGL(a, i, 0, this.type, e, 0, n) : u.multiDrawArraysWEBGL(a, e, 0, i, 0, n);
      let c = 0;
      for (let h = 0; h < n; h++)
        c += i[h];
      l.update(o, c, a, 1);
    }
  }
  renderMultiDrawInstances(e, i, n, s) {
    const { extensions: a, mode: o, object: l, info: u } = this;
    if (n === 0) return;
    const c = a.get("WEBGL_multi_draw");
    if (c === null)
      for (let h = 0; h < n; h++)
        this.renderInstances(e[h], i[h], s[h]);
    else {
      this.index !== 0 ? c.multiDrawElementsInstancedWEBGL(o, i, 0, this.type, e, 0, s, 0, n) : c.multiDrawArraysInstancedWEBGL(o, e, 0, i, 0, s, 0, n);
      let h = 0;
      for (let d = 0; d < n; d++)
        h += i[d] * s[d];
      u.update(l, h, o, 1);
    }
  }
  //
}
class cA extends rO {
  constructor(e = {}) {
    super(e), this.isWebGLBackend = !0;
  }
  init(e) {
    super.init(e);
    const i = this.parameters, n = i.context !== void 0 ? i.context : e.domElement.getContext("webgl2");
    function s(a) {
      a.preventDefault();
      const o = {
        api: "WebGL",
        message: a.statusMessage || "Unknown reason",
        reason: null,
        originalEvent: a
      };
      e.onDeviceLost(o);
    }
    this._onContextLost = s, e.domElement.addEventListener("webglcontextlost", s, !1), this.gl = n, this.extensions = new HQ(this), this.capabilities = new WQ(this), this.attributeUtils = new zQ(this), this.textureUtils = new GQ(this), this.bufferRenderer = new qQ(this), this.state = new jQ(this), this.utils = new VQ(this), this.vaoCache = {}, this.transformFeedbackCache = {}, this.discard = !1, this.trackTimestamp = i.trackTimestamp === !0, this.extensions.get("EXT_color_buffer_float"), this.extensions.get("WEBGL_clip_cull_distance"), this.extensions.get("OES_texture_float_linear"), this.extensions.get("EXT_color_buffer_half_float"), this.extensions.get("WEBGL_multisampled_render_to_texture"), this.extensions.get("WEBGL_render_shared_exponent"), this.extensions.get("WEBGL_multi_draw"), this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2"), this.parallel = this.extensions.get("KHR_parallel_shader_compile"), this._knownBindings = /* @__PURE__ */ new WeakSet(), this._currentContext = null;
  }
  get coordinateSystem() {
    return Yn;
  }
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  async waitForGPU() {
    await this.utils._clientWaitAsync();
  }
  initTimestampQuery(e) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const i = this.get(e);
    if (this.queryRunning) {
      i.queryQueue || (i.queryQueue = []), i.queryQueue.push(e);
      return;
    }
    i.activeQuery && (this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT), i.activeQuery = null), i.activeQuery = this.gl.createQuery(), i.activeQuery !== null && (this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT, i.activeQuery), this.queryRunning = !0);
  }
  // timestamp utils
  prepareTimestampBuffer(e) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const i = this.get(e);
    if (i.activeQuery && (this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT), i.gpuQueries || (i.gpuQueries = []), i.gpuQueries.push({ query: i.activeQuery }), i.activeQuery = null, this.queryRunning = !1, i.queryQueue && i.queryQueue.length > 0)) {
      const n = i.queryQueue.shift();
      this.initTimestampQuery(n);
    }
  }
  async resolveTimestampAsync(e, i = "render") {
    if (!this.disjoint || !this.trackTimestamp) return;
    const n = this.get(e);
    n.gpuQueries || (n.gpuQueries = []);
    for (let s = 0; s < n.gpuQueries.length; s++) {
      const a = n.gpuQueries[s], o = this.gl.getQueryParameter(a.query, this.gl.QUERY_RESULT_AVAILABLE), l = this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);
      if (o && !l) {
        const u = this.gl.getQueryParameter(a.query, this.gl.QUERY_RESULT), c = Number(u) / 1e6;
        this.gl.deleteQuery(a.query), n.gpuQueries.splice(s, 1), s--, this.renderer.info.updateTimestamp(i, c);
      }
    }
  }
  getContext() {
    return this.gl;
  }
  beginRender(e) {
    const { gl: i } = this, n = this.get(e);
    if (this.initTimestampQuery(e), n.previousContext = this._currentContext, this._currentContext = e, this._setFramebuffer(e), this.clear(e.clearColor, e.clearDepth, e.clearStencil, e, !1), e.viewport ? this.updateViewport(e) : i.viewport(0, 0, i.drawingBufferWidth, i.drawingBufferHeight), e.scissor) {
      const { x: a, y: o, width: l, height: u } = e.scissorValue;
      i.scissor(a, e.height - u - o, l, u);
    }
    const s = e.occlusionQueryCount;
    s > 0 && (n.currentOcclusionQueries = n.occlusionQueries, n.currentOcclusionQueryObjects = n.occlusionQueryObjects, n.lastOcclusionObject = null, n.occlusionQueries = new Array(s), n.occlusionQueryObjects = new Array(s), n.occlusionQueryIndex = 0);
  }
  finishRender(e) {
    const { gl: i, state: n } = this, s = this.get(e), a = s.previousContext, o = e.occlusionQueryCount;
    o > 0 && (o > s.occlusionQueryIndex && i.endQuery(i.ANY_SAMPLES_PASSED), this.resolveOccludedAsync(e));
    const l = e.textures;
    if (l !== null)
      for (let u = 0; u < l.length; u++) {
        const c = l[u];
        c.generateMipmaps && this.generateMipmaps(c);
      }
    if (this._currentContext = a, e.textures !== null && e.renderTarget) {
      const u = this.get(e.renderTarget), { samples: c } = e.renderTarget;
      if (c > 0) {
        const h = u.framebuffers[e.getCacheKey()], d = i.COLOR_BUFFER_BIT, p = u.msaaFrameBuffer, f = e.textures;
        n.bindFramebuffer(i.READ_FRAMEBUFFER, p), n.bindFramebuffer(i.DRAW_FRAMEBUFFER, h);
        for (let m = 0; m < f.length; m++)
          if (e.scissor) {
            const { x: v, y, width: g, height: _ } = e.scissorValue, x = e.height - _ - y;
            i.blitFramebuffer(v, x, v + g, x + _, v, x, v + g, x + _, d, i.NEAREST), i.invalidateSubFramebuffer(i.READ_FRAMEBUFFER, u.invalidationArray, v, x, g, _);
          } else
            i.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, d, i.NEAREST), i.invalidateFramebuffer(i.READ_FRAMEBUFFER, u.invalidationArray);
      }
    }
    a !== null && (this._setFramebuffer(a), a.viewport ? this.updateViewport(a) : i.viewport(0, 0, i.drawingBufferWidth, i.drawingBufferHeight)), this.prepareTimestampBuffer(e);
  }
  resolveOccludedAsync(e) {
    const i = this.get(e), { currentOcclusionQueries: n, currentOcclusionQueryObjects: s } = i;
    if (n && s) {
      const a = /* @__PURE__ */ new WeakSet(), { gl: o } = this;
      i.currentOcclusionQueryObjects = null, i.currentOcclusionQueries = null;
      const l = () => {
        let u = 0;
        for (let c = 0; c < n.length; c++) {
          const h = n[c];
          h !== null && o.getQueryParameter(h, o.QUERY_RESULT_AVAILABLE) && (o.getQueryParameter(h, o.QUERY_RESULT) > 0 && a.add(s[c]), n[c] = null, o.deleteQuery(h), u++);
        }
        u < n.length ? requestAnimationFrame(l) : i.occluded = a;
      };
      l();
    }
  }
  isOccluded(e, i) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(i);
  }
  updateViewport(e) {
    const i = this.gl, { x: n, y: s, width: a, height: o } = e.viewportValue;
    i.viewport(n, e.height - o - s, a, o);
  }
  setScissorTest(e) {
    const i = this.gl;
    e ? i.enable(i.SCISSOR_TEST) : i.disable(i.SCISSOR_TEST);
  }
  clear(e, i, n, s = null, a = !0) {
    const { gl: o } = this;
    if (s === null) {
      const u = this.getClearColor();
      u.r *= u.a, u.g *= u.a, u.b *= u.a, s = {
        textures: null,
        clearColorValue: u
      };
    }
    let l = 0;
    if (e && (l |= o.COLOR_BUFFER_BIT), i && (l |= o.DEPTH_BUFFER_BIT), n && (l |= o.STENCIL_BUFFER_BIT), l !== 0) {
      let u;
      if (s.clearColorValue ? u = s.clearColorValue : (u = this.getClearColor(), u.r *= u.a, u.g *= u.a, u.b *= u.a), i && this.state.setDepthMask(!0), s.textures === null)
        o.clearColor(u.r, u.g, u.b, u.a), o.clear(l);
      else {
        if (a && this._setFramebuffer(s), e)
          for (let c = 0; c < s.textures.length; c++)
            o.clearBufferfv(o.COLOR, c, [u.r, u.g, u.b, u.a]);
        i && n ? o.clearBufferfi(o.DEPTH_STENCIL, 0, 1, 0) : i ? o.clearBufferfv(o.DEPTH, 0, [1]) : n && o.clearBufferiv(o.STENCIL, 0, [0]);
      }
    }
  }
  beginCompute(e) {
    const { state: i, gl: n } = this;
    i.bindFramebuffer(n.FRAMEBUFFER, null), this.initTimestampQuery(e);
  }
  compute(e, i, n, s) {
    const { state: a, gl: o } = this;
    this.discard || (o.enable(o.RASTERIZER_DISCARD), this.discard = !0);
    const { programGPU: l, transformBuffers: u, attributes: c } = this.get(s), h = this._getVaoKey(null, c), d = this.vaoCache[h];
    d === void 0 ? this._createVao(null, c) : o.bindVertexArray(d), a.useProgram(l), this._bindUniforms(n);
    const p = this._getTransformFeedback(u);
    o.bindTransformFeedback(o.TRANSFORM_FEEDBACK, p), o.beginTransformFeedback(o.POINTS), c[0].isStorageInstancedBufferAttribute ? o.drawArraysInstanced(o.POINTS, 0, 1, i.count) : o.drawArrays(o.POINTS, 0, i.count), o.endTransformFeedback(), o.bindTransformFeedback(o.TRANSFORM_FEEDBACK, null);
    for (let f = 0; f < u.length; f++) {
      const m = u[f];
      m.pbo && this.textureUtils.copyBufferToTexture(m.transformBuffer, m.pbo), m.switchBuffers();
    }
  }
  finishCompute(e) {
    const i = this.gl;
    this.discard = !1, i.disable(i.RASTERIZER_DISCARD), this.prepareTimestampBuffer(e), this._currentContext && this._setFramebuffer(this._currentContext);
  }
  draw(e) {
    const { object: i, pipeline: n, material: s, context: a } = e, { programGPU: o } = this.get(n), { gl: l, state: u } = this, c = this.get(a), h = e.getDrawParameters();
    if (h === null) return;
    this._bindUniforms(e.getBindings());
    const d = i.isMesh && i.matrixWorld.determinant() < 0;
    u.setMaterial(s, d), u.useProgram(o);
    let p = e.staticVao;
    if (p === void 0) {
      const x = this._getVaoKey(e.getIndex(), e.getAttributes());
      if (p = this.vaoCache[x], p === void 0) {
        let b;
        ({ vaoGPU: p, staticVao: b } = this._createVao(e.getIndex(), e.getAttributes())), b && (e.staticVao = p);
      }
    }
    l.bindVertexArray(p);
    const f = e.getIndex(), m = c.lastOcclusionObject;
    if (m !== i && m !== void 0) {
      if (m !== null && m.occlusionTest === !0 && (l.endQuery(l.ANY_SAMPLES_PASSED), c.occlusionQueryIndex++), i.occlusionTest === !0) {
        const x = l.createQuery();
        l.beginQuery(l.ANY_SAMPLES_PASSED, x), c.occlusionQueries[c.occlusionQueryIndex] = x, c.occlusionQueryObjects[c.occlusionQueryIndex] = i;
      }
      c.lastOcclusionObject = i;
    }
    const v = this.bufferRenderer;
    i.isPoints ? v.mode = l.POINTS : i.isLineSegments ? v.mode = l.LINES : i.isLine ? v.mode = l.LINE_STRIP : i.isLineLoop ? v.mode = l.LINE_LOOP : s.wireframe === !0 ? (u.setLineWidth(s.wireframeLinewidth * this.renderer.getPixelRatio()), v.mode = l.LINES) : v.mode = l.TRIANGLES;
    const { vertexCount: y, instanceCount: g } = h;
    let { firstVertex: _ } = h;
    if (v.object = i, f !== null) {
      _ *= f.array.BYTES_PER_ELEMENT;
      const x = this.get(f);
      v.index = f.count, v.type = x.type;
    } else
      v.index = 0;
    i.isBatchedMesh ? i._multiDrawInstances !== null ? v.renderMultiDrawInstances(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount, i._multiDrawInstances) : this.hasFeature("WEBGL_multi_draw") ? v.renderMultiDraw(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount) : E7("THREE.WebGLRenderer: WEBGL_multi_draw not supported.") : g > 1 ? v.renderInstances(_, y, g) : v.render(_, y), l.bindVertexArray(null);
  }
  needsRenderUpdate() {
    return !1;
  }
  getRenderCacheKey() {
    return "";
  }
  // textures
  createDefaultTexture(e) {
    this.textureUtils.createDefaultTexture(e);
  }
  createTexture(e, i) {
    this.textureUtils.createTexture(e, i);
  }
  updateTexture(e, i) {
    this.textureUtils.updateTexture(e, i);
  }
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  destroyTexture(e) {
    this.textureUtils.destroyTexture(e);
  }
  copyTextureToBuffer(e, i, n, s, a, o) {
    return this.textureUtils.copyTextureToBuffer(e, i, n, s, a, o);
  }
  createSampler() {
  }
  destroySampler() {
  }
  // node builder
  createNodeBuilder(e, i) {
    return new kQ(e, i);
  }
  // program
  createProgram(e) {
    const i = this.gl, { stage: n, code: s } = e, a = n === "fragment" ? i.createShader(i.FRAGMENT_SHADER) : i.createShader(i.VERTEX_SHADER);
    i.shaderSource(a, s), i.compileShader(a), this.set(e, {
      shaderGPU: a
    });
  }
  destroyProgram() {
    console.warn("Abstract class.");
  }
  createRenderPipeline(e, i) {
    const n = this.gl, s = e.pipeline, { fragmentProgram: a, vertexProgram: o } = s, l = n.createProgram(), u = this.get(a).shaderGPU, c = this.get(o).shaderGPU;
    if (n.attachShader(l, u), n.attachShader(l, c), n.linkProgram(l), this.set(s, {
      programGPU: l,
      fragmentShader: u,
      vertexShader: c
    }), i !== null && this.parallel) {
      const h = new Promise((d) => {
        const p = this.parallel, f = () => {
          n.getProgramParameter(l, p.COMPLETION_STATUS_KHR) ? (this._completeCompile(e, s), d()) : requestAnimationFrame(f);
        };
        f();
      });
      i.push(h);
      return;
    }
    this._completeCompile(e, s);
  }
  _handleSource(e, i) {
    const n = e.split(`
`), s = [], a = Math.max(i - 6, 0), o = Math.min(i + 6, n.length);
    for (let l = a; l < o; l++) {
      const u = l + 1;
      s.push(`${u === i ? ">" : " "} ${u}: ${n[l]}`);
    }
    return s.join(`
`);
  }
  _getShaderErrors(e, i, n) {
    const s = e.getShaderParameter(i, e.COMPILE_STATUS), a = e.getShaderInfoLog(i).trim();
    if (s && a === "") return "";
    const o = /ERROR: 0:(\d+)/.exec(a);
    if (o) {
      const l = parseInt(o[1]);
      return n.toUpperCase() + `

` + a + `

` + this._handleSource(e.getShaderSource(i), l);
    } else
      return a;
  }
  _logProgramError(e, i, n) {
    if (this.renderer.debug.checkShaderErrors) {
      const s = this.gl, a = s.getProgramInfoLog(e).trim();
      if (s.getProgramParameter(e, s.LINK_STATUS) === !1)
        if (typeof this.renderer.debug.onShaderError == "function")
          this.renderer.debug.onShaderError(s, e, n, i);
        else {
          const o = this._getShaderErrors(s, n, "vertex"), l = this._getShaderErrors(s, i, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(e, s.VALIDATE_STATUS) + `

Program Info Log: ` + a + `
` + o + `
` + l
          );
        }
      else a !== "" && console.warn("THREE.WebGLProgram: Program Info Log:", a);
    }
  }
  _completeCompile(e, i) {
    const { state: n, gl: s } = this, a = this.get(i), { programGPU: o, fragmentShader: l, vertexShader: u } = a;
    s.getProgramParameter(o, s.LINK_STATUS) === !1 && this._logProgramError(o, l, u), n.useProgram(o);
    const c = e.getBindings();
    this._setupBindings(c, o), this.set(i, {
      programGPU: o
    });
  }
  createComputePipeline(e, i) {
    const { state: n, gl: s } = this, a = {
      stage: "fragment",
      code: `#version 300 es
precision highp float;
void main() {}`
    };
    this.createProgram(a);
    const { computeProgram: o } = e, l = s.createProgram(), u = this.get(a).shaderGPU, c = this.get(o).shaderGPU, h = o.transforms, d = [], p = [];
    for (let y = 0; y < h.length; y++) {
      const g = h[y];
      d.push(g.varyingName), p.push(g.attributeNode);
    }
    s.attachShader(l, u), s.attachShader(l, c), s.transformFeedbackVaryings(
      l,
      d,
      s.SEPARATE_ATTRIBS
    ), s.linkProgram(l), s.getProgramParameter(l, s.LINK_STATUS) === !1 && this._logProgramError(l, u, c), n.useProgram(l), this._setupBindings(i, l);
    const f = o.attributes, m = [], v = [];
    for (let y = 0; y < f.length; y++) {
      const g = f[y].node.attribute;
      m.push(g), this.has(g) || this.attributeUtils.createAttribute(g, s.ARRAY_BUFFER);
    }
    for (let y = 0; y < p.length; y++) {
      const g = p[y].attribute;
      this.has(g) || this.attributeUtils.createAttribute(g, s.ARRAY_BUFFER);
      const _ = this.get(g);
      v.push(_);
    }
    this.set(e, {
      programGPU: l,
      transformBuffers: v,
      attributes: m
    });
  }
  createBindings(e, i) {
    if (this._knownBindings.has(i) === !1) {
      this._knownBindings.add(i);
      let n = 0, s = 0;
      for (const a of i) {
        this.set(a, {
          textures: s,
          uniformBuffers: n
        });
        for (const o of a.bindings)
          o.isUniformBuffer && n++, o.isSampledTexture && s++;
      }
    }
    this.updateBindings(e, i);
  }
  updateBindings(e) {
    const { gl: i } = this, n = this.get(e);
    let s = n.uniformBuffers, a = n.textures;
    for (const o of e.bindings)
      if (o.isUniformsGroup || o.isUniformBuffer) {
        const l = o.buffer, u = i.createBuffer();
        i.bindBuffer(i.UNIFORM_BUFFER, u), i.bufferData(i.UNIFORM_BUFFER, l, i.DYNAMIC_DRAW), this.set(o, {
          index: s++,
          bufferGPU: u
        });
      } else if (o.isSampledTexture) {
        const { textureGPU: l, glTextureType: u } = this.get(o.texture);
        this.set(o, {
          index: a++,
          textureGPU: l,
          glTextureType: u
        });
      }
  }
  updateBinding(e) {
    const i = this.gl;
    if (e.isUniformsGroup || e.isUniformBuffer) {
      const n = this.get(e).bufferGPU, s = e.buffer;
      i.bindBuffer(i.UNIFORM_BUFFER, n), i.bufferData(i.UNIFORM_BUFFER, s, i.DYNAMIC_DRAW);
    }
  }
  // attributes
  createIndexAttribute(e) {
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ELEMENT_ARRAY_BUFFER);
  }
  createAttribute(e) {
    if (this.has(e)) return;
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ARRAY_BUFFER);
  }
  createStorageAttribute(e) {
    if (this.has(e)) return;
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ARRAY_BUFFER);
  }
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  updateSize() {
  }
  hasFeature(e) {
    const i = Object.keys(uA).filter((s) => uA[s] === e), n = this.extensions;
    for (let s = 0; s < i.length; s++)
      if (n.has(i[s])) return !0;
    return !1;
  }
  getMaxAnisotropy() {
    return this.capabilities.getMaxAnisotropy();
  }
  copyTextureToTexture(e, i, n, s, a) {
    this.textureUtils.copyTextureToTexture(e, i, n, s, a);
  }
  copyFramebufferToTexture(e, i, n) {
    this.textureUtils.copyFramebufferToTexture(e, i, n);
  }
  _setFramebuffer(e) {
    const { gl: i, state: n } = this;
    let s = null;
    if (e.textures !== null) {
      const a = e.renderTarget, o = this.get(a), { samples: l, depthBuffer: u, stencilBuffer: c } = a, h = a.isWebGLCubeRenderTarget === !0;
      let d = o.msaaFrameBuffer, p = o.depthRenderbuffer;
      const f = BI(e);
      let m;
      if (h ? (o.cubeFramebuffers || (o.cubeFramebuffers = {}), m = o.cubeFramebuffers[f]) : (o.framebuffers || (o.framebuffers = {}), m = o.framebuffers[f]), m === void 0) {
        m = i.createFramebuffer(), n.bindFramebuffer(i.FRAMEBUFFER, m);
        const v = e.textures;
        if (h) {
          o.cubeFramebuffers[f] = m;
          const { textureGPU: y } = this.get(v[0]), g = this.renderer._activeCubeFace;
          i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + g, y, 0);
        } else {
          o.framebuffers[f] = m;
          for (let y = 0; y < v.length; y++) {
            const g = v[y], _ = this.get(g);
            _.renderTarget = e.renderTarget, _.cacheKey = f;
            const x = i.COLOR_ATTACHMENT0 + y;
            i.framebufferTexture2D(i.FRAMEBUFFER, x, i.TEXTURE_2D, _.textureGPU, 0);
          }
          n.drawBuffers(e, m);
        }
        if (e.depthTexture !== null) {
          const y = this.get(e.depthTexture), g = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
          y.renderTarget = e.renderTarget, y.cacheKey = f, i.framebufferTexture2D(i.FRAMEBUFFER, g, i.TEXTURE_2D, y.textureGPU, 0);
        }
      }
      if (l > 0) {
        if (d === void 0) {
          const v = [];
          d = i.createFramebuffer(), n.bindFramebuffer(i.FRAMEBUFFER, d);
          const y = [], g = e.textures;
          for (let _ = 0; _ < g.length; _++) {
            if (y[_] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, y[_]), v.push(i.COLOR_ATTACHMENT0 + _), u) {
              const T = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
              v.push(T);
            }
            const x = e.textures[_], b = this.get(x);
            i.renderbufferStorageMultisample(i.RENDERBUFFER, l, b.glInternalFormat, e.width, e.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + _, i.RENDERBUFFER, y[_]);
          }
          if (o.msaaFrameBuffer = d, o.msaaRenderbuffers = y, p === void 0) {
            p = i.createRenderbuffer(), this.textureUtils.setupRenderBufferStorage(p, e), o.depthRenderbuffer = p;
            const _ = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
            v.push(_);
          }
          o.invalidationArray = v;
        }
        s = o.msaaFrameBuffer;
      } else
        s = m;
    }
    n.bindFramebuffer(i.FRAMEBUFFER, s);
  }
  _getVaoKey(e, i) {
    let n = [];
    if (e !== null) {
      const s = this.get(e);
      n += ":" + s.id;
    }
    for (let s = 0; s < i.length; s++) {
      const a = this.get(i[s]);
      n += ":" + a.id;
    }
    return n;
  }
  _createVao(e, i) {
    const { gl: n } = this, s = n.createVertexArray();
    let a = "", o = !0;
    if (n.bindVertexArray(s), e !== null) {
      const l = this.get(e);
      n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, l.bufferGPU), a += ":" + l.id;
    }
    for (let l = 0; l < i.length; l++) {
      const u = i[l], c = this.get(u);
      a += ":" + c.id, n.bindBuffer(n.ARRAY_BUFFER, c.bufferGPU), n.enableVertexAttribArray(l), (u.isStorageBufferAttribute || u.isStorageInstancedBufferAttribute) && (o = !1);
      let h, d;
      u.isInterleavedBufferAttribute === !0 ? (h = u.data.stride * c.bytesPerElement, d = u.offset * c.bytesPerElement) : (h = 0, d = 0), c.isInteger ? n.vertexAttribIPointer(l, u.itemSize, c.type, h, d) : n.vertexAttribPointer(l, u.itemSize, c.type, u.normalized, h, d), u.isInstancedBufferAttribute && !u.isInterleavedBufferAttribute ? n.vertexAttribDivisor(l, u.meshPerAttribute) : u.isInterleavedBufferAttribute && u.data.isInstancedInterleavedBuffer && n.vertexAttribDivisor(l, u.data.meshPerAttribute);
    }
    return n.bindBuffer(n.ARRAY_BUFFER, null), this.vaoCache[a] = s, { vaoGPU: s, staticVao: o };
  }
  _getTransformFeedback(e) {
    let i = "";
    for (let a = 0; a < e.length; a++)
      i += ":" + e[a].id;
    let n = this.transformFeedbackCache[i];
    if (n !== void 0)
      return n;
    const { gl: s } = this;
    n = s.createTransformFeedback(), s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, n);
    for (let a = 0; a < e.length; a++) {
      const o = e[a];
      s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER, a, o.transformBuffer);
    }
    return s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, null), this.transformFeedbackCache[i] = n, n;
  }
  _setupBindings(e, i) {
    const n = this.gl;
    for (const s of e)
      for (const a of s.bindings) {
        const o = this.get(a).index;
        if (a.isUniformsGroup || a.isUniformBuffer) {
          const l = n.getUniformBlockIndex(i, a.name);
          n.uniformBlockBinding(i, l, o);
        } else if (a.isSampledTexture) {
          const l = n.getUniformLocation(i, a.name);
          n.uniform1i(l, o);
        }
      }
  }
  _bindUniforms(e) {
    const { gl: i, state: n } = this;
    for (const s of e)
      for (const a of s.bindings) {
        const o = this.get(a), l = o.index;
        a.isUniformsGroup || a.isUniformBuffer ? n.bindBufferBase(i.UNIFORM_BUFFER, l, o.bufferGPU) : a.isSampledTexture && n.bindTexture(o.glTextureType, o.textureGPU, i.TEXTURE0 + l);
      }
  }
  dispose() {
    this.renderer.domElement.removeEventListener("webglcontextlost", this._onContextLost);
  }
}
class XQ extends HT {
  constructor(e, i) {
    super(e), this.texture = i, this.version = i ? i.version : 0, this.isSampler = !0;
  }
}
class $Q extends XQ {
  constructor(e, i, n) {
    super(e, i ? i.value : null), this.textureNode = i, this.groupNode = n;
  }
  update() {
    this.texture = this.textureNode.value;
  }
}
class YQ extends ZI {
  constructor(e, i) {
    super(e, i ? i.array : null), this.attribute = i, this.isStorageBuffer = !0;
  }
}
let KQ = 0;
class ZQ extends YQ {
  constructor(e, i) {
    super("StorageBuffer_" + KQ++, e ? e.value : null), this.nodeUniform = e, this.access = e ? e.access : Nx.Storage, this.groupNode = i;
  }
  get buffer() {
    return this.nodeUniform.value;
  }
}
class QQ extends So {
  constructor(e) {
    super(), this.device = e;
    const i = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`, n = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`, s = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
    this.mipmapSampler = e.createSampler({ minFilter: Zo.Linear }), this.flipYSampler = e.createSampler({ minFilter: Zo.Nearest }), this.transferPipelines = {}, this.flipYPipelines = {}, this.mipmapVertexShaderModule = e.createShaderModule({
      label: "mipmapVertex",
      code: i
    }), this.mipmapFragmentShaderModule = e.createShaderModule({
      label: "mipmapFragment",
      code: n
    }), this.flipYFragmentShaderModule = e.createShaderModule({
      label: "flipYFragment",
      code: s
    });
  }
  getTransferPipeline(e) {
    let i = this.transferPipelines[e];
    return i === void 0 && (i = this.device.createRenderPipeline({
      label: `mipmap-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.mipmapFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: zu.TriangleStrip,
        stripIndexFormat: Mc.Uint32
      },
      layout: "auto"
    }), this.transferPipelines[e] = i), i;
  }
  getFlipYPipeline(e) {
    let i = this.flipYPipelines[e];
    return i === void 0 && (i = this.device.createRenderPipeline({
      label: `flipY-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.flipYFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: zu.TriangleStrip,
        stripIndexFormat: Mc.Uint32
      },
      layout: "auto"
    }), this.flipYPipelines[e] = i), i;
  }
  flipY(e, i, n = 0) {
    const s = i.format, { width: a, height: o } = i.size, l = this.getTransferPipeline(s), u = this.getFlipYPipeline(s), c = this.device.createTexture({
      size: { width: a, height: o, depthOrArrayLayers: 1 },
      format: s,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    }), h = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: yn.TwoD,
      baseArrayLayer: n
    }), d = c.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: yn.TwoD,
      baseArrayLayer: 0
    }), p = this.device.createCommandEncoder({}), f = (m, v, y) => {
      const g = m.getBindGroupLayout(0), _ = this.device.createBindGroup({
        layout: g,
        entries: [{
          binding: 0,
          resource: this.flipYSampler
        }, {
          binding: 1,
          resource: v
        }]
      }), x = p.beginRenderPass({
        colorAttachments: [{
          view: y,
          loadOp: Oi.Clear,
          storeOp: Ji.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      x.setPipeline(m), x.setBindGroup(0, _), x.draw(4, 1, 0, 0), x.end();
    };
    f(l, h, d), f(u, d, h), this.device.queue.submit([p.finish()]), c.destroy();
  }
  generateMipmaps(e, i, n = 0) {
    const s = this.get(e);
    s.useCount === void 0 && (s.useCount = 0, s.layers = []);
    const a = s.layers[n] || this._mipmapCreateBundles(e, i, n), o = this.device.createCommandEncoder({});
    this._mipmapRunBundles(o, a), this.device.queue.submit([o.finish()]), s.useCount !== 0 && (s.layers[n] = a), s.useCount++;
  }
  _mipmapCreateBundles(e, i, n) {
    const s = this.getTransferPipeline(i.format), a = s.getBindGroupLayout(0);
    let o = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: yn.TwoD,
      baseArrayLayer: n
    });
    const l = [];
    for (let u = 1; u < i.mipLevelCount; u++) {
      const c = this.device.createBindGroup({
        layout: a,
        entries: [{
          binding: 0,
          resource: this.mipmapSampler
        }, {
          binding: 1,
          resource: o
        }]
      }), h = e.createView({
        baseMipLevel: u,
        mipLevelCount: 1,
        dimension: yn.TwoD,
        baseArrayLayer: n
      }), d = {
        colorAttachments: [{
          view: h,
          loadOp: Oi.Clear,
          storeOp: Ji.Store,
          clearValue: [0, 0, 0, 0]
        }]
      }, p = this.device.createRenderBundleEncoder({
        colorFormats: [i.format]
      });
      p.setPipeline(s), p.setBindGroup(0, c), p.draw(4, 1, 0, 0), l.push({
        renderBundles: [p.finish()],
        passDescriptor: d
      }), o = h;
    }
    return l;
  }
  _mipmapRunBundles(e, i) {
    const n = i.length;
    for (let s = 0; s < n; s++) {
      const a = i[s], o = e.beginRenderPass(a.passDescriptor);
      o.executeBundles(a.renderBundles), o.end();
    }
  }
}
const JQ = {
  [ZN]: "never",
  [oT]: "less",
  [QN]: "equal",
  [JN]: "less-equal",
  [eP]: "greater",
  [iP]: "greater-equal",
  [rP]: "always",
  [tP]: "not-equal"
}, eJ = [0, 1, 3, 2, 4, 5];
class tJ {
  constructor(e) {
    this.backend = e, this._passUtils = null, this.defaultTexture = {}, this.defaultCubeTexture = {}, this.defaultVideoFrame = null, this.colorBuffer = null, this.depthTexture = new jc(), this.depthTexture.name = "depthBuffer";
  }
  createSampler(e) {
    const i = this.backend, n = i.device, s = i.get(e), a = {
      addressModeU: this._convertAddressMode(e.wrapS),
      addressModeV: this._convertAddressMode(e.wrapT),
      addressModeW: this._convertAddressMode(e.wrapR),
      magFilter: this._convertFilterMode(e.magFilter),
      minFilter: this._convertFilterMode(e.minFilter),
      mipmapFilter: this._convertFilterMode(e.minFilter),
      maxAnisotropy: 1
    };
    a.magFilter === Zo.Linear && a.minFilter === Zo.Linear && a.mipmapFilter === Zo.Linear && (a.maxAnisotropy = e.anisotropy), e.isDepthTexture && e.compareFunction !== null && (a.compare = JQ[e.compareFunction]), s.sampler = n.createSampler(a);
  }
  createDefaultTexture(e) {
    let i;
    const n = Ox(e);
    e.isCubeTexture ? i = this._getDefaultCubeTextureGPU(n) : e.isVideoTexture ? this.backend.get(e).externalTexture = this._getDefaultVideoFrame() : i = this._getDefaultTextureGPU(n), this.backend.get(e).texture = i;
  }
  createTexture(e, i = {}) {
    const n = this.backend, s = n.get(e);
    if (s.initialized)
      throw new Error("WebGPUTextureUtils: Texture already initialized.");
    i.needsMipmaps === void 0 && (i.needsMipmaps = !1), i.levels === void 0 && (i.levels = 1), i.depth === void 0 && (i.depth = 1);
    const { width: a, height: o, depth: l, levels: u } = i;
    e.isFramebufferTexture && (i.renderTarget ? i.format = this.backend.utils.getCurrentColorFormat(i.renderTarget) : i.format = this.backend.utils.getPreferredCanvasFormat());
    const c = this._getDimension(e), h = e.internalFormat || i.format || Ox(e, n.device);
    s.format = h;
    let d = i.sampleCount !== void 0 ? i.sampleCount : 1;
    d = n.utils.getSampleCount(d);
    const p = e.isRenderTargetTexture && !e.isMultisampleRenderTargetTexture ? 1 : d;
    let f = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
    e.isStorageTexture === !0 && (f |= GPUTextureUsage.STORAGE_BINDING), e.isCompressedTexture !== !0 && e.isCompressedArrayTexture !== !0 && (f |= GPUTextureUsage.RENDER_ATTACHMENT);
    const m = {
      label: e.name,
      size: {
        width: a,
        height: o,
        depthOrArrayLayers: l
      },
      mipLevelCount: u,
      sampleCount: p,
      dimension: c,
      format: h,
      usage: f
    };
    if (e.isVideoTexture) {
      const v = e.source.data, y = new VideoFrame(v);
      m.size.width = y.displayWidth, m.size.height = y.displayHeight, y.close(), s.externalTexture = v;
    } else {
      if (h === void 0)
        return console.warn("WebGPURenderer: Texture format not supported."), this.createDefaultTexture(e);
      s.texture = n.device.createTexture(m);
    }
    if (e.isRenderTargetTexture && d > 1 && !e.isMultisampleRenderTargetTexture) {
      const v = Object.assign({}, m);
      v.label = v.label + "-msaa", v.sampleCount = d, s.msaaTexture = n.device.createTexture(v);
    }
    s.initialized = !0, s.textureDescriptorGPU = m;
  }
  destroyTexture(e) {
    const i = this.backend, n = i.get(e);
    n.texture.destroy(), n.msaaTexture !== void 0 && n.msaaTexture.destroy(), i.delete(e);
  }
  destroySampler(e) {
    const i = this.backend.get(e);
    delete i.sampler;
  }
  generateMipmaps(e) {
    const i = this.backend.get(e);
    if (e.isCubeTexture)
      for (let n = 0; n < 6; n++)
        this._generateMipmaps(i.texture, i.textureDescriptorGPU, n);
    else {
      const n = e.image.depth || 1;
      for (let s = 0; s < n; s++)
        this._generateMipmaps(i.texture, i.textureDescriptorGPU, s);
    }
  }
  getColorBuffer() {
    this.colorBuffer && this.colorBuffer.destroy();
    const e = this.backend, { width: i, height: n } = e.getDrawingBufferSize();
    return this.colorBuffer = e.device.createTexture({
      label: "colorBuffer",
      size: {
        width: i,
        height: n,
        depthOrArrayLayers: 1
      },
      sampleCount: e.utils.getSampleCount(e.renderer.samples),
      format: e.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
    }), this.colorBuffer;
  }
  getDepthBuffer(e = !0, i = !1) {
    const n = this.backend, { width: s, height: a } = n.getDrawingBufferSize(), o = this.depthTexture, l = n.get(o).texture;
    let u, c;
    if (i ? (u = Tc, c = $d) : e && (u = gl, c = er), l !== void 0) {
      if (o.image.width === s && o.image.height === a && o.format === u && o.type === c)
        return l;
      this.destroyTexture(o);
    }
    return o.name = "depthBuffer", o.format = u, o.type = c, o.image.width = s, o.image.height = a, this.createTexture(o, { sampleCount: n.utils.getSampleCount(n.renderer.samples), width: s, height: a }), n.get(o).texture;
  }
  updateTexture(e, i) {
    const n = this.backend.get(e), { textureDescriptorGPU: s } = n;
    if (!(e.isRenderTargetTexture || s === void 0)) {
      if (e.isDataTexture)
        this._copyBufferToTexture(i.image, n.texture, s, 0, e.flipY);
      else if (e.isDataArrayTexture || e.isData3DTexture)
        for (let a = 0; a < i.image.depth; a++)
          this._copyBufferToTexture(i.image, n.texture, s, a, e.flipY, a);
      else if (e.isCompressedTexture || e.isCompressedArrayTexture)
        this._copyCompressedBufferToTexture(e.mipmaps, n.texture, s);
      else if (e.isCubeTexture)
        this._copyCubeMapToTexture(i.images, n.texture, s, e.flipY);
      else if (e.isVideoTexture) {
        const a = e.source.data;
        n.externalTexture = a;
      } else
        this._copyImageToTexture(i.image, n.texture, s, 0, e.flipY);
      n.version = e.version, e.onUpdate && e.onUpdate(e);
    }
  }
  async copyTextureToBuffer(e, i, n, s, a, o) {
    const l = this.backend.device, u = this.backend.get(e), c = u.texture, h = u.textureDescriptorGPU.format, d = this._getBytesPerTexel(h);
    let p = s * d;
    p = Math.ceil(p / 256) * 256;
    const f = l.createBuffer(
      {
        size: s * a * d,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }
    ), m = l.createCommandEncoder();
    m.copyTextureToBuffer(
      {
        texture: c,
        origin: { x: i, y: n, z: o }
      },
      {
        buffer: f,
        bytesPerRow: p
      },
      {
        width: s,
        height: a
      }
    );
    const v = this._getTypedArrayType(h);
    l.queue.submit([m.finish()]), await f.mapAsync(GPUMapMode.READ);
    const y = f.getMappedRange();
    return new v(y);
  }
  _isEnvironmentTexture(e) {
    const i = e.mapping;
    return i === qd || i === Xd || i === Tl || i === _c;
  }
  _getDefaultTextureGPU(e) {
    let i = this.defaultTexture[e];
    if (i === void 0) {
      const n = new Cr();
      n.minFilter = gr, n.magFilter = gr, this.createTexture(n, { width: 1, height: 1, format: e }), this.defaultTexture[e] = i = n;
    }
    return this.backend.get(i).texture;
  }
  _getDefaultCubeTextureGPU(e) {
    let i = this.defaultTexture[e];
    if (i === void 0) {
      const n = new cT();
      n.minFilter = gr, n.magFilter = gr, this.createTexture(n, { width: 1, height: 1, depth: 6 }), this.defaultCubeTexture[e] = i = n;
    }
    return this.backend.get(i).texture;
  }
  _getDefaultVideoFrame() {
    let e = this.defaultVideoFrame;
    if (e === null) {
      const i = {
        timestamp: 0,
        codedWidth: 1,
        codedHeight: 1,
        format: "RGBA"
      };
      this.defaultVideoFrame = e = new VideoFrame(new Uint8Array([0, 0, 0, 255]), i);
    }
    return e;
  }
  _copyCubeMapToTexture(e, i, n, s) {
    for (let a = 0; a < 6; a++) {
      const o = e[a], l = s === !0 ? eJ[a] : a;
      o.isDataTexture ? this._copyBufferToTexture(o.image, i, n, l, s) : this._copyImageToTexture(o, i, n, l, s);
    }
  }
  _copyImageToTexture(e, i, n, s, a) {
    this.backend.device.queue.copyExternalImageToTexture(
      {
        source: e
      },
      {
        texture: i,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: s }
      },
      {
        width: e.width,
        height: e.height,
        depthOrArrayLayers: 1
      }
    ), a === !0 && this._flipY(i, n, s);
  }
  _getPassUtils() {
    let e = this._passUtils;
    return e === null && (this._passUtils = e = new QQ(this.backend.device)), e;
  }
  _generateMipmaps(e, i, n = 0) {
    this._getPassUtils().generateMipmaps(e, i, n);
  }
  _flipY(e, i, n = 0) {
    this._getPassUtils().flipY(e, i, n);
  }
  _copyBufferToTexture(e, i, n, s, a, o = 0) {
    const l = this.backend.device, u = e.data, c = this._getBytesPerTexel(n.format), h = e.width * c;
    l.queue.writeTexture(
      {
        texture: i,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: s }
      },
      u,
      {
        offset: e.width * e.height * c * o,
        bytesPerRow: h
      },
      {
        width: e.width,
        height: e.height,
        depthOrArrayLayers: 1
      }
    ), a === !0 && this._flipY(i, n, s);
  }
  _copyCompressedBufferToTexture(e, i, n) {
    const s = this.backend.device, a = this._getBlockData(n.format), o = n.size.depthOrArrayLayers > 1;
    for (let l = 0; l < e.length; l++) {
      const u = e[l], c = u.width, h = u.height, d = o ? n.size.depthOrArrayLayers : 1, p = Math.ceil(c / a.width) * a.byteLength, f = p * Math.ceil(h / a.height);
      for (let m = 0; m < d; m++)
        s.queue.writeTexture(
          {
            texture: i,
            mipLevel: l,
            origin: { x: 0, y: 0, z: m }
          },
          u.data,
          {
            offset: m * f,
            bytesPerRow: p,
            rowsPerImage: Math.ceil(h / a.height)
          },
          {
            width: Math.ceil(c / a.width) * a.width,
            height: Math.ceil(h / a.height) * a.height,
            depthOrArrayLayers: 1
          }
        );
    }
  }
  _getBlockData(e) {
    if (e === $.BC1RGBAUnorm || e === $.BC1RGBAUnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.BC2RGBAUnorm || e === $.BC2RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC3RGBAUnorm || e === $.BC3RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC4RUnorm || e === $.BC4RSNorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.BC5RGUnorm || e === $.BC5RGSnorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC6HRGBUFloat || e === $.BC6HRGBFloat) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC7RGBAUnorm || e === $.BC7RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.ETC2RGB8Unorm || e === $.ETC2RGB8UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.ETC2RGB8A1Unorm || e === $.ETC2RGB8A1UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.ETC2RGBA8Unorm || e === $.ETC2RGBA8UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.EACR11Unorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.EACR11Snorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.EACRG11Unorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.EACRG11Snorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.ASTC4x4Unorm || e === $.ASTC4x4UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.ASTC5x4Unorm || e === $.ASTC5x4UnormSRGB) return { byteLength: 16, width: 5, height: 4 };
    if (e === $.ASTC5x5Unorm || e === $.ASTC5x5UnormSRGB) return { byteLength: 16, width: 5, height: 5 };
    if (e === $.ASTC6x5Unorm || e === $.ASTC6x5UnormSRGB) return { byteLength: 16, width: 6, height: 5 };
    if (e === $.ASTC6x6Unorm || e === $.ASTC6x6UnormSRGB) return { byteLength: 16, width: 6, height: 6 };
    if (e === $.ASTC8x5Unorm || e === $.ASTC8x5UnormSRGB) return { byteLength: 16, width: 8, height: 5 };
    if (e === $.ASTC8x6Unorm || e === $.ASTC8x6UnormSRGB) return { byteLength: 16, width: 8, height: 6 };
    if (e === $.ASTC8x8Unorm || e === $.ASTC8x8UnormSRGB) return { byteLength: 16, width: 8, height: 8 };
    if (e === $.ASTC10x5Unorm || e === $.ASTC10x5UnormSRGB) return { byteLength: 16, width: 10, height: 5 };
    if (e === $.ASTC10x6Unorm || e === $.ASTC10x6UnormSRGB) return { byteLength: 16, width: 10, height: 6 };
    if (e === $.ASTC10x8Unorm || e === $.ASTC10x8UnormSRGB) return { byteLength: 16, width: 10, height: 8 };
    if (e === $.ASTC10x10Unorm || e === $.ASTC10x10UnormSRGB) return { byteLength: 16, width: 10, height: 10 };
    if (e === $.ASTC12x10Unorm || e === $.ASTC12x10UnormSRGB) return { byteLength: 16, width: 12, height: 10 };
    if (e === $.ASTC12x12Unorm || e === $.ASTC12x12UnormSRGB) return { byteLength: 16, width: 12, height: 12 };
  }
  _convertAddressMode(e) {
    let i = t0.ClampToEdge;
    return e === Dm ? i = t0.Repeat : e === Lm && (i = t0.MirrorRepeat), i;
  }
  _convertFilterMode(e) {
    let i = Zo.Linear;
    return (e === gr || e === Zb || e === Ku) && (i = Zo.Nearest), i;
  }
  _getBytesPerTexel(e) {
    if (e === $.R8Unorm || e === $.R8Snorm || e === $.R8Uint || e === $.R8Sint) return 1;
    if (e === $.R16Uint || e === $.R16Sint || e === $.R16Float || e === $.RG8Unorm || e === $.RG8Snorm || e === $.RG8Uint || e === $.RG8Sint) return 2;
    if (e === $.R32Uint || e === $.R32Sint || e === $.R32Float || e === $.RG16Uint || e === $.RG16Sint || e === $.RG16Float || e === $.RGBA8Unorm || e === $.RGBA8UnormSRGB || e === $.RGBA8Snorm || e === $.RGBA8Uint || e === $.RGBA8Sint || e === $.BGRA8Unorm || e === $.BGRA8UnormSRGB || // Packed 32-bit formats
    e === $.RGB9E5UFloat || e === $.RGB10A2Unorm || e === $.RG11B10UFloat || e === $.Depth32Float || e === $.Depth24Plus || e === $.Depth24PlusStencil8 || e === $.Depth32FloatStencil8) return 4;
    if (e === $.RG32Uint || e === $.RG32Sint || e === $.RG32Float || e === $.RGBA16Uint || e === $.RGBA16Sint || e === $.RGBA16Float) return 8;
    if (e === $.RGBA32Uint || e === $.RGBA32Sint || e === $.RGBA32Float) return 16;
  }
  _getTypedArrayType(e) {
    if (e === $.R8Uint) return Uint8Array;
    if (e === $.R8Sint) return Int8Array;
    if (e === $.R8Unorm) return Uint8Array;
    if (e === $.R8Snorm) return Int8Array;
    if (e === $.RG8Uint) return Uint8Array;
    if (e === $.RG8Sint) return Int8Array;
    if (e === $.RG8Unorm) return Uint8Array;
    if (e === $.RG8Snorm) return Int8Array;
    if (e === $.RGBA8Uint) return Uint8Array;
    if (e === $.RGBA8Sint) return Int8Array;
    if (e === $.RGBA8Unorm) return Uint8Array;
    if (e === $.RGBA8Snorm) return Int8Array;
    if (e === $.R16Uint) return Uint16Array;
    if (e === $.R16Sint) return Int16Array;
    if (e === $.RG16Uint) return Uint16Array;
    if (e === $.RG16Sint) return Int16Array;
    if (e === $.RGBA16Uint) return Uint16Array;
    if (e === $.RGBA16Sint) return Int16Array;
    if (e === $.R16Float || e === $.RG16Float || e === $.RGBA16Float) return Uint16Array;
    if (e === $.R32Uint) return Uint32Array;
    if (e === $.R32Sint) return Int32Array;
    if (e === $.R32Float) return Float32Array;
    if (e === $.RG32Uint) return Uint32Array;
    if (e === $.RG32Sint) return Int32Array;
    if (e === $.RG32Float) return Float32Array;
    if (e === $.RGBA32Uint) return Uint32Array;
    if (e === $.RGBA32Sint) return Int32Array;
    if (e === $.RGBA32Float) return Float32Array;
    if (e === $.BGRA8Unorm || e === $.BGRA8UnormSRGB) return Uint8Array;
    if (e === $.RGB10A2Unorm || e === $.RGB9E5UFloat || e === $.RG11B10UFloat) return Uint32Array;
    if (e === $.Depth32Float) return Float32Array;
    if (e === $.Depth24Plus || e === $.Depth24PlusStencil8) return Uint32Array;
    if (e === $.Depth32FloatStencil8) return Float32Array;
  }
  _getDimension(e) {
    let i;
    return e.isData3DTexture ? i = HM.ThreeD : i = HM.TwoD, i;
  }
}
function Ox(r, e = null) {
  const i = r.format, n = r.type, s = r.colorSpace;
  let a;
  if (r.isCompressedTexture === !0 || r.isCompressedArrayTexture === !0)
    switch (i) {
      case em:
        a = s === ct ? $.BC1RGBAUnormSRGB : $.BC1RGBAUnorm;
        break;
      case tm:
        a = s === ct ? $.BC2RGBAUnormSRGB : $.BC2RGBAUnorm;
        break;
      case im:
        a = s === ct ? $.BC3RGBAUnormSRGB : $.BC3RGBAUnorm;
        break;
      case Jb:
        a = s === ct ? $.ETC2RGB8UnormSRGB : $.ETC2RGB8Unorm;
        break;
      case ex:
        a = s === ct ? $.ETC2RGBA8UnormSRGB : $.ETC2RGBA8Unorm;
        break;
      case tx:
        a = s === ct ? $.ASTC4x4UnormSRGB : $.ASTC4x4Unorm;
        break;
      case ix:
        a = s === ct ? $.ASTC5x4UnormSRGB : $.ASTC5x4Unorm;
        break;
      case rx:
        a = s === ct ? $.ASTC5x5UnormSRGB : $.ASTC5x5Unorm;
        break;
      case nx:
        a = s === ct ? $.ASTC6x5UnormSRGB : $.ASTC6x5Unorm;
        break;
      case sx:
        a = s === ct ? $.ASTC6x6UnormSRGB : $.ASTC6x6Unorm;
        break;
      case ax:
        a = s === ct ? $.ASTC8x5UnormSRGB : $.ASTC8x5Unorm;
        break;
      case ox:
        a = s === ct ? $.ASTC8x6UnormSRGB : $.ASTC8x6Unorm;
        break;
      case lx:
        a = s === ct ? $.ASTC8x8UnormSRGB : $.ASTC8x8Unorm;
        break;
      case ux:
        a = s === ct ? $.ASTC10x5UnormSRGB : $.ASTC10x5Unorm;
        break;
      case cx:
        a = s === ct ? $.ASTC10x6UnormSRGB : $.ASTC10x6Unorm;
        break;
      case hx:
        a = s === ct ? $.ASTC10x8UnormSRGB : $.ASTC10x8Unorm;
        break;
      case dx:
        a = s === ct ? $.ASTC10x10UnormSRGB : $.ASTC10x10Unorm;
        break;
      case px:
        a = s === ct ? $.ASTC12x10UnormSRGB : $.ASTC12x10Unorm;
        break;
      case fx:
        a = s === ct ? $.ASTC12x12UnormSRGB : $.ASTC12x12Unorm;
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", i);
    }
  else
    switch (i) {
      case Fc:
        switch (n) {
          case Qh:
            a = $.RGBA8Snorm;
            break;
          case Jh:
            a = $.RGBA16Sint;
            break;
          case Uu:
            a = $.RGBA16Uint;
            break;
          case er:
            a = $.RGBA32Uint;
            break;
          case Sr:
            a = $.RGBA32Sint;
            break;
          case ho:
            a = s === ct ? $.RGBA8UnormSRGB : $.RGBA8Unorm;
            break;
          case fa:
            a = $.RGBA16Float;
            break;
          case on:
            a = $.RGBA32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.", n);
        }
        break;
      case iT:
        switch (n) {
          case YN:
            a = $.RGB9E5UFloat;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBFormat.", n);
        }
        break;
      case rT:
        switch (n) {
          case Qh:
            a = $.R8Snorm;
            break;
          case Jh:
            a = $.R16Sint;
            break;
          case Uu:
            a = $.R16Uint;
            break;
          case er:
            a = $.R32Uint;
            break;
          case Sr:
            a = $.R32Sint;
            break;
          case ho:
            a = $.R8Unorm;
            break;
          case fa:
            a = $.R16Float;
            break;
          case on:
            a = $.R32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedFormat.", n);
        }
        break;
      case gd:
        switch (n) {
          case Qh:
            a = $.RG8Snorm;
            break;
          case Jh:
            a = $.RG16Sint;
            break;
          case Uu:
            a = $.RG16Uint;
            break;
          case er:
            a = $.RG32Uint;
            break;
          case Sr:
            a = $.RG32Sint;
            break;
          case ho:
            a = $.RG8Unorm;
            break;
          case fa:
            a = $.RG16Float;
            break;
          case on:
            a = $.RG32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGFormat.", n);
        }
        break;
      case gl:
        switch (n) {
          case Uu:
            a = $.Depth16Unorm;
            break;
          case er:
            a = $.Depth24Plus;
            break;
          case on:
            a = $.Depth32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthFormat.", n);
        }
        break;
      case Tc:
        switch (n) {
          case $d:
            a = $.Depth24PlusStencil8;
            break;
          case on:
            e && e.features.has(Px.Depth32FloatStencil8) === !1 && console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'), a = $.Depth32FloatStencil8;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", n);
        }
        break;
      case nT:
        switch (n) {
          case Sr:
            a = $.R32Sint;
            break;
          case er:
            a = $.R32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.", n);
        }
        break;
      case sT:
        switch (n) {
          case Sr:
            a = $.RG32Sint;
            break;
          case er:
            a = $.RG32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.", n);
        }
        break;
      case aT:
        switch (n) {
          case Sr:
            a = $.RGBA32Sint;
            break;
          case er:
            a = $.RGBA32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.", n);
        }
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", i);
    }
  return a;
}
const iJ = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i, rJ = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig, hA = {
  f32: "float",
  i32: "int",
  u32: "uint",
  bool: "bool",
  "vec2<f32>": "vec2",
  "vec2<i32>": "ivec2",
  "vec2<u32>": "uvec2",
  "vec2<bool>": "bvec2",
  vec2f: "vec2",
  vec2i: "ivec2",
  vec2u: "uvec2",
  vec2b: "bvec2",
  "vec3<f32>": "vec3",
  "vec3<i32>": "ivec3",
  "vec3<u32>": "uvec3",
  "vec3<bool>": "bvec3",
  vec3f: "vec3",
  vec3i: "ivec3",
  vec3u: "uvec3",
  vec3b: "bvec3",
  "vec4<f32>": "vec4",
  "vec4<i32>": "ivec4",
  "vec4<u32>": "uvec4",
  "vec4<bool>": "bvec4",
  vec4f: "vec4",
  vec4i: "ivec4",
  vec4u: "uvec4",
  vec4b: "bvec4",
  "mat2x2<f32>": "mat2",
  mat2x2f: "mat2",
  "mat3x3<f32>": "mat3",
  mat3x3f: "mat3",
  "mat4x4<f32>": "mat4",
  mat4x4f: "mat4",
  sampler: "sampler",
  texture_1d: "texture",
  texture_2d: "texture",
  texture_2d_array: "texture",
  texture_multisampled_2d: "cubeTexture",
  texture_depth_2d: "depthTexture",
  texture_3d: "texture3D",
  texture_cube: "cubeTexture",
  texture_cube_array: "cubeTexture",
  texture_storage_1d: "storageTexture",
  texture_storage_2d: "storageTexture",
  texture_storage_2d_array: "storageTexture",
  texture_storage_3d: "storageTexture"
}, nJ = (r) => {
  r = r.trim();
  const e = r.match(iJ);
  if (e !== null && e.length === 4) {
    const i = e[2], n = [];
    let s = null;
    for (; (s = rJ.exec(i)) !== null; )
      n.push({ name: s[1], type: s[2] });
    const a = [];
    for (let c = 0; c < n.length; c++) {
      const { name: h, type: d } = n[c];
      let p = d;
      p.startsWith("ptr") ? p = "pointer" : (p.startsWith("texture") && (p = d.split("<")[0]), p = hA[p]), a.push(new VT(p, h));
    }
    const o = r.substring(e[0].length), l = e[3] || "void", u = e[1] !== void 0 ? e[1] : "";
    return {
      type: hA[l] || l,
      inputs: a,
      name: u,
      inputsCode: i,
      blockCode: o,
      outputType: l
    };
  } else
    throw new Error("FunctionNode: Function is not a WGSL code.");
};
class sJ extends GT {
  constructor(e) {
    const { type: i, inputs: n, name: s, inputsCode: a, blockCode: o, outputType: l } = nJ(e);
    super(i, n, s), this.inputsCode = a, this.blockCode = o, this.outputType = l;
  }
  getCode(e = this.name) {
    const i = this.outputType !== "void" ? "-> " + this.outputType : "";
    return `fn ${e} ( ${this.inputsCode.trim()} ) ${i}` + this.blockCode;
  }
}
class aJ extends YI {
  parseFunction(e) {
    return new sJ(e);
  }
}
const Su = self.GPUShaderStage, Ef = {
  vertex: Su ? Su.VERTEX : 1,
  fragment: Su ? Su.FRAGMENT : 2,
  compute: Su ? Su.COMPUTE : 4
}, dA = {
  instance: !0,
  swizzleAssign: !1,
  storageBuffer: !0
}, oJ = {
  "^^": "tsl_xor"
}, lJ = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat2: "mat2x2<f32>",
  mat3: "mat3x3<f32>",
  mat4: "mat4x4<f32>"
}, qs = {
  tsl_xor: new fr("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
  mod_float: new fr("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
  mod_vec2: new fr("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
  mod_vec3: new fr("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
  mod_vec4: new fr("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
  equals_bool: new fr("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
  equals_bvec2: new fr("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
  equals_bvec3: new fr("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
  equals_bvec4: new fr("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
  repeatWrapping: new fr(
    /* wgsl */
    `
fn tsl_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {

	let uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );

	return ( ( uvScaled % dimension ) + dimension ) % dimension;

}
`
  ),
  biquadraticTexture: new fr(
    /* wgsl */
    `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, level : i32 ) -> vec4f {

	let iRes = vec2i( textureDimensions( map, level ) );
	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2i( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2i( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2i( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2i( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`
  )
}, Gh = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod_float: "tsl_mod_float",
  mod_vec2: "tsl_mod_vec2",
  mod_vec3: "tsl_mod_vec3",
  mod_vec4: "tsl_mod_vec4",
  equals_bool: "tsl_equals_bool",
  equals_bvec2: "tsl_equals_bvec2",
  equals_bvec3: "tsl_equals_bvec3",
  equals_bvec4: "tsl_equals_bvec4",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>"
};
/Windows/g.test(navigator.userAgent) && (qs.pow_float = new fr("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"), qs.pow_vec2 = new fr("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }", [qs.pow_float]), qs.pow_vec3 = new fr("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }", [qs.pow_float]), qs.pow_vec4 = new fr("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }", [qs.pow_float]), Gh.pow_float = "tsl_pow_float", Gh.pow_vec2 = "tsl_pow_vec2", Gh.pow_vec3 = "tsl_pow_vec3", Gh.pow_vec4 = "tsl_pow_vec4");
let nO = "";
/Firefox|Deno/g.test(navigator.userAgent) !== !0 && (nO += `diagnostic( off, derivative_uniformity );
`);
class uJ extends XI {
  constructor(e, i) {
    super(e, i, new aJ()), this.uniformGroups = {}, this.builtins = {}, this.directives = {}, this.scopedArrays = /* @__PURE__ */ new Map();
  }
  needsToWorkingColorSpace(e) {
    return e.isVideoTexture === !0 && e.colorSpace !== Sl;
  }
  _generateTextureSample(e, i, n, s, a = this.shaderStage) {
    return a === "fragment" ? s ? `textureSample( ${i}, ${i}_sampler, ${n}, ${s} )` : `textureSample( ${i}, ${i}_sampler, ${n} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, i, n) : this.generateTextureLod(e, i, n, "0");
  }
  _generateVideoSample(e, i, n = this.shaderStage) {
    if (n === "fragment")
      return `textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${i}.x, 1.0 - ${i}.y ) )`;
    console.error(`WebGPURenderer: THREE.VideoTexture does not support ${n} shader.`);
  }
  _generateTextureSampleLevel(e, i, n, s, a, o = this.shaderStage) {
    return o === "fragment" && this.isUnfilterable(e) === !1 ? `textureSampleLevel( ${i}, ${i}_sampler, ${n}, ${s} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, i, n, s) : this.generateTextureLod(e, i, n, s);
  }
  generateFilteredTexture(e, i, n, s = "0") {
    return this._include("biquadraticTexture"), `tsl_biquadraticTexture( ${i}, ${n}, i32( ${s} ) )`;
  }
  generateTextureLod(e, i, n, s = "0") {
    this._include("repeatWrapping");
    const a = e.isMultisampleRenderTargetTexture === !0 ? `textureDimensions( ${i} )` : `textureDimensions( ${i}, 0 )`;
    return `textureLoad( ${i}, tsl_repeatWrapping( ${n}, ${a} ), i32( ${s} ) )`;
  }
  generateTextureLoad(e, i, n, s, a = "0u") {
    return s ? `textureLoad( ${i}, ${n}, ${s}, ${a} )` : `textureLoad( ${i}, ${n}, ${a} )`;
  }
  generateTextureStore(e, i, n, s) {
    return `textureStore( ${i}, ${n}, ${s} )`;
  }
  isUnfilterable(e) {
    return this.getComponentTypeFromTexture(e) !== "float" || !this.isAvailable("float32Filterable") && e.isDataTexture === !0 && e.type === on || e.isMultisampleRenderTargetTexture === !0;
  }
  generateTexture(e, i, n, s, a = this.shaderStage) {
    let o = null;
    return e.isVideoTexture === !0 ? o = this._generateVideoSample(i, n, a) : this.isUnfilterable(e) ? o = this.generateTextureLod(e, i, n, "0", s, a) : o = this._generateTextureSample(e, i, n, s, a), o;
  }
  generateTextureGrad(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleGrad( ${i}, ${i}_sampler, ${n},  ${s[0]}, ${s[1]} )`;
    console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${o} shader.`);
  }
  generateTextureCompare(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleCompare( ${i}, ${i}_sampler, ${n}, ${s} )`;
    console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${o} shader.`);
  }
  generateTextureLevel(e, i, n, s, a, o = this.shaderStage) {
    let l = null;
    return e.isVideoTexture === !0 ? l = this._generateVideoSample(i, n, o) : l = this._generateTextureSampleLevel(e, i, n, s, a, o), l;
  }
  generateTextureBias(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleBias( ${i}, ${i}_sampler, ${n}, ${s} )`;
    console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${o} shader.`);
  }
  getPropertyName(e, i = this.shaderStage) {
    if (e.isNodeVarying === !0 && e.needsInterpolation === !0) {
      if (i === "vertex")
        return `varyings.${e.name}`;
    } else if (e.isNodeUniform === !0) {
      const n = e.name, s = e.type;
      return s === "texture" || s === "cubeTexture" || s === "storageTexture" || s === "texture3D" ? n : s === "buffer" || s === "storageBuffer" || s === "indirectStorageBuffer" ? `NodeBuffer_${e.id}.${n}` : e.groupNode.name + "." + n;
    }
    return super.getPropertyName(e);
  }
  getOutputStructName() {
    return "output";
  }
  _getUniformGroupCount(e) {
    return Object.keys(this.uniforms[e]).length;
  }
  getFunctionOperator(e) {
    const i = oJ[e];
    return i !== void 0 ? (this._include(i), i) : null;
  }
  getStorageAccess(e) {
    if (e.isStorageTextureNode)
      switch (e.access) {
        case GM.ReadOnly:
          return "read";
        case GM.WriteOnly:
          return "write";
        default:
          return "read_write";
      }
    else
      switch (e.access) {
        case Nx.Storage:
          return "read_write";
        case Nx.ReadOnlyStorage:
          return "read";
        default:
          return "write";
      }
  }
  getUniformFromNode(e, i, n, s = null) {
    const a = super.getUniformFromNode(e, i, n, s), o = this.getDataFromNode(e, n, this.globalCache);
    if (o.uniformGPU === void 0) {
      let l;
      const u = e.groupNode, c = u.name, h = this.getBindGroupArray(c, n);
      if (i === "texture" || i === "cubeTexture" || i === "storageTexture" || i === "texture3D") {
        let d = null;
        if (i === "texture" || i === "storageTexture" ? d = new Vg(a.name, a.node, u, e.access ? e.access : null) : i === "cubeTexture" ? d = new tO(a.name, a.node, u, e.access ? e.access : null) : i === "texture3D" && (d = new iO(a.name, a.node, u, e.access ? e.access : null)), d.store = e.isStorageTextureNode === !0, d.setVisibility(Ef[n]), n === "fragment" && this.isUnfilterable(e.value) === !1 && d.store === !1) {
          const p = new $Q(`${a.name}_sampler`, a.node, u);
          p.setVisibility(Ef[n]), h.push(p, d), l = [p, d];
        } else
          h.push(d), l = [d];
      } else if (i === "buffer" || i === "storageBuffer" || i === "indirectStorageBuffer") {
        const d = i === "buffer" ? JI : ZQ, p = new d(e, u);
        p.setVisibility(Ef[n]), h.push(p), l = p;
      } else {
        const d = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let p = d[c];
        p === void 0 && (p = new eO(c, u), p.setVisibility(Ef[n]), d[c] = p, h.push(p)), l = this.getNodeUniform(a, i), p.addUniform(l);
      }
      o.uniformGPU = l;
    }
    return a;
  }
  getBuiltin(e, i, n, s = this.shaderStage) {
    const a = this.builtins[s] || (this.builtins[s] = /* @__PURE__ */ new Map());
    return a.has(e) === !1 && a.set(e, {
      name: e,
      property: i,
      type: n
    }), i;
  }
  hasBuiltin(e, i = this.shaderStage) {
    return this.builtins[i] !== void 0 && this.builtins[i].has(e);
  }
  getVertexIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute") : "vertexIndex";
  }
  buildFunctionCode(e) {
    const i = e.layout, n = this.flowShaderNode(e), s = [];
    for (const o of i.inputs)
      s.push(o.name + " : " + this.getType(o.type));
    let a = `fn ${i.name}( ${s.join(", ")} ) -> ${this.getType(i.type)} {
${n.vars}
${n.code}
`;
    return n.result && (a += `	return ${n.result};
`), a += `
}
`, a;
  }
  getInstanceIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute") : "instanceIndex";
  }
  getInvocationLocalIndex() {
    return this.getBuiltin("local_invocation_index", "invocationLocalIndex", "u32", "attribute");
  }
  getSubgroupSize() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
  }
  getInvocationSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_invocation_id", "invocationSubgroupIndex", "u32", "attribute");
  }
  getSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute");
  }
  getDrawIndex() {
    return null;
  }
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
  }
  getFragDepth() {
    return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
  }
  isFlipY() {
    return !1;
  }
  enableDirective(e, i = this.shaderStage) {
    (this.directives[i] || (this.directives[i] = /* @__PURE__ */ new Set())).add(e);
  }
  getDirectives(e) {
    const i = [], n = this.directives[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`enable ${s};`);
    return i.join(`
`);
  }
  enableSubGroups() {
    this.enableDirective("subgroups");
  }
  enableSubgroupsF16() {
    this.enableDirective("subgroups-f16");
  }
  enableClipDistances() {
    this.enableDirective("clip_distances");
  }
  enableShaderF16() {
    this.enableDirective("f16");
  }
  enableDualSourceBlending() {
    this.enableDirective("dual_source_blending");
  }
  getBuiltins(e) {
    const i = [], n = this.builtins[e];
    if (n !== void 0)
      for (const { name: s, property: a, type: o } of n.values())
        i.push(`@builtin( ${s} ) ${a} : ${o}`);
    return i.join(`,
	`);
  }
  getScopedArray(e, i, n, s) {
    return this.scopedArrays.has(e) === !1 && this.scopedArrays.set(e, {
      name: e,
      scope: i,
      bufferType: n,
      bufferCount: s
    }), e;
  }
  getScopedArrays(e) {
    if (e !== "compute")
      return;
    const i = [];
    for (const { name: n, scope: s, bufferType: a, bufferCount: o } of this.scopedArrays.values()) {
      const l = this.getType(a);
      i.push(`var<${s}> ${n}: array< ${l}, ${o} >;`);
    }
    return i.join(`
`);
  }
  getAttributes(e) {
    const i = [];
    if (e === "compute" && (this.getBuiltin("global_invocation_id", "id", "vec3<u32>", "attribute"), this.getBuiltin("workgroup_id", "workgroupId", "vec3<u32>", "attribute"), this.getBuiltin("local_invocation_id", "localId", "vec3<u32>", "attribute"), this.getBuiltin("num_workgroups", "numWorkgroups", "vec3<u32>", "attribute"), this.renderer.hasFeature("subgroups") && (this.enableDirective("subgroups", e), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute"))), e === "vertex" || e === "compute") {
      const n = this.getBuiltins("attribute");
      n && i.push(n);
      const s = this.getAttributesArray();
      for (let a = 0, o = s.length; a < o; a++) {
        const l = s[a], u = l.name, c = this.getType(l.type);
        i.push(`@location( ${a} ) ${u} : ${c}`);
      }
    }
    return i.join(`,
	`);
  }
  getStructMembers(e) {
    const i = [], n = e.getMemberTypes();
    for (let a = 0; a < n.length; a++) {
      const o = n[a];
      i.push(`	@location( ${a} ) m${a} : ${o}<f32>`);
    }
    const s = this.getBuiltins("output");
    return s && i.push("	" + s), i.join(`,
`);
  }
  getStructs(e) {
    const i = [], n = this.structs[e];
    for (let s = 0, a = n.length; s < a; s++) {
      const o = n[s], l = o.name;
      let u = `struct ${l} {
`;
      u += this.getStructMembers(o), u += `
}`, i.push(u), i.push(`
var<private> output : ${l};

`);
    }
    return i.join(`

`);
  }
  getVar(e, i) {
    return `var ${i} : ${this.getType(e)}`;
  }
  getVars(e) {
    const i = [], n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`	${this.getVar(s.type, s.name)};`);
    return `
${i.join(`
`)}
`;
  }
  getVaryings(e) {
    const i = [];
    if (e === "vertex" && this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex"), e === "vertex" || e === "fragment") {
      const a = this.varyings, o = this.vars[e];
      for (let l = 0; l < a.length; l++) {
        const u = a[l];
        if (u.needsInterpolation) {
          let c = `@location( ${l} )`;
          /^(int|uint|ivec|uvec)/.test(u.type) && (c += " @interpolate( flat )"), i.push(`${c} ${u.name} : ${this.getType(u.type)}`);
        } else e === "vertex" && o.includes(u) === !1 && o.push(u);
      }
    }
    const n = this.getBuiltins(e);
    n && i.push(n);
    const s = i.join(`,
	`);
    return e === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + s) : s;
  }
  getUniforms(e) {
    const i = this.uniforms[e], n = [], s = [], a = [], o = {};
    for (const u of i) {
      const c = u.groupNode.name, h = this.bindingsIndexes[c];
      if (u.type === "texture" || u.type === "cubeTexture" || u.type === "storageTexture" || u.type === "texture3D") {
        const d = u.node.value;
        e === "fragment" && this.isUnfilterable(d) === !1 && u.node.isStorageTextureNode !== !0 && (d.isDepthTexture === !0 && d.compareFunction !== null ? n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name}_sampler : sampler_comparison;`) : n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name}_sampler : sampler;`));
        let p, f = "";
        if (d.isMultisampleRenderTargetTexture === !0 && (f = "_multisampled"), d.isCubeTexture === !0)
          p = "texture_cube<f32>";
        else if (d.isDataArrayTexture === !0 || d.isCompressedArrayTexture === !0)
          p = "texture_2d_array<f32>";
        else if (d.isDepthTexture === !0)
          p = `texture_depth${f}_2d`;
        else if (d.isVideoTexture === !0)
          p = "texture_external";
        else if (d.isData3DTexture === !0)
          p = "texture_3d<f32>";
        else if (u.node.isStorageTextureNode === !0) {
          const m = Ox(d), v = this.getStorageAccess(u.node);
          p = `texture_storage_2d<${m}, ${v}>`;
        } else {
          const m = this.getComponentTypeFromTexture(d).charAt(0);
          p = `texture${f}_2d<${m}32>`;
        }
        n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name} : ${p};`);
      } else if (u.type === "buffer" || u.type === "storageBuffer" || u.type === "indirectStorageBuffer") {
        const d = u.node, p = this.getType(d.bufferType), f = d.bufferCount, m = f > 0 && u.type === "buffer" ? ", " + f : "", v = d.isAtomic ? `atomic<${p}>` : `${p}`, y = `	${u.name} : array< ${v}${m} >
`, g = d.isStorageBufferNode ? `storage, ${this.getStorageAccess(d)}` : "uniform";
        s.push(this._getWGSLStructBinding("NodeBuffer_" + d.id, y, g, h.binding++, h.group));
      } else {
        const d = this.getType(this.getVectorType(u.type)), p = u.groupNode.name;
        (o[p] || (o[p] = {
          index: h.binding++,
          id: h.group,
          snippets: []
        })).snippets.push(`	${u.name} : ${d}`);
      }
    }
    for (const u in o) {
      const c = o[u];
      a.push(this._getWGSLStructBinding(u, c.snippets.join(`,
`), "uniform", c.index, c.id));
    }
    let l = n.join(`
`);
    return l += s.join(`
`), l += a.join(`
`), l;
  }
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const i in e) {
      const n = e[i];
      n.uniforms = this.getUniforms(i), n.attributes = this.getAttributes(i), n.varyings = this.getVaryings(i), n.structs = this.getStructs(i), n.vars = this.getVars(i), n.codes = this.getCodes(i), n.directives = this.getDirectives(i), n.scopedArrays = this.getScopedArrays(i);
      let s = `// code

`;
      s += this.flowCode[i];
      const a = this.flowNodes[i], o = a[a.length - 1], l = o.outputNode, u = l !== void 0 && l.isOutputStructNode === !0;
      for (const c of a) {
        const h = this.getFlowData(
          c
          /*, shaderStage*/
        ), d = c.name;
        if (d && (s.length > 0 && (s += `
`), s += `	// flow -> ${d}
	`), s += `${h.code}
	`, c === o && i !== "compute") {
          if (s += `// result

	`, i === "vertex")
            s += `varyings.Vertex = ${h.result};`;
          else if (i === "fragment")
            if (u)
              n.returnType = l.nodeType, s += `return ${h.result};`;
            else {
              let p = "	@location(0) color: vec4<f32>";
              const f = this.getBuiltins("output");
              f && (p += `,
	` + f), n.returnType = "OutputStruct", n.structs += this._getWGSLStruct("OutputStruct", p), n.structs += `
var<private> output : OutputStruct;

`, s += `output.color = ${h.result};

	return output;`;
            }
        }
      }
      n.flow = s;
    }
    this.material !== null ? (this.vertexShader = this._getWGSLVertexCode(e.vertex), this.fragmentShader = this._getWGSLFragmentCode(e.fragment)) : this.computeShader = this._getWGSLComputeCode(e.compute, (this.object.workgroupSize || [64]).join(", "));
  }
  getMethod(e, i = null) {
    let n;
    return i !== null && (n = this._getWGSLMethod(e + "_" + i)), n === void 0 && (n = this._getWGSLMethod(e)), n || e;
  }
  getType(e) {
    return lJ[e] || e;
  }
  isAvailable(e) {
    let i = dA[e];
    return i === void 0 && (e === "float32Filterable" && (i = this.renderer.hasFeature("float32-filterable")), dA[e] = i), i;
  }
  _getWGSLMethod(e) {
    return qs[e] !== void 0 && this._include(e), Gh[e];
  }
  _include(e) {
    const i = qs[e];
    return i.build(this), this.currentFunctionNode !== null && this.currentFunctionNode.includes.push(i), i;
  }
  _getWGSLVertexCode(e) {
    return `${this.getSignature()}
// directives
${e.directives}

// uniforms
${e.uniforms}

// varyings
${e.varyings}
var<private> varyings : VaryingsStruct;

// codes
${e.codes}

@vertex
fn main( ${e.attributes} ) -> VaryingsStruct {

	// vars
	${e.vars}

	// flow
	${e.flow}

	return varyings;

}
`;
  }
  _getWGSLFragmentCode(e) {
    return `${this.getSignature()}
// global
${nO}

// uniforms
${e.uniforms}

// structs
${e.structs}

// codes
${e.codes}

@fragment
fn main( ${e.varyings} ) -> ${e.returnType} {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  _getWGSLComputeCode(e, i) {
    return `${this.getSignature()}
// directives
${e.directives}

// system
var<private> instanceIndex : u32;

// locals
${e.scopedArrays}

// uniforms
${e.uniforms}

// codes
${e.codes}

@compute @workgroup_size( ${i} )
fn main( ${e.attributes} ) {

	// system
	instanceIndex = id.x + id.y * numWorkgroups.x * u32(${i}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${i});

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  _getWGSLStruct(e, i) {
    return `
struct ${e} {
${i}
};`;
  }
  _getWGSLStructBinding(e, i, n, s = 0, a = 0) {
    const o = e + "Struct";
    return `${this._getWGSLStruct(o, i)}
@binding( ${s} ) @group( ${a} )
var<${n}> ${e} : ${o};`;
  }
}
class cJ {
  constructor(e) {
    this.backend = e;
  }
  getCurrentDepthStencilFormat(e) {
    let i;
    return e.depthTexture !== null ? i = this.getTextureFormatGPU(e.depthTexture) : e.depth && e.stencil ? i = $.Depth24PlusStencil8 : e.depth && (i = $.Depth24Plus), i;
  }
  getTextureFormatGPU(e) {
    return this.backend.get(e).format;
  }
  getCurrentColorFormat(e) {
    let i;
    return e.textures !== null ? i = this.getTextureFormatGPU(e.textures[0]) : i = this.getPreferredCanvasFormat(), i;
  }
  getCurrentColorSpace(e) {
    return e.textures !== null ? e.textures[0].colorSpace : this.backend.renderer.outputColorSpace;
  }
  getPrimitiveTopology(e, i) {
    if (e.isPoints) return zu.PointList;
    if (e.isLineSegments || e.isMesh && i.wireframe === !0) return zu.LineList;
    if (e.isLine) return zu.LineStrip;
    if (e.isMesh) return zu.TriangleList;
  }
  getSampleCount(e) {
    let i = 1;
    return e > 1 && (i = Math.pow(2, Math.floor(Math.log2(e))), i === 2 && (i = 4)), i;
  }
  getSampleCountRenderContext(e) {
    return e.textures !== null ? this.getSampleCount(e.sampleCount) : this.getSampleCount(this.backend.renderer.samples);
  }
  getPreferredCanvasFormat() {
    return navigator.userAgent.includes("Quest") ? $.BGRA8Unorm : navigator.gpu.getPreferredCanvasFormat();
  }
}
const hJ = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]), dJ = /* @__PURE__ */ new Map([
  [lP, ["float16"]]
]), pJ = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Int16Array, "sint32"],
  // patch for INT16
  [Uint32Array, "uint32"],
  [Uint16Array, "uint32"],
  // patch for UINT16
  [Float32Array, "float32"]
]);
class fJ {
  constructor(e) {
    this.backend = e;
  }
  createAttribute(e, i) {
    const n = this._getBufferAttribute(e), s = this.backend, a = s.get(n);
    let o = a.buffer;
    if (o === void 0) {
      const l = s.device;
      let u = n.array;
      if (e.normalized === !1 && (u.constructor === Int16Array || u.constructor === Uint16Array)) {
        const h = new Uint32Array(u.length);
        for (let d = 0; d < u.length; d++)
          h[d] = u[d];
        u = h;
      }
      if (n.array = u, (n.isStorageBufferAttribute || n.isStorageInstancedBufferAttribute) && n.itemSize === 3) {
        u = new u.constructor(n.count * 4);
        for (let h = 0; h < n.count; h++)
          u.set(n.array.subarray(h * 3, h * 3 + 3), h * 4);
        n.itemSize = 4, n.array = u;
      }
      const c = u.byteLength + (4 - u.byteLength % 4) % 4;
      o = l.createBuffer({
        label: n.name,
        size: c,
        usage: i,
        mappedAtCreation: !0
      }), new u.constructor(o.getMappedRange()).set(u), o.unmap(), a.buffer = o;
    }
  }
  updateAttribute(e) {
    const i = this._getBufferAttribute(e), n = this.backend, s = n.device, a = n.get(i).buffer, o = i.array, l = i.updateRanges;
    if (l.length === 0)
      s.queue.writeBuffer(
        a,
        0,
        o,
        0
      );
    else {
      for (let u = 0, c = l.length; u < c; u++) {
        const h = l[u];
        s.queue.writeBuffer(
          a,
          0,
          o,
          h.start * o.BYTES_PER_ELEMENT,
          h.count * o.BYTES_PER_ELEMENT
        );
      }
      i.clearUpdateRanges();
    }
  }
  createShaderVertexBuffers(e) {
    const i = e.getAttributes(), n = /* @__PURE__ */ new Map();
    for (let s = 0; s < i.length; s++) {
      const a = i[s], o = a.array.BYTES_PER_ELEMENT, l = this._getBufferAttribute(a);
      let u = n.get(l);
      if (u === void 0) {
        let d, p;
        a.isInterleavedBufferAttribute === !0 ? (d = a.data.stride * o, p = a.data.isInstancedInterleavedBuffer ? gf.Instance : gf.Vertex) : (d = a.itemSize * o, p = a.isInstancedBufferAttribute ? gf.Instance : gf.Vertex), a.normalized === !1 && (a.array.constructor === Int16Array || a.array.constructor === Uint16Array) && (d = 4), u = {
          arrayStride: d,
          attributes: [],
          stepMode: p
        }, n.set(l, u);
      }
      const c = this._getVertexFormat(a), h = a.isInterleavedBufferAttribute === !0 ? a.offset * o : 0;
      u.attributes.push({
        shaderLocation: s,
        offset: h,
        format: c
      });
    }
    return Array.from(n.values());
  }
  destroyAttribute(e) {
    const i = this.backend;
    i.get(this._getBufferAttribute(e)).buffer.destroy(), i.delete(e);
  }
  async getArrayBufferAsync(e) {
    const i = this.backend, n = i.device, s = i.get(this._getBufferAttribute(e)).buffer, a = s.size, o = n.createBuffer({
      label: e.name,
      size: a,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    }), l = n.createCommandEncoder({});
    l.copyBufferToBuffer(
      s,
      0,
      o,
      0,
      a
    ), o.unmap();
    const u = l.finish();
    return n.queue.submit([u]), await o.mapAsync(GPUMapMode.READ), o.getMappedRange();
  }
  _getVertexFormat(e) {
    const { itemSize: i, normalized: n } = e, s = e.array.constructor, a = e.constructor;
    let o;
    if (i == 1)
      o = pJ.get(s);
    else {
      const l = (dJ.get(a) || hJ.get(s))[n ? 1 : 0];
      if (l) {
        const u = s.BYTES_PER_ELEMENT * i, c = Math.floor((u + 3) / 4) * 4 / s.BYTES_PER_ELEMENT;
        if (c % 1)
          throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
        o = `${l}x${c}`;
      }
    }
    return o || console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet."), o;
  }
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
class mJ {
  constructor(e) {
    this.backend = e, this.bindGroupLayoutCache = /* @__PURE__ */ new WeakMap();
  }
  createBindingsLayout(e) {
    const i = this.backend.device, n = [];
    let s = 0;
    for (const a of e.bindings) {
      const o = {
        binding: s++,
        visibility: a.visibility
      };
      if (a.isUniformBuffer || a.isStorageBuffer) {
        const l = {};
        a.isStorageBuffer && (l.type = a.access), o.buffer = l;
      } else if (a.isSampler) {
        const l = {};
        a.texture.isDepthTexture && a.texture.compareFunction !== null && (l.type = "comparison"), o.sampler = l;
      } else if (a.isSampledTexture && a.texture.isVideoTexture)
        o.externalTexture = {};
      else if (a.isSampledTexture && a.store) {
        const l = this.backend.get(a.texture).texture.format, u = a.access;
        o.storageTexture = { format: l, access: u };
      } else if (a.isSampledTexture) {
        const l = {};
        if (a.texture.isMultisampleRenderTargetTexture === !0 && (l.multisampled = !0), a.texture.isDepthTexture)
          l.sampleType = Eh.Depth;
        else if (a.texture.isDataTexture || a.texture.isDataArrayTexture || a.texture.isData3DTexture) {
          const u = a.texture.type;
          u === Sr ? l.sampleType = Eh.SInt : u === er ? l.sampleType = Eh.UInt : u === on && (this.backend.hasFeature("float32-filterable") ? l.sampleType = Eh.Float : l.sampleType = Eh.UnfilterableFloat);
        }
        a.isSampledCubeTexture ? l.viewDimension = yn.Cube : a.texture.isDataArrayTexture || a.texture.isCompressedArrayTexture ? l.viewDimension = yn.TwoDArray : a.isSampledTexture3D && (l.viewDimension = yn.ThreeD), o.texture = l;
      } else
        console.error(`WebGPUBindingUtils: Unsupported binding "${a}".`);
      n.push(o);
    }
    return i.createBindGroupLayout({ entries: n });
  }
  createBindings(e) {
    const { backend: i, bindGroupLayoutCache: n } = this, s = i.get(e);
    let a = n.get(e.bindingsReference);
    a === void 0 && (a = this.createBindingsLayout(e), n.set(e.bindingsReference, a));
    const o = this.createBindGroup(e, a);
    s.layout = a, s.group = o;
  }
  updateBinding(e) {
    const i = this.backend, n = i.device, s = e.buffer, a = i.get(e).buffer;
    n.queue.writeBuffer(a, 0, s, 0);
  }
  createBindGroup(e, i) {
    const n = this.backend, s = n.device;
    let a = 0;
    const o = [];
    for (const l of e.bindings) {
      if (l.isUniformBuffer) {
        const u = n.get(l);
        if (u.buffer === void 0) {
          const c = l.byteLength, h = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, d = s.createBuffer({
            label: "bindingBuffer_" + l.name,
            size: c,
            usage: h
          });
          u.buffer = d;
        }
        o.push({ binding: a, resource: { buffer: u.buffer } });
      } else if (l.isStorageBuffer) {
        const u = n.get(l);
        if (u.buffer === void 0) {
          const c = l.attribute;
          u.buffer = n.get(c).buffer;
        }
        o.push({ binding: a, resource: { buffer: u.buffer } });
      } else if (l.isSampler) {
        const u = n.get(l.texture);
        o.push({ binding: a, resource: u.sampler });
      } else if (l.isSampledTexture) {
        const u = n.get(l.texture);
        let c;
        if (u.externalTexture !== void 0)
          c = s.importExternalTexture({ source: u.externalTexture });
        else {
          const h = l.store ? 1 : u.texture.mipLevelCount, d = `view-${u.texture.width}-${u.texture.height}-${h}`;
          if (c = u[d], c === void 0) {
            const p = iZ.All;
            let f;
            l.isSampledCubeTexture ? f = yn.Cube : l.isSampledTexture3D ? f = yn.ThreeD : l.texture.isDataArrayTexture || l.texture.isCompressedArrayTexture ? f = yn.TwoDArray : f = yn.TwoD, c = u[d] = u.texture.createView({ aspect: p, dimension: f, mipLevelCount: h });
          }
        }
        o.push({ binding: a, resource: c });
      }
      a++;
    }
    return s.createBindGroup({
      label: "bindGroup_" + e.name,
      layout: i,
      entries: o
    });
  }
}
class gJ {
  constructor(e) {
    this.backend = e;
  }
  _getSampleCount(e) {
    return this.backend.utils.getSampleCountRenderContext(e);
  }
  createRenderPipeline(e, i) {
    const { object: n, material: s, geometry: a, pipeline: o } = e, { vertexProgram: l, fragmentProgram: u } = o, c = this.backend, h = c.device, d = c.utils, p = c.get(o), f = [];
    for (const U of e.getBindings()) {
      const C = c.get(U);
      f.push(C.layout);
    }
    const m = c.attributeUtils.createShaderVertexBuffers(e);
    let v;
    s.transparent === !0 && s.blending !== xc && (v = this._getBlending(s));
    let y = {};
    s.stencilWrite === !0 && (y = {
      compare: this._getStencilCompare(s),
      failOp: this._getStencilOperation(s.stencilFail),
      depthFailOp: this._getStencilOperation(s.stencilZFail),
      passOp: this._getStencilOperation(s.stencilZPass)
    });
    const g = this._getColorWriteMask(s), _ = [];
    if (e.context.textures !== null) {
      const U = e.context.textures;
      for (let C = 0; C < U.length; C++) {
        const O = d.getTextureFormatGPU(U[C]);
        _.push({
          format: O,
          blend: v,
          writeMask: g
        });
      }
    } else {
      const U = d.getCurrentColorFormat(e.context);
      _.push({
        format: U,
        blend: v,
        writeMask: g
      });
    }
    const x = c.get(l).module, b = c.get(u).module, T = this._getPrimitiveState(n, a, s), S = this._getDepthCompare(s), w = d.getCurrentDepthStencilFormat(e.context), A = this._getSampleCount(e.context), E = {
      label: `renderPipeline_${s.name || s.type}_${s.id}`,
      vertex: Object.assign({}, x, { buffers: m }),
      fragment: Object.assign({}, b, { targets: _ }),
      primitive: T,
      multisample: {
        count: A,
        alphaToCoverageEnabled: s.alphaToCoverage && A > 1
      },
      layout: h.createPipelineLayout({
        bindGroupLayouts: f
      })
    }, M = {}, N = e.context.depth, k = e.context.stencil;
    if ((N === !0 || k === !0) && (N === !0 && (M.format = w, M.depthWriteEnabled = s.depthWrite, M.depthCompare = S), k === !0 && (M.stencilFront = y, M.stencilBack = {}, M.stencilReadMask = s.stencilFuncMask, M.stencilWriteMask = s.stencilWriteMask), E.depthStencil = M), i === null)
      p.pipeline = h.createRenderPipeline(E);
    else {
      const U = new Promise((C) => {
        h.createRenderPipelineAsync(E).then((O) => {
          p.pipeline = O, C();
        });
      });
      i.push(U);
    }
  }
  createBundleEncoder(e) {
    const i = this.backend, { utils: n, device: s } = i, a = n.getCurrentDepthStencilFormat(e), o = n.getCurrentColorFormat(e), l = this._getSampleCount(e), u = {
      label: "renderBundleEncoder",
      colorFormats: [o],
      depthStencilFormat: a,
      sampleCount: l
    };
    return s.createRenderBundleEncoder(u);
  }
  createComputePipeline(e, i) {
    const n = this.backend, s = n.device, a = n.get(e.computeProgram).module, o = n.get(e), l = [];
    for (const u of i) {
      const c = n.get(u);
      l.push(c.layout);
    }
    o.pipeline = s.createComputePipeline({
      compute: a,
      layout: s.createPipelineLayout({
        bindGroupLayouts: l
      })
    });
  }
  _getBlending(e) {
    let i, n;
    const s = e.blending, a = e.blendSrc, o = e.blendDst, l = e.blendEquation;
    if (s === NN) {
      const u = e.blendSrcAlpha !== null ? e.blendSrcAlpha : a, c = e.blendDstAlpha !== null ? e.blendDstAlpha : o, h = e.blendEquationAlpha !== null ? e.blendEquationAlpha : l;
      i = {
        srcFactor: this._getBlendFactor(a),
        dstFactor: this._getBlendFactor(o),
        operation: this._getBlendOperation(l)
      }, n = {
        srcFactor: this._getBlendFactor(u),
        dstFactor: this._getBlendFactor(c),
        operation: this._getBlendOperation(h)
      };
    } else {
      const u = e.premultipliedAlpha, c = (h, d, p, f) => {
        i = {
          srcFactor: h,
          dstFactor: d,
          operation: Bo.Add
        }, n = {
          srcFactor: p,
          dstFactor: f,
          operation: Bo.Add
        };
      };
      if (u)
        switch (s) {
          case co:
            c(vt.One, vt.OneMinusSrcAlpha, vt.One, vt.OneMinusSrcAlpha);
            break;
          case Cm:
            c(vt.One, vt.One, vt.One, vt.One);
            break;
          case Rm:
            c(vt.Zero, vt.OneMinusSrc, vt.Zero, vt.One);
            break;
          case Nm:
            c(vt.Zero, vt.Src, vt.Zero, vt.SrcAlpha);
            break;
        }
      else
        switch (s) {
          case co:
            c(vt.SrcAlpha, vt.OneMinusSrcAlpha, vt.One, vt.OneMinusSrcAlpha);
            break;
          case Cm:
            c(vt.SrcAlpha, vt.One, vt.SrcAlpha, vt.One);
            break;
          case Rm:
            c(vt.Zero, vt.OneMinusSrc, vt.Zero, vt.One);
            break;
          case Nm:
            c(vt.Zero, vt.Src, vt.Zero, vt.Src);
            break;
        }
    }
    if (i !== void 0 && n !== void 0)
      return { color: i, alpha: n };
    console.error("THREE.WebGPURenderer: Invalid blending: ", s);
  }
  _getBlendFactor(e) {
    let i;
    switch (e) {
      case ON:
        i = vt.Zero;
        break;
      case DN:
        i = vt.One;
        break;
      case LN:
        i = vt.Src;
        break;
      case UN:
        i = vt.OneMinusSrc;
        break;
      case Pm:
        i = vt.SrcAlpha;
        break;
      case Im:
        i = vt.OneMinusSrcAlpha;
        break;
      case BN:
        i = vt.Dst;
        break;
      case zN:
        i = vt.OneMinusDstColor;
        break;
      case kN:
        i = vt.DstAlpha;
        break;
      case FN:
        i = vt.OneMinusDstAlpha;
        break;
      case jN:
        i = vt.SrcAlphaSaturated;
        break;
      case NK:
        i = vt.Constant;
        break;
      case PK:
        i = vt.OneMinusConstant;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend factor not supported.", e);
    }
    return i;
  }
  _getStencilCompare(e) {
    let i;
    const n = e.stencilFunc;
    switch (n) {
      case J9:
        i = Qi.Never;
        break;
      case mx:
        i = Qi.Always;
        break;
      case e7:
        i = Qi.Less;
        break;
      case i7:
        i = Qi.LessEqual;
        break;
      case t7:
        i = Qi.Equal;
        break;
      case s7:
        i = Qi.GreaterEqual;
        break;
      case r7:
        i = Qi.Greater;
        break;
      case n7:
        i = Qi.NotEqual;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil function.", n);
    }
    return i;
  }
  _getStencilOperation(e) {
    let i;
    switch (e) {
      case Go:
        i = Ha.Keep;
        break;
      case q9:
        i = Ha.Zero;
        break;
      case X9:
        i = Ha.Replace;
        break;
      case Q9:
        i = Ha.Invert;
        break;
      case $9:
        i = Ha.IncrementClamp;
        break;
      case Y9:
        i = Ha.DecrementClamp;
        break;
      case K9:
        i = Ha.IncrementWrap;
        break;
      case Z9:
        i = Ha.DecrementWrap;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil operation.", i);
    }
    return i;
  }
  _getBlendOperation(e) {
    let i;
    switch (e) {
      case eo:
        i = Bo.Add;
        break;
      case PN:
        i = Bo.Subtract;
        break;
      case IN:
        i = Bo.ReverseSubtract;
        break;
      case C9:
        i = Bo.Min;
        break;
      case R9:
        i = Bo.Max;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.", e);
    }
    return i;
  }
  _getPrimitiveState(e, i, n) {
    const s = {}, a = this.backend.utils;
    switch (s.topology = a.getPrimitiveTopology(e, n), i.index !== null && e.isLine === !0 && e.isLineSegments !== !0 && (s.stripIndexFormat = i.index.array instanceof Uint16Array ? Mc.Uint16 : Mc.Uint32), n.side) {
      case bc:
        s.frontFace = Jv.CCW, s.cullMode = e0.Back;
        break;
      case Zn:
        s.frontFace = Jv.CCW, s.cullMode = e0.Front;
        break;
      case $u:
        s.frontFace = Jv.CCW, s.cullMode = e0.None;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.", n.side);
        break;
    }
    return s;
  }
  _getColorWriteMask(e) {
    return e.colorWrite === !0 ? VM.All : VM.None;
  }
  _getDepthCompare(e) {
    let i;
    if (e.depthTest === !1)
      i = Qi.Always;
    else {
      const n = e.depthFunc;
      switch (n) {
        case VN:
          i = Qi.Never;
          break;
        case GN:
          i = Qi.Always;
          break;
        case HN:
          i = Qi.Less;
          break;
        case Om:
          i = Qi.LessEqual;
          break;
        case WN:
          i = Qi.Equal;
          break;
        case qN:
          i = Qi.GreaterEqual;
          break;
        case XN:
          i = Qi.Greater;
          break;
        case $N:
          i = Qi.NotEqual;
          break;
        default:
          console.error("THREE.WebGPUPipelineUtils: Invalid depth function.", n);
      }
    }
    return i;
  }
}
class yJ extends rO {
  constructor(e = {}) {
    super(e), this.isWebGPUBackend = !0, this.parameters.alpha = e.alpha === void 0 ? !0 : e.alpha, this.parameters.requiredLimits = e.requiredLimits === void 0 ? {} : e.requiredLimits, this.trackTimestamp = e.trackTimestamp === !0, this.device = null, this.context = null, this.colorBuffer = null, this.defaultRenderPassdescriptor = null, this.utils = new cJ(this), this.attributeUtils = new fJ(this), this.bindingUtils = new mJ(this), this.pipelineUtils = new gJ(this), this.textureUtils = new tJ(this), this.occludedResolveCache = /* @__PURE__ */ new Map();
  }
  async init(e) {
    await super.init(e);
    const i = this.parameters;
    let n;
    if (i.device === void 0) {
      const o = {
        powerPreference: i.powerPreference
      }, l = await navigator.gpu.requestAdapter(o);
      if (l === null)
        throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
      const u = Object.values(Px), c = [];
      for (const d of u)
        l.features.has(d) && c.push(d);
      const h = {
        requiredFeatures: c,
        requiredLimits: i.requiredLimits
      };
      n = await l.requestDevice(h);
    } else
      n = i.device;
    n.lost.then((o) => {
      const l = {
        api: "WebGPU",
        message: o.message || "Unknown reason",
        reason: o.reason || null,
        originalEvent: o
      };
      e.onDeviceLost(l);
    });
    const s = i.context !== void 0 ? i.context : e.domElement.getContext("webgpu");
    this.device = n, this.context = s;
    const a = i.alpha ? "premultiplied" : "opaque";
    this.trackTimestamp = this.trackTimestamp && this.hasFeature(Px.TimestampQuery), this.context.configure({
      device: this.device,
      format: this.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
      alphaMode: a
    }), this.updateSize();
  }
  get coordinateSystem() {
    return wl;
  }
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  getContext() {
    return this.context;
  }
  _getDefaultRenderPassDescriptor() {
    let e = this.defaultRenderPassdescriptor;
    if (e === null) {
      const n = this.renderer;
      e = {
        colorAttachments: [{
          view: null
        }]
      }, (this.renderer.depth === !0 || this.renderer.stencil === !0) && (e.depthStencilAttachment = {
        view: this.textureUtils.getDepthBuffer(n.depth, n.stencil).createView()
      });
      const s = e.colorAttachments[0];
      this.renderer.samples > 0 ? s.view = this.colorBuffer.createView() : s.resolveTarget = void 0, this.defaultRenderPassdescriptor = e;
    }
    const i = e.colorAttachments[0];
    return this.renderer.samples > 0 ? i.resolveTarget = this.context.getCurrentTexture().createView() : i.view = this.context.getCurrentTexture().createView(), e;
  }
  _getRenderPassDescriptor(e) {
    const i = e.renderTarget, n = this.get(i);
    let s = n.descriptors;
    if (s === void 0 || n.width !== i.width || n.height !== i.height || n.activeMipmapLevel !== i.activeMipmapLevel || n.samples !== i.samples) {
      s = {}, n.descriptors = s;
      const l = () => {
        i.removeEventListener("dispose", l), this.delete(i);
      };
      i.addEventListener("dispose", l);
    }
    const a = e.getCacheKey();
    let o = s[a];
    if (o === void 0) {
      const l = e.textures, u = [];
      for (let c = 0; c < l.length; c++) {
        const h = this.get(l[c]), d = h.texture.createView({
          baseMipLevel: e.activeMipmapLevel,
          mipLevelCount: 1,
          baseArrayLayer: e.activeCubeFace,
          dimension: yn.TwoD
        });
        let p, f;
        h.msaaTexture !== void 0 ? (p = h.msaaTexture.createView(), f = d) : (p = d, f = void 0), u.push({
          view: p,
          resolveTarget: f,
          loadOp: Oi.Load,
          storeOp: Ji.Store
        });
      }
      if (o = {
        colorAttachments: u
      }, e.depth) {
        const c = {
          view: this.get(e.depthTexture).texture.createView()
        };
        o.depthStencilAttachment = c;
      }
      s[a] = o, n.width = i.width, n.height = i.height, n.samples = i.samples, n.activeMipmapLevel = i.activeMipmapLevel;
    }
    return o;
  }
  beginRender(e) {
    const i = this.get(e), n = this.device, s = e.occlusionQueryCount;
    let a;
    s > 0 && (i.currentOcclusionQuerySet && i.currentOcclusionQuerySet.destroy(), i.currentOcclusionQueryBuffer && i.currentOcclusionQueryBuffer.destroy(), i.currentOcclusionQuerySet = i.occlusionQuerySet, i.currentOcclusionQueryBuffer = i.occlusionQueryBuffer, i.currentOcclusionQueryObjects = i.occlusionQueryObjects, a = n.createQuerySet({ type: "occlusion", count: s }), i.occlusionQuerySet = a, i.occlusionQueryIndex = 0, i.occlusionQueryObjects = new Array(s), i.lastOcclusionObject = null);
    let o;
    e.textures === null ? o = this._getDefaultRenderPassDescriptor() : o = this._getRenderPassDescriptor(e), this.initTimestampQuery(e, o), o.occlusionQuerySet = a;
    const l = o.depthStencilAttachment;
    if (e.textures !== null) {
      const h = o.colorAttachments;
      for (let d = 0; d < h.length; d++) {
        const p = h[d];
        e.clearColor ? (p.clearValue = d === 0 ? e.clearColorValue : { r: 0, g: 0, b: 0, a: 1 }, p.loadOp = Oi.Clear, p.storeOp = Ji.Store) : (p.loadOp = Oi.Load, p.storeOp = Ji.Store);
      }
    } else {
      const h = o.colorAttachments[0];
      e.clearColor ? (h.clearValue = e.clearColorValue, h.loadOp = Oi.Clear, h.storeOp = Ji.Store) : (h.loadOp = Oi.Load, h.storeOp = Ji.Store);
    }
    e.depth && (e.clearDepth ? (l.depthClearValue = e.clearDepthValue, l.depthLoadOp = Oi.Clear, l.depthStoreOp = Ji.Store) : (l.depthLoadOp = Oi.Load, l.depthStoreOp = Ji.Store)), e.stencil && (e.clearStencil ? (l.stencilClearValue = e.clearStencilValue, l.stencilLoadOp = Oi.Clear, l.stencilStoreOp = Ji.Store) : (l.stencilLoadOp = Oi.Load, l.stencilStoreOp = Ji.Store));
    const u = n.createCommandEncoder({ label: "renderContext_" + e.id }), c = u.beginRenderPass(o);
    if (i.descriptor = o, i.encoder = u, i.currentPass = c, i.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, i.renderBundles = [], e.viewport && this.updateViewport(e), e.scissor) {
      const { x: h, y: d, width: p, height: f } = e.scissorValue;
      c.setScissorRect(h, d, p, f);
    }
  }
  finishRender(e) {
    const i = this.get(e), n = e.occlusionQueryCount;
    if (i.renderBundles.length > 0 && i.currentPass.executeBundles(i.renderBundles), n > i.occlusionQueryIndex && i.currentPass.endOcclusionQuery(), i.currentPass.end(), n > 0) {
      const s = n * 8;
      let a = this.occludedResolveCache.get(s);
      a === void 0 && (a = this.device.createBuffer(
        {
          size: s,
          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
        }
      ), this.occludedResolveCache.set(s, a));
      const o = this.device.createBuffer(
        {
          size: s,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        }
      );
      i.encoder.resolveQuerySet(i.occlusionQuerySet, 0, n, a, 0), i.encoder.copyBufferToBuffer(a, 0, o, 0, s), i.occlusionQueryBuffer = o, this.resolveOccludedAsync(e);
    }
    if (this.prepareTimestampBuffer(e, i.encoder), this.device.queue.submit([i.encoder.finish()]), e.textures !== null) {
      const s = e.textures;
      for (let a = 0; a < s.length; a++) {
        const o = s[a];
        o.generateMipmaps === !0 && this.textureUtils.generateMipmaps(o);
      }
    }
  }
  isOccluded(e, i) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(i);
  }
  async resolveOccludedAsync(e) {
    const i = this.get(e), { currentOcclusionQueryBuffer: n, currentOcclusionQueryObjects: s } = i;
    if (n && s) {
      const a = /* @__PURE__ */ new WeakSet();
      i.currentOcclusionQueryObjects = null, i.currentOcclusionQueryBuffer = null, await n.mapAsync(GPUMapMode.READ);
      const o = n.getMappedRange(), l = new BigUint64Array(o);
      for (let u = 0; u < s.length; u++)
        l[u] !== BigInt(0) && a.add(s[u]);
      n.destroy(), i.occluded = a;
    }
  }
  updateViewport(e) {
    const { currentPass: i } = this.get(e), { x: n, y: s, width: a, height: o, minDepth: l, maxDepth: u } = e.viewportValue;
    i.setViewport(n, s, a, o, l, u);
  }
  clear(e, i, n, s = null) {
    const a = this.device, o = this.renderer;
    let l = [], u, c, h, d;
    if (e) {
      const f = this.getClearColor();
      if (this.renderer.alpha === !0) {
        const m = f.a;
        c = { r: f.r * m, g: f.g * m, b: f.b * m, a: m };
      } else
        c = { r: f.r, g: f.g, b: f.b, a: f.a };
    }
    if (s === null) {
      h = o.depth, d = o.stencil;
      const f = this._getDefaultRenderPassDescriptor();
      if (e) {
        l = f.colorAttachments;
        const m = l[0];
        m.clearValue = c, m.loadOp = Oi.Clear, m.storeOp = Ji.Store;
      }
      (h || d) && (u = f.depthStencilAttachment);
    } else {
      if (h = s.depth, d = s.stencil, e)
        for (const f of s.textures) {
          const m = this.get(f), v = m.texture.createView();
          let y, g;
          m.msaaTexture !== void 0 ? (y = m.msaaTexture.createView(), g = v) : (y = v, g = void 0), l.push({
            view: y,
            resolveTarget: g,
            clearValue: c,
            loadOp: Oi.Clear,
            storeOp: Ji.Store
          });
        }
      (h || d) && (u = {
        view: this.get(s.depthTexture).texture.createView()
      });
    }
    h && (i ? (u.depthLoadOp = Oi.Clear, u.depthClearValue = o.getClearDepth(), u.depthStoreOp = Ji.Store) : (u.depthLoadOp = Oi.Load, u.depthStoreOp = Ji.Store)), d && (n ? (u.stencilLoadOp = Oi.Clear, u.stencilClearValue = o.getClearStencil(), u.stencilStoreOp = Ji.Store) : (u.stencilLoadOp = Oi.Load, u.stencilStoreOp = Ji.Store));
    const p = a.createCommandEncoder({});
    p.beginRenderPass({
      colorAttachments: l,
      depthStencilAttachment: u
    }).end(), a.queue.submit([p.finish()]);
  }
  // compute
  beginCompute(e) {
    const i = this.get(e), n = {};
    this.initTimestampQuery(e, n), i.cmdEncoderGPU = this.device.createCommandEncoder(), i.passEncoderGPU = i.cmdEncoderGPU.beginComputePass(n);
  }
  compute(e, i, n, s) {
    const { passEncoderGPU: a } = this.get(e), o = this.get(s).pipeline;
    a.setPipeline(o);
    for (let h = 0, d = n.length; h < d; h++) {
      const p = n[h], f = this.get(p);
      a.setBindGroup(h, f.group);
    }
    const l = this.device.limits.maxComputeWorkgroupsPerDimension, u = this.get(i);
    u.dispatchSize === void 0 && (u.dispatchSize = { x: 0, y: 1, z: 1 });
    const { dispatchSize: c } = u;
    i.dispatchCount > l ? (c.x = Math.min(i.dispatchCount, l), c.y = Math.ceil(i.dispatchCount / l)) : c.x = i.dispatchCount, a.dispatchWorkgroups(
      c.x,
      c.y,
      c.z
    );
  }
  finishCompute(e) {
    const i = this.get(e);
    i.passEncoderGPU.end(), this.prepareTimestampBuffer(e, i.cmdEncoderGPU), this.device.queue.submit([i.cmdEncoderGPU.finish()]);
  }
  async waitForGPU() {
    await this.device.queue.onSubmittedWorkDone();
  }
  // render object
  draw(e, i) {
    const { object: n, context: s, pipeline: a } = e, o = e.getBindings(), l = this.get(s), u = this.get(a).pipeline, c = l.currentSets, h = l.currentPass, d = e.getDrawParameters();
    if (d === null) return;
    c.pipeline !== u && (h.setPipeline(u), c.pipeline = u);
    const p = c.bindingGroups;
    for (let y = 0, g = o.length; y < g; y++) {
      const _ = o[y], x = this.get(_);
      p[_.index] !== _.id && (h.setBindGroup(_.index, x.group), p[_.index] = _.id);
    }
    const f = e.getIndex(), m = f !== null;
    if (m === !0 && c.index !== f) {
      const y = this.get(f).buffer, g = f.array instanceof Uint16Array ? Mc.Uint16 : Mc.Uint32;
      h.setIndexBuffer(y, g), c.index = f;
    }
    const v = e.getVertexBuffers();
    for (let y = 0, g = v.length; y < g; y++) {
      const _ = v[y];
      if (c.attributes[y] !== _) {
        const x = this.get(_).buffer;
        h.setVertexBuffer(y, x), c.attributes[y] = _;
      }
    }
    if (l.occlusionQuerySet !== void 0) {
      const y = l.lastOcclusionObject;
      y !== n && (y !== null && y.occlusionTest === !0 && (h.endOcclusionQuery(), l.occlusionQueryIndex++), n.occlusionTest === !0 && (h.beginOcclusionQuery(l.occlusionQueryIndex), l.occlusionQueryObjects[l.occlusionQueryIndex] = n), l.lastOcclusionObject = n);
    }
    if (n.isBatchedMesh === !0) {
      const y = n._multiDrawStarts, g = n._multiDrawCounts, _ = n._multiDrawCount, x = n._multiDrawInstances, b = m ? f.array.BYTES_PER_ELEMENT : 1;
      for (let T = 0; T < _; T++) {
        const S = x ? x[T] : 1, w = S > 1 ? 0 : T;
        h.drawIndexed(g[T], S, y[T] / b, 0, w);
      }
    } else if (m === !0) {
      const { vertexCount: y, instanceCount: g, firstVertex: _ } = d, x = e.getIndirect();
      if (x !== null) {
        const b = this.get(x).buffer;
        h.drawIndexedIndirect(b, 0);
      } else
        h.drawIndexed(y, g, _, 0, 0);
      i.update(n, y, g);
    } else {
      const { vertexCount: y, instanceCount: g, firstVertex: _ } = d, x = e.getIndirect();
      if (x !== null) {
        const b = this.get(x).buffer;
        h.drawIndirect(b, 0);
      } else
        h.draw(y, g, _, 0);
      i.update(n, y, g);
    }
  }
  // cache key
  needsRenderUpdate(e) {
    const i = this.get(e), { object: n, material: s } = e, a = this.utils, o = a.getSampleCountRenderContext(e.context), l = a.getCurrentColorSpace(e.context), u = a.getCurrentColorFormat(e.context), c = a.getCurrentDepthStencilFormat(e.context), h = a.getPrimitiveTopology(n, s);
    let d = !1;
    return (i.material !== s || i.materialVersion !== s.version || i.transparent !== s.transparent || i.blending !== s.blending || i.premultipliedAlpha !== s.premultipliedAlpha || i.blendSrc !== s.blendSrc || i.blendDst !== s.blendDst || i.blendEquation !== s.blendEquation || i.blendSrcAlpha !== s.blendSrcAlpha || i.blendDstAlpha !== s.blendDstAlpha || i.blendEquationAlpha !== s.blendEquationAlpha || i.colorWrite !== s.colorWrite || i.depthWrite !== s.depthWrite || i.depthTest !== s.depthTest || i.depthFunc !== s.depthFunc || i.stencilWrite !== s.stencilWrite || i.stencilFunc !== s.stencilFunc || i.stencilFail !== s.stencilFail || i.stencilZFail !== s.stencilZFail || i.stencilZPass !== s.stencilZPass || i.stencilFuncMask !== s.stencilFuncMask || i.stencilWriteMask !== s.stencilWriteMask || i.side !== s.side || i.alphaToCoverage !== s.alphaToCoverage || i.sampleCount !== o || i.colorSpace !== l || i.colorFormat !== u || i.depthStencilFormat !== c || i.primitiveTopology !== h || i.clippingContextCacheKey !== e.clippingContext.cacheKey) && (i.material = s, i.materialVersion = s.version, i.transparent = s.transparent, i.blending = s.blending, i.premultipliedAlpha = s.premultipliedAlpha, i.blendSrc = s.blendSrc, i.blendDst = s.blendDst, i.blendEquation = s.blendEquation, i.blendSrcAlpha = s.blendSrcAlpha, i.blendDstAlpha = s.blendDstAlpha, i.blendEquationAlpha = s.blendEquationAlpha, i.colorWrite = s.colorWrite, i.depthWrite = s.depthWrite, i.depthTest = s.depthTest, i.depthFunc = s.depthFunc, i.stencilWrite = s.stencilWrite, i.stencilFunc = s.stencilFunc, i.stencilFail = s.stencilFail, i.stencilZFail = s.stencilZFail, i.stencilZPass = s.stencilZPass, i.stencilFuncMask = s.stencilFuncMask, i.stencilWriteMask = s.stencilWriteMask, i.side = s.side, i.alphaToCoverage = s.alphaToCoverage, i.sampleCount = o, i.colorSpace = l, i.colorFormat = u, i.depthStencilFormat = c, i.primitiveTopology = h, i.clippingContextCacheKey = e.clippingContext.cacheKey, d = !0), d;
  }
  getRenderCacheKey(e) {
    const { object: i, material: n } = e, s = this.utils, a = e.context;
    return [
      n.transparent,
      n.blending,
      n.premultipliedAlpha,
      n.blendSrc,
      n.blendDst,
      n.blendEquation,
      n.blendSrcAlpha,
      n.blendDstAlpha,
      n.blendEquationAlpha,
      n.colorWrite,
      n.depthWrite,
      n.depthTest,
      n.depthFunc,
      n.stencilWrite,
      n.stencilFunc,
      n.stencilFail,
      n.stencilZFail,
      n.stencilZPass,
      n.stencilFuncMask,
      n.stencilWriteMask,
      n.side,
      s.getSampleCountRenderContext(a),
      s.getCurrentColorSpace(a),
      s.getCurrentColorFormat(a),
      s.getCurrentDepthStencilFormat(a),
      s.getPrimitiveTopology(i, n),
      e.getGeometryCacheKey(),
      e.clippingContext.cacheKey
    ].join();
  }
  // textures
  createSampler(e) {
    this.textureUtils.createSampler(e);
  }
  destroySampler(e) {
    this.textureUtils.destroySampler(e);
  }
  createDefaultTexture(e) {
    this.textureUtils.createDefaultTexture(e);
  }
  createTexture(e, i) {
    this.textureUtils.createTexture(e, i);
  }
  updateTexture(e, i) {
    this.textureUtils.updateTexture(e, i);
  }
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  destroyTexture(e) {
    this.textureUtils.destroyTexture(e);
  }
  copyTextureToBuffer(e, i, n, s, a, o) {
    return this.textureUtils.copyTextureToBuffer(e, i, n, s, a, o);
  }
  initTimestampQuery(e, i) {
    if (!this.trackTimestamp) return;
    const n = this.get(e);
    if (!n.timeStampQuerySet) {
      const s = this.device.createQuerySet({ type: "timestamp", count: 2 });
      Object.assign(i, {
        timestampWrites: {
          querySet: s,
          beginningOfPassWriteIndex: 0,
          // Write timestamp in index 0 when pass begins.
          endOfPassWriteIndex: 1
          // Write timestamp in index 1 when pass ends.
        }
      }), n.timeStampQuerySet = s;
    }
  }
  // timestamp utils
  prepareTimestampBuffer(e, i) {
    if (!this.trackTimestamp) return;
    const n = this.get(e), s = 2 * BigInt64Array.BYTES_PER_ELEMENT;
    n.currentTimestampQueryBuffers === void 0 && (n.currentTimestampQueryBuffers = {
      resolveBuffer: this.device.createBuffer({
        label: "timestamp resolve buffer",
        size: s,
        usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
      }),
      resultBuffer: this.device.createBuffer({
        label: "timestamp result buffer",
        size: s,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }),
      isMappingPending: !1
    });
    const { resolveBuffer: a, resultBuffer: o, isMappingPending: l } = n.currentTimestampQueryBuffers;
    l !== !0 && (i.resolveQuerySet(n.timeStampQuerySet, 0, 2, a, 0), i.copyBufferToBuffer(a, 0, o, 0, s));
  }
  async resolveTimestampAsync(e, i = "render") {
    if (!this.trackTimestamp) return;
    const n = this.get(e);
    if (n.currentTimestampQueryBuffers === void 0) return;
    const { resultBuffer: s, isMappingPending: a } = n.currentTimestampQueryBuffers;
    a !== !0 && (n.currentTimestampQueryBuffers.isMappingPending = !0, s.mapAsync(GPUMapMode.READ).then(() => {
      const o = new BigUint64Array(s.getMappedRange()), l = Number(o[1] - o[0]) / 1e6;
      this.renderer.info.updateTimestamp(i, l), s.unmap(), n.currentTimestampQueryBuffers.isMappingPending = !1;
    }));
  }
  // node builder
  createNodeBuilder(e, i) {
    return new uJ(e, i);
  }
  // program
  createProgram(e) {
    const i = this.get(e);
    i.module = {
      module: this.device.createShaderModule({ code: e.code, label: e.stage }),
      entryPoint: "main"
    };
  }
  destroyProgram(e) {
    this.delete(e);
  }
  // pipelines
  createRenderPipeline(e, i) {
    this.pipelineUtils.createRenderPipeline(e, i);
  }
  createComputePipeline(e, i) {
    this.pipelineUtils.createComputePipeline(e, i);
  }
  beginBundle(e) {
    const i = this.get(e);
    i._currentPass = i.currentPass, i._currentSets = i.currentSets, i.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, i.currentPass = this.pipelineUtils.createBundleEncoder(e);
  }
  finishBundle(e, i) {
    const n = this.get(e), s = n.currentPass.finish();
    this.get(i).bundleGPU = s, n.currentSets = n._currentSets, n.currentPass = n._currentPass;
  }
  addBundle(e, i) {
    this.get(e).renderBundles.push(this.get(i).bundleGPU);
  }
  // bindings
  createBindings(e) {
    this.bindingUtils.createBindings(e);
  }
  updateBindings(e) {
    this.bindingUtils.createBindings(e);
  }
  updateBinding(e) {
    this.bindingUtils.updateBinding(e);
  }
  // attributes
  createIndexAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createIndirectStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  // canvas
  updateSize() {
    this.colorBuffer = this.textureUtils.getColorBuffer(), this.defaultRenderPassdescriptor = null;
  }
  // utils public
  getMaxAnisotropy() {
    return 16;
  }
  hasFeature(e) {
    return this.device.features.has(e);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    let o = 0, l = 0, u = 0, c = 0, h = 0, d = 0, p = e.image.width, f = e.image.height;
    n !== null && (c = n.x, h = n.y, d = n.z || 0, p = n.width, f = n.height), s !== null && (o = s.x, l = s.y, u = s.z || 0);
    const m = this.device.createCommandEncoder({ label: "copyTextureToTexture_" + e.id + "_" + i.id }), v = this.get(e).texture, y = this.get(i).texture;
    m.copyTextureToTexture(
      {
        texture: v,
        mipLevel: a,
        origin: { x: c, y: h, z: d }
      },
      {
        texture: y,
        mipLevel: a,
        origin: { x: o, y: l, z: u }
      },
      [
        p,
        f,
        1
      ]
    ), this.device.queue.submit([m.finish()]);
  }
  copyFramebufferToTexture(e, i, n) {
    const s = this.get(i);
    let a = null;
    i.renderTarget ? e.isDepthTexture ? a = this.get(i.depthTexture).texture : a = this.get(i.textures[0]).texture : e.isDepthTexture ? a = this.textureUtils.getDepthBuffer(i.depth, i.stencil) : a = this.context.getCurrentTexture();
    const o = this.get(e).texture;
    if (a.format !== o.format) {
      console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.", a.format, o.format);
      return;
    }
    let l;
    if (s.currentPass ? (s.currentPass.end(), l = s.encoder) : l = this.device.createCommandEncoder({ label: "copyFramebufferToTexture_" + e.id }), l.copyTextureToTexture(
      {
        texture: a,
        origin: { x: n.x, y: n.y, z: 0 }
      },
      {
        texture: o
      },
      [
        n.z,
        n.w
      ]
    ), e.generateMipmaps && this.textureUtils.generateMipmaps(e), s.currentPass) {
      const { descriptor: u } = s;
      for (let c = 0; c < u.colorAttachments.length; c++)
        u.colorAttachments[c].loadOp = Oi.Load;
      i.depth && (u.depthStencilAttachment.depthLoadOp = Oi.Load), i.stencil && (u.depthStencilAttachment.stencilLoadOp = Oi.Load), s.currentPass = l.beginRenderPass(u), s.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
    } else
      this.device.queue.submit([l.finish()]);
  }
}
class vJ extends EP {
  constructor(e, i, n, s, a, o) {
    super(e, i, n, s, a, o), this.iesMap = null;
  }
  copy(e, i) {
    return super.copy(e, i), this.iesMap = e.iesMap, this;
  }
}
class bJ extends KI {
  constructor() {
    super(), this.addMaterial(_Y, bP), this.addMaterial(UI, fT), this.addMaterial(oK, vP), this.addMaterial(hK, xP), this.addMaterial(fY, Ng), this.addMaterial(bY, TP), this.addMaterial(lY, _P), this.addMaterial(mK, SP), this.addMaterial(rY, dT), this.addMaterial(sY, wP), this.addMaterial(yK, gP), this.addMaterial(_K, fP), this.addMaterial(wK, yP), this.addLight(DZ, rW), this.addLight(cQ, sW), this.addLight(hQ, oW), this.addLight($I, EP), this.addLight(pQ, aW), this.addLight(fQ, eW), this.addLight(mQ, uW), this.addLight(dQ, vJ), this.addToneMapping(sZ, I9), this.addToneMapping(aZ, O9), this.addToneMapping(oZ, D9), this.addToneMapping(uZ, L9), this.addToneMapping(pZ, U9), this.addToneMapping(fZ, k9);
  }
}
class xJ extends MQ {
  constructor(e = {}) {
    let i;
    e.forceWebGL ? i = cA : (i = yJ, e.getFallback = () => (console.warn("THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend."), new cA(e)));
    const n = new i(e);
    super(n, e), this.library = new bJ(), this.isWebGPURenderer = !0;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Cg
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Cg);
const g0 = { type: "change" }, WT = { type: "start" }, qT = { type: "end" }, pA = 1e-6, qt = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 }, Mf = new Ue(), qa = new Ue(), _J = new q(), Af = new q(), y0 = new q(), wu = new bs(), fA = new q(), Cf = new q(), v0 = new q(), Rf = new q();
class TJ extends wg {
  constructor(e, i = null) {
    super(e, i), this.enabled = !0, this.screen = { left: 0, top: 0, width: 0, height: 0 }, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = 0.3, this.noRotate = !1, this.noZoom = !1, this.noPan = !1, this.staticMoving = !1, this.dynamicDampingFactor = 0.2, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.keys = [
      "KeyA",
      "KeyS",
      "KeyD"
      /*D*/
    ], this.mouseButtons = { LEFT: ir.ROTATE, MIDDLE: ir.DOLLY, RIGHT: ir.PAN }, this.state = qt.NONE, this.keyState = qt.NONE, this.target = new q(), this._lastPosition = new q(), this._lastZoom = 1, this._touchZoomDistanceStart = 0, this._touchZoomDistanceEnd = 0, this._lastAngle = 0, this._eye = new q(), this._movePrev = new Ue(), this._moveCurr = new Ue(), this._lastAxis = new q(), this._zoomStart = new Ue(), this._zoomEnd = new Ue(), this._panStart = new Ue(), this._panEnd = new Ue(), this._pointers = [], this._pointerPositions = {}, this._onPointerMove = wJ.bind(this), this._onPointerDown = SJ.bind(this), this._onPointerUp = EJ.bind(this), this._onPointerCancel = MJ.bind(this), this._onContextMenu = OJ.bind(this), this._onMouseWheel = IJ.bind(this), this._onKeyDown = CJ.bind(this), this._onKeyUp = AJ.bind(this), this._onTouchStart = DJ.bind(this), this._onTouchMove = LJ.bind(this), this._onTouchEnd = UJ.bind(this), this._onMouseDown = RJ.bind(this), this._onMouseMove = NJ.bind(this), this._onMouseUp = PJ.bind(this), this._target0 = this.target.clone(), this._position0 = this.object.position.clone(), this._up0 = this.object.up.clone(), this._zoom0 = this.object.zoom, i !== null && (this.connect(), this.handleResize()), this.update();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown), window.addEventListener("keyup", this._onKeyUp), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  handleResize() {
    const e = this.domElement.getBoundingClientRect(), i = this.domElement.ownerDocument.documentElement;
    this.screen.left = e.left + window.pageXOffset - i.clientLeft, this.screen.top = e.top + window.pageYOffset - i.clientTop, this.screen.width = e.width, this.screen.height = e.height;
  }
  update() {
    this._eye.subVectors(this.object.position, this.target), this.noRotate || this._rotateCamera(), this.noZoom || this._zoomCamera(), this.noPan || this._panCamera(), this.object.position.addVectors(this.target, this._eye), this.object.isPerspectiveCamera ? (this._checkDistances(), this.object.lookAt(this.target), this._lastPosition.distanceToSquared(this.object.position) > pA && (this.dispatchEvent(g0), this._lastPosition.copy(this.object.position))) : this.object.isOrthographicCamera ? (this.object.lookAt(this.target), (this._lastPosition.distanceToSquared(this.object.position) > pA || this._lastZoom !== this.object.zoom) && (this.dispatchEvent(g0), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type.");
  }
  reset() {
    this.state = qt.NONE, this.keyState = qt.NONE, this.target.copy(this._target0), this.object.position.copy(this._position0), this.object.up.copy(this._up0), this.object.zoom = this._zoom0, this.object.updateProjectionMatrix(), this._eye.subVectors(this.object.position, this.target), this.object.lookAt(this.target), this.dispatchEvent(g0), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom;
  }
  _panCamera() {
    if (qa.copy(this._panEnd).sub(this._panStart), qa.lengthSq()) {
      if (this.object.isOrthographicCamera) {
        const e = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth, i = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;
        qa.x *= e, qa.y *= i;
      }
      qa.multiplyScalar(this._eye.length() * this.panSpeed), Af.copy(this._eye).cross(this.object.up).setLength(qa.x), Af.add(_J.copy(this.object.up).setLength(qa.y)), this.object.position.add(Af), this.target.add(Af), this.staticMoving ? this._panStart.copy(this._panEnd) : this._panStart.add(qa.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
    }
  }
  _rotateCamera() {
    Rf.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
    let e = Rf.length();
    e ? (this._eye.copy(this.object.position).sub(this.target), fA.copy(this._eye).normalize(), Cf.copy(this.object.up).normalize(), v0.crossVectors(Cf, fA).normalize(), Cf.setLength(this._moveCurr.y - this._movePrev.y), v0.setLength(this._moveCurr.x - this._movePrev.x), Rf.copy(Cf.add(v0)), y0.crossVectors(Rf, this._eye).normalize(), e *= this.rotateSpeed, wu.setFromAxisAngle(y0, e), this._eye.applyQuaternion(wu), this.object.up.applyQuaternion(wu), this._lastAxis.copy(y0), this._lastAngle = e) : !this.staticMoving && this._lastAngle && (this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor), this._eye.copy(this.object.position).sub(this.target), wu.setFromAxisAngle(this._lastAxis, this._lastAngle), this._eye.applyQuaternion(wu), this.object.up.applyQuaternion(wu)), this._movePrev.copy(this._moveCurr);
  }
  _zoomCamera() {
    let e;
    this.state === qt.TOUCH_ZOOM_PAN ? (e = this._touchZoomDistanceStart / this._touchZoomDistanceEnd, this._touchZoomDistanceStart = this._touchZoomDistanceEnd, this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = Ib.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (e = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed, e !== 1 && e > 0 && (this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = Ib.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")), this.staticMoving ? this._zoomStart.copy(this._zoomEnd) : this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor);
  }
  _getMouseOnScreen(e, i) {
    return Mf.set(
      (e - this.screen.left) / this.screen.width,
      (i - this.screen.top) / this.screen.height
    ), Mf;
  }
  _getMouseOnCircle(e, i) {
    return Mf.set(
      (e - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5),
      (this.screen.height + 2 * (this.screen.top - i)) / this.screen.width
      // screen.width intentional
    ), Mf;
  }
  _addPointer(e) {
    this._pointers.push(e);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i].pointerId == e.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
  }
  _trackPointer(e) {
    let i = this._pointerPositions[e.pointerId];
    i === void 0 && (i = new Ue(), this._pointerPositions[e.pointerId] = i), i.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const i = e.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[i.pointerId];
  }
  _checkDistances() {
    (!this.noZoom || !this.noPan) && (this._eye.lengthSq() > this.maxDistance * this.maxDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance)), this._zoomStart.copy(this._zoomEnd)), this._eye.lengthSq() < this.minDistance * this.minDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance)), this._zoomStart.copy(this._zoomEnd)));
  }
}
function SJ(r) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(r.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), this._addPointer(r), r.pointerType === "touch" ? this._onTouchStart(r) : this._onMouseDown(r));
}
function wJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchMove(r) : this._onMouseMove(r));
}
function EJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchEnd(r) : this._onMouseUp(), this._removePointer(r), this._pointers.length === 0 && (this.domElement.releasePointerCapture(r.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp)));
}
function MJ(r) {
  this._removePointer(r);
}
function AJ() {
  this.enabled !== !1 && (this.keyState = qt.NONE, window.addEventListener("keydown", this._onKeyDown));
}
function CJ(r) {
  this.enabled !== !1 && (window.removeEventListener("keydown", this._onKeyDown), this.keyState === qt.NONE && (r.code === this.keys[qt.ROTATE] && !this.noRotate ? this.keyState = qt.ROTATE : r.code === this.keys[qt.ZOOM] && !this.noZoom ? this.keyState = qt.ZOOM : r.code === this.keys[qt.PAN] && !this.noPan && (this.keyState = qt.PAN)));
}
function RJ(r) {
  let e;
  switch (r.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case ir.DOLLY:
      this.state = qt.ZOOM;
      break;
    case ir.ROTATE:
      this.state = qt.ROTATE;
      break;
    case ir.PAN:
      this.state = qt.PAN;
      break;
    default:
      this.state = qt.NONE;
  }
  const i = this.keyState !== qt.NONE ? this.keyState : this.state;
  i === qt.ROTATE && !this.noRotate ? (this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY)), this._movePrev.copy(this._moveCurr)) : i === qt.ZOOM && !this.noZoom ? (this._zoomStart.copy(this._getMouseOnScreen(r.pageX, r.pageY)), this._zoomEnd.copy(this._zoomStart)) : i === qt.PAN && !this.noPan && (this._panStart.copy(this._getMouseOnScreen(r.pageX, r.pageY)), this._panEnd.copy(this._panStart)), this.dispatchEvent(WT);
}
function NJ(r) {
  const e = this.keyState !== qt.NONE ? this.keyState : this.state;
  e === qt.ROTATE && !this.noRotate ? (this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY))) : e === qt.ZOOM && !this.noZoom ? this._zoomEnd.copy(this._getMouseOnScreen(r.pageX, r.pageY)) : e === qt.PAN && !this.noPan && this._panEnd.copy(this._getMouseOnScreen(r.pageX, r.pageY));
}
function PJ() {
  this.state = qt.NONE, this.dispatchEvent(qT);
}
function IJ(r) {
  if (this.enabled !== !1 && this.noZoom !== !0) {
    switch (r.preventDefault(), r.deltaMode) {
      case 2:
        this._zoomStart.y -= r.deltaY * 0.025;
        break;
      case 1:
        this._zoomStart.y -= r.deltaY * 0.01;
        break;
      default:
        this._zoomStart.y -= r.deltaY * 25e-5;
        break;
    }
    this.dispatchEvent(WT), this.dispatchEvent(qT);
  }
}
function OJ(r) {
  this.enabled !== !1 && r.preventDefault();
}
function DJ(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      this.state = qt.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY)), this._movePrev.copy(this._moveCurr);
      break;
    default:
      this.state = qt.TOUCH_ZOOM_PAN;
      const e = this._pointers[0].pageX - this._pointers[1].pageX, i = this._pointers[0].pageY - this._pointers[1].pageY;
      this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(e * e + i * i);
      const n = (this._pointers[0].pageX + this._pointers[1].pageX) / 2, s = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;
      this._panStart.copy(this._getMouseOnScreen(n, s)), this._panEnd.copy(this._panStart);
      break;
  }
  this.dispatchEvent(WT);
}
function LJ(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY));
      break;
    default:
      const e = this._getSecondPointerPosition(r), i = r.pageX - e.x, n = r.pageY - e.y;
      this._touchZoomDistanceEnd = Math.sqrt(i * i + n * n);
      const s = (r.pageX + e.x) / 2, a = (r.pageY + e.y) / 2;
      this._panEnd.copy(this._getMouseOnScreen(s, a));
      break;
  }
}
function UJ(r) {
  switch (this._pointers.length) {
    case 0:
      this.state = qt.NONE;
      break;
    case 1:
      this.state = qt.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY)), this._movePrev.copy(this._moveCurr);
      break;
    case 2:
      this.state = qt.TOUCH_ZOOM_PAN;
      for (let e = 0; e < this._pointers.length; e++)
        if (this._pointers[e].pointerId !== r.pointerId) {
          const i = this._pointerPositions[this._pointers[e].pointerId];
          this._moveCurr.copy(this._getMouseOnCircle(i.x, i.y)), this._movePrev.copy(this._moveCurr);
          break;
        }
      break;
  }
  this.dispatchEvent(qT);
}
const mA = { type: "change" }, XT = { type: "start" }, sO = { type: "end" }, Nf = new xg(), gA = new Xs(), kJ = Math.cos(70 * Ib.DEG2RAD), Gi = new q(), Or = 2 * Math.PI, ei = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
}, b0 = 1e-6;
class FJ extends wg {
  constructor(e, i = null) {
    super(e, i), this.state = ei.NONE, this.enabled = !0, this.target = new q(), this.cursor = new q(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: ir.ROTATE, MIDDLE: ir.DOLLY, RIGHT: ir.PAN }, this.touches = { ONE: ra.ROTATE, TWO: ra.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new q(), this._lastQuaternion = new bs(), this._lastTargetPosition = new q(), this._quat = new bs().setFromUnitVectors(e.up, new q(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new Aw(), this._sphericalDelta = new Aw(), this._scale = 1, this._panOffset = new q(), this._rotateStart = new Ue(), this._rotateEnd = new Ue(), this._rotateDelta = new Ue(), this._panStart = new Ue(), this._panEnd = new Ue(), this._panDelta = new Ue(), this._dollyStart = new Ue(), this._dollyEnd = new Ue(), this._dollyDelta = new Ue(), this._dollyDirection = new q(), this._mouse = new Ue(), this._performCursorZoom = !1, this._pointers = [], this._pointerPositions = {}, this._controlActive = !1, this._onPointerMove = zJ.bind(this), this._onPointerDown = BJ.bind(this), this._onPointerUp = jJ.bind(this), this._onContextMenu = $J.bind(this), this._onMouseWheel = HJ.bind(this), this._onKeyDown = WJ.bind(this), this._onTouchStart = qJ.bind(this), this._onTouchMove = XJ.bind(this), this._onMouseDown = VJ.bind(this), this._onMouseMove = GJ.bind(this), this._interceptControlDown = YJ.bind(this), this._interceptControlUp = KJ.bind(this), this.domElement !== null && this.connect(), this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, { passive: !0, capture: !0 }), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, { capture: !0 }), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
  }
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
  }
  saveState() {
    this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(mA), this.update(), this.state = ei.NONE;
  }
  update(e = null) {
    const i = this.object.position;
    Gi.copy(i).sub(this.target), Gi.applyQuaternion(this._quat), this._spherical.setFromVector3(Gi), this.autoRotate && this.state === ei.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
    let n = this.minAzimuthAngle, s = this.maxAzimuthAngle;
    isFinite(n) && isFinite(s) && (n < -Math.PI ? n += Or : n > Math.PI && (n -= Or), s < -Math.PI ? s += Or : s > Math.PI && (s -= Or), n <= s ? this._spherical.theta = Math.max(n, Math.min(s, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (n + s) / 2 ? Math.max(n, this._spherical.theta) : Math.min(s, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
    let a = !1;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const o = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), a = o != this._spherical.radius;
    }
    if (Gi.setFromSpherical(this._spherical), Gi.applyQuaternion(this._quatInverse), i.copy(this.target).add(Gi), this.object.lookAt(this.target), this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
      let o = null;
      if (this.object.isPerspectiveCamera) {
        const l = Gi.length();
        o = this._clampDistance(l * this._scale);
        const u = l - o;
        this.object.position.addScaledVector(this._dollyDirection, u), this.object.updateMatrixWorld(), a = !!u;
      } else if (this.object.isOrthographicCamera) {
        const l = new q(this._mouse.x, this._mouse.y, 0);
        l.unproject(this.object);
        const u = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), a = u !== this.object.zoom;
        const c = new q(this._mouse.x, this._mouse.y, 0);
        c.unproject(this.object), this.object.position.sub(c).add(l), this.object.updateMatrixWorld(), o = Gi.length();
      } else
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = !1;
      o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : (Nf.origin.copy(this.object.position), Nf.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(Nf.direction)) < kJ ? this.object.lookAt(this.target) : (gA.setFromNormalAndCoplanarPoint(this.object.up, this.target), Nf.intersectPlane(gA, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const o = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), o !== this.object.zoom && (this.object.updateProjectionMatrix(), a = !0);
    }
    return this._scale = 1, this._performCursorZoom = !1, a || this._lastPosition.distanceToSquared(this.object.position) > b0 || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > b0 || this._lastTargetPosition.distanceToSquared(this.target) > b0 ? (this.dispatchEvent(mA), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), !0) : !1;
  }
  _getAutoRotationAngle(e) {
    return e !== null ? Or / 60 * this.autoRotateSpeed * e : Or / 60 / 60 * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const i = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * i);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, i) {
    Gi.setFromMatrixColumn(i, 0), Gi.multiplyScalar(-e), this._panOffset.add(Gi);
  }
  _panUp(e, i) {
    this.screenSpacePanning === !0 ? Gi.setFromMatrixColumn(i, 1) : (Gi.setFromMatrixColumn(i, 0), Gi.crossVectors(this.object.up, Gi)), Gi.multiplyScalar(e), this._panOffset.add(Gi);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(e, i) {
    const n = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const s = this.object.position;
      Gi.copy(s).sub(this.target);
      let a = Gi.length();
      a *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * a / n.clientHeight, this.object.matrix), this._panUp(2 * i * a / n.clientHeight, this.object.matrix);
    } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / n.clientWidth, this.object.matrix), this._panUp(i * (this.object.top - this.object.bottom) / this.object.zoom / n.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = !1);
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _updateZoomParameters(e, i) {
    if (!this.zoomToCursor)
      return;
    this._performCursorZoom = !0;
    const n = this.domElement.getBoundingClientRect(), s = e - n.left, a = i - n.top, o = n.width, l = n.height;
    this._mouse.x = s / o * 2 - 1, this._mouse.y = -(a / l) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const i = this.domElement;
    this._rotateLeft(Or * this._rotateDelta.x / i.clientHeight), this._rotateUp(Or * this._rotateDelta.y / i.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
  }
  _handleKeyDown(e) {
    let i = !1;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(Or * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, this.keyPanSpeed), i = !0;
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(-Or * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, -this.keyPanSpeed), i = !0;
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(Or * this.rotateSpeed / this.domElement.clientHeight) : this._pan(this.keyPanSpeed, 0), i = !0;
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(-Or * this.rotateSpeed / this.domElement.clientHeight) : this._pan(-this.keyPanSpeed, 0), i = !0;
        break;
    }
    i && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1)
      this._rotateStart.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._rotateStart.set(n, s);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1)
      this._panStart.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._panStart.set(n, s);
    }
  }
  _handleTouchStartDolly(e) {
    const i = this._getSecondPointerPosition(e), n = e.pageX - i.x, s = e.pageY - i.y, a = Math.sqrt(n * n + s * s);
    this._dollyStart.set(0, a);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1)
      this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const n = this._getSecondPointerPosition(e), s = 0.5 * (e.pageX + n.x), a = 0.5 * (e.pageY + n.y);
      this._rotateEnd.set(s, a);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const i = this.domElement;
    this._rotateLeft(Or * this._rotateDelta.x / i.clientHeight), this._rotateUp(Or * this._rotateDelta.y / i.clientHeight), this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1)
      this._panEnd.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._panEnd.set(n, s);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const i = this._getSecondPointerPosition(e), n = e.pageX - i.x, s = e.pageY - i.y, a = Math.sqrt(n * n + s * s);
    this._dollyEnd.set(0, a), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
    const o = (e.pageX + i.x) * 0.5, l = (e.pageY + i.y) * 0.5;
    this._updateZoomParameters(o, l);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
  }
  // pointers
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i] == e.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
  }
  _isTrackingPointer(e) {
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i] == e.pointerId) return !0;
    return !1;
  }
  _trackPointer(e) {
    let i = this._pointerPositions[e.pointerId];
    i === void 0 && (i = new Ue(), this._pointerPositions[e.pointerId] = i), i.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const i = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[i];
  }
  //
  _customWheelEvent(e) {
    const i = e.deltaMode, n = {
      clientX: e.clientX,
      clientY: e.clientY,
      deltaY: e.deltaY
    };
    switch (i) {
      case 1:
        n.deltaY *= 16;
        break;
      case 2:
        n.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (n.deltaY *= 10), n;
  }
}
function BJ(r) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(r.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(r) && (this._addPointer(r), r.pointerType === "touch" ? this._onTouchStart(r) : this._onMouseDown(r)));
}
function zJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchMove(r) : this._onMouseMove(r));
}
function jJ(r) {
  switch (this._removePointer(r), this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(r.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(sO), this.state = ei.NONE;
      break;
    case 1:
      const e = this._pointers[0], i = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: i.x, pageY: i.y });
      break;
  }
}
function VJ(r) {
  let e;
  switch (r.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case ir.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseDownDolly(r), this.state = ei.DOLLY;
      break;
    case ir.ROTATE:
      if (r.ctrlKey || r.metaKey || r.shiftKey) {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(r), this.state = ei.PAN;
      } else {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(r), this.state = ei.ROTATE;
      }
      break;
    case ir.PAN:
      if (r.ctrlKey || r.metaKey || r.shiftKey) {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(r), this.state = ei.ROTATE;
      } else {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(r), this.state = ei.PAN;
      }
      break;
    default:
      this.state = ei.NONE;
  }
  this.state !== ei.NONE && this.dispatchEvent(XT);
}
function GJ(r) {
  switch (this.state) {
    case ei.ROTATE:
      if (this.enableRotate === !1) return;
      this._handleMouseMoveRotate(r);
      break;
    case ei.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseMoveDolly(r);
      break;
    case ei.PAN:
      if (this.enablePan === !1) return;
      this._handleMouseMovePan(r);
      break;
  }
}
function HJ(r) {
  this.enabled === !1 || this.enableZoom === !1 || this.state !== ei.NONE || (r.preventDefault(), this.dispatchEvent(XT), this._handleMouseWheel(this._customWheelEvent(r)), this.dispatchEvent(sO));
}
function WJ(r) {
  this.enabled === !1 || this.enablePan === !1 || this._handleKeyDown(r);
}
function qJ(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case ra.ROTATE:
          if (this.enableRotate === !1) return;
          this._handleTouchStartRotate(r), this.state = ei.TOUCH_ROTATE;
          break;
        case ra.PAN:
          if (this.enablePan === !1) return;
          this._handleTouchStartPan(r), this.state = ei.TOUCH_PAN;
          break;
        default:
          this.state = ei.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case ra.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1) return;
          this._handleTouchStartDollyPan(r), this.state = ei.TOUCH_DOLLY_PAN;
          break;
        case ra.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1) return;
          this._handleTouchStartDollyRotate(r), this.state = ei.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = ei.NONE;
      }
      break;
    default:
      this.state = ei.NONE;
  }
  this.state !== ei.NONE && this.dispatchEvent(XT);
}
function XJ(r) {
  switch (this._trackPointer(r), this.state) {
    case ei.TOUCH_ROTATE:
      if (this.enableRotate === !1) return;
      this._handleTouchMoveRotate(r), this.update();
      break;
    case ei.TOUCH_PAN:
      if (this.enablePan === !1) return;
      this._handleTouchMovePan(r), this.update();
      break;
    case ei.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1) return;
      this._handleTouchMoveDollyPan(r), this.update();
      break;
    case ei.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1) return;
      this._handleTouchMoveDollyRotate(r), this.update();
      break;
    default:
      this.state = ei.NONE;
  }
}
function $J(r) {
  this.enabled !== !1 && r.preventDefault();
}
function YJ(r) {
  r.key === "Control" && (this._controlActive = !0, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
function KJ(r) {
  r.key === "Control" && (this._controlActive = !1, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
const ZJ = { type: "change" }, yA = 1e-6, vA = new bs();
class QJ extends wg {
  constructor(e, i = null) {
    super(e, i), this.movementSpeed = 1, this.rollSpeed = 5e-3, this.dragToLook = !1, this.autoForward = !1, this._moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 }, this._moveVector = new q(0, 0, 0), this._rotationVector = new q(0, 0, 0), this._lastQuaternion = new bs(), this._lastPosition = new q(), this._status = 0, this._onKeyDown = JJ.bind(this), this._onKeyUp = eee.bind(this), this._onPointerMove = iee.bind(this), this._onPointerDown = tee.bind(this), this._onPointerUp = ree.bind(this), this._onPointerCancel = nee.bind(this), this._onContextMenu = see.bind(this), i !== null && this.connect();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown), window.addEventListener("keyup", this._onKeyUp), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("contextmenu", this._onContextMenu);
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("contextmenu", this._onContextMenu);
  }
  dispose() {
    this.disconnect();
  }
  update(e) {
    if (this.enabled === !1) return;
    const i = this.object, n = e * this.movementSpeed, s = e * this.rollSpeed;
    i.translateX(this._moveVector.x * n), i.translateY(this._moveVector.y * n), i.translateZ(this._moveVector.z * n), vA.set(this._rotationVector.x * s, this._rotationVector.y * s, this._rotationVector.z * s, 1).normalize(), i.quaternion.multiply(vA), (this._lastPosition.distanceToSquared(i.position) > yA || 8 * (1 - this._lastQuaternion.dot(i.quaternion)) > yA) && (this.dispatchEvent(ZJ), this._lastQuaternion.copy(i.quaternion), this._lastPosition.copy(i.position));
  }
  // private
  _updateMovementVector() {
    const e = this._moveState.forward || this.autoForward && !this._moveState.back ? 1 : 0;
    this._moveVector.x = -this._moveState.left + this._moveState.right, this._moveVector.y = -this._moveState.down + this._moveState.up, this._moveVector.z = -e + this._moveState.back;
  }
  _updateRotationVector() {
    this._rotationVector.x = -this._moveState.pitchDown + this._moveState.pitchUp, this._rotationVector.y = -this._moveState.yawRight + this._moveState.yawLeft, this._rotationVector.z = -this._moveState.rollRight + this._moveState.rollLeft;
  }
  _getContainerDimensions() {
    return this.domElement != document ? {
      size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
      offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
    } : {
      size: [window.innerWidth, window.innerHeight],
      offset: [0, 0]
    };
  }
}
function JJ(r) {
  if (!(r.altKey || this.enabled === !1)) {
    switch (r.code) {
      case "ShiftLeft":
      case "ShiftRight":
        this.movementSpeedMultiplier = 0.1;
        break;
      case "KeyW":
        this._moveState.forward = 1;
        break;
      case "KeyS":
        this._moveState.back = 1;
        break;
      case "KeyA":
        this._moveState.left = 1;
        break;
      case "KeyD":
        this._moveState.right = 1;
        break;
      case "KeyR":
        this._moveState.up = 1;
        break;
      case "KeyF":
        this._moveState.down = 1;
        break;
      case "ArrowUp":
        this._moveState.pitchUp = 1;
        break;
      case "ArrowDown":
        this._moveState.pitchDown = 1;
        break;
      case "ArrowLeft":
        this._moveState.yawLeft = 1;
        break;
      case "ArrowRight":
        this._moveState.yawRight = 1;
        break;
      case "KeyQ":
        this._moveState.rollLeft = 1;
        break;
      case "KeyE":
        this._moveState.rollRight = 1;
        break;
    }
    this._updateMovementVector(), this._updateRotationVector();
  }
}
function eee(r) {
  if (this.enabled !== !1) {
    switch (r.code) {
      case "ShiftLeft":
      case "ShiftRight":
        this.movementSpeedMultiplier = 1;
        break;
      case "KeyW":
        this._moveState.forward = 0;
        break;
      case "KeyS":
        this._moveState.back = 0;
        break;
      case "KeyA":
        this._moveState.left = 0;
        break;
      case "KeyD":
        this._moveState.right = 0;
        break;
      case "KeyR":
        this._moveState.up = 0;
        break;
      case "KeyF":
        this._moveState.down = 0;
        break;
      case "ArrowUp":
        this._moveState.pitchUp = 0;
        break;
      case "ArrowDown":
        this._moveState.pitchDown = 0;
        break;
      case "ArrowLeft":
        this._moveState.yawLeft = 0;
        break;
      case "ArrowRight":
        this._moveState.yawRight = 0;
        break;
      case "KeyQ":
        this._moveState.rollLeft = 0;
        break;
      case "KeyE":
        this._moveState.rollRight = 0;
        break;
    }
    this._updateMovementVector(), this._updateRotationVector();
  }
}
function tee(r) {
  if (this.enabled !== !1)
    if (this.dragToLook)
      this._status++;
    else {
      switch (r.button) {
        case 0:
          this._moveState.forward = 1;
          break;
        case 2:
          this._moveState.back = 1;
          break;
      }
      this._updateMovementVector();
    }
}
function iee(r) {
  if (this.enabled !== !1 && (!this.dragToLook || this._status > 0)) {
    const e = this._getContainerDimensions(), i = e.size[0] / 2, n = e.size[1] / 2;
    this._moveState.yawLeft = -(r.pageX - e.offset[0] - i) / i, this._moveState.pitchDown = (r.pageY - e.offset[1] - n) / n, this._updateRotationVector();
  }
}
function ree(r) {
  if (this.enabled !== !1) {
    if (this.dragToLook)
      this._status--, this._moveState.yawLeft = this._moveState.pitchDown = 0;
    else {
      switch (r.button) {
        case 0:
          this._moveState.forward = 0;
          break;
        case 2:
          this._moveState.back = 0;
          break;
      }
      this._updateMovementVector();
    }
    this._updateRotationVector();
  }
}
function nee() {
  this.enabled !== !1 && (this.dragToLook ? (this._status = 0, this._moveState.yawLeft = this._moveState.pitchDown = 0) : (this._moveState.forward = 0, this._moveState.back = 0, this._updateMovementVector()), this._updateRotationVector());
}
function see(r) {
  this.enabled !== !1 && r.preventDefault();
}
const aee = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class Gg {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const oee = new I_(-1, 1, 1, -1, 0, 1);
class lee extends cn {
  constructor() {
    super(), this.setAttribute("position", new Ri([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Ri([0, 2, 0, 0, 2, 0], 2));
  }
}
const uee = new lee();
class cee {
  constructor(e) {
    this._mesh = new Ur(uee, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, oee);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class hee extends Gg {
  constructor(e, i) {
    super(), this.textureID = i !== void 0 ? i : "tDiffuse", e instanceof xs ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = sR.clone(e.uniforms), this.material = new xs({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new cee(this.material);
  }
  render(e, i, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(i), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class bA extends Gg {
  constructor(e, i) {
    super(), this.scene = e, this.camera = i, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, i, n) {
    const s = e.getContext(), a = e.state;
    a.buffers.color.setMask(!1), a.buffers.depth.setMask(!1), a.buffers.color.setLocked(!0), a.buffers.depth.setLocked(!0);
    let o, l;
    this.inverse ? (o = 0, l = 1) : (o = 1, l = 0), a.buffers.stencil.setTest(!0), a.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), a.buffers.stencil.setFunc(s.ALWAYS, o, 4294967295), a.buffers.stencil.setClear(l), a.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), a.buffers.color.setLocked(!1), a.buffers.depth.setLocked(!1), a.buffers.color.setMask(!0), a.buffers.depth.setMask(!0), a.buffers.stencil.setLocked(!1), a.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), a.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), a.buffers.stencil.setLocked(!0);
  }
}
class dee extends Gg {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class pee {
  constructor(e, i) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), i === void 0) {
      const n = e.getSize(new Ue());
      this._width = n.width, this._height = n.height, i = new go(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: Dc }), i.texture.name = "EffectComposer.rt1";
    } else
      this._width = i.width, this._height = i.height;
    this.renderTarget1 = i, this.renderTarget2 = i.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new hee(aee), this.copyPass.material.blending = ua, this.clock = new TR();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, i) {
    this.passes.splice(i, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const i = this.passes.indexOf(e);
    i !== -1 && this.passes.splice(i, 1);
  }
  isLastEnabledPass(e) {
    for (let i = e + 1; i < this.passes.length; i++)
      if (this.passes[i].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const i = this.renderer.getRenderTarget();
    let n = !1;
    for (let s = 0, a = this.passes.length; s < a; s++) {
      const o = this.passes[s];
      if (o.enabled !== !1) {
        if (o.renderToScreen = this.renderToScreen && this.isLastEnabledPass(s), o.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), o.needsSwap) {
          if (n) {
            const l = this.renderer.getContext(), u = this.renderer.state.buffers.stencil;
            u.setFunc(l.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), u.setFunc(l.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        bA !== void 0 && (o instanceof bA ? n = !0 : o instanceof dee && (n = !1));
      }
    }
    this.renderer.setRenderTarget(i);
  }
  reset(e) {
    if (e === void 0) {
      const i = this.renderer.getSize(new Ue());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = i.width, this._height = i.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, i) {
    this._width = e, this._height = i;
    const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, s), this.renderTarget2.setSize(n, s);
    for (let a = 0; a < this.passes.length; a++)
      this.passes[a].setSize(n, s);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class fee extends Gg {
  constructor(e, i, n = null, s = null, a = null) {
    super(), this.scene = e, this.camera = i, this.overrideMaterial = n, this.clearColor = s, this.clearAlpha = a, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new kt();
  }
  render(e, i, n) {
    const s = e.autoClear;
    e.autoClear = !1;
    let a, o;
    this.overrideMaterial !== null && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (a = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(a), this.overrideMaterial !== null && (this.scene.overrideMaterial = o), e.autoClear = s;
  }
}
function Wr() {
  return Wr = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i) ({}).hasOwnProperty.call(i, n) && (r[n] = i[n]);
    }
    return r;
  }, Wr.apply(null, arguments);
}
function mee(r) {
  if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function Cd(r, e) {
  return Cd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Cd(r, e);
}
function gee(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Cd(r, e);
}
function Dx(r) {
  return Dx = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Dx(r);
}
function yee(r) {
  try {
    return Function.toString.call(r).indexOf("[native code]") !== -1;
  } catch {
    return typeof r == "function";
  }
}
function aO() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (aO = function() {
    return !!r;
  })();
}
function vee(r, e, i) {
  if (aO()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return i && Cd(s, i.prototype), s;
}
function Lx(r) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Lx = function(i) {
    if (i === null || !yee(i)) return i;
    if (typeof i != "function") throw new TypeError("Super expression must either be null or a function");
    if (e !== void 0) {
      if (e.has(i)) return e.get(i);
      e.set(i, n);
    }
    function n() {
      return vee(i, arguments, Dx(this).constructor);
    }
    return n.prototype = Object.create(i.prototype, {
      constructor: {
        value: n,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Cd(n, i);
  }, Lx(r);
}
var bee = {
  1: `Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).

`,
  2: `Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).

`,
  3: `Passed an incorrect argument to a color function, please pass a string representation of a color.

`,
  4: `Couldn't generate valid rgb string from %s, it returned %s.

`,
  5: `Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.

`,
  6: `Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).

`,
  7: `Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).

`,
  8: `Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.

`,
  9: `Please provide a number of steps to the modularScale helper.

`,
  10: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
  11: `Invalid value passed as base to modularScale, expected number or em string but got "%s"

`,
  12: `Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.

`,
  13: `Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.

`,
  14: `Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.

`,
  15: `Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.

`,
  16: `You must provide a template to this method.

`,
  17: `You passed an unsupported selector state to this method.

`,
  18: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
  19: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
  20: `expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
  21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  23: `fontFace expects a name of a font-family.

`,
  24: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
  25: `fontFace expects localFonts to be an array.

`,
  26: `fontFace expects fileFormats to be an array.

`,
  27: `radialGradient requries at least 2 color-stops to properly render.

`,
  28: `Please supply a filename to retinaImage() as the first argument.

`,
  29: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
  30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  31: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation

`,
  32: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])
To pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')

`,
  33: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation

`,
  34: `borderRadius expects a radius value as a string or number as the second argument.

`,
  35: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
  36: `Property must be a string value.

`,
  37: `Syntax Error at %s.

`,
  38: `Formula contains a function that needs parentheses at %s.

`,
  39: `Formula is missing closing parenthesis at %s.

`,
  40: `Formula has too many closing parentheses at %s.

`,
  41: `All values in a formula must have the same unit or be unitless.

`,
  42: `Please provide a number of steps to the modularScale helper.

`,
  43: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
  44: `Invalid value passed as base to modularScale, expected number or em/rem string but got %s.

`,
  45: `Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.

`,
  46: `Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.

`,
  47: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
  48: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
  49: `Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
  50: `Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.

`,
  51: `Expects the first argument object to have the properties prop, fromSize, and toSize.

`,
  52: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
  53: `fontFace expects localFonts to be an array.

`,
  54: `fontFace expects fileFormats to be an array.

`,
  55: `fontFace expects a name of a font-family.

`,
  56: `linearGradient requries at least 2 color-stops to properly render.

`,
  57: `radialGradient requries at least 2 color-stops to properly render.

`,
  58: `Please supply a filename to retinaImage() as the first argument.

`,
  59: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
  60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  61: `Property must be a string value.

`,
  62: `borderRadius expects a radius value as a string or number as the second argument.

`,
  63: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
  64: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.

`,
  65: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').

`,
  66: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.

`,
  67: `You must provide a template to this method.

`,
  68: `You passed an unsupported selector state to this method.

`,
  69: `Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.

`,
  70: `Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.

`,
  71: `Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.

`,
  72: `Passed invalid base value %s to %s(), please pass a value like "12px" or 12.

`,
  73: `Please provide a valid CSS variable.

`,
  74: `CSS variable not found and no default was provided.

`,
  75: `important requires a valid style object, got a %s instead.

`,
  76: `fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.

`,
  77: `remToPx expects a value in "rem" but you provided it in "%s".

`,
  78: `base must be set in "px" or "%" but you set it in "%s".
`
};
function xee() {
  for (var r = arguments.length, e = new Array(r), i = 0; i < r; i++)
    e[i] = arguments[i];
  var n = e[0], s = [], a;
  for (a = 1; a < e.length; a += 1)
    s.push(e[a]);
  return s.forEach(function(o) {
    n = n.replace(/%[a-z]/, o);
  }), n;
}
var ms = /* @__PURE__ */ function(r) {
  gee(e, r);
  function e(i) {
    var n;
    if (process.env.NODE_ENV === "production")
      n = r.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + i + " for more information.") || this;
    else {
      for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), o = 1; o < s; o++)
        a[o - 1] = arguments[o];
      n = r.call(this, xee.apply(void 0, [bee[i]].concat(a))) || this;
    }
    return mee(n);
  }
  return e;
}(/* @__PURE__ */ Lx(Error));
function x0(r) {
  return Math.round(r * 255);
}
function _ee(r, e, i) {
  return x0(r) + "," + x0(e) + "," + x0(i);
}
function Xm(r, e, i, n) {
  if (n === void 0 && (n = _ee), e === 0)
    return n(i, i, i);
  var s = (r % 360 + 360) % 360 / 60, a = (1 - Math.abs(2 * i - 1)) * e, o = a * (1 - Math.abs(s % 2 - 1)), l = 0, u = 0, c = 0;
  s >= 0 && s < 1 ? (l = a, u = o) : s >= 1 && s < 2 ? (l = o, u = a) : s >= 2 && s < 3 ? (u = a, c = o) : s >= 3 && s < 4 ? (u = o, c = a) : s >= 4 && s < 5 ? (l = o, c = a) : s >= 5 && s < 6 && (l = a, c = o);
  var h = i - a / 2, d = l + h, p = u + h, f = c + h;
  return n(d, p, f);
}
var xA = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function Tee(r) {
  if (typeof r != "string") return r;
  var e = r.toLowerCase();
  return xA[e] ? "#" + xA[e] : r;
}
var See = /^#[a-fA-F0-9]{6}$/, wee = /^#[a-fA-F0-9]{8}$/, Eee = /^#[a-fA-F0-9]{3}$/, Mee = /^#[a-fA-F0-9]{4}$/, _0 = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i, Aee = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i, Cee = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, Ree = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function Ac(r) {
  if (typeof r != "string")
    throw new ms(3);
  var e = Tee(r);
  if (e.match(See))
    return {
      red: parseInt("" + e[1] + e[2], 16),
      green: parseInt("" + e[3] + e[4], 16),
      blue: parseInt("" + e[5] + e[6], 16)
    };
  if (e.match(wee)) {
    var i = parseFloat((parseInt("" + e[7] + e[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + e[1] + e[2], 16),
      green: parseInt("" + e[3] + e[4], 16),
      blue: parseInt("" + e[5] + e[6], 16),
      alpha: i
    };
  }
  if (e.match(Eee))
    return {
      red: parseInt("" + e[1] + e[1], 16),
      green: parseInt("" + e[2] + e[2], 16),
      blue: parseInt("" + e[3] + e[3], 16)
    };
  if (e.match(Mee)) {
    var n = parseFloat((parseInt("" + e[4] + e[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + e[1] + e[1], 16),
      green: parseInt("" + e[2] + e[2], 16),
      blue: parseInt("" + e[3] + e[3], 16),
      alpha: n
    };
  }
  var s = _0.exec(e);
  if (s)
    return {
      red: parseInt("" + s[1], 10),
      green: parseInt("" + s[2], 10),
      blue: parseInt("" + s[3], 10)
    };
  var a = Aee.exec(e.substring(0, 50));
  if (a)
    return {
      red: parseInt("" + a[1], 10),
      green: parseInt("" + a[2], 10),
      blue: parseInt("" + a[3], 10),
      alpha: parseFloat("" + a[4]) > 1 ? parseFloat("" + a[4]) / 100 : parseFloat("" + a[4])
    };
  var o = Cee.exec(e);
  if (o) {
    var l = parseInt("" + o[1], 10), u = parseInt("" + o[2], 10) / 100, c = parseInt("" + o[3], 10) / 100, h = "rgb(" + Xm(l, u, c) + ")", d = _0.exec(h);
    if (!d)
      throw new ms(4, e, h);
    return {
      red: parseInt("" + d[1], 10),
      green: parseInt("" + d[2], 10),
      blue: parseInt("" + d[3], 10)
    };
  }
  var p = Ree.exec(e.substring(0, 50));
  if (p) {
    var f = parseInt("" + p[1], 10), m = parseInt("" + p[2], 10) / 100, v = parseInt("" + p[3], 10) / 100, y = "rgb(" + Xm(f, m, v) + ")", g = _0.exec(y);
    if (!g)
      throw new ms(4, e, y);
    return {
      red: parseInt("" + g[1], 10),
      green: parseInt("" + g[2], 10),
      blue: parseInt("" + g[3], 10),
      alpha: parseFloat("" + p[4]) > 1 ? parseFloat("" + p[4]) / 100 : parseFloat("" + p[4])
    };
  }
  throw new ms(5);
}
function Nee(r) {
  var e = r.red / 255, i = r.green / 255, n = r.blue / 255, s = Math.max(e, i, n), a = Math.min(e, i, n), o = (s + a) / 2;
  if (s === a)
    return r.alpha !== void 0 ? {
      hue: 0,
      saturation: 0,
      lightness: o,
      alpha: r.alpha
    } : {
      hue: 0,
      saturation: 0,
      lightness: o
    };
  var l, u = s - a, c = o > 0.5 ? u / (2 - s - a) : u / (s + a);
  switch (s) {
    case e:
      l = (i - n) / u + (i < n ? 6 : 0);
      break;
    case i:
      l = (n - e) / u + 2;
      break;
    default:
      l = (e - i) / u + 4;
      break;
  }
  return l *= 60, r.alpha !== void 0 ? {
    hue: l,
    saturation: c,
    lightness: o,
    alpha: r.alpha
  } : {
    hue: l,
    saturation: c,
    lightness: o
  };
}
function wo(r) {
  return Nee(Ac(r));
}
var Pee = function(r) {
  return r.length === 7 && r[1] === r[2] && r[3] === r[4] && r[5] === r[6] ? "#" + r[1] + r[3] + r[5] : r;
}, Ux = Pee;
function qo(r) {
  var e = r.toString(16);
  return e.length === 1 ? "0" + e : e;
}
function T0(r) {
  return qo(Math.round(r * 255));
}
function Iee(r, e, i) {
  return Ux("#" + T0(r) + T0(e) + T0(i));
}
function oO(r, e, i) {
  return Xm(r, e, i, Iee);
}
function Oee(r, e, i) {
  if (typeof r == "object" && e === void 0 && i === void 0)
    return oO(r.hue, r.saturation, r.lightness);
  throw new ms(1);
}
function Dee(r, e, i, n) {
  if (typeof r == "object" && e === void 0 && i === void 0 && n === void 0)
    return r.alpha >= 1 ? oO(r.hue, r.saturation, r.lightness) : "rgba(" + Xm(r.hue, r.saturation, r.lightness) + "," + r.alpha + ")";
  throw new ms(2);
}
function lO(r, e, i) {
  if (typeof r == "number" && typeof e == "number" && typeof i == "number")
    return Ux("#" + qo(r) + qo(e) + qo(i));
  if (typeof r == "object" && e === void 0 && i === void 0)
    return Ux("#" + qo(r.red) + qo(r.green) + qo(r.blue));
  throw new ms(6);
}
function Hg(r, e, i, n) {
  if (typeof r == "object" && e === void 0 && i === void 0 && n === void 0)
    return r.alpha >= 1 ? lO(r.red, r.green, r.blue) : "rgba(" + r.red + "," + r.green + "," + r.blue + "," + r.alpha + ")";
  throw new ms(7);
}
var Lee = function(r) {
  return typeof r.red == "number" && typeof r.green == "number" && typeof r.blue == "number" && (typeof r.alpha != "number" || typeof r.alpha > "u");
}, Uee = function(r) {
  return typeof r.red == "number" && typeof r.green == "number" && typeof r.blue == "number" && typeof r.alpha == "number";
}, kee = function(r) {
  return typeof r.hue == "number" && typeof r.saturation == "number" && typeof r.lightness == "number" && (typeof r.alpha != "number" || typeof r.alpha > "u");
}, Fee = function(r) {
  return typeof r.hue == "number" && typeof r.saturation == "number" && typeof r.lightness == "number" && typeof r.alpha == "number";
};
function Eo(r) {
  if (typeof r != "object") throw new ms(8);
  if (Uee(r)) return Hg(r);
  if (Lee(r)) return lO(r);
  if (Fee(r)) return Dee(r);
  if (kee(r)) return Oee(r);
  throw new ms(8);
}
function uO(r, e, i) {
  return function() {
    var n = i.concat(Array.prototype.slice.call(arguments));
    return n.length >= e ? r.apply(this, n) : uO(r, e, n);
  };
}
function hn(r) {
  return uO(r, r.length, []);
}
function Bee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return Eo(Wr({}, i, {
    hue: i.hue + parseFloat(r)
  }));
}
hn(Bee);
function Hc(r, e, i) {
  return Math.max(r, Math.min(e, i));
}
function zee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return Eo(Wr({}, i, {
    lightness: Hc(0, 1, i.lightness - parseFloat(r))
  }));
}
hn(zee);
function jee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return Eo(Wr({}, i, {
    saturation: Hc(0, 1, i.saturation - parseFloat(r))
  }));
}
hn(jee);
function Vee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return Eo(Wr({}, i, {
    lightness: Hc(0, 1, i.lightness + parseFloat(r))
  }));
}
hn(Vee);
function Gee(r, e, i) {
  if (e === "transparent") return i;
  if (i === "transparent") return e;
  if (r === 0) return i;
  var n = Ac(e), s = Wr({}, n, {
    alpha: typeof n.alpha == "number" ? n.alpha : 1
  }), a = Ac(i), o = Wr({}, a, {
    alpha: typeof a.alpha == "number" ? a.alpha : 1
  }), l = s.alpha - o.alpha, u = parseFloat(r) * 2 - 1, c = u * l === -1 ? u : u + l, h = 1 + u * l, d = (c / h + 1) / 2, p = 1 - d, f = {
    red: Math.floor(s.red * d + o.red * p),
    green: Math.floor(s.green * d + o.green * p),
    blue: Math.floor(s.blue * d + o.blue * p),
    alpha: s.alpha * parseFloat(r) + o.alpha * (1 - parseFloat(r))
  };
  return Hg(f);
}
var Hee = hn(Gee), cO = Hee;
function Wee(r, e) {
  if (e === "transparent") return e;
  var i = Ac(e), n = typeof i.alpha == "number" ? i.alpha : 1, s = Wr({}, i, {
    alpha: Hc(0, 1, (n * 100 + parseFloat(r) * 100) / 100)
  });
  return Hg(s);
}
var qee = hn(Wee), Xee = qee;
function $ee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return Eo(Wr({}, i, {
    saturation: Hc(0, 1, i.saturation + parseFloat(r))
  }));
}
hn($ee);
function Yee(r, e) {
  return e === "transparent" ? e : Eo(Wr({}, wo(e), {
    hue: parseFloat(r)
  }));
}
hn(Yee);
function Kee(r, e) {
  return e === "transparent" ? e : Eo(Wr({}, wo(e), {
    lightness: parseFloat(r)
  }));
}
hn(Kee);
function Zee(r, e) {
  return e === "transparent" ? e : Eo(Wr({}, wo(e), {
    saturation: parseFloat(r)
  }));
}
hn(Zee);
function Qee(r, e) {
  return e === "transparent" ? e : cO(parseFloat(r), "rgb(0, 0, 0)", e);
}
hn(Qee);
function Jee(r, e) {
  return e === "transparent" ? e : cO(parseFloat(r), "rgb(255, 255, 255)", e);
}
hn(Jee);
function ete(r, e) {
  if (e === "transparent") return e;
  var i = Ac(e), n = typeof i.alpha == "number" ? i.alpha : 1, s = Wr({}, i, {
    alpha: Hc(0, 1, +(n * 100 - parseFloat(r) * 100).toFixed(2) / 100)
  });
  return Hg(s);
}
hn(ete);
var ba = Object.freeze({
  Linear: Object.freeze({
    None: function(r) {
      return r;
    },
    In: function(r) {
      return r;
    },
    Out: function(r) {
      return r;
    },
    InOut: function(r) {
      return r;
    }
  }),
  Quadratic: Object.freeze({
    In: function(r) {
      return r * r;
    },
    Out: function(r) {
      return r * (2 - r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(r) {
      return r * r * r;
    },
    Out: function(r) {
      return --r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(r) {
      return r * r * r * r;
    },
    Out: function(r) {
      return 1 - --r * r * r * r;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(r) {
      return r * r * r * r * r;
    },
    Out: function(r) {
      return --r * r * r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(r) {
      return 1 - Math.sin((1 - r) * Math.PI / 2);
    },
    Out: function(r) {
      return Math.sin(r * Math.PI / 2);
    },
    InOut: function(r) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - r)));
    }
  }),
  Exponential: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : Math.pow(1024, r - 1);
    },
    Out: function(r) {
      return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(r) {
      return 1 - Math.sqrt(1 - r * r);
    },
    Out: function(r) {
      return Math.sqrt(1 - --r * r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : -Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI);
    },
    Out: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : Math.pow(2, -10 * r) * Math.sin((r - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2, r < 1 ? -0.5 * Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In: function(r) {
      var e = 1.70158;
      return r === 1 ? 1 : r * r * ((e + 1) * r - e);
    },
    Out: function(r) {
      var e = 1.70158;
      return r === 0 ? 0 : --r * r * ((e + 1) * r + e) + 1;
    },
    InOut: function(r) {
      var e = 2.5949095;
      return (r *= 2) < 1 ? 0.5 * (r * r * ((e + 1) * r - e)) : 0.5 * ((r -= 2) * r * ((e + 1) * r + e) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(r) {
      return 1 - ba.Bounce.Out(1 - r);
    },
    Out: function(r) {
      return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
    },
    InOut: function(r) {
      return r < 0.5 ? ba.Bounce.In(r * 2) * 0.5 : ba.Bounce.Out(r * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(r) {
    return r === void 0 && (r = 4), r = r < Number.EPSILON ? Number.EPSILON : r, r = r > 1e4 ? 1e4 : r, {
      In: function(e) {
        return Math.pow(e, r);
      },
      Out: function(e) {
        return 1 - Math.pow(1 - e, r);
      },
      InOut: function(e) {
        return e < 0.5 ? Math.pow(e * 2, r) / 2 : (1 - Math.pow(2 - e * 2, r)) / 2 + 0.5;
      }
    };
  }
}), Hh = function() {
  return performance.now();
}, $T = (
  /** @class */
  function() {
    function r() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      this._tweens = {}, this._tweensAddedDuringUpdate = {}, this.add.apply(this, e);
    }
    return r.prototype.getAll = function() {
      var e = this;
      return Object.keys(this._tweens).map(function(i) {
        return e._tweens[i];
      });
    }, r.prototype.removeAll = function() {
      this._tweens = {};
    }, r.prototype.add = function() {
      for (var e, i = [], n = 0; n < arguments.length; n++)
        i[n] = arguments[n];
      for (var s = 0, a = i; s < a.length; s++) {
        var o = a[s];
        (e = o._group) === null || e === void 0 || e.remove(o), o._group = this, this._tweens[o.getId()] = o, this._tweensAddedDuringUpdate[o.getId()] = o;
      }
    }, r.prototype.remove = function() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      for (var n = 0, s = e; n < s.length; n++) {
        var a = s[n];
        a._group = void 0, delete this._tweens[a.getId()], delete this._tweensAddedDuringUpdate[a.getId()];
      }
    }, r.prototype.allStopped = function() {
      return this.getAll().every(function(e) {
        return !e.isPlaying();
      });
    }, r.prototype.update = function(e, i) {
      e === void 0 && (e = Hh()), i === void 0 && (i = !0);
      var n = Object.keys(this._tweens);
      if (n.length !== 0)
        for (; n.length > 0; ) {
          this._tweensAddedDuringUpdate = {};
          for (var s = 0; s < n.length; s++) {
            var a = this._tweens[n[s]], o = !i;
            a && a.update(e, o) === !1 && !i && this.remove(a);
          }
          n = Object.keys(this._tweensAddedDuringUpdate);
        }
    }, r;
  }()
), kx = {
  Linear: function(r, e) {
    var i = r.length - 1, n = i * e, s = Math.floor(n), a = kx.Utils.Linear;
    return e < 0 ? a(r[0], r[1], n) : e > 1 ? a(r[i], r[i - 1], i - n) : a(r[s], r[s + 1 > i ? i : s + 1], n - s);
  },
  Utils: {
    Linear: function(r, e, i) {
      return (e - r) * i + r;
    }
  }
}, hO = (
  /** @class */
  function() {
    function r() {
    }
    return r.nextId = function() {
      return r._nextId++;
    }, r._nextId = 0, r;
  }()
), Fx = new $T(), $m = (
  /** @class */
  function() {
    function r(e, i) {
      this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = ba.Linear.None, this._interpolationFunction = kx.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = hO.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1, this._object = e, typeof i == "object" ? (this._group = i, i.add(this)) : i === !0 && (this._group = Fx, Fx.add(this));
    }
    return r.prototype.getId = function() {
      return this._id;
    }, r.prototype.isPlaying = function() {
      return this._isPlaying;
    }, r.prototype.isPaused = function() {
      return this._isPaused;
    }, r.prototype.getDuration = function() {
      return this._duration;
    }, r.prototype.to = function(e, i) {
      if (i === void 0 && (i = 1e3), this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      return this._valuesEnd = e, this._propertiesAreSetUp = !1, this._duration = i < 0 ? 0 : i, this;
    }, r.prototype.duration = function(e) {
      return e === void 0 && (e = 1e3), this._duration = e < 0 ? 0 : e, this;
    }, r.prototype.dynamic = function(e) {
      return e === void 0 && (e = !1), this._isDynamic = e, this;
    }, r.prototype.start = function(e, i) {
      if (e === void 0 && (e = Hh()), i === void 0 && (i = !1), this._isPlaying)
        return this;
      if (this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var n in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n];
      }
      if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = e, this._startTime += this._delayTime, !this._propertiesAreSetUp || i) {
        if (this._propertiesAreSetUp = !0, !this._isDynamic) {
          var s = {};
          for (var a in this._valuesEnd)
            s[a] = this._valuesEnd[a];
          this._valuesEnd = s;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, i);
      }
      return this;
    }, r.prototype.startFromCurrentValues = function(e) {
      return this.start(e, !0);
    }, r.prototype._setupProperties = function(e, i, n, s, a) {
      for (var o in n) {
        var l = e[o], u = Array.isArray(l), c = u ? "array" : typeof l, h = !u && Array.isArray(n[o]);
        if (!(c === "undefined" || c === "function")) {
          if (h) {
            var d = n[o];
            if (d.length === 0)
              continue;
            for (var p = [l], f = 0, m = d.length; f < m; f += 1) {
              var v = this._handleRelativeValue(l, d[f]);
              if (isNaN(v)) {
                h = !1, console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              p.push(v);
            }
            h && (n[o] = p);
          }
          if ((c === "object" || u) && l && !h) {
            i[o] = u ? [] : {};
            var y = l;
            for (var g in y)
              i[o][g] = y[g];
            s[o] = u ? [] : {};
            var d = n[o];
            if (!this._isDynamic) {
              var _ = {};
              for (var g in d)
                _[g] = d[g];
              n[o] = d = _;
            }
            this._setupProperties(y, i[o], d, s[o], a);
          } else
            (typeof i[o] > "u" || a) && (i[o] = l), u || (i[o] *= 1), h ? s[o] = n[o].slice().reverse() : s[o] = i[o] || 0;
        }
      }
    }, r.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, r.prototype.end = function() {
      return this._goToEnd = !0, this.update(this._startTime + this._duration), this;
    }, r.prototype.pause = function(e) {
      return e === void 0 && (e = Hh()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = e, this);
    }, r.prototype.resume = function(e) {
      return e === void 0 && (e = Hh()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += e - this._pauseStart, this._pauseStart = 0, this);
    }, r.prototype.stopChainedTweens = function() {
      for (var e = 0, i = this._chainedTweens.length; e < i; e++)
        this._chainedTweens[e].stop();
      return this;
    }, r.prototype.group = function(e) {
      return e ? (e.add(this), this) : (console.warn("tween.group() without args has been removed, use group.add(tween) instead."), this);
    }, r.prototype.remove = function() {
      var e;
      return (e = this._group) === null || e === void 0 || e.remove(this), this;
    }, r.prototype.delay = function(e) {
      return e === void 0 && (e = 0), this._delayTime = e, this;
    }, r.prototype.repeat = function(e) {
      return e === void 0 && (e = 0), this._initialRepeat = e, this._repeat = e, this;
    }, r.prototype.repeatDelay = function(e) {
      return this._repeatDelayTime = e, this;
    }, r.prototype.yoyo = function(e) {
      return e === void 0 && (e = !1), this._yoyo = e, this;
    }, r.prototype.easing = function(e) {
      return e === void 0 && (e = ba.Linear.None), this._easingFunction = e, this;
    }, r.prototype.interpolation = function(e) {
      return e === void 0 && (e = kx.Linear), this._interpolationFunction = e, this;
    }, r.prototype.chain = function() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      return this._chainedTweens = e, this;
    }, r.prototype.onStart = function(e) {
      return this._onStartCallback = e, this;
    }, r.prototype.onEveryStart = function(e) {
      return this._onEveryStartCallback = e, this;
    }, r.prototype.onUpdate = function(e) {
      return this._onUpdateCallback = e, this;
    }, r.prototype.onRepeat = function(e) {
      return this._onRepeatCallback = e, this;
    }, r.prototype.onComplete = function(e) {
      return this._onCompleteCallback = e, this;
    }, r.prototype.onStop = function(e) {
      return this._onStopCallback = e, this;
    }, r.prototype.update = function(e, i) {
      var n = this, s;
      if (e === void 0 && (e = Hh()), i === void 0 && (i = r.autoStartOnUpdate), this._isPaused)
        return !0;
      var a;
      if (!this._goToEnd && !this._isPlaying)
        if (i)
          this.start(e, !0);
        else
          return !1;
      if (this._goToEnd = !1, e < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0);
      var o = e - this._startTime, l = this._duration + ((s = this._repeatDelayTime) !== null && s !== void 0 ? s : this._delayTime), u = this._duration + this._repeat * l, c = function() {
        if (n._duration === 0 || o > u)
          return 1;
        var v = Math.trunc(o / l), y = o - v * l, g = Math.min(y / n._duration, 1);
        return g === 0 && o === n._duration ? 1 : g;
      }, h = c(), d = this._easingFunction(h);
      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, d), this._onUpdateCallback && this._onUpdateCallback(this._object, h), this._duration === 0 || o >= this._duration)
        if (this._repeat > 0) {
          var p = Math.min(Math.trunc((o - this._duration) / l) + 1, this._repeat);
          isFinite(this._repeat) && (this._repeat -= p);
          for (a in this._valuesStartRepeat)
            !this._yoyo && typeof this._valuesEnd[a] == "string" && (this._valuesStartRepeat[a] = // eslint-disable-next-line
            // @ts-ignore FIXME?
            this._valuesStartRepeat[a] + parseFloat(this._valuesEnd[a])), this._yoyo && this._swapEndStartRepeatValues(a), this._valuesStart[a] = this._valuesStartRepeat[a];
          return this._yoyo && (this._reversed = !this._reversed), this._startTime += l * p, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;
        } else {
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var f = 0, m = this._chainedTweens.length; f < m; f++)
            this._chainedTweens[f].start(this._startTime + this._duration, !1);
          return this._isPlaying = !1, !1;
        }
      return !0;
    }, r.prototype._updateProperties = function(e, i, n, s) {
      for (var a in n)
        if (i[a] !== void 0) {
          var o = i[a] || 0, l = n[a], u = Array.isArray(e[a]), c = Array.isArray(l), h = !u && c;
          h ? e[a] = this._interpolationFunction(l, s) : typeof l == "object" && l ? this._updateProperties(e[a], o, l, s) : (l = this._handleRelativeValue(o, l), typeof l == "number" && (e[a] = o + (l - o) * s));
        }
    }, r.prototype._handleRelativeValue = function(e, i) {
      return typeof i != "string" ? i : i.charAt(0) === "+" || i.charAt(0) === "-" ? e + parseFloat(i) : parseFloat(i);
    }, r.prototype._swapEndStartRepeatValues = function(e) {
      var i = this._valuesStartRepeat[e], n = this._valuesEnd[e];
      typeof n == "string" ? this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(n) : this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = i;
    }, r.autoStartOnUpdate = !1, r;
  }()
);
hO.nextId;
var Ss = Fx;
Ss.getAll.bind(Ss);
Ss.removeAll.bind(Ss);
Ss.add.bind(Ss);
Ss.remove.bind(Ss);
Ss.update.bind(Ss);
var Bx = "http://www.w3.org/1999/xhtml";
const _A = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Bx,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Wg(r) {
  var e = r += "", i = e.indexOf(":");
  return i >= 0 && (e = r.slice(0, i)) !== "xmlns" && (r = r.slice(i + 1)), _A.hasOwnProperty(e) ? { space: _A[e], local: r } : r;
}
function tte(r) {
  return function() {
    var e = this.ownerDocument, i = this.namespaceURI;
    return i === Bx && e.documentElement.namespaceURI === Bx ? e.createElement(r) : e.createElementNS(i, r);
  };
}
function ite(r) {
  return function() {
    return this.ownerDocument.createElementNS(r.space, r.local);
  };
}
function dO(r) {
  var e = Wg(r);
  return (e.local ? ite : tte)(e);
}
function rte() {
}
function YT(r) {
  return r == null ? rte : function() {
    return this.querySelector(r);
  };
}
function nte(r) {
  typeof r != "function" && (r = YT(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = new Array(o), u, c, h = 0; h < o; ++h)
      (u = a[h]) && (c = r.call(u, u.__data__, h, a)) && ("__data__" in u && (c.__data__ = u.__data__), l[h] = c);
  return new un(n, this._parents);
}
function ste(r) {
  return r == null ? [] : Array.isArray(r) ? r : Array.from(r);
}
function ate() {
  return [];
}
function pO(r) {
  return r == null ? ate : function() {
    return this.querySelectorAll(r);
  };
}
function ote(r) {
  return function() {
    return ste(r.apply(this, arguments));
  };
}
function lte(r) {
  typeof r == "function" ? r = ote(r) : r = pO(r);
  for (var e = this._groups, i = e.length, n = [], s = [], a = 0; a < i; ++a)
    for (var o = e[a], l = o.length, u, c = 0; c < l; ++c)
      (u = o[c]) && (n.push(r.call(u, u.__data__, c, o)), s.push(u));
  return new un(n, s);
}
function fO(r) {
  return function() {
    return this.matches(r);
  };
}
function mO(r) {
  return function(e) {
    return e.matches(r);
  };
}
var ute = Array.prototype.find;
function cte(r) {
  return function() {
    return ute.call(this.children, r);
  };
}
function hte() {
  return this.firstElementChild;
}
function dte(r) {
  return this.select(r == null ? hte : cte(typeof r == "function" ? r : mO(r)));
}
var pte = Array.prototype.filter;
function fte() {
  return Array.from(this.children);
}
function mte(r) {
  return function() {
    return pte.call(this.children, r);
  };
}
function gte(r) {
  return this.selectAll(r == null ? fte : mte(typeof r == "function" ? r : mO(r)));
}
function yte(r) {
  typeof r != "function" && (r = fO(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = [], u, c = 0; c < o; ++c)
      (u = a[c]) && r.call(u, u.__data__, c, a) && l.push(u);
  return new un(n, this._parents);
}
function gO(r) {
  return new Array(r.length);
}
function vte() {
  return new un(this._enter || this._groups.map(gO), this._parents);
}
function Ym(r, e) {
  this.ownerDocument = r.ownerDocument, this.namespaceURI = r.namespaceURI, this._next = null, this._parent = r, this.__data__ = e;
}
Ym.prototype = {
  constructor: Ym,
  appendChild: function(r) {
    return this._parent.insertBefore(r, this._next);
  },
  insertBefore: function(r, e) {
    return this._parent.insertBefore(r, e);
  },
  querySelector: function(r) {
    return this._parent.querySelector(r);
  },
  querySelectorAll: function(r) {
    return this._parent.querySelectorAll(r);
  }
};
function bte(r) {
  return function() {
    return r;
  };
}
function xte(r, e, i, n, s, a) {
  for (var o = 0, l, u = e.length, c = a.length; o < c; ++o)
    (l = e[o]) ? (l.__data__ = a[o], n[o] = l) : i[o] = new Ym(r, a[o]);
  for (; o < u; ++o)
    (l = e[o]) && (s[o] = l);
}
function _te(r, e, i, n, s, a, o) {
  var l, u, c = /* @__PURE__ */ new Map(), h = e.length, d = a.length, p = new Array(h), f;
  for (l = 0; l < h; ++l)
    (u = e[l]) && (p[l] = f = o.call(u, u.__data__, l, e) + "", c.has(f) ? s[l] = u : c.set(f, u));
  for (l = 0; l < d; ++l)
    f = o.call(r, a[l], l, a) + "", (u = c.get(f)) ? (n[l] = u, u.__data__ = a[l], c.delete(f)) : i[l] = new Ym(r, a[l]);
  for (l = 0; l < h; ++l)
    (u = e[l]) && c.get(p[l]) === u && (s[l] = u);
}
function Tte(r) {
  return r.__data__;
}
function Ste(r, e) {
  if (!arguments.length) return Array.from(this, Tte);
  var i = e ? _te : xte, n = this._parents, s = this._groups;
  typeof r != "function" && (r = bte(r));
  for (var a = s.length, o = new Array(a), l = new Array(a), u = new Array(a), c = 0; c < a; ++c) {
    var h = n[c], d = s[c], p = d.length, f = wte(r.call(h, h && h.__data__, c, n)), m = f.length, v = l[c] = new Array(m), y = o[c] = new Array(m), g = u[c] = new Array(p);
    i(h, d, v, y, g, f, e);
    for (var _ = 0, x = 0, b, T; _ < m; ++_)
      if (b = v[_]) {
        for (_ >= x && (x = _ + 1); !(T = y[x]) && ++x < m; ) ;
        b._next = T || null;
      }
  }
  return o = new un(o, n), o._enter = l, o._exit = u, o;
}
function wte(r) {
  return typeof r == "object" && "length" in r ? r : Array.from(r);
}
function Ete() {
  return new un(this._exit || this._groups.map(gO), this._parents);
}
function Mte(r, e, i) {
  var n = this.enter(), s = this, a = this.exit();
  return typeof r == "function" ? (n = r(n), n && (n = n.selection())) : n = n.append(r + ""), e != null && (s = e(s), s && (s = s.selection())), i == null ? a.remove() : i(a), n && s ? n.merge(s).order() : s;
}
function Ate(r) {
  for (var e = r.selection ? r.selection() : r, i = this._groups, n = e._groups, s = i.length, a = n.length, o = Math.min(s, a), l = new Array(s), u = 0; u < o; ++u)
    for (var c = i[u], h = n[u], d = c.length, p = l[u] = new Array(d), f, m = 0; m < d; ++m)
      (f = c[m] || h[m]) && (p[m] = f);
  for (; u < s; ++u)
    l[u] = i[u];
  return new un(l, this._parents);
}
function Cte() {
  for (var r = this._groups, e = -1, i = r.length; ++e < i; )
    for (var n = r[e], s = n.length - 1, a = n[s], o; --s >= 0; )
      (o = n[s]) && (a && o.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(o, a), a = o);
  return this;
}
function Rte(r) {
  r || (r = Nte);
  function e(d, p) {
    return d && p ? r(d.__data__, p.__data__) : !d - !p;
  }
  for (var i = this._groups, n = i.length, s = new Array(n), a = 0; a < n; ++a) {
    for (var o = i[a], l = o.length, u = s[a] = new Array(l), c, h = 0; h < l; ++h)
      (c = o[h]) && (u[h] = c);
    u.sort(e);
  }
  return new un(s, this._parents).order();
}
function Nte(r, e) {
  return r < e ? -1 : r > e ? 1 : r >= e ? 0 : NaN;
}
function Pte() {
  var r = arguments[0];
  return arguments[0] = this, r.apply(null, arguments), this;
}
function Ite() {
  return Array.from(this);
}
function Ote() {
  for (var r = this._groups, e = 0, i = r.length; e < i; ++e)
    for (var n = r[e], s = 0, a = n.length; s < a; ++s) {
      var o = n[s];
      if (o) return o;
    }
  return null;
}
function Dte() {
  let r = 0;
  for (const e of this) ++r;
  return r;
}
function Lte() {
  return !this.node();
}
function Ute(r) {
  for (var e = this._groups, i = 0, n = e.length; i < n; ++i)
    for (var s = e[i], a = 0, o = s.length, l; a < o; ++a)
      (l = s[a]) && r.call(l, l.__data__, a, s);
  return this;
}
function kte(r) {
  return function() {
    this.removeAttribute(r);
  };
}
function Fte(r) {
  return function() {
    this.removeAttributeNS(r.space, r.local);
  };
}
function Bte(r, e) {
  return function() {
    this.setAttribute(r, e);
  };
}
function zte(r, e) {
  return function() {
    this.setAttributeNS(r.space, r.local, e);
  };
}
function jte(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? this.removeAttribute(r) : this.setAttribute(r, i);
  };
}
function Vte(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? this.removeAttributeNS(r.space, r.local) : this.setAttributeNS(r.space, r.local, i);
  };
}
function Gte(r, e) {
  var i = Wg(r);
  if (arguments.length < 2) {
    var n = this.node();
    return i.local ? n.getAttributeNS(i.space, i.local) : n.getAttribute(i);
  }
  return this.each((e == null ? i.local ? Fte : kte : typeof e == "function" ? i.local ? Vte : jte : i.local ? zte : Bte)(i, e));
}
function yO(r) {
  return r.ownerDocument && r.ownerDocument.defaultView || r.document && r || r.defaultView;
}
function Hte(r) {
  return function() {
    this.style.removeProperty(r);
  };
}
function Wte(r, e, i) {
  return function() {
    this.style.setProperty(r, e, i);
  };
}
function qte(r, e, i) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(r) : this.style.setProperty(r, n, i);
  };
}
function Xte(r, e, i) {
  return arguments.length > 1 ? this.each((e == null ? Hte : typeof e == "function" ? qte : Wte)(r, e, i ?? "")) : Cc(this.node(), r);
}
function Cc(r, e) {
  return r.style.getPropertyValue(e) || yO(r).getComputedStyle(r, null).getPropertyValue(e);
}
function $te(r) {
  return function() {
    delete this[r];
  };
}
function Yte(r, e) {
  return function() {
    this[r] = e;
  };
}
function Kte(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? delete this[r] : this[r] = i;
  };
}
function Zte(r, e) {
  return arguments.length > 1 ? this.each((e == null ? $te : typeof e == "function" ? Kte : Yte)(r, e)) : this.node()[r];
}
function vO(r) {
  return r.trim().split(/^|\s+/);
}
function KT(r) {
  return r.classList || new bO(r);
}
function bO(r) {
  this._node = r, this._names = vO(r.getAttribute("class") || "");
}
bO.prototype = {
  add: function(r) {
    var e = this._names.indexOf(r);
    e < 0 && (this._names.push(r), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(r) {
    var e = this._names.indexOf(r);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(r) {
    return this._names.indexOf(r) >= 0;
  }
};
function xO(r, e) {
  for (var i = KT(r), n = -1, s = e.length; ++n < s; ) i.add(e[n]);
}
function _O(r, e) {
  for (var i = KT(r), n = -1, s = e.length; ++n < s; ) i.remove(e[n]);
}
function Qte(r) {
  return function() {
    xO(this, r);
  };
}
function Jte(r) {
  return function() {
    _O(this, r);
  };
}
function eie(r, e) {
  return function() {
    (e.apply(this, arguments) ? xO : _O)(this, r);
  };
}
function tie(r, e) {
  var i = vO(r + "");
  if (arguments.length < 2) {
    for (var n = KT(this.node()), s = -1, a = i.length; ++s < a; ) if (!n.contains(i[s])) return !1;
    return !0;
  }
  return this.each((typeof e == "function" ? eie : e ? Qte : Jte)(i, e));
}
function iie() {
  this.textContent = "";
}
function rie(r) {
  return function() {
    this.textContent = r;
  };
}
function nie(r) {
  return function() {
    var e = r.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function sie(r) {
  return arguments.length ? this.each(r == null ? iie : (typeof r == "function" ? nie : rie)(r)) : this.node().textContent;
}
function aie() {
  this.innerHTML = "";
}
function oie(r) {
  return function() {
    this.innerHTML = r;
  };
}
function lie(r) {
  return function() {
    var e = r.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function uie(r) {
  return arguments.length ? this.each(r == null ? aie : (typeof r == "function" ? lie : oie)(r)) : this.node().innerHTML;
}
function cie() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function hie() {
  return this.each(cie);
}
function die() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function pie() {
  return this.each(die);
}
function fie(r) {
  var e = typeof r == "function" ? r : dO(r);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function mie() {
  return null;
}
function gie(r, e) {
  var i = typeof r == "function" ? r : dO(r), n = e == null ? mie : typeof e == "function" ? e : YT(e);
  return this.select(function() {
    return this.insertBefore(i.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function yie() {
  var r = this.parentNode;
  r && r.removeChild(this);
}
function vie() {
  return this.each(yie);
}
function bie() {
  var r = this.cloneNode(!1), e = this.parentNode;
  return e ? e.insertBefore(r, this.nextSibling) : r;
}
function xie() {
  var r = this.cloneNode(!0), e = this.parentNode;
  return e ? e.insertBefore(r, this.nextSibling) : r;
}
function _ie(r) {
  return this.select(r ? xie : bie);
}
function Tie(r) {
  return arguments.length ? this.property("__data__", r) : this.node().__data__;
}
function Sie(r) {
  return function(e) {
    r.call(this, e, this.__data__);
  };
}
function wie(r) {
  return r.trim().split(/^|\s+/).map(function(e) {
    var i = "", n = e.indexOf(".");
    return n >= 0 && (i = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: i };
  });
}
function Eie(r) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var i = 0, n = -1, s = e.length, a; i < s; ++i)
        a = e[i], (!r.type || a.type === r.type) && a.name === r.name ? this.removeEventListener(a.type, a.listener, a.options) : e[++n] = a;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function Mie(r, e, i) {
  return function() {
    var n = this.__on, s, a = Sie(e);
    if (n) {
      for (var o = 0, l = n.length; o < l; ++o)
        if ((s = n[o]).type === r.type && s.name === r.name) {
          this.removeEventListener(s.type, s.listener, s.options), this.addEventListener(s.type, s.listener = a, s.options = i), s.value = e;
          return;
        }
    }
    this.addEventListener(r.type, a, i), s = { type: r.type, name: r.name, value: e, listener: a, options: i }, n ? n.push(s) : this.__on = [s];
  };
}
function Aie(r, e, i) {
  var n = wie(r + ""), s, a = n.length, o;
  if (arguments.length < 2) {
    var l = this.node().__on;
    if (l) {
      for (var u = 0, c = l.length, h; u < c; ++u)
        for (s = 0, h = l[u]; s < a; ++s)
          if ((o = n[s]).type === h.type && o.name === h.name)
            return h.value;
    }
    return;
  }
  for (l = e ? Mie : Eie, s = 0; s < a; ++s) this.each(l(n[s], e, i));
  return this;
}
function TO(r, e, i) {
  var n = yO(r), s = n.CustomEvent;
  typeof s == "function" ? s = new s(e, i) : (s = n.document.createEvent("Event"), i ? (s.initEvent(e, i.bubbles, i.cancelable), s.detail = i.detail) : s.initEvent(e, !1, !1)), r.dispatchEvent(s);
}
function Cie(r, e) {
  return function() {
    return TO(this, r, e);
  };
}
function Rie(r, e) {
  return function() {
    return TO(this, r, e.apply(this, arguments));
  };
}
function Nie(r, e) {
  return this.each((typeof e == "function" ? Rie : Cie)(r, e));
}
function* Pie() {
  for (var r = this._groups, e = 0, i = r.length; e < i; ++e)
    for (var n = r[e], s = 0, a = n.length, o; s < a; ++s)
      (o = n[s]) && (yield o);
}
var SO = [null];
function un(r, e) {
  this._groups = r, this._parents = e;
}
function ip() {
  return new un([[document.documentElement]], SO);
}
function Iie() {
  return this;
}
un.prototype = ip.prototype = {
  constructor: un,
  select: nte,
  selectAll: lte,
  selectChild: dte,
  selectChildren: gte,
  filter: yte,
  data: Ste,
  enter: vte,
  exit: Ete,
  join: Mte,
  merge: Ate,
  selection: Iie,
  order: Cte,
  sort: Rte,
  call: Pte,
  nodes: Ite,
  node: Ote,
  size: Dte,
  empty: Lte,
  each: Ute,
  attr: Gte,
  style: Xte,
  property: Zte,
  classed: tie,
  text: sie,
  html: uie,
  raise: hie,
  lower: pie,
  append: fie,
  insert: gie,
  remove: vie,
  clone: _ie,
  datum: Tie,
  on: Aie,
  dispatch: Nie,
  [Symbol.iterator]: Pie
};
function bn(r) {
  return typeof r == "string" ? new un([[document.querySelector(r)]], [document.documentElement]) : new un([[r]], SO);
}
function Oie(r) {
  let e;
  for (; e = r.sourceEvent; ) r = e;
  return r;
}
function as(r, e) {
  if (r = Oie(r), e === void 0 && (e = r.currentTarget), e) {
    var i = e.ownerSVGElement || e;
    if (i.createSVGPoint) {
      var n = i.createSVGPoint();
      return n.x = r.clientX, n.y = r.clientY, n = n.matrixTransform(e.getScreenCTM().inverse()), [n.x, n.y];
    }
    if (e.getBoundingClientRect) {
      var s = e.getBoundingClientRect();
      return [r.clientX - s.left - e.clientLeft, r.clientY - s.top - e.clientTop];
    }
  }
  return [r.pageX, r.pageY];
}
var rp, mi, wO, EO, Jo, TA, MO, AO, CO, ZT, zx, jx, Rd = {}, RO = [], Die = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, qg = Array.isArray;
function gs(r, e) {
  for (var i in e) r[i] = e[i];
  return r;
}
function QT(r) {
  r && r.parentNode && r.parentNode.removeChild(r);
}
function Lie(r, e, i) {
  var n, s, a, o = {};
  for (a in e) a == "key" ? n = e[a] : a == "ref" ? s = e[a] : o[a] = e[a];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? rp.call(arguments, 2) : i), typeof r == "function" && r.defaultProps != null) for (a in r.defaultProps) o[a] === void 0 && (o[a] = r.defaultProps[a]);
  return sd(r, o, n, s, null);
}
function sd(r, e, i, n, s) {
  var a = { type: r, props: e, key: i, ref: n, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: s ?? ++wO, __i: -1, __u: 0 };
  return s == null && mi.vnode != null && mi.vnode(a), a;
}
function Xg(r) {
  return r.children;
}
function lm(r, e) {
  this.props = r, this.context = e;
}
function Rc(r, e) {
  if (e == null) return r.__ ? Rc(r.__, r.__i + 1) : null;
  for (var i; e < r.__k.length; e++) if ((i = r.__k[e]) != null && i.__e != null) return i.__e;
  return typeof r.type == "function" ? Rc(r) : null;
}
function NO(r) {
  var e, i;
  if ((r = r.__) != null && r.__c != null) {
    for (r.__e = r.__c.base = null, e = 0; e < r.__k.length; e++) if ((i = r.__k[e]) != null && i.__e != null) {
      r.__e = r.__c.base = i.__e;
      break;
    }
    return NO(r);
  }
}
function SA(r) {
  (!r.__d && (r.__d = !0) && Jo.push(r) && !Km.__r++ || TA !== mi.debounceRendering) && ((TA = mi.debounceRendering) || MO)(Km);
}
function Km() {
  for (var r, e, i, n, s, a, o, l = 1; Jo.length; ) Jo.length > l && Jo.sort(AO), r = Jo.shift(), l = Jo.length, r.__d && (i = void 0, s = (n = (e = r).__v).__e, a = [], o = [], e.__P && ((i = gs({}, n)).__v = n.__v + 1, mi.vnode && mi.vnode(i), JT(e.__P, i, n, e.__n, e.__P.namespaceURI, 32 & n.__u ? [s] : null, a, s ?? Rc(n), !!(32 & n.__u), o), i.__v = n.__v, i.__.__k[i.__i] = i, OO(a, i, o), i.__e != s && NO(i)));
  Km.__r = 0;
}
function PO(r, e, i, n, s, a, o, l, u, c, h) {
  var d, p, f, m, v, y, g = n && n.__k || RO, _ = e.length;
  for (u = Uie(i, e, g, u, _), d = 0; d < _; d++) (f = i.__k[d]) != null && (p = f.__i === -1 ? Rd : g[f.__i] || Rd, f.__i = d, y = JT(r, f, p, s, a, o, l, u, c, h), m = f.__e, f.ref && p.ref != f.ref && (p.ref && eS(p.ref, null, f), h.push(f.ref, f.__c || m, f)), v == null && m != null && (v = m), 4 & f.__u || p.__k === f.__k ? u = IO(f, u, r) : typeof f.type == "function" && y !== void 0 ? u = y : m && (u = m.nextSibling), f.__u &= -7);
  return i.__e = v, u;
}
function Uie(r, e, i, n, s) {
  var a, o, l, u, c, h = i.length, d = h, p = 0;
  for (r.__k = new Array(s), a = 0; a < s; a++) (o = e[a]) != null && typeof o != "boolean" && typeof o != "function" ? (u = a + p, (o = r.__k[a] = typeof o == "string" || typeof o == "number" || typeof o == "bigint" || o.constructor == String ? sd(null, o, null, null, null) : qg(o) ? sd(Xg, { children: o }, null, null, null) : o.constructor === void 0 && o.__b > 0 ? sd(o.type, o.props, o.key, o.ref ? o.ref : null, o.__v) : o).__ = r, o.__b = r.__b + 1, l = null, (c = o.__i = kie(o, i, u, d)) !== -1 && (d--, (l = i[c]) && (l.__u |= 2)), l == null || l.__v === null ? (c == -1 && (s > h ? p-- : s < h && p++), typeof o.type != "function" && (o.__u |= 4)) : c != u && (c == u - 1 ? p-- : c == u + 1 ? p++ : (c > u ? p-- : p++, o.__u |= 4))) : r.__k[a] = null;
  if (d) for (a = 0; a < h; a++) (l = i[a]) != null && !(2 & l.__u) && (l.__e == n && (n = Rc(l)), LO(l, l));
  return n;
}
function IO(r, e, i) {
  var n, s;
  if (typeof r.type == "function") {
    for (n = r.__k, s = 0; n && s < n.length; s++) n[s] && (n[s].__ = r, e = IO(n[s], e, i));
    return e;
  }
  r.__e != e && (e && r.type && !i.contains(e) && (e = Rc(r)), i.insertBefore(r.__e, e || null), e = r.__e);
  do
    e = e && e.nextSibling;
  while (e != null && e.nodeType == 8);
  return e;
}
function kie(r, e, i, n) {
  var s, a, o = r.key, l = r.type, u = e[i];
  if (u === null && r.key == null || u && o == u.key && l === u.type && !(2 & u.__u)) return i;
  if (n > (u != null && !(2 & u.__u) ? 1 : 0)) for (s = i - 1, a = i + 1; s >= 0 || a < e.length; ) {
    if (s >= 0) {
      if ((u = e[s]) && !(2 & u.__u) && o == u.key && l === u.type) return s;
      s--;
    }
    if (a < e.length) {
      if ((u = e[a]) && !(2 & u.__u) && o == u.key && l === u.type) return a;
      a++;
    }
  }
  return -1;
}
function wA(r, e, i) {
  e[0] == "-" ? r.setProperty(e, i ?? "") : r[e] = i == null ? "" : typeof i != "number" || Die.test(e) ? i : i + "px";
}
function Pf(r, e, i, n, s) {
  var a;
  e: if (e == "style") if (typeof i == "string") r.style.cssText = i;
  else {
    if (typeof n == "string" && (r.style.cssText = n = ""), n) for (e in n) i && e in i || wA(r.style, e, "");
    if (i) for (e in i) n && i[e] === n[e] || wA(r.style, e, i[e]);
  }
  else if (e[0] == "o" && e[1] == "n") a = e != (e = e.replace(CO, "$1")), e = e.toLowerCase() in r || e == "onFocusOut" || e == "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), r.l || (r.l = {}), r.l[e + a] = i, i ? n ? i.t = n.t : (i.t = ZT, r.addEventListener(e, a ? jx : zx, a)) : r.removeEventListener(e, a ? jx : zx, a);
  else {
    if (s == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in r) try {
      r[e] = i ?? "";
      break e;
    } catch {
    }
    typeof i == "function" || (i == null || i === !1 && e[4] != "-" ? r.removeAttribute(e) : r.setAttribute(e, e == "popover" && i == 1 ? "" : i));
  }
}
function EA(r) {
  return function(e) {
    if (this.l) {
      var i = this.l[e.type + r];
      if (e.u == null) e.u = ZT++;
      else if (e.u < i.t) return;
      return i(mi.event ? mi.event(e) : e);
    }
  };
}
function JT(r, e, i, n, s, a, o, l, u, c) {
  var h, d, p, f, m, v, y, g, _, x, b, T, S, w, A, E, M, N = e.type;
  if (e.constructor !== void 0) return null;
  128 & i.__u && (u = !!(32 & i.__u), a = [l = e.__e = i.__e]), (h = mi.__b) && h(e);
  e: if (typeof N == "function") try {
    if (g = e.props, _ = "prototype" in N && N.prototype.render, x = (h = N.contextType) && n[h.__c], b = h ? x ? x.props.value : h.__ : n, i.__c ? y = (d = e.__c = i.__c).__ = d.__E : (_ ? e.__c = d = new N(g, b) : (e.__c = d = new lm(g, b), d.constructor = N, d.render = Bie), x && x.sub(d), d.props = g, d.state || (d.state = {}), d.context = b, d.__n = n, p = d.__d = !0, d.__h = [], d._sb = []), _ && d.__s == null && (d.__s = d.state), _ && N.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = gs({}, d.__s)), gs(d.__s, N.getDerivedStateFromProps(g, d.__s))), f = d.props, m = d.state, d.__v = e, p) _ && N.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(), _ && d.componentDidMount != null && d.__h.push(d.componentDidMount);
    else {
      if (_ && N.getDerivedStateFromProps == null && g !== f && d.componentWillReceiveProps != null && d.componentWillReceiveProps(g, b), !d.__e && (d.shouldComponentUpdate != null && d.shouldComponentUpdate(g, d.__s, b) === !1 || e.__v == i.__v)) {
        for (e.__v != i.__v && (d.props = g, d.state = d.__s, d.__d = !1), e.__e = i.__e, e.__k = i.__k, e.__k.some(function(k) {
          k && (k.__ = e);
        }), T = 0; T < d._sb.length; T++) d.__h.push(d._sb[T]);
        d._sb = [], d.__h.length && o.push(d);
        break e;
      }
      d.componentWillUpdate != null && d.componentWillUpdate(g, d.__s, b), _ && d.componentDidUpdate != null && d.__h.push(function() {
        d.componentDidUpdate(f, m, v);
      });
    }
    if (d.context = b, d.props = g, d.__P = r, d.__e = !1, S = mi.__r, w = 0, _) {
      for (d.state = d.__s, d.__d = !1, S && S(e), h = d.render(d.props, d.state, d.context), A = 0; A < d._sb.length; A++) d.__h.push(d._sb[A]);
      d._sb = [];
    } else do
      d.__d = !1, S && S(e), h = d.render(d.props, d.state, d.context), d.state = d.__s;
    while (d.__d && ++w < 25);
    d.state = d.__s, d.getChildContext != null && (n = gs(gs({}, n), d.getChildContext())), _ && !p && d.getSnapshotBeforeUpdate != null && (v = d.getSnapshotBeforeUpdate(f, m)), E = h, h != null && h.type === Xg && h.key == null && (E = DO(h.props.children)), l = PO(r, qg(E) ? E : [E], e, i, n, s, a, o, l, u, c), d.base = e.__e, e.__u &= -161, d.__h.length && o.push(d), y && (d.__E = d.__ = null);
  } catch (k) {
    if (e.__v = null, u || a != null) if (k.then) {
      for (e.__u |= u ? 160 : 128; l && l.nodeType == 8 && l.nextSibling; ) l = l.nextSibling;
      a[a.indexOf(l)] = null, e.__e = l;
    } else for (M = a.length; M--; ) QT(a[M]);
    else e.__e = i.__e, e.__k = i.__k;
    mi.__e(k, e, i);
  }
  else a == null && e.__v == i.__v ? (e.__k = i.__k, e.__e = i.__e) : l = e.__e = Fie(i.__e, e, i, n, s, a, o, u, c);
  return (h = mi.diffed) && h(e), 128 & e.__u ? void 0 : l;
}
function OO(r, e, i) {
  for (var n = 0; n < i.length; n++) eS(i[n], i[++n], i[++n]);
  mi.__c && mi.__c(e, r), r.some(function(s) {
    try {
      r = s.__h, s.__h = [], r.some(function(a) {
        a.call(s);
      });
    } catch (a) {
      mi.__e(a, s.__v);
    }
  });
}
function DO(r) {
  return typeof r != "object" || r == null ? r : qg(r) ? r.map(DO) : gs({}, r);
}
function Fie(r, e, i, n, s, a, o, l, u) {
  var c, h, d, p, f, m, v, y = i.props, g = e.props, _ = e.type;
  if (_ == "svg" ? s = "http://www.w3.org/2000/svg" : _ == "math" ? s = "http://www.w3.org/1998/Math/MathML" : s || (s = "http://www.w3.org/1999/xhtml"), a != null) {
    for (c = 0; c < a.length; c++) if ((f = a[c]) && "setAttribute" in f == !!_ && (_ ? f.localName == _ : f.nodeType == 3)) {
      r = f, a[c] = null;
      break;
    }
  }
  if (r == null) {
    if (_ == null) return document.createTextNode(g);
    r = document.createElementNS(s, _, g.is && g), l && (mi.__m && mi.__m(e, a), l = !1), a = null;
  }
  if (_ === null) y === g || l && r.data === g || (r.data = g);
  else {
    if (a = a && rp.call(r.childNodes), y = i.props || Rd, !l && a != null) for (y = {}, c = 0; c < r.attributes.length; c++) y[(f = r.attributes[c]).name] = f.value;
    for (c in y) if (f = y[c], c != "children") {
      if (c == "dangerouslySetInnerHTML") d = f;
      else if (!(c in g)) {
        if (c == "value" && "defaultValue" in g || c == "checked" && "defaultChecked" in g) continue;
        Pf(r, c, null, f, s);
      }
    }
    for (c in g) f = g[c], c == "children" ? p = f : c == "dangerouslySetInnerHTML" ? h = f : c == "value" ? m = f : c == "checked" ? v = f : l && typeof f != "function" || y[c] === f || Pf(r, c, f, y[c], s);
    if (h) l || d && (h.__html === d.__html || h.__html === r.innerHTML) || (r.innerHTML = h.__html), e.__k = [];
    else if (d && (r.innerHTML = ""), PO(e.type === "template" ? r.content : r, qg(p) ? p : [p], e, i, n, _ == "foreignObject" ? "http://www.w3.org/1999/xhtml" : s, a, o, a ? a[0] : i.__k && Rc(i, 0), l, u), a != null) for (c = a.length; c--; ) QT(a[c]);
    l || (c = "value", _ == "progress" && m == null ? r.removeAttribute("value") : m !== void 0 && (m !== r[c] || _ == "progress" && !m || _ == "option" && m !== y[c]) && Pf(r, c, m, y[c], s), c = "checked", v !== void 0 && v !== r[c] && Pf(r, c, v, y[c], s));
  }
  return r;
}
function eS(r, e, i) {
  try {
    if (typeof r == "function") {
      var n = typeof r.__u == "function";
      n && r.__u(), n && e == null || (r.__u = r(e));
    } else r.current = e;
  } catch (s) {
    mi.__e(s, i);
  }
}
function LO(r, e, i) {
  var n, s;
  if (mi.unmount && mi.unmount(r), (n = r.ref) && (n.current && n.current !== r.__e || eS(n, null, e)), (n = r.__c) != null) {
    if (n.componentWillUnmount) try {
      n.componentWillUnmount();
    } catch (a) {
      mi.__e(a, e);
    }
    n.base = n.__P = null;
  }
  if (n = r.__k) for (s = 0; s < n.length; s++) n[s] && LO(n[s], e, i || typeof r.type != "function");
  i || QT(r.__e), r.__c = r.__ = r.__e = void 0;
}
function Bie(r, e, i) {
  return this.constructor(r, i);
}
function zie(r, e, i) {
  var n, s, a, o;
  e == document && (e = document.documentElement), mi.__ && mi.__(r, e), s = (n = !1) ? null : e.__k, a = [], o = [], JT(e, r = e.__k = Lie(Xg, null, [r]), s || Rd, Rd, e.namespaceURI, s ? null : e.firstChild ? rp.call(e.childNodes) : null, a, s ? s.__e : e.firstChild, n, o), OO(a, r, o);
}
function UO(r, e, i) {
  var n, s, a, o, l = gs({}, r.props);
  for (a in r.type && r.type.defaultProps && (o = r.type.defaultProps), e) a == "key" ? n = e[a] : a == "ref" ? s = e[a] : l[a] = e[a] === void 0 && o !== void 0 ? o[a] : e[a];
  return arguments.length > 2 && (l.children = arguments.length > 3 ? rp.call(arguments, 2) : i), sd(r.type, l, n || r.key, s || r.ref, null);
}
rp = RO.slice, mi = { __e: function(r, e, i, n) {
  for (var s, a, o; e = e.__; ) if ((s = e.__c) && !s.__) try {
    if ((a = s.constructor) && a.getDerivedStateFromError != null && (s.setState(a.getDerivedStateFromError(r)), o = s.__d), s.componentDidCatch != null && (s.componentDidCatch(r, n || {}), o = s.__d), o) return s.__E = s;
  } catch (l) {
    r = l;
  }
  throw r;
} }, wO = 0, EO = function(r) {
  return r != null && r.constructor == null;
}, lm.prototype.setState = function(r, e) {
  var i;
  i = this.__s != null && this.__s !== this.state ? this.__s : this.__s = gs({}, this.state), typeof r == "function" && (r = r(gs({}, i), this.props)), r && gs(i, r), r != null && this.__v && (e && this._sb.push(e), SA(this));
}, lm.prototype.forceUpdate = function(r) {
  this.__v && (this.__e = !0, r && this.__h.push(r), SA(this));
}, lm.prototype.render = Xg, Jo = [], MO = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, AO = function(r, e) {
  return r.__v.__b - e.__v.__b;
}, Km.__r = 0, CO = /(PointerCapture)$|Capture$/i, ZT = 0, zx = EA(!1), jx = EA(!0);
function MA(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function jie(r) {
  if (Array.isArray(r)) return r;
}
function Vie(r, e, i) {
  return (e = $ie(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function Gie(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function Hie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function AA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function Wie(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? AA(Object(i), !0).forEach(function(n) {
      Vie(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : AA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function qie(r, e) {
  return jie(r) || Gie(r, e) || Yie(r, e) || Hie();
}
function Xie(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function $ie(r) {
  var e = Xie(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Zm(r) {
  "@babel/helpers - typeof";
  return Zm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Zm(r);
}
function Yie(r, e) {
  if (r) {
    if (typeof r == "string") return MA(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? MA(r, e) : void 0;
  }
}
var Vx = function(r) {
  if (Zm(r) !== "object") return r;
  var e = UO(r);
  if (e.props) {
    var i;
    e.props = Wie({}, e.props), e != null && (i = e.props) !== null && i !== void 0 && i.children && (e.props.children = Array.isArray(e.props.children) ? e.props.children.map(Vx) : Vx(e.props.children));
  }
  return e;
}, Kie = function(r) {
  return EO(UO(r));
}, Zie = function(r, e) {
  delete e.__k, zie(Vx(r), e);
};
function Qie(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var Jie = `.float-tooltip-kap {
  position: absolute;
  width: max-content; /* prevent shrinking near right edge */
  max-width: max(50%, 150px);
  padding: 3px 5px;
  border-radius: 3px;
  font: 12px sans-serif;
  color: #eee;
  background: rgba(0,0,0,0.6);
  pointer-events: none;
}
`;
Qie(Jie);
var kO = Pl({
  props: {
    content: {
      default: !1
    },
    offsetX: {
      triggerUpdate: !1
    },
    // null or number
    offsetY: {
      triggerUpdate: !1
    }
    // null or number
  },
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.style, s = n === void 0 ? {} : n, a = !!r && Zm(r) === "object" && !!r.node && typeof r.node == "function", o = bn(a ? r.node() : r);
    o.style("position") === "static" && o.style("position", "relative"), e.tooltipEl = o.append("div").attr("class", "float-tooltip-kap"), Object.entries(s).forEach(function(u) {
      var c = qie(u, 2), h = c[0], d = c[1];
      return e.tooltipEl.style(h, d);
    }), e.tooltipEl.style("left", "-10000px").style("display", "none");
    var l = "tooltip-".concat(Math.round(Math.random() * 1e12));
    e.mouseInside = !1, o.on("mousemove.".concat(l), function(u) {
      e.mouseInside = !0;
      var c = as(u), h = o.node(), d = h.offsetWidth, p = h.offsetHeight, f = [e.offsetX === null || e.offsetX === void 0 ? "-".concat(c[0] / d * 100, "%") : typeof e.offsetX == "number" ? "calc(-50% + ".concat(e.offsetX, "px)") : e.offsetX, e.offsetY === null || e.offsetY === void 0 ? p > 130 && p - c[1] < 100 ? "calc(-100% - 6px)" : "21px" : typeof e.offsetY == "number" ? e.offsetY < 0 ? "calc(-100% - ".concat(Math.abs(e.offsetY), "px)") : "".concat(e.offsetY, "px") : e.offsetY];
      e.tooltipEl.style("left", c[0] + "px").style("top", c[1] + "px").style("transform", "translate(".concat(f.join(","), ")")), e.content && e.tooltipEl.style("display", "inline");
    }), o.on("mouseover.".concat(l), function() {
      e.mouseInside = !0, e.content && e.tooltipEl.style("display", "inline");
    }), o.on("mouseout.".concat(l), function() {
      e.mouseInside = !1, e.tooltipEl.style("display", "none");
    });
  },
  update: function(r) {
    r.tooltipEl.style("display", r.content && r.mouseInside ? "inline" : "none"), r.content ? r.content instanceof HTMLElement ? (r.tooltipEl.text(""), r.tooltipEl.append(function() {
      return r.content;
    })) : typeof r.content == "string" ? r.tooltipEl.html(r.content) : Kie(r.content) ? (r.tooltipEl.text(""), Zie(r.content, r.tooltipEl.node())) : (r.tooltipEl.style("display", "none"), console.warn("Tooltip content is invalid, skipping.", r.content, r.content.toString())) : r.tooltipEl.text("");
  }
});
function ere(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var tre = `.scene-nav-info {
  position: absolute;
  bottom: 5px;
  width: 100%;
  text-align: center;
  color: slategrey;
  opacity: 0.7;
  font-size: 10px;
  font-family: sans-serif;
  pointer-events: none;
  user-select: none;
}

.scene-container canvas:focus {
  outline: none;
}`;
ere(tre);
function Gx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function ire(r) {
  if (Array.isArray(r)) return r;
}
function rre(r) {
  if (Array.isArray(r)) return Gx(r);
}
function nre(r, e, i) {
  return (e = hre(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function sre(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function are(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function ore() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function lre() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ure(r, e) {
  return ire(r) || are(r, e) || FO(r, e) || ore();
}
function zo(r) {
  return rre(r) || sre(r) || FO(r) || lre();
}
function cre(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function hre(r) {
  var e = cre(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function FO(r, e) {
  if (r) {
    if (typeof r == "string") return Gx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Gx(r, e) : void 0;
  }
}
var pi = window.THREE ? window.THREE : {
  WebGLRenderer: _j,
  Scene: Tj,
  PerspectiveCamera: vn,
  Raycaster: SR,
  SRGBColorSpace: sn,
  TextureLoader: qj,
  Vector2: Ue,
  Vector3: q,
  Box3: Rl,
  Color: kt,
  Mesh: Ur,
  SphereGeometry: bR,
  MeshBasicMaterial: _g,
  BackSide: Ar,
  Clock: TR
}, BO = Pl({
  props: {
    width: {
      default: window.innerWidth,
      onChange: function(r, e, i) {
        isNaN(r) && (e.width = i);
      }
    },
    height: {
      default: window.innerHeight,
      onChange: function(r, e, i) {
        isNaN(r) && (e.height = i);
      }
    },
    viewOffset: {
      default: [0, 0]
    },
    backgroundColor: {
      default: "#000011"
    },
    backgroundImageUrl: {},
    onBackgroundImageLoaded: {},
    showNavInfo: {
      default: !0
    },
    skyRadius: {
      default: 5e4
    },
    objects: {
      default: []
    },
    lights: {
      default: []
    },
    enablePointerInteraction: {
      default: !0,
      onChange: function(r, e) {
        e.hoverObj = null, e.tooltip && e.tooltip.content(null);
      },
      triggerUpdate: !1
    },
    lineHoverPrecision: {
      default: 1,
      triggerUpdate: !1
    },
    pointsHoverPrecision: {
      default: 1,
      triggerUpdate: !1
    },
    hoverOrderComparator: {
      triggerUpdate: !1
    },
    // keep existing order by default
    hoverFilter: {
      default: function() {
        return !0;
      },
      triggerUpdate: !1
    },
    // exclude objects from interaction
    tooltipContent: {
      triggerUpdate: !1
    },
    hoverDuringDrag: {
      default: !1,
      triggerUpdate: !1
    },
    clickAfterDrag: {
      default: !1,
      triggerUpdate: !1
    },
    onHover: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onClick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onRightClick: {
      triggerUpdate: !1
    }
  },
  methods: {
    tick: function(r) {
      if (r.initialised) {
        if (r.controls.update && r.controls.update(Math.min(1, r.clock.getDelta())), r.postProcessingComposer ? r.postProcessingComposer.render() : r.renderer.render(r.scene, r.camera), r.extraRenderers.forEach(function(s) {
          return s.render(r.scene, r.camera);
        }), r.enablePointerInteraction) {
          var e = null;
          if (r.hoverDuringDrag || !r.isPointerDragging) {
            var i = this.intersectingObjects(r.pointerPos.x, r.pointerPos.y);
            r.hoverOrderComparator && i.sort(function(s, a) {
              return r.hoverOrderComparator(s.object, a.object);
            });
            var n = i.find(function(s) {
              return r.hoverFilter(s.object);
            }) || null;
            e = n ? n.object : null, r.intersection = n || null;
          }
          e !== r.hoverObj && (r.onHover(e, r.hoverObj, r.intersection), r.tooltip.content(e && et(r.tooltipContent)(e, r.intersection) || null), r.hoverObj = e);
        }
        r.tweenGroup.update();
      }
      return this;
    },
    getPointerPos: function(r) {
      var e = r.pointerPos, i = e.x, n = e.y;
      return {
        x: i,
        y: n
      };
    },
    cameraPosition: function(r, e, i, n) {
      var s = r.camera;
      if (e && r.initialised) {
        var a = e, o = i || {
          x: 0,
          y: 0,
          z: 0
        };
        if (!n)
          c(a), h(o);
        else {
          var l = Object.assign({}, s.position), u = d();
          r.tweenGroup.add(new $m(l).to(a, n).easing(ba.Quadratic.Out).onUpdate(c).start()), r.tweenGroup.add(new $m(u).to(o, n / 3).easing(ba.Quadratic.Out).onUpdate(h).start());
        }
        return this;
      }
      return Object.assign({}, s.position, {
        lookAt: d()
      });
      function c(p) {
        var f = p.x, m = p.y, v = p.z;
        f !== void 0 && (s.position.x = f), m !== void 0 && (s.position.y = m), v !== void 0 && (s.position.z = v);
      }
      function h(p) {
        var f = new pi.Vector3(p.x, p.y, p.z);
        r.controls.target ? r.controls.target = f : s.lookAt(f);
      }
      function d() {
        return Object.assign(new pi.Vector3(0, 0, -1e3).applyQuaternion(s.quaternion).add(s.position));
      }
    },
    zoomToFit: function(r) {
      for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, n = arguments.length, s = new Array(n > 3 ? n - 3 : 0), a = 3; a < n; a++)
        s[a - 3] = arguments[a];
      return this.fitToBbox(this.getBbox.apply(this, s), e, i);
    },
    fitToBbox: function(r, e) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10, s = r.camera;
      if (e) {
        var a = new pi.Vector3(0, 0, 0), o = Math.max.apply(Math, zo(Object.entries(e).map(function(p) {
          var f = ure(p, 2), m = f[0], v = f[1];
          return Math.max.apply(Math, zo(v.map(function(y) {
            return Math.abs(a[m] - y);
          })));
        }))) * 2, l = (1 - n * 2 / r.height) * s.fov, u = o / Math.atan(l * Math.PI / 180), c = u / s.aspect, h = Math.max(u, c);
        if (h > 0) {
          var d = a.clone().sub(s.position).normalize().multiplyScalar(-h);
          this.cameraPosition(d, a, i);
        }
      }
      return this;
    },
    getBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      }, i = new pi.Box3(new pi.Vector3(0, 0, 0), new pi.Vector3(0, 0, 0)), n = r.objects.filter(e);
      return n.length ? (n.forEach(function(s) {
        return i.expandByObject(s);
      }), Object.assign.apply(Object, zo(["x", "y", "z"].map(function(s) {
        return nre({}, s, [i.min[s], i.max[s]]);
      })))) : null;
    },
    getScreenCoords: function(r, e, i, n) {
      var s = new pi.Vector3(e, i, n);
      return s.project(this.camera()), {
        // align relative pos to canvas dimensions
        x: (s.x + 1) * r.width / 2,
        y: -(s.y - 1) * r.height / 2
      };
    },
    getSceneCoords: function(r, e, i) {
      var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s = new pi.Vector2(e / r.width * 2 - 1, -(i / r.height) * 2 + 1), a = new pi.Raycaster();
      return a.setFromCamera(s, r.camera), Object.assign({}, a.ray.at(n, new pi.Vector3()));
    },
    intersectingObjects: function(r, e, i) {
      var n = new pi.Vector2(e / r.width * 2 - 1, -(i / r.height) * 2 + 1), s = new pi.Raycaster();
      return s.params.Line.threshold = r.lineHoverPrecision, s.params.Points.threshold = r.pointsHoverPrecision, s.setFromCamera(n, r.camera), s.intersectObjects(r.objects, !0);
    },
    renderer: function(r) {
      return r.renderer;
    },
    scene: function(r) {
      return r.scene;
    },
    camera: function(r) {
      return r.camera;
    },
    postProcessingComposer: function(r) {
      return r.postProcessingComposer;
    },
    controls: function(r) {
      return r.controls;
    },
    tbControls: function(r) {
      return r.controls;
    }
    // to be deprecated
  },
  stateInit: function() {
    return {
      scene: new pi.Scene(),
      camera: new pi.PerspectiveCamera(),
      clock: new pi.Clock(),
      tweenGroup: new $T()
    };
  },
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.controlType, s = n === void 0 ? "trackball" : n, a = i.useWebGPU, o = a === void 0 ? !1 : a, l = i.rendererConfig, u = l === void 0 ? {} : l, c = i.extraRenderers, h = c === void 0 ? [] : c, d = i.waitForLoadComplete, p = d === void 0 ? !0 : d;
    r.innerHTML = "", r.appendChild(e.container = document.createElement("div")), e.container.className = "scene-container", e.container.style.position = "relative", e.container.appendChild(e.navInfo = document.createElement("div")), e.navInfo.className = "scene-nav-info", e.navInfo.textContent = {
      orbit: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      trackball: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      fly: "WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw"
    }[s] || "", e.navInfo.style.display = e.showNavInfo ? null : "none", e.tooltip = new kO(e.container), e.pointerPos = new pi.Vector2(), e.pointerPos.x = -2, e.pointerPos.y = -2, ["pointermove", "pointerdown"].forEach(function(f) {
      return e.container.addEventListener(f, function(m) {
        if (f === "pointerdown" && (e.isPointerPressed = !0), !e.isPointerDragging && m.type === "pointermove" && (m.pressure > 0 || e.isPointerPressed) && (m.pointerType !== "touch" || m.movementX === void 0 || [m.movementX, m.movementY].some(function(g) {
          return Math.abs(g) > 1;
        })) && (e.isPointerDragging = !0), e.enablePointerInteraction) {
          var v = y(e.container);
          e.pointerPos.x = m.pageX - v.left, e.pointerPos.y = m.pageY - v.top;
        }
        function y(g) {
          var _ = g.getBoundingClientRect(), x = window.pageXOffset || document.documentElement.scrollLeft, b = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: _.top + b,
            left: _.left + x
          };
        }
      }, {
        passive: !0
      });
    }), e.container.addEventListener("pointerup", function(f) {
      e.isPointerPressed = !1, !(e.isPointerDragging && (e.isPointerDragging = !1, !e.clickAfterDrag)) && requestAnimationFrame(function() {
        f.button === 0 && e.onClick(e.hoverObj || null, f, e.intersection), f.button === 2 && e.onRightClick && e.onRightClick(e.hoverObj || null, f, e.intersection);
      });
    }, {
      passive: !0,
      capture: !0
    }), e.container.addEventListener("contextmenu", function(f) {
      e.onRightClick && f.preventDefault();
    }), e.renderer = new (o ? xJ : pi.WebGLRenderer)(Object.assign({
      antialias: !0,
      alpha: !0
    }, u)), e.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio)), e.container.appendChild(e.renderer.domElement), e.extraRenderers = h, e.extraRenderers.forEach(function(f) {
      f.domElement.style.position = "absolute", f.domElement.style.top = "0px", f.domElement.style.pointerEvents = "none", e.container.appendChild(f.domElement);
    }), e.postProcessingComposer = new pee(e.renderer), e.postProcessingComposer.addPass(new fee(e.scene, e.camera)), e.controls = new {
      trackball: TJ,
      orbit: FJ,
      fly: QJ
    }[s](e.camera, e.renderer.domElement), s === "fly" && (e.controls.movementSpeed = 300, e.controls.rollSpeed = Math.PI / 6, e.controls.dragToLook = !0), (s === "trackball" || s === "orbit") && (e.controls.minDistance = 0.1, e.controls.maxDistance = e.skyRadius, e.controls.addEventListener("start", function() {
      e.controlsEngaged = !0;
    }), e.controls.addEventListener("change", function() {
      e.controlsEngaged && (e.controlsDragging = !0);
    }), e.controls.addEventListener("end", function() {
      e.controlsEngaged = !1, e.controlsDragging = !1;
    })), [e.renderer, e.postProcessingComposer].concat(zo(e.extraRenderers)).forEach(function(f) {
      return f.setSize(e.width, e.height);
    }), e.camera.aspect = e.width / e.height, e.camera.updateProjectionMatrix(), e.camera.position.z = 1e3, e.scene.add(e.skysphere = new pi.Mesh()), e.skysphere.visible = !1, e.loadComplete = e.scene.visible = !p, window.scene = e.scene;
  },
  update: function(r, e) {
    if (r.width && r.height && (e.hasOwnProperty("width") || e.hasOwnProperty("height"))) {
      var i, n = r.width, s = r.height;
      r.container.style.width = "".concat(n, "px"), r.container.style.height = "".concat(s, "px"), [r.renderer, r.postProcessingComposer].concat(zo(r.extraRenderers)).forEach(function(p) {
        return p.setSize(n, s);
      }), r.camera.aspect = n / s;
      var a = r.viewOffset.slice(0, 2);
      a.some(function(p) {
        return p;
      }) && (i = r.camera).setViewOffset.apply(i, [n, s].concat(zo(a), [n, s])), r.camera.updateProjectionMatrix();
    }
    if (e.hasOwnProperty("viewOffset")) {
      var o, l = r.width, u = r.height, c = r.viewOffset.slice(0, 2);
      c.some(function(p) {
        return p;
      }) ? (o = r.camera).setViewOffset.apply(o, [l, u].concat(zo(c), [l, u])) : r.camera.clearViewOffset();
    }
    if (e.hasOwnProperty("skyRadius") && r.skyRadius && (r.controls.hasOwnProperty("maxDistance") && e.skyRadius && (r.controls.maxDistance = Math.min(r.controls.maxDistance, r.skyRadius)), r.camera.far = r.skyRadius * 2.5, r.camera.updateProjectionMatrix(), r.skysphere.geometry = new pi.SphereGeometry(r.skyRadius)), e.hasOwnProperty("backgroundColor")) {
      var h = Ac(r.backgroundColor).alpha;
      h === void 0 && (h = 1), r.renderer.setClearColor(new pi.Color(Xee(1, r.backgroundColor)), h);
    }
    e.hasOwnProperty("backgroundImageUrl") && (r.backgroundImageUrl ? new pi.TextureLoader().load(r.backgroundImageUrl, function(p) {
      p.colorSpace = pi.SRGBColorSpace, r.skysphere.material = new pi.MeshBasicMaterial({
        map: p,
        side: pi.BackSide
      }), r.skysphere.visible = !0, r.onBackgroundImageLoaded && setTimeout(r.onBackgroundImageLoaded), !r.loadComplete && d();
    }) : (r.skysphere.visible = !1, r.skysphere.material.map = null, !r.loadComplete && d())), e.hasOwnProperty("showNavInfo") && (r.navInfo.style.display = r.showNavInfo ? null : "none"), e.hasOwnProperty("lights") && ((e.lights || []).forEach(function(p) {
      return r.scene.remove(p);
    }), r.lights.forEach(function(p) {
      return r.scene.add(p);
    })), e.hasOwnProperty("objects") && ((e.objects || []).forEach(function(p) {
      return r.scene.remove(p);
    }), r.objects.forEach(function(p) {
      return r.scene.add(p);
    }));
    function d() {
      r.loadComplete = r.scene.visible = !0;
    }
  }
});
function dre(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var pre = `.graph-info-msg {
  top: 50%;
  width: 100%;
  text-align: center;
  color: lavender;
  opacity: 0.7;
  font-size: 22px;
  position: absolute;
  font-family: Sans-serif;
}

.scene-container .clickable {
  cursor: pointer;
}

.scene-container .grabbable {
  cursor: move;
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

.scene-container .grabbable:active {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
}`;
dre(pre);
function Hx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function fre(r) {
  if (Array.isArray(r)) return Hx(r);
}
function np(r, e, i) {
  return (e = vre(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function mre(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function gre() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function CA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function If(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? CA(Object(i), !0).forEach(function(n) {
      np(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : CA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function $g(r) {
  return fre(r) || mre(r) || bre(r) || gre();
}
function yre(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function vre(r) {
  var e = yre(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function bre(r, e) {
  if (r) {
    if (typeof r == "string") return Hx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Hx(r, e) : void 0;
  }
}
function zO(r, e) {
  var i = new e();
  return i._destructor && i._destructor(), {
    linkProp: function(n) {
      return {
        default: i[n](),
        onChange: function(s, a) {
          a[r][n](s);
        },
        triggerUpdate: !1
      };
    },
    linkMethod: function(n) {
      return function(s) {
        for (var a = s[r], o = arguments.length, l = new Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)
          l[u - 1] = arguments[u];
        var c = a[n].apply(a, l);
        return c === a ? this : c;
      };
    }
  };
}
var S0 = window.THREE ? window.THREE : {
  AmbientLight: Kj,
  DirectionalLight: Yj,
  REVISION: gg
}, xre = 170, jO = zO("forceGraph", Du), _re = Object.assign.apply(Object, $g(["jsonUrl", "graphData", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeVisibility", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "forceEngine", "d3AlphaDecay", "d3VelocityDecay", "d3AlphaMin", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(r) {
  return np({}, r, jO.linkProp(r));
}))), Tre = Object.assign.apply(Object, $g(["refresh", "getGraphBbox", "d3Force", "d3ReheatSimulation", "emitParticle"].map(function(r) {
  return np({}, r, jO.linkMethod(r));
}))), um = zO("renderObjs", BO), Sre = Object.assign.apply(Object, $g(["width", "height", "backgroundColor", "showNavInfo", "enablePointerInteraction"].map(function(r) {
  return np({}, r, um.linkProp(r));
}))), wre = Object.assign.apply(Object, $g(["lights", "cameraPosition", "postProcessingComposer"].map(function(r) {
  return np({}, r, um.linkMethod(r));
})).concat([{
  graph2ScreenCoords: um.linkMethod("getScreenCoords"),
  screen2GraphCoords: um.linkMethod("getSceneCoords")
}])), Ere = Pl({
  props: If(If({
    nodeLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkHoverPrecision: {
      default: 1,
      onChange: function(r, e) {
        return e.renderObjs.lineHoverPrecision(r);
      },
      triggerUpdate: !1
    },
    enableNavigationControls: {
      default: !0,
      onChange: function(r, e) {
        var i = e.renderObjs.controls();
        i && (i.enabled = r, r && i.domElement && i.domElement.dispatchEvent(new PointerEvent("pointerup")));
      },
      triggerUpdate: !1
    },
    enableNodeDrag: {
      default: !0,
      triggerUpdate: !1
    },
    onNodeDrag: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeDragEnd: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeClick: {
      triggerUpdate: !1
    },
    onNodeRightClick: {
      triggerUpdate: !1
    },
    onNodeHover: {
      triggerUpdate: !1
    },
    onLinkClick: {
      triggerUpdate: !1
    },
    onLinkRightClick: {
      triggerUpdate: !1
    },
    onLinkHover: {
      triggerUpdate: !1
    },
    onBackgroundClick: {
      triggerUpdate: !1
    },
    onBackgroundRightClick: {
      triggerUpdate: !1
    }
  }, _re), Sre),
  methods: If(If({
    zoomToFit: function(r, e, i) {
      for (var n, s = arguments.length, a = new Array(s > 3 ? s - 3 : 0), o = 3; o < s; o++)
        a[o - 3] = arguments[o];
      return r.renderObjs.fitToBbox((n = r.forceGraph).getGraphBbox.apply(n, a), e, i), this;
    },
    pauseAnimation: function(r) {
      return r.animationFrameRequestId !== null && (cancelAnimationFrame(r.animationFrameRequestId), r.animationFrameRequestId = null), this;
    },
    resumeAnimation: function(r) {
      return r.animationFrameRequestId === null && this._animationCycle(), this;
    },
    _animationCycle: function(r) {
      r.enablePointerInteraction && (this.renderer().domElement.style.cursor = null), r.forceGraph.tickFrame(), r.renderObjs.tick(), r.animationFrameRequestId = requestAnimationFrame(this._animationCycle);
    },
    scene: function(r) {
      return r.renderObjs.scene();
    },
    // Expose scene
    camera: function(r) {
      return r.renderObjs.camera();
    },
    // Expose camera
    renderer: function(r) {
      return r.renderObjs.renderer();
    },
    // Expose renderer
    controls: function(r) {
      return r.renderObjs.controls();
    },
    // Expose controls
    tbControls: function(r) {
      return r.renderObjs.tbControls();
    },
    // To be deprecated
    _destructor: function() {
      this.pauseAnimation(), this.graphData({
        nodes: [],
        links: []
      });
    }
  }, Tre), wre),
  stateInit: function(r) {
    var e = r.controlType, i = r.rendererConfig, n = r.extraRenderers, s = new Du();
    return {
      forceGraph: s,
      renderObjs: BO({
        controlType: e,
        rendererConfig: i,
        extraRenderers: n
      }).objects([s]).lights([new S0.AmbientLight(13421772, Math.PI), new S0.DirectionalLight(16777215, 0.6 * Math.PI)])
    };
  },
  init: function(r, e) {
    r.innerHTML = "", r.appendChild(e.container = document.createElement("div")), e.container.style.position = "relative";
    var i = document.createElement("div");
    e.container.appendChild(i), e.renderObjs(i);
    var n = e.renderObjs.camera(), s = e.renderObjs.renderer(), a = e.renderObjs.controls();
    a.enabled = !!e.enableNavigationControls, e.lastSetCameraZ = n.position.z;
    var o;
    e.container.appendChild(o = document.createElement("div")), o.className = "graph-info-msg", o.textContent = "", e.forceGraph.onLoading(function() {
      o.textContent = "Loading...";
    }).onFinishLoading(function() {
      o.textContent = "";
    }).onUpdate(function() {
      e.graphData = e.forceGraph.graphData(), n.position.x === 0 && n.position.y === 0 && n.position.z === e.lastSetCameraZ && e.graphData.nodes.length && (n.lookAt(e.forceGraph.position), e.lastSetCameraZ = n.position.z = Math.cbrt(e.graphData.nodes.length) * xre);
    }).onFinishUpdate(function() {
      if (e._dragControls) {
        var l = e.graphData.nodes.find(function(c) {
          return c.__initialFixedPos && !c.__disposeControlsAfterDrag;
        });
        l ? l.__disposeControlsAfterDrag = !0 : e._dragControls.dispose(), e._dragControls = void 0;
      }
      if (e.enableNodeDrag && e.enablePointerInteraction && e.forceEngine === "d3") {
        var u = e._dragControls = new b9(e.graphData.nodes.map(function(c) {
          return c.__threeObj;
        }).filter(function(c) {
          return c;
        }), n, s.domElement);
        u.addEventListener("dragstart", function(c) {
          var h = zs(c.object);
          if (h) {
            a.enabled = !1, c.object.__initialPos = c.object.position.clone(), c.object.__prevPos = c.object.position.clone();
            var d = h.__data;
            !d.__initialFixedPos && (d.__initialFixedPos = {
              fx: d.fx,
              fy: d.fy,
              fz: d.fz
            }), !d.__initialPos && (d.__initialPos = {
              x: d.x,
              y: d.y,
              z: d.z
            }), ["x", "y", "z"].forEach(function(p) {
              return d["f".concat(p)] = d[p];
            }), s.domElement.classList.add("grabbable");
          }
        }), u.addEventListener("drag", function(c) {
          var h = zs(c.object);
          if (h) {
            if (!c.object.hasOwnProperty("__graphObjType")) {
              var d = c.object.__initialPos, p = c.object.__prevPos, f = c.object.position;
              h.position.add(f.clone().sub(p)), p.copy(f), f.copy(d);
            }
            var m = h.__data, v = h.position, y = {
              x: v.x - m.x,
              y: v.y - m.y,
              z: v.z - m.z
            };
            ["x", "y", "z"].forEach(function(g) {
              return m["f".concat(g)] = m[g] = v[g];
            }), e.forceGraph.d3AlphaTarget(0.3).resetCountdown(), m.__dragged = !0, e.onNodeDrag(m, y);
          }
        }), u.addEventListener("dragend", function(c) {
          var h = zs(c.object);
          if (h) {
            delete c.object.__initialPos, delete c.object.__prevPos;
            var d = h.__data;
            d.__disposeControlsAfterDrag && (u.dispose(), delete d.__disposeControlsAfterDrag);
            var p = d.__initialFixedPos, f = d.__initialPos, m = {
              x: f.x - d.x,
              y: f.y - d.y,
              z: f.z - d.z
            };
            p && (["x", "y", "z"].forEach(function(v) {
              var y = "f".concat(v);
              p[y] === void 0 && delete d[y];
            }), delete d.__initialFixedPos, delete d.__initialPos, d.__dragged && (delete d.__dragged, e.onNodeDragEnd(d, m))), e.forceGraph.d3AlphaTarget(0).resetCountdown(), e.enableNavigationControls && (a.enabled = !0, a.domElement && a.domElement.ownerDocument && a.domElement.ownerDocument.dispatchEvent(
              // simulate mouseup to ensure the controls don't take over after dragend
              new PointerEvent("pointerup", {
                pointerType: "touch"
              })
            )), s.domElement.classList.remove("grabbable");
          }
        });
      }
    }), S0.REVISION < 155 && (e.renderObjs.renderer().useLegacyLights = !1), e.renderObjs.hoverOrderComparator(function(l, u) {
      var c = zs(l);
      if (!c) return 1;
      var h = zs(u);
      if (!h) return -1;
      var d = function(p) {
        return p.__graphObjType === "node";
      };
      return d(h) - d(c);
    }).tooltipContent(function(l) {
      var u = zs(l);
      return u && et(e["".concat(u.__graphObjType, "Label")])(u.__data) || "";
    }).hoverDuringDrag(!1).onHover(function(l) {
      var u = zs(l);
      if (u !== e.hoverObj) {
        var c = e.hoverObj ? e.hoverObj.__graphObjType : null, h = e.hoverObj ? e.hoverObj.__data : null, d = u ? u.__graphObjType : null, p = u ? u.__data : null;
        if (c && c !== d) {
          var f = e["on".concat(c === "node" ? "Node" : "Link", "Hover")];
          f && f(null, h);
        }
        if (d) {
          var m = e["on".concat(d === "node" ? "Node" : "Link", "Hover")];
          m && m(p, c === d ? h : null);
        }
        s.domElement.classList[u && e["on".concat(d === "node" ? "Node" : "Link", "Click")] || !u && e.onBackgroundClick ? "add" : "remove"]("clickable"), e.hoverObj = u;
      }
    }).clickAfterDrag(!1).onClick(function(l, u) {
      var c = zs(l);
      if (c) {
        var h = e["on".concat(c.__graphObjType === "node" ? "Node" : "Link", "Click")];
        h && h(c.__data, u);
      } else
        e.onBackgroundClick && e.onBackgroundClick(u);
    }).onRightClick(function(l, u) {
      var c = zs(l);
      if (c) {
        var h = e["on".concat(c.__graphObjType === "node" ? "Node" : "Link", "RightClick")];
        h && h(c.__data, u);
      } else
        e.onBackgroundRightClick && e.onBackgroundRightClick(u);
    }), this._animationCycle();
  }
});
function zs(r) {
  for (var e = r; e && !e.hasOwnProperty("__graphObjType"); )
    e = e.parent;
  return e;
}
const Mre = { passive: !1 }, Nd = { capture: !0, passive: !1 };
function w0(r) {
  r.stopImmediatePropagation();
}
function tc(r) {
  r.preventDefault(), r.stopImmediatePropagation();
}
function VO(r) {
  var e = r.document.documentElement, i = bn(r).on("dragstart.drag", tc, Nd);
  "onselectstart" in e ? i.on("selectstart.drag", tc, Nd) : (e.__noselect = e.style.MozUserSelect, e.style.MozUserSelect = "none");
}
function GO(r, e) {
  var i = r.document.documentElement, n = bn(r).on("dragstart.drag", null);
  e && (n.on("click.drag", tc, Nd), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in i ? n.on("selectstart.drag", null) : (i.style.MozUserSelect = i.__noselect, delete i.__noselect);
}
const Of = (r) => () => r;
function Wx(r, {
  sourceEvent: e,
  subject: i,
  target: n,
  identifier: s,
  active: a,
  x: o,
  y: l,
  dx: u,
  dy: c,
  dispatch: h
}) {
  Object.defineProperties(this, {
    type: { value: r, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    subject: { value: i, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    identifier: { value: s, enumerable: !0, configurable: !0 },
    active: { value: a, enumerable: !0, configurable: !0 },
    x: { value: o, enumerable: !0, configurable: !0 },
    y: { value: l, enumerable: !0, configurable: !0 },
    dx: { value: u, enumerable: !0, configurable: !0 },
    dy: { value: c, enumerable: !0, configurable: !0 },
    _: { value: h }
  });
}
Wx.prototype.on = function() {
  var r = this._.on.apply(this._, arguments);
  return r === this._ ? this : r;
};
function Are(r) {
  return !r.ctrlKey && !r.button;
}
function Cre() {
  return this.parentNode;
}
function Rre(r, e) {
  return e ?? { x: r.x, y: r.y };
}
function Nre() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Pre() {
  var r = Are, e = Cre, i = Rre, n = Nre, s = {}, a = Gd("start", "drag", "end"), o = 0, l, u, c, h, d = 0;
  function p(b) {
    b.on("mousedown.drag", f).filter(n).on("touchstart.drag", y).on("touchmove.drag", g, Mre).on("touchend.drag touchcancel.drag", _).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function f(b, T) {
    if (!(h || !r.call(this, b, T))) {
      var S = x(this, e.call(this, b, T), b, T, "mouse");
      S && (bn(b.view).on("mousemove.drag", m, Nd).on("mouseup.drag", v, Nd), VO(b.view), w0(b), c = !1, l = b.clientX, u = b.clientY, S("start", b));
    }
  }
  function m(b) {
    if (tc(b), !c) {
      var T = b.clientX - l, S = b.clientY - u;
      c = T * T + S * S > d;
    }
    s.mouse("drag", b);
  }
  function v(b) {
    bn(b.view).on("mousemove.drag mouseup.drag", null), GO(b.view, c), tc(b), s.mouse("end", b);
  }
  function y(b, T) {
    if (r.call(this, b, T)) {
      var S = b.changedTouches, w = e.call(this, b, T), A = S.length, E, M;
      for (E = 0; E < A; ++E)
        (M = x(this, w, b, T, S[E].identifier, S[E])) && (w0(b), M("start", b, S[E]));
    }
  }
  function g(b) {
    var T = b.changedTouches, S = T.length, w, A;
    for (w = 0; w < S; ++w)
      (A = s[T[w].identifier]) && (tc(b), A("drag", b, T[w]));
  }
  function _(b) {
    var T = b.changedTouches, S = T.length, w, A;
    for (h && clearTimeout(h), h = setTimeout(function() {
      h = null;
    }, 500), w = 0; w < S; ++w)
      (A = s[T[w].identifier]) && (w0(b), A("end", b, T[w]));
  }
  function x(b, T, S, w, A, E) {
    var M = a.copy(), N = as(E || S, T), k, U, C;
    if ((C = i.call(b, new Wx("beforestart", {
      sourceEvent: S,
      target: p,
      identifier: A,
      active: o,
      x: N[0],
      y: N[1],
      dx: 0,
      dy: 0,
      dispatch: M
    }), w)) != null)
      return k = C.x - N[0] || 0, U = C.y - N[1] || 0, function O(D, H, j) {
        var K = N, L;
        switch (D) {
          case "start":
            s[A] = O, L = o++;
            break;
          case "end":
            delete s[A], --o;
          case "drag":
            N = as(j || H, T), L = o;
            break;
        }
        M.call(
          D,
          b,
          new Wx(D, {
            sourceEvent: H,
            subject: C,
            target: p,
            identifier: A,
            active: L,
            x: N[0] + k,
            y: N[1] + U,
            dx: N[0] - K[0],
            dy: N[1] - K[1],
            dispatch: M
          }),
          w
        );
      };
  }
  return p.filter = function(b) {
    return arguments.length ? (r = typeof b == "function" ? b : Of(!!b), p) : r;
  }, p.container = function(b) {
    return arguments.length ? (e = typeof b == "function" ? b : Of(b), p) : e;
  }, p.subject = function(b) {
    return arguments.length ? (i = typeof b == "function" ? b : Of(b), p) : i;
  }, p.touchable = function(b) {
    return arguments.length ? (n = typeof b == "function" ? b : Of(!!b), p) : n;
  }, p.on = function() {
    var b = a.on.apply(a, arguments);
    return b === a ? p : b;
  }, p.clickDistance = function(b) {
    return arguments.length ? (d = (b = +b) * b, p) : Math.sqrt(d);
  }, p;
}
var Ire = Gd("start", "end", "cancel", "interrupt"), Ore = [], HO = 0, RA = 1, qx = 2, cm = 3, NA = 4, Xx = 5, hm = 6;
function Yg(r, e, i, n, s, a) {
  var o = r.__transition;
  if (!o) r.__transition = {};
  else if (i in o) return;
  Dre(r, i, {
    name: e,
    index: n,
    // For context during callback.
    group: s,
    // For context during callback.
    on: Ire,
    tween: Ore,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: HO
  });
}
function tS(r, e) {
  var i = ts(r, e);
  if (i.state > HO) throw new Error("too late; already scheduled");
  return i;
}
function Es(r, e) {
  var i = ts(r, e);
  if (i.state > cm) throw new Error("too late; already running");
  return i;
}
function ts(r, e) {
  var i = r.__transition;
  if (!i || !(i = i[e])) throw new Error("transition not found");
  return i;
}
function Dre(r, e, i) {
  var n = r.__transition, s;
  n[e] = i, i.timer = H_(a, 0, i.time);
  function a(c) {
    i.state = RA, i.timer.restart(o, i.delay, i.time), i.delay <= c && o(c - i.delay);
  }
  function o(c) {
    var h, d, p, f;
    if (i.state !== RA) return u();
    for (h in n)
      if (f = n[h], f.name === i.name) {
        if (f.state === cm) return Dw(o);
        f.state === NA ? (f.state = hm, f.timer.stop(), f.on.call("interrupt", r, r.__data__, f.index, f.group), delete n[h]) : +h < e && (f.state = hm, f.timer.stop(), f.on.call("cancel", r, r.__data__, f.index, f.group), delete n[h]);
      }
    if (Dw(function() {
      i.state === cm && (i.state = NA, i.timer.restart(l, i.delay, i.time), l(c));
    }), i.state = qx, i.on.call("start", r, r.__data__, i.index, i.group), i.state === qx) {
      for (i.state = cm, s = new Array(p = i.tween.length), h = 0, d = -1; h < p; ++h)
        (f = i.tween[h].value.call(r, r.__data__, i.index, i.group)) && (s[++d] = f);
      s.length = d + 1;
    }
  }
  function l(c) {
    for (var h = c < i.duration ? i.ease.call(null, c / i.duration) : (i.timer.restart(u), i.state = Xx, 1), d = -1, p = s.length; ++d < p; )
      s[d].call(r, h);
    i.state === Xx && (i.on.call("end", r, r.__data__, i.index, i.group), u());
  }
  function u() {
    i.state = hm, i.timer.stop(), delete n[e];
    for (var c in n) return;
    delete r.__transition;
  }
}
function dm(r, e) {
  var i = r.__transition, n, s, a = !0, o;
  if (i) {
    e = e == null ? null : e + "";
    for (o in i) {
      if ((n = i[o]).name !== e) {
        a = !1;
        continue;
      }
      s = n.state > qx && n.state < Xx, n.state = hm, n.timer.stop(), n.on.call(s ? "interrupt" : "cancel", r, r.__data__, n.index, n.group), delete i[o];
    }
    a && delete r.__transition;
  }
}
function Lre(r) {
  return this.each(function() {
    dm(this, r);
  });
}
function Ure(r, e) {
  var i, n;
  return function() {
    var s = Es(this, r), a = s.tween;
    if (a !== i) {
      n = i = a;
      for (var o = 0, l = n.length; o < l; ++o)
        if (n[o].name === e) {
          n = n.slice(), n.splice(o, 1);
          break;
        }
    }
    s.tween = n;
  };
}
function kre(r, e, i) {
  var n, s;
  if (typeof i != "function") throw new Error();
  return function() {
    var a = Es(this, r), o = a.tween;
    if (o !== n) {
      s = (n = o).slice();
      for (var l = { name: e, value: i }, u = 0, c = s.length; u < c; ++u)
        if (s[u].name === e) {
          s[u] = l;
          break;
        }
      u === c && s.push(l);
    }
    a.tween = s;
  };
}
function Fre(r, e) {
  var i = this._id;
  if (r += "", arguments.length < 2) {
    for (var n = ts(this.node(), i).tween, s = 0, a = n.length, o; s < a; ++s)
      if ((o = n[s]).name === r)
        return o.value;
    return null;
  }
  return this.each((e == null ? Ure : kre)(i, r, e));
}
function iS(r, e, i) {
  var n = r._id;
  return r.each(function() {
    var s = Es(this, n);
    (s.value || (s.value = {}))[e] = i.apply(this, arguments);
  }), function(s) {
    return ts(s, n).value[e];
  };
}
function WO(r, e) {
  var i;
  return (typeof e == "number" ? Ka : e instanceof md ? sE : (i = md(e)) ? (e = i, sE) : hH)(r, e);
}
function Bre(r) {
  return function() {
    this.removeAttribute(r);
  };
}
function zre(r) {
  return function() {
    this.removeAttributeNS(r.space, r.local);
  };
}
function jre(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = this.getAttribute(r);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function Vre(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = this.getAttributeNS(r.space, r.local);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function Gre(r, e, i) {
  var n, s, a;
  return function() {
    var o, l = i(this), u;
    return l == null ? void this.removeAttribute(r) : (o = this.getAttribute(r), u = l + "", o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l)));
  };
}
function Hre(r, e, i) {
  var n, s, a;
  return function() {
    var o, l = i(this), u;
    return l == null ? void this.removeAttributeNS(r.space, r.local) : (o = this.getAttributeNS(r.space, r.local), u = l + "", o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l)));
  };
}
function Wre(r, e) {
  var i = Wg(r), n = i === "transform" ? mH : WO;
  return this.attrTween(r, typeof e == "function" ? (i.local ? Hre : Gre)(i, n, iS(this, "attr." + r, e)) : e == null ? (i.local ? zre : Bre)(i) : (i.local ? Vre : jre)(i, n, e));
}
function qre(r, e) {
  return function(i) {
    this.setAttribute(r, e.call(this, i));
  };
}
function Xre(r, e) {
  return function(i) {
    this.setAttributeNS(r.space, r.local, e.call(this, i));
  };
}
function $re(r, e) {
  var i, n;
  function s() {
    var a = e.apply(this, arguments);
    return a !== n && (i = (n = a) && Xre(r, a)), i;
  }
  return s._value = e, s;
}
function Yre(r, e) {
  var i, n;
  function s() {
    var a = e.apply(this, arguments);
    return a !== n && (i = (n = a) && qre(r, a)), i;
  }
  return s._value = e, s;
}
function Kre(r, e) {
  var i = "attr." + r;
  if (arguments.length < 2) return (i = this.tween(i)) && i._value;
  if (e == null) return this.tween(i, null);
  if (typeof e != "function") throw new Error();
  var n = Wg(r);
  return this.tween(i, (n.local ? $re : Yre)(n, e));
}
function Zre(r, e) {
  return function() {
    tS(this, r).delay = +e.apply(this, arguments);
  };
}
function Qre(r, e) {
  return e = +e, function() {
    tS(this, r).delay = e;
  };
}
function Jre(r) {
  var e = this._id;
  return arguments.length ? this.each((typeof r == "function" ? Zre : Qre)(e, r)) : ts(this.node(), e).delay;
}
function ene(r, e) {
  return function() {
    Es(this, r).duration = +e.apply(this, arguments);
  };
}
function tne(r, e) {
  return e = +e, function() {
    Es(this, r).duration = e;
  };
}
function ine(r) {
  var e = this._id;
  return arguments.length ? this.each((typeof r == "function" ? ene : tne)(e, r)) : ts(this.node(), e).duration;
}
function rne(r, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    Es(this, r).ease = e;
  };
}
function nne(r) {
  var e = this._id;
  return arguments.length ? this.each(rne(e, r)) : ts(this.node(), e).ease;
}
function sne(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    if (typeof i != "function") throw new Error();
    Es(this, r).ease = i;
  };
}
function ane(r) {
  if (typeof r != "function") throw new Error();
  return this.each(sne(this._id, r));
}
function one(r) {
  typeof r != "function" && (r = fO(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = [], u, c = 0; c < o; ++c)
      (u = a[c]) && r.call(u, u.__data__, c, a) && l.push(u);
  return new Sa(n, this._parents, this._name, this._id);
}
function lne(r) {
  if (r._id !== this._id) throw new Error();
  for (var e = this._groups, i = r._groups, n = e.length, s = i.length, a = Math.min(n, s), o = new Array(n), l = 0; l < a; ++l)
    for (var u = e[l], c = i[l], h = u.length, d = o[l] = new Array(h), p, f = 0; f < h; ++f)
      (p = u[f] || c[f]) && (d[f] = p);
  for (; l < n; ++l)
    o[l] = e[l];
  return new Sa(o, this._parents, this._name, this._id);
}
function une(r) {
  return (r + "").trim().split(/^|\s+/).every(function(e) {
    var i = e.indexOf(".");
    return i >= 0 && (e = e.slice(0, i)), !e || e === "start";
  });
}
function cne(r, e, i) {
  var n, s, a = une(e) ? tS : Es;
  return function() {
    var o = a(this, r), l = o.on;
    l !== n && (s = (n = l).copy()).on(e, i), o.on = s;
  };
}
function hne(r, e) {
  var i = this._id;
  return arguments.length < 2 ? ts(this.node(), i).on.on(r) : this.each(cne(i, r, e));
}
function dne(r) {
  return function() {
    var e = this.parentNode;
    for (var i in this.__transition) if (+i !== r) return;
    e && e.removeChild(this);
  };
}
function pne() {
  return this.on("end.remove", dne(this._id));
}
function fne(r) {
  var e = this._name, i = this._id;
  typeof r != "function" && (r = YT(r));
  for (var n = this._groups, s = n.length, a = new Array(s), o = 0; o < s; ++o)
    for (var l = n[o], u = l.length, c = a[o] = new Array(u), h, d, p = 0; p < u; ++p)
      (h = l[p]) && (d = r.call(h, h.__data__, p, l)) && ("__data__" in h && (d.__data__ = h.__data__), c[p] = d, Yg(c[p], e, i, p, c, ts(h, i)));
  return new Sa(a, this._parents, e, i);
}
function mne(r) {
  var e = this._name, i = this._id;
  typeof r != "function" && (r = pO(r));
  for (var n = this._groups, s = n.length, a = [], o = [], l = 0; l < s; ++l)
    for (var u = n[l], c = u.length, h, d = 0; d < c; ++d)
      if (h = u[d]) {
        for (var p = r.call(h, h.__data__, d, u), f, m = ts(h, i), v = 0, y = p.length; v < y; ++v)
          (f = p[v]) && Yg(f, e, i, v, p, m);
        a.push(p), o.push(h);
      }
  return new Sa(a, o, e, i);
}
var gne = ip.prototype.constructor;
function yne() {
  return new gne(this._groups, this._parents);
}
function vne(r, e) {
  var i, n, s;
  return function() {
    var a = Cc(this, r), o = (this.style.removeProperty(r), Cc(this, r));
    return a === o ? null : a === i && o === n ? s : s = e(i = a, n = o);
  };
}
function qO(r) {
  return function() {
    this.style.removeProperty(r);
  };
}
function bne(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = Cc(this, r);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function xne(r, e, i) {
  var n, s, a;
  return function() {
    var o = Cc(this, r), l = i(this), u = l + "";
    return l == null && (u = l = (this.style.removeProperty(r), Cc(this, r))), o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l));
  };
}
function _ne(r, e) {
  var i, n, s, a = "style." + e, o = "end." + a, l;
  return function() {
    var u = Es(this, r), c = u.on, h = u.value[a] == null ? l || (l = qO(e)) : void 0;
    (c !== i || s !== h) && (n = (i = c).copy()).on(o, s = h), u.on = n;
  };
}
function Tne(r, e, i) {
  var n = (r += "") == "transform" ? fH : WO;
  return e == null ? this.styleTween(r, vne(r, n)).on("end.style." + r, qO(r)) : typeof e == "function" ? this.styleTween(r, xne(r, n, iS(this, "style." + r, e))).each(_ne(this._id, r)) : this.styleTween(r, bne(r, n, e), i).on("end.style." + r, null);
}
function Sne(r, e, i) {
  return function(n) {
    this.style.setProperty(r, e.call(this, n), i);
  };
}
function wne(r, e, i) {
  var n, s;
  function a() {
    var o = e.apply(this, arguments);
    return o !== s && (n = (s = o) && Sne(r, o, i)), n;
  }
  return a._value = e, a;
}
function Ene(r, e, i) {
  var n = "style." + (r += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  return this.tween(n, wne(r, e, i ?? ""));
}
function Mne(r) {
  return function() {
    this.textContent = r;
  };
}
function Ane(r) {
  return function() {
    var e = r(this);
    this.textContent = e ?? "";
  };
}
function Cne(r) {
  return this.tween("text", typeof r == "function" ? Ane(iS(this, "text", r)) : Mne(r == null ? "" : r + ""));
}
function Rne(r) {
  return function(e) {
    this.textContent = r.call(this, e);
  };
}
function Nne(r) {
  var e, i;
  function n() {
    var s = r.apply(this, arguments);
    return s !== i && (e = (i = s) && Rne(s)), e;
  }
  return n._value = r, n;
}
function Pne(r) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (r == null) return this.tween(e, null);
  if (typeof r != "function") throw new Error();
  return this.tween(e, Nne(r));
}
function Ine() {
  for (var r = this._name, e = this._id, i = XO(), n = this._groups, s = n.length, a = 0; a < s; ++a)
    for (var o = n[a], l = o.length, u, c = 0; c < l; ++c)
      if (u = o[c]) {
        var h = ts(u, e);
        Yg(u, r, i, c, o, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new Sa(n, this._parents, r, i);
}
function One() {
  var r, e, i = this, n = i._id, s = i.size();
  return new Promise(function(a, o) {
    var l = { value: o }, u = { value: function() {
      --s === 0 && a();
    } };
    i.each(function() {
      var c = Es(this, n), h = c.on;
      h !== r && (e = (r = h).copy(), e._.cancel.push(l), e._.interrupt.push(l), e._.end.push(u)), c.on = e;
    }), s === 0 && a();
  });
}
var Dne = 0;
function Sa(r, e, i, n) {
  this._groups = r, this._parents = e, this._name = i, this._id = n;
}
function XO() {
  return ++Dne;
}
var js = ip.prototype;
Sa.prototype = {
  constructor: Sa,
  select: fne,
  selectAll: mne,
  selectChild: js.selectChild,
  selectChildren: js.selectChildren,
  filter: one,
  merge: lne,
  selection: yne,
  transition: Ine,
  call: js.call,
  nodes: js.nodes,
  node: js.node,
  size: js.size,
  empty: js.empty,
  each: js.each,
  on: hne,
  attr: Wre,
  attrTween: Kre,
  style: Tne,
  styleTween: Ene,
  text: Cne,
  textTween: Pne,
  remove: pne,
  tween: Fre,
  delay: Jre,
  duration: ine,
  ease: nne,
  easeVarying: ane,
  end: One,
  [Symbol.iterator]: js[Symbol.iterator]
};
function Lne(r) {
  return ((r *= 2) <= 1 ? r * r * r : (r -= 2) * r * r + 2) / 2;
}
var Une = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Lne
};
function kne(r, e) {
  for (var i; !(i = r.__transition) || !(i = i[e]); )
    if (!(r = r.parentNode))
      throw new Error(`transition ${e} not found`);
  return i;
}
function Fne(r) {
  var e, i;
  r instanceof Sa ? (e = r._id, r = r._name) : (e = XO(), (i = Une).time = G_(), r = r == null ? null : r + "");
  for (var n = this._groups, s = n.length, a = 0; a < s; ++a)
    for (var o = n[a], l = o.length, u, c = 0; c < l; ++c)
      (u = o[c]) && Yg(u, r, e, c, o, i || kne(u, e));
  return new Sa(n, this._parents, r, e);
}
ip.prototype.interrupt = Lre;
ip.prototype.transition = Fne;
const Df = (r) => () => r;
function Bne(r, {
  sourceEvent: e,
  target: i,
  transform: n,
  dispatch: s
}) {
  Object.defineProperties(this, {
    type: { value: r, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    target: { value: i, enumerable: !0, configurable: !0 },
    transform: { value: n, enumerable: !0, configurable: !0 },
    _: { value: s }
  });
}
function oa(r, e, i) {
  this.k = r, this.x = e, this.y = i;
}
oa.prototype = {
  constructor: oa,
  scale: function(r) {
    return r === 1 ? this : new oa(this.k * r, this.x, this.y);
  },
  translate: function(r, e) {
    return r === 0 & e === 0 ? this : new oa(this.k, this.x + this.k * r, this.y + this.k * e);
  },
  apply: function(r) {
    return [r[0] * this.k + this.x, r[1] * this.k + this.y];
  },
  applyX: function(r) {
    return r * this.k + this.x;
  },
  applyY: function(r) {
    return r * this.k + this.y;
  },
  invert: function(r) {
    return [(r[0] - this.x) / this.k, (r[1] - this.y) / this.k];
  },
  invertX: function(r) {
    return (r - this.x) / this.k;
  },
  invertY: function(r) {
    return (r - this.y) / this.k;
  },
  rescaleX: function(r) {
    return r.copy().domain(r.range().map(this.invertX, this).map(r.invert, r));
  },
  rescaleY: function(r) {
    return r.copy().domain(r.range().map(this.invertY, this).map(r.invert, r));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var rS = new oa(1, 0, 0);
ss.prototype = oa.prototype;
function ss(r) {
  for (; !r.__zoom; ) if (!(r = r.parentNode)) return rS;
  return r.__zoom;
}
function E0(r) {
  r.stopImmediatePropagation();
}
function Ch(r) {
  r.preventDefault(), r.stopImmediatePropagation();
}
function zne(r) {
  return (!r.ctrlKey || r.type === "wheel") && !r.button;
}
function jne() {
  var r = this;
  return r instanceof SVGElement ? (r = r.ownerSVGElement || r, r.hasAttribute("viewBox") ? (r = r.viewBox.baseVal, [[r.x, r.y], [r.x + r.width, r.y + r.height]]) : [[0, 0], [r.width.baseVal.value, r.height.baseVal.value]]) : [[0, 0], [r.clientWidth, r.clientHeight]];
}
function PA() {
  return this.__zoom || rS;
}
function Vne(r) {
  return -r.deltaY * (r.deltaMode === 1 ? 0.05 : r.deltaMode ? 1 : 2e-3) * (r.ctrlKey ? 10 : 1);
}
function Gne() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Hne(r, e, i) {
  var n = r.invertX(e[0][0]) - i[0][0], s = r.invertX(e[1][0]) - i[1][0], a = r.invertY(e[0][1]) - i[0][1], o = r.invertY(e[1][1]) - i[1][1];
  return r.translate(
    s > n ? (n + s) / 2 : Math.min(0, n) || Math.max(0, s),
    o > a ? (a + o) / 2 : Math.min(0, a) || Math.max(0, o)
  );
}
function Wne() {
  var r = zne, e = jne, i = Hne, n = Vne, s = Gne, a = [0, 1 / 0], o = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], l = 250, u = bH, c = Gd("start", "zoom", "end"), h, d, p, f = 500, m = 150, v = 0, y = 10;
  function g(C) {
    C.property("__zoom", PA).on("wheel.zoom", A, { passive: !1 }).on("mousedown.zoom", E).on("dblclick.zoom", M).filter(s).on("touchstart.zoom", N).on("touchmove.zoom", k).on("touchend.zoom touchcancel.zoom", U).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  g.transform = function(C, O, D, H) {
    var j = C.selection ? C.selection() : C;
    j.property("__zoom", PA), C !== j ? T(C, O, D, H) : j.interrupt().each(function() {
      S(this, arguments).event(H).start().zoom(null, typeof O == "function" ? O.apply(this, arguments) : O).end();
    });
  }, g.scaleBy = function(C, O, D, H) {
    g.scaleTo(C, function() {
      var j = this.__zoom.k, K = typeof O == "function" ? O.apply(this, arguments) : O;
      return j * K;
    }, D, H);
  }, g.scaleTo = function(C, O, D, H) {
    g.transform(C, function() {
      var j = e.apply(this, arguments), K = this.__zoom, L = D == null ? b(j) : typeof D == "function" ? D.apply(this, arguments) : D, B = K.invert(L), Q = typeof O == "function" ? O.apply(this, arguments) : O;
      return i(x(_(K, Q), L, B), j, o);
    }, D, H);
  }, g.translateBy = function(C, O, D, H) {
    g.transform(C, function() {
      return i(this.__zoom.translate(
        typeof O == "function" ? O.apply(this, arguments) : O,
        typeof D == "function" ? D.apply(this, arguments) : D
      ), e.apply(this, arguments), o);
    }, null, H);
  }, g.translateTo = function(C, O, D, H, j) {
    g.transform(C, function() {
      var K = e.apply(this, arguments), L = this.__zoom, B = H == null ? b(K) : typeof H == "function" ? H.apply(this, arguments) : H;
      return i(rS.translate(B[0], B[1]).scale(L.k).translate(
        typeof O == "function" ? -O.apply(this, arguments) : -O,
        typeof D == "function" ? -D.apply(this, arguments) : -D
      ), K, o);
    }, H, j);
  };
  function _(C, O) {
    return O = Math.max(a[0], Math.min(a[1], O)), O === C.k ? C : new oa(O, C.x, C.y);
  }
  function x(C, O, D) {
    var H = O[0] - D[0] * C.k, j = O[1] - D[1] * C.k;
    return H === C.x && j === C.y ? C : new oa(C.k, H, j);
  }
  function b(C) {
    return [(+C[0][0] + +C[1][0]) / 2, (+C[0][1] + +C[1][1]) / 2];
  }
  function T(C, O, D, H) {
    C.on("start.zoom", function() {
      S(this, arguments).event(H).start();
    }).on("interrupt.zoom end.zoom", function() {
      S(this, arguments).event(H).end();
    }).tween("zoom", function() {
      var j = this, K = arguments, L = S(j, K).event(H), B = e.apply(j, K), Q = D == null ? b(B) : typeof D == "function" ? D.apply(j, K) : D, W = Math.max(B[1][0] - B[0][0], B[1][1] - B[0][1]), z = j.__zoom, X = typeof O == "function" ? O.apply(j, K) : O, ae = u(z.invert(Q).concat(W / z.k), X.invert(Q).concat(W / X.k));
      return function(ue) {
        if (ue === 1) ue = X;
        else {
          var ge = ae(ue), we = W / ge[2];
          ue = new oa(we, Q[0] - ge[0] * we, Q[1] - ge[1] * we);
        }
        L.zoom(null, ue);
      };
    });
  }
  function S(C, O, D) {
    return !D && C.__zooming || new w(C, O);
  }
  function w(C, O) {
    this.that = C, this.args = O, this.active = 0, this.sourceEvent = null, this.extent = e.apply(C, O), this.taps = 0;
  }
  w.prototype = {
    event: function(C) {
      return C && (this.sourceEvent = C), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(C, O) {
      return this.mouse && C !== "mouse" && (this.mouse[1] = O.invert(this.mouse[0])), this.touch0 && C !== "touch" && (this.touch0[1] = O.invert(this.touch0[0])), this.touch1 && C !== "touch" && (this.touch1[1] = O.invert(this.touch1[0])), this.that.__zoom = O, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(C) {
      var O = bn(this.that).datum();
      c.call(
        C,
        this.that,
        new Bne(C, {
          sourceEvent: this.sourceEvent,
          target: g,
          transform: this.that.__zoom,
          dispatch: c
        }),
        O
      );
    }
  };
  function A(C, ...O) {
    if (!r.apply(this, arguments)) return;
    var D = S(this, O).event(C), H = this.__zoom, j = Math.max(a[0], Math.min(a[1], H.k * Math.pow(2, n.apply(this, arguments)))), K = as(C);
    if (D.wheel)
      (D.mouse[0][0] !== K[0] || D.mouse[0][1] !== K[1]) && (D.mouse[1] = H.invert(D.mouse[0] = K)), clearTimeout(D.wheel);
    else {
      if (H.k === j) return;
      D.mouse = [K, H.invert(K)], dm(this), D.start();
    }
    Ch(C), D.wheel = setTimeout(L, m), D.zoom("mouse", i(x(_(H, j), D.mouse[0], D.mouse[1]), D.extent, o));
    function L() {
      D.wheel = null, D.end();
    }
  }
  function E(C, ...O) {
    if (p || !r.apply(this, arguments)) return;
    var D = C.currentTarget, H = S(this, O, !0).event(C), j = bn(C.view).on("mousemove.zoom", Q, !0).on("mouseup.zoom", W, !0), K = as(C, D), L = C.clientX, B = C.clientY;
    VO(C.view), E0(C), H.mouse = [K, this.__zoom.invert(K)], dm(this), H.start();
    function Q(z) {
      if (Ch(z), !H.moved) {
        var X = z.clientX - L, ae = z.clientY - B;
        H.moved = X * X + ae * ae > v;
      }
      H.event(z).zoom("mouse", i(x(H.that.__zoom, H.mouse[0] = as(z, D), H.mouse[1]), H.extent, o));
    }
    function W(z) {
      j.on("mousemove.zoom mouseup.zoom", null), GO(z.view, H.moved), Ch(z), H.event(z).end();
    }
  }
  function M(C, ...O) {
    if (r.apply(this, arguments)) {
      var D = this.__zoom, H = as(C.changedTouches ? C.changedTouches[0] : C, this), j = D.invert(H), K = D.k * (C.shiftKey ? 0.5 : 2), L = i(x(_(D, K), H, j), e.apply(this, O), o);
      Ch(C), l > 0 ? bn(this).transition().duration(l).call(T, L, H, C) : bn(this).call(g.transform, L, H, C);
    }
  }
  function N(C, ...O) {
    if (r.apply(this, arguments)) {
      var D = C.touches, H = D.length, j = S(this, O, C.changedTouches.length === H).event(C), K, L, B, Q;
      for (E0(C), L = 0; L < H; ++L)
        B = D[L], Q = as(B, this), Q = [Q, this.__zoom.invert(Q), B.identifier], j.touch0 ? !j.touch1 && j.touch0[2] !== Q[2] && (j.touch1 = Q, j.taps = 0) : (j.touch0 = Q, K = !0, j.taps = 1 + !!h);
      h && (h = clearTimeout(h)), K && (j.taps < 2 && (d = Q[0], h = setTimeout(function() {
        h = null;
      }, f)), dm(this), j.start());
    }
  }
  function k(C, ...O) {
    if (this.__zooming) {
      var D = S(this, O).event(C), H = C.changedTouches, j = H.length, K, L, B, Q;
      for (Ch(C), K = 0; K < j; ++K)
        L = H[K], B = as(L, this), D.touch0 && D.touch0[2] === L.identifier ? D.touch0[0] = B : D.touch1 && D.touch1[2] === L.identifier && (D.touch1[0] = B);
      if (L = D.that.__zoom, D.touch1) {
        var W = D.touch0[0], z = D.touch0[1], X = D.touch1[0], ae = D.touch1[1], ue = (ue = X[0] - W[0]) * ue + (ue = X[1] - W[1]) * ue, ge = (ge = ae[0] - z[0]) * ge + (ge = ae[1] - z[1]) * ge;
        L = _(L, Math.sqrt(ue / ge)), B = [(W[0] + X[0]) / 2, (W[1] + X[1]) / 2], Q = [(z[0] + ae[0]) / 2, (z[1] + ae[1]) / 2];
      } else if (D.touch0) B = D.touch0[0], Q = D.touch0[1];
      else return;
      D.zoom("touch", i(x(L, B, Q), D.extent, o));
    }
  }
  function U(C, ...O) {
    if (this.__zooming) {
      var D = S(this, O).event(C), H = C.changedTouches, j = H.length, K, L;
      for (E0(C), p && clearTimeout(p), p = setTimeout(function() {
        p = null;
      }, f), K = 0; K < j; ++K)
        L = H[K], D.touch0 && D.touch0[2] === L.identifier ? delete D.touch0 : D.touch1 && D.touch1[2] === L.identifier && delete D.touch1;
      if (D.touch1 && !D.touch0 && (D.touch0 = D.touch1, delete D.touch1), D.touch0) D.touch0[1] = this.__zoom.invert(D.touch0[0]);
      else if (D.end(), D.taps === 2 && (L = as(L, this), Math.hypot(d[0] - L[0], d[1] - L[1]) < y)) {
        var B = bn(this).on("dblclick.zoom");
        B && B.apply(this, arguments);
      }
    }
  }
  return g.wheelDelta = function(C) {
    return arguments.length ? (n = typeof C == "function" ? C : Df(+C), g) : n;
  }, g.filter = function(C) {
    return arguments.length ? (r = typeof C == "function" ? C : Df(!!C), g) : r;
  }, g.touchable = function(C) {
    return arguments.length ? (s = typeof C == "function" ? C : Df(!!C), g) : s;
  }, g.extent = function(C) {
    return arguments.length ? (e = typeof C == "function" ? C : Df([[+C[0][0], +C[0][1]], [+C[1][0], +C[1][1]]]), g) : e;
  }, g.scaleExtent = function(C) {
    return arguments.length ? (a[0] = +C[0], a[1] = +C[1], g) : [a[0], a[1]];
  }, g.translateExtent = function(C) {
    return arguments.length ? (o[0][0] = +C[0][0], o[1][0] = +C[1][0], o[0][1] = +C[0][1], o[1][1] = +C[1][1], g) : [[o[0][0], o[0][1]], [o[1][0], o[1][1]]];
  }, g.constrain = function(C) {
    return arguments.length ? (i = C, g) : i;
  }, g.duration = function(C) {
    return arguments.length ? (l = +C, g) : l;
  }, g.interpolate = function(C) {
    return arguments.length ? (u = C, g) : u;
  }, g.on = function() {
    var C = c.on.apply(c, arguments);
    return C === c ? g : C;
  }, g.clickDistance = function(C) {
    return arguments.length ? (v = (C = +C) * C, g) : Math.sqrt(v);
  }, g.tapDistance = function(C) {
    return arguments.length ? (y = +C, g) : y;
  }, g;
}
var qne = "Expected a function";
function Xne(r, e, i) {
  var n = !0, s = !0;
  if (typeof r != "function")
    throw new TypeError(qne);
  return Tm(i) && (n = "leading" in i ? !!i.leading : n, s = "trailing" in i ? !!i.trailing : s), tN(r, e, {
    leading: n,
    maxWait: e,
    trailing: s
  });
}
function $x(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function $ne(r) {
  if (Array.isArray(r)) return $x(r);
}
function $O(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function Yne(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function Kne(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function fn(r, e) {
  return r.get($O(r, e));
}
function IA(r, e, i) {
  Yne(r, e), e.set(r, i);
}
function OA(r, e, i) {
  return r.set($O(r, e), i), i;
}
function Zne(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, rse(n.key), n);
  }
}
function Qne(r, e, i) {
  return e && Zne(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function Jne(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function ese() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function tse(r) {
  return $ne(r) || Jne(r) || nse(r) || ese();
}
function ise(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function rse(r) {
  var e = ise(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function nse(r, e) {
  if (r) {
    if (typeof r == "string") return $x(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? $x(r, e) : void 0;
  }
}
var sse = 123, ase = function(r) {
  return "#".concat(Math.min(r, Math.pow(2, 24)).toString(16).padStart(6, "0"));
}, YO = function(r, e, i) {
  return (r << 16) + (e << 8) + i;
}, ose = function(r) {
  var e = it(r).toRgb(), i = e.r, n = e.g, s = e.b;
  return YO(i, n, s);
}, DA = function(r, e) {
  return r * sse % Math.pow(2, e);
}, jo = /* @__PURE__ */ new WeakMap(), Vs = /* @__PURE__ */ new WeakMap(), lse = /* @__PURE__ */ function() {
  function r() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6;
    Kne(this, r), IA(this, jo, void 0), IA(this, Vs, void 0), OA(Vs, this, e), this.reset();
  }
  return Qne(r, [{
    key: "reset",
    value: function() {
      OA(jo, this, ["__reserved for background__"]);
    }
  }, {
    key: "register",
    value: function(e) {
      if (fn(jo, this).length >= Math.pow(2, 24 - fn(Vs, this)))
        return null;
      var i = fn(jo, this).length, n = DA(i, fn(Vs, this)), s = ase(i + (n << 24 - fn(Vs, this)));
      return fn(jo, this).push(e), s;
    }
  }, {
    key: "lookup",
    value: function(e) {
      if (!e) return null;
      var i = typeof e == "string" ? ose(e) : YO.apply(void 0, tse(e));
      if (!i) return null;
      var n = i & Math.pow(2, 24 - fn(Vs, this)) - 1, s = i >> 24 - fn(Vs, this) & Math.pow(2, fn(Vs, this)) - 1;
      return DA(n, fn(Vs, this)) !== s || n >= fn(jo, this).length ? null : fn(jo, this)[n];
    }
    // How many bits to reserve for checksum. Will eat away into the usable size of the registry.
  }]);
}();
const { abs: Rh, cos: Gs, sin: Eu, acos: use, atan2: Nh, sqrt: Xa, pow: mn } = Math;
function Ph(r) {
  return r < 0 ? -mn(-r, 1 / 3) : mn(r, 1 / 3);
}
const KO = Math.PI, Lf = 2 * KO, $a = KO / 2, cse = 1e-6, M0 = Number.MAX_SAFE_INTEGER || 9007199254740991, A0 = Number.MIN_SAFE_INTEGER || -9007199254740991, hse = { x: 0, y: 0, z: 0 }, Oe = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(r, e) {
    const i = e(r);
    let n = i.x * i.x + i.y * i.y;
    return typeof i.z < "u" && (n += i.z * i.z), Xa(n);
  },
  compute: function(r, e, i) {
    if (r === 0)
      return e[0].t = 0, e[0];
    const n = e.length - 1;
    if (r === 1)
      return e[n].t = 1, e[n];
    const s = 1 - r;
    let a = e;
    if (n === 0)
      return e[0].t = r, e[0];
    if (n === 1) {
      const l = {
        x: s * a[0].x + r * a[1].x,
        y: s * a[0].y + r * a[1].y,
        t: r
      };
      return i && (l.z = s * a[0].z + r * a[1].z), l;
    }
    if (n < 4) {
      let l = s * s, u = r * r, c, h, d, p = 0;
      n === 2 ? (a = [a[0], a[1], a[2], hse], c = l, h = s * r * 2, d = u) : n === 3 && (c = l * s, h = l * r * 3, d = s * u * 3, p = r * u);
      const f = {
        x: c * a[0].x + h * a[1].x + d * a[2].x + p * a[3].x,
        y: c * a[0].y + h * a[1].y + d * a[2].y + p * a[3].y,
        t: r
      };
      return i && (f.z = c * a[0].z + h * a[1].z + d * a[2].z + p * a[3].z), f;
    }
    const o = JSON.parse(JSON.stringify(e));
    for (; o.length > 1; ) {
      for (let l = 0; l < o.length - 1; l++)
        o[l] = {
          x: o[l].x + (o[l + 1].x - o[l].x) * r,
          y: o[l].y + (o[l + 1].y - o[l].y) * r
        }, typeof o[l].z < "u" && (o[l].z = o[l].z + (o[l + 1].z - o[l].z) * r);
      o.splice(o.length - 1, 1);
    }
    return o[0].t = r, o[0];
  },
  computeWithRatios: function(r, e, i, n) {
    const s = 1 - r, a = i, o = e;
    let l = a[0], u = a[1], c = a[2], h = a[3], d;
    if (l *= s, u *= r, o.length === 2)
      return d = l + u, {
        x: (l * o[0].x + u * o[1].x) / d,
        y: (l * o[0].y + u * o[1].y) / d,
        z: n ? (l * o[0].z + u * o[1].z) / d : !1,
        t: r
      };
    if (l *= s, u *= 2 * s, c *= r * r, o.length === 3)
      return d = l + u + c, {
        x: (l * o[0].x + u * o[1].x + c * o[2].x) / d,
        y: (l * o[0].y + u * o[1].y + c * o[2].y) / d,
        z: n ? (l * o[0].z + u * o[1].z + c * o[2].z) / d : !1,
        t: r
      };
    if (l *= s, u *= 1.5 * s, c *= 3 * s, h *= r * r * r, o.length === 4)
      return d = l + u + c + h, {
        x: (l * o[0].x + u * o[1].x + c * o[2].x + h * o[3].x) / d,
        y: (l * o[0].y + u * o[1].y + c * o[2].y + h * o[3].y) / d,
        z: n ? (l * o[0].z + u * o[1].z + c * o[2].z + h * o[3].z) / d : !1,
        t: r
      };
  },
  derive: function(r, e) {
    const i = [];
    for (let n = r, s = n.length, a = s - 1; s > 1; s--, a--) {
      const o = [];
      for (let l = 0, u; l < a; l++)
        u = {
          x: a * (n[l + 1].x - n[l].x),
          y: a * (n[l + 1].y - n[l].y)
        }, e && (u.z = a * (n[l + 1].z - n[l].z)), o.push(u);
      i.push(o), n = o;
    }
    return i;
  },
  between: function(r, e, i) {
    return e <= r && r <= i || Oe.approximately(r, e) || Oe.approximately(r, i);
  },
  approximately: function(r, e, i) {
    return Rh(r - e) <= (i || cse);
  },
  length: function(r) {
    const e = Oe.Tvalues.length;
    let i = 0;
    for (let n = 0, s; n < e; n++)
      s = 0.5 * Oe.Tvalues[n] + 0.5, i += Oe.Cvalues[n] * Oe.arcfn(s, r);
    return 0.5 * i;
  },
  map: function(r, e, i, n, s) {
    const a = i - e, o = s - n, l = r - e, u = l / a;
    return n + o * u;
  },
  lerp: function(r, e, i) {
    const n = {
      x: e.x + r * (i.x - e.x),
      y: e.y + r * (i.y - e.y)
    };
    return e.z !== void 0 && i.z !== void 0 && (n.z = e.z + r * (i.z - e.z)), n;
  },
  pointToString: function(r) {
    let e = r.x + "/" + r.y;
    return typeof r.z < "u" && (e += "/" + r.z), e;
  },
  pointsToString: function(r) {
    return "[" + r.map(Oe.pointToString).join(", ") + "]";
  },
  copy: function(r) {
    return JSON.parse(JSON.stringify(r));
  },
  angle: function(r, e, i) {
    const n = e.x - r.x, s = e.y - r.y, a = i.x - r.x, o = i.y - r.y, l = n * o - s * a, u = n * a + s * o;
    return Nh(l, u);
  },
  // round as string, to avoid rounding errors
  round: function(r, e) {
    const i = "" + r, n = i.indexOf(".");
    return parseFloat(i.substring(0, n + 1 + e));
  },
  dist: function(r, e) {
    const i = r.x - e.x, n = r.y - e.y;
    return Xa(i * i + n * n);
  },
  closest: function(r, e) {
    let i = mn(2, 63), n, s;
    return r.forEach(function(a, o) {
      s = Oe.dist(e, a), s < i && (i = s, n = o);
    }), { mdist: i, mpos: n };
  },
  abcratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const i = mn(r, e) + mn(1 - r, e), n = i - 1;
    return Rh(n / i);
  },
  projectionratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const i = mn(1 - r, e), n = mn(r, e) + i;
    return i / n;
  },
  lli8: function(r, e, i, n, s, a, o, l) {
    const u = (r * n - e * i) * (s - o) - (r - i) * (s * l - a * o), c = (r * n - e * i) * (a - l) - (e - n) * (s * l - a * o), h = (r - i) * (a - l) - (e - n) * (s - o);
    return h == 0 ? !1 : { x: u / h, y: c / h };
  },
  lli4: function(r, e, i, n) {
    const s = r.x, a = r.y, o = e.x, l = e.y, u = i.x, c = i.y, h = n.x, d = n.y;
    return Oe.lli8(s, a, o, l, u, c, h, d);
  },
  lli: function(r, e) {
    return Oe.lli4(r, r.c, e, e.c);
  },
  makeline: function(r, e) {
    return new oi(
      r.x,
      r.y,
      (r.x + e.x) / 2,
      (r.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(r) {
    let e = M0, i = M0, n = A0, s = A0;
    return r.forEach(function(a) {
      const o = a.bbox();
      e > o.x.min && (e = o.x.min), i > o.y.min && (i = o.y.min), n < o.x.max && (n = o.x.max), s < o.y.max && (s = o.y.max);
    }), {
      x: { min: e, mid: (e + n) / 2, max: n, size: n - e },
      y: { min: i, mid: (i + s) / 2, max: s, size: s - i }
    };
  },
  shapeintersections: function(r, e, i, n, s) {
    if (!Oe.bboxoverlap(e, n)) return [];
    const a = [], o = [r.startcap, r.forward, r.back, r.endcap], l = [i.startcap, i.forward, i.back, i.endcap];
    return o.forEach(function(u) {
      u.virtual || l.forEach(function(c) {
        if (c.virtual) return;
        const h = u.intersects(c, s);
        h.length > 0 && (h.c1 = u, h.c2 = c, h.s1 = r, h.s2 = i, a.push(h));
      });
    }), a;
  },
  makeshape: function(r, e, i) {
    const n = e.points.length, s = r.points.length, a = Oe.makeline(e.points[n - 1], r.points[0]), o = Oe.makeline(r.points[s - 1], e.points[0]), l = {
      startcap: a,
      forward: r,
      back: e,
      endcap: o,
      bbox: Oe.findbbox([a, r, e, o])
    };
    return l.intersections = function(u) {
      return Oe.shapeintersections(
        l,
        l.bbox,
        u,
        u.bbox,
        i
      );
    }, l;
  },
  getminmax: function(r, e, i) {
    if (!i) return { min: 0, max: 0 };
    let n = M0, s = A0, a, o;
    i.indexOf(0) === -1 && (i = [0].concat(i)), i.indexOf(1) === -1 && i.push(1);
    for (let l = 0, u = i.length; l < u; l++)
      a = i[l], o = r.get(a), o[e] < n && (n = o[e]), o[e] > s && (s = o[e]);
    return { min: n, mid: (n + s) / 2, max: s, size: s - n };
  },
  align: function(r, e) {
    const i = e.p1.x, n = e.p1.y, s = -Nh(e.p2.y - n, e.p2.x - i), a = function(o) {
      return {
        x: (o.x - i) * Gs(s) - (o.y - n) * Eu(s),
        y: (o.x - i) * Eu(s) + (o.y - n) * Gs(s)
      };
    };
    return r.map(a);
  },
  roots: function(r, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const i = r.length - 1, n = Oe.align(r, e), s = function(w) {
      return 0 <= w && w <= 1;
    };
    if (i === 2) {
      const w = n[0].y, A = n[1].y, E = n[2].y, M = w - 2 * A + E;
      if (M !== 0) {
        const N = -Xa(A * A - w * E), k = -w + A, U = -(N + k) / M, C = -(-N + k) / M;
        return [U, C].filter(s);
      } else if (A !== E && M === 0)
        return [(2 * A - E) / (2 * A - 2 * E)].filter(s);
      return [];
    }
    const a = n[0].y, o = n[1].y, l = n[2].y, u = n[3].y;
    let c = -a + 3 * o - 3 * l + u, h = 3 * a - 6 * o + 3 * l, d = -3 * a + 3 * o, p = a;
    if (Oe.approximately(c, 0)) {
      if (Oe.approximately(h, 0))
        return Oe.approximately(d, 0) ? [] : [-p / d].filter(s);
      const w = Xa(d * d - 4 * h * p), A = 2 * h;
      return [(w - d) / A, (-d - w) / A].filter(s);
    }
    h /= c, d /= c, p /= c;
    const f = (3 * d - h * h) / 3, m = f / 3, v = (2 * h * h * h - 9 * h * d + 27 * p) / 27, y = v / 2, g = y * y + m * m * m;
    let _, x, b, T, S;
    if (g < 0) {
      const w = -f / 3, A = w * w * w, E = Xa(A), M = -v / (2 * E), N = M < -1 ? -1 : M > 1 ? 1 : M, k = use(N), U = Ph(E), C = 2 * U;
      return b = C * Gs(k / 3) - h / 3, T = C * Gs((k + Lf) / 3) - h / 3, S = C * Gs((k + 2 * Lf) / 3) - h / 3, [b, T, S].filter(s);
    } else {
      if (g === 0)
        return _ = y < 0 ? Ph(-y) : -Ph(y), b = 2 * _ - h / 3, T = -_ - h / 3, [b, T].filter(s);
      {
        const w = Xa(g);
        return _ = Ph(-y + w), x = Ph(y + w), [_ - x - h / 3].filter(s);
      }
    }
  },
  droots: function(r) {
    if (r.length === 3) {
      const e = r[0], i = r[1], n = r[2], s = e - 2 * i + n;
      if (s !== 0) {
        const a = -Xa(i * i - e * n), o = -e + i, l = -(a + o) / s, u = -(-a + o) / s;
        return [l, u];
      } else if (i !== n && s === 0)
        return [(2 * i - n) / (2 * (i - n))];
      return [];
    }
    if (r.length === 2) {
      const e = r[0], i = r[1];
      return e !== i ? [e / (e - i)] : [];
    }
    return [];
  },
  curvature: function(r, e, i, n, s) {
    let a, o, l, u, c = 0, h = 0;
    const d = Oe.compute(r, e), p = Oe.compute(r, i), f = d.x * d.x + d.y * d.y;
    if (n ? (a = Xa(
      mn(d.y * p.z - p.y * d.z, 2) + mn(d.z * p.x - p.z * d.x, 2) + mn(d.x * p.y - p.x * d.y, 2)
    ), o = mn(f + d.z * d.z, 3 / 2)) : (a = d.x * p.y - d.y * p.x, o = mn(f, 3 / 2)), a === 0 || o === 0)
      return { k: 0, r: 0 };
    if (c = a / o, h = o / a, !s) {
      const m = Oe.curvature(r - 1e-3, e, i, n, !0).k, v = Oe.curvature(r + 1e-3, e, i, n, !0).k;
      u = (v - c + (c - m)) / 2, l = (Rh(v - c) + Rh(c - m)) / 2;
    }
    return { k: c, r: h, dk: u, adk: l };
  },
  inflections: function(r) {
    if (r.length < 4) return [];
    const e = Oe.align(r, { p1: r[0], p2: r.slice(-1)[0] }), i = e[2].x * e[1].y, n = e[3].x * e[1].y, s = e[1].x * e[2].y, a = e[3].x * e[2].y, o = 18 * (-3 * i + 2 * n + 3 * s - a), l = 18 * (3 * i - n - 3 * s), u = 18 * (s - i);
    if (Oe.approximately(o, 0)) {
      if (!Oe.approximately(l, 0)) {
        let p = -u / l;
        if (0 <= p && p <= 1) return [p];
      }
      return [];
    }
    const c = 2 * o;
    if (Oe.approximately(c, 0)) return [];
    const h = l * l - 4 * o * u;
    if (h < 0) return [];
    const d = Math.sqrt(h);
    return [(d - l) / c, -(l + d) / c].filter(function(p) {
      return 0 <= p && p <= 1;
    });
  },
  bboxoverlap: function(r, e) {
    const i = ["x", "y"], n = i.length;
    for (let s = 0, a, o, l, u; s < n; s++)
      if (a = i[s], o = r[a].mid, l = e[a].mid, u = (r[a].size + e[a].size) / 2, Rh(o - l) >= u) return !1;
    return !0;
  },
  expandbox: function(r, e) {
    e.x.min < r.x.min && (r.x.min = e.x.min), e.y.min < r.y.min && (r.y.min = e.y.min), e.z && e.z.min < r.z.min && (r.z.min = e.z.min), e.x.max > r.x.max && (r.x.max = e.x.max), e.y.max > r.y.max && (r.y.max = e.y.max), e.z && e.z.max > r.z.max && (r.z.max = e.z.max), r.x.mid = (r.x.min + r.x.max) / 2, r.y.mid = (r.y.min + r.y.max) / 2, r.z && (r.z.mid = (r.z.min + r.z.max) / 2), r.x.size = r.x.max - r.x.min, r.y.size = r.y.max - r.y.min, r.z && (r.z.size = r.z.max - r.z.min);
  },
  pairiteration: function(r, e, i) {
    const n = r.bbox(), s = e.bbox(), a = 1e5, o = i || 0.5;
    if (n.x.size + n.y.size < o && s.x.size + s.y.size < o)
      return [
        (a * (r._t1 + r._t2) / 2 | 0) / a + "/" + (a * (e._t1 + e._t2) / 2 | 0) / a
      ];
    let l = r.split(0.5), u = e.split(0.5), c = [
      { left: l.left, right: u.left },
      { left: l.left, right: u.right },
      { left: l.right, right: u.right },
      { left: l.right, right: u.left }
    ];
    c = c.filter(function(d) {
      return Oe.bboxoverlap(d.left.bbox(), d.right.bbox());
    });
    let h = [];
    return c.length === 0 || (c.forEach(function(d) {
      h = h.concat(
        Oe.pairiteration(d.left, d.right, o)
      );
    }), h = h.filter(function(d, p) {
      return h.indexOf(d) === p;
    })), h;
  },
  getccenter: function(r, e, i) {
    const n = e.x - r.x, s = e.y - r.y, a = i.x - e.x, o = i.y - e.y, l = n * Gs($a) - s * Eu($a), u = n * Eu($a) + s * Gs($a), c = a * Gs($a) - o * Eu($a), h = a * Eu($a) + o * Gs($a), d = (r.x + e.x) / 2, p = (r.y + e.y) / 2, f = (e.x + i.x) / 2, m = (e.y + i.y) / 2, v = d + l, y = p + u, g = f + c, _ = m + h, x = Oe.lli8(d, p, v, y, f, m, g, _), b = Oe.dist(x, r);
    let T = Nh(r.y - x.y, r.x - x.x), S = Nh(e.y - x.y, e.x - x.x), w = Nh(i.y - x.y, i.x - x.x), A;
    return T < w ? ((T > S || S > w) && (T += Lf), T > w && (A = w, w = T, T = A)) : w < S && S < T ? (A = w, w = T, T = A) : w += Lf, x.s = T, x.e = w, x.r = b, x;
  },
  numberSort: function(r, e) {
    return r - e;
  }
};
class ad {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return Oe.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, i) {
      return e + i;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var i = e[0].bbox(), n = 1; n < e.length; n++)
      Oe.expandbox(i, e[n].bbox());
    return i;
  }
  offset(e) {
    const i = [];
    return this.curves.forEach(function(n) {
      i.push(...n.offset(e));
    }), new ad(i);
  }
}
const { abs: Ih, min: LA, max: UA, cos: dse, sin: pse, acos: fse, sqrt: Oh } = Math, mse = Math.PI;
class oi {
  constructor(e) {
    let i = e && e.forEach ? e : Array.from(arguments).slice(), n = !1;
    if (typeof i[0] == "object") {
      n = i.length;
      const f = [];
      i.forEach(function(m) {
        ["x", "y", "z"].forEach(function(v) {
          typeof m[v] < "u" && f.push(m[v]);
        });
      }), i = f;
    }
    let s = !1;
    const a = i.length;
    if (n) {
      if (n > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        s = !0;
      }
    } else if (a !== 6 && a !== 8 && a !== 9 && a !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const o = this._3d = !s && (a === 9 || a === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let f = 0, m = o ? 3 : 2; f < a; f += m) {
      var u = {
        x: i[f],
        y: i[f + 1]
      };
      o && (u.z = i[f + 2]), l.push(u);
    }
    const c = this.order = l.length - 1, h = this.dims = ["x", "y"];
    o && h.push("z"), this.dimlen = h.length;
    const d = Oe.align(l, { p1: l[0], p2: l[c] }), p = Oe.dist(l[0], l[c]);
    this._linear = d.reduce((f, m) => f + Ih(m.y), 0) < p / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, i, n, s) {
    if (typeof s > "u" && (s = 0.5), s === 0)
      return new oi(i, i, n);
    if (s === 1)
      return new oi(e, i, i);
    const a = oi.getABC(2, e, i, n, s);
    return new oi(e, a.A, n);
  }
  static cubicFromPoints(e, i, n, s, a) {
    typeof s > "u" && (s = 0.5);
    const o = oi.getABC(3, e, i, n, s);
    typeof a > "u" && (a = Oe.dist(i, o.C));
    const l = a * (1 - s) / s, u = Oe.dist(e, n), c = (n.x - e.x) / u, h = (n.y - e.y) / u, d = a * c, p = a * h, f = l * c, m = l * h, v = { x: i.x - d, y: i.y - p }, y = { x: i.x + f, y: i.y + m }, g = o.A, _ = { x: g.x + (v.x - g.x) / (1 - s), y: g.y + (v.y - g.y) / (1 - s) }, x = { x: g.x + (y.x - g.x) / s, y: g.y + (y.y - g.y) / s }, b = { x: e.x + (_.x - e.x) / s, y: e.y + (_.y - e.y) / s }, T = {
      x: n.x + (x.x - n.x) / (1 - s),
      y: n.y + (x.y - n.y) / (1 - s)
    };
    return new oi(e, b, T, n);
  }
  static getUtils() {
    return Oe;
  }
  getUtils() {
    return oi.getUtils();
  }
  static get PolyBezier() {
    return ad;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return Oe.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, i = e[0].x, n = e[0].y, s = ["M", i, n, this.order === 2 ? "Q" : "C"];
    for (let a = 1, o = e.length; a < o; a++)
      s.push(e[a].x), s.push(e[a].y);
    return s.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, i) {
      return "" + i + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = Oe.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, i = Oe.angle(e[0], e[this.order], e[1]);
    this.clockwise = i > 0;
  }
  length() {
    return Oe.length(this.derivative.bind(this));
  }
  static getABC(e = 2, i, n, s, a = 0.5) {
    const o = Oe.projectionratio(a, e), l = 1 - o, u = {
      x: o * i.x + l * s.x,
      y: o * i.y + l * s.y
    }, c = Oe.abcratio(a, e);
    return { A: {
      x: n.x + (n.x - u.x) / c,
      y: n.y + (n.y - u.y) / c
    }, B: n, C: u, S: i, E: s };
  }
  getABC(e, i) {
    i = i || this.get(e);
    let n = this.points[0], s = this.points[this.order];
    return oi.getABC(this.order, n, i, s, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let i = 0, n, s; i < e; i++)
      s = i / (e - 1), n = this.compute(s), n.t = s, this._lut.push(n);
    return this._lut;
  }
  on(e, i) {
    i = i || 5;
    const n = this.getLUT(), s = [];
    for (let a = 0, o, l = 0; a < n.length; a++)
      o = n[a], Oe.dist(o, e) < i && (s.push(o), l += a / n.length);
    return s.length ? t /= s.length : !1;
  }
  project(e) {
    const i = this.getLUT(), n = i.length - 1, s = Oe.closest(i, e), a = s.mpos, o = (a - 1) / n, l = (a + 1) / n, u = 0.1 / n;
    let c = s.mdist, h = o, d = h, p;
    c += 1;
    for (let f; h < l + u; h += u)
      p = this.compute(h), f = Oe.dist(e, p), f < c && (c = f, d = h);
    return d = d < 0 ? 0 : d > 1 ? 1 : d, p = this.compute(d), p.t = d, p.d = c, p;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? Oe.computeWithRatios(e, this.points, this.ratios, this._3d) : Oe.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, i = [e[0]], n = e.length;
    for (let s = 1, a, o; s < n; s++)
      a = e[s], o = e[s - 1], i[s] = {
        x: (n - s) / n * a.x + s / n * o.x,
        y: (n - s) / n * a.y + s / n * o.y
      };
    return i[n] = e[n - 1], new oi(i);
  }
  derivative(e) {
    return Oe.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return Oe.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new oi(Oe.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return Oe.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return Oe.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const i = this.derivative(e), n = Oh(i.x * i.x + i.y * i.y);
    return { t: e, x: -i.y / n, y: i.x / n };
  }
  __normal3(e) {
    const i = this.derivative(e), n = this.derivative(e + 0.01), s = Oh(i.x * i.x + i.y * i.y + i.z * i.z), a = Oh(n.x * n.x + n.y * n.y + n.z * n.z);
    i.x /= s, i.y /= s, i.z /= s, n.x /= a, n.y /= a, n.z /= a;
    const o = {
      x: n.y * i.z - n.z * i.y,
      y: n.z * i.x - n.x * i.z,
      z: n.x * i.y - n.y * i.x
    }, l = Oh(o.x * o.x + o.y * o.y + o.z * o.z);
    o.x /= l, o.y /= l, o.z /= l;
    const u = [
      o.x * o.x,
      o.x * o.y - o.z,
      o.x * o.z + o.y,
      o.x * o.y + o.z,
      o.y * o.y,
      o.y * o.z - o.x,
      o.x * o.z - o.y,
      o.y * o.z + o.x,
      o.z * o.z
    ];
    return {
      t: e,
      x: u[0] * i.x + u[1] * i.y + u[2] * i.z,
      y: u[3] * i.x + u[4] * i.y + u[5] * i.z,
      z: u[6] * i.x + u[7] * i.y + u[8] * i.z
    };
  }
  hull(e) {
    let i = this.points, n = [], s = [], a = 0;
    for (s[a++] = i[0], s[a++] = i[1], s[a++] = i[2], this.order === 3 && (s[a++] = i[3]); i.length > 1; ) {
      n = [];
      for (let o = 0, l, u = i.length - 1; o < u; o++)
        l = Oe.lerp(e, i[o], i[o + 1]), s[a++] = l, n.push(l);
      i = n;
    }
    return s;
  }
  split(e, i) {
    if (e === 0 && i)
      return this.split(i).left;
    if (i === 1)
      return this.split(e).right;
    const n = this.hull(e), s = {
      left: this.order === 2 ? new oi([n[0], n[3], n[5]]) : new oi([n[0], n[4], n[7], n[9]]),
      right: this.order === 2 ? new oi([n[5], n[4], n[2]]) : new oi([n[9], n[8], n[6], n[3]]),
      span: n
    };
    return s.left._t1 = Oe.map(0, 0, 1, this._t1, this._t2), s.left._t2 = Oe.map(e, 0, 1, this._t1, this._t2), s.right._t1 = Oe.map(e, 0, 1, this._t1, this._t2), s.right._t2 = Oe.map(1, 0, 1, this._t1, this._t2), i ? (i = Oe.map(i, e, 1, 0, 1), s.right.split(i).left) : s;
  }
  extrema() {
    const e = {};
    let i = [];
    return this.dims.forEach(
      (function(n) {
        let s = function(o) {
          return o[n];
        }, a = this.dpoints[0].map(s);
        e[n] = Oe.droots(a), this.order === 3 && (a = this.dpoints[1].map(s), e[n] = e[n].concat(Oe.droots(a))), e[n] = e[n].filter(function(o) {
          return o >= 0 && o <= 1;
        }), i = i.concat(e[n].sort(Oe.numberSort));
      }).bind(this)
    ), e.values = i.sort(Oe.numberSort).filter(function(n, s) {
      return i.indexOf(n) === s;
    }), e;
  }
  bbox() {
    const e = this.extrema(), i = {};
    return this.dims.forEach(
      (function(n) {
        i[n] = Oe.getminmax(this, n, e[n]);
      }).bind(this)
    ), i;
  }
  overlaps(e) {
    const i = this.bbox(), n = e.bbox();
    return Oe.bboxoverlap(i, n);
  }
  offset(e, i) {
    if (typeof i < "u") {
      const n = this.get(e), s = this.normal(e), a = {
        c: n,
        n: s,
        x: n.x + s.x * i,
        y: n.y + s.y * i
      };
      return this._3d && (a.z = n.z + s.z * i), a;
    }
    if (this._linear) {
      const n = this.normal(0), s = this.points.map(function(a) {
        const o = {
          x: a.x + e * n.x,
          y: a.y + e * n.y
        };
        return a.z && n.z && (o.z = a.z + e * n.z), o;
      });
      return [new oi(s)];
    }
    return this.reduce().map(function(n) {
      return n._linear ? n.offset(e)[0] : n.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const s = Oe.angle(this.points[0], this.points[3], this.points[1]), a = Oe.angle(this.points[0], this.points[3], this.points[2]);
      if (s > 0 && a < 0 || s < 0 && a > 0) return !1;
    }
    const e = this.normal(0), i = this.normal(1);
    let n = e.x * i.x + e.y * i.y;
    return this._3d && (n += e.z * i.z), Ih(fse(n)) < mse / 3;
  }
  reduce() {
    let e, i = 0, n = 0, s = 0.01, a, o = [], l = [], u = this.extrema().values;
    for (u.indexOf(0) === -1 && (u = [0].concat(u)), u.indexOf(1) === -1 && u.push(1), i = u[0], e = 1; e < u.length; e++)
      n = u[e], a = this.split(i, n), a._t1 = i, a._t2 = n, o.push(a), i = n;
    return o.forEach(function(c) {
      for (i = 0, n = 0; n <= 1; )
        for (n = i + s; n <= 1 + s; n += s)
          if (a = c.split(i, n), !a.simple()) {
            if (n -= s, Ih(i - n) < s)
              return [];
            a = c.split(i, n), a._t1 = Oe.map(i, 0, 1, c._t1, c._t2), a._t2 = Oe.map(n, 0, 1, c._t1, c._t2), l.push(a), i = n;
            break;
          }
      i < 1 && (a = c.split(i, 1), a._t1 = Oe.map(i, 0, 1, c._t1, c._t2), a._t2 = c._t2, l.push(a));
    }), l;
  }
  translate(e, i, n) {
    n = typeof n == "number" ? n : i;
    const s = this.order;
    let a = this.points.map((o, l) => (1 - l / s) * i + l / s * n);
    return new oi(
      this.points.map((o, l) => ({
        x: o.x + e.x * a[l],
        y: o.y + e.y * a[l]
      }))
    );
  }
  scale(e) {
    const i = this.order;
    let n = !1;
    if (typeof e == "function" && (n = e), n && i === 2)
      return this.raise().scale(n);
    const s = this.clockwise, a = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        n ? n(0) : e,
        n ? n(1) : e
      );
    const o = n ? n(0) : e, l = n ? n(1) : e, u = [this.offset(0, 10), this.offset(1, 10)], c = [], h = Oe.lli4(u[0], u[0].c, u[1], u[1].c);
    if (!h)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(d) {
      const p = c[d * i] = Oe.copy(a[d * i]);
      p.x += (d ? l : o) * u[d].n.x, p.y += (d ? l : o) * u[d].n.y;
    }), n ? ([0, 1].forEach(function(d) {
      if (!(i === 2 && d)) {
        var p = a[d + 1], f = {
          x: p.x - h.x,
          y: p.y - h.y
        }, m = n ? n((d + 1) / i) : e;
        n && !s && (m = -m);
        var v = Oh(f.x * f.x + f.y * f.y);
        f.x /= v, f.y /= v, c[d + 1] = {
          x: p.x + m * f.x,
          y: p.y + m * f.y
        };
      }
    }), new oi(c)) : ([0, 1].forEach((d) => {
      if (i === 2 && d) return;
      const p = c[d * i], f = this.derivative(d), m = { x: p.x + f.x, y: p.y + f.y };
      c[d + 1] = Oe.lli4(p, m, h, a[d + 1]);
    }), new oi(c));
  }
  outline(e, i, n, s) {
    if (i = i === void 0 ? e : i, this._linear) {
      const T = this.normal(0), S = this.points[0], w = this.points[this.points.length - 1];
      let A, E, M;
      n === void 0 && (n = e, s = i), A = { x: S.x + T.x * e, y: S.y + T.y * e }, M = { x: w.x + T.x * n, y: w.y + T.y * n }, E = { x: (A.x + M.x) / 2, y: (A.y + M.y) / 2 };
      const N = [A, E, M];
      A = { x: S.x - T.x * i, y: S.y - T.y * i }, M = { x: w.x - T.x * s, y: w.y - T.y * s }, E = { x: (A.x + M.x) / 2, y: (A.y + M.y) / 2 };
      const k = [M, E, A], U = Oe.makeline(k[2], N[0]), C = Oe.makeline(N[2], k[0]), O = [U, new oi(N), C, new oi(k)];
      return new ad(O);
    }
    const a = this.reduce(), o = a.length, l = [];
    let u = [], c, h = 0, d = this.length();
    const p = typeof n < "u" && typeof s < "u";
    function f(T, S, w, A, E) {
      return function(M) {
        const N = A / w, k = (A + E) / w, U = S - T;
        return Oe.map(M, 0, 1, T + N * U, T + k * U);
      };
    }
    a.forEach(function(T) {
      const S = T.length();
      p ? (l.push(
        T.scale(f(e, n, d, h, S))
      ), u.push(
        T.scale(f(-i, -s, d, h, S))
      )) : (l.push(T.scale(e)), u.push(T.scale(-i))), h += S;
    }), u = u.map(function(T) {
      return c = T.points, c[3] ? T.points = [c[3], c[2], c[1], c[0]] : T.points = [c[2], c[1], c[0]], T;
    }).reverse();
    const m = l[0].points[0], v = l[o - 1].points[l[o - 1].points.length - 1], y = u[o - 1].points[u[o - 1].points.length - 1], g = u[0].points[0], _ = Oe.makeline(y, m), x = Oe.makeline(v, g), b = [_].concat(l).concat([x]).concat(u);
    return new ad(b);
  }
  outlineshapes(e, i, n) {
    i = i || e;
    const s = this.outline(e, i).curves, a = [];
    for (let o = 1, l = s.length; o < l / 2; o++) {
      const u = Oe.makeshape(
        s[o],
        s[l - o],
        n
      );
      u.startcap.virtual = o > 1, u.endcap.virtual = o < l / 2 - 1, a.push(u);
    }
    return a;
  }
  intersects(e, i) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof oi && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      i
    )) : this.selfintersects(i);
  }
  lineIntersects(e) {
    const i = LA(e.p1.x, e.p2.x), n = LA(e.p1.y, e.p2.y), s = UA(e.p1.x, e.p2.x), a = UA(e.p1.y, e.p2.y);
    return Oe.roots(this.points, e).filter((o) => {
      var l = this.get(o);
      return Oe.between(l.x, i, s) && Oe.between(l.y, n, a);
    });
  }
  selfintersects(e) {
    const i = this.reduce(), n = i.length - 2, s = [];
    for (let a = 0, o, l, u; a < n; a++)
      l = i.slice(a, a + 1), u = i.slice(a + 2), o = this.curveintersects(l, u, e), s.push(...o);
    return s;
  }
  curveintersects(e, i, n) {
    const s = [];
    e.forEach(function(o) {
      i.forEach(function(l) {
        o.overlaps(l) && s.push({ left: o, right: l });
      });
    });
    let a = [];
    return s.forEach(function(o) {
      const l = Oe.pairiteration(
        o.left,
        o.right,
        n
      );
      l.length > 0 && (a = a.concat(l));
    }), a;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, i, n, s) {
    const a = (s - n) / 4, o = this.get(n + a), l = this.get(s - a), u = Oe.dist(e, i), c = Oe.dist(e, o), h = Oe.dist(e, l);
    return Ih(c - u) + Ih(h - u);
  }
  _iterate(e, i) {
    let n = 0, s = 1, a;
    do {
      a = 0, s = 1;
      let o = this.get(n), l, u, c, h, d = !1, p = !1, f, m = s, v = 1;
      do
        if (p = d, h = c, m = (n + s) / 2, l = this.get(m), u = this.get(s), c = Oe.getccenter(o, l, u), c.interval = {
          start: n,
          end: s
        }, d = this._error(c, o, n, s) <= e, f = p && !d, f || (v = s), d) {
          if (s >= 1) {
            if (c.interval.end = v = 1, h = c, s > 1) {
              let y = {
                x: c.x + c.r * dse(c.e),
                y: c.y + c.r * pse(c.e)
              };
              c.e += Oe.angle({ x: c.x, y: c.y }, y, this.get(1));
            }
            break;
          }
          s = s + (s - n) / 2;
        } else
          s = m;
      while (!f && a++ < 100);
      if (a >= 100)
        break;
      h = h || c, i.push(h), n = v;
    } while (s < 1);
    return i;
  }
}
function Yx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function gse(r) {
  if (Array.isArray(r)) return r;
}
function yse(r) {
  if (Array.isArray(r)) return Yx(r);
}
function vse(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function bse(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function xse() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _se() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Tse(r, e) {
  if (r == null) return {};
  var i, n, s = Sse(r, e);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(r);
    for (n = 0; n < a.length; n++) i = a[n], e.includes(i) || {}.propertyIsEnumerable.call(r, i) && (s[i] = r[i]);
  }
  return s;
}
function Sse(r, e) {
  if (r == null) return {};
  var i = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    i[n] = r[n];
  }
  return i;
}
function wse(r, e) {
  return gse(r) || bse(r, e) || ZO(r, e) || xse();
}
function Ese(r) {
  return yse(r) || vse(r) || ZO(r) || _se();
}
function Mse(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function Ase(r) {
  var e = Mse(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function ZO(r, e) {
  if (r) {
    if (typeof r == "string") return Yx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Yx(r, e) : void 0;
  }
}
var Cse = function() {
  var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = (e instanceof Array ? e.length ? e : [void 0] : [e]).map(function(l) {
    return {
      keyAccessor: l,
      isProp: !(l instanceof Function)
    };
  }), a = r.reduce(function(l, u) {
    var c = l, h = u;
    return s.forEach(function(d, p) {
      var f = d.keyAccessor, m = d.isProp, v;
      if (m) {
        var y = h, g = y[f], _ = Tse(y, [f].map(Ase));
        v = g, h = _;
      } else
        v = f(h, p);
      p + 1 < s.length ? (c.hasOwnProperty(v) || (c[v] = {}), c = c[v]) : i ? (c.hasOwnProperty(v) || (c[v] = []), c[v].push(h)) : c[v] = h;
    }), l;
  }, {});
  i instanceof Function && function l(u) {
    var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    c === s.length ? Object.keys(u).forEach(function(h) {
      return u[h] = i(u[h]);
    }) : Object.values(u).forEach(function(h) {
      return l(h, c + 1);
    });
  }(a);
  var o = a;
  return n && (o = [], function l(u) {
    var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    c.length === s.length ? o.push({
      keys: c,
      vals: u
    }) : Object.entries(u).forEach(function(h) {
      var d = wse(h, 2), p = d[0], f = d[1];
      return l(f, [].concat(Ese(c), [p]));
    });
  }(a), e instanceof Array && e.length === 0 && o.length === 1 && (o[0].keys = [])), o;
};
function Rse(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var Nse = `.force-graph-container canvas {
  display: block;
  user-select: none;
  outline: none;
  -webkit-tap-highlight-color: transparent;
}

.force-graph-container .clickable {
  cursor: pointer;
}

.force-graph-container .grabbable {
  cursor: move;
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

.force-graph-container .grabbable:active {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
}
`;
Rse(Nse);
function Kx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Pse(r) {
  if (Array.isArray(r)) return r;
}
function Ise(r) {
  if (Array.isArray(r)) return Kx(r);
}
function kA(r, e, i) {
  if (QO()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return s;
}
function Pd(r, e, i) {
  return (e = Fse(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function QO() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (QO = function() {
    return !!r;
  })();
}
function Ose(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function Dse(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function Lse() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Use() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function FA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function Mu(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? FA(Object(i), !0).forEach(function(n) {
      Pd(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : FA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function od(r, e) {
  return Pse(r) || Dse(r, e) || JO(r, e) || Lse();
}
function xn(r) {
  return Ise(r) || Ose(r) || JO(r) || Use();
}
function kse(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Fse(r) {
  var e = kse(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Zx(r) {
  "@babel/helpers - typeof";
  return Zx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Zx(r);
}
function JO(r, e) {
  if (r) {
    if (typeof r == "string") return Kx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Kx(r, e) : void 0;
  }
}
var Bse = Q_(hN);
function BA(r, e, i) {
  !e || typeof i != "string" || r.filter(function(n) {
    return !n[i];
  }).forEach(function(n) {
    n[i] = Bse(e(n));
  });
}
function zse(r, e) {
  var i = r.nodes, n = r.links, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = s.nodeFilter, o = a === void 0 ? function() {
    return !0;
  } : a, l = s.onLoopError, u = l === void 0 ? function(f) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(f.join(" -> "), ".");
  } : l, c = {};
  i.forEach(function(f) {
    return c[e(f)] = {
      data: f,
      out: [],
      depth: -1,
      skip: !o(f)
    };
  }), n.forEach(function(f) {
    var m = f.source, v = f.target, y = b(m), g = b(v);
    if (!c.hasOwnProperty(y)) throw "Missing source node with id: ".concat(y);
    if (!c.hasOwnProperty(g)) throw "Missing target node with id: ".concat(g);
    var _ = c[y], x = c[g];
    _.out.push(x);
    function b(T) {
      return Zx(T) === "object" ? e(T) : T;
    }
  });
  var h = [];
  p(Object.values(c));
  var d = Object.assign.apply(Object, [{}].concat(xn(Object.entries(c).filter(function(f) {
    var m = od(f, 2), v = m[1];
    return !v.skip;
  }).map(function(f) {
    var m = od(f, 2), v = m[0], y = m[1];
    return Pd({}, v, y.depth);
  }))));
  return d;
  function p(f) {
    for (var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, y = function() {
      var x = f[g];
      if (m.indexOf(x) !== -1) {
        var b = [].concat(xn(m.slice(m.indexOf(x))), [x]).map(function(T) {
          return e(T.data);
        });
        return h.some(function(T) {
          return T.length === b.length && T.every(function(S, w) {
            return S === b[w];
          });
        }) || (h.push(b), u(b)), 1;
      }
      v > x.depth && (x.depth = v, p(x.out, [].concat(xn(m), [x]), v + (x.skip ? 0 : 1)));
    }, g = 0, _ = f.length; g < _; g++)
      y();
  }
}
var jse = 2, pr = function(r, e) {
  return e.onNeedsRedraw && e.onNeedsRedraw();
}, zA = function(r, e) {
  if (!e.isShadow) {
    var i = et(e.linkDirectionalParticles);
    e.graphData.links.forEach(function(n) {
      var s = Math.round(Math.abs(i(n)));
      s ? n.__photons = xn(Array(s)).map(function() {
        return {};
      }) : delete n.__photons;
    });
  }
}, Qm = Pl({
  props: {
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        e.engineRunning = !1, zA(r, e);
      }
    },
    dagMode: {
      onChange: function(r, e) {
        !r && (e.graphData.nodes || []).forEach(function(i) {
          return i.fx = i.fy = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function(r) {
        return !0;
      }
    },
    onDagError: {
      triggerUpdate: !1
    },
    nodeRelSize: {
      default: 4,
      triggerUpdate: !1,
      onChange: pr
    },
    // area per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val",
      triggerUpdate: !1,
      onChange: pr
    },
    nodeColor: {
      default: "color",
      triggerUpdate: !1,
      onChange: pr
    },
    nodeAutoColorBy: {},
    nodeCanvasObject: {
      triggerUpdate: !1,
      onChange: pr
    },
    nodeCanvasObjectMode: {
      default: function() {
        return "replace";
      },
      triggerUpdate: !1,
      onChange: pr
    },
    nodeVisibility: {
      default: !0,
      triggerUpdate: !1,
      onChange: pr
    },
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0,
      triggerUpdate: !1,
      onChange: pr
    },
    linkColor: {
      default: "color",
      triggerUpdate: !1,
      onChange: pr
    },
    linkAutoColorBy: {},
    linkLineDash: {
      triggerUpdate: !1,
      onChange: pr
    },
    linkWidth: {
      default: 1,
      triggerUpdate: !1,
      onChange: pr
    },
    linkCurvature: {
      default: 0,
      triggerUpdate: !1,
      onChange: pr
    },
    linkCanvasObject: {
      triggerUpdate: !1,
      onChange: pr
    },
    linkCanvasObjectMode: {
      default: function() {
        return "replace";
      },
      triggerUpdate: !1,
      onChange: pr
    },
    linkDirectionalArrowLength: {
      default: 0,
      triggerUpdate: !1,
      onChange: pr
    },
    linkDirectionalArrowColor: {
      triggerUpdate: !1,
      onChange: pr
    },
    linkDirectionalArrowRelPos: {
      default: 0.5,
      triggerUpdate: !1,
      onChange: pr
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalParticles: {
      default: 0,
      triggerUpdate: !1,
      onChange: zA
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01,
      triggerUpdate: !1
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 4,
      triggerUpdate: !1
    },
    linkDirectionalParticleColor: {
      triggerUpdate: !1
    },
    globalScale: {
      default: 1,
      triggerUpdate: !1
    },
    d3AlphaMin: {
      default: 0,
      triggerUpdate: !1
    },
    d3AlphaDecay: {
      default: 0.0228,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.alphaDecay(r);
      }
    },
    d3AlphaTarget: {
      default: 0,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.alphaTarget(r);
      }
    },
    d3VelocityDecay: {
      default: 0.4,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.velocityDecay(r);
      }
    },
    warmupTicks: {
      default: 0,
      triggerUpdate: !1
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      default: 1 / 0,
      triggerUpdate: !1
    },
    cooldownTime: {
      default: 15e3,
      triggerUpdate: !1
    },
    // ms
    onUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineTick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineStop: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNeedsRedraw: {
      triggerUpdate: !1
    },
    isShadow: {
      default: !1,
      triggerUpdate: !1
    }
  },
  methods: {
    // Expose d3 forces for external manipulation
    d3Force: function(r, e, i) {
      return i === void 0 ? r.forceLayout.force(e) : (r.forceLayout.force(e, i), this);
    },
    d3ReheatSimulation: function(r) {
      return r.forceLayout.alpha(1), this.resetCountdown(), this;
    },
    // reset cooldown state
    resetCountdown: function(r) {
      return r.cntTicks = 0, r.startTickTime = /* @__PURE__ */ new Date(), r.engineRunning = !0, this;
    },
    isEngineRunning: function(r) {
      return !!r.engineRunning;
    },
    tickFrame: function(r) {
      return !r.isShadow && e(), n(), !r.isShadow && s(), !r.isShadow && a(), i(), this;
      function e() {
        r.engineRunning && (++r.cntTicks > r.cooldownTicks || /* @__PURE__ */ new Date() - r.startTickTime > r.cooldownTime || r.d3AlphaMin > 0 && r.forceLayout.alpha() < r.d3AlphaMin ? (r.engineRunning = !1, r.onEngineStop()) : (r.forceLayout.tick(), r.onEngineTick()));
      }
      function i() {
        var o = et(r.nodeVisibility), l = et(r.nodeVal), u = et(r.nodeColor), c = et(r.nodeCanvasObjectMode), h = r.ctx, d = r.isShadow / r.globalScale, p = r.graphData.nodes.filter(o);
        h.save(), p.forEach(function(f) {
          var m = c(f);
          if (r.nodeCanvasObject && (m === "before" || m === "replace") && (r.nodeCanvasObject(f, h, r.globalScale), m === "replace")) {
            h.restore();
            return;
          }
          var v = Math.sqrt(Math.max(0, l(f) || 1)) * r.nodeRelSize + d;
          h.beginPath(), h.arc(f.x, f.y, v, 0, 2 * Math.PI, !1), h.fillStyle = u(f) || "rgba(31, 120, 180, 0.92)", h.fill(), r.nodeCanvasObject && m === "after" && r.nodeCanvasObject(f, r.ctx, r.globalScale);
        }), h.restore();
      }
      function n() {
        var o = et(r.linkVisibility), l = et(r.linkColor), u = et(r.linkWidth), c = et(r.linkLineDash), h = et(r.linkCurvature), d = et(r.linkCanvasObjectMode), p = r.ctx, f = r.isShadow * 2, m = r.graphData.links.filter(o);
        m.forEach(T);
        var v = [], y = [], g = m;
        if (r.linkCanvasObject) {
          var _ = [], x = [];
          m.forEach(function(S) {
            return ({
              before: v,
              after: y,
              replace: _
            }[d(S)] || x).push(S);
          }), g = [].concat(xn(v), y, x), v = v.concat(_);
        }
        p.save(), v.forEach(function(S) {
          return r.linkCanvasObject(S, p, r.globalScale);
        }), p.restore();
        var b = Cse(g, [l, u, c]);
        p.save(), Object.entries(b).forEach(function(S) {
          var w = od(S, 2), A = w[0], E = w[1], M = !A || A === "undefined" ? "rgba(0,0,0,0.15)" : A;
          Object.entries(E).forEach(function(N) {
            var k = od(N, 2), U = k[0], C = k[1], O = (U || 1) / r.globalScale + f;
            Object.entries(C).forEach(function(D) {
              var H = od(D, 2);
              H[0];
              var j = H[1], K = c(j[0]);
              p.beginPath(), j.forEach(function(L) {
                var B = L.source, Q = L.target;
                if (!(!B || !Q || !B.hasOwnProperty("x") || !Q.hasOwnProperty("x"))) {
                  p.moveTo(B.x, B.y);
                  var W = L.__controlPoints;
                  W ? p[W.length === 2 ? "quadraticCurveTo" : "bezierCurveTo"].apply(p, xn(W).concat([Q.x, Q.y])) : p.lineTo(Q.x, Q.y);
                }
              }), p.strokeStyle = M, p.lineWidth = O, p.setLineDash(K || []), p.stroke();
            });
          });
        }), p.restore(), p.save(), y.forEach(function(S) {
          return r.linkCanvasObject(S, p, r.globalScale);
        }), p.restore();
        function T(S) {
          var w = h(S);
          if (!w) {
            S.__controlPoints = null;
            return;
          }
          var A = S.source, E = S.target;
          if (!(!A || !E || !A.hasOwnProperty("x") || !E.hasOwnProperty("x"))) {
            var M = Math.sqrt(Math.pow(E.x - A.x, 2) + Math.pow(E.y - A.y, 2));
            if (M > 0) {
              var N = Math.atan2(E.y - A.y, E.x - A.x), k = M * w, U = {
                // control point
                x: (A.x + E.x) / 2 + k * Math.cos(N - Math.PI / 2),
                y: (A.y + E.y) / 2 + k * Math.sin(N - Math.PI / 2)
              };
              S.__controlPoints = [U.x, U.y];
            } else {
              var C = w * 70;
              S.__controlPoints = [E.x, E.y - C, E.x + C, E.y];
            }
          }
        }
      }
      function s() {
        var o = 1.6, l = 0.2, u = et(r.linkDirectionalArrowLength), c = et(r.linkDirectionalArrowRelPos), h = et(r.linkVisibility), d = et(r.linkDirectionalArrowColor || r.linkColor), p = et(r.nodeVal), f = r.ctx;
        f.save(), r.graphData.links.filter(h).forEach(function(m) {
          var v = u(m);
          if (!(!v || v < 0)) {
            var y = m.source, g = m.target;
            if (!(!y || !g || !y.hasOwnProperty("x") || !g.hasOwnProperty("x"))) {
              var _ = Math.sqrt(Math.max(0, p(y) || 1)) * r.nodeRelSize, x = Math.sqrt(Math.max(0, p(g) || 1)) * r.nodeRelSize, b = Math.min(1, Math.max(0, c(m))), T = d(m) || "rgba(0,0,0,0.28)", S = v / o / 2, w = m.__controlPoints && kA(oi, [y.x, y.y].concat(xn(m.__controlPoints), [g.x, g.y])), A = w ? function(O) {
                return w.get(O);
              } : function(O) {
                return {
                  // straight line: interpolate linearly
                  x: y.x + (g.x - y.x) * O || 0,
                  y: y.y + (g.y - y.y) * O || 0
                };
              }, E = w ? w.length() : Math.sqrt(Math.pow(g.x - y.x, 2) + Math.pow(g.y - y.y, 2)), M = _ + v + (E - _ - x - v) * b, N = A(M / E), k = A((M - v) / E), U = A((M - v * (1 - l)) / E), C = Math.atan2(N.y - k.y, N.x - k.x) - Math.PI / 2;
              f.beginPath(), f.moveTo(N.x, N.y), f.lineTo(k.x + S * Math.cos(C), k.y + S * Math.sin(C)), f.lineTo(U.x, U.y), f.lineTo(k.x - S * Math.cos(C), k.y - S * Math.sin(C)), f.fillStyle = T, f.fill();
            }
          }
        }), f.restore();
      }
      function a() {
        var o = et(r.linkDirectionalParticles), l = et(r.linkDirectionalParticleSpeed), u = et(r.linkDirectionalParticleWidth), c = et(r.linkVisibility), h = et(r.linkDirectionalParticleColor || r.linkColor), d = r.ctx;
        d.save(), r.graphData.links.filter(c).forEach(function(p) {
          var f = o(p);
          if (!(!p.hasOwnProperty("__photons") || !p.__photons.length)) {
            var m = p.source, v = p.target;
            if (!(!m || !v || !m.hasOwnProperty("x") || !v.hasOwnProperty("x"))) {
              var y = l(p), g = p.__photons || [], _ = Math.max(0, u(p) / 2) / Math.sqrt(r.globalScale), x = h(p) || "rgba(0,0,0,0.28)";
              d.fillStyle = x;
              var b = p.__controlPoints ? kA(oi, [m.x, m.y].concat(xn(p.__controlPoints), [v.x, v.y])) : null, T = 0, S = !1;
              g.forEach(function(w) {
                var A = !!w.__singleHop;
                if (w.hasOwnProperty("__progressRatio") || (w.__progressRatio = A ? 0 : T / f), !A && T++, w.__progressRatio += y, w.__progressRatio >= 1)
                  if (!A)
                    w.__progressRatio = w.__progressRatio % 1;
                  else {
                    S = !0;
                    return;
                  }
                var E = w.__progressRatio, M = b ? b.get(E) : {
                  // straight line: interpolate linearly
                  x: m.x + (v.x - m.x) * E || 0,
                  y: m.y + (v.y - m.y) * E || 0
                };
                d.beginPath(), d.arc(M.x, M.y, _, 0, 2 * Math.PI, !1), d.fill();
              }), S && (p.__photons = p.__photons.filter(function(w) {
                return !w.__singleHop || w.__progressRatio <= 1;
              }));
            }
          }
        }), d.restore();
      }
    },
    emitParticle: function(r, e) {
      return e && (!e.__photons && (e.__photons = []), e.__photons.push({
        __singleHop: !0
      })), this;
    }
  },
  stateInit: function() {
    return {
      forceLayout: DR().force("link", PR()).force("charge", LR()).force("center", wR()).force("dagRadial", null).stop(),
      engineRunning: !1
    };
  },
  init: function(r, e) {
    e.ctx = r;
  },
  update: function(r, e) {
    r.engineRunning = !1, r.onUpdate(), r.nodeAutoColorBy !== null && BA(r.graphData.nodes, et(r.nodeAutoColorBy), r.nodeColor), r.linkAutoColorBy !== null && BA(r.graphData.links, et(r.linkAutoColorBy), r.linkColor), r.graphData.links.forEach(function(d) {
      d.source = d[r.linkSource], d.target = d[r.linkTarget];
    }), r.forceLayout.stop().alpha(1).nodes(r.graphData.nodes);
    var i = r.forceLayout.force("link");
    i && i.id(function(d) {
      return d[r.nodeId];
    }).links(r.graphData.links);
    var n = r.dagMode && zse(r.graphData, function(d) {
      return d[r.nodeId];
    }, {
      nodeFilter: r.dagNodeFilter,
      onLoopError: r.onDagError || void 0
    }), s = Math.max.apply(Math, xn(Object.values(n || []))), a = r.dagLevelDistance || r.graphData.nodes.length / (s || 1) * jse * (["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? 0.7 : 1);
    if (["lr", "rl", "td", "bu"].includes(e.dagMode)) {
      var o = ["lr", "rl"].includes(e.dagMode) ? "fx" : "fy";
      r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(d) {
        return delete d[o];
      });
    }
    if (["lr", "rl", "td", "bu"].includes(r.dagMode)) {
      var l = ["rl", "bu"].includes(r.dagMode), u = function(d) {
        return (n[d[r.nodeId]] - s / 2) * a * (l ? -1 : 1);
      }, c = ["lr", "rl"].includes(r.dagMode) ? "fx" : "fy";
      r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(d) {
        return d[c] = u(d);
      });
    }
    r.forceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? UR(function(d) {
      var p = n[d[r.nodeId]] || -1;
      return (r.dagMode === "radialin" ? s - p : p) * a;
    }).strength(function(d) {
      return r.dagNodeFilter(d) ? 1 : 0;
    }) : null);
    for (var h = 0; h < r.warmupTicks && !(r.d3AlphaMin > 0 && r.forceLayout.alpha() < r.d3AlphaMin); h++)
      r.forceLayout.tick();
    this.resetCountdown(), r.onFinishUpdate();
  }
});
function e3(r, e) {
  var i = r instanceof Array ? r : [r], n = new e();
  return n._destructor && n._destructor(), {
    linkProp: function(s) {
      return {
        default: n[s](),
        onChange: function(a, o) {
          i.forEach(function(l) {
            return o[l][s](a);
          });
        },
        triggerUpdate: !1
      };
    },
    linkMethod: function(s) {
      return function(a) {
        for (var o = arguments.length, l = new Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)
          l[u - 1] = arguments[u];
        var c = [];
        return i.forEach(function(h) {
          var d = a[h], p = d[s].apply(d, l);
          p !== d && c.push(p);
        }), c.length ? c[0] : this;
      };
    }
  };
}
var Vse = 800, Gse = 4, Hse = 5, t3 = e3("forceGraph", Qm), Wse = e3(["forceGraph", "shadowGraph"], Qm), qse = Object.assign.apply(Object, xn(["nodeColor", "nodeAutoColorBy", "nodeCanvasObject", "nodeCanvasObjectMode", "linkColor", "linkAutoColorBy", "linkLineDash", "linkWidth", "linkCanvasObject", "linkCanvasObjectMode", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(r) {
  return Pd({}, r, t3.linkProp(r));
})).concat(xn(["nodeRelSize", "nodeId", "nodeVal", "nodeVisibility", "linkSource", "linkTarget", "linkVisibility", "linkCurvature"].map(function(r) {
  return Pd({}, r, Wse.linkProp(r));
})))), Xse = Object.assign.apply(Object, xn(["d3Force", "d3ReheatSimulation", "emitParticle"].map(function(r) {
  return Pd({}, r, t3.linkMethod(r));
})));
function C0(r) {
  if (r.canvas) {
    var e = r.canvas.width, i = r.canvas.height;
    e === 300 && i === 150 && (e = i = 0);
    var n = window.devicePixelRatio;
    e /= n, i /= n, [r.canvas, r.shadowCanvas].forEach(function(a) {
      a.style.width = "".concat(r.width, "px"), a.style.height = "".concat(r.height, "px"), a.width = r.width * n, a.height = r.height * n, !e && !i && a.getContext("2d").scale(n, n);
    });
    var s = ss(r.canvas).k;
    r.zoom.translateBy(r.zoom.__baseElem, (r.width - e) / 2 / s, (r.height - i) / 2 / s), r.needsRedraw = !0;
  }
}
function i3(r) {
  var e = window.devicePixelRatio;
  r.setTransform(e, 0, 0, e, 0, 0);
}
function jA(r, e, i) {
  r.save(), i3(r), r.clearRect(0, 0, e, i), r.restore();
}
var $se = Pl({
  props: Mu({
    width: {
      default: window.innerWidth,
      onChange: function(r, e) {
        return C0(e);
      },
      triggerUpdate: !1
    },
    height: {
      default: window.innerHeight,
      onChange: function(r, e) {
        return C0(e);
      },
      triggerUpdate: !1
    },
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        [r.nodes, r.links].every(function(n) {
          return (n || []).every(function(s) {
            return !s.hasOwnProperty("__indexColor");
          });
        }) && e.colorTracker.reset(), [{
          type: "Node",
          objs: r.nodes
        }, {
          type: "Link",
          objs: r.links
        }].forEach(i), e.forceGraph.graphData(r), e.shadowGraph.graphData(r);
        function i(n) {
          var s = n.type, a = n.objs;
          a.filter(function(o) {
            if (!o.hasOwnProperty("__indexColor")) return !0;
            var l = e.colorTracker.lookup(o.__indexColor);
            return !l || !l.hasOwnProperty("d") || l.d !== o;
          }).forEach(function(o) {
            o.__indexColor = e.colorTracker.register({
              type: s,
              d: o
            });
          });
        }
      },
      triggerUpdate: !1
    },
    backgroundColor: {
      onChange: function(r, e) {
        e.canvas && r && (e.canvas.style.background = r);
      },
      triggerUpdate: !1
    },
    nodeLabel: {
      default: "name",
      triggerUpdate: !1
    },
    nodePointerAreaPaint: {
      onChange: function(r, e) {
        e.shadowGraph.nodeCanvasObject(r ? function(i, n, s) {
          return r(i, i.__indexColor, n, s);
        } : null), e.flushShadowCanvas && e.flushShadowCanvas();
      },
      triggerUpdate: !1
    },
    linkPointerAreaPaint: {
      onChange: function(r, e) {
        e.shadowGraph.linkCanvasObject(r ? function(i, n, s) {
          return r(i, i.__indexColor, n, s);
        } : null), e.flushShadowCanvas && e.flushShadowCanvas();
      },
      triggerUpdate: !1
    },
    linkLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkHoverPrecision: {
      default: 4,
      triggerUpdate: !1
    },
    minZoom: {
      default: 0.01,
      onChange: function(r, e) {
        e.zoom.scaleExtent([r, e.zoom.scaleExtent()[1]]);
      },
      triggerUpdate: !1
    },
    maxZoom: {
      default: 1e3,
      onChange: function(r, e) {
        e.zoom.scaleExtent([e.zoom.scaleExtent()[0], r]);
      },
      triggerUpdate: !1
    },
    enableNodeDrag: {
      default: !0,
      triggerUpdate: !1
    },
    enableZoomInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    enablePanInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    enableZoomPanInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    // to be deprecated
    enablePointerInteraction: {
      default: !0,
      onChange: function(r, e) {
        e.hoverObj = null;
      },
      triggerUpdate: !1
    },
    autoPauseRedraw: {
      default: !0,
      triggerUpdate: !1
    },
    onNodeDrag: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeDragEnd: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeClick: {
      triggerUpdate: !1
    },
    onNodeRightClick: {
      triggerUpdate: !1
    },
    onNodeHover: {
      triggerUpdate: !1
    },
    onLinkClick: {
      triggerUpdate: !1
    },
    onLinkRightClick: {
      triggerUpdate: !1
    },
    onLinkHover: {
      triggerUpdate: !1
    },
    onBackgroundClick: {
      triggerUpdate: !1
    },
    onBackgroundRightClick: {
      triggerUpdate: !1
    },
    onZoom: {
      triggerUpdate: !1
    },
    onZoomEnd: {
      triggerUpdate: !1
    },
    onRenderFramePre: {
      triggerUpdate: !1
    },
    onRenderFramePost: {
      triggerUpdate: !1
    }
  }, qse),
  aliases: {
    // Prop names supported for backwards compatibility
    stopAnimation: "pauseAnimation"
  },
  methods: Mu({
    graph2ScreenCoords: function(r, e, i) {
      var n = ss(r.canvas);
      return {
        x: e * n.k + n.x,
        y: i * n.k + n.y
      };
    },
    screen2GraphCoords: function(r, e, i) {
      var n = ss(r.canvas);
      return {
        x: (e - n.x) / n.k,
        y: (i - n.y) / n.k
      };
    },
    centerAt: function(r, e, i, n) {
      if (!r.canvas) return null;
      if (e !== void 0 || i !== void 0) {
        var s = Object.assign({}, e !== void 0 ? {
          x: e
        } : {}, i !== void 0 ? {
          y: i
        } : {});
        return n ? r.tweenGroup.add(new $m(a()).to(s, n).easing(ba.Quadratic.Out).onUpdate(o).start()) : o(s), this;
      }
      return a();
      function a() {
        var l = ss(r.canvas);
        return {
          x: (r.width / 2 - l.x) / l.k,
          y: (r.height / 2 - l.y) / l.k
        };
      }
      function o(l) {
        var u = l.x, c = l.y;
        r.zoom.translateTo(r.zoom.__baseElem, u === void 0 ? a().x : u, c === void 0 ? a().y : c), r.needsRedraw = !0;
      }
    },
    zoom: function(r, e, i) {
      if (!r.canvas) return null;
      if (e !== void 0)
        return i ? r.tweenGroup.add(new $m({
          k: n()
        }).to({
          k: e
        }, i).easing(ba.Quadratic.Out).onUpdate(function(a) {
          var o = a.k;
          return s(o);
        }).start()) : s(e), this;
      return n();
      function n() {
        return ss(r.canvas).k;
      }
      function s(a) {
        r.zoom.scaleTo(r.zoom.__baseElem, a), r.needsRedraw = !0;
      }
    },
    zoomToFit: function(r) {
      for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, n = arguments.length, s = new Array(n > 3 ? n - 3 : 0), a = 3; a < n; a++)
        s[a - 3] = arguments[a];
      var o = this.getGraphBbox.apply(this, s);
      if (o) {
        var l = {
          x: (o.x[0] + o.x[1]) / 2,
          y: (o.y[0] + o.y[1]) / 2
        }, u = Math.max(1e-12, Math.min(1e12, (r.width - i * 2) / (o.x[1] - o.x[0]), (r.height - i * 2) / (o.y[1] - o.y[0])));
        this.centerAt(l.x, l.y, e), this.zoom(u, e);
      }
      return this;
    },
    getGraphBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      }, i = et(r.nodeVal), n = function(a) {
        return Math.sqrt(Math.max(0, i(a) || 1)) * r.nodeRelSize;
      }, s = r.graphData.nodes.filter(e).map(function(a) {
        return {
          x: a.x,
          y: a.y,
          r: n(a)
        };
      });
      return s.length ? {
        x: [Fb(s, function(a) {
          return a.x - a.r;
        }), kb(s, function(a) {
          return a.x + a.r;
        })],
        y: [Fb(s, function(a) {
          return a.y - a.r;
        }), kb(s, function(a) {
          return a.y + a.r;
        })]
      } : null;
    },
    pauseAnimation: function(r) {
      return r.animationFrameRequestId && (cancelAnimationFrame(r.animationFrameRequestId), r.animationFrameRequestId = null), this;
    },
    resumeAnimation: function(r) {
      return r.animationFrameRequestId || this._animationCycle(), this;
    },
    _destructor: function() {
      this.pauseAnimation(), this.graphData({
        nodes: [],
        links: []
      });
    }
  }, Xse),
  stateInit: function() {
    return {
      lastSetZoom: 1,
      zoom: Wne(),
      forceGraph: new Qm(),
      shadowGraph: new Qm().cooldownTicks(0).nodeColor("__indexColor").linkColor("__indexColor").isShadow(!0),
      colorTracker: new lse(),
      // indexed objects for rgb lookup
      tweenGroup: new $T()
    };
  },
  init: function(r, e) {
    var i = this;
    r.innerHTML = "";
    var n = document.createElement("div");
    n.classList.add("force-graph-container"), n.style.position = "relative", r.appendChild(n), e.canvas = document.createElement("canvas"), e.backgroundColor && (e.canvas.style.background = e.backgroundColor), n.appendChild(e.canvas), e.shadowCanvas = document.createElement("canvas");
    var s = e.canvas.getContext("2d"), a = e.shadowCanvas.getContext("2d", {
      willReadFrequently: !0
    }), o = {
      x: -1e12,
      y: -1e12
    }, l = function() {
      var c = null, h = window.devicePixelRatio, d = o.x > 0 && o.y > 0 ? a.getImageData(o.x * h, o.y * h, 1, 1) : null;
      return d && (c = e.colorTracker.lookup(d.data)), c;
    };
    bn(e.canvas).call(Pre().subject(function() {
      if (!e.enableNodeDrag)
        return null;
      var c = l();
      return c && c.type === "Node" ? c.d : null;
    }).on("start", function(c) {
      var h = c.subject;
      h.__initialDragPos = {
        x: h.x,
        y: h.y,
        fx: h.fx,
        fy: h.fy
      }, c.active || (h.fx = h.x, h.fy = h.y), e.canvas.classList.add("grabbable");
    }).on("drag", function(c) {
      var h = c.subject, d = h.__initialDragPos, p = c, f = ss(e.canvas).k, m = {
        x: d.x + (p.x - d.x) / f - h.x,
        y: d.y + (p.y - d.y) / f - h.y
      };
      ["x", "y"].forEach(function(v) {
        return h["f".concat(v)] = h[v] = d[v] + (p[v] - d[v]) / f;
      }), !(!h.__dragged && Hse >= Math.sqrt(PG(["x", "y"].map(function(v) {
        return Math.pow(c[v] - d[v], 2);
      })))) && (e.forceGraph.d3AlphaTarget(0.3).resetCountdown(), e.isPointerDragging = !0, h.__dragged = !0, e.onNodeDrag(h, m));
    }).on("end", function(c) {
      var h = c.subject, d = h.__initialDragPos, p = {
        x: h.x - d.x,
        y: h.y - d.y
      };
      d.fx === void 0 && (h.fx = void 0), d.fy === void 0 && (h.fy = void 0), delete h.__initialDragPos, e.forceGraph.d3AlphaTarget() && e.forceGraph.d3AlphaTarget(0).resetCountdown(), e.canvas.classList.remove("grabbable"), e.isPointerDragging = !1, h.__dragged && (delete h.__dragged, e.onNodeDragEnd(h, p));
    })), e.zoom(e.zoom.__baseElem = bn(e.canvas)), e.zoom.__baseElem.on("dblclick.zoom", null), e.zoom.filter(function(c) {
      return (
        // disable zoom interaction
        !c.button && e.enableZoomPanInteraction && (c.type !== "wheel" || et(e.enableZoomInteraction)(c)) && (c.type === "wheel" || et(e.enablePanInteraction)(c))
      );
    }).on("zoom", function(c) {
      var h = c.transform;
      [s, a].forEach(function(d) {
        i3(d), d.translate(h.x, h.y), d.scale(h.k, h.k);
      }), e.onZoom && e.onZoom(Mu(Mu({}, h), i.centerAt())), e.needsRedraw = !0;
    }).on("end", function(c) {
      return e.onZoomEnd && e.onZoomEnd(Mu(Mu({}, c.transform), i.centerAt()));
    }), C0(e), e.forceGraph.onNeedsRedraw(function() {
      return e.needsRedraw = !0;
    }).onFinishUpdate(function() {
      ss(e.canvas).k === e.lastSetZoom && e.graphData.nodes.length && (e.zoom.scaleTo(e.zoom.__baseElem, e.lastSetZoom = Gse / Math.cbrt(e.graphData.nodes.length)), e.needsRedraw = !0);
    }), e.tooltip = new kO(n), ["pointermove", "pointerdown"].forEach(function(c) {
      return n.addEventListener(c, function(h) {
        c === "pointerdown" && (e.isPointerPressed = !0, e.pointerDownEvent = h), !e.isPointerDragging && h.type === "pointermove" && e.onBackgroundClick && (h.pressure > 0 || e.isPointerPressed) && (h.pointerType !== "touch" || h.movementX === void 0 || [h.movementX, h.movementY].some(function(f) {
          return Math.abs(f) > 1;
        })) && (e.isPointerDragging = !0);
        var d = p(n);
        o.x = h.pageX - d.left, o.y = h.pageY - d.top;
        function p(f) {
          var m = f.getBoundingClientRect(), v = window.pageXOffset || document.documentElement.scrollLeft, y = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: m.top + y,
            left: m.left + v
          };
        }
      }, {
        passive: !0
      });
    }), n.addEventListener("pointerup", function(c) {
      if (e.isPointerPressed = !1, e.isPointerDragging) {
        e.isPointerDragging = !1;
        return;
      }
      var h = [c, e.pointerDownEvent];
      requestAnimationFrame(function() {
        if (c.button === 0)
          if (e.hoverObj) {
            var d = e["on".concat(e.hoverObj.type, "Click")];
            d && d.apply(void 0, [e.hoverObj.d].concat(h));
          } else
            e.onBackgroundClick && e.onBackgroundClick.apply(e, h);
        if (c.button === 2)
          if (e.hoverObj) {
            var p = e["on".concat(e.hoverObj.type, "RightClick")];
            p && p.apply(void 0, [e.hoverObj.d].concat(h));
          } else
            e.onBackgroundRightClick && e.onBackgroundRightClick.apply(e, h);
      });
    }, {
      passive: !0
    }), n.addEventListener("contextmenu", function(c) {
      return !e.onBackgroundRightClick && !e.onNodeRightClick && !e.onLinkRightClick ? !0 : (c.preventDefault(), !1);
    }), e.forceGraph(s), e.shadowGraph(a);
    var u = Xne(function() {
      jA(a, e.width, e.height), e.shadowGraph.linkWidth(function(h) {
        return et(e.linkWidth)(h) + e.linkHoverPrecision;
      });
      var c = ss(e.canvas);
      e.shadowGraph.globalScale(c.k).tickFrame();
    }, Vse);
    e.flushShadowCanvas = u.flush, (this._animationCycle = function c() {
      var h = !e.autoPauseRedraw || !!e.needsRedraw || e.forceGraph.isEngineRunning() || e.graphData.links.some(function(_) {
        return _.__photons && _.__photons.length;
      });
      if (e.needsRedraw = !1, e.enablePointerInteraction) {
        var d = e.isPointerDragging ? null : l();
        if (d !== e.hoverObj) {
          var p = e.hoverObj, f = p ? p.type : null, m = d ? d.type : null;
          if (f && f !== m) {
            var v = e["on".concat(f, "Hover")];
            v && v(null, p.d);
          }
          if (m) {
            var y = e["on".concat(m, "Hover")];
            y && y(d.d, f === m ? p.d : null);
          }
          e.tooltip.content(d && et(e["".concat(d.type.toLowerCase(), "Label")])(d.d) || null), e.canvas.classList[d && e["on".concat(m, "Click")] || !d && e.onBackgroundClick ? "add" : "remove"]("clickable"), e.hoverObj = d;
        }
        h && u();
      }
      if (h) {
        jA(s, e.width, e.height);
        var g = ss(e.canvas).k;
        e.onRenderFramePre && e.onRenderFramePre(s, g), e.forceGraph.globalScale(g).tickFrame(), e.onRenderFramePost && e.onRenderFramePost(s, g);
      }
      e.tweenGroup.update(), e.animationFrameRequestId = requestAnimationFrame(c);
    })();
  },
  update: function(r) {
  }
}), Kg = {
  width: ie.number,
  height: ie.number,
  graphData: ie.shape({
    nodes: ie.arrayOf(ie.object).isRequired,
    links: ie.arrayOf(ie.object).isRequired
  }),
  backgroundColor: ie.string,
  nodeRelSize: ie.number,
  nodeId: ie.string,
  nodeLabel: ie.oneOfType([ie.string, ie.func]),
  nodeVal: ie.oneOfType([ie.number, ie.string, ie.func]),
  nodeVisibility: ie.oneOfType([ie.bool, ie.string, ie.func]),
  nodeColor: ie.oneOfType([ie.string, ie.func]),
  nodeAutoColorBy: ie.oneOfType([ie.string, ie.func]),
  onNodeHover: ie.func,
  onNodeClick: ie.func,
  linkSource: ie.string,
  linkTarget: ie.string,
  linkLabel: ie.oneOfType([ie.string, ie.func]),
  linkVisibility: ie.oneOfType([ie.bool, ie.string, ie.func]),
  linkColor: ie.oneOfType([ie.string, ie.func]),
  linkAutoColorBy: ie.oneOfType([ie.string, ie.func]),
  linkWidth: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkCurvature: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalArrowLength: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalArrowColor: ie.oneOfType([ie.string, ie.func]),
  linkDirectionalArrowRelPos: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticles: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticleSpeed: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticleWidth: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticleColor: ie.oneOfType([ie.string, ie.func]),
  onLinkHover: ie.func,
  onLinkClick: ie.func,
  dagMode: ie.oneOf(["td", "bu", "lr", "rl", "zin", "zout", "radialin", "radialout"]),
  dagLevelDistance: ie.number,
  dagNodeFilter: ie.func,
  onDagError: ie.func,
  d3AlphaMin: ie.number,
  d3AlphaDecay: ie.number,
  d3VelocityDecay: ie.number,
  warmupTicks: ie.number,
  cooldownTicks: ie.number,
  cooldownTime: ie.number,
  onEngineTick: ie.func,
  onEngineStop: ie.func,
  getGraphBbox: ie.func
}, r3 = {
  zoomToFit: ie.func,
  onNodeRightClick: ie.func,
  onNodeDrag: ie.func,
  onNodeDragEnd: ie.func,
  onLinkRightClick: ie.func,
  linkHoverPrecision: ie.number,
  onBackgroundClick: ie.func,
  onBackgroundRightClick: ie.func,
  enablePointerInteraction: ie.bool,
  enableNodeDrag: ie.bool
}, nS = {
  showNavInfo: ie.bool,
  nodeOpacity: ie.number,
  nodeResolution: ie.number,
  nodeThreeObject: ie.oneOfType([ie.object, ie.string, ie.func]),
  nodeThreeObjectExtend: ie.oneOfType([ie.bool, ie.string, ie.func]),
  linkOpacity: ie.number,
  linkResolution: ie.number,
  linkCurveRotation: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkMaterial: ie.oneOfType([ie.object, ie.string, ie.func]),
  linkThreeObject: ie.oneOfType([ie.object, ie.string, ie.func]),
  linkThreeObjectExtend: ie.oneOfType([ie.bool, ie.string, ie.func]),
  linkPositionUpdate: ie.func,
  linkDirectionalArrowResolution: ie.number,
  linkDirectionalParticleResolution: ie.number,
  forceEngine: ie.oneOf(["d3", "ngraph"]),
  ngraphPhysics: ie.object,
  numDimensions: ie.oneOf([1, 2, 3])
}, Yse = Object.assign({}, Kg, r3, {
  linkLineDash: ie.oneOfType([ie.arrayOf(ie.number), ie.string, ie.func]),
  nodeCanvasObjectMode: ie.oneOfType([ie.string, ie.func]),
  nodeCanvasObject: ie.func,
  nodePointerAreaPaint: ie.func,
  linkCanvasObjectMode: ie.oneOfType([ie.string, ie.func]),
  linkCanvasObject: ie.func,
  linkPointerAreaPaint: ie.func,
  autoPauseRedraw: ie.bool,
  minZoom: ie.number,
  maxZoom: ie.number,
  enableZoomInteraction: ie.oneOfType([ie.bool, ie.func]),
  enablePanInteraction: ie.oneOfType([ie.bool, ie.func]),
  onZoom: ie.func,
  onZoomEnd: ie.func,
  onRenderFramePre: ie.func,
  onRenderFramePost: ie.func
}), Kse = Object.assign({}, Kg, r3, nS, {
  enableNavigationControls: ie.bool,
  controlType: ie.oneOf(["trackball", "orbit", "fly"]),
  rendererConfig: ie.object,
  extraRenderers: ie.arrayOf(ie.shape({
    render: ie.func.isRequired
  }))
}), Zse = Object.assign({}, Kg, nS, {
  nodeDesc: ie.oneOfType([ie.string, ie.func]),
  linkDesc: ie.oneOfType([ie.string, ie.func])
}), Qse = Object.assign({}, Kg, nS, {
  markerAttrs: ie.object,
  yOffset: ie.number,
  glScale: ie.number
});
const n3 = mg(d2, {
  methodNames: [
    // bind methods
    "getGraphBbox",
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "refresh"
  ]
});
n3.displayName = "ForceGraphVR";
n3.propTypes = Zse;
const s3 = mg(v9, {
  methodNames: [
    // bind methods
    "getGraphBbox",
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "refresh"
  ],
  initPropNames: ["markerAttrs"]
});
s3.displayName = "ForceGraphAR";
s3.propTypes = Qse;
const sS = mg(Ere, {
  methodNames: [
    // bind methods
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "stopAnimation",
    "pauseAnimation",
    "resumeAnimation",
    "cameraPosition",
    "zoomToFit",
    "getGraphBbox",
    "screen2GraphCoords",
    "graph2ScreenCoords",
    "postProcessingComposer",
    "lights",
    "scene",
    "camera",
    "renderer",
    "controls",
    "refresh"
  ],
  initPropNames: ["controlType", "rendererConfig", "extraRenderers"]
});
sS.displayName = "ForceGraph3D";
sS.propTypes = Kse;
const aS = mg($se, {
  methodNames: [
    // bind methods
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "stopAnimation",
    "pauseAnimation",
    "resumeAnimation",
    "centerAt",
    "zoom",
    "zoomToFit",
    "getGraphBbox",
    "screen2GraphCoords",
    "graph2ScreenCoords"
  ]
});
aS.displayName = "ForceGraph2D";
aS.propTypes = Yse;
const Jse = {
  position: "absolute",
  pointerEvents: "none",
  background: Ei.PREDICATE,
  color: "#fff",
  border: `2px solid ${Ei.PREDICATE}`,
  borderRadius: 8,
  padding: "6px 14px",
  fontSize: 15,
  fontWeight: "bold",
  zIndex: 1e4,
  boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
  whiteSpace: "nowrap",
  maxWidth: 260,
  overflow: "hidden",
  textOverflow: "ellipsis"
}, eae = 16, VA = 32, tae = ({
  graphData: r,
  onNodeClick: e,
  onEngineStop: i,
  fgRef: n,
  children: s,
  selectedTriple: a,
  endpoint: o
}) => {
  const l = yr(), [u, c] = Pe(null), [h, d] = Pe(null), [p, f] = Pe({ x: 0, y: 0 }), [m, v] = Pe({ width: 100, height: 100 }), [y, g] = Pe(/* @__PURE__ */ new Map());
  si(() => {
    const S = () => {
      l.current && v({
        width: l.current.clientWidth,
        height: l.current.clientHeight
      });
    };
    return S(), window.addEventListener("resize", S), () => window.removeEventListener("resize", S);
  }, []), si(() => {
    r.nodes.forEach((S) => {
      if (S.image && !y.has(S.image)) {
        const w = new Image();
        w.crossOrigin = "anonymous", w.src = S.image, w.onload = () => {
          g((A) => new Map(A).set(S.image, w)), n.current && n.current.emit("redraw");
        };
      }
    });
  }, [r.nodes]);
  const _ = Dr(() => {
    c(null), d(null);
  }, []), x = Dr((S) => {
    if (l.current) {
      const w = l.current.getBoundingClientRect();
      f({
        x: S.clientX - w.left,
        y: S.clientY - w.top
      });
    }
  }, []), b = Dr(() => {
    c(null), d(null);
  }, []), T = () => {
    if (!l.current) return { left: p.x, top: p.y };
    const S = l.current.getBoundingClientRect(), w = 180, A = 36;
    let E = p.x + eae, M = p.y - VA;
    return E + w > S.width && (E = S.width - w - 8), E < 0 && (E = 8), M < 0 && (M = p.y + VA), M + A > S.height && (M = S.height - A - 8), { left: E, top: M };
  };
  return /* @__PURE__ */ ne.jsxs(
    "div",
    {
      ref: l,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      onMouseMove: x,
      children: [
        /* @__PURE__ */ ne.jsx(
          aS,
          {
            ref: n,
            graphData: r,
            width: m.width,
            height: m.height,
            nodeCanvasObject: (S, w, A) => {
              const E = 44 / A * Math.pow(A, 0.15);
              if (S.type === "object")
                if (S.image) {
                  if (w.save(), w.beginPath(), w.rect(S.x - E / 2, S.y - E / 2, E, E), w.closePath(), w.strokeStyle = S.color, w.lineWidth = 3 / A, w.stroke(), w.clip(), !S.__img) {
                    const M = new window.Image();
                    M.crossOrigin = "anonymous", M.src = S.image, M.onload = () => {
                      S.__imgLoaded = !0, n && n.current && n.current.emit && n.current.emit("redraw");
                    }, S.__img = M, S.__imgLoaded = !1;
                  }
                  S.__imgLoaded ? w.drawImage(
                    S.__img,
                    S.x - E / 2,
                    S.y - E / 2,
                    E,
                    E
                  ) : (w.fillStyle = S.color || "#888", w.fillRect(S.x - E / 2, S.y - E / 2, E, E)), w.restore();
                } else {
                  w.save(), w.beginPath(), w.rect(S.x - E / 2, S.y - E / 2, E, E), w.closePath(), w.fillStyle = S.color + "CC", w.fill(), w.strokeStyle = S.color, w.lineWidth = 3 / A, w.stroke();
                  const M = (S.label || "?").substring(0, 3), N = 20 / A;
                  w.font = `bold ${N}px Sans-Serif`, w.fillStyle = "#fff", w.textAlign = "center", w.textBaseline = "middle", w.fillText(M, S.x, S.y + E * 0.04), w.restore();
                }
              else if (S.image) {
                if (!S.__img) {
                  const M = new window.Image();
                  M.src = S.image, M.onload = () => {
                    S.__imgLoaded = !0, n && n.current && n.current.emit && n.current.emit("redraw");
                  }, S.__img = M, S.__imgLoaded = !1;
                }
                w.save(), w.beginPath(), w.arc(S.x, S.y, E / 2, 0, 2 * Math.PI, !1), w.closePath(), w.lineWidth = 3 / A, w.strokeStyle = S.color, w.stroke(), w.clip(), S.__imgLoaded ? w.drawImage(
                  S.__img,
                  S.x - E / 2,
                  S.y - E / 2,
                  E,
                  E
                ) : (w.fillStyle = S.color || "#888", w.fill()), w.restore();
              } else {
                w.save(), w.beginPath(), w.arc(S.x, S.y, E / 2, 0, 2 * Math.PI, !1), w.closePath(), w.fillStyle = S.color + "CC", w.fill(), w.strokeStyle = S.color, w.lineWidth = 3 / A, w.stroke();
                const M = (S.label || "?").substring(0, 3), N = 20 / A;
                w.font = `bold ${N}px Sans-Serif`, w.fillStyle = "#fff", w.textAlign = "center", w.textBaseline = "middle", w.fillText(M, S.x, S.y + E * 0.04), w.restore();
              }
            },
            nodePointerAreaPaint: (S, w, A, E) => {
              const M = 44 / E * Math.pow(E, 0.15);
              A.fillStyle = w, S.type === "object" ? (A.beginPath(), A.rect(S.x - M / 2, S.y - M / 2, M, M), A.closePath(), A.fill()) : (A.beginPath(), A.arc(S.x, S.y, M / 2, 0, 2 * Math.PI, !1), A.closePath(), A.fill());
            },
            linkColor: () => "rgba(255, 211, 42, 0.15)",
            linkDirectionalParticles: 1,
            linkDirectionalParticleSpeed: 0.01,
            linkDirectionalParticleColor: () => "rgba(255,255,255,0.5)",
            nodeAutoColorBy: "type",
            onNodeClick: e,
            onEngineStop: i,
            onNodeHover: d,
            onLinkHover: c,
            onBackgroundClick: b,
            onZoom: _
          }
        ),
        u && u.label ? /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              ...Jse,
              ...T(),
              pointerEvents: "none"
            },
            children: u.label
          }
        ) : h && h.label ? /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: p.x + 18,
              top: p.y - 10,
              background: "#232326",
              color: "#fff",
              border: "1.5px solid #ffd32a",
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 10001,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: h.label
          }
        ) : null,
        a && /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: 80,
              right: 30,
              width: 350,
              zIndex: 9999,
              maxHeight: "80vh",
              background: "#18181b",
              borderRadius: "10px",
              border: "3px solid #ffd32a",
              boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
              overflowY: "auto"
            },
            children: /* @__PURE__ */ ne.jsx(
              b_,
              {
                triple: a,
                endpoint: o,
                onClose: () => e(null)
              }
            )
          }
        ),
        /* @__PURE__ */ ne.jsx("div", { style: { position: "relative", zIndex: 2e3 }, children: s })
      ]
    }
  );
};
var iae = typeof window < "u" && window.THREE ? window.THREE : {
  Sprite: Ej
};
iae.Sprite;
const rae = ({
  graphData: r,
  onNodeClick: e,
  onEngineStop: i,
  fgRef: n,
  children: s,
  selectedTriple: a,
  endpoint: o
}) => {
  const l = yr(), [u, c] = Pe({ width: 100, height: 100 }), [h, d] = Pe(null), [p, f] = Pe(null), [m, v] = Pe({ x: 0, y: 0 }), y = yr(/* @__PURE__ */ new Map());
  si(() => {
    const _ = () => {
      l.current && c({
        width: l.current.clientWidth,
        height: l.current.clientHeight
      });
    };
    return _(), window.addEventListener("resize", _), () => window.removeEventListener("resize", _);
  }, []);
  const g = (_) => {
    if (y.current.has(_.id))
      return y.current.get(_.id);
    const x = 128, b = document.createElement("canvas");
    b.width = b.height = x;
    const T = b.getContext("2d");
    if (T.clearRect(0, 0, x, x), _.image) {
      const A = new window.Image();
      A.crossOrigin = "anonymous", A.src = _.image, A.onload = () => {
        if (T.clearRect(0, 0, x, x), _.type === "object") {
          T.fillStyle = Pu(_.type) + "CC", T.fillRect(0, 0, x, x);
          const E = Math.max(x / A.width, x / A.height), M = A.width * E, N = A.height * E;
          T.drawImage(A, x / 2 - M / 2, x / 2 - N / 2, M, N);
        } else {
          T.save(), T.beginPath(), T.arc(x / 2, x / 2, x / 2, 0, 2 * Math.PI), T.closePath(), T.clip(), T.fillStyle = Pu(_.type) + "CC", T.fillRect(0, 0, x, x);
          const E = Math.max(x / A.width, x / A.height), M = A.width * E, N = A.height * E;
          T.drawImage(A, x / 2 - M / 2, x / 2 - N / 2, M, N), T.restore();
        }
        S.needsUpdate = !0, n.current && n.current.emit("redraw");
      };
    } else {
      _.type === "object" ? (T.fillStyle = Pu(_.type) + "CC", T.fillRect(0, 0, x, x)) : (T.save(), T.beginPath(), T.arc(x / 2, x / 2, x / 2, 0, 2 * Math.PI), T.closePath(), T.clip(), T.fillStyle = Pu(_.type) + "CC", T.fillRect(0, 0, x, x), T.restore());
      const A = (_.label || "?").substring(0, 3);
      T.font = "bold 48px Sans-Serif", T.fillStyle = "#fff", T.textAlign = "center", T.textBaseline = "middle", T.fillText(A, x / 2, x / 2 + 6);
    }
    const S = new En(b);
    S.needsUpdate = !0;
    const w = new _g({
      map: S,
      transparent: !0
    });
    return y.current.set(_.id, w), w;
  };
  return /* @__PURE__ */ ne.jsxs(
    "div",
    {
      ref: l,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      onMouseMove: (_) => {
        if (l.current) {
          const x = l.current.getBoundingClientRect();
          v({
            x: _.clientX - x.left,
            y: _.clientY - x.top
          });
        }
      },
      children: [
        /* @__PURE__ */ ne.jsx(
          sS,
          {
            ref: n,
            graphData: r,
            width: u.width,
            height: u.height,
            controlType: "fly",
            backgroundColor: "rgba(0,0,0,0)",
            nodeLabel: "",
            onNodeClick: e,
            linkColor: () => "rgba(255, 211, 42, 0.15)",
            linkDirectionalParticles: 2,
            linkDirectionalParticleSpeed: 25e-4,
            linkDirectionalParticleColor: () => "rgba(255,255,255,0.5)",
            nodeAutoColorBy: "type",
            nodeThreeObject: (_) => {
              const x = new nl(), b = g(_);
              let T;
              return _.type === "object" ? T = new Ur(
                new Vd(16, 16),
                b
              ) : T = new Ur(
                new U_(16 / 2, 48),
                b
              ), x.add(T), x;
            },
            onEngineStop: i,
            onNodeHover: d,
            onLinkHover: f,
            onBackgroundClick: () => {
              f(null), d(null);
            },
            onZoom: () => {
              f(null), d(null);
            }
          }
        ),
        a && /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: 80,
              right: 30,
              width: 350,
              zIndex: 9999,
              maxHeight: "80vh",
              background: "#18181b",
              borderRadius: "10px",
              border: "3px solid #ffd32a",
              boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
              overflowY: "auto"
            },
            children: /* @__PURE__ */ ne.jsx(
              b_,
              {
                triple: a,
                endpoint: o,
                onClose: () => e(null)
              }
            )
          }
        ),
        /* @__PURE__ */ ne.jsx("div", { style: { position: "relative", zIndex: 2e3 }, children: s }),
        p && p.label ? /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: m.x + 18,
              top: m.y - 10,
              background: Ei.PREDICATE,
              color: "#fff",
              border: `1.5px solid ${Ei.PREDICATE}`,
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 10001,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: p.label
          }
        ) : h && h.label ? /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: m.x + 18,
              top: m.y - 10,
              background: "#232326",
              color: "#fff",
              border: "1.5px solid #ffd32a",
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 10001,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: h.label
          }
        ) : null
      ]
    }
  );
};
var a3 = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, GA = ni.createContext && /* @__PURE__ */ ni.createContext(a3), nae = ["attr", "size", "title"];
function sae(r, e) {
  if (r == null) return {};
  var i = aae(r, e), n, s;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(r);
    for (s = 0; s < a.length; s++)
      n = a[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (i[n] = r[n]);
  }
  return i;
}
function aae(r, e) {
  if (r == null) return {};
  var i = {};
  for (var n in r)
    if (Object.prototype.hasOwnProperty.call(r, n)) {
      if (e.indexOf(n) >= 0) continue;
      i[n] = r[n];
    }
  return i;
}
function Jm() {
  return Jm = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n]);
    }
    return r;
  }, Jm.apply(this, arguments);
}
function HA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function eg(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? HA(Object(i), !0).forEach(function(n) {
      oae(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : HA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function oae(r, e, i) {
  return e = lae(e), e in r ? Object.defineProperty(r, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = i, r;
}
function lae(r) {
  var e = uae(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function uae(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function o3(r) {
  return r && r.map((e, i) => /* @__PURE__ */ ni.createElement(e.tag, eg({
    key: i
  }, e.attr), o3(e.child)));
}
function oS(r) {
  return (e) => /* @__PURE__ */ ni.createElement(cae, Jm({
    attr: eg({}, r.attr)
  }, e), o3(r.child));
}
function cae(r) {
  var e = (i) => {
    var {
      attr: n,
      size: s,
      title: a
    } = r, o = sae(r, nae), l = s || i.size || "1em", u;
    return i.className && (u = i.className), r.className && (u = (u ? u + " " : "") + r.className), /* @__PURE__ */ ni.createElement("svg", Jm({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, i.attr, n, o, {
      className: u,
      style: eg(eg({
        color: r.color || i.color
      }, i.style), r.style),
      height: l,
      width: l,
      xmlns: "http://www.w3.org/2000/svg"
    }), a && /* @__PURE__ */ ni.createElement("title", null, a), r.children);
  };
  return GA !== void 0 ? /* @__PURE__ */ ni.createElement(GA.Consumer, null, (i) => e(i)) : e(a3);
}
function hae(r) {
  return oS({ attr: { viewBox: "0 0 256 256", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M200,154a29.87,29.87,0,0,0-19.5,7.23L154.88,141.3A29.83,29.83,0,0,0,158,128a30.52,30.52,0,0,0-.22-3.6L174,119a30,30,0,1,0-4-15,30.52,30.52,0,0,0,.22,3.6L154,113a29.91,29.91,0,0,0-32.42-14.31l-8.14-18.3a30,30,0,1,0-11,4.88l8.14,18.3A29.92,29.92,0,0,0,102.06,143L74,168a30.08,30.08,0,1,0,8,9L110,152a29.91,29.91,0,0,0,37.47-1.23l25.62,19.93A30,30,0,1,0,200,154Zm0-68a18,18,0,1,1-18,18A18,18,0,0,1,200,86ZM78,56A18,18,0,1,1,96,74,18,18,0,0,1,78,56ZM56,210a18,18,0,1,1,18-18A18,18,0,0,1,56,210Zm72-64a18,18,0,1,1,18-18A18,18,0,0,1,128,146Zm72,56a18,18,0,1,1,18-18A18,18,0,0,1,200,202Z" }, child: [] }] })(r);
}
function dae(r) {
  return oS({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z" }, child: [] }] })(r);
}
function pae(r) {
  return oS({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z" }, child: [] }] })(r);
}
const WA = {
  background: "#ffd32a",
  color: "#18181b",
  border: "none",
  borderRadius: 12,
  width: 44,
  height: 44,
  fontSize: 22,
  fontWeight: "bold",
  boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
  cursor: "pointer",
  marginBottom: 0,
  marginTop: 0,
  textTransform: "uppercase",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: 0,
  transition: "background 0.2s, color 0.2s, transform 0.1s"
}, fae = {
  background: "#ffe066",
  color: "#18181b",
  transform: "translateY(-2px) scale(1.03)"
}, mae = ({
  onReset: r,
  onBack: e,
  onForward: i,
  canGoBack: n,
  canGoForward: s
}) => {
  const [a, o] = ni.useState(""), l = (u) => a === u ? { ...WA, ...fae } : WA;
  return /* @__PURE__ */ ne.jsxs(
    "div",
    {
      style: {
        position: "absolute",
        top: "18px",
        left: "18px",
        zIndex: 50,
        display: "flex",
        flexDirection: "row",
        gap: "12px",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              width: 44,
              height: 44
              // Espace vide pour maintenir l'alignement
            }
          }
        ),
        /* @__PURE__ */ ne.jsx(
          "button",
          {
            style: { ...l("graph"), width: 54 },
            onClick: r,
            "aria-label": "Return to graph",
            onMouseEnter: () => o("graph"),
            onMouseLeave: () => o(""),
            children: /* @__PURE__ */ ne.jsx(hae, { size: 28 })
          }
        ),
        /* @__PURE__ */ ne.jsx(
          "button",
          {
            style: { ...l("prev"), opacity: n ? 1 : 0.5 },
            onClick: e,
            disabled: !n,
            "aria-label": "Previous",
            onMouseEnter: () => o("prev"),
            onMouseLeave: () => o(""),
            children: /* @__PURE__ */ ne.jsx(dae, {})
          }
        ),
        /* @__PURE__ */ ne.jsx(
          "button",
          {
            style: { ...l("next"), opacity: s ? 1 : 0.5 },
            onClick: i,
            disabled: !s,
            "aria-label": "Next",
            onMouseEnter: () => o("next"),
            onMouseLeave: () => o(""),
            children: /* @__PURE__ */ ne.jsx(pae, {})
          }
        )
      ]
    }
  );
}, gae = ({ viewMode: r, onViewModeChange: e }) => /* @__PURE__ */ ne.jsxs(
  "div",
  {
    className: "agent-navbar",
    style: {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      background: "#18181b",
      border: "2px solid #ffd32a",
      borderRadius: "10px",
      padding: "6px 16px",
      color: "#ffd32a",
      fontWeight: "bold",
      fontSize: "15px",
      boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
    },
    children: [
      /* @__PURE__ */ ne.jsx("label", { htmlFor: "viewMode", style: { color: "#ffd32a", marginRight: 8 }, children: "View Mode:" }),
      /* @__PURE__ */ ne.jsxs(
        "select",
        {
          id: "viewMode",
          value: r,
          onChange: (i) => e(i.target.value),
          style: {
            background: "#232326",
            color: "#ffd32a",
            border: "1.5px solid #ffd32a",
            borderRadius: 6,
            padding: "4px 10px",
            fontWeight: "bold",
            fontSize: 15,
            outline: "none",
            cursor: "pointer"
          },
          children: [
            /* @__PURE__ */ ne.jsx("option", { value: "2D", children: "2D" }),
            /* @__PURE__ */ ne.jsx("option", { value: "3D", children: "3D" }),
            /* @__PURE__ */ ne.jsx("option", { value: "VR", children: "VR" })
          ]
        }
      )
    ]
  }
), pm = (r) => {
  const e = [], i = [], n = /* @__PURE__ */ new Map();
  return r.forEach(({ subject: s, predicate: a, object: o }) => {
    if (!n.has(s.id)) {
      const l = {
        id: s.id,
        label: s.label,
        image: s.image,
        isTriple: !1,
        color: Pu("subject"),
        type: "subject"
      };
      n.set(s.id, l), e.push(l);
    }
    if (!n.has(o.id)) {
      const l = {
        id: o.id,
        label: o.label,
        image: o.image,
        isTriple: !1,
        color: Pu("object"),
        type: "object"
      };
      n.set(o.id, l), e.push(l);
    }
    i.push({
      source: s.id,
      target: o.id,
      type: "subject-to-object",
      label: a.label,
      predicateId: a.id
    });
  }), { nodes: e, links: i };
}, yae = "0x5dc0a2335c12343d8e0f71b62a73fbf70d06fcbaf647f57d82a189873ad90da3", vae = (r, e = "base") => {
  const [i, n] = Pe({ nodes: [], links: [] }), [s, a] = Pe(null), [o, l] = Pe(!0), [u, c] = Pe(null), [h, d] = Pe(!1), [p, f] = Pe([]), [m, v] = Pe(0), y = yr(null), [g, _] = Pe(""), [x, b] = Pe(""), [T, S] = Pe(""), [w, A] = Pe(!1), [E, M] = Pe(!1), N = Dr(async () => {
    d(!0);
    try {
      let j;
      e === "agent" ? j = await Pk(yae, r) : j = await v_(r);
      const K = pm(j);
      n(K), a(K);
    } catch (j) {
      console.error("Error loading graph data:", j);
    } finally {
      d(!1);
    }
  }, [r, e]), k = Dr(() => {
    n(s), c(null), _(""), b(""), S(""), M(!1);
  }, [s]), U = Dr(
    async (j, K, L) => {
      if (j === null) {
        c(null);
        return;
      }
      if (c(j), K && K.current)
        try {
          const B = {
            x: j.x,
            y: j.y,
            z: j.z || 0
          }, Q = await Rk(j.id, r), W = pm(Q), z = W.nodes.find((X) => X.id === j.id);
          z && (z.x = B.x, z.y = B.y, L === "3D" && (z.z = B.z), z.fx = B.x, z.fy = B.y, L === "3D" && (z.fz = B.z)), f((X) => {
            const ae = X.slice(
              0,
              m + 1
            );
            return ae.push({ graphData: i, selectedTriple: j }), ae;
          }), v((X) => X + 1), n(W);
        } catch (B) {
          console.error("Error fetching triples:", B);
        }
    },
    [r, i, m]
  ), C = Dr((j, K) => {
    switch (y.current && clearTimeout(y.current), j) {
      case "subject":
        _(K);
        break;
      case "predicate":
        b(K);
        break;
      case "object":
        S(K);
        break;
    }
    y.current = setTimeout(() => {
      M(!0);
    }, 500);
  }, []), O = Dr(async () => {
    if (E) {
      if (!g && !x && !T) {
        k();
        return;
      }
      A(!0);
      try {
        const j = await Iu({
          subject: g,
          predicate: x,
          object: T
        }, r);
        if (!j || j.length === 0) {
          n({ nodes: [], links: [] });
          return;
        }
        const K = pm(j);
        n(K), f((L) => {
          const B = L.slice(0, m + 1);
          return B.push({ graphData: K, selectedTriple: null }), B;
        }), v((L) => L + 1);
      } catch (j) {
        console.error("Error searching triples:", j);
      } finally {
        A(!1), M(!1);
      }
    }
  }, [
    g,
    x,
    T,
    r,
    k,
    m,
    E
  ]), D = Dr(() => {
    if (m > 0) {
      const { graphData: j, selectedTriple: K } = p[m - 1];
      n(j), c(K), v((L) => L - 1);
    }
  }, [m, p]), H = Dr(() => {
    if (m < p.length - 1) {
      const { graphData: j, selectedTriple: K } = p[m + 1];
      n(j), c(K), v((L) => L + 1);
    }
  }, [m, p]);
  return {
    graphData: i,
    initialGraphData: s,
    isInitialLoad: o,
    selectedTriple: u,
    isLoading: h,
    isSearching: w,
    subjectFilter: g,
    predicateFilter: x,
    objectFilter: T,
    shouldSearch: E,
    canGoBack: m > 0,
    canGoForward: m < p.length - 1,
    setSelectedTriple: c,
    setIsInitialLoad: l,
    loadInitialData: N,
    resetGraph: k,
    handleNodeClick: U,
    handleFilterChange: C,
    applyFilters: O,
    goBack: D,
    goForward: H,
    setGraphData: n,
    graphHistory: p,
    setGraphHistory: f,
    currentHistoryIndex: m,
    setCurrentHistoryIndex: v
  };
};
let Dh = {
  endpoint: null,
  data: null,
  timestamp: null
};
const bae = 15 * 60 * 1e3, xae = async (r) => {
  const e = Date.now();
  if (Dh.data && Dh.endpoint === r && e - Dh.timestamp < bae)
    return Dh.data;
  const i = await v_(r);
  return Dh = {
    endpoint: r,
    data: i,
    timestamp: e
  }, i;
}, _ae = async (r, e = "base", i = 10) => {
  if (!r || r.length < 1)
    return { subjects: [], predicates: [], objects: [], triples: [] };
  const n = r.toLowerCase().trim();
  if (["is", "of", "in", "at", "by", "to"].includes(n))
    try {
      const s = await Iu({ predicate: n }, e);
      if (s && s.length > 0)
        return {
          subjects: [...new Set(s.map((a) => a.subject.label))].slice(0, i),
          predicates: [n],
          objects: [...new Set(s.map((a) => a.object.label))].slice(0, i),
          triples: s.map((a) => ({
            subject: a.subject.label,
            predicate: a.predicate.label,
            object: a.object.label
          })).slice(0, i)
        };
    } catch {
    }
  try {
    const s = (await xae(e)).filter((f) => n.length <= 3 ? f.subject && f.subject.label && f.subject.label.toLowerCase().indexOf(n) !== -1 || f.predicate && f.predicate.label && f.predicate.label.toLowerCase().indexOf(n) !== -1 || f.object && f.object.label && f.object.label.toLowerCase().indexOf(n) !== -1 : f.subject && f.subject.label && f.subject.label.toLowerCase().includes(n) || f.predicate && f.predicate.label && f.predicate.label.toLowerCase().includes(n) || f.object && f.object.label && f.object.label.toLowerCase().includes(n));
    if (s.length > 0) {
      const f = (x) => {
        if (!x) return 0;
        const b = x.toLowerCase();
        let T = 100 - Math.min(x.length, 50);
        return b.startsWith(n) && (T += 200), b === n && (T += 300), !/^0x[0-9a-f]{8,}$/i.test(b) && !/[0-9a-f]{30,}/i.test(b) && (T += 150), /^[A-Za-z0-9]+ - [A-Za-z0-9 ]+$/.test(x) && (T += 100), T;
      }, m = [...new Set(
        s.filter((x) => x.subject && x.subject.label && x.subject.label.toLowerCase().indexOf(n) !== -1).map((x) => x.subject.label)
      )].sort((x, b) => f(b) - f(x));
      let v = [...new Set(
        s.filter((x) => x.predicate && x.predicate.label && x.predicate.label.toLowerCase().indexOf(n) !== -1).map((x) => x.predicate.label)
      )].sort((x, b) => x.toLowerCase() === n ? -1 : b.toLowerCase() === n ? 1 : f(b) - f(x));
      const y = [...new Set(
        s.filter((x) => x.object && x.object.label && x.object.label.toLowerCase().indexOf(n) !== -1).map((x) => x.object.label)
      )].sort((x, b) => f(b) - f(x)), g = (x) => {
        if (!x) return 0;
        const b = x.subject ? f(x.subject) : 0, T = x.predicate ? f(x.predicate) : 0, S = x.object ? f(x.object) : 0;
        return Math.max(b, T, S);
      }, _ = s.map((x) => ({
        subject: x.subject.label,
        predicate: x.predicate.label,
        object: x.object.label
      })).sort((x, b) => g(b) - g(x)).slice(0, i);
      return {
        subjects: m.slice(0, i),
        predicates: v.slice(0, i),
        objects: y.slice(0, i),
        triples: _
      };
    }
    const a = await Iu({ subject: r }, e), o = await Iu({ predicate: r }, e), l = await Iu({ object: r }, e);
    let u = [...a || []];
    o && o.length > 0 && (u = [...u, ...o.filter(
      (f) => !u.some((m) => m.id === f.id)
    )]), l && l.length > 0 && (u = [...u, ...l.filter(
      (f) => !u.some((m) => m.id === f.id)
    )]);
    const c = [...new Set(
      u.filter((f) => f.subject && f.subject.label).map((f) => f.subject.label).filter((f) => f.toLowerCase().includes(n))
    )], h = [...new Set(
      u.filter((f) => f.predicate && f.predicate.label).map((f) => f.predicate.label).filter((f) => f.toLowerCase().includes(n))
    )], d = [...new Set(
      u.filter((f) => f.object && f.object.label).map((f) => f.object.label).filter((f) => f.toLowerCase().includes(n))
    )], p = u.map((f) => ({
      subject: f.subject.label,
      predicate: f.predicate.label,
      object: f.object.label
    })).slice(0, i);
    return {
      subjects: c.slice(0, i),
      predicates: h.slice(0, i),
      objects: d.slice(0, i),
      triples: p
    };
  } catch {
    return { subjects: [], predicates: [], objects: [], triples: [] };
  }
}, Tae = ({
  endpoint: r,
  onSearch: e,
  isSearching: i,
  onSearchStart: n
}) => {
  const [s, a] = Pe(""), [o, l] = Pe({
    subjects: [],
    predicates: [],
    objects: [],
    triples: []
  }), [u, c] = Pe({
    subject: "",
    predicate: "",
    object: ""
  }), [h, d] = Pe(!1), [p, f] = Pe(!1), m = yr(null), v = yr(null);
  si(() => {
    const U = (C) => {
      v.current && !v.current.contains(C.target) && d(!1);
    };
    return document.addEventListener("mousedown", U), () => {
      document.removeEventListener("mousedown", U);
    };
  }, []), si(() => (s.length >= 2 ? (clearTimeout(m.current), f(!0), d(!0), m.current = setTimeout(async () => {
    try {
      const U = await _ae(s, r);
      l(U), d(!0), f(!1);
    } catch (U) {
      console.error("Error retrieving suggestions:", U), f(!1);
    }
  }, 300)) : (l({
    subjects: [],
    predicates: [],
    objects: [],
    triples: []
  }), d(!1), f(!1)), () => {
    clearTimeout(m.current);
  }), [s, r]);
  const y = (U, C) => {
    c((O) => ({
      ...O,
      [U]: O[U] === C ? "" : C
    }));
  }, g = async () => {
    typeof n == "function" && n();
    try {
      const U = {
        subject: u.subject || "",
        predicate: u.predicate || "",
        object: u.object || ""
      };
      typeof e == "function" && await e(s, U);
    } catch {
    }
  }, _ = u.subject || u.predicate || u.object, x = o.subjects.length > 0 || o.predicates.length > 0 || o.objects.length > 0 || o.triples && o.triples.length > 0, b = {
    container: {
      width: "100%",
      maxWidth: "550px",
      margin: "0 auto",
      position: "relative",
      zIndex: 1e3
    },
    inputWrapper: {
      display: "flex",
      width: "100%",
      boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
      borderRadius: "12px",
      overflow: "hidden",
      backgroundColor: "rgba(30, 30, 40, 0.6)",
      backdropFilter: "blur(5px)",
      border: "1px solid rgba(255, 255, 255, 0.2)"
    },
    input: {
      flex: 1,
      padding: "10px 15px",
      fontSize: "15px",
      border: "none",
      backgroundColor: "transparent",
      color: "white",
      outline: "none",
      fontWeight: "400",
      height: "40px"
    },
    button: {
      padding: "0 22px",
      border: "none",
      cursor: "pointer",
      fontWeight: "bold",
      fontSize: "15px",
      textTransform: "uppercase"
    },
    activeFilters: {
      display: "flex",
      flexWrap: "wrap",
      alignItems: "center",
      marginTop: "12px",
      padding: "8px 12px",
      backgroundColor: "rgba(30, 30, 40, 0.7)",
      borderRadius: "6px",
      border: "1px solid rgba(255, 255, 255, 0.1)",
      backdropFilter: "blur(5px)"
    },
    filtersLabel: {
      fontWeight: "600",
      marginRight: "12px",
      color: "rgba(255, 255, 255, 0.9)",
      fontSize: "13px"
    },
    filtersChips: {
      display: "flex",
      flexWrap: "wrap",
      gap: "6px",
      flex: 1
    },
    filterChip: {
      display: "flex",
      alignItems: "center",
      padding: "3px 8px",
      borderRadius: "16px",
      fontSize: "12px",
      color: "white",
      boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
    },
    subjectChip: {
      backgroundColor: `${Ei.SUBJECT}cc`
    },
    predicateChip: {
      backgroundColor: `${Ei.PREDICATE}cc`
    },
    objectChip: {
      backgroundColor: `${Ei.OBJECT}cc`
    },
    chipButton: {
      background: "none",
      border: "none",
      color: "white",
      marginLeft: "4px",
      cursor: "pointer",
      fontSize: "14px",
      lineHeight: 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "16px",
      height: "16px",
      borderRadius: "50%",
      transition: "background-color 0.2s ease"
    },
    chipButtonHover: {
      backgroundColor: "rgba(255, 255, 255, 0.2)"
    },
    clearButton: {
      padding: "4px 10px",
      backgroundColor: "rgba(255, 70, 70, 0.8)",
      color: "white",
      border: "none",
      borderRadius: "16px",
      cursor: "pointer",
      fontSize: "12px",
      fontWeight: "500",
      boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)",
      transition: "background-color 0.2s ease",
      marginLeft: "auto"
    },
    clearButtonHover: {
      backgroundColor: "rgba(255, 70, 70, 1)"
    },
    suggestionsContainer: {
      position: "absolute",
      top: "calc(100% + 8px)",
      left: 0,
      right: 0,
      backgroundColor: "rgba(25, 25, 35, 0.9)",
      backdropFilter: "blur(10px)",
      border: "1px solid rgba(255, 255, 255, 0.1)",
      borderRadius: "8px",
      maxHeight: "400px",
      overflowY: "auto",
      zIndex: 1001,
      boxShadow: "0 8px 16px rgba(0, 0, 0, 0.3)",
      color: "white"
    },
    suggestionCategory: {
      padding: "14px",
      borderBottom: "1px solid rgba(255, 255, 255, 0.1)"
    },
    categoryHeader: {
      fontWeight: "600",
      marginBottom: "10px",
      color: "rgba(255, 255, 255, 0.8)",
      fontSize: "14px",
      textTransform: "uppercase",
      letterSpacing: "0.5px"
    },
    suggestionList: {
      display: "flex",
      flexWrap: "wrap",
      gap: "8px"
    },
    suggestionItem: {
      padding: "3px 8px",
      borderRadius: "16px",
      backgroundColor: "rgba(255, 255, 255, 0.15)",
      fontSize: "12px",
      cursor: "pointer",
      transition: "all 0.2s ease",
      color: "rgba(255, 255, 255, 0.9)"
    },
    suggestionItemHover: {
      backgroundColor: "rgba(255, 255, 255, 0.25)"
    },
    selectedSuggestion: {
      backgroundColor: "#4A66E8",
      color: "white"
    },
    loadingContainer: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: "25px"
    },
    loader: {
      width: "30px",
      height: "30px",
      border: "3px solid rgba(255,255,255,0.2)",
      borderRadius: "50%",
      borderTop: "3px solid #ffd32a",
      animation: "spin 1s linear infinite"
    },
    noResults: {
      padding: "25px",
      textAlign: "center",
      fontSize: "14px",
      color: "rgba(255,255,255,0.7)"
    },
    tripleSuggestion: {
      padding: "8px 12px",
      borderRadius: "12px",
      fontSize: "13px",
      cursor: "pointer",
      transition: "all 0.2s ease",
      backgroundColor: "rgba(30, 30, 40, 0.55)",
      backdropFilter: "blur(5px)",
      border: "1px solid rgba(255, 255, 255, 0.15)",
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      gap: "6px",
      alignItems: "center",
      justifyContent: "center"
    },
    tripleSuggestionHover: {
      backgroundColor: "rgba(50, 50, 60, 0.65)"
    },
    tripleSubjectPart: {
      color: Ei.SUBJECT,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Ei.SUBJECT}33`
    },
    triplePredicatePart: {
      color: Ei.PREDICATE,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Ei.PREDICATE}33`
    },
    tripleObjectPart: {
      color: Ei.OBJECT,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Ei.OBJECT}33`
    },
    subjectSuggestion: {
      backgroundColor: Ei.SUBJECT,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    },
    predicateSuggestion: {
      backgroundColor: Ei.PREDICATE,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    },
    objectSuggestion: {
      backgroundColor: Ei.OBJECT,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    }
  }, [T, S] = Pe(!1), [w, A] = Pe(!1), [E, M] = Pe(null), [N, k] = Pe(null);
  return /* @__PURE__ */ ne.jsxs("div", { style: b.container, children: [
    /* @__PURE__ */ ne.jsx("style", { children: `
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        ` }),
    /* @__PURE__ */ ne.jsxs("div", { style: b.inputWrapper, children: [
      /* @__PURE__ */ ne.jsx(
        "input",
        {
          type: "text",
          value: s,
          onChange: (U) => a(U.target.value),
          placeholder: "Search for triples...",
          style: b.input,
          onFocus: () => {
            s.length >= 2 && d(!0);
          }
        }
      ),
      /* @__PURE__ */ ne.jsx(
        "button",
        {
          onClick: g,
          disabled: i,
          style: {
            ...b.button,
            backgroundColor: "#ffd32a",
            color: "#18181b",
            height: "40px",
            borderRadius: "0 12px 12px 0",
            boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
            transition: "background 0.2s, color 0.2s, transform 0.1s"
          },
          onMouseEnter: (U) => U.currentTarget.style.backgroundColor = "#ffe066",
          onMouseLeave: (U) => U.currentTarget.style.backgroundColor = "#ffd32a",
          children: i ? "Searching..." : "Search"
        }
      )
    ] }),
    _ && /* @__PURE__ */ ne.jsxs("div", { style: b.activeFilters, children: [
      /* @__PURE__ */ ne.jsx("div", { style: b.filtersLabel, children: "Active filters:" }),
      /* @__PURE__ */ ne.jsxs("div", { style: b.filtersChips, children: [
        u.subject && /* @__PURE__ */ ne.jsxs("div", { style: { ...b.filterChip, ...b.subjectChip }, children: [
          /* @__PURE__ */ ne.jsxs("span", { children: [
            "Subject: ",
            u.subject
          ] }),
          /* @__PURE__ */ ne.jsx(
            "button",
            {
              onClick: () => y("subject", u.subject),
              style: {
                ...b.chipButton,
                ...E === "subject" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => M("subject"),
              onMouseLeave: () => M(null),
              children: ""
            }
          )
        ] }),
        u.predicate && /* @__PURE__ */ ne.jsxs("div", { style: { ...b.filterChip, ...b.predicateChip }, children: [
          /* @__PURE__ */ ne.jsxs("span", { children: [
            "Predicate: ",
            u.predicate
          ] }),
          /* @__PURE__ */ ne.jsx(
            "button",
            {
              onClick: () => y("predicate", u.predicate),
              style: {
                ...b.chipButton,
                ...E === "predicate" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => M("predicate"),
              onMouseLeave: () => M(null),
              children: ""
            }
          )
        ] }),
        u.object && /* @__PURE__ */ ne.jsxs("div", { style: { ...b.filterChip, ...b.objectChip }, children: [
          /* @__PURE__ */ ne.jsxs("span", { children: [
            "Object: ",
            u.object
          ] }),
          /* @__PURE__ */ ne.jsx(
            "button",
            {
              onClick: () => y("object", u.object),
              style: {
                ...b.chipButton,
                ...E === "object" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => M("object"),
              onMouseLeave: () => M(null),
              children: ""
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ ne.jsx(
        "button",
        {
          onClick: () => c({ subject: "", predicate: "", object: "" }),
          style: {
            ...b.clearButton,
            ...w ? b.clearButtonHover : {}
          },
          onMouseEnter: () => A(!0),
          onMouseLeave: () => A(!1),
          children: "Clear all filters"
        }
      )
    ] }),
    h && /* @__PURE__ */ ne.jsxs("div", { style: b.suggestionsContainer, ref: v, children: [
      p && /* @__PURE__ */ ne.jsx("div", { style: b.loadingContainer, children: /* @__PURE__ */ ne.jsx("div", { style: b.loader }) }),
      !p && !x && s.length >= 2 && /* @__PURE__ */ ne.jsxs("div", { style: b.noResults, children: [
        'Aucune suggestion trouve pour "',
        s,
        '"'
      ] }),
      !p && o.subjects.length > 0 && /* @__PURE__ */ ne.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ ne.jsx("div", { style: b.categoryHeader, children: "Suggested Subjects" }),
        /* @__PURE__ */ ne.jsx("div", { style: b.suggestionList, children: o.subjects.map((U, C) => /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.subjectSuggestion,
              ...N === `subject-${C}` ? b.suggestionItemHover : {},
              ...u.subject === U ? b.selectedSuggestion : {}
            },
            onClick: () => y("subject", U),
            onMouseEnter: () => k(`subject-${C}`),
            onMouseLeave: () => k(null),
            children: U
          },
          `subject-${C}`
        )) })
      ] }),
      !p && o.predicates.length > 0 && /* @__PURE__ */ ne.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ ne.jsx("div", { style: b.categoryHeader, children: "Suggested Predicates" }),
        /* @__PURE__ */ ne.jsx("div", { style: b.suggestionList, children: o.predicates.map((U, C) => /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.predicateSuggestion,
              ...N === `predicate-${C}` ? b.suggestionItemHover : {},
              ...u.predicate === U ? b.selectedSuggestion : {}
            },
            onClick: () => y("predicate", U),
            onMouseEnter: () => k(`predicate-${C}`),
            onMouseLeave: () => k(null),
            children: U
          },
          `predicate-${C}`
        )) })
      ] }),
      !p && o.objects.length > 0 && /* @__PURE__ */ ne.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ ne.jsx("div", { style: b.categoryHeader, children: "Suggested Objects" }),
        /* @__PURE__ */ ne.jsx("div", { style: b.suggestionList, children: o.objects.map((U, C) => /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.objectSuggestion,
              ...N === `object-${C}` ? b.suggestionItemHover : {},
              ...u.object === U ? b.selectedSuggestion : {}
            },
            onClick: () => y("object", U),
            onMouseEnter: () => k(`object-${C}`),
            onMouseLeave: () => k(null),
            children: U
          },
          `object-${C}`
        )) })
      ] }),
      !p && o.triples && o.triples.length > 0 && /* @__PURE__ */ ne.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ ne.jsx("div", { style: b.categoryHeader, children: "Suggested Triples" }),
        /* @__PURE__ */ ne.jsx("div", { style: b.suggestionList, children: o.triples.map((U, C) => /* @__PURE__ */ ne.jsxs(
          "div",
          {
            style: {
              ...b.tripleSuggestion,
              ...N === `triple-${C}` ? b.tripleSuggestionHover : {}
            },
            onClick: () => {
              c({
                subject: U.subject,
                predicate: U.predicate,
                object: U.object
              });
            },
            onMouseEnter: () => k(`triple-${C}`),
            onMouseLeave: () => k(null),
            children: [
              /* @__PURE__ */ ne.jsx("span", { style: b.tripleSubjectPart, children: U.subject }),
              /* @__PURE__ */ ne.jsx("span", { style: b.triplePredicatePart, children: U.predicate }),
              /* @__PURE__ */ ne.jsx("span", { style: b.tripleObjectPart, children: U.object })
            ]
          },
          `triple-${C}`
        )) })
      ] })
    ] })
  ] });
}, Sae = ({ endpoint: r, walletAddress: e, onNodeSelect: i, onLoadingChange: n }) => {
  const s = yr(), a = yr(), [o, l] = ni.useState("2D"), [u, c] = ni.useState(!1), [h, d] = Pe(!1), [p, f] = Pe(!1), [m, v] = Pe(!1), [y, g] = Pe(null), [_, x] = ni.useState("agent"), {
    graphData: b,
    isInitialLoad: T,
    selectedTriple: S,
    isLoading: w,
    isSearching: A,
    subjectFilter: E,
    predicateFilter: M,
    objectFilter: N,
    shouldSearch: k,
    canGoBack: U,
    canGoForward: C,
    setIsInitialLoad: O,
    loadInitialData: D,
    resetGraph: H,
    handleNodeClick: j,
    handleFilterChange: K,
    applyFilters: L,
    goBack: B,
    goForward: Q,
    setGraphData: W,
    setGraphHistory: z,
    currentHistoryIndex: X,
    setCurrentHistoryIndex: ae
  } = vae(r, _), ue = m && y ? y : b, ge = p || A;
  si(() => {
    D();
  }, [D, _]), si(() => {
    k && (v(!1), L());
  }, [k, L]);
  const we = () => {
    T && s.current && O(!1);
  }, Ne = async (Xe, yt) => {
    try {
      f(!0);
      const rt = {
        subject: yt.subject || "",
        predicate: yt.predicate || "",
        object: yt.object || ""
      }, Nt = await Iu(rt, r);
      if (Nt && Nt.length > 0) {
        const nt = pm(Nt);
        v(!1), W(nt), z((F) => {
          const P = F.slice(0, X + 1);
          return P.push({
            graphData: nt,
            selectedTriple: null,
            filters: rt
          }), P;
        }), ae((F) => F + 1);
      } else
        W({ nodes: [], links: [] });
    } catch {
      W({ nodes: [], links: [] });
    } finally {
      f(!1);
    }
  }, lt = () => {
    f(!0);
  }, be = () => {
    v(!1), H();
  }, bt = (Xe, yt) => {
    v(!1), K(Xe, yt);
  }, Y = () => {
    m && v(!1);
  }, Gt = () => /* @__PURE__ */ ne.jsxs(
    "div",
    {
      style: {
        display: "none",
        alignItems: "center",
        backgroundColor: "#27272a",
        padding: "8px 12px",
        borderRadius: 8,
        marginLeft: 12,
        boxShadow: "0 2px 8px rgba(0,0,0,0.2)"
      },
      children: [
        /* @__PURE__ */ ne.jsx("span", { style: { color: "white", marginRight: 10, fontSize: 14 }, children: "Graph Type:" }),
        /* @__PURE__ */ ne.jsxs(
          "select",
          {
            value: _,
            onChange: (Xe) => x(Xe.target.value),
            style: {
              backgroundColor: "#3f3f46",
              color: "white",
              border: "none",
              padding: "4px 8px",
              borderRadius: 4,
              cursor: "pointer"
            },
            children: [
              /* @__PURE__ */ ne.jsx("option", { value: "base", children: "Base" }),
              /* @__PURE__ */ ne.jsx("option", { value: "agent", children: "Agent" })
            ]
          }
        )
      ]
    }
  );
  return /* @__PURE__ */ ne.jsxs(
    "div",
    {
      ref: a,
      className: "graph-visualization-container",
      style: {
        position: "relative",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        width: "100%",
        height: "100vh",
        overflow: "hidden"
      },
      children: [
        (w || ge || h) && /* @__PURE__ */ ne.jsx(MC, {}),
        /* @__PURE__ */ ne.jsx(
          mae,
          {
            onReset: be,
            onBack: () => {
              Y(), B();
            },
            onForward: () => {
              Y(), Q();
            },
            canGoBack: U,
            canGoForward: C
          }
        ),
        /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "80px",
              left: "18px",
              zIndex: 50
            },
            children: /* @__PURE__ */ ne.jsx(gae, { viewMode: o, onViewModeChange: l })
          }
        ),
        /* @__PURE__ */ ne.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "10px",
              left: "50%",
              transform: "translateX(-50%)",
              zIndex: 1e3,
              width: "550px",
              maxWidth: "calc(100% - 350px)"
            },
            children: /* @__PURE__ */ ne.jsx(
              Tae,
              {
                endpoint: r,
                onSearch: Ne,
                isSearching: ge,
                onSearchStart: lt
              }
            )
          }
        ),
        /* @__PURE__ */ ne.jsxs(
          "div",
          {
            className: "agent-navbar",
            style: {
              position: "absolute",
              top: "10px",
              right: "10px",
              zIndex: 10,
              display: "flex",
              flexDirection: "row",
              alignItems: "center",
              gap: "16px"
            },
            children: [
              /* @__PURE__ */ ne.jsx(Gt, {}),
              !u && /* @__PURE__ */ ne.jsx(
                "button",
                {
                  style: {
                    background: "#ffd32a",
                    color: "#18181b",
                    border: "none",
                    borderRadius: 12,
                    width: 120,
                    height: 40,
                    fontSize: 15,
                    fontWeight: "bold",
                    boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
                    cursor: "pointer",
                    textTransform: "uppercase",
                    marginLeft: 12,
                    transition: "background 0.2s, color 0.2s, transform 0.1s"
                  },
                  onMouseEnter: (Xe) => Xe.currentTarget.style.background = "#ffe066",
                  onMouseLeave: (Xe) => Xe.currentTarget.style.background = "#ffd32a",
                  onClick: () => c((Xe) => !Xe),
                  children: "Filters"
                }
              ),
              u && /* @__PURE__ */ ne.jsx(
                "div",
                {
                  style: {
                    marginLeft: 12,
                    display: "flex",
                    alignItems: "center",
                    gap: 16,
                    position: "relative"
                  },
                  children: /* @__PURE__ */ ne.jsx(
                    "div",
                    {
                      style: {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "flex-end",
                        position: "relative"
                      },
                      children: /* @__PURE__ */ ne.jsx(
                        Ok,
                        {
                          subjectFilter: E,
                          predicateFilter: M,
                          objectFilter: N,
                          onFilterChange: bt,
                          onReset: be,
                          onClose: () => c(!1)
                        }
                      )
                    }
                  )
                }
              )
            ]
          }
        ),
        o === "2D" && /* @__PURE__ */ ne.jsx(
          tae,
          {
            graphData: ue,
            onNodeClick: (Xe) => {
              Y(), j(Xe, s, o);
            },
            onEngineStop: we,
            fgRef: s,
            selectedTriple: S,
            endpoint: r,
            children: /* @__PURE__ */ ne.jsx(GS, {})
          }
        ),
        o === "3D" && /* @__PURE__ */ ne.jsx(
          rae,
          {
            graphData: ue,
            onNodeClick: (Xe) => {
              Y(), j(Xe, s, o);
            },
            onEngineStop: we,
            fgRef: s,
            selectedTriple: S,
            endpoint: r,
            children: /* @__PURE__ */ ne.jsx(GS, {})
          }
        ),
        o === "VR" && /* @__PURE__ */ ne.jsx(
          Ik,
          {
            graphData: ue,
            onNodeClick: (Xe) => {
              Y(), j(Xe, s, o);
            },
            onBack: () => {
              Y(), B();
            },
            onForward: () => {
              Y(), Q();
            },
            selectedTriple: S,
            endpoint: r
          }
        )
      ]
    }
  );
};
function wae({
  open: r,
  onClose: e,
  children: i
}) {
  return /* @__PURE__ */ V.jsx(
    "div",
    {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        width: r ? "16.67vw" : 0,
        minWidth: r ? "250px" : 0,
        backgroundColor: "#18181b",
        borderTopRightRadius: 18,
        borderBottomRightRadius: 18,
        transition: "width 0.35s cubic-bezier(0.4, 1.3, 0.5, 1)",
        zIndex: 1300,
        boxShadow: "2px 0 16px rgba(0, 0, 0, 0.18)",
        border: "2px solid #ffd32a",
        overflow: "hidden"
      },
      children: r && /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
        /* @__PURE__ */ V.jsx(
          "button",
          {
            style: {
              background: "none",
              border: "none",
              color: "#ffd32a",
              fontSize: 32,
              position: "absolute",
              top: 10,
              right: 18,
              cursor: "pointer",
              zIndex: 1302,
              transition: "color 0.2s"
            },
            onClick: e,
            children: ""
          }
        ),
        /* @__PURE__ */ V.jsx(
          "div",
          {
            style: {
              padding: "48px 24px 24px 24px",
              overflowY: "auto",
              height: "100%",
              color: "#ffd32a"
            },
            children: i
          }
        )
      ] })
    }
  );
}
const Au = ({ label: r, value: e }) => /* @__PURE__ */ V.jsxs("div", { style: { display: "flex", gap: 8, marginBottom: 4 }, children: [
  /* @__PURE__ */ V.jsxs("span", { style: { color: "#ffd32a", fontWeight: 700, minWidth: 110 }, children: [
    r,
    ":"
  ] }),
  /* @__PURE__ */ V.jsx("span", { style: { color: "#fff" }, children: e || "N/A" })
] }), Eae = ({ src: r, alt: e }) => r ? /* @__PURE__ */ V.jsx(
  "img",
  {
    src: r,
    alt: e,
    style: {
      width: 48,
      height: 48,
      borderRadius: "50%",
      objectFit: "cover",
      boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
      marginRight: 10
    }
  }
) : null, Mae = ({ position: r }) => {
  var a;
  const e = Number(((a = r.term) == null ? void 0 : a.total_market_cap) || 0), i = Number(r.shares || 0), n = r.account, s = r.term;
  return /* @__PURE__ */ V.jsxs(
    "div",
    {
      style: {
        background: "#232326",
        borderRadius: 14,
        padding: "18px 24px",
        marginBottom: 18,
        boxShadow: "0 2px 12px rgba(0,0,0,0.13)",
        borderLeft: "6px solid #ffd32a",
        position: "relative",
        display: "flex",
        flexDirection: "column",
        gap: 2
      },
      className: "activity-card",
      children: [
        /* @__PURE__ */ V.jsxs("div", { style: { display: "flex", alignItems: "center", marginBottom: 10 }, children: [
          /* @__PURE__ */ V.jsx(Eae, { src: n == null ? void 0 : n.image, alt: n == null ? void 0 : n.label }),
          /* @__PURE__ */ V.jsxs("div", { children: [
            /* @__PURE__ */ V.jsx(Au, { label: "Account", value: (n == null ? void 0 : n.label) || (n == null ? void 0 : n.id) }),
            /* @__PURE__ */ V.jsx(Au, { label: "Type", value: n == null ? void 0 : n.type })
          ] })
        ] }),
        /* @__PURE__ */ V.jsx(Au, { label: "Position ID", value: r.id }),
        /* @__PURE__ */ V.jsx(Au, { label: "Shares", value: i }),
        /* @__PURE__ */ V.jsx(Au, { label: "Term Shares", value: e }),
        /* @__PURE__ */ V.jsx(Au, { label: "Term ID", value: s == null ? void 0 : s.term_id })
      ]
    }
  );
};
var l3 = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, qA = ni.createContext && /* @__PURE__ */ ni.createContext(l3), Aae = ["attr", "size", "title"];
function Cae(r, e) {
  if (r == null) return {};
  var i = Rae(r, e), n, s;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(r);
    for (s = 0; s < a.length; s++)
      n = a[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (i[n] = r[n]);
  }
  return i;
}
function Rae(r, e) {
  if (r == null) return {};
  var i = {};
  for (var n in r)
    if (Object.prototype.hasOwnProperty.call(r, n)) {
      if (e.indexOf(n) >= 0) continue;
      i[n] = r[n];
    }
  return i;
}
function tg() {
  return tg = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n]);
    }
    return r;
  }, tg.apply(this, arguments);
}
function XA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function ig(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? XA(Object(i), !0).forEach(function(n) {
      Nae(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : XA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function Nae(r, e, i) {
  return e = Pae(e), e in r ? Object.defineProperty(r, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = i, r;
}
function Pae(r) {
  var e = Iae(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Iae(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function u3(r) {
  return r && r.map((e, i) => /* @__PURE__ */ ni.createElement(e.tag, ig({
    key: i
  }, e.attr), u3(e.child)));
}
function Oae(r) {
  return (e) => /* @__PURE__ */ ni.createElement(Dae, tg({
    attr: ig({}, r.attr)
  }, e), u3(r.child));
}
function Dae(r) {
  var e = (i) => {
    var {
      attr: n,
      size: s,
      title: a
    } = r, o = Cae(r, Aae), l = s || i.size || "1em", u;
    return i.className && (u = i.className), r.className && (u = (u ? u + " " : "") + r.className), /* @__PURE__ */ ni.createElement("svg", tg({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, i.attr, n, o, {
      className: u,
      style: ig(ig({
        color: r.color || i.color
      }, i.style), r.style),
      height: l,
      width: l,
      xmlns: "http://www.w3.org/2000/svg"
    }), a && /* @__PURE__ */ ni.createElement("title", null, a), r.children);
  };
  return qA !== void 0 ? /* @__PURE__ */ ni.createElement(qA.Consumer, null, (i) => e(i)) : e(l3);
}
function Lae(r) {
  return Oae({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z" }, child: [] }] })(r);
}
var Zg = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(r) {
    return this.listeners.add(r), this.onSubscribe(), () => {
      this.listeners.delete(r), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, Uae = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (r, e) => setTimeout(r, e),
  clearTimeout: (r) => clearTimeout(r),
  setInterval: (r, e) => setInterval(r, e),
  clearInterval: (r) => clearInterval(r)
}, os, al, i2, kae = (i2 = class {
  constructor() {
    // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
    // type at app boot; and if we leave that type, then any new timer provider
    // would need to support ReturnType<typeof setTimeout>, which is infeasible.
    //
    // We settle for type safety for the TimeoutProvider type, and accept that
    // this class is unsafe internally to allow for extension.
    zt(this, os, Uae);
    zt(this, al, !1);
  }
  setTimeoutProvider(r) {
    process.env.NODE_ENV !== "production" && me(this, al) && r !== me(this, os) && console.error(
      "[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.",
      { previous: me(this, os), provider: r }
    ), mt(this, os, r), process.env.NODE_ENV !== "production" && mt(this, al, !1);
  }
  setTimeout(r, e) {
    return process.env.NODE_ENV !== "production" && mt(this, al, !0), me(this, os).setTimeout(r, e);
  }
  clearTimeout(r) {
    me(this, os).clearTimeout(r);
  }
  setInterval(r, e) {
    return process.env.NODE_ENV !== "production" && mt(this, al, !0), me(this, os).setInterval(r, e);
  }
  clearInterval(r) {
    me(this, os).clearInterval(r);
  }
}, os = new WeakMap(), al = new WeakMap(), i2), Qx = new kae();
function Fae(r) {
  setTimeout(r, 0);
}
var Qg = typeof window > "u" || "Deno" in globalThis;
function Fn() {
}
function Bae(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function zae(r) {
  return typeof r == "number" && r >= 0 && r !== 1 / 0;
}
function jae(r, e) {
  return Math.max(r + (e || 0) - Date.now(), 0);
}
function Jx(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function Vae(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function $A(r, e) {
  const {
    type: i = "all",
    exact: n,
    fetchStatus: s,
    predicate: a,
    queryKey: o,
    stale: l
  } = r;
  if (o) {
    if (n) {
      if (e.queryHash !== lS(o, e.options))
        return !1;
    } else if (!Od(e.queryKey, o))
      return !1;
  }
  if (i !== "all") {
    const u = e.isActive();
    if (i === "active" && !u || i === "inactive" && u)
      return !1;
  }
  return !(typeof l == "boolean" && e.isStale() !== l || s && s !== e.state.fetchStatus || a && !a(e));
}
function YA(r, e) {
  const { exact: i, status: n, predicate: s, mutationKey: a } = r;
  if (a) {
    if (!e.options.mutationKey)
      return !1;
    if (i) {
      if (Id(e.options.mutationKey) !== Id(a))
        return !1;
    } else if (!Od(e.options.mutationKey, a))
      return !1;
  }
  return !(n && e.state.status !== n || s && !s(e));
}
function lS(r, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || Id)(r);
}
function Id(r) {
  return JSON.stringify(
    r,
    (e, i) => t_(i) ? Object.keys(i).sort().reduce((n, s) => (n[s] = i[s], n), {}) : i
  );
}
function Od(r, e) {
  return r === e ? !0 : typeof r != typeof e ? !1 : r && e && typeof r == "object" && typeof e == "object" ? Object.keys(e).every((i) => Od(r[i], e[i])) : !1;
}
var Gae = Object.prototype.hasOwnProperty;
function e_(r, e) {
  if (r === e)
    return r;
  const i = KA(r) && KA(e);
  if (!i && !(t_(r) && t_(e))) return e;
  const s = (i ? r : Object.keys(r)).length, a = i ? e : Object.keys(e), o = a.length, l = i ? new Array(o) : {};
  let u = 0;
  for (let c = 0; c < o; c++) {
    const h = i ? c : a[c], d = r[h], p = e[h];
    if (d === p) {
      l[h] = d, (i ? c < s : Gae.call(r, h)) && u++;
      continue;
    }
    if (d === null || p === null || typeof d != "object" || typeof p != "object") {
      l[h] = p;
      continue;
    }
    const f = e_(d, p);
    l[h] = f, f === d && u++;
  }
  return s === o && u === s ? r : l;
}
function KA(r) {
  return Array.isArray(r) && r.length === Object.keys(r).length;
}
function t_(r) {
  if (!ZA(r))
    return !1;
  const e = r.constructor;
  if (e === void 0)
    return !0;
  const i = e.prototype;
  return !(!ZA(i) || !i.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(r) !== Object.prototype);
}
function ZA(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
function Hae(r) {
  return new Promise((e) => {
    Qx.setTimeout(e, r);
  });
}
function Wae(r, e, i) {
  if (typeof i.structuralSharing == "function")
    return i.structuralSharing(r, e);
  if (i.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return e_(r, e);
      } catch (n) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${i.queryHash}]: ${n}`
        ), n;
      }
    return e_(r, e);
  }
  return e;
}
function qae(r, e, i = 0) {
  const n = [...r, e];
  return i && n.length > i ? n.slice(1) : n;
}
function Xae(r, e, i = 0) {
  const n = [e, ...r];
  return i && n.length > i ? n.slice(0, -1) : n;
}
var rg = Symbol();
function c3(r, e) {
  return process.env.NODE_ENV !== "production" && r.queryFn === rg && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${r.queryHash}'`
  ), !r.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !r.queryFn || r.queryFn === rg ? () => Promise.reject(new Error(`Missing queryFn: '${r.queryHash}'`)) : r.queryFn;
}
var ol, ro, ic, r2, $ae = (r2 = class extends Zg {
  constructor() {
    super();
    zt(this, ol);
    zt(this, ro);
    zt(this, ic);
    mt(this, ic, (e) => {
      if (!Qg && window.addEventListener) {
        const i = () => e();
        return window.addEventListener("visibilitychange", i, !1), () => {
          window.removeEventListener("visibilitychange", i);
        };
      }
    });
  }
  onSubscribe() {
    me(this, ro) || this.setEventListener(me(this, ic));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = me(this, ro)) == null || e.call(this), mt(this, ro, void 0));
  }
  setEventListener(e) {
    var i;
    mt(this, ic, e), (i = me(this, ro)) == null || i.call(this), mt(this, ro, e((n) => {
      typeof n == "boolean" ? this.setFocused(n) : this.onFocus();
    }));
  }
  setFocused(e) {
    me(this, ol) !== e && (mt(this, ol, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((i) => {
      i(e);
    });
  }
  isFocused() {
    var e;
    return typeof me(this, ol) == "boolean" ? me(this, ol) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden";
  }
}, ol = new WeakMap(), ro = new WeakMap(), ic = new WeakMap(), r2), h3 = new $ae();
function Yae() {
  let r, e;
  const i = new Promise((s, a) => {
    r = s, e = a;
  });
  i.status = "pending", i.catch(() => {
  });
  function n(s) {
    Object.assign(i, s), delete i.resolve, delete i.reject;
  }
  return i.resolve = (s) => {
    n({
      status: "fulfilled",
      value: s
    }), r(s);
  }, i.reject = (s) => {
    n({
      status: "rejected",
      reason: s
    }), e(s);
  }, i;
}
var Kae = Fae;
function Zae() {
  let r = [], e = 0, i = (l) => {
    l();
  }, n = (l) => {
    l();
  }, s = Kae;
  const a = (l) => {
    e ? r.push(l) : s(() => {
      i(l);
    });
  }, o = () => {
    const l = r;
    r = [], l.length && s(() => {
      n(() => {
        l.forEach((u) => {
          i(u);
        });
      });
    });
  };
  return {
    batch: (l) => {
      let u;
      e++;
      try {
        u = l();
      } finally {
        e--, e || o();
      }
      return u;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (l) => (...u) => {
      a(() => {
        l(...u);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (l) => {
      i = l;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (l) => {
      n = l;
    },
    setScheduler: (l) => {
      s = l;
    }
  };
}
var wr = Zae(), rc, no, nc, n2, Qae = (n2 = class extends Zg {
  constructor() {
    super();
    zt(this, rc, !0);
    zt(this, no);
    zt(this, nc);
    mt(this, nc, (e) => {
      if (!Qg && window.addEventListener) {
        const i = () => e(!0), n = () => e(!1);
        return window.addEventListener("online", i, !1), window.addEventListener("offline", n, !1), () => {
          window.removeEventListener("online", i), window.removeEventListener("offline", n);
        };
      }
    });
  }
  onSubscribe() {
    me(this, no) || this.setEventListener(me(this, nc));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = me(this, no)) == null || e.call(this), mt(this, no, void 0));
  }
  setEventListener(e) {
    var i;
    mt(this, nc, e), (i = me(this, no)) == null || i.call(this), mt(this, no, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    me(this, rc) !== e && (mt(this, rc, e), this.listeners.forEach((n) => {
      n(e);
    }));
  }
  isOnline() {
    return me(this, rc);
  }
}, rc = new WeakMap(), no = new WeakMap(), nc = new WeakMap(), n2), ng = new Qae();
function Jae(r) {
  return Math.min(1e3 * 2 ** r, 3e4);
}
function d3(r) {
  return (r ?? "online") === "online" ? ng.isOnline() : !0;
}
var i_ = class extends Error {
  constructor(r) {
    super("CancelledError"), this.revert = r == null ? void 0 : r.revert, this.silent = r == null ? void 0 : r.silent;
  }
};
function p3(r) {
  let e = !1, i = 0, n;
  const s = Yae(), a = () => s.status !== "pending", o = (v) => {
    var y;
    if (!a()) {
      const g = new i_(v);
      p(g), (y = r.onCancel) == null || y.call(r, g);
    }
  }, l = () => {
    e = !0;
  }, u = () => {
    e = !1;
  }, c = () => h3.isFocused() && (r.networkMode === "always" || ng.isOnline()) && r.canRun(), h = () => d3(r.networkMode) && r.canRun(), d = (v) => {
    a() || (n == null || n(), s.resolve(v));
  }, p = (v) => {
    a() || (n == null || n(), s.reject(v));
  }, f = () => new Promise((v) => {
    var y;
    n = (g) => {
      (a() || c()) && v(g);
    }, (y = r.onPause) == null || y.call(r);
  }).then(() => {
    var v;
    n = void 0, a() || (v = r.onContinue) == null || v.call(r);
  }), m = () => {
    if (a())
      return;
    let v;
    const y = i === 0 ? r.initialPromise : void 0;
    try {
      v = y ?? r.fn();
    } catch (g) {
      v = Promise.reject(g);
    }
    Promise.resolve(v).then(d).catch((g) => {
      var S;
      if (a())
        return;
      const _ = r.retry ?? (Qg ? 0 : 3), x = r.retryDelay ?? Jae, b = typeof x == "function" ? x(i, g) : x, T = _ === !0 || typeof _ == "number" && i < _ || typeof _ == "function" && _(i, g);
      if (e || !T) {
        p(g);
        return;
      }
      i++, (S = r.onFail) == null || S.call(r, i, g), Hae(b).then(() => c() ? void 0 : f()).then(() => {
        e ? p(g) : m();
      });
    });
  };
  return {
    promise: s,
    status: () => s.status,
    cancel: o,
    continue: () => (n == null || n(), s),
    cancelRetry: l,
    continueRetry: u,
    canStart: h,
    start: () => (h() ? m() : f().then(m), s)
  };
}
var ll, s2, f3 = (s2 = class {
  constructor() {
    zt(this, ll);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), zae(this.gcTime) && mt(this, ll, Qx.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(r) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      r ?? (Qg ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    me(this, ll) && (Qx.clearTimeout(me(this, ll)), mt(this, ll, void 0));
  }
}, ll = new WeakMap(), s2), ul, sc, gn, cl, $i, Dd, hl, Bn, Ws, a2, eoe = (a2 = class extends f3 {
  constructor(e) {
    super();
    zt(this, Bn);
    zt(this, ul);
    zt(this, sc);
    zt(this, gn);
    zt(this, cl);
    zt(this, $i);
    zt(this, Dd);
    zt(this, hl);
    mt(this, hl, !1), mt(this, Dd, e.defaultOptions), this.setOptions(e.options), this.observers = [], mt(this, cl, e.client), mt(this, gn, me(this, cl).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, mt(this, ul, QA(this.options)), this.state = e.state ?? me(this, ul), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = me(this, $i)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    if (this.options = { ...me(this, Dd), ...e }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const i = QA(this.options);
      i.data !== void 0 && (this.setData(i.data, {
        updatedAt: i.dataUpdatedAt,
        manual: !0
      }), mt(this, ul, i));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && me(this, gn).remove(this);
  }
  setData(e, i) {
    const n = Wae(this.state.data, e, this.options);
    return or(this, Bn, Ws).call(this, {
      data: n,
      type: "success",
      dataUpdatedAt: i == null ? void 0 : i.updatedAt,
      manual: i == null ? void 0 : i.manual
    }), n;
  }
  setState(e, i) {
    or(this, Bn, Ws).call(this, { type: "setState", state: e, setStateOptions: i });
  }
  cancel(e) {
    var n, s;
    const i = (n = me(this, $i)) == null ? void 0 : n.promise;
    return (s = me(this, $i)) == null || s.cancel(e), i ? i.then(Fn).catch(Fn) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(me(this, ul));
  }
  isActive() {
    return this.observers.some(
      (e) => Vae(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === rg || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => Jx(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !jae(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var i;
    const e = this.observers.find((n) => n.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (i = me(this, $i)) == null || i.continue();
  }
  onOnline() {
    var i;
    const e = this.observers.find((n) => n.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (i = me(this, $i)) == null || i.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), me(this, gn).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((i) => i !== e), this.observers.length || (me(this, $i) && (me(this, hl) ? me(this, $i).cancel({ revert: !0 }) : me(this, $i).cancelRetry()), this.scheduleGc()), me(this, gn).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || or(this, Bn, Ws).call(this, { type: "invalidate" });
  }
  async fetch(e, i) {
    var u, c, h, d, p, f, m, v, y, g, _, x;
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    ((u = me(this, $i)) == null ? void 0 : u.status()) !== "rejected") {
      if (this.state.data !== void 0 && (i != null && i.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (me(this, $i))
        return me(this, $i).continueRetry(), me(this, $i).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const b = this.observers.find((T) => T.options.queryFn);
      b && this.setOptions(b.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const n = new AbortController(), s = (b) => {
      Object.defineProperty(b, "signal", {
        enumerable: !0,
        get: () => (mt(this, hl, !0), n.signal)
      });
    }, a = () => {
      const b = c3(this.options, i), S = (() => {
        const w = {
          client: me(this, cl),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(w), w;
      })();
      return mt(this, hl, !1), this.options.persister ? this.options.persister(
        b,
        S,
        this
      ) : b(S);
    }, l = (() => {
      const b = {
        fetchOptions: i,
        options: this.options,
        queryKey: this.queryKey,
        client: me(this, cl),
        state: this.state,
        fetchFn: a
      };
      return s(b), b;
    })();
    (c = this.options.behavior) == null || c.onFetch(l, this), mt(this, sc, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((h = l.fetchOptions) == null ? void 0 : h.meta)) && or(this, Bn, Ws).call(this, { type: "fetch", meta: (d = l.fetchOptions) == null ? void 0 : d.meta }), mt(this, $i, p3({
      initialPromise: i == null ? void 0 : i.initialPromise,
      fn: l.fetchFn,
      onCancel: (b) => {
        b instanceof i_ && b.revert && this.setState({
          ...me(this, sc),
          fetchStatus: "idle"
        }), n.abort();
      },
      onFail: (b, T) => {
        or(this, Bn, Ws).call(this, { type: "failed", failureCount: b, error: T });
      },
      onPause: () => {
        or(this, Bn, Ws).call(this, { type: "pause" });
      },
      onContinue: () => {
        or(this, Bn, Ws).call(this, { type: "continue" });
      },
      retry: l.options.retry,
      retryDelay: l.options.retryDelay,
      networkMode: l.options.networkMode,
      canRun: () => !0
    }));
    try {
      const b = await me(this, $i).start();
      if (b === void 0)
        throw process.env.NODE_ENV !== "production" && console.error(
          `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
        ), new Error(`${this.queryHash} data is undefined`);
      return this.setData(b), (f = (p = me(this, gn).config).onSuccess) == null || f.call(p, b, this), (v = (m = me(this, gn).config).onSettled) == null || v.call(
        m,
        b,
        this.state.error,
        this
      ), b;
    } catch (b) {
      if (b instanceof i_) {
        if (b.silent)
          return me(this, $i).promise;
        if (b.revert) {
          if (this.state.data === void 0)
            throw b;
          return this.state.data;
        }
      }
      throw or(this, Bn, Ws).call(this, {
        type: "error",
        error: b
      }), (g = (y = me(this, gn).config).onError) == null || g.call(
        y,
        b,
        this
      ), (x = (_ = me(this, gn).config).onSettled) == null || x.call(
        _,
        this.state.data,
        b,
        this
      ), b;
    } finally {
      this.scheduleGc();
    }
  }
}, ul = new WeakMap(), sc = new WeakMap(), gn = new WeakMap(), cl = new WeakMap(), $i = new WeakMap(), Dd = new WeakMap(), hl = new WeakMap(), Bn = new WeakSet(), Ws = function(e) {
  const i = (n) => {
    switch (e.type) {
      case "failed":
        return {
          ...n,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...n,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...n,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...n,
          ...toe(n.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        const s = {
          ...n,
          data: e.data,
          dataUpdateCount: n.dataUpdateCount + 1,
          dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        return mt(this, sc, e.manual ? s : void 0), s;
      case "error":
        const a = e.error;
        return {
          ...n,
          error: a,
          errorUpdateCount: n.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: n.fetchFailureCount + 1,
          fetchFailureReason: a,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...n,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...n,
          ...e.state
        };
    }
  };
  this.state = i(this.state), wr.batch(() => {
    this.observers.forEach((n) => {
      n.onQueryUpdate();
    }), me(this, gn).notify({ query: this, type: "updated", action: e });
  });
}, a2);
function toe(r, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: d3(e.networkMode) ? "fetching" : "paused",
    ...r === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function QA(r) {
  const e = typeof r.initialData == "function" ? r.initialData() : r.initialData, i = e !== void 0, n = i ? typeof r.initialDataUpdatedAt == "function" ? r.initialDataUpdatedAt() : r.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: i ? n ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: i ? "success" : "pending",
    fetchStatus: "idle"
  };
}
function JA(r) {
  return {
    onFetch: (e, i) => {
      var h, d, p, f, m;
      const n = e.options, s = (p = (d = (h = e.fetchOptions) == null ? void 0 : h.meta) == null ? void 0 : d.fetchMore) == null ? void 0 : p.direction, a = ((f = e.state.data) == null ? void 0 : f.pages) || [], o = ((m = e.state.data) == null ? void 0 : m.pageParams) || [];
      let l = { pages: [], pageParams: [] }, u = 0;
      const c = async () => {
        let v = !1;
        const y = (x) => {
          Object.defineProperty(x, "signal", {
            enumerable: !0,
            get: () => (e.signal.aborted ? v = !0 : e.signal.addEventListener("abort", () => {
              v = !0;
            }), e.signal)
          });
        }, g = c3(e.options, e.fetchOptions), _ = async (x, b, T) => {
          if (v)
            return Promise.reject();
          if (b == null && x.pages.length)
            return Promise.resolve(x);
          const w = (() => {
            const N = {
              client: e.client,
              queryKey: e.queryKey,
              pageParam: b,
              direction: T ? "backward" : "forward",
              meta: e.options.meta
            };
            return y(N), N;
          })(), A = await g(w), { maxPages: E } = e.options, M = T ? Xae : qae;
          return {
            pages: M(x.pages, A, E),
            pageParams: M(x.pageParams, b, E)
          };
        };
        if (s && a.length) {
          const x = s === "backward", b = x ? ioe : e2, T = {
            pages: a,
            pageParams: o
          }, S = b(n, T);
          l = await _(T, S, x);
        } else {
          const x = r ?? a.length;
          do {
            const b = u === 0 ? o[0] ?? n.initialPageParam : e2(n, l);
            if (u > 0 && b == null)
              break;
            l = await _(l, b), u++;
          } while (u < x);
        }
        return l;
      };
      e.options.persister ? e.fetchFn = () => {
        var v, y;
        return (y = (v = e.options).persister) == null ? void 0 : y.call(
          v,
          c,
          {
            client: e.client,
            queryKey: e.queryKey,
            meta: e.options.meta,
            signal: e.signal
          },
          i
        );
      } : e.fetchFn = c;
    }
  };
}
function e2(r, { pages: e, pageParams: i }) {
  const n = e.length - 1;
  return e.length > 0 ? r.getNextPageParam(
    e[n],
    e,
    i[n],
    i
  ) : void 0;
}
function ioe(r, { pages: e, pageParams: i }) {
  var n;
  return e.length > 0 ? (n = r.getPreviousPageParam) == null ? void 0 : n.call(r, e[0], e, i[0], i) : void 0;
}
var ls, Tr, dl, us, Ya, o2, roe = (o2 = class extends f3 {
  constructor(e) {
    super();
    zt(this, us);
    zt(this, ls);
    zt(this, Tr);
    zt(this, dl);
    this.mutationId = e.mutationId, mt(this, Tr, e.mutationCache), mt(this, ls, []), this.state = e.state || noe(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    me(this, ls).includes(e) || (me(this, ls).push(e), this.clearGcTimeout(), me(this, Tr).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    mt(this, ls, me(this, ls).filter((i) => i !== e)), this.scheduleGc(), me(this, Tr).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    me(this, ls).length || (this.state.status === "pending" ? this.scheduleGc() : me(this, Tr).remove(this));
  }
  continue() {
    var e;
    return ((e = me(this, dl)) == null ? void 0 : e.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    var a, o, l, u, c, h, d, p, f, m, v, y, g, _, x, b, T, S, w, A;
    const i = () => {
      or(this, us, Ya).call(this, { type: "continue" });
    };
    mt(this, dl, p3({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (E, M) => {
        or(this, us, Ya).call(this, { type: "failed", failureCount: E, error: M });
      },
      onPause: () => {
        or(this, us, Ya).call(this, { type: "pause" });
      },
      onContinue: i,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => me(this, Tr).canRun(this)
    }));
    const n = this.state.status === "pending", s = !me(this, dl).canStart();
    try {
      if (n)
        i();
      else {
        or(this, us, Ya).call(this, { type: "pending", variables: e, isPaused: s }), await ((o = (a = me(this, Tr).config).onMutate) == null ? void 0 : o.call(
          a,
          e,
          this
        ));
        const M = await ((u = (l = this.options).onMutate) == null ? void 0 : u.call(l, e));
        M !== this.state.context && or(this, us, Ya).call(this, {
          type: "pending",
          context: M,
          variables: e,
          isPaused: s
        });
      }
      const E = await me(this, dl).start();
      return await ((h = (c = me(this, Tr).config).onSuccess) == null ? void 0 : h.call(
        c,
        E,
        e,
        this.state.context,
        this
      )), await ((p = (d = this.options).onSuccess) == null ? void 0 : p.call(d, E, e, this.state.context)), await ((m = (f = me(this, Tr).config).onSettled) == null ? void 0 : m.call(
        f,
        E,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((y = (v = this.options).onSettled) == null ? void 0 : y.call(v, E, null, e, this.state.context)), or(this, us, Ya).call(this, { type: "success", data: E }), E;
    } catch (E) {
      try {
        throw await ((_ = (g = me(this, Tr).config).onError) == null ? void 0 : _.call(
          g,
          E,
          e,
          this.state.context,
          this
        )), await ((b = (x = this.options).onError) == null ? void 0 : b.call(
          x,
          E,
          e,
          this.state.context
        )), await ((S = (T = me(this, Tr).config).onSettled) == null ? void 0 : S.call(
          T,
          void 0,
          E,
          this.state.variables,
          this.state.context,
          this
        )), await ((A = (w = this.options).onSettled) == null ? void 0 : A.call(
          w,
          void 0,
          E,
          e,
          this.state.context
        )), E;
      } finally {
        or(this, us, Ya).call(this, { type: "error", error: E });
      }
    } finally {
      me(this, Tr).runNext(this);
    }
  }
}, ls = new WeakMap(), Tr = new WeakMap(), dl = new WeakMap(), us = new WeakSet(), Ya = function(e) {
  const i = (n) => {
    switch (e.type) {
      case "failed":
        return {
          ...n,
          failureCount: e.failureCount,
          failureReason: e.error
        };
      case "pause":
        return {
          ...n,
          isPaused: !0
        };
      case "continue":
        return {
          ...n,
          isPaused: !1
        };
      case "pending":
        return {
          ...n,
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...n,
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...n,
          data: void 0,
          error: e.error,
          failureCount: n.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = i(this.state), wr.batch(() => {
    me(this, ls).forEach((n) => {
      n.onMutationUpdate(e);
    }), me(this, Tr).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, o2);
function noe() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var Zs, zn, Ld, l2, soe = (l2 = class extends Zg {
  constructor(e = {}) {
    super();
    zt(this, Zs);
    zt(this, zn);
    zt(this, Ld);
    this.config = e, mt(this, Zs, /* @__PURE__ */ new Set()), mt(this, zn, /* @__PURE__ */ new Map()), mt(this, Ld, 0);
  }
  build(e, i, n) {
    const s = new roe({
      mutationCache: this,
      mutationId: ++sp(this, Ld)._,
      options: e.defaultMutationOptions(i),
      state: n
    });
    return this.add(s), s;
  }
  add(e) {
    me(this, Zs).add(e);
    const i = Uf(e);
    if (typeof i == "string") {
      const n = me(this, zn).get(i);
      n ? n.push(e) : me(this, zn).set(i, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (me(this, Zs).delete(e)) {
      const i = Uf(e);
      if (typeof i == "string") {
        const n = me(this, zn).get(i);
        if (n)
          if (n.length > 1) {
            const s = n.indexOf(e);
            s !== -1 && n.splice(s, 1);
          } else n[0] === e && me(this, zn).delete(i);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const i = Uf(e);
    if (typeof i == "string") {
      const n = me(this, zn).get(i), s = n == null ? void 0 : n.find(
        (a) => a.state.status === "pending"
      );
      return !s || s === e;
    } else
      return !0;
  }
  runNext(e) {
    var n;
    const i = Uf(e);
    if (typeof i == "string") {
      const s = (n = me(this, zn).get(i)) == null ? void 0 : n.find((a) => a !== e && a.state.isPaused);
      return (s == null ? void 0 : s.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    wr.batch(() => {
      me(this, Zs).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), me(this, Zs).clear(), me(this, zn).clear();
    });
  }
  getAll() {
    return Array.from(me(this, Zs));
  }
  find(e) {
    const i = { exact: !0, ...e };
    return this.getAll().find(
      (n) => YA(i, n)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((i) => YA(e, i));
  }
  notify(e) {
    wr.batch(() => {
      this.listeners.forEach((i) => {
        i(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((i) => i.state.isPaused);
    return wr.batch(
      () => Promise.all(
        e.map((i) => i.continue().catch(Fn))
      )
    );
  }
}, Zs = new WeakMap(), zn = new WeakMap(), Ld = new WeakMap(), l2);
function Uf(r) {
  var e;
  return (e = r.options.scope) == null ? void 0 : e.id;
}
var cs, u2, aoe = (u2 = class extends Zg {
  constructor(e = {}) {
    super();
    zt(this, cs);
    this.config = e, mt(this, cs, /* @__PURE__ */ new Map());
  }
  build(e, i, n) {
    const s = i.queryKey, a = i.queryHash ?? lS(s, i);
    let o = this.get(a);
    return o || (o = new eoe({
      client: e,
      queryKey: s,
      queryHash: a,
      options: e.defaultQueryOptions(i),
      state: n,
      defaultOptions: e.getQueryDefaults(s)
    }), this.add(o)), o;
  }
  add(e) {
    me(this, cs).has(e.queryHash) || (me(this, cs).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const i = me(this, cs).get(e.queryHash);
    i && (e.destroy(), i === e && me(this, cs).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    wr.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return me(this, cs).get(e);
  }
  getAll() {
    return [...me(this, cs).values()];
  }
  find(e) {
    const i = { exact: !0, ...e };
    return this.getAll().find(
      (n) => $A(i, n)
    );
  }
  findAll(e = {}) {
    const i = this.getAll();
    return Object.keys(e).length > 0 ? i.filter((n) => $A(e, n)) : i;
  }
  notify(e) {
    wr.batch(() => {
      this.listeners.forEach((i) => {
        i(e);
      });
    });
  }
  onFocus() {
    wr.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    wr.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, cs = new WeakMap(), u2), Si, so, ao, ac, oc, oo, lc, uc, c2, ooe = (c2 = class {
  constructor(r = {}) {
    zt(this, Si);
    zt(this, so);
    zt(this, ao);
    zt(this, ac);
    zt(this, oc);
    zt(this, oo);
    zt(this, lc);
    zt(this, uc);
    mt(this, Si, r.queryCache || new aoe()), mt(this, so, r.mutationCache || new soe()), mt(this, ao, r.defaultOptions || {}), mt(this, ac, /* @__PURE__ */ new Map()), mt(this, oc, /* @__PURE__ */ new Map()), mt(this, oo, 0);
  }
  mount() {
    sp(this, oo)._++, me(this, oo) === 1 && (mt(this, lc, h3.subscribe(async (r) => {
      r && (await this.resumePausedMutations(), me(this, Si).onFocus());
    })), mt(this, uc, ng.subscribe(async (r) => {
      r && (await this.resumePausedMutations(), me(this, Si).onOnline());
    })));
  }
  unmount() {
    var r, e;
    sp(this, oo)._--, me(this, oo) === 0 && ((r = me(this, lc)) == null || r.call(this), mt(this, lc, void 0), (e = me(this, uc)) == null || e.call(this), mt(this, uc, void 0));
  }
  isFetching(r) {
    return me(this, Si).findAll({ ...r, fetchStatus: "fetching" }).length;
  }
  isMutating(r) {
    return me(this, so).findAll({ ...r, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(r) {
    var i;
    const e = this.defaultQueryOptions({ queryKey: r });
    return (i = me(this, Si).get(e.queryHash)) == null ? void 0 : i.state.data;
  }
  ensureQueryData(r) {
    const e = this.defaultQueryOptions(r), i = me(this, Si).build(this, e), n = i.state.data;
    return n === void 0 ? this.fetchQuery(r) : (r.revalidateIfStale && i.isStaleByTime(Jx(e.staleTime, i)) && this.prefetchQuery(e), Promise.resolve(n));
  }
  getQueriesData(r) {
    return me(this, Si).findAll(r).map(({ queryKey: e, state: i }) => {
      const n = i.data;
      return [e, n];
    });
  }
  setQueryData(r, e, i) {
    const n = this.defaultQueryOptions({ queryKey: r }), s = me(this, Si).get(
      n.queryHash
    ), a = s == null ? void 0 : s.state.data, o = Bae(e, a);
    if (o !== void 0)
      return me(this, Si).build(this, n).setData(o, { ...i, manual: !0 });
  }
  setQueriesData(r, e, i) {
    return wr.batch(
      () => me(this, Si).findAll(r).map(({ queryKey: n }) => [
        n,
        this.setQueryData(n, e, i)
      ])
    );
  }
  getQueryState(r) {
    var i;
    const e = this.defaultQueryOptions({ queryKey: r });
    return (i = me(this, Si).get(
      e.queryHash
    )) == null ? void 0 : i.state;
  }
  removeQueries(r) {
    const e = me(this, Si);
    wr.batch(() => {
      e.findAll(r).forEach((i) => {
        e.remove(i);
      });
    });
  }
  resetQueries(r, e) {
    const i = me(this, Si);
    return wr.batch(() => (i.findAll(r).forEach((n) => {
      n.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...r
      },
      e
    )));
  }
  cancelQueries(r, e = {}) {
    const i = { revert: !0, ...e }, n = wr.batch(
      () => me(this, Si).findAll(r).map((s) => s.cancel(i))
    );
    return Promise.all(n).then(Fn).catch(Fn);
  }
  invalidateQueries(r, e = {}) {
    return wr.batch(() => (me(this, Si).findAll(r).forEach((i) => {
      i.invalidate();
    }), (r == null ? void 0 : r.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...r,
        type: (r == null ? void 0 : r.refetchType) ?? (r == null ? void 0 : r.type) ?? "active"
      },
      e
    )));
  }
  refetchQueries(r, e = {}) {
    const i = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, n = wr.batch(
      () => me(this, Si).findAll(r).filter((s) => !s.isDisabled() && !s.isStatic()).map((s) => {
        let a = s.fetch(void 0, i);
        return i.throwOnError || (a = a.catch(Fn)), s.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(n).then(Fn);
  }
  fetchQuery(r) {
    const e = this.defaultQueryOptions(r);
    e.retry === void 0 && (e.retry = !1);
    const i = me(this, Si).build(this, e);
    return i.isStaleByTime(
      Jx(e.staleTime, i)
    ) ? i.fetch(e) : Promise.resolve(i.state.data);
  }
  prefetchQuery(r) {
    return this.fetchQuery(r).then(Fn).catch(Fn);
  }
  fetchInfiniteQuery(r) {
    return r.behavior = JA(r.pages), this.fetchQuery(r);
  }
  prefetchInfiniteQuery(r) {
    return this.fetchInfiniteQuery(r).then(Fn).catch(Fn);
  }
  ensureInfiniteQueryData(r) {
    return r.behavior = JA(r.pages), this.ensureQueryData(r);
  }
  resumePausedMutations() {
    return ng.isOnline() ? me(this, so).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return me(this, Si);
  }
  getMutationCache() {
    return me(this, so);
  }
  getDefaultOptions() {
    return me(this, ao);
  }
  setDefaultOptions(r) {
    mt(this, ao, r);
  }
  setQueryDefaults(r, e) {
    me(this, ac).set(Id(r), {
      queryKey: r,
      defaultOptions: e
    });
  }
  getQueryDefaults(r) {
    const e = [...me(this, ac).values()], i = {};
    return e.forEach((n) => {
      Od(r, n.queryKey) && Object.assign(i, n.defaultOptions);
    }), i;
  }
  setMutationDefaults(r, e) {
    me(this, oc).set(Id(r), {
      mutationKey: r,
      defaultOptions: e
    });
  }
  getMutationDefaults(r) {
    const e = [...me(this, oc).values()], i = {};
    return e.forEach((n) => {
      Od(r, n.mutationKey) && Object.assign(i, n.defaultOptions);
    }), i;
  }
  defaultQueryOptions(r) {
    if (r._defaulted)
      return r;
    const e = {
      ...me(this, ao).queries,
      ...this.getQueryDefaults(r.queryKey),
      ...r,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = lS(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === rg && (e.enabled = !1), e;
  }
  defaultMutationOptions(r) {
    return r != null && r._defaulted ? r : {
      ...me(this, ao).mutations,
      ...(r == null ? void 0 : r.mutationKey) && this.getMutationDefaults(r.mutationKey),
      ...r,
      _defaulted: !0
    };
  }
  clear() {
    me(this, Si).clear(), me(this, so).clear();
  }
}, Si = new WeakMap(), so = new WeakMap(), ao = new WeakMap(), ac = new WeakMap(), oc = new WeakMap(), oo = new WeakMap(), lc = new WeakMap(), uc = new WeakMap(), c2), loe = h2.createContext(
  void 0
), uoe = ({
  client: r,
  children: e
}) => (h2.useEffect(() => (r.mount(), () => {
  r.unmount();
}), [r]), /* @__PURE__ */ V.jsx(loe.Provider, { value: r, children: e })), coe = "https://prod.base-sepolia.intuition-api.com/v1/graphql", hoe = "https://prod.base-mainnet-v-1-0.intuition.sh/v1/graphql", doe = hoe, t2 = {
  apiUrl: doe
};
function poe(r) {
  t2 = { ...t2, ...r };
}
var Vi = /* @__PURE__ */ ((r) => (r.MAINNET = "mainnet", r.TESTNET = "testnet", r))(Vi || {});
const Ms = {
  mainnet: "https://testnet.intuition.sh/v1/graphql",
  testnet: coe
  // TODO: change to mainnet
}, foe = async (r, e = Vi.MAINNET, i = 1e3) => {
  var n;
  try {
    const s = Ms[e];
    return ((n = (await (await fetch(s, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query Triples_for_Agent($objectId: String!, $batchSize: Int!) {
            triples(limit: $batchSize, where: { object_id: { _eq: $objectId } }) {
              term_id
              subject {
                term_id
                label
                type
                image
              }
              predicate {
                term_id
                label
                type
                image
              }
              object {
                term_id
                label
                type
                image
              }
              term {
                total_market_cap
                total_assets
                positions_aggregate {
                  aggregate {
                    count
                  }
                }
              }
              counter_term {
                total_market_cap
                total_assets
                positions_aggregate {
                  aggregate {
                    count
                  }
                }
              }
            }
          }
        `,
        variables: { objectId: r, batchSize: i }
      })
    })).json()).data) == null ? void 0 : n.triples) || [];
  } catch (s) {
    return console.error("Error fetching triples for agent:", s), [];
  }
}, moe = async (r, e = Vi.MAINNET) => {
  var i;
  try {
    const n = Ms[e];
    return ((i = (await (await fetch(n, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetAccountActivity($accountId: String!) {
            positions(where: { account_id: { _eq: $accountId } }) {
              id
              shares
              account {
                id
                label
                image
                atom_id
                type
              }
              term {
                id
                total_market_cap
                total_assets
              }
            }
          }
        `,
        variables: { accountId: r }
      })
    })).json()).data) == null ? void 0 : i.positions) || [];
  } catch (n) {
    return console.error("Error fetching positions by account:", n), [];
  }
}, goe = async (r, e = Vi.MAINNET) => {
  var i;
  try {
    const n = Ms[e];
    return ((i = (await (await fetch(n, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
        query ClaimsByAccount($accountId: String!) {
          triples(where: { creator_id: { _eq: $accountId } }) {
            term_id
            subject {
              term_id
              label
              type
              image
            }
            predicate {
              term_id
              label
              type
            }
            object {
              term_id
              label
              type
              image
            }
          }
        }
      `,
        variables: { accountId: r }
      })
    })).json()).data) == null ? void 0 : i.triples) || [];
  } catch (n) {
    return console.error("Error fetching claims by account:", n), [];
  }
}, yoe = async (r, e, i = Vi.MAINNET) => {
  var n, s, a, o;
  try {
    const l = Ms[i], u = "0x4b5ec64b82fae56c71a469fc902df2096b0dc7c930dd61032e817d583575fe47", h = await (await fetch(l, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetFollowsAndFollowers($predicateId: String!, $userAtomId: String!) {
            follows: triples(
              where: {
                _and: [
                  { predicate_id: { _eq: $predicateId } },
                  { subject_id: { _eq: $userAtomId } }
                ]
              }
            ) {
              term_id
              object {
                term_id
                label
                image
                creator_id
              }
            }
            followers: triples(
              where: {
                _and: [
                  { predicate_id: { _eq: $predicateId } },
                  { object_id: { _eq: $userAtomId } }
                ]
              }
            ) {
              term_id
              creator_id
              subject {
                term_id
                label
                image
              }
            }
          }
        `,
        variables: { predicateId: r, userAtomId: u }
      })
    })).json();
    return {
      follows: ((s = (n = h.data) == null ? void 0 : n.follows) == null ? void 0 : s.map((d) => ({
        ...d,
        object: { ...d.object, id: d.object.term_id }
      }))) || [],
      followers: ((o = (a = h.data) == null ? void 0 : a.followers) == null ? void 0 : o.map((d) => ({
        ...d,
        subject: { ...d.subject, id: d.subject.term_id }
      }))) || []
    };
  } catch (l) {
    return console.error("Error fetching follows and followers:", l), { follows: [], followers: [] };
  }
}, voe = async (r, e = ti.IS_PLAYER_GAMES.predicateId.toString(), i = ti.IS_PLAYER_GAMES.objectId.toString(), n = Vi.MAINNET) => {
  var l;
  const s = Ms[n], a = {
    where: {
      subject: {
        creator_id: { _eq: r }
      },
      predicate_id: {
        _eq: `0x${ti.IS_PLAYER_GAMES.predicateId.toString(16).padStart(64, "0")}`
      },
      object_id: {
        _eq: `0x${ti.IS_PLAYER_GAMES.objectId.toString(16).padStart(64, "0")}`
      }
    }
  }, o = `
    query GetTriples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject_id
        predicate_id
        object_id
        subject {
          term_id
          label
          type
          creator_id
        }
        predicate {
          term_id
          label
          type
        }
        object {
          term_id
          label
          type
        }
        block_number
        created_at
        transaction_hash
      }
    }
  `;
  try {
    const c = await (await fetch(s, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify({
        query: o,
        //  Utiliser la requte directe
        variables: a
      })
    })).json();
    if (c.errors)
      throw console.error("la Erreurs GraphQL:", c.errors), new Error(((l = c.errors[0]) == null ? void 0 : l.message) || "Erreur GraphQL inconnue");
    return c.data;
  } catch (u) {
    throw console.error(
      `[fetchTriplesByCreator] Erreur lors de la requte directe vers ${s}:`,
      u
    ), u;
  }
}, uS = (r, e = ti.IS_PLAYER_GAMES.predicateId.toString(), i = ti.IS_PLAYER_GAMES.objectId.toString(), n = Vi.MAINNET) => {
  const [s, a] = Pe(null), [o, l] = Pe(!0), [u, c] = Pe(null);
  si(() => {
    (async () => {
      if (!r) {
        l(!1);
        return;
      }
      try {
        const p = await voe(
          r,
          e,
          i,
          n
        );
        a(p);
      } catch (p) {
        console.error(
          `[${n}] Erreur lors de la rcupration des triples:`,
          p
        ), c(p instanceof Error ? p : new Error(String(p)));
      } finally {
        l(!1);
      }
    })();
  }, [r, e, i, n]);
  const h = (s == null ? void 0 : s.triples) || [];
  return {
    loading: o,
    error: u,
    triples: h,
    network: n,
    rawData: s
  };
}, boe = (r, e = Vi.MAINNET) => {
  const [i, n] = Pe([]), [s, a] = Pe([]), [o, l] = Pe([]), [u, c] = Pe({
    follows: [],
    followers: []
  }), [h, d] = Pe(!1), [p, f] = Pe(null), { triples: m, loading: v, error: y } = uS(
    r || "",
    void 0,
    // Utiliser les valeurs par dfaut
    void 0,
    e
  ), g = m.length > 0 ? m[0].subject : null;
  return si(() => {
    if (!r) {
      n([]), a([]), l([]);
      return;
    }
    (async () => {
      d(!0), f(null);
      try {
        const [x, b, T, S] = await Promise.all([
          foe(r, e),
          moe(r, e),
          goe(r, e),
          // Ajouter les claims
          yoe(nU.FOLLOWS, r, e)
          // Ajouter les connections
        ]);
        n(x), a(b), l(T), c(S);
      } catch (x) {
        console.error("Error loading sidebar data:", x), f(x instanceof Error ? x.message : "Unknown error");
      } finally {
        d(!1);
      }
    })();
  }, [r, e]), {
    atomDetails: g,
    triples: i,
    positions: s,
    activities: o,
    connections: u,
    loading: h || v,
    error: p || (y ? y.message : null)
  };
}, xoe = ({ walletAddress: r }) => {
  const [e, i] = Pe(null), [n, s] = Pe("base"), [a, o] = Pe(!1), [l, u] = Pe(!1), [c, h] = Pe(""), { atomDetails: d, positions: p, activities: f, connections: m, loading: v, error: y } = boe(r, Vi.MAINNET), g = {
    background: "#ffd32a",
    color: "#18181b",
    border: "none",
    borderRadius: 12,
    width: 44,
    height: 44,
    fontSize: 22,
    fontWeight: "bold",
    boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
    cursor: "pointer",
    marginBottom: 0,
    marginTop: 0,
    textTransform: "uppercase",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: 0,
    transition: "background 0.2s, color 0.2s, transform 0.1s"
  }, _ = {
    background: "#ffe066",
    color: "#18181b",
    transform: "translateY(-2px) scale(1.03)"
  }, x = (b) => c === b ? { ...g, ..._ } : g;
  return /* @__PURE__ */ V.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        height: "100%",
        width: "100%",
        position: "relative",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ V.jsx(
          "div",
          {
            style: {
              position: "relative",
              flex: 1,
              width: "100%",
              height: "100%",
              overflow: "hidden"
            },
            children: /* @__PURE__ */ V.jsx(
              Sae,
              {
                endpoint: n,
                onNodeSelect: i,
                onLoadingChange: o,
                walletAddress: r
              }
            )
          }
        ),
        a && /* @__PURE__ */ V.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              zIndex: 2
            },
            children: /* @__PURE__ */ V.jsx(MC, {})
          }
        ),
        /* @__PURE__ */ V.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "18px",
              left: "18px",
              zIndex: 50,
              display: "flex",
              flexDirection: "row",
              gap: "12px",
              alignItems: "center"
            },
            children: /* @__PURE__ */ V.jsx(
              "button",
              {
                style: x("profile"),
                onClick: () => u(!0),
                "aria-label": "Profile",
                onMouseEnter: () => h("profile"),
                onMouseLeave: () => h(""),
                children: /* @__PURE__ */ V.jsx(Lae, {})
              }
            )
          }
        ),
        l && /* @__PURE__ */ V.jsx(
          "div",
          {
            style: {
              position: "absolute",
              inset: 0,
              backgroundColor: "rgba(0, 0, 0, 0.35)",
              zIndex: 1200,
              pointerEvents: "auto"
            },
            onClick: () => u(!1)
          }
        ),
        /* @__PURE__ */ V.jsxs(
          wae,
          {
            open: l,
            onClose: () => u(!1),
            children: [
              v && /* @__PURE__ */ V.jsx("p", { children: "Loading data..." }),
              y && /* @__PURE__ */ V.jsxs("p", { style: { color: "red" }, children: [
                "Error : ",
                y
              ] }),
              !v && !y && /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
                d && /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
                  /* @__PURE__ */ V.jsx("p", { children: /* @__PURE__ */ V.jsx("strong", { children: d.label || "Not defined" }) }),
                  /* @__PURE__ */ V.jsx("div", { style: { marginBottom: "10px" }, children: /* @__PURE__ */ V.jsxs("p", { children: [
                    "Following: ",
                    m.followers.length,
                    " - Followers: ",
                    m.follows.length
                  ] }) }),
                  /* @__PURE__ */ V.jsxs("p", { children: [
                    /* @__PURE__ */ V.jsx("strong", { children: "ID :" }),
                    " ",
                    d.description || "query a travailler"
                  ] }),
                  /* @__PURE__ */ V.jsxs("p", { children: [
                    /* @__PURE__ */ V.jsx("strong", { children: "Wallet :" }),
                    " ",
                    r || "Not connected"
                  ] })
                ] }),
                /* @__PURE__ */ V.jsxs("div", { style: { marginTop: "20px" }, children: [
                  /* @__PURE__ */ V.jsxs("h3", { children: [
                    "My Claims (",
                    f.length,
                    ")"
                  ] }),
                  f.length > 0 ? /* @__PURE__ */ V.jsxs("ul", { style: { fontSize: "14px", maxHeight: "200px", overflowY: "auto" }, children: [
                    f.slice(0, 5).map((b, T) => /* @__PURE__ */ V.jsxs("li", { style: { marginBottom: "8px" }, children: [
                      b.predicate.label,
                      "  ",
                      b.object.label
                    ] }, b.term_id)),
                    f.length > 5 && /* @__PURE__ */ V.jsxs("li", { children: [
                      "... and ",
                      f.length - 5,
                      " others"
                    ] })
                  ] }) : /* @__PURE__ */ V.jsx("p", { children: "No claim found" })
                ] }),
                /* @__PURE__ */ V.jsxs("div", { style: { marginTop: "20px" }, children: [
                  /* @__PURE__ */ V.jsxs("h3", { children: [
                    "My Activity (",
                    p.length,
                    ")"
                  ] }),
                  p.length > 0 ? /* @__PURE__ */ V.jsxs("div", { style: { fontSize: "14px", maxHeight: "200px", overflowY: "auto" }, children: [
                    p.slice(0, 5).map((b, T) => /* @__PURE__ */ V.jsx(Mae, { position: b }, b.id || T)),
                    p.length > 5 && /* @__PURE__ */ V.jsxs("p", { style: { color: "#fff", fontSize: "12px", textAlign: "center", marginTop: "10px" }, children: [
                      "... and ",
                      p.length - 5,
                      " other activities"
                    ] })
                  ] }) : /* @__PURE__ */ V.jsx("p", { children: "No activity found" })
                ] })
              ] })
            ]
          }
        )
      ]
    }
  );
}, m3 = ({
  isOpen: r,
  onConnectWallet: e
}) => r ? /* @__PURE__ */ V.jsx(
  "div",
  {
    style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "rgba(0, 0, 0, 0.7)",
      backdropFilter: "blur(5px)",
      zIndex: 1e3,
      width: "100%",
      height: "100%"
    },
    children: /* @__PURE__ */ V.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#1a1a2e",
          padding: "30px",
          borderRadius: "10px",
          textAlign: "center",
          maxWidth: "500px",
          boxShadow: "0 0 15px rgba(108, 92, 231, 0.5)"
        },
        children: [
          /* @__PURE__ */ V.jsx("h2", { style: { color: "#6c5ce7", marginBottom: "20px" }, children: "Wallet Required" }),
          /* @__PURE__ */ V.jsx("p", { style: { fontSize: "18px", marginBottom: "25px", color: "#fff" }, children: "Please connect your wallet to access this feature" }),
          /* @__PURE__ */ V.jsx(
            "button",
            {
              onClick: e,
              style: {
                padding: "12px 24px",
                backgroundColor: "#6c5ce7",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
                fontSize: "16px"
              },
              children: "Connect Wallet"
            }
          )
        ]
      }
    )
  }
) : null, _oe = ({
  isOpen: r,
  onCreatePlayer: e,
  onClose: i
}) => r ? /* @__PURE__ */ V.jsx(
  "div",
  {
    style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "rgba(0, 0, 0, 1)",
      backdropFilter: "blur(1px)",
      zIndex: 1e3,
      width: "100%",
      height: "100%"
    },
    children: /* @__PURE__ */ V.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#1a1a2e",
          padding: "30px",
          borderRadius: "10px",
          textAlign: "center",
          maxWidth: "500px",
          boxShadow: "0 0 15px rgba(0, 128, 255, 0.7)",
          position: "relative"
        },
        children: [
          i && /* @__PURE__ */ V.jsx(
            "button",
            {
              onClick: i,
              style: {
                position: "absolute",
                top: "10px",
                right: "10px",
                backgroundColor: "transparent",
                border: "none",
                fontSize: "20px",
                color: "#666",
                cursor: "pointer"
              },
              children: ""
            }
          ),
          /* @__PURE__ */ V.jsx("h2", { style: { color: "#FFD32A", marginBottom: "20px" }, children: "Player Required" }),
          /* @__PURE__ */ V.jsx("p", { style: { fontSize: "18px", marginBottom: "25px", color: "#fff" }, children: "You need to create a player before you can vote on claims" }),
          /* @__PURE__ */ V.jsx(
            "button",
            {
              onClick: e,
              style: {
                padding: "12px 24px",
                backgroundColor: "#1976d2",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
                fontSize: "16px"
              },
              children: "Create Player"
            }
          )
        ]
      }
    )
  }
) : null, g3 = new ooe({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: !1
    }
  }
});
S3({
  queryClient: g3
});
const Toe = ({
  children: r
}) => /* @__PURE__ */ V.jsx(uoe, { client: g3, children: r }), Soe = "https://testnet.intuition.sh/v1/graphql";
function woe() {
  poe({ apiUrl: Soe });
}
const ale = ({
  walletConnected: r = !1,
  walletAddress: e = "",
  wagmiConfig: i,
  walletHooks: n,
  onClose: s,
  onCreatePlayer: a,
  onConnectWallet: o
}) => {
  si(() => {
    woe();
  }, []);
  const [l, u] = Pe(Vi.MAINNET), [c, h] = Pe(!1), [d, p] = Pe(!1), f = e || "";
  si(() => {
    p(!!(e && e !== ""));
  }, [e]);
  const {
    loading: m,
    error: v,
    triples: y
  } = uS(f, ti.IS_PLAYER_GAMES.predicateId.toString(), ti.IS_PLAYER_GAMES.objectId.toString(), l), g = y.length > 0, _ = m, x = v, b = Dr(() => {
    a && a(), h(!0);
  }, [a]), T = Dr(() => {
    h(!1), s && s();
  }, [s]), S = Dr(() => {
    o && o();
  }, [o]);
  return x ? /* @__PURE__ */ V.jsxs("div", { style: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100%",
    flexDirection: "column",
    gap: "20px"
  }, children: [
    /* @__PURE__ */ V.jsx("h2", { style: { color: "red", textAlign: "center" }, children: "Erreur lors du chargement des donnes" }),
    /* @__PURE__ */ V.jsx("p", { style: { textAlign: "center", color: "#666" }, children: x.message || "Une erreur inattendue s'est produite" }),
    /* @__PURE__ */ V.jsx(
      "button",
      {
        onClick: () => window.location.reload(),
        style: {
          padding: "10px 20px",
          backgroundColor: "#FFD32A",
          color: "#000",
          border: "none",
          borderRadius: "5px",
          cursor: "pointer"
        },
        children: "Recharger la page"
      }
    )
  ] }) : _ ? /* @__PURE__ */ V.jsxs("div", { style: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100%",
    flexDirection: "column",
    gap: "20px"
  }, children: [
    /* @__PURE__ */ V.jsx("div", { style: {
      width: "50px",
      height: "50px",
      border: "4px solid #FFD32A",
      borderTop: "4px solid transparent",
      borderRadius: "50%",
      animation: "spin 1s linear infinite"
    } }),
    /* @__PURE__ */ V.jsx("p", { style: { textAlign: "center", color: "#666" }, children: "Chargement des donnes du joueur..." })
  ] }) : /* @__PURE__ */ V.jsx(Toe, { children: /* @__PURE__ */ V.jsxs("div", { style: { position: "relative", width: "100%", height: "100%" }, children: [
    /* @__PURE__ */ V.jsx(
      m3,
      {
        isOpen: !d,
        onConnectWallet: S
      }
    ),
    (!d || d && !g) && /* @__PURE__ */ V.jsx("div", { style: {
      filter: d ? "none" : "blur(3px)",
      opacity: d ? 1 : 0.7,
      position: "relative"
    }, children: /* @__PURE__ */ V.jsx(
      M3,
      {
        walletConnected: d,
        walletAddress: e,
        wagmiConfig: i,
        walletHooks: n,
        onCreatePlayer: b
      }
    ) }),
    d && g && /* @__PURE__ */ V.jsx(xoe, { walletAddress: e }),
    /* @__PURE__ */ V.jsx(
      oC,
      {
        isOpen: c,
        onClose: T,
        walletConnected: r,
        walletAddress: e,
        wagmiConfig: i,
        walletHooks: n
      }
    )
  ] }) });
};
var at = /* @__PURE__ */ ((r) => (r.For = "FOR", r.Against = "AGAINST", r.None = "NONE", r))(at || {});
const y3 = 10000000000000000n, Eoe = [
  "0x27191de92fe0308355319ec8f2359e5ce85123bd243bf7ffa6eb8028347b3eab",
  "0x561a2c3e4359c8ed1c468aef27691e8e48b4424344a38c7693b9127b1911efc9",
  "0x6d7e52c5e80bf6c2873a21cb7013ba0655dc0458c77f2c0e7446c49efdbd0033",
  "0x9df847b39391899840d7973d9718d8caef5c5467dde9374a96d1f71727bae7c4"
], Moe = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  network: n = Vi.MAINNET
}) => {
  const [s, a] = Pe(!1), o = async (u) => {
    var c;
    try {
      const h = Ms[n], d = await fetch(h, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: `
            query Triple($tripleId: String!) {
              triple(term_id: $tripleId) {
                term_id
                counter_term_id
              }
            }
          `,
          variables: { tripleId: String(u) }
        })
      });
      if (!d.ok)
        return null;
      const p = await d.json();
      return p.errors ? (console.error(" GraphQL errors:", p.errors), null) : (c = p.data) != null && c.triple ? {
        id: String(u),
        ...p.data.triple
      } : (console.error(" No triple data found"), null);
    } catch (h) {
      return console.error(" fetchTripleDetails error:", h), null;
    }
  };
  return {
    depositTriple: async (u) => {
      if (!r || !e)
        return {
          success: !1,
          error: "Wallet not connected"
        };
      if (u.length === 0)
        return {
          success: !1,
          error: "No votes provided"
        };
      for (const c of u)
        if (c.units <= 0)
          return {
            success: !1,
            error: "Units must be greater than 0"
          };
      a(!0);
      try {
        const c = [], h = [], d = [], p = [];
        for (const v of u) {
          const y = await o(v.claimId);
          if (!y)
            return a(!1), {
              success: !1,
              error: `Failed to fetch triple details for claim ${v.claimId}`
            };
          let g;
          if (v.direction === at.For) {
            if (!y.term_id)
              return console.error(" term_id is undefined for FOR vote"), { success: !1, error: "term_id not found" };
            g = y.term_id;
          } else {
            if (!y.counter_term_id)
              return console.error(" counter_term_id is undefined for AGAINST vote"), { success: !1, error: "counter_term_id not found" };
            g = y.counter_term_id;
          }
          if (!g)
            return console.error(" targetId is undefined"), { success: !1, error: "targetId not found" };
          const _ = y3 * BigInt(v.units);
          c.push(g), h.push(2n), d.push(_), p.push(0n);
        }
        const f = await r.writeContract({
          address: pl,
          abi: Wh,
          functionName: "depositBatch",
          args: [
            e,
            // receiver
            c,
            // termIds array
            h,
            // curveIds array
            d,
            // assets array
            p
            // minShares array
          ],
          value: d.reduce((v, y) => v + y, 0n),
          // Total value
          gas: 500000n * BigInt(u.length)
          // Gas based on number of votes
        });
        let m;
        return r.waitForTransactionReceipt ? m = await r.waitForTransactionReceipt({ hash: f }) : f.wait ? m = await f.wait() : await new Promise((v) => setTimeout(v, 5e3)), a(!1), {
          success: !0,
          hash: typeof f == "string" ? f : f.hash
        };
      } catch (c) {
        return a(!1), {
          success: !1,
          error: c instanceof Error ? c.message : String(c)
        };
      }
    },
    isLoading: s
  };
}, Aoe = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  network: n = Vi.MAINNET,
  onSuccess: s
}) => {
  const [a, o] = Pe(!1), [l, u] = Pe({
    status: "idle",
    message: ""
  }), { depositTriple: c, isLoading: h } = Moe({
    walletConnected: r,
    walletAddress: e,
    publicClient: i,
    network: n
  });
  return {
    submitVotes: async (p) => {
      var m;
      if (!p.some((v) => v.units > 0))
        return u({
          status: "error",
          message: "Please place at least one vote."
        }), null;
      if (!r || !e)
        return u({
          status: "error",
          message: "Wallet not connected."
        }), null;
      try {
        o(!0), u({
          status: "pending",
          message: "Transaction in progress..."
        });
        const y = p.filter((_) => _.units > 0).map((_) => ({
          claimId: `0x${_.id.toString(16).padStart(64, "0")}`,
          units: _.units,
          direction: _.direction
        })), g = await c(y);
        if (g.success)
          return u({
            status: "success",
            message: `Transaction successful! Hash: ${(m = g.hash) == null ? void 0 : m.substring(0, 10)}...`
          }), s && s(), g;
        {
          let _ = g.error || "An error occurred.";
          return _.includes("user rejected") ? u({
            status: "error",
            message: "Transaction cancelled: User rejected the request."
          }) : u({
            status: "error",
            message: `Error: ${_}`
          }), null;
        }
      } catch (v) {
        return console.error("Error submitting votes:", v), u({
          status: "error",
          message: v instanceof Error ? v.message : "An error occurred."
        }), null;
      } finally {
        o(!1);
      }
    },
    isSubmitting: a,
    isDepositLoading: h,
    transactionStatus: l,
    setTransactionStatus: u
  };
}, Coe = ({
  network: r = Vi.MAINNET,
  onError: e
} = {}) => {
  const [i, n] = Pe(!1);
  return {
    fetchTripleDetails: async (a) => {
      var o, l, u, c, h, d, p;
      n(!0);
      try {
        const f = Ms[r], m = await fetch(f, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: `
          query Triple($tripleId: String!) {
            triple(term_id: $tripleId) {
              term_id
              subject_id
              predicate_id
              object_id
              subject {
                term_id
                label
              }
              predicate {
                term_id
                label
              }
              object {
                term_id
                label
              }
              term_id
              term {
                total_market_cap
                total_assets
              }
              counter_term_id
              counter_term {
                total_market_cap
                total_assets
              }
            }
          }
        `,
            variables: { tripleId: a.toString() }
            // Convertir en string pour v2
          })
        });
        if (!m.ok)
          throw new Error(`GraphQL request failed with status ${m.status}`);
        const v = await m.json();
        if (v.errors)
          throw new Error(`GraphQL errors: ${JSON.stringify(v.errors)}`);
        if (!((o = v.data) != null && o.triple))
          return e && e(`Triple with ID ${a} not found`), n(!1), null;
        const y = ((c = (u = (l = v.data.triple.term) == null ? void 0 : l.positions_aggregate) == null ? void 0 : u.aggregate) == null ? void 0 : c.count) || 0, g = ((p = (d = (h = v.data.triple.counter_term) == null ? void 0 : h.positions_aggregate) == null ? void 0 : d.aggregate) == null ? void 0 : p.count) || 0;
        return n(!1), {
          id: String(a),
          subject: v.data.triple.subject,
          predicate: v.data.triple.predicate,
          object: v.data.triple.object,
          term_id: v.data.triple.term_id,
          counter_term_id: v.data.triple.counter_term_id,
          term_position_count: y,
          counter_term_position_count: g
        };
      } catch (f) {
        return e && e(`Error fetching details for triple ${a}: ${f instanceof Error ? f.message : String(f)}`), n(!1), null;
      }
    },
    isLoading: i
  };
}, Roe = (r) => {
  const [e, i] = Pe(null), [n, s] = Pe(!0), [a, o] = Pe(null);
  return si(() => {
    (async () => {
      if (!r) {
        s(!1);
        return;
      }
      try {
        s(!0);
        const h = await (await fetch(Ms[Vi.MAINNET], {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            query: `
          query GetTriplesWithPositions($accountId: String!) {
            triples {
              term_id
              counter_term_id
              subject_id
              predicate_id
              object_id
              positions(where: { account_id: { _eq: $accountId } }) {
                account_id
                term_id
                shares
                account {
                  id
                  label
                }
              }
              term {
                id
                total_market_cap
                total_assets
                positions(where: { account_id: { _eq: $accountId } }) {
                  account_id
                  shares
                }
              }
              counter_term {
                id
                total_market_cap
                total_assets
                positions(where: { account_id: { _eq: $accountId } }) {
                  account_id
                  shares
                }
              }
            }
          }
        `,
            variables: { accountId: r }
          })
        })).json();
        if (h.errors)
          throw console.error("GraphQL Errors:", h.errors), new Error(h.errors[0].message);
        const d = {
          triples: h.data.triples,
          positions: h.data.triples.flatMap((p) => {
            var f, m;
            return [
              ...p.positions || [],
              ...((f = p.term) == null ? void 0 : f.positions) || [],
              ...((m = p.counter_term) == null ? void 0 : m.positions) || []
            ];
          })
        };
        i(d), s(!1);
      } catch (u) {
        console.error("Erreur lors de la rcupration des triples:", u), o(u), s(!1);
      }
    })();
  }, [r]), { data: e, loading: n, error: a };
}, Noe = ({
  network: r = Vi.MAINNET,
  walletAddress: e = "",
  onError: i
}) => {
  const [n, s] = Pe([]), [a, o] = Pe(!0), [l, u] = Pe(0), [c, h] = Pe({}), { fetchTripleDetails: d } = Coe({
    network: r,
    onError: i
  }), { data: p, loading: f } = Roe(e);
  si(() => {
    if (p && !f && e) {
      const x = {};
      p.positions && Array.isArray(p.positions) && p.positions.forEach((b) => {
        if (!b.triple_id) return;
        const T = b.triple_id;
        if (b.is_for !== void 0) {
          const S = b.is_for ? at.For : at.Against;
          x[String(T)] = S;
        } else b.term_id && b.counter_term_id;
      }), p.triples && Array.isArray(p.triples) && p.triples.forEach((b) => {
        var E, M;
        if (!b.id)
          return;
        if (b.positions && Array.isArray(b.positions)) {
          const N = b.positions.find(
            (k) => {
              var U, C;
              return ((C = (U = k.account) == null ? void 0 : U.id) == null ? void 0 : C.toLowerCase()) === e.toLowerCase();
            }
          );
          N && (N.is_for !== void 0 ? x[String(b.id)] = N.is_for ? at.For : at.Against : N.term_id && b.term_id === N.term_id ? x[String(b.id)] = at.For : N.term_id && b.counter_term_id === N.term_id && (x[String(b.id)] = at.Against));
        }
        const T = ((E = b.term) == null ? void 0 : E.positions) || [], S = ((M = b.counter_term) == null ? void 0 : M.positions) || [], w = T.find((N) => {
          var k, U;
          return ((U = (k = N.account) == null ? void 0 : k.id) == null ? void 0 : U.toLowerCase()) === e.toLowerCase();
        }), A = S.find((N) => {
          var k, U;
          return ((U = (k = N.account) == null ? void 0 : k.id) == null ? void 0 : U.toLowerCase()) === e.toLowerCase();
        });
        w ? x[String(b.id)] = at.For : A && (x[String(b.id)] = at.Against);
      }), p.position_triples && Array.isArray(p.position_triples) && p.position_triples.forEach((b) => {
        var S, w, A, E;
        if (!b.triple_id && !((S = b.triple) != null && S.id)) return;
        const T = b.triple_id || ((w = b.triple) == null ? void 0 : w.id);
        b.is_for !== void 0 ? x[String(T)] = b.is_for ? at.For : at.Against : b.term_id && ((A = b.triple) == null ? void 0 : A.term_id) === b.term_id ? x[String(T)] = at.For : b.term_id && ((E = b.triple) == null ? void 0 : E.counter_term_id) === b.term_id && (x[String(T)] = at.Against);
      }), h(x), s(
        (b) => b.map((T) => {
          const S = x[String(T.id)] || at.None, w = S !== at.None;
          return {
            ...T,
            userHasPosition: w,
            userPositionDirection: S
          };
        })
      );
    }
  }, [p, f, e]), si(() => {
    try {
      m();
    } catch (x) {
      console.error("Error in loadTripleDetails:", x);
    }
  }, []), si(() => {
    const x = n.reduce((b, T) => b + T.units, 0);
    u(x);
  }, [n]);
  const m = async () => {
    o(!0);
    try {
      const x = Eoe.map(async (S) => {
        var E, M, N;
        const w = await d(S);
        if (!w)
          return {
            id: BigInt(S),
            subject: `Claim ${S}`,
            predicate: "is",
            object: "Unknown",
            units: 0,
            direction: at.None,
            userHasPosition: !1,
            userPositionDirection: at.None
          };
        const A = c[String(S)] || at.None;
        return {
          id: BigInt(w.id),
          subject: ((E = w.subject) == null ? void 0 : E.label) || `Subject ${S}`,
          predicate: ((M = w.predicate) == null ? void 0 : M.label) || "is",
          object: ((N = w.object) == null ? void 0 : N.label) || `Object ${S}`,
          units: 0,
          direction: at.None,
          term_id: w.term_id,
          term_position_count: w.term_position_count || 0,
          counter_term_id: w.counter_term_id,
          counter_term_position_count: w.counter_term_position_count || 0,
          userHasPosition: A !== at.None,
          userPositionDirection: A
        };
      }), b = await Promise.all(x);
      b.every((S) => S.object === "Unknown") && i && i("Error: Failed to fetch triple details. Please check your network connection or try again later."), s(b);
    } catch {
      i && i("Error: Failed to fetch triple details");
    } finally {
      o(!1);
    }
  }, v = (x, b, T) => {
    if (b !== at.None && !_(x, b)) {
      const w = n.find((A) => A.id === x);
      if (w && w.userHasPosition && w.userPositionDirection !== at.None) {
        i && i(`Cannot vote ${b === at.For ? "for" : "against"} this claim as you already have an ${w.userPositionDirection === at.For ? "affirmative" : "opposing"} position on it.`);
        return;
      }
    }
    s(
      (S) => S.map((w) => w.id === x ? w.userHasPosition && w.userPositionDirection !== at.None && b !== at.None && w.userPositionDirection !== b ? w : w.direction !== b && w.direction !== at.None ? { ...w, units: T, direction: b } : T === 0 ? { ...w, units: 0, direction: at.None } : { ...w, units: T, direction: b } : w)
    );
  }, y = () => {
    s(
      (x) => x.map((b) => ({
        ...b,
        units: 0,
        direction: at.None
      }))
    );
  }, g = n.filter((x) => x.units > 0).length, _ = (x, b) => {
    const T = n.find((w) => w.id === x);
    return !T || !T.userHasPosition ? !0 : T.userPositionDirection === at.None || T.userPositionDirection === b;
  };
  return {
    voteItems: n,
    setVoteItems: s,
    isLoading: a || f,
    totalUnits: l,
    numberOfTransactions: g,
    handleChangeUnits: v,
    resetAllVotes: y,
    loadTripleDetails: m,
    isVoteDirectionAllowed: _,
    userPositions: c
  };
}, v3 = (r) => (r * 0.01).toFixed(2), Poe = (r) => (r * 5e-5).toFixed(5), Ioe = ({
  numberOfTransactions: r,
  totalUnits: e,
  onResetAll: i
}) => /* @__PURE__ */ V.jsxs(
  "div",
  {
    style: {
      backgroundColor: "#10172d",
      padding: "10px",
      borderRadius: "8px",
      marginBottom: "25px",
      display: "flex",
      flexDirection: "column",
      border: "1px solid #1e3b70"
    },
    children: [
      /* @__PURE__ */ V.jsxs("div", { style: { display: "flex", justifyContent: "space-between", marginBottom: "15px" }, children: [
        /* @__PURE__ */ V.jsxs("div", { children: [
          /* @__PURE__ */ V.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Unit value:" }),
          /* @__PURE__ */ V.jsxs("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: [
            v3(e),
            " tTRUST"
          ] })
        ] }),
        /* @__PURE__ */ V.jsxs("div", { children: [
          /* @__PURE__ */ V.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Number of transactions:" }),
          /* @__PURE__ */ V.jsx("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: r })
        ] }),
        /* @__PURE__ */ V.jsxs("div", { children: [
          /* @__PURE__ */ V.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Estimated gas cost:" }),
          /* @__PURE__ */ V.jsxs("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: [
            "~",
            Poe(r),
            " tTRUST"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ V.jsxs("div", { style: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center"
      }, children: [
        /* @__PURE__ */ V.jsxs("div", { style: { fontSize: "1em", fontWeight: "bold" }, children: [
          "Total units selected:",
          /* @__PURE__ */ V.jsxs("span", { style: { fontSize: "1.6em", marginLeft: "10px", color: "#FFD32A" }, children: [
            e,
            " ",
            e === 1 ? "unit" : "units"
          ] })
        ] }),
        e > 0 && /* @__PURE__ */ V.jsx(
          "button",
          {
            onClick: i,
            style: {
              backgroundColor: "transparent",
              border: "1px solid #6b7280",
              color: "#FFF",
              padding: "6px 12px",
              borderRadius: "4px",
              cursor: "pointer",
              fontSize: "0.9em"
            },
            children: "Reset all"
          }
        )
      ] })
    ]
  }
), Ooe = ({ onClose: r }) => /* @__PURE__ */ V.jsxs(
  "div",
  {
    style: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      marginBottom: "25px",
      borderBottom: "1px solid #1e3b70"
    },
    children: [
      /* @__PURE__ */ V.jsx("h2", { style: { fontSize: "1.3em", color: "#FFD32A", margin: 0, fontWeight: "bold" }, children: "VOTE ON CLAIMS" }),
      r && /* @__PURE__ */ V.jsx(
        "button",
        {
          onClick: r,
          style: {
            backgroundColor: "transparent",
            border: "none",
            color: "#FFF",
            cursor: "pointer",
            fontSize: "1.5em"
          },
          children: ""
        }
      )
    ]
  }
), Doe = ({
  walletAddress: r,
  tripleId: e,
  network: i = Vi.MAINNET
}) => {
  const [n, s] = Pe(!1), [a, o] = Pe(null), [l, u] = Pe(!0), [c, h] = Pe(null), [d, p] = Pe(0), [f, m] = Pe(0);
  return si(() => {
    (async () => {
      var y, g, _, x, b, T, S, w, A, E, M, N, k, U, C, O, D, H, j;
      if (!r || !e) {
        u(!1);
        return;
      }
      try {
        u(!0);
        const K = Ms[i], L = await fetch(K, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: `
              query GetTripleUserPosition($tripleId: String!, $walletAddress: String!) {
                # Get the triple with vault information
                triple(term_id: $tripleId) {
                  term_id
                  subject {
                    label
                  }
                  predicate {
                    label
                  }
                  object {
                    label
                  }
                  term_id
                  counter_term_id
                  
                  # Get vault positions (user only)
                  term {
                    id
                    positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                      aggregate {
                        count
                      }
                      nodes {
                        id
                      }
                    }
                  }
                  
                  # Get counter vault positions (user only)
                  counter_term {
                    id
                    positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                      aggregate {
                        count
                      }
                      nodes {
                        id
                      }
                    }
                  }
                }
              }
            `,
            variables: {
              tripleId: String(e),
              walletAddress: r.toLowerCase()
            }
          })
        });
        if (!L.ok)
          throw new Error(`GraphQL request failed with status ${L.status}`);
        const B = await L.json();
        if (B.errors)
          throw console.error("GraphQL errors:", B.errors), new Error(`GraphQL errors: ${JSON.stringify(B.errors)}`);
        const Q = (y = B.data) == null ? void 0 : y.triple;
        if (!Q) {
          s(!1), o(null), u(!1);
          return;
        }
        const W = ((x = (_ = (g = Q.term) == null ? void 0 : g.positions_aggregate) == null ? void 0 : _.aggregate) == null ? void 0 : x.count) > 0 || ((S = (T = (b = Q.term) == null ? void 0 : b.positions_aggregate) == null ? void 0 : T.nodes) == null ? void 0 : S.length) > 0, z = ((E = (A = (w = Q.counter_term) == null ? void 0 : w.positions_aggregate) == null ? void 0 : A.aggregate) == null ? void 0 : E.count) > 0 || ((k = (N = (M = Q.counter_term) == null ? void 0 : M.positions_aggregate) == null ? void 0 : N.nodes) == null ? void 0 : k.length) > 0;
        p(((O = (C = (U = Q.term) == null ? void 0 : U.positions_aggregate) == null ? void 0 : C.aggregate) == null ? void 0 : O.count) || 0), m(((j = (H = (D = Q.counter_term) == null ? void 0 : D.positions_aggregate) == null ? void 0 : H.aggregate) == null ? void 0 : j.count) || 0);
        const X = W || z;
        s(X), X && o(W), u(!1);
      } catch (K) {
        console.error("Error checking triple position:", K), h(K), u(!1);
      }
    })();
  }, [r, e, i]), { hasPosition: n, isFor: a, loading: l, error: c, termPositionCount: d, counterTermPositionCount: f };
}, Loe = ({
  voteItem: r,
  onChangeUnits: e,
  isVoteDirectionAllowed: i = () => !0,
  walletAddress: n = "",
  network: s = Vi.MAINNET
}) => {
  const {
    id: a,
    subject: o,
    predicate: l,
    object: u,
    units: c,
    direction: h,
    term_position_count: d = 0,
    counter_term_position_count: p = 0,
    userHasPosition: f = !1,
    userPositionDirection: m = at.None
  } = r, [v, y] = Pe(0), [g, _] = Pe(!1), [x, b] = Pe(!1), {
    hasPosition: T,
    isFor: S,
    loading: w,
    termPositionCount: A,
    counterTermPositionCount: E
  } = Doe({
    walletAddress: n,
    tripleId: `0x${a.toString(16).padStart(64, "0")}`,
    network: s
  }), M = w ? f : T, N = w ? m : S !== null ? S ? at.For : at.Against : at.None, k = 20;
  si(() => {
    h === at.For ? y(c) : h === at.Against ? y(-c) : y(0);
  }, [c, h]);
  const U = i ? i(a, at.For) : !M || N === at.For, C = i ? i(a, at.Against) : !M || N === at.Against, O = () => {
    if (!U)
      return;
    const X = Math.min(v + 1, k);
    y(X), e(a, at.For, X);
  }, D = () => {
    if (!U || v <= 0)
      return;
    const X = v - 1;
    y(X), X === 0 ? e(a, at.None, 0) : e(a, at.For, X);
  }, H = () => {
    if (!C)
      return;
    const X = Math.max(v - 1, -k);
    y(X), e(a, at.Against, Math.abs(X));
  }, j = () => {
    if (!C || v >= 0)
      return;
    const X = v + 1;
    y(X), X === 0 ? e(a, at.None, 0) : e(a, at.Against, Math.abs(X));
  }, K = h === at.For && c > 0, L = h === at.Against && c > 0, B = Number(y3) / 10 ** 18 * c, Q = M && N !== at.None, W = Q && N === at.Against ? "You cannot vote FOR this claim because you already have an AGAINST position" : "", z = Q && N === at.For ? "You cannot vote AGAINST this claim because you already have a FOR position" : "";
  return /* @__PURE__ */ V.jsxs(
    "div",
    {
      style: {
        padding: "20px",
        marginBottom: "20px",
        borderRadius: "8px",
        backgroundColor: "#0c1228",
        position: "relative",
        border: Q ? N === at.For ? "2px solid #4CAF50" : "2px solid #F44336" : "1px solid #1e3b70",
        boxShadow: "0 4px 10px rgba(0, 0, 0, 0.3)"
      },
      children: [
        c > 0 && /* @__PURE__ */ V.jsxs("div", { style: {
          position: "absolute",
          top: "5px",
          left: "5px",
          backgroundColor: "#FFD32A",
          color: "#000000",
          padding: "3px 6px",
          fontSize: "10px",
          fontWeight: "bold",
          borderRadius: "4px"
        }, children: [
          B.toFixed(2),
          " tTRUST"
        ] }),
        /* @__PURE__ */ V.jsxs("div", { style: {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        }, children: [
          /* @__PURE__ */ V.jsxs("div", { style: { display: "flex", alignItems: "center", position: "relative" }, children: [
            /* @__PURE__ */ V.jsx("div", { style: { fontSize: "0.9em", color: "#E1E1E1", marginRight: "10px" }, children: "For :" }),
            N === at.For || N === at.None ? /* @__PURE__ */ V.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
              /* @__PURE__ */ V.jsx(
                "button",
                {
                  onClick: U && v > 0 ? D : void 0,
                  disabled: !U || v <= 0,
                  style: {
                    width: "30px",
                    height: "30px",
                    backgroundColor: U && v > 0 ? "#1e2030" : "#606060",
                    border: "none",
                    borderRadius: "4px",
                    color: "#ffffff",
                    fontSize: "16px",
                    cursor: U && v > 0 ? "pointer" : "not-allowed",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    opacity: U && v > 0 ? 1 : 0.4,
                    pointerEvents: U && v > 0 ? "auto" : "none",
                    userSelect: "none"
                  },
                  children: "-"
                }
              ),
              /* @__PURE__ */ V.jsx("span", { style: { margin: "0 10px", color: "#ffffff", fontWeight: "bold" }, children: K ? c : 0 }),
              /* @__PURE__ */ V.jsxs(
                "div",
                {
                  style: { position: "relative" },
                  onMouseEnter: () => W && _(!0),
                  onMouseLeave: () => W && _(!1),
                  children: [
                    /* @__PURE__ */ V.jsx(
                      "button",
                      {
                        onClick: U ? O : void 0,
                        disabled: !U,
                        style: {
                          width: "30px",
                          height: "30px",
                          backgroundColor: U ? "#1976d2" : "#606060",
                          border: !U && Q ? "2px solid #F44336" : "none",
                          borderRadius: "4px",
                          color: "#ffffff",
                          fontSize: "16px",
                          cursor: U ? "pointer" : "not-allowed",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          opacity: U ? 1 : 0.4,
                          pointerEvents: U ? "auto" : "none",
                          userSelect: "none"
                        },
                        children: "+"
                      }
                    ),
                    (!U && Q || g && W) && /* @__PURE__ */ V.jsx("div", { style: {
                      position: "absolute",
                      bottom: "100%",
                      left: "50%",
                      transform: "translateX(-50%)",
                      backgroundColor: "#F44336",
                      color: "white",
                      padding: "5px 10px",
                      borderRadius: "4px",
                      fontSize: "12px",
                      whiteSpace: "nowrap",
                      zIndex: 10,
                      marginBottom: "5px"
                    }, children: W })
                  ]
                }
              )
            ] }) : /* @__PURE__ */ V.jsx("div", { style: {
              backgroundColor: "#606060",
              borderRadius: "4px",
              color: "#ffffff",
              padding: "5px 10px",
              fontSize: "12px",
              marginLeft: "10px"
            }, children: "You have voted AGAINST " })
          ] }),
          /* @__PURE__ */ V.jsxs("div", { style: { display: "flex", marginBottom: "20px", gap: "5px", marginTop: "20px" }, children: [
            /* @__PURE__ */ V.jsx("span", { style: {
              backgroundColor: "#FFB300",
              padding: "4px 8px",
              borderRadius: "4px",
              fontSize: "0.9em",
              color: "#000000",
              fontWeight: "bold"
            }, children: o }),
            "-",
            /* @__PURE__ */ V.jsx("span", { style: {
              backgroundColor: "#ccd3d3",
              padding: "4px 8px",
              borderRadius: "4px",
              fontSize: "0.9em",
              color: "#000000",
              fontWeight: "bold"
            }, children: l }),
            "-",
            /* @__PURE__ */ V.jsx("span", { style: {
              backgroundColor: "#43A047",
              padding: "4px 8px",
              borderRadius: "4px",
              fontSize: "0.9em",
              color: "#000000",
              fontWeight: "bold"
            }, children: u })
          ] }),
          /* @__PURE__ */ V.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
            /* @__PURE__ */ V.jsx("div", { style: { fontSize: "0.9em", color: "#E1E1E1", marginRight: "10px" }, children: "Against :" }),
            N === at.Against || N === at.None ? /* @__PURE__ */ V.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
              /* @__PURE__ */ V.jsx(
                "button",
                {
                  onClick: C && v < 0 ? j : void 0,
                  disabled: !C || v >= 0,
                  style: {
                    width: "30px",
                    height: "30px",
                    backgroundColor: C && v < 0 ? "#1e2030" : "#606060",
                    border: "none",
                    borderRadius: "4px",
                    color: "#ffffff",
                    fontSize: "16px",
                    cursor: C && v < 0 ? "pointer" : "not-allowed",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    opacity: C && v < 0 ? 1 : 0.4,
                    pointerEvents: C && v < 0 ? "auto" : "none",
                    userSelect: "none"
                  },
                  children: "-"
                }
              ),
              /* @__PURE__ */ V.jsx("span", { style: { margin: "0 10px", color: "#ffffff", fontWeight: "bold" }, children: L ? c : 0 }),
              /* @__PURE__ */ V.jsxs(
                "div",
                {
                  style: { position: "relative" },
                  onMouseEnter: () => z && b(!0),
                  onMouseLeave: () => z && b(!1),
                  children: [
                    /* @__PURE__ */ V.jsx(
                      "button",
                      {
                        onClick: C ? H : void 0,
                        disabled: !C,
                        style: {
                          width: "30px",
                          height: "30px",
                          backgroundColor: C ? "#dc3545" : "#606060",
                          border: !C && Q ? "2px solid #4CAF50" : "none",
                          borderRadius: "4px",
                          color: "#ffffff",
                          fontSize: "16px",
                          cursor: C ? "pointer" : "not-allowed",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          opacity: C ? 1 : 0.4,
                          pointerEvents: C ? "auto" : "none",
                          userSelect: "none"
                        },
                        children: "+"
                      }
                    ),
                    (!C && Q || x && z) && /* @__PURE__ */ V.jsx("div", { style: {
                      position: "absolute",
                      bottom: "100%",
                      left: "50%",
                      transform: "translateX(-50%)",
                      backgroundColor: "#F44336",
                      color: "white",
                      padding: "5px 10px",
                      borderRadius: "4px",
                      fontSize: "12px",
                      whiteSpace: "nowrap",
                      zIndex: 10,
                      marginBottom: "5px"
                    }, children: z })
                  ]
                }
              )
            ] }) : /* @__PURE__ */ V.jsx("div", { style: {
              backgroundColor: "#606060",
              borderRadius: "4px",
              color: "#ffffff",
              padding: "5px 10px",
              fontSize: "12px",
              marginLeft: "10px"
            }, children: "You have voted FOR " })
          ] })
        ] }),
        /* @__PURE__ */ V.jsxs("div", { className: "flex flex-row justify-between", children: [
          /* @__PURE__ */ V.jsxs("div", { style: {
            fontSize: "0.7em",
            color: "#4CAF50",
            marginBottom: "8px",
            backgroundColor: "rgba(76, 175, 80, 0.1)",
            padding: "2px 6px",
            borderRadius: "4px",
            fontWeight: "bold"
          }, children: [
            A,
            " positions"
          ] }),
          /* @__PURE__ */ V.jsxs("div", { style: {
            fontSize: "0.7em",
            color: "#F44336",
            marginBottom: "8px",
            backgroundColor: "rgba(244, 67, 54, 0.1)",
            padding: "2px 6px",
            borderRadius: "4px",
            fontWeight: "bold"
          }, children: [
            E,
            " positions"
          ] })
        ] })
      ]
    }
  );
}, Uoe = ({
  isLoading: r,
  voteItems: e,
  onChangeUnits: i,
  isVoteDirectionAllowed: n,
  walletAddress: s = "",
  network: a = Vi.MAINNET
}) => r ? /* @__PURE__ */ V.jsx("div", { style: { textAlign: "center", padding: "30px", color: "#6b7280", fontSize: "1.1em" }, children: "Loading claims..." }) : /* @__PURE__ */ V.jsx("div", { style: { marginBottom: "25px" }, children: e.map((o) => /* @__PURE__ */ V.jsx(
  Loe,
  {
    voteItem: o,
    onChangeUnits: i,
    isVoteDirectionAllowed: n,
    walletAddress: s,
    network: a
  },
  o.id.toString()
)) }), koe = ({
  onSubmit: r,
  isSubmitting: e,
  isDepositLoading: i,
  totalUnits: n,
  numberOfTransactions: s
}) => /* @__PURE__ */ V.jsxs("div", { style: { textAlign: "center" }, children: [
  /* @__PURE__ */ V.jsx("div", { style: { marginBottom: "15px", fontSize: "0.9em", color: "#6b7280" }, children: s > 0 && `You will initiate ${s} transaction${s > 1 ? "s" : ""}` }),
  /* @__PURE__ */ V.jsx(
    "button",
    {
      onClick: r,
      disabled: e || i || n === 0,
      style: {
        backgroundColor: n > 0 && !e && !i ? "#1976d2" : "#10172d",
        color: "#FFF",
        padding: "12px 30px",
        border: "none",
        borderRadius: "8px",
        fontSize: "1.1em",
        fontWeight: "bold",
        cursor: n > 0 && !e && !i ? "pointer" : "not-allowed",
        width: "100%",
        maxWidth: "350px",
        boxShadow: "0 4px 10px rgba(0, 0, 0, 0.3)",
        transition: "background-color 0.2s ease"
      },
      children: e || i ? "Processing..." : n > 0 ? `Submit votes (${v3(n)} tTRUST)` : "Submit votes"
    }
  )
] }), Foe = ({
  transactionStatus: r
}) => r.status === "idle" || r.status === "whitelist_error" ? null : /* @__PURE__ */ V.jsx(
  "div",
  {
    style: {
      marginTop: "25px",
      padding: "20px",
      borderRadius: "8px",
      backgroundColor: r.status === "pending" ? "#10172d" : r.status === "approval_pending" ? "rgba(255, 211, 42, 0.1)" : r.status === "success" ? "rgba(0, 128, 0, 0.1)" : "rgba(255, 0, 0, 0.1)",
      color: r.status === "success" ? "#4CAF50" : r.status === "error" ? "#F44336" : r.status === "approval_pending" ? "#FFD32A" : "#FFF",
      display: "flex",
      flexDirection: "column",
      gap: "10px",
      border: "1px solid #1e3b70"
    },
    children: /* @__PURE__ */ V.jsx("div", { children: r.message })
  }
), ole = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  onClose: n,
  network: s = Vi.MAINNET,
  onConnectWallet: a,
  onCreatePlayer: o,
  wagmiConfig: l,
  walletHooks: u
}) => {
  const [c, h] = Pe(!1), [d, p] = Pe(!1), [f, m] = Pe(!1), {
    loading: v,
    triples: y
  } = uS(
    e || "",
    ti.IS_PLAYER_GAMES.predicateId.toString(),
    ti.IS_PLAYER_GAMES.objectId.toString(),
    s
  ), g = y.length > 0;
  si(() => {
    m(!!(e && e !== ""));
  }, [e]), si(() => {
    p(!!(f && !g && !v));
  }, [f, g, v]);
  const {
    voteItems: _,
    isLoading: x,
    totalUnits: b,
    numberOfTransactions: T,
    handleChangeUnits: S,
    resetAllVotes: w,
    isVoteDirectionAllowed: A
  } = Noe({
    network: s,
    walletAddress: e,
    onError: (Q) => {
      U({
        status: "error",
        message: Q
      });
    }
  }), {
    submitVotes: E,
    isSubmitting: M,
    isDepositLoading: N,
    transactionStatus: k,
    setTransactionStatus: U
  } = Aoe({
    walletConnected: r,
    walletAddress: e,
    publicClient: i,
    network: s,
    onSuccess: w
  }), C = async () => {
    await E(_);
  }, O = () => {
    p(!1), h(!0), o && o();
  }, D = () => {
    h(!1);
  }, H = () => {
    p(!1), n && n();
  }, { isCorrectNetwork: j, currentChainId: K, targetChainId: L, allowedChainIds: B } = sC({
    walletConnected: r,
    publicClient: i
  });
  return f ? f && !g && !v ? /* @__PURE__ */ V.jsxs(
    "div",
    {
      style: {
        backgroundColor: "#070b1a",
        minHeight: "50vh",
        color: "#fff",
        padding: "15px",
        border: "1px solid #1e3b70",
        borderRadius: "8px",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: [
        /* @__PURE__ */ V.jsx(
          _oe,
          {
            isOpen: !0,
            onCreatePlayer: O,
            onClose: H
          }
        ),
        /* @__PURE__ */ V.jsx(
          oC,
          {
            isOpen: c,
            onClose: D,
            walletConnected: r,
            walletAddress: e,
            wagmiConfig: l,
            walletHooks: u
          }
        )
      ]
    }
  ) : /* @__PURE__ */ V.jsxs(
    "div",
    {
      style: {
        backgroundColor: "#070b1a",
        minHeight: "50vh",
        opacity: "0.9",
        color: "#fff",
        padding: "15px",
        border: "1px solid #1e3b70",
        borderRadius: "8px",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: [
        /* @__PURE__ */ V.jsx(Ooe, { onClose: n }),
        /* @__PURE__ */ V.jsx(
          Ioe,
          {
            numberOfTransactions: T,
            totalUnits: b,
            onResetAll: w
          }
        ),
        /* @__PURE__ */ V.jsx(
          Uoe,
          {
            isLoading: x || v,
            voteItems: _,
            onChangeUnits: S,
            isVoteDirectionAllowed: A,
            walletAddress: e,
            network: s
          }
        ),
        /* @__PURE__ */ V.jsx(
          koe,
          {
            onSubmit: C,
            isSubmitting: M,
            isDepositLoading: N,
            totalUnits: b,
            numberOfTransactions: T
          }
        ),
        /* @__PURE__ */ V.jsx(Foe, { transactionStatus: k }),
        !j && /* @__PURE__ */ V.jsx(
          aC,
          {
            allowedChainIds: B,
            currentChainId: K,
            targetChainId: L
          }
        )
      ]
    }
  ) : /* @__PURE__ */ V.jsx(
    "div",
    {
      style: {
        backgroundColor: "#070b1a",
        minHeight: "50vh",
        opacity: "0.9",
        color: "#fff",
        padding: "15px",
        border: "1px solid #1e3b70",
        borderRadius: "8px",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: /* @__PURE__ */ V.jsx(
        m3,
        {
          isOpen: !0,
          onConnectWallet: a || (() => {
          })
        }
      )
    }
  );
}, lle = async (r, e, i = Vi.MAINNET) => {
  var n, s, a, o, l, u, c, h, d, p, f, m, v;
  if (!r)
    throw new Error("Wallet address is required");
  try {
    const y = Ms[i], g = await fetch(y, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetTripleUserPosition($tripleId: numeric!, $walletAddress: String!) {
            # Get the triple with vault information
            triple(term_id: $tripleId) {
              id
              subject {
                label
              }
              predicate {
                label
              }
              object {
                label
              }
              term_id
              counter_term_id
              
              # Get vault positions
              term {
                id
                positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                  aggregate {
                    count
                  }
                  nodes {
                    id
                  }
                }
              }
              
              # Get counter vault positions
              counter_term {
                id
                positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                  aggregate {
                    count
                  }
                  nodes {
                    id
                  }
                }
              }
            }
          }
        `,
        variables: {
          tripleId: Number(e),
          walletAddress: r.toLowerCase()
        }
      })
    });
    if (!g.ok)
      throw new Error(`GraphQL request failed with status ${g.status}`);
    const _ = await g.json();
    if (_.errors)
      throw console.error("GraphQL errors:", _.errors), new Error(`GraphQL errors: ${JSON.stringify(_.errors)}`);
    const x = (n = _.data) == null ? void 0 : n.triple;
    if (!x)
      return {
        hasPosition: !1,
        isFor: null,
        result: _.data
      };
    const b = ((o = (a = (s = x.term) == null ? void 0 : s.positions_aggregate) == null ? void 0 : a.aggregate) == null ? void 0 : o.count) > 0 || ((c = (u = (l = x.term) == null ? void 0 : l.positions_aggregate) == null ? void 0 : u.nodes) == null ? void 0 : c.length) > 0, T = ((p = (d = (h = x.counter_term) == null ? void 0 : h.positions_aggregate) == null ? void 0 : d.aggregate) == null ? void 0 : p.count) > 0 || ((v = (m = (f = x.counter_term) == null ? void 0 : f.positions_aggregate) == null ? void 0 : m.nodes) == null ? void 0 : v.length) > 0, S = b || T;
    return {
      hasPosition: S,
      isFor: S ? b : null,
      result: _.data
      // Return raw data for debugging
    };
  } catch (y) {
    throw console.error("Error checking triple position:", y), y;
  }
}, ule = {
  /**
   * Initialise la configuration de la bibliothque Player-map
   * @param config Configuration contenant l'URL de l'API (obligatoire)
   */
  init: (r) => {
    if (!r.apiUrl)
      throw new Error(
        "L'URL de l'API est obligatoire pour initialiser Player-map"
      );
    return tU(r), !0;
  },
  /**
   * Rcupre la configuration actuelle
   * @throws Error si la configuration n'a pas t initialise
   */
  get: hg
}, cle = {
  setAuthToken: zS,
  getAuthToken: c_,
  isAuthenticated: cg,
  clearAuthToken: eU,
  // Fonction d'initialisation pour les applications intgrant la bibliothque
  initialize: (r) => r ? (zS(r), !0) : !1
};
export {
  ole as ClaimVoting,
  ale as GraphComponent,
  Eoe as PREDEFINED_CLAIM_IDS,
  ule as PlayerMapConfig,
  xoe as PlayerMapGraph,
  M3 as PlayerMapHome,
  oC as RegistrationForm,
  y3 as UNIT_VALUE,
  at as VoteDirection,
  cle as auth,
  lle as checkTriplePosition,
  eU as clearAuthToken,
  M3 as default,
  c_ as getAuthToken,
  cg as isAuthenticated,
  zS as setAuthToken,
  Doe as useCheckSpecificTriplePosition,
  Moe as useDepositTriple,
  Roe as useDisplayTriplesWithPosition
};
