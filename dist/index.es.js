var xT = (r) => {
  throw TypeError(r);
};
var ny = (r, e, i) => e.has(r) || xT("Cannot " + i);
var me = (r, e, i) => (ny(r, e, "read from private field"), i ? i.call(r) : e.get(r)), zt = (r, e, i) => e.has(r) ? xT("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, i), mt = (r, e, i, n) => (ny(r, e, "write to private field"), n ? n.call(r, i) : e.set(r, i), i), ar = (r, e, i) => (ny(r, e, "access private method"), i);
var op = (r, e, i, n) => ({
  set _(s) {
    mt(r, e, s, i);
  },
  get _() {
    return me(r, e, n);
  }
});
import * as _2 from "react";
import si, { useState as ve, useEffect as Ft, useRef as gr, forwardRef as IO, useMemo as T2, useCallback as Or, useImperativeHandle as OO, useLayoutEffect as DO, createContext as LO } from "react";
import S2 from "3d-force-graph-vr";
var Dv = { exports: {} }, Yc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _T;
function kO() {
  if (_T) return Yc;
  _T = 1;
  var r = si, e = Symbol.for("react.element"), i = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(l, u, c) {
    var h, d = {}, p = null, f = null;
    c !== void 0 && (p = "" + c), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (f = u.ref);
    for (h in u) n.call(u, h) && !a.hasOwnProperty(h) && (d[h] = u[h]);
    if (l && l.defaultProps) for (h in u = l.defaultProps, u) d[h] === void 0 && (d[h] = u[h]);
    return { $$typeof: e, type: l, key: p, ref: f, props: d, _owner: s.current };
  }
  return Yc.Fragment = i, Yc.jsx = o, Yc.jsxs = o, Yc;
}
var Kc = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TT;
function UO() {
  return TT || (TT = 1, process.env.NODE_ENV !== "production" && function() {
    var r = si, e = Symbol.for("react.element"), i = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), m = Symbol.iterator, y = "@@iterator";
    function v(R) {
      if (R === null || typeof R != "object")
        return null;
      var J = m && R[m] || R[y];
      return typeof J == "function" ? J : null;
    }
    var g = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(R) {
      {
        for (var J = arguments.length, ce = new Array(J > 1 ? J - 1 : 0), Re = 1; Re < J; Re++)
          ce[Re - 1] = arguments[Re];
        x("error", R, ce);
      }
    }
    function x(R, J, ce) {
      {
        var Re = g.ReactDebugCurrentFrame, Ze = Re.getStackAddendum();
        Ze !== "" && (J += "%s", ce = ce.concat([Ze]));
        var at = ce.map(function(qe) {
          return String(qe);
        });
        at.unshift("Warning: " + J), Function.prototype.apply.call(console[R], console, at);
      }
    }
    var b = !1, T = !1, S = !1, w = !1, M = !1, E;
    E = Symbol.for("react.module.reference");
    function A(R) {
      return !!(typeof R == "string" || typeof R == "function" || R === n || R === a || M || R === s || R === c || R === h || w || R === f || b || T || S || typeof R == "object" && R !== null && (R.$$typeof === p || R.$$typeof === d || R.$$typeof === o || R.$$typeof === l || R.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      R.$$typeof === E || R.getModuleId !== void 0));
    }
    function N(R, J, ce) {
      var Re = R.displayName;
      if (Re)
        return Re;
      var Ze = J.displayName || J.name || "";
      return Ze !== "" ? ce + "(" + Ze + ")" : ce;
    }
    function U(R) {
      return R.displayName || "Context";
    }
    function k(R) {
      if (R == null)
        return null;
      if (typeof R.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof R == "function")
        return R.displayName || R.name || null;
      if (typeof R == "string")
        return R;
      switch (R) {
        case n:
          return "Fragment";
        case i:
          return "Portal";
        case a:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case l:
            var J = R;
            return U(J) + ".Consumer";
          case o:
            var ce = R;
            return U(ce._context) + ".Provider";
          case u:
            return N(R, R.render, "ForwardRef");
          case d:
            var Re = R.displayName || null;
            return Re !== null ? Re : k(R.type) || "Memo";
          case p: {
            var Ze = R, at = Ze._payload, qe = Ze._init;
            try {
              return k(qe(at));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var C = Object.assign, I = 0, O, W, V, Q, F, B, q;
    function G() {
    }
    G.__reactDisabledLog = !0;
    function z() {
      {
        if (I === 0) {
          O = console.log, W = console.info, V = console.warn, Q = console.error, F = console.group, B = console.groupCollapsed, q = console.groupEnd;
          var R = {
            configurable: !0,
            enumerable: !0,
            value: G,
            writable: !0
          };
          Object.defineProperties(console, {
            info: R,
            log: R,
            warn: R,
            error: R,
            group: R,
            groupCollapsed: R,
            groupEnd: R
          });
        }
        I++;
      }
    }
    function Y() {
      {
        if (I--, I === 0) {
          var R = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: C({}, R, {
              value: O
            }),
            info: C({}, R, {
              value: W
            }),
            warn: C({}, R, {
              value: V
            }),
            error: C({}, R, {
              value: Q
            }),
            group: C({}, R, {
              value: F
            }),
            groupCollapsed: C({}, R, {
              value: B
            }),
            groupEnd: C({}, R, {
              value: q
            })
          });
        }
        I < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var se = g.ReactCurrentDispatcher, ne;
    function fe(R, J, ce) {
      {
        if (ne === void 0)
          try {
            throw Error();
          } catch (Ze) {
            var Re = Ze.stack.trim().match(/\n( *(at )?)/);
            ne = Re && Re[1] || "";
          }
        return `
` + ne + R;
      }
    }
    var Se = !1, Pe;
    {
      var lt = typeof WeakMap == "function" ? WeakMap : Map;
      Pe = new lt();
    }
    function xe(R, J) {
      if (!R || Se)
        return "";
      {
        var ce = Pe.get(R);
        if (ce !== void 0)
          return ce;
      }
      var Re;
      Se = !0;
      var Ze = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var at;
      at = se.current, se.current = null, z();
      try {
        if (J) {
          var qe = function() {
            throw Error();
          };
          if (Object.defineProperty(qe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(qe, []);
            } catch (Ne) {
              Re = Ne;
            }
            Reflect.construct(R, [], qe);
          } else {
            try {
              qe.call();
            } catch (Ne) {
              Re = Ne;
            }
            R.call(qe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            Re = Ne;
          }
          R();
        }
      } catch (Ne) {
        if (Ne && Re && typeof Ne.stack == "string") {
          for (var Ge = Ne.stack.split(`
`), L = Re.stack.split(`
`), H = Ge.length - 1, te = L.length - 1; H >= 1 && te >= 0 && Ge[H] !== L[te]; )
            te--;
          for (; H >= 1 && te >= 0; H--, te--)
            if (Ge[H] !== L[te]) {
              if (H !== 1 || te !== 1)
                do
                  if (H--, te--, te < 0 || Ge[H] !== L[te]) {
                    var oe = `
` + Ge[H].replace(" at new ", " at ");
                    return R.displayName && oe.includes("<anonymous>") && (oe = oe.replace("<anonymous>", R.displayName)), typeof R == "function" && Pe.set(R, oe), oe;
                  }
                while (H >= 1 && te >= 0);
              break;
            }
        }
      } finally {
        Se = !1, se.current = at, Y(), Error.prepareStackTrace = Ze;
      }
      var K = R ? R.displayName || R.name : "", Me = K ? fe(K) : "";
      return typeof R == "function" && Pe.set(R, Me), Me;
    }
    function vt(R, J, ce) {
      return xe(R, !1);
    }
    function Z(R) {
      var J = R.prototype;
      return !!(J && J.isReactComponent);
    }
    function Ht(R, J, ce) {
      if (R == null)
        return "";
      if (typeof R == "function")
        return xe(R, Z(R));
      if (typeof R == "string")
        return fe(R);
      switch (R) {
        case c:
          return fe("Suspense");
        case h:
          return fe("SuspenseList");
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case u:
            return vt(R.render);
          case d:
            return Ht(R.type, J, ce);
          case p: {
            var Re = R, Ze = Re._payload, at = Re._init;
            try {
              return Ht(at(Ze), J, ce);
            } catch {
            }
          }
        }
      return "";
    }
    var nt = Object.prototype.hasOwnProperty, Tt = {}, We = g.ReactDebugCurrentFrame;
    function At(R) {
      if (R) {
        var J = R._owner, ce = Ht(R.type, R._source, J ? J.type : null);
        We.setExtraStackFrame(ce);
      } else
        We.setExtraStackFrame(null);
    }
    function st(R, J, ce, Re, Ze) {
      {
        var at = Function.call.bind(nt);
        for (var qe in R)
          if (at(R, qe)) {
            var Ge = void 0;
            try {
              if (typeof R[qe] != "function") {
                var L = Error((Re || "React class") + ": " + ce + " type `" + qe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof R[qe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw L.name = "Invariant Violation", L;
              }
              Ge = R[qe](J, qe, Re, ce, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (H) {
              Ge = H;
            }
            Ge && !(Ge instanceof Error) && (At(Ze), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Re || "React class", ce, qe, typeof Ge), At(null)), Ge instanceof Error && !(Ge.message in Tt) && (Tt[Ge.message] = !0, At(Ze), _("Failed %s type: %s", ce, Ge.message), At(null));
          }
      }
    }
    var j = Array.isArray;
    function D(R) {
      return j(R);
    }
    function le(R) {
      {
        var J = typeof Symbol == "function" && Symbol.toStringTag, ce = J && R[Symbol.toStringTag] || R.constructor.name || "Object";
        return ce;
      }
    }
    function Te(R) {
      try {
        return Ce(R), !1;
      } catch {
        return !0;
      }
    }
    function Ce(R) {
      return "" + R;
    }
    function _e(R) {
      if (Te(R))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", le(R)), Ce(R);
    }
    var Je = g.ReactCurrentOwner, Be = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Xe, Pt;
    function Ie(R) {
      if (nt.call(R, "ref")) {
        var J = Object.getOwnPropertyDescriptor(R, "ref").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return R.ref !== void 0;
    }
    function $e(R) {
      if (nt.call(R, "key")) {
        var J = Object.getOwnPropertyDescriptor(R, "key").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return R.key !== void 0;
    }
    function ut(R, J) {
      typeof R.ref == "string" && Je.current;
    }
    function ft(R, J) {
      {
        var ce = function() {
          Xe || (Xe = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "key", {
          get: ce,
          configurable: !0
        });
      }
    }
    function Ye(R, J) {
      {
        var ce = function() {
          Pt || (Pt = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "ref", {
          get: ce,
          configurable: !0
        });
      }
    }
    var Ot = function(R, J, ce, Re, Ze, at, qe) {
      var Ge = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: R,
        key: J,
        ref: ce,
        props: qe,
        // Record the component responsible for creating this element.
        _owner: at
      };
      return Ge._store = {}, Object.defineProperty(Ge._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ge, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Re
      }), Object.defineProperty(Ge, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ze
      }), Object.freeze && (Object.freeze(Ge.props), Object.freeze(Ge)), Ge;
    };
    function bt(R, J, ce, Re, Ze) {
      {
        var at, qe = {}, Ge = null, L = null;
        ce !== void 0 && (_e(ce), Ge = "" + ce), $e(J) && (_e(J.key), Ge = "" + J.key), Ie(J) && (L = J.ref, ut(J, Ze));
        for (at in J)
          nt.call(J, at) && !Be.hasOwnProperty(at) && (qe[at] = J[at]);
        if (R && R.defaultProps) {
          var H = R.defaultProps;
          for (at in H)
            qe[at] === void 0 && (qe[at] = H[at]);
        }
        if (Ge || L) {
          var te = typeof R == "function" ? R.displayName || R.name || "Unknown" : R;
          Ge && ft(qe, te), L && Ye(qe, te);
        }
        return Ot(R, Ge, L, Ze, Re, Je.current, qe);
      }
    }
    var jt = g.ReactCurrentOwner, ee = g.ReactDebugCurrentFrame;
    function Le(R) {
      if (R) {
        var J = R._owner, ce = Ht(R.type, R._source, J ? J.type : null);
        ee.setExtraStackFrame(ce);
      } else
        ee.setExtraStackFrame(null);
    }
    var de;
    de = !1;
    function Ee(R) {
      return typeof R == "object" && R !== null && R.$$typeof === e;
    }
    function ze() {
      {
        if (jt.current) {
          var R = k(jt.current.type);
          if (R)
            return `

Check the render method of \`` + R + "`.";
        }
        return "";
      }
    }
    function Ue(R) {
      return "";
    }
    var Ct = {};
    function ni(R) {
      {
        var J = ze();
        if (!J) {
          var ce = typeof R == "string" ? R : R.displayName || R.name;
          ce && (J = `

Check the top-level render call using <` + ce + ">.");
        }
        return J;
      }
    }
    function _i(R, J) {
      {
        if (!R._store || R._store.validated || R.key != null)
          return;
        R._store.validated = !0;
        var ce = ni(J);
        if (Ct[ce])
          return;
        Ct[ce] = !0;
        var Re = "";
        R && R._owner && R._owner !== jt.current && (Re = " It was passed a child from " + k(R._owner.type) + "."), Le(R), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ce, Re), Le(null);
      }
    }
    function Bt(R, J) {
      {
        if (typeof R != "object")
          return;
        if (D(R))
          for (var ce = 0; ce < R.length; ce++) {
            var Re = R[ce];
            Ee(Re) && _i(Re, J);
          }
        else if (Ee(R))
          R._store && (R._store.validated = !0);
        else if (R) {
          var Ze = v(R);
          if (typeof Ze == "function" && Ze !== R.entries)
            for (var at = Ze.call(R), qe; !(qe = at.next()).done; )
              Ee(qe.value) && _i(qe.value, J);
        }
      }
    }
    function yr(R) {
      {
        var J = R.type;
        if (J == null || typeof J == "string")
          return;
        var ce;
        if (typeof J == "function")
          ce = J.propTypes;
        else if (typeof J == "object" && (J.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        J.$$typeof === d))
          ce = J.propTypes;
        else
          return;
        if (ce) {
          var Re = k(J);
          st(ce, R.props, "prop", Re, R);
        } else if (J.PropTypes !== void 0 && !de) {
          de = !0;
          var Ze = k(J);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ze || "Unknown");
        }
        typeof J.getDefaultProps == "function" && !J.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Xr(R) {
      {
        for (var J = Object.keys(R.props), ce = 0; ce < J.length; ce++) {
          var Re = J[ce];
          if (Re !== "children" && Re !== "key") {
            Le(R), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Re), Le(null);
            break;
          }
        }
        R.ref !== null && (Le(R), _("Invalid attribute `ref` supplied to `React.Fragment`."), Le(null));
      }
    }
    var Aa = {};
    function Ca(R, J, ce, Re, Ze, at) {
      {
        var qe = A(R);
        if (!qe) {
          var Ge = "";
          (R === void 0 || typeof R == "object" && R !== null && Object.keys(R).length === 0) && (Ge += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var L = Ue();
          L ? Ge += L : Ge += ze();
          var H;
          R === null ? H = "null" : D(R) ? H = "array" : R !== void 0 && R.$$typeof === e ? (H = "<" + (k(R.type) || "Unknown") + " />", Ge = " Did you accidentally export a JSX literal instead of a component?") : H = typeof R, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", H, Ge);
        }
        var te = bt(R, J, ce, Ze, at);
        if (te == null)
          return te;
        if (qe) {
          var oe = J.children;
          if (oe !== void 0)
            if (Re)
              if (D(oe)) {
                for (var K = 0; K < oe.length; K++)
                  Bt(oe[K], R);
                Object.freeze && Object.freeze(oe);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Bt(oe, R);
        }
        if (nt.call(J, "key")) {
          var Me = k(R), Ne = Object.keys(J).filter(function(gt) {
            return gt !== "key";
          }), Ke = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Aa[Me + Ke]) {
            var tt = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            _(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ke, Me, tt, Me), Aa[Me + Ke] = !0;
          }
        }
        return R === n ? Xr(te) : yr(te), te;
      }
    }
    function Mn(R, J, ce) {
      return Ca(R, J, ce, !0);
    }
    function Mo(R, J, ce) {
      return Ca(R, J, ce, !1);
    }
    var kl = Mo, Ul = Mn;
    Kc.Fragment = n, Kc.jsx = kl, Kc.jsxs = Ul;
  }()), Kc;
}
process.env.NODE_ENV === "production" ? Dv.exports = kO() : Dv.exports = UO();
var P = Dv.exports;
const w2 = "data:image/svg+xml,%3csvg%20width='300'%20height='50'%20viewBox='0%200%20500%2084'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20width='500'%20height='84'%20fill='url(%23pattern0_10_2)'/%3e%3cdefs%3e%3cpattern%20id='pattern0_10_2'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_10_2'%20transform='scale(0.002%200.0119048)'/%3e%3c/pattern%3e%3cimage%20id='image0_10_2'%20width='500'%20height='84'%20preserveAspectRatio='none'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABUCAYAAAB0vcXQAAAAAXNSR0IArs4c6QAAIABJREFUeF7tXQeYJFW5vfdWro4zw2wgioCoJEUMwDOsGEAFFR/6RFEREAH1IUpQQaIEFcWEiiAGVIKib0URFFBEfQbQJ+CCgODCssvuhE5VXfm+PjVVQ01vz0x3T/eE3arvQ2S6wr3/Def+6fyULPC1YcOGjKZpewiC8JwgCPZkjD07CIIVlNICISRPCMG/JUJImVJa4ZzXov//YBAED3iet0bTtPtVVX2MUore8AXuUvr5VAKpBFIJpBJYaAkADjpGg64eWuieTn4/RMD5vsrl8m6CILyRc/56wsl/EEoEQkhXbclms8S2beL7/oZ6vf6rTCbzy2q1euuyZcs2RO/seEh7Io+lPS96IoIt9SWLeWgXc9u21PmwNPqVzoylMU5za2VXINrNJyuVyrMppScSQt5KCFk+zTtcQsjDhJDHCSElQgg08rLImOdzDk09RwjJEkKWEUKeTQgZEASBQDN3HIcwxggAvlarBZIk/da27Svuv//+H++///4WpXRhgL0bYaXPpBJIJZBKIJVAKoEOJdBXQOecy4Zh/GcQBO8jhLxcEAROOKEBD2LT+AOc819QSv9IKV2TyWTWUEoB6m1d1Wp1med5z1UUZR/XdV8tCMIrGGMZ3/eJ53kEYC8IwngQBN+2bfvr22yzDb5HU3BvS7zpTakEUgmkEghNp6k2tDQmQl8AnXPODMN4G2PsfELILgBYzAhBFIDkd/i+f4PnebcMDAw81ksxcc4Vy7IO9DzvMELIkZIkDQdBwD3PA4jjoHC14zjnDw0NPbFVA3u6Qns57dJ3TfFttTe52rsrFW1/JJBKvz9yXfi39hzQa7XaqznnFxPC9+WchOZwTdVGOeFXm6Z5RaFQeKhVtzdt2pTLZDLPIYQ8k3P+TELIDoQQJTKzi5xzh1I6TiktE0I2BEHwD8YYAuIeb6VxP/TQQ8qKFSveFATBcYyxgxhjOGTSIAjqlmV9yXXdc1euXFlPtfWFn4RpCxa/BBYvBCzels06qku46bP2Lb1hQSTQM0Avl8uDjLEvEkLeEVloKOd8I6X0vGw2eyUhBIA8abnZuHFjVtO0QxhjLyOEHEgI2ZsQwjoNjvN9v+L7/p2MsdsEQbgtm83e26x912q1vSilnyKEHCpJEszx9+i6/oI77rhDXLVqlTdXyafrcq4STJ9PJZBKIJVAKoG5SqAngF6r1V7LOb8qCILt0CDGWKWhWV+azWY/Rwg3KA21YwKfer1eP6yRavY2SunrCCE6Atmmv0KletqfgyD0xYe+crwn8p0/LEkSDhDf13X98SS4V6vVV8iyfKrrul/MZrO3wDVAKZ14SXqlEkglsMQkkB6ll9iApc3tswTmBOgAaNu2P+e67kmKohDDMACs/2NZ1vHLli2Ddh4C+djYWIEx9n7G2AcppTHo96RrUe755Ls47PwTl885/7nv+58qFAp/BLAzSjlv2gOq1eqwIAhfC4IAloT/26p96z0ZkS3kJYsSKxa4UQvw+QX45BYygdNubI0S6BrQOecF0zSv9X3/YKSMqapq+L5/WqFQuDwGRZDGKIpyKmX0I5TQDCLTAMAza+WdDcNmgB7AcT/lHdDAb23cd46u6yGwxwcNBNHZtn1BEAQfJYSMEkJO0nX9ulRz72wM0rtTCcwsgRSW0xmSSmA+JNAVoI+Pjz+DMXaTJEl7oJGyJP/JcZ0jdF1fi/8GaG7cuPFwxtjndF3fMdmRGTTqrvrb7vtgWuecX+O67smFQqEEUOecC7Ztn8A5/1Kk2duO45xXLBYvxG+UUr+rRs36ULrBzSqi9IYF5UXa8sW/BNbgEmjilj9PllYP2wP0xMSqVqugab0d5C6+73NBEG7UNO2dlFIbWL5hw4Zl+Xz+SsbYoa7rclEUN/tGwiwO8J9RYhGoIvCtEGnOUzT8DgA9/A6ldF2DrObDuq7fEGvrlmW9LgiC6wkhGdd1EST3tUKh8MFegXq6LpfWokhbm0oglUAqgaUogfYAPepZvV7fyfO83wmCAD84kPhyTdM+FAeWIWXN87zvSpIEJrfQvN58wdwOf3u1WiW5XA6sbrgFh4E/U0p/Rwj5P9/3/8UYezSXy21MPj86OpoXBGFIFMXdGWNIcXs+53wVIWT7yIwOtXvGcdA0jZTLZV/TtKtWr1594hFHHAEbfLBx48bnZbPZnzRy1XdCRH6Dhe4Luq6f1itQX4qTI21zswTSo1k6J1IJpBJYvBJoG9BHRka203X9TkrpMwOwtXB+Rjab/UxsYq9Wqx9paLifCdngpglNjwEeLG6O4xiiKK5uAPN1uVzuFkqp1Y2YoGU7jrN7EARv5py/mxCye5w2F78vBnlExeP/4x+krzmO8wdZlo/QNO1JHAg2bNiwcz6f/xVy4aM0u0s1Tft4CurdjEz6TCqBVAKpBFIJzKcE2gJ05Jjruv5by7KeyzkPBEH4VCaT+WQE5uKGDRs+VywWEcHOgyCY7Z3ws3++Xq9/c2hoqNpLVkGAe71eP4Axdirn/I0T7vwwrn3StA8gB7BblkWgrQtUeNxyrNcjfx33VSqV3ZHPTgjZjlJaJ4Scoev6F1NQn2ZapkrrfK7X9FupBFIJpBKYVgKzgS+AkNm2/UPHcd4MwBYE4Yu6rp8cgaRcq9WuURTlCPjLZyGFGSGEfELX9asIIUG/Gdocx3keUtE454fiEIJ+oM2u64bsdbIsh8Cuqiqqta13HOcNxWLxHtyDOAEQ1QRBsFwQhDHP896Yz+fv6k30e6cIGN3f6WPppE8lMC8SSCfmvIg5ZVSfHzEv8a/MCOjQbqvV6oc555dCyaWM3pjP5f8TfQbL2gEHHHBlEAQwc4eacNJ/DV85gNO2bT+fz39t7dq1Z+24445hdPl8yQxtMk3zjZTSLxNCto0APfTtx4CONkeuAJRbfaOu63/CfeVy+SXw6cuyjAPNg47jvHCbbbYxQjnMYx/mS1bpd7ZGCfQKjHv1nq1xDNI+b7kSmP91MSOgR6D2W865SAh5NAiCfQcGBkrQVGu12qWe552squqkZh4DOv4d5Zo/6TjOewuFAljZFqzKWalUGpAk6TJK6btgHYgoZjebR5zzfzuO8woUjYGJ3TTNoxtEON/ww+oy5Ke5XA5+epFSOme62C13Eqc9SyWQSiCVwGYSCNENezFjDKWv4drcidKQnwRlsaEQViilcMM+Rjh/SNW0+yilYdR0erUngWkBnXOeaZQ+vS8IgmegoIkkSQdmMpm/ApgrlcpJmqZ9SZIkblnWlHfAhA2zdr1e/61hGIevXLlydDFotADoer2OeuyXRaLZjHMWB5Eg8P9qGOZLV6xYYYBvXlXVy2VZPooQUmtYG84qFAqXzbc/vdNzHudcN03zlYj+B2Ne5AoJXxMVtMEhbU60t/fdd5+84447vkiW5X0453bDvcFAwYsrNNdQqvi+/0Qmk/lJ94e5mXsev9c0zR0YY6+PDl7hQ4IgiEEQoJDPbyMK4Fn7G7+vUqlgwwE1MZ4X4n61t6R6ehcOy4wxhnKBd6mq+uBs43bOOeewc845JxgdHd1eUZSXc87zeD6ymIXvqtfrvykUCg/P9q5OehLLrlarreCcv5wxNgQPVyKZXhIE4Zeqqj7U5XfDcUX/zjjjjNfatr1rIzDXUlUVQAAXXoYx9ntZlv88e7spmXgk5KLI1uv1VzPGtvN9H9k2s7ohZ39/d3f4vo9GyaIoPqiq6u/aDRSO5Wnb9uGc822xHqPOId5JHR0d/eOKFSvu6R+vRuv+xnOxVqs9jzH2XyhxTSndBwuqVQZU01swNmD7vJtzfhvn/Lv5fP6B7iTb/VOJef0aSukzpnsTCodpmnZjv2UMZlPG2JswT5P7EmLCKKU/bDl50YlarXYeIeTMaHP+YC6X+wo6MzIy8iJFUe4KgkDM5XIUL8KFAUL0OnLTGWM/yuVy72wuyNK9WHv3pGVZr25YGlaDD6dZU58A9AB9+Vk2m30DvooNShTFO0VB3K1m1NbWarV9t9tuu/HFaHpPbqqMse8TQpDSB0CfQNqJcbpC07TjQdtLKUV6XkdX/A0ARaVSuViWZRDzuJxzKcEAGFptMMkrlcopy5Yt+9Zf/vIXab/99tus1n2nh5VkY+ODlWVZB3POb/Y8zxcEgWEOSpLEgiBYyxh7n6qqsBDNalmJi/VUKpVjRFG8EhtjVPEvdst0JKse3Bxbv1AV8ERN074FOUelgFu+Pu5nuVx+ra7rV3qeh0NdXK+Acc7rmqYdSyn9/nRj0k27E7I7kFJ6FWMM2SaYezg4A6iEIAiOymaz17QzFhO4+rR3Lp53aPNuu+22WlXVgz3P83Bwi9JM5Qbz40Wapn3i6TPl9O69GATr9fozOOc3CIKwH+ZPEARCksmyDeDpRlyTzzS5KXFwE13Xva7BXIk9d1M7h+F4LVuWdTeldN84Zgjr0nVdKZvNXvjkk09esMMOO9Tbed+cOjQhfHbDDTeIr3zlK4+UZRnxVnvLskxh6OxEnvF+HGctNep//Mn3/cvy+fwPZ1oDc21/qz2mWq3eyBhDHFkr7pTY6ntoJpO5aWKj7WW499MtMgzjhZyQ/6UTB/1QnpATlGjP8/ZpCejlcnk3Qsh9jYkgG4bxx3w+/xK8EuYSURTv4ZyDKW4SyOPPAfwJId/KZDLvnY+JM+1paRZZ1uv1l4LnHcVhpgF1qwF2H89ms5/H0NRqtYMymcwvy+WyA6DM5/NHt7cp9XJqzf6uhQD0fD5/Qr1edz3Pk0RRTC7YcJIHQfBX0zTfMDw8/GSXmtm0HY8BfXR09OBMJnOz67q+KIoMAZqqquLfay3Let/Q0FBHgF6v148RBAFgOAnos0u/L3fMCdBxKGn0Y3ts8FHrmOd59SAIji0UCn0F9Gw2u3u9XofRBBtPoOu6UKlUjioUCm0C+lR5JgF9r732Wi3L8sGWZXlQLHAw1TRNrlarF+Xz+Y4B3XXdGxob8X6I9/F9fzNA79PeHHYwCeiiKIaAXq/XrzNN84MrV67sCNBN07y7kQocAjrk7vu+m81mpWq1emG5XO47oCcOSdj/z0EJ7BiUY/DpdJUkQD0Ul67riIt6pGFN+ditt95641vf+tY+sXlOtDTeYwDogiC8eYb2Y61uaGjpe1NKEQDelwuATgDolIYAHAM6Dkuu624O6BgU0zRvcl33kIaGDl/x/sVi8S9YUIZhXNXwMx8dmW6nHAaik9f/aJoWdnoxmNlnkqhpmijZ+uvoLDWpwSYmEEhtXpHL5dagVjui83VdPyIIgk2lUumNQ0NDf+gYoPq5M0SUu5A7rArTaegNk9wVmUymJxp6uVy+uFAonGCaZgjoSAlsxdzXcNt8K5vN4hA0o3bZ6QpIAno2m70ZG3IUxMgzeobZjt01oEuidKXjOimgtzkosYY+NjZ2oCRJV80HoNfrdS86WHcN6KCxFgThhmw2u59lWf6E0j+5HXSkUbYpqim3NQO6wATRsq3rqtVqx4BuGMbdqqzs6wV+4HleCOi5XK7vgB7vgxs2bNgTAdBROezJAwusnq0UwHbk1QToRNd1YppmkM1m2fj4+K0o+lUsFh9t513d3BPvMZVK5UZRFGcDdPhwrlqzZs0JrayRU77fJRZ0DOgjIyMHybL8K1mWkVP+ZV3XP4SG1Ov1lwVB8Jtm0pbEBv47TdPgt3UXO5jHgjVNExH7NyTN0skFFgTBXblc7qW4v1qtPldTtb+7novVfqemaS/vpcmym8nW/Eyzhk4pXQU/VNLk3ktAh8kdGjoAHaY9ZA40AXqoYQqCMMI5P1lRlO/10rKRBPRcLnczNmRFUZhlWRwL3rKsmQG9aVHFoNSJhh6fkKcxxU07rLGcZmE2XHIa+qICdEZ5wmrfDKRhTEUM6Llcbj9YFJoBvbmQVKvxwj2Rq64llXUrM3Pze/DfgiAg1kF0HGcaQG+NArHJvVqt3q3r+r6e54WA7nmem8/n+wro8RrctGnTkaqqfqmR1jyYFHRzPzsxuTdbMPDfiqyQag1xc4TDtaYoSo1zflQ+n4cbtedXM6DPss4RswC31iGqqv6i540hBBVNO9PQy+XyzfBP+b5fdhxn52KxOI4JY5omcrTDYizJK+rgJvhudF1/oh+d6Nc7oTFalgUSmk9NgDoVnrZOhl81HMc5aWBg4Nucc81xnNNQtc3zvBHHcd5WLBZv71hL71dnWmjojLFVQRAsJKAD4AP4s13XvbtUKr1uxYoVG3slszkDetNYJAGdMXZlFCSlzDRkmP/YzKHVxUyE7WxaKaB3linSyuTeCw0dPvTY5I4DIUzuSQ29HUDH/YgfSgI7TKDxe2YD9Bj0ouDH0Ideq9U61tA7A/QuVcTEYogP57Va7dOiKJ6M/bTVQaUZL6JgyTWEkH8QQtYhsj0IAsT0aBGh13M8z3suBgJyTI4BfMUIvMZag8yjIDSBc35cLpf7ZkxD3qtttkNADy3TjuMAB59XKBTGetWO+D0dAXqtVtuLMfZ3xhg0g0sbJVEBdmBfOwkVyaZpHMxeh2az2b6cSHotkBZabb5er/+UEPKyViltvu8/cPPNN+8JXw247CmliDTGxF2t6zrS2HpqRp5Lf5sijb8vy/JmgB4EQc9M7m1o6OFJmjEWchRwzq/UNO24bmXWvAX1GtDj9zXiRg4RBOEizvmTQRBI041JvNFgY1EUBUE/iPZHENreyX0vChAE6+CaRnAbXDl4ZxjxhY1phgvZAogIRkzHF9sJ7ksGxS2ED31Raegz8EXEh0q4pxqgcJYois/zPK+GbA2MRzy2Sd9vkkI6jiKnlO4niuKAbdsIxAQNNZixmSiKjzLGUJMCAzzpnmw2IcdjH5mlfUTr+77/C9d1vzw4OFhuJxYp1tDL5fLd2Wx2XjT0eJ4ZhoFg6eNjK+A0h9l4kv8MMVaapv0ySk/bbOonMk1Qs+OVnPNjRVE8yLbt8KDVrCFH6ydWWj6QzWa/1stI81aAPuOCnZgkmB5fVVUVdU56muLcDOhxW1r60E3TvIYQ8o4G3SlC13eDxo2a4fV6HSku2Kg2w0Pf96/O5/PHTJ14cz/9zQXY2n92op22bT/H9/2/hZOSEiE200FIQRDYkiR9Utf1T8OXLsvyhaqqfoBzDiKaV0SpRH3PsW9HoklAD4Lg+6qqropSuSadggsA6CGoR3mmALMPRTXnZ406n20cew3os31vloUc9qdaraJs8I8ScZlh6hmlFBv88aqq/rKXbocWB9SwHYhyTwG9PyRWEZ00DlqeaZq3y5K8yqybcPcInuc5uq7LlmVd8Mgjj5y/5557Ou2A8hznXpixUiqV7s7lcn0H9Hj+joyMnK9p2qlxJgj60AToMZD/oHGw+aSqqv/qpJ+x3EZHR587MDBwvmEYb2SMPR3gMPVAHIP6W3O5HNyoPbm6APTwnB6t+YM0TUNl0p5dk4DOKEu6k1oCumEYb2qkGv13o8jJo3Gkummax4BcZZoWbWyYh56Tz+fH5+43bweyeiaXKS/CBK3X6x9tTMyLmtO8wPduGMZD2Wz2WXhobGxsb0VR/k8URQsap6qqKLM6Z3DqRc+aAV3X9FWu504xufcS0Gu12sXZbLalDz3BwBfB+cQkD4LgT4899tghe+yxx9hspvfZZsRSAXSEeWNNpYDe2yj3uZjc57LemgEdB+darearqhoCOiLuOwH02eb5bG2NNfTx8fG7G77kvgJ6vObK5TJKZn+ZUlqILLqhFSIC9DiN65+NctXHNWKr7pytD7MclsN4B6Sn+r7/1YaWP10+eBjxTik9UNf1P7b7zZnk3yWgx/mW/7Zt+/kgY2u3LbPd15GGHr8s7kRExoJk/l1bfAj86CdmMpmv9/sEOlsne/F7tVpdJgjCXyIylnBe4H8cx4E51ajVascODw9fi9Q9ALksy4cLgvCIqqoguEgBfSIoboIOkPN/c87/jzF2WOKAFGrpCJyrVqtfKxaLJ4CcBhpMt+O3KAA92g3iOZDU0CfCF2iYE+/7/qOc8+Oz2WyqoXexXnrtQ+92zuG5dgDdNM0LHn300XnV0PsN6EnSIkmSfpPL5Z5pmuaUGh6xT9v3/Rsx3/P5fE9SuCKZY+8YFEXxes45ArCbr7A4mCAID3ie99K5fzskIIIlxo+j3BMWiNjq+GtUIEWKHhZ7HByZCB7/gqZpH+mVG6ArQI+lVK1WXyEIwh0RiUpzzvq/VVXdZT4Krcxl8bX7LCbr6aef/i7O+dVRup6Y9Jl5nvebgYGBVyCyfeedd37z4ODgda7rbqpWq+8cGhq6dTZts912zOW+djR0PwiuyPYoba2Fhh5omsYQk+D7/scFQbg38iHBTIb5EyA/3LKsDZZlIdgQi77rw9CiAPRowFoBekSkgUhcBAWmgN7jPPRuNPS5asPNgN7I/rk91tA1VRNcz3VUVZUrlcoFjz/++BYF6HHsi2EYq4MgOLQ5YBCHd/ANVKvVq2zb/vDw8HC118oe1jzGoFwug4sAbI5TLrgYZVlGMN1n1q1bd9Zuu+2G1NOOr3iezKChx5U8f8YYu5wQ8kPf9xHUl7xAqISYjP/Qdf134Q9znICtAD2Oy2iZhx63BgNhmuY3KKXHhO2gU/AcDf1vVVW/3OsB61jyPXwgotX7Kwq5RBGrYaejwIuNkiT9B6grx8bGdmwUpXlUEAQwn10xMDDwobkA0/Rd6Gz02wH0zk3urRm7wBTXAtB9TdMEwzRvzWYyrzVN8zMNLma4MqCFg5kvFCdA3ff9Pzz66KMH77rrrtVzzz2Xgq6006FsBnTbsny5k7S1Tj84w/3x+I+Pjx8uy3LoQ4+icLmu6cyyLeTKphp6D4llugH0Xgx5UkOfAuiKJniB5yiKssUBerzWTNMEvSxcsEhPS2rnoWvP9/0fB0FwTJQd1ZfYIrQFe8Zpp52GNOoDmscUwfFIP6xWq3utWLHivrmM+WyAzjn/RaOg1+vq9fqXfd9/f0TVPAmjEW7+U9O0/XrBSz8zoE/DFIfWRHzg6yml+WZAB6WnoiioXgbO4HmrnjaXgZl4dmaAhAl4l112Oc0PgvMFxkIayERUJWgTP5nNZj+L+vCEkG/m8/k3mqa5JpPJoE78gke79wfQp0o9Sf3aDOiiJPkZXQdn/h26rr8SZWglSfpOwPm+NKKgrdfrXNO0kIfY87yv6Lr+gVlN79MMWysNHcQyjuOEeeiGYax1HKdtprju51domtssKA4aOo7xuVwOZE1LEtDbPVIuNWKZ7sd6qsl9Og29XKlc8MQWpKEntHNUo0Qu9BRNFEDGOX/IcZxXDQ4Oru2noheb30dGRlZkMhn4ymHuDpXOaL8OMw0459fCVYq6HN2O90yAjk+6rvvz0dHRt3iex1esWHE/YwxW68krwkcso4s1TTuzG9N7cg1OZ3KHlm7b9gRTXLVaBWe7Aw7zXC53P/5mGMbr8N8JHt3JUwch5GpN05oi27sV2eJ6zrKsXV3XfUiSJM/3fWzSk2QRKJCh6zpoYxXXdY8SBOEbrus+ZVkWaqmDTW/WAiD97O1CA7okSaHJDZucrusHoa+QDeccaYFIbwxN70jlgaxc133Stu33DQ8P/6wbC8fiAfRwk587oLeLnm1YCtIo9/5Vd5xWQ99CTe4J7fwIzvnXCSEDMS7g0CpJEiyVkm3brykWi7/s5x4Xv/v6668XolRiMFCiPDZovAnop23bRtqhp+u6uH79+uduu+22yHnv6moH0HO53OGUUrtWq72qkcYILvdJ7oqmIMGXtBWsN8M+0Bagl8vl9YSQFZIkfVfXdfiR6fj4+CW6riMPfYogOAh6PP+gXC4Hc8cWd3HOC9VqdbWiKC9DTimYfxKHmg3j4+N7bbvttiOVSmV3RVEesG27ZNv2GcPDwwgODAMoFkoorQDdcZ2+EcvEGnqtVnMFQZDgv8pms+Dsvq1QKLwKIPfYY4+JQ0NDZ+dyuTMqlQoOjTK0c1EUA4EJMEX/Znx8/JDtt98+rPLTicWnHUAPguB9Ufnern317Yxn66C4AO4ans/nQw09DYrrbZQ7uNw9zxMFQeiY+rWdMZ3unukAHSlVMa/8YvGhg/q1VqvNics9jqI3TRNVz6YEo6GgDdL1KKXfrtVqHxoaGqr0UztPjkm85iqVyl2NSn4HxnnqcHXBnw8OB8/zPpfL5T7WTSEqvCTeY0ql0o2SJIXFWaIrdDd4nvdzlNWO31+pVL4my/Jx8J0joLqJRvh+VVVfRCk1u51/MaAna5DEhEahhl4qlXaRZflhfMBxnBOLxeJXoT1VKpU/KoqyXzOge543msvltmlv0HqgcnTb8y6fwySpVCof1DTtc7Ztx9Wcwrdxzsu+778zn8/fZBgGXA5/C4JgIAiCbxQKhRPxLKPUmzgCzX/fJ8aE8VqtugJ56EhbmxHQGXWmo8acaTOLyk5O+tCTgA4N3XXd21RVfdWTTz6pb7vttmalUnmWIAjX6rr+fNM0w4WGVJcoIh7z7rP5fP7UWU3vTY1KAX3zUZqWWGbC29n34iybEct4PmNC/4qzpIAe7kthHnqrKPe5AnpsdYzWMHKqt4sVnCi2yBVFUWpUsNwX5bW73Ha7eixuW7lcfp0kSdcxxrIRgVW4XUf/bNQ07TmU0VKne12ngI72rF+/Xi0UCn8XRTE0vcOCkTwANIrmnJfNZs+dYLTrHCOSgB4HMDQD+ltkWf5hBOgvKBaLqKaWN02zFEUxTomGa5wCflwsFhEY0ZeAh65GtscPjY+PPz+Tydxj23Y4WROvBw3UZzKZzJmVSmXI87zv5XP517qeCx77/+gUkHrc7DCdJi7O0hagz7F8arOGjtN6LpeDyf02XdehoatxnAUWnaqqcOGEpnekl8D0HuVow+fWdpnTyRUSWURQbS3mckeKGPxZ8KHXarW1862hR0FDk8QyqPxWKBRSDb1P1dYWG6BDLwKxzJaiocdZq3WfAAAgAElEQVQHxFKpdFqj+BIqqGmxXxjWSKxlz/MQ9f6efgbCTbdXxvU0fNe/16ibe4rilMI6UNVF3/dflc1mb+tmv51NQ4cPPZ/Phxp6vP9Wq9VXMsZ+LoqikgD08HwA/nnf918MF2037Wmloce005Zl7QNa1zMdxzkf0cf5fD4Hc4BpmjAL/DEqh5oEdG7b9n8PDAx8qW1A7/wQ0k0/e/JMYkCWaar2QN2qF0RRRA8mSBMYJb7n35LJZA4Ga1yj3vAnBgcGT3c9d+0ll1yy89lnnw3zPDTQBQkUXMyA/uijj6rDw8PnqIp6uh/4DrJL4OuC6T2TySCV7XZN0+IKfziZzCrDVhp6CugTvvytwYe+GE3uWyCgxyx0N0uSdHBTthPKSaPOx9sHBwev7ckm3OFL4j2gWq2eBUXLtm05YVUOrYG2bV9aKBQ+3o3ZvRNAjzT6MI6qVCp9nVJ6LPajZJcAvo7j/K1UKh2A+vQddneyOEvS5D4F0CuVyncIIQjwAjvcMwEKhmG8UxTF77TgmQZbz8sHBwfv6rQhS+n+0dHRPOhJKaUHJ/jdQwtHEAQP6rr+bJi5KpXKEblc7hrHcdY7jrMqn88/GJMvLER/FwugW5Z1m6ZpoYYOHvLYNGZZ1rMopZDr81AFDoUwoopJ4EHHYfHTxWLxjHYtHSmgd2Byn7h1/k3ufa6Hnmro/TO5x7EC5557bvChD33oHwMDA7ujkmHCn4hUU8+27T2KxeIjbSt5Pdwc429GDJ6/EUWxmDRz43dFVv53vDT+GuTFd/rp2QCdc/5z1PRIHhZi0/vAwMDfBUHYBQVlEKxnWVaY9YK6Dw1r5lnZbPbCTovJzKqhVyqVOwRBeAWlNEw1igD9U6IofiyuHpUQQuD7/rJcLjfWjgbVqfAWy/2PP/64tnLlys+g0hpjLA4qiwF93U033bQTIiwty3qVLMu/bMQebISpdXBw8HcLGem+WAE9OrmG7oBKpXKoIAiroUVGla3w95Aq0vf9xzzPQw7r7XEa1ExzIgX0RQzomezudauOQxu8KgFiKyo9JpZJNfSJ8e+XDz3ey0ql0n6SJP2PKIqIG8JJHBbL0NzeIE35VRAER+ZyuU0LAehR/8OUYcMwHmOMoYDWZNEj3/c9TdUFs24M5/P50U4xpktAD/e6Uqn0almWf0opVSRRIo47ESQXFfJBsa8XDA4O/r2TNs0K6MijJoQ8mxDyA13Xj8QgVqvVb8qy/O4WgD6WyWSGFmrgOun4lHs7NPvDb7Rx48b/Hh4e/qzjOKEfJllgxLbtA3AiXbdu3fNXrlx5j+M4I6ihPTAwsDpOp+i6rW0+2KpLSwHQYXpfuXLlOYqinO44Tmh6b0rt+KWqqjC9h0EtMx0cU0DvDNA5Dk2eVw+C4NhCofD92P/Y5pSb8bZZ89A1XahUt/wo98Vucg84p6wNd1YElGHWjmmab3Uc56uodS6KYlxNDLEwKPV6SS6XQ5BXx+bjXsy7qJ2hm6lULv1YkZU3xeVs8Zvv+66malLdqu+Ry+VQrrWjqxtAj9oUmt4bwdNX+L5/LA5BoL2O0+oa8QgA9r888cQTB3ZCfz0roBuGsYkQgqj1L2SzWdS0RTDRjyRJelMzoKN0aGRu3gIC4mZG+dHR0bcV8oVrPT/MgQgBHYDJGButVquv32abbRBj8AwU3bAsa9y27Y8ODAx8cyFT1xYzoCcnOUzvhBBEpYamdxD4JOI1YAW6MJfLnTWb6T0F9M4APTW5d7SXT3vzTGlrMaCXKpUL1i0CYpm5RLnHAXGWZaGi2jmSJOkIOPU8D/ugSylFqupxuq5f1RuLbYeaVzRCCdC9RBCEU2RZDmm7gV8TGromVqqVwwYHB8GH0dHVLaDH+93dd9+t7rrrrv+QZXknpNOhTYqiEATLwvQuMvFUJrJL25VfO4BeI4RkGtScF2YymU9EgH6bJEmvaOFD/5Ou6y9echp6R0M4cXO5XH490tOQupYEdLDkua77ZuThm6a5g+/7axljtcYJ7Nx8Pv/ZdkzF0zenuwkdv2+xA3o0ycPD4NjY2KGZTGY1fHAA9JjrPTLz/ct13ffk8/nfznRA6j2gdy//ePNLo9zHDpQk6apsNrt7vZ6a3OezfGqv09ZidjjTNC/mnJ8C8hhkPgGYkPuPgDjP8w7OZrO3dLHFTvtIp6sw3gfK5fJJoih+VhRFFdgVFUoJq+CBMS6Xy13dqc96joAe7nXIwpEkCdzzSO9L9pvDSskY2wfxV+3IcFZAr1arYPmBBnoOTCeRyf1/ZVl+YQtAj9ORtgANfWbxlUqlgwqFwq+QuoaJDA0dqVacc5TCOzKTydxsmub2vu8/EqViXZDP5y/qhvGsnYFs556lBOiIDWlUajq7kdb2McZYyPWOU7VpmsHQ0BCsRLdeeumlh5x9Nm5pbXrvJaB3uok0j0cK6HeIq1at8jbLQ0996PNWD71fgG4YxhcJISdFNb6hXcJ0bGuapjTW6QH5fP4P7exP/bonkY/+TlmWEV2ux9gFl0EE6B/KZrOXd0r8NRdAb7JKXmnb9nslSZqSNYYsKtd1f7dmzZpV++23H7BmxmtWQK9UKsdFdJx/ymazf4s09DslSTqwBaDfqev6y7cGDX18fPzlxWLx10lAR7+DIAC5zLsadYdXxxo6IaTWOPmB5/3zc9PQZxvOmX9fCoDeNMl355zfEATBXgg+hKaOaHdMelhGcrncBYIgnDud6X1isTF/dHSkZR56tVZby+eZKS7V0FMNHXnoi4XLfS4m93jdwQ9MCAFOhFzpAHRJkkJAL5VK+w4MDPx1ITEhBnTTNN8CxjpYnIFdsCYAwMFkZxjGGZlMBqbtkEau3WuugB5bJR988MHstttue68oijslvw0XBkDd9/3/zmazX2plem/F5T5t2loLTSPUjiRJOqgFoP9Z1/UXLeTgtTsQc72vUqm8IZfL/bTZ5B4EwXgQBG/J5XJ3mKa5o+/7/4aF3vf9j0UsewtG/7pUAD1pejcMAzXTEUEbRr1H/smwIlsjffLhRsGHdxQKhT+1Mr33UkOf63xJNfQeaugtzCXx3EYg35577bVakeWD0yj3iVnbxyj3OHocXOknxCACk3sM6JVK5SWFQgEFUhbsigG9Xq+/g3OOw0fI6w6LX6yhV6vVk/P5/JfnW0NP7nVPPfXUa3K5HLjeJ8nKIl8/r9frKLs7q+l9Vg29eRSQR33qqaf+BPVu8VuSi5YQ8kAjP/s5WwGg03K5fGQ+n7+mGdBd1x21bfvg4eHhv4yPj+9ULBYfq9Vq457npUFxEVNccx56q5UezyHOuVatVs/XNf0jjuvAPBmWWVVVNfA8j9m2vRpV7aIUGZTtnSScSfjODs7omZuRJgUiB2j5uq6nTHGieKUgCNs3qgTGjrulmYdO4e+aYEEEoO+1117wRy4AoE+cNNoJitsSmOISPvRPN1yNJwdBEAIRQEiSpNCH7rpu1yxsvToBxPuAYRjHU0o/TynVYgrYIAh81KmvGbXjCoXCN+fTh57sX7zfGYaBAMKjGUMQ/EThr8jXj9vvUFX1NTNZEToGdHy4XC5fpSjK0fHgJRpm6LoOvtwt2ocOs/n+++9/kqIolzUDuiAIm+r1+oGFQuEhy7LCAi2NogRjrut+YHBw8AdbXZR7JnNCzTCmFGdpB9CjuRWmdlSr1eeKongd53zPOL8VmzcmPefcbvC+n60oyiXNpvctD9Dn6sl/uupbkiku4DwI38w5Djt9TVurVCoHUko3C4rTNA31qY8q9LAeeqqh91dDj9Maa7Uaipuc5fs+gDJcl6iwhih3UL5qmgYz94JdCUA/v5E+dzraFbPFxVHu1Vr1LQMDAzd22shemNzjbwI3YXpfsWLFvbqu7xQxZU7+HBGXnaDrOuIAWjJldgXotVrtzAYbxHlg3EHeXOJCStHKbDa7qd0w+04FuBjuh9ZYqVQ+qygKCq6E9IFxHnq9Xn8SBW123nlna3R09DWDg4O31Gq1jZ7nvXVgYOA3cyOWmduGvhAm90wmc4LRJaAnzVEjIyOH5/P5HzHKPNux4bagoIUVRRFVi9ZUKpV3LFu2DL66SZfGlgfoc5/9yeIsjLErZVkONfTIfbYggC4IAlwobQD69PM/aXJfOA19EkDRUMxDL1kPHdXWFnseeifKWBwPVKvV3hEEwZcFQSiiemAjroUKghBn/5wry/JFKB8699nb3RviOV+r1b7PGPuvuOgT3pYA9OcPDAz8rdMvzAbolNKfq6o6hSluum/Esi+Xy4dQSuFmhEtjsjx3hDEmpXRPTdMea/UeAHoQBP8Ltqb49ynUr7VaDb5yfCCXy+WOj5jiQDBzDZLfm/zoMIO+AulEnQpmKd0/NjZWyGazNzDKXu16Lsy8k8LjnD+A6j2gNa3VakcjctI0zXX1ev3FQ0NDT6KfC3XYgSI2UW2t1l61tR4UZ9F1/QTTNEMNHYcfaGK2bU+hfp1p7ONJjspsy5cvP58xdoplWa7neWGKDMBAURSQHd2Yz+ffkjS9p4C+uWRnAnQcNoMg6LuGLoriVZqmTaatRWOI1KEJDT3gImUdByctApP71gXoMUkWrC6SJN2gKMpKwzBiQA8ZNBljq+v1+nvBwtbJYaGXeJBwDSD1C/TSkyCJ+rq6pot1qw6GU3CudHT1EtCTCsy6deu+OTg4+J7IfTOlTZzzW3Vdf10rf/+sgF6pVD4my/KF9Xqdj4yMFHfbbbfK6OjoSzRN+wOS35vD7B3HOb1YLH5moQZvsudzU2ZbDmrcp2q1Oqyp2n1+4G+DVLW4OEs0IDfpun4oKtI1ZHa27/unMMYey2QyO8cTq60ZM5f2T/NsJxp6wLnM5gjotm1fLAriCXWr3jWgRzINTe+2bT8XXO9BEOzpum4Y9Q5mKpj4CCF1zvmZuq5/Lja9twJ0aPQLXW2NEDKl2hrqodfr9UcZY8erqvrLfqY2JgGdUnqlqqrbQz3HPAZblWEYnq7rx+bz+W93NF+bJnXzFEzUg18lSdKViqI807Ks8LsYW1mSBcu2jspms9d00//pNHTXdcN66GFkebl8UbFY/ERMAtWvg/VmPnRFXVUzauC4ndTQt4Qo96if9KmnntIYY38dHh7eDTiBAYVsAZyU0hHDMF40MDDw2EJgQgyI9Xp9B0opyrcORntKyASG+aer+t9LldJLUau9rb05cVO8x1QqlRtFUZxSDz3q7+Ya+ix7e2x632677e4jhOyYULbDpkd4c0zDLI+8+Smm9xjQ4wDFSOkJFe+w2trY2NjrFEX5Gf5gmuaBy5cv/z3nXK9UKuMSVPSo0ljcR9/3f4KC7gsxeJ0ORrf3G4YB7uI/gzYwGZFICHE555fpun5auVwelCTpakVRDjNN8w+5XO6A2ZjNum1Pu891AuhxZGy7747vSwSz5QHojLETkNoHDR0WLqSIOI7Ttobe/F6kfTHGftQAbxyuoQGEZVajCXw/TGqKotwXaephFGu5XJ4MiltUgE4JcR2XLwSg12q1VwVBAEDfKQZ0RCdnMhlqWdaJmUzmq3MB9OZ5E4M0uPobmtzXBSasdFwniOdLNC5H6rqOOJOQqrOtuRdtjosa0FV1Va2WAHRNlyvVygWPd8QU1/0Jv19R7hifhx56SNltt91szvntKEAVB5tFYO4ITJAN0zikUCj8oq3x7OVNE8GSoQvO9/2TbNv+LKVUTVRbC8szW5Z1eaFQOKUbt0BXgD5LHxOm99cSQn4mJmu+RkYgQojR2Af3aja9zwroIyMj2ymK8kRUJP3EXC6HhQ4T512SJO0fCicx13zfH8lmsytQhaxfJ+Bejnmn78JmU6/XTxZF8TPwv0SbT/gaznm5QfX67kwm8z+GYayklP5JUZRtDdO4Jp/Lv7uX3Nidtjtpztnc5I4YgImDHtI6MpkMXCthWcTZvzN1o+k3oOMwaRjGBaIofrhRnjZ5oApPro3KTjcUi8W3YlzQ9qhU6OIEdJwA3XkH9HCDq1QqL+WcX5nRM8/yA9/H4QjzGeZHyujHBEG4uJcH0PhwALO6JEmXB0GA4NmQ0Rc+V/AMeJ73Nl3XcVhrH9CjCbqkAH3e6qFPRt2Ha7nXxDLRfhGmrm3cuPF8SZJO0zQNWSjhWmSMxfXGr6xWqx9etmxZbb4VvXjPrVQqqLT2stjcjnmH9iEUp16vHz4wMPDj2fe6KVAX75fxempfQ2/jQ7GcKpXKtymlR8WKc1Jb55zflMlkDkvibLlcfmGjCuj/xm7gzTR0fBt87r7vb0MI+XY+nw/t+q7rfsbzvI80t822bZiWXl8oFLqj++v+INqGmOZ+C+e8UK/X/0dgwssDHkDDgDk4Lkiw3jTN5wwODpYNw3g+pfQe3/dLnPPT8/n8FQsZ4T4zoBOYArsE9KkybQZ0SukJjuOEGjqARBIlwfXcjjX0qP2TUe/gepckaU/45eGrwyYCDukgCIxGyszHdV3/YlyeddFq6AsI6JifnucB0PeNAT0IAheBOJzzr+i6/gHM7dkK4LS7ouIDYr1eP7MRRHo+rAJRVS4uyzLjnCO188hsNvuLbsiXthRAb739zW1T7KeGHgf5btq0ab9MJvNTxhiUuRjQQ6u27/uB67rPLRQK4I3oLgOqCxHEpao3bdq0r6Iot6uqWoAVKtpL0EZY9mxd13eklHZcaS16T18APd6vCSGFWq12LyFke/wtAeihuwCV7AqFwg/iddgWoJdKJQQ8/CfnfKOu68vx8FNPPfVqTdNuFQQhtumH70SUIyHkqlwud1zXg9fuLrEA99m2/Rzf9/+B012sBcbNoJT+TlXV/0AUfBAE76OUXua67nrUiEca20LLYyFM7r0E9OShZHx8/HBoc0EQYIWGXO+R6ZiJongvY+ytSBnEM7Va7WBRFG+Oa3V25UPvYkNJTs8kscwC+9DDQxFoiV3XBaC/1g+gHHsiNHRFUUTTNG8qFovHUEo3zi0rY/KQmIz6/gal9FhYV5C3jDFBhLtt22sEQXhPI9inJUnQbEt9SwH02frZze/9BHS0JxGz8kfLsl6U8POGFrIgCGAtu1jTNFRds7rpQzfPJNw8P5Jl+fCwbKrvT5RpjCOEOf8WAne7bVc/TO4J5WqypLQkST9GzFDMcBdjre/7Y6g3v3z58qfwtxjQYx86ItynRLnjpvHx8aNVVUWlMOI4zguKxeI9mCRI0eKcDzULm1JaMgxjx2222QaUpy3z5boZoIV+BhN3l112Oa0xiMhnjDXDuFmYqOc16A4vgv9cFMVv6rr+xtHR0Xu32WabvbvxR84RQzYT15YE6DC927Z9QWMOTzG9J6qyXavr+tt7BuhznHyLCNAnNaRSqXRlNpM9xg/8MGsAByJBEJC6tk6SJKz5ngToxZveyMjIszOZzNWEkJcgngIHMdd1QzO/WTdvFkXx/bqur+3mELFVAXqHG0O/AT2e2yMjIydkMplPE0KyCVDHksRYwwoDLf6vSRftHJfVtI/HcwhZWqIoIgi1EGdkRQxxobmdc/5iHCK7bUc/AT2pwNTr9e8EQfBOaOVJLd11XZrP528477zz/uucc84J2gL0arW6TBTF9RBSo/73mcVi8VNYQJZlXYHayc3CQJCS4zgfKRQKly20VtrtQLV6DnJolI0Fnz3MSriSRPo4Ib1Y07R/m6a5neM4DzHGRFSW0jTthG78gt20faa1viUAejTJJ03vjLEbGGPPjQEiAejVRs4vTO9fRiCWLMur56ShdzMYiWcWC6BH8gv9nqVS6YxsJnsRNHTf98WoSpYnorKGbX8in89f2It5Gx9mK5XKsZIkgSZUiTd813WdTCYjG4ZxaT6f/2hyE+tE5FsVoHcimD5SvyY1SRzObrjhBn7ooYf+nRCC9Zi03MbKz69d1z0in8+PdIILHZ5fwmYBaO+//35h1113vYcQskccrBeB+UT+Lue3GYbx5uHhYewVXV39BvR4PTz22GOF7bff/l7HcULTe3xBYQbXO2PsCFEUf1gqlfZjjIFqN0ylbqmh44d6vf5nnLAIIX/XdX0f/K1arb6SMXZb0+CFdn7XdR/J5XK7bynBcRi4SqXyflmWsSHFpAlJ2f5S07TXQIvfYYcd3pbP57/DOR91HOe9qqqujnM2u5o1PXpoSwH05KZvmuZbGWOonR6WWY3SCMOod0rpfVbdeqkkSy8QRfFXSxLQu9nNZpkvidS1gxtpa1dyzreDdg4qXUEQfEVWBLNu/r4RDHusoihr5hL7EfsxEc9g2zZS0t6SWD/cdd2QVKZer7+rUCh8t9sDRAro0w96vzX0aD2GgYzIkGi4HC+Blt5gcMT5GmyOuCXcMymln1EU5ewGY1t98xb3ZrLHc2j9+vXXDgwMvC2Oao//jXZG7tKX6rp+11y21/kA9Lh9hmEcQghBzfYw5im2OAC0HccZFUVxD8/zdmgL0E3TRGT35z3Pw2YJQSB9DXzYf2WM7Z04McT/F/edrOv6lzo5jc1FuP18tlarLaeU/rmRuxufkELtXNM0UiqVEIh1Qjab/W6lUhmilF6fzWZfOT4+/uDg4OCzu92ket2fLRHQN2zYkCkWixdJkvRBFyHjnMeFDeJAxUtN0/xJoVD4rWGavhTloWeyWWbUamsR64AAzn6P0SLT0EMLR6lUGtAA6IQcHsUihJkBYPmCT73BAnmOoigomdx1QaFYOx8bGztBUZQvwmqVUADCNEbbtv/i+/4x2Wz2791+a94AvQ3MQVvaY4p74vw999xj3sqnjo2P313I5/fFHo7Dm+d57lyqrTXvT3FEuWEYd+m6HlbjdJynE2UApDBz+76PaPjLYCXqwx4XztVyufxlRVHej3FIpKmFOBiZ/7+naRrinMy5tGG+AD2e36Zp4tD7jtg63ETs9r0gCLDGfh+Dfssod3T40UcfLW6zzTbrwNfLGEO0+9GR2f3oIAiuagHo+NOm9evX7/bMZz6zspR96diUIrrbTzb7zmGm9DwvBG50eGx8bK+B4sDfDcMwfN//fKFQOCsJFm3sB3OZXzM+uyUB+oRWEDBKGQhn9ooIZ8DQNxn1Hk36hx3HuUfTtNc3MjMy0Bq6Coqb06iAmSoINRjk0S9kUFzcjRhoLcuCO+jyUJWi4RkV/xPn9YPd67iGRe7H3Rx4EsQ+LwTNbCaT2RtZMPFmg1QqSqncCKQ9W9O08yIg7IpJcd4AvY150D6gP37+nnvuOW+A3o+0taQ4Yr+14zgvNE1ztaqqKxIusLC0ahwk1zhQnJfNZkEJ27MguWi+cZRzdRznPcjfnqBKmaysNpEnScg4IWS/6ehT2xjiyVvmC9CjPtBSqVQQRfE+xth2SS090ebzG8kzIE8KTe7TAjp+rFQq3yGEHKUoirFhw4Yddtppp3FEdNdqtX9F6QrhoCUubBJX4iTUfy29f1BZrVb3IIQgchq87VPI60VRBFXmqaqqfgXaoizLZw0MDJxeq9UQcwAa3H920/d+9GZLA/R4kuOwWK1W3yYIwrURIUkY9R4v5KhgRPgvzE9oKNlsdsGqrS0SQJ+MdscaJYSAxCLpSgqB13Gch3VdP0aSpDs7SSeLXUylUmlnWZavliUZaZ7wesQpkuH7KaVrGkyK75Fluavo9sQBpSX166Jgimsmlpm3PPQJ6cyHyT0xDuHBtVKpfLxxuD5LlmU1tshEgA5Tcch7EATBTz3PO3FoaOiJTkC0+d54X1u/fv0zMpnMtzzPezksp7Ish7XZE1fMG3KYqqowXc/5mk9AjxtbqVQOEwQBhWTCqPemKz6Mh3+eDdAPlGX5rojeL6RRhDBN0zyGEPINvKAJ0DGZfNu23zQ4OIg6r0vuAm87AqoopS+L4gEmedvRGUmS/vmpT33qOYgwtCxrV8dx7ofWkc1mb6WUvrab6PZ+CWlLBnQcpvL5PE78H0R6N4Ym4TObKEHIWIjyKaBPzLBEtayjKKXfEARBSWpUmO9RkYcNlUrlw8PDw9e2E4Eeb3Ku677M87zLVVXdA77ySqXCsNFGBZ1Csz6l9COg623nvVPWRdOJN9XQp9815hPQowNECOqGYXybMfau+GAdAzrWJaxkWJOc8zFVVc99/PHHrwDjXKd7H+bNr3/9a3nPPfc8qVGs6ZOKouTjXPNcLkdQsSy6QqroRq2C0zOZzOfaZiKcpUHtAzpzYvKuTvuYvD+e55VK5buCIISm9xagPvnIjICOu0ql0q9lWX657/s1y7KeNTw8DE1Usizr7iAI9trsuBAEGLwnZVneT9f1DUvJ9A5aw+XLl58jCMIZcRR104HFqFarxy9fvvx7GzduzEqSdGGxWPygZVkjoigeIUnSrzveqOYy2rNPvlCLma/iLKB+7XUeeqsuJlJU9hIE4XpCCNwfoQYYRbVO1hRuR0Pvk3VkUZnco012wsY+YeH4vKIoJyMXHcFLsZwTAA9T5Q8aVqqzVFX9VyurUzwOqHXQMKWeQSmFjzKZwoTqVkRRlPDA1eB0QEnck6LCHaHFoNvpv7QAXZMrlWqH1K/dSmZ+NfTEvArHs16v39SwvrwOwBqnW8U1vjEXMPfAFOi67kOCIFzNGPuOruvrZuptPNaWZe3SKIb1X5xz1DnfYZq9Afjjy7Ii+L73JdBy98HMD+bFnjLFzdZ/RL0PDQ3d1ziIh6b36a5ZAX18fPxliqL8BoQylNIvyLL8YbwMpUJ1Xb8lIpaZtLvjhZIoEddz/zIyMvKy7bff3poJ1PuxmXa7FEZHR5EKcL0oikm/3+TrfN+/JZfLHRz1fw/4NmRZhqZ+88DAwBsWmuq1ud/NGrqqqqsw2WOfZrQYO6R+nfqV+BsoTjMF0EVBomRuTHEzTvKAU8ooN03zbZTSayPzMQAdh5jNAD2TyTDDMBY8KA6aSi6Xm7fiLC3mRLjx4pAniuIVhBAUFpoE9URAURxk6HPOUWbyds75w0EQlKHJc7Bb0nwAABCXSURBVM5znPNnSJIESlnkmYem1lD40RUdrnwBYbmE/M3zvPciL7nbQLhWmgvWXLJ8ampynwrouWwOzIBhUBxqUWSzWcQHXVguly/YYYcdUOCoOya3pokVxRGwc889lx9//PHXDwwMvEUUROBAeCfmAgAdU6F5jhFC/kEIgQsG1dE2MMYQuIZEjFwEYLtSSl/aYC7dOXatTU6zKTRnIbWyr2u6UK1VL4VFuRu+9lnANcEUJ7054XGOwlLaL5+62XdmAcNKpfJGzvmNyVKpze8A/ka07bBW7DPFIR4NBMjsb/I8DyH0lmVZzxseHn4QA1gul78uSdJxyTS2BKAjze3Hy5YtO7xXk6ZboG7nuVKp9BpBEG5GEFUS8BL70yZBEHC4eQDaeaFQ+IrjOO+SJGnj2NjYIdtuuy3Id+akdbTTzk7uSQI65/z7jYPZvAA6omkppSh36ouCKDiuc1sjXeRVMTVrJ32Y7t7EQSJbr9dhev9AVCwnrCkcmtwngnLCnaERhLWoAN2yrEcppX2vtjaNFhNuSrC4BUEAJje4l8KDXiy32NKRLD0Zb8RJk19TZagpLjgcHJD/6/v+Y/Cba5r2m16AebQvbeZDt23bcxxn4autLSIf+nwBeuIQF84tWIBEUTwpWcyqOZ2sk33g6X14etTDdxs0w4JhGB8dHBz8Qq/M7E0Hyb5Rv85ykAjne7VaRY33t89kdoeLC7+3BHR8BNy4siz/WZIkZtv2XcViEaT3OJHkGlG8IBZ4RrIxSF1AgIKu6wisu64RKHZkrziiO5kE7d6LwhWCINzCGINPEcmUk49GEwk5lGdEfOEoVPP6XC63GnW/GyQn12ua9s62o4Ln0STRDOiyLK9ClFK/NHTXdS/mnJ8wH4AeHzajMqt7+b4/aXrHom4GdFVVmWma/dHQW4zpdGlrvu9zWAts254fQJ9mvsWHz3q9vhMh5GuEEFieQr9jrElNKNZP57+2A+gA+Oi+cJ4pinJ/rVZ7b6FQmFMQXAtLw6IEdMuybsfBOa62hsh+FDCpVDqtttbu7rX5fUkfeiaT2Re0p9DQwd0PDb1cLl9YrVZ7qqE/vWE+XfHM87y3eJ6HGgvbxvMoeUCM/9Z8KGzV8+ZYraZ7Yj19bePw+J5cLndH99Kb+cn2fejtFLrqrJXYz6vV6iD4NhprNiY72+wlWLdYw67rbq6hx6fher2O0pinVatVrmnaKdls9jL8BjCklN4RBAHL6BnquE54So9P+AhYkCTpJw3CirdBg1psPnWYMQRBuA4aZcQmNEVAUYWo67LZbEgrCk5smIdEUVzped6/gyB4SSaTCXl1p+vbPGJ4c9snfejQ0AHoiDiNS41Gbb5C07QOqq1NnT/NJncAOni7EWcB0pJ+aegJjSA+uU5GvUf9S1qbUH+b1a16fwC9xbpsBeiRL5Hrug4GxvkB9Bn2jMTYabZtgyXuZByEkN4PP6eiKOHGkNQGmjWD5s0Y2oFpmr6macg3v85xnFOGh4dBGd1T61XSh/6sZz1rNVxh0NAjAhEkQ6MK2EWaps1rPXTP9W4nhKyyncl0vbA2e6lUumDdunXzmraGOCfG2PwCejTf4pREQkjRtu1PEUKOBZd/xE4Y3oWIdIDPxBxqsp3PgnUJgEccBv65zDCM8+bCAtcOvC4koMftq1arSIW9IU5VizA6/BlyiU3u0wJ69AC4tP8qy/KzKpVKzXXdFwwPD4cpWtVq9RhZlr8hSRJ3HGdqHtvT2u6fG7z+/wnu5nYE1+97MDD1ev0E3/e/BOBJaq3Jb7uu+7exsbH9d955Zwum9lwu93XG2JEonep53knZbPZ7vTIj9rrPzRq6JEmoXzwF0JHD2Qh07Amg12q1UEMXRXHeAR1jgzxXQRA+0KJufYD627ZtLzigY+dSZIW5nrvggJ44FMUpbQcSQj7ted4BiJkBqEeRyZNTcxZABwsc5PwAKg42tMPV0YM9P9P2B9C7a2YyDx2A7npueHBmjOFQ4xQKBbnhCrjgoYcemhbQu/ty6x0j1tA3btx4d6FQ2BeABw0dGKqqqmQYRs996NPtXYmAtmc1SpEj2PjtnuepOCjOrJnPDPCR8mRTSr/FOb+oJa70UqhPH1QWxOTeLF+Y3iHLxBqeBPQY4D3Pa62hxw+Zpnmg7/u/1VSN2o695sknn3zJbrvtVonqpV8ERiBVVaeMRBNrz8YgCN6Nkon98au3N4KIymWMXS4Iwn/Cv5o86TQJ7hFN0w6ilP4boF2tVt8ty/JVoB31PO+HKAbStqm912idfN/0ZtVQe0Uqnqqqx4ADPaopjsUdHrwcx7mzUChc00nOcfLT8Tg+/vjj2rJly94siuJrXdc1okNOIDIx53jO3bquf74XKX2tuhprf+VyeVfG2IdEUZzkDo/XoSAIsud5T/m+f00ul7u/1xpj8/DG70fZUsYYGKzCtB1ciqLIqMrHGPueoij/6Hdb2p168Vi6rnug67of9DwPZvhCssJiC0CP1zvcUncJgvDFhx9++NZ+E6jEbUX++2GHHXZSvV5/kaqq1Qi4EOQ3wDm/Pp/P/6Rfh4qEXOF/xFpD2dBTXNeFVlxF4ZswSEvX85s2bbp+zZo1P1+1atVEPc8+XvFaLpVKn9A0bXfOuRmVrsUhIxsEwY26rv+sH8xtswF7pVJBWW7sE9g794+CKTuRhkEIATPatbZj/2hwYBBBmvN2JTI73i+K4vOjfTQs6BbRT9+rKMpX++G/T3YSckRZ4hC7OD7OJzb0hIbemH/nbRYU17x5VyqVcxog+Mkw+E2SVqPCGO7BJDrggAOu9n3/nTPZT+BDlGX5GhRzyWazI52a4NuD7NbjC57p00477U0wzzRKvu4giii+M8E93LxRcc6fCILgtblcDhGYKFP3WkrpL2BSbORa/qvBjLTvwMAASP6xkreYCnPztjLm40MdTJYObp2Pli/oN5KHtEKhgOIP+zcyCZAauDwIgoGocVWUVxYE4Z9Icbdt5/eDgwPl/hzUF1Qc6cf7JIE77rhDffGLX7xfI3Ib1SkRyQ53ZoEQko+yVqAYlBhjj3POH6GU/p+qaXcz2nv/dJ+6uOCvnRHQ0bqoAhvK070JKWtBEFyYyWTOjH4TTNNEgM2xEcht9r6EqWUUJwxN05A6M2NqWy+kAk2pkSP7Wc75K+P0mmSIf1ydB9+CJsc5P7RQKMBNgPrazwuC4E5CSE4QhDFK6WG6rv9usWhWvZBP+o5UAqkEUgm0JYH09NuWmBbDTbMCegTcecuyfh8EwR4wWTfyWM8Ea1cM6rVa7XMwfTbnpUa/N/dzQ6PW9aeDIPguyuz1UggAXMuykKp1KmMMVJeT7oA4cC8iO5gMzmgQ4T/kuu5h+Xz+gUgz3xU5uBGRQVUURXBdX7cYqqn1Ulbpu1IJTCeBdP9O50YqgaUpgbYAHV0rlUq7MMZ+SwhZGUUZop7yxRFogx72+IYfC7mAYMufQjbRLJrI3G03yrWCLvZ7vu/fMTAwUOpYhDR0VFLX9fYG4UgQBEcIggC/KmeMTelbHCUZR/GiDb7v/8nzvEOXL1++CRaG9evX75HJZH5GCEFqj9Uo1XlusVhE4FfX1ag67lP6wAwS6DHU9Ph16dDNXQKLYUgWQxvmLsn0DVujBNoGdAinUqkg4OI38K0xxhDxc04ul4OjPrzK5fJLGqVWbxQEATlz4bubguTC+2L/deI3BI78JQiCuxhjawgha1zXBaF/eWhoqBK9R/7nP/+ZX7Zs2XaCIIBBCCQZCLI4UBAEBL1NUCBF/vHpCDDANW2apjc2Nvb1crl8yh577BGm1o2MjLxoYGDgZ4ZhIIgDZQC/ksvlTl4yYJ7uQlvj+k373BcJpIupL2JNX9p3CXQE6GhNtVpFCUsk8i8HXsuy/JMHH3zwqH322QfRiPh9mSAIl9m2/XYEoTVrytNo69N2NCa7iG+Ahp0Mq49z8JooBiff10xQ4Pv+esuy3jc8PHxTHNBTLpdfLEnS7b7v65qqOa7nXqJp2ieXDJj3fZosxQ8stk15sbVnKY5p2uZUAqkEZpJAx4CeAHUA4jOhEbuue3cmk3mTruuTZfJc1z2oXq9/DSbwuQxBi+puHb0u8Ty07m+WSqUzV6xYEfru42j1Rm72tg061z8ODQ0NBUHwcZDopGDekZh7cHMKeD0QYvqKVAKpBLZiCXQF6JBXqVQaUBTle5ZlHZLJZBApPo5SiZqmXZ1gpNINwziRUvrRSKPfTNSzUPzNOjStTPrJhwDalNJbkDOfzWbvbZVmg7+Zpvk83/dfkM/nr0yj2WcV+ww3pMA8F+kttWfT0V5qI7ZE25tOtLYGrmtAx9tBHFKtVi+WZfkU0EY2ctZRC/mnpmm+H/SPcQsaUe0A9hMopScTQpB7OHFxQujU2LW2Gp28KU6Liw8GCYB3KaPX8YB/Lqr4FLnYuWqa5qt93/9DFGWfTpWOpb40HkgHdmmM05bSynS+bSkjuXT7MSdAj7sdcc1eHgTBchRp4ZyPNwpeXfLII498ee+99zZj0zbM2IZhHEQIOZpSCoIaNVl+cVoxTrNSwBMMAIcfHQQwEQ/7Pb7v/wBlUXVdB0HBZLlAwzBe6Ps+ige8WJblr2madmJqWl+6kzdteSqBVAKpBFIJPC2BngA6XgcTvCRJn6WUvtdxnDAYznXdjYqiXJzJZC4H62iSYY1znjFNE1XcXtWgkMQ/e0zHrz7TgPm+/ySi40VRvLPBSX1roVB4qNmsDqKYBuif4/s+6suGbHGSJD1Uq9X2HR4eRi3elP1tK1wVqUa1dAe9p2PX05ctXZmmLV/6EugZoMeisCzr9ZzzS0BCI0kSMQyDaJoGJrarbdu+slgsPtJKbA3CfcUwjN0ZY8+JCtsPUErBz1yMABfpa14QBBsZY/8mhPyLc/6viKR/syUZuQMOkSQJhUhQ2x0XtHWHc/7VtWvXnrX77rvXUhrXpT+J0x6kEtgaJJCeO5b4KM/DAPYc0CHyiC72yIZJ/BxCyC4om4cLVc4YY0h5Q/nSW3tdiQ2ad71eh1n9aM75mwVBWI5CEw2CGGpZliOK4reDILi4WCziMDBpiu94mszDwHTcpj49sBV1tU8STF+bSiCVQFsSSDebtsQ00019AfT4gyjrZ1nW213XfR/n/ACUW03UzUU6+T8opTejjq8kSfdls9kH2q1ag/esXbu26HlesMsuu4QVeFABLJ/Pf1UUxXfj7yihGQRBSVEUpKt9ddmyZQ/PCcjnLO70BakEUgmkEkglsPVIYH5PKX0F9OSgVavVPRhjJzRA/K2EkOHI/h0WaMcF9rhGDrjDGHuYUrqRcz5KCEFBl1KjIIxMKdUJIVIjqG2wkU++oyiKuzqOgzq7nxwcHAQ9a/iier3+X5RS1I69pUGCc10QBNcvX758MjBv65lIaU9TCaQSSCWwdUpgfmG0lYwXpgXzBugJrZ0ahrE3pfQNCIjzff+lbOIKA96RhjbbFfGwE9Ri55xfq2nakXG0esN/r61bt25o++23B8nNwkh1tg6kv6cSSCWQSiCVwFYlgafBqH+wNO+A3jyCyFE3TXMPx3H2lCRpz6gO8yDnHJr4UKPgC4LjUCcXjviaKIp1z/PWIijOdd1/EULuKRaLv5rRlN4/+W1VEzLtbCqBVAKpBFIJLF4J/D/xclRhztyp5QAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", FO = ({
  walletConnected: r,
  walletAddress: e,
  wagmiConfig: i,
  walletHooks: n,
  onClose: s,
  isOpen: a,
  onCreatePlayer: o
}) => {
  r && (e || r.account && r.account.address);
  const l = () => {
    o && o();
  };
  return /* @__PURE__ */ P.jsxs(
    "div",
    {
      style: {
        backgroundColor: "#101020",
        color: "#fff",
        padding: "20px",
        textAlign: "center",
        border: "4px solid #0078D4",
        borderRadius: "5px",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ P.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "0",
              left: "0",
              width: "100%",
              height: "4px",
              backgroundColor: "#0078D4"
            }
          }
        ),
        /* @__PURE__ */ P.jsx(
          "div",
          {
            style: {
              position: "absolute",
              bottom: "0",
              left: "0",
              width: "100%",
              height: "4px",
              backgroundColor: "#0078D4"
            }
          }
        ),
        /* @__PURE__ */ P.jsx(
          "img",
          {
            src: w2,
            alt: "Intuition Logo",
            style: { width: "200px", marginBottom: "10px", marginTop: "20px" }
          }
        ),
        /* @__PURE__ */ P.jsx(
          "h2",
          {
            style: {
              fontSize: "1.2em",
              margin: "0 0 20px 0",
              color: "#FFD32A"
              // Couleur orange pour le texte BOSS FIGHTERS
            },
            children: "BOSS FIGHTERS COMMUNITY PLAYER MAP"
          }
        ),
        /* @__PURE__ */ P.jsxs("div", { style: { maxWidth: "80%", margin: "0 auto" }, children: [
          /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "At first, there was nothing. And then, suddenly, the whole community appeared !" }),
          /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Everything of which the Boss Fighters community would one day be composed, would be born in an instant." }),
          /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "A single species of condensed matter, exploding in a vast universe." }),
          /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Although energy would neither be created nor destroyed, the interaction between these newly-created atoms would continue to create something beautiful..." }),
          /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "What had been separate would become whole again. And what would be created in the process would be even more beautiful than what came before..." }),
          /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Our story begins with the atom. The cornerstone of our ecosystem." }),
          /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: 'And our "atoms" start with you !' }),
          /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Every contribution will help build our ecosystem and make it healthy..." })
        ] }),
        /* @__PURE__ */ P.jsxs(
          "div",
          {
            style: {
              border: "1px solid #FFD32A",
              borderRadius: "10px",
              padding: "15px",
              margin: "20px 0",
              display: "inline-block",
              backgroundColor: "rgba(0, 0, 0, 0.3)",
              width: "80%",
              maxWidth: "700px"
            },
            children: [
              /* @__PURE__ */ P.jsx(
                "p",
                {
                  style: { fontSize: "0.9em", margin: "0 0 10px 0", textAlign: "left" },
                  children: 'Claims in Intuition, also referred to as "Triples" structured in Semantic Triple format :'
                }
              ),
              /* @__PURE__ */ P.jsx(
                "p",
                {
                  style: { fontSize: "0.9em", margin: "0 0 10px 0", textAlign: "left" },
                  children: "[Subject] ⇒ [Predicate] ⇒ [Object] (For example, a triple could be : [SciFi] [is] [strong Boss])"
                }
              ),
              /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.9em", margin: "0", textAlign: "left" }, children: "This keeps our attestations tidy !" })
            ]
          }
        ),
        /* @__PURE__ */ P.jsx(
          "button",
          {
            onClick: l,
            style: {
              marginTop: "20px",
              marginBottom: "20px",
              padding: "10px 20px",
              backgroundColor: "#FFD32A",
              color: "#000",
              border: "none",
              cursor: "pointer",
              borderRadius: "5px",
              fontSize: "1em",
              fontWeight: "bold"
            },
            children: "CREATE YOUR PLAYER"
          }
        )
      ]
    }
  );
};
function BO(r, e) {
  const i = r.exec(e);
  return i == null ? void 0 : i.groups;
}
const ST = /^tuple(?<array>(\[(\d*)\])*)$/;
function Lv(r) {
  let e = r.type;
  if (ST.test(r.type) && "components" in r) {
    e = "(";
    const i = r.components.length;
    for (let s = 0; s < i; s++) {
      const a = r.components[s];
      e += Lv(a), s < i - 1 && (e += ", ");
    }
    const n = BO(ST, r.type);
    return e += `)${(n == null ? void 0 : n.array) ?? ""}`, Lv({
      ...r,
      type: e
    });
  }
  return "indexed" in r && r.indexed && (e = `${e} indexed`), r.name ? `${e} ${r.name}` : e;
}
function Zc(r) {
  let e = "";
  const i = r.length;
  for (let n = 0; n < i; n++) {
    const s = r[n];
    e += Lv(s), n !== i - 1 && (e += ", ");
  }
  return e;
}
function zO(r) {
  var e;
  return r.type === "function" ? `function ${r.name}(${Zc(r.inputs)})${r.stateMutability && r.stateMutability !== "nonpayable" ? ` ${r.stateMutability}` : ""}${(e = r.outputs) != null && e.length ? ` returns (${Zc(r.outputs)})` : ""}` : r.type === "event" ? `event ${r.name}(${Zc(r.inputs)})` : r.type === "error" ? `error ${r.name}(${Zc(r.inputs)})` : r.type === "constructor" ? `constructor(${Zc(r.inputs)})${r.stateMutability === "payable" ? " payable" : ""}` : r.type === "fallback" ? `fallback() external${r.stateMutability === "payable" ? " payable" : ""}` : "receive() external payable";
}
function u_(r, { strict: e = !0 } = {}) {
  return !r || typeof r != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(r) : r.startsWith("0x");
}
function wT(r) {
  return u_(r, { strict: !1 }) ? Math.ceil((r.length - 2) / 2) : r.length;
}
const E2 = "2.37.7";
let Qc = {
  getDocsUrl: ({ docsBaseUrl: r, docsPath: e = "", docsSlug: i }) => e ? `${r ?? "https://viem.sh"}${e}${i ? `#${i}` : ""}` : void 0,
  version: `viem@${E2}`
};
class Tn extends Error {
  constructor(e, i = {}) {
    var l;
    const n = (() => {
      var u;
      return i.cause instanceof Tn ? i.cause.details : (u = i.cause) != null && u.message ? i.cause.message : i.details;
    })(), s = i.cause instanceof Tn && i.cause.docsPath || i.docsPath, a = (l = Qc.getDocsUrl) == null ? void 0 : l.call(Qc, { ...i, docsPath: s }), o = [
      e || "An error occurred.",
      "",
      ...i.metaMessages ? [...i.metaMessages, ""] : [],
      ...a ? [`Docs: ${a}`] : [],
      ...n ? [`Details: ${n}`] : [],
      ...Qc.version ? [`Version: ${Qc.version}`] : []
    ].join(`
`);
    super(o, i.cause ? { cause: i.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = n, this.docsPath = s, this.metaMessages = i.metaMessages, this.name = i.name ?? this.name, this.shortMessage = e, this.version = E2;
  }
  walk(e) {
    return M2(this, e);
  }
}
function M2(r, e) {
  return e != null && e(r) ? r : r && typeof r == "object" && "cause" in r && r.cause !== void 0 ? M2(r.cause, e) : e ? null : r;
}
class jO extends Tn {
  constructor({ expectedLength: e, givenLength: i }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${i}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class VO extends Tn {
  constructor({ expectedSize: e, givenSize: i }) {
    super(`Expected bytes${e}, got bytes${i}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class GO extends Tn {
  constructor(e) {
    super(`Type "${e}" is not supported for packed encoding.`, {
      name: "UnsupportedPackedAbiType"
    });
  }
}
class A2 extends Tn {
  constructor({ size: e, targetSize: i, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${i}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
function oa(r, { dir: e, size: i = 32 } = {}) {
  return typeof r == "string" ? HO(r, { dir: e, size: i }) : WO(r, { dir: e, size: i });
}
function HO(r, { dir: e, size: i = 32 } = {}) {
  if (i === null)
    return r;
  const n = r.replace("0x", "");
  if (n.length > i * 2)
    throw new A2({
      size: Math.ceil(n.length / 2),
      targetSize: i,
      type: "hex"
    });
  return `0x${n[e === "right" ? "padEnd" : "padStart"](i * 2, "0")}`;
}
function WO(r, { dir: e, size: i = 32 } = {}) {
  if (i === null)
    return r;
  if (r.length > i)
    throw new A2({
      size: r.length,
      targetSize: i,
      type: "bytes"
    });
  const n = new Uint8Array(i);
  for (let s = 0; s < i; s++) {
    const a = e === "right";
    n[a ? s : i - s - 1] = r[a ? s : r.length - s - 1];
  }
  return n;
}
class qO extends Tn {
  constructor({ max: e, min: i, signed: n, size: s, value: a }) {
    super(`Number "${a}" is not in safe ${s ? `${s * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${i} to ${e})` : `(above ${i})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class XO extends Tn {
  constructor({ givenSize: e, maxSize: i }) {
    super(`Size cannot exceed ${i} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function Fd(r, { size: e }) {
  if (wT(r) > e)
    throw new XO({
      givenSize: wT(r),
      maxSize: e
    });
}
const $O = /* @__PURE__ */ Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function C2(r, e = {}) {
  return typeof r == "number" || typeof r == "bigint" ? c_(r, e) : typeof r == "string" ? P2(r, e) : typeof r == "boolean" ? R2(r, e) : N2(r, e);
}
function R2(r, e = {}) {
  const i = `0x${Number(r)}`;
  return typeof e.size == "number" ? (Fd(i, { size: e.size }), oa(i, { size: e.size })) : i;
}
function N2(r, e = {}) {
  let i = "";
  for (let s = 0; s < r.length; s++)
    i += $O[r[s]];
  const n = `0x${i}`;
  return typeof e.size == "number" ? (Fd(n, { size: e.size }), oa(n, { dir: "right", size: e.size })) : n;
}
function c_(r, e = {}) {
  const { signed: i, size: n } = e, s = BigInt(r);
  let a;
  n ? i ? a = (1n << BigInt(n) * 8n - 1n) - 1n : a = 2n ** (BigInt(n) * 8n) - 1n : typeof r == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof a == "bigint" && i ? -a - 1n : 0;
  if (a && s > a || s < o) {
    const u = typeof r == "bigint" ? "n" : "";
    throw new qO({
      max: a ? `${a}${u}` : void 0,
      min: `${o}${u}`,
      signed: i,
      size: n,
      value: `${r}${u}`
    });
  }
  const l = `0x${(i && s < 0 ? (1n << BigInt(n * 8)) + BigInt(s) : s).toString(16)}`;
  return n ? oa(l, { size: n }) : l;
}
const YO = /* @__PURE__ */ new TextEncoder();
function P2(r, e = {}) {
  const i = YO.encode(r);
  return N2(i, e);
}
const KO = /* @__PURE__ */ new TextEncoder();
function I2(r, e = {}) {
  return typeof r == "number" || typeof r == "bigint" ? QO(r, e) : typeof r == "boolean" ? ZO(r, e) : u_(r) ? O2(r, e) : D2(r, e);
}
function ZO(r, e = {}) {
  const i = new Uint8Array(1);
  return i[0] = Number(r), typeof e.size == "number" ? (Fd(i, { size: e.size }), oa(i, { size: e.size })) : i;
}
const Ms = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function ET(r) {
  if (r >= Ms.zero && r <= Ms.nine)
    return r - Ms.zero;
  if (r >= Ms.A && r <= Ms.F)
    return r - (Ms.A - 10);
  if (r >= Ms.a && r <= Ms.f)
    return r - (Ms.a - 10);
}
function O2(r, e = {}) {
  let i = r;
  e.size && (Fd(i, { size: e.size }), i = oa(i, { dir: "right", size: e.size }));
  let n = i.slice(2);
  n.length % 2 && (n = `0${n}`);
  const s = n.length / 2, a = new Uint8Array(s);
  for (let o = 0, l = 0; o < s; o++) {
    const u = ET(n.charCodeAt(l++)), c = ET(n.charCodeAt(l++));
    if (u === void 0 || c === void 0)
      throw new Tn(`Invalid byte sequence ("${n[l - 2]}${n[l - 1]}" in "${n}").`);
    a[o] = u * 16 + c;
  }
  return a;
}
function QO(r, e) {
  const i = c_(r, e);
  return O2(i);
}
function D2(r, e = {}) {
  const i = KO.encode(r);
  return typeof e.size == "number" ? (Fd(i, { size: e.size }), oa(i, { dir: "right", size: e.size })) : i;
}
const lp = /* @__PURE__ */ BigInt(2 ** 32 - 1), MT = /* @__PURE__ */ BigInt(32);
function JO(r, e = !1) {
  return e ? { h: Number(r & lp), l: Number(r >> MT & lp) } : { h: Number(r >> MT & lp) | 0, l: Number(r & lp) | 0 };
}
function eD(r, e = !1) {
  const i = r.length;
  let n = new Uint32Array(i), s = new Uint32Array(i);
  for (let a = 0; a < i; a++) {
    const { h: o, l } = JO(r[a], e);
    [n[a], s[a]] = [o, l];
  }
  return [n, s];
}
const tD = (r, e, i) => r << i | e >>> 32 - i, iD = (r, e, i) => e << i | r >>> 32 - i, rD = (r, e, i) => e << i - 32 | r >>> 64 - i, nD = (r, e, i) => r << i - 32 | e >>> 64 - i;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function sD(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function AT(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error("positive integer expected, got " + r);
}
function ym(r, ...e) {
  if (!sD(r))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function CT(r, e = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function aD(r, e) {
  ym(r);
  const i = e.outputLen;
  if (r.length < i)
    throw new Error("digestInto() expects output buffer of length at least " + i);
}
function oD(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function L2(...r) {
  for (let e = 0; e < r.length; e++)
    r[e].fill(0);
}
const lD = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function uD(r) {
  return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255;
}
function cD(r) {
  for (let e = 0; e < r.length; e++)
    r[e] = uD(r[e]);
  return r;
}
const RT = lD ? (r) => r : cD;
function hD(r) {
  if (typeof r != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function k2(r) {
  return typeof r == "string" && (r = hD(r)), ym(r), r;
}
class dD {
}
function pD(r) {
  const e = (n) => r().update(k2(n)).digest(), i = r();
  return e.outputLen = i.outputLen, e.blockLen = i.blockLen, e.create = () => r(), e;
}
const fD = BigInt(0), Jc = BigInt(1), mD = BigInt(2), gD = BigInt(7), yD = BigInt(256), vD = BigInt(113), U2 = [], F2 = [], B2 = [];
for (let r = 0, e = Jc, i = 1, n = 0; r < 24; r++) {
  [i, n] = [n, (2 * i + 3 * n) % 5], U2.push(2 * (5 * n + i)), F2.push((r + 1) * (r + 2) / 2 % 64);
  let s = fD;
  for (let a = 0; a < 7; a++)
    e = (e << Jc ^ (e >> gD) * vD) % yD, e & mD && (s ^= Jc << (Jc << /* @__PURE__ */ BigInt(a)) - Jc);
  B2.push(s);
}
const z2 = eD(B2, !0), bD = z2[0], xD = z2[1], NT = (r, e, i) => i > 32 ? rD(r, e, i) : tD(r, e, i), PT = (r, e, i) => i > 32 ? nD(r, e, i) : iD(r, e, i);
function _D(r, e = 24) {
  const i = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      i[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const l = (o + 8) % 10, u = (o + 2) % 10, c = i[u], h = i[u + 1], d = NT(c, h, 1) ^ i[l], p = PT(c, h, 1) ^ i[l + 1];
      for (let f = 0; f < 50; f += 10)
        r[o + f] ^= d, r[o + f + 1] ^= p;
    }
    let s = r[2], a = r[3];
    for (let o = 0; o < 24; o++) {
      const l = F2[o], u = NT(s, a, l), c = PT(s, a, l), h = U2[o];
      s = r[h], a = r[h + 1], r[h] = u, r[h + 1] = c;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let l = 0; l < 10; l++)
        i[l] = r[o + l];
      for (let l = 0; l < 10; l++)
        r[o + l] ^= ~i[(l + 2) % 10] & i[(l + 4) % 10];
    }
    r[0] ^= bD[n], r[1] ^= xD[n];
  }
  L2(i);
}
class h_ extends dD {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, i, n, s = !1, a = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = i, this.outputLen = n, this.enableXOF = s, this.rounds = a, AT(n), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = oD(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    RT(this.state32), _D(this.state32, this.rounds), RT(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    CT(this), e = k2(e), ym(e);
    const { blockLen: i, state: n } = this, s = e.length;
    for (let a = 0; a < s; ) {
      const o = Math.min(i - this.pos, s - a);
      for (let l = 0; l < o; l++)
        n[this.pos++] ^= e[a++];
      this.pos === i && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: i, pos: n, blockLen: s } = this;
    e[n] ^= i, i & 128 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    CT(this, !1), ym(e), this.finish();
    const i = this.state, { blockLen: n } = this;
    for (let s = 0, a = e.length; s < a; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, a - s);
      e.set(i.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return AT(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (aD(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, L2(this.state);
  }
  _cloneInto(e) {
    const { blockLen: i, suffix: n, outputLen: s, rounds: a, enableXOF: o } = this;
    return e || (e = new h_(i, n, s, o, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = n, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const TD = (r, e, i) => pD(() => new h_(e, r, i)), SD = TD(1, 136, 256 / 8);
function d_(r, e) {
  const i = e || "hex", n = SD(u_(r, { strict: !1 }) ? I2(r) : r);
  return i === "bytes" ? n : C2(n);
}
const wD = (r) => d_(I2(r));
function ED(r) {
  return wD(r);
}
function MD(r) {
  let e = !0, i = "", n = 0, s = "", a = !1;
  for (let o = 0; o < r.length; o++) {
    const l = r[o];
    if (["(", ")", ","].includes(l) && (e = !0), l === "(" && n++, l === ")" && n--, !!e) {
      if (n === 0) {
        if (l === " " && ["event", "function", ""].includes(s))
          s = "";
        else if (s += l, l === ")") {
          a = !0;
          break;
        }
        continue;
      }
      if (l === " ") {
        r[o - 1] !== "," && i !== "," && i !== ",(" && (i = "", e = !1);
        continue;
      }
      s += l, i += l;
    }
  }
  if (!a)
    throw new Tn("Unable to normalize signature.");
  return s;
}
const AD = (r) => {
  const e = typeof r == "string" ? r : zO(r);
  return MD(e);
};
function CD(r) {
  return ED(AD(r));
}
const RD = CD;
class ND extends Tn {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class j2 extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const i = super.get(e);
    return super.has(e) && i !== void 0 && (this.delete(e), super.set(e, i)), i;
  }
  set(e, i) {
    if (super.set(e, i), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
const sy = /* @__PURE__ */ new j2(8192);
function PD(r, e) {
  if (sy.has(`${r}.${e}`))
    return sy.get(`${r}.${e}`);
  const i = r.substring(2).toLowerCase(), n = d_(D2(i), "bytes"), s = i.split("");
  for (let o = 0; o < 40; o += 2)
    n[o >> 1] >> 4 >= 8 && s[o] && (s[o] = s[o].toUpperCase()), (n[o >> 1] & 15) >= 8 && s[o + 1] && (s[o + 1] = s[o + 1].toUpperCase());
  const a = `0x${s.join("")}`;
  return sy.set(`${r}.${e}`, a), a;
}
const ID = /^0x[a-fA-F0-9]{40}$/, ay = /* @__PURE__ */ new j2(8192);
function OD(r, e) {
  const { strict: i = !0 } = {}, n = `${r}.${i}`;
  if (ay.has(n))
    return ay.get(n);
  const s = ID.test(r) ? r.toLowerCase() === r ? !0 : i ? PD(r) === r : !0 : !1;
  return ay.set(n, s), s;
}
function V2(r) {
  return `0x${r.reduce((e, i) => e + i.replace("0x", ""), "")}`;
}
const DD = /^(.*)\[([0-9]*)\]$/, LD = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, kD = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function UD(r, e) {
  if (r.length !== e.length)
    throw new jO({
      expectedLength: r.length,
      givenLength: e.length
    });
  const i = [];
  for (let n = 0; n < r.length; n++) {
    const s = r[n], a = e[n];
    i.push(G2(s, a));
  }
  return V2(i);
}
function G2(r, e, i = !1) {
  if (r === "address") {
    const o = e;
    if (!OD(o))
      throw new ND({ address: o });
    return oa(o.toLowerCase(), {
      size: i ? 32 : null
    });
  }
  if (r === "string")
    return P2(e);
  if (r === "bytes")
    return e;
  if (r === "bool")
    return oa(R2(e), { size: i ? 32 : 1 });
  const n = r.match(kD);
  if (n) {
    const [o, l, u = "256"] = n, c = Number.parseInt(u, 10) / 8;
    return c_(e, {
      size: i ? 32 : c,
      signed: l === "int"
    });
  }
  const s = r.match(LD);
  if (s) {
    const [o, l] = s;
    if (Number.parseInt(l, 10) !== (e.length - 2) / 2)
      throw new VO({
        expectedSize: Number.parseInt(l, 10),
        givenSize: (e.length - 2) / 2
      });
    return oa(e, { dir: "right", size: i ? 32 : null });
  }
  const a = r.match(DD);
  if (a && Array.isArray(e)) {
    const [o, l] = a, u = [];
    for (let c = 0; c < e.length; c++)
      u.push(G2(l, e[c], !0));
    return u.length === 0 ? "0x" : V2(u);
  }
  throw new GO(r);
}
const oo = "0xB92EA1B47E4ABD0a520E9138BB59dBd1bC6C475B", FD = 13579, oy = BigInt("10000000000000000"), IT = BigInt("10000000000000000"), ju = [
  {
    type: "function",
    name: "BURN_ADDRESS",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "CONTROLLER_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "COUNTER_SALT",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "DEFAULT_ADMIN_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "MAX_BATCH_SIZE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "MIGRATOR_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "ONE_SHARE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "_maxRedeem",
    inputs: [
      {
        name: "sender",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "accumulatedAtomWalletDepositFees",
    inputs: [
      {
        name: "atomWallet",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "accumulatedFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "accumulatedProtocolFees",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "accumulatedFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "approve",
    inputs: [
      {
        name: "sender",
        type: "address",
        internalType: "address"
      },
      {
        name: "approvalType",
        type: "uint8",
        internalType: "enum IMultiVault.ApprovalTypes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "atom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "atomConfig",
    inputs: [],
    outputs: [
      {
        name: "atomCreationProtocolFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomWalletDepositFee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "atomDepositFractionAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "batchSetAtomData",
    inputs: [
      {
        name: "creators",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "atomDataArray",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetTripleData",
    inputs: [
      {
        name: "creators",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "tripleAtomIds",
        type: "bytes32[3][]",
        internalType: "bytes32[3][]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetUserBalances",
    inputs: [
      {
        name: "params",
        type: "tuple",
        internalType: "struct MultiVaultMigrationMode.BatchSetUserBalancesParams",
        components: [
          {
            name: "termIds",
            type: "bytes32[]",
            internalType: "bytes32[]"
          },
          {
            name: "bondingCurveId",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "user",
            type: "address",
            internalType: "address"
          },
          {
            name: "userBalances",
            type: "uint256[]",
            internalType: "uint256[]"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetVaultTotals",
    inputs: [
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "bondingCurveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "vaultTotals",
        type: "tuple[]",
        internalType: "struct MultiVaultMigrationMode.VaultTotals[]",
        components: [
          {
            name: "totalAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalShares",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "bondingCurveConfig",
    inputs: [],
    outputs: [
      {
        name: "registry",
        type: "address",
        internalType: "address"
      },
      {
        name: "defaultCurveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "calculateAtomId",
    inputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "id",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "calculateCounterTripleId",
    inputs: [
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "calculateTripleId",
    inputs: [
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "claimAtomWalletDepositFees",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "computeAtomWalletAddr",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "convertToAssets",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "bondingCurveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "convertToShares",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "createAtoms",
    inputs: [
      {
        name: "data",
        type: "bytes[]",
        internalType: "bytes[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "createTriples",
    inputs: [
      {
        name: "subjectIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "predicateIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "objectIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "currentEpoch",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "currentSharePrice",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "deposit",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minShares",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "depositBatch",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "curveIds",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "minShares",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "entryFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "exitFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "generalConfig",
    inputs: [],
    outputs: [
      {
        name: "admin",
        type: "address",
        internalType: "address"
      },
      {
        name: "protocolMultisig",
        type: "address",
        internalType: "address"
      },
      {
        name: "feeDenominator",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "trustBonding",
        type: "address",
        internalType: "address"
      },
      {
        name: "minDeposit",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minShare",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomDataMaxLength",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "decimalPrecision",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomCreationCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomWarden",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getBondingCurveConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getCounterIdFromTripleId",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "getDefaultCurveId",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getGeneralConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleAdmin",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getShares",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTotalUtilizationForEpoch",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTriple",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleIdFromCounterId",
    inputs: [
      {
        name: "counterId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserUtilizationForEpoch",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVault",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultFees",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultType",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint8",
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getWalletConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "hasRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      {
        name: "_generalConfig",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_atomConfig",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_tripleConfig",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_walletConfig",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      },
      {
        name: "_vaultFees",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_bondingCurveConfig",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "isAtom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isCounterTriple",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTermCreated",
    inputs: [
      {
        name: "id",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTriple",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "lastActiveEpoch",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "pause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "paused",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "personalUtilization",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "utilizationAmount",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewAtomCreate",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFixedFees",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewDeposit",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewRedeem",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewTripleCreate",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFixedFees",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "protocolFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "redeem",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minAssets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "redeemBatch",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "curveIds",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "shares",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "minAssets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "received",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "renounceRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "callerConfirmation",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setAtomConfig",
    inputs: [
      {
        name: "_atomConfig",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setBondingCurveConfig",
    inputs: [
      {
        name: "_bondingCurveConfig",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setGeneralConfig",
    inputs: [
      {
        name: "_generalConfig",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setTermCount",
    inputs: [
      {
        name: "_termCount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setTripleConfig",
    inputs: [
      {
        name: "_tripleConfig",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setVaultFees",
    inputs: [
      {
        name: "_vaultFees",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setWalletConfig",
    inputs: [
      {
        name: "_walletConfig",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [
      {
        name: "interfaceId",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "totalTermsCreated",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "totalUtilization",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "utilizationAmount",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "triple",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "tripleConfig",
    inputs: [],
    outputs: [
      {
        name: "tripleCreationProtocolFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "totalAtomDepositsOnTripleCreation",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomDepositFractionForTriple",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "unpause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "vaultFees",
    inputs: [],
    outputs: [
      {
        name: "entryFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "exitFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "protocolFee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "walletConfig",
    inputs: [],
    outputs: [
      {
        name: "permit2",
        type: "address",
        internalType: "contract IPermit2"
      },
      {
        name: "entryPoint",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWarden",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWalletBeacon",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWalletFactory",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "ApprovalTypeUpdated",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "approvalType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.ApprovalTypes"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomCreated",
    inputs: [
      {
        name: "creator",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "atomData",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      },
      {
        name: "atomWallet",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomDepositFractionDeposited",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomWalletDepositFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomWalletDepositFeesClaimed",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "atomWalletOwner",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "feesClaimed",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ConfigSynced",
    inputs: [
      {
        name: "caller",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Deposited",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "EntryFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ExitFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Initialized",
    inputs: [
      {
        name: "version",
        type: "uint64",
        indexed: !1,
        internalType: "uint64"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Paused",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "PersonalUtilizationAdded",
    inputs: [
      {
        name: "user",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueAdded",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "personalUtilization",
        type: "int256",
        indexed: !1,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "PersonalUtilizationRemoved",
    inputs: [
      {
        name: "user",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueRemoved",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "personalUtilization",
        type: "int256",
        indexed: !1,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ProtocolFeeAccrued",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ProtocolFeeTransferred",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "destination",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Redeemed",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "fees",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleAdminChanged",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "previousAdminRole",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "newAdminRole",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleGranted",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleRevoked",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "SharePriceChanged",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sharePrice",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalAssets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "SharesPullApproval",
    inputs: [
      {
        name: "accountFrom",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "accountTo",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "status",
        type: "bool",
        indexed: !1,
        internalType: "bool"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TermCountSet",
    inputs: [
      {
        name: "termCount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TokensRecovered",
    inputs: [
      {
        name: "token",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "recipient",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TotalUtilizationAdded",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueAdded",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "totalUtilization",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TotalUtilizationRemoved",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueRemoved",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "totalUtilization",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TripleCreated",
    inputs: [
      {
        name: "creator",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "subjectId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Unpaused",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WalletMigrated",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "oldWallet",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "newWallet",
        type: "address",
        indexed: !1,
        internalType: "address"
      },
      {
        name: "sharesMigrated",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WrappedERC20Registered",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "wrappedERC20",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WrapperTransfer",
    inputs: [
      {
        name: "from",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "to",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "error",
    name: "AccessControlBadConfirmation",
    inputs: []
  },
  {
    type: "error",
    name: "AccessControlUnauthorizedAccount",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      },
      {
        name: "neededRole",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "AtomDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "EnforcedPause",
    inputs: []
  },
  {
    type: "error",
    name: "ExpectedPause",
    inputs: []
  },
  {
    type: "error",
    name: "FailedCall",
    inputs: []
  },
  {
    type: "error",
    name: "InsufficientBalance",
    inputs: [
      {
        name: "balance",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "needed",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "InvalidInitialization",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ActionExceedsMaxAssets",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ArraysNotSameLength",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_AtomDataTooLong",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_AtomDoesNotExist",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_AtomExists",
    inputs: [
      {
        name: "atomData",
        type: "bytes",
        internalType: "bytes"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_BurnFromZeroAddress",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_BurnInsufficientBalance",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_CannotApproveOrRevokeSelf",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_DepositBelowMinimumDeposit",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_DepositOrRedeemZeroShares",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_EmptyArray",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientAssets",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientBalance",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientRemainingSharesInVault",
    inputs: [
      {
        name: "remainingShares",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_InsufficientSharesInVault",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InvalidArrayLength",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InvalidBondingCurveId",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_NoAtomDataProvided",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_OnlyAssociatedAtomWallet",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_RedeemerNotApproved",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_SenderNotApproved",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_SlippageExceeded",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_TermDoesNotExist",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_TripleExists",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_ZeroAddress",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ZeroValue",
    inputs: []
  },
  {
    type: "error",
    name: "NotInitializing",
    inputs: []
  },
  {
    type: "error",
    name: "ReentrancyGuardReentrantCall",
    inputs: []
  },
  {
    type: "error",
    name: "TermDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "TripleDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  }
];
function H2(r, e) {
  return function() {
    return r.apply(e, arguments);
  };
}
const { toString: BD } = Object.prototype, { getPrototypeOf: p_ } = Object, { iterator: lg, toStringTag: W2 } = Symbol, ug = /* @__PURE__ */ ((r) => (e) => {
  const i = BD.call(e);
  return r[i] || (r[i] = i.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), es = (r) => (r = r.toLowerCase(), (e) => ug(e) === r), cg = (r) => (e) => typeof e === r, { isArray: Pc } = Array, cc = cg("undefined");
function Bd(r) {
  return r !== null && !cc(r) && r.constructor !== null && !cc(r.constructor) && zr(r.constructor.isBuffer) && r.constructor.isBuffer(r);
}
const q2 = es("ArrayBuffer");
function zD(r) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(r) : e = r && r.buffer && q2(r.buffer), e;
}
const jD = cg("string"), zr = cg("function"), X2 = cg("number"), zd = (r) => r !== null && typeof r == "object", VD = (r) => r === !0 || r === !1, Bf = (r) => {
  if (ug(r) !== "object")
    return !1;
  const e = p_(r);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(W2 in r) && !(lg in r);
}, GD = (r) => {
  if (!zd(r) || Bd(r))
    return !1;
  try {
    return Object.keys(r).length === 0 && Object.getPrototypeOf(r) === Object.prototype;
  } catch {
    return !1;
  }
}, HD = es("Date"), WD = es("File"), qD = es("Blob"), XD = es("FileList"), $D = (r) => zd(r) && zr(r.pipe), YD = (r) => {
  let e;
  return r && (typeof FormData == "function" && r instanceof FormData || zr(r.append) && ((e = ug(r)) === "formdata" || // detect form-data instance
  e === "object" && zr(r.toString) && r.toString() === "[object FormData]"));
}, KD = es("URLSearchParams"), [ZD, QD, JD, eL] = ["ReadableStream", "Request", "Response", "Headers"].map(es), tL = (r) => r.trim ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function jd(r, e, { allOwnKeys: i = !1 } = {}) {
  if (r === null || typeof r > "u")
    return;
  let n, s;
  if (typeof r != "object" && (r = [r]), Pc(r))
    for (n = 0, s = r.length; n < s; n++)
      e.call(null, r[n], n, r);
  else {
    if (Bd(r))
      return;
    const a = i ? Object.getOwnPropertyNames(r) : Object.keys(r), o = a.length;
    let l;
    for (n = 0; n < o; n++)
      l = a[n], e.call(null, r[l], l, r);
  }
}
function $2(r, e) {
  if (Bd(r))
    return null;
  e = e.toLowerCase();
  const i = Object.keys(r);
  let n = i.length, s;
  for (; n-- > 0; )
    if (s = i[n], e === s.toLowerCase())
      return s;
  return null;
}
const tl = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, Y2 = (r) => !cc(r) && r !== tl;
function kv() {
  const { caseless: r, skipUndefined: e } = Y2(this) && this || {}, i = {}, n = (s, a) => {
    const o = r && $2(i, a) || a;
    Bf(i[o]) && Bf(s) ? i[o] = kv(i[o], s) : Bf(s) ? i[o] = kv({}, s) : Pc(s) ? i[o] = s.slice() : (!e || !cc(s)) && (i[o] = s);
  };
  for (let s = 0, a = arguments.length; s < a; s++)
    arguments[s] && jd(arguments[s], n);
  return i;
}
const iL = (r, e, i, { allOwnKeys: n } = {}) => (jd(e, (s, a) => {
  i && zr(s) ? r[a] = H2(s, i) : r[a] = s;
}, { allOwnKeys: n }), r), rL = (r) => (r.charCodeAt(0) === 65279 && (r = r.slice(1)), r), nL = (r, e, i, n) => {
  r.prototype = Object.create(e.prototype, n), r.prototype.constructor = r, Object.defineProperty(r, "super", {
    value: e.prototype
  }), i && Object.assign(r.prototype, i);
}, sL = (r, e, i, n) => {
  let s, a, o;
  const l = {};
  if (e = e || {}, r == null) return e;
  do {
    for (s = Object.getOwnPropertyNames(r), a = s.length; a-- > 0; )
      o = s[a], (!n || n(o, r, e)) && !l[o] && (e[o] = r[o], l[o] = !0);
    r = i !== !1 && p_(r);
  } while (r && (!i || i(r, e)) && r !== Object.prototype);
  return e;
}, aL = (r, e, i) => {
  r = String(r), (i === void 0 || i > r.length) && (i = r.length), i -= e.length;
  const n = r.indexOf(e, i);
  return n !== -1 && n === i;
}, oL = (r) => {
  if (!r) return null;
  if (Pc(r)) return r;
  let e = r.length;
  if (!X2(e)) return null;
  const i = new Array(e);
  for (; e-- > 0; )
    i[e] = r[e];
  return i;
}, lL = /* @__PURE__ */ ((r) => (e) => r && e instanceof r)(typeof Uint8Array < "u" && p_(Uint8Array)), uL = (r, e) => {
  const n = (r && r[lg]).call(r);
  let s;
  for (; (s = n.next()) && !s.done; ) {
    const a = s.value;
    e.call(r, a[0], a[1]);
  }
}, cL = (r, e) => {
  let i;
  const n = [];
  for (; (i = r.exec(e)) !== null; )
    n.push(i);
  return n;
}, hL = es("HTMLFormElement"), dL = (r) => r.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(i, n, s) {
    return n.toUpperCase() + s;
  }
), OT = (({ hasOwnProperty: r }) => (e, i) => r.call(e, i))(Object.prototype), pL = es("RegExp"), K2 = (r, e) => {
  const i = Object.getOwnPropertyDescriptors(r), n = {};
  jd(i, (s, a) => {
    let o;
    (o = e(s, a, r)) !== !1 && (n[a] = o || s);
  }), Object.defineProperties(r, n);
}, fL = (r) => {
  K2(r, (e, i) => {
    if (zr(r) && ["arguments", "caller", "callee"].indexOf(i) !== -1)
      return !1;
    const n = r[i];
    if (zr(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + i + "'");
      });
    }
  });
}, mL = (r, e) => {
  const i = {}, n = (s) => {
    s.forEach((a) => {
      i[a] = !0;
    });
  };
  return Pc(r) ? n(r) : n(String(r).split(e)), i;
}, gL = () => {
}, yL = (r, e) => r != null && Number.isFinite(r = +r) ? r : e;
function vL(r) {
  return !!(r && zr(r.append) && r[W2] === "FormData" && r[lg]);
}
const bL = (r) => {
  const e = new Array(10), i = (n, s) => {
    if (zd(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (Bd(n))
        return n;
      if (!("toJSON" in n)) {
        e[s] = n;
        const a = Pc(n) ? [] : {};
        return jd(n, (o, l) => {
          const u = i(o, s + 1);
          !cc(u) && (a[l] = u);
        }), e[s] = void 0, a;
      }
    }
    return n;
  };
  return i(r, 0);
}, xL = es("AsyncFunction"), _L = (r) => r && (zd(r) || zr(r)) && zr(r.then) && zr(r.catch), Z2 = ((r, e) => r ? setImmediate : e ? ((i, n) => (tl.addEventListener("message", ({ source: s, data: a }) => {
  s === tl && a === i && n.length && n.shift()();
}, !1), (s) => {
  n.push(s), tl.postMessage(i, "*");
}))(`axios@${Math.random()}`, []) : (i) => setTimeout(i))(
  typeof setImmediate == "function",
  zr(tl.postMessage)
), TL = typeof queueMicrotask < "u" ? queueMicrotask.bind(tl) : typeof process < "u" && process.nextTick || Z2, SL = (r) => r != null && zr(r[lg]), he = {
  isArray: Pc,
  isArrayBuffer: q2,
  isBuffer: Bd,
  isFormData: YD,
  isArrayBufferView: zD,
  isString: jD,
  isNumber: X2,
  isBoolean: VD,
  isObject: zd,
  isPlainObject: Bf,
  isEmptyObject: GD,
  isReadableStream: ZD,
  isRequest: QD,
  isResponse: JD,
  isHeaders: eL,
  isUndefined: cc,
  isDate: HD,
  isFile: WD,
  isBlob: qD,
  isRegExp: pL,
  isFunction: zr,
  isStream: $D,
  isURLSearchParams: KD,
  isTypedArray: lL,
  isFileList: XD,
  forEach: jd,
  merge: kv,
  extend: iL,
  trim: tL,
  stripBOM: rL,
  inherits: nL,
  toFlatObject: sL,
  kindOf: ug,
  kindOfTest: es,
  endsWith: aL,
  toArray: oL,
  forEachEntry: uL,
  matchAll: cL,
  isHTMLForm: hL,
  hasOwnProperty: OT,
  hasOwnProp: OT,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: K2,
  freezeMethods: fL,
  toObjectSet: mL,
  toCamelCase: dL,
  noop: gL,
  toFiniteNumber: yL,
  findKey: $2,
  global: tl,
  isContextDefined: Y2,
  isSpecCompliantForm: vL,
  toJSONObject: bL,
  isAsyncFn: xL,
  isThenable: _L,
  setImmediate: Z2,
  asap: TL,
  isIterable: SL
};
function Et(r, e, i, n, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = r, this.name = "AxiosError", e && (this.code = e), i && (this.config = i), n && (this.request = n), s && (this.response = s, this.status = s.status ? s.status : null);
}
he.inherits(Et, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: he.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const Q2 = Et.prototype, J2 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((r) => {
  J2[r] = { value: r };
});
Object.defineProperties(Et, J2);
Object.defineProperty(Q2, "isAxiosError", { value: !0 });
Et.from = (r, e, i, n, s, a) => {
  const o = Object.create(Q2);
  he.toFlatObject(r, o, function(h) {
    return h !== Error.prototype;
  }, (c) => c !== "isAxiosError");
  const l = r && r.message ? r.message : "Error", u = e == null && r ? r.code : e;
  return Et.call(o, l, u, i, n, s), r && o.cause == null && Object.defineProperty(o, "cause", { value: r, configurable: !0 }), o.name = r && r.name || "Error", a && Object.assign(o, a), o;
};
const wL = null;
function Uv(r) {
  return he.isPlainObject(r) || he.isArray(r);
}
function eC(r) {
  return he.endsWith(r, "[]") ? r.slice(0, -2) : r;
}
function DT(r, e, i) {
  return r ? r.concat(e).map(function(s, a) {
    return s = eC(s), !i && a ? "[" + s + "]" : s;
  }).join(i ? "." : "") : e;
}
function EL(r) {
  return he.isArray(r) && !r.some(Uv);
}
const ML = he.toFlatObject(he, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function hg(r, e, i) {
  if (!he.isObject(r))
    throw new TypeError("target must be an object");
  e = e || new FormData(), i = he.toFlatObject(i, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(y, v) {
    return !he.isUndefined(v[y]);
  });
  const n = i.metaTokens, s = i.visitor || h, a = i.dots, o = i.indexes, u = (i.Blob || typeof Blob < "u" && Blob) && he.isSpecCompliantForm(e);
  if (!he.isFunction(s))
    throw new TypeError("visitor must be a function");
  function c(m) {
    if (m === null) return "";
    if (he.isDate(m))
      return m.toISOString();
    if (he.isBoolean(m))
      return m.toString();
    if (!u && he.isBlob(m))
      throw new Et("Blob is not supported. Use a Buffer instead.");
    return he.isArrayBuffer(m) || he.isTypedArray(m) ? u && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m;
  }
  function h(m, y, v) {
    let g = m;
    if (m && !v && typeof m == "object") {
      if (he.endsWith(y, "{}"))
        y = n ? y : y.slice(0, -2), m = JSON.stringify(m);
      else if (he.isArray(m) && EL(m) || (he.isFileList(m) || he.endsWith(y, "[]")) && (g = he.toArray(m)))
        return y = eC(y), g.forEach(function(x, b) {
          !(he.isUndefined(x) || x === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? DT([y], b, a) : o === null ? y : y + "[]",
            c(x)
          );
        }), !1;
    }
    return Uv(m) ? !0 : (e.append(DT(v, y, a), c(m)), !1);
  }
  const d = [], p = Object.assign(ML, {
    defaultVisitor: h,
    convertValue: c,
    isVisitable: Uv
  });
  function f(m, y) {
    if (!he.isUndefined(m)) {
      if (d.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      d.push(m), he.forEach(m, function(g, _) {
        (!(he.isUndefined(g) || g === null) && s.call(
          e,
          g,
          he.isString(_) ? _.trim() : _,
          y,
          p
        )) === !0 && f(g, y ? y.concat(_) : [_]);
      }), d.pop();
    }
  }
  if (!he.isObject(r))
    throw new TypeError("data must be an object");
  return f(r), e;
}
function LT(r) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(r).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function f_(r, e) {
  this._pairs = [], r && hg(r, this, e);
}
const tC = f_.prototype;
tC.append = function(e, i) {
  this._pairs.push([e, i]);
};
tC.toString = function(e) {
  const i = e ? function(n) {
    return e.call(this, n, LT);
  } : LT;
  return this._pairs.map(function(s) {
    return i(s[0]) + "=" + i(s[1]);
  }, "").join("&");
};
function AL(r) {
  return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function iC(r, e, i) {
  if (!e)
    return r;
  const n = i && i.encode || AL;
  he.isFunction(i) && (i = {
    serialize: i
  });
  const s = i && i.serialize;
  let a;
  if (s ? a = s(e, i) : a = he.isURLSearchParams(e) ? e.toString() : new f_(e, i).toString(n), a) {
    const o = r.indexOf("#");
    o !== -1 && (r = r.slice(0, o)), r += (r.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return r;
}
class kT {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, i, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: i,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    he.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const rC = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, CL = typeof URLSearchParams < "u" ? URLSearchParams : f_, RL = typeof FormData < "u" ? FormData : null, NL = typeof Blob < "u" ? Blob : null, PL = {
  isBrowser: !0,
  classes: {
    URLSearchParams: CL,
    FormData: RL,
    Blob: NL
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, m_ = typeof window < "u" && typeof document < "u", Fv = typeof navigator == "object" && navigator || void 0, IL = m_ && (!Fv || ["ReactNative", "NativeScript", "NS"].indexOf(Fv.product) < 0), OL = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", DL = m_ && window.location.href || "http://localhost", LL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: m_,
  hasStandardBrowserEnv: IL,
  hasStandardBrowserWebWorkerEnv: OL,
  navigator: Fv,
  origin: DL
}, Symbol.toStringTag, { value: "Module" })), fr = {
  ...LL,
  ...PL
};
function kL(r, e) {
  return hg(r, new fr.classes.URLSearchParams(), {
    visitor: function(i, n, s, a) {
      return fr.isNode && he.isBuffer(i) ? (this.append(n, i.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    },
    ...e
  });
}
function UL(r) {
  return he.matchAll(/\w+|\[(\w*)]/g, r).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function FL(r) {
  const e = {}, i = Object.keys(r);
  let n;
  const s = i.length;
  let a;
  for (n = 0; n < s; n++)
    a = i[n], e[a] = r[a];
  return e;
}
function nC(r) {
  function e(i, n, s, a) {
    let o = i[a++];
    if (o === "__proto__") return !0;
    const l = Number.isFinite(+o), u = a >= i.length;
    return o = !o && he.isArray(s) ? s.length : o, u ? (he.hasOwnProp(s, o) ? s[o] = [s[o], n] : s[o] = n, !l) : ((!s[o] || !he.isObject(s[o])) && (s[o] = []), e(i, n, s[o], a) && he.isArray(s[o]) && (s[o] = FL(s[o])), !l);
  }
  if (he.isFormData(r) && he.isFunction(r.entries)) {
    const i = {};
    return he.forEachEntry(r, (n, s) => {
      e(UL(n), s, i, 0);
    }), i;
  }
  return null;
}
function BL(r, e, i) {
  if (he.isString(r))
    try {
      return (e || JSON.parse)(r), he.trim(r);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (i || JSON.stringify)(r);
}
const Vd = {
  transitional: rC,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, i) {
    const n = i.getContentType() || "", s = n.indexOf("application/json") > -1, a = he.isObject(e);
    if (a && he.isHTMLForm(e) && (e = new FormData(e)), he.isFormData(e))
      return s ? JSON.stringify(nC(e)) : e;
    if (he.isArrayBuffer(e) || he.isBuffer(e) || he.isStream(e) || he.isFile(e) || he.isBlob(e) || he.isReadableStream(e))
      return e;
    if (he.isArrayBufferView(e))
      return e.buffer;
    if (he.isURLSearchParams(e))
      return i.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let l;
    if (a) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return kL(e, this.formSerializer).toString();
      if ((l = he.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const u = this.env && this.env.FormData;
        return hg(
          l ? { "files[]": e } : e,
          u && new u(),
          this.formSerializer
        );
      }
    }
    return a || s ? (i.setContentType("application/json", !1), BL(e)) : e;
  }],
  transformResponse: [function(e) {
    const i = this.transitional || Vd.transitional, n = i && i.forcedJSONParsing, s = this.responseType === "json";
    if (he.isResponse(e) || he.isReadableStream(e))
      return e;
    if (e && he.isString(e) && (n && !this.responseType || s)) {
      const o = !(i && i.silentJSONParsing) && s;
      try {
        return JSON.parse(e, this.parseReviver);
      } catch (l) {
        if (o)
          throw l.name === "SyntaxError" ? Et.from(l, Et.ERR_BAD_RESPONSE, this, null, this.response) : l;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: fr.classes.FormData,
    Blob: fr.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
he.forEach(["delete", "get", "head", "post", "put", "patch"], (r) => {
  Vd.headers[r] = {};
});
const zL = he.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), jL = (r) => {
  const e = {};
  let i, n, s;
  return r && r.split(`
`).forEach(function(o) {
    s = o.indexOf(":"), i = o.substring(0, s).trim().toLowerCase(), n = o.substring(s + 1).trim(), !(!i || e[i] && zL[i]) && (i === "set-cookie" ? e[i] ? e[i].push(n) : e[i] = [n] : e[i] = e[i] ? e[i] + ", " + n : n);
  }), e;
}, UT = Symbol("internals");
function eh(r) {
  return r && String(r).trim().toLowerCase();
}
function zf(r) {
  return r === !1 || r == null ? r : he.isArray(r) ? r.map(zf) : String(r);
}
function VL(r) {
  const e = /* @__PURE__ */ Object.create(null), i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = i.exec(r); )
    e[n[1]] = n[2];
  return e;
}
const GL = (r) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function ly(r, e, i, n, s) {
  if (he.isFunction(n))
    return n.call(this, e, i);
  if (s && (e = i), !!he.isString(e)) {
    if (he.isString(n))
      return e.indexOf(n) !== -1;
    if (he.isRegExp(n))
      return n.test(e);
  }
}
function HL(r) {
  return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, i, n) => i.toUpperCase() + n);
}
function WL(r, e) {
  const i = he.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(r, n + i, {
      value: function(s, a, o) {
        return this[n].call(this, e, s, a, o);
      },
      configurable: !0
    });
  });
}
let jr = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, i, n) {
    const s = this;
    function a(l, u, c) {
      const h = eh(u);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const d = he.findKey(s, h);
      (!d || s[d] === void 0 || c === !0 || c === void 0 && s[d] !== !1) && (s[d || u] = zf(l));
    }
    const o = (l, u) => he.forEach(l, (c, h) => a(c, h, u));
    if (he.isPlainObject(e) || e instanceof this.constructor)
      o(e, i);
    else if (he.isString(e) && (e = e.trim()) && !GL(e))
      o(jL(e), i);
    else if (he.isObject(e) && he.isIterable(e)) {
      let l = {}, u, c;
      for (const h of e) {
        if (!he.isArray(h))
          throw TypeError("Object iterator must return a key-value pair");
        l[c = h[0]] = (u = l[c]) ? he.isArray(u) ? [...u, h[1]] : [u, h[1]] : h[1];
      }
      o(l, i);
    } else
      e != null && a(i, e, n);
    return this;
  }
  get(e, i) {
    if (e = eh(e), e) {
      const n = he.findKey(this, e);
      if (n) {
        const s = this[n];
        if (!i)
          return s;
        if (i === !0)
          return VL(s);
        if (he.isFunction(i))
          return i.call(this, s, n);
        if (he.isRegExp(i))
          return i.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, i) {
    if (e = eh(e), e) {
      const n = he.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!i || ly(this, this[n], n, i)));
    }
    return !1;
  }
  delete(e, i) {
    const n = this;
    let s = !1;
    function a(o) {
      if (o = eh(o), o) {
        const l = he.findKey(n, o);
        l && (!i || ly(n, n[l], l, i)) && (delete n[l], s = !0);
      }
    }
    return he.isArray(e) ? e.forEach(a) : a(e), s;
  }
  clear(e) {
    const i = Object.keys(this);
    let n = i.length, s = !1;
    for (; n--; ) {
      const a = i[n];
      (!e || ly(this, this[a], a, e, !0)) && (delete this[a], s = !0);
    }
    return s;
  }
  normalize(e) {
    const i = this, n = {};
    return he.forEach(this, (s, a) => {
      const o = he.findKey(n, a);
      if (o) {
        i[o] = zf(s), delete i[a];
        return;
      }
      const l = e ? HL(a) : String(a).trim();
      l !== a && delete i[a], i[l] = zf(s), n[l] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const i = /* @__PURE__ */ Object.create(null);
    return he.forEach(this, (n, s) => {
      n != null && n !== !1 && (i[s] = e && he.isArray(n) ? n.join(", ") : n);
    }), i;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, i]) => e + ": " + i).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...i) {
    const n = new this(e);
    return i.forEach((s) => n.set(s)), n;
  }
  static accessor(e) {
    const n = (this[UT] = this[UT] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function a(o) {
      const l = eh(o);
      n[l] || (WL(s, o), n[l] = !0);
    }
    return he.isArray(e) ? e.forEach(a) : a(e), this;
  }
};
jr.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
he.reduceDescriptors(jr.prototype, ({ value: r }, e) => {
  let i = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => r,
    set(n) {
      this[i] = n;
    }
  };
});
he.freezeMethods(jr);
function uy(r, e) {
  const i = this || Vd, n = e || i, s = jr.from(n.headers);
  let a = n.data;
  return he.forEach(r, function(l) {
    a = l.call(i, a, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), a;
}
function sC(r) {
  return !!(r && r.__CANCEL__);
}
function Ic(r, e, i) {
  Et.call(this, r ?? "canceled", Et.ERR_CANCELED, e, i), this.name = "CanceledError";
}
he.inherits(Ic, Et, {
  __CANCEL__: !0
});
function aC(r, e, i) {
  const n = i.config.validateStatus;
  !i.status || !n || n(i.status) ? r(i) : e(new Et(
    "Request failed with status code " + i.status,
    [Et.ERR_BAD_REQUEST, Et.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4],
    i.config,
    i.request,
    i
  ));
}
function qL(r) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(r);
  return e && e[1] || "";
}
function XL(r, e) {
  r = r || 10;
  const i = new Array(r), n = new Array(r);
  let s = 0, a = 0, o;
  return e = e !== void 0 ? e : 1e3, function(u) {
    const c = Date.now(), h = n[a];
    o || (o = c), i[s] = u, n[s] = c;
    let d = a, p = 0;
    for (; d !== s; )
      p += i[d++], d = d % r;
    if (s = (s + 1) % r, s === a && (a = (a + 1) % r), c - o < e)
      return;
    const f = h && c - h;
    return f ? Math.round(p * 1e3 / f) : void 0;
  };
}
function $L(r, e) {
  let i = 0, n = 1e3 / e, s, a;
  const o = (c, h = Date.now()) => {
    i = h, s = null, a && (clearTimeout(a), a = null), r(...c);
  };
  return [(...c) => {
    const h = Date.now(), d = h - i;
    d >= n ? o(c, h) : (s = c, a || (a = setTimeout(() => {
      a = null, o(s);
    }, n - d)));
  }, () => s && o(s)];
}
const vm = (r, e, i = 3) => {
  let n = 0;
  const s = XL(50, 250);
  return $L((a) => {
    const o = a.loaded, l = a.lengthComputable ? a.total : void 0, u = o - n, c = s(u), h = o <= l;
    n = o;
    const d = {
      loaded: o,
      total: l,
      progress: l ? o / l : void 0,
      bytes: u,
      rate: c || void 0,
      estimated: c && l && h ? (l - o) / c : void 0,
      event: a,
      lengthComputable: l != null,
      [e ? "download" : "upload"]: !0
    };
    r(d);
  }, i);
}, FT = (r, e) => {
  const i = r != null;
  return [(n) => e[0]({
    lengthComputable: i,
    total: r,
    loaded: n
  }), e[1]];
}, BT = (r) => (...e) => he.asap(() => r(...e)), YL = fr.hasStandardBrowserEnv ? /* @__PURE__ */ ((r, e) => (i) => (i = new URL(i, fr.origin), r.protocol === i.protocol && r.host === i.host && (e || r.port === i.port)))(
  new URL(fr.origin),
  fr.navigator && /(msie|trident)/i.test(fr.navigator.userAgent)
) : () => !0, KL = fr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(r, e, i, n, s, a) {
      const o = [r + "=" + encodeURIComponent(e)];
      he.isNumber(i) && o.push("expires=" + new Date(i).toGMTString()), he.isString(n) && o.push("path=" + n), he.isString(s) && o.push("domain=" + s), a === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(r) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(r) {
      this.write(r, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function ZL(r) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(r);
}
function QL(r, e) {
  return e ? r.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : r;
}
function oC(r, e, i) {
  let n = !ZL(e);
  return r && (n || i == !1) ? QL(r, e) : e;
}
const zT = (r) => r instanceof jr ? { ...r } : r;
function vl(r, e) {
  e = e || {};
  const i = {};
  function n(c, h, d, p) {
    return he.isPlainObject(c) && he.isPlainObject(h) ? he.merge.call({ caseless: p }, c, h) : he.isPlainObject(h) ? he.merge({}, h) : he.isArray(h) ? h.slice() : h;
  }
  function s(c, h, d, p) {
    if (he.isUndefined(h)) {
      if (!he.isUndefined(c))
        return n(void 0, c, d, p);
    } else return n(c, h, d, p);
  }
  function a(c, h) {
    if (!he.isUndefined(h))
      return n(void 0, h);
  }
  function o(c, h) {
    if (he.isUndefined(h)) {
      if (!he.isUndefined(c))
        return n(void 0, c);
    } else return n(void 0, h);
  }
  function l(c, h, d) {
    if (d in e)
      return n(c, h);
    if (d in r)
      return n(void 0, c);
  }
  const u = {
    url: a,
    method: a,
    data: a,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: l,
    headers: (c, h, d) => s(zT(c), zT(h), d, !0)
  };
  return he.forEach(Object.keys({ ...r, ...e }), function(h) {
    const d = u[h] || s, p = d(r[h], e[h], h);
    he.isUndefined(p) && d !== l || (i[h] = p);
  }), i;
}
const lC = (r) => {
  const e = vl({}, r);
  let { data: i, withXSRFToken: n, xsrfHeaderName: s, xsrfCookieName: a, headers: o, auth: l } = e;
  if (e.headers = o = jr.from(o), e.url = iC(oC(e.baseURL, e.url, e.allowAbsoluteUrls), r.params, r.paramsSerializer), l && o.set(
    "Authorization",
    "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))
  ), he.isFormData(i)) {
    if (fr.hasStandardBrowserEnv || fr.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if (he.isFunction(i.getHeaders)) {
      const u = i.getHeaders(), c = ["content-type", "content-length"];
      Object.entries(u).forEach(([h, d]) => {
        c.includes(h.toLowerCase()) && o.set(h, d);
      });
    }
  }
  if (fr.hasStandardBrowserEnv && (n && he.isFunction(n) && (n = n(e)), n || n !== !1 && YL(e.url))) {
    const u = s && a && KL.read(a);
    u && o.set(s, u);
  }
  return e;
}, JL = typeof XMLHttpRequest < "u", ek = JL && function(r) {
  return new Promise(function(i, n) {
    const s = lC(r);
    let a = s.data;
    const o = jr.from(s.headers).normalize();
    let { responseType: l, onUploadProgress: u, onDownloadProgress: c } = s, h, d, p, f, m;
    function y() {
      f && f(), m && m(), s.cancelToken && s.cancelToken.unsubscribe(h), s.signal && s.signal.removeEventListener("abort", h);
    }
    let v = new XMLHttpRequest();
    v.open(s.method.toUpperCase(), s.url, !0), v.timeout = s.timeout;
    function g() {
      if (!v)
        return;
      const x = jr.from(
        "getAllResponseHeaders" in v && v.getAllResponseHeaders()
      ), T = {
        data: !l || l === "text" || l === "json" ? v.responseText : v.response,
        status: v.status,
        statusText: v.statusText,
        headers: x,
        config: r,
        request: v
      };
      aC(function(w) {
        i(w), y();
      }, function(w) {
        n(w), y();
      }, T), v = null;
    }
    "onloadend" in v ? v.onloadend = g : v.onreadystatechange = function() {
      !v || v.readyState !== 4 || v.status === 0 && !(v.responseURL && v.responseURL.indexOf("file:") === 0) || setTimeout(g);
    }, v.onabort = function() {
      v && (n(new Et("Request aborted", Et.ECONNABORTED, r, v)), v = null);
    }, v.onerror = function(b) {
      const T = b && b.message ? b.message : "Network Error", S = new Et(T, Et.ERR_NETWORK, r, v);
      S.event = b || null, n(S), v = null;
    }, v.ontimeout = function() {
      let b = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const T = s.transitional || rC;
      s.timeoutErrorMessage && (b = s.timeoutErrorMessage), n(new Et(
        b,
        T.clarifyTimeoutError ? Et.ETIMEDOUT : Et.ECONNABORTED,
        r,
        v
      )), v = null;
    }, a === void 0 && o.setContentType(null), "setRequestHeader" in v && he.forEach(o.toJSON(), function(b, T) {
      v.setRequestHeader(T, b);
    }), he.isUndefined(s.withCredentials) || (v.withCredentials = !!s.withCredentials), l && l !== "json" && (v.responseType = s.responseType), c && ([p, m] = vm(c, !0), v.addEventListener("progress", p)), u && v.upload && ([d, f] = vm(u), v.upload.addEventListener("progress", d), v.upload.addEventListener("loadend", f)), (s.cancelToken || s.signal) && (h = (x) => {
      v && (n(!x || x.type ? new Ic(null, r, v) : x), v.abort(), v = null);
    }, s.cancelToken && s.cancelToken.subscribe(h), s.signal && (s.signal.aborted ? h() : s.signal.addEventListener("abort", h)));
    const _ = qL(s.url);
    if (_ && fr.protocols.indexOf(_) === -1) {
      n(new Et("Unsupported protocol " + _ + ":", Et.ERR_BAD_REQUEST, r));
      return;
    }
    v.send(a || null);
  });
}, tk = (r, e) => {
  const { length: i } = r = r ? r.filter(Boolean) : [];
  if (e || i) {
    let n = new AbortController(), s;
    const a = function(c) {
      if (!s) {
        s = !0, l();
        const h = c instanceof Error ? c : this.reason;
        n.abort(h instanceof Et ? h : new Ic(h instanceof Error ? h.message : h));
      }
    };
    let o = e && setTimeout(() => {
      o = null, a(new Et(`timeout ${e} of ms exceeded`, Et.ETIMEDOUT));
    }, e);
    const l = () => {
      r && (o && clearTimeout(o), o = null, r.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(a) : c.removeEventListener("abort", a);
      }), r = null);
    };
    r.forEach((c) => c.addEventListener("abort", a));
    const { signal: u } = n;
    return u.unsubscribe = () => he.asap(l), u;
  }
}, ik = function* (r, e) {
  let i = r.byteLength;
  if (i < e) {
    yield r;
    return;
  }
  let n = 0, s;
  for (; n < i; )
    s = n + e, yield r.slice(n, s), n = s;
}, rk = async function* (r, e) {
  for await (const i of nk(r))
    yield* ik(i, e);
}, nk = async function* (r) {
  if (r[Symbol.asyncIterator]) {
    yield* r;
    return;
  }
  const e = r.getReader();
  try {
    for (; ; ) {
      const { done: i, value: n } = await e.read();
      if (i)
        break;
      yield n;
    }
  } finally {
    await e.cancel();
  }
}, jT = (r, e, i, n) => {
  const s = rk(r, e);
  let a = 0, o, l = (u) => {
    o || (o = !0, n && n(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: c, value: h } = await s.next();
        if (c) {
          l(), u.close();
          return;
        }
        let d = h.byteLength;
        if (i) {
          let p = a += d;
          i(p);
        }
        u.enqueue(new Uint8Array(h));
      } catch (c) {
        throw l(c), c;
      }
    },
    cancel(u) {
      return l(u), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, VT = 64 * 1024, { isFunction: up } = he, sk = (({ Request: r, Response: e }) => ({
  Request: r,
  Response: e
}))(he.global), {
  ReadableStream: GT,
  TextEncoder: HT
} = he.global, WT = (r, ...e) => {
  try {
    return !!r(...e);
  } catch {
    return !1;
  }
}, ak = (r) => {
  r = he.merge.call({
    skipUndefined: !0
  }, sk, r);
  const { fetch: e, Request: i, Response: n } = r, s = e ? up(e) : typeof fetch == "function", a = up(i), o = up(n);
  if (!s)
    return !1;
  const l = s && up(GT), u = s && (typeof HT == "function" ? /* @__PURE__ */ ((m) => (y) => m.encode(y))(new HT()) : async (m) => new Uint8Array(await new i(m).arrayBuffer())), c = a && l && WT(() => {
    let m = !1;
    const y = new i(fr.origin, {
      body: new GT(),
      method: "POST",
      get duplex() {
        return m = !0, "half";
      }
    }).headers.has("Content-Type");
    return m && !y;
  }), h = o && l && WT(() => he.isReadableStream(new n("").body)), d = {
    stream: h && ((m) => m.body)
  };
  s && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((m) => {
    !d[m] && (d[m] = (y, v) => {
      let g = y && y[m];
      if (g)
        return g.call(y);
      throw new Et(`Response type '${m}' is not supported`, Et.ERR_NOT_SUPPORT, v);
    });
  });
  const p = async (m) => {
    if (m == null)
      return 0;
    if (he.isBlob(m))
      return m.size;
    if (he.isSpecCompliantForm(m))
      return (await new i(fr.origin, {
        method: "POST",
        body: m
      }).arrayBuffer()).byteLength;
    if (he.isArrayBufferView(m) || he.isArrayBuffer(m))
      return m.byteLength;
    if (he.isURLSearchParams(m) && (m = m + ""), he.isString(m))
      return (await u(m)).byteLength;
  }, f = async (m, y) => {
    const v = he.toFiniteNumber(m.getContentLength());
    return v ?? p(y);
  };
  return async (m) => {
    let {
      url: y,
      method: v,
      data: g,
      signal: _,
      cancelToken: x,
      timeout: b,
      onDownloadProgress: T,
      onUploadProgress: S,
      responseType: w,
      headers: M,
      withCredentials: E = "same-origin",
      fetchOptions: A
    } = lC(m), N = e || fetch;
    w = w ? (w + "").toLowerCase() : "text";
    let U = tk([_, x && x.toAbortSignal()], b), k = null;
    const C = U && U.unsubscribe && (() => {
      U.unsubscribe();
    });
    let I;
    try {
      if (S && c && v !== "get" && v !== "head" && (I = await f(M, g)) !== 0) {
        let B = new i(y, {
          method: "POST",
          body: g,
          duplex: "half"
        }), q;
        if (he.isFormData(g) && (q = B.headers.get("content-type")) && M.setContentType(q), B.body) {
          const [G, z] = FT(
            I,
            vm(BT(S))
          );
          g = jT(B.body, VT, G, z);
        }
      }
      he.isString(E) || (E = E ? "include" : "omit");
      const O = a && "credentials" in i.prototype, W = {
        ...A,
        signal: U,
        method: v.toUpperCase(),
        headers: M.normalize().toJSON(),
        body: g,
        duplex: "half",
        credentials: O ? E : void 0
      };
      k = a && new i(y, W);
      let V = await (a ? N(k, A) : N(y, W));
      const Q = h && (w === "stream" || w === "response");
      if (h && (T || Q && C)) {
        const B = {};
        ["status", "statusText", "headers"].forEach((Y) => {
          B[Y] = V[Y];
        });
        const q = he.toFiniteNumber(V.headers.get("content-length")), [G, z] = T && FT(
          q,
          vm(BT(T), !0)
        ) || [];
        V = new n(
          jT(V.body, VT, G, () => {
            z && z(), C && C();
          }),
          B
        );
      }
      w = w || "text";
      let F = await d[he.findKey(d, w) || "text"](V, m);
      return !Q && C && C(), await new Promise((B, q) => {
        aC(B, q, {
          data: F,
          headers: jr.from(V.headers),
          status: V.status,
          statusText: V.statusText,
          config: m,
          request: k
        });
      });
    } catch (O) {
      throw C && C(), O && O.name === "TypeError" && /Load failed|fetch/i.test(O.message) ? Object.assign(
        new Et("Network Error", Et.ERR_NETWORK, m, k),
        {
          cause: O.cause || O
        }
      ) : Et.from(O, O && O.code, m, k);
    }
  };
}, ok = /* @__PURE__ */ new Map(), uC = (r) => {
  let e = r ? r.env : {};
  const { fetch: i, Request: n, Response: s } = e, a = [
    n,
    s,
    i
  ];
  let o = a.length, l = o, u, c, h = ok;
  for (; l--; )
    u = a[l], c = h.get(u), c === void 0 && h.set(u, c = l ? /* @__PURE__ */ new Map() : ak(e)), h = c;
  return c;
};
uC();
const Bv = {
  http: wL,
  xhr: ek,
  fetch: {
    get: uC
  }
};
he.forEach(Bv, (r, e) => {
  if (r) {
    try {
      Object.defineProperty(r, "name", { value: e });
    } catch {
    }
    Object.defineProperty(r, "adapterName", { value: e });
  }
});
const qT = (r) => `- ${r}`, lk = (r) => he.isFunction(r) || r === null || r === !1, cC = {
  getAdapter: (r, e) => {
    r = he.isArray(r) ? r : [r];
    const { length: i } = r;
    let n, s;
    const a = {};
    for (let o = 0; o < i; o++) {
      n = r[o];
      let l;
      if (s = n, !lk(n) && (s = Bv[(l = String(n)).toLowerCase()], s === void 0))
        throw new Et(`Unknown adapter '${l}'`);
      if (s && (he.isFunction(s) || (s = s.get(e))))
        break;
      a[l || "#" + o] = s;
    }
    if (!s) {
      const o = Object.entries(a).map(
        ([u, c]) => `adapter ${u} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let l = i ? o.length > 1 ? `since :
` + o.map(qT).join(`
`) : " " + qT(o[0]) : "as no adapter specified";
      throw new Et(
        "There is no suitable adapter to dispatch the request " + l,
        "ERR_NOT_SUPPORT"
      );
    }
    return s;
  },
  adapters: Bv
};
function cy(r) {
  if (r.cancelToken && r.cancelToken.throwIfRequested(), r.signal && r.signal.aborted)
    throw new Ic(null, r);
}
function XT(r) {
  return cy(r), r.headers = jr.from(r.headers), r.data = uy.call(
    r,
    r.transformRequest
  ), ["post", "put", "patch"].indexOf(r.method) !== -1 && r.headers.setContentType("application/x-www-form-urlencoded", !1), cC.getAdapter(r.adapter || Vd.adapter, r)(r).then(function(n) {
    return cy(r), n.data = uy.call(
      r,
      r.transformResponse,
      n
    ), n.headers = jr.from(n.headers), n;
  }, function(n) {
    return sC(n) || (cy(r), n && n.response && (n.response.data = uy.call(
      r,
      r.transformResponse,
      n.response
    ), n.response.headers = jr.from(n.response.headers))), Promise.reject(n);
  });
}
const hC = "1.12.2", dg = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((r, e) => {
  dg[r] = function(n) {
    return typeof n === r || "a" + (e < 1 ? "n " : " ") + r;
  };
});
const $T = {};
dg.transitional = function(e, i, n) {
  function s(a, o) {
    return "[Axios v" + hC + "] Transitional option '" + a + "'" + o + (n ? ". " + n : "");
  }
  return (a, o, l) => {
    if (e === !1)
      throw new Et(
        s(o, " has been removed" + (i ? " in " + i : "")),
        Et.ERR_DEPRECATED
      );
    return i && !$T[o] && ($T[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + i + " and will be removed in the near future"
      )
    )), e ? e(a, o, l) : !0;
  };
};
dg.spelling = function(e) {
  return (i, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function uk(r, e, i) {
  if (typeof r != "object")
    throw new Et("options must be an object", Et.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(r);
  let s = n.length;
  for (; s-- > 0; ) {
    const a = n[s], o = e[a];
    if (o) {
      const l = r[a], u = l === void 0 || o(l, a, r);
      if (u !== !0)
        throw new Et("option " + a + " must be " + u, Et.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (i !== !0)
      throw new Et("Unknown option " + a, Et.ERR_BAD_OPTION);
  }
}
const jf = {
  assertOptions: uk,
  validators: dg
}, rs = jf.validators;
let fl = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new kT(),
      response: new kT()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, i) {
    try {
      return await this._request(e, i);
    } catch (n) {
      if (n instanceof Error) {
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const a = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? a && !String(n.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + a) : n.stack = a;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, i) {
    typeof e == "string" ? (i = i || {}, i.url = e) : i = e || {}, i = vl(this.defaults, i);
    const { transitional: n, paramsSerializer: s, headers: a } = i;
    n !== void 0 && jf.assertOptions(n, {
      silentJSONParsing: rs.transitional(rs.boolean),
      forcedJSONParsing: rs.transitional(rs.boolean),
      clarifyTimeoutError: rs.transitional(rs.boolean)
    }, !1), s != null && (he.isFunction(s) ? i.paramsSerializer = {
      serialize: s
    } : jf.assertOptions(s, {
      encode: rs.function,
      serialize: rs.function
    }, !0)), i.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? i.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : i.allowAbsoluteUrls = !0), jf.assertOptions(i, {
      baseUrl: rs.spelling("baseURL"),
      withXsrfToken: rs.spelling("withXSRFToken")
    }, !0), i.method = (i.method || this.defaults.method || "get").toLowerCase();
    let o = a && he.merge(
      a.common,
      a[i.method]
    );
    a && he.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (m) => {
        delete a[m];
      }
    ), i.headers = jr.concat(o, a);
    const l = [];
    let u = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(i) === !1 || (u = u && y.synchronous, l.unshift(y.fulfilled, y.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(y) {
      c.push(y.fulfilled, y.rejected);
    });
    let h, d = 0, p;
    if (!u) {
      const m = [XT.bind(this), void 0];
      for (m.unshift(...l), m.push(...c), p = m.length, h = Promise.resolve(i); d < p; )
        h = h.then(m[d++], m[d++]);
      return h;
    }
    p = l.length;
    let f = i;
    for (; d < p; ) {
      const m = l[d++], y = l[d++];
      try {
        f = m(f);
      } catch (v) {
        y.call(this, v);
        break;
      }
    }
    try {
      h = XT.call(this, f);
    } catch (m) {
      return Promise.reject(m);
    }
    for (d = 0, p = c.length; d < p; )
      h = h.then(c[d++], c[d++]);
    return h;
  }
  getUri(e) {
    e = vl(this.defaults, e);
    const i = oC(e.baseURL, e.url, e.allowAbsoluteUrls);
    return iC(i, e.params, e.paramsSerializer);
  }
};
he.forEach(["delete", "get", "head", "options"], function(e) {
  fl.prototype[e] = function(i, n) {
    return this.request(vl(n || {}, {
      method: e,
      url: i,
      data: (n || {}).data
    }));
  };
});
he.forEach(["post", "put", "patch"], function(e) {
  function i(n) {
    return function(a, o, l) {
      return this.request(vl(l || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: o
      }));
    };
  }
  fl.prototype[e] = i(), fl.prototype[e + "Form"] = i(!0);
});
let ck = class dC {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let i;
    this.promise = new Promise(function(a) {
      i = a;
    });
    const n = this;
    this.promise.then((s) => {
      if (!n._listeners) return;
      let a = n._listeners.length;
      for (; a-- > 0; )
        n._listeners[a](s);
      n._listeners = null;
    }), this.promise.then = (s) => {
      let a;
      const o = new Promise((l) => {
        n.subscribe(l), a = l;
      }).then(s);
      return o.cancel = function() {
        n.unsubscribe(a);
      }, o;
    }, e(function(a, o, l) {
      n.reason || (n.reason = new Ic(a, o, l), i(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const i = this._listeners.indexOf(e);
    i !== -1 && this._listeners.splice(i, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), i = (n) => {
      e.abort(n);
    };
    return this.subscribe(i), e.signal.unsubscribe = () => this.unsubscribe(i), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new dC(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
function hk(r) {
  return function(i) {
    return r.apply(null, i);
  };
}
function dk(r) {
  return he.isObject(r) && r.isAxiosError === !0;
}
const zv = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(zv).forEach(([r, e]) => {
  zv[e] = r;
});
function pC(r) {
  const e = new fl(r), i = H2(fl.prototype.request, e);
  return he.extend(i, fl.prototype, e, { allOwnKeys: !0 }), he.extend(i, e, null, { allOwnKeys: !0 }), i.create = function(s) {
    return pC(vl(r, s));
  }, i;
}
const xi = pC(Vd);
xi.Axios = fl;
xi.CanceledError = Ic;
xi.CancelToken = ck;
xi.isCancel = sC;
xi.VERSION = hC;
xi.toFormData = hg;
xi.AxiosError = Et;
xi.Cancel = xi.CanceledError;
xi.all = function(e) {
  return Promise.all(e);
};
xi.spread = hk;
xi.isAxiosError = dk;
xi.mergeConfig = vl;
xi.AxiosHeaders = jr;
xi.formToJSON = (r) => nC(he.isHTMLForm(r) ? new FormData(r) : r);
xi.getAdapter = cC.getAdapter;
xi.HttpStatusCode = zv;
xi.default = xi;
const {
  Axios: _le,
  AxiosError: Tle,
  CanceledError: Sle,
  isCancel: wle,
  CancelToken: Ele,
  VERSION: Mle,
  all: Ale,
  Cancel: Cle,
  isAxiosError: Rle,
  spread: Nle,
  toFormData: Ple,
  AxiosHeaders: Ile,
  HttpStatusCode: Ole,
  formToJSON: Dle,
  getAdapter: Lle,
  mergeConfig: kle
} = xi, YT = (r) => {
  localStorage.setItem("auth_token", r);
}, g_ = () => localStorage.getItem("auth_token"), pg = () => !!g_(), pk = () => {
  localStorage.removeItem("auth_token");
}, y_ = () => {
  const r = g_();
  return r ? `Bearer ${r}` : "";
};
let jv = null;
const fg = () => {
  if (!jv)
    throw new Error(
      "Configuration Player-map non initialisée. Utilisez PlayerMapConfig.init() pour configurer la bibliothèque."
    );
  return { ...jv };
}, fk = (r) => {
  if (!r.apiUrl)
    throw new Error("L'URL de l'API est requise pour initialiser Player-map");
  jv = {
    apiUrl: r.apiUrl
  };
}, mk = async (r) => {
  try {
    const e = new FormData();
    if (e.append("file", r), !pg())
      throw new Error("Vous devez être connecté pour téléverser des fichiers");
    const { apiUrl: i } = fg(), n = `${i}/ipfs/upload_file`;
    return (await xi.post(
      n,
      e,
      {
        headers: {
          "Content-Type": "multipart/form-data",
          Authorization: y_()
        }
      }
    )).data.ipfs_url;
  } catch (e) {
    throw e instanceof Error && e.message.includes("Configuration Player-map non initialisée") ? (console.error("Erreur de configuration Player-map:", e.message), new Error("Erreur de configuration: Initialisez la bibliothèque Player-map avec PlayerMapConfig.init() avant utilisation")) : (console.error("Erreur lors du téléversement vers le serveur:", e), new Error("Échec du téléversement de l'image vers IPFS"));
  }
}, fC = (r) => r ? r.startsWith("ipfs://") : !1, gk = async (r) => {
  if (!fC(r)) return r;
  try {
    let e = sessionStorage.getItem("ipfs_gateway");
    if (!e) {
      if (!pg())
        throw new Error("Vous devez être connecté pour accéder à la passerelle IPFS");
      const { apiUrl: n } = fg();
      if (e = (await xi.get(
        `${n}/ipfs/gateway_url`,
        {
          headers: {
            Authorization: y_()
          }
        }
      )).data.gateway_url, e)
        sessionStorage.setItem("ipfs_gateway", e);
      else
        throw new Error("Aucune passerelle IPFS configurée");
    }
    const i = r.replace("ipfs://", "");
    return `https://${e}/ipfs/${i}`;
  } catch (e) {
    throw e instanceof Error && e.message.includes("Configuration Player-map non initialisée") ? (console.error("Erreur de configuration Player-map:", e.message), new Error("Erreur de configuration: Initialisez la bibliothèque Player-map avec PlayerMapConfig.init() avant utilisation")) : (console.error("Erreur lors de la récupération du gateway URL:", e), e);
  }
}, yk = ({ src: r }) => {
  const [e, i] = si.useState(r), [n, s] = si.useState(!0);
  return si.useEffect(() => {
    (async () => {
      s(!0);
      try {
        const o = vk(r) ? bk(r) : r;
        i(o);
      } catch (o) {
        console.error("Error loading image:", o);
      } finally {
        s(!1);
      }
    })();
  }, [r]), n ? /* @__PURE__ */ P.jsx("div", { children: "Loading image..." }) : /* @__PURE__ */ P.jsx(
    "img",
    {
      src: e,
      alt: "Preview",
      style: {
        maxWidth: "100%",
        maxHeight: "150px",
        borderRadius: "5px"
      }
    }
  );
}, vk = (r) => r.startsWith("ipfs://"), bk = (r) => r.replace("ipfs://", "https://gateway.pinata.cloud/ipfs/"), xk = ({
  step: r,
  isCreatingAtom: e,
  isCreatingTriples: i,
  creationSuccess: n,
  atomId: s,
  tripleCreated: a,
  walletAddress: o,
  hasExistingAtom: l,
  formData: u,
  handleInputChange: c,
  handleSelectChange: h,
  handleFileUpload: d,
  handleSubmit: p,
  isLoading: f,
  isUploading: m,
  fileInputRef: y,
  constants: v
}) => {
  const { OFFICIAL_GUILDS: g } = v;
  return /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
    /* @__PURE__ */ P.jsxs("div", { style: { marginBottom: "20px" }, children: [
      /* @__PURE__ */ P.jsxs(
        "div",
        {
          style: {
            display: "flex",
            justifyContent: "space-between",
            marginBottom: "10px"
          },
          children: [
            /* @__PURE__ */ P.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
              /* @__PURE__ */ P.jsx(
                "div",
                {
                  style: {
                    width: "30px",
                    height: "30px",
                    borderRadius: "15px",
                    backgroundColor: e || r > 1 ? "#FFD32A" : "#2e2e40",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    margin: "0 auto",
                    color: e || r > 1 ? "#000" : "#fff"
                  },
                  children: r > 1 ? "✓" : "1"
                }
              ),
              /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Atom Creation" })
            ] }),
            /* @__PURE__ */ P.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
              /* @__PURE__ */ P.jsx(
                "div",
                {
                  style: {
                    width: "30px",
                    height: "30px",
                    borderRadius: "15px",
                    backgroundColor: i || r > 2 ? "#FFD32A" : "#2e2e40",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    margin: "0 auto",
                    color: i || r > 2 ? "#000" : "#fff"
                  },
                  children: r > 2 ? "✓" : "2"
                }
              ),
              /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Triples Creation" })
            ] }),
            /* @__PURE__ */ P.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
              /* @__PURE__ */ P.jsx(
                "div",
                {
                  style: {
                    width: "30px",
                    height: "30px",
                    borderRadius: "15px",
                    backgroundColor: r === 3 ? "#4CAF50" : "#2e2e40",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    margin: "0 auto",
                    color: r === 3 ? "#000" : "#fff"
                  },
                  children: r === 3 ? "✓" : "3"
                }
              ),
              /* @__PURE__ */ P.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Success" })
            ] })
          ]
        }
      ),
      /* @__PURE__ */ P.jsx(
        "div",
        {
          style: {
            height: "4px",
            backgroundColor: "#2e2e40",
            position: "relative",
            marginBottom: "20px"
          },
          children: /* @__PURE__ */ P.jsx(
            "div",
            {
              style: {
                position: "absolute",
                left: 0,
                top: 0,
                height: "100%",
                width: `${(r - 1) * 50}%`,
                backgroundColor: "#FFD32A",
                transition: "width 0.3s ease"
              }
            }
          )
        }
      )
    ] }),
    n ? /* @__PURE__ */ P.jsxs("div", { style: { textAlign: "center", color: "#4CAF50" }, children: [
      /* @__PURE__ */ P.jsx("h3", { style: { color: "#4CAF50", marginBottom: "10px" }, children: "Success!" }),
      /* @__PURE__ */ P.jsx("p", { children: "Your player has been created successfully." }),
      /* @__PURE__ */ P.jsxs("p", { children: [
        "Atom ID: ",
        s
      ] }),
      /* @__PURE__ */ P.jsxs("p", { children: [
        "Triples created: ",
        a ? "Yes" : "No"
      ] }),
      /* @__PURE__ */ P.jsx("p", { children: "This window will close automatically..." })
    ] }) : o ? l ? /* @__PURE__ */ P.jsx("p", { style: { textAlign: "center", color: "#ff4444" }, children: "You already have an atom associated with this wallet" }) : /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
      /* @__PURE__ */ P.jsxs("div", { style: { marginBottom: "15px" }, children: [
        /* @__PURE__ */ P.jsx(
          "label",
          {
            style: {
              display: "block",
              marginBottom: "5px",
              fontSize: "0.9em",
              textAlign: "left"
            },
            children: "Pseudo"
          }
        ),
        /* @__PURE__ */ P.jsx(
          "input",
          {
            type: "text",
            name: "pseudo",
            value: u.pseudo,
            onChange: c,
            placeholder: "Enter your pseudo",
            style: {
              width: "100%",
              padding: "8px",
              backgroundColor: "#1e1e30",
              border: "1px solid #333",
              color: "#fff",
              borderRadius: "4px"
            }
          }
        )
      ] }),
      /* @__PURE__ */ P.jsxs("div", { style: { marginBottom: "15px" }, children: [
        /* @__PURE__ */ P.jsx(
          "label",
          {
            style: {
              display: "block",
              marginBottom: "5px",
              fontSize: "0.9em",
              textAlign: "left"
            },
            children: "User UID"
          }
        ),
        /* @__PURE__ */ P.jsx(
          "input",
          {
            type: "text",
            name: "userId",
            value: u.userId,
            onChange: c,
            placeholder: "Enter your BossFighters UID",
            style: {
              width: "100%",
              padding: "8px",
              backgroundColor: "#1e1e30",
              border: "1px solid #333",
              color: "#fff",
              borderRadius: "4px"
            }
          }
        )
      ] }),
      /* @__PURE__ */ P.jsxs("div", { style: { marginBottom: "15px" }, children: [
        /* @__PURE__ */ P.jsx(
          "label",
          {
            style: {
              display: "block",
              marginBottom: "5px",
              fontSize: "0.9em",
              textAlign: "left"
            },
            children: "Guild (Optional)"
          }
        ),
        /* @__PURE__ */ P.jsxs(
          "select",
          {
            name: "guildId",
            value: u.guildId || "",
            onChange: h,
            style: {
              width: "100%",
              padding: "8px",
              backgroundColor: "#1e1e30",
              border: "1px solid #333",
              color: "#fff",
              borderRadius: "4px"
            },
            children: [
              /* @__PURE__ */ P.jsx("option", { value: "", children: "Select a guild (optional)" }),
              g.map((_) => /* @__PURE__ */ P.jsx("option", { value: _.id.toString(), children: _.name }, _.id.toString()))
            ]
          }
        )
      ] }),
      /* @__PURE__ */ P.jsxs("div", { style: { marginBottom: "15px" }, children: [
        /* @__PURE__ */ P.jsx(
          "label",
          {
            style: {
              display: "block",
              marginBottom: "5px",
              fontSize: "0.9em",
              textAlign: "left"
            },
            children: "Profile Picture (optional)"
          }
        ),
        /* @__PURE__ */ P.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "column",
              gap: "10px"
            },
            children: [
              /* @__PURE__ */ P.jsxs("div", { children: [
                /* @__PURE__ */ P.jsx(
                  "button",
                  {
                    onClick: () => {
                      var _;
                      return (_ = y.current) == null ? void 0 : _.click();
                    },
                    style: {
                      padding: "8px 15px",
                      backgroundColor: "#2e2e40",
                      color: "#fff",
                      border: "1px solid #333",
                      borderRadius: "4px",
                      cursor: "pointer",
                      marginRight: "10px"
                    },
                    disabled: m,
                    children: m ? "Upload in progress..." : "Choose an image"
                  }
                ),
                /* @__PURE__ */ P.jsx(
                  "input",
                  {
                    ref: y,
                    type: "file",
                    accept: "image/*",
                    onChange: d,
                    style: { display: "none" }
                  }
                )
              ] }),
              /* @__PURE__ */ P.jsx(
                "p",
                {
                  style: { fontSize: "0.8em", color: "#aaa", marginTop: "0px" },
                  children: "This image will be used as your player's profile picture."
                }
              ),
              u.image && /* @__PURE__ */ P.jsxs("div", { style: { marginTop: "10px" }, children: [
                /* @__PURE__ */ P.jsx(
                  "p",
                  {
                    style: {
                      fontSize: "0.8em",
                      color: "#aaa",
                      marginBottom: "5px"
                    },
                    children: "Image preview:"
                  }
                ),
                /* @__PURE__ */ P.jsx(yk, { src: u.image })
              ] })
            ]
          }
        )
      ] }),
      /* @__PURE__ */ P.jsx("div", { style: { textAlign: "center" }, children: /* @__PURE__ */ P.jsx(
        "button",
        {
          onClick: p,
          disabled: f || m,
          style: {
            padding: "8px 20px",
            backgroundColor: "#FFD32A",
            color: "#000",
            border: "none",
            borderRadius: "5px",
            cursor: "pointer",
            fontWeight: "bold",
            opacity: f || m ? 0.7 : 1
          },
          children: f ? e ? "Creating atom..." : i ? "Creating triples..." : "Creating in progress..." : "CREATE YOUR PLAYER"
        }
      ) })
    ] }) : /* @__PURE__ */ P.jsx("div", { children: /* @__PURE__ */ P.jsx("p", { style: { textAlign: "center", color: "#ff4444" }, children: "Please connect your wallet first" }) })
  ] });
}, _k = async (r) => {
  try {
    if (!pg())
      throw new Error("Vous devez être connecté pour envoyer des données à IPFS");
    const { apiUrl: e } = fg(), i = `${e}/ipfs/hash_data`, n = await xi.post(
      i,
      { data: r },
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: y_()
        }
      }
    );
    return {
      ipfsHash: n.data.ipfs_hash,
      httpUrl: n.data.http_url
    };
  } catch (e) {
    throw e instanceof Error && e.message.includes("Configuration Player-map non initialisée") ? (console.error("Erreur de configuration Player-map:", e.message), new Error("Erreur de configuration: Initialisez la bibliothèque Player-map avec PlayerMapConfig.init() avant utilisation")) : (console.error("Erreur lors du hachage de données vers IPFS:", e), e);
  }
}, Tk = ({ walletConnected: r, walletAddress: e, publicClient: i }) => ({
  createAtom: async (s) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const a = {
        "@context": "https://schema.org/",
        "@type": "Thing",
        ...s
      };
      a.image && fC(a.image) && (a.image = await gk(a.image));
      const { ipfsHash: o } = await _k(a), l = C2(o);
      console.log("Contract address:", oo), console.log("VALUE_PER_ATOM:", oy.toString()), console.log("Hex data:", l);
      const u = l;
      console.log("Calculating atom ID using keccak256(encodePacked)...");
      const c = d_(UD(["bytes"], [u])), h = BigInt(c);
      console.log("Calculated atom ID:", h.toString()), console.log("Creating atom with createAtoms...");
      const d = await r.writeContract({
        address: oo,
        abi: ju,
        functionName: "createAtoms",
        args: [
          [u],
          // data: bytes[] - tableau avec un seul élément bytes
          [oy]
          // assets: uint256[] - tableau avec la valeur pour un atome
        ],
        value: oy
      });
      return console.log("Transaction hash:", d), console.log("Atom created successfully with ID:", h.toString()), {
        atomId: h,
        ipfsHash: o
      };
    } catch (a) {
      throw console.error("Error creating atom:", a), a;
    }
  }
}), Sk = ({ walletConnected: r, walletAddress: e, publicClient: i, constants: n }) => {
  const { PLAYER_TRIPLE_TYPES: s } = n, a = async (u, c, h) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const d = i || r;
      return !d || typeof d.readContract != "function" ? (console.warn("No valid read client available to check if triple exists"), !1) : await d.readContract({
        address: oo,
        abi: ju,
        functionName: "isTriple",
        args: [u, c, h]
      });
    } catch (d) {
      if (console.error("Error checking if triple exists:", d), i && i !== r && typeof i.readContract == "function")
        try {
          return await i.readContract({
            address: oo,
            abi: ju,
            functionName: "isTriple",
            args: [u, c, h]
          });
        } catch (p) {
          console.error("Second attempt failed when checking if triple exists:", p);
        }
      return !1;
    }
  }, o = async (u) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const c = u.map((y) => `0x${y.subjectId.toString(16).padStart(64, "0")}`), h = u.map((y) => `0x${y.predicateId.toString(16).padStart(64, "0")}`), d = u.map((y) => `0x${y.objectId.toString(16).padStart(64, "0")}`), p = u.map(() => IT), f = await r.writeContract({
        address: oo,
        abi: ju,
        functionName: "createTriples",
        // Changé de "batchCreateTriple" à "createTriples"
        args: [c, h, d, p],
        // Ajouté le paramètre assets
        value: IT * BigInt(u.length),
        // Valeur pour chaque triple
        gas: 5000000n
      });
      let m;
      return r.waitForTransactionReceipt ? m = await r.waitForTransactionReceipt({ hash: f }) : f.wait ? m = await f.wait() : await new Promise((y) => setTimeout(y, 3e3)), {
        hash: typeof f == "string" ? f : f.hash,
        receipt: m
      };
    } catch (c) {
      throw console.error("Error batch creating triples:", c), c;
    }
  };
  return {
    checkTripleExists: a,
    batchCreateTriple: o,
    createPlayerTriples: async (u) => {
      const c = Object.entries(s).filter(([h, d]) => "objectId" in d && d.objectId !== null).map(([h, d]) => ({
        subjectId: u,
        predicateId: BigInt(d.predicateId),
        objectId: BigInt(d.objectId)
      }));
      return o(c);
    }
  };
}, wk = (r, e, i, n) => {
  const { PLAYER_TRIPLE_TYPES: s } = i, { createAtom: a } = Tk({ walletConnected: r, walletAddress: e, publicClient: n }), { batchCreateTriple: o } = Sk({ walletConnected: r, walletAddress: e, publicClient: n, constants: i });
  return {
    createPlayer: async (u) => {
      try {
        const c = await a({
          name: u.pseudo,
          description: u.userId,
          image: u.image
        }), h = c.atomId;
        await new Promise((d) => setTimeout(d, 2e3));
        try {
          const d = Object.entries(s).filter(([f, m]) => "objectId" in m && m.objectId !== null).map(([f, m]) => ({
            subjectId: h,
            predicateId: BigInt(m.predicateId),
            objectId: BigInt(m.objectId)
          }));
          u.guildId && d.push({
            subjectId: h,
            predicateId: BigInt(s.PLAYER_GUILD.predicateId),
            objectId: u.guildId
          });
          const p = await o(d);
          return {
            atomId: h,
            ipfsHash: c.ipfsHash,
            tripleCreated: !0,
            transactionHash: p.hash
          };
        } catch (d) {
          return console.error("Erreur lors de la création des triples:", d), {
            atomId: h,
            ipfsHash: c.ipfsHash,
            tripleCreated: !1,
            transactionHash: void 0
          };
        }
      } catch (c) {
        throw console.error("Erreur lors de la création du joueur:", c), c;
      }
    }
  };
}, mC = ({ walletConnected: r, publicClient: e }) => {
  const [i, n] = ve(null), s = [13579], a = Number(FD);
  return Ft(() => {
    (async () => {
      if (!(!r || !e))
        try {
          const l = await e.getChainId();
          n(Number(l));
        } catch (l) {
          console.error("Error checking network:", l), n(null);
        }
    })();
  }, [r, e]), {
    isCorrectNetwork: i !== null && s.includes(i),
    currentChainId: i,
    targetChainId: a,
    allowedChainIds: s
  };
}, gC = ({
  currentChainId: r,
  targetChainId: e,
  allowedChainIds: i = [13579]
}) => {
  const n = (s) => {
    switch (s) {
      case 13579:
        return "Intuition Testnet";
      default:
        return `Chain ID: ${s}`;
    }
  };
  return /* @__PURE__ */ P.jsxs("div", { style: {
    padding: "15px",
    backgroundColor: "#2e2e40",
    borderRadius: "8px",
    margin: "10px 0",
    textAlign: "center"
  }, children: [
    /* @__PURE__ */ P.jsx("p", { style: { color: "#ff4444", marginBottom: "10px" }, children: "You are not on the correct network" }),
    /* @__PURE__ */ P.jsxs("p", { style: { color: "#aaa", fontSize: "0.9em", marginBottom: "10px" }, children: [
      "Current network: ",
      r ? n(r) : "Not connected",
      /* @__PURE__ */ P.jsx("br", {}),
      "Required network: ",
      n(13579)
    ] }),
    /* @__PURE__ */ P.jsx("p", { style: { color: "#fff", fontSize: "0.9em" }, children: "Please switch to Intuition Testnet (13579) in your wallet to continue" })
  ] });
}, yC = ({
  isOpen: r,
  onClose: e,
  walletConnected: i,
  walletAddress: n,
  wagmiConfig: s,
  walletHooks: a,
  constants: o
}) => {
  const [l, u] = ve({
    pseudo: "",
    userId: "",
    image: "",
    guildId: ""
  }), [c, h] = ve(!1), [d, p] = ve(!1), [f, m] = ve(!1), [y, v] = ve(null), g = s == null ? void 0 : s.publicClient, [_, x] = ve(!1), b = gr(null), [T, S] = ve(1), [w, M] = ve(!1), [E, A] = ve(!1), [N, U] = ve(!1), { createPlayer: k } = wk(
    i,
    n || "",
    g,
    o
    // Passer les constantes personnalisées !
  ), { isCorrectNetwork: C, currentChainId: I, targetChainId: O } = mC({
    walletConnected: i,
    publicClient: s == null ? void 0 : s.publicClient
  });
  Ft(() => {
    (async () => {
      if (!(!n || !g))
        try {
          const q = RD("AtomCreated(address,address,bytes,uint256)"), Y = (await (await fetch("https://testnet.rpc.intuition.systems", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              jsonrpc: "2.0",
              method: "eth_getLogs",
              params: [{
                address: oo,
                topics: [
                  q,
                  n
                ],
                fromBlock: "0x0",
                toBlock: "latest"
              }],
              id: 1
            })
          })).json()).result || [];
          console.log("Found logs:", Y.length), h(Y.length > 0);
        } catch (q) {
          console.error("Error checking atom ownership:", q), h(!1);
        }
    })();
  }, [n, g]);
  const W = (B) => {
    const { name: q, value: G } = B.target;
    u((z) => ({
      ...z,
      [q]: G
    }));
  }, V = (B) => {
    const { name: q, value: G } = B.target;
    u((z) => ({
      ...z,
      [q]: G
    }));
  }, Q = async (B) => {
    if (!B.target.files || B.target.files.length === 0)
      return;
    const q = B.target.files[0];
    try {
      x(!0);
      const G = await mk(q);
      u((z) => ({
        ...z,
        image: G
      })), x(!1);
    } catch (G) {
      console.error("Error uploading image:", G), alert("Error uploading image. Please try again."), x(!1);
    }
  }, F = async () => {
    if (!n || !i) {
      alert("Please connect your wallet first");
      return;
    }
    if (c) {
      alert("You already have an atom!");
      return;
    }
    if (!l.pseudo || !l.userId) {
      alert("Please fill in all fields");
      return;
    }
    try {
      p(!0), M(!0), S(1);
      const B = await k({
        pseudo: l.pseudo,
        userId: l.userId,
        image: l.image || void 0,
        guildId: l.guildId ? BigInt(l.guildId) : void 0
      });
      v(B.atomId.toString()), M(!1), S(2), A(!0), await new Promise((q) => setTimeout(q, 1500)), A(!1), U(B.tripleCreated), S(3), m(!0), p(!1), setTimeout(() => {
        e(), window.location.reload();
      }, 3e3);
    } catch (B) {
      console.error("Error creating player:", B), alert("Error creating player. Please try again."), p(!1), M(!1), A(!1);
    }
  };
  return r ? /* @__PURE__ */ P.jsx(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(0, 0, 0, 0.7)",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        zIndex: 1e3
      },
      children: /* @__PURE__ */ P.jsxs(
        "div",
        {
          style: {
            backgroundColor: "#101020",
            color: "#fff",
            padding: "30px",
            borderRadius: "10px",
            maxWidth: "760px",
            width: "90%",
            position: "relative",
            border: "1px solid #FFD32A"
          },
          children: [
            /* @__PURE__ */ P.jsx(
              "div",
              {
                style: {
                  position: "absolute",
                  top: "40px",
                  right: "10px",
                  fontSize: "10px",
                  color: "#666",
                  textAlign: "left",
                  backgroundColor: "rgba(0,0,0,0.3)",
                  padding: "5px",
                  borderRadius: "3px",
                  maxWidth: "200px",
                  overflow: "hidden"
                },
                children: /* @__PURE__ */ P.jsxs("div", { children: [
                  "Wallet:",
                  " ",
                  n ? n.slice(0, 6) + "..." + n.slice(-4) : "Not connected"
                ] })
              }
            ),
            /* @__PURE__ */ P.jsx(
              "button",
              {
                onClick: e,
                style: {
                  position: "absolute",
                  top: "10px",
                  right: "10px",
                  backgroundColor: "transparent",
                  border: "none",
                  fontSize: "20px",
                  color: "#666",
                  cursor: "pointer"
                },
                children: "×"
              }
            ),
            /* @__PURE__ */ P.jsx(
              "img",
              {
                src: w2,
                alt: "Intuition Logo",
                style: { width: "100px", marginBottom: "10px" }
              }
            ),
            /* @__PURE__ */ P.jsx(
              "h2",
              {
                style: {
                  fontSize: "1.5em",
                  margin: "0 0 20px 0",
                  textAlign: "center"
                },
                children: "Create Your Player"
              }
            ),
            C ? /* @__PURE__ */ P.jsx(
              xk,
              {
                step: T,
                isCreatingAtom: w,
                isCreatingTriples: E,
                creationSuccess: f,
                atomId: y,
                tripleCreated: N,
                walletAddress: n,
                hasExistingAtom: c,
                formData: l,
                handleInputChange: W,
                handleSelectChange: V,
                handleFileUpload: Q,
                handleSubmit: F,
                isLoading: d,
                isUploading: _,
                fileInputRef: b,
                constants: o
              }
            ) : /* @__PURE__ */ P.jsx(
              gC,
              {
                currentChainId: I,
                targetChainId: O
              }
            )
          ]
        }
      )
    }
  ) : null;
};
var Ek = Object.defineProperty, Mk = (r, e, i) => e in r ? Ek(r, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : r[e] = i, Xh = (r, e, i) => Mk(r, typeof e != "symbol" ? e + "" : e, i);
function v_(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Vv = { exports: {} }, th = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KT;
function Ak() {
  if (KT) return th;
  KT = 1;
  var r = si, e = Symbol.for("react.element"), i = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(l, u, c) {
    var h, d = {}, p = null, f = null;
    c !== void 0 && (p = "" + c), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (f = u.ref);
    for (h in u) n.call(u, h) && !a.hasOwnProperty(h) && (d[h] = u[h]);
    if (l && l.defaultProps) for (h in u = l.defaultProps, u) d[h] === void 0 && (d[h] = u[h]);
    return { $$typeof: e, type: l, key: p, ref: f, props: d, _owner: s.current };
  }
  return th.Fragment = i, th.jsx = o, th.jsxs = o, th;
}
var cp = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZT;
function Ck() {
  return ZT || (ZT = 1, process.env.NODE_ENV !== "production" && function() {
    var r = si, e = Symbol.for("react.element"), i = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), m = Symbol.iterator, y = "@@iterator";
    function v(R) {
      if (R === null || typeof R != "object")
        return null;
      var J = m && R[m] || R[y];
      return typeof J == "function" ? J : null;
    }
    var g = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(R) {
      {
        for (var J = arguments.length, ce = new Array(J > 1 ? J - 1 : 0), Re = 1; Re < J; Re++)
          ce[Re - 1] = arguments[Re];
        x("error", R, ce);
      }
    }
    function x(R, J, ce) {
      {
        var Re = g.ReactDebugCurrentFrame, Ze = Re.getStackAddendum();
        Ze !== "" && (J += "%s", ce = ce.concat([Ze]));
        var at = ce.map(function(qe) {
          return String(qe);
        });
        at.unshift("Warning: " + J), Function.prototype.apply.call(console[R], console, at);
      }
    }
    var b = !1, T = !1, S = !1, w = !1, M = !1, E;
    E = Symbol.for("react.module.reference");
    function A(R) {
      return !!(typeof R == "string" || typeof R == "function" || R === n || R === a || M || R === s || R === c || R === h || w || R === f || b || T || S || typeof R == "object" && R !== null && (R.$$typeof === p || R.$$typeof === d || R.$$typeof === o || R.$$typeof === l || R.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      R.$$typeof === E || R.getModuleId !== void 0));
    }
    function N(R, J, ce) {
      var Re = R.displayName;
      if (Re)
        return Re;
      var Ze = J.displayName || J.name || "";
      return Ze !== "" ? ce + "(" + Ze + ")" : ce;
    }
    function U(R) {
      return R.displayName || "Context";
    }
    function k(R) {
      if (R == null)
        return null;
      if (typeof R.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof R == "function")
        return R.displayName || R.name || null;
      if (typeof R == "string")
        return R;
      switch (R) {
        case n:
          return "Fragment";
        case i:
          return "Portal";
        case a:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case l:
            var J = R;
            return U(J) + ".Consumer";
          case o:
            var ce = R;
            return U(ce._context) + ".Provider";
          case u:
            return N(R, R.render, "ForwardRef");
          case d:
            var Re = R.displayName || null;
            return Re !== null ? Re : k(R.type) || "Memo";
          case p: {
            var Ze = R, at = Ze._payload, qe = Ze._init;
            try {
              return k(qe(at));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var C = Object.assign, I = 0, O, W, V, Q, F, B, q;
    function G() {
    }
    G.__reactDisabledLog = !0;
    function z() {
      {
        if (I === 0) {
          O = console.log, W = console.info, V = console.warn, Q = console.error, F = console.group, B = console.groupCollapsed, q = console.groupEnd;
          var R = {
            configurable: !0,
            enumerable: !0,
            value: G,
            writable: !0
          };
          Object.defineProperties(console, {
            info: R,
            log: R,
            warn: R,
            error: R,
            group: R,
            groupCollapsed: R,
            groupEnd: R
          });
        }
        I++;
      }
    }
    function Y() {
      {
        if (I--, I === 0) {
          var R = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: C({}, R, {
              value: O
            }),
            info: C({}, R, {
              value: W
            }),
            warn: C({}, R, {
              value: V
            }),
            error: C({}, R, {
              value: Q
            }),
            group: C({}, R, {
              value: F
            }),
            groupCollapsed: C({}, R, {
              value: B
            }),
            groupEnd: C({}, R, {
              value: q
            })
          });
        }
        I < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var se = g.ReactCurrentDispatcher, ne;
    function fe(R, J, ce) {
      {
        if (ne === void 0)
          try {
            throw Error();
          } catch (Ze) {
            var Re = Ze.stack.trim().match(/\n( *(at )?)/);
            ne = Re && Re[1] || "";
          }
        return `
` + ne + R;
      }
    }
    var Se = !1, Pe;
    {
      var lt = typeof WeakMap == "function" ? WeakMap : Map;
      Pe = new lt();
    }
    function xe(R, J) {
      if (!R || Se)
        return "";
      {
        var ce = Pe.get(R);
        if (ce !== void 0)
          return ce;
      }
      var Re;
      Se = !0;
      var Ze = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var at;
      at = se.current, se.current = null, z();
      try {
        if (J) {
          var qe = function() {
            throw Error();
          };
          if (Object.defineProperty(qe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(qe, []);
            } catch (Ne) {
              Re = Ne;
            }
            Reflect.construct(R, [], qe);
          } else {
            try {
              qe.call();
            } catch (Ne) {
              Re = Ne;
            }
            R.call(qe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            Re = Ne;
          }
          R();
        }
      } catch (Ne) {
        if (Ne && Re && typeof Ne.stack == "string") {
          for (var Ge = Ne.stack.split(`
`), L = Re.stack.split(`
`), H = Ge.length - 1, te = L.length - 1; H >= 1 && te >= 0 && Ge[H] !== L[te]; )
            te--;
          for (; H >= 1 && te >= 0; H--, te--)
            if (Ge[H] !== L[te]) {
              if (H !== 1 || te !== 1)
                do
                  if (H--, te--, te < 0 || Ge[H] !== L[te]) {
                    var oe = `
` + Ge[H].replace(" at new ", " at ");
                    return R.displayName && oe.includes("<anonymous>") && (oe = oe.replace("<anonymous>", R.displayName)), typeof R == "function" && Pe.set(R, oe), oe;
                  }
                while (H >= 1 && te >= 0);
              break;
            }
        }
      } finally {
        Se = !1, se.current = at, Y(), Error.prepareStackTrace = Ze;
      }
      var K = R ? R.displayName || R.name : "", Me = K ? fe(K) : "";
      return typeof R == "function" && Pe.set(R, Me), Me;
    }
    function vt(R, J, ce) {
      return xe(R, !1);
    }
    function Z(R) {
      var J = R.prototype;
      return !!(J && J.isReactComponent);
    }
    function Ht(R, J, ce) {
      if (R == null)
        return "";
      if (typeof R == "function")
        return xe(R, Z(R));
      if (typeof R == "string")
        return fe(R);
      switch (R) {
        case c:
          return fe("Suspense");
        case h:
          return fe("SuspenseList");
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case u:
            return vt(R.render);
          case d:
            return Ht(R.type, J, ce);
          case p: {
            var Re = R, Ze = Re._payload, at = Re._init;
            try {
              return Ht(at(Ze), J, ce);
            } catch {
            }
          }
        }
      return "";
    }
    var nt = Object.prototype.hasOwnProperty, Tt = {}, We = g.ReactDebugCurrentFrame;
    function At(R) {
      if (R) {
        var J = R._owner, ce = Ht(R.type, R._source, J ? J.type : null);
        We.setExtraStackFrame(ce);
      } else
        We.setExtraStackFrame(null);
    }
    function st(R, J, ce, Re, Ze) {
      {
        var at = Function.call.bind(nt);
        for (var qe in R)
          if (at(R, qe)) {
            var Ge = void 0;
            try {
              if (typeof R[qe] != "function") {
                var L = Error((Re || "React class") + ": " + ce + " type `" + qe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof R[qe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw L.name = "Invariant Violation", L;
              }
              Ge = R[qe](J, qe, Re, ce, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (H) {
              Ge = H;
            }
            Ge && !(Ge instanceof Error) && (At(Ze), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Re || "React class", ce, qe, typeof Ge), At(null)), Ge instanceof Error && !(Ge.message in Tt) && (Tt[Ge.message] = !0, At(Ze), _("Failed %s type: %s", ce, Ge.message), At(null));
          }
      }
    }
    var j = Array.isArray;
    function D(R) {
      return j(R);
    }
    function le(R) {
      {
        var J = typeof Symbol == "function" && Symbol.toStringTag, ce = J && R[Symbol.toStringTag] || R.constructor.name || "Object";
        return ce;
      }
    }
    function Te(R) {
      try {
        return Ce(R), !1;
      } catch {
        return !0;
      }
    }
    function Ce(R) {
      return "" + R;
    }
    function _e(R) {
      if (Te(R))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", le(R)), Ce(R);
    }
    var Je = g.ReactCurrentOwner, Be = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Xe, Pt;
    function Ie(R) {
      if (nt.call(R, "ref")) {
        var J = Object.getOwnPropertyDescriptor(R, "ref").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return R.ref !== void 0;
    }
    function $e(R) {
      if (nt.call(R, "key")) {
        var J = Object.getOwnPropertyDescriptor(R, "key").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return R.key !== void 0;
    }
    function ut(R, J) {
      typeof R.ref == "string" && Je.current;
    }
    function ft(R, J) {
      {
        var ce = function() {
          Xe || (Xe = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "key", {
          get: ce,
          configurable: !0
        });
      }
    }
    function Ye(R, J) {
      {
        var ce = function() {
          Pt || (Pt = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "ref", {
          get: ce,
          configurable: !0
        });
      }
    }
    var Ot = function(R, J, ce, Re, Ze, at, qe) {
      var Ge = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: R,
        key: J,
        ref: ce,
        props: qe,
        // Record the component responsible for creating this element.
        _owner: at
      };
      return Ge._store = {}, Object.defineProperty(Ge._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ge, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Re
      }), Object.defineProperty(Ge, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ze
      }), Object.freeze && (Object.freeze(Ge.props), Object.freeze(Ge)), Ge;
    };
    function bt(R, J, ce, Re, Ze) {
      {
        var at, qe = {}, Ge = null, L = null;
        ce !== void 0 && (_e(ce), Ge = "" + ce), $e(J) && (_e(J.key), Ge = "" + J.key), Ie(J) && (L = J.ref, ut(J));
        for (at in J)
          nt.call(J, at) && !Be.hasOwnProperty(at) && (qe[at] = J[at]);
        if (R && R.defaultProps) {
          var H = R.defaultProps;
          for (at in H)
            qe[at] === void 0 && (qe[at] = H[at]);
        }
        if (Ge || L) {
          var te = typeof R == "function" ? R.displayName || R.name || "Unknown" : R;
          Ge && ft(qe, te), L && Ye(qe, te);
        }
        return Ot(R, Ge, L, Ze, Re, Je.current, qe);
      }
    }
    var jt = g.ReactCurrentOwner, ee = g.ReactDebugCurrentFrame;
    function Le(R) {
      if (R) {
        var J = R._owner, ce = Ht(R.type, R._source, J ? J.type : null);
        ee.setExtraStackFrame(ce);
      } else
        ee.setExtraStackFrame(null);
    }
    var de;
    de = !1;
    function Ee(R) {
      return typeof R == "object" && R !== null && R.$$typeof === e;
    }
    function ze() {
      {
        if (jt.current) {
          var R = k(jt.current.type);
          if (R)
            return `

Check the render method of \`` + R + "`.";
        }
        return "";
      }
    }
    function Ue(R) {
      return "";
    }
    var Ct = {};
    function ni(R) {
      {
        var J = ze();
        if (!J) {
          var ce = typeof R == "string" ? R : R.displayName || R.name;
          ce && (J = `

Check the top-level render call using <` + ce + ">.");
        }
        return J;
      }
    }
    function _i(R, J) {
      {
        if (!R._store || R._store.validated || R.key != null)
          return;
        R._store.validated = !0;
        var ce = ni(J);
        if (Ct[ce])
          return;
        Ct[ce] = !0;
        var Re = "";
        R && R._owner && R._owner !== jt.current && (Re = " It was passed a child from " + k(R._owner.type) + "."), Le(R), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ce, Re), Le(null);
      }
    }
    function Bt(R, J) {
      {
        if (typeof R != "object")
          return;
        if (D(R))
          for (var ce = 0; ce < R.length; ce++) {
            var Re = R[ce];
            Ee(Re) && _i(Re, J);
          }
        else if (Ee(R))
          R._store && (R._store.validated = !0);
        else if (R) {
          var Ze = v(R);
          if (typeof Ze == "function" && Ze !== R.entries)
            for (var at = Ze.call(R), qe; !(qe = at.next()).done; )
              Ee(qe.value) && _i(qe.value, J);
        }
      }
    }
    function yr(R) {
      {
        var J = R.type;
        if (J == null || typeof J == "string")
          return;
        var ce;
        if (typeof J == "function")
          ce = J.propTypes;
        else if (typeof J == "object" && (J.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        J.$$typeof === d))
          ce = J.propTypes;
        else
          return;
        if (ce) {
          var Re = k(J);
          st(ce, R.props, "prop", Re, R);
        } else if (J.PropTypes !== void 0 && !de) {
          de = !0;
          var Ze = k(J);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ze || "Unknown");
        }
        typeof J.getDefaultProps == "function" && !J.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Xr(R) {
      {
        for (var J = Object.keys(R.props), ce = 0; ce < J.length; ce++) {
          var Re = J[ce];
          if (Re !== "children" && Re !== "key") {
            Le(R), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Re), Le(null);
            break;
          }
        }
        R.ref !== null && (Le(R), _("Invalid attribute `ref` supplied to `React.Fragment`."), Le(null));
      }
    }
    var Aa = {};
    function Ca(R, J, ce, Re, Ze, at) {
      {
        var qe = A(R);
        if (!qe) {
          var Ge = "";
          (R === void 0 || typeof R == "object" && R !== null && Object.keys(R).length === 0) && (Ge += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var L = Ue();
          L ? Ge += L : Ge += ze();
          var H;
          R === null ? H = "null" : D(R) ? H = "array" : R !== void 0 && R.$$typeof === e ? (H = "<" + (k(R.type) || "Unknown") + " />", Ge = " Did you accidentally export a JSX literal instead of a component?") : H = typeof R, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", H, Ge);
        }
        var te = bt(R, J, ce, Ze, at);
        if (te == null)
          return te;
        if (qe) {
          var oe = J.children;
          if (oe !== void 0)
            if (Re)
              if (D(oe)) {
                for (var K = 0; K < oe.length; K++)
                  Bt(oe[K], R);
                Object.freeze && Object.freeze(oe);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Bt(oe, R);
        }
        if (nt.call(J, "key")) {
          var Me = k(R), Ne = Object.keys(J).filter(function(gt) {
            return gt !== "key";
          }), Ke = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Aa[Me + Ke]) {
            var tt = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            _(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ke, Me, tt, Me), Aa[Me + Ke] = !0;
          }
        }
        return R === n ? Xr(te) : yr(te), te;
      }
    }
    function Mn(R, J, ce) {
      return Ca(R, J, ce, !0);
    }
    function Mo(R, J, ce) {
      return Ca(R, J, ce, !1);
    }
    var kl = Mo, Ul = Mn;
    cp.Fragment = n, cp.jsx = kl, cp.jsxs = Ul;
  }()), cp;
}
process.env.NODE_ENV === "production" ? Vv.exports = Ak() : Vv.exports = Ck();
var ae = Vv.exports;
const Ei = {
  SUBJECT: "#FFB300",
  // Jaune/orangé accessible
  PREDICATE: "#1976D2",
  // Bleu profond accessible
  OBJECT: "#43A047"
  // Vert foncé accessible
}, Nu = (r) => {
  switch (r) {
    case "subject":
      return Ei.SUBJECT;
    case "predicate":
      return Ei.PREDICATE;
    case "object":
      return Ei.OBJECT;
    default:
      return "#444";
  }
}, QT = () => /* @__PURE__ */ ae.jsxs(
  "div",
  {
    style: {
      position: "absolute",
      bottom: 80,
      right: 30,
      zIndex: 1e3,
      background: "#18181b",
      borderRadius: "10px",
      border: "2px solid #ffd32a",
      padding: "16px 24px",
      boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)"
    },
    children: [
      /* @__PURE__ */ ae.jsx(
        "h4",
        {
          style: {
            margin: "0 0 16px 0",
            fontSize: "18px",
            color: "#ffd32a",
            fontWeight: "bold",
            letterSpacing: "0.5px"
          },
          children: "Graph Legend"
        }
      ),
      /* @__PURE__ */ ae.jsxs(
        "ul",
        {
          style: {
            listStyle: "none",
            padding: 0,
            margin: 0,
            display: "flex",
            flexDirection: "column",
            gap: "12px"
          },
          children: [
            /* @__PURE__ */ ae.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ ae.jsx(
                    "span",
                    {
                      style: {
                        width: "20px",
                        height: "20px",
                        backgroundColor: Ei.SUBJECT,
                        borderRadius: "50%",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ ae.jsx("span", { style: { fontSize: "15px" }, children: "Subject" })
                ]
              }
            ),
            /* @__PURE__ */ ae.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ ae.jsx(
                    "span",
                    {
                      style: {
                        width: "20px",
                        height: "20px",
                        backgroundColor: Ei.OBJECT,
                        borderRadius: "4px",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ ae.jsx("span", { style: { fontSize: "15px" }, children: "Object" })
                ]
              }
            ),
            /* @__PURE__ */ ae.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ ae.jsx(
                    "span",
                    {
                      style: {
                        width: "24px",
                        height: "12px",
                        backgroundColor: Ei.PREDICATE,
                        borderRadius: "4px",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ ae.jsx("span", { style: { fontSize: "15px" }, children: "Predicate" })
                ]
              }
            )
          ]
        }
      )
    ]
  }
);
class Vu extends Error {
  constructor(e, i) {
    const n = `${Vu.extractMessage(e)}: ${JSON.stringify({
      response: e,
      request: i
    })}`;
    super(n), Xh(this, "response"), Xh(this, "request"), Object.setPrototypeOf(this, Vu.prototype), this.response = e, this.request = i, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, Vu);
  }
  static extractMessage(e) {
    var i, n;
    return ((n = (i = e.errors) == null ? void 0 : i[0]) == null ? void 0 : n.message) ?? `GraphQL Error (Code: ${String(e.status)})`;
  }
}
const JT = (r) => r.toUpperCase(), hy = (r) => typeof r == "function" ? r() : r, vC = (r, e) => r.map((i, n) => [i, e[n]]), Bl = (r) => {
  let e = {};
  return r instanceof Headers ? e = Rk(r) : Array.isArray(r) ? r.forEach(([i, n]) => {
    i && n !== void 0 && (e[i] = n);
  }) : r && (e = r), e;
}, Rk = (r) => {
  const e = {};
  return r.forEach((i, n) => {
    e[n] = i;
  }), e;
}, Nk = (r) => {
  try {
    const e = r();
    return Pk(e) ? e.catch((i) => eS(i)) : e;
  } catch (e) {
    return eS(e);
  }
}, eS = (r) => r instanceof Error ? r : new Error(String(r)), Pk = (r) => typeof r == "object" && r !== null && "then" in r && typeof r.then == "function" && "catch" in r && typeof r.catch == "function" && "finally" in r && typeof r.finally == "function", b_ = (r) => {
  throw new Error(`Unhandled case: ${String(r)}`);
}, Vf = (r) => typeof r == "object" && r !== null && !Array.isArray(r), Ik = (r, e) => r.documents ? r : {
  documents: r,
  requestHeaders: e,
  signal: void 0
}, Ok = (r, e, i) => r.query ? r : {
  query: r,
  variables: e,
  requestHeaders: i,
  signal: void 0
};
function Gf(r, e) {
  throw new Error(e);
}
function Dk(r) {
  return typeof r == "object" && r !== null;
}
function Lk(r, e) {
  throw new Error(
    "Unexpected invariant triggered."
  );
}
const kk = /\r\n|[\n\r]/g;
function Gv(r, e) {
  let i = 0, n = 1;
  for (const s of r.body.matchAll(kk)) {
    if (typeof s.index == "number" || Lk(), s.index >= e)
      break;
    i = s.index + s[0].length, n += 1;
  }
  return {
    line: n,
    column: e + 1 - i
  };
}
function Uk(r) {
  return bC(
    r.source,
    Gv(r.source, r.start)
  );
}
function bC(r, e) {
  const i = r.locationOffset.column - 1, n = "".padStart(i) + r.body, s = e.line - 1, a = r.locationOffset.line - 1, o = e.line + a, l = e.line === 1 ? i : 0, u = e.column + l, c = `${r.name}:${o}:${u}
`, h = n.split(/\r\n|[\n\r]/g), d = h[s];
  if (d.length > 120) {
    const p = Math.floor(u / 80), f = u % 80, m = [];
    for (let y = 0; y < d.length; y += 80)
      m.push(d.slice(y, y + 80));
    return c + tS([
      [`${o} |`, m[0]],
      ...m.slice(1, p + 1).map((y) => ["|", y]),
      ["|", "^".padStart(f)],
      ["|", m[p + 1]]
    ]);
  }
  return c + tS([
    // Lines specified like this: ["prefix", "string"],
    [`${o - 1} |`, h[s - 1]],
    [`${o} |`, d],
    ["|", "^".padStart(u)],
    [`${o + 1} |`, h[s + 1]]
  ]);
}
function tS(r) {
  const e = r.filter(([n, s]) => s !== void 0), i = Math.max(...e.map(([n]) => n.length));
  return e.map(([n, s]) => n.padStart(i) + (s ? " " + s : "")).join(`
`);
}
function Fk(r) {
  const e = r[0];
  return e == null || "kind" in e || "length" in e ? {
    nodes: e,
    source: r[1],
    positions: r[2],
    path: r[3],
    originalError: r[4],
    extensions: r[5]
  } : e;
}
class x_ extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(e, ...i) {
    var n, s, a;
    const { nodes: o, source: l, positions: u, path: c, originalError: h, extensions: d } = Fk(i);
    super(e), this.name = "GraphQLError", this.path = c ?? void 0, this.originalError = h ?? void 0, this.nodes = iS(
      Array.isArray(o) ? o : o ? [o] : void 0
    );
    const p = iS(
      (n = this.nodes) === null || n === void 0 ? void 0 : n.map((m) => m.loc).filter((m) => m != null)
    );
    this.source = l ?? (p == null || (s = p[0]) === null || s === void 0 ? void 0 : s.source), this.positions = u ?? (p == null ? void 0 : p.map((m) => m.start)), this.locations = u && l ? u.map((m) => Gv(l, m)) : p == null ? void 0 : p.map((m) => Gv(m.source, m.start));
    const f = Dk(
      h == null ? void 0 : h.extensions
    ) ? h == null ? void 0 : h.extensions : void 0;
    this.extensions = (a = d ?? f) !== null && a !== void 0 ? a : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), h != null && h.stack ? Object.defineProperty(this, "stack", {
      value: h.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, x_) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let e = this.message;
    if (this.nodes)
      for (const i of this.nodes)
        i.loc && (e += `

` + Uk(i.loc));
    else if (this.source && this.locations)
      for (const i of this.locations)
        e += `

` + bC(this.source, i);
    return e;
  }
  toJSON() {
    const e = {
      message: this.message
    };
    return this.locations != null && (e.locations = this.locations), this.path != null && (e.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (e.extensions = this.extensions), e;
  }
}
function iS(r) {
  return r === void 0 || r.length === 0 ? void 0 : r;
}
function $i(r, e, i) {
  return new x_(`Syntax Error: ${i}`, {
    source: r,
    positions: [e]
  });
}
class Bk {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(e, i, n) {
    this.start = e.start, this.end = i.end, this.startToken = e, this.endToken = i, this.source = n;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class xC {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(e, i, n, s, a, o) {
    this.kind = e, this.start = i, this.end = n, this.line = s, this.column = a, this.value = o, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const _C = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, zk = new Set(Object.keys(_C));
function rS(r) {
  const e = r == null ? void 0 : r.kind;
  return typeof e == "string" && zk.has(e);
}
var il;
(function(r) {
  r.QUERY = "query", r.MUTATION = "mutation", r.SUBSCRIPTION = "subscription";
})(il || (il = {}));
var Hv;
(function(r) {
  r.QUERY = "QUERY", r.MUTATION = "MUTATION", r.SUBSCRIPTION = "SUBSCRIPTION", r.FIELD = "FIELD", r.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", r.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", r.INLINE_FRAGMENT = "INLINE_FRAGMENT", r.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", r.SCHEMA = "SCHEMA", r.SCALAR = "SCALAR", r.OBJECT = "OBJECT", r.FIELD_DEFINITION = "FIELD_DEFINITION", r.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", r.INTERFACE = "INTERFACE", r.UNION = "UNION", r.ENUM = "ENUM", r.ENUM_VALUE = "ENUM_VALUE", r.INPUT_OBJECT = "INPUT_OBJECT", r.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(Hv || (Hv = {}));
var pt;
(function(r) {
  r.NAME = "Name", r.DOCUMENT = "Document", r.OPERATION_DEFINITION = "OperationDefinition", r.VARIABLE_DEFINITION = "VariableDefinition", r.SELECTION_SET = "SelectionSet", r.FIELD = "Field", r.ARGUMENT = "Argument", r.FRAGMENT_SPREAD = "FragmentSpread", r.INLINE_FRAGMENT = "InlineFragment", r.FRAGMENT_DEFINITION = "FragmentDefinition", r.VARIABLE = "Variable", r.INT = "IntValue", r.FLOAT = "FloatValue", r.STRING = "StringValue", r.BOOLEAN = "BooleanValue", r.NULL = "NullValue", r.ENUM = "EnumValue", r.LIST = "ListValue", r.OBJECT = "ObjectValue", r.OBJECT_FIELD = "ObjectField", r.DIRECTIVE = "Directive", r.NAMED_TYPE = "NamedType", r.LIST_TYPE = "ListType", r.NON_NULL_TYPE = "NonNullType", r.SCHEMA_DEFINITION = "SchemaDefinition", r.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", r.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", r.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", r.FIELD_DEFINITION = "FieldDefinition", r.INPUT_VALUE_DEFINITION = "InputValueDefinition", r.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", r.UNION_TYPE_DEFINITION = "UnionTypeDefinition", r.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", r.ENUM_VALUE_DEFINITION = "EnumValueDefinition", r.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", r.DIRECTIVE_DEFINITION = "DirectiveDefinition", r.SCHEMA_EXTENSION = "SchemaExtension", r.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", r.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", r.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", r.UNION_TYPE_EXTENSION = "UnionTypeExtension", r.ENUM_TYPE_EXTENSION = "EnumTypeExtension", r.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(pt || (pt = {}));
function Wv(r) {
  return r === 9 || r === 32;
}
function ud(r) {
  return r >= 48 && r <= 57;
}
function TC(r) {
  return r >= 97 && r <= 122 || // A-Z
  r >= 65 && r <= 90;
}
function SC(r) {
  return TC(r) || r === 95;
}
function jk(r) {
  return TC(r) || ud(r) || r === 95;
}
function Vk(r) {
  var e;
  let i = Number.MAX_SAFE_INTEGER, n = null, s = -1;
  for (let o = 0; o < r.length; ++o) {
    var a;
    const l = r[o], u = Gk(l);
    u !== l.length && (n = (a = n) !== null && a !== void 0 ? a : o, s = o, o !== 0 && u < i && (i = u));
  }
  return r.map((o, l) => l === 0 ? o : o.slice(i)).slice(
    (e = n) !== null && e !== void 0 ? e : 0,
    s + 1
  );
}
function Gk(r) {
  let e = 0;
  for (; e < r.length && Wv(r.charCodeAt(e)); )
    ++e;
  return e;
}
function Hk(r, e) {
  const i = r.replace(/"""/g, '\\"""'), n = i.split(/\r\n|[\n\r]/g), s = n.length === 1, a = n.length > 1 && n.slice(1).every((f) => f.length === 0 || Wv(f.charCodeAt(0))), o = i.endsWith('\\"""'), l = r.endsWith('"') && !o, u = r.endsWith("\\"), c = l || u, h = (
    // add leading and trailing new lines only if it improves readability
    !s || r.length > 70 || c || a || o
  );
  let d = "";
  const p = s && Wv(r.charCodeAt(0));
  return (h && !p || a) && (d += `
`), d += i, (h || c) && (d += `
`), '"""' + d + '"""';
}
var we;
(function(r) {
  r.SOF = "<SOF>", r.EOF = "<EOF>", r.BANG = "!", r.DOLLAR = "$", r.AMP = "&", r.PAREN_L = "(", r.PAREN_R = ")", r.SPREAD = "...", r.COLON = ":", r.EQUALS = "=", r.AT = "@", r.BRACKET_L = "[", r.BRACKET_R = "]", r.BRACE_L = "{", r.PIPE = "|", r.BRACE_R = "}", r.NAME = "Name", r.INT = "Int", r.FLOAT = "Float", r.STRING = "String", r.BLOCK_STRING = "BlockString", r.COMMENT = "Comment";
})(we || (we = {}));
class Wk {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(e) {
    const i = new xC(we.SOF, 0, 0, 0, 0);
    this.source = e, this.lastToken = i, this.token = i, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let e = this.token;
    if (e.kind !== we.EOF)
      do
        if (e.next)
          e = e.next;
        else {
          const i = Xk(this, e.end);
          e.next = i, i.prev = e, e = i;
        }
      while (e.kind === we.COMMENT);
    return e;
  }
}
function qk(r) {
  return r === we.BANG || r === we.DOLLAR || r === we.AMP || r === we.PAREN_L || r === we.PAREN_R || r === we.SPREAD || r === we.COLON || r === we.EQUALS || r === we.AT || r === we.BRACKET_L || r === we.BRACKET_R || r === we.BRACE_L || r === we.PIPE || r === we.BRACE_R;
}
function Oc(r) {
  return r >= 0 && r <= 55295 || r >= 57344 && r <= 1114111;
}
function mg(r, e) {
  return wC(r.charCodeAt(e)) && EC(r.charCodeAt(e + 1));
}
function wC(r) {
  return r >= 55296 && r <= 56319;
}
function EC(r) {
  return r >= 56320 && r <= 57343;
}
function bl(r, e) {
  const i = r.source.body.codePointAt(e);
  if (i === void 0)
    return we.EOF;
  if (i >= 32 && i <= 126) {
    const n = String.fromCodePoint(i);
    return n === '"' ? `'"'` : `"${n}"`;
  }
  return "U+" + i.toString(16).toUpperCase().padStart(4, "0");
}
function Di(r, e, i, n, s) {
  const a = r.line, o = 1 + i - r.lineStart;
  return new xC(e, i, n, a, o, s);
}
function Xk(r, e) {
  const i = r.source.body, n = i.length;
  let s = e;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    switch (a) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++s;
        continue;
      case 10:
        ++s, ++r.line, r.lineStart = s;
        continue;
      case 13:
        i.charCodeAt(s + 1) === 10 ? s += 2 : ++s, ++r.line, r.lineStart = s;
        continue;
      case 35:
        return $k(r, s);
      case 33:
        return Di(r, we.BANG, s, s + 1);
      case 36:
        return Di(r, we.DOLLAR, s, s + 1);
      case 38:
        return Di(r, we.AMP, s, s + 1);
      case 40:
        return Di(r, we.PAREN_L, s, s + 1);
      case 41:
        return Di(r, we.PAREN_R, s, s + 1);
      case 46:
        if (i.charCodeAt(s + 1) === 46 && i.charCodeAt(s + 2) === 46)
          return Di(r, we.SPREAD, s, s + 3);
        break;
      case 58:
        return Di(r, we.COLON, s, s + 1);
      case 61:
        return Di(r, we.EQUALS, s, s + 1);
      case 64:
        return Di(r, we.AT, s, s + 1);
      case 91:
        return Di(r, we.BRACKET_L, s, s + 1);
      case 93:
        return Di(r, we.BRACKET_R, s, s + 1);
      case 123:
        return Di(r, we.BRACE_L, s, s + 1);
      case 124:
        return Di(r, we.PIPE, s, s + 1);
      case 125:
        return Di(r, we.BRACE_R, s, s + 1);
      case 34:
        return i.charCodeAt(s + 1) === 34 && i.charCodeAt(s + 2) === 34 ? eU(r, s) : Kk(r, s);
    }
    if (ud(a) || a === 45)
      return Yk(r, s, a);
    if (SC(a))
      return tU(r, s);
    throw $i(
      r.source,
      s,
      a === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Oc(a) || mg(i, s) ? `Unexpected character: ${bl(r, s)}.` : `Invalid character: ${bl(r, s)}.`
    );
  }
  return Di(r, we.EOF, n, n);
}
function $k(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    if (a === 10 || a === 13)
      break;
    if (Oc(a))
      ++s;
    else if (mg(i, s))
      s += 2;
    else
      break;
  }
  return Di(
    r,
    we.COMMENT,
    e,
    s,
    i.slice(e + 1, s)
  );
}
function Yk(r, e, i) {
  const n = r.source.body;
  let s = e, a = i, o = !1;
  if (a === 45 && (a = n.charCodeAt(++s)), a === 48) {
    if (a = n.charCodeAt(++s), ud(a))
      throw $i(
        r.source,
        s,
        `Invalid number, unexpected digit after 0: ${bl(
          r,
          s
        )}.`
      );
  } else
    s = dy(r, s, a), a = n.charCodeAt(s);
  if (a === 46 && (o = !0, a = n.charCodeAt(++s), s = dy(r, s, a), a = n.charCodeAt(s)), (a === 69 || a === 101) && (o = !0, a = n.charCodeAt(++s), (a === 43 || a === 45) && (a = n.charCodeAt(++s)), s = dy(r, s, a), a = n.charCodeAt(s)), a === 46 || SC(a))
    throw $i(
      r.source,
      s,
      `Invalid number, expected digit but got: ${bl(
        r,
        s
      )}.`
    );
  return Di(
    r,
    o ? we.FLOAT : we.INT,
    e,
    s,
    n.slice(e, s)
  );
}
function dy(r, e, i) {
  if (!ud(i))
    throw $i(
      r.source,
      e,
      `Invalid number, expected digit but got: ${bl(
        r,
        e
      )}.`
    );
  const n = r.source.body;
  let s = e + 1;
  for (; ud(n.charCodeAt(s)); )
    ++s;
  return s;
}
function Kk(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1, a = s, o = "";
  for (; s < n; ) {
    const l = i.charCodeAt(s);
    if (l === 34)
      return o += i.slice(a, s), Di(r, we.STRING, e, s + 1, o);
    if (l === 92) {
      o += i.slice(a, s);
      const u = i.charCodeAt(s + 1) === 117 ? i.charCodeAt(s + 2) === 123 ? Zk(r, s) : Qk(r, s) : Jk(r, s);
      o += u.value, s += u.size, a = s;
      continue;
    }
    if (l === 10 || l === 13)
      break;
    if (Oc(l))
      ++s;
    else if (mg(i, s))
      s += 2;
    else
      throw $i(
        r.source,
        s,
        `Invalid character within String: ${bl(
          r,
          s
        )}.`
      );
  }
  throw $i(r.source, s, "Unterminated string.");
}
function Zk(r, e) {
  const i = r.source.body;
  let n = 0, s = 3;
  for (; s < 12; ) {
    const a = i.charCodeAt(e + s++);
    if (a === 125) {
      if (s < 5 || !Oc(n))
        break;
      return {
        value: String.fromCodePoint(n),
        size: s
      };
    }
    if (n = n << 4 | Uh(a), n < 0)
      break;
  }
  throw $i(
    r.source,
    e,
    `Invalid Unicode escape sequence: "${i.slice(
      e,
      e + s
    )}".`
  );
}
function Qk(r, e) {
  const i = r.source.body, n = nS(i, e + 2);
  if (Oc(n))
    return {
      value: String.fromCodePoint(n),
      size: 6
    };
  if (wC(n) && i.charCodeAt(e + 6) === 92 && i.charCodeAt(e + 7) === 117) {
    const s = nS(i, e + 8);
    if (EC(s))
      return {
        value: String.fromCodePoint(n, s),
        size: 12
      };
  }
  throw $i(
    r.source,
    e,
    `Invalid Unicode escape sequence: "${i.slice(e, e + 6)}".`
  );
}
function nS(r, e) {
  return Uh(r.charCodeAt(e)) << 12 | Uh(r.charCodeAt(e + 1)) << 8 | Uh(r.charCodeAt(e + 2)) << 4 | Uh(r.charCodeAt(e + 3));
}
function Uh(r) {
  return r >= 48 && r <= 57 ? r - 48 : r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : -1;
}
function Jk(r, e) {
  const i = r.source.body;
  switch (i.charCodeAt(e + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw $i(
    r.source,
    e,
    `Invalid character escape sequence: "${i.slice(
      e,
      e + 2
    )}".`
  );
}
function eU(r, e) {
  const i = r.source.body, n = i.length;
  let s = r.lineStart, a = e + 3, o = a, l = "";
  const u = [];
  for (; a < n; ) {
    const c = i.charCodeAt(a);
    if (c === 34 && i.charCodeAt(a + 1) === 34 && i.charCodeAt(a + 2) === 34) {
      l += i.slice(o, a), u.push(l);
      const h = Di(
        r,
        we.BLOCK_STRING,
        e,
        a + 3,
        // Return a string of the lines joined with U+000A.
        Vk(u).join(`
`)
      );
      return r.line += u.length - 1, r.lineStart = s, h;
    }
    if (c === 92 && i.charCodeAt(a + 1) === 34 && i.charCodeAt(a + 2) === 34 && i.charCodeAt(a + 3) === 34) {
      l += i.slice(o, a), o = a + 1, a += 4;
      continue;
    }
    if (c === 10 || c === 13) {
      l += i.slice(o, a), u.push(l), c === 13 && i.charCodeAt(a + 1) === 10 ? a += 2 : ++a, l = "", o = a, s = a;
      continue;
    }
    if (Oc(c))
      ++a;
    else if (mg(i, a))
      a += 2;
    else
      throw $i(
        r.source,
        a,
        `Invalid character within String: ${bl(
          r,
          a
        )}.`
      );
  }
  throw $i(r.source, a, "Unterminated string.");
}
function tU(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    if (jk(a))
      ++s;
    else
      break;
  }
  return Di(
    r,
    we.NAME,
    e,
    s,
    i.slice(e, s)
  );
}
const iU = 10, MC = 2;
function __(r) {
  return gg(r, []);
}
function gg(r, e) {
  switch (typeof r) {
    case "string":
      return JSON.stringify(r);
    case "function":
      return r.name ? `[function ${r.name}]` : "[function]";
    case "object":
      return rU(r, e);
    default:
      return String(r);
  }
}
function rU(r, e) {
  if (r === null)
    return "null";
  if (e.includes(r))
    return "[Circular]";
  const i = [...e, r];
  if (nU(r)) {
    const n = r.toJSON();
    if (n !== r)
      return typeof n == "string" ? n : gg(n, i);
  } else if (Array.isArray(r))
    return aU(r, i);
  return sU(r, i);
}
function nU(r) {
  return typeof r.toJSON == "function";
}
function sU(r, e) {
  const i = Object.entries(r);
  return i.length === 0 ? "{}" : e.length > MC ? "[" + oU(r) + "]" : "{ " + i.map(
    ([n, s]) => n + ": " + gg(s, e)
  ).join(", ") + " }";
}
function aU(r, e) {
  if (r.length === 0)
    return "[]";
  if (e.length > MC)
    return "[Array]";
  const i = Math.min(iU, r.length), n = r.length - i, s = [];
  for (let a = 0; a < i; ++a)
    s.push(gg(r[a], e));
  return n === 1 ? s.push("... 1 more item") : n > 1 && s.push(`... ${n} more items`), "[" + s.join(", ") + "]";
}
function oU(r) {
  const e = Object.prototype.toString.call(r).replace(/^\[object /, "").replace(/]$/, "");
  if (e === "Object" && typeof r.constructor == "function") {
    const i = r.constructor.name;
    if (typeof i == "string" && i !== "")
      return i;
  }
  return e;
}
const lU = globalThis.process && // eslint-disable-next-line no-undef
process.env.NODE_ENV === "production", uU = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  lU ? function(r, e) {
    return r instanceof e;
  } : function(r, e) {
    if (r instanceof e)
      return !0;
    if (typeof r == "object" && r !== null) {
      var i;
      const n = e.prototype[Symbol.toStringTag], s = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in r ? r[Symbol.toStringTag] : (i = r.constructor) === null || i === void 0 ? void 0 : i.name
      );
      if (n === s) {
        const a = __(r);
        throw new Error(`Cannot use ${n} "${a}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
let AC = class {
  constructor(r, e = "GraphQL request", i = {
    line: 1,
    column: 1
  }) {
    typeof r == "string" || Gf(!1, `Body must be a string. Received: ${__(r)}.`), this.body = r, this.name = e, this.locationOffset = i, this.locationOffset.line > 0 || Gf(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || Gf(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function cU(r) {
  return uU(r, AC);
}
function hU(r, e) {
  const i = new dU(r, e), n = i.parseDocument();
  return Object.defineProperty(n, "tokenCount", {
    enumerable: !1,
    value: i.tokenCount
  }), n;
}
class dU {
  constructor(e, i = {}) {
    const n = cU(e) ? e : new AC(e);
    this._lexer = new Wk(n), this._options = i, this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const e = this.expectToken(we.NAME);
    return this.node(e, {
      kind: pt.NAME,
      value: e.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: pt.DOCUMENT,
      definitions: this.many(
        we.SOF,
        this.parseDefinition,
        we.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(we.BRACE_L))
      return this.parseOperationDefinition();
    const e = this.peekDescription(), i = e ? this._lexer.lookahead() : this._lexer.token;
    if (i.kind === we.NAME) {
      switch (i.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (e)
        throw $i(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (i.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(i);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const e = this._lexer.token;
    if (this.peek(we.BRACE_L))
      return this.node(e, {
        kind: pt.OPERATION_DEFINITION,
        operation: il.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const i = this.parseOperationType();
    let n;
    return this.peek(we.NAME) && (n = this.parseName()), this.node(e, {
      kind: pt.OPERATION_DEFINITION,
      operation: i,
      name: n,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const e = this.expectToken(we.NAME);
    switch (e.value) {
      case "query":
        return il.QUERY;
      case "mutation":
        return il.MUTATION;
      case "subscription":
        return il.SUBSCRIPTION;
    }
    throw this.unexpected(e);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      we.PAREN_L,
      this.parseVariableDefinition,
      we.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: pt.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(we.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(we.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const e = this._lexer.token;
    return this.expectToken(we.DOLLAR), this.node(e, {
      kind: pt.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: pt.SELECTION_SET,
      selections: this.many(
        we.BRACE_L,
        this.parseSelection,
        we.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(we.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const e = this._lexer.token, i = this.parseName();
    let n, s;
    return this.expectOptionalToken(we.COLON) ? (n = i, s = this.parseName()) : s = i, this.node(e, {
      kind: pt.FIELD,
      alias: n,
      name: s,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(we.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(e) {
    const i = e ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(we.PAREN_L, i, we.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(e = !1) {
    const i = this._lexer.token, n = this.parseName();
    return this.expectToken(we.COLON), this.node(i, {
      kind: pt.ARGUMENT,
      name: n,
      value: this.parseValueLiteral(e)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const e = this._lexer.token;
    this.expectToken(we.SPREAD);
    const i = this.expectOptionalKeyword("on");
    return !i && this.peek(we.NAME) ? this.node(e, {
      kind: pt.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(e, {
      kind: pt.INLINE_FRAGMENT,
      typeCondition: i ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const e = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(e, {
      kind: pt.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(e, {
      kind: pt.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(e) {
    const i = this._lexer.token;
    switch (i.kind) {
      case we.BRACKET_L:
        return this.parseList(e);
      case we.BRACE_L:
        return this.parseObject(e);
      case we.INT:
        return this.advanceLexer(), this.node(i, {
          kind: pt.INT,
          value: i.value
        });
      case we.FLOAT:
        return this.advanceLexer(), this.node(i, {
          kind: pt.FLOAT,
          value: i.value
        });
      case we.STRING:
      case we.BLOCK_STRING:
        return this.parseStringLiteral();
      case we.NAME:
        switch (this.advanceLexer(), i.value) {
          case "true":
            return this.node(i, {
              kind: pt.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(i, {
              kind: pt.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(i, {
              kind: pt.NULL
            });
          default:
            return this.node(i, {
              kind: pt.ENUM,
              value: i.value
            });
        }
      case we.DOLLAR:
        if (e)
          if (this.expectToken(we.DOLLAR), this._lexer.token.kind === we.NAME) {
            const n = this._lexer.token.value;
            throw $i(
              this._lexer.source,
              i.start,
              `Unexpected variable "$${n}" in constant value.`
            );
          } else
            throw this.unexpected(i);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const e = this._lexer.token;
    return this.advanceLexer(), this.node(e, {
      kind: pt.STRING,
      value: e.value,
      block: e.kind === we.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(e) {
    const i = () => this.parseValueLiteral(e);
    return this.node(this._lexer.token, {
      kind: pt.LIST,
      values: this.any(we.BRACKET_L, i, we.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(e) {
    const i = () => this.parseObjectField(e);
    return this.node(this._lexer.token, {
      kind: pt.OBJECT,
      fields: this.any(we.BRACE_L, i, we.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(e) {
    const i = this._lexer.token, n = this.parseName();
    return this.expectToken(we.COLON), this.node(i, {
      kind: pt.OBJECT_FIELD,
      name: n,
      value: this.parseValueLiteral(e)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(e) {
    const i = [];
    for (; this.peek(we.AT); )
      i.push(this.parseDirective(e));
    return i;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(e) {
    const i = this._lexer.token;
    return this.expectToken(we.AT), this.node(i, {
      kind: pt.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(e)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const e = this._lexer.token;
    let i;
    if (this.expectOptionalToken(we.BRACKET_L)) {
      const n = this.parseTypeReference();
      this.expectToken(we.BRACKET_R), i = this.node(e, {
        kind: pt.LIST_TYPE,
        type: n
      });
    } else
      i = this.parseNamedType();
    return this.expectOptionalToken(we.BANG) ? this.node(e, {
      kind: pt.NON_NULL_TYPE,
      type: i
    }) : i;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: pt.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(we.STRING) || this.peek(we.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("schema");
    const n = this.parseConstDirectives(), s = this.many(
      we.BRACE_L,
      this.parseOperationTypeDefinition,
      we.BRACE_R
    );
    return this.node(e, {
      kind: pt.SCHEMA_DEFINITION,
      description: i,
      directives: n,
      operationTypes: s
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const e = this._lexer.token, i = this.parseOperationType();
    this.expectToken(we.COLON);
    const n = this.parseNamedType();
    return this.node(e, {
      kind: pt.OPERATION_TYPE_DEFINITION,
      operation: i,
      type: n
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("scalar");
    const n = this.parseName(), s = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.SCALAR_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("type");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(e, {
      kind: pt.OBJECT_TYPE_DEFINITION,
      description: i,
      name: n,
      interfaces: s,
      directives: a,
      fields: o
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(we.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      we.BRACE_L,
      this.parseFieldDefinition,
      we.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseName(), s = this.parseArgumentDefs();
    this.expectToken(we.COLON);
    const a = this.parseTypeReference(), o = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.FIELD_DEFINITION,
      description: i,
      name: n,
      arguments: s,
      type: a,
      directives: o
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      we.PAREN_L,
      this.parseInputValueDef,
      we.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseName();
    this.expectToken(we.COLON);
    const s = this.parseTypeReference();
    let a;
    this.expectOptionalToken(we.EQUALS) && (a = this.parseConstValueLiteral());
    const o = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.INPUT_VALUE_DEFINITION,
      description: i,
      name: n,
      type: s,
      defaultValue: a,
      directives: o
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("interface");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(e, {
      kind: pt.INTERFACE_TYPE_DEFINITION,
      description: i,
      name: n,
      interfaces: s,
      directives: a,
      fields: o
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("union");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseUnionMemberTypes();
    return this.node(e, {
      kind: pt.UNION_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      types: a
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(we.EQUALS) ? this.delimitedMany(we.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("enum");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseEnumValuesDefinition();
    return this.node(e, {
      kind: pt.ENUM_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      values: a
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      we.BRACE_L,
      this.parseEnumValueDefinition,
      we.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseEnumValueName(), s = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.ENUM_VALUE_DEFINITION,
      description: i,
      name: n,
      directives: s
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw $i(
        this._lexer.source,
        this._lexer.token.start,
        `${hp(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("input");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseInputFieldsDefinition();
    return this.node(e, {
      kind: pt.INPUT_OBJECT_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      fields: a
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      we.BRACE_L,
      this.parseInputValueDef,
      we.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const e = this._lexer.lookahead();
    if (e.kind === we.NAME)
      switch (e.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(e);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const i = this.parseConstDirectives(), n = this.optionalMany(
      we.BRACE_L,
      this.parseOperationTypeDefinition,
      we.BRACE_R
    );
    if (i.length === 0 && n.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.SCHEMA_EXTENSION,
      directives: i,
      operationTypes: n
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const i = this.parseName(), n = this.parseConstDirectives();
    if (n.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.SCALAR_TYPE_EXTENSION,
      name: i,
      directives: n
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const i = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.OBJECT_TYPE_EXTENSION,
      name: i,
      interfaces: n,
      directives: s,
      fields: a
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const i = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.INTERFACE_TYPE_EXTENSION,
      name: i,
      interfaces: n,
      directives: s,
      fields: a
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseUnionMemberTypes();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.UNION_TYPE_EXTENSION,
      name: i,
      directives: n,
      types: s
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseEnumValuesDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.ENUM_TYPE_EXTENSION,
      name: i,
      directives: n,
      values: s
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseInputFieldsDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.INPUT_OBJECT_TYPE_EXTENSION,
      name: i,
      directives: n,
      fields: s
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(we.AT);
    const n = this.parseName(), s = this.parseArgumentDefs(), a = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const o = this.parseDirectiveLocations();
    return this.node(e, {
      kind: pt.DIRECTIVE_DEFINITION,
      description: i,
      name: n,
      arguments: s,
      repeatable: a,
      locations: o
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(we.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const e = this._lexer.token, i = this.parseName();
    if (Object.prototype.hasOwnProperty.call(Hv, i.value))
      return i;
    throw this.unexpected(e);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(e, i) {
    return this._options.noLocation !== !0 && (i.loc = new Bk(
      e,
      this._lexer.lastToken,
      this._lexer.source
    )), i;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(e) {
    return this._lexer.token.kind === e;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(e) {
    const i = this._lexer.token;
    if (i.kind === e)
      return this.advanceLexer(), i;
    throw $i(
      this._lexer.source,
      i.start,
      `Expected ${CC(e)}, found ${hp(i)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(e) {
    return this._lexer.token.kind === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(e) {
    const i = this._lexer.token;
    if (i.kind === we.NAME && i.value === e)
      this.advanceLexer();
    else
      throw $i(
        this._lexer.source,
        i.start,
        `Expected "${e}", found ${hp(i)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(e) {
    const i = this._lexer.token;
    return i.kind === we.NAME && i.value === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(e) {
    const i = e ?? this._lexer.token;
    return $i(
      this._lexer.source,
      i.start,
      `Unexpected ${hp(i)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(e, i, n) {
    this.expectToken(e);
    const s = [];
    for (; !this.expectOptionalToken(n); )
      s.push(i.call(this));
    return s;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(e, i, n) {
    if (this.expectOptionalToken(e)) {
      const s = [];
      do
        s.push(i.call(this));
      while (!this.expectOptionalToken(n));
      return s;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(e, i, n) {
    this.expectToken(e);
    const s = [];
    do
      s.push(i.call(this));
    while (!this.expectOptionalToken(n));
    return s;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(e, i) {
    this.expectOptionalToken(e);
    const n = [];
    do
      n.push(i.call(this));
    while (this.expectOptionalToken(e));
    return n;
  }
  advanceLexer() {
    const { maxTokens: e } = this._options, i = this._lexer.advance();
    if (i.kind !== we.EOF && (++this._tokenCounter, e !== void 0 && this._tokenCounter > e))
      throw $i(
        this._lexer.source,
        i.start,
        `Document contains more that ${e} tokens. Parsing aborted.`
      );
  }
}
function hp(r) {
  const e = r.value;
  return CC(r.kind) + (e != null ? ` "${e}"` : "");
}
function CC(r) {
  return qk(r) ? `"${r}"` : r;
}
function pU(r) {
  return `"${r.replace(fU, mU)}"`;
}
const fU = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function mU(r) {
  return gU[r.charCodeAt(0)];
}
const gU = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], yU = Object.freeze({});
function vU(r, e, i = _C) {
  const n = /* @__PURE__ */ new Map();
  for (const g of Object.values(pt))
    n.set(g, bU(e, g));
  let s, a = Array.isArray(r), o = [r], l = -1, u = [], c = r, h, d;
  const p = [], f = [];
  do {
    l++;
    const g = l === o.length, _ = g && u.length !== 0;
    if (g) {
      if (h = f.length === 0 ? void 0 : p[p.length - 1], c = d, d = f.pop(), _)
        if (a) {
          c = c.slice();
          let b = 0;
          for (const [T, S] of u) {
            const w = T - b;
            S === null ? (c.splice(w, 1), b++) : c[w] = S;
          }
        } else {
          c = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(c)
          );
          for (const [b, T] of u)
            c[b] = T;
        }
      l = s.index, o = s.keys, u = s.edits, a = s.inArray, s = s.prev;
    } else if (d) {
      if (h = a ? l : o[l], c = d[h], c == null)
        continue;
      p.push(h);
    }
    let x;
    if (!Array.isArray(c)) {
      var m, y;
      rS(c) || Gf(!1, `Invalid AST Node: ${__(c)}.`);
      const b = g ? (m = n.get(c.kind)) === null || m === void 0 ? void 0 : m.leave : (y = n.get(c.kind)) === null || y === void 0 ? void 0 : y.enter;
      if (x = b == null ? void 0 : b.call(e, c, h, d, p, f), x === yU)
        break;
      if (x === !1) {
        if (!g) {
          p.pop();
          continue;
        }
      } else if (x !== void 0 && (u.push([h, x]), !g))
        if (rS(x))
          c = x;
        else {
          p.pop();
          continue;
        }
    }
    if (x === void 0 && _ && u.push([h, c]), g)
      p.pop();
    else {
      var v;
      s = {
        inArray: a,
        index: l,
        keys: o,
        edits: u,
        prev: s
      }, a = Array.isArray(c), o = a ? c : (v = i[c.kind]) !== null && v !== void 0 ? v : [], l = -1, u = [], d && f.push(d), d = c;
    }
  } while (s !== void 0);
  return u.length !== 0 ? u[u.length - 1][1] : r;
}
function bU(r, e) {
  const i = r[e];
  return typeof i == "object" ? i : typeof i == "function" ? {
    enter: i,
    leave: void 0
  } : {
    enter: r.enter,
    leave: r.leave
  };
}
function xU(r) {
  return vU(r, TU);
}
const _U = 80, TU = {
  Name: {
    leave: (r) => r.value
  },
  Variable: {
    leave: (r) => "$" + r.name
  },
  // Document
  Document: {
    leave: (r) => Qe(r.definitions, `

`)
  },
  OperationDefinition: {
    leave(r) {
      const e = Lt("(", Qe(r.variableDefinitions, ", "), ")"), i = Qe(
        [
          r.operation,
          Qe([r.name, e]),
          Qe(r.directives, " ")
        ],
        " "
      );
      return (i === "query" ? "" : i + " ") + r.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: r, type: e, defaultValue: i, directives: n }) => r + ": " + e + Lt(" = ", i) + Lt(" ", Qe(n, " "))
  },
  SelectionSet: {
    leave: ({ selections: r }) => Cn(r)
  },
  Field: {
    leave({ alias: r, name: e, arguments: i, directives: n, selectionSet: s }) {
      const a = Lt("", r, ": ") + e;
      let o = a + Lt("(", Qe(i, ", "), ")");
      return o.length > _U && (o = a + Lt(`(
`, Hf(Qe(i, `
`)), `
)`)), Qe([o, Qe(n, " "), s], " ");
    }
  },
  Argument: {
    leave: ({ name: r, value: e }) => r + ": " + e
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: r, directives: e }) => "..." + r + Lt(" ", Qe(e, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: r, directives: e, selectionSet: i }) => Qe(
      [
        "...",
        Lt("on ", r),
        Qe(e, " "),
        i
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: r, typeCondition: e, variableDefinitions: i, directives: n, selectionSet: s }) => (
      // or removed in the future.
      `fragment ${r}${Lt("(", Qe(i, ", "), ")")} on ${e} ${Lt("", Qe(n, " "), " ")}` + s
    )
  },
  // Value
  IntValue: {
    leave: ({ value: r }) => r
  },
  FloatValue: {
    leave: ({ value: r }) => r
  },
  StringValue: {
    leave: ({ value: r, block: e }) => e ? Hk(r) : pU(r)
  },
  BooleanValue: {
    leave: ({ value: r }) => r ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: r }) => r
  },
  ListValue: {
    leave: ({ values: r }) => "[" + Qe(r, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: r }) => "{" + Qe(r, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: r, value: e }) => r + ": " + e
  },
  // Directive
  Directive: {
    leave: ({ name: r, arguments: e }) => "@" + r + Lt("(", Qe(e, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: r }) => r
  },
  ListType: {
    leave: ({ type: r }) => "[" + r + "]"
  },
  NonNullType: {
    leave: ({ type: r }) => r + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: r, directives: e, operationTypes: i }) => Lt("", r, `
`) + Qe(["schema", Qe(e, " "), Cn(i)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: r, type: e }) => r + ": " + e
  },
  ScalarTypeDefinition: {
    leave: ({ description: r, name: e, directives: i }) => Lt("", r, `
`) + Qe(["scalar", e, Qe(i, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: r, name: e, interfaces: i, directives: n, fields: s }) => Lt("", r, `
`) + Qe(
      [
        "type",
        e,
        Lt("implements ", Qe(i, " & ")),
        Qe(n, " "),
        Cn(s)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: r, name: e, arguments: i, type: n, directives: s }) => Lt("", r, `
`) + e + (sS(i) ? Lt(`(
`, Hf(Qe(i, `
`)), `
)`) : Lt("(", Qe(i, ", "), ")")) + ": " + n + Lt(" ", Qe(s, " "))
  },
  InputValueDefinition: {
    leave: ({ description: r, name: e, type: i, defaultValue: n, directives: s }) => Lt("", r, `
`) + Qe(
      [e + ": " + i, Lt("= ", n), Qe(s, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: r, name: e, interfaces: i, directives: n, fields: s }) => Lt("", r, `
`) + Qe(
      [
        "interface",
        e,
        Lt("implements ", Qe(i, " & ")),
        Qe(n, " "),
        Cn(s)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, types: n }) => Lt("", r, `
`) + Qe(
      ["union", e, Qe(i, " "), Lt("= ", Qe(n, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, values: n }) => Lt("", r, `
`) + Qe(["enum", e, Qe(i, " "), Cn(n)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: r, name: e, directives: i }) => Lt("", r, `
`) + Qe([e, Qe(i, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, fields: n }) => Lt("", r, `
`) + Qe(["input", e, Qe(i, " "), Cn(n)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: r, name: e, arguments: i, repeatable: n, locations: s }) => Lt("", r, `
`) + "directive @" + e + (sS(i) ? Lt(`(
`, Hf(Qe(i, `
`)), `
)`) : Lt("(", Qe(i, ", "), ")")) + (n ? " repeatable" : "") + " on " + Qe(s, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: r, operationTypes: e }) => Qe(
      ["extend schema", Qe(r, " "), Cn(e)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: r, directives: e }) => Qe(["extend scalar", r, Qe(e, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: r, interfaces: e, directives: i, fields: n }) => Qe(
      [
        "extend type",
        r,
        Lt("implements ", Qe(e, " & ")),
        Qe(i, " "),
        Cn(n)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: r, interfaces: e, directives: i, fields: n }) => Qe(
      [
        "extend interface",
        r,
        Lt("implements ", Qe(e, " & ")),
        Qe(i, " "),
        Cn(n)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: r, directives: e, types: i }) => Qe(
      [
        "extend union",
        r,
        Qe(e, " "),
        Lt("= ", Qe(i, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: r, directives: e, values: i }) => Qe(["extend enum", r, Qe(e, " "), Cn(i)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: r, directives: e, fields: i }) => Qe(["extend input", r, Qe(e, " "), Cn(i)], " ")
  }
};
function Qe(r, e = "") {
  var i;
  return (i = r == null ? void 0 : r.filter((n) => n).join(e)) !== null && i !== void 0 ? i : "";
}
function Cn(r) {
  return Lt(`{
`, Hf(Qe(r, `
`)), `
}`);
}
function Lt(r, e, i = "") {
  return e != null && e !== "" ? r + e + i : "";
}
function Hf(r) {
  return Lt("  ", r.replace(/\n/g, `
  `));
}
function sS(r) {
  var e;
  return (e = r == null ? void 0 : r.some((i) => i.includes(`
`))) !== null && e !== void 0 ? e : !1;
}
const aS = "Accept", qv = "Content-Type", Xv = "application/json", RC = "application/graphql-response+json", oS = (r) => r.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), SU = (r) => {
  const e = r.toLowerCase();
  return e.includes(RC) || e.includes(Xv);
}, lS = (r) => {
  try {
    if (Array.isArray(r))
      return {
        _tag: "Batch",
        executionResults: r.map(uS)
      };
    if (Vf(r))
      return {
        _tag: "Single",
        executionResult: uS(r)
      };
    throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(r)}`);
  } catch (e) {
    return e;
  }
}, uS = (r) => {
  if (typeof r != "object" || r === null)
    throw new Error("Invalid execution result: result is not object");
  let e, i, n;
  if ("errors" in r) {
    if (!Vf(r.errors) && !Array.isArray(r.errors))
      throw new Error("Invalid execution result: errors is not plain object OR array");
    e = r.errors;
  }
  if ("data" in r) {
    if (!Vf(r.data) && r.data !== null)
      throw new Error("Invalid execution result: data is not plain object");
    i = r.data;
  }
  if ("extensions" in r) {
    if (!Vf(r.extensions))
      throw new Error("Invalid execution result: extensions is not plain object");
    n = r.extensions;
  }
  return {
    data: i,
    errors: e,
    extensions: n
  };
}, wU = (r) => r._tag === "Batch" ? r.executionResults.some(cS) : cS(r.executionResult), cS = (r) => Array.isArray(r.errors) ? r.errors.length > 0 : !!r.errors, NC = (r) => typeof r == "object" && r !== null && "kind" in r && r.kind === pt.OPERATION_DEFINITION, EU = (r) => {
  var e;
  let i;
  const n = r.definitions.filter(NC);
  return n.length === 1 && (i = (e = n[0].name) == null ? void 0 : e.value), i;
}, MU = (r) => {
  let e = !1;
  const i = r.definitions.filter(NC);
  return i.length === 1 && (e = i[0].operation === il.MUTATION), e;
}, py = (r, e) => {
  const i = typeof r == "string" ? r : xU(r);
  let n = !1, s;
  if (e)
    return { expression: i, isMutation: n, operationName: s };
  const a = Nk(() => typeof r == "string" ? hU(r) : r);
  return a instanceof Error ? { expression: i, isMutation: n, operationName: s } : (s = EU(a), n = MU(a), { expression: i, operationName: s, isMutation: n });
}, T_ = JSON, fy = async (r) => {
  const e = {
    ...r,
    method: r.request._tag === "Single" ? r.request.document.isMutation ? "POST" : JT(r.method ?? "post") : r.request.hasMutations ? "POST" : JT(r.method ?? "post"),
    fetchOptions: {
      ...r.fetchOptions,
      errorPolicy: r.fetchOptions.errorPolicy ?? "none"
    }
  }, i = await CU(e.method)(e);
  if (!i.ok)
    return new Vu({ status: i.status, headers: i.headers }, {
      query: r.request._tag === "Single" ? r.request.document.expression : r.request.query,
      variables: r.request.variables
    });
  const n = await AU(i, r.fetchOptions.jsonSerializer ?? T_);
  if (n instanceof Error)
    throw n;
  const s = {
    status: i.status,
    headers: i.headers
  };
  if (wU(n) && e.fetchOptions.errorPolicy === "none") {
    const a = n._tag === "Batch" ? { ...n.executionResults, ...s } : {
      ...n.executionResult,
      ...s
    };
    return new Vu(a, {
      query: r.request._tag === "Single" ? r.request.document.expression : r.request.query,
      variables: r.request.variables
    });
  }
  switch (n._tag) {
    case "Single":
      return {
        ...s,
        ...hS(e)(n.executionResult)
      };
    case "Batch":
      return {
        ...s,
        data: n.executionResults.map(hS(e))
      };
    default:
      b_(n);
  }
}, hS = (r) => (e) => ({
  extensions: e.extensions,
  data: e.data,
  errors: r.fetchOptions.errorPolicy === "all" ? e.errors : void 0
}), AU = async (r, e) => {
  const i = r.headers.get(qv), n = await r.text();
  return i && SU(i) ? lS(e.parse(n)) : lS(n);
}, CU = (r) => async (e) => {
  const i = new Headers(e.headers);
  let n = null, s;
  i.has(aS) || i.set(aS, [RC, Xv].join(", ")), r === "POST" ? (s = (e.fetchOptions.jsonSerializer ?? T_).stringify(RU(e)), typeof s == "string" && !i.has(qv) && i.set(qv, Xv)) : n = NU(e);
  const a = { method: r, headers: i, body: s, ...e.fetchOptions };
  let o = new URL(e.url), l = a;
  if (e.middleware) {
    const u = await Promise.resolve(e.middleware({
      ...a,
      url: e.url,
      operationName: e.request._tag === "Single" ? e.request.document.operationName : void 0,
      variables: e.request.variables
    })), { url: c, ...h } = u;
    o = new URL(c), l = h;
  }
  return n && n.forEach((u, c) => {
    o.searchParams.append(c, u);
  }), await (e.fetch ?? fetch)(o, l);
}, RU = (r) => {
  switch (r.request._tag) {
    case "Single":
      return {
        query: r.request.document.expression,
        variables: r.request.variables,
        operationName: r.request.document.operationName
      };
    case "Batch":
      return vC(r.request.query, r.request.variables ?? []).map(([e, i]) => ({
        query: e,
        variables: i
      }));
    default:
      throw b_(r.request);
  }
}, NU = (r) => {
  var e;
  const i = r.fetchOptions.jsonSerializer ?? T_, n = new URLSearchParams();
  switch (r.request._tag) {
    case "Single":
      return n.append("query", oS(r.request.document.expression)), r.request.variables && n.append("variables", i.stringify(r.request.variables)), r.request.document.operationName && n.append("operationName", r.request.document.operationName), n;
    case "Batch": {
      const s = ((e = r.request.variables) == null ? void 0 : e.map((l) => i.stringify(l))) ?? [], a = r.request.query.map(oS), o = vC(a, s).map(([l, u]) => ({
        query: l,
        variables: u
      }));
      return n.append("query", i.stringify(o)), n;
    }
    default:
      throw b_(r.request);
  }
};
class PC {
  constructor(e, i = {}) {
    Xh(this, "url"), Xh(this, "requestConfig"), Xh(this, "rawRequest", async (...n) => {
      const [s, a, o] = n, l = Ok(s, a, o), { headers: u, fetch: c = globalThis.fetch, method: h = "POST", requestMiddleware: d, responseMiddleware: p, excludeOperationName: f, ...m } = this.requestConfig, { url: y } = this;
      l.signal !== void 0 && (m.signal = l.signal);
      const v = py(l.query, f), g = await fy({
        url: y,
        request: {
          _tag: "Single",
          document: v,
          variables: l.variables
        },
        headers: {
          ...Bl(hy(u)),
          ...Bl(l.requestHeaders)
        },
        fetch: c,
        method: h,
        fetchOptions: m,
        middleware: d
      });
      if (p && await p(g, {
        operationName: v.operationName,
        variables: a,
        url: this.url
      }), g instanceof Error)
        throw g;
      return g;
    }), this.url = e, this.requestConfig = i;
  }
  async request(e, ...i) {
    const [n, s] = i, a = PU(e, n, s), { headers: o, fetch: l = globalThis.fetch, method: u = "POST", requestMiddleware: c, responseMiddleware: h, excludeOperationName: d, ...p } = this.requestConfig, { url: f } = this;
    a.signal !== void 0 && (p.signal = a.signal);
    const m = py(a.document, d), y = await fy({
      url: f,
      request: {
        _tag: "Single",
        document: m,
        variables: a.variables
      },
      headers: {
        ...Bl(hy(o)),
        ...Bl(a.requestHeaders)
      },
      fetch: l,
      method: u,
      fetchOptions: p,
      middleware: c
    });
    if (h && await h(y, {
      operationName: m.operationName,
      variables: a.variables,
      url: this.url
    }), y instanceof Error)
      throw y;
    return y.data;
  }
  async batchRequests(e, i) {
    const n = Ik(e, i), { headers: s, excludeOperationName: a, ...o } = this.requestConfig;
    n.signal !== void 0 && (o.signal = n.signal);
    const l = n.documents.map(({ document: p }) => py(p, a)), u = l.map(({ expression: p }) => p), c = l.some(({ isMutation: p }) => p), h = n.documents.map(({ variables: p }) => p), d = await fy({
      url: this.url,
      request: {
        _tag: "Batch",
        operationName: void 0,
        query: u,
        hasMutations: c,
        variables: h
      },
      headers: {
        ...Bl(hy(s)),
        ...Bl(n.requestHeaders)
      },
      fetch: this.requestConfig.fetch ?? globalThis.fetch,
      method: this.requestConfig.method || "POST",
      fetchOptions: o,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware && await this.requestConfig.responseMiddleware(d, {
      operationName: void 0,
      variables: h,
      url: this.url
    }), d instanceof Error)
      throw d;
    return d.data;
  }
  setHeaders(e) {
    return this.requestConfig.headers = e, this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(e, i) {
    const { headers: n } = this.requestConfig;
    return n ? n[e] = i : this.requestConfig.headers = { [e]: i }, this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(e) {
    return this.url = e, this;
  }
}
const PU = (r, e, i) => r.document ? r : {
  document: r,
  variables: e,
  requestHeaders: i,
  signal: void 0
}, vs = (r, ...e) => r.reduce((i, n, s) => `${i}${n}${s in e ? String(e[s]) : ""}`, ""), IC = {
  base: {
    url: " https://prod.base.intuition-api.com/v1/graphql",
    displayName: "Base Mainnet"
  }
}, Gd = (r) => new PC(IC[r].url), IU = async (r, e = "baseSepolia") => {
  const i = Gd(e);
  let n;
  n = vs`
    query GetAtom($atomId: numeric!) {
      atom(id: $atomId) {
        id
        image
        label
        emoji
        type
        creator_id
        vault {
          total_shares
        }
      }
    }
  `;
  const s = { atomId: r };
  try {
    return (await i.request(n, s)).atom;
  } catch (a) {
    throw console.error("Error fetching atom details:", a), a;
  }
}, OU = async (r = "baseSepolia") => {
  const e = Gd(r);
  let i, n;
  return i = vs`
    query {
      triples(limit: 1000) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, n = await e.request(i), {
    items: n.triples
  }.items;
}, DU = async (r, e = "baseSepolia") => {
  const i = Gd(e);
  let n, s, a;
  return n = vs`
    query Triples($where: triples_bool_exp) {
      triples(where: $where) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, a = {
    where: {
      _or: [
        {
          predicate_id: {
            _eq: r
          }
        },
        {
          subject_id: {
            _eq: r
          }
        },
        {
          object_id: {
            _eq: r
          }
        }
      ]
    }
  }, s = await i.request(n, a), s.triples;
}, LU = async (r, e = "baseSepolia") => {
  const i = Gd(e), n = vs`
    query SearchTriples($where: triples_bool_exp) {
      triples(where: $where) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, s = {
    _and: []
  };
  r.subject && s._and.push({
    subject: {
      label: {
        _ilike: `%${r.subject}%`
      }
    }
  }), r.predicate && s._and.push({
    predicate: {
      label: {
        _ilike: `%${r.predicate}%`
      }
    }
  }), r.object && s._and.push({
    object: {
      label: {
        _ilike: `%${r.object}%`
      }
    }
  });
  const a = {
    where: s._and.length > 0 ? s : {}
  };
  console.log("Executing search query with variables:", a);
  try {
    const o = await i.request(n, a);
    return console.log("Search query response:", o), o.triples;
  } catch (o) {
    throw console.error("Error executing search query:", o), o;
  }
}, kU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ENDPOINTS: IC,
  createClient: Gd,
  fetchAtomDetails: IU,
  fetchTriples: OU,
  fetchTriplesForNode: DU,
  searchTriples: LU
}, Symbol.toStringTag, { value: "Module" })), OC = {
  baseSepolia: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Intuition Testnet"
  },
  base: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Intuition Testnet"
  }
}, Dc = (r) => new PC(OC[r].url), S_ = (r) => ({
  id: r.term_id,
  subject: {
    id: r.subject.term_id,
    label: r.subject.label,
    type: r.subject.type,
    image: r.subject.image
  },
  predicate: {
    id: r.predicate.term_id,
    label: r.predicate.label,
    type: r.predicate.type
  },
  object: {
    id: r.object.term_id,
    label: r.object.label,
    type: r.object.type,
    image: r.object.image
  }
}), UU = async (r, e = "base") => {
  const i = Dc(e);
  let n;
  n = vs`
    query GetAtom($atomId: String!) {
      atoms(where: { term_id: { _eq: $atomId } }) {
        term_id
        image
        label
        emoji
        type
        creator_id
        term {
          total_market_cap
        }
      }
    }
  `;
  const s = { atomId: r };
  try {
    return (await i.request(n, s)).atoms[0];
  } catch (a) {
    throw console.error("Error fetching atom details:", a), a;
  }
}, DC = async (r = "base") => {
  const e = Dc(r);
  let i, n;
  return i = vs`
    query {
      triples(limit: 1000) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, n = await e.request(i), {
    items: n.triples
  }.items;
}, FU = async (r, e = "base") => {
  const i = Dc(e);
  let n, s, a;
  return n = vs`
    query Triples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, a = {
    where: {
      _or: [
        {
          predicate_id: {
            _eq: r
          }
        },
        {
          subject_id: {
            _eq: r
          }
        },
        {
          object_id: {
            _eq: r
          }
        }
      ]
    }
  }, s = await i.request(n, a), s.triples.map(S_);
}, BU = async (r, e = "base") => {
  const i = Dc(e), n = vs`
    query SearchTriples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, s = {
    _and: []
  };
  r.subject && s._and.push({
    subject: {
      label: {
        _ilike: `%${r.subject}%`
      }
    }
  }), r.predicate && s._and.push({
    predicate: {
      label: {
        _ilike: `%${r.predicate}%`
      }
    }
  }), r.object && s._and.push({
    object: {
      label: {
        _ilike: `%${r.object}%`
      }
    }
  });
  const a = {
    where: s._and.length > 0 ? s : {}
  };
  try {
    return (await i.request(n, a)).triples.map(S_);
  } catch (o) {
    throw console.error("Error executing search query:", o), o;
  }
}, LC = async (r, e = "base", i = 1e3) => {
  const n = Dc(e), s = vs`
    query Triples_for_Agent($objectId: String!, $batchSize: Int!) {
      triples(limit: $batchSize, where: { object_id: { _eq: $objectId } }) {
        term_id
        subject {
          term_id
          label
          type
          image
        }
        predicate {
          term_id
          label
          type
          image
        }
        object {
          term_id
          label
          type
          image
        }
      }
    }
  `, a = vs`
    query Relations_for_Subject($subjectId: String!) {
      triples(where: { subject_id: { _eq: $subjectId } }) {
        term_id
        subject {
          term_id
          label
          type
          image
        }
        predicate {
          term_id
          label
          type
          image
        }
        object {
          term_id
          label
          type
          image
        }
      }
    }
  `, o = {
    batchSize: i,
    objectId: String(r)
  };
  try {
    const l = (await n.request(s, o)).triples, u = [...new Set(l.map((h) => h.subject.term_id))].map(
      (h) => n.request(a, { subjectId: h })
    ), c = (await Promise.all(u)).flatMap((h) => h.triples);
    return [...l, ...c].map(S_);
  } catch (l) {
    return console.error("Error fetching agent-specific triples:", l), DC(e).then((u) => u.filter(
      (c) => c.subject.term_id === r || c.object.term_id === r || c.predicate.term_id === r
    )).catch((u) => {
      throw console.error("Fallback fetch also failed:", u), l;
    });
  }
}, dS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ENDPOINTS: OC,
  createClient: Dc,
  fetchAtomDetails: UU,
  fetchTriples: DC,
  fetchTriplesForAgent: LC,
  fetchTriplesForNode: FU,
  searchTriples: BU
}, Symbol.toStringTag, { value: "Module" })), my = {
  railsMockApi: {
    url: "https://api-i7n.thp-lab.org/api/v1/graph",
    displayName: "[OffChain] Playground API",
    module: kU
    // Default to Base module for railsMockApi
  },
  baseSepolia: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Base Testnet",
    module: dS
  },
  base: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Base Mainnet",
    module: dS
  }
}, yg = (r) => {
  if (!my[r] || !my[r].module)
    throw new Error(`No module defined for endpoint '${r}'.`);
  return my[r].module;
}, w_ = async (r = "base") => {
  const e = yg(r);
  try {
    return e.fetchTriples(r);
  } catch (i) {
    throw console.error(`Error fetching triples for endpoint ${r}:`, i), i;
  }
}, zU = async (r, e = "base") => {
  const i = yg(e);
  try {
    return i.fetchTriplesForNode(r, e);
  } catch (n) {
    throw console.error(
      `Error fetching triples for node ${r} with endpoint ${e}:`,
      n
    ), n;
  }
}, jU = async (r, e = "base") => {
  const i = yg(e);
  try {
    return i.fetchAtomDetails(r, e);
  } catch (n) {
    throw console.error(
      `Error fetching atom details for ${r} with endpoint ${e}:`,
      n
    ), n;
  }
}, Pu = async (r, e = "base") => {
  const i = yg(e);
  try {
    return i.searchTriples(r, e);
  } catch (n) {
    throw console.error(`Error searching triples with endpoint ${e}:`, n), n;
  }
}, VU = async (r, e = "baseSepolia", i = 1e3) => LC(r, e, i), E_ = ({ triple: r, endpoint: e, onClose: i }) => {
  var n;
  const [s, a] = ve(null), [o, l] = ve(null), [u, c] = ve(!1), [h, d] = ve(null);
  Ft(() => {
    r && (c(!0), d(null), l(null), (async () => {
      try {
        const y = (await w_(e)).filter(
          (v) => {
            var g, _, x;
            return v.id === r.id || ((g = v.subject) == null ? void 0 : g.id) === r.id || ((_ = v.predicate) == null ? void 0 : _.id) === r.id || ((x = v.object) == null ? void 0 : x.id) === r.id;
          }
        );
        if (a(y), r.id) {
          const v = await jU(
            r.id,
            e
          );
          l(v);
        }
      } catch (y) {
        console.error("Error fetching sidebar data:", y), d("Failed to fetch data");
      } finally {
        c(!1);
      }
    })());
  }, [r, e]);
  const p = (y) => `${(y / 1e18).toFixed(4)} ETH`;
  if (!r)
    return null;
  const f = (y, v = 4, g = 4) => !y || y.length <= v + g ? y : `${y.slice(0, v)}...${y.slice(-g)}`, m = async (y) => {
    try {
      await navigator.clipboard.writeText(y), console.log("ID copied:", y);
    } catch (v) {
      console.error("Error copying ID:", v);
    }
  };
  return /* @__PURE__ */ ae.jsxs(
    "div",
    {
      style: {
        background: "#18181b",
        borderRadius: "10px",
        border: "2px solid #ffd32a",
        padding: "24px",
        boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
        color: "#fff",
        maxWidth: "400px",
        width: "100%"
      },
      children: [
        /* @__PURE__ */ ae.jsxs(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              marginBottom: "24px"
            },
            children: [
              /* @__PURE__ */ ae.jsx(
                "h2",
                {
                  style: {
                    margin: 0,
                    fontSize: "24px",
                    color: "#ffd32a",
                    fontWeight: "bold",
                    letterSpacing: "0.5px"
                  },
                  children: r.label || "No Label"
                }
              ),
              /* @__PURE__ */ ae.jsx(
                "button",
                {
                  onClick: i,
                  style: {
                    background: "none",
                    border: "none",
                    color: "#ffd32a",
                    fontSize: "24px",
                    cursor: "pointer",
                    padding: "4px",
                    lineHeight: 1
                  },
                  children: "×"
                }
              )
            ]
          }
        ),
        o && o.image && /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "center",
              margin: "24px 0"
            },
            children: /* @__PURE__ */ ae.jsx(
              "img",
              {
                src: o.image,
                alt: o.label || "Node image",
                style: {
                  width: "120px",
                  height: "120px",
                  borderRadius: "50%",
                  objectFit: "cover",
                  border: "3px solid #ffd32a",
                  boxShadow: "0 4px 12px rgba(0,0,0,0.2)"
                }
              }
            )
          }
        ),
        u && /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              textAlign: "center",
              padding: "20px",
              color: "#ffd32a"
            },
            children: "Loading..."
          }
        ),
        h && /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              color: "#ff4444",
              padding: "12px",
              background: "rgba(255,68,68,0.1)",
              borderRadius: "8px",
              marginBottom: "16px"
            },
            children: h
          }
        ),
        o && /* @__PURE__ */ ae.jsxs(
          "div",
          {
            style: {
              background: "#232326",
              borderRadius: "8px",
              padding: "16px",
              marginBottom: "24px"
            },
            children: [
              /* @__PURE__ */ ae.jsx(
                "h4",
                {
                  style: {
                    color: "#ffd32a",
                    margin: "0 0 16px 0",
                    fontSize: "18px",
                    fontWeight: "bold"
                  },
                  children: "Atom Info"
                }
              ),
              /* @__PURE__ */ ae.jsxs(
                "div",
                {
                  style: {
                    display: "grid",
                    gap: "12px"
                  },
                  children: [
                    /* @__PURE__ */ ae.jsxs("div", { children: [
                      /* @__PURE__ */ ae.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "ID:" }),
                      " ",
                      /* @__PURE__ */ ae.jsx(
                        "span",
                        {
                          style: {
                            cursor: "pointer",
                            textDecoration: "underline",
                            color: "#ffd32a"
                          },
                          onClick: () => m(o.term_id),
                          title: `Cliquer pour copier: ${o.term_id}`,
                          children: f(o.term_id)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ ae.jsxs("div", { children: [
                      /* @__PURE__ */ ae.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Label:" }),
                      " ",
                      o.label
                    ] }),
                    /* @__PURE__ */ ae.jsxs("div", { children: [
                      /* @__PURE__ */ ae.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Type:" }),
                      " ",
                      o.type
                    ] }),
                    /* @__PURE__ */ ae.jsxs("div", { children: [
                      /* @__PURE__ */ ae.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Creator:" }),
                      " ",
                      /* @__PURE__ */ ae.jsx(
                        "span",
                        {
                          style: {
                            cursor: "pointer",
                            textDecoration: "underline",
                            color: "#ffd32a"
                          },
                          onClick: () => m(o.creator_id),
                          title: `Cliquer pour copier: ${o.creator_id}`,
                          children: f(o.creator_id)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ ae.jsxs("div", { children: [
                      /* @__PURE__ */ ae.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Vault Shares:" }),
                      " ",
                      p(((n = o.vault) == null ? void 0 : n.total_shares) || 0)
                    ] })
                  ]
                }
              )
            ]
          }
        ),
        s && s.length > 0 && /* @__PURE__ */ ae.jsxs(
          "div",
          {
            style: {
              background: "#232326",
              borderRadius: "8px",
              padding: "16px"
            },
            children: [
              /* @__PURE__ */ ae.jsx(
                "h4",
                {
                  style: {
                    color: "#ffd32a",
                    margin: "0 0 16px 0",
                    fontSize: "18px",
                    fontWeight: "bold"
                  },
                  children: "Related Data"
                }
              ),
              /* @__PURE__ */ ae.jsx(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: "12px"
                  },
                  children: s.map((y) => {
                    var v, g, _;
                    return /* @__PURE__ */ ae.jsxs(
                      "div",
                      {
                        style: {
                          padding: "12px",
                          background: "#18181b",
                          borderRadius: "6px",
                          border: "1px solid #ffd32a33"
                        },
                        children: [
                          /* @__PURE__ */ ae.jsxs("div", { children: [
                            /* @__PURE__ */ ae.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Subject:" }),
                            " ",
                            (v = y.subject) == null ? void 0 : v.label
                          ] }),
                          /* @__PURE__ */ ae.jsxs("div", { children: [
                            /* @__PURE__ */ ae.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Predicate:" }),
                            " ",
                            (g = y.predicate) == null ? void 0 : g.label
                          ] }),
                          /* @__PURE__ */ ae.jsxs("div", { children: [
                            /* @__PURE__ */ ae.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Object:" }),
                            " ",
                            (_ = y.object) == null ? void 0 : _.label
                          ] })
                        ]
                      },
                      y.id
                    );
                  })
                }
              )
            ]
          }
        ),
        !u && !(s != null && s.length) && /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              textAlign: "center",
              padding: "20px",
              color: "#888",
              background: "#232326",
              borderRadius: "8px"
            },
            children: "No additional related data found."
          }
        )
      ]
    }
  );
}, GU = ({ graphData: r, onNodeClick: e, onBack: i, onForward: n, selectedTriple: s, endpoint: a, disableNodeDetailsSidebar: o = !1 }) => {
  const l = gr(), u = gr(), [c, h] = ve({ width: 100, height: 100 });
  return Ft(() => {
    const d = () => {
      l.current && h({
        width: l.current.clientWidth,
        height: l.current.clientHeight
      });
    };
    return d(), window.addEventListener("resize", d), () => window.removeEventListener("resize", d);
  }, []), Ft(() => {
    if (u.current && c.width > 0 && c.height > 0) {
      const d = S2()(u.current);
      d.width(c.width).height(c.height).graphData(r).nodeLabel((p) => p.label || p.id).nodeAutoColorBy("group"), e && d.onNodeClick((p) => {
        console.log("VR Node clicked inside Graph:", p), e(p);
      });
    }
  }, [r, e, c]), /* @__PURE__ */ ae.jsxs(
    "div",
    {
      ref: l,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ ae.jsx(
          "div",
          {
            ref: u,
            style: { width: "100%", height: "100%" }
          }
        ),
        /* @__PURE__ */ ae.jsxs("div", { style: { position: "absolute", bottom: 20, left: 20, zIndex: 100 }, children: [
          /* @__PURE__ */ ae.jsx(
            "button",
            {
              onClick: i,
              style: {
                background: "#ffd32a",
                color: "#18181b",
                border: "none",
                borderRadius: 8,
                padding: "10px 20px",
                marginRight: 10,
                cursor: "pointer",
                fontWeight: "bold"
              },
              children: "Back"
            }
          ),
          /* @__PURE__ */ ae.jsx(
            "button",
            {
              onClick: n,
              style: {
                background: "#ffd32a",
                color: "#18181b",
                border: "none",
                borderRadius: 8,
                padding: "10px 20px",
                cursor: "pointer",
                fontWeight: "bold"
              },
              children: "Forward"
            }
          )
        ] }),
        s && !o && /* @__PURE__ */ ae.jsx("div", { style: {
          position: "absolute",
          top: 80,
          right: 30,
          width: 350,
          zIndex: 9999,
          maxHeight: "80vh",
          background: "#18181b",
          borderRadius: "10px",
          border: "3px solid #ffd32a",
          boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
          overflowY: "auto"
        }, children: /* @__PURE__ */ ae.jsx(
          E_,
          {
            triple: s,
            endpoint: a,
            onClose: () => e(null)
          }
        ) })
      ]
    }
  );
}, kC = () => {
  const [r, e] = ve([]), i = 200;
  Ft(() => {
    let s;
    const a = () => {
      const o = Date.now() / 1e3, l = [];
      for (let u = 0; u < 3; u++) {
        const c = o * 0.8 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 150 + 200,
          y: Math.sin(c) * 150 + 200,
          color: "#00fff2"
        });
      }
      for (let u = 0; u < 3; u++) {
        const c = -o * 1.2 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 100 + 200,
          y: Math.sin(c) * 100 + 200,
          color: "#ff00ff"
        });
      }
      for (let u = 0; u < 3; u++) {
        const c = o * 1.5 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 50 + 200,
          y: Math.sin(c) * 50 + 200,
          color: "#ffff00"
        });
      }
      e(l), s = requestAnimationFrame(a);
    };
    return a(), () => cancelAnimationFrame(s);
  }, []);
  const n = r.flatMap(
    (s, a) => r.slice(a + 1).map((o, l) => {
      const u = o.x - s.x, c = o.y - s.y, h = Math.sqrt(u * u + c * c);
      if (h < i) {
        const d = 1 - h / i;
        return {
          x1: s.x,
          y1: s.y,
          x2: o.x,
          y2: o.y,
          opacity: d * 0.8,
          // Slightly reduce max opacity for subtler effect
          gradient: `link-gradient-${a}-${l}`,
          color1: s.color,
          color2: o.color
        };
      }
      return null;
    }).filter(Boolean)
  );
  return /* @__PURE__ */ ae.jsxs("div", { style: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    alignItems: "center",
    background: "rgba(0, 0, 0, 0.9)",
    zIndex: 1e3,
    overflow: "hidden"
  }, children: [
    /* @__PURE__ */ ae.jsxs("div", { style: {
      position: "relative",
      width: "400px",
      height: "400px",
      display: "flex",
      flexDirection: "column",
      alignItems: "center"
    }, children: [
      /* @__PURE__ */ ae.jsxs("svg", { width: "400", height: "400", children: [
        /* @__PURE__ */ ae.jsx("defs", { children: n.map((s) => /* @__PURE__ */ ae.jsxs(
          "linearGradient",
          {
            id: s.gradient,
            x1: "0%",
            y1: "0%",
            x2: "100%",
            y2: "0%",
            children: [
              /* @__PURE__ */ ae.jsx("stop", { offset: "0%", stopColor: s.color1, stopOpacity: s.opacity }),
              /* @__PURE__ */ ae.jsx("stop", { offset: "100%", stopColor: s.color2, stopOpacity: s.opacity })
            ]
          },
          s.gradient
        )) }),
        n.map((s, a) => /* @__PURE__ */ ae.jsx(
          "line",
          {
            x1: s.x1,
            y1: s.y1,
            x2: s.x2,
            y2: s.y2,
            stroke: `url(#${s.gradient})`,
            strokeWidth: "3",
            style: {
              filter: "brightness(1.5) blur(1px)"
            }
          },
          a
        ))
      ] }),
      /* @__PURE__ */ ae.jsx("div", { style: {
        color: "#00fff2",
        fontSize: "40px",
        fontFamily: "sans-serif",
        letterSpacing: "-2px",
        textShadow: `
            0 0 5px #00fff2,
            0 0 10px #00fff2,
            0 0 20px #00fff2,
            0 0 40px #00fff2
          `,
        animation: "textPulse 1.5s ease-in-out infinite",
        whiteSpace: "nowrap",
        marginTop: "20px"
      }, children: "Connecting I7n Dots..." })
    ] }),
    /* @__PURE__ */ ae.jsx("style", { children: `
          @keyframes textPulse {
            0% { 
              opacity: 0.5;
              transform: scale(0.98) translateY(0);
            }
            50% { 
              opacity: 1;
              transform: scale(1.02) translateY(-5px);
            }
            100% { 
              opacity: 0.5;
              transform: scale(0.98) translateY(0);
            }
          }
        ` })
  ] });
}, HU = ({
  subjectFilter: r,
  predicateFilter: e,
  objectFilter: i,
  onFilterChange: n,
  onReset: s,
  onClose: a
}) => /* @__PURE__ */ ae.jsxs(
  "div",
  {
    style: {
      display: "flex",
      flexDirection: "column",
      background: "#18181b",
      padding: "16px 24px",
      borderRadius: "10px",
      border: "2px solid #ffd32a",
      boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
      position: "relative"
    },
    children: [
      /* @__PURE__ */ ae.jsx(
        "button",
        {
          onClick: a,
          style: {
            position: "absolute",
            top: 4,
            right: 6,
            background: "none",
            border: "none",
            color: "#ffd32a",
            fontSize: 20,
            cursor: "pointer",
            padding: 0,
            lineHeight: 1,
            width: 24,
            height: 24,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            zIndex: 2
          },
          "aria-label": "Close filters",
          children: "×"
        }
      ),
      /* @__PURE__ */ ae.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: [
        /* @__PURE__ */ ae.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ ae.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Subject"
            }
          ),
          /* @__PURE__ */ ae.jsx(
            "input",
            {
              type: "text",
              value: r,
              onChange: (o) => n("subject", o.target.value),
              placeholder: "Filter by subject...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ ae.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ ae.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Predicate"
            }
          ),
          /* @__PURE__ */ ae.jsx(
            "input",
            {
              type: "text",
              value: e,
              onChange: (o) => n("predicate", o.target.value),
              placeholder: "Filter by predicate...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ ae.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ ae.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Object"
            }
          ),
          /* @__PURE__ */ ae.jsx(
            "input",
            {
              type: "text",
              value: i,
              onChange: (o) => n("object", o.target.value),
              placeholder: "Filter by object...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ ae.jsx(
          "button",
          {
            style: {
              background: "#ffd32a",
              color: "#18181b",
              border: "none",
              borderRadius: "8px",
              padding: "8px 24px",
              fontSize: "14px",
              fontWeight: "bold",
              cursor: "pointer",
              textTransform: "uppercase",
              transition: "background 0.2s, transform 0.1s",
              alignSelf: "flex-start",
              marginTop: "8px",
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
            },
            onMouseEnter: (o) => {
              o.currentTarget.style.background = "#ffe066", o.currentTarget.style.transform = "translateY(-1px)";
            },
            onMouseLeave: (o) => {
              o.currentTarget.style.background = "#ffd32a", o.currentTarget.style.transform = "translateY(0)";
            },
            onClick: s,
            children: "Reset"
          }
        )
      ] })
    ]
  }
);
function WU(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e === 0) {
        if (Object(i) !== i) return;
        u = !1;
      } else for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function qU(r, e, i) {
  return e = eF(e), e in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function pS(r, e) {
  return YU(r) || WU(r, e) || UC(r, e) || QU();
}
function XU(r) {
  return $U(r) || KU(r) || UC(r) || ZU();
}
function $U(r) {
  if (Array.isArray(r)) return $v(r);
}
function YU(r) {
  if (Array.isArray(r)) return r;
}
function KU(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function UC(r, e) {
  if (r) {
    if (typeof r == "string") return $v(r, e);
    var i = Object.prototype.toString.call(r).slice(8, -1);
    if (i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set") return Array.from(r);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return $v(r, e);
  }
}
function $v(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = new Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function ZU() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function QU() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function JU(r, e) {
  if (typeof r != "object" || r === null) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function eF(r) {
  var e = JU(r, "string");
  return typeof e == "symbol" ? e : String(e);
}
var tF = function(r, e) {
  var i = new Set(e);
  return Object.assign.apply(Object, [{}].concat(XU(Object.entries(r).filter(function(n) {
    var s = pS(n, 1), a = s[0];
    return !i.has(a);
  }).map(function(n) {
    var s = pS(n, 2), a = s[0], o = s[1];
    return qU({}, a, o);
  }))));
};
function Yv(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function iF(r) {
  if (Array.isArray(r)) return r;
}
function rF(r) {
  if (Array.isArray(r)) return Yv(r);
}
function nF(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function sF(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function aF() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function oF() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function lF(r, e) {
  return iF(r) || sF(r, e) || FC(r, e) || aF();
}
function fS(r) {
  return rF(r) || nF(r) || FC(r) || oF();
}
function FC(r, e) {
  if (r) {
    if (typeof r == "string") return Yv(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Yv(r, e) : void 0;
  }
}
function vg(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = e.wrapperElementType, n = i === void 0 ? "div" : i, s = e.nodeMapper, a = s === void 0 ? function(h) {
    return h;
  } : s, o = e.methodNames, l = o === void 0 ? [] : o, u = e.initPropNames, c = u === void 0 ? [] : u;
  return /* @__PURE__ */ IO(function(h, d) {
    var p = gr(), f = T2(function() {
      var v = Object.fromEntries(c.filter(function(g) {
        return h.hasOwnProperty(g);
      }).map(function(g) {
        return [g, h[g]];
      }));
      return r(v);
    }, []);
    mS(function() {
      f(a(p.current));
    }, DO), mS(function() {
      return f._destructor instanceof Function ? f._destructor : void 0;
    });
    var m = Or(
      function(v) {
        for (var g = arguments.length, _ = new Array(g > 1 ? g - 1 : 0), x = 1; x < g; x++)
          _[x - 1] = arguments[x];
        return f[v] instanceof Function ? f[v].apply(f, _) : void 0;
      },
      [f]
    ), y = gr({});
    return Object.keys(tF(h, [].concat(fS(l), fS(c)))).filter(function(v) {
      return y.current[v] !== h[v];
    }).forEach(function(v) {
      return m(v, h[v]);
    }), y.current = h, OO(d, function() {
      return Object.fromEntries(l.map(function(v) {
        return [v, function() {
          for (var g = arguments.length, _ = new Array(g), x = 0; x < g; x++)
            _[x] = arguments[x];
          return m.apply(void 0, [v].concat(_));
        }];
      }));
    }, [m]), /* @__PURE__ */ si.createElement(n, {
      ref: p
    });
  });
}
function mS(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ft, i = gr(), n = gr(!1), s = gr(!1), a = ve(0), o = lF(a, 2);
  o[0];
  var l = o[1];
  n.current && (s.current = !0), e(function() {
    return n.current || (i.current = r(), n.current = !0), l(function(u) {
      return u + 1;
    }), function() {
      s.current && i.current && i.current();
    };
  }, []);
}
var Kv = { exports: {} }, gy = { exports: {} }, $t = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gS;
function uF() {
  if (gS) return $t;
  gS = 1;
  var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, i = r ? Symbol.for("react.portal") : 60106, n = r ? Symbol.for("react.fragment") : 60107, s = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, o = r ? Symbol.for("react.provider") : 60109, l = r ? Symbol.for("react.context") : 60110, u = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, h = r ? Symbol.for("react.forward_ref") : 60112, d = r ? Symbol.for("react.suspense") : 60113, p = r ? Symbol.for("react.suspense_list") : 60120, f = r ? Symbol.for("react.memo") : 60115, m = r ? Symbol.for("react.lazy") : 60116, y = r ? Symbol.for("react.block") : 60121, v = r ? Symbol.for("react.fundamental") : 60117, g = r ? Symbol.for("react.responder") : 60118, _ = r ? Symbol.for("react.scope") : 60119;
  function x(T) {
    if (typeof T == "object" && T !== null) {
      var S = T.$$typeof;
      switch (S) {
        case e:
          switch (T = T.type, T) {
            case u:
            case c:
            case n:
            case a:
            case s:
            case d:
              return T;
            default:
              switch (T = T && T.$$typeof, T) {
                case l:
                case h:
                case m:
                case f:
                case o:
                  return T;
                default:
                  return S;
              }
          }
        case i:
          return S;
      }
    }
  }
  function b(T) {
    return x(T) === c;
  }
  return $t.AsyncMode = u, $t.ConcurrentMode = c, $t.ContextConsumer = l, $t.ContextProvider = o, $t.Element = e, $t.ForwardRef = h, $t.Fragment = n, $t.Lazy = m, $t.Memo = f, $t.Portal = i, $t.Profiler = a, $t.StrictMode = s, $t.Suspense = d, $t.isAsyncMode = function(T) {
    return b(T) || x(T) === u;
  }, $t.isConcurrentMode = b, $t.isContextConsumer = function(T) {
    return x(T) === l;
  }, $t.isContextProvider = function(T) {
    return x(T) === o;
  }, $t.isElement = function(T) {
    return typeof T == "object" && T !== null && T.$$typeof === e;
  }, $t.isForwardRef = function(T) {
    return x(T) === h;
  }, $t.isFragment = function(T) {
    return x(T) === n;
  }, $t.isLazy = function(T) {
    return x(T) === m;
  }, $t.isMemo = function(T) {
    return x(T) === f;
  }, $t.isPortal = function(T) {
    return x(T) === i;
  }, $t.isProfiler = function(T) {
    return x(T) === a;
  }, $t.isStrictMode = function(T) {
    return x(T) === s;
  }, $t.isSuspense = function(T) {
    return x(T) === d;
  }, $t.isValidElementType = function(T) {
    return typeof T == "string" || typeof T == "function" || T === n || T === c || T === a || T === s || T === d || T === p || typeof T == "object" && T !== null && (T.$$typeof === m || T.$$typeof === f || T.$$typeof === o || T.$$typeof === l || T.$$typeof === h || T.$$typeof === v || T.$$typeof === g || T.$$typeof === _ || T.$$typeof === y);
  }, $t.typeOf = x, $t;
}
var Qt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yS;
function cF() {
  return yS || (yS = 1, process.env.NODE_ENV !== "production" && function() {
    var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, i = r ? Symbol.for("react.portal") : 60106, n = r ? Symbol.for("react.fragment") : 60107, s = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, o = r ? Symbol.for("react.provider") : 60109, l = r ? Symbol.for("react.context") : 60110, u = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, h = r ? Symbol.for("react.forward_ref") : 60112, d = r ? Symbol.for("react.suspense") : 60113, p = r ? Symbol.for("react.suspense_list") : 60120, f = r ? Symbol.for("react.memo") : 60115, m = r ? Symbol.for("react.lazy") : 60116, y = r ? Symbol.for("react.block") : 60121, v = r ? Symbol.for("react.fundamental") : 60117, g = r ? Symbol.for("react.responder") : 60118, _ = r ? Symbol.for("react.scope") : 60119;
    function x(xe) {
      return typeof xe == "string" || typeof xe == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      xe === n || xe === c || xe === a || xe === s || xe === d || xe === p || typeof xe == "object" && xe !== null && (xe.$$typeof === m || xe.$$typeof === f || xe.$$typeof === o || xe.$$typeof === l || xe.$$typeof === h || xe.$$typeof === v || xe.$$typeof === g || xe.$$typeof === _ || xe.$$typeof === y);
    }
    function b(xe) {
      if (typeof xe == "object" && xe !== null) {
        var vt = xe.$$typeof;
        switch (vt) {
          case e:
            var Z = xe.type;
            switch (Z) {
              case u:
              case c:
              case n:
              case a:
              case s:
              case d:
                return Z;
              default:
                var Ht = Z && Z.$$typeof;
                switch (Ht) {
                  case l:
                  case h:
                  case m:
                  case f:
                  case o:
                    return Ht;
                  default:
                    return vt;
                }
            }
          case i:
            return vt;
        }
      }
    }
    var T = u, S = c, w = l, M = o, E = e, A = h, N = n, U = m, k = f, C = i, I = a, O = s, W = d, V = !1;
    function Q(xe) {
      return V || (V = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), F(xe) || b(xe) === u;
    }
    function F(xe) {
      return b(xe) === c;
    }
    function B(xe) {
      return b(xe) === l;
    }
    function q(xe) {
      return b(xe) === o;
    }
    function G(xe) {
      return typeof xe == "object" && xe !== null && xe.$$typeof === e;
    }
    function z(xe) {
      return b(xe) === h;
    }
    function Y(xe) {
      return b(xe) === n;
    }
    function se(xe) {
      return b(xe) === m;
    }
    function ne(xe) {
      return b(xe) === f;
    }
    function fe(xe) {
      return b(xe) === i;
    }
    function Se(xe) {
      return b(xe) === a;
    }
    function Pe(xe) {
      return b(xe) === s;
    }
    function lt(xe) {
      return b(xe) === d;
    }
    Qt.AsyncMode = T, Qt.ConcurrentMode = S, Qt.ContextConsumer = w, Qt.ContextProvider = M, Qt.Element = E, Qt.ForwardRef = A, Qt.Fragment = N, Qt.Lazy = U, Qt.Memo = k, Qt.Portal = C, Qt.Profiler = I, Qt.StrictMode = O, Qt.Suspense = W, Qt.isAsyncMode = Q, Qt.isConcurrentMode = F, Qt.isContextConsumer = B, Qt.isContextProvider = q, Qt.isElement = G, Qt.isForwardRef = z, Qt.isFragment = Y, Qt.isLazy = se, Qt.isMemo = ne, Qt.isPortal = fe, Qt.isProfiler = Se, Qt.isStrictMode = Pe, Qt.isSuspense = lt, Qt.isValidElementType = x, Qt.typeOf = b;
  }()), Qt;
}
var vS;
function BC() {
  return vS || (vS = 1, process.env.NODE_ENV === "production" ? gy.exports = uF() : gy.exports = cF()), gy.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var yy, bS;
function hF() {
  if (bS) return yy;
  bS = 1;
  var r = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, i = Object.prototype.propertyIsEnumerable;
  function n(a) {
    if (a == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(a);
  }
  function s() {
    try {
      if (!Object.assign)
        return !1;
      var a = new String("abc");
      if (a[5] = "de", Object.getOwnPropertyNames(a)[0] === "5")
        return !1;
      for (var o = {}, l = 0; l < 10; l++)
        o["_" + String.fromCharCode(l)] = l;
      var u = Object.getOwnPropertyNames(o).map(function(h) {
        return o[h];
      });
      if (u.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(h) {
        c[h] = h;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return yy = s() ? Object.assign : function(a, o) {
    for (var l, u = n(a), c, h = 1; h < arguments.length; h++) {
      l = Object(arguments[h]);
      for (var d in l)
        e.call(l, d) && (u[d] = l[d]);
      if (r) {
        c = r(l);
        for (var p = 0; p < c.length; p++)
          i.call(l, c[p]) && (u[c[p]] = l[c[p]]);
      }
    }
    return u;
  }, yy;
}
var vy, xS;
function M_() {
  if (xS) return vy;
  xS = 1;
  var r = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return vy = r, vy;
}
var _S, TS;
function zC() {
  return TS || (TS = 1, _S = Function.call.bind(Object.prototype.hasOwnProperty)), _S;
}
var by, SS;
function dF() {
  if (SS) return by;
  SS = 1;
  var r = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = M_(), i = {}, n = zC();
    r = function(a) {
      var o = "Warning: " + a;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function s(a, o, l, u, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var h in a)
        if (n(a, h)) {
          var d;
          try {
            if (typeof a[h] != "function") {
              var p = Error(
                (u || "React class") + ": " + l + " type `" + h + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[h] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = a[h](o, h, u, l, null, e);
          } catch (m) {
            d = m;
          }
          if (d && !(d instanceof Error) && r(
            (u || "React class") + ": type specification of " + l + " `" + h + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in i)) {
            i[d.message] = !0;
            var f = c ? c() : "";
            r(
              "Failed " + l + " type: " + d.message + (f ?? "")
            );
          }
        }
    }
  }
  return s.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (i = {});
  }, by = s, by;
}
var xy, wS;
function pF() {
  if (wS) return xy;
  wS = 1;
  var r = BC(), e = hF(), i = M_(), n = zC(), s = dF(), a = function() {
  };
  process.env.NODE_ENV !== "production" && (a = function(l) {
    var u = "Warning: " + l;
    typeof console < "u" && console.error(u);
    try {
      throw new Error(u);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return xy = function(l, u) {
    var c = typeof Symbol == "function" && Symbol.iterator, h = "@@iterator";
    function d(F) {
      var B = F && (c && F[c] || F[h]);
      if (typeof B == "function")
        return B;
    }
    var p = "<<anonymous>>", f = {
      array: g("array"),
      bigint: g("bigint"),
      bool: g("boolean"),
      func: g("function"),
      number: g("number"),
      object: g("object"),
      string: g("string"),
      symbol: g("symbol"),
      any: _(),
      arrayOf: x,
      element: b(),
      elementType: T(),
      instanceOf: S,
      node: A(),
      objectOf: M,
      oneOf: w,
      oneOfType: E,
      shape: U,
      exact: k
    };
    function m(F, B) {
      return F === B ? F !== 0 || 1 / F === 1 / B : F !== F && B !== B;
    }
    function y(F, B) {
      this.message = F, this.data = B && typeof B == "object" ? B : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function v(F) {
      if (process.env.NODE_ENV !== "production")
        var B = {}, q = 0;
      function G(Y, se, ne, fe, Se, Pe, lt) {
        if (fe = fe || p, Pe = Pe || ne, lt !== i) {
          if (u) {
            var xe = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw xe.name = "Invariant Violation", xe;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var vt = fe + ":" + ne;
            !B[vt] && // Avoid spamming the console because they are often not actionable except for lib authors
            q < 3 && (a(
              "You are manually calling a React.PropTypes validation function for the `" + Pe + "` prop on `" + fe + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), B[vt] = !0, q++);
          }
        }
        return se[ne] == null ? Y ? se[ne] === null ? new y("The " + Se + " `" + Pe + "` is marked as required " + ("in `" + fe + "`, but its value is `null`.")) : new y("The " + Se + " `" + Pe + "` is marked as required in " + ("`" + fe + "`, but its value is `undefined`.")) : null : F(se, ne, fe, Se, Pe);
      }
      var z = G.bind(null, !1);
      return z.isRequired = G.bind(null, !0), z;
    }
    function g(F) {
      function B(q, G, z, Y, se, ne) {
        var fe = q[G], Se = O(fe);
        if (Se !== F) {
          var Pe = W(fe);
          return new y(
            "Invalid " + Y + " `" + se + "` of type " + ("`" + Pe + "` supplied to `" + z + "`, expected ") + ("`" + F + "`."),
            { expectedType: F }
          );
        }
        return null;
      }
      return v(B);
    }
    function _() {
      return v(o);
    }
    function x(F) {
      function B(q, G, z, Y, se) {
        if (typeof F != "function")
          return new y("Property `" + se + "` of component `" + z + "` has invalid PropType notation inside arrayOf.");
        var ne = q[G];
        if (!Array.isArray(ne)) {
          var fe = O(ne);
          return new y("Invalid " + Y + " `" + se + "` of type " + ("`" + fe + "` supplied to `" + z + "`, expected an array."));
        }
        for (var Se = 0; Se < ne.length; Se++) {
          var Pe = F(ne, Se, z, Y, se + "[" + Se + "]", i);
          if (Pe instanceof Error)
            return Pe;
        }
        return null;
      }
      return v(B);
    }
    function b() {
      function F(B, q, G, z, Y) {
        var se = B[q];
        if (!l(se)) {
          var ne = O(se);
          return new y("Invalid " + z + " `" + Y + "` of type " + ("`" + ne + "` supplied to `" + G + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(F);
    }
    function T() {
      function F(B, q, G, z, Y) {
        var se = B[q];
        if (!r.isValidElementType(se)) {
          var ne = O(se);
          return new y("Invalid " + z + " `" + Y + "` of type " + ("`" + ne + "` supplied to `" + G + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(F);
    }
    function S(F) {
      function B(q, G, z, Y, se) {
        if (!(q[G] instanceof F)) {
          var ne = F.name || p, fe = Q(q[G]);
          return new y("Invalid " + Y + " `" + se + "` of type " + ("`" + fe + "` supplied to `" + z + "`, expected ") + ("instance of `" + ne + "`."));
        }
        return null;
      }
      return v(B);
    }
    function w(F) {
      if (!Array.isArray(F))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? a(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : a("Invalid argument supplied to oneOf, expected an array.")), o;
      function B(q, G, z, Y, se) {
        for (var ne = q[G], fe = 0; fe < F.length; fe++)
          if (m(ne, F[fe]))
            return null;
        var Se = JSON.stringify(F, function(Pe, lt) {
          var xe = W(lt);
          return xe === "symbol" ? String(lt) : lt;
        });
        return new y("Invalid " + Y + " `" + se + "` of value `" + String(ne) + "` " + ("supplied to `" + z + "`, expected one of " + Se + "."));
      }
      return v(B);
    }
    function M(F) {
      function B(q, G, z, Y, se) {
        if (typeof F != "function")
          return new y("Property `" + se + "` of component `" + z + "` has invalid PropType notation inside objectOf.");
        var ne = q[G], fe = O(ne);
        if (fe !== "object")
          return new y("Invalid " + Y + " `" + se + "` of type " + ("`" + fe + "` supplied to `" + z + "`, expected an object."));
        for (var Se in ne)
          if (n(ne, Se)) {
            var Pe = F(ne, Se, z, Y, se + "." + Se, i);
            if (Pe instanceof Error)
              return Pe;
          }
        return null;
      }
      return v(B);
    }
    function E(F) {
      if (!Array.isArray(F))
        return process.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var B = 0; B < F.length; B++) {
        var q = F[B];
        if (typeof q != "function")
          return a(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + V(q) + " at index " + B + "."
          ), o;
      }
      function G(z, Y, se, ne, fe) {
        for (var Se = [], Pe = 0; Pe < F.length; Pe++) {
          var lt = F[Pe], xe = lt(z, Y, se, ne, fe, i);
          if (xe == null)
            return null;
          xe.data && n(xe.data, "expectedType") && Se.push(xe.data.expectedType);
        }
        var vt = Se.length > 0 ? ", expected one of type [" + Se.join(", ") + "]" : "";
        return new y("Invalid " + ne + " `" + fe + "` supplied to " + ("`" + se + "`" + vt + "."));
      }
      return v(G);
    }
    function A() {
      function F(B, q, G, z, Y) {
        return C(B[q]) ? null : new y("Invalid " + z + " `" + Y + "` supplied to " + ("`" + G + "`, expected a ReactNode."));
      }
      return v(F);
    }
    function N(F, B, q, G, z) {
      return new y(
        (F || "React class") + ": " + B + " type `" + q + "." + G + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + z + "`."
      );
    }
    function U(F) {
      function B(q, G, z, Y, se) {
        var ne = q[G], fe = O(ne);
        if (fe !== "object")
          return new y("Invalid " + Y + " `" + se + "` of type `" + fe + "` " + ("supplied to `" + z + "`, expected `object`."));
        for (var Se in F) {
          var Pe = F[Se];
          if (typeof Pe != "function")
            return N(z, Y, se, Se, W(Pe));
          var lt = Pe(ne, Se, z, Y, se + "." + Se, i);
          if (lt)
            return lt;
        }
        return null;
      }
      return v(B);
    }
    function k(F) {
      function B(q, G, z, Y, se) {
        var ne = q[G], fe = O(ne);
        if (fe !== "object")
          return new y("Invalid " + Y + " `" + se + "` of type `" + fe + "` " + ("supplied to `" + z + "`, expected `object`."));
        var Se = e({}, q[G], F);
        for (var Pe in Se) {
          var lt = F[Pe];
          if (n(F, Pe) && typeof lt != "function")
            return N(z, Y, se, Pe, W(lt));
          if (!lt)
            return new y(
              "Invalid " + Y + " `" + se + "` key `" + Pe + "` supplied to `" + z + "`.\nBad object: " + JSON.stringify(q[G], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(F), null, "  ")
            );
          var xe = lt(ne, Pe, z, Y, se + "." + Pe, i);
          if (xe)
            return xe;
        }
        return null;
      }
      return v(B);
    }
    function C(F) {
      switch (typeof F) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !F;
        case "object":
          if (Array.isArray(F))
            return F.every(C);
          if (F === null || l(F))
            return !0;
          var B = d(F);
          if (B) {
            var q = B.call(F), G;
            if (B !== F.entries) {
              for (; !(G = q.next()).done; )
                if (!C(G.value))
                  return !1;
            } else
              for (; !(G = q.next()).done; ) {
                var z = G.value;
                if (z && !C(z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function I(F, B) {
      return F === "symbol" ? !0 : B ? B["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && B instanceof Symbol : !1;
    }
    function O(F) {
      var B = typeof F;
      return Array.isArray(F) ? "array" : F instanceof RegExp ? "object" : I(B, F) ? "symbol" : B;
    }
    function W(F) {
      if (typeof F > "u" || F === null)
        return "" + F;
      var B = O(F);
      if (B === "object") {
        if (F instanceof Date)
          return "date";
        if (F instanceof RegExp)
          return "regexp";
      }
      return B;
    }
    function V(F) {
      var B = W(F);
      switch (B) {
        case "array":
        case "object":
          return "an " + B;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + B;
        default:
          return B;
      }
    }
    function Q(F) {
      return !F.constructor || !F.constructor.name ? p : F.constructor.name;
    }
    return f.checkPropTypes = s, f.resetWarningCache = s.resetWarningCache, f.PropTypes = f, f;
  }, xy;
}
var _y, ES;
function fF() {
  if (ES) return _y;
  ES = 1;
  var r = M_();
  function e() {
  }
  function i() {
  }
  return i.resetWarningCache = e, _y = function() {
    function n(o, l, u, c, h, d) {
      if (d !== r) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    n.isRequired = n;
    function s() {
      return n;
    }
    var a = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: s,
      element: n,
      elementType: n,
      instanceOf: s,
      node: n,
      objectOf: s,
      oneOf: s,
      oneOfType: s,
      shape: s,
      exact: s,
      checkPropTypes: i,
      resetWarningCache: e
    };
    return a.PropTypes = a, a;
  }, _y;
}
if (process.env.NODE_ENV !== "production") {
  var mF = BC(), gF = !0;
  Kv.exports = pF()(mF.isElement, gF);
} else
  Kv.exports = fF()();
var yF = Kv.exports;
const ie = /* @__PURE__ */ v_(yF);
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const bg = "170", tr = { ROTATE: 0, DOLLY: 1, PAN: 2 }, ia = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, vF = 0, MS = 1, bF = 2, jC = 1, xF = 2, Gs = 3, mo = 0, Mr = 1, Zs = 2, la = 0, Gu = 1, AS = 2, CS = 3, RS = 4, _F = 5, $o = 100, TF = 101, SF = 102, wF = 103, EF = 104, MF = 200, AF = 201, CF = 202, RF = 203, Zv = 204, Qv = 205, NF = 206, PF = 207, IF = 208, OF = 209, DF = 210, LF = 211, kF = 212, UF = 213, FF = 214, Jv = 0, eb = 1, tb = 2, hc = 3, ib = 4, rb = 5, nb = 6, sb = 7, A_ = 0, BF = 1, zF = 2, lo = 0, jF = 1, VF = 2, GF = 3, HF = 4, WF = 5, qF = 6, XF = 7, VC = 300, dc = 301, pc = 302, ab = 303, ob = 304, xg = 306, lb = 1e3, rl = 1001, ub = 1002, Kn = 1003, $F = 1004, dp = 1005, ds = 1006, Ty = 1007, nl = 1008, ba = 1009, GC = 1010, HC = 1011, cd = 1012, C_ = 1013, xl = 1014, ra = 1015, Lc = 1016, R_ = 1017, N_ = 1018, fc = 1020, WC = 35902, qC = 1021, XC = 1022, Xn = 1023, $C = 1024, YC = 1025, Hu = 1026, mc = 1027, KC = 1028, P_ = 1029, ZC = 1030, I_ = 1031, O_ = 1033, Wf = 33776, qf = 33777, Xf = 33778, $f = 33779, cb = 35840, hb = 35841, db = 35842, pb = 35843, fb = 36196, mb = 37492, gb = 37496, yb = 37808, vb = 37809, bb = 37810, xb = 37811, _b = 37812, Tb = 37813, Sb = 37814, wb = 37815, Eb = 37816, Mb = 37817, Ab = 37818, Cb = 37819, Rb = 37820, Nb = 37821, Yf = 36492, Pb = 36494, Ib = 36495, QC = 36283, Ob = 36284, Db = 36285, Lb = 36286, YF = 3200, KF = 3201, JC = 0, ZF = 1, Qa = "", nn = "srgb", kc = "srgb-linear", _g = "linear", ei = "srgb", zl = 7680, NS = 519, QF = 512, JF = 513, e5 = 514, eR = 515, t5 = 516, i5 = 517, r5 = 518, n5 = 519, kb = 35044, PS = "300 es", na = 2e3, bm = 2001;
let Cl = class {
  addEventListener(r, e) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[r] === void 0 && (i[r] = []), i[r].indexOf(e) === -1 && i[r].push(e);
  }
  hasEventListener(r, e) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[r] !== void 0 && i[r].indexOf(e) !== -1;
  }
  removeEventListener(r, e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[r];
    if (i !== void 0) {
      const n = i.indexOf(e);
      n !== -1 && i.splice(n, 1);
    }
  }
  dispatchEvent(r) {
    if (this._listeners === void 0) return;
    const e = this._listeners[r.type];
    if (e !== void 0) {
      r.target = this;
      const i = e.slice(0);
      for (let n = 0, s = i.length; n < s; n++)
        i[n].call(this, r);
      r.target = null;
    }
  }
};
const or = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let IS = 1234567;
const $h = Math.PI / 180, hd = 180 / Math.PI;
function ua() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (or[r & 255] + or[r >> 8 & 255] + or[r >> 16 & 255] + or[r >> 24 & 255] + "-" + or[e & 255] + or[e >> 8 & 255] + "-" + or[e >> 16 & 15 | 64] + or[e >> 24 & 255] + "-" + or[i & 63 | 128] + or[i >> 8 & 255] + "-" + or[i >> 16 & 255] + or[i >> 24 & 255] + or[n & 255] + or[n >> 8 & 255] + or[n >> 16 & 255] + or[n >> 24 & 255]).toLowerCase();
}
function Yi(r, e, i) {
  return Math.max(e, Math.min(i, r));
}
function D_(r, e) {
  return (r % e + e) % e;
}
function s5(r, e, i, n, s) {
  return n + (r - e) * (s - n) / (i - e);
}
function a5(r, e, i) {
  return r !== e ? (i - r) / (e - r) : 0;
}
function Yh(r, e, i) {
  return (1 - i) * r + i * e;
}
function o5(r, e, i, n) {
  return Yh(r, e, 1 - Math.exp(-i * n));
}
function l5(r, e = 1) {
  return e - Math.abs(D_(r, e * 2) - e);
}
function u5(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * (3 - 2 * r));
}
function c5(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * r * (r * (r * 6 - 15) + 10));
}
function h5(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function d5(r, e) {
  return r + Math.random() * (e - r);
}
function p5(r) {
  return r * (0.5 - Math.random());
}
function f5(r) {
  r !== void 0 && (IS = r);
  let e = IS += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function m5(r) {
  return r * $h;
}
function g5(r) {
  return r * hd;
}
function y5(r) {
  return (r & r - 1) === 0 && r !== 0;
}
function v5(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function b5(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function x5(r, e, i, n, s) {
  const a = Math.cos, o = Math.sin, l = a(i / 2), u = o(i / 2), c = a((e + n) / 2), h = o((e + n) / 2), d = a((e - n) / 2), p = o((e - n) / 2), f = a((n - e) / 2), m = o((n - e) / 2);
  switch (s) {
    case "XYX":
      r.set(l * h, u * d, u * p, l * c);
      break;
    case "YZY":
      r.set(u * p, l * h, u * d, l * c);
      break;
    case "ZXZ":
      r.set(u * d, u * p, l * h, l * c);
      break;
    case "XZX":
      r.set(l * h, u * m, u * f, l * c);
      break;
    case "YXY":
      r.set(u * f, l * h, u * m, l * c);
      break;
    case "ZYZ":
      r.set(u * m, u * f, l * h, l * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function Hn(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Jt(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Ub = {
  DEG2RAD: $h,
  RAD2DEG: hd,
  generateUUID: ua,
  clamp: Yi,
  euclideanModulo: D_,
  mapLinear: s5,
  inverseLerp: a5,
  lerp: Yh,
  damp: o5,
  pingpong: l5,
  smoothstep: u5,
  smootherstep: c5,
  randInt: h5,
  randFloat: d5,
  randFloatSpread: p5,
  seededRandom: f5,
  degToRad: m5,
  radToDeg: g5,
  isPowerOfTwo: y5,
  ceilPowerOfTwo: v5,
  floorPowerOfTwo: b5,
  setQuaternionFromProperEuler: x5,
  normalize: Jt,
  denormalize: Hn
};
let ke = class tR {
  constructor(e = 0, i = 0) {
    tR.prototype.isVector2 = !0, this.x = e, this.y = i;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, i) {
    return this.x = e, this.y = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * i + s[3] * n + s[6], this.y = s[1] * i + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(Yi(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y;
    return i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this;
  }
  rotateAround(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = this.x - e.x, o = this.y - e.y;
    return this.x = a * n - o * s + e.x, this.y = a * s + o * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}, It = class iR {
  constructor(e, i, n, s, a, o, l, u, c) {
    iR.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c);
  }
  set(e, i, n, s, a, o, l, u, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = l, h[3] = i, h[4] = a, h[5] = u, h[6] = n, h[7] = o, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrix3Column(this, 0), i.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[4],
      i[8],
      i[1],
      i[5],
      i[9],
      i[2],
      i[6],
      i[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[3], u = n[6], c = n[1], h = n[4], d = n[7], p = n[2], f = n[5], m = n[8], y = s[0], v = s[3], g = s[6], _ = s[1], x = s[4], b = s[7], T = s[2], S = s[5], w = s[8];
    return a[0] = o * y + l * _ + u * T, a[3] = o * v + l * x + u * S, a[6] = o * g + l * b + u * w, a[1] = c * y + h * _ + d * T, a[4] = c * v + h * x + d * S, a[7] = c * g + h * b + d * w, a[2] = p * y + f * _ + m * T, a[5] = p * v + f * x + m * S, a[8] = p * g + f * b + m * w, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= e, i[4] *= e, i[7] *= e, i[2] *= e, i[5] *= e, i[8] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8];
    return i * o * h - i * l * c - n * a * h + n * l * u + s * a * c - s * o * u;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = h * o - l * c, p = l * u - h * a, f = c * a - o * u, m = i * d + n * p + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const y = 1 / m;
    return e[0] = d * y, e[1] = (s * c - h * n) * y, e[2] = (l * n - s * o) * y, e[3] = p * y, e[4] = (h * i - s * u) * y, e[5] = (s * a - l * i) * y, e[6] = f * y, e[7] = (n * u - c * i) * y, e[8] = (o * i - n * a) * y, this;
  }
  transpose() {
    let e;
    const i = this.elements;
    return e = i[1], i[1] = i[3], i[3] = e, e = i[2], i[2] = i[6], i[6] = e, e = i[5], i[5] = i[7], i[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const i = this.elements;
    return e[0] = i[0], e[1] = i[3], e[2] = i[6], e[3] = i[1], e[4] = i[4], e[5] = i[7], e[6] = i[2], e[7] = i[5], e[8] = i[8], this;
  }
  setUvTransform(e, i, n, s, a, o, l) {
    const u = Math.cos(a), c = Math.sin(a);
    return this.set(
      n * u,
      n * c,
      -n * (u * o + c * l) + o + e,
      -s * c,
      s * u,
      -s * (-c * o + u * l) + l + i,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, i) {
    return this.premultiply(Sy.makeScale(e, i)), this;
  }
  rotate(e) {
    return this.premultiply(Sy.makeRotation(-e)), this;
  }
  translate(e, i) {
    return this.premultiply(Sy.makeTranslation(e, i)), this;
  }
  // for 2D Transforms
  makeTranslation(e, i) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      i,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      n,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i) {
    return this.set(
      e,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
const Sy = /* @__PURE__ */ new It();
function rR(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function dd(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function _5() {
  const r = dd("canvas");
  return r.style.display = "block", r;
}
const OS = {};
function Fh(r) {
  r in OS || (OS[r] = !0, console.warn(r));
}
function T5(r, e, i) {
  return new Promise(function(n, s) {
    function a() {
      switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case r.WAIT_FAILED:
          s();
          break;
        case r.TIMEOUT_EXPIRED:
          setTimeout(a, i);
          break;
        default:
          n();
      }
    }
    setTimeout(a, i);
  });
}
function S5(r) {
  const e = r.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function w5(r) {
  const e = r.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const Gt = {
  enabled: !0,
  workingColorSpace: kc,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(r, e, i) {
    return this.enabled === !1 || e === i || !e || !i || (this.spaces[e].transfer === ei && (r.r = ca(r.r), r.g = ca(r.g), r.b = ca(r.b)), this.spaces[e].primaries !== this.spaces[i].primaries && (r.applyMatrix3(this.spaces[e].toXYZ), r.applyMatrix3(this.spaces[i].fromXYZ)), this.spaces[i].transfer === ei && (r.r = Wu(r.r), r.g = Wu(r.g), r.b = Wu(r.b))), r;
  },
  fromWorkingColorSpace: function(r, e) {
    return this.convert(r, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(r, e) {
    return this.convert(r, e, this.workingColorSpace);
  },
  getPrimaries: function(r) {
    return this.spaces[r].primaries;
  },
  getTransfer: function(r) {
    return r === Qa ? _g : this.spaces[r].transfer;
  },
  getLuminanceCoefficients: function(r, e = this.workingColorSpace) {
    return r.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(r) {
    Object.assign(this.spaces, r);
  },
  // Internal APIs
  _getMatrix: function(r, e, i) {
    return r.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(r) {
    return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(r = this.workingColorSpace) {
    return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
  }
};
function ca(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Wu(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const DS = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], LS = [0.2126, 0.7152, 0.0722], kS = [0.3127, 0.329], US = /* @__PURE__ */ new It().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), FS = /* @__PURE__ */ new It().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
Gt.define({
  [kc]: {
    primaries: DS,
    whitePoint: kS,
    transfer: _g,
    toXYZ: US,
    fromXYZ: FS,
    luminanceCoefficients: LS,
    workingColorSpaceConfig: { unpackColorSpace: nn },
    outputColorSpaceConfig: { drawingBufferColorSpace: nn }
  },
  [nn]: {
    primaries: DS,
    whitePoint: kS,
    transfer: ei,
    toXYZ: US,
    fromXYZ: FS,
    luminanceCoefficients: LS,
    outputColorSpaceConfig: { drawingBufferColorSpace: nn }
  }
});
let jl, E5 = class {
  static getDataURL(r) {
    if (/^data:/i.test(r.src) || typeof HTMLCanvasElement > "u")
      return r.src;
    let e;
    if (r instanceof HTMLCanvasElement)
      e = r;
    else {
      jl === void 0 && (jl = dd("canvas")), jl.width = r.width, jl.height = r.height;
      const i = jl.getContext("2d");
      r instanceof ImageData ? i.putImageData(r, 0, 0) : i.drawImage(r, 0, 0, r.width, r.height), e = jl;
    }
    return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", r), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
  }
  static sRGBToLinear(r) {
    if (typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap) {
      const e = dd("canvas");
      e.width = r.width, e.height = r.height;
      const i = e.getContext("2d");
      i.drawImage(r, 0, 0, r.width, r.height);
      const n = i.getImageData(0, 0, r.width, r.height), s = n.data;
      for (let a = 0; a < s.length; a++)
        s[a] = ca(s[a] / 255) * 255;
      return i.putImageData(n, 0, 0), e;
    } else if (r.data) {
      const e = r.data.slice(0);
      for (let i = 0; i < e.length; i++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[i] = Math.floor(ca(e[i] / 255) * 255) : e[i] = ca(e[i]);
      return {
        data: e,
        width: r.width,
        height: r.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), r;
  }
}, M5 = 0, nR = class {
  constructor(r = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: M5++ }), this.uuid = ua(), this.data = r, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  toJSON(r) {
    const e = r === void 0 || typeof r == "string";
    if (!e && r.images[this.uuid] !== void 0)
      return r.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, n = this.data;
    if (n !== null) {
      let s;
      if (Array.isArray(n)) {
        s = [];
        for (let a = 0, o = n.length; a < o; a++)
          n[a].isDataTexture ? s.push(wy(n[a].image)) : s.push(wy(n[a]));
      } else
        s = wy(n);
      i.url = s;
    }
    return e || (r.images[this.uuid] = i), i;
  }
};
function wy(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? E5.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let A5 = 0, wn = class Kf extends Cl {
  constructor(e = Kf.DEFAULT_IMAGE, i = Kf.DEFAULT_MAPPING, n = rl, s = rl, a = ds, o = nl, l = Xn, u = ba, c = Kf.DEFAULT_ANISOTROPY, h = Qa) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: A5++ }), this.uuid = ua(), this.name = "", this.source = new nR(e), this.mipmaps = [], this.mapping = i, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = a, this.minFilter = o, this.anisotropy = c, this.format = l, this.internalFormat = null, this.type = u, this.offset = new ke(0, 0), this.repeat = new ke(1, 1), this.center = new ke(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new It(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), i || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== VC) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case lb:
          e.x = e.x - Math.floor(e.x);
          break;
        case rl:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case ub:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case lb:
          e.y = e.y - Math.floor(e.y);
          break;
        case rl:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case ub:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
};
wn.DEFAULT_IMAGE = null;
wn.DEFAULT_MAPPING = VC;
wn.DEFAULT_ANISOTROPY = 1;
let Fi = class sR {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    sR.prototype.isVector4 = !0, this.x = e, this.y = i, this.z = n, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, i, n, s) {
    return this.x = e, this.y = i, this.z = n, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      case 3:
        this.w = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this.w = e.w + i.w, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this.w += e.w * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this.w = e.w - i.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = this.w, o = e.elements;
    return this.x = o[0] * i + o[4] * n + o[8] * s + o[12] * a, this.y = o[1] * i + o[5] * n + o[9] * s + o[13] * a, this.z = o[2] * i + o[6] * n + o[10] * s + o[14] * a, this.w = o[3] * i + o[7] * n + o[11] * s + o[15] * a, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const i = Math.sqrt(1 - e.w * e.w);
    return i < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / i, this.y = e.y / i, this.z = e.z / i), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let i, n, s, a;
    const o = e.elements, l = o[0], u = o[4], c = o[8], h = o[1], d = o[5], p = o[9], f = o[2], m = o[6], y = o[10];
    if (Math.abs(u - h) < 0.01 && Math.abs(c - f) < 0.01 && Math.abs(p - m) < 0.01) {
      if (Math.abs(u + h) < 0.1 && Math.abs(c + f) < 0.1 && Math.abs(p + m) < 0.1 && Math.abs(l + d + y - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      i = Math.PI;
      const g = (l + 1) / 2, _ = (d + 1) / 2, x = (y + 1) / 2, b = (u + h) / 4, T = (c + f) / 4, S = (p + m) / 4;
      return g > _ && g > x ? g < 0.01 ? (n = 0, s = 0.707106781, a = 0.707106781) : (n = Math.sqrt(g), s = b / n, a = T / n) : _ > x ? _ < 0.01 ? (n = 0.707106781, s = 0, a = 0.707106781) : (s = Math.sqrt(_), n = b / s, a = S / s) : x < 0.01 ? (n = 0.707106781, s = 0.707106781, a = 0) : (a = Math.sqrt(x), n = T / a, s = S / a), this.set(n, s, a, i), this;
    }
    let v = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (h - u) * (h - u));
    return Math.abs(v) < 1e-3 && (v = 1), this.x = (m - p) / v, this.y = (c - f) / v, this.z = (h - u) / v, this.w = Math.acos((l + d + y - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this.w = i[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this.w = Math.max(e.w, Math.min(i.w, this.w)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this.w = Math.max(e, Math.min(i, this.w)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this.w += (e.w - this.w) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this.w = e.w + (i.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this.w = e[i + 3], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e[i + 3] = this.w, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this.w = e.getW(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}, C5 = class extends Cl {
  constructor(r = 1, e = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = r, this.height = e, this.depth = 1, this.scissor = new Fi(0, 0, r, e), this.scissorTest = !1, this.viewport = new Fi(0, 0, r, e);
    const n = { width: r, height: e, depth: 1 };
    i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: ds,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, i);
    const s = new wn(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    s.flipY = !1, s.generateMipmaps = i.generateMipmaps, s.internalFormat = i.internalFormat, this.textures = [];
    const a = i.count;
    for (let o = 0; o < a; o++)
      this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = !0;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(r) {
    this.textures[0] = r;
  }
  setSize(r, e, i = 1) {
    if (this.width !== r || this.height !== e || this.depth !== i) {
      this.width = r, this.height = e, this.depth = i;
      for (let n = 0, s = this.textures.length; n < s; n++)
        this.textures[n].image.width = r, this.textures[n].image.height = e, this.textures[n].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, r, e), this.scissor.set(0, 0, r, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    this.width = r.width, this.height = r.height, this.depth = r.depth, this.scissor.copy(r.scissor), this.scissorTest = r.scissorTest, this.viewport.copy(r.viewport), this.textures.length = 0;
    for (let i = 0, n = r.textures.length; i < n; i++)
      this.textures[i] = r.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
    const e = Object.assign({}, r.texture.image);
    return this.texture.source = new nR(e), this.depthBuffer = r.depthBuffer, this.stencilBuffer = r.stencilBuffer, this.resolveDepthBuffer = r.resolveDepthBuffer, this.resolveStencilBuffer = r.resolveStencilBuffer, r.depthTexture !== null && (this.depthTexture = r.depthTexture.clone()), this.samples = r.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}, go = class extends C5 {
  constructor(r = 1, e = 1, i = {}) {
    super(r, e, i), this.isWebGLRenderTarget = !0;
  }
}, aR = class extends wn {
  constructor(r = null, e = 1, i = 1, n = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: r, width: e, height: i, depth: n }, this.magFilter = Kn, this.minFilter = Kn, this.wrapR = rl, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(r) {
    this.layerUpdates.add(r);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
};
class R5 extends wn {
  constructor(e = null, i = 1, n = 1, s = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: i, height: n, depth: s }, this.magFilter = Kn, this.minFilter = Kn, this.wrapR = rl, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
let bs = class {
  constructor(r = 0, e = 0, i = 0, n = 1) {
    this.isQuaternion = !0, this._x = r, this._y = e, this._z = i, this._w = n;
  }
  static slerpFlat(r, e, i, n, s, a, o) {
    let l = i[n + 0], u = i[n + 1], c = i[n + 2], h = i[n + 3];
    const d = s[a + 0], p = s[a + 1], f = s[a + 2], m = s[a + 3];
    if (o === 0) {
      r[e + 0] = l, r[e + 1] = u, r[e + 2] = c, r[e + 3] = h;
      return;
    }
    if (o === 1) {
      r[e + 0] = d, r[e + 1] = p, r[e + 2] = f, r[e + 3] = m;
      return;
    }
    if (h !== m || l !== d || u !== p || c !== f) {
      let y = 1 - o;
      const v = l * d + u * p + c * f + h * m, g = v >= 0 ? 1 : -1, _ = 1 - v * v;
      if (_ > Number.EPSILON) {
        const b = Math.sqrt(_), T = Math.atan2(b, v * g);
        y = Math.sin(y * T) / b, o = Math.sin(o * T) / b;
      }
      const x = o * g;
      if (l = l * y + d * x, u = u * y + p * x, c = c * y + f * x, h = h * y + m * x, y === 1 - o) {
        const b = 1 / Math.sqrt(l * l + u * u + c * c + h * h);
        l *= b, u *= b, c *= b, h *= b;
      }
    }
    r[e] = l, r[e + 1] = u, r[e + 2] = c, r[e + 3] = h;
  }
  static multiplyQuaternionsFlat(r, e, i, n, s, a) {
    const o = i[n], l = i[n + 1], u = i[n + 2], c = i[n + 3], h = s[a], d = s[a + 1], p = s[a + 2], f = s[a + 3];
    return r[e] = o * f + c * h + l * p - u * d, r[e + 1] = l * f + c * d + u * h - o * p, r[e + 2] = u * f + c * p + o * d - l * h, r[e + 3] = c * f - o * h - l * d - u * p, r;
  }
  get x() {
    return this._x;
  }
  set x(r) {
    this._x = r, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(r) {
    this._y = r, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(r) {
    this._z = r, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(r) {
    this._w = r, this._onChangeCallback();
  }
  set(r, e, i, n) {
    return this._x = r, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(r) {
    return this._x = r.x, this._y = r.y, this._z = r.z, this._w = r.w, this._onChangeCallback(), this;
  }
  setFromEuler(r, e = !0) {
    const i = r._x, n = r._y, s = r._z, a = r._order, o = Math.cos, l = Math.sin, u = o(i / 2), c = o(n / 2), h = o(s / 2), d = l(i / 2), p = l(n / 2), f = l(s / 2);
    switch (a) {
      case "XYZ":
        this._x = d * c * h + u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "YXZ":
        this._x = d * c * h + u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h + d * p * f;
        break;
      case "ZXY":
        this._x = d * c * h - u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "ZYX":
        this._x = d * c * h - u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h + d * p * f;
        break;
      case "YZX":
        this._x = d * c * h + u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "XZY":
        this._x = d * c * h - u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h + d * p * f;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(r, e) {
    const i = e / 2, n = Math.sin(i);
    return this._x = r.x * n, this._y = r.y * n, this._z = r.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(r) {
    const e = r.elements, i = e[0], n = e[4], s = e[8], a = e[1], o = e[5], l = e[9], u = e[2], c = e[6], h = e[10], d = i + o + h;
    if (d > 0) {
      const p = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / p, this._x = (c - l) * p, this._y = (s - u) * p, this._z = (a - n) * p;
    } else if (i > o && i > h) {
      const p = 2 * Math.sqrt(1 + i - o - h);
      this._w = (c - l) / p, this._x = 0.25 * p, this._y = (n + a) / p, this._z = (s + u) / p;
    } else if (o > h) {
      const p = 2 * Math.sqrt(1 + o - i - h);
      this._w = (s - u) / p, this._x = (n + a) / p, this._y = 0.25 * p, this._z = (l + c) / p;
    } else {
      const p = 2 * Math.sqrt(1 + h - i - o);
      this._w = (a - n) / p, this._x = (s + u) / p, this._y = (l + c) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(r, e) {
    let i = r.dot(e) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(r.x) > Math.abs(r.z) ? (this._x = -r.y, this._y = r.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -r.z, this._z = r.y, this._w = i)) : (this._x = r.y * e.z - r.z * e.y, this._y = r.z * e.x - r.x * e.z, this._z = r.x * e.y - r.y * e.x, this._w = i), this.normalize();
  }
  angleTo(r) {
    return 2 * Math.acos(Math.abs(Yi(this.dot(r), -1, 1)));
  }
  rotateTowards(r, e) {
    const i = this.angleTo(r);
    if (i === 0) return this;
    const n = Math.min(1, e / i);
    return this.slerp(r, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(r) {
    return this._x * r._x + this._y * r._y + this._z * r._z + this._w * r._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let r = this.length();
    return r === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (r = 1 / r, this._x = this._x * r, this._y = this._y * r, this._z = this._z * r, this._w = this._w * r), this._onChangeCallback(), this;
  }
  multiply(r) {
    return this.multiplyQuaternions(this, r);
  }
  premultiply(r) {
    return this.multiplyQuaternions(r, this);
  }
  multiplyQuaternions(r, e) {
    const i = r._x, n = r._y, s = r._z, a = r._w, o = e._x, l = e._y, u = e._z, c = e._w;
    return this._x = i * c + a * o + n * u - s * l, this._y = n * c + a * l + s * o - i * u, this._z = s * c + a * u + i * l - n * o, this._w = a * c - i * o - n * l - s * u, this._onChangeCallback(), this;
  }
  slerp(r, e) {
    if (e === 0) return this;
    if (e === 1) return this.copy(r);
    const i = this._x, n = this._y, s = this._z, a = this._w;
    let o = a * r._w + i * r._x + n * r._y + s * r._z;
    if (o < 0 ? (this._w = -r._w, this._x = -r._x, this._y = -r._y, this._z = -r._z, o = -o) : this.copy(r), o >= 1)
      return this._w = a, this._x = i, this._y = n, this._z = s, this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const p = 1 - e;
      return this._w = p * a + e * this._w, this._x = p * i + e * this._x, this._y = p * n + e * this._y, this._z = p * s + e * this._z, this.normalize(), this;
    }
    const u = Math.sqrt(l), c = Math.atan2(u, o), h = Math.sin((1 - e) * c) / u, d = Math.sin(e * c) / u;
    return this._w = a * h + this._w * d, this._x = i * h + this._x * d, this._y = n * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(r, e, i) {
    return this.copy(r).slerp(e, i);
  }
  random() {
    const r = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), s = Math.sqrt(i);
    return this.set(
      n * Math.sin(r),
      n * Math.cos(r),
      s * Math.sin(e),
      s * Math.cos(e)
    );
  }
  equals(r) {
    return r._x === this._x && r._y === this._y && r._z === this._z && r._w === this._w;
  }
  fromArray(r, e = 0) {
    return this._x = r[e], this._y = r[e + 1], this._z = r[e + 2], this._w = r[e + 3], this._onChangeCallback(), this;
  }
  toArray(r = [], e = 0) {
    return r[e] = this._x, r[e + 1] = this._y, r[e + 2] = this._z, r[e + 3] = this._w, r;
  }
  fromBufferAttribute(r, e) {
    return this._x = r.getX(e), this._y = r.getY(e), this._z = r.getZ(e), this._w = r.getW(e), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(r) {
    return this._onChangeCallback = r, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}, X = class oR {
  constructor(e = 0, i = 0, n = 0) {
    oR.prototype.isVector3 = !0, this.x = e, this.y = i, this.z = n;
  }
  set(e, i, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = i, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, i) {
    return this.x = e.x * i.x, this.y = e.y * i.y, this.z = e.z * i.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(BS.setFromEuler(e));
  }
  applyAxisAngle(e, i) {
    return this.applyQuaternion(BS.setFromAxisAngle(e, i));
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[3] * n + a[6] * s, this.y = a[1] * i + a[4] * n + a[7] * s, this.z = a[2] * i + a[5] * n + a[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements, o = 1 / (a[3] * i + a[7] * n + a[11] * s + a[15]);
    return this.x = (a[0] * i + a[4] * n + a[8] * s + a[12]) * o, this.y = (a[1] * i + a[5] * n + a[9] * s + a[13]) * o, this.z = (a[2] * i + a[6] * n + a[10] * s + a[14]) * o, this;
  }
  applyQuaternion(e) {
    const i = this.x, n = this.y, s = this.z, a = e.x, o = e.y, l = e.z, u = e.w, c = 2 * (o * s - l * n), h = 2 * (l * i - a * s), d = 2 * (a * n - o * i);
    return this.x = i + u * c + o * d - l * h, this.y = n + u * h + l * c - a * d, this.z = s + u * d + a * h - o * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[4] * n + a[8] * s, this.y = a[1] * i + a[5] * n + a[9] * s, this.z = a[2] * i + a[6] * n + a[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, i) {
    const n = e.x, s = e.y, a = e.z, o = i.x, l = i.y, u = i.z;
    return this.x = s * u - a * l, this.y = a * o - n * u, this.z = n * l - s * o, this;
  }
  projectOnVector(e) {
    const i = e.lengthSq();
    if (i === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / i;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return Ey.copy(this).projectOnVector(e), this.sub(Ey);
  }
  reflect(e) {
    return this.sub(Ey.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(Yi(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
    return i * i + n * n + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, i, n) {
    const s = Math.sin(i) * e;
    return this.x = s * Math.sin(n), this.y = Math.cos(i) * e, this.z = s * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, i, n) {
    return this.x = e * Math.sin(i), this.y = n, this.z = e * Math.cos(i), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this;
  }
  setFromMatrixScale(e) {
    const i = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = i, this.y = n, this.z = s, this;
  }
  setFromMatrixColumn(e, i) {
    return this.fromArray(e.elements, i * 4);
  }
  setFromMatrix3Column(e, i) {
    return this.fromArray(e.elements, i * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, i = Math.random() * 2 - 1, n = Math.sqrt(1 - i * i);
    return this.x = n * Math.cos(e), this.y = i, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
};
const Ey = /* @__PURE__ */ new X(), BS = /* @__PURE__ */ new bs();
let Rl = class {
  constructor(r = new X(1 / 0, 1 / 0, 1 / 0), e = new X(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = r, this.max = e;
  }
  set(r, e) {
    return this.min.copy(r), this.max.copy(e), this;
  }
  setFromArray(r) {
    this.makeEmpty();
    for (let e = 0, i = r.length; e < i; e += 3)
      this.expandByPoint(Rn.fromArray(r, e));
    return this;
  }
  setFromBufferAttribute(r) {
    this.makeEmpty();
    for (let e = 0, i = r.count; e < i; e++)
      this.expandByPoint(Rn.fromBufferAttribute(r, e));
    return this;
  }
  setFromPoints(r) {
    this.makeEmpty();
    for (let e = 0, i = r.length; e < i; e++)
      this.expandByPoint(r[e]);
    return this;
  }
  setFromCenterAndSize(r, e) {
    const i = Rn.copy(e).multiplyScalar(0.5);
    return this.min.copy(r).sub(i), this.max.copy(r).add(i), this;
  }
  setFromObject(r, e = !1) {
    return this.makeEmpty(), this.expandByObject(r, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    return this.min.copy(r.min), this.max.copy(r.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(r) {
    return this.isEmpty() ? r.set(0, 0, 0) : r.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(r) {
    return this.isEmpty() ? r.set(0, 0, 0) : r.subVectors(this.max, this.min);
  }
  expandByPoint(r) {
    return this.min.min(r), this.max.max(r), this;
  }
  expandByVector(r) {
    return this.min.sub(r), this.max.add(r), this;
  }
  expandByScalar(r) {
    return this.min.addScalar(-r), this.max.addScalar(r), this;
  }
  expandByObject(r, e = !1) {
    r.updateWorldMatrix(!1, !1);
    const i = r.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (e === !0 && s !== void 0 && r.isInstancedMesh !== !0)
        for (let a = 0, o = s.count; a < o; a++)
          r.isMesh === !0 ? r.getVertexPosition(a, Rn) : Rn.fromBufferAttribute(s, a), Rn.applyMatrix4(r.matrixWorld), this.expandByPoint(Rn);
      else
        r.boundingBox !== void 0 ? (r.boundingBox === null && r.computeBoundingBox(), pp.copy(r.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), pp.copy(i.boundingBox)), pp.applyMatrix4(r.matrixWorld), this.union(pp);
    }
    const n = r.children;
    for (let s = 0, a = n.length; s < a; s++)
      this.expandByObject(n[s], e);
    return this;
  }
  containsPoint(r) {
    return r.x >= this.min.x && r.x <= this.max.x && r.y >= this.min.y && r.y <= this.max.y && r.z >= this.min.z && r.z <= this.max.z;
  }
  containsBox(r) {
    return this.min.x <= r.min.x && r.max.x <= this.max.x && this.min.y <= r.min.y && r.max.y <= this.max.y && this.min.z <= r.min.z && r.max.z <= this.max.z;
  }
  getParameter(r, e) {
    return e.set(
      (r.x - this.min.x) / (this.max.x - this.min.x),
      (r.y - this.min.y) / (this.max.y - this.min.y),
      (r.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(r) {
    return r.max.x >= this.min.x && r.min.x <= this.max.x && r.max.y >= this.min.y && r.min.y <= this.max.y && r.max.z >= this.min.z && r.min.z <= this.max.z;
  }
  intersectsSphere(r) {
    return this.clampPoint(r.center, Rn), Rn.distanceToSquared(r.center) <= r.radius * r.radius;
  }
  intersectsPlane(r) {
    let e, i;
    return r.normal.x > 0 ? (e = r.normal.x * this.min.x, i = r.normal.x * this.max.x) : (e = r.normal.x * this.max.x, i = r.normal.x * this.min.x), r.normal.y > 0 ? (e += r.normal.y * this.min.y, i += r.normal.y * this.max.y) : (e += r.normal.y * this.max.y, i += r.normal.y * this.min.y), r.normal.z > 0 ? (e += r.normal.z * this.min.z, i += r.normal.z * this.max.z) : (e += r.normal.z * this.max.z, i += r.normal.z * this.min.z), e <= -r.constant && i >= -r.constant;
  }
  intersectsTriangle(r) {
    if (this.isEmpty())
      return !1;
    this.getCenter(ih), fp.subVectors(this.max, ih), Vl.subVectors(r.a, ih), Gl.subVectors(r.b, ih), Hl.subVectors(r.c, ih), Na.subVectors(Gl, Vl), Pa.subVectors(Hl, Gl), Ro.subVectors(Vl, Hl);
    let e = [
      0,
      -Na.z,
      Na.y,
      0,
      -Pa.z,
      Pa.y,
      0,
      -Ro.z,
      Ro.y,
      Na.z,
      0,
      -Na.x,
      Pa.z,
      0,
      -Pa.x,
      Ro.z,
      0,
      -Ro.x,
      -Na.y,
      Na.x,
      0,
      -Pa.y,
      Pa.x,
      0,
      -Ro.y,
      Ro.x,
      0
    ];
    return !My(e, Vl, Gl, Hl, fp) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !My(e, Vl, Gl, Hl, fp)) ? !1 : (mp.crossVectors(Na, Pa), e = [mp.x, mp.y, mp.z], My(e, Vl, Gl, Hl, fp));
  }
  clampPoint(r, e) {
    return e.copy(r).clamp(this.min, this.max);
  }
  distanceToPoint(r) {
    return this.clampPoint(r, Rn).distanceTo(r);
  }
  getBoundingSphere(r) {
    return this.isEmpty() ? r.makeEmpty() : (this.getCenter(r.center), r.radius = this.getSize(Rn).length() * 0.5), r;
  }
  intersect(r) {
    return this.min.max(r.min), this.max.min(r.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(r) {
    return this.min.min(r.min), this.max.max(r.max), this;
  }
  applyMatrix4(r) {
    return this.isEmpty() ? this : (As[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(r), As[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(r), As[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(r), As[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(r), As[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(r), As[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(r), As[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(r), As[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(r), this.setFromPoints(As), this);
  }
  translate(r) {
    return this.min.add(r), this.max.add(r), this;
  }
  equals(r) {
    return r.min.equals(this.min) && r.max.equals(this.max);
  }
};
const As = [
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X()
], Rn = /* @__PURE__ */ new X(), pp = /* @__PURE__ */ new Rl(), Vl = /* @__PURE__ */ new X(), Gl = /* @__PURE__ */ new X(), Hl = /* @__PURE__ */ new X(), Na = /* @__PURE__ */ new X(), Pa = /* @__PURE__ */ new X(), Ro = /* @__PURE__ */ new X(), ih = /* @__PURE__ */ new X(), fp = /* @__PURE__ */ new X(), mp = /* @__PURE__ */ new X(), No = /* @__PURE__ */ new X();
function My(r, e, i, n, s) {
  for (let a = 0, o = r.length - 3; a <= o; a += 3) {
    No.fromArray(r, a);
    const l = s.x * Math.abs(No.x) + s.y * Math.abs(No.y) + s.z * Math.abs(No.z), u = e.dot(No), c = i.dot(No), h = n.dot(No);
    if (Math.max(-Math.max(u, c, h), Math.min(u, c, h)) > l)
      return !1;
  }
  return !0;
}
const N5 = /* @__PURE__ */ new Rl(), rh = /* @__PURE__ */ new X(), Ay = /* @__PURE__ */ new X();
let Tg = class {
  constructor(r = new X(), e = -1) {
    this.isSphere = !0, this.center = r, this.radius = e;
  }
  set(r, e) {
    return this.center.copy(r), this.radius = e, this;
  }
  setFromPoints(r, e) {
    const i = this.center;
    e !== void 0 ? i.copy(e) : N5.setFromPoints(r).getCenter(i);
    let n = 0;
    for (let s = 0, a = r.length; s < a; s++)
      n = Math.max(n, i.distanceToSquared(r[s]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(r) {
    return this.center.copy(r.center), this.radius = r.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(r) {
    return r.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(r) {
    return r.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(r) {
    const e = this.radius + r.radius;
    return r.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(r) {
    return r.intersectsSphere(this);
  }
  intersectsPlane(r) {
    return Math.abs(r.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(r, e) {
    const i = this.center.distanceToSquared(r);
    return e.copy(r), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  }
  getBoundingBox(r) {
    return this.isEmpty() ? (r.makeEmpty(), r) : (r.set(this.center, this.center), r.expandByScalar(this.radius), r);
  }
  applyMatrix4(r) {
    return this.center.applyMatrix4(r), this.radius = this.radius * r.getMaxScaleOnAxis(), this;
  }
  translate(r) {
    return this.center.add(r), this;
  }
  expandByPoint(r) {
    if (this.isEmpty())
      return this.center.copy(r), this.radius = 0, this;
    rh.subVectors(r, this.center);
    const e = rh.lengthSq();
    if (e > this.radius * this.radius) {
      const i = Math.sqrt(e), n = (i - this.radius) * 0.5;
      this.center.addScaledVector(rh, n / i), this.radius += n;
    }
    return this;
  }
  union(r) {
    return r.isEmpty() ? this : this.isEmpty() ? (this.copy(r), this) : (this.center.equals(r.center) === !0 ? this.radius = Math.max(this.radius, r.radius) : (Ay.subVectors(r.center, this.center).setLength(r.radius), this.expandByPoint(rh.copy(r.center).add(Ay)), this.expandByPoint(rh.copy(r.center).sub(Ay))), this);
  }
  equals(r) {
    return r.center.equals(this.center) && r.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const Cs = /* @__PURE__ */ new X(), Cy = /* @__PURE__ */ new X(), gp = /* @__PURE__ */ new X(), Ia = /* @__PURE__ */ new X(), Ry = /* @__PURE__ */ new X(), yp = /* @__PURE__ */ new X(), Ny = /* @__PURE__ */ new X();
let Sg = class {
  constructor(r = new X(), e = new X(0, 0, -1)) {
    this.origin = r, this.direction = e;
  }
  set(r, e) {
    return this.origin.copy(r), this.direction.copy(e), this;
  }
  copy(r) {
    return this.origin.copy(r.origin), this.direction.copy(r.direction), this;
  }
  at(r, e) {
    return e.copy(this.origin).addScaledVector(this.direction, r);
  }
  lookAt(r) {
    return this.direction.copy(r).sub(this.origin).normalize(), this;
  }
  recast(r) {
    return this.origin.copy(this.at(r, Cs)), this;
  }
  closestPointToPoint(r, e) {
    e.subVectors(r, this.origin);
    const i = e.dot(this.direction);
    return i < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(r) {
    return Math.sqrt(this.distanceSqToPoint(r));
  }
  distanceSqToPoint(r) {
    const e = Cs.subVectors(r, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(r) : (Cs.copy(this.origin).addScaledVector(this.direction, e), Cs.distanceToSquared(r));
  }
  distanceSqToSegment(r, e, i, n) {
    Cy.copy(r).add(e).multiplyScalar(0.5), gp.copy(e).sub(r).normalize(), Ia.copy(this.origin).sub(Cy);
    const s = r.distanceTo(e) * 0.5, a = -this.direction.dot(gp), o = Ia.dot(this.direction), l = -Ia.dot(gp), u = Ia.lengthSq(), c = Math.abs(1 - a * a);
    let h, d, p, f;
    if (c > 0)
      if (h = a * l - o, d = a * o - l, f = s * c, h >= 0)
        if (d >= -f)
          if (d <= f) {
            const m = 1 / c;
            h *= m, d *= m, p = h * (h + a * d + 2 * o) + d * (a * h + d + 2 * l) + u;
          } else
            d = s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
        else
          d = -s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
      else
        d <= -f ? (h = Math.max(0, -(-a * s + o)), d = h > 0 ? -s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + u) : d <= f ? (h = 0, d = Math.min(Math.max(-s, -l), s), p = d * (d + 2 * l) + u) : (h = Math.max(0, -(a * s + o)), d = h > 0 ? s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + u);
    else
      d = a > 0 ? -s : s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
    return i && i.copy(this.origin).addScaledVector(this.direction, h), n && n.copy(Cy).addScaledVector(gp, d), p;
  }
  intersectSphere(r, e) {
    Cs.subVectors(r.center, this.origin);
    const i = Cs.dot(this.direction), n = Cs.dot(Cs) - i * i, s = r.radius * r.radius;
    if (n > s) return null;
    const a = Math.sqrt(s - n), o = i - a, l = i + a;
    return l < 0 ? null : o < 0 ? this.at(l, e) : this.at(o, e);
  }
  intersectsSphere(r) {
    return this.distanceSqToPoint(r.center) <= r.radius * r.radius;
  }
  distanceToPlane(r) {
    const e = r.normal.dot(this.direction);
    if (e === 0)
      return r.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(r.normal) + r.constant) / e;
    return i >= 0 ? i : null;
  }
  intersectPlane(r, e) {
    const i = this.distanceToPlane(r);
    return i === null ? null : this.at(i, e);
  }
  intersectsPlane(r) {
    const e = r.distanceToPoint(this.origin);
    return e === 0 || r.normal.dot(this.direction) * e < 0;
  }
  intersectBox(r, e) {
    let i, n, s, a, o, l;
    const u = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin;
    return u >= 0 ? (i = (r.min.x - d.x) * u, n = (r.max.x - d.x) * u) : (i = (r.max.x - d.x) * u, n = (r.min.x - d.x) * u), c >= 0 ? (s = (r.min.y - d.y) * c, a = (r.max.y - d.y) * c) : (s = (r.max.y - d.y) * c, a = (r.min.y - d.y) * c), i > a || s > n || ((s > i || isNaN(i)) && (i = s), (a < n || isNaN(n)) && (n = a), h >= 0 ? (o = (r.min.z - d.z) * h, l = (r.max.z - d.z) * h) : (o = (r.max.z - d.z) * h, l = (r.min.z - d.z) * h), i > l || o > n) || ((o > i || i !== i) && (i = o), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(i >= 0 ? i : n, e);
  }
  intersectsBox(r) {
    return this.intersectBox(r, Cs) !== null;
  }
  intersectTriangle(r, e, i, n, s) {
    Ry.subVectors(e, r), yp.subVectors(i, r), Ny.crossVectors(Ry, yp);
    let a = this.direction.dot(Ny), o;
    if (a > 0) {
      if (n) return null;
      o = 1;
    } else if (a < 0)
      o = -1, a = -a;
    else
      return null;
    Ia.subVectors(this.origin, r);
    const l = o * this.direction.dot(yp.crossVectors(Ia, yp));
    if (l < 0)
      return null;
    const u = o * this.direction.dot(Ry.cross(Ia));
    if (u < 0 || l + u > a)
      return null;
    const c = -o * Ia.dot(Ny);
    return c < 0 ? null : this.at(c / a, s);
  }
  applyMatrix4(r) {
    return this.origin.applyMatrix4(r), this.direction.transformDirection(r), this;
  }
  equals(r) {
    return r.origin.equals(this.origin) && r.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}, ui = class Fb {
  constructor(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v) {
    Fb.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v);
  }
  set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v) {
    const g = this.elements;
    return g[0] = e, g[4] = i, g[8] = n, g[12] = s, g[1] = a, g[5] = o, g[9] = l, g[13] = u, g[2] = c, g[6] = h, g[10] = d, g[14] = p, g[3] = f, g[7] = m, g[11] = y, g[15] = v, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Fb().fromArray(this.elements);
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], i[9] = n[9], i[10] = n[10], i[11] = n[11], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15], this;
  }
  copyPosition(e) {
    const i = this.elements, n = e.elements;
    return i[12] = n[12], i[13] = n[13], i[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[3],
      i[6],
      0,
      i[1],
      i[4],
      i[7],
      0,
      i[2],
      i[5],
      i[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrixColumn(this, 0), i.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, i, n) {
    return this.set(
      e.x,
      i.x,
      n.x,
      0,
      e.y,
      i.y,
      n.y,
      0,
      e.z,
      i.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const i = this.elements, n = e.elements, s = 1 / Wl.setFromMatrixColumn(e, 0).length(), a = 1 / Wl.setFromMatrixColumn(e, 1).length(), o = 1 / Wl.setFromMatrixColumn(e, 2).length();
    return i[0] = n[0] * s, i[1] = n[1] * s, i[2] = n[2] * s, i[3] = 0, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[7] = 0, i[8] = n[8] * o, i[9] = n[9] * o, i[10] = n[10] * o, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z, o = Math.cos(n), l = Math.sin(n), u = Math.cos(s), c = Math.sin(s), h = Math.cos(a), d = Math.sin(a);
    if (e.order === "XYZ") {
      const p = o * h, f = o * d, m = l * h, y = l * d;
      i[0] = u * h, i[4] = -u * d, i[8] = c, i[1] = f + m * c, i[5] = p - y * c, i[9] = -l * u, i[2] = y - p * c, i[6] = m + f * c, i[10] = o * u;
    } else if (e.order === "YXZ") {
      const p = u * h, f = u * d, m = c * h, y = c * d;
      i[0] = p + y * l, i[4] = m * l - f, i[8] = o * c, i[1] = o * d, i[5] = o * h, i[9] = -l, i[2] = f * l - m, i[6] = y + p * l, i[10] = o * u;
    } else if (e.order === "ZXY") {
      const p = u * h, f = u * d, m = c * h, y = c * d;
      i[0] = p - y * l, i[4] = -o * d, i[8] = m + f * l, i[1] = f + m * l, i[5] = o * h, i[9] = y - p * l, i[2] = -o * c, i[6] = l, i[10] = o * u;
    } else if (e.order === "ZYX") {
      const p = o * h, f = o * d, m = l * h, y = l * d;
      i[0] = u * h, i[4] = m * c - f, i[8] = p * c + y, i[1] = u * d, i[5] = y * c + p, i[9] = f * c - m, i[2] = -c, i[6] = l * u, i[10] = o * u;
    } else if (e.order === "YZX") {
      const p = o * u, f = o * c, m = l * u, y = l * c;
      i[0] = u * h, i[4] = y - p * d, i[8] = m * d + f, i[1] = d, i[5] = o * h, i[9] = -l * h, i[2] = -c * h, i[6] = f * d + m, i[10] = p - y * d;
    } else if (e.order === "XZY") {
      const p = o * u, f = o * c, m = l * u, y = l * c;
      i[0] = u * h, i[4] = -d, i[8] = c * h, i[1] = p * d + y, i[5] = o * h, i[9] = f * d - m, i[2] = m * d - f, i[6] = l * h, i[10] = y * d + p;
    }
    return i[3] = 0, i[7] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(P5, e, I5);
  }
  lookAt(e, i, n) {
    const s = this.elements;
    return Yr.subVectors(e, i), Yr.lengthSq() === 0 && (Yr.z = 1), Yr.normalize(), Oa.crossVectors(n, Yr), Oa.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Yr.x += 1e-4 : Yr.z += 1e-4, Yr.normalize(), Oa.crossVectors(n, Yr)), Oa.normalize(), vp.crossVectors(Yr, Oa), s[0] = Oa.x, s[4] = vp.x, s[8] = Yr.x, s[1] = Oa.y, s[5] = vp.y, s[9] = Yr.y, s[2] = Oa.z, s[6] = vp.z, s[10] = Yr.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[4], u = n[8], c = n[12], h = n[1], d = n[5], p = n[9], f = n[13], m = n[2], y = n[6], v = n[10], g = n[14], _ = n[3], x = n[7], b = n[11], T = n[15], S = s[0], w = s[4], M = s[8], E = s[12], A = s[1], N = s[5], U = s[9], k = s[13], C = s[2], I = s[6], O = s[10], W = s[14], V = s[3], Q = s[7], F = s[11], B = s[15];
    return a[0] = o * S + l * A + u * C + c * V, a[4] = o * w + l * N + u * I + c * Q, a[8] = o * M + l * U + u * O + c * F, a[12] = o * E + l * k + u * W + c * B, a[1] = h * S + d * A + p * C + f * V, a[5] = h * w + d * N + p * I + f * Q, a[9] = h * M + d * U + p * O + f * F, a[13] = h * E + d * k + p * W + f * B, a[2] = m * S + y * A + v * C + g * V, a[6] = m * w + y * N + v * I + g * Q, a[10] = m * M + y * U + v * O + g * F, a[14] = m * E + y * k + v * W + g * B, a[3] = _ * S + x * A + b * C + T * V, a[7] = _ * w + x * N + b * I + T * Q, a[11] = _ * M + x * U + b * O + T * F, a[15] = _ * E + x * k + b * W + T * B, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[4] *= e, i[8] *= e, i[12] *= e, i[1] *= e, i[5] *= e, i[9] *= e, i[13] *= e, i[2] *= e, i[6] *= e, i[10] *= e, i[14] *= e, i[3] *= e, i[7] *= e, i[11] *= e, i[15] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[4], s = e[8], a = e[12], o = e[1], l = e[5], u = e[9], c = e[13], h = e[2], d = e[6], p = e[10], f = e[14], m = e[3], y = e[7], v = e[11], g = e[15];
    return m * (+a * u * d - s * c * d - a * l * p + n * c * p + s * l * f - n * u * f) + y * (+i * u * f - i * c * p + a * o * p - s * o * f + s * c * h - a * u * h) + v * (+i * c * d - i * l * f - a * o * d + n * o * f + a * l * h - n * c * h) + g * (-s * l * h - i * u * d + i * l * p + s * o * d - n * o * p + n * u * h);
  }
  transpose() {
    const e = this.elements;
    let i;
    return i = e[1], e[1] = e[4], e[4] = i, i = e[2], e[2] = e[8], e[8] = i, i = e[6], e[6] = e[9], e[9] = i, i = e[3], e[3] = e[12], e[12] = i, i = e[7], e[7] = e[13], e[13] = i, i = e[11], e[11] = e[14], e[14] = i, this;
  }
  setPosition(e, i, n) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = i, s[14] = n), this;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = e[9], p = e[10], f = e[11], m = e[12], y = e[13], v = e[14], g = e[15], _ = d * v * c - y * p * c + y * u * f - l * v * f - d * u * g + l * p * g, x = m * p * c - h * v * c - m * u * f + o * v * f + h * u * g - o * p * g, b = h * y * c - m * d * c + m * l * f - o * y * f - h * l * g + o * d * g, T = m * d * u - h * y * u - m * l * p + o * y * p + h * l * v - o * d * v, S = i * _ + n * x + s * b + a * T;
    if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / S;
    return e[0] = _ * w, e[1] = (y * p * a - d * v * a - y * s * f + n * v * f + d * s * g - n * p * g) * w, e[2] = (l * v * a - y * u * a + y * s * c - n * v * c - l * s * g + n * u * g) * w, e[3] = (d * u * a - l * p * a - d * s * c + n * p * c + l * s * f - n * u * f) * w, e[4] = x * w, e[5] = (h * v * a - m * p * a + m * s * f - i * v * f - h * s * g + i * p * g) * w, e[6] = (m * u * a - o * v * a - m * s * c + i * v * c + o * s * g - i * u * g) * w, e[7] = (o * p * a - h * u * a + h * s * c - i * p * c - o * s * f + i * u * f) * w, e[8] = b * w, e[9] = (m * d * a - h * y * a - m * n * f + i * y * f + h * n * g - i * d * g) * w, e[10] = (o * y * a - m * l * a + m * n * c - i * y * c - o * n * g + i * l * g) * w, e[11] = (h * l * a - o * d * a - h * n * c + i * d * c + o * n * f - i * l * f) * w, e[12] = T * w, e[13] = (h * y * s - m * d * s + m * n * p - i * y * p - h * n * v + i * d * v) * w, e[14] = (m * l * s - o * y * s - m * n * u + i * y * u + o * n * v - i * l * v) * w, e[15] = (o * d * s - h * l * s + h * n * u - i * d * u - o * n * p + i * l * p) * w, this;
  }
  scale(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z;
    return i[0] *= n, i[4] *= s, i[8] *= a, i[1] *= n, i[5] *= s, i[9] *= a, i[2] *= n, i[6] *= s, i[10] *= a, i[3] *= n, i[7] *= s, i[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(i, n, s));
  }
  makeTranslation(e, i, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      i,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = 1 - n, o = e.x, l = e.y, u = e.z, c = a * o, h = a * l;
    return this.set(
      c * o + n,
      c * l - s * u,
      c * u + s * l,
      0,
      c * l + s * u,
      h * l + n,
      h * u - s * o,
      0,
      c * u - s * l,
      h * u + s * o,
      a * u * u + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, i, n, s, a, o) {
    return this.set(
      1,
      n,
      a,
      0,
      e,
      1,
      o,
      0,
      i,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, i, n) {
    const s = this.elements, a = i._x, o = i._y, l = i._z, u = i._w, c = a + a, h = o + o, d = l + l, p = a * c, f = a * h, m = a * d, y = o * h, v = o * d, g = l * d, _ = u * c, x = u * h, b = u * d, T = n.x, S = n.y, w = n.z;
    return s[0] = (1 - (y + g)) * T, s[1] = (f + b) * T, s[2] = (m - x) * T, s[3] = 0, s[4] = (f - b) * S, s[5] = (1 - (p + g)) * S, s[6] = (v + _) * S, s[7] = 0, s[8] = (m + x) * w, s[9] = (v - _) * w, s[10] = (1 - (p + y)) * w, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, i, n) {
    const s = this.elements;
    let a = Wl.set(s[0], s[1], s[2]).length();
    const o = Wl.set(s[4], s[5], s[6]).length(), l = Wl.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (a = -a), e.x = s[12], e.y = s[13], e.z = s[14], Nn.copy(this);
    const u = 1 / a, c = 1 / o, h = 1 / l;
    return Nn.elements[0] *= u, Nn.elements[1] *= u, Nn.elements[2] *= u, Nn.elements[4] *= c, Nn.elements[5] *= c, Nn.elements[6] *= c, Nn.elements[8] *= h, Nn.elements[9] *= h, Nn.elements[10] *= h, i.setFromRotationMatrix(Nn), n.x = a, n.y = o, n.z = l, this;
  }
  makePerspective(e, i, n, s, a, o, l = na) {
    const u = this.elements, c = 2 * a / (i - e), h = 2 * a / (n - s), d = (i + e) / (i - e), p = (n + s) / (n - s);
    let f, m;
    if (l === na)
      f = -(o + a) / (o - a), m = -2 * o * a / (o - a);
    else if (l === bm)
      f = -o / (o - a), m = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return u[0] = c, u[4] = 0, u[8] = d, u[12] = 0, u[1] = 0, u[5] = h, u[9] = p, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = f, u[14] = m, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this;
  }
  makeOrthographic(e, i, n, s, a, o, l = na) {
    const u = this.elements, c = 1 / (i - e), h = 1 / (n - s), d = 1 / (o - a), p = (i + e) * c, f = (n + s) * h;
    let m, y;
    if (l === na)
      m = (o + a) * d, y = -2 * d;
    else if (l === bm)
      m = a * d, y = -1 * d;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return u[0] = 2 * c, u[4] = 0, u[8] = 0, u[12] = -p, u[1] = 0, u[5] = 2 * h, u[9] = 0, u[13] = -f, u[2] = 0, u[6] = 0, u[10] = y, u[14] = -m, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this;
  }
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 16; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e[i + 9] = n[9], e[i + 10] = n[10], e[i + 11] = n[11], e[i + 12] = n[12], e[i + 13] = n[13], e[i + 14] = n[14], e[i + 15] = n[15], e;
  }
};
const Wl = /* @__PURE__ */ new X(), Nn = /* @__PURE__ */ new ui(), P5 = /* @__PURE__ */ new X(0, 0, 0), I5 = /* @__PURE__ */ new X(1, 1, 1), Oa = /* @__PURE__ */ new X(), vp = /* @__PURE__ */ new X(), Yr = /* @__PURE__ */ new X(), zS = /* @__PURE__ */ new ui(), jS = /* @__PURE__ */ new bs();
let yo = class lR {
  constructor(e = 0, i = 0, n = 0, s = lR.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = i, this._z = n, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, i, n, s = this._order) {
    return this._x = e, this._y = i, this._z = n, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, i = this._order, n = !0) {
    const s = e.elements, a = s[0], o = s[4], l = s[8], u = s[1], c = s[5], h = s[9], d = s[2], p = s[6], f = s[10];
    switch (i) {
      case "XYZ":
        this._y = Math.asin(Yi(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(p, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Yi(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(u, c)) : (this._y = Math.atan2(-d, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Yi(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(u, a));
        break;
      case "ZYX":
        this._y = Math.asin(-Yi(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(u, a)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin(Yi(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-d, a)) : (this._x = 0, this._y = Math.atan2(l, f));
        break;
      case "XZY":
        this._z = Math.asin(-Yi(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + i);
    }
    return this._order = i, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, i, n) {
    return zS.makeRotationFromQuaternion(e), this.setFromRotationMatrix(zS, i, n);
  }
  setFromVector3(e, i = this._order) {
    return this.set(e.x, e.y, e.z, i);
  }
  reorder(e) {
    return jS.setFromEuler(this), this.setFromQuaternion(jS, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
};
yo.DEFAULT_ORDER = "XYZ";
let L_ = class {
  constructor() {
    this.mask = 1;
  }
  set(r) {
    this.mask = (1 << r | 0) >>> 0;
  }
  enable(r) {
    this.mask |= 1 << r | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(r) {
    this.mask ^= 1 << r | 0;
  }
  disable(r) {
    this.mask &= ~(1 << r | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(r) {
    return (this.mask & r.mask) !== 0;
  }
  isEnabled(r) {
    return (this.mask & (1 << r | 0)) !== 0;
  }
}, O5 = 0;
const VS = /* @__PURE__ */ new X(), ql = /* @__PURE__ */ new bs(), Rs = /* @__PURE__ */ new ui(), bp = /* @__PURE__ */ new X(), nh = /* @__PURE__ */ new X(), D5 = /* @__PURE__ */ new X(), L5 = /* @__PURE__ */ new bs(), GS = /* @__PURE__ */ new X(1, 0, 0), HS = /* @__PURE__ */ new X(0, 1, 0), WS = /* @__PURE__ */ new X(0, 0, 1), qS = { type: "added" }, k5 = { type: "removed" }, Xl = { type: "childadded", child: null }, Py = { type: "childremoved", child: null };
let Vr = class Zf extends Cl {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: O5++ }), this.uuid = ua(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Zf.DEFAULT_UP.clone();
    const e = new X(), i = new yo(), n = new bs(), s = new X(1, 1, 1);
    function a() {
      n.setFromEuler(i, !1);
    }
    function o() {
      i.setFromQuaternion(n, void 0, !1);
    }
    i._onChange(a), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      modelViewMatrix: {
        value: new ui()
      },
      normalMatrix: {
        value: new It()
      }
    }), this.matrix = new ui(), this.matrixWorld = new ui(), this.matrixAutoUpdate = Zf.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Zf.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new L_(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, i) {
    this.quaternion.setFromAxisAngle(e, i);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, i) {
    return ql.setFromAxisAngle(e, i), this.quaternion.multiply(ql), this;
  }
  rotateOnWorldAxis(e, i) {
    return ql.setFromAxisAngle(e, i), this.quaternion.premultiply(ql), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(GS, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(HS, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(WS, e);
  }
  translateOnAxis(e, i) {
    return VS.copy(e).applyQuaternion(this.quaternion), this.position.add(VS.multiplyScalar(i)), this;
  }
  translateX(e) {
    return this.translateOnAxis(GS, e);
  }
  translateY(e) {
    return this.translateOnAxis(HS, e);
  }
  translateZ(e) {
    return this.translateOnAxis(WS, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Rs.copy(this.matrixWorld).invert());
  }
  lookAt(e, i, n) {
    e.isVector3 ? bp.copy(e) : bp.set(e, i, n);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), nh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Rs.lookAt(nh, bp, this.up) : Rs.lookAt(bp, nh, this.up), this.quaternion.setFromRotationMatrix(Rs), s && (Rs.extractRotation(s.matrixWorld), ql.setFromRotationMatrix(Rs), this.quaternion.premultiply(ql.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.add(arguments[i]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(qS), Xl.child = e, this.dispatchEvent(Xl), Xl.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const i = this.children.indexOf(e);
    return i !== -1 && (e.parent = null, this.children.splice(i, 1), e.dispatchEvent(k5), Py.child = e, this.dispatchEvent(Py), Py.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Rs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Rs.multiply(e.parent.matrixWorld)), e.applyMatrix4(Rs), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(qS), Xl.child = e, this.dispatchEvent(Xl), Xl.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, i) {
    if (this[e] === i) return this;
    for (let n = 0, s = this.children.length; n < s; n++) {
      const a = this.children[n].getObjectByProperty(e, i);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, i, n = []) {
    this[e] === i && n.push(this);
    const s = this.children;
    for (let a = 0, o = s.length; a < o; a++)
      s[a].getObjectsByProperty(e, i, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nh, e, D5), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nh, L5, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const i = this.matrixWorld.elements;
    return e.set(i[8], i[9], i[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const i = this.parent;
    i !== null && (e(i), i.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, i) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), i === !0) {
      const s = this.children;
      for (let a = 0, o = s.length; a < o; a++)
        s[a].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string", n = {};
    i && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
      center: s.boundingSphere.center.toArray(),
      radius: s.boundingSphere.radius
    }), this.boundingBox !== null && (s.boundingBox = {
      min: s.boundingBox.min.toArray(),
      max: s.boundingBox.max.toArray()
    }));
    function a(l, u) {
      return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = a(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const u = l.shapes;
        if (Array.isArray(u))
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c];
            a(e.shapes, d);
          }
        else
          a(e.shapes, u);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let u = 0, c = this.material.length; u < c; u++)
          l.push(a(e.materials, this.material[u]));
        s.material = l;
      } else
        s.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let l = 0; l < this.children.length; l++)
        s.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const u = this.animations[l];
        s.animations.push(a(e.animations, u));
      }
    }
    if (i) {
      const l = o(e.geometries), u = o(e.materials), c = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), f = o(e.animations), m = o(e.nodes);
      l.length > 0 && (n.geometries = l), u.length > 0 && (n.materials = u), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), d.length > 0 && (n.shapes = d), p.length > 0 && (n.skeletons = p), f.length > 0 && (n.animations = f), m.length > 0 && (n.nodes = m);
    }
    return n.object = s, n;
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, i = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), i === !0)
      for (let n = 0; n < e.children.length; n++) {
        const s = e.children[n];
        this.add(s.clone());
      }
    return this;
  }
};
Vr.DEFAULT_UP = /* @__PURE__ */ new X(0, 1, 0);
Vr.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Vr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Pn = /* @__PURE__ */ new X(), Ns = /* @__PURE__ */ new X(), Iy = /* @__PURE__ */ new X(), Ps = /* @__PURE__ */ new X(), $l = /* @__PURE__ */ new X(), Yl = /* @__PURE__ */ new X(), XS = /* @__PURE__ */ new X(), Oy = /* @__PURE__ */ new X(), Dy = /* @__PURE__ */ new X(), Ly = /* @__PURE__ */ new X(), ky = /* @__PURE__ */ new Fi(), Uy = /* @__PURE__ */ new Fi(), Fy = /* @__PURE__ */ new Fi();
let Au = class Cu {
  constructor(e = new X(), i = new X(), n = new X()) {
    this.a = e, this.b = i, this.c = n;
  }
  static getNormal(e, i, n, s) {
    s.subVectors(n, i), Pn.subVectors(e, i), s.cross(Pn);
    const a = s.lengthSq();
    return a > 0 ? s.multiplyScalar(1 / Math.sqrt(a)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, i, n, s, a) {
    Pn.subVectors(s, i), Ns.subVectors(n, i), Iy.subVectors(e, i);
    const o = Pn.dot(Pn), l = Pn.dot(Ns), u = Pn.dot(Iy), c = Ns.dot(Ns), h = Ns.dot(Iy), d = o * c - l * l;
    if (d === 0)
      return a.set(0, 0, 0), null;
    const p = 1 / d, f = (c * u - l * h) * p, m = (o * h - l * u) * p;
    return a.set(1 - f - m, m, f);
  }
  static containsPoint(e, i, n, s) {
    return this.getBarycoord(e, i, n, s, Ps) === null ? !1 : Ps.x >= 0 && Ps.y >= 0 && Ps.x + Ps.y <= 1;
  }
  static getInterpolation(e, i, n, s, a, o, l, u) {
    return this.getBarycoord(e, i, n, s, Ps) === null ? (u.x = 0, u.y = 0, "z" in u && (u.z = 0), "w" in u && (u.w = 0), null) : (u.setScalar(0), u.addScaledVector(a, Ps.x), u.addScaledVector(o, Ps.y), u.addScaledVector(l, Ps.z), u);
  }
  static getInterpolatedAttribute(e, i, n, s, a, o) {
    return ky.setScalar(0), Uy.setScalar(0), Fy.setScalar(0), ky.fromBufferAttribute(e, i), Uy.fromBufferAttribute(e, n), Fy.fromBufferAttribute(e, s), o.setScalar(0), o.addScaledVector(ky, a.x), o.addScaledVector(Uy, a.y), o.addScaledVector(Fy, a.z), o;
  }
  static isFrontFacing(e, i, n, s) {
    return Pn.subVectors(n, i), Ns.subVectors(e, i), Pn.cross(Ns).dot(s) < 0;
  }
  set(e, i, n) {
    return this.a.copy(e), this.b.copy(i), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, i, n, s) {
    return this.a.copy(e[i]), this.b.copy(e[n]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, i, n, s) {
    return this.a.fromBufferAttribute(e, i), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Pn.subVectors(this.c, this.b), Ns.subVectors(this.a, this.b), Pn.cross(Ns).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Cu.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, i) {
    return Cu.getBarycoord(e, this.a, this.b, this.c, i);
  }
  getInterpolation(e, i, n, s, a) {
    return Cu.getInterpolation(e, this.a, this.b, this.c, i, n, s, a);
  }
  containsPoint(e) {
    return Cu.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Cu.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, i) {
    const n = this.a, s = this.b, a = this.c;
    let o, l;
    $l.subVectors(s, n), Yl.subVectors(a, n), Oy.subVectors(e, n);
    const u = $l.dot(Oy), c = Yl.dot(Oy);
    if (u <= 0 && c <= 0)
      return i.copy(n);
    Dy.subVectors(e, s);
    const h = $l.dot(Dy), d = Yl.dot(Dy);
    if (h >= 0 && d <= h)
      return i.copy(s);
    const p = u * d - h * c;
    if (p <= 0 && u >= 0 && h <= 0)
      return o = u / (u - h), i.copy(n).addScaledVector($l, o);
    Ly.subVectors(e, a);
    const f = $l.dot(Ly), m = Yl.dot(Ly);
    if (m >= 0 && f <= m)
      return i.copy(a);
    const y = f * c - u * m;
    if (y <= 0 && c >= 0 && m <= 0)
      return l = c / (c - m), i.copy(n).addScaledVector(Yl, l);
    const v = h * m - f * d;
    if (v <= 0 && d - h >= 0 && f - m >= 0)
      return XS.subVectors(a, s), l = (d - h) / (d - h + (f - m)), i.copy(s).addScaledVector(XS, l);
    const g = 1 / (v + y + p);
    return o = y * g, l = p * g, i.copy(n).addScaledVector($l, o).addScaledVector(Yl, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
};
const uR = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Da = { h: 0, s: 0, l: 0 }, xp = { h: 0, s: 0, l: 0 };
function By(r, e, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? r + (e - r) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - i) : r;
}
let Ut = class {
  constructor(r, e, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(r, e, i);
  }
  set(r, e, i) {
    if (e === void 0 && i === void 0) {
      const n = r;
      n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
    } else
      this.setRGB(r, e, i);
    return this;
  }
  setScalar(r) {
    return this.r = r, this.g = r, this.b = r, this;
  }
  setHex(r, e = nn) {
    return r = Math.floor(r), this.r = (r >> 16 & 255) / 255, this.g = (r >> 8 & 255) / 255, this.b = (r & 255) / 255, Gt.toWorkingColorSpace(this, e), this;
  }
  setRGB(r, e, i, n = Gt.workingColorSpace) {
    return this.r = r, this.g = e, this.b = i, Gt.toWorkingColorSpace(this, n), this;
  }
  setHSL(r, e, i, n = Gt.workingColorSpace) {
    if (r = D_(r, 1), e = Yi(e, 0, 1), i = Yi(i, 0, 1), e === 0)
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + e) : i + e - i * e, a = 2 * i - s;
      this.r = By(a, s, r + 1 / 3), this.g = By(a, s, r), this.b = By(a, s, r - 1 / 3);
    }
    return Gt.toWorkingColorSpace(this, n), this;
  }
  setStyle(r, e = nn) {
    function i(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + r + " will be ignored.");
    }
    let n;
    if (n = /^(\w+)\(([^\)]*)\)/.exec(r)) {
      let s;
      const a = n[1], o = n[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setRGB(
              Math.min(255, parseInt(s[1], 10)) / 255,
              Math.min(255, parseInt(s[2], 10)) / 255,
              Math.min(255, parseInt(s[3], 10)) / 255,
              e
            );
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setRGB(
              Math.min(100, parseInt(s[1], 10)) / 100,
              Math.min(100, parseInt(s[2], 10)) / 100,
              Math.min(100, parseInt(s[3], 10)) / 100,
              e
            );
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setHSL(
              parseFloat(s[1]) / 360,
              parseFloat(s[2]) / 100,
              parseFloat(s[3]) / 100,
              e
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + r);
      }
    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(r)) {
      const s = n[1], a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          e
        );
      if (a === 6)
        return this.setHex(parseInt(s, 16), e);
      console.warn("THREE.Color: Invalid hex color " + r);
    } else if (r && r.length > 0)
      return this.setColorName(r, e);
    return this;
  }
  setColorName(r, e = nn) {
    const i = uR[r.toLowerCase()];
    return i !== void 0 ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + r), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(r) {
    return this.r = r.r, this.g = r.g, this.b = r.b, this;
  }
  copySRGBToLinear(r) {
    return this.r = ca(r.r), this.g = ca(r.g), this.b = ca(r.b), this;
  }
  copyLinearToSRGB(r) {
    return this.r = Wu(r.r), this.g = Wu(r.g), this.b = Wu(r.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(r = nn) {
    return Gt.fromWorkingColorSpace(lr.copy(this), r), Math.round(Yi(lr.r * 255, 0, 255)) * 65536 + Math.round(Yi(lr.g * 255, 0, 255)) * 256 + Math.round(Yi(lr.b * 255, 0, 255));
  }
  getHexString(r = nn) {
    return ("000000" + this.getHex(r).toString(16)).slice(-6);
  }
  getHSL(r, e = Gt.workingColorSpace) {
    Gt.fromWorkingColorSpace(lr.copy(this), e);
    const i = lr.r, n = lr.g, s = lr.b, a = Math.max(i, n, s), o = Math.min(i, n, s);
    let l, u;
    const c = (o + a) / 2;
    if (o === a)
      l = 0, u = 0;
    else {
      const h = a - o;
      switch (u = c <= 0.5 ? h / (a + o) : h / (2 - a - o), a) {
        case i:
          l = (n - s) / h + (n < s ? 6 : 0);
          break;
        case n:
          l = (s - i) / h + 2;
          break;
        case s:
          l = (i - n) / h + 4;
          break;
      }
      l /= 6;
    }
    return r.h = l, r.s = u, r.l = c, r;
  }
  getRGB(r, e = Gt.workingColorSpace) {
    return Gt.fromWorkingColorSpace(lr.copy(this), e), r.r = lr.r, r.g = lr.g, r.b = lr.b, r;
  }
  getStyle(r = nn) {
    Gt.fromWorkingColorSpace(lr.copy(this), r);
    const e = lr.r, i = lr.g, n = lr.b;
    return r !== nn ? `color(${r} ${e.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`;
  }
  offsetHSL(r, e, i) {
    return this.getHSL(Da), this.setHSL(Da.h + r, Da.s + e, Da.l + i);
  }
  add(r) {
    return this.r += r.r, this.g += r.g, this.b += r.b, this;
  }
  addColors(r, e) {
    return this.r = r.r + e.r, this.g = r.g + e.g, this.b = r.b + e.b, this;
  }
  addScalar(r) {
    return this.r += r, this.g += r, this.b += r, this;
  }
  sub(r) {
    return this.r = Math.max(0, this.r - r.r), this.g = Math.max(0, this.g - r.g), this.b = Math.max(0, this.b - r.b), this;
  }
  multiply(r) {
    return this.r *= r.r, this.g *= r.g, this.b *= r.b, this;
  }
  multiplyScalar(r) {
    return this.r *= r, this.g *= r, this.b *= r, this;
  }
  lerp(r, e) {
    return this.r += (r.r - this.r) * e, this.g += (r.g - this.g) * e, this.b += (r.b - this.b) * e, this;
  }
  lerpColors(r, e, i) {
    return this.r = r.r + (e.r - r.r) * i, this.g = r.g + (e.g - r.g) * i, this.b = r.b + (e.b - r.b) * i, this;
  }
  lerpHSL(r, e) {
    this.getHSL(Da), r.getHSL(xp);
    const i = Yh(Da.h, xp.h, e), n = Yh(Da.s, xp.s, e), s = Yh(Da.l, xp.l, e);
    return this.setHSL(i, n, s), this;
  }
  setFromVector3(r) {
    return this.r = r.x, this.g = r.y, this.b = r.z, this;
  }
  applyMatrix3(r) {
    const e = this.r, i = this.g, n = this.b, s = r.elements;
    return this.r = s[0] * e + s[3] * i + s[6] * n, this.g = s[1] * e + s[4] * i + s[7] * n, this.b = s[2] * e + s[5] * i + s[8] * n, this;
  }
  equals(r) {
    return r.r === this.r && r.g === this.g && r.b === this.b;
  }
  fromArray(r, e = 0) {
    return this.r = r[e], this.g = r[e + 1], this.b = r[e + 2], this;
  }
  toArray(r = [], e = 0) {
    return r[e] = this.r, r[e + 1] = this.g, r[e + 2] = this.b, r;
  }
  fromBufferAttribute(r, e) {
    return this.r = r.getX(e), this.g = r.getY(e), this.b = r.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const lr = /* @__PURE__ */ new Ut();
Ut.NAMES = uR;
let U5 = 0, Nl = class extends Cl {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(r) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: U5++ }), this.uuid = ua(), this.name = "", this.blending = Gu, this.side = mo, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Zv, this.blendDst = Qv, this.blendEquation = $o, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ut(0, 0, 0), this.blendAlpha = 0, this.depthFunc = hc, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = NS, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = zl, this.stencilZFail = zl, this.stencilZPass = zl, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(r) {
    this._alphaTest > 0 != r > 0 && this.version++, this._alphaTest = r;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(r) {
    if (r !== void 0)
      for (const e in r) {
        const i = r[e];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
          continue;
        }
        const n = this[e];
        if (n === void 0) {
          console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
          continue;
        }
        n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i;
      }
  }
  toJSON(r) {
    const e = r === void 0 || typeof r == "string";
    e && (r = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(r).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(r).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(r).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(r).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(r).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(r).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(r).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(r).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(r).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(r).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(r).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(r).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(r).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(r).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(r).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(r).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(r).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(r).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(r).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(r).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(r).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(r).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(r).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(r).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Gu && (i.blending = this.blending), this.side !== mo && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== Zv && (i.blendSrc = this.blendSrc), this.blendDst !== Qv && (i.blendDst = this.blendDst), this.blendEquation !== $o && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== hc && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== NS && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== zl && (i.stencilFail = this.stencilFail), this.stencilZFail !== zl && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== zl && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function n(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (e) {
      const s = n(r.textures), a = n(r.images);
      s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    this.name = r.name, this.blending = r.blending, this.side = r.side, this.vertexColors = r.vertexColors, this.opacity = r.opacity, this.transparent = r.transparent, this.blendSrc = r.blendSrc, this.blendDst = r.blendDst, this.blendEquation = r.blendEquation, this.blendSrcAlpha = r.blendSrcAlpha, this.blendDstAlpha = r.blendDstAlpha, this.blendEquationAlpha = r.blendEquationAlpha, this.blendColor.copy(r.blendColor), this.blendAlpha = r.blendAlpha, this.depthFunc = r.depthFunc, this.depthTest = r.depthTest, this.depthWrite = r.depthWrite, this.stencilWriteMask = r.stencilWriteMask, this.stencilFunc = r.stencilFunc, this.stencilRef = r.stencilRef, this.stencilFuncMask = r.stencilFuncMask, this.stencilFail = r.stencilFail, this.stencilZFail = r.stencilZFail, this.stencilZPass = r.stencilZPass, this.stencilWrite = r.stencilWrite;
    const e = r.clippingPlanes;
    let i = null;
    if (e !== null) {
      const n = e.length;
      i = new Array(n);
      for (let s = 0; s !== n; ++s)
        i[s] = e[s].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = r.clipIntersection, this.clipShadows = r.clipShadows, this.shadowSide = r.shadowSide, this.colorWrite = r.colorWrite, this.precision = r.precision, this.polygonOffset = r.polygonOffset, this.polygonOffsetFactor = r.polygonOffsetFactor, this.polygonOffsetUnits = r.polygonOffsetUnits, this.dithering = r.dithering, this.alphaTest = r.alphaTest, this.alphaHash = r.alphaHash, this.alphaToCoverage = r.alphaToCoverage, this.premultipliedAlpha = r.premultipliedAlpha, this.forceSinglePass = r.forceSinglePass, this.visible = r.visible, this.toneMapped = r.toneMapped, this.userData = JSON.parse(JSON.stringify(r.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}, wg = class extends Nl {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(r) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Ut(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new yo(), this.combine = A_, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.lightMap = r.lightMap, this.lightMapIntensity = r.lightMapIntensity, this.aoMap = r.aoMap, this.aoMapIntensity = r.aoMapIntensity, this.specularMap = r.specularMap, this.alphaMap = r.alphaMap, this.envMap = r.envMap, this.envMapRotation.copy(r.envMapRotation), this.combine = r.combine, this.reflectivity = r.reflectivity, this.refractionRatio = r.refractionRatio, this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.wireframeLinecap = r.wireframeLinecap, this.wireframeLinejoin = r.wireframeLinejoin, this.fog = r.fog, this;
  }
};
const Pi = /* @__PURE__ */ new X(), _p = /* @__PURE__ */ new ke();
let xn = class {
  constructor(r, e, i = !1) {
    if (Array.isArray(r))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = r, this.itemSize = e, this.count = r !== void 0 ? r.length / e : 0, this.normalized = i, this.usage = kb, this.updateRanges = [], this.gpuType = ra, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  setUsage(r) {
    return this.usage = r, this;
  }
  addUpdateRange(r, e) {
    this.updateRanges.push({ start: r, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(r) {
    return this.name = r.name, this.array = new r.array.constructor(r.array), this.itemSize = r.itemSize, this.count = r.count, this.normalized = r.normalized, this.usage = r.usage, this.gpuType = r.gpuType, this;
  }
  copyAt(r, e, i) {
    r *= this.itemSize, i *= e.itemSize;
    for (let n = 0, s = this.itemSize; n < s; n++)
      this.array[r + n] = e.array[i + n];
    return this;
  }
  copyArray(r) {
    return this.array.set(r), this;
  }
  applyMatrix3(r) {
    if (this.itemSize === 2)
      for (let e = 0, i = this.count; e < i; e++)
        _p.fromBufferAttribute(this, e), _p.applyMatrix3(r), this.setXY(e, _p.x, _p.y);
    else if (this.itemSize === 3)
      for (let e = 0, i = this.count; e < i; e++)
        Pi.fromBufferAttribute(this, e), Pi.applyMatrix3(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  applyMatrix4(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.applyMatrix4(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  applyNormalMatrix(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.applyNormalMatrix(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  transformDirection(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.transformDirection(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  set(r, e = 0) {
    return this.array.set(r, e), this;
  }
  getComponent(r, e) {
    let i = this.array[r * this.itemSize + e];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  setComponent(r, e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.array[r * this.itemSize + e] = i, this;
  }
  getX(r) {
    let e = this.array[r * this.itemSize];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setX(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize] = e, this;
  }
  getY(r) {
    let e = this.array[r * this.itemSize + 1];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setY(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize + 1] = e, this;
  }
  getZ(r) {
    let e = this.array[r * this.itemSize + 2];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setZ(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize + 2] = e, this;
  }
  getW(r) {
    let e = this.array[r * this.itemSize + 3];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setW(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize + 3] = e, this;
  }
  setXY(r, e, i) {
    return r *= this.itemSize, this.normalized && (e = Jt(e, this.array), i = Jt(i, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this;
  }
  setXYZ(r, e, i, n) {
    return r *= this.itemSize, this.normalized && (e = Jt(e, this.array), i = Jt(i, this.array), n = Jt(n, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this.array[r + 2] = n, this;
  }
  setXYZW(r, e, i, n, s) {
    return r *= this.itemSize, this.normalized && (e = Jt(e, this.array), i = Jt(i, this.array), n = Jt(n, this.array), s = Jt(s, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this.array[r + 2] = n, this.array[r + 3] = s, this;
  }
  onUpload(r) {
    return this.onUploadCallback = r, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const r = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (r.name = this.name), this.usage !== kb && (r.usage = this.usage), r;
  }
}, cR = class extends xn {
  constructor(r, e, i) {
    super(new Uint16Array(r), e, i);
  }
}, hR = class extends xn {
  constructor(r, e, i) {
    super(new Uint32Array(r), e, i);
  }
}, Ri = class extends xn {
  constructor(r, e, i) {
    super(new Float32Array(r), e, i);
  }
}, F5 = 0;
const hn = /* @__PURE__ */ new ui(), zy = /* @__PURE__ */ new Vr(), Kl = /* @__PURE__ */ new X(), Kr = /* @__PURE__ */ new Rl(), sh = /* @__PURE__ */ new Rl(), Wi = /* @__PURE__ */ new X();
let un = class dR extends Cl {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: F5++ }), this.uuid = ua(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (rR(e) ? hR : cR)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, i) {
    return this.attributes[e] = i, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, i, n = 0) {
    this.groups.push({
      start: e,
      count: i,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, i) {
    this.drawRange.start = e, this.drawRange.count = i;
  }
  applyMatrix4(e) {
    const i = this.attributes.position;
    i !== void 0 && (i.applyMatrix4(e), i.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const a = new It().getNormalMatrix(e);
      n.applyNormalMatrix(a), n.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return hn.makeRotationFromQuaternion(e), this.applyMatrix4(hn), this;
  }
  rotateX(e) {
    return hn.makeRotationX(e), this.applyMatrix4(hn), this;
  }
  rotateY(e) {
    return hn.makeRotationY(e), this.applyMatrix4(hn), this;
  }
  rotateZ(e) {
    return hn.makeRotationZ(e), this.applyMatrix4(hn), this;
  }
  translate(e, i, n) {
    return hn.makeTranslation(e, i, n), this.applyMatrix4(hn), this;
  }
  scale(e, i, n) {
    return hn.makeScale(e, i, n), this.applyMatrix4(hn), this;
  }
  lookAt(e) {
    return zy.lookAt(e), zy.updateMatrix(), this.applyMatrix4(zy.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Kl).negate(), this.translate(Kl.x, Kl.y, Kl.z), this;
  }
  setFromPoints(e) {
    const i = this.getAttribute("position");
    if (i === void 0) {
      const n = [];
      for (let s = 0, a = e.length; s < a; s++) {
        const o = e[s];
        n.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new Ri(n, 3));
    } else {
      for (let n = 0, s = i.count; n < s; n++) {
        const a = e[n];
        i.setXYZ(n, a.x, a.y, a.z || 0);
      }
      e.length > i.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), i.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Rl());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new X(-1 / 0, -1 / 0, -1 / 0),
        new X(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), i)
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n];
          Kr.setFromBufferAttribute(a), this.morphTargetsRelative ? (Wi.addVectors(this.boundingBox.min, Kr.min), this.boundingBox.expandByPoint(Wi), Wi.addVectors(this.boundingBox.max, Kr.max), this.boundingBox.expandByPoint(Wi)) : (this.boundingBox.expandByPoint(Kr.min), this.boundingBox.expandByPoint(Kr.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Tg());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new X(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (Kr.setFromBufferAttribute(e), i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a];
          sh.setFromBufferAttribute(l), this.morphTargetsRelative ? (Wi.addVectors(Kr.min, sh.min), Kr.expandByPoint(Wi), Wi.addVectors(Kr.max, sh.max), Kr.expandByPoint(Wi)) : (Kr.expandByPoint(sh.min), Kr.expandByPoint(sh.max));
        }
      Kr.getCenter(n);
      let s = 0;
      for (let a = 0, o = e.count; a < o; a++)
        Wi.fromBufferAttribute(e, a), s = Math.max(s, n.distanceToSquared(Wi));
      if (i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a], u = this.morphTargetsRelative;
          for (let c = 0, h = l.count; c < h; c++)
            Wi.fromBufferAttribute(l, c), u && (Kl.fromBufferAttribute(e, c), Wi.add(Kl)), s = Math.max(s, n.distanceToSquared(Wi));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, i = this.attributes;
    if (e === null || i.position === void 0 || i.normal === void 0 || i.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = i.position, s = i.normal, a = i.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new xn(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"), l = [], u = [];
    for (let M = 0; M < n.count; M++)
      l[M] = new X(), u[M] = new X();
    const c = new X(), h = new X(), d = new X(), p = new ke(), f = new ke(), m = new ke(), y = new X(), v = new X();
    function g(M, E, A) {
      c.fromBufferAttribute(n, M), h.fromBufferAttribute(n, E), d.fromBufferAttribute(n, A), p.fromBufferAttribute(a, M), f.fromBufferAttribute(a, E), m.fromBufferAttribute(a, A), h.sub(c), d.sub(c), f.sub(p), m.sub(p);
      const N = 1 / (f.x * m.y - m.x * f.y);
      isFinite(N) && (y.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(N), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(N), l[M].add(y), l[E].add(y), l[A].add(y), u[M].add(v), u[E].add(v), u[A].add(v));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{
      start: 0,
      count: e.count
    }]);
    for (let M = 0, E = _.length; M < E; ++M) {
      const A = _[M], N = A.start, U = A.count;
      for (let k = N, C = N + U; k < C; k += 3)
        g(
          e.getX(k + 0),
          e.getX(k + 1),
          e.getX(k + 2)
        );
    }
    const x = new X(), b = new X(), T = new X(), S = new X();
    function w(M) {
      T.fromBufferAttribute(s, M), S.copy(T);
      const E = l[M];
      x.copy(E), x.sub(T.multiplyScalar(T.dot(E))).normalize(), b.crossVectors(S, E);
      const A = b.dot(u[M]) < 0 ? -1 : 1;
      o.setXYZW(M, x.x, x.y, x.z, A);
    }
    for (let M = 0, E = _.length; M < E; ++M) {
      const A = _[M], N = A.start, U = A.count;
      for (let k = N, C = N + U; k < C; k += 3)
        w(e.getX(k + 0)), w(e.getX(k + 1)), w(e.getX(k + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, i = this.getAttribute("position");
    if (i !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new xn(new Float32Array(i.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let p = 0, f = n.count; p < f; p++)
          n.setXYZ(p, 0, 0, 0);
      const s = new X(), a = new X(), o = new X(), l = new X(), u = new X(), c = new X(), h = new X(), d = new X();
      if (e)
        for (let p = 0, f = e.count; p < f; p += 3) {
          const m = e.getX(p + 0), y = e.getX(p + 1), v = e.getX(p + 2);
          s.fromBufferAttribute(i, m), a.fromBufferAttribute(i, y), o.fromBufferAttribute(i, v), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, y), c.fromBufferAttribute(n, v), l.add(h), u.add(h), c.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(y, u.x, u.y, u.z), n.setXYZ(v, c.x, c.y, c.z);
        }
      else
        for (let p = 0, f = i.count; p < f; p += 3)
          s.fromBufferAttribute(i, p + 0), a.fromBufferAttribute(i, p + 1), o.fromBufferAttribute(i, p + 2), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), n.setXYZ(p + 0, h.x, h.y, h.z), n.setXYZ(p + 1, h.x, h.y, h.z), n.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let i = 0, n = e.count; i < n; i++)
      Wi.fromBufferAttribute(e, i), Wi.normalize(), e.setXYZ(i, Wi.x, Wi.y, Wi.z);
  }
  toNonIndexed() {
    function e(l, u) {
      const c = l.array, h = l.itemSize, d = l.normalized, p = new c.constructor(u.length * h);
      let f = 0, m = 0;
      for (let y = 0, v = u.length; y < v; y++) {
        l.isInterleavedBufferAttribute ? f = u[y] * l.data.stride + l.offset : f = u[y] * h;
        for (let g = 0; g < h; g++)
          p[m++] = c[f++];
      }
      return new xn(p, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const i = new dR(), n = this.index.array, s = this.attributes;
    for (const l in s) {
      const u = s[l], c = e(u, n);
      i.setAttribute(l, c);
    }
    const a = this.morphAttributes;
    for (const l in a) {
      const u = [], c = a[l];
      for (let h = 0, d = c.length; h < d; h++) {
        const p = c[h], f = e(p, n);
        u.push(f);
      }
      i.morphAttributes[l] = u;
    }
    i.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const c = o[l];
      i.addGroup(c.start, c.count, c.materialIndex);
    }
    return i;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const u = this.parameters;
      for (const c in u)
        u[c] !== void 0 && (e[c] = u[c]);
      return e;
    }
    e.data = { attributes: {} };
    const i = this.index;
    i !== null && (e.data.index = {
      type: i.array.constructor.name,
      array: Array.prototype.slice.call(i.array)
    });
    const n = this.attributes;
    for (const u in n) {
      const c = n[u];
      e.data.attributes[u] = c.toJSON(e.data);
    }
    const s = {};
    let a = !1;
    for (const u in this.morphAttributes) {
      const c = this.morphAttributes[u], h = [];
      for (let d = 0, p = c.length; d < p; d++) {
        const f = c[d];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (s[u] = h, a = !0);
    }
    a && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const i = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(i));
    const s = e.attributes;
    for (const c in s) {
      const h = s[c];
      this.setAttribute(c, h.clone(i));
    }
    const a = e.morphAttributes;
    for (const c in a) {
      const h = [], d = a[c];
      for (let p = 0, f = d.length; p < f; p++)
        h.push(d[p].clone(i));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = e.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
const $S = /* @__PURE__ */ new ui(), Po = /* @__PURE__ */ new Sg(), Tp = /* @__PURE__ */ new Tg(), YS = /* @__PURE__ */ new X(), Sp = /* @__PURE__ */ new X(), wp = /* @__PURE__ */ new X(), Ep = /* @__PURE__ */ new X(), jy = /* @__PURE__ */ new X(), Mp = /* @__PURE__ */ new X(), KS = /* @__PURE__ */ new X(), Ap = /* @__PURE__ */ new X();
let Lr = class extends Vr {
  constructor(r = new un(), e = new wg()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = r, this.material = e, this.updateMorphTargets();
  }
  copy(r, e) {
    return super.copy(r, e), r.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = r.morphTargetInfluences.slice()), r.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, r.morphTargetDictionary)), this.material = Array.isArray(r.material) ? r.material.slice() : r.material, this.geometry = r.geometry, this;
  }
  updateMorphTargets() {
    const r = this.geometry.morphAttributes, e = Object.keys(r);
    if (e.length > 0) {
      const i = r[e[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n].name || String(n);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = n;
        }
      }
    }
  }
  getVertexPosition(r, e) {
    const i = this.geometry, n = i.attributes.position, s = i.morphAttributes.position, a = i.morphTargetsRelative;
    e.fromBufferAttribute(n, r);
    const o = this.morphTargetInfluences;
    if (s && o) {
      Mp.set(0, 0, 0);
      for (let l = 0, u = s.length; l < u; l++) {
        const c = o[l], h = s[l];
        c !== 0 && (jy.fromBufferAttribute(h, r), a ? Mp.addScaledVector(jy, c) : Mp.addScaledVector(jy.sub(e), c));
      }
      e.add(Mp);
    }
    return e;
  }
  raycast(r, e) {
    const i = this.geometry, n = this.material, s = this.matrixWorld;
    n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Tp.copy(i.boundingSphere), Tp.applyMatrix4(s), Po.copy(r.ray).recast(r.near), !(Tp.containsPoint(Po.origin) === !1 && (Po.intersectSphere(Tp, YS) === null || Po.origin.distanceToSquared(YS) > (r.far - r.near) ** 2)) && ($S.copy(s).invert(), Po.copy(r.ray).applyMatrix4($S), !(i.boundingBox !== null && Po.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(r, e, Po)));
  }
  _computeIntersections(r, e, i) {
    let n;
    const s = this.geometry, a = this.material, o = s.index, l = s.attributes.position, u = s.attributes.uv, c = s.attributes.uv1, h = s.attributes.normal, d = s.groups, p = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let f = 0, m = d.length; f < m; f++) {
          const y = d[f], v = a[y.materialIndex], g = Math.max(y.start, p.start), _ = Math.min(o.count, Math.min(y.start + y.count, p.start + p.count));
          for (let x = g, b = _; x < b; x += 3) {
            const T = o.getX(x), S = o.getX(x + 1), w = o.getX(x + 2);
            n = Cp(this, v, r, i, u, c, h, T, S, w), n && (n.faceIndex = Math.floor(x / 3), n.face.materialIndex = y.materialIndex, e.push(n));
          }
        }
      else {
        const f = Math.max(0, p.start), m = Math.min(o.count, p.start + p.count);
        for (let y = f, v = m; y < v; y += 3) {
          const g = o.getX(y), _ = o.getX(y + 1), x = o.getX(y + 2);
          n = Cp(this, a, r, i, u, c, h, g, _, x), n && (n.faceIndex = Math.floor(y / 3), e.push(n));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let f = 0, m = d.length; f < m; f++) {
          const y = d[f], v = a[y.materialIndex], g = Math.max(y.start, p.start), _ = Math.min(l.count, Math.min(y.start + y.count, p.start + p.count));
          for (let x = g, b = _; x < b; x += 3) {
            const T = x, S = x + 1, w = x + 2;
            n = Cp(this, v, r, i, u, c, h, T, S, w), n && (n.faceIndex = Math.floor(x / 3), n.face.materialIndex = y.materialIndex, e.push(n));
          }
        }
      else {
        const f = Math.max(0, p.start), m = Math.min(l.count, p.start + p.count);
        for (let y = f, v = m; y < v; y += 3) {
          const g = y, _ = y + 1, x = y + 2;
          n = Cp(this, a, r, i, u, c, h, g, _, x), n && (n.faceIndex = Math.floor(y / 3), e.push(n));
        }
      }
  }
};
function B5(r, e, i, n, s, a, o, l) {
  let u;
  if (e.side === Mr ? u = n.intersectTriangle(o, a, s, !0, l) : u = n.intersectTriangle(s, a, o, e.side === mo, l), u === null) return null;
  Ap.copy(l), Ap.applyMatrix4(r.matrixWorld);
  const c = i.ray.origin.distanceTo(Ap);
  return c < i.near || c > i.far ? null : {
    distance: c,
    point: Ap.clone(),
    object: r
  };
}
function Cp(r, e, i, n, s, a, o, l, u, c) {
  r.getVertexPosition(l, Sp), r.getVertexPosition(u, wp), r.getVertexPosition(c, Ep);
  const h = B5(r, e, i, n, Sp, wp, Ep, KS);
  if (h) {
    const d = new X();
    Au.getBarycoord(KS, Sp, wp, Ep, d), s && (h.uv = Au.getInterpolatedAttribute(s, l, u, c, d, new ke())), a && (h.uv1 = Au.getInterpolatedAttribute(a, l, u, c, d, new ke())), o && (h.normal = Au.getInterpolatedAttribute(o, l, u, c, d, new X()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const p = {
      a: l,
      b: u,
      c,
      normal: new X(),
      materialIndex: 0
    };
    Au.getNormal(Sp, wp, Ep, p.normal), h.face = p, h.barycoord = d;
  }
  return h;
}
let k_ = class pR extends un {
  constructor(e = 1, i = 1, n = 1, s = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: i,
      depth: n,
      widthSegments: s,
      heightSegments: a,
      depthSegments: o
    };
    const l = this;
    s = Math.floor(s), a = Math.floor(a), o = Math.floor(o);
    const u = [], c = [], h = [], d = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, n, i, e, o, a, 0), m("z", "y", "x", 1, -1, n, i, -e, o, a, 1), m("x", "z", "y", 1, 1, e, n, i, s, o, 2), m("x", "z", "y", 1, -1, e, n, -i, s, o, 3), m("x", "y", "z", 1, -1, e, i, n, s, a, 4), m("x", "y", "z", -1, -1, e, i, -n, s, a, 5), this.setIndex(u), this.setAttribute("position", new Ri(c, 3)), this.setAttribute("normal", new Ri(h, 3)), this.setAttribute("uv", new Ri(d, 2));
    function m(y, v, g, _, x, b, T, S, w, M, E) {
      const A = b / w, N = T / M, U = b / 2, k = T / 2, C = S / 2, I = w + 1, O = M + 1;
      let W = 0, V = 0;
      const Q = new X();
      for (let F = 0; F < O; F++) {
        const B = F * N - k;
        for (let q = 0; q < I; q++) {
          const G = q * A - U;
          Q[y] = G * _, Q[v] = B * x, Q[g] = C, c.push(Q.x, Q.y, Q.z), Q[y] = 0, Q[v] = 0, Q[g] = S > 0 ? 1 : -1, h.push(Q.x, Q.y, Q.z), d.push(q / w), d.push(1 - F / M), W += 1;
        }
      }
      for (let F = 0; F < M; F++)
        for (let B = 0; B < w; B++) {
          const q = p + B + I * F, G = p + B + I * (F + 1), z = p + (B + 1) + I * (F + 1), Y = p + (B + 1) + I * F;
          u.push(q, G, Y), u.push(G, z, Y), V += 6;
        }
      l.addGroup(f, V, E), f += V, p += W;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new pR(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
};
function gc(r) {
  const e = {};
  for (const i in r) {
    e[i] = {};
    for (const n in r[i]) {
      const s = r[i][n];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][n] = null) : e[i][n] = s.clone() : Array.isArray(s) ? e[i][n] = s.slice() : e[i][n] = s;
    }
  }
  return e;
}
function xr(r) {
  const e = {};
  for (let i = 0; i < r.length; i++) {
    const n = gc(r[i]);
    for (const s in n)
      e[s] = n[s];
  }
  return e;
}
function z5(r) {
  const e = [];
  for (let i = 0; i < r.length; i++)
    e.push(r[i].clone());
  return e;
}
function fR(r) {
  const e = r.getRenderTarget();
  return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Gt.workingColorSpace;
}
const mR = { clone: gc, merge: xr };
var j5 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, V5 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
let xs = class extends Nl {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(r) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = j5, this.fragmentShader = V5, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, r !== void 0 && this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.fragmentShader = r.fragmentShader, this.vertexShader = r.vertexShader, this.uniforms = gc(r.uniforms), this.uniformsGroups = z5(r.uniformsGroups), this.defines = Object.assign({}, r.defines), this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.fog = r.fog, this.lights = r.lights, this.clipping = r.clipping, this.extensions = Object.assign({}, r.extensions), this.glslVersion = r.glslVersion, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    e.glslVersion = this.glslVersion, e.uniforms = {};
    for (const n in this.uniforms) {
      const s = this.uniforms[n].value;
      s && s.isTexture ? e.uniforms[n] = {
        type: "t",
        value: s.toJSON(r).uuid
      } : s && s.isColor ? e.uniforms[n] = {
        type: "c",
        value: s.getHex()
      } : s && s.isVector2 ? e.uniforms[n] = {
        type: "v2",
        value: s.toArray()
      } : s && s.isVector3 ? e.uniforms[n] = {
        type: "v3",
        value: s.toArray()
      } : s && s.isVector4 ? e.uniforms[n] = {
        type: "v4",
        value: s.toArray()
      } : s && s.isMatrix3 ? e.uniforms[n] = {
        type: "m3",
        value: s.toArray()
      } : s && s.isMatrix4 ? e.uniforms[n] = {
        type: "m4",
        value: s.toArray()
      } : e.uniforms[n] = {
        value: s
      };
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
    const i = {};
    for (const n in this.extensions)
      this.extensions[n] === !0 && (i[n] = !0);
    return Object.keys(i).length > 0 && (e.extensions = i), e;
  }
}, gR = class extends Vr {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ui(), this.projectionMatrix = new ui(), this.projectionMatrixInverse = new ui(), this.coordinateSystem = na;
  }
  copy(r, e) {
    return super.copy(r, e), this.matrixWorldInverse.copy(r.matrixWorldInverse), this.projectionMatrix.copy(r.projectionMatrix), this.projectionMatrixInverse.copy(r.projectionMatrixInverse), this.coordinateSystem = r.coordinateSystem, this;
  }
  getWorldDirection(r) {
    return super.getWorldDirection(r).negate();
  }
  updateMatrixWorld(r) {
    super.updateMatrixWorld(r), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(r, e) {
    super.updateWorldMatrix(r, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const La = /* @__PURE__ */ new X(), ZS = /* @__PURE__ */ new ke(), QS = /* @__PURE__ */ new ke();
let yn = class extends gR {
  constructor(r = 50, e = 1, i = 0.1, n = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = r, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(r, e) {
    return super.copy(r, e), this.fov = r.fov, this.zoom = r.zoom, this.near = r.near, this.far = r.far, this.focus = r.focus, this.aspect = r.aspect, this.view = r.view === null ? null : Object.assign({}, r.view), this.filmGauge = r.filmGauge, this.filmOffset = r.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(r) {
    const e = 0.5 * this.getFilmHeight() / r;
    this.fov = hd * 2 * Math.atan(e), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const r = Math.tan($h * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / r;
  }
  getEffectiveFOV() {
    return hd * 2 * Math.atan(
      Math.tan($h * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(r, e, i) {
    La.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), e.set(La.x, La.y).multiplyScalar(-r / La.z), La.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(La.x, La.y).multiplyScalar(-r / La.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(r, e) {
    return this.getViewBounds(r, ZS, QS), e.subVectors(QS, ZS);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(r, e, i, n, s, a) {
    this.aspect = r / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = r, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const r = this.near;
    let e = r * Math.tan($h * 0.5 * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, s = -0.5 * n;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth, u = a.fullHeight;
      s += a.offsetX * n / l, e -= a.offsetY * i / u, n *= a.width / l, i *= a.height / u;
    }
    const o = this.filmOffset;
    o !== 0 && (s += r * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + n, e, e - i, r, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
};
const Zl = -90, Ql = 1;
let G5 = class extends Vr {
  constructor(r, e, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const n = new yn(Zl, Ql, r, e);
    n.layers = this.layers, this.add(n);
    const s = new yn(Zl, Ql, r, e);
    s.layers = this.layers, this.add(s);
    const a = new yn(Zl, Ql, r, e);
    a.layers = this.layers, this.add(a);
    const o = new yn(Zl, Ql, r, e);
    o.layers = this.layers, this.add(o);
    const l = new yn(Zl, Ql, r, e);
    l.layers = this.layers, this.add(l);
    const u = new yn(Zl, Ql, r, e);
    u.layers = this.layers, this.add(u);
  }
  updateCoordinateSystem() {
    const r = this.coordinateSystem, e = this.children.concat(), [i, n, s, a, o, l] = e;
    for (const u of e) this.remove(u);
    if (r === na)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (r === bm)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + r);
    for (const u of e)
      this.add(u), u.updateMatrixWorld();
  }
  update(r, e) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: n } = this;
    this.coordinateSystem !== r.coordinateSystem && (this.coordinateSystem = r.coordinateSystem, this.updateCoordinateSystem());
    const [s, a, o, l, u, c] = this.children, h = r.getRenderTarget(), d = r.getActiveCubeFace(), p = r.getActiveMipmapLevel(), f = r.xr.enabled;
    r.xr.enabled = !1;
    const m = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, r.setRenderTarget(i, 0, n), r.render(e, s), r.setRenderTarget(i, 1, n), r.render(e, a), r.setRenderTarget(i, 2, n), r.render(e, o), r.setRenderTarget(i, 3, n), r.render(e, l), r.setRenderTarget(i, 4, n), r.render(e, u), i.texture.generateMipmaps = m, r.setRenderTarget(i, 5, n), r.render(e, c), r.setRenderTarget(h, d, p), r.xr.enabled = f, i.texture.needsPMREMUpdate = !0;
  }
}, yR = class extends wn {
  constructor(r, e, i, n, s, a, o, l, u, c) {
    r = r !== void 0 ? r : [], e = e !== void 0 ? e : dc, super(r, e, i, n, s, a, o, l, u, c), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(r) {
    this.image = r;
  }
}, H5 = class extends go {
  constructor(r = 1, e = {}) {
    super(r, r, e), this.isWebGLCubeRenderTarget = !0;
    const i = { width: r, height: r, depth: 1 }, n = [i, i, i, i, i, i];
    this.texture = new yR(n, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : ds;
  }
  fromEquirectangularTexture(r, e) {
    this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, n = new k_(5, 5, 5), s = new xs({
      name: "CubemapFromEquirect",
      uniforms: gc(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: Mr,
      blending: la
    });
    s.uniforms.tEquirect.value = e;
    const a = new Lr(n, s), o = e.minFilter;
    return e.minFilter === nl && (e.minFilter = ds), new G5(1, 10, this).update(r, a), e.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(r, e, i, n) {
    const s = r.getRenderTarget();
    for (let a = 0; a < 6; a++)
      r.setRenderTarget(this, a), r.clear(e, i, n);
    r.setRenderTarget(s);
  }
};
const Vy = /* @__PURE__ */ new X(), W5 = /* @__PURE__ */ new X(), q5 = /* @__PURE__ */ new It();
let qs = class {
  constructor(r = new X(1, 0, 0), e = 0) {
    this.isPlane = !0, this.normal = r, this.constant = e;
  }
  set(r, e) {
    return this.normal.copy(r), this.constant = e, this;
  }
  setComponents(r, e, i, n) {
    return this.normal.set(r, e, i), this.constant = n, this;
  }
  setFromNormalAndCoplanarPoint(r, e) {
    return this.normal.copy(r), this.constant = -e.dot(this.normal), this;
  }
  setFromCoplanarPoints(r, e, i) {
    const n = Vy.subVectors(i, e).cross(W5.subVectors(r, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, r), this;
  }
  copy(r) {
    return this.normal.copy(r.normal), this.constant = r.constant, this;
  }
  normalize() {
    const r = 1 / this.normal.length();
    return this.normal.multiplyScalar(r), this.constant *= r, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(r) {
    return this.normal.dot(r) + this.constant;
  }
  distanceToSphere(r) {
    return this.distanceToPoint(r.center) - r.radius;
  }
  projectPoint(r, e) {
    return e.copy(r).addScaledVector(this.normal, -this.distanceToPoint(r));
  }
  intersectLine(r, e) {
    const i = r.delta(Vy), n = this.normal.dot(i);
    if (n === 0)
      return this.distanceToPoint(r.start) === 0 ? e.copy(r.start) : null;
    const s = -(r.start.dot(this.normal) + this.constant) / n;
    return s < 0 || s > 1 ? null : e.copy(r.start).addScaledVector(i, s);
  }
  intersectsLine(r) {
    const e = this.distanceToPoint(r.start), i = this.distanceToPoint(r.end);
    return e < 0 && i > 0 || i < 0 && e > 0;
  }
  intersectsBox(r) {
    return r.intersectsPlane(this);
  }
  intersectsSphere(r) {
    return r.intersectsPlane(this);
  }
  coplanarPoint(r) {
    return r.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(r, e) {
    const i = e || q5.getNormalMatrix(r), n = this.coplanarPoint(Vy).applyMatrix4(r), s = this.normal.applyMatrix3(i).normalize();
    return this.constant = -n.dot(s), this;
  }
  translate(r) {
    return this.constant -= r.dot(this.normal), this;
  }
  equals(r) {
    return r.normal.equals(this.normal) && r.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const Io = /* @__PURE__ */ new Tg(), Rp = /* @__PURE__ */ new X();
let U_ = class {
  constructor(r = new qs(), e = new qs(), i = new qs(), n = new qs(), s = new qs(), a = new qs()) {
    this.planes = [r, e, i, n, s, a];
  }
  set(r, e, i, n, s, a) {
    const o = this.planes;
    return o[0].copy(r), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(s), o[5].copy(a), this;
  }
  copy(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++)
      e[i].copy(r.planes[i]);
    return this;
  }
  setFromProjectionMatrix(r, e = na) {
    const i = this.planes, n = r.elements, s = n[0], a = n[1], o = n[2], l = n[3], u = n[4], c = n[5], h = n[6], d = n[7], p = n[8], f = n[9], m = n[10], y = n[11], v = n[12], g = n[13], _ = n[14], x = n[15];
    if (i[0].setComponents(l - s, d - u, y - p, x - v).normalize(), i[1].setComponents(l + s, d + u, y + p, x + v).normalize(), i[2].setComponents(l + a, d + c, y + f, x + g).normalize(), i[3].setComponents(l - a, d - c, y - f, x - g).normalize(), i[4].setComponents(l - o, d - h, y - m, x - _).normalize(), e === na)
      i[5].setComponents(l + o, d + h, y + m, x + _).normalize();
    else if (e === bm)
      i[5].setComponents(o, h, m, _).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
    return this;
  }
  intersectsObject(r) {
    if (r.boundingSphere !== void 0)
      r.boundingSphere === null && r.computeBoundingSphere(), Io.copy(r.boundingSphere).applyMatrix4(r.matrixWorld);
    else {
      const e = r.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(), Io.copy(e.boundingSphere).applyMatrix4(r.matrixWorld);
    }
    return this.intersectsSphere(Io);
  }
  intersectsSprite(r) {
    return Io.center.set(0, 0, 0), Io.radius = 0.7071067811865476, Io.applyMatrix4(r.matrixWorld), this.intersectsSphere(Io);
  }
  intersectsSphere(r) {
    const e = this.planes, i = r.center, n = -r.radius;
    for (let s = 0; s < 6; s++)
      if (e[s].distanceToPoint(i) < n)
        return !1;
    return !0;
  }
  intersectsBox(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = e[i];
      if (Rp.x = n.normal.x > 0 ? r.max.x : r.min.x, Rp.y = n.normal.y > 0 ? r.max.y : r.min.y, Rp.z = n.normal.z > 0 ? r.max.z : r.min.z, n.distanceToPoint(Rp) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++)
      if (e[i].distanceToPoint(r) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function vR() {
  let r = null, e = !1, i = null, n = null;
  function s(a, o) {
    i(a, o), n = r.requestAnimationFrame(s);
  }
  return {
    start: function() {
      e !== !0 && i !== null && (n = r.requestAnimationFrame(s), e = !0);
    },
    stop: function() {
      r.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(a) {
      i = a;
    },
    setContext: function(a) {
      r = a;
    }
  };
}
function X5(r) {
  const e = /* @__PURE__ */ new WeakMap();
  function i(l, u) {
    const c = l.array, h = l.usage, d = c.byteLength, p = r.createBuffer();
    r.bindBuffer(u, p), r.bufferData(u, c, h), l.onUploadCallback();
    let f;
    if (c instanceof Float32Array)
      f = r.FLOAT;
    else if (c instanceof Uint16Array)
      l.isFloat16BufferAttribute ? f = r.HALF_FLOAT : f = r.UNSIGNED_SHORT;
    else if (c instanceof Int16Array)
      f = r.SHORT;
    else if (c instanceof Uint32Array)
      f = r.UNSIGNED_INT;
    else if (c instanceof Int32Array)
      f = r.INT;
    else if (c instanceof Int8Array)
      f = r.BYTE;
    else if (c instanceof Uint8Array)
      f = r.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray)
      f = r.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
    return {
      buffer: p,
      type: f,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: l.version,
      size: d
    };
  }
  function n(l, u, c) {
    const h = u.array, d = u.updateRanges;
    if (r.bindBuffer(c, l), d.length === 0)
      r.bufferSubData(c, 0, h);
    else {
      d.sort((f, m) => f.start - m.start);
      let p = 0;
      for (let f = 1; f < d.length; f++) {
        const m = d[p], y = d[f];
        y.start <= m.start + m.count + 1 ? m.count = Math.max(
          m.count,
          y.start + y.count - m.start
        ) : (++p, d[p] = y);
      }
      d.length = p + 1;
      for (let f = 0, m = d.length; f < m; f++) {
        const y = d[f];
        r.bufferSubData(
          c,
          y.start * h.BYTES_PER_ELEMENT,
          h,
          y.start,
          y.count
        );
      }
      u.clearUpdateRanges();
    }
    u.onUploadCallback();
  }
  function s(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function a(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const u = e.get(l);
    u && (r.deleteBuffer(u.buffer), e.delete(l));
  }
  function o(l, u) {
    if (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute) {
      const h = e.get(l);
      (!h || h.version < l.version) && e.set(l, {
        buffer: l.buffer,
        type: l.type,
        bytesPerElement: l.elementSize,
        version: l.version
      });
      return;
    }
    const c = e.get(l);
    if (c === void 0)
      e.set(l, i(l, u));
    else if (c.version < l.version) {
      if (c.size !== l.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n(c.buffer, l, u), c.version = l.version;
    }
  }
  return {
    get: s,
    remove: a,
    update: o
  };
}
class Hd extends un {
  constructor(e = 1, i = 1, n = 1, s = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: i,
      widthSegments: n,
      heightSegments: s
    };
    const a = e / 2, o = i / 2, l = Math.floor(n), u = Math.floor(s), c = l + 1, h = u + 1, d = e / l, p = i / u, f = [], m = [], y = [], v = [];
    for (let g = 0; g < h; g++) {
      const _ = g * p - o;
      for (let x = 0; x < c; x++) {
        const b = x * d - a;
        m.push(b, -_, 0), y.push(0, 0, 1), v.push(x / l), v.push(1 - g / u);
      }
    }
    for (let g = 0; g < u; g++)
      for (let _ = 0; _ < l; _++) {
        const x = _ + c * g, b = _ + c * (g + 1), T = _ + 1 + c * (g + 1), S = _ + 1 + c * g;
        f.push(x, b, S), f.push(b, T, S);
      }
    this.setIndex(f), this.setAttribute("position", new Ri(m, 3)), this.setAttribute("normal", new Ri(y, 3)), this.setAttribute("uv", new Ri(v, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Hd(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var $5 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Y5 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, K5 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Z5 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Q5 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, J5 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, eB = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, tB = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, iB = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, rB = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, nB = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, sB = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, aB = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, oB = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, lB = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, uB = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, cB = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, hB = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, dB = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, pB = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, fB = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, mB = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, gB = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, yB = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, vB = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, bB = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, xB = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, _B = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, TB = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, SB = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, wB = "gl_FragColor = linearToOutputTexel( gl_FragColor );", EB = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, MB = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, AB = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, CB = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, RB = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, NB = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, PB = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, IB = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, OB = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, DB = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, LB = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, kB = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, UB = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, FB = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, BB = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, zB = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, jB = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, VB = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, GB = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, HB = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, WB = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, qB = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, XB = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, $B = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, YB = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, KB = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, ZB = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, QB = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, JB = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, ez = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, tz = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, iz = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, rz = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, nz = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, sz = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, az = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, oz = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, lz = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, uz = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, cz = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, hz = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, dz = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, pz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, fz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, mz = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, gz = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, yz = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, vz = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, bz = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, xz = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, _z = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Tz = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, Sz = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, wz = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Ez = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Mz = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Az = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Cz = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Rz = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, Nz = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Pz = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Iz = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Oz = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Dz = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Lz = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, kz = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Uz = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Fz = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Bz = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, zz = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, jz = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, Vz = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Gz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Hz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Wz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, qz = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Xz = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, $z = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Yz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Kz = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Zz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Qz = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Jz = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, e4 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, t4 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, i4 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, r4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, n4 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, s4 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, a4 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, o4 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, l4 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, u4 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, c4 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, h4 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, d4 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, p4 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, f4 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, m4 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, g4 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, y4 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, v4 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, b4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, x4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, _4 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, T4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, S4 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, w4 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, E4 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, M4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Rt = {
  alphahash_fragment: $5,
  alphahash_pars_fragment: Y5,
  alphamap_fragment: K5,
  alphamap_pars_fragment: Z5,
  alphatest_fragment: Q5,
  alphatest_pars_fragment: J5,
  aomap_fragment: eB,
  aomap_pars_fragment: tB,
  batching_pars_vertex: iB,
  batching_vertex: rB,
  begin_vertex: nB,
  beginnormal_vertex: sB,
  bsdfs: aB,
  iridescence_fragment: oB,
  bumpmap_pars_fragment: lB,
  clipping_planes_fragment: uB,
  clipping_planes_pars_fragment: cB,
  clipping_planes_pars_vertex: hB,
  clipping_planes_vertex: dB,
  color_fragment: pB,
  color_pars_fragment: fB,
  color_pars_vertex: mB,
  color_vertex: gB,
  common: yB,
  cube_uv_reflection_fragment: vB,
  defaultnormal_vertex: bB,
  displacementmap_pars_vertex: xB,
  displacementmap_vertex: _B,
  emissivemap_fragment: TB,
  emissivemap_pars_fragment: SB,
  colorspace_fragment: wB,
  colorspace_pars_fragment: EB,
  envmap_fragment: MB,
  envmap_common_pars_fragment: AB,
  envmap_pars_fragment: CB,
  envmap_pars_vertex: RB,
  envmap_physical_pars_fragment: zB,
  envmap_vertex: NB,
  fog_vertex: PB,
  fog_pars_vertex: IB,
  fog_fragment: OB,
  fog_pars_fragment: DB,
  gradientmap_pars_fragment: LB,
  lightmap_pars_fragment: kB,
  lights_lambert_fragment: UB,
  lights_lambert_pars_fragment: FB,
  lights_pars_begin: BB,
  lights_toon_fragment: jB,
  lights_toon_pars_fragment: VB,
  lights_phong_fragment: GB,
  lights_phong_pars_fragment: HB,
  lights_physical_fragment: WB,
  lights_physical_pars_fragment: qB,
  lights_fragment_begin: XB,
  lights_fragment_maps: $B,
  lights_fragment_end: YB,
  logdepthbuf_fragment: KB,
  logdepthbuf_pars_fragment: ZB,
  logdepthbuf_pars_vertex: QB,
  logdepthbuf_vertex: JB,
  map_fragment: ez,
  map_pars_fragment: tz,
  map_particle_fragment: iz,
  map_particle_pars_fragment: rz,
  metalnessmap_fragment: nz,
  metalnessmap_pars_fragment: sz,
  morphinstance_vertex: az,
  morphcolor_vertex: oz,
  morphnormal_vertex: lz,
  morphtarget_pars_vertex: uz,
  morphtarget_vertex: cz,
  normal_fragment_begin: hz,
  normal_fragment_maps: dz,
  normal_pars_fragment: pz,
  normal_pars_vertex: fz,
  normal_vertex: mz,
  normalmap_pars_fragment: gz,
  clearcoat_normal_fragment_begin: yz,
  clearcoat_normal_fragment_maps: vz,
  clearcoat_pars_fragment: bz,
  iridescence_pars_fragment: xz,
  opaque_fragment: _z,
  packing: Tz,
  premultiplied_alpha_fragment: Sz,
  project_vertex: wz,
  dithering_fragment: Ez,
  dithering_pars_fragment: Mz,
  roughnessmap_fragment: Az,
  roughnessmap_pars_fragment: Cz,
  shadowmap_pars_fragment: Rz,
  shadowmap_pars_vertex: Nz,
  shadowmap_vertex: Pz,
  shadowmask_pars_fragment: Iz,
  skinbase_vertex: Oz,
  skinning_pars_vertex: Dz,
  skinning_vertex: Lz,
  skinnormal_vertex: kz,
  specularmap_fragment: Uz,
  specularmap_pars_fragment: Fz,
  tonemapping_fragment: Bz,
  tonemapping_pars_fragment: zz,
  transmission_fragment: jz,
  transmission_pars_fragment: Vz,
  uv_pars_fragment: Gz,
  uv_pars_vertex: Hz,
  uv_vertex: Wz,
  worldpos_vertex: qz,
  background_vert: Xz,
  background_frag: $z,
  backgroundCube_vert: Yz,
  backgroundCube_frag: Kz,
  cube_vert: Zz,
  cube_frag: Qz,
  depth_vert: Jz,
  depth_frag: e4,
  distanceRGBA_vert: t4,
  distanceRGBA_frag: i4,
  equirect_vert: r4,
  equirect_frag: n4,
  linedashed_vert: s4,
  linedashed_frag: a4,
  meshbasic_vert: o4,
  meshbasic_frag: l4,
  meshlambert_vert: u4,
  meshlambert_frag: c4,
  meshmatcap_vert: h4,
  meshmatcap_frag: d4,
  meshnormal_vert: p4,
  meshnormal_frag: f4,
  meshphong_vert: m4,
  meshphong_frag: g4,
  meshphysical_vert: y4,
  meshphysical_frag: v4,
  meshtoon_vert: b4,
  meshtoon_frag: x4,
  points_vert: _4,
  points_frag: T4,
  shadow_vert: S4,
  shadow_frag: w4,
  sprite_vert: E4,
  sprite_frag: M4
}, je = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Ut(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new It() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new It() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new It() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new It() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new It() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new It() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new It() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new It() },
    normalScale: { value: /* @__PURE__ */ new ke(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new It() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new It() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new It() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new It() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Ut(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Ut(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new It() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new It() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Ut(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new ke(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new It() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new It() },
    alphaTest: { value: 0 }
  }
}, hs = {
  basic: {
    uniforms: /* @__PURE__ */ xr([
      je.common,
      je.specularmap,
      je.envmap,
      je.aomap,
      je.lightmap,
      je.fog
    ]),
    vertexShader: Rt.meshbasic_vert,
    fragmentShader: Rt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ xr([
      je.common,
      je.specularmap,
      je.envmap,
      je.aomap,
      je.lightmap,
      je.emissivemap,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      je.fog,
      je.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ut(0) }
      }
    ]),
    vertexShader: Rt.meshlambert_vert,
    fragmentShader: Rt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ xr([
      je.common,
      je.specularmap,
      je.envmap,
      je.aomap,
      je.lightmap,
      je.emissivemap,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      je.fog,
      je.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ut(0) },
        specular: { value: /* @__PURE__ */ new Ut(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Rt.meshphong_vert,
    fragmentShader: Rt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ xr([
      je.common,
      je.envmap,
      je.aomap,
      je.lightmap,
      je.emissivemap,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      je.roughnessmap,
      je.metalnessmap,
      je.fog,
      je.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ut(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Rt.meshphysical_vert,
    fragmentShader: Rt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ xr([
      je.common,
      je.aomap,
      je.lightmap,
      je.emissivemap,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      je.gradientmap,
      je.fog,
      je.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ut(0) }
      }
    ]),
    vertexShader: Rt.meshtoon_vert,
    fragmentShader: Rt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ xr([
      je.common,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      je.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Rt.meshmatcap_vert,
    fragmentShader: Rt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ xr([
      je.points,
      je.fog
    ]),
    vertexShader: Rt.points_vert,
    fragmentShader: Rt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ xr([
      je.common,
      je.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Rt.linedashed_vert,
    fragmentShader: Rt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ xr([
      je.common,
      je.displacementmap
    ]),
    vertexShader: Rt.depth_vert,
    fragmentShader: Rt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ xr([
      je.common,
      je.bumpmap,
      je.normalmap,
      je.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Rt.meshnormal_vert,
    fragmentShader: Rt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ xr([
      je.sprite,
      je.fog
    ]),
    vertexShader: Rt.sprite_vert,
    fragmentShader: Rt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new It() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Rt.background_vert,
    fragmentShader: Rt.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new It() }
    },
    vertexShader: Rt.backgroundCube_vert,
    fragmentShader: Rt.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Rt.cube_vert,
    fragmentShader: Rt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Rt.equirect_vert,
    fragmentShader: Rt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ xr([
      je.common,
      je.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new X() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Rt.distanceRGBA_vert,
    fragmentShader: Rt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ xr([
      je.lights,
      je.fog,
      {
        color: { value: /* @__PURE__ */ new Ut(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Rt.shadow_vert,
    fragmentShader: Rt.shadow_frag
  }
};
hs.physical = {
  uniforms: /* @__PURE__ */ xr([
    hs.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new It() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new It() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new ke(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new It() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new It() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new It() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Ut(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new It() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new It() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new It() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new ke() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new It() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Ut(0) },
      specularColor: { value: /* @__PURE__ */ new Ut(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new It() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new It() },
      anisotropyVector: { value: /* @__PURE__ */ new ke() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new It() }
    }
  ]),
  vertexShader: Rt.meshphysical_vert,
  fragmentShader: Rt.meshphysical_frag
};
const Np = { r: 0, b: 0, g: 0 }, Oo = /* @__PURE__ */ new yo(), A4 = /* @__PURE__ */ new ui();
function C4(r, e, i, n, s, a, o) {
  const l = new Ut(0);
  let u = a === !0 ? 0 : 1, c, h, d = null, p = 0, f = null;
  function m(_) {
    let x = _.isScene === !0 ? _.background : null;
    return x && x.isTexture && (x = (_.backgroundBlurriness > 0 ? i : e).get(x)), x;
  }
  function y(_) {
    let x = !1;
    const b = m(_);
    b === null ? g(l, u) : b && b.isColor && (g(b, 1), x = !0);
    const T = r.xr.getEnvironmentBlendMode();
    T === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : T === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (r.autoClear || x) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil));
  }
  function v(_, x) {
    const b = m(x);
    b && (b.isCubeTexture || b.mapping === xg) ? (h === void 0 && (h = new Lr(
      new k_(1, 1, 1),
      new xs({
        name: "BackgroundCubeMaterial",
        uniforms: gc(hs.backgroundCube.uniforms),
        vertexShader: hs.backgroundCube.vertexShader,
        fragmentShader: hs.backgroundCube.fragmentShader,
        side: Mr,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(T, S, w) {
      this.matrixWorld.copyPosition(w.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), s.update(h)), Oo.copy(x.backgroundRotation), Oo.x *= -1, Oo.y *= -1, Oo.z *= -1, b.isCubeTexture && b.isRenderTargetTexture === !1 && (Oo.y *= -1, Oo.z *= -1), h.material.uniforms.envMap.value = b, h.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = x.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(A4.makeRotationFromEuler(Oo)), h.material.toneMapped = Gt.getTransfer(b.colorSpace) !== ei, (d !== b || p !== b.version || f !== r.toneMapping) && (h.material.needsUpdate = !0, d = b, p = b.version, f = r.toneMapping), h.layers.enableAll(), _.unshift(h, h.geometry, h.material, 0, 0, null)) : b && b.isTexture && (c === void 0 && (c = new Lr(
      new Hd(2, 2),
      new xs({
        name: "BackgroundMaterial",
        uniforms: gc(hs.background.uniforms),
        vertexShader: hs.background.vertexShader,
        fragmentShader: hs.background.fragmentShader,
        side: mo,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), s.update(c)), c.material.uniforms.t2D.value = b, c.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, c.material.toneMapped = Gt.getTransfer(b.colorSpace) !== ei, b.matrixAutoUpdate === !0 && b.updateMatrix(), c.material.uniforms.uvTransform.value.copy(b.matrix), (d !== b || p !== b.version || f !== r.toneMapping) && (c.material.needsUpdate = !0, d = b, p = b.version, f = r.toneMapping), c.layers.enableAll(), _.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function g(_, x) {
    _.getRGB(Np, fR(r)), n.buffers.color.setClear(Np.r, Np.g, Np.b, x, o);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(_, x = 1) {
      l.set(_), u = x, g(l, u);
    },
    getClearAlpha: function() {
      return u;
    },
    setClearAlpha: function(_) {
      u = _, g(l, u);
    },
    render: y,
    addToRenderList: v
  };
}
function R4(r, e) {
  const i = r.getParameter(r.MAX_VERTEX_ATTRIBS), n = {}, s = p(null);
  let a = s, o = !1;
  function l(A, N, U, k, C) {
    let I = !1;
    const O = d(k, U, N);
    a !== O && (a = O, c(a.object)), I = f(A, k, U, C), I && m(A, k, U, C), C !== null && e.update(C, r.ELEMENT_ARRAY_BUFFER), (I || o) && (o = !1, b(A, N, U, k), C !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(C).buffer));
  }
  function u() {
    return r.createVertexArray();
  }
  function c(A) {
    return r.bindVertexArray(A);
  }
  function h(A) {
    return r.deleteVertexArray(A);
  }
  function d(A, N, U) {
    const k = U.wireframe === !0;
    let C = n[A.id];
    C === void 0 && (C = {}, n[A.id] = C);
    let I = C[N.id];
    I === void 0 && (I = {}, C[N.id] = I);
    let O = I[k];
    return O === void 0 && (O = p(u()), I[k] = O), O;
  }
  function p(A) {
    const N = [], U = [], k = [];
    for (let C = 0; C < i; C++)
      N[C] = 0, U[C] = 0, k[C] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: N,
      enabledAttributes: U,
      attributeDivisors: k,
      object: A,
      attributes: {},
      index: null
    };
  }
  function f(A, N, U, k) {
    const C = a.attributes, I = N.attributes;
    let O = 0;
    const W = U.getAttributes();
    for (const V in W)
      if (W[V].location >= 0) {
        const Q = C[V];
        let F = I[V];
        if (F === void 0 && (V === "instanceMatrix" && A.instanceMatrix && (F = A.instanceMatrix), V === "instanceColor" && A.instanceColor && (F = A.instanceColor)), Q === void 0 || Q.attribute !== F || F && Q.data !== F.data) return !0;
        O++;
      }
    return a.attributesNum !== O || a.index !== k;
  }
  function m(A, N, U, k) {
    const C = {}, I = N.attributes;
    let O = 0;
    const W = U.getAttributes();
    for (const V in W)
      if (W[V].location >= 0) {
        let Q = I[V];
        Q === void 0 && (V === "instanceMatrix" && A.instanceMatrix && (Q = A.instanceMatrix), V === "instanceColor" && A.instanceColor && (Q = A.instanceColor));
        const F = {};
        F.attribute = Q, Q && Q.data && (F.data = Q.data), C[V] = F, O++;
      }
    a.attributes = C, a.attributesNum = O, a.index = k;
  }
  function y() {
    const A = a.newAttributes;
    for (let N = 0, U = A.length; N < U; N++)
      A[N] = 0;
  }
  function v(A) {
    g(A, 0);
  }
  function g(A, N) {
    const U = a.newAttributes, k = a.enabledAttributes, C = a.attributeDivisors;
    U[A] = 1, k[A] === 0 && (r.enableVertexAttribArray(A), k[A] = 1), C[A] !== N && (r.vertexAttribDivisor(A, N), C[A] = N);
  }
  function _() {
    const A = a.newAttributes, N = a.enabledAttributes;
    for (let U = 0, k = N.length; U < k; U++)
      N[U] !== A[U] && (r.disableVertexAttribArray(U), N[U] = 0);
  }
  function x(A, N, U, k, C, I, O) {
    O === !0 ? r.vertexAttribIPointer(A, N, U, C, I) : r.vertexAttribPointer(A, N, U, k, C, I);
  }
  function b(A, N, U, k) {
    y();
    const C = k.attributes, I = U.getAttributes(), O = N.defaultAttributeValues;
    for (const W in I) {
      const V = I[W];
      if (V.location >= 0) {
        let Q = C[W];
        if (Q === void 0 && (W === "instanceMatrix" && A.instanceMatrix && (Q = A.instanceMatrix), W === "instanceColor" && A.instanceColor && (Q = A.instanceColor)), Q !== void 0) {
          const F = Q.normalized, B = Q.itemSize, q = e.get(Q);
          if (q === void 0) continue;
          const G = q.buffer, z = q.type, Y = q.bytesPerElement, se = z === r.INT || z === r.UNSIGNED_INT || Q.gpuType === C_;
          if (Q.isInterleavedBufferAttribute) {
            const ne = Q.data, fe = ne.stride, Se = Q.offset;
            if (ne.isInstancedInterleavedBuffer) {
              for (let Pe = 0; Pe < V.locationSize; Pe++)
                g(V.location + Pe, ne.meshPerAttribute);
              A.isInstancedMesh !== !0 && k._maxInstanceCount === void 0 && (k._maxInstanceCount = ne.meshPerAttribute * ne.count);
            } else
              for (let Pe = 0; Pe < V.locationSize; Pe++)
                v(V.location + Pe);
            r.bindBuffer(r.ARRAY_BUFFER, G);
            for (let Pe = 0; Pe < V.locationSize; Pe++)
              x(
                V.location + Pe,
                B / V.locationSize,
                z,
                F,
                fe * Y,
                (Se + B / V.locationSize * Pe) * Y,
                se
              );
          } else {
            if (Q.isInstancedBufferAttribute) {
              for (let ne = 0; ne < V.locationSize; ne++)
                g(V.location + ne, Q.meshPerAttribute);
              A.isInstancedMesh !== !0 && k._maxInstanceCount === void 0 && (k._maxInstanceCount = Q.meshPerAttribute * Q.count);
            } else
              for (let ne = 0; ne < V.locationSize; ne++)
                v(V.location + ne);
            r.bindBuffer(r.ARRAY_BUFFER, G);
            for (let ne = 0; ne < V.locationSize; ne++)
              x(
                V.location + ne,
                B / V.locationSize,
                z,
                F,
                B * Y,
                B / V.locationSize * ne * Y,
                se
              );
          }
        } else if (O !== void 0) {
          const F = O[W];
          if (F !== void 0)
            switch (F.length) {
              case 2:
                r.vertexAttrib2fv(V.location, F);
                break;
              case 3:
                r.vertexAttrib3fv(V.location, F);
                break;
              case 4:
                r.vertexAttrib4fv(V.location, F);
                break;
              default:
                r.vertexAttrib1fv(V.location, F);
            }
        }
      }
    }
    _();
  }
  function T() {
    M();
    for (const A in n) {
      const N = n[A];
      for (const U in N) {
        const k = N[U];
        for (const C in k)
          h(k[C].object), delete k[C];
        delete N[U];
      }
      delete n[A];
    }
  }
  function S(A) {
    if (n[A.id] === void 0) return;
    const N = n[A.id];
    for (const U in N) {
      const k = N[U];
      for (const C in k)
        h(k[C].object), delete k[C];
      delete N[U];
    }
    delete n[A.id];
  }
  function w(A) {
    for (const N in n) {
      const U = n[N];
      if (U[A.id] === void 0) continue;
      const k = U[A.id];
      for (const C in k)
        h(k[C].object), delete k[C];
      delete U[A.id];
    }
  }
  function M() {
    E(), o = !0, a !== s && (a = s, c(a.object));
  }
  function E() {
    s.geometry = null, s.program = null, s.wireframe = !1;
  }
  return {
    setup: l,
    reset: M,
    resetDefaultState: E,
    dispose: T,
    releaseStatesOfGeometry: S,
    releaseStatesOfProgram: w,
    initAttributes: y,
    enableAttribute: v,
    disableUnusedAttributes: _
  };
}
function N4(r, e, i) {
  let n;
  function s(c) {
    n = c;
  }
  function a(c, h) {
    r.drawArrays(n, c, h), i.update(h, n, 1);
  }
  function o(c, h, d) {
    d !== 0 && (r.drawArraysInstanced(n, c, h, d), i.update(h, n, d));
  }
  function l(c, h, d) {
    if (d === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, h, 0, d);
    let p = 0;
    for (let f = 0; f < d; f++)
      p += h[f];
    i.update(p, n, 1);
  }
  function u(c, h, d, p) {
    if (d === 0) return;
    const f = e.get("WEBGL_multi_draw");
    if (f === null)
      for (let m = 0; m < c.length; m++)
        o(c[m], h[m], p[m]);
    else {
      f.multiDrawArraysInstancedWEBGL(n, c, 0, h, 0, p, 0, d);
      let m = 0;
      for (let y = 0; y < d; y++)
        m += h[y] * p[y];
      i.update(m, n, 1);
    }
  }
  this.setMode = s, this.render = a, this.renderInstances = o, this.renderMultiDraw = l, this.renderMultiDrawInstances = u;
}
function P4(r, e, i, n) {
  let s;
  function a() {
    if (s !== void 0) return s;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const w = e.get("EXT_texture_filter_anisotropic");
      s = r.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      s = 0;
    return s;
  }
  function o(w) {
    return !(w !== Xn && n.convert(w) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function l(w) {
    const M = w === Lc && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(w !== ba && n.convert(w) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    w !== ra && !M);
  }
  function u(w) {
    if (w === "highp") {
      if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
        return "highp";
      w = "mediump";
    }
    return w === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let c = i.precision !== void 0 ? i.precision : "highp";
  const h = u(c);
  h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
  const d = i.logarithmicDepthBuffer === !0, p = i.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), f = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), m = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), y = r.getParameter(r.MAX_TEXTURE_SIZE), v = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), g = r.getParameter(r.MAX_VERTEX_ATTRIBS), _ = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), x = r.getParameter(r.MAX_VARYING_VECTORS), b = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), T = m > 0, S = r.getParameter(r.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: a,
    getMaxPrecision: u,
    textureFormatReadable: o,
    textureTypeReadable: l,
    precision: c,
    logarithmicDepthBuffer: d,
    reverseDepthBuffer: p,
    maxTextures: f,
    maxVertexTextures: m,
    maxTextureSize: y,
    maxCubemapSize: v,
    maxAttributes: g,
    maxVertexUniforms: _,
    maxVaryings: x,
    maxFragmentUniforms: b,
    vertexTextures: T,
    maxSamples: S
  };
}
function I4(r) {
  const e = this;
  let i = null, n = 0, s = !1, a = !1;
  const o = new qs(), l = new It(), u = { value: null, needsUpdate: !1 };
  this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, p) {
    const f = d.length !== 0 || p || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || s;
    return s = p, n = d.length, f;
  }, this.beginShadows = function() {
    a = !0, h(null);
  }, this.endShadows = function() {
    a = !1;
  }, this.setGlobalState = function(d, p) {
    i = h(d, p, 0);
  }, this.setState = function(d, p, f) {
    const m = d.clippingPlanes, y = d.clipIntersection, v = d.clipShadows, g = r.get(d);
    if (!s || m === null || m.length === 0 || a && !v)
      a ? h(null) : c();
    else {
      const _ = a ? 0 : n, x = _ * 4;
      let b = g.clippingState || null;
      u.value = b, b = h(m, p, x, f);
      for (let T = 0; T !== x; ++T)
        b[T] = i[T];
      g.clippingState = b, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += _;
    }
  };
  function c() {
    u.value !== i && (u.value = i, u.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function h(d, p, f, m) {
    const y = d !== null ? d.length : 0;
    let v = null;
    if (y !== 0) {
      if (v = u.value, m !== !0 || v === null) {
        const g = f + y * 4, _ = p.matrixWorldInverse;
        l.getNormalMatrix(_), (v === null || v.length < g) && (v = new Float32Array(g));
        for (let x = 0, b = f; x !== y; ++x, b += 4)
          o.copy(d[x]).applyMatrix4(_, l), o.normal.toArray(v, b), v[b + 3] = o.constant;
      }
      u.value = v, u.needsUpdate = !0;
    }
    return e.numPlanes = y, e.numIntersection = 0, v;
  }
}
function O4(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function i(o, l) {
    return l === ab ? o.mapping = dc : l === ob && (o.mapping = pc), o;
  }
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping;
      if (l === ab || l === ob)
        if (e.has(o)) {
          const u = e.get(o).texture;
          return i(u, o.mapping);
        } else {
          const u = o.image;
          if (u && u.height > 0) {
            const c = new H5(u.height);
            return c.fromEquirectangularTexture(r, o), e.set(o, c), o.addEventListener("dispose", s), i(c.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function s(o) {
    const l = o.target;
    l.removeEventListener("dispose", s);
    const u = e.get(l);
    u !== void 0 && (e.delete(l), u.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: a
  };
}
let F_ = class extends gR {
  constructor(r = -1, e = 1, i = 1, n = -1, s = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = r, this.right = e, this.top = i, this.bottom = n, this.near = s, this.far = a, this.updateProjectionMatrix();
  }
  copy(r, e) {
    return super.copy(r, e), this.left = r.left, this.right = r.right, this.top = r.top, this.bottom = r.bottom, this.near = r.near, this.far = r.far, this.zoom = r.zoom, this.view = r.view === null ? null : Object.assign({}, r.view), this;
  }
  setViewOffset(r, e, i, n, s, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = r, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const r = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
    let s = i - r, a = i + r, o = n + e, l = n - e;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += u * this.view.offsetX, a = s + u * this.view.width, o -= c * this.view.offsetY, l = o - c * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
};
const Iu = 4, JS = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Yo = 20, Gy = /* @__PURE__ */ new F_(), ew = /* @__PURE__ */ new Ut();
let Hy = null, Wy = 0, qy = 0, Xy = !1;
const Vo = (1 + Math.sqrt(5)) / 2, Jl = 1 / Vo, tw = [
  /* @__PURE__ */ new X(-Vo, Jl, 0),
  /* @__PURE__ */ new X(Vo, Jl, 0),
  /* @__PURE__ */ new X(-Jl, 0, Vo),
  /* @__PURE__ */ new X(Jl, 0, Vo),
  /* @__PURE__ */ new X(0, Vo, -Jl),
  /* @__PURE__ */ new X(0, Vo, Jl),
  /* @__PURE__ */ new X(-1, 1, -1),
  /* @__PURE__ */ new X(1, 1, -1),
  /* @__PURE__ */ new X(-1, 1, 1),
  /* @__PURE__ */ new X(1, 1, 1)
];
let iw = class {
  constructor(r) {
    this._renderer = r, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(r, e = 0, i = 0.1, n = 100) {
    Hy = this._renderer.getRenderTarget(), Wy = this._renderer.getActiveCubeFace(), qy = this._renderer.getActiveMipmapLevel(), Xy = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(r, i, n, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(r, e = null) {
    return this._fromTexture(r, e);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(r, e = null) {
    return this._fromTexture(r, e);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = sw(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = nw(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(r) {
    this._lodMax = Math.floor(Math.log2(r)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let r = 0; r < this._lodPlanes.length; r++)
      this._lodPlanes[r].dispose();
  }
  _cleanup(r) {
    this._renderer.setRenderTarget(Hy, Wy, qy), this._renderer.xr.enabled = Xy, r.scissorTest = !1, Pp(r, 0, 0, r.width, r.height);
  }
  _fromTexture(r, e) {
    r.mapping === dc || r.mapping === pc ? this._setSize(r.image.length === 0 ? 16 : r.image[0].width || r.image[0].image.width) : this._setSize(r.image.width / 4), Hy = this._renderer.getRenderTarget(), Wy = this._renderer.getActiveCubeFace(), qy = this._renderer.getActiveMipmapLevel(), Xy = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const i = e || this._allocateTargets();
    return this._textureToCubeUV(r, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const r = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, i = {
      magFilter: ds,
      minFilter: ds,
      generateMipmaps: !1,
      type: Lc,
      format: Xn,
      colorSpace: kc,
      depthBuffer: !1
    }, n = rw(r, e, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== r || this._pingPongRenderTarget.height !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = rw(r, e, i);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = D4(s)), this._blurMaterial = L4(s, r, e);
    }
    return n;
  }
  _compileMaterial(r) {
    const e = new Lr(this._lodPlanes[0], r);
    this._renderer.compile(e, Gy);
  }
  _sceneToCubeUV(r, e, i, n) {
    const s = new yn(90, 1, e, i), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], l = this._renderer, u = l.autoClear, c = l.toneMapping;
    l.getClearColor(ew), l.toneMapping = lo, l.autoClear = !1;
    const h = new wg({
      name: "PMREM.Background",
      side: Mr,
      depthWrite: !1,
      depthTest: !1
    }), d = new Lr(new k_(), h);
    let p = !1;
    const f = r.background;
    f ? f.isColor && (h.color.copy(f), r.background = null, p = !0) : (h.color.copy(ew), p = !0);
    for (let m = 0; m < 6; m++) {
      const y = m % 3;
      y === 0 ? (s.up.set(0, a[m], 0), s.lookAt(o[m], 0, 0)) : y === 1 ? (s.up.set(0, 0, a[m]), s.lookAt(0, o[m], 0)) : (s.up.set(0, a[m], 0), s.lookAt(0, 0, o[m]));
      const v = this._cubeSize;
      Pp(n, y * v, m > 2 ? v : 0, v, v), l.setRenderTarget(n), p && l.render(d, s), l.render(r, s);
    }
    d.geometry.dispose(), d.material.dispose(), l.toneMapping = c, l.autoClear = u, r.background = f;
  }
  _textureToCubeUV(r, e) {
    const i = this._renderer, n = r.mapping === dc || r.mapping === pc;
    n ? (this._cubemapMaterial === null && (this._cubemapMaterial = sw()), this._cubemapMaterial.uniforms.flipEnvMap.value = r.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = nw());
    const s = n ? this._cubemapMaterial : this._equirectMaterial, a = new Lr(this._lodPlanes[0], s), o = s.uniforms;
    o.envMap.value = r;
    const l = this._cubeSize;
    Pp(e, 0, 0, 3 * l, 2 * l), i.setRenderTarget(e), i.render(a, Gy);
  }
  _applyPMREM(r) {
    const e = this._renderer, i = e.autoClear;
    e.autoClear = !1;
    const n = this._lodPlanes.length;
    for (let s = 1; s < n; s++) {
      const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]), o = tw[(n - s - 1) % tw.length];
      this._blur(r, s - 1, s, a, o);
    }
    e.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(r, e, i, n, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      r,
      a,
      e,
      i,
      n,
      "latitudinal",
      s
    ), this._halfBlur(
      a,
      r,
      i,
      i,
      n,
      "longitudinal",
      s
    );
  }
  _halfBlur(r, e, i, n, s, a, o) {
    const l = this._renderer, u = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const c = 3, h = new Lr(this._lodPlanes[n], u), d = u.uniforms, p = this._sizeLods[i] - 1, f = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * Yo - 1), m = s / f, y = isFinite(s) ? 1 + Math.floor(c * m) : Yo;
    y > Yo && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${Yo}`);
    const v = [];
    let g = 0;
    for (let S = 0; S < Yo; ++S) {
      const w = S / m, M = Math.exp(-w * w / 2);
      v.push(M), S === 0 ? g += M : S < y && (g += 2 * M);
    }
    for (let S = 0; S < v.length; S++)
      v[S] = v[S] / g;
    d.envMap.value = r.texture, d.samples.value = y, d.weights.value = v, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
    const { _lodMax: _ } = this;
    d.dTheta.value = f, d.mipInt.value = _ - i;
    const x = this._sizeLods[n], b = 3 * x * (n > _ - Iu ? n - _ + Iu : 0), T = 4 * (this._cubeSize - x);
    Pp(e, b, T, 3 * x, 2 * x), l.setRenderTarget(e), l.render(h, Gy);
  }
};
function D4(r) {
  const e = [], i = [], n = [];
  let s = r;
  const a = r - Iu + 1 + JS.length;
  for (let o = 0; o < a; o++) {
    const l = Math.pow(2, s);
    i.push(l);
    let u = 1 / l;
    o > r - Iu ? u = JS[o - r + Iu - 1] : o === 0 && (u = 0), n.push(u);
    const c = 1 / (l - 2), h = -c, d = 1 + c, p = [h, h, d, h, d, d, h, h, d, d, h, d], f = 6, m = 6, y = 3, v = 2, g = 1, _ = new Float32Array(y * m * f), x = new Float32Array(v * m * f), b = new Float32Array(g * m * f);
    for (let S = 0; S < f; S++) {
      const w = S % 3 * 2 / 3 - 1, M = S > 2 ? 0 : -1, E = [
        w,
        M,
        0,
        w + 2 / 3,
        M,
        0,
        w + 2 / 3,
        M + 1,
        0,
        w,
        M,
        0,
        w + 2 / 3,
        M + 1,
        0,
        w,
        M + 1,
        0
      ];
      _.set(E, y * m * S), x.set(p, v * m * S);
      const A = [S, S, S, S, S, S];
      b.set(A, g * m * S);
    }
    const T = new un();
    T.setAttribute("position", new xn(_, y)), T.setAttribute("uv", new xn(x, v)), T.setAttribute("faceIndex", new xn(b, g)), e.push(T), s > Iu && s--;
  }
  return { lodPlanes: e, sizeLods: i, sigmas: n };
}
function rw(r, e, i) {
  const n = new go(r, e, i);
  return n.texture.mapping = xg, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function Pp(r, e, i, n, s) {
  r.viewport.set(e, i, n, s), r.scissor.set(e, i, n, s);
}
function L4(r, e, i) {
  const n = new Float32Array(Yo), s = new X(0, 1, 0);
  return new xs({
    name: "SphericalGaussianBlur",
    defines: {
      n: Yo,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / i,
      CUBEUV_MAX_MIP: `${r}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: s }
    },
    vertexShader: B_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: la,
    depthTest: !1,
    depthWrite: !1
  });
}
function nw() {
  return new xs({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: B_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: la,
    depthTest: !1,
    depthWrite: !1
  });
}
function sw() {
  return new xs({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: B_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: la,
    depthTest: !1,
    depthWrite: !1
  });
}
function B_() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function k4(r) {
  let e = /* @__PURE__ */ new WeakMap(), i = null;
  function n(l) {
    if (l && l.isTexture) {
      const u = l.mapping, c = u === ab || u === ob, h = u === dc || u === pc;
      if (c || h) {
        let d = e.get(l);
        const p = d !== void 0 ? d.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== p)
          return i === null && (i = new iw(r)), d = c ? i.fromEquirectangular(l, d) : i.fromCubemap(l, d), d.texture.pmremVersion = l.pmremVersion, e.set(l, d), d.texture;
        if (d !== void 0)
          return d.texture;
        {
          const f = l.image;
          return c && f && f.height > 0 || h && f && s(f) ? (i === null && (i = new iw(r)), d = c ? i.fromEquirectangular(l) : i.fromCubemap(l), d.texture.pmremVersion = l.pmremVersion, e.set(l, d), l.addEventListener("dispose", a), d.texture) : null;
        }
      }
    }
    return l;
  }
  function s(l) {
    let u = 0;
    const c = 6;
    for (let h = 0; h < c; h++)
      l[h] !== void 0 && u++;
    return u === c;
  }
  function a(l) {
    const u = l.target;
    u.removeEventListener("dispose", a);
    const c = e.get(u);
    c !== void 0 && (e.delete(u), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), i !== null && (i.dispose(), i = null);
  }
  return {
    get: n,
    dispose: o
  };
}
function U4(r) {
  const e = {};
  function i(n) {
    if (e[n] !== void 0)
      return e[n];
    let s;
    switch (n) {
      case "WEBGL_depth_texture":
        s = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        s = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        s = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        s = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        s = r.getExtension(n);
    }
    return e[n] = s, s;
  }
  return {
    has: function(n) {
      return i(n) !== null;
    },
    init: function() {
      i("EXT_color_buffer_float"), i("WEBGL_clip_cull_distance"), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float"), i("WEBGL_multisampled_render_to_texture"), i("WEBGL_render_shared_exponent");
    },
    get: function(n) {
      const s = i(n);
      return s === null && Fh("THREE.WebGLRenderer: " + n + " extension not supported."), s;
    }
  };
}
function F4(r, e, i, n) {
  const s = {}, a = /* @__PURE__ */ new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const m in p.attributes)
      e.remove(p.attributes[m]);
    for (const m in p.morphAttributes) {
      const y = p.morphAttributes[m];
      for (let v = 0, g = y.length; v < g; v++)
        e.remove(y[v]);
    }
    p.removeEventListener("dispose", o), delete s[p.id];
    const f = a.get(p);
    f && (e.remove(f), a.delete(p)), n.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, i.memory.geometries--;
  }
  function l(d, p) {
    return s[p.id] === !0 || (p.addEventListener("dispose", o), s[p.id] = !0, i.memory.geometries++), p;
  }
  function u(d) {
    const p = d.attributes;
    for (const m in p)
      e.update(p[m], r.ARRAY_BUFFER);
    const f = d.morphAttributes;
    for (const m in f) {
      const y = f[m];
      for (let v = 0, g = y.length; v < g; v++)
        e.update(y[v], r.ARRAY_BUFFER);
    }
  }
  function c(d) {
    const p = [], f = d.index, m = d.attributes.position;
    let y = 0;
    if (f !== null) {
      const _ = f.array;
      y = f.version;
      for (let x = 0, b = _.length; x < b; x += 3) {
        const T = _[x + 0], S = _[x + 1], w = _[x + 2];
        p.push(T, S, S, w, w, T);
      }
    } else if (m !== void 0) {
      const _ = m.array;
      y = m.version;
      for (let x = 0, b = _.length / 3 - 1; x < b; x += 3) {
        const T = x + 0, S = x + 1, w = x + 2;
        p.push(T, S, S, w, w, T);
      }
    } else
      return;
    const v = new (rR(p) ? hR : cR)(p, 1);
    v.version = y;
    const g = a.get(d);
    g && e.remove(g), a.set(d, v);
  }
  function h(d) {
    const p = a.get(d);
    if (p) {
      const f = d.index;
      f !== null && p.version < f.version && c(d);
    } else
      c(d);
    return a.get(d);
  }
  return {
    get: l,
    update: u,
    getWireframeAttribute: h
  };
}
function B4(r, e, i) {
  let n;
  function s(p) {
    n = p;
  }
  let a, o;
  function l(p) {
    a = p.type, o = p.bytesPerElement;
  }
  function u(p, f) {
    r.drawElements(n, f, a, p * o), i.update(f, n, 1);
  }
  function c(p, f, m) {
    m !== 0 && (r.drawElementsInstanced(n, f, a, p * o, m), i.update(f, n, m));
  }
  function h(p, f, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, f, 0, a, p, 0, m);
    let y = 0;
    for (let v = 0; v < m; v++)
      y += f[v];
    i.update(y, n, 1);
  }
  function d(p, f, m, y) {
    if (m === 0) return;
    const v = e.get("WEBGL_multi_draw");
    if (v === null)
      for (let g = 0; g < p.length; g++)
        c(p[g] / o, f[g], y[g]);
    else {
      v.multiDrawElementsInstancedWEBGL(n, f, 0, a, p, 0, y, 0, m);
      let g = 0;
      for (let _ = 0; _ < m; _++)
        g += f[_] * y[_];
      i.update(g, n, 1);
    }
  }
  this.setMode = s, this.setIndex = l, this.render = u, this.renderInstances = c, this.renderMultiDraw = h, this.renderMultiDrawInstances = d;
}
function z4(r) {
  const e = {
    geometries: 0,
    textures: 0
  }, i = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(a, o, l) {
    switch (i.calls++, o) {
      case r.TRIANGLES:
        i.triangles += l * (a / 3);
        break;
      case r.LINES:
        i.lines += l * (a / 2);
        break;
      case r.LINE_STRIP:
        i.lines += l * (a - 1);
        break;
      case r.LINE_LOOP:
        i.lines += l * a;
        break;
      case r.POINTS:
        i.points += l * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function s() {
    i.calls = 0, i.triangles = 0, i.points = 0, i.lines = 0;
  }
  return {
    memory: e,
    render: i,
    programs: null,
    autoReset: !0,
    reset: s,
    update: n
  };
}
function j4(r, e, i) {
  const n = /* @__PURE__ */ new WeakMap(), s = new Fi();
  function a(o, l, u) {
    const c = o.morphTargetInfluences, h = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color, d = h !== void 0 ? h.length : 0;
    let p = n.get(l);
    if (p === void 0 || p.count !== d) {
      let f = function() {
        M.dispose(), n.delete(l), l.removeEventListener("dispose", f);
      };
      p !== void 0 && p.texture.dispose();
      const m = l.morphAttributes.position !== void 0, y = l.morphAttributes.normal !== void 0, v = l.morphAttributes.color !== void 0, g = l.morphAttributes.position || [], _ = l.morphAttributes.normal || [], x = l.morphAttributes.color || [];
      let b = 0;
      m === !0 && (b = 1), y === !0 && (b = 2), v === !0 && (b = 3);
      let T = l.attributes.position.count * b, S = 1;
      T > e.maxTextureSize && (S = Math.ceil(T / e.maxTextureSize), T = e.maxTextureSize);
      const w = new Float32Array(T * S * 4 * d), M = new aR(w, T, S, d);
      M.type = ra, M.needsUpdate = !0;
      const E = b * 4;
      for (let A = 0; A < d; A++) {
        const N = g[A], U = _[A], k = x[A], C = T * S * 4 * A;
        for (let I = 0; I < N.count; I++) {
          const O = I * E;
          m === !0 && (s.fromBufferAttribute(N, I), w[C + O + 0] = s.x, w[C + O + 1] = s.y, w[C + O + 2] = s.z, w[C + O + 3] = 0), y === !0 && (s.fromBufferAttribute(U, I), w[C + O + 4] = s.x, w[C + O + 5] = s.y, w[C + O + 6] = s.z, w[C + O + 7] = 0), v === !0 && (s.fromBufferAttribute(k, I), w[C + O + 8] = s.x, w[C + O + 9] = s.y, w[C + O + 10] = s.z, w[C + O + 11] = k.itemSize === 4 ? s.w : 1);
        }
      }
      p = {
        count: d,
        texture: M,
        size: new ke(T, S)
      }, n.set(l, p), l.addEventListener("dispose", f);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      u.getUniforms().setValue(r, "morphTexture", o.morphTexture, i);
    else {
      let f = 0;
      for (let y = 0; y < c.length; y++)
        f += c[y];
      const m = l.morphTargetsRelative ? 1 : 1 - f;
      u.getUniforms().setValue(r, "morphTargetBaseInfluence", m), u.getUniforms().setValue(r, "morphTargetInfluences", c);
    }
    u.getUniforms().setValue(r, "morphTargetsTexture", p.texture, i), u.getUniforms().setValue(r, "morphTargetsTextureSize", p.size);
  }
  return {
    update: a
  };
}
function V4(r, e, i, n) {
  let s = /* @__PURE__ */ new WeakMap();
  function a(u) {
    const c = n.render.frame, h = u.geometry, d = e.get(u, h);
    if (s.get(d) !== c && (e.update(d), s.set(d, c)), u.isInstancedMesh && (u.hasEventListener("dispose", l) === !1 && u.addEventListener("dispose", l), s.get(u) !== c && (i.update(u.instanceMatrix, r.ARRAY_BUFFER), u.instanceColor !== null && i.update(u.instanceColor, r.ARRAY_BUFFER), s.set(u, c))), u.isSkinnedMesh) {
      const p = u.skeleton;
      s.get(p) !== c && (p.update(), s.set(p, c));
    }
    return d;
  }
  function o() {
    s = /* @__PURE__ */ new WeakMap();
  }
  function l(u) {
    const c = u.target;
    c.removeEventListener("dispose", l), i.remove(c.instanceMatrix), c.instanceColor !== null && i.remove(c.instanceColor);
  }
  return {
    update: a,
    dispose: o
  };
}
let bR = class extends wn {
  constructor(r, e, i, n, s, a, o, l, u, c = Hu) {
    if (c !== Hu && c !== mc)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && c === Hu && (i = xl), i === void 0 && c === mc && (i = fc), super(null, n, s, a, o, l, c, i, u), this.isDepthTexture = !0, this.image = { width: r, height: e }, this.magFilter = o !== void 0 ? o : Kn, this.minFilter = l !== void 0 ? l : Kn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(r) {
    return super.copy(r), this.compareFunction = r.compareFunction, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
  }
};
const xR = /* @__PURE__ */ new wn(), aw = /* @__PURE__ */ new bR(1, 1), _R = /* @__PURE__ */ new aR(), TR = /* @__PURE__ */ new R5(), SR = /* @__PURE__ */ new yR(), ow = [], lw = [], uw = new Float32Array(16), cw = new Float32Array(9), hw = new Float32Array(4);
function Uc(r, e, i) {
  const n = r[0];
  if (n <= 0 || n > 0) return r;
  const s = e * i;
  let a = ow[s];
  if (a === void 0 && (a = new Float32Array(s), ow[s] = a), e !== 0) {
    n.toArray(a, 0);
    for (let o = 1, l = 0; o !== e; ++o)
      l += i, r[o].toArray(a, l);
  }
  return a;
}
function Gi(r, e) {
  if (r.length !== e.length) return !1;
  for (let i = 0, n = r.length; i < n; i++)
    if (r[i] !== e[i]) return !1;
  return !0;
}
function Hi(r, e) {
  for (let i = 0, n = e.length; i < n; i++)
    r[i] = e[i];
}
function Eg(r, e) {
  let i = lw[e];
  i === void 0 && (i = new Int32Array(e), lw[e] = i);
  for (let n = 0; n !== e; ++n)
    i[n] = r.allocateTextureUnit();
  return i;
}
function G4(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1f(this.addr, e), i[0] = e);
}
function H4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Gi(i, e)) return;
    r.uniform2fv(this.addr, e), Hi(i, e);
  }
}
function W4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else if (e.r !== void 0)
    (i[0] !== e.r || i[1] !== e.g || i[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
  else {
    if (Gi(i, e)) return;
    r.uniform3fv(this.addr, e), Hi(i, e);
  }
}
function q4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Gi(i, e)) return;
    r.uniform4fv(this.addr, e), Hi(i, e);
  }
}
function X4(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Gi(i, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), Hi(i, e);
  } else {
    if (Gi(i, n)) return;
    hw.set(n), r.uniformMatrix2fv(this.addr, !1, hw), Hi(i, n);
  }
}
function $4(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Gi(i, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), Hi(i, e);
  } else {
    if (Gi(i, n)) return;
    cw.set(n), r.uniformMatrix3fv(this.addr, !1, cw), Hi(i, n);
  }
}
function Y4(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Gi(i, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), Hi(i, e);
  } else {
    if (Gi(i, n)) return;
    uw.set(n), r.uniformMatrix4fv(this.addr, !1, uw), Hi(i, n);
  }
}
function K4(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1i(this.addr, e), i[0] = e);
}
function Z4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Gi(i, e)) return;
    r.uniform2iv(this.addr, e), Hi(i, e);
  }
}
function Q4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else {
    if (Gi(i, e)) return;
    r.uniform3iv(this.addr, e), Hi(i, e);
  }
}
function J4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Gi(i, e)) return;
    r.uniform4iv(this.addr, e), Hi(i, e);
  }
}
function e6(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1ui(this.addr, e), i[0] = e);
}
function t6(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Gi(i, e)) return;
    r.uniform2uiv(this.addr, e), Hi(i, e);
  }
}
function i6(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else {
    if (Gi(i, e)) return;
    r.uniform3uiv(this.addr, e), Hi(i, e);
  }
}
function r6(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Gi(i, e)) return;
    r.uniform4uiv(this.addr, e), Hi(i, e);
  }
}
function n6(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s);
  let a;
  this.type === r.SAMPLER_2D_SHADOW ? (aw.compareFunction = eR, a = aw) : a = xR, i.setTexture2D(e || a, s);
}
function s6(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTexture3D(e || TR, s);
}
function a6(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTextureCube(e || SR, s);
}
function o6(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTexture2DArray(e || _R, s);
}
function l6(r) {
  switch (r) {
    case 5126:
      return G4;
    case 35664:
      return H4;
    case 35665:
      return W4;
    case 35666:
      return q4;
    case 35674:
      return X4;
    case 35675:
      return $4;
    case 35676:
      return Y4;
    case 5124:
    case 35670:
      return K4;
    case 35667:
    case 35671:
      return Z4;
    case 35668:
    case 35672:
      return Q4;
    case 35669:
    case 35673:
      return J4;
    case 5125:
      return e6;
    case 36294:
      return t6;
    case 36295:
      return i6;
    case 36296:
      return r6;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return n6;
    case 35679:
    case 36299:
    case 36307:
      return s6;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return a6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return o6;
  }
}
function u6(r, e) {
  r.uniform1fv(this.addr, e);
}
function c6(r, e) {
  const i = Uc(e, this.size, 2);
  r.uniform2fv(this.addr, i);
}
function h6(r, e) {
  const i = Uc(e, this.size, 3);
  r.uniform3fv(this.addr, i);
}
function d6(r, e) {
  const i = Uc(e, this.size, 4);
  r.uniform4fv(this.addr, i);
}
function p6(r, e) {
  const i = Uc(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, i);
}
function f6(r, e) {
  const i = Uc(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, i);
}
function m6(r, e) {
  const i = Uc(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, i);
}
function g6(r, e) {
  r.uniform1iv(this.addr, e);
}
function y6(r, e) {
  r.uniform2iv(this.addr, e);
}
function v6(r, e) {
  r.uniform3iv(this.addr, e);
}
function b6(r, e) {
  r.uniform4iv(this.addr, e);
}
function x6(r, e) {
  r.uniform1uiv(this.addr, e);
}
function _6(r, e) {
  r.uniform2uiv(this.addr, e);
}
function T6(r, e) {
  r.uniform3uiv(this.addr, e);
}
function S6(r, e) {
  r.uniform4uiv(this.addr, e);
}
function w6(r, e, i) {
  const n = this.cache, s = e.length, a = Eg(i, s);
  Gi(n, a) || (r.uniform1iv(this.addr, a), Hi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture2D(e[o] || xR, a[o]);
}
function E6(r, e, i) {
  const n = this.cache, s = e.length, a = Eg(i, s);
  Gi(n, a) || (r.uniform1iv(this.addr, a), Hi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture3D(e[o] || TR, a[o]);
}
function M6(r, e, i) {
  const n = this.cache, s = e.length, a = Eg(i, s);
  Gi(n, a) || (r.uniform1iv(this.addr, a), Hi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTextureCube(e[o] || SR, a[o]);
}
function A6(r, e, i) {
  const n = this.cache, s = e.length, a = Eg(i, s);
  Gi(n, a) || (r.uniform1iv(this.addr, a), Hi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture2DArray(e[o] || _R, a[o]);
}
function C6(r) {
  switch (r) {
    case 5126:
      return u6;
    case 35664:
      return c6;
    case 35665:
      return h6;
    case 35666:
      return d6;
    case 35674:
      return p6;
    case 35675:
      return f6;
    case 35676:
      return m6;
    case 5124:
    case 35670:
      return g6;
    case 35667:
    case 35671:
      return y6;
    case 35668:
    case 35672:
      return v6;
    case 35669:
    case 35673:
      return b6;
    case 5125:
      return x6;
    case 36294:
      return _6;
    case 36295:
      return T6;
    case 36296:
      return S6;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return w6;
    case 35679:
    case 36299:
    case 36307:
      return E6;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return M6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return A6;
  }
}
class R6 {
  constructor(e, i, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = i.type, this.setValue = l6(i.type);
  }
}
class N6 {
  constructor(e, i, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = i.type, this.size = i.size, this.setValue = C6(i.type);
  }
}
class P6 {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, i, n) {
    const s = this.seq;
    for (let a = 0, o = s.length; a !== o; ++a) {
      const l = s[a];
      l.setValue(e, i[l.id], n);
    }
  }
}
const $y = /(\w+)(\])?(\[|\.)?/g;
function dw(r, e) {
  r.seq.push(e), r.map[e.id] = e;
}
function I6(r, e, i) {
  const n = r.name, s = n.length;
  for ($y.lastIndex = 0; ; ) {
    const a = $y.exec(n), o = $y.lastIndex;
    let l = a[1];
    const u = a[2] === "]", c = a[3];
    if (u && (l = l | 0), c === void 0 || c === "[" && o + 2 === s) {
      dw(i, c === void 0 ? new R6(l, r, e) : new N6(l, r, e));
      break;
    } else {
      let h = i.map[l];
      h === void 0 && (h = new P6(l), dw(i, h)), i = h;
    }
  }
}
class Qf {
  constructor(e, i) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(i, e.ACTIVE_UNIFORMS);
    for (let s = 0; s < n; ++s) {
      const a = e.getActiveUniform(i, s), o = e.getUniformLocation(i, a.name);
      I6(a, o, this);
    }
  }
  setValue(e, i, n, s) {
    const a = this.map[i];
    a !== void 0 && a.setValue(e, n, s);
  }
  setOptional(e, i, n) {
    const s = i[n];
    s !== void 0 && this.setValue(e, n, s);
  }
  static upload(e, i, n, s) {
    for (let a = 0, o = i.length; a !== o; ++a) {
      const l = i[a], u = n[l.id];
      u.needsUpdate !== !1 && l.setValue(e, u.value, s);
    }
  }
  static seqWithValue(e, i) {
    const n = [];
    for (let s = 0, a = e.length; s !== a; ++s) {
      const o = e[s];
      o.id in i && n.push(o);
    }
    return n;
  }
}
function pw(r, e, i) {
  const n = r.createShader(e);
  return r.shaderSource(n, i), r.compileShader(n), n;
}
const O6 = 37297;
let D6 = 0;
function L6(r, e) {
  const i = r.split(`
`), n = [], s = Math.max(e - 6, 0), a = Math.min(e + 6, i.length);
  for (let o = s; o < a; o++) {
    const l = o + 1;
    n.push(`${l === e ? ">" : " "} ${l}: ${i[o]}`);
  }
  return n.join(`
`);
}
const fw = /* @__PURE__ */ new It();
function k6(r) {
  Gt._getMatrix(fw, Gt.workingColorSpace, r);
  const e = `mat3( ${fw.elements.map((i) => i.toFixed(4))} )`;
  switch (Gt.getTransfer(r)) {
    case _g:
      return [e, "LinearTransferOETF"];
    case ei:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", r), [e, "LinearTransferOETF"];
  }
}
function mw(r, e, i) {
  const n = r.getShaderParameter(e, r.COMPILE_STATUS), s = r.getShaderInfoLog(e).trim();
  if (n && s === "") return "";
  const a = /ERROR: 0:(\d+)/.exec(s);
  if (a) {
    const o = parseInt(a[1]);
    return i.toUpperCase() + `

` + s + `

` + L6(r.getShaderSource(e), o);
  } else
    return s;
}
function U6(r, e) {
  const i = k6(e);
  return [
    `vec4 ${r}( vec4 value ) {`,
    `	return ${i[1]}( vec4( value.rgb * ${i[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function F6(r, e) {
  let i;
  switch (e) {
    case jF:
      i = "Linear";
      break;
    case VF:
      i = "Reinhard";
      break;
    case GF:
      i = "Cineon";
      break;
    case HF:
      i = "ACESFilmic";
      break;
    case qF:
      i = "AgX";
      break;
    case XF:
      i = "Neutral";
      break;
    case WF:
      i = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), i = "Linear";
  }
  return "vec3 " + r + "( vec3 color ) { return " + i + "ToneMapping( color ); }";
}
const Ip = /* @__PURE__ */ new X();
function B6() {
  Gt.getLuminanceCoefficients(Ip);
  const r = Ip.x.toFixed(4), e = Ip.y.toFixed(4), i = Ip.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r}, ${e}, ${i} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function z6(r) {
  return [
    r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(Bh).join(`
`);
}
function j6(r) {
  const e = [];
  for (const i in r) {
    const n = r[i];
    n !== !1 && e.push("#define " + i + " " + n);
  }
  return e.join(`
`);
}
function V6(r, e) {
  const i = {}, n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
  for (let s = 0; s < n; s++) {
    const a = r.getActiveAttrib(e, s), o = a.name;
    let l = 1;
    a.type === r.FLOAT_MAT2 && (l = 2), a.type === r.FLOAT_MAT3 && (l = 3), a.type === r.FLOAT_MAT4 && (l = 4), i[o] = {
      type: a.type,
      location: r.getAttribLocation(e, o),
      locationSize: l
    };
  }
  return i;
}
function Bh(r) {
  return r !== "";
}
function gw(r, e) {
  const i = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function yw(r, e) {
  return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const G6 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Bb(r) {
  return r.replace(G6, W6);
}
const H6 = /* @__PURE__ */ new Map();
function W6(r, e) {
  let i = Rt[e];
  if (i === void 0) {
    const n = H6.get(e);
    if (n !== void 0)
      i = Rt[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return Bb(i);
}
const q6 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function vw(r) {
  return r.replace(q6, X6);
}
function X6(r, e, i, n) {
  let s = "";
  for (let a = parseInt(e); a < parseInt(i); a++)
    s += n.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
  return s;
}
function bw(r) {
  let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
  return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function $6(r) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return r.shadowMapType === jC ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === xF ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === Gs && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function Y6(r) {
  let e = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case dc:
      case pc:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case xg:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function K6(r) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case pc:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function Z6(r) {
  let e = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case A_:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case BF:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case zF:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function Q6(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const i = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 7 * 16)), texelHeight: n, maxMip: i };
}
function J6(r, e, i, n) {
  const s = r.getContext(), a = i.defines;
  let o = i.vertexShader, l = i.fragmentShader;
  const u = $6(i), c = Y6(i), h = K6(i), d = Z6(i), p = Q6(i), f = z6(i), m = j6(a), y = s.createProgram();
  let v, g, _ = i.glslVersion ? "#version " + i.glslVersion + `
` : "";
  i.isRawShaderMaterial ? (v = [
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m
  ].filter(Bh).join(`
`), v.length > 0 && (v += `
`), g = [
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m
  ].filter(Bh).join(`
`), g.length > 0 && (g += `
`)) : (v = [
    bw(i),
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m,
    i.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    i.batching ? "#define USE_BATCHING" : "",
    i.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    i.instancing ? "#define USE_INSTANCING" : "",
    i.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    i.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    i.useFog && i.fog ? "#define USE_FOG" : "",
    i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
    i.map ? "#define USE_MAP" : "",
    i.envMap ? "#define USE_ENVMAP" : "",
    i.envMap ? "#define " + h : "",
    i.lightMap ? "#define USE_LIGHTMAP" : "",
    i.aoMap ? "#define USE_AOMAP" : "",
    i.bumpMap ? "#define USE_BUMPMAP" : "",
    i.normalMap ? "#define USE_NORMALMAP" : "",
    i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    i.anisotropy ? "#define USE_ANISOTROPY" : "",
    i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    i.specularMap ? "#define USE_SPECULARMAP" : "",
    i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    i.metalnessMap ? "#define USE_METALNESSMAP" : "",
    i.alphaMap ? "#define USE_ALPHAMAP" : "",
    i.alphaHash ? "#define USE_ALPHAHASH" : "",
    i.transmission ? "#define USE_TRANSMISSION" : "",
    i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    i.mapUv ? "#define MAP_UV " + i.mapUv : "",
    i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "",
    i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "",
    i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "",
    i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "",
    i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "",
    i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "",
    i.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv : "",
    i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "",
    i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "",
    i.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv : "",
    i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "",
    i.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv : "",
    i.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv : "",
    i.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv : "",
    i.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i.iridescenceThicknessMapUv : "",
    i.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv : "",
    i.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv : "",
    i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "",
    i.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv : "",
    i.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv : "",
    i.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv : "",
    i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "",
    //
    i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "",
    i.vertexColors ? "#define USE_COLOR" : "",
    i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    i.vertexUv1s ? "#define USE_UV1" : "",
    i.vertexUv2s ? "#define USE_UV2" : "",
    i.vertexUv3s ? "#define USE_UV3" : "",
    i.pointsUvs ? "#define USE_POINTS_UV" : "",
    i.flatShading ? "#define FLAT_SHADED" : "",
    i.skinning ? "#define USE_SKINNING" : "",
    i.morphTargets ? "#define USE_MORPHTARGETS" : "",
    i.morphNormals && i.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    i.morphColors ? "#define USE_MORPHCOLORS" : "",
    i.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "",
    i.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "",
    i.doubleSided ? "#define DOUBLE_SIDED" : "",
    i.flipSided ? "#define FLIP_SIDED" : "",
    i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    i.shadowMapEnabled ? "#define " + u : "",
    i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Bh).join(`
`), g = [
    bw(i),
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m,
    i.useFog && i.fog ? "#define USE_FOG" : "",
    i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
    i.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    i.map ? "#define USE_MAP" : "",
    i.matcap ? "#define USE_MATCAP" : "",
    i.envMap ? "#define USE_ENVMAP" : "",
    i.envMap ? "#define " + c : "",
    i.envMap ? "#define " + h : "",
    i.envMap ? "#define " + d : "",
    p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
    p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
    p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
    i.lightMap ? "#define USE_LIGHTMAP" : "",
    i.aoMap ? "#define USE_AOMAP" : "",
    i.bumpMap ? "#define USE_BUMPMAP" : "",
    i.normalMap ? "#define USE_NORMALMAP" : "",
    i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    i.anisotropy ? "#define USE_ANISOTROPY" : "",
    i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    i.clearcoat ? "#define USE_CLEARCOAT" : "",
    i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    i.dispersion ? "#define USE_DISPERSION" : "",
    i.iridescence ? "#define USE_IRIDESCENCE" : "",
    i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    i.specularMap ? "#define USE_SPECULARMAP" : "",
    i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    i.metalnessMap ? "#define USE_METALNESSMAP" : "",
    i.alphaMap ? "#define USE_ALPHAMAP" : "",
    i.alphaTest ? "#define USE_ALPHATEST" : "",
    i.alphaHash ? "#define USE_ALPHAHASH" : "",
    i.sheen ? "#define USE_SHEEN" : "",
    i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    i.transmission ? "#define USE_TRANSMISSION" : "",
    i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "",
    i.vertexColors || i.instancingColor || i.batchingColor ? "#define USE_COLOR" : "",
    i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    i.vertexUv1s ? "#define USE_UV1" : "",
    i.vertexUv2s ? "#define USE_UV2" : "",
    i.vertexUv3s ? "#define USE_UV3" : "",
    i.pointsUvs ? "#define USE_POINTS_UV" : "",
    i.gradientMap ? "#define USE_GRADIENTMAP" : "",
    i.flatShading ? "#define FLAT_SHADED" : "",
    i.doubleSided ? "#define DOUBLE_SIDED" : "",
    i.flipSided ? "#define FLIP_SIDED" : "",
    i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    i.shadowMapEnabled ? "#define " + u : "",
    i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    i.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    i.toneMapping !== lo ? "#define TONE_MAPPING" : "",
    i.toneMapping !== lo ? Rt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    i.toneMapping !== lo ? F6("toneMapping", i.toneMapping) : "",
    i.dithering ? "#define DITHERING" : "",
    i.opaque ? "#define OPAQUE" : "",
    Rt.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    U6("linearToOutputTexel", i.outputColorSpace),
    B6(),
    i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
    `
`
  ].filter(Bh).join(`
`)), o = Bb(o), o = gw(o, i), o = yw(o, i), l = Bb(l), l = gw(l, i), l = yw(l, i), o = vw(o), l = vw(l), i.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, v = [
    f,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + v, g = [
    "#define varying in",
    i.glslVersion === PS ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    i.glslVersion === PS ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + g);
  const x = _ + v + o, b = _ + g + l, T = pw(s, s.VERTEX_SHADER, x), S = pw(s, s.FRAGMENT_SHADER, b);
  s.attachShader(y, T), s.attachShader(y, S), i.index0AttributeName !== void 0 ? s.bindAttribLocation(y, 0, i.index0AttributeName) : i.morphTargets === !0 && s.bindAttribLocation(y, 0, "position"), s.linkProgram(y);
  function w(N) {
    if (r.debug.checkShaderErrors) {
      const U = s.getProgramInfoLog(y).trim(), k = s.getShaderInfoLog(T).trim(), C = s.getShaderInfoLog(S).trim();
      let I = !0, O = !0;
      if (s.getProgramParameter(y, s.LINK_STATUS) === !1)
        if (I = !1, typeof r.debug.onShaderError == "function")
          r.debug.onShaderError(s, y, T, S);
        else {
          const W = mw(s, T, "vertex"), V = mw(s, S, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(y, s.VALIDATE_STATUS) + `

Material Name: ` + N.name + `
Material Type: ` + N.type + `

Program Info Log: ` + U + `
` + W + `
` + V
          );
        }
      else U !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", U) : (k === "" || C === "") && (O = !1);
      O && (N.diagnostics = {
        runnable: I,
        programLog: U,
        vertexShader: {
          log: k,
          prefix: v
        },
        fragmentShader: {
          log: C,
          prefix: g
        }
      });
    }
    s.deleteShader(T), s.deleteShader(S), M = new Qf(s, y), E = V6(s, y);
  }
  let M;
  this.getUniforms = function() {
    return M === void 0 && w(this), M;
  };
  let E;
  this.getAttributes = function() {
    return E === void 0 && w(this), E;
  };
  let A = i.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return A === !1 && (A = s.getProgramParameter(y, O6)), A;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), s.deleteProgram(y), this.program = void 0;
  }, this.type = i.shaderType, this.name = i.shaderName, this.id = D6++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = T, this.fragmentShader = S, this;
}
let ej = 0;
class tj {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const i = e.vertexShader, n = e.fragmentShader, s = this._getShaderStage(i), a = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e);
    return o.has(s) === !1 && (o.add(s), s.usedTimes++), o.has(a) === !1 && (o.add(a), a.usedTimes++), this;
  }
  remove(e) {
    const i = this.materialCache.get(e);
    for (const n of i)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const i = this.materialCache;
    let n = i.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), i.set(e, n)), n;
  }
  _getShaderStage(e) {
    const i = this.shaderCache;
    let n = i.get(e);
    return n === void 0 && (n = new ij(e), i.set(e, n)), n;
  }
}
class ij {
  constructor(e) {
    this.id = ej++, this.code = e, this.usedTimes = 0;
  }
}
function rj(r, e, i, n, s, a, o) {
  const l = new L_(), u = new tj(), c = /* @__PURE__ */ new Set(), h = [], d = s.logarithmicDepthBuffer, p = s.vertexTextures;
  let f = s.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function y(E) {
    return c.add(E), E === 0 ? "uv" : `uv${E}`;
  }
  function v(E, A, N, U, k) {
    const C = U.fog, I = k.geometry, O = E.isMeshStandardMaterial ? U.environment : null, W = (E.isMeshStandardMaterial ? i : e).get(E.envMap || O), V = W && W.mapping === xg ? W.image.height : null, Q = m[E.type];
    E.precision !== null && (f = s.getMaxPrecision(E.precision), f !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", f, "instead."));
    const F = I.morphAttributes.position || I.morphAttributes.normal || I.morphAttributes.color, B = F !== void 0 ? F.length : 0;
    let q = 0;
    I.morphAttributes.position !== void 0 && (q = 1), I.morphAttributes.normal !== void 0 && (q = 2), I.morphAttributes.color !== void 0 && (q = 3);
    let G, z, Y, se;
    if (Q) {
      const Bt = hs[Q];
      G = Bt.vertexShader, z = Bt.fragmentShader;
    } else
      G = E.vertexShader, z = E.fragmentShader, u.update(E), Y = u.getVertexShaderID(E), se = u.getFragmentShaderID(E);
    const ne = r.getRenderTarget(), fe = r.state.buffers.depth.getReversed(), Se = k.isInstancedMesh === !0, Pe = k.isBatchedMesh === !0, lt = !!E.map, xe = !!E.matcap, vt = !!W, Z = !!E.aoMap, Ht = !!E.lightMap, nt = !!E.bumpMap, Tt = !!E.normalMap, We = !!E.displacementMap, At = !!E.emissiveMap, st = !!E.metalnessMap, j = !!E.roughnessMap, D = E.anisotropy > 0, le = E.clearcoat > 0, Te = E.dispersion > 0, Ce = E.iridescence > 0, _e = E.sheen > 0, Je = E.transmission > 0, Be = D && !!E.anisotropyMap, Xe = le && !!E.clearcoatMap, Pt = le && !!E.clearcoatNormalMap, Ie = le && !!E.clearcoatRoughnessMap, $e = Ce && !!E.iridescenceMap, ut = Ce && !!E.iridescenceThicknessMap, ft = _e && !!E.sheenColorMap, Ye = _e && !!E.sheenRoughnessMap, Ot = !!E.specularMap, bt = !!E.specularColorMap, jt = !!E.specularIntensityMap, ee = Je && !!E.transmissionMap, Le = Je && !!E.thicknessMap, de = !!E.gradientMap, Ee = !!E.alphaMap, ze = E.alphaTest > 0, Ue = !!E.alphaHash, Ct = !!E.extensions;
    let ni = lo;
    E.toneMapped && (ne === null || ne.isXRRenderTarget === !0) && (ni = r.toneMapping);
    const _i = {
      shaderID: Q,
      shaderType: E.type,
      shaderName: E.name,
      vertexShader: G,
      fragmentShader: z,
      defines: E.defines,
      customVertexShaderID: Y,
      customFragmentShaderID: se,
      isRawShaderMaterial: E.isRawShaderMaterial === !0,
      glslVersion: E.glslVersion,
      precision: f,
      batching: Pe,
      batchingColor: Pe && k._colorsTexture !== null,
      instancing: Se,
      instancingColor: Se && k.instanceColor !== null,
      instancingMorph: Se && k.morphTexture !== null,
      supportsVertexTextures: p,
      outputColorSpace: ne === null ? r.outputColorSpace : ne.isXRRenderTarget === !0 ? ne.texture.colorSpace : kc,
      alphaToCoverage: !!E.alphaToCoverage,
      map: lt,
      matcap: xe,
      envMap: vt,
      envMapMode: vt && W.mapping,
      envMapCubeUVHeight: V,
      aoMap: Z,
      lightMap: Ht,
      bumpMap: nt,
      normalMap: Tt,
      displacementMap: p && We,
      emissiveMap: At,
      normalMapObjectSpace: Tt && E.normalMapType === ZF,
      normalMapTangentSpace: Tt && E.normalMapType === JC,
      metalnessMap: st,
      roughnessMap: j,
      anisotropy: D,
      anisotropyMap: Be,
      clearcoat: le,
      clearcoatMap: Xe,
      clearcoatNormalMap: Pt,
      clearcoatRoughnessMap: Ie,
      dispersion: Te,
      iridescence: Ce,
      iridescenceMap: $e,
      iridescenceThicknessMap: ut,
      sheen: _e,
      sheenColorMap: ft,
      sheenRoughnessMap: Ye,
      specularMap: Ot,
      specularColorMap: bt,
      specularIntensityMap: jt,
      transmission: Je,
      transmissionMap: ee,
      thicknessMap: Le,
      gradientMap: de,
      opaque: E.transparent === !1 && E.blending === Gu && E.alphaToCoverage === !1,
      alphaMap: Ee,
      alphaTest: ze,
      alphaHash: Ue,
      combine: E.combine,
      //
      mapUv: lt && y(E.map.channel),
      aoMapUv: Z && y(E.aoMap.channel),
      lightMapUv: Ht && y(E.lightMap.channel),
      bumpMapUv: nt && y(E.bumpMap.channel),
      normalMapUv: Tt && y(E.normalMap.channel),
      displacementMapUv: We && y(E.displacementMap.channel),
      emissiveMapUv: At && y(E.emissiveMap.channel),
      metalnessMapUv: st && y(E.metalnessMap.channel),
      roughnessMapUv: j && y(E.roughnessMap.channel),
      anisotropyMapUv: Be && y(E.anisotropyMap.channel),
      clearcoatMapUv: Xe && y(E.clearcoatMap.channel),
      clearcoatNormalMapUv: Pt && y(E.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ie && y(E.clearcoatRoughnessMap.channel),
      iridescenceMapUv: $e && y(E.iridescenceMap.channel),
      iridescenceThicknessMapUv: ut && y(E.iridescenceThicknessMap.channel),
      sheenColorMapUv: ft && y(E.sheenColorMap.channel),
      sheenRoughnessMapUv: Ye && y(E.sheenRoughnessMap.channel),
      specularMapUv: Ot && y(E.specularMap.channel),
      specularColorMapUv: bt && y(E.specularColorMap.channel),
      specularIntensityMapUv: jt && y(E.specularIntensityMap.channel),
      transmissionMapUv: ee && y(E.transmissionMap.channel),
      thicknessMapUv: Le && y(E.thicknessMap.channel),
      alphaMapUv: Ee && y(E.alphaMap.channel),
      //
      vertexTangents: !!I.attributes.tangent && (Tt || D),
      vertexColors: E.vertexColors,
      vertexAlphas: E.vertexColors === !0 && !!I.attributes.color && I.attributes.color.itemSize === 4,
      pointsUvs: k.isPoints === !0 && !!I.attributes.uv && (lt || Ee),
      fog: !!C,
      useFog: E.fog === !0,
      fogExp2: !!C && C.isFogExp2,
      flatShading: E.flatShading === !0,
      sizeAttenuation: E.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      reverseDepthBuffer: fe,
      skinning: k.isSkinnedMesh === !0,
      morphTargets: I.morphAttributes.position !== void 0,
      morphNormals: I.morphAttributes.normal !== void 0,
      morphColors: I.morphAttributes.color !== void 0,
      morphTargetsCount: B,
      morphTextureStride: q,
      numDirLights: A.directional.length,
      numPointLights: A.point.length,
      numSpotLights: A.spot.length,
      numSpotLightMaps: A.spotLightMap.length,
      numRectAreaLights: A.rectArea.length,
      numHemiLights: A.hemi.length,
      numDirLightShadows: A.directionalShadowMap.length,
      numPointLightShadows: A.pointShadowMap.length,
      numSpotLightShadows: A.spotShadowMap.length,
      numSpotLightShadowsWithMaps: A.numSpotLightShadowsWithMaps,
      numLightProbes: A.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: E.dithering,
      shadowMapEnabled: r.shadowMap.enabled && N.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: ni,
      decodeVideoTexture: lt && E.map.isVideoTexture === !0 && Gt.getTransfer(E.map.colorSpace) === ei,
      decodeVideoTextureEmissive: At && E.emissiveMap.isVideoTexture === !0 && Gt.getTransfer(E.emissiveMap.colorSpace) === ei,
      premultipliedAlpha: E.premultipliedAlpha,
      doubleSided: E.side === Zs,
      flipSided: E.side === Mr,
      useDepthPacking: E.depthPacking >= 0,
      depthPacking: E.depthPacking || 0,
      index0AttributeName: E.index0AttributeName,
      extensionClipCullDistance: Ct && E.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (Ct && E.extensions.multiDraw === !0 || Pe) && n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: E.customProgramCacheKey()
    };
    return _i.vertexUv1s = c.has(1), _i.vertexUv2s = c.has(2), _i.vertexUv3s = c.has(3), c.clear(), _i;
  }
  function g(E) {
    const A = [];
    if (E.shaderID ? A.push(E.shaderID) : (A.push(E.customVertexShaderID), A.push(E.customFragmentShaderID)), E.defines !== void 0)
      for (const N in E.defines)
        A.push(N), A.push(E.defines[N]);
    return E.isRawShaderMaterial === !1 && (_(A, E), x(A, E), A.push(r.outputColorSpace)), A.push(E.customProgramCacheKey), A.join();
  }
  function _(E, A) {
    E.push(A.precision), E.push(A.outputColorSpace), E.push(A.envMapMode), E.push(A.envMapCubeUVHeight), E.push(A.mapUv), E.push(A.alphaMapUv), E.push(A.lightMapUv), E.push(A.aoMapUv), E.push(A.bumpMapUv), E.push(A.normalMapUv), E.push(A.displacementMapUv), E.push(A.emissiveMapUv), E.push(A.metalnessMapUv), E.push(A.roughnessMapUv), E.push(A.anisotropyMapUv), E.push(A.clearcoatMapUv), E.push(A.clearcoatNormalMapUv), E.push(A.clearcoatRoughnessMapUv), E.push(A.iridescenceMapUv), E.push(A.iridescenceThicknessMapUv), E.push(A.sheenColorMapUv), E.push(A.sheenRoughnessMapUv), E.push(A.specularMapUv), E.push(A.specularColorMapUv), E.push(A.specularIntensityMapUv), E.push(A.transmissionMapUv), E.push(A.thicknessMapUv), E.push(A.combine), E.push(A.fogExp2), E.push(A.sizeAttenuation), E.push(A.morphTargetsCount), E.push(A.morphAttributeCount), E.push(A.numDirLights), E.push(A.numPointLights), E.push(A.numSpotLights), E.push(A.numSpotLightMaps), E.push(A.numHemiLights), E.push(A.numRectAreaLights), E.push(A.numDirLightShadows), E.push(A.numPointLightShadows), E.push(A.numSpotLightShadows), E.push(A.numSpotLightShadowsWithMaps), E.push(A.numLightProbes), E.push(A.shadowMapType), E.push(A.toneMapping), E.push(A.numClippingPlanes), E.push(A.numClipIntersection), E.push(A.depthPacking);
  }
  function x(E, A) {
    l.disableAll(), A.supportsVertexTextures && l.enable(0), A.instancing && l.enable(1), A.instancingColor && l.enable(2), A.instancingMorph && l.enable(3), A.matcap && l.enable(4), A.envMap && l.enable(5), A.normalMapObjectSpace && l.enable(6), A.normalMapTangentSpace && l.enable(7), A.clearcoat && l.enable(8), A.iridescence && l.enable(9), A.alphaTest && l.enable(10), A.vertexColors && l.enable(11), A.vertexAlphas && l.enable(12), A.vertexUv1s && l.enable(13), A.vertexUv2s && l.enable(14), A.vertexUv3s && l.enable(15), A.vertexTangents && l.enable(16), A.anisotropy && l.enable(17), A.alphaHash && l.enable(18), A.batching && l.enable(19), A.dispersion && l.enable(20), A.batchingColor && l.enable(21), E.push(l.mask), l.disableAll(), A.fog && l.enable(0), A.useFog && l.enable(1), A.flatShading && l.enable(2), A.logarithmicDepthBuffer && l.enable(3), A.reverseDepthBuffer && l.enable(4), A.skinning && l.enable(5), A.morphTargets && l.enable(6), A.morphNormals && l.enable(7), A.morphColors && l.enable(8), A.premultipliedAlpha && l.enable(9), A.shadowMapEnabled && l.enable(10), A.doubleSided && l.enable(11), A.flipSided && l.enable(12), A.useDepthPacking && l.enable(13), A.dithering && l.enable(14), A.transmission && l.enable(15), A.sheen && l.enable(16), A.opaque && l.enable(17), A.pointsUvs && l.enable(18), A.decodeVideoTexture && l.enable(19), A.decodeVideoTextureEmissive && l.enable(20), A.alphaToCoverage && l.enable(21), E.push(l.mask);
  }
  function b(E) {
    const A = m[E.type];
    let N;
    if (A) {
      const U = hs[A];
      N = mR.clone(U.uniforms);
    } else
      N = E.uniforms;
    return N;
  }
  function T(E, A) {
    let N;
    for (let U = 0, k = h.length; U < k; U++) {
      const C = h[U];
      if (C.cacheKey === A) {
        N = C, ++N.usedTimes;
        break;
      }
    }
    return N === void 0 && (N = new J6(r, A, E, a), h.push(N)), N;
  }
  function S(E) {
    if (--E.usedTimes === 0) {
      const A = h.indexOf(E);
      h[A] = h[h.length - 1], h.pop(), E.destroy();
    }
  }
  function w(E) {
    u.remove(E);
  }
  function M() {
    u.dispose();
  }
  return {
    getParameters: v,
    getProgramCacheKey: g,
    getUniforms: b,
    acquireProgram: T,
    releaseProgram: S,
    releaseShaderCache: w,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: h,
    dispose: M
  };
}
function nj() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(o) {
    return r.has(o);
  }
  function i(o) {
    let l = r.get(o);
    return l === void 0 && (l = {}, r.set(o, l)), l;
  }
  function n(o) {
    r.delete(o);
  }
  function s(o, l, u) {
    r.get(o)[l] = u;
  }
  function a() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: i,
    remove: n,
    update: s,
    dispose: a
  };
}
function sj(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
}
function xw(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
}
function _w() {
  const r = [];
  let e = 0;
  const i = [], n = [], s = [];
  function a() {
    e = 0, i.length = 0, n.length = 0, s.length = 0;
  }
  function o(d, p, f, m, y, v) {
    let g = r[e];
    return g === void 0 ? (g = {
      id: d.id,
      object: d,
      geometry: p,
      material: f,
      groupOrder: m,
      renderOrder: d.renderOrder,
      z: y,
      group: v
    }, r[e] = g) : (g.id = d.id, g.object = d, g.geometry = p, g.material = f, g.groupOrder = m, g.renderOrder = d.renderOrder, g.z = y, g.group = v), e++, g;
  }
  function l(d, p, f, m, y, v) {
    const g = o(d, p, f, m, y, v);
    f.transmission > 0 ? n.push(g) : f.transparent === !0 ? s.push(g) : i.push(g);
  }
  function u(d, p, f, m, y, v) {
    const g = o(d, p, f, m, y, v);
    f.transmission > 0 ? n.unshift(g) : f.transparent === !0 ? s.unshift(g) : i.unshift(g);
  }
  function c(d, p) {
    i.length > 1 && i.sort(d || sj), n.length > 1 && n.sort(p || xw), s.length > 1 && s.sort(p || xw);
  }
  function h() {
    for (let d = e, p = r.length; d < p; d++) {
      const f = r[d];
      if (f.id === null) break;
      f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
    }
  }
  return {
    opaque: i,
    transmissive: n,
    transparent: s,
    init: a,
    push: l,
    unshift: u,
    finish: h,
    sort: c
  };
}
function aj() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(n, s) {
    const a = r.get(n);
    let o;
    return a === void 0 ? (o = new _w(), r.set(n, [o])) : s >= a.length ? (o = new _w(), a.push(o)) : o = a[s], o;
  }
  function i() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: i
  };
}
function oj() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let i;
      switch (e.type) {
        case "DirectionalLight":
          i = {
            direction: new X(),
            color: new Ut()
          };
          break;
        case "SpotLight":
          i = {
            position: new X(),
            direction: new X(),
            color: new Ut(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          i = {
            position: new X(),
            color: new Ut(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          i = {
            direction: new X(),
            skyColor: new Ut(),
            groundColor: new Ut()
          };
          break;
        case "RectAreaLight":
          i = {
            color: new Ut(),
            position: new X(),
            halfWidth: new X(),
            halfHeight: new X()
          };
          break;
      }
      return r[e.id] = i, i;
    }
  };
}
function lj() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let i;
      switch (e.type) {
        case "DirectionalLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke()
          };
          break;
        case "SpotLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke()
          };
          break;
        case "PointLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return r[e.id] = i, i;
    }
  };
}
let uj = 0;
function cj(r, e) {
  return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0);
}
function hj(r) {
  const e = new oj(), i = lj(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let c = 0; c < 9; c++) n.probe.push(new X());
  const s = new X(), a = new ui(), o = new ui();
  function l(c) {
    let h = 0, d = 0, p = 0;
    for (let E = 0; E < 9; E++) n.probe[E].set(0, 0, 0);
    let f = 0, m = 0, y = 0, v = 0, g = 0, _ = 0, x = 0, b = 0, T = 0, S = 0, w = 0;
    c.sort(cj);
    for (let E = 0, A = c.length; E < A; E++) {
      const N = c[E], U = N.color, k = N.intensity, C = N.distance, I = N.shadow && N.shadow.map ? N.shadow.map.texture : null;
      if (N.isAmbientLight)
        h += U.r * k, d += U.g * k, p += U.b * k;
      else if (N.isLightProbe) {
        for (let O = 0; O < 9; O++)
          n.probe[O].addScaledVector(N.sh.coefficients[O], k);
        w++;
      } else if (N.isDirectionalLight) {
        const O = e.get(N);
        if (O.color.copy(N.color).multiplyScalar(N.intensity), N.castShadow) {
          const W = N.shadow, V = i.get(N);
          V.shadowIntensity = W.intensity, V.shadowBias = W.bias, V.shadowNormalBias = W.normalBias, V.shadowRadius = W.radius, V.shadowMapSize = W.mapSize, n.directionalShadow[f] = V, n.directionalShadowMap[f] = I, n.directionalShadowMatrix[f] = N.shadow.matrix, _++;
        }
        n.directional[f] = O, f++;
      } else if (N.isSpotLight) {
        const O = e.get(N);
        O.position.setFromMatrixPosition(N.matrixWorld), O.color.copy(U).multiplyScalar(k), O.distance = C, O.coneCos = Math.cos(N.angle), O.penumbraCos = Math.cos(N.angle * (1 - N.penumbra)), O.decay = N.decay, n.spot[y] = O;
        const W = N.shadow;
        if (N.map && (n.spotLightMap[T] = N.map, T++, W.updateMatrices(N), N.castShadow && S++), n.spotLightMatrix[y] = W.matrix, N.castShadow) {
          const V = i.get(N);
          V.shadowIntensity = W.intensity, V.shadowBias = W.bias, V.shadowNormalBias = W.normalBias, V.shadowRadius = W.radius, V.shadowMapSize = W.mapSize, n.spotShadow[y] = V, n.spotShadowMap[y] = I, b++;
        }
        y++;
      } else if (N.isRectAreaLight) {
        const O = e.get(N);
        O.color.copy(U).multiplyScalar(k), O.halfWidth.set(N.width * 0.5, 0, 0), O.halfHeight.set(0, N.height * 0.5, 0), n.rectArea[v] = O, v++;
      } else if (N.isPointLight) {
        const O = e.get(N);
        if (O.color.copy(N.color).multiplyScalar(N.intensity), O.distance = N.distance, O.decay = N.decay, N.castShadow) {
          const W = N.shadow, V = i.get(N);
          V.shadowIntensity = W.intensity, V.shadowBias = W.bias, V.shadowNormalBias = W.normalBias, V.shadowRadius = W.radius, V.shadowMapSize = W.mapSize, V.shadowCameraNear = W.camera.near, V.shadowCameraFar = W.camera.far, n.pointShadow[m] = V, n.pointShadowMap[m] = I, n.pointShadowMatrix[m] = N.shadow.matrix, x++;
        }
        n.point[m] = O, m++;
      } else if (N.isHemisphereLight) {
        const O = e.get(N);
        O.skyColor.copy(N.color).multiplyScalar(k), O.groundColor.copy(N.groundColor).multiplyScalar(k), n.hemi[g] = O, g++;
      }
    }
    v > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = je.LTC_FLOAT_1, n.rectAreaLTC2 = je.LTC_FLOAT_2) : (n.rectAreaLTC1 = je.LTC_HALF_1, n.rectAreaLTC2 = je.LTC_HALF_2)), n.ambient[0] = h, n.ambient[1] = d, n.ambient[2] = p;
    const M = n.hash;
    (M.directionalLength !== f || M.pointLength !== m || M.spotLength !== y || M.rectAreaLength !== v || M.hemiLength !== g || M.numDirectionalShadows !== _ || M.numPointShadows !== x || M.numSpotShadows !== b || M.numSpotMaps !== T || M.numLightProbes !== w) && (n.directional.length = f, n.spot.length = y, n.rectArea.length = v, n.point.length = m, n.hemi.length = g, n.directionalShadow.length = _, n.directionalShadowMap.length = _, n.pointShadow.length = x, n.pointShadowMap.length = x, n.spotShadow.length = b, n.spotShadowMap.length = b, n.directionalShadowMatrix.length = _, n.pointShadowMatrix.length = x, n.spotLightMatrix.length = b + T - S, n.spotLightMap.length = T, n.numSpotLightShadowsWithMaps = S, n.numLightProbes = w, M.directionalLength = f, M.pointLength = m, M.spotLength = y, M.rectAreaLength = v, M.hemiLength = g, M.numDirectionalShadows = _, M.numPointShadows = x, M.numSpotShadows = b, M.numSpotMaps = T, M.numLightProbes = w, n.version = uj++);
  }
  function u(c, h) {
    let d = 0, p = 0, f = 0, m = 0, y = 0;
    const v = h.matrixWorldInverse;
    for (let g = 0, _ = c.length; g < _; g++) {
      const x = c[g];
      if (x.isDirectionalLight) {
        const b = n.directional[d];
        b.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(v), d++;
      } else if (x.isSpotLight) {
        const b = n.spot[f];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(v), b.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(v), f++;
      } else if (x.isRectAreaLight) {
        const b = n.rectArea[m];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(v), o.identity(), a.copy(x.matrixWorld), a.premultiply(v), o.extractRotation(a), b.halfWidth.set(x.width * 0.5, 0, 0), b.halfHeight.set(0, x.height * 0.5, 0), b.halfWidth.applyMatrix4(o), b.halfHeight.applyMatrix4(o), m++;
      } else if (x.isPointLight) {
        const b = n.point[p];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(v), p++;
      } else if (x.isHemisphereLight) {
        const b = n.hemi[y];
        b.direction.setFromMatrixPosition(x.matrixWorld), b.direction.transformDirection(v), y++;
      }
    }
  }
  return {
    setup: l,
    setupView: u,
    state: n
  };
}
function Tw(r) {
  const e = new hj(r), i = [], n = [];
  function s(h) {
    c.camera = h, i.length = 0, n.length = 0;
  }
  function a(h) {
    i.push(h);
  }
  function o(h) {
    n.push(h);
  }
  function l() {
    e.setup(i);
  }
  function u(h) {
    e.setupView(i, h);
  }
  const c = {
    lightsArray: i,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: s,
    state: c,
    setupLights: l,
    setupLightsView: u,
    pushLight: a,
    pushShadow: o
  };
}
function dj(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function i(s, a = 0) {
    const o = e.get(s);
    let l;
    return o === void 0 ? (l = new Tw(r), e.set(s, [l])) : a >= o.length ? (l = new Tw(r), o.push(l)) : l = o[a], l;
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: n
  };
}
class pj extends Nl {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.depthPacking = YF, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class fj extends Nl {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const mj = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, gj = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function yj(r, e, i) {
  let n = new U_();
  const s = new ke(), a = new ke(), o = new Fi(), l = new pj({ depthPacking: KF }), u = new fj(), c = {}, h = i.maxTextureSize, d = { [mo]: Mr, [Mr]: mo, [Zs]: Zs }, p = new xs({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new ke() },
      radius: { value: 4 }
    },
    vertexShader: mj,
    fragmentShader: gj
  }), f = p.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new un();
  m.setAttribute(
    "position",
    new xn(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const y = new Lr(m, p), v = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = jC;
  let g = this.type;
  this.render = function(S, w, M) {
    if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || S.length === 0) return;
    const E = r.getRenderTarget(), A = r.getActiveCubeFace(), N = r.getActiveMipmapLevel(), U = r.state;
    U.setBlending(la), U.buffers.color.setClear(1, 1, 1, 1), U.buffers.depth.setTest(!0), U.setScissorTest(!1);
    const k = g !== Gs && this.type === Gs, C = g === Gs && this.type !== Gs;
    for (let I = 0, O = S.length; I < O; I++) {
      const W = S[I], V = W.shadow;
      if (V === void 0) {
        console.warn("THREE.WebGLShadowMap:", W, "has no shadow.");
        continue;
      }
      if (V.autoUpdate === !1 && V.needsUpdate === !1) continue;
      s.copy(V.mapSize);
      const Q = V.getFrameExtents();
      if (s.multiply(Q), a.copy(V.mapSize), (s.x > h || s.y > h) && (s.x > h && (a.x = Math.floor(h / Q.x), s.x = a.x * Q.x, V.mapSize.x = a.x), s.y > h && (a.y = Math.floor(h / Q.y), s.y = a.y * Q.y, V.mapSize.y = a.y)), V.map === null || k === !0 || C === !0) {
        const B = this.type !== Gs ? { minFilter: Kn, magFilter: Kn } : {};
        V.map !== null && V.map.dispose(), V.map = new go(s.x, s.y, B), V.map.texture.name = W.name + ".shadowMap", V.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(V.map), r.clear();
      const F = V.getViewportCount();
      for (let B = 0; B < F; B++) {
        const q = V.getViewport(B);
        o.set(
          a.x * q.x,
          a.y * q.y,
          a.x * q.z,
          a.y * q.w
        ), U.viewport(o), V.updateMatrices(W, B), n = V.getFrustum(), b(w, M, V.camera, W, this.type);
      }
      V.isPointLightShadow !== !0 && this.type === Gs && _(V, M), V.needsUpdate = !1;
    }
    g = this.type, v.needsUpdate = !1, r.setRenderTarget(E, A, N);
  };
  function _(S, w) {
    const M = e.update(y);
    p.defines.VSM_SAMPLES !== S.blurSamples && (p.defines.VSM_SAMPLES = S.blurSamples, f.defines.VSM_SAMPLES = S.blurSamples, p.needsUpdate = !0, f.needsUpdate = !0), S.mapPass === null && (S.mapPass = new go(s.x, s.y)), p.uniforms.shadow_pass.value = S.map.texture, p.uniforms.resolution.value = S.mapSize, p.uniforms.radius.value = S.radius, r.setRenderTarget(S.mapPass), r.clear(), r.renderBufferDirect(w, null, M, p, y, null), f.uniforms.shadow_pass.value = S.mapPass.texture, f.uniforms.resolution.value = S.mapSize, f.uniforms.radius.value = S.radius, r.setRenderTarget(S.map), r.clear(), r.renderBufferDirect(w, null, M, f, y, null);
  }
  function x(S, w, M, E) {
    let A = null;
    const N = M.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
    if (N !== void 0)
      A = N;
    else if (A = M.isPointLight === !0 ? u : l, r.localClippingEnabled && w.clipShadows === !0 && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
      const U = A.uuid, k = w.uuid;
      let C = c[U];
      C === void 0 && (C = {}, c[U] = C);
      let I = C[k];
      I === void 0 && (I = A.clone(), C[k] = I, w.addEventListener("dispose", T)), A = I;
    }
    if (A.visible = w.visible, A.wireframe = w.wireframe, E === Gs ? A.side = w.shadowSide !== null ? w.shadowSide : w.side : A.side = w.shadowSide !== null ? w.shadowSide : d[w.side], A.alphaMap = w.alphaMap, A.alphaTest = w.alphaTest, A.map = w.map, A.clipShadows = w.clipShadows, A.clippingPlanes = w.clippingPlanes, A.clipIntersection = w.clipIntersection, A.displacementMap = w.displacementMap, A.displacementScale = w.displacementScale, A.displacementBias = w.displacementBias, A.wireframeLinewidth = w.wireframeLinewidth, A.linewidth = w.linewidth, M.isPointLight === !0 && A.isMeshDistanceMaterial === !0) {
      const U = r.properties.get(A);
      U.light = M;
    }
    return A;
  }
  function b(S, w, M, E, A) {
    if (S.visible === !1) return;
    if (S.layers.test(w.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && A === Gs) && (!S.frustumCulled || n.intersectsObject(S))) {
      S.modelViewMatrix.multiplyMatrices(M.matrixWorldInverse, S.matrixWorld);
      const U = e.update(S), k = S.material;
      if (Array.isArray(k)) {
        const C = U.groups;
        for (let I = 0, O = C.length; I < O; I++) {
          const W = C[I], V = k[W.materialIndex];
          if (V && V.visible) {
            const Q = x(S, V, E, A);
            S.onBeforeShadow(r, S, w, M, U, Q, W), r.renderBufferDirect(M, null, U, Q, S, W), S.onAfterShadow(r, S, w, M, U, Q, W);
          }
        }
      } else if (k.visible) {
        const C = x(S, k, E, A);
        S.onBeforeShadow(r, S, w, M, U, C, null), r.renderBufferDirect(M, null, U, C, S, null), S.onAfterShadow(r, S, w, M, U, C, null);
      }
    }
    const N = S.children;
    for (let U = 0, k = N.length; U < k; U++)
      b(N[U], w, M, E, A);
  }
  function T(S) {
    S.target.removeEventListener("dispose", T);
    for (const w in c) {
      const M = c[w], E = S.target.uuid;
      E in M && (M[E].dispose(), delete M[E]);
    }
  }
}
const vj = {
  [Jv]: eb,
  [tb]: nb,
  [ib]: sb,
  [hc]: rb,
  [eb]: Jv,
  [nb]: tb,
  [sb]: ib,
  [rb]: hc
};
function bj(r, e) {
  function i() {
    let ee = !1;
    const Le = new Fi();
    let de = null;
    const Ee = new Fi(0, 0, 0, 0);
    return {
      setMask: function(ze) {
        de !== ze && !ee && (r.colorMask(ze, ze, ze, ze), de = ze);
      },
      setLocked: function(ze) {
        ee = ze;
      },
      setClear: function(ze, Ue, Ct, ni, _i) {
        _i === !0 && (ze *= ni, Ue *= ni, Ct *= ni), Le.set(ze, Ue, Ct, ni), Ee.equals(Le) === !1 && (r.clearColor(ze, Ue, Ct, ni), Ee.copy(Le));
      },
      reset: function() {
        ee = !1, de = null, Ee.set(-1, 0, 0, 0);
      }
    };
  }
  function n() {
    let ee = !1, Le = !1, de = null, Ee = null, ze = null;
    return {
      setReversed: function(Ue) {
        if (Le !== Ue) {
          const Ct = e.get("EXT_clip_control");
          Le ? Ct.clipControlEXT(Ct.LOWER_LEFT_EXT, Ct.ZERO_TO_ONE_EXT) : Ct.clipControlEXT(Ct.LOWER_LEFT_EXT, Ct.NEGATIVE_ONE_TO_ONE_EXT);
          const ni = ze;
          ze = null, this.setClear(ni);
        }
        Le = Ue;
      },
      getReversed: function() {
        return Le;
      },
      setTest: function(Ue) {
        Ue ? ne(r.DEPTH_TEST) : fe(r.DEPTH_TEST);
      },
      setMask: function(Ue) {
        de !== Ue && !ee && (r.depthMask(Ue), de = Ue);
      },
      setFunc: function(Ue) {
        if (Le && (Ue = vj[Ue]), Ee !== Ue) {
          switch (Ue) {
            case Jv:
              r.depthFunc(r.NEVER);
              break;
            case eb:
              r.depthFunc(r.ALWAYS);
              break;
            case tb:
              r.depthFunc(r.LESS);
              break;
            case hc:
              r.depthFunc(r.LEQUAL);
              break;
            case ib:
              r.depthFunc(r.EQUAL);
              break;
            case rb:
              r.depthFunc(r.GEQUAL);
              break;
            case nb:
              r.depthFunc(r.GREATER);
              break;
            case sb:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          Ee = Ue;
        }
      },
      setLocked: function(Ue) {
        ee = Ue;
      },
      setClear: function(Ue) {
        ze !== Ue && (Le && (Ue = 1 - Ue), r.clearDepth(Ue), ze = Ue);
      },
      reset: function() {
        ee = !1, de = null, Ee = null, ze = null, Le = !1;
      }
    };
  }
  function s() {
    let ee = !1, Le = null, de = null, Ee = null, ze = null, Ue = null, Ct = null, ni = null, _i = null;
    return {
      setTest: function(Bt) {
        ee || (Bt ? ne(r.STENCIL_TEST) : fe(r.STENCIL_TEST));
      },
      setMask: function(Bt) {
        Le !== Bt && !ee && (r.stencilMask(Bt), Le = Bt);
      },
      setFunc: function(Bt, yr, Xr) {
        (de !== Bt || Ee !== yr || ze !== Xr) && (r.stencilFunc(Bt, yr, Xr), de = Bt, Ee = yr, ze = Xr);
      },
      setOp: function(Bt, yr, Xr) {
        (Ue !== Bt || Ct !== yr || ni !== Xr) && (r.stencilOp(Bt, yr, Xr), Ue = Bt, Ct = yr, ni = Xr);
      },
      setLocked: function(Bt) {
        ee = Bt;
      },
      setClear: function(Bt) {
        _i !== Bt && (r.clearStencil(Bt), _i = Bt);
      },
      reset: function() {
        ee = !1, Le = null, de = null, Ee = null, ze = null, Ue = null, Ct = null, ni = null, _i = null;
      }
    };
  }
  const a = new i(), o = new n(), l = new s(), u = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
  let h = {}, d = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, y = !1, v = null, g = null, _ = null, x = null, b = null, T = null, S = null, w = new Ut(0, 0, 0), M = 0, E = !1, A = null, N = null, U = null, k = null, C = null;
  const I = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let O = !1, W = 0;
  const V = r.getParameter(r.VERSION);
  V.indexOf("WebGL") !== -1 ? (W = parseFloat(/^WebGL (\d)/.exec(V)[1]), O = W >= 1) : V.indexOf("OpenGL ES") !== -1 && (W = parseFloat(/^OpenGL ES (\d)/.exec(V)[1]), O = W >= 2);
  let Q = null, F = {};
  const B = r.getParameter(r.SCISSOR_BOX), q = r.getParameter(r.VIEWPORT), G = new Fi().fromArray(B), z = new Fi().fromArray(q);
  function Y(ee, Le, de, Ee) {
    const ze = new Uint8Array(4), Ue = r.createTexture();
    r.bindTexture(ee, Ue), r.texParameteri(ee, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(ee, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let Ct = 0; Ct < de; Ct++)
      ee === r.TEXTURE_3D || ee === r.TEXTURE_2D_ARRAY ? r.texImage3D(Le, 0, r.RGBA, 1, 1, Ee, 0, r.RGBA, r.UNSIGNED_BYTE, ze) : r.texImage2D(Le + Ct, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, ze);
    return Ue;
  }
  const se = {};
  se[r.TEXTURE_2D] = Y(r.TEXTURE_2D, r.TEXTURE_2D, 1), se[r.TEXTURE_CUBE_MAP] = Y(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), se[r.TEXTURE_2D_ARRAY] = Y(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), se[r.TEXTURE_3D] = Y(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), a.setClear(0, 0, 0, 1), o.setClear(1), l.setClear(0), ne(r.DEPTH_TEST), o.setFunc(hc), nt(!1), Tt(MS), ne(r.CULL_FACE), Z(la);
  function ne(ee) {
    h[ee] !== !0 && (r.enable(ee), h[ee] = !0);
  }
  function fe(ee) {
    h[ee] !== !1 && (r.disable(ee), h[ee] = !1);
  }
  function Se(ee, Le) {
    return d[ee] !== Le ? (r.bindFramebuffer(ee, Le), d[ee] = Le, ee === r.DRAW_FRAMEBUFFER && (d[r.FRAMEBUFFER] = Le), ee === r.FRAMEBUFFER && (d[r.DRAW_FRAMEBUFFER] = Le), !0) : !1;
  }
  function Pe(ee, Le) {
    let de = f, Ee = !1;
    if (ee) {
      de = p.get(Le), de === void 0 && (de = [], p.set(Le, de));
      const ze = ee.textures;
      if (de.length !== ze.length || de[0] !== r.COLOR_ATTACHMENT0) {
        for (let Ue = 0, Ct = ze.length; Ue < Ct; Ue++)
          de[Ue] = r.COLOR_ATTACHMENT0 + Ue;
        de.length = ze.length, Ee = !0;
      }
    } else
      de[0] !== r.BACK && (de[0] = r.BACK, Ee = !0);
    Ee && r.drawBuffers(de);
  }
  function lt(ee) {
    return m !== ee ? (r.useProgram(ee), m = ee, !0) : !1;
  }
  const xe = {
    [$o]: r.FUNC_ADD,
    [TF]: r.FUNC_SUBTRACT,
    [SF]: r.FUNC_REVERSE_SUBTRACT
  };
  xe[wF] = r.MIN, xe[EF] = r.MAX;
  const vt = {
    [MF]: r.ZERO,
    [AF]: r.ONE,
    [CF]: r.SRC_COLOR,
    [Zv]: r.SRC_ALPHA,
    [DF]: r.SRC_ALPHA_SATURATE,
    [IF]: r.DST_COLOR,
    [NF]: r.DST_ALPHA,
    [RF]: r.ONE_MINUS_SRC_COLOR,
    [Qv]: r.ONE_MINUS_SRC_ALPHA,
    [OF]: r.ONE_MINUS_DST_COLOR,
    [PF]: r.ONE_MINUS_DST_ALPHA,
    [LF]: r.CONSTANT_COLOR,
    [kF]: r.ONE_MINUS_CONSTANT_COLOR,
    [UF]: r.CONSTANT_ALPHA,
    [FF]: r.ONE_MINUS_CONSTANT_ALPHA
  };
  function Z(ee, Le, de, Ee, ze, Ue, Ct, ni, _i, Bt) {
    if (ee === la) {
      y === !0 && (fe(r.BLEND), y = !1);
      return;
    }
    if (y === !1 && (ne(r.BLEND), y = !0), ee !== _F) {
      if (ee !== v || Bt !== E) {
        if ((g !== $o || b !== $o) && (r.blendEquation(r.FUNC_ADD), g = $o, b = $o), Bt)
          switch (ee) {
            case Gu:
              r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case AS:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case CS:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case RS:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ee);
              break;
          }
        else
          switch (ee) {
            case Gu:
              r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case AS:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case CS:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case RS:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ee);
              break;
          }
        _ = null, x = null, T = null, S = null, w.set(0, 0, 0), M = 0, v = ee, E = Bt;
      }
      return;
    }
    ze = ze || Le, Ue = Ue || de, Ct = Ct || Ee, (Le !== g || ze !== b) && (r.blendEquationSeparate(xe[Le], xe[ze]), g = Le, b = ze), (de !== _ || Ee !== x || Ue !== T || Ct !== S) && (r.blendFuncSeparate(vt[de], vt[Ee], vt[Ue], vt[Ct]), _ = de, x = Ee, T = Ue, S = Ct), (ni.equals(w) === !1 || _i !== M) && (r.blendColor(ni.r, ni.g, ni.b, _i), w.copy(ni), M = _i), v = ee, E = !1;
  }
  function Ht(ee, Le) {
    ee.side === Zs ? fe(r.CULL_FACE) : ne(r.CULL_FACE);
    let de = ee.side === Mr;
    Le && (de = !de), nt(de), ee.blending === Gu && ee.transparent === !1 ? Z(la) : Z(ee.blending, ee.blendEquation, ee.blendSrc, ee.blendDst, ee.blendEquationAlpha, ee.blendSrcAlpha, ee.blendDstAlpha, ee.blendColor, ee.blendAlpha, ee.premultipliedAlpha), o.setFunc(ee.depthFunc), o.setTest(ee.depthTest), o.setMask(ee.depthWrite), a.setMask(ee.colorWrite);
    const Ee = ee.stencilWrite;
    l.setTest(Ee), Ee && (l.setMask(ee.stencilWriteMask), l.setFunc(ee.stencilFunc, ee.stencilRef, ee.stencilFuncMask), l.setOp(ee.stencilFail, ee.stencilZFail, ee.stencilZPass)), At(ee.polygonOffset, ee.polygonOffsetFactor, ee.polygonOffsetUnits), ee.alphaToCoverage === !0 ? ne(r.SAMPLE_ALPHA_TO_COVERAGE) : fe(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function nt(ee) {
    A !== ee && (ee ? r.frontFace(r.CW) : r.frontFace(r.CCW), A = ee);
  }
  function Tt(ee) {
    ee !== vF ? (ne(r.CULL_FACE), ee !== N && (ee === MS ? r.cullFace(r.BACK) : ee === bF ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : fe(r.CULL_FACE), N = ee;
  }
  function We(ee) {
    ee !== U && (O && r.lineWidth(ee), U = ee);
  }
  function At(ee, Le, de) {
    ee ? (ne(r.POLYGON_OFFSET_FILL), (k !== Le || C !== de) && (r.polygonOffset(Le, de), k = Le, C = de)) : fe(r.POLYGON_OFFSET_FILL);
  }
  function st(ee) {
    ee ? ne(r.SCISSOR_TEST) : fe(r.SCISSOR_TEST);
  }
  function j(ee) {
    ee === void 0 && (ee = r.TEXTURE0 + I - 1), Q !== ee && (r.activeTexture(ee), Q = ee);
  }
  function D(ee, Le, de) {
    de === void 0 && (Q === null ? de = r.TEXTURE0 + I - 1 : de = Q);
    let Ee = F[de];
    Ee === void 0 && (Ee = { type: void 0, texture: void 0 }, F[de] = Ee), (Ee.type !== ee || Ee.texture !== Le) && (Q !== de && (r.activeTexture(de), Q = de), r.bindTexture(ee, Le || se[ee]), Ee.type = ee, Ee.texture = Le);
  }
  function le() {
    const ee = F[Q];
    ee !== void 0 && ee.type !== void 0 && (r.bindTexture(ee.type, null), ee.type = void 0, ee.texture = void 0);
  }
  function Te() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Ce() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function _e() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Je() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Be() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Xe() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Pt() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Ie() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function $e() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function ut() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function ft(ee) {
    G.equals(ee) === !1 && (r.scissor(ee.x, ee.y, ee.z, ee.w), G.copy(ee));
  }
  function Ye(ee) {
    z.equals(ee) === !1 && (r.viewport(ee.x, ee.y, ee.z, ee.w), z.copy(ee));
  }
  function Ot(ee, Le) {
    let de = c.get(Le);
    de === void 0 && (de = /* @__PURE__ */ new WeakMap(), c.set(Le, de));
    let Ee = de.get(ee);
    Ee === void 0 && (Ee = r.getUniformBlockIndex(Le, ee.name), de.set(ee, Ee));
  }
  function bt(ee, Le) {
    const de = c.get(Le).get(ee);
    u.get(Le) !== de && (r.uniformBlockBinding(Le, de, ee.__bindingPointIndex), u.set(Le, de));
  }
  function jt() {
    r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), o.setReversed(!1), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), h = {}, Q = null, F = {}, d = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, y = !1, v = null, g = null, _ = null, x = null, b = null, T = null, S = null, w = new Ut(0, 0, 0), M = 0, E = !1, A = null, N = null, U = null, k = null, C = null, G.set(0, 0, r.canvas.width, r.canvas.height), z.set(0, 0, r.canvas.width, r.canvas.height), a.reset(), o.reset(), l.reset();
  }
  return {
    buffers: {
      color: a,
      depth: o,
      stencil: l
    },
    enable: ne,
    disable: fe,
    bindFramebuffer: Se,
    drawBuffers: Pe,
    useProgram: lt,
    setBlending: Z,
    setMaterial: Ht,
    setFlipSided: nt,
    setCullFace: Tt,
    setLineWidth: We,
    setPolygonOffset: At,
    setScissorTest: st,
    activeTexture: j,
    bindTexture: D,
    unbindTexture: le,
    compressedTexImage2D: Te,
    compressedTexImage3D: Ce,
    texImage2D: $e,
    texImage3D: ut,
    updateUBOMapping: Ot,
    uniformBlockBinding: bt,
    texStorage2D: Pt,
    texStorage3D: Ie,
    texSubImage2D: _e,
    texSubImage3D: Je,
    compressedTexSubImage2D: Be,
    compressedTexSubImage3D: Xe,
    scissor: ft,
    viewport: Ye,
    reset: jt
  };
}
function Sw(r, e, i, n) {
  const s = xj(n);
  switch (i) {
    case qC:
      return r * e;
    case $C:
      return r * e;
    case YC:
      return r * e * 2;
    case KC:
      return r * e / s.components * s.byteLength;
    case P_:
      return r * e / s.components * s.byteLength;
    case ZC:
      return r * e * 2 / s.components * s.byteLength;
    case I_:
      return r * e * 2 / s.components * s.byteLength;
    case XC:
      return r * e * 3 / s.components * s.byteLength;
    case Xn:
      return r * e * 4 / s.components * s.byteLength;
    case O_:
      return r * e * 4 / s.components * s.byteLength;
    case Wf:
    case qf:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Xf:
    case $f:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case hb:
    case pb:
      return Math.max(r, 16) * Math.max(e, 8) / 4;
    case cb:
    case db:
      return Math.max(r, 8) * Math.max(e, 8) / 2;
    case fb:
    case mb:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case gb:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case yb:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case vb:
      return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case bb:
      return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case xb:
      return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case _b:
      return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Tb:
      return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Sb:
      return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case wb:
      return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Eb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Mb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Ab:
      return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Cb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Rb:
      return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Nb:
      return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Yf:
    case Pb:
    case Ib:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
    case QC:
    case Ob:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
    case Db:
    case Lb:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${i} format.`
  );
}
function xj(r) {
  switch (r) {
    case ba:
    case GC:
      return { byteLength: 1, components: 1 };
    case cd:
    case HC:
    case Lc:
      return { byteLength: 2, components: 1 };
    case R_:
    case N_:
      return { byteLength: 2, components: 4 };
    case xl:
    case C_:
    case ra:
      return { byteLength: 4, components: 1 };
    case WC:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${r}.`);
}
function _j(r, e, i, n, s, a, o) {
  const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, u = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), c = new ke(), h = /* @__PURE__ */ new WeakMap();
  let d;
  const p = /* @__PURE__ */ new WeakMap();
  let f = !1;
  try {
    f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function m(j, D) {
    return f ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(j, D)
    ) : dd("canvas");
  }
  function y(j, D, le) {
    let Te = 1;
    const Ce = st(j);
    if ((Ce.width > le || Ce.height > le) && (Te = le / Math.max(Ce.width, Ce.height)), Te < 1)
      if (typeof HTMLImageElement < "u" && j instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && j instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && j instanceof ImageBitmap || typeof VideoFrame < "u" && j instanceof VideoFrame) {
        const _e = Math.floor(Te * Ce.width), Je = Math.floor(Te * Ce.height);
        d === void 0 && (d = m(_e, Je));
        const Be = D ? m(_e, Je) : d;
        return Be.width = _e, Be.height = Je, Be.getContext("2d").drawImage(j, 0, 0, _e, Je), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Ce.width + "x" + Ce.height + ") to (" + _e + "x" + Je + ")."), Be;
      } else
        return "data" in j && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Ce.width + "x" + Ce.height + ")."), j;
    return j;
  }
  function v(j) {
    return j.generateMipmaps;
  }
  function g(j) {
    r.generateMipmap(j);
  }
  function _(j) {
    return j.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : j.isWebGL3DRenderTarget ? r.TEXTURE_3D : j.isWebGLArrayRenderTarget || j.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D;
  }
  function x(j, D, le, Te, Ce = !1) {
    if (j !== null) {
      if (r[j] !== void 0) return r[j];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + j + "'");
    }
    let _e = D;
    if (D === r.RED && (le === r.FLOAT && (_e = r.R32F), le === r.HALF_FLOAT && (_e = r.R16F), le === r.UNSIGNED_BYTE && (_e = r.R8)), D === r.RED_INTEGER && (le === r.UNSIGNED_BYTE && (_e = r.R8UI), le === r.UNSIGNED_SHORT && (_e = r.R16UI), le === r.UNSIGNED_INT && (_e = r.R32UI), le === r.BYTE && (_e = r.R8I), le === r.SHORT && (_e = r.R16I), le === r.INT && (_e = r.R32I)), D === r.RG && (le === r.FLOAT && (_e = r.RG32F), le === r.HALF_FLOAT && (_e = r.RG16F), le === r.UNSIGNED_BYTE && (_e = r.RG8)), D === r.RG_INTEGER && (le === r.UNSIGNED_BYTE && (_e = r.RG8UI), le === r.UNSIGNED_SHORT && (_e = r.RG16UI), le === r.UNSIGNED_INT && (_e = r.RG32UI), le === r.BYTE && (_e = r.RG8I), le === r.SHORT && (_e = r.RG16I), le === r.INT && (_e = r.RG32I)), D === r.RGB_INTEGER && (le === r.UNSIGNED_BYTE && (_e = r.RGB8UI), le === r.UNSIGNED_SHORT && (_e = r.RGB16UI), le === r.UNSIGNED_INT && (_e = r.RGB32UI), le === r.BYTE && (_e = r.RGB8I), le === r.SHORT && (_e = r.RGB16I), le === r.INT && (_e = r.RGB32I)), D === r.RGBA_INTEGER && (le === r.UNSIGNED_BYTE && (_e = r.RGBA8UI), le === r.UNSIGNED_SHORT && (_e = r.RGBA16UI), le === r.UNSIGNED_INT && (_e = r.RGBA32UI), le === r.BYTE && (_e = r.RGBA8I), le === r.SHORT && (_e = r.RGBA16I), le === r.INT && (_e = r.RGBA32I)), D === r.RGB && le === r.UNSIGNED_INT_5_9_9_9_REV && (_e = r.RGB9_E5), D === r.RGBA) {
      const Je = Ce ? _g : Gt.getTransfer(Te);
      le === r.FLOAT && (_e = r.RGBA32F), le === r.HALF_FLOAT && (_e = r.RGBA16F), le === r.UNSIGNED_BYTE && (_e = Je === ei ? r.SRGB8_ALPHA8 : r.RGBA8), le === r.UNSIGNED_SHORT_4_4_4_4 && (_e = r.RGBA4), le === r.UNSIGNED_SHORT_5_5_5_1 && (_e = r.RGB5_A1);
    }
    return (_e === r.R16F || _e === r.R32F || _e === r.RG16F || _e === r.RG32F || _e === r.RGBA16F || _e === r.RGBA32F) && e.get("EXT_color_buffer_float"), _e;
  }
  function b(j, D) {
    let le;
    return j ? D === null || D === xl || D === fc ? le = r.DEPTH24_STENCIL8 : D === ra ? le = r.DEPTH32F_STENCIL8 : D === cd && (le = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : D === null || D === xl || D === fc ? le = r.DEPTH_COMPONENT24 : D === ra ? le = r.DEPTH_COMPONENT32F : D === cd && (le = r.DEPTH_COMPONENT16), le;
  }
  function T(j, D) {
    return v(j) === !0 || j.isFramebufferTexture && j.minFilter !== Kn && j.minFilter !== ds ? Math.log2(Math.max(D.width, D.height)) + 1 : j.mipmaps !== void 0 && j.mipmaps.length > 0 ? j.mipmaps.length : j.isCompressedTexture && Array.isArray(j.image) ? D.mipmaps.length : 1;
  }
  function S(j) {
    const D = j.target;
    D.removeEventListener("dispose", S), M(D), D.isVideoTexture && h.delete(D);
  }
  function w(j) {
    const D = j.target;
    D.removeEventListener("dispose", w), A(D);
  }
  function M(j) {
    const D = n.get(j);
    if (D.__webglInit === void 0) return;
    const le = j.source, Te = p.get(le);
    if (Te) {
      const Ce = Te[D.__cacheKey];
      Ce.usedTimes--, Ce.usedTimes === 0 && E(j), Object.keys(Te).length === 0 && p.delete(le);
    }
    n.remove(j);
  }
  function E(j) {
    const D = n.get(j);
    r.deleteTexture(D.__webglTexture);
    const le = j.source, Te = p.get(le);
    delete Te[D.__cacheKey], o.memory.textures--;
  }
  function A(j) {
    const D = n.get(j);
    if (j.depthTexture && (j.depthTexture.dispose(), n.remove(j.depthTexture)), j.isWebGLCubeRenderTarget)
      for (let Te = 0; Te < 6; Te++) {
        if (Array.isArray(D.__webglFramebuffer[Te]))
          for (let Ce = 0; Ce < D.__webglFramebuffer[Te].length; Ce++) r.deleteFramebuffer(D.__webglFramebuffer[Te][Ce]);
        else
          r.deleteFramebuffer(D.__webglFramebuffer[Te]);
        D.__webglDepthbuffer && r.deleteRenderbuffer(D.__webglDepthbuffer[Te]);
      }
    else {
      if (Array.isArray(D.__webglFramebuffer))
        for (let Te = 0; Te < D.__webglFramebuffer.length; Te++) r.deleteFramebuffer(D.__webglFramebuffer[Te]);
      else
        r.deleteFramebuffer(D.__webglFramebuffer);
      if (D.__webglDepthbuffer && r.deleteRenderbuffer(D.__webglDepthbuffer), D.__webglMultisampledFramebuffer && r.deleteFramebuffer(D.__webglMultisampledFramebuffer), D.__webglColorRenderbuffer)
        for (let Te = 0; Te < D.__webglColorRenderbuffer.length; Te++)
          D.__webglColorRenderbuffer[Te] && r.deleteRenderbuffer(D.__webglColorRenderbuffer[Te]);
      D.__webglDepthRenderbuffer && r.deleteRenderbuffer(D.__webglDepthRenderbuffer);
    }
    const le = j.textures;
    for (let Te = 0, Ce = le.length; Te < Ce; Te++) {
      const _e = n.get(le[Te]);
      _e.__webglTexture && (r.deleteTexture(_e.__webglTexture), o.memory.textures--), n.remove(le[Te]);
    }
    n.remove(j);
  }
  let N = 0;
  function U() {
    N = 0;
  }
  function k() {
    const j = N;
    return j >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + j + " texture units while this GPU supports only " + s.maxTextures), N += 1, j;
  }
  function C(j) {
    const D = [];
    return D.push(j.wrapS), D.push(j.wrapT), D.push(j.wrapR || 0), D.push(j.magFilter), D.push(j.minFilter), D.push(j.anisotropy), D.push(j.internalFormat), D.push(j.format), D.push(j.type), D.push(j.generateMipmaps), D.push(j.premultiplyAlpha), D.push(j.flipY), D.push(j.unpackAlignment), D.push(j.colorSpace), D.join();
  }
  function I(j, D) {
    const le = n.get(j);
    if (j.isVideoTexture && We(j), j.isRenderTargetTexture === !1 && j.version > 0 && le.__version !== j.version) {
      const Te = j.image;
      if (Te === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (Te.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        z(le, j, D);
        return;
      }
    }
    i.bindTexture(r.TEXTURE_2D, le.__webglTexture, r.TEXTURE0 + D);
  }
  function O(j, D) {
    const le = n.get(j);
    if (j.version > 0 && le.__version !== j.version) {
      z(le, j, D);
      return;
    }
    i.bindTexture(r.TEXTURE_2D_ARRAY, le.__webglTexture, r.TEXTURE0 + D);
  }
  function W(j, D) {
    const le = n.get(j);
    if (j.version > 0 && le.__version !== j.version) {
      z(le, j, D);
      return;
    }
    i.bindTexture(r.TEXTURE_3D, le.__webglTexture, r.TEXTURE0 + D);
  }
  function V(j, D) {
    const le = n.get(j);
    if (j.version > 0 && le.__version !== j.version) {
      Y(le, j, D);
      return;
    }
    i.bindTexture(r.TEXTURE_CUBE_MAP, le.__webglTexture, r.TEXTURE0 + D);
  }
  const Q = {
    [lb]: r.REPEAT,
    [rl]: r.CLAMP_TO_EDGE,
    [ub]: r.MIRRORED_REPEAT
  }, F = {
    [Kn]: r.NEAREST,
    [$F]: r.NEAREST_MIPMAP_NEAREST,
    [dp]: r.NEAREST_MIPMAP_LINEAR,
    [ds]: r.LINEAR,
    [Ty]: r.LINEAR_MIPMAP_NEAREST,
    [nl]: r.LINEAR_MIPMAP_LINEAR
  }, B = {
    [QF]: r.NEVER,
    [n5]: r.ALWAYS,
    [JF]: r.LESS,
    [eR]: r.LEQUAL,
    [e5]: r.EQUAL,
    [r5]: r.GEQUAL,
    [t5]: r.GREATER,
    [i5]: r.NOTEQUAL
  };
  function q(j, D) {
    if (D.type === ra && e.has("OES_texture_float_linear") === !1 && (D.magFilter === ds || D.magFilter === Ty || D.magFilter === dp || D.magFilter === nl || D.minFilter === ds || D.minFilter === Ty || D.minFilter === dp || D.minFilter === nl) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(j, r.TEXTURE_WRAP_S, Q[D.wrapS]), r.texParameteri(j, r.TEXTURE_WRAP_T, Q[D.wrapT]), (j === r.TEXTURE_3D || j === r.TEXTURE_2D_ARRAY) && r.texParameteri(j, r.TEXTURE_WRAP_R, Q[D.wrapR]), r.texParameteri(j, r.TEXTURE_MAG_FILTER, F[D.magFilter]), r.texParameteri(j, r.TEXTURE_MIN_FILTER, F[D.minFilter]), D.compareFunction && (r.texParameteri(j, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(j, r.TEXTURE_COMPARE_FUNC, B[D.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (D.magFilter === Kn || D.minFilter !== dp && D.minFilter !== nl || D.type === ra && e.has("OES_texture_float_linear") === !1) return;
      if (D.anisotropy > 1 || n.get(D).__currentAnisotropy) {
        const le = e.get("EXT_texture_filter_anisotropic");
        r.texParameterf(j, le.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(D.anisotropy, s.getMaxAnisotropy())), n.get(D).__currentAnisotropy = D.anisotropy;
      }
    }
  }
  function G(j, D) {
    let le = !1;
    j.__webglInit === void 0 && (j.__webglInit = !0, D.addEventListener("dispose", S));
    const Te = D.source;
    let Ce = p.get(Te);
    Ce === void 0 && (Ce = {}, p.set(Te, Ce));
    const _e = C(D);
    if (_e !== j.__cacheKey) {
      Ce[_e] === void 0 && (Ce[_e] = {
        texture: r.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, le = !0), Ce[_e].usedTimes++;
      const Je = Ce[j.__cacheKey];
      Je !== void 0 && (Ce[j.__cacheKey].usedTimes--, Je.usedTimes === 0 && E(D)), j.__cacheKey = _e, j.__webglTexture = Ce[_e].texture;
    }
    return le;
  }
  function z(j, D, le) {
    let Te = r.TEXTURE_2D;
    (D.isDataArrayTexture || D.isCompressedArrayTexture) && (Te = r.TEXTURE_2D_ARRAY), D.isData3DTexture && (Te = r.TEXTURE_3D);
    const Ce = G(j, D), _e = D.source;
    i.bindTexture(Te, j.__webglTexture, r.TEXTURE0 + le);
    const Je = n.get(_e);
    if (_e.version !== Je.__version || Ce === !0) {
      i.activeTexture(r.TEXTURE0 + le);
      const Be = Gt.getPrimaries(Gt.workingColorSpace), Xe = D.colorSpace === Qa ? null : Gt.getPrimaries(D.colorSpace), Pt = D.colorSpace === Qa || Be === Xe ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, D.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, D.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Pt);
      let Ie = y(D.image, !1, s.maxTextureSize);
      Ie = At(D, Ie);
      const $e = a.convert(D.format, D.colorSpace), ut = a.convert(D.type);
      let ft = x(D.internalFormat, $e, ut, D.colorSpace, D.isVideoTexture);
      q(Te, D);
      let Ye;
      const Ot = D.mipmaps, bt = D.isVideoTexture !== !0, jt = Je.__version === void 0 || Ce === !0, ee = _e.dataReady, Le = T(D, Ie);
      if (D.isDepthTexture)
        ft = b(D.format === mc, D.type), jt && (bt ? i.texStorage2D(r.TEXTURE_2D, 1, ft, Ie.width, Ie.height) : i.texImage2D(r.TEXTURE_2D, 0, ft, Ie.width, Ie.height, 0, $e, ut, null));
      else if (D.isDataTexture)
        if (Ot.length > 0) {
          bt && jt && i.texStorage2D(r.TEXTURE_2D, Le, ft, Ot[0].width, Ot[0].height);
          for (let de = 0, Ee = Ot.length; de < Ee; de++)
            Ye = Ot[de], bt ? ee && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, Ye.width, Ye.height, $e, ut, Ye.data) : i.texImage2D(r.TEXTURE_2D, de, ft, Ye.width, Ye.height, 0, $e, ut, Ye.data);
          D.generateMipmaps = !1;
        } else
          bt ? (jt && i.texStorage2D(r.TEXTURE_2D, Le, ft, Ie.width, Ie.height), ee && i.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ie.width, Ie.height, $e, ut, Ie.data)) : i.texImage2D(r.TEXTURE_2D, 0, ft, Ie.width, Ie.height, 0, $e, ut, Ie.data);
      else if (D.isCompressedTexture)
        if (D.isCompressedArrayTexture) {
          bt && jt && i.texStorage3D(r.TEXTURE_2D_ARRAY, Le, ft, Ot[0].width, Ot[0].height, Ie.depth);
          for (let de = 0, Ee = Ot.length; de < Ee; de++)
            if (Ye = Ot[de], D.format !== Xn)
              if ($e !== null)
                if (bt) {
                  if (ee)
                    if (D.layerUpdates.size > 0) {
                      const ze = Sw(Ye.width, Ye.height, D.format, D.type);
                      for (const Ue of D.layerUpdates) {
                        const Ct = Ye.data.subarray(
                          Ue * ze / Ye.data.BYTES_PER_ELEMENT,
                          (Ue + 1) * ze / Ye.data.BYTES_PER_ELEMENT
                        );
                        i.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, Ue, Ye.width, Ye.height, 1, $e, Ct);
                      }
                      D.clearLayerUpdates();
                    } else
                      i.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, 0, Ye.width, Ye.height, Ie.depth, $e, Ye.data);
                } else
                  i.compressedTexImage3D(r.TEXTURE_2D_ARRAY, de, ft, Ye.width, Ye.height, Ie.depth, 0, Ye.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              bt ? ee && i.texSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, 0, Ye.width, Ye.height, Ie.depth, $e, ut, Ye.data) : i.texImage3D(r.TEXTURE_2D_ARRAY, de, ft, Ye.width, Ye.height, Ie.depth, 0, $e, ut, Ye.data);
        } else {
          bt && jt && i.texStorage2D(r.TEXTURE_2D, Le, ft, Ot[0].width, Ot[0].height);
          for (let de = 0, Ee = Ot.length; de < Ee; de++)
            Ye = Ot[de], D.format !== Xn ? $e !== null ? bt ? ee && i.compressedTexSubImage2D(r.TEXTURE_2D, de, 0, 0, Ye.width, Ye.height, $e, Ye.data) : i.compressedTexImage2D(r.TEXTURE_2D, de, ft, Ye.width, Ye.height, 0, Ye.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : bt ? ee && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, Ye.width, Ye.height, $e, ut, Ye.data) : i.texImage2D(r.TEXTURE_2D, de, ft, Ye.width, Ye.height, 0, $e, ut, Ye.data);
        }
      else if (D.isDataArrayTexture)
        if (bt) {
          if (jt && i.texStorage3D(r.TEXTURE_2D_ARRAY, Le, ft, Ie.width, Ie.height, Ie.depth), ee)
            if (D.layerUpdates.size > 0) {
              const de = Sw(Ie.width, Ie.height, D.format, D.type);
              for (const Ee of D.layerUpdates) {
                const ze = Ie.data.subarray(
                  Ee * de / Ie.data.BYTES_PER_ELEMENT,
                  (Ee + 1) * de / Ie.data.BYTES_PER_ELEMENT
                );
                i.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, Ee, Ie.width, Ie.height, 1, $e, ut, ze);
              }
              D.clearLayerUpdates();
            } else
              i.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Ie.width, Ie.height, Ie.depth, $e, ut, Ie.data);
        } else
          i.texImage3D(r.TEXTURE_2D_ARRAY, 0, ft, Ie.width, Ie.height, Ie.depth, 0, $e, ut, Ie.data);
      else if (D.isData3DTexture)
        bt ? (jt && i.texStorage3D(r.TEXTURE_3D, Le, ft, Ie.width, Ie.height, Ie.depth), ee && i.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, Ie.width, Ie.height, Ie.depth, $e, ut, Ie.data)) : i.texImage3D(r.TEXTURE_3D, 0, ft, Ie.width, Ie.height, Ie.depth, 0, $e, ut, Ie.data);
      else if (D.isFramebufferTexture) {
        if (jt)
          if (bt)
            i.texStorage2D(r.TEXTURE_2D, Le, ft, Ie.width, Ie.height);
          else {
            let de = Ie.width, Ee = Ie.height;
            for (let ze = 0; ze < Le; ze++)
              i.texImage2D(r.TEXTURE_2D, ze, ft, de, Ee, 0, $e, ut, null), de >>= 1, Ee >>= 1;
          }
      } else if (Ot.length > 0) {
        if (bt && jt) {
          const de = st(Ot[0]);
          i.texStorage2D(r.TEXTURE_2D, Le, ft, de.width, de.height);
        }
        for (let de = 0, Ee = Ot.length; de < Ee; de++)
          Ye = Ot[de], bt ? ee && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, $e, ut, Ye) : i.texImage2D(r.TEXTURE_2D, de, ft, $e, ut, Ye);
        D.generateMipmaps = !1;
      } else if (bt) {
        if (jt) {
          const de = st(Ie);
          i.texStorage2D(r.TEXTURE_2D, Le, ft, de.width, de.height);
        }
        ee && i.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, $e, ut, Ie);
      } else
        i.texImage2D(r.TEXTURE_2D, 0, ft, $e, ut, Ie);
      v(D) && g(Te), Je.__version = _e.version, D.onUpdate && D.onUpdate(D);
    }
    j.__version = D.version;
  }
  function Y(j, D, le) {
    if (D.image.length !== 6) return;
    const Te = G(j, D), Ce = D.source;
    i.bindTexture(r.TEXTURE_CUBE_MAP, j.__webglTexture, r.TEXTURE0 + le);
    const _e = n.get(Ce);
    if (Ce.version !== _e.__version || Te === !0) {
      i.activeTexture(r.TEXTURE0 + le);
      const Je = Gt.getPrimaries(Gt.workingColorSpace), Be = D.colorSpace === Qa ? null : Gt.getPrimaries(D.colorSpace), Xe = D.colorSpace === Qa || Je === Be ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, D.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, D.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Xe);
      const Pt = D.isCompressedTexture || D.image[0].isCompressedTexture, Ie = D.image[0] && D.image[0].isDataTexture, $e = [];
      for (let Ee = 0; Ee < 6; Ee++)
        !Pt && !Ie ? $e[Ee] = y(D.image[Ee], !0, s.maxCubemapSize) : $e[Ee] = Ie ? D.image[Ee].image : D.image[Ee], $e[Ee] = At(D, $e[Ee]);
      const ut = $e[0], ft = a.convert(D.format, D.colorSpace), Ye = a.convert(D.type), Ot = x(D.internalFormat, ft, Ye, D.colorSpace), bt = D.isVideoTexture !== !0, jt = _e.__version === void 0 || Te === !0, ee = Ce.dataReady;
      let Le = T(D, ut);
      q(r.TEXTURE_CUBE_MAP, D);
      let de;
      if (Pt) {
        bt && jt && i.texStorage2D(r.TEXTURE_CUBE_MAP, Le, Ot, ut.width, ut.height);
        for (let Ee = 0; Ee < 6; Ee++) {
          de = $e[Ee].mipmaps;
          for (let ze = 0; ze < de.length; ze++) {
            const Ue = de[ze];
            D.format !== Xn ? ft !== null ? bt ? ee && i.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, ze, 0, 0, Ue.width, Ue.height, ft, Ue.data) : i.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, ze, Ot, Ue.width, Ue.height, 0, Ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : bt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, ze, 0, 0, Ue.width, Ue.height, ft, Ye, Ue.data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, ze, Ot, Ue.width, Ue.height, 0, ft, Ye, Ue.data);
          }
        }
      } else {
        if (de = D.mipmaps, bt && jt) {
          de.length > 0 && Le++;
          const Ee = st($e[0]);
          i.texStorage2D(r.TEXTURE_CUBE_MAP, Le, Ot, Ee.width, Ee.height);
        }
        for (let Ee = 0; Ee < 6; Ee++)
          if (Ie) {
            bt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, 0, 0, $e[Ee].width, $e[Ee].height, ft, Ye, $e[Ee].data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, Ot, $e[Ee].width, $e[Ee].height, 0, ft, Ye, $e[Ee].data);
            for (let ze = 0; ze < de.length; ze++) {
              const Ue = de[ze].image[Ee].image;
              bt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, ze + 1, 0, 0, Ue.width, Ue.height, ft, Ye, Ue.data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, ze + 1, Ot, Ue.width, Ue.height, 0, ft, Ye, Ue.data);
            }
          } else {
            bt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, 0, 0, ft, Ye, $e[Ee]) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, Ot, ft, Ye, $e[Ee]);
            for (let ze = 0; ze < de.length; ze++) {
              const Ue = de[ze];
              bt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, ze + 1, 0, 0, ft, Ye, Ue.image[Ee]) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, ze + 1, Ot, ft, Ye, Ue.image[Ee]);
            }
          }
      }
      v(D) && g(r.TEXTURE_CUBE_MAP), _e.__version = Ce.version, D.onUpdate && D.onUpdate(D);
    }
    j.__version = D.version;
  }
  function se(j, D, le, Te, Ce, _e) {
    const Je = a.convert(le.format, le.colorSpace), Be = a.convert(le.type), Xe = x(le.internalFormat, Je, Be, le.colorSpace), Pt = n.get(D), Ie = n.get(le);
    if (Ie.__renderTarget = D, !Pt.__hasExternalTextures) {
      const $e = Math.max(1, D.width >> _e), ut = Math.max(1, D.height >> _e);
      Ce === r.TEXTURE_3D || Ce === r.TEXTURE_2D_ARRAY ? i.texImage3D(Ce, _e, Xe, $e, ut, D.depth, 0, Je, Be, null) : i.texImage2D(Ce, _e, Xe, $e, ut, 0, Je, Be, null);
    }
    i.bindFramebuffer(r.FRAMEBUFFER, j), Tt(D) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, Te, Ce, Ie.__webglTexture, 0, nt(D)) : (Ce === r.TEXTURE_2D || Ce >= r.TEXTURE_CUBE_MAP_POSITIVE_X && Ce <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, Te, Ce, Ie.__webglTexture, _e), i.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function ne(j, D, le) {
    if (r.bindRenderbuffer(r.RENDERBUFFER, j), D.depthBuffer) {
      const Te = D.depthTexture, Ce = Te && Te.isDepthTexture ? Te.type : null, _e = b(D.stencilBuffer, Ce), Je = D.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Be = nt(D);
      Tt(D) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, Be, _e, D.width, D.height) : le ? r.renderbufferStorageMultisample(r.RENDERBUFFER, Be, _e, D.width, D.height) : r.renderbufferStorage(r.RENDERBUFFER, _e, D.width, D.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, Je, r.RENDERBUFFER, j);
    } else {
      const Te = D.textures;
      for (let Ce = 0; Ce < Te.length; Ce++) {
        const _e = Te[Ce], Je = a.convert(_e.format, _e.colorSpace), Be = a.convert(_e.type), Xe = x(_e.internalFormat, Je, Be, _e.colorSpace), Pt = nt(D);
        le && Tt(D) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, Pt, Xe, D.width, D.height) : Tt(D) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, Pt, Xe, D.width, D.height) : r.renderbufferStorage(r.RENDERBUFFER, Xe, D.width, D.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function fe(j, D) {
    if (D && D.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (i.bindFramebuffer(r.FRAMEBUFFER, j), !(D.depthTexture && D.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const le = n.get(D.depthTexture);
    le.__renderTarget = D, (!le.__webglTexture || D.depthTexture.image.width !== D.width || D.depthTexture.image.height !== D.height) && (D.depthTexture.image.width = D.width, D.depthTexture.image.height = D.height, D.depthTexture.needsUpdate = !0), I(D.depthTexture, 0);
    const Te = le.__webglTexture, Ce = nt(D);
    if (D.depthTexture.format === Hu)
      Tt(D) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Te, 0, Ce) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Te, 0);
    else if (D.depthTexture.format === mc)
      Tt(D) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Te, 0, Ce) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Te, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Se(j) {
    const D = n.get(j), le = j.isWebGLCubeRenderTarget === !0;
    if (D.__boundDepthTexture !== j.depthTexture) {
      const Te = j.depthTexture;
      if (D.__depthDisposeCallback && D.__depthDisposeCallback(), Te) {
        const Ce = () => {
          delete D.__boundDepthTexture, delete D.__depthDisposeCallback, Te.removeEventListener("dispose", Ce);
        };
        Te.addEventListener("dispose", Ce), D.__depthDisposeCallback = Ce;
      }
      D.__boundDepthTexture = Te;
    }
    if (j.depthTexture && !D.__autoAllocateDepthBuffer) {
      if (le) throw new Error("target.depthTexture not supported in Cube render targets");
      fe(D.__webglFramebuffer, j);
    } else if (le) {
      D.__webglDepthbuffer = [];
      for (let Te = 0; Te < 6; Te++)
        if (i.bindFramebuffer(r.FRAMEBUFFER, D.__webglFramebuffer[Te]), D.__webglDepthbuffer[Te] === void 0)
          D.__webglDepthbuffer[Te] = r.createRenderbuffer(), ne(D.__webglDepthbuffer[Te], j, !1);
        else {
          const Ce = j.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, _e = D.__webglDepthbuffer[Te];
          r.bindRenderbuffer(r.RENDERBUFFER, _e), r.framebufferRenderbuffer(r.FRAMEBUFFER, Ce, r.RENDERBUFFER, _e);
        }
    } else if (i.bindFramebuffer(r.FRAMEBUFFER, D.__webglFramebuffer), D.__webglDepthbuffer === void 0)
      D.__webglDepthbuffer = r.createRenderbuffer(), ne(D.__webglDepthbuffer, j, !1);
    else {
      const Te = j.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Ce = D.__webglDepthbuffer;
      r.bindRenderbuffer(r.RENDERBUFFER, Ce), r.framebufferRenderbuffer(r.FRAMEBUFFER, Te, r.RENDERBUFFER, Ce);
    }
    i.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function Pe(j, D, le) {
    const Te = n.get(j);
    D !== void 0 && se(Te.__webglFramebuffer, j, j.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), le !== void 0 && Se(j);
  }
  function lt(j) {
    const D = j.texture, le = n.get(j), Te = n.get(D);
    j.addEventListener("dispose", w);
    const Ce = j.textures, _e = j.isWebGLCubeRenderTarget === !0, Je = Ce.length > 1;
    if (Je || (Te.__webglTexture === void 0 && (Te.__webglTexture = r.createTexture()), Te.__version = D.version, o.memory.textures++), _e) {
      le.__webglFramebuffer = [];
      for (let Be = 0; Be < 6; Be++)
        if (D.mipmaps && D.mipmaps.length > 0) {
          le.__webglFramebuffer[Be] = [];
          for (let Xe = 0; Xe < D.mipmaps.length; Xe++)
            le.__webglFramebuffer[Be][Xe] = r.createFramebuffer();
        } else
          le.__webglFramebuffer[Be] = r.createFramebuffer();
    } else {
      if (D.mipmaps && D.mipmaps.length > 0) {
        le.__webglFramebuffer = [];
        for (let Be = 0; Be < D.mipmaps.length; Be++)
          le.__webglFramebuffer[Be] = r.createFramebuffer();
      } else
        le.__webglFramebuffer = r.createFramebuffer();
      if (Je)
        for (let Be = 0, Xe = Ce.length; Be < Xe; Be++) {
          const Pt = n.get(Ce[Be]);
          Pt.__webglTexture === void 0 && (Pt.__webglTexture = r.createTexture(), o.memory.textures++);
        }
      if (j.samples > 0 && Tt(j) === !1) {
        le.__webglMultisampledFramebuffer = r.createFramebuffer(), le.__webglColorRenderbuffer = [], i.bindFramebuffer(r.FRAMEBUFFER, le.__webglMultisampledFramebuffer);
        for (let Be = 0; Be < Ce.length; Be++) {
          const Xe = Ce[Be];
          le.__webglColorRenderbuffer[Be] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, le.__webglColorRenderbuffer[Be]);
          const Pt = a.convert(Xe.format, Xe.colorSpace), Ie = a.convert(Xe.type), $e = x(Xe.internalFormat, Pt, Ie, Xe.colorSpace, j.isXRRenderTarget === !0), ut = nt(j);
          r.renderbufferStorageMultisample(r.RENDERBUFFER, ut, $e, j.width, j.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Be, r.RENDERBUFFER, le.__webglColorRenderbuffer[Be]);
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null), j.depthBuffer && (le.__webglDepthRenderbuffer = r.createRenderbuffer(), ne(le.__webglDepthRenderbuffer, j, !0)), i.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (_e) {
      i.bindTexture(r.TEXTURE_CUBE_MAP, Te.__webglTexture), q(r.TEXTURE_CUBE_MAP, D);
      for (let Be = 0; Be < 6; Be++)
        if (D.mipmaps && D.mipmaps.length > 0)
          for (let Xe = 0; Xe < D.mipmaps.length; Xe++)
            se(le.__webglFramebuffer[Be][Xe], j, D, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Be, Xe);
        else
          se(le.__webglFramebuffer[Be], j, D, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0);
      v(D) && g(r.TEXTURE_CUBE_MAP), i.unbindTexture();
    } else if (Je) {
      for (let Be = 0, Xe = Ce.length; Be < Xe; Be++) {
        const Pt = Ce[Be], Ie = n.get(Pt);
        i.bindTexture(r.TEXTURE_2D, Ie.__webglTexture), q(r.TEXTURE_2D, Pt), se(le.__webglFramebuffer, j, Pt, r.COLOR_ATTACHMENT0 + Be, r.TEXTURE_2D, 0), v(Pt) && g(r.TEXTURE_2D);
      }
      i.unbindTexture();
    } else {
      let Be = r.TEXTURE_2D;
      if ((j.isWebGL3DRenderTarget || j.isWebGLArrayRenderTarget) && (Be = j.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), i.bindTexture(Be, Te.__webglTexture), q(Be, D), D.mipmaps && D.mipmaps.length > 0)
        for (let Xe = 0; Xe < D.mipmaps.length; Xe++)
          se(le.__webglFramebuffer[Xe], j, D, r.COLOR_ATTACHMENT0, Be, Xe);
      else
        se(le.__webglFramebuffer, j, D, r.COLOR_ATTACHMENT0, Be, 0);
      v(D) && g(Be), i.unbindTexture();
    }
    j.depthBuffer && Se(j);
  }
  function xe(j) {
    const D = j.textures;
    for (let le = 0, Te = D.length; le < Te; le++) {
      const Ce = D[le];
      if (v(Ce)) {
        const _e = _(j), Je = n.get(Ce).__webglTexture;
        i.bindTexture(_e, Je), g(_e), i.unbindTexture();
      }
    }
  }
  const vt = [], Z = [];
  function Ht(j) {
    if (j.samples > 0) {
      if (Tt(j) === !1) {
        const D = j.textures, le = j.width, Te = j.height;
        let Ce = r.COLOR_BUFFER_BIT;
        const _e = j.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Je = n.get(j), Be = D.length > 1;
        if (Be)
          for (let Xe = 0; Xe < D.length; Xe++)
            i.bindFramebuffer(r.FRAMEBUFFER, Je.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Xe, r.RENDERBUFFER, null), i.bindFramebuffer(r.FRAMEBUFFER, Je.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Xe, r.TEXTURE_2D, null, 0);
        i.bindFramebuffer(r.READ_FRAMEBUFFER, Je.__webglMultisampledFramebuffer), i.bindFramebuffer(r.DRAW_FRAMEBUFFER, Je.__webglFramebuffer);
        for (let Xe = 0; Xe < D.length; Xe++) {
          if (j.resolveDepthBuffer && (j.depthBuffer && (Ce |= r.DEPTH_BUFFER_BIT), j.stencilBuffer && j.resolveStencilBuffer && (Ce |= r.STENCIL_BUFFER_BIT)), Be) {
            r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, Je.__webglColorRenderbuffer[Xe]);
            const Pt = n.get(D[Xe]).__webglTexture;
            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, Pt, 0);
          }
          r.blitFramebuffer(0, 0, le, Te, 0, 0, le, Te, Ce, r.NEAREST), u === !0 && (vt.length = 0, Z.length = 0, vt.push(r.COLOR_ATTACHMENT0 + Xe), j.depthBuffer && j.resolveDepthBuffer === !1 && (vt.push(_e), Z.push(_e), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, Z)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, vt));
        }
        if (i.bindFramebuffer(r.READ_FRAMEBUFFER, null), i.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), Be)
          for (let Xe = 0; Xe < D.length; Xe++) {
            i.bindFramebuffer(r.FRAMEBUFFER, Je.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Xe, r.RENDERBUFFER, Je.__webglColorRenderbuffer[Xe]);
            const Pt = n.get(D[Xe]).__webglTexture;
            i.bindFramebuffer(r.FRAMEBUFFER, Je.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Xe, r.TEXTURE_2D, Pt, 0);
          }
        i.bindFramebuffer(r.DRAW_FRAMEBUFFER, Je.__webglMultisampledFramebuffer);
      } else if (j.depthBuffer && j.resolveDepthBuffer === !1 && u) {
        const D = j.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
        r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [D]);
      }
    }
  }
  function nt(j) {
    return Math.min(s.maxSamples, j.samples);
  }
  function Tt(j) {
    const D = n.get(j);
    return j.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && D.__useRenderToTexture !== !1;
  }
  function We(j) {
    const D = o.render.frame;
    h.get(j) !== D && (h.set(j, D), j.update());
  }
  function At(j, D) {
    const le = j.colorSpace, Te = j.format, Ce = j.type;
    return j.isCompressedTexture === !0 || j.isVideoTexture === !0 || le !== kc && le !== Qa && (Gt.getTransfer(le) === ei ? (Te !== Xn || Ce !== ba) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", le)), D;
  }
  function st(j) {
    return typeof HTMLImageElement < "u" && j instanceof HTMLImageElement ? (c.width = j.naturalWidth || j.width, c.height = j.naturalHeight || j.height) : typeof VideoFrame < "u" && j instanceof VideoFrame ? (c.width = j.displayWidth, c.height = j.displayHeight) : (c.width = j.width, c.height = j.height), c;
  }
  this.allocateTextureUnit = k, this.resetTextureUnits = U, this.setTexture2D = I, this.setTexture2DArray = O, this.setTexture3D = W, this.setTextureCube = V, this.rebindTextures = Pe, this.setupRenderTarget = lt, this.updateRenderTargetMipmap = xe, this.updateMultisampleRenderTarget = Ht, this.setupDepthRenderbuffer = Se, this.setupFrameBufferTexture = se, this.useMultisampledRTT = Tt;
}
function Tj(r, e) {
  function i(n, s = Qa) {
    let a;
    const o = Gt.getTransfer(s);
    if (n === ba) return r.UNSIGNED_BYTE;
    if (n === R_) return r.UNSIGNED_SHORT_4_4_4_4;
    if (n === N_) return r.UNSIGNED_SHORT_5_5_5_1;
    if (n === WC) return r.UNSIGNED_INT_5_9_9_9_REV;
    if (n === GC) return r.BYTE;
    if (n === HC) return r.SHORT;
    if (n === cd) return r.UNSIGNED_SHORT;
    if (n === C_) return r.INT;
    if (n === xl) return r.UNSIGNED_INT;
    if (n === ra) return r.FLOAT;
    if (n === Lc) return r.HALF_FLOAT;
    if (n === qC) return r.ALPHA;
    if (n === XC) return r.RGB;
    if (n === Xn) return r.RGBA;
    if (n === $C) return r.LUMINANCE;
    if (n === YC) return r.LUMINANCE_ALPHA;
    if (n === Hu) return r.DEPTH_COMPONENT;
    if (n === mc) return r.DEPTH_STENCIL;
    if (n === KC) return r.RED;
    if (n === P_) return r.RED_INTEGER;
    if (n === ZC) return r.RG;
    if (n === I_) return r.RG_INTEGER;
    if (n === O_) return r.RGBA_INTEGER;
    if (n === Wf || n === qf || n === Xf || n === $f)
      if (o === ei)
        if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (n === Wf) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === qf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === Xf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === $f) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (n === Wf) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === qf) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === Xf) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === $f) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === cb || n === hb || n === db || n === pb)
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (n === cb) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === hb) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === db) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === pb) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === fb || n === mb || n === gb)
      if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (n === fb || n === mb) return o === ei ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (n === gb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (n === yb || n === vb || n === bb || n === xb || n === _b || n === Tb || n === Sb || n === wb || n === Eb || n === Mb || n === Ab || n === Cb || n === Rb || n === Nb)
      if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (n === yb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === vb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === bb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === xb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === _b) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === Tb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === Sb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === wb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === Eb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === Mb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === Ab) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === Cb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === Rb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === Nb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === Yf || n === Pb || n === Ib)
      if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
        if (n === Yf) return o === ei ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === Pb) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === Ib) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (n === QC || n === Ob || n === Db || n === Lb)
      if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
        if (n === Yf) return a.COMPRESSED_RED_RGTC1_EXT;
        if (n === Ob) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === Db) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === Lb) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === fc ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null;
  }
  return { convert: i };
}
class Sj extends yn {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
let sl = class extends Vr {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
};
const wj = { type: "move" };
class Yy {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new sl(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new sl(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new X(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new X()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new sl(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new X(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new X()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const i = this._hand;
      if (i)
        for (const n of e.hand.values())
          this._getHandJoint(i, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, i, n) {
    let s = null, a = null, o = null;
    const l = this._targetRay, u = this._grip, c = this._hand;
    if (e && i.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const y of e.hand.values()) {
          const v = i.getJointPose(y, n), g = this._getHandJoint(c, y);
          v !== null && (g.matrix.fromArray(v.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, g.jointRadius = v.radius), g.visible = v !== null;
        }
        const h = c.joints["index-finger-tip"], d = c.joints["thumb-tip"], p = h.position.distanceTo(d.position), f = 0.02, m = 5e-3;
        c.inputState.pinching && p > f + m ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && p <= f - m && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        u !== null && e.gripSpace && (a = i.getPose(e.gripSpace, n), a !== null && (u.matrix.fromArray(a.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (u.hasLinearVelocity = !0, u.linearVelocity.copy(a.linearVelocity)) : u.hasLinearVelocity = !1, a.angularVelocity ? (u.hasAngularVelocity = !0, u.angularVelocity.copy(a.angularVelocity)) : u.hasAngularVelocity = !1));
      l !== null && (s = i.getPose(e.targetRaySpace, n), s === null && a !== null && (s = a), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent(wj)));
    }
    return l !== null && (l.visible = s !== null), u !== null && (u.visible = a !== null), c !== null && (c.visible = o !== null), this;
  }
  // private method
  _getHandJoint(e, i) {
    if (e.joints[i.jointName] === void 0) {
      const n = new sl();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[i.jointName] = n, e.add(n);
    }
    return e.joints[i.jointName];
  }
}
const Ej = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, Mj = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class Aj {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, i, n) {
    if (this.texture === null) {
      const s = new wn(), a = e.properties.get(s);
      a.__webglTexture = i.texture, (i.depthNear != n.depthNear || i.depthFar != n.depthFar) && (this.depthNear = i.depthNear, this.depthFar = i.depthFar), this.texture = s;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const i = e.cameras[0].viewport, n = new xs({
        vertexShader: Ej,
        fragmentShader: Mj,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: i.z },
          depthHeight: { value: i.w }
        }
      });
      this.mesh = new Lr(new Hd(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class Cj extends Cl {
  constructor(e, i) {
    super();
    const n = this;
    let s = null, a = 1, o = null, l = "local-floor", u = 1, c = null, h = null, d = null, p = null, f = null, m = null;
    const y = new Aj(), v = i.getContextAttributes();
    let g = null, _ = null;
    const x = [], b = [], T = new ke();
    let S = null;
    const w = new yn();
    w.viewport = new Fi();
    const M = new yn();
    M.viewport = new Fi();
    const E = [w, M], A = new Sj();
    let N = null, U = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(z) {
      let Y = x[z];
      return Y === void 0 && (Y = new Yy(), x[z] = Y), Y.getTargetRaySpace();
    }, this.getControllerGrip = function(z) {
      let Y = x[z];
      return Y === void 0 && (Y = new Yy(), x[z] = Y), Y.getGripSpace();
    }, this.getHand = function(z) {
      let Y = x[z];
      return Y === void 0 && (Y = new Yy(), x[z] = Y), Y.getHandSpace();
    };
    function k(z) {
      const Y = b.indexOf(z.inputSource);
      if (Y === -1)
        return;
      const se = x[Y];
      se !== void 0 && (se.update(z.inputSource, z.frame, c || o), se.dispatchEvent({ type: z.type, data: z.inputSource }));
    }
    function C() {
      s.removeEventListener("select", k), s.removeEventListener("selectstart", k), s.removeEventListener("selectend", k), s.removeEventListener("squeeze", k), s.removeEventListener("squeezestart", k), s.removeEventListener("squeezeend", k), s.removeEventListener("end", C), s.removeEventListener("inputsourceschange", I);
      for (let z = 0; z < x.length; z++) {
        const Y = b[z];
        Y !== null && (b[z] = null, x[z].disconnect(Y));
      }
      N = null, U = null, y.reset(), e.setRenderTarget(g), f = null, p = null, d = null, s = null, _ = null, G.stop(), n.isPresenting = !1, e.setPixelRatio(S), e.setSize(T.width, T.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(z) {
      a = z, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(z) {
      l = z, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || o;
    }, this.setReferenceSpace = function(z) {
      c = z;
    }, this.getBaseLayer = function() {
      return p !== null ? p : f;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return s;
    }, this.setSession = async function(z) {
      if (s = z, s !== null) {
        if (g = e.getRenderTarget(), s.addEventListener("select", k), s.addEventListener("selectstart", k), s.addEventListener("selectend", k), s.addEventListener("squeeze", k), s.addEventListener("squeezestart", k), s.addEventListener("squeezeend", k), s.addEventListener("end", C), s.addEventListener("inputsourceschange", I), v.xrCompatible !== !0 && await i.makeXRCompatible(), S = e.getPixelRatio(), e.getSize(T), s.renderState.layers === void 0) {
          const Y = {
            antialias: v.antialias,
            alpha: !0,
            depth: v.depth,
            stencil: v.stencil,
            framebufferScaleFactor: a
          };
          f = new XRWebGLLayer(s, i, Y), s.updateRenderState({ baseLayer: f }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), _ = new go(
            f.framebufferWidth,
            f.framebufferHeight,
            {
              format: Xn,
              type: ba,
              colorSpace: e.outputColorSpace,
              stencilBuffer: v.stencil
            }
          );
        } else {
          let Y = null, se = null, ne = null;
          v.depth && (ne = v.stencil ? i.DEPTH24_STENCIL8 : i.DEPTH_COMPONENT24, Y = v.stencil ? mc : Hu, se = v.stencil ? fc : xl);
          const fe = {
            colorFormat: i.RGBA8,
            depthFormat: ne,
            scaleFactor: a
          };
          d = new XRWebGLBinding(s, i), p = d.createProjectionLayer(fe), s.updateRenderState({ layers: [p] }), e.setPixelRatio(1), e.setSize(p.textureWidth, p.textureHeight, !1), _ = new go(
            p.textureWidth,
            p.textureHeight,
            {
              format: Xn,
              type: ba,
              depthTexture: new bR(p.textureWidth, p.textureHeight, se, void 0, void 0, void 0, void 0, void 0, void 0, Y),
              stencilBuffer: v.stencil,
              colorSpace: e.outputColorSpace,
              samples: v.antialias ? 4 : 0,
              resolveDepthBuffer: p.ignoreDepthValues === !1
            }
          );
        }
        _.isXRRenderTarget = !0, this.setFoveation(u), c = null, o = await s.requestReferenceSpace(l), G.setContext(s), G.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (s !== null)
        return s.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return y.getDepthTexture();
    };
    function I(z) {
      for (let Y = 0; Y < z.removed.length; Y++) {
        const se = z.removed[Y], ne = b.indexOf(se);
        ne >= 0 && (b[ne] = null, x[ne].disconnect(se));
      }
      for (let Y = 0; Y < z.added.length; Y++) {
        const se = z.added[Y];
        let ne = b.indexOf(se);
        if (ne === -1) {
          for (let Se = 0; Se < x.length; Se++)
            if (Se >= b.length) {
              b.push(se), ne = Se;
              break;
            } else if (b[Se] === null) {
              b[Se] = se, ne = Se;
              break;
            }
          if (ne === -1) break;
        }
        const fe = x[ne];
        fe && fe.connect(se);
      }
    }
    const O = new X(), W = new X();
    function V(z, Y, se) {
      O.setFromMatrixPosition(Y.matrixWorld), W.setFromMatrixPosition(se.matrixWorld);
      const ne = O.distanceTo(W), fe = Y.projectionMatrix.elements, Se = se.projectionMatrix.elements, Pe = fe[14] / (fe[10] - 1), lt = fe[14] / (fe[10] + 1), xe = (fe[9] + 1) / fe[5], vt = (fe[9] - 1) / fe[5], Z = (fe[8] - 1) / fe[0], Ht = (Se[8] + 1) / Se[0], nt = Pe * Z, Tt = Pe * Ht, We = ne / (-Z + Ht), At = We * -Z;
      if (Y.matrixWorld.decompose(z.position, z.quaternion, z.scale), z.translateX(At), z.translateZ(We), z.matrixWorld.compose(z.position, z.quaternion, z.scale), z.matrixWorldInverse.copy(z.matrixWorld).invert(), fe[10] === -1)
        z.projectionMatrix.copy(Y.projectionMatrix), z.projectionMatrixInverse.copy(Y.projectionMatrixInverse);
      else {
        const st = Pe + We, j = lt + We, D = nt - At, le = Tt + (ne - At), Te = xe * lt / j * st, Ce = vt * lt / j * st;
        z.projectionMatrix.makePerspective(D, le, Te, Ce, st, j), z.projectionMatrixInverse.copy(z.projectionMatrix).invert();
      }
    }
    function Q(z, Y) {
      Y === null ? z.matrixWorld.copy(z.matrix) : z.matrixWorld.multiplyMatrices(Y.matrixWorld, z.matrix), z.matrixWorldInverse.copy(z.matrixWorld).invert();
    }
    this.updateCamera = function(z) {
      if (s === null) return;
      let Y = z.near, se = z.far;
      y.texture !== null && (y.depthNear > 0 && (Y = y.depthNear), y.depthFar > 0 && (se = y.depthFar)), A.near = M.near = w.near = Y, A.far = M.far = w.far = se, (N !== A.near || U !== A.far) && (s.updateRenderState({
        depthNear: A.near,
        depthFar: A.far
      }), N = A.near, U = A.far), w.layers.mask = z.layers.mask | 2, M.layers.mask = z.layers.mask | 4, A.layers.mask = w.layers.mask | M.layers.mask;
      const ne = z.parent, fe = A.cameras;
      Q(A, ne);
      for (let Se = 0; Se < fe.length; Se++)
        Q(fe[Se], ne);
      fe.length === 2 ? V(A, w, M) : A.projectionMatrix.copy(w.projectionMatrix), F(z, A, ne);
    };
    function F(z, Y, se) {
      se === null ? z.matrix.copy(Y.matrixWorld) : (z.matrix.copy(se.matrixWorld), z.matrix.invert(), z.matrix.multiply(Y.matrixWorld)), z.matrix.decompose(z.position, z.quaternion, z.scale), z.updateMatrixWorld(!0), z.projectionMatrix.copy(Y.projectionMatrix), z.projectionMatrixInverse.copy(Y.projectionMatrixInverse), z.isPerspectiveCamera && (z.fov = hd * 2 * Math.atan(1 / z.projectionMatrix.elements[5]), z.zoom = 1);
    }
    this.getCamera = function() {
      return A;
    }, this.getFoveation = function() {
      if (!(p === null && f === null))
        return u;
    }, this.setFoveation = function(z) {
      u = z, p !== null && (p.fixedFoveation = z), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = z);
    }, this.hasDepthSensing = function() {
      return y.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return y.getMesh(A);
    };
    let B = null;
    function q(z, Y) {
      if (h = Y.getViewerPose(c || o), m = Y, h !== null) {
        const se = h.views;
        f !== null && (e.setRenderTargetFramebuffer(_, f.framebuffer), e.setRenderTarget(_));
        let ne = !1;
        se.length !== A.cameras.length && (A.cameras.length = 0, ne = !0);
        for (let Se = 0; Se < se.length; Se++) {
          const Pe = se[Se];
          let lt = null;
          if (f !== null)
            lt = f.getViewport(Pe);
          else {
            const vt = d.getViewSubImage(p, Pe);
            lt = vt.viewport, Se === 0 && (e.setRenderTargetTextures(
              _,
              vt.colorTexture,
              p.ignoreDepthValues ? void 0 : vt.depthStencilTexture
            ), e.setRenderTarget(_));
          }
          let xe = E[Se];
          xe === void 0 && (xe = new yn(), xe.layers.enable(Se), xe.viewport = new Fi(), E[Se] = xe), xe.matrix.fromArray(Pe.transform.matrix), xe.matrix.decompose(xe.position, xe.quaternion, xe.scale), xe.projectionMatrix.fromArray(Pe.projectionMatrix), xe.projectionMatrixInverse.copy(xe.projectionMatrix).invert(), xe.viewport.set(lt.x, lt.y, lt.width, lt.height), Se === 0 && (A.matrix.copy(xe.matrix), A.matrix.decompose(A.position, A.quaternion, A.scale)), ne === !0 && A.cameras.push(xe);
        }
        const fe = s.enabledFeatures;
        if (fe && fe.includes("depth-sensing")) {
          const Se = d.getDepthInformation(se[0]);
          Se && Se.isValid && Se.texture && y.init(e, Se, s.renderState);
        }
      }
      for (let se = 0; se < x.length; se++) {
        const ne = b[se], fe = x[se];
        ne !== null && fe !== void 0 && fe.update(ne, Y, c || o);
      }
      B && B(z, Y), Y.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: Y }), m = null;
    }
    const G = new vR();
    G.setAnimationLoop(q), this.setAnimationLoop = function(z) {
      B = z;
    }, this.dispose = function() {
    };
  }
}
const Do = /* @__PURE__ */ new yo(), Rj = /* @__PURE__ */ new ui();
function Nj(r, e) {
  function i(v, g) {
    v.matrixAutoUpdate === !0 && v.updateMatrix(), g.value.copy(v.matrix);
  }
  function n(v, g) {
    g.color.getRGB(v.fogColor.value, fR(r)), g.isFog ? (v.fogNear.value = g.near, v.fogFar.value = g.far) : g.isFogExp2 && (v.fogDensity.value = g.density);
  }
  function s(v, g, _, x, b) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial ? a(v, g) : g.isMeshToonMaterial ? (a(v, g), d(v, g)) : g.isMeshPhongMaterial ? (a(v, g), h(v, g)) : g.isMeshStandardMaterial ? (a(v, g), p(v, g), g.isMeshPhysicalMaterial && f(v, g, b)) : g.isMeshMatcapMaterial ? (a(v, g), m(v, g)) : g.isMeshDepthMaterial ? a(v, g) : g.isMeshDistanceMaterial ? (a(v, g), y(v, g)) : g.isMeshNormalMaterial ? a(v, g) : g.isLineBasicMaterial ? (o(v, g), g.isLineDashedMaterial && l(v, g)) : g.isPointsMaterial ? u(v, g, _, x) : g.isSpriteMaterial ? c(v, g) : g.isShadowMaterial ? (v.color.value.copy(g.color), v.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function a(v, g) {
    v.opacity.value = g.opacity, g.color && v.diffuse.value.copy(g.color), g.emissive && v.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (v.map.value = g.map, i(g.map, v.mapTransform)), g.alphaMap && (v.alphaMap.value = g.alphaMap, i(g.alphaMap, v.alphaMapTransform)), g.bumpMap && (v.bumpMap.value = g.bumpMap, i(g.bumpMap, v.bumpMapTransform), v.bumpScale.value = g.bumpScale, g.side === Mr && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, i(g.normalMap, v.normalMapTransform), v.normalScale.value.copy(g.normalScale), g.side === Mr && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, i(g.displacementMap, v.displacementMapTransform), v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias), g.emissiveMap && (v.emissiveMap.value = g.emissiveMap, i(g.emissiveMap, v.emissiveMapTransform)), g.specularMap && (v.specularMap.value = g.specularMap, i(g.specularMap, v.specularMapTransform)), g.alphaTest > 0 && (v.alphaTest.value = g.alphaTest);
    const _ = e.get(g), x = _.envMap, b = _.envMapRotation;
    x && (v.envMap.value = x, Do.copy(b), Do.x *= -1, Do.y *= -1, Do.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === !1 && (Do.y *= -1, Do.z *= -1), v.envMapRotation.value.setFromMatrix4(Rj.makeRotationFromEuler(Do)), v.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, v.reflectivity.value = g.reflectivity, v.ior.value = g.ior, v.refractionRatio.value = g.refractionRatio), g.lightMap && (v.lightMap.value = g.lightMap, v.lightMapIntensity.value = g.lightMapIntensity, i(g.lightMap, v.lightMapTransform)), g.aoMap && (v.aoMap.value = g.aoMap, v.aoMapIntensity.value = g.aoMapIntensity, i(g.aoMap, v.aoMapTransform));
  }
  function o(v, g) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, g.map && (v.map.value = g.map, i(g.map, v.mapTransform));
  }
  function l(v, g) {
    v.dashSize.value = g.dashSize, v.totalSize.value = g.dashSize + g.gapSize, v.scale.value = g.scale;
  }
  function u(v, g, _, x) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, v.size.value = g.size * _, v.scale.value = x * 0.5, g.map && (v.map.value = g.map, i(g.map, v.uvTransform)), g.alphaMap && (v.alphaMap.value = g.alphaMap, i(g.alphaMap, v.alphaMapTransform)), g.alphaTest > 0 && (v.alphaTest.value = g.alphaTest);
  }
  function c(v, g) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, v.rotation.value = g.rotation, g.map && (v.map.value = g.map, i(g.map, v.mapTransform)), g.alphaMap && (v.alphaMap.value = g.alphaMap, i(g.alphaMap, v.alphaMapTransform)), g.alphaTest > 0 && (v.alphaTest.value = g.alphaTest);
  }
  function h(v, g) {
    v.specular.value.copy(g.specular), v.shininess.value = Math.max(g.shininess, 1e-4);
  }
  function d(v, g) {
    g.gradientMap && (v.gradientMap.value = g.gradientMap);
  }
  function p(v, g) {
    v.metalness.value = g.metalness, g.metalnessMap && (v.metalnessMap.value = g.metalnessMap, i(g.metalnessMap, v.metalnessMapTransform)), v.roughness.value = g.roughness, g.roughnessMap && (v.roughnessMap.value = g.roughnessMap, i(g.roughnessMap, v.roughnessMapTransform)), g.envMap && (v.envMapIntensity.value = g.envMapIntensity);
  }
  function f(v, g, _) {
    v.ior.value = g.ior, g.sheen > 0 && (v.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), v.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (v.sheenColorMap.value = g.sheenColorMap, i(g.sheenColorMap, v.sheenColorMapTransform)), g.sheenRoughnessMap && (v.sheenRoughnessMap.value = g.sheenRoughnessMap, i(g.sheenRoughnessMap, v.sheenRoughnessMapTransform))), g.clearcoat > 0 && (v.clearcoat.value = g.clearcoat, v.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (v.clearcoatMap.value = g.clearcoatMap, i(g.clearcoatMap, v.clearcoatMapTransform)), g.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap, i(g.clearcoatRoughnessMap, v.clearcoatRoughnessMapTransform)), g.clearcoatNormalMap && (v.clearcoatNormalMap.value = g.clearcoatNormalMap, i(g.clearcoatNormalMap, v.clearcoatNormalMapTransform), v.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === Mr && v.clearcoatNormalScale.value.negate())), g.dispersion > 0 && (v.dispersion.value = g.dispersion), g.iridescence > 0 && (v.iridescence.value = g.iridescence, v.iridescenceIOR.value = g.iridescenceIOR, v.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], v.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (v.iridescenceMap.value = g.iridescenceMap, i(g.iridescenceMap, v.iridescenceMapTransform)), g.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = g.iridescenceThicknessMap, i(g.iridescenceThicknessMap, v.iridescenceThicknessMapTransform))), g.transmission > 0 && (v.transmission.value = g.transmission, v.transmissionSamplerMap.value = _.texture, v.transmissionSamplerSize.value.set(_.width, _.height), g.transmissionMap && (v.transmissionMap.value = g.transmissionMap, i(g.transmissionMap, v.transmissionMapTransform)), v.thickness.value = g.thickness, g.thicknessMap && (v.thicknessMap.value = g.thicknessMap, i(g.thicknessMap, v.thicknessMapTransform)), v.attenuationDistance.value = g.attenuationDistance, v.attenuationColor.value.copy(g.attenuationColor)), g.anisotropy > 0 && (v.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && (v.anisotropyMap.value = g.anisotropyMap, i(g.anisotropyMap, v.anisotropyMapTransform))), v.specularIntensity.value = g.specularIntensity, v.specularColor.value.copy(g.specularColor), g.specularColorMap && (v.specularColorMap.value = g.specularColorMap, i(g.specularColorMap, v.specularColorMapTransform)), g.specularIntensityMap && (v.specularIntensityMap.value = g.specularIntensityMap, i(g.specularIntensityMap, v.specularIntensityMapTransform));
  }
  function m(v, g) {
    g.matcap && (v.matcap.value = g.matcap);
  }
  function y(v, g) {
    const _ = e.get(g).light;
    v.referencePosition.value.setFromMatrixPosition(_.matrixWorld), v.nearDistance.value = _.shadow.camera.near, v.farDistance.value = _.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: s
  };
}
function Pj(r, e, i, n) {
  let s = {}, a = {}, o = [];
  const l = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
  function u(_, x) {
    const b = x.program;
    n.uniformBlockBinding(_, b);
  }
  function c(_, x) {
    let b = s[_.id];
    b === void 0 && (m(_), b = h(_), s[_.id] = b, _.addEventListener("dispose", v));
    const T = x.program;
    n.updateUBOMapping(_, T);
    const S = e.render.frame;
    a[_.id] !== S && (p(_), a[_.id] = S);
  }
  function h(_) {
    const x = d();
    _.__bindingPointIndex = x;
    const b = r.createBuffer(), T = _.__size, S = _.usage;
    return r.bindBuffer(r.UNIFORM_BUFFER, b), r.bufferData(r.UNIFORM_BUFFER, T, S), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, x, b), b;
  }
  function d() {
    for (let _ = 0; _ < l; _++)
      if (o.indexOf(_) === -1)
        return o.push(_), _;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function p(_) {
    const x = s[_.id], b = _.uniforms, T = _.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, x);
    for (let S = 0, w = b.length; S < w; S++) {
      const M = Array.isArray(b[S]) ? b[S] : [b[S]];
      for (let E = 0, A = M.length; E < A; E++) {
        const N = M[E];
        if (f(N, S, E, T) === !0) {
          const U = N.__offset, k = Array.isArray(N.value) ? N.value : [N.value];
          let C = 0;
          for (let I = 0; I < k.length; I++) {
            const O = k[I], W = y(O);
            typeof O == "number" || typeof O == "boolean" ? (N.__data[0] = O, r.bufferSubData(r.UNIFORM_BUFFER, U + C, N.__data)) : O.isMatrix3 ? (N.__data[0] = O.elements[0], N.__data[1] = O.elements[1], N.__data[2] = O.elements[2], N.__data[3] = 0, N.__data[4] = O.elements[3], N.__data[5] = O.elements[4], N.__data[6] = O.elements[5], N.__data[7] = 0, N.__data[8] = O.elements[6], N.__data[9] = O.elements[7], N.__data[10] = O.elements[8], N.__data[11] = 0) : (O.toArray(N.__data, C), C += W.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          r.bufferSubData(r.UNIFORM_BUFFER, U, N.__data);
        }
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function f(_, x, b, T) {
    const S = _.value, w = x + "_" + b;
    if (T[w] === void 0)
      return typeof S == "number" || typeof S == "boolean" ? T[w] = S : T[w] = S.clone(), !0;
    {
      const M = T[w];
      if (typeof S == "number" || typeof S == "boolean") {
        if (M !== S)
          return T[w] = S, !0;
      } else if (M.equals(S) === !1)
        return M.copy(S), !0;
    }
    return !1;
  }
  function m(_) {
    const x = _.uniforms;
    let b = 0;
    const T = 16;
    for (let w = 0, M = x.length; w < M; w++) {
      const E = Array.isArray(x[w]) ? x[w] : [x[w]];
      for (let A = 0, N = E.length; A < N; A++) {
        const U = E[A], k = Array.isArray(U.value) ? U.value : [U.value];
        for (let C = 0, I = k.length; C < I; C++) {
          const O = k[C], W = y(O), V = b % T, Q = V % W.boundary, F = V + Q;
          b += Q, F !== 0 && T - F < W.storage && (b += T - F), U.__data = new Float32Array(W.storage / Float32Array.BYTES_PER_ELEMENT), U.__offset = b, b += W.storage;
        }
      }
    }
    const S = b % T;
    return S > 0 && (b += T - S), _.__size = b, _.__cache = {}, this;
  }
  function y(_) {
    const x = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof _ == "number" || typeof _ == "boolean" ? (x.boundary = 4, x.storage = 4) : _.isVector2 ? (x.boundary = 8, x.storage = 8) : _.isVector3 || _.isColor ? (x.boundary = 16, x.storage = 12) : _.isVector4 ? (x.boundary = 16, x.storage = 16) : _.isMatrix3 ? (x.boundary = 48, x.storage = 48) : _.isMatrix4 ? (x.boundary = 64, x.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), x;
  }
  function v(_) {
    const x = _.target;
    x.removeEventListener("dispose", v);
    const b = o.indexOf(x.__bindingPointIndex);
    o.splice(b, 1), r.deleteBuffer(s[x.id]), delete s[x.id], delete a[x.id];
  }
  function g() {
    for (const _ in s)
      r.deleteBuffer(s[_]);
    o = [], s = {}, a = {};
  }
  return {
    bind: u,
    update: c,
    dispose: g
  };
}
class Ij {
  constructor(e = {}) {
    const {
      canvas: i = _5(),
      context: n = null,
      depth: s = !0,
      stencil: a = !1,
      alpha: o = !1,
      antialias: l = !1,
      premultipliedAlpha: u = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: d = !1,
      reverseDepthBuffer: p = !1
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    if (n !== null) {
      if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      f = n.getContextAttributes().alpha;
    } else
      f = o;
    const m = new Uint32Array(4), y = new Int32Array(4);
    let v = null, g = null;
    const _ = [], x = [];
    this.domElement = i, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = nn, this.toneMapping = lo, this.toneMappingExposure = 1;
    const b = this;
    let T = !1, S = 0, w = 0, M = null, E = -1, A = null;
    const N = new Fi(), U = new Fi();
    let k = null;
    const C = new Ut(0);
    let I = 0, O = i.width, W = i.height, V = 1, Q = null, F = null;
    const B = new Fi(0, 0, O, W), q = new Fi(0, 0, O, W);
    let G = !1;
    const z = new U_();
    let Y = !1, se = !1;
    const ne = new ui(), fe = new ui(), Se = new X(), Pe = new Fi(), lt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let xe = !1;
    function vt() {
      return M === null ? V : 1;
    }
    let Z = n;
    function Ht(L, H) {
      return i.getContext(L, H);
    }
    try {
      const L = {
        alpha: !0,
        depth: s,
        stencil: a,
        antialias: l,
        premultipliedAlpha: u,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: d
      };
      if ("setAttribute" in i && i.setAttribute("data-engine", `three.js r${bg}`), i.addEventListener("webglcontextlost", Ee, !1), i.addEventListener("webglcontextrestored", ze, !1), i.addEventListener("webglcontextcreationerror", Ue, !1), Z === null) {
        const H = "webgl2";
        if (Z = Ht(H, L), Z === null)
          throw Ht(H) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (L) {
      throw console.error("THREE.WebGLRenderer: " + L.message), L;
    }
    let nt, Tt, We, At, st, j, D, le, Te, Ce, _e, Je, Be, Xe, Pt, Ie, $e, ut, ft, Ye, Ot, bt, jt, ee;
    function Le() {
      nt = new U4(Z), nt.init(), bt = new Tj(Z, nt), Tt = new P4(Z, nt, e, bt), We = new bj(Z, nt), Tt.reverseDepthBuffer && p && We.buffers.depth.setReversed(!0), At = new z4(Z), st = new nj(), j = new _j(Z, nt, We, st, Tt, bt, At), D = new O4(b), le = new k4(b), Te = new X5(Z), jt = new R4(Z, Te), Ce = new F4(Z, Te, At, jt), _e = new V4(Z, Ce, Te, At), ft = new j4(Z, Tt, j), Ie = new I4(st), Je = new rj(b, D, le, nt, Tt, jt, Ie), Be = new Nj(b, st), Xe = new aj(), Pt = new dj(nt), ut = new C4(b, D, le, We, _e, f, u), $e = new yj(b, _e, Tt), ee = new Pj(Z, At, Tt, We), Ye = new N4(Z, nt, At), Ot = new B4(Z, nt, At), At.programs = Je.programs, b.capabilities = Tt, b.extensions = nt, b.properties = st, b.renderLists = Xe, b.shadowMap = $e, b.state = We, b.info = At;
    }
    Le();
    const de = new Cj(b, Z);
    this.xr = de, this.getContext = function() {
      return Z;
    }, this.getContextAttributes = function() {
      return Z.getContextAttributes();
    }, this.forceContextLoss = function() {
      const L = nt.get("WEBGL_lose_context");
      L && L.loseContext();
    }, this.forceContextRestore = function() {
      const L = nt.get("WEBGL_lose_context");
      L && L.restoreContext();
    }, this.getPixelRatio = function() {
      return V;
    }, this.setPixelRatio = function(L) {
      L !== void 0 && (V = L, this.setSize(O, W, !1));
    }, this.getSize = function(L) {
      return L.set(O, W);
    }, this.setSize = function(L, H, te = !0) {
      if (de.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      O = L, W = H, i.width = Math.floor(L * V), i.height = Math.floor(H * V), te === !0 && (i.style.width = L + "px", i.style.height = H + "px"), this.setViewport(0, 0, L, H);
    }, this.getDrawingBufferSize = function(L) {
      return L.set(O * V, W * V).floor();
    }, this.setDrawingBufferSize = function(L, H, te) {
      O = L, W = H, V = te, i.width = Math.floor(L * te), i.height = Math.floor(H * te), this.setViewport(0, 0, L, H);
    }, this.getCurrentViewport = function(L) {
      return L.copy(N);
    }, this.getViewport = function(L) {
      return L.copy(B);
    }, this.setViewport = function(L, H, te, oe) {
      L.isVector4 ? B.set(L.x, L.y, L.z, L.w) : B.set(L, H, te, oe), We.viewport(N.copy(B).multiplyScalar(V).round());
    }, this.getScissor = function(L) {
      return L.copy(q);
    }, this.setScissor = function(L, H, te, oe) {
      L.isVector4 ? q.set(L.x, L.y, L.z, L.w) : q.set(L, H, te, oe), We.scissor(U.copy(q).multiplyScalar(V).round());
    }, this.getScissorTest = function() {
      return G;
    }, this.setScissorTest = function(L) {
      We.setScissorTest(G = L);
    }, this.setOpaqueSort = function(L) {
      Q = L;
    }, this.setTransparentSort = function(L) {
      F = L;
    }, this.getClearColor = function(L) {
      return L.copy(ut.getClearColor());
    }, this.setClearColor = function() {
      ut.setClearColor.apply(ut, arguments);
    }, this.getClearAlpha = function() {
      return ut.getClearAlpha();
    }, this.setClearAlpha = function() {
      ut.setClearAlpha.apply(ut, arguments);
    }, this.clear = function(L = !0, H = !0, te = !0) {
      let oe = 0;
      if (L) {
        let K = !1;
        if (M !== null) {
          const Me = M.texture.format;
          K = Me === O_ || Me === I_ || Me === P_;
        }
        if (K) {
          const Me = M.texture.type, Ne = Me === ba || Me === xl || Me === cd || Me === fc || Me === R_ || Me === N_, Ke = ut.getClearColor(), tt = ut.getClearAlpha(), gt = Ke.r, St = Ke.g, ht = Ke.b;
          Ne ? (m[0] = gt, m[1] = St, m[2] = ht, m[3] = tt, Z.clearBufferuiv(Z.COLOR, 0, m)) : (y[0] = gt, y[1] = St, y[2] = ht, y[3] = tt, Z.clearBufferiv(Z.COLOR, 0, y));
        } else
          oe |= Z.COLOR_BUFFER_BIT;
      }
      H && (oe |= Z.DEPTH_BUFFER_BIT), te && (oe |= Z.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Z.clear(oe);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      i.removeEventListener("webglcontextlost", Ee, !1), i.removeEventListener("webglcontextrestored", ze, !1), i.removeEventListener("webglcontextcreationerror", Ue, !1), Xe.dispose(), Pt.dispose(), st.dispose(), D.dispose(), le.dispose(), _e.dispose(), jt.dispose(), ee.dispose(), Je.dispose(), de.dispose(), de.removeEventListener("sessionstart", Aa), de.removeEventListener("sessionend", Ca), Mn.stop();
    };
    function Ee(L) {
      L.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), T = !0;
    }
    function ze() {
      console.log("THREE.WebGLRenderer: Context Restored."), T = !1;
      const L = At.autoReset, H = $e.enabled, te = $e.autoUpdate, oe = $e.needsUpdate, K = $e.type;
      Le(), At.autoReset = L, $e.enabled = H, $e.autoUpdate = te, $e.needsUpdate = oe, $e.type = K;
    }
    function Ue(L) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", L.statusMessage);
    }
    function Ct(L) {
      const H = L.target;
      H.removeEventListener("dispose", Ct), ni(H);
    }
    function ni(L) {
      _i(L), st.remove(L);
    }
    function _i(L) {
      const H = st.get(L).programs;
      H !== void 0 && (H.forEach(function(te) {
        Je.releaseProgram(te);
      }), L.isShaderMaterial && Je.releaseShaderCache(L));
    }
    this.renderBufferDirect = function(L, H, te, oe, K, Me) {
      H === null && (H = lt);
      const Ne = K.isMesh && K.matrixWorld.determinant() < 0, Ke = at(L, H, te, oe, K);
      We.setMaterial(oe, Ne);
      let tt = te.index, gt = 1;
      if (oe.wireframe === !0) {
        if (tt = Ce.getWireframeAttribute(te), tt === void 0) return;
        gt = 2;
      }
      const St = te.drawRange, ht = te.attributes.position;
      let Wt = St.start * gt, ci = (St.start + St.count) * gt;
      Me !== null && (Wt = Math.max(Wt, Me.start * gt), ci = Math.min(ci, (Me.start + Me.count) * gt)), tt !== null ? (Wt = Math.max(Wt, 0), ci = Math.min(ci, tt.count)) : ht != null && (Wt = Math.max(Wt, 0), ci = Math.min(ci, ht.count));
      const hi = ci - Wt;
      if (hi < 0 || hi === 1 / 0) return;
      jt.setup(K, oe, Ke, te, tt);
      let Ni, di = Ye;
      if (tt !== null && (Ni = Te.get(tt), di = Ot, di.setIndex(Ni)), K.isMesh)
        oe.wireframe === !0 ? (We.setLineWidth(oe.wireframeLinewidth * vt()), di.setMode(Z.LINES)) : di.setMode(Z.TRIANGLES);
      else if (K.isLine) {
        let ot = oe.linewidth;
        ot === void 0 && (ot = 1), We.setLineWidth(ot * vt()), K.isLineSegments ? di.setMode(Z.LINES) : K.isLineLoop ? di.setMode(Z.LINE_LOOP) : di.setMode(Z.LINE_STRIP);
      } else K.isPoints ? di.setMode(Z.POINTS) : K.isSprite && di.setMode(Z.TRIANGLES);
      if (K.isBatchedMesh)
        if (K._multiDrawInstances !== null)
          di.renderMultiDrawInstances(K._multiDrawStarts, K._multiDrawCounts, K._multiDrawCount, K._multiDrawInstances);
        else if (nt.get("WEBGL_multi_draw"))
          di.renderMultiDraw(K._multiDrawStarts, K._multiDrawCounts, K._multiDrawCount);
        else {
          const ot = K._multiDrawStarts, Ao = K._multiDrawCounts, Co = K._multiDrawCount, An = tt ? Te.get(tt).bytesPerElement : 1, Fl = st.get(oe).currentProgram.getUniforms();
          for (let $r = 0; $r < Co; $r++)
            Fl.setValue(Z, "_gl_DrawID", $r), di.render(ot[$r] / An, Ao[$r]);
        }
      else if (K.isInstancedMesh)
        di.renderInstances(Wt, hi, K.count);
      else if (te.isInstancedBufferGeometry) {
        const ot = te._maxInstanceCount !== void 0 ? te._maxInstanceCount : 1 / 0, Ao = Math.min(te.instanceCount, ot);
        di.renderInstances(Wt, hi, Ao);
      } else
        di.render(Wt, hi);
    };
    function Bt(L, H, te) {
      L.transparent === !0 && L.side === Zs && L.forceSinglePass === !1 ? (L.side = Mr, L.needsUpdate = !0, ce(L, H, te), L.side = mo, L.needsUpdate = !0, ce(L, H, te), L.side = Zs) : ce(L, H, te);
    }
    this.compile = function(L, H, te = null) {
      te === null && (te = L), g = Pt.get(te), g.init(H), x.push(g), te.traverseVisible(function(K) {
        K.isLight && K.layers.test(H.layers) && (g.pushLight(K), K.castShadow && g.pushShadow(K));
      }), L !== te && L.traverseVisible(function(K) {
        K.isLight && K.layers.test(H.layers) && (g.pushLight(K), K.castShadow && g.pushShadow(K));
      }), g.setupLights();
      const oe = /* @__PURE__ */ new Set();
      return L.traverse(function(K) {
        if (!(K.isMesh || K.isPoints || K.isLine || K.isSprite))
          return;
        const Me = K.material;
        if (Me)
          if (Array.isArray(Me))
            for (let Ne = 0; Ne < Me.length; Ne++) {
              const Ke = Me[Ne];
              Bt(Ke, te, K), oe.add(Ke);
            }
          else
            Bt(Me, te, K), oe.add(Me);
      }), x.pop(), g = null, oe;
    }, this.compileAsync = function(L, H, te = null) {
      const oe = this.compile(L, H, te);
      return new Promise((K) => {
        function Me() {
          if (oe.forEach(function(Ne) {
            st.get(Ne).currentProgram.isReady() && oe.delete(Ne);
          }), oe.size === 0) {
            K(L);
            return;
          }
          setTimeout(Me, 10);
        }
        nt.get("KHR_parallel_shader_compile") !== null ? Me() : setTimeout(Me, 10);
      });
    };
    let yr = null;
    function Xr(L) {
      yr && yr(L);
    }
    function Aa() {
      Mn.stop();
    }
    function Ca() {
      Mn.start();
    }
    const Mn = new vR();
    Mn.setAnimationLoop(Xr), typeof self < "u" && Mn.setContext(self), this.setAnimationLoop = function(L) {
      yr = L, de.setAnimationLoop(L), L === null ? Mn.stop() : Mn.start();
    }, de.addEventListener("sessionstart", Aa), de.addEventListener("sessionend", Ca), this.render = function(L, H) {
      if (H !== void 0 && H.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (T === !0) return;
      if (L.matrixWorldAutoUpdate === !0 && L.updateMatrixWorld(), H.parent === null && H.matrixWorldAutoUpdate === !0 && H.updateMatrixWorld(), de.enabled === !0 && de.isPresenting === !0 && (de.cameraAutoUpdate === !0 && de.updateCamera(H), H = de.getCamera()), L.isScene === !0 && L.onBeforeRender(b, L, H, M), g = Pt.get(L, x.length), g.init(H), x.push(g), fe.multiplyMatrices(H.projectionMatrix, H.matrixWorldInverse), z.setFromProjectionMatrix(fe), se = this.localClippingEnabled, Y = Ie.init(this.clippingPlanes, se), v = Xe.get(L, _.length), v.init(), _.push(v), de.enabled === !0 && de.isPresenting === !0) {
        const Me = b.xr.getDepthSensingMesh();
        Me !== null && Mo(Me, H, -1 / 0, b.sortObjects);
      }
      Mo(L, H, 0, b.sortObjects), v.finish(), b.sortObjects === !0 && v.sort(Q, F), xe = de.enabled === !1 || de.isPresenting === !1 || de.hasDepthSensing() === !1, xe && ut.addToRenderList(v, L), this.info.render.frame++, Y === !0 && Ie.beginShadows();
      const te = g.state.shadowsArray;
      $e.render(te, L, H), Y === !0 && Ie.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const oe = v.opaque, K = v.transmissive;
      if (g.setupLights(), H.isArrayCamera) {
        const Me = H.cameras;
        if (K.length > 0)
          for (let Ne = 0, Ke = Me.length; Ne < Ke; Ne++) {
            const tt = Me[Ne];
            Ul(oe, K, L, tt);
          }
        xe && ut.render(L);
        for (let Ne = 0, Ke = Me.length; Ne < Ke; Ne++) {
          const tt = Me[Ne];
          kl(v, L, tt, tt.viewport);
        }
      } else
        K.length > 0 && Ul(oe, K, L, H), xe && ut.render(L), kl(v, L, H);
      M !== null && (j.updateMultisampleRenderTarget(M), j.updateRenderTargetMipmap(M)), L.isScene === !0 && L.onAfterRender(b, L, H), jt.resetDefaultState(), E = -1, A = null, x.pop(), x.length > 0 ? (g = x[x.length - 1], Y === !0 && Ie.setGlobalState(b.clippingPlanes, g.state.camera)) : g = null, _.pop(), _.length > 0 ? v = _[_.length - 1] : v = null;
    };
    function Mo(L, H, te, oe) {
      if (L.visible === !1) return;
      if (L.layers.test(H.layers)) {
        if (L.isGroup)
          te = L.renderOrder;
        else if (L.isLOD)
          L.autoUpdate === !0 && L.update(H);
        else if (L.isLight)
          g.pushLight(L), L.castShadow && g.pushShadow(L);
        else if (L.isSprite) {
          if (!L.frustumCulled || z.intersectsSprite(L)) {
            oe && Pe.setFromMatrixPosition(L.matrixWorld).applyMatrix4(fe);
            const Me = _e.update(L), Ne = L.material;
            Ne.visible && v.push(L, Me, Ne, te, Pe.z, null);
          }
        } else if ((L.isMesh || L.isLine || L.isPoints) && (!L.frustumCulled || z.intersectsObject(L))) {
          const Me = _e.update(L), Ne = L.material;
          if (oe && (L.boundingSphere !== void 0 ? (L.boundingSphere === null && L.computeBoundingSphere(), Pe.copy(L.boundingSphere.center)) : (Me.boundingSphere === null && Me.computeBoundingSphere(), Pe.copy(Me.boundingSphere.center)), Pe.applyMatrix4(L.matrixWorld).applyMatrix4(fe)), Array.isArray(Ne)) {
            const Ke = Me.groups;
            for (let tt = 0, gt = Ke.length; tt < gt; tt++) {
              const St = Ke[tt], ht = Ne[St.materialIndex];
              ht && ht.visible && v.push(L, Me, ht, te, Pe.z, St);
            }
          } else Ne.visible && v.push(L, Me, Ne, te, Pe.z, null);
        }
      }
      const K = L.children;
      for (let Me = 0, Ne = K.length; Me < Ne; Me++)
        Mo(K[Me], H, te, oe);
    }
    function kl(L, H, te, oe) {
      const K = L.opaque, Me = L.transmissive, Ne = L.transparent;
      g.setupLightsView(te), Y === !0 && Ie.setGlobalState(b.clippingPlanes, te), oe && We.viewport(N.copy(oe)), K.length > 0 && R(K, H, te), Me.length > 0 && R(Me, H, te), Ne.length > 0 && R(Ne, H, te), We.buffers.depth.setTest(!0), We.buffers.depth.setMask(!0), We.buffers.color.setMask(!0), We.setPolygonOffset(!1);
    }
    function Ul(L, H, te, oe) {
      if ((te.isScene === !0 ? te.overrideMaterial : null) !== null)
        return;
      g.state.transmissionRenderTarget[oe.id] === void 0 && (g.state.transmissionRenderTarget[oe.id] = new go(1, 1, {
        generateMipmaps: !0,
        type: nt.has("EXT_color_buffer_half_float") || nt.has("EXT_color_buffer_float") ? Lc : ba,
        minFilter: nl,
        samples: 4,
        stencilBuffer: a,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: Gt.workingColorSpace
      }));
      const K = g.state.transmissionRenderTarget[oe.id], Me = oe.viewport || N;
      K.setSize(Me.z, Me.w);
      const Ne = b.getRenderTarget();
      b.setRenderTarget(K), b.getClearColor(C), I = b.getClearAlpha(), I < 1 && b.setClearColor(16777215, 0.5), b.clear(), xe && ut.render(te);
      const Ke = b.toneMapping;
      b.toneMapping = lo;
      const tt = oe.viewport;
      if (oe.viewport !== void 0 && (oe.viewport = void 0), g.setupLightsView(oe), Y === !0 && Ie.setGlobalState(b.clippingPlanes, oe), R(L, te, oe), j.updateMultisampleRenderTarget(K), j.updateRenderTargetMipmap(K), nt.has("WEBGL_multisampled_render_to_texture") === !1) {
        let gt = !1;
        for (let St = 0, ht = H.length; St < ht; St++) {
          const Wt = H[St], ci = Wt.object, hi = Wt.geometry, Ni = Wt.material, di = Wt.group;
          if (Ni.side === Zs && ci.layers.test(oe.layers)) {
            const ot = Ni.side;
            Ni.side = Mr, Ni.needsUpdate = !0, J(ci, te, oe, hi, Ni, di), Ni.side = ot, Ni.needsUpdate = !0, gt = !0;
          }
        }
        gt === !0 && (j.updateMultisampleRenderTarget(K), j.updateRenderTargetMipmap(K));
      }
      b.setRenderTarget(Ne), b.setClearColor(C, I), tt !== void 0 && (oe.viewport = tt), b.toneMapping = Ke;
    }
    function R(L, H, te) {
      const oe = H.isScene === !0 ? H.overrideMaterial : null;
      for (let K = 0, Me = L.length; K < Me; K++) {
        const Ne = L[K], Ke = Ne.object, tt = Ne.geometry, gt = oe === null ? Ne.material : oe, St = Ne.group;
        Ke.layers.test(te.layers) && J(Ke, H, te, tt, gt, St);
      }
    }
    function J(L, H, te, oe, K, Me) {
      L.onBeforeRender(b, H, te, oe, K, Me), L.modelViewMatrix.multiplyMatrices(te.matrixWorldInverse, L.matrixWorld), L.normalMatrix.getNormalMatrix(L.modelViewMatrix), K.onBeforeRender(b, H, te, oe, L, Me), K.transparent === !0 && K.side === Zs && K.forceSinglePass === !1 ? (K.side = Mr, K.needsUpdate = !0, b.renderBufferDirect(te, H, oe, K, L, Me), K.side = mo, K.needsUpdate = !0, b.renderBufferDirect(te, H, oe, K, L, Me), K.side = Zs) : b.renderBufferDirect(te, H, oe, K, L, Me), L.onAfterRender(b, H, te, oe, K, Me);
    }
    function ce(L, H, te) {
      H.isScene !== !0 && (H = lt);
      const oe = st.get(L), K = g.state.lights, Me = g.state.shadowsArray, Ne = K.state.version, Ke = Je.getParameters(L, K.state, Me, H, te), tt = Je.getProgramCacheKey(Ke);
      let gt = oe.programs;
      oe.environment = L.isMeshStandardMaterial ? H.environment : null, oe.fog = H.fog, oe.envMap = (L.isMeshStandardMaterial ? le : D).get(L.envMap || oe.environment), oe.envMapRotation = oe.environment !== null && L.envMap === null ? H.environmentRotation : L.envMapRotation, gt === void 0 && (L.addEventListener("dispose", Ct), gt = /* @__PURE__ */ new Map(), oe.programs = gt);
      let St = gt.get(tt);
      if (St !== void 0) {
        if (oe.currentProgram === St && oe.lightsStateVersion === Ne)
          return Ze(L, Ke), St;
      } else
        Ke.uniforms = Je.getUniforms(L), L.onBeforeCompile(Ke, b), St = Je.acquireProgram(Ke, tt), gt.set(tt, St), oe.uniforms = Ke.uniforms;
      const ht = oe.uniforms;
      return (!L.isShaderMaterial && !L.isRawShaderMaterial || L.clipping === !0) && (ht.clippingPlanes = Ie.uniform), Ze(L, Ke), oe.needsLights = Ge(L), oe.lightsStateVersion = Ne, oe.needsLights && (ht.ambientLightColor.value = K.state.ambient, ht.lightProbe.value = K.state.probe, ht.directionalLights.value = K.state.directional, ht.directionalLightShadows.value = K.state.directionalShadow, ht.spotLights.value = K.state.spot, ht.spotLightShadows.value = K.state.spotShadow, ht.rectAreaLights.value = K.state.rectArea, ht.ltc_1.value = K.state.rectAreaLTC1, ht.ltc_2.value = K.state.rectAreaLTC2, ht.pointLights.value = K.state.point, ht.pointLightShadows.value = K.state.pointShadow, ht.hemisphereLights.value = K.state.hemi, ht.directionalShadowMap.value = K.state.directionalShadowMap, ht.directionalShadowMatrix.value = K.state.directionalShadowMatrix, ht.spotShadowMap.value = K.state.spotShadowMap, ht.spotLightMatrix.value = K.state.spotLightMatrix, ht.spotLightMap.value = K.state.spotLightMap, ht.pointShadowMap.value = K.state.pointShadowMap, ht.pointShadowMatrix.value = K.state.pointShadowMatrix), oe.currentProgram = St, oe.uniformsList = null, St;
    }
    function Re(L) {
      if (L.uniformsList === null) {
        const H = L.currentProgram.getUniforms();
        L.uniformsList = Qf.seqWithValue(H.seq, L.uniforms);
      }
      return L.uniformsList;
    }
    function Ze(L, H) {
      const te = st.get(L);
      te.outputColorSpace = H.outputColorSpace, te.batching = H.batching, te.batchingColor = H.batchingColor, te.instancing = H.instancing, te.instancingColor = H.instancingColor, te.instancingMorph = H.instancingMorph, te.skinning = H.skinning, te.morphTargets = H.morphTargets, te.morphNormals = H.morphNormals, te.morphColors = H.morphColors, te.morphTargetsCount = H.morphTargetsCount, te.numClippingPlanes = H.numClippingPlanes, te.numIntersection = H.numClipIntersection, te.vertexAlphas = H.vertexAlphas, te.vertexTangents = H.vertexTangents, te.toneMapping = H.toneMapping;
    }
    function at(L, H, te, oe, K) {
      H.isScene !== !0 && (H = lt), j.resetTextureUnits();
      const Me = H.fog, Ne = oe.isMeshStandardMaterial ? H.environment : null, Ke = M === null ? b.outputColorSpace : M.isXRRenderTarget === !0 ? M.texture.colorSpace : kc, tt = (oe.isMeshStandardMaterial ? le : D).get(oe.envMap || Ne), gt = oe.vertexColors === !0 && !!te.attributes.color && te.attributes.color.itemSize === 4, St = !!te.attributes.tangent && (!!oe.normalMap || oe.anisotropy > 0), ht = !!te.morphAttributes.position, Wt = !!te.morphAttributes.normal, ci = !!te.morphAttributes.color;
      let hi = lo;
      oe.toneMapped && (M === null || M.isXRRenderTarget === !0) && (hi = b.toneMapping);
      const Ni = te.morphAttributes.position || te.morphAttributes.normal || te.morphAttributes.color, di = Ni !== void 0 ? Ni.length : 0, ot = st.get(oe), Ao = g.state.lights;
      if (Y === !0 && (se === !0 || L !== A)) {
        const Pr = L === A && oe.id === E;
        Ie.setState(oe, L, Pr);
      }
      let Co = !1;
      oe.version === ot.__version ? (ot.needsLights && ot.lightsStateVersion !== Ao.state.version || ot.outputColorSpace !== Ke || K.isBatchedMesh && ot.batching === !1 || !K.isBatchedMesh && ot.batching === !0 || K.isBatchedMesh && ot.batchingColor === !0 && K.colorTexture === null || K.isBatchedMesh && ot.batchingColor === !1 && K.colorTexture !== null || K.isInstancedMesh && ot.instancing === !1 || !K.isInstancedMesh && ot.instancing === !0 || K.isSkinnedMesh && ot.skinning === !1 || !K.isSkinnedMesh && ot.skinning === !0 || K.isInstancedMesh && ot.instancingColor === !0 && K.instanceColor === null || K.isInstancedMesh && ot.instancingColor === !1 && K.instanceColor !== null || K.isInstancedMesh && ot.instancingMorph === !0 && K.morphTexture === null || K.isInstancedMesh && ot.instancingMorph === !1 && K.morphTexture !== null || ot.envMap !== tt || oe.fog === !0 && ot.fog !== Me || ot.numClippingPlanes !== void 0 && (ot.numClippingPlanes !== Ie.numPlanes || ot.numIntersection !== Ie.numIntersection) || ot.vertexAlphas !== gt || ot.vertexTangents !== St || ot.morphTargets !== ht || ot.morphNormals !== Wt || ot.morphColors !== ci || ot.toneMapping !== hi || ot.morphTargetsCount !== di) && (Co = !0) : (Co = !0, ot.__version = oe.version);
      let An = ot.currentProgram;
      Co === !0 && (An = ce(oe, H, K));
      let Fl = !1, $r = !1, qc = !1;
      const ai = An.getUniforms(), is = ot.uniforms;
      if (We.useProgram(An.program) && (Fl = !0, $r = !0, qc = !0), oe.id !== E && (E = oe.id, $r = !0), Fl || A !== L) {
        We.buffers.depth.getReversed() ? (ne.copy(L.projectionMatrix), S5(ne), w5(ne), ai.setValue(Z, "projectionMatrix", ne)) : ai.setValue(Z, "projectionMatrix", L.projectionMatrix), ai.setValue(Z, "viewMatrix", L.matrixWorldInverse);
        const Pr = ai.map.cameraPosition;
        Pr !== void 0 && Pr.setValue(Z, Se.setFromMatrixPosition(L.matrixWorld)), Tt.logarithmicDepthBuffer && ai.setValue(
          Z,
          "logDepthBufFC",
          2 / (Math.log(L.far + 1) / Math.LN2)
        ), (oe.isMeshPhongMaterial || oe.isMeshToonMaterial || oe.isMeshLambertMaterial || oe.isMeshBasicMaterial || oe.isMeshStandardMaterial || oe.isShaderMaterial) && ai.setValue(Z, "isOrthographic", L.isOrthographicCamera === !0), A !== L && (A = L, $r = !0, qc = !0);
      }
      if (K.isSkinnedMesh) {
        ai.setOptional(Z, K, "bindMatrix"), ai.setOptional(Z, K, "bindMatrixInverse");
        const Pr = K.skeleton;
        Pr && (Pr.boneTexture === null && Pr.computeBoneTexture(), ai.setValue(Z, "boneTexture", Pr.boneTexture, j));
      }
      K.isBatchedMesh && (ai.setOptional(Z, K, "batchingTexture"), ai.setValue(Z, "batchingTexture", K._matricesTexture, j), ai.setOptional(Z, K, "batchingIdTexture"), ai.setValue(Z, "batchingIdTexture", K._indirectTexture, j), ai.setOptional(Z, K, "batchingColorTexture"), K._colorsTexture !== null && ai.setValue(Z, "batchingColorTexture", K._colorsTexture, j));
      const Xc = te.morphAttributes;
      if ((Xc.position !== void 0 || Xc.normal !== void 0 || Xc.color !== void 0) && ft.update(K, te, An), ($r || ot.receiveShadow !== K.receiveShadow) && (ot.receiveShadow = K.receiveShadow, ai.setValue(Z, "receiveShadow", K.receiveShadow)), oe.isMeshGouraudMaterial && oe.envMap !== null && (is.envMap.value = tt, is.flipEnvMap.value = tt.isCubeTexture && tt.isRenderTargetTexture === !1 ? -1 : 1), oe.isMeshStandardMaterial && oe.envMap === null && H.environment !== null && (is.envMapIntensity.value = H.environmentIntensity), $r && (ai.setValue(Z, "toneMappingExposure", b.toneMappingExposure), ot.needsLights && qe(is, qc), Me && oe.fog === !0 && Be.refreshFogUniforms(is, Me), Be.refreshMaterialUniforms(is, oe, V, W, g.state.transmissionRenderTarget[L.id]), Qf.upload(Z, Re(ot), is, j)), oe.isShaderMaterial && oe.uniformsNeedUpdate === !0 && (Qf.upload(Z, Re(ot), is, j), oe.uniformsNeedUpdate = !1), oe.isSpriteMaterial && ai.setValue(Z, "center", K.center), ai.setValue(Z, "modelViewMatrix", K.modelViewMatrix), ai.setValue(Z, "normalMatrix", K.normalMatrix), ai.setValue(Z, "modelMatrix", K.matrixWorld), oe.isShaderMaterial || oe.isRawShaderMaterial) {
        const Pr = oe.uniformsGroups;
        for (let $c = 0, Ra = Pr.length; $c < Ra; $c++) {
          const bT = Pr[$c];
          ee.update(bT, An), ee.bind(bT, An);
        }
      }
      return An;
    }
    function qe(L, H) {
      L.ambientLightColor.needsUpdate = H, L.lightProbe.needsUpdate = H, L.directionalLights.needsUpdate = H, L.directionalLightShadows.needsUpdate = H, L.pointLights.needsUpdate = H, L.pointLightShadows.needsUpdate = H, L.spotLights.needsUpdate = H, L.spotLightShadows.needsUpdate = H, L.rectAreaLights.needsUpdate = H, L.hemisphereLights.needsUpdate = H;
    }
    function Ge(L) {
      return L.isMeshLambertMaterial || L.isMeshToonMaterial || L.isMeshPhongMaterial || L.isMeshStandardMaterial || L.isShadowMaterial || L.isShaderMaterial && L.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return S;
    }, this.getActiveMipmapLevel = function() {
      return w;
    }, this.getRenderTarget = function() {
      return M;
    }, this.setRenderTargetTextures = function(L, H, te) {
      st.get(L.texture).__webglTexture = H, st.get(L.depthTexture).__webglTexture = te;
      const oe = st.get(L);
      oe.__hasExternalTextures = !0, oe.__autoAllocateDepthBuffer = te === void 0, oe.__autoAllocateDepthBuffer || nt.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), oe.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(L, H) {
      const te = st.get(L);
      te.__webglFramebuffer = H, te.__useDefaultFramebuffer = H === void 0;
    }, this.setRenderTarget = function(L, H = 0, te = 0) {
      M = L, S = H, w = te;
      let oe = !0, K = null, Me = !1, Ne = !1;
      if (L) {
        const Ke = st.get(L);
        if (Ke.__useDefaultFramebuffer !== void 0)
          We.bindFramebuffer(Z.FRAMEBUFFER, null), oe = !1;
        else if (Ke.__webglFramebuffer === void 0)
          j.setupRenderTarget(L);
        else if (Ke.__hasExternalTextures)
          j.rebindTextures(L, st.get(L.texture).__webglTexture, st.get(L.depthTexture).__webglTexture);
        else if (L.depthBuffer) {
          const St = L.depthTexture;
          if (Ke.__boundDepthTexture !== St) {
            if (St !== null && st.has(St) && (L.width !== St.image.width || L.height !== St.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            j.setupDepthRenderbuffer(L);
          }
        }
        const tt = L.texture;
        (tt.isData3DTexture || tt.isDataArrayTexture || tt.isCompressedArrayTexture) && (Ne = !0);
        const gt = st.get(L).__webglFramebuffer;
        L.isWebGLCubeRenderTarget ? (Array.isArray(gt[H]) ? K = gt[H][te] : K = gt[H], Me = !0) : L.samples > 0 && j.useMultisampledRTT(L) === !1 ? K = st.get(L).__webglMultisampledFramebuffer : Array.isArray(gt) ? K = gt[te] : K = gt, N.copy(L.viewport), U.copy(L.scissor), k = L.scissorTest;
      } else
        N.copy(B).multiplyScalar(V).floor(), U.copy(q).multiplyScalar(V).floor(), k = G;
      if (We.bindFramebuffer(Z.FRAMEBUFFER, K) && oe && We.drawBuffers(L, K), We.viewport(N), We.scissor(U), We.setScissorTest(k), Me) {
        const Ke = st.get(L.texture);
        Z.framebufferTexture2D(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_CUBE_MAP_POSITIVE_X + H, Ke.__webglTexture, te);
      } else if (Ne) {
        const Ke = st.get(L.texture), tt = H || 0;
        Z.framebufferTextureLayer(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Ke.__webglTexture, te || 0, tt);
      }
      E = -1;
    }, this.readRenderTargetPixels = function(L, H, te, oe, K, Me, Ne) {
      if (!(L && L.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Ke = st.get(L).__webglFramebuffer;
      if (L.isWebGLCubeRenderTarget && Ne !== void 0 && (Ke = Ke[Ne]), Ke) {
        We.bindFramebuffer(Z.FRAMEBUFFER, Ke);
        try {
          const tt = L.texture, gt = tt.format, St = tt.type;
          if (!Tt.textureFormatReadable(gt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!Tt.textureTypeReadable(St)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          H >= 0 && H <= L.width - oe && te >= 0 && te <= L.height - K && Z.readPixels(H, te, oe, K, bt.convert(gt), bt.convert(St), Me);
        } finally {
          const tt = M !== null ? st.get(M).__webglFramebuffer : null;
          We.bindFramebuffer(Z.FRAMEBUFFER, tt);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(L, H, te, oe, K, Me, Ne) {
      if (!(L && L.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Ke = st.get(L).__webglFramebuffer;
      if (L.isWebGLCubeRenderTarget && Ne !== void 0 && (Ke = Ke[Ne]), Ke) {
        const tt = L.texture, gt = tt.format, St = tt.type;
        if (!Tt.textureFormatReadable(gt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!Tt.textureTypeReadable(St))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (H >= 0 && H <= L.width - oe && te >= 0 && te <= L.height - K) {
          We.bindFramebuffer(Z.FRAMEBUFFER, Ke);
          const ht = Z.createBuffer();
          Z.bindBuffer(Z.PIXEL_PACK_BUFFER, ht), Z.bufferData(Z.PIXEL_PACK_BUFFER, Me.byteLength, Z.STREAM_READ), Z.readPixels(H, te, oe, K, bt.convert(gt), bt.convert(St), 0);
          const Wt = M !== null ? st.get(M).__webglFramebuffer : null;
          We.bindFramebuffer(Z.FRAMEBUFFER, Wt);
          const ci = Z.fenceSync(Z.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return Z.flush(), await T5(Z, ci, 4), Z.bindBuffer(Z.PIXEL_PACK_BUFFER, ht), Z.getBufferSubData(Z.PIXEL_PACK_BUFFER, 0, Me), Z.deleteBuffer(ht), Z.deleteSync(ci), Me;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(L, H = null, te = 0) {
      L.isTexture !== !0 && (Fh("WebGLRenderer: copyFramebufferToTexture function signature has changed."), H = arguments[0] || null, L = arguments[1]);
      const oe = Math.pow(2, -te), K = Math.floor(L.image.width * oe), Me = Math.floor(L.image.height * oe), Ne = H !== null ? H.x : 0, Ke = H !== null ? H.y : 0;
      j.setTexture2D(L, 0), Z.copyTexSubImage2D(Z.TEXTURE_2D, te, 0, 0, Ne, Ke, K, Me), We.unbindTexture();
    }, this.copyTextureToTexture = function(L, H, te = null, oe = null, K = 0) {
      L.isTexture !== !0 && (Fh("WebGLRenderer: copyTextureToTexture function signature has changed."), oe = arguments[0] || null, L = arguments[1], H = arguments[2], K = arguments[3] || 0, te = null);
      let Me, Ne, Ke, tt, gt, St, ht, Wt, ci;
      const hi = L.isCompressedTexture ? L.mipmaps[K] : L.image;
      te !== null ? (Me = te.max.x - te.min.x, Ne = te.max.y - te.min.y, Ke = te.isBox3 ? te.max.z - te.min.z : 1, tt = te.min.x, gt = te.min.y, St = te.isBox3 ? te.min.z : 0) : (Me = hi.width, Ne = hi.height, Ke = hi.depth || 1, tt = 0, gt = 0, St = 0), oe !== null ? (ht = oe.x, Wt = oe.y, ci = oe.z) : (ht = 0, Wt = 0, ci = 0);
      const Ni = bt.convert(H.format), di = bt.convert(H.type);
      let ot;
      H.isData3DTexture ? (j.setTexture3D(H, 0), ot = Z.TEXTURE_3D) : H.isDataArrayTexture || H.isCompressedArrayTexture ? (j.setTexture2DArray(H, 0), ot = Z.TEXTURE_2D_ARRAY) : (j.setTexture2D(H, 0), ot = Z.TEXTURE_2D), Z.pixelStorei(Z.UNPACK_FLIP_Y_WEBGL, H.flipY), Z.pixelStorei(Z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, H.premultiplyAlpha), Z.pixelStorei(Z.UNPACK_ALIGNMENT, H.unpackAlignment);
      const Ao = Z.getParameter(Z.UNPACK_ROW_LENGTH), Co = Z.getParameter(Z.UNPACK_IMAGE_HEIGHT), An = Z.getParameter(Z.UNPACK_SKIP_PIXELS), Fl = Z.getParameter(Z.UNPACK_SKIP_ROWS), $r = Z.getParameter(Z.UNPACK_SKIP_IMAGES);
      Z.pixelStorei(Z.UNPACK_ROW_LENGTH, hi.width), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, hi.height), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, tt), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, gt), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, St);
      const qc = L.isDataArrayTexture || L.isData3DTexture, ai = H.isDataArrayTexture || H.isData3DTexture;
      if (L.isRenderTargetTexture || L.isDepthTexture) {
        const is = st.get(L), Xc = st.get(H), Pr = st.get(is.__renderTarget), $c = st.get(Xc.__renderTarget);
        We.bindFramebuffer(Z.READ_FRAMEBUFFER, Pr.__webglFramebuffer), We.bindFramebuffer(Z.DRAW_FRAMEBUFFER, $c.__webglFramebuffer);
        for (let Ra = 0; Ra < Ke; Ra++)
          qc && Z.framebufferTextureLayer(Z.READ_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, st.get(L).__webglTexture, K, St + Ra), L.isDepthTexture ? (ai && Z.framebufferTextureLayer(Z.DRAW_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, st.get(H).__webglTexture, K, ci + Ra), Z.blitFramebuffer(tt, gt, Me, Ne, ht, Wt, Me, Ne, Z.DEPTH_BUFFER_BIT, Z.NEAREST)) : ai ? Z.copyTexSubImage3D(ot, K, ht, Wt, ci + Ra, tt, gt, Me, Ne) : Z.copyTexSubImage2D(ot, K, ht, Wt, ci + Ra, tt, gt, Me, Ne);
        We.bindFramebuffer(Z.READ_FRAMEBUFFER, null), We.bindFramebuffer(Z.DRAW_FRAMEBUFFER, null);
      } else
        ai ? L.isDataTexture || L.isData3DTexture ? Z.texSubImage3D(ot, K, ht, Wt, ci, Me, Ne, Ke, Ni, di, hi.data) : H.isCompressedArrayTexture ? Z.compressedTexSubImage3D(ot, K, ht, Wt, ci, Me, Ne, Ke, Ni, hi.data) : Z.texSubImage3D(ot, K, ht, Wt, ci, Me, Ne, Ke, Ni, di, hi) : L.isDataTexture ? Z.texSubImage2D(Z.TEXTURE_2D, K, ht, Wt, Me, Ne, Ni, di, hi.data) : L.isCompressedTexture ? Z.compressedTexSubImage2D(Z.TEXTURE_2D, K, ht, Wt, hi.width, hi.height, Ni, hi.data) : Z.texSubImage2D(Z.TEXTURE_2D, K, ht, Wt, Me, Ne, Ni, di, hi);
      Z.pixelStorei(Z.UNPACK_ROW_LENGTH, Ao), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, Co), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, An), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, Fl), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, $r), K === 0 && H.generateMipmaps && Z.generateMipmap(ot), We.unbindTexture();
    }, this.copyTextureToTexture3D = function(L, H, te = null, oe = null, K = 0) {
      return L.isTexture !== !0 && (Fh("WebGLRenderer: copyTextureToTexture3D function signature has changed."), te = arguments[0] || null, oe = arguments[1] || null, L = arguments[2], H = arguments[3], K = arguments[4] || 0), Fh('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(L, H, te, oe, K);
    }, this.initRenderTarget = function(L) {
      st.get(L).__webglFramebuffer === void 0 && j.setupRenderTarget(L);
    }, this.initTexture = function(L) {
      L.isCubeTexture ? j.setTextureCube(L, 0) : L.isData3DTexture ? j.setTexture3D(L, 0) : L.isDataArrayTexture || L.isCompressedArrayTexture ? j.setTexture2DArray(L, 0) : j.setTexture2D(L, 0), We.unbindTexture();
    }, this.resetState = function() {
      S = 0, w = 0, M = null, We.reset(), jt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return na;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const i = this.getContext();
    i.drawingBufferColorspace = Gt._getDrawingBufferColorSpace(e), i.unpackColorSpace = Gt._getUnpackColorSpace();
  }
}
let Oj = class extends Vr {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new yo(), this.environmentIntensity = 1, this.environmentRotation = new yo(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(r, e) {
    return super.copy(r, e), r.background !== null && (this.background = r.background.clone()), r.environment !== null && (this.environment = r.environment.clone()), r.fog !== null && (this.fog = r.fog.clone()), this.backgroundBlurriness = r.backgroundBlurriness, this.backgroundIntensity = r.backgroundIntensity, this.backgroundRotation.copy(r.backgroundRotation), this.environmentIntensity = r.environmentIntensity, this.environmentRotation.copy(r.environmentRotation), r.overrideMaterial !== null && (this.overrideMaterial = r.overrideMaterial.clone()), this.matrixAutoUpdate = r.matrixAutoUpdate, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
  }
}, Dj = class {
  constructor(r, e) {
    this.isInterleavedBuffer = !0, this.array = r, this.stride = e, this.count = r !== void 0 ? r.length / e : 0, this.usage = kb, this.updateRanges = [], this.version = 0, this.uuid = ua();
  }
  onUploadCallback() {
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  setUsage(r) {
    return this.usage = r, this;
  }
  addUpdateRange(r, e) {
    this.updateRanges.push({ start: r, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(r) {
    return this.array = new r.array.constructor(r.array), this.count = r.count, this.stride = r.stride, this.usage = r.usage, this;
  }
  copyAt(r, e, i) {
    r *= this.stride, i *= e.stride;
    for (let n = 0, s = this.stride; n < s; n++)
      this.array[r + n] = e.array[i + n];
    return this;
  }
  set(r, e = 0) {
    return this.array.set(r, e), this;
  }
  clone(r) {
    r.arrayBuffers === void 0 && (r.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ua()), r.arrayBuffers[this.array.buffer._uuid] === void 0 && (r.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(r.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(e, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(r) {
    return this.onUploadCallback = r, this;
  }
  toJSON(r) {
    return r.arrayBuffers === void 0 && (r.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ua()), r.arrayBuffers[this.array.buffer._uuid] === void 0 && (r.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
};
const vr = /* @__PURE__ */ new X();
let ww = class wR {
  constructor(e, i, n, s = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = i, this.offset = n, this.normalized = s;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.data.count; i < n; i++)
      vr.fromBufferAttribute(this, i), vr.applyMatrix4(e), this.setXYZ(i, vr.x, vr.y, vr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      vr.fromBufferAttribute(this, i), vr.applyNormalMatrix(e), this.setXYZ(i, vr.x, vr.y, vr.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      vr.fromBufferAttribute(this, i), vr.transformDirection(e), this.setXYZ(i, vr.x, vr.y, vr.z);
    return this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.data.stride + this.offset + i];
    return this.normalized && (n = Hn(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = Jt(n, this.array)), this.data.array[e * this.data.stride + this.offset + i] = n, this;
  }
  setX(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset] = i, this;
  }
  setY(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = i, this;
  }
  setZ(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = i, this;
  }
  setW(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = i, this;
  }
  getX(e) {
    let i = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  getY(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  getZ(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  getW(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  setXY(e, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Jt(i, this.array), n = Jt(n, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Jt(i, this.array), n = Jt(n, this.array), s = Jt(s, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Jt(i, this.array), n = Jt(n, this.array), s = Jt(s, this.array), a = Jt(a, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = a, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return new xn(new this.array.constructor(i), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new wR(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: i,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}, Lj = class extends Nl {
  static get type() {
    return "SpriteMaterial";
  }
  constructor(r) {
    super(), this.isSpriteMaterial = !0, this.color = new Ut(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.alphaMap = r.alphaMap, this.rotation = r.rotation, this.sizeAttenuation = r.sizeAttenuation, this.fog = r.fog, this;
  }
}, eu;
const ah = /* @__PURE__ */ new X(), tu = /* @__PURE__ */ new X(), iu = /* @__PURE__ */ new X(), ru = /* @__PURE__ */ new ke(), oh = /* @__PURE__ */ new ke(), ER = /* @__PURE__ */ new ui(), Op = /* @__PURE__ */ new X(), lh = /* @__PURE__ */ new X(), Dp = /* @__PURE__ */ new X(), Ew = /* @__PURE__ */ new ke(), Ky = /* @__PURE__ */ new ke(), Mw = /* @__PURE__ */ new ke();
class kj extends Vr {
  constructor(e = new Lj()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", eu === void 0) {
      eu = new un();
      const i = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new Dj(i, 5);
      eu.setIndex([0, 1, 2, 0, 2, 3]), eu.setAttribute("position", new ww(n, 3, 0, !1)), eu.setAttribute("uv", new ww(n, 2, 3, !1));
    }
    this.geometry = eu, this.material = e, this.center = new ke(0.5, 0.5);
  }
  raycast(e, i) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), tu.setFromMatrixScale(this.matrixWorld), ER.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), iu.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && tu.multiplyScalar(-iu.z);
    const n = this.material.rotation;
    let s, a;
    n !== 0 && (a = Math.cos(n), s = Math.sin(n));
    const o = this.center;
    Lp(Op.set(-0.5, -0.5, 0), iu, o, tu, s, a), Lp(lh.set(0.5, -0.5, 0), iu, o, tu, s, a), Lp(Dp.set(0.5, 0.5, 0), iu, o, tu, s, a), Ew.set(0, 0), Ky.set(1, 0), Mw.set(1, 1);
    let l = e.ray.intersectTriangle(Op, lh, Dp, !1, ah);
    if (l === null && (Lp(lh.set(-0.5, 0.5, 0), iu, o, tu, s, a), Ky.set(0, 1), l = e.ray.intersectTriangle(Op, Dp, lh, !1, ah), l === null))
      return;
    const u = e.ray.origin.distanceTo(ah);
    u < e.near || u > e.far || i.push({
      distance: u,
      point: ah.clone(),
      uv: Au.getInterpolation(ah, Op, lh, Dp, Ew, Ky, Mw, new ke()),
      face: null,
      object: this
    });
  }
  copy(e, i) {
    return super.copy(e, i), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Lp(r, e, i, n, s, a) {
  ru.subVectors(r, i).addScalar(0.5).multiply(n), s !== void 0 ? (oh.x = a * ru.x - s * ru.y, oh.y = s * ru.x + a * ru.y) : oh.copy(ru), r.copy(e), r.x += oh.x, r.y += oh.y, r.applyMatrix4(ER);
}
let MR = class extends Nl {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(r) {
    super(), this.isLineBasicMaterial = !0, this.color = new Ut(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.linewidth = r.linewidth, this.linecap = r.linecap, this.linejoin = r.linejoin, this.fog = r.fog, this;
  }
};
const xm = /* @__PURE__ */ new X(), _m = /* @__PURE__ */ new X(), Aw = /* @__PURE__ */ new ui(), uh = /* @__PURE__ */ new Sg(), kp = /* @__PURE__ */ new Tg(), Zy = /* @__PURE__ */ new X(), Cw = /* @__PURE__ */ new X();
class Uj extends Vr {
  constructor(e = new un(), i = new MR()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = i, this.updateMorphTargets();
  }
  copy(e, i) {
    return super.copy(e, i), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const i = e.attributes.position, n = [0];
      for (let s = 1, a = i.count; s < a; s++)
        xm.fromBufferAttribute(i, s - 1), _m.fromBufferAttribute(i, s), n[s] = n[s - 1], n[s] += xm.distanceTo(_m);
      e.setAttribute("lineDistance", new Ri(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, i) {
    const n = this.geometry, s = this.matrixWorld, a = e.params.Line.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), kp.copy(n.boundingSphere), kp.applyMatrix4(s), kp.radius += a, e.ray.intersectsSphere(kp) === !1) return;
    Aw.copy(s).invert(), uh.copy(e.ray).applyMatrix4(Aw);
    const l = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), u = l * l, c = this.isLineSegments ? 2 : 1, h = n.index, d = n.attributes.position;
    if (h !== null) {
      const p = Math.max(0, o.start), f = Math.min(h.count, o.start + o.count);
      for (let m = p, y = f - 1; m < y; m += c) {
        const v = h.getX(m), g = h.getX(m + 1), _ = Up(this, e, uh, u, v, g);
        _ && i.push(_);
      }
      if (this.isLineLoop) {
        const m = h.getX(f - 1), y = h.getX(p), v = Up(this, e, uh, u, m, y);
        v && i.push(v);
      }
    } else {
      const p = Math.max(0, o.start), f = Math.min(d.count, o.start + o.count);
      for (let m = p, y = f - 1; m < y; m += c) {
        const v = Up(this, e, uh, u, m, m + 1);
        v && i.push(v);
      }
      if (this.isLineLoop) {
        const m = Up(this, e, uh, u, f - 1, p);
        m && i.push(m);
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, i = Object.keys(e);
    if (i.length > 0) {
      const n = e[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
        }
      }
    }
  }
}
function Up(r, e, i, n, s, a) {
  const o = r.geometry.attributes.position;
  if (xm.fromBufferAttribute(o, s), _m.fromBufferAttribute(o, a), i.distanceSqToSegment(xm, _m, Zy, Cw) > n) return;
  Zy.applyMatrix4(r.matrixWorld);
  const l = e.ray.origin.distanceTo(Zy);
  if (!(l < e.near || l > e.far))
    return {
      distance: l,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: Cw.clone().applyMatrix4(r.matrixWorld),
      index: s,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: r
    };
}
class Sa {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, i) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, i);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const i = [];
    for (let n = 0; n <= e; n++)
      i.push(this.getPoint(n / e));
    return i;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const i = [];
    for (let n = 0; n <= e; n++)
      i.push(this.getPointAt(n / e));
    return i;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const i = [];
    let n, s = this.getPoint(0), a = 0;
    i.push(0);
    for (let o = 1; o <= e; o++)
      n = this.getPoint(o / e), a += n.distanceTo(s), i.push(a), s = n;
    return this.cacheArcLengths = i, i;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, i) {
    const n = this.getLengths();
    let s = 0;
    const a = n.length;
    let o;
    i ? o = i : o = e * n[a - 1];
    let l = 0, u = a - 1, c;
    for (; l <= u; )
      if (s = Math.floor(l + (u - l) / 2), c = n[s] - o, c < 0)
        l = s + 1;
      else if (c > 0)
        u = s - 1;
      else {
        u = s;
        break;
      }
    if (s = u, n[s] === o)
      return s / (a - 1);
    const h = n[s], d = n[s + 1] - h, p = (o - h) / d;
    return (s + p) / (a - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, i) {
    let n = e - 1e-4, s = e + 1e-4;
    n < 0 && (n = 0), s > 1 && (s = 1);
    const a = this.getPoint(n), o = this.getPoint(s), l = i || (a.isVector2 ? new ke() : new X());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(e, i) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, i);
  }
  computeFrenetFrames(e, i) {
    const n = new X(), s = [], a = [], o = [], l = new X(), u = new ui();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      s[f] = this.getTangentAt(m, new X());
    }
    a[0] = new X(), o[0] = new X();
    let c = Number.MAX_VALUE;
    const h = Math.abs(s[0].x), d = Math.abs(s[0].y), p = Math.abs(s[0].z);
    h <= c && (c = h, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), p <= c && n.set(0, 0, 1), l.crossVectors(s[0], n).normalize(), a[0].crossVectors(s[0], l), o[0].crossVectors(s[0], a[0]);
    for (let f = 1; f <= e; f++) {
      if (a[f] = a[f - 1].clone(), o[f] = o[f - 1].clone(), l.crossVectors(s[f - 1], s[f]), l.length() > Number.EPSILON) {
        l.normalize();
        const m = Math.acos(Yi(s[f - 1].dot(s[f]), -1, 1));
        a[f].applyMatrix4(u.makeRotationAxis(l, m));
      }
      o[f].crossVectors(s[f], a[f]);
    }
    if (i === !0) {
      let f = Math.acos(Yi(a[0].dot(a[e]), -1, 1));
      f /= e, s[0].dot(l.crossVectors(a[0], a[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++)
        a[m].applyMatrix4(u.makeRotationAxis(s[m], f * m)), o[m].crossVectors(s[m], a[m]);
    }
    return {
      tangents: s,
      normals: a,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class AR extends Sa {
  constructor(e = 0, i = 0, n = 1, s = 1, a = 0, o = Math.PI * 2, l = !1, u = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = i, this.xRadius = n, this.yRadius = s, this.aStartAngle = a, this.aEndAngle = o, this.aClockwise = l, this.aRotation = u;
  }
  getPoint(e, i = new ke()) {
    const n = i, s = Math.PI * 2;
    let a = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(a) < Number.EPSILON;
    for (; a < 0; ) a += s;
    for (; a > s; ) a -= s;
    a < Number.EPSILON && (o ? a = 0 : a = s), this.aClockwise === !0 && !o && (a === s ? a = -s : a = a - s);
    const l = this.aStartAngle + e * a;
    let u = this.aX + this.xRadius * Math.cos(l), c = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = u - this.aX, f = c - this.aY;
      u = p * h - f * d + this.aX, c = p * d + f * h + this.aY;
    }
    return n.set(u, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class Fj extends AR {
  constructor(e, i, n, s, a, o) {
    super(e, i, n, n, s, a, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function z_() {
  let r = 0, e = 0, i = 0, n = 0;
  function s(a, o, l, u) {
    r = a, e = l, i = -3 * a + 3 * o - 2 * l - u, n = 2 * a - 2 * o + l + u;
  }
  return {
    initCatmullRom: function(a, o, l, u, c) {
      s(o, l, c * (l - a), c * (u - o));
    },
    initNonuniformCatmullRom: function(a, o, l, u, c, h, d) {
      let p = (o - a) / c - (l - a) / (c + h) + (l - o) / h, f = (l - o) / h - (u - o) / (h + d) + (u - l) / d;
      p *= h, f *= h, s(o, l, p, f);
    },
    calc: function(a) {
      const o = a * a, l = o * a;
      return r + e * a + i * o + n * l;
    }
  };
}
const Fp = /* @__PURE__ */ new X(), Qy = /* @__PURE__ */ new z_(), Jy = /* @__PURE__ */ new z_(), e0 = /* @__PURE__ */ new z_();
class Bj extends Sa {
  constructor(e = [], i = !1, n = "centripetal", s = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = i, this.curveType = n, this.tension = s;
  }
  getPoint(e, i = new X()) {
    const n = i, s = this.points, a = s.length, o = (a - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(o), u = o - l;
    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / a) + 1) * a : u === 0 && l === a - 1 && (l = a - 2, u = 1);
    let c, h;
    this.closed || l > 0 ? c = s[(l - 1) % a] : (Fp.subVectors(s[0], s[1]).add(s[0]), c = Fp);
    const d = s[l % a], p = s[(l + 1) % a];
    if (this.closed || l + 2 < a ? h = s[(l + 2) % a] : (Fp.subVectors(s[a - 1], s[a - 2]).add(s[a - 1]), h = Fp), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(c.distanceToSquared(d), f), y = Math.pow(d.distanceToSquared(p), f), v = Math.pow(p.distanceToSquared(h), f);
      y < 1e-4 && (y = 1), m < 1e-4 && (m = y), v < 1e-4 && (v = y), Qy.initNonuniformCatmullRom(c.x, d.x, p.x, h.x, m, y, v), Jy.initNonuniformCatmullRom(c.y, d.y, p.y, h.y, m, y, v), e0.initNonuniformCatmullRom(c.z, d.z, p.z, h.z, m, y, v);
    } else this.curveType === "catmullrom" && (Qy.initCatmullRom(c.x, d.x, p.x, h.x, this.tension), Jy.initCatmullRom(c.y, d.y, p.y, h.y, this.tension), e0.initCatmullRom(c.z, d.z, p.z, h.z, this.tension));
    return n.set(
      Qy.calc(u),
      Jy.calc(u),
      e0.calc(u)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(s.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let i = 0, n = this.points.length; i < n; i++) {
      const s = this.points[i];
      e.points.push(s.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(new X().fromArray(s));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function Rw(r, e, i, n, s) {
  const a = (n - e) * 0.5, o = (s - i) * 0.5, l = r * r, u = r * l;
  return (2 * i - 2 * n + a + o) * u + (-3 * i + 3 * n - 2 * a - o) * l + a * r + i;
}
function zj(r, e) {
  const i = 1 - r;
  return i * i * e;
}
function jj(r, e) {
  return 2 * (1 - r) * r * e;
}
function Vj(r, e) {
  return r * r * e;
}
function Kh(r, e, i, n) {
  return zj(r, e) + jj(r, i) + Vj(r, n);
}
function Gj(r, e) {
  const i = 1 - r;
  return i * i * i * e;
}
function Hj(r, e) {
  const i = 1 - r;
  return 3 * i * i * r * e;
}
function Wj(r, e) {
  return 3 * (1 - r) * r * r * e;
}
function qj(r, e) {
  return r * r * r * e;
}
function Zh(r, e, i, n, s) {
  return Gj(r, e) + Hj(r, i) + Wj(r, n) + qj(r, s);
}
class Xj extends Sa {
  constructor(e = new ke(), i = new ke(), n = new ke(), s = new ke()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = i, this.v2 = n, this.v3 = s;
  }
  getPoint(e, i = new ke()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2, l = this.v3;
    return n.set(
      Zh(e, s.x, a.x, o.x, l.x),
      Zh(e, s.y, a.y, o.y, l.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class CR extends Sa {
  constructor(e = new X(), i = new X(), n = new X(), s = new X()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = i, this.v2 = n, this.v3 = s;
  }
  getPoint(e, i = new X()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2, l = this.v3;
    return n.set(
      Zh(e, s.x, a.x, o.x, l.x),
      Zh(e, s.y, a.y, o.y, l.y),
      Zh(e, s.z, a.z, o.z, l.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class $j extends Sa {
  constructor(e = new ke(), i = new ke()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = i;
  }
  getPoint(e, i = new ke()) {
    const n = i;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, i) {
    return this.getPoint(e, i);
  }
  getTangent(e, i = new ke()) {
    return i.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, i) {
    return this.getTangent(e, i);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Yj extends Sa {
  constructor(e = new X(), i = new X()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = i;
  }
  getPoint(e, i = new X()) {
    const n = i;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, i) {
    return this.getPoint(e, i);
  }
  getTangent(e, i = new X()) {
    return i.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, i) {
    return this.getTangent(e, i);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Kj extends Sa {
  constructor(e = new ke(), i = new ke(), n = new ke()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = i, this.v2 = n;
  }
  getPoint(e, i = new ke()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2;
    return n.set(
      Kh(e, s.x, a.x, o.x),
      Kh(e, s.y, a.y, o.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class j_ extends Sa {
  constructor(e = new X(), i = new X(), n = new X()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = i, this.v2 = n;
  }
  getPoint(e, i = new X()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2;
    return n.set(
      Kh(e, s.x, a.x, o.x),
      Kh(e, s.y, a.y, o.y),
      Kh(e, s.z, a.z, o.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Zj extends Sa {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, i = new ke()) {
    const n = i, s = this.points, a = (s.length - 1) * e, o = Math.floor(a), l = a - o, u = s[o === 0 ? o : o - 1], c = s[o], h = s[o > s.length - 2 ? s.length - 1 : o + 1], d = s[o > s.length - 3 ? s.length - 1 : o + 2];
    return n.set(
      Rw(l, u.x, c.x, h.x, d.x),
      Rw(l, u.y, c.y, h.y, d.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let i = 0, n = this.points.length; i < n; i++) {
      const s = this.points[i];
      e.points.push(s.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(new ke().fromArray(s));
    }
    return this;
  }
}
var Qj = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: Fj,
  CatmullRomCurve3: Bj,
  CubicBezierCurve: Xj,
  CubicBezierCurve3: CR,
  EllipseCurve: AR,
  LineCurve: $j,
  LineCurve3: Yj,
  QuadraticBezierCurve: Kj,
  QuadraticBezierCurve3: j_,
  SplineCurve: Zj
});
class V_ extends un {
  constructor(e = 1, i = 32, n = 0, s = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: i,
      thetaStart: n,
      thetaLength: s
    }, i = Math.max(3, i);
    const a = [], o = [], l = [], u = [], c = new X(), h = new ke();
    o.push(0, 0, 0), l.push(0, 0, 1), u.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= i; d++, p += 3) {
      const f = n + d / i * s;
      c.x = e * Math.cos(f), c.y = e * Math.sin(f), o.push(c.x, c.y, c.z), l.push(0, 0, 1), h.x = (o[p] / e + 1) / 2, h.y = (o[p + 1] / e + 1) / 2, u.push(h.x, h.y);
    }
    for (let d = 1; d <= i; d++)
      a.push(d, d + 1, 0);
    this.setIndex(a), this.setAttribute("position", new Ri(o, 3)), this.setAttribute("normal", new Ri(l, 3)), this.setAttribute("uv", new Ri(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new V_(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Mg extends un {
  constructor(e = 1, i = 1, n = 1, s = 32, a = 1, o = !1, l = 0, u = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: i,
      height: n,
      radialSegments: s,
      heightSegments: a,
      openEnded: o,
      thetaStart: l,
      thetaLength: u
    };
    const c = this;
    s = Math.floor(s), a = Math.floor(a);
    const h = [], d = [], p = [], f = [];
    let m = 0;
    const y = [], v = n / 2;
    let g = 0;
    _(), o === !1 && (e > 0 && x(!0), i > 0 && x(!1)), this.setIndex(h), this.setAttribute("position", new Ri(d, 3)), this.setAttribute("normal", new Ri(p, 3)), this.setAttribute("uv", new Ri(f, 2));
    function _() {
      const b = new X(), T = new X();
      let S = 0;
      const w = (i - e) / n;
      for (let M = 0; M <= a; M++) {
        const E = [], A = M / a, N = A * (i - e) + e;
        for (let U = 0; U <= s; U++) {
          const k = U / s, C = k * u + l, I = Math.sin(C), O = Math.cos(C);
          T.x = N * I, T.y = -A * n + v, T.z = N * O, d.push(T.x, T.y, T.z), b.set(I, w, O).normalize(), p.push(b.x, b.y, b.z), f.push(k, 1 - A), E.push(m++);
        }
        y.push(E);
      }
      for (let M = 0; M < s; M++)
        for (let E = 0; E < a; E++) {
          const A = y[E][M], N = y[E + 1][M], U = y[E + 1][M + 1], k = y[E][M + 1];
          (e > 0 || E !== 0) && (h.push(A, N, k), S += 3), (i > 0 || E !== a - 1) && (h.push(N, U, k), S += 3);
        }
      c.addGroup(g, S, 0), g += S;
    }
    function x(b) {
      const T = m, S = new ke(), w = new X();
      let M = 0;
      const E = b === !0 ? e : i, A = b === !0 ? 1 : -1;
      for (let U = 1; U <= s; U++)
        d.push(0, v * A, 0), p.push(0, A, 0), f.push(0.5, 0.5), m++;
      const N = m;
      for (let U = 0; U <= s; U++) {
        const k = U / s * u + l, C = Math.cos(k), I = Math.sin(k);
        w.x = E * I, w.y = v * A, w.z = E * C, d.push(w.x, w.y, w.z), p.push(0, A, 0), S.x = C * 0.5 + 0.5, S.y = I * 0.5 * A + 0.5, f.push(S.x, S.y), m++;
      }
      for (let U = 0; U < s; U++) {
        const k = T + U, C = N + U;
        b === !0 ? h.push(C, C + 1, k) : h.push(C + 1, C, k), M += 3;
      }
      c.addGroup(g, M, b === !0 ? 1 : 2), g += M;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Mg(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class G_ extends Mg {
  constructor(e = 1, i = 1, n = 32, s = 1, a = !1, o = 0, l = Math.PI * 2) {
    super(0, e, i, n, s, a, o, l), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: i,
      radialSegments: n,
      heightSegments: s,
      openEnded: a,
      thetaStart: o,
      thetaLength: l
    };
  }
  static fromJSON(e) {
    return new G_(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
let RR = class NR extends un {
  constructor(e = 1, i = 32, n = 16, s = 0, a = Math.PI * 2, o = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: i,
      heightSegments: n,
      phiStart: s,
      phiLength: a,
      thetaStart: o,
      thetaLength: l
    }, i = Math.max(3, Math.floor(i)), n = Math.max(2, Math.floor(n));
    const u = Math.min(o + l, Math.PI);
    let c = 0;
    const h = [], d = new X(), p = new X(), f = [], m = [], y = [], v = [];
    for (let g = 0; g <= n; g++) {
      const _ = [], x = g / n;
      let b = 0;
      g === 0 && o === 0 ? b = 0.5 / i : g === n && u === Math.PI && (b = -0.5 / i);
      for (let T = 0; T <= i; T++) {
        const S = T / i;
        d.x = -e * Math.cos(s + S * a) * Math.sin(o + x * l), d.y = e * Math.cos(o + x * l), d.z = e * Math.sin(s + S * a) * Math.sin(o + x * l), m.push(d.x, d.y, d.z), p.copy(d).normalize(), y.push(p.x, p.y, p.z), v.push(S + b, 1 - x), _.push(c++);
      }
      h.push(_);
    }
    for (let g = 0; g < n; g++)
      for (let _ = 0; _ < i; _++) {
        const x = h[g][_ + 1], b = h[g][_], T = h[g + 1][_], S = h[g + 1][_ + 1];
        (g !== 0 || o > 0) && f.push(x, b, S), (g !== n - 1 || u < Math.PI) && f.push(b, T, S);
      }
    this.setIndex(f), this.setAttribute("position", new Ri(m, 3)), this.setAttribute("normal", new Ri(y, 3)), this.setAttribute("uv", new Ri(v, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new NR(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
};
class H_ extends un {
  constructor(e = new j_(new X(-1, -1, 0), new X(-1, 1, 0), new X(1, 1, 0)), i = 64, n = 1, s = 8, a = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: i,
      radius: n,
      radialSegments: s,
      closed: a
    };
    const o = e.computeFrenetFrames(i, a);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const l = new X(), u = new X(), c = new ke();
    let h = new X();
    const d = [], p = [], f = [], m = [];
    y(), this.setIndex(m), this.setAttribute("position", new Ri(d, 3)), this.setAttribute("normal", new Ri(p, 3)), this.setAttribute("uv", new Ri(f, 2));
    function y() {
      for (let x = 0; x < i; x++)
        v(x);
      v(a === !1 ? i : 0), _(), g();
    }
    function v(x) {
      h = e.getPointAt(x / i, h);
      const b = o.normals[x], T = o.binormals[x];
      for (let S = 0; S <= s; S++) {
        const w = S / s * Math.PI * 2, M = Math.sin(w), E = -Math.cos(w);
        u.x = E * b.x + M * T.x, u.y = E * b.y + M * T.y, u.z = E * b.z + M * T.z, u.normalize(), p.push(u.x, u.y, u.z), l.x = h.x + n * u.x, l.y = h.y + n * u.y, l.z = h.z + n * u.z, d.push(l.x, l.y, l.z);
      }
    }
    function g() {
      for (let x = 1; x <= i; x++)
        for (let b = 1; b <= s; b++) {
          const T = (s + 1) * (x - 1) + (b - 1), S = (s + 1) * x + (b - 1), w = (s + 1) * x + b, M = (s + 1) * (x - 1) + b;
          m.push(T, S, M), m.push(S, w, M);
        }
    }
    function _() {
      for (let x = 0; x <= i; x++)
        for (let b = 0; b <= s; b++)
          c.x = x / i, c.y = b / s, f.push(c.x, c.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new H_(
      new Qj[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
let Jj = class extends Nl {
  static get type() {
    return "MeshLambertMaterial";
  }
  constructor(r) {
    super(), this.isMeshLambertMaterial = !0, this.color = new Ut(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ut(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = JC, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new yo(), this.combine = A_, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.lightMap = r.lightMap, this.lightMapIntensity = r.lightMapIntensity, this.aoMap = r.aoMap, this.aoMapIntensity = r.aoMapIntensity, this.emissive.copy(r.emissive), this.emissiveMap = r.emissiveMap, this.emissiveIntensity = r.emissiveIntensity, this.bumpMap = r.bumpMap, this.bumpScale = r.bumpScale, this.normalMap = r.normalMap, this.normalMapType = r.normalMapType, this.normalScale.copy(r.normalScale), this.displacementMap = r.displacementMap, this.displacementScale = r.displacementScale, this.displacementBias = r.displacementBias, this.specularMap = r.specularMap, this.alphaMap = r.alphaMap, this.envMap = r.envMap, this.envMapRotation.copy(r.envMapRotation), this.combine = r.combine, this.reflectivity = r.reflectivity, this.refractionRatio = r.refractionRatio, this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.wireframeLinecap = r.wireframeLinecap, this.wireframeLinejoin = r.wireframeLinejoin, this.flatShading = r.flatShading, this.fog = r.fog, this;
  }
};
const Nw = {
  enabled: !1,
  files: {},
  add: function(r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function(r) {
    if (this.enabled !== !1)
      return this.files[r];
  },
  remove: function(r) {
    delete this.files[r];
  },
  clear: function() {
    this.files = {};
  }
};
class eV {
  constructor(e, i, n) {
    const s = this;
    let a = !1, o = 0, l = 0, u;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = i, this.onError = n, this.itemStart = function(h) {
      l++, a === !1 && s.onStart !== void 0 && s.onStart(h, o, l), a = !0;
    }, this.itemEnd = function(h) {
      o++, s.onProgress !== void 0 && s.onProgress(h, o, l), o === l && (a = !1, s.onLoad !== void 0 && s.onLoad());
    }, this.itemError = function(h) {
      s.onError !== void 0 && s.onError(h);
    }, this.resolveURL = function(h) {
      return u ? u(h) : h;
    }, this.setURLModifier = function(h) {
      return u = h, this;
    }, this.addHandler = function(h, d) {
      return c.push(h, d), this;
    }, this.removeHandler = function(h) {
      const d = c.indexOf(h);
      return d !== -1 && c.splice(d, 2), this;
    }, this.getHandler = function(h) {
      for (let d = 0, p = c.length; d < p; d += 2) {
        const f = c[d], m = c[d + 1];
        if (f.global && (f.lastIndex = 0), f.test(h))
          return m;
      }
      return null;
    };
  }
}
const tV = /* @__PURE__ */ new eV();
class W_ {
  constructor(e) {
    this.manager = e !== void 0 ? e : tV, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, i) {
    const n = this;
    return new Promise(function(s, a) {
      n.load(e, s, i, a);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
W_.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class iV extends W_ {
  constructor(e) {
    super(e);
  }
  load(e, i, n, s) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const a = this, o = Nw.get(e);
    if (o !== void 0)
      return a.manager.itemStart(e), setTimeout(function() {
        i && i(o), a.manager.itemEnd(e);
      }, 0), o;
    const l = dd("img");
    function u() {
      h(), Nw.add(e, this), i && i(this), a.manager.itemEnd(e);
    }
    function c(d) {
      h(), s && s(d), a.manager.itemError(e), a.manager.itemEnd(e);
    }
    function h() {
      l.removeEventListener("load", u, !1), l.removeEventListener("error", c, !1);
    }
    return l.addEventListener("load", u, !1), l.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), a.manager.itemStart(e), l.src = e, l;
  }
}
class rV extends W_ {
  constructor(e) {
    super(e);
  }
  load(e, i, n, s) {
    const a = new wn(), o = new iV(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(l) {
      a.image = l, a.needsUpdate = !0, i !== void 0 && i(a);
    }, n, s), a;
  }
}
let PR = class extends Vr {
  constructor(r, e = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Ut(r), this.intensity = e;
  }
  dispose() {
  }
  copy(r, e) {
    return super.copy(r, e), this.color.copy(r.color), this.intensity = r.intensity, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (e.object.target = this.target.uuid), e;
  }
};
const t0 = /* @__PURE__ */ new ui(), Pw = /* @__PURE__ */ new X(), Iw = /* @__PURE__ */ new X();
let nV = class {
  constructor(r) {
    this.camera = r, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ke(512, 512), this.map = null, this.mapPass = null, this.matrix = new ui(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new U_(), this._frameExtents = new ke(1, 1), this._viewportCount = 1, this._viewports = [
      new Fi(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(r) {
    const e = this.camera, i = this.matrix;
    Pw.setFromMatrixPosition(r.matrixWorld), e.position.copy(Pw), Iw.setFromMatrixPosition(r.target.matrixWorld), e.lookAt(Iw), e.updateMatrixWorld(), t0.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(t0), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(t0);
  }
  getViewport(r) {
    return this._viewports[r];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(r) {
    return this.camera = r.camera.clone(), this.intensity = r.intensity, this.bias = r.bias, this.radius = r.radius, this.mapSize.copy(r.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const r = {};
    return this.intensity !== 1 && (r.intensity = this.intensity), this.bias !== 0 && (r.bias = this.bias), this.normalBias !== 0 && (r.normalBias = this.normalBias), this.radius !== 1 && (r.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (r.mapSize = this.mapSize.toArray()), r.camera = this.camera.toJSON(!1).object, delete r.camera.matrix, r;
  }
}, sV = class extends nV {
  constructor() {
    super(new F_(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}, aV = class extends PR {
  constructor(r, e) {
    super(r, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Vr.DEFAULT_UP), this.updateMatrix(), this.target = new Vr(), this.shadow = new sV();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(r) {
    return super.copy(r), this.target = r.target.clone(), this.shadow = r.shadow.clone(), this;
  }
}, oV = class extends PR {
  constructor(r, e) {
    super(r, e), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
};
class IR {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = Ow(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const i = Ow();
      e = (i - this.oldTime) / 1e3, this.oldTime = i, this.elapsedTime += e;
    }
    return e;
  }
}
function Ow() {
  return performance.now();
}
const Dw = /* @__PURE__ */ new ui();
class OR {
  constructor(e, i, n = 0, s = 1 / 0) {
    this.ray = new Sg(e, i), this.near = n, this.far = s, this.camera = null, this.layers = new L_(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, i) {
    this.ray.set(e, i);
  }
  setFromCamera(e, i) {
    i.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(i.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(i).sub(this.ray.origin).normalize(), this.camera = i) : i.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (i.near + i.far) / (i.near - i.far)).unproject(i), this.ray.direction.set(0, 0, -1).transformDirection(i.matrixWorld), this.camera = i) : console.error("THREE.Raycaster: Unsupported camera type: " + i.type);
  }
  setFromXRController(e) {
    return Dw.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Dw), this;
  }
  intersectObject(e, i = !0, n = []) {
    return zb(e, this, n, i), n.sort(Lw), n;
  }
  intersectObjects(e, i = !0, n = []) {
    for (let s = 0, a = e.length; s < a; s++)
      zb(e[s], this, n, i);
    return n.sort(Lw), n;
  }
}
function Lw(r, e) {
  return r.distance - e.distance;
}
function zb(r, e, i, n) {
  let s = !0;
  if (r.layers.test(e.layers) && r.raycast(e, i) === !1 && (s = !1), s === !0 && n === !0) {
    const a = r.children;
    for (let o = 0, l = a.length; o < l; o++)
      zb(a[o], e, i, !0);
  }
}
class kw {
  constructor(e = 1, i = 0, n = 0) {
    return this.radius = e, this.phi = i, this.theta = n, this;
  }
  set(e, i, n) {
    return this.radius = e, this.phi = i, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, i, n) {
    return this.radius = Math.sqrt(e * e + i * i + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Yi(i / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ag extends Cl {
  constructor(e, i = null) {
    super(), this.object = e, this.domElement = i, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: bg
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = bg);
function DR(r, e, i) {
  var n, s = 1;
  r == null && (r = 0), e == null && (e = 0), i == null && (i = 0);
  function a() {
    var o, l = n.length, u, c = 0, h = 0, d = 0;
    for (o = 0; o < l; ++o)
      u = n[o], c += u.x || 0, h += u.y || 0, d += u.z || 0;
    for (c = (c / l - r) * s, h = (h / l - e) * s, d = (d / l - i) * s, o = 0; o < l; ++o)
      u = n[o], c && (u.x -= c), h && (u.y -= h), d && (u.z -= d);
  }
  return a.initialize = function(o) {
    n = o;
  }, a.x = function(o) {
    return arguments.length ? (r = +o, a) : r;
  }, a.y = function(o) {
    return arguments.length ? (e = +o, a) : e;
  }, a.z = function(o) {
    return arguments.length ? (i = +o, a) : i;
  }, a.strength = function(o) {
    return arguments.length ? (s = +o, a) : s;
  }, a;
}
function lV(r) {
  const e = +this._x.call(null, r);
  return LR(this.cover(e), e, r);
}
function LR(r, e, i) {
  if (isNaN(e)) return r;
  var n, s = r._root, a = { data: i }, o = r._x0, l = r._x1, u, c, h, d, p;
  if (!s) return r._root = a, r;
  for (; s.length; )
    if ((h = e >= (u = (o + l) / 2)) ? o = u : l = u, n = s, !(s = s[d = +h])) return n[d] = a, r;
  if (c = +r._x.call(null, s.data), e === c) return a.next = s, n ? n[d] = a : r._root = a, r;
  do
    n = n ? n[d] = new Array(2) : r._root = new Array(2), (h = e >= (u = (o + l) / 2)) ? o = u : l = u;
  while ((d = +h) == (p = +(c >= u)));
  return n[p] = s, n[d] = a, r;
}
function uV(r) {
  Array.isArray(r) || (r = Array.from(r));
  const e = r.length, i = new Float64Array(e);
  let n = 1 / 0, s = -1 / 0;
  for (let a = 0, o; a < e; ++a)
    isNaN(o = +this._x.call(null, r[a])) || (i[a] = o, o < n && (n = o), o > s && (s = o));
  if (n > s) return this;
  this.cover(n).cover(s);
  for (let a = 0; a < e; ++a)
    LR(this, i[a], r[a]);
  return this;
}
function cV(r) {
  if (isNaN(r = +r)) return this;
  var e = this._x0, i = this._x1;
  if (isNaN(e))
    i = (e = Math.floor(r)) + 1;
  else {
    for (var n = i - e || 1, s = this._root, a, o; e > r || r >= i; )
      switch (o = +(r < e), a = new Array(2), a[o] = s, s = a, n *= 2, o) {
        case 0:
          i = e + n;
          break;
        case 1:
          e = i - n;
          break;
      }
    this._root && this._root.length && (this._root = s);
  }
  return this._x0 = e, this._x1 = i, this;
}
function hV() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function dV(r) {
  return arguments.length ? this.cover(+r[0][0]).cover(+r[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
}
function ha(r, e, i) {
  this.node = r, this.x0 = e, this.x1 = i;
}
function pV(r, e) {
  var i, n = this._x0, s, a, o = this._x1, l = [], u = this._root, c, h;
  for (u && l.push(new ha(u, n, o)), e == null ? e = 1 / 0 : (n = r - e, o = r + e); c = l.pop(); )
    if (!(!(u = c.node) || (s = c.x0) > o || (a = c.x1) < n))
      if (u.length) {
        var d = (s + a) / 2;
        l.push(
          new ha(u[1], d, a),
          new ha(u[0], s, d)
        ), (h = +(r >= d)) && (c = l[l.length - 1], l[l.length - 1] = l[l.length - 1 - h], l[l.length - 1 - h] = c);
      } else {
        var p = Math.abs(r - +this._x.call(null, u.data));
        p < e && (e = p, n = r - p, o = r + p, i = u.data);
      }
  return i;
}
function fV(r) {
  if (isNaN(u = +this._x.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._x1, u, c, h, d, p;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((h = u >= (c = (o + l) / 2)) ? o = c : l = c, e = i, !(i = i[d = +h])) return this;
    if (!i.length) break;
    e[d + 1 & 1] && (n = e, p = d);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[d] = a : delete e[d], (i = e[0] || e[1]) && i === (e[1] || e[0]) && !i.length && (n ? n[p] = i : this._root = i), this) : (this._root = a, this);
}
function mV(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function gV() {
  return this._root;
}
function yV() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function vV(r) {
  var e = [], i, n = this._root, s, a, o;
  for (n && e.push(new ha(n, this._x0, this._x1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.x1) && n.length) {
      var l = (a + o) / 2;
      (s = n[1]) && e.push(new ha(s, l, o)), (s = n[0]) && e.push(new ha(s, a, l));
    }
  return this;
}
function bV(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new ha(this._root, this._x0, this._x1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.x1, u = (o + l) / 2;
      (a = s[0]) && e.push(new ha(a, o, u)), (a = s[1]) && e.push(new ha(a, u, l));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.x1);
  return this;
}
function xV(r) {
  return r[0];
}
function _V(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function kR(r, e) {
  var i = new q_(e ?? xV, NaN, NaN);
  return r == null ? i : i.addAll(r);
}
function q_(r, e, i) {
  this._x = r, this._x0 = e, this._x1 = i, this._root = void 0;
}
function Uw(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var Wr = kR.prototype = q_.prototype;
Wr.copy = function() {
  var r = new q_(this._x, this._x0, this._x1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = Uw(e), r;
  for (i = [{ source: e, target: r._root = new Array(2) }]; e = i.pop(); )
    for (var s = 0; s < 2; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(2) }) : e.target[s] = Uw(n));
  return r;
};
Wr.add = lV;
Wr.addAll = uV;
Wr.cover = cV;
Wr.data = hV;
Wr.extent = dV;
Wr.find = pV;
Wr.remove = fV;
Wr.removeAll = mV;
Wr.root = gV;
Wr.size = yV;
Wr.visit = vV;
Wr.visitAfter = bV;
Wr.x = _V;
function TV(r) {
  const e = +this._x.call(null, r), i = +this._y.call(null, r);
  return UR(this.cover(e, i), e, i, r);
}
function UR(r, e, i, n) {
  if (isNaN(e) || isNaN(i)) return r;
  var s, a = r._root, o = { data: n }, l = r._x0, u = r._y0, c = r._x1, h = r._y1, d, p, f, m, y, v, g, _;
  if (!a) return r._root = o, r;
  for (; a.length; )
    if ((y = e >= (d = (l + c) / 2)) ? l = d : c = d, (v = i >= (p = (u + h) / 2)) ? u = p : h = p, s = a, !(a = a[g = v << 1 | y])) return s[g] = o, r;
  if (f = +r._x.call(null, a.data), m = +r._y.call(null, a.data), e === f && i === m) return o.next = a, s ? s[g] = o : r._root = o, r;
  do
    s = s ? s[g] = new Array(4) : r._root = new Array(4), (y = e >= (d = (l + c) / 2)) ? l = d : c = d, (v = i >= (p = (u + h) / 2)) ? u = p : h = p;
  while ((g = v << 1 | y) === (_ = (m >= p) << 1 | f >= d));
  return s[_] = a, s[g] = o, r;
}
function SV(r) {
  var e, i, n = r.length, s, a, o = new Array(n), l = new Array(n), u = 1 / 0, c = 1 / 0, h = -1 / 0, d = -1 / 0;
  for (i = 0; i < n; ++i)
    isNaN(s = +this._x.call(null, e = r[i])) || isNaN(a = +this._y.call(null, e)) || (o[i] = s, l[i] = a, s < u && (u = s), s > h && (h = s), a < c && (c = a), a > d && (d = a));
  if (u > h || c > d) return this;
  for (this.cover(u, c).cover(h, d), i = 0; i < n; ++i)
    UR(this, o[i], l[i], r[i]);
  return this;
}
function wV(r, e) {
  if (isNaN(r = +r) || isNaN(e = +e)) return this;
  var i = this._x0, n = this._y0, s = this._x1, a = this._y1;
  if (isNaN(i))
    s = (i = Math.floor(r)) + 1, a = (n = Math.floor(e)) + 1;
  else {
    for (var o = s - i || 1, l = this._root, u, c; i > r || r >= s || n > e || e >= a; )
      switch (c = (e < n) << 1 | r < i, u = new Array(4), u[c] = l, l = u, o *= 2, c) {
        case 0:
          s = i + o, a = n + o;
          break;
        case 1:
          i = s - o, a = n + o;
          break;
        case 2:
          s = i + o, n = a - o;
          break;
        case 3:
          i = s - o, n = a - o;
          break;
      }
    this._root && this._root.length && (this._root = l);
  }
  return this._x0 = i, this._y0 = n, this._x1 = s, this._y1 = a, this;
}
function EV() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function MV(r) {
  return arguments.length ? this.cover(+r[0][0], +r[0][1]).cover(+r[1][0], +r[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function wr(r, e, i, n, s) {
  this.node = r, this.x0 = e, this.y0 = i, this.x1 = n, this.y1 = s;
}
function AV(r, e, i) {
  var n, s = this._x0, a = this._y0, o, l, u, c, h = this._x1, d = this._y1, p = [], f = this._root, m, y;
  for (f && p.push(new wr(f, s, a, h, d)), i == null ? i = 1 / 0 : (s = r - i, a = e - i, h = r + i, d = e + i, i *= i); m = p.pop(); )
    if (!(!(f = m.node) || (o = m.x0) > h || (l = m.y0) > d || (u = m.x1) < s || (c = m.y1) < a))
      if (f.length) {
        var v = (o + u) / 2, g = (l + c) / 2;
        p.push(
          new wr(f[3], v, g, u, c),
          new wr(f[2], o, g, v, c),
          new wr(f[1], v, l, u, g),
          new wr(f[0], o, l, v, g)
        ), (y = (e >= g) << 1 | r >= v) && (m = p[p.length - 1], p[p.length - 1] = p[p.length - 1 - y], p[p.length - 1 - y] = m);
      } else {
        var _ = r - +this._x.call(null, f.data), x = e - +this._y.call(null, f.data), b = _ * _ + x * x;
        if (b < i) {
          var T = Math.sqrt(i = b);
          s = r - T, a = e - T, h = r + T, d = e + T, n = f.data;
        }
      }
  return n;
}
function CV(r) {
  if (isNaN(h = +this._x.call(null, r)) || isNaN(d = +this._y.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._y0, u = this._x1, c = this._y1, h, d, p, f, m, y, v, g;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((m = h >= (p = (o + u) / 2)) ? o = p : u = p, (y = d >= (f = (l + c) / 2)) ? l = f : c = f, e = i, !(i = i[v = y << 1 | m])) return this;
    if (!i.length) break;
    (e[v + 1 & 3] || e[v + 2 & 3] || e[v + 3 & 3]) && (n = e, g = v);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[v] = a : delete e[v], (i = e[0] || e[1] || e[2] || e[3]) && i === (e[3] || e[2] || e[1] || e[0]) && !i.length && (n ? n[g] = i : this._root = i), this) : (this._root = a, this);
}
function RV(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function NV() {
  return this._root;
}
function PV() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function IV(r) {
  var e = [], i, n = this._root, s, a, o, l, u;
  for (n && e.push(new wr(n, this._x0, this._y0, this._x1, this._y1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.y0, l = i.x1, u = i.y1) && n.length) {
      var c = (a + l) / 2, h = (o + u) / 2;
      (s = n[3]) && e.push(new wr(s, c, h, l, u)), (s = n[2]) && e.push(new wr(s, a, h, c, u)), (s = n[1]) && e.push(new wr(s, c, o, l, h)), (s = n[0]) && e.push(new wr(s, a, o, c, h));
    }
  return this;
}
function OV(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new wr(this._root, this._x0, this._y0, this._x1, this._y1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.y0, u = n.x1, c = n.y1, h = (o + u) / 2, d = (l + c) / 2;
      (a = s[0]) && e.push(new wr(a, o, l, h, d)), (a = s[1]) && e.push(new wr(a, h, l, u, d)), (a = s[2]) && e.push(new wr(a, o, d, h, c)), (a = s[3]) && e.push(new wr(a, h, d, u, c));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.y0, n.x1, n.y1);
  return this;
}
function DV(r) {
  return r[0];
}
function LV(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function kV(r) {
  return r[1];
}
function UV(r) {
  return arguments.length ? (this._y = r, this) : this._y;
}
function FR(r, e, i) {
  var n = new X_(e ?? DV, i ?? kV, NaN, NaN, NaN, NaN);
  return r == null ? n : n.addAll(r);
}
function X_(r, e, i, n, s, a) {
  this._x = r, this._y = e, this._x0 = i, this._y0 = n, this._x1 = s, this._y1 = a, this._root = void 0;
}
function Fw(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var Nr = FR.prototype = X_.prototype;
Nr.copy = function() {
  var r = new X_(this._x, this._y, this._x0, this._y0, this._x1, this._y1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = Fw(e), r;
  for (i = [{ source: e, target: r._root = new Array(4) }]; e = i.pop(); )
    for (var s = 0; s < 4; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(4) }) : e.target[s] = Fw(n));
  return r;
};
Nr.add = TV;
Nr.addAll = SV;
Nr.cover = wV;
Nr.data = EV;
Nr.extent = MV;
Nr.find = AV;
Nr.remove = CV;
Nr.removeAll = RV;
Nr.root = NV;
Nr.size = PV;
Nr.visit = IV;
Nr.visitAfter = OV;
Nr.x = LV;
Nr.y = UV;
function FV(r) {
  const e = +this._x.call(null, r), i = +this._y.call(null, r), n = +this._z.call(null, r);
  return BR(this.cover(e, i, n), e, i, n, r);
}
function BR(r, e, i, n, s) {
  if (isNaN(e) || isNaN(i) || isNaN(n)) return r;
  var a, o = r._root, l = { data: s }, u = r._x0, c = r._y0, h = r._z0, d = r._x1, p = r._y1, f = r._z1, m, y, v, g, _, x, b, T, S, w, M;
  if (!o) return r._root = l, r;
  for (; o.length; )
    if ((b = e >= (m = (u + d) / 2)) ? u = m : d = m, (T = i >= (y = (c + p) / 2)) ? c = y : p = y, (S = n >= (v = (h + f) / 2)) ? h = v : f = v, a = o, !(o = o[w = S << 2 | T << 1 | b])) return a[w] = l, r;
  if (g = +r._x.call(null, o.data), _ = +r._y.call(null, o.data), x = +r._z.call(null, o.data), e === g && i === _ && n === x) return l.next = o, a ? a[w] = l : r._root = l, r;
  do
    a = a ? a[w] = new Array(8) : r._root = new Array(8), (b = e >= (m = (u + d) / 2)) ? u = m : d = m, (T = i >= (y = (c + p) / 2)) ? c = y : p = y, (S = n >= (v = (h + f) / 2)) ? h = v : f = v;
  while ((w = S << 2 | T << 1 | b) === (M = (x >= v) << 2 | (_ >= y) << 1 | g >= m));
  return a[M] = o, a[w] = l, r;
}
function BV(r) {
  Array.isArray(r) || (r = Array.from(r));
  const e = r.length, i = new Float64Array(e), n = new Float64Array(e), s = new Float64Array(e);
  let a = 1 / 0, o = 1 / 0, l = 1 / 0, u = -1 / 0, c = -1 / 0, h = -1 / 0;
  for (let d = 0, p, f, m, y; d < e; ++d)
    isNaN(f = +this._x.call(null, p = r[d])) || isNaN(m = +this._y.call(null, p)) || isNaN(y = +this._z.call(null, p)) || (i[d] = f, n[d] = m, s[d] = y, f < a && (a = f), f > u && (u = f), m < o && (o = m), m > c && (c = m), y < l && (l = y), y > h && (h = y));
  if (a > u || o > c || l > h) return this;
  this.cover(a, o, l).cover(u, c, h);
  for (let d = 0; d < e; ++d)
    BR(this, i[d], n[d], s[d], r[d]);
  return this;
}
function zV(r, e, i) {
  if (isNaN(r = +r) || isNaN(e = +e) || isNaN(i = +i)) return this;
  var n = this._x0, s = this._y0, a = this._z0, o = this._x1, l = this._y1, u = this._z1;
  if (isNaN(n))
    o = (n = Math.floor(r)) + 1, l = (s = Math.floor(e)) + 1, u = (a = Math.floor(i)) + 1;
  else {
    for (var c = o - n || 1, h = this._root, d, p; n > r || r >= o || s > e || e >= l || a > i || i >= u; )
      switch (p = (i < a) << 2 | (e < s) << 1 | r < n, d = new Array(8), d[p] = h, h = d, c *= 2, p) {
        case 0:
          o = n + c, l = s + c, u = a + c;
          break;
        case 1:
          n = o - c, l = s + c, u = a + c;
          break;
        case 2:
          o = n + c, s = l - c, u = a + c;
          break;
        case 3:
          n = o - c, s = l - c, u = a + c;
          break;
        case 4:
          o = n + c, l = s + c, a = u - c;
          break;
        case 5:
          n = o - c, l = s + c, a = u - c;
          break;
        case 6:
          o = n + c, s = l - c, a = u - c;
          break;
        case 7:
          n = o - c, s = l - c, a = u - c;
          break;
      }
    this._root && this._root.length && (this._root = h);
  }
  return this._x0 = n, this._y0 = s, this._z0 = a, this._x1 = o, this._y1 = l, this._z1 = u, this;
}
function jV() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function VV(r) {
  return arguments.length ? this.cover(+r[0][0], +r[0][1], +r[0][2]).cover(+r[1][0], +r[1][1], +r[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
}
function ii(r, e, i, n, s, a, o) {
  this.node = r, this.x0 = e, this.y0 = i, this.z0 = n, this.x1 = s, this.y1 = a, this.z1 = o;
}
function GV(r, e, i, n) {
  var s, a = this._x0, o = this._y0, l = this._z0, u, c, h, d, p, f, m = this._x1, y = this._y1, v = this._z1, g = [], _ = this._root, x, b;
  for (_ && g.push(new ii(_, a, o, l, m, y, v)), n == null ? n = 1 / 0 : (a = r - n, o = e - n, l = i - n, m = r + n, y = e + n, v = i + n, n *= n); x = g.pop(); )
    if (!(!(_ = x.node) || (u = x.x0) > m || (c = x.y0) > y || (h = x.z0) > v || (d = x.x1) < a || (p = x.y1) < o || (f = x.z1) < l))
      if (_.length) {
        var T = (u + d) / 2, S = (c + p) / 2, w = (h + f) / 2;
        g.push(
          new ii(_[7], T, S, w, d, p, f),
          new ii(_[6], u, S, w, T, p, f),
          new ii(_[5], T, c, w, d, S, f),
          new ii(_[4], u, c, w, T, S, f),
          new ii(_[3], T, S, h, d, p, w),
          new ii(_[2], u, S, h, T, p, w),
          new ii(_[1], T, c, h, d, S, w),
          new ii(_[0], u, c, h, T, S, w)
        ), (b = (i >= w) << 2 | (e >= S) << 1 | r >= T) && (x = g[g.length - 1], g[g.length - 1] = g[g.length - 1 - b], g[g.length - 1 - b] = x);
      } else {
        var M = r - +this._x.call(null, _.data), E = e - +this._y.call(null, _.data), A = i - +this._z.call(null, _.data), N = M * M + E * E + A * A;
        if (N < n) {
          var U = Math.sqrt(n = N);
          a = r - U, o = e - U, l = i - U, m = r + U, y = e + U, v = i + U, s = _.data;
        }
      }
  return s;
}
const HV = (r, e, i, n, s, a) => Math.sqrt((r - n) ** 2 + (e - s) ** 2 + (i - a) ** 2);
function WV(r, e, i, n) {
  const s = [], a = r - n, o = e - n, l = i - n, u = r + n, c = e + n, h = i + n;
  return this.visit((d, p, f, m, y, v, g) => {
    if (!d.length)
      do {
        const _ = d.data;
        HV(r, e, i, this._x(_), this._y(_), this._z(_)) <= n && s.push(_);
      } while (d = d.next);
    return p > u || f > c || m > h || y < a || v < o || g < l;
  }), s;
}
function qV(r) {
  if (isNaN(p = +this._x.call(null, r)) || isNaN(f = +this._y.call(null, r)) || isNaN(m = +this._z.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._y0, u = this._z0, c = this._x1, h = this._y1, d = this._z1, p, f, m, y, v, g, _, x, b, T, S;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((_ = p >= (y = (o + c) / 2)) ? o = y : c = y, (x = f >= (v = (l + h) / 2)) ? l = v : h = v, (b = m >= (g = (u + d) / 2)) ? u = g : d = g, e = i, !(i = i[T = b << 2 | x << 1 | _])) return this;
    if (!i.length) break;
    (e[T + 1 & 7] || e[T + 2 & 7] || e[T + 3 & 7] || e[T + 4 & 7] || e[T + 5 & 7] || e[T + 6 & 7] || e[T + 7 & 7]) && (n = e, S = T);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[T] = a : delete e[T], (i = e[0] || e[1] || e[2] || e[3] || e[4] || e[5] || e[6] || e[7]) && i === (e[7] || e[6] || e[5] || e[4] || e[3] || e[2] || e[1] || e[0]) && !i.length && (n ? n[S] = i : this._root = i), this) : (this._root = a, this);
}
function XV(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function $V() {
  return this._root;
}
function YV() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function KV(r) {
  var e = [], i, n = this._root, s, a, o, l, u, c, h;
  for (n && e.push(new ii(n, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.y0, l = i.z0, u = i.x1, c = i.y1, h = i.z1) && n.length) {
      var d = (a + u) / 2, p = (o + c) / 2, f = (l + h) / 2;
      (s = n[7]) && e.push(new ii(s, d, p, f, u, c, h)), (s = n[6]) && e.push(new ii(s, a, p, f, d, c, h)), (s = n[5]) && e.push(new ii(s, d, o, f, u, p, h)), (s = n[4]) && e.push(new ii(s, a, o, f, d, p, h)), (s = n[3]) && e.push(new ii(s, d, p, l, u, c, f)), (s = n[2]) && e.push(new ii(s, a, p, l, d, c, f)), (s = n[1]) && e.push(new ii(s, d, o, l, u, p, f)), (s = n[0]) && e.push(new ii(s, a, o, l, d, p, f));
    }
  return this;
}
function ZV(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new ii(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.y0, u = n.z0, c = n.x1, h = n.y1, d = n.z1, p = (o + c) / 2, f = (l + h) / 2, m = (u + d) / 2;
      (a = s[0]) && e.push(new ii(a, o, l, u, p, f, m)), (a = s[1]) && e.push(new ii(a, p, l, u, c, f, m)), (a = s[2]) && e.push(new ii(a, o, f, u, p, h, m)), (a = s[3]) && e.push(new ii(a, p, f, u, c, h, m)), (a = s[4]) && e.push(new ii(a, o, l, m, p, f, d)), (a = s[5]) && e.push(new ii(a, p, l, m, c, f, d)), (a = s[6]) && e.push(new ii(a, o, f, m, p, h, d)), (a = s[7]) && e.push(new ii(a, p, f, m, c, h, d));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.y0, n.z0, n.x1, n.y1, n.z1);
  return this;
}
function QV(r) {
  return r[0];
}
function JV(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function eG(r) {
  return r[1];
}
function tG(r) {
  return arguments.length ? (this._y = r, this) : this._y;
}
function iG(r) {
  return r[2];
}
function rG(r) {
  return arguments.length ? (this._z = r, this) : this._z;
}
function zR(r, e, i, n) {
  var s = new $_(e ?? QV, i ?? eG, n ?? iG, NaN, NaN, NaN, NaN, NaN, NaN);
  return r == null ? s : s.addAll(r);
}
function $_(r, e, i, n, s, a, o, l, u) {
  this._x = r, this._y = e, this._z = i, this._x0 = n, this._y0 = s, this._z0 = a, this._x1 = o, this._y1 = l, this._z1 = u, this._root = void 0;
}
function Bw(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var sr = zR.prototype = $_.prototype;
sr.copy = function() {
  var r = new $_(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = Bw(e), r;
  for (i = [{ source: e, target: r._root = new Array(8) }]; e = i.pop(); )
    for (var s = 0; s < 8; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(8) }) : e.target[s] = Bw(n));
  return r;
};
sr.add = FV;
sr.addAll = BV;
sr.cover = zV;
sr.data = jV;
sr.extent = VV;
sr.find = GV;
sr.findAllWithinRadius = WV;
sr.remove = qV;
sr.removeAll = XV;
sr.root = $V;
sr.size = YV;
sr.visit = KV;
sr.visitAfter = ZV;
sr.x = JV;
sr.y = tG;
sr.z = rG;
function sa(r) {
  return function() {
    return r;
  };
}
function Xs(r) {
  return (r() - 0.5) * 1e-6;
}
function nG(r) {
  return r.index;
}
function zw(r, e) {
  var i = r.get(e);
  if (!i) throw new Error("node not found: " + e);
  return i;
}
function jR(r) {
  var e = nG, i = p, n, s = sa(30), a, o, l, u, c, h, d = 1;
  r == null && (r = []);
  function p(g) {
    return 1 / Math.min(u[g.source.index], u[g.target.index]);
  }
  function f(g) {
    for (var _ = 0, x = r.length; _ < d; ++_)
      for (var b = 0, T, S, w, M = 0, E = 0, A = 0, N, U; b < x; ++b)
        T = r[b], S = T.source, w = T.target, M = w.x + w.vx - S.x - S.vx || Xs(h), l > 1 && (E = w.y + w.vy - S.y - S.vy || Xs(h)), l > 2 && (A = w.z + w.vz - S.z - S.vz || Xs(h)), N = Math.sqrt(M * M + E * E + A * A), N = (N - a[b]) / N * g * n[b], M *= N, E *= N, A *= N, w.vx -= M * (U = c[b]), l > 1 && (w.vy -= E * U), l > 2 && (w.vz -= A * U), S.vx += M * (U = 1 - U), l > 1 && (S.vy += E * U), l > 2 && (S.vz += A * U);
  }
  function m() {
    if (o) {
      var g, _ = o.length, x = r.length, b = new Map(o.map((S, w) => [e(S, w, o), S])), T;
      for (g = 0, u = new Array(_); g < x; ++g)
        T = r[g], T.index = g, typeof T.source != "object" && (T.source = zw(b, T.source)), typeof T.target != "object" && (T.target = zw(b, T.target)), u[T.source.index] = (u[T.source.index] || 0) + 1, u[T.target.index] = (u[T.target.index] || 0) + 1;
      for (g = 0, c = new Array(x); g < x; ++g)
        T = r[g], c[g] = u[T.source.index] / (u[T.source.index] + u[T.target.index]);
      n = new Array(x), y(), a = new Array(x), v();
    }
  }
  function y() {
    if (o)
      for (var g = 0, _ = r.length; g < _; ++g)
        n[g] = +i(r[g], g, r);
  }
  function v() {
    if (o)
      for (var g = 0, _ = r.length; g < _; ++g)
        a[g] = +s(r[g], g, r);
  }
  return f.initialize = function(g, ..._) {
    o = g, h = _.find((x) => typeof x == "function") || Math.random, l = _.find((x) => [1, 2, 3].includes(x)) || 2, m();
  }, f.links = function(g) {
    return arguments.length ? (r = g, m(), f) : r;
  }, f.id = function(g) {
    return arguments.length ? (e = g, f) : e;
  }, f.iterations = function(g) {
    return arguments.length ? (d = +g, f) : d;
  }, f.strength = function(g) {
    return arguments.length ? (i = typeof g == "function" ? g : sa(+g), y(), f) : i;
  }, f.distance = function(g) {
    return arguments.length ? (s = typeof g == "function" ? g : sa(+g), v(), f) : s;
  }, f;
}
var sG = { value: () => {
} };
function Wd() {
  for (var r = 0, e = arguments.length, i = {}, n; r < e; ++r) {
    if (!(n = arguments[r] + "") || n in i || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    i[n] = [];
  }
  return new Jf(i);
}
function Jf(r) {
  this._ = r;
}
function aG(r, e) {
  return r.trim().split(/^|\s+/).map(function(i) {
    var n = "", s = i.indexOf(".");
    if (s >= 0 && (n = i.slice(s + 1), i = i.slice(0, s)), i && !e.hasOwnProperty(i)) throw new Error("unknown type: " + i);
    return { type: i, name: n };
  });
}
Jf.prototype = Wd.prototype = {
  constructor: Jf,
  on: function(r, e) {
    var i = this._, n = aG(r + "", i), s, a = -1, o = n.length;
    if (arguments.length < 2) {
      for (; ++a < o; ) if ((s = (r = n[a]).type) && (s = oG(i[s], r.name))) return s;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++a < o; )
      if (s = (r = n[a]).type) i[s] = jw(i[s], r.name, e);
      else if (e == null) for (s in i) i[s] = jw(i[s], r.name, null);
    return this;
  },
  copy: function() {
    var r = {}, e = this._;
    for (var i in e) r[i] = e[i].slice();
    return new Jf(r);
  },
  call: function(r, e) {
    if ((s = arguments.length - 2) > 0) for (var i = new Array(s), n = 0, s, a; n < s; ++n) i[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    for (a = this._[r], n = 0, s = a.length; n < s; ++n) a[n].value.apply(e, i);
  },
  apply: function(r, e, i) {
    if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    for (var n = this._[r], s = 0, a = n.length; s < a; ++s) n[s].value.apply(e, i);
  }
};
function oG(r, e) {
  for (var i = 0, n = r.length, s; i < n; ++i)
    if ((s = r[i]).name === e)
      return s.value;
}
function jw(r, e, i) {
  for (var n = 0, s = r.length; n < s; ++n)
    if (r[n].name === e) {
      r[n] = sG, r = r.slice(0, n).concat(r.slice(n + 1));
      break;
    }
  return i != null && r.push({ name: e, value: i }), r;
}
var yc = 0, zh = 0, ch = 0, VR = 1e3, Tm, jh, Sm = 0, _l = 0, Cg = 0, pd = typeof performance == "object" && performance.now ? performance : Date, GR = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(r) {
  setTimeout(r, 17);
};
function Y_() {
  return _l || (GR(lG), _l = pd.now() + Cg);
}
function lG() {
  _l = 0;
}
function wm() {
  this._call = this._time = this._next = null;
}
wm.prototype = K_.prototype = {
  constructor: wm,
  restart: function(r, e, i) {
    if (typeof r != "function") throw new TypeError("callback is not a function");
    i = (i == null ? Y_() : +i) + (e == null ? 0 : +e), !this._next && jh !== this && (jh ? jh._next = this : Tm = this, jh = this), this._call = r, this._time = i, jb();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, jb());
  }
};
function K_(r, e, i) {
  var n = new wm();
  return n.restart(r, e, i), n;
}
function uG() {
  Y_(), ++yc;
  for (var r = Tm, e; r; )
    (e = _l - r._time) >= 0 && r._call.call(void 0, e), r = r._next;
  --yc;
}
function Vw() {
  _l = (Sm = pd.now()) + Cg, yc = zh = 0;
  try {
    uG();
  } finally {
    yc = 0, hG(), _l = 0;
  }
}
function cG() {
  var r = pd.now(), e = r - Sm;
  e > VR && (Cg -= e, Sm = r);
}
function hG() {
  for (var r, e = Tm, i, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), r = e, e = e._next) : (i = e._next, e._next = null, e = r ? r._next = i : Tm = i);
  jh = r, jb(n);
}
function jb(r) {
  if (!yc) {
    zh && (zh = clearTimeout(zh));
    var e = r - _l;
    e > 24 ? (r < 1 / 0 && (zh = setTimeout(Vw, r - pd.now() - Cg)), ch && (ch = clearInterval(ch))) : (ch || (Sm = pd.now(), ch = setInterval(cG, VR)), yc = 1, GR(Vw));
  }
}
function Gw(r, e, i) {
  var n = new wm();
  return e = e == null ? 0 : +e, n.restart((s) => {
    n.stop(), r(s + e);
  }, e, i), n;
}
const dG = 1664525, pG = 1013904223, Hw = 4294967296;
function fG() {
  let r = 1;
  return () => (r = (dG * r + pG) % Hw) / Hw;
}
var Ww = 3;
function i0(r) {
  return r.x;
}
function qw(r) {
  return r.y;
}
function mG(r) {
  return r.z;
}
var gG = 10, yG = Math.PI * (3 - Math.sqrt(5)), vG = Math.PI * 20 / (9 + Math.sqrt(221));
function HR(r, e) {
  e = e || 2;
  var i = Math.min(Ww, Math.max(1, Math.round(e))), n, s = 1, a = 1e-3, o = 1 - Math.pow(a, 1 / 300), l = 0, u = 0.6, c = /* @__PURE__ */ new Map(), h = K_(f), d = Wd("tick", "end"), p = fG();
  r == null && (r = []);
  function f() {
    m(), d.call("tick", n), s < a && (h.stop(), d.call("end", n));
  }
  function m(g) {
    var _, x = r.length, b;
    g === void 0 && (g = 1);
    for (var T = 0; T < g; ++T)
      for (s += (l - s) * o, c.forEach(function(S) {
        S(s);
      }), _ = 0; _ < x; ++_)
        b = r[_], b.fx == null ? b.x += b.vx *= u : (b.x = b.fx, b.vx = 0), i > 1 && (b.fy == null ? b.y += b.vy *= u : (b.y = b.fy, b.vy = 0)), i > 2 && (b.fz == null ? b.z += b.vz *= u : (b.z = b.fz, b.vz = 0));
    return n;
  }
  function y() {
    for (var g = 0, _ = r.length, x; g < _; ++g) {
      if (x = r[g], x.index = g, x.fx != null && (x.x = x.fx), x.fy != null && (x.y = x.fy), x.fz != null && (x.z = x.fz), isNaN(x.x) || i > 1 && isNaN(x.y) || i > 2 && isNaN(x.z)) {
        var b = gG * (i > 2 ? Math.cbrt(0.5 + g) : i > 1 ? Math.sqrt(0.5 + g) : g), T = g * yG, S = g * vG;
        i === 1 ? x.x = b : i === 2 ? (x.x = b * Math.cos(T), x.y = b * Math.sin(T)) : (x.x = b * Math.sin(T) * Math.cos(S), x.y = b * Math.cos(T), x.z = b * Math.sin(T) * Math.sin(S));
      }
      (isNaN(x.vx) || i > 1 && isNaN(x.vy) || i > 2 && isNaN(x.vz)) && (x.vx = 0, i > 1 && (x.vy = 0), i > 2 && (x.vz = 0));
    }
  }
  function v(g) {
    return g.initialize && g.initialize(r, p, i), g;
  }
  return y(), n = {
    tick: m,
    restart: function() {
      return h.restart(f), n;
    },
    stop: function() {
      return h.stop(), n;
    },
    numDimensions: function(g) {
      return arguments.length ? (i = Math.min(Ww, Math.max(1, Math.round(g))), c.forEach(v), n) : i;
    },
    nodes: function(g) {
      return arguments.length ? (r = g, y(), c.forEach(v), n) : r;
    },
    alpha: function(g) {
      return arguments.length ? (s = +g, n) : s;
    },
    alphaMin: function(g) {
      return arguments.length ? (a = +g, n) : a;
    },
    alphaDecay: function(g) {
      return arguments.length ? (o = +g, n) : +o;
    },
    alphaTarget: function(g) {
      return arguments.length ? (l = +g, n) : l;
    },
    velocityDecay: function(g) {
      return arguments.length ? (u = 1 - g, n) : 1 - u;
    },
    randomSource: function(g) {
      return arguments.length ? (p = g, c.forEach(v), n) : p;
    },
    force: function(g, _) {
      return arguments.length > 1 ? (_ == null ? c.delete(g) : c.set(g, v(_)), n) : c.get(g);
    },
    find: function() {
      var g = Array.prototype.slice.call(arguments), _ = g.shift() || 0, x = (i > 1 ? g.shift() : null) || 0, b = (i > 2 ? g.shift() : null) || 0, T = g.shift() || 1 / 0, S = 0, w = r.length, M, E, A, N, U, k;
      for (T *= T, S = 0; S < w; ++S)
        U = r[S], M = _ - U.x, E = x - (U.y || 0), A = b - (U.z || 0), N = M * M + E * E + A * A, N < T && (k = U, T = N);
      return k;
    },
    on: function(g, _) {
      return arguments.length > 1 ? (d.on(g, _), n) : d.on(g);
    }
  };
}
function WR() {
  var r, e, i, n, s, a = sa(-30), o, l = 1, u = 1 / 0, c = 0.81;
  function h(m) {
    var y, v = r.length, g = (e === 1 ? kR(r, i0) : e === 2 ? FR(r, i0, qw) : e === 3 ? zR(r, i0, qw, mG) : null).visitAfter(p);
    for (s = m, y = 0; y < v; ++y) i = r[y], g.visit(f);
  }
  function d() {
    if (r) {
      var m, y = r.length, v;
      for (o = new Array(y), m = 0; m < y; ++m) v = r[m], o[v.index] = +a(v, m, r);
    }
  }
  function p(m) {
    var y = 0, v, g, _ = 0, x, b, T, S, w = m.length;
    if (w) {
      for (x = b = T = S = 0; S < w; ++S)
        (v = m[S]) && (g = Math.abs(v.value)) && (y += v.value, _ += g, x += g * (v.x || 0), b += g * (v.y || 0), T += g * (v.z || 0));
      y *= Math.sqrt(4 / w), m.x = x / _, e > 1 && (m.y = b / _), e > 2 && (m.z = T / _);
    } else {
      v = m, v.x = v.data.x, e > 1 && (v.y = v.data.y), e > 2 && (v.z = v.data.z);
      do
        y += o[v.data.index];
      while (v = v.next);
    }
    m.value = y;
  }
  function f(m, y, v, g, _) {
    if (!m.value) return !0;
    var x = [v, g, _][e - 1], b = m.x - i.x, T = e > 1 ? m.y - i.y : 0, S = e > 2 ? m.z - i.z : 0, w = x - y, M = b * b + T * T + S * S;
    if (w * w / c < M)
      return M < u && (b === 0 && (b = Xs(n), M += b * b), e > 1 && T === 0 && (T = Xs(n), M += T * T), e > 2 && S === 0 && (S = Xs(n), M += S * S), M < l && (M = Math.sqrt(l * M)), i.vx += b * m.value * s / M, e > 1 && (i.vy += T * m.value * s / M), e > 2 && (i.vz += S * m.value * s / M)), !0;
    if (!(m.length || M >= u)) {
      (m.data !== i || m.next) && (b === 0 && (b = Xs(n), M += b * b), e > 1 && T === 0 && (T = Xs(n), M += T * T), e > 2 && S === 0 && (S = Xs(n), M += S * S), M < l && (M = Math.sqrt(l * M)));
      do
        m.data !== i && (w = o[m.data.index] * s / M, i.vx += b * w, e > 1 && (i.vy += T * w), e > 2 && (i.vz += S * w));
      while (m = m.next);
    }
  }
  return h.initialize = function(m, ...y) {
    r = m, n = y.find((v) => typeof v == "function") || Math.random, e = y.find((v) => [1, 2, 3].includes(v)) || 2, d();
  }, h.strength = function(m) {
    return arguments.length ? (a = typeof m == "function" ? m : sa(+m), d(), h) : a;
  }, h.distanceMin = function(m) {
    return arguments.length ? (l = m * m, h) : Math.sqrt(l);
  }, h.distanceMax = function(m) {
    return arguments.length ? (u = m * m, h) : Math.sqrt(u);
  }, h.theta = function(m) {
    return arguments.length ? (c = m * m, h) : Math.sqrt(c);
  }, h;
}
function qR(r, e, i, n) {
  var s, a, o = sa(0.1), l, u;
  typeof r != "function" && (r = sa(+r)), e == null && (e = 0), i == null && (i = 0), n == null && (n = 0);
  function c(d) {
    for (var p = 0, f = s.length; p < f; ++p) {
      var m = s[p], y = m.x - e || 1e-6, v = (m.y || 0) - i || 1e-6, g = (m.z || 0) - n || 1e-6, _ = Math.sqrt(y * y + v * v + g * g), x = (u[p] - _) * l[p] * d / _;
      m.vx += y * x, a > 1 && (m.vy += v * x), a > 2 && (m.vz += g * x);
    }
  }
  function h() {
    if (s) {
      var d, p = s.length;
      for (l = new Array(p), u = new Array(p), d = 0; d < p; ++d)
        u[d] = +r(s[d], d, s), l[d] = isNaN(u[d]) ? 0 : +o(s[d], d, s);
    }
  }
  return c.initialize = function(d, ...p) {
    s = d, a = p.find((f) => [1, 2, 3].includes(f)) || 2, h();
  }, c.strength = function(d) {
    return arguments.length ? (o = typeof d == "function" ? d : sa(+d), h(), c) : o;
  }, c.radius = function(d) {
    return arguments.length ? (r = typeof d == "function" ? d : sa(+d), h(), c) : r;
  }, c.x = function(d) {
    return arguments.length ? (e = +d, c) : e;
  }, c.y = function(d) {
    return arguments.length ? (i = +d, c) : i;
  }, c.z = function(d) {
    return arguments.length ? (n = +d, c) : n;
  }, c;
}
var Z_ = function(r) {
  xG(r);
  var e = bG(r);
  return r.on = e.on, r.off = e.off, r.fire = e.fire, r;
};
function bG(r) {
  var e = /* @__PURE__ */ Object.create(null);
  return {
    on: function(i, n, s) {
      if (typeof n != "function")
        throw new Error("callback is expected to be a function");
      var a = e[i];
      return a || (a = e[i] = []), a.push({ callback: n, ctx: s }), r;
    },
    off: function(i, n) {
      var s = typeof i > "u";
      if (s)
        return e = /* @__PURE__ */ Object.create(null), r;
      if (e[i]) {
        var a = typeof n != "function";
        if (a)
          delete e[i];
        else
          for (var o = e[i], l = 0; l < o.length; ++l)
            o[l].callback === n && o.splice(l, 1);
      }
      return r;
    },
    fire: function(i) {
      var n = e[i];
      if (!n)
        return r;
      var s;
      arguments.length > 1 && (s = Array.prototype.splice.call(arguments, 1));
      for (var a = 0; a < n.length; ++a) {
        var o = n[a];
        o.callback.apply(o.ctx, s);
      }
      return r;
    }
  };
}
function xG(r) {
  if (!r)
    throw new Error("Eventify cannot use falsy object as events subject");
  for (var e = ["on", "fire", "off"], i = 0; i < e.length; ++i)
    if (r.hasOwnProperty(e[i]))
      throw new Error("Subject cannot be eventified, since it already has property '" + e[i] + "'");
}
var _G = SG, TG = Z_;
function SG(r) {
  if (r = r || {}, "uniqueLinkId" in r && (console.warn(
    "ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\nUse `multigraph` option instead\n",
    `
`,
    `Note: there is also change in default behavior: From now on each graph
is considered to be not a multigraph by default (each edge is unique).`
  ), r.multigraph = r.uniqueLinkId), r.multigraph === void 0 && (r.multigraph = !1), typeof Map != "function")
    throw new Error("ngraph.graph requires `Map` to be defined. Please polyfill it before using ngraph");
  var e = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = {}, s = 0, a = r.multigraph ? b : x, o = [], l = O, u = O, c = O, h = O, d = {
    /**
     * Sometimes duck typing could be slow. Giving clients a hint about data structure
     * via explicit version number here:
     */
    version: 20,
    /**
     * Adds node to the graph. If node with given id already exists in the graph
     * its data is extended with whatever comes in 'data' argument.
     *
     * @param nodeId the node's identifier. A string or number is preferred.
     * @param [data] additional data for the node being added. If node already
     *   exists its data object is augmented with the new one.
     *
     * @return {node} The newly added node or node with given id if it already exists.
     */
    addNode: y,
    /**
     * Adds a link to the graph. The function always create a new
     * link between two nodes. If one of the nodes does not exists
     * a new node is created.
     *
     * @param fromId link start node id;
     * @param toId link end node id;
     * @param [data] additional data to be set on the new link;
     *
     * @return {link} The newly created link
     */
    addLink: _,
    /**
     * Removes link from the graph. If link does not exist does nothing.
     *
     * @param link - object returned by addLink() or getLinks() methods.
     *
     * @returns true if link was removed; false otherwise.
     */
    removeLink: M,
    /**
     * Removes node with given id from the graph. If node does not exist in the graph
     * does nothing.
     *
     * @param nodeId node's identifier passed to addNode() function.
     *
     * @returns true if node was removed; false otherwise.
     */
    removeNode: g,
    /**
     * Gets node with given identifier. If node does not exist undefined value is returned.
     *
     * @param nodeId requested node identifier;
     *
     * @return {node} in with requested identifier or undefined if no such node exists.
     */
    getNode: v,
    /**
     * Gets number of nodes in this graph.
     *
     * @return number of nodes in the graph.
     */
    getNodeCount: T,
    /**
     * Gets total number of links in the graph.
     */
    getLinkCount: S,
    /**
     * Gets total number of links in the graph.
     */
    getEdgeCount: S,
    /**
     * Synonym for `getLinkCount()`
     */
    getLinksCount: S,
    /**
     * Synonym for `getNodeCount()`
     */
    getNodesCount: T,
    /**
     * Gets all links (inbound and outbound) from the node with given id.
     * If node with given id is not found null is returned.
     *
     * @param nodeId requested node identifier.
     *
     * @return Set of links from and to requested node if such node exists;
     *   otherwise null is returned.
     */
    getLinks: w,
    /**
     * Invokes callback on each node of the graph.
     *
     * @param {Function(node)} callback Function to be invoked. The function
     *   is passed one argument: visited node.
     */
    forEachNode: Q,
    /**
     * Invokes callback on every linked (adjacent) node to the given one.
     *
     * @param nodeId Identifier of the requested node.
     * @param {Function(node, link)} callback Function to be called on all linked nodes.
     *   The function is passed two parameters: adjacent node and link object itself.
     * @param oriented if true graph treated as oriented.
     */
    forEachLinkedNode: k,
    /**
     * Enumerates all links in the graph
     *
     * @param {Function(link)} callback Function to be called on all links in the graph.
     *   The function is passed one parameter: graph's link object.
     *
     * Link object contains at least the following fields:
     *  fromId - node id where link starts;
     *  toId - node id where link ends,
     *  data - additional data passed to graph.addLink() method.
     */
    forEachLink: U,
    /**
     * Suspend all notifications about graph changes until
     * endUpdate is called.
     */
    beginUpdate: c,
    /**
     * Resumes all notifications about graph changes and fires
     * graph 'changed' event in case there are any pending changes.
     */
    endUpdate: h,
    /**
     * Removes all nodes and links from the graph.
     */
    clear: N,
    /**
     * Detects whether there is a link between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     * NOTE: this function is synonym for getLink()
     *
     * @returns link if there is one. null otherwise.
     */
    hasLink: A,
    /**
     * Detects whether there is a node with given id
     * 
     * Operation complexity is O(1)
     * NOTE: this function is synonym for getNode()
     *
     * @returns node if there is one; Falsy value otherwise.
     */
    hasNode: v,
    /**
     * Gets an edge between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     *
     * @param {string} fromId link start identifier
     * @param {string} toId link end identifier
     *
     * @returns link if there is one; undefined otherwise.
     */
    getLink: A
  };
  return TG(d), p(), d;
  function p() {
    var F = d.on;
    d.on = B;
    function B() {
      return d.beginUpdate = c = W, d.endUpdate = h = V, l = f, u = m, d.on = F, F.apply(d, arguments);
    }
  }
  function f(F, B) {
    o.push({
      link: F,
      changeType: B
    });
  }
  function m(F, B) {
    o.push({
      node: F,
      changeType: B
    });
  }
  function y(F, B) {
    if (F === void 0)
      throw new Error("Invalid node identifier");
    c();
    var q = v(F);
    return q ? (q.data = B, u(q, "update")) : (q = new wG(F, B), u(q, "add")), e.set(F, q), h(), q;
  }
  function v(F) {
    return e.get(F);
  }
  function g(F) {
    var B = v(F);
    if (!B)
      return !1;
    c();
    var q = B.links;
    return q && (q.forEach(E), B.links = null), e.delete(F), u(B, "remove"), h(), !0;
  }
  function _(F, B, q) {
    c();
    var G = v(F) || y(F), z = v(B) || y(B), Y = a(F, B, q), se = i.has(Y.id);
    return i.set(Y.id, Y), Xw(G, Y), F !== B && Xw(z, Y), l(Y, se ? "update" : "add"), h(), Y;
  }
  function x(F, B, q) {
    var G = Bp(F, B), z = i.get(G);
    return z ? (z.data = q, z) : new $w(F, B, q, G);
  }
  function b(F, B, q) {
    var G = Bp(F, B), z = n.hasOwnProperty(G);
    if (z || A(F, B)) {
      z || (n[G] = 0);
      var Y = "@" + ++n[G];
      G = Bp(F + Y, B + Y);
    }
    return new $w(F, B, q, G);
  }
  function T() {
    return e.size;
  }
  function S() {
    return i.size;
  }
  function w(F) {
    var B = v(F);
    return B ? B.links : null;
  }
  function M(F, B) {
    return B !== void 0 && (F = A(F, B)), E(F);
  }
  function E(F) {
    if (!F || !i.get(F.id)) return !1;
    c(), i.delete(F.id);
    var B = v(F.fromId), q = v(F.toId);
    return B && B.links.delete(F), q && q.links.delete(F), l(F, "remove"), h(), !0;
  }
  function A(F, B) {
    if (!(F === void 0 || B === void 0))
      return i.get(Bp(F, B));
  }
  function N() {
    c(), Q(function(F) {
      g(F.id);
    }), h();
  }
  function U(F) {
    if (typeof F == "function")
      for (var B = i.values(), q = B.next(); !q.done; ) {
        if (F(q.value))
          return !0;
        q = B.next();
      }
  }
  function k(F, B, q) {
    var G = v(F);
    if (G && G.links && typeof B == "function")
      return q ? I(G.links, F, B) : C(G.links, F, B);
  }
  function C(F, B, q) {
    for (var G, z = F.values(), Y = z.next(); !Y.done; ) {
      var se = Y.value, ne = se.fromId === B ? se.toId : se.fromId;
      if (G = q(e.get(ne), se), G)
        return !0;
      Y = z.next();
    }
  }
  function I(F, B, q) {
    for (var G, z = F.values(), Y = z.next(); !Y.done; ) {
      var se = Y.value;
      if (se.fromId === B && (G = q(e.get(se.toId), se), G))
        return !0;
      Y = z.next();
    }
  }
  function O() {
  }
  function W() {
    s += 1;
  }
  function V() {
    s -= 1, s === 0 && o.length > 0 && (d.fire("changed", o), o.length = 0);
  }
  function Q(F) {
    if (typeof F != "function")
      throw new Error("Function is expected to iterate over graph nodes. You passed " + F);
    for (var B = e.values(), q = B.next(); !q.done; ) {
      if (F(q.value))
        return !0;
      q = B.next();
    }
  }
}
function wG(r, e) {
  this.id = r, this.links = null, this.data = e;
}
function Xw(r, e) {
  r.links ? r.links.add(e) : r.links = /* @__PURE__ */ new Set([e]);
}
function $w(r, e, i, n) {
  this.fromId = r, this.toId = e, this.data = i, this.id = n;
}
function Bp(r, e) {
  return r.toString() + "👉 " + e.toString();
}
const EG = /* @__PURE__ */ v_(_G);
var Q_ = { exports: {} }, qd = { exports: {} }, XR = function(r) {
  return r === 0 ? "x" : r === 1 ? "y" : r === 2 ? "z" : "c" + (r + 1);
};
const MG = XR;
var Fc = function(r) {
  return e;
  function e(i, n) {
    let s = n && n.indent || 0, a = n && n.join !== void 0 ? n.join : `
`, o = Array(s + 1).join(" "), l = [];
    for (let u = 0; u < r; ++u) {
      let c = MG(u), h = u === 0 ? "" : o;
      l.push(h + i.replace(/{var}/g, c));
    }
    return l.join(a);
  }
};
const $R = Fc;
qd.exports = AG;
qd.exports.generateCreateBodyFunctionBody = YR;
qd.exports.getVectorCode = ZR;
qd.exports.getBodyCode = KR;
function AG(r, e) {
  let i = YR(r, e), { Body: n } = new Function(i)();
  return n;
}
function YR(r, e) {
  return `
${ZR(r, e)}
${KR(r)}
return {Body: Body, Vector: Vector};
`;
}
function KR(r) {
  let e = $R(r), i = e("{var}", { join: ", " });
  return `
function Body(${i}) {
  this.isPinned = false;
  this.pos = new Vector(${i});
  this.force = new Vector();
  this.velocity = new Vector();
  this.mass = 1;

  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.reset = function() {
  this.force.reset();
  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.setPosition = function (${i}) {
  ${e("this.pos.{var} = {var} || 0;", { indent: 2 })}
};`;
}
function ZR(r, e) {
  let i = $R(r), n = "";
  return e && (n = `${i(`
   var v{var};
Object.defineProperty(this, '{var}', {
  set: function(v) { 
    if (!Number.isFinite(v)) throw new Error('Cannot set non-numbers to {var}');
    v{var} = v; 
  },
  get: function() { return v{var}; }
});`)}`), `function Vector(${i("{var}", { join: ", " })}) {
  ${n}
    if (typeof arguments[0] === 'object') {
      // could be another vector
      let v = arguments[0];
      ${i('if (!Number.isFinite(v.{var})) throw new Error("Expected value is not a finite number at Vector constructor ({var})");', { indent: 4 })}
      ${i("this.{var} = v.{var};", { indent: 4 })}
    } else {
      ${i('this.{var} = typeof {var} === "number" ? {var} : 0;', { indent: 4 })}
    }
  }
  
  Vector.prototype.reset = function () {
    ${i("this.{var} = ", { join: "" })}0;
  };`;
}
var CG = qd.exports, _o = { exports: {} };
const J_ = Fc, ka = XR;
_o.exports = RG;
_o.exports.generateQuadTreeFunctionBody = QR;
_o.exports.getInsertStackCode = rN;
_o.exports.getQuadNodeCode = iN;
_o.exports.isSamePosition = JR;
_o.exports.getChildBodyCode = tN;
_o.exports.setChildBodyCode = eN;
function RG(r) {
  let e = QR(r);
  return new Function(e)();
}
function QR(r) {
  let e = J_(r), i = Math.pow(2, r);
  return `
${rN()}
${iN(r)}
${JR(r)}
${tN(r)}
${eN(r)}

function createQuadTree(options, random) {
  options = options || {};
  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;
  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;

  var gravity = options.gravity;
  var updateQueue = [];
  var insertStack = new InsertStack();
  var theta = options.theta;

  var nodesCache = [];
  var currentInCache = 0;
  var root = newNode();

  return {
    insertBodies: insertBodies,

    /**
     * Gets root node if it is present
     */
    getRoot: function() {
      return root;
    },

    updateBodyForce: update,

    options: function(newOptions) {
      if (newOptions) {
        if (typeof newOptions.gravity === 'number') {
          gravity = newOptions.gravity;
        }
        if (typeof newOptions.theta === 'number') {
          theta = newOptions.theta;
        }

        return this;
      }

      return {
        gravity: gravity,
        theta: theta
      };
    }
  };

  function newNode() {
    // To avoid pressure on GC we reuse nodes.
    var node = nodesCache[currentInCache];
    if (node) {
${a("      node.")}
      node.body = null;
      node.mass = ${e("node.mass_{var} = ", { join: "" })}0;
      ${e("node.min_{var} = node.max_{var} = ", { join: "" })}0;
    } else {
      node = new QuadNode();
      nodesCache[currentInCache] = node;
    }

    ++currentInCache;
    return node;
  }

  function update(sourceBody) {
    var queue = updateQueue;
    var v;
    ${e("var d{var};", { indent: 4 })}
    var r; 
    ${e("var f{var} = 0;", { indent: 4 })}
    var queueLength = 1;
    var shiftIdx = 0;
    var pushIdx = 1;

    queue[0] = root;

    while (queueLength) {
      var node = queue[shiftIdx];
      var body = node.body;

      queueLength -= 1;
      shiftIdx += 1;
      var differentBody = (body !== sourceBody);
      if (body && differentBody) {
        // If the current node is a leaf node (and it is not source body),
        // calculate the force exerted by the current node on body, and add this
        // amount to body's net force.
        ${e("d{var} = body.pos.{var} - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Poor man's protection against zero distance.
          ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
        }

        // This is standard gravitation force calculation but we divide
        // by r^3 to save two operations when normalizing force vector.
        v = gravity * body.mass * sourceBody.mass / (r * r * r);
        ${e("f{var} += v * d{var};", { indent: 8 })}
      } else if (differentBody) {
        // Otherwise, calculate the ratio s / r,  where s is the width of the region
        // represented by the internal node, and r is the distance between the body
        // and the node's center-of-mass
        ${e("d{var} = node.mass_{var} / node.mass - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Sorry about code duplication. I don't want to create many functions
          // right away. Just want to see performance first.
          ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
        }
        // If s / r < θ, treat this internal node as a single body, and calculate the
        // force it exerts on sourceBody, and add this amount to sourceBody's net force.
        if ((node.max_${ka(0)} - node.min_${ka(0)}) / r < theta) {
          // in the if statement above we consider node's width only
          // because the region was made into square during tree creation.
          // Thus there is no difference between using width or height.
          v = gravity * node.mass * sourceBody.mass / (r * r * r);
          ${e("f{var} += v * d{var};", { indent: 10 })}
        } else {
          // Otherwise, run the procedure recursively on each of the current node's children.

          // I intentionally unfolded this loop, to save several CPU cycles.
${s()}
        }
      }
    }

    ${e("sourceBody.force.{var} += f{var};", { indent: 4 })}
  }

  function insertBodies(bodies) {
    ${e("var {var}min = Number.MAX_VALUE;", { indent: 4 })}
    ${e("var {var}max = Number.MIN_VALUE;", { indent: 4 })}
    var i = bodies.length;

    // To reduce quad tree depth we are looking for exact bounding box of all particles.
    while (i--) {
      var pos = bodies[i].pos;
      ${e("if (pos.{var} < {var}min) {var}min = pos.{var};", { indent: 6 })}
      ${e("if (pos.{var} > {var}max) {var}max = pos.{var};", { indent: 6 })}
    }

    // Makes the bounds square.
    var maxSideLength = -Infinity;
    ${e("if ({var}max - {var}min > maxSideLength) maxSideLength = {var}max - {var}min ;", { indent: 4 })}

    currentInCache = 0;
    root = newNode();
    ${e("root.min_{var} = {var}min;", { indent: 4 })}
    ${e("root.max_{var} = {var}min + maxSideLength;", { indent: 4 })}

    i = bodies.length - 1;
    if (i >= 0) {
      root.body = bodies[i];
    }
    while (i--) {
      insert(bodies[i], root);
    }
  }

  function insert(newBody) {
    insertStack.reset();
    insertStack.push(root, newBody);

    while (!insertStack.isEmpty()) {
      var stackItem = insertStack.pop();
      var node = stackItem.node;
      var body = stackItem.body;

      if (!node.body) {
        // This is internal node. Update the total mass of the node and center-of-mass.
        ${e("var {var} = body.pos.{var};", { indent: 8 })}
        node.mass += body.mass;
        ${e("node.mass_{var} += body.mass * {var};", { indent: 8 })}

        // Recursively insert the body in the appropriate quadrant.
        // But first find the appropriate quadrant.
        var quadIdx = 0; // Assume we are in the 0's quad.
        ${e("var min_{var} = node.min_{var};", { indent: 8 })}
        ${e("var max_{var} = (min_{var} + node.max_{var}) / 2;", { indent: 8 })}

${n(8)}

        var child = getChild(node, quadIdx);

        if (!child) {
          // The node is internal but this quadrant is not taken. Add
          // subnode to it.
          child = newNode();
          ${e("child.min_{var} = min_{var};", { indent: 10 })}
          ${e("child.max_{var} = max_{var};", { indent: 10 })}
          child.body = body;

          setChild(node, quadIdx, child);
        } else {
          // continue searching in this quadrant.
          insertStack.push(child, body);
        }
      } else {
        // We are trying to add to the leaf node.
        // We have to convert current leaf into internal node
        // and continue adding two nodes.
        var oldBody = node.body;
        node.body = null; // internal nodes do not cary bodies

        if (isSamePosition(oldBody.pos, body.pos)) {
          // Prevent infinite subdivision by bumping one node
          // anywhere in this quadrant
          var retriesCount = 3;
          do {
            var offset = random.nextDouble();
            ${e("var d{var} = (node.max_{var} - node.min_{var}) * offset;", { indent: 12 })}

            ${e("oldBody.pos.{var} = node.min_{var} + d{var};", { indent: 12 })}
            retriesCount -= 1;
            // Make sure we don't bump it out of the box. If we do, next iteration should fix it
          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));

          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {
            // This is very bad, we ran out of precision.
            // if we do not return from the method we'll get into
            // infinite loop here. So we sacrifice correctness of layout, and keep the app running
            // Next layout iteration should get larger bounding box in the first step and fix this
            return;
          }
        }
        // Next iteration should subdivide node further.
        insertStack.push(node, oldBody);
        insertStack.push(node, body);
      }
    }
  }
}
return createQuadTree;

`;
  function n(o) {
    let l = [], u = Array(o + 1).join(" ");
    for (let c = 0; c < r; ++c)
      l.push(u + `if (${ka(c)} > max_${ka(c)}) {`), l.push(u + `  quadIdx = quadIdx + ${Math.pow(2, c)};`), l.push(u + `  min_${ka(c)} = max_${ka(c)};`), l.push(u + `  max_${ka(c)} = node.max_${ka(c)};`), l.push(u + "}");
    return l.join(`
`);
  }
  function s() {
    let o = Array(11).join(" "), l = [];
    for (let u = 0; u < i; ++u)
      l.push(o + `if (node.quad${u}) {`), l.push(o + `  queue[pushIdx] = node.quad${u};`), l.push(o + "  queueLength += 1;"), l.push(o + "  pushIdx += 1;"), l.push(o + "}");
    return l.join(`
`);
  }
  function a(o) {
    let l = [];
    for (let u = 0; u < i; ++u)
      l.push(`${o}quad${u} = null;`);
    return l.join(`
`);
  }
}
function JR(r) {
  let e = J_(r);
  return `
  function isSamePosition(point1, point2) {
    ${e("var d{var} = Math.abs(point1.{var} - point2.{var});", { indent: 2 })}
  
    return ${e("d{var} < 1e-8", { join: " && " })};
  }  
`;
}
function eN(r) {
  var e = Math.pow(2, r);
  return `
function setChild(node, idx, child) {
  ${i()}
}`;
  function i() {
    let n = [];
    for (let s = 0; s < e; ++s) {
      let a = s === 0 ? "  " : "  else ";
      n.push(`${a}if (idx === ${s}) node.quad${s} = child;`);
    }
    return n.join(`
`);
  }
}
function tN(r) {
  return `function getChild(node, idx) {
${e()}
  return null;
}`;
  function e() {
    let i = [], n = Math.pow(2, r);
    for (let s = 0; s < n; ++s)
      i.push(`  if (idx === ${s}) return node.quad${s};`);
    return i.join(`
`);
  }
}
function iN(r) {
  let e = J_(r), i = Math.pow(2, r);
  var n = `
function QuadNode() {
  // body stored inside this node. In quad tree only leaf nodes (by construction)
  // contain bodies:
  this.body = null;

  // Child nodes are stored in quads. Each quad is presented by number:
  // 0 | 1
  // -----
  // 2 | 3
${s("  this.")}

  // Total mass of current node
  this.mass = 0;

  // Center of mass coordinates
  ${e("this.mass_{var} = 0;", { indent: 2 })}

  // bounding box coordinates
  ${e("this.min_{var} = 0;", { indent: 2 })}
  ${e("this.max_{var} = 0;", { indent: 2 })}
}
`;
  return n;
  function s(a) {
    let o = [];
    for (let l = 0; l < i; ++l)
      o.push(`${a}quad${l} = null;`);
    return o.join(`
`);
  }
}
function rN() {
  return `
/**
 * Our implementation of QuadTree is non-recursive to avoid GC hit
 * This data structure represent stack of elements
 * which we are trying to insert into quad tree.
 */
function InsertStack () {
    this.stack = [];
    this.popIdx = 0;
}

InsertStack.prototype = {
    isEmpty: function() {
        return this.popIdx === 0;
    },
    push: function (node, body) {
        var item = this.stack[this.popIdx];
        if (!item) {
            // we are trying to avoid memory pressure: create new element
            // only when absolutely necessary
            this.stack[this.popIdx] = new InsertStackElement(node, body);
        } else {
            item.node = node;
            item.body = body;
        }
        ++this.popIdx;
    },
    pop: function () {
        if (this.popIdx > 0) {
            return this.stack[--this.popIdx];
        }
    },
    reset: function () {
        this.popIdx = 0;
    }
};

function InsertStackElement(node, body) {
    this.node = node; // QuadTree node
    this.body = body; // physical body which needs to be inserted to node
}
`;
}
var NG = _o.exports, e1 = { exports: {} };
e1.exports = IG;
e1.exports.generateFunctionBody = nN;
const PG = Fc;
function IG(r) {
  let e = nN(r);
  return new Function("bodies", "settings", "random", e);
}
function nN(r) {
  let e = PG(r);
  return `
  var boundingBox = {
    ${e("min_{var}: 0, max_{var}: 0,", { indent: 4 })}
  };

  return {
    box: boundingBox,

    update: updateBoundingBox,

    reset: resetBoundingBox,

    getBestNewPosition: function (neighbors) {
      var ${e("base_{var} = 0", { join: ", " })};

      if (neighbors.length) {
        for (var i = 0; i < neighbors.length; ++i) {
          let neighborPos = neighbors[i].pos;
          ${e("base_{var} += neighborPos.{var};", { indent: 10 })}
        }

        ${e("base_{var} /= neighbors.length;", { indent: 8 })}
      } else {
        ${e("base_{var} = (boundingBox.min_{var} + boundingBox.max_{var}) / 2;", { indent: 8 })}
      }

      var springLength = settings.springLength;
      return {
        ${e("{var}: base_{var} + (random.nextDouble() - 0.5) * springLength,", { indent: 8 })}
      };
    }
  };

  function updateBoundingBox() {
    var i = bodies.length;
    if (i === 0) return; // No bodies - no borders.

    ${e("var max_{var} = -Infinity;", { indent: 4 })}
    ${e("var min_{var} = Infinity;", { indent: 4 })}

    while(i--) {
      // this is O(n), it could be done faster with quadtree, if we check the root node bounds
      var bodyPos = bodies[i].pos;
      ${e("if (bodyPos.{var} < min_{var}) min_{var} = bodyPos.{var};", { indent: 6 })}
      ${e("if (bodyPos.{var} > max_{var}) max_{var} = bodyPos.{var};", { indent: 6 })}
    }

    ${e("boundingBox.min_{var} = min_{var};", { indent: 4 })}
    ${e("boundingBox.max_{var} = max_{var};", { indent: 4 })}
  }

  function resetBoundingBox() {
    ${e("boundingBox.min_{var} = boundingBox.max_{var} = 0;", { indent: 4 })}
  }
`;
}
var OG = e1.exports, t1 = { exports: {} };
const DG = Fc;
t1.exports = LG;
t1.exports.generateCreateDragForceFunctionBody = sN;
function LG(r) {
  let e = sN(r);
  return new Function("options", e);
}
function sN(r) {
  return `
  if (!Number.isFinite(options.dragCoefficient)) throw new Error('dragCoefficient is not a finite number');

  return {
    update: function(body) {
      ${DG(r)("body.force.{var} -= options.dragCoefficient * body.velocity.{var};", { indent: 6 })}
    }
  };
`;
}
var kG = t1.exports, i1 = { exports: {} };
const UG = Fc;
i1.exports = FG;
i1.exports.generateCreateSpringForceFunctionBody = aN;
function FG(r) {
  let e = aN(r);
  return new Function("options", "random", e);
}
function aN(r) {
  let e = UG(r);
  return `
  if (!Number.isFinite(options.springCoefficient)) throw new Error('Spring coefficient is not a number');
  if (!Number.isFinite(options.springLength)) throw new Error('Spring length is not a number');

  return {
    /**
     * Updates forces acting on a spring
     */
    update: function (spring) {
      var body1 = spring.from;
      var body2 = spring.to;
      var length = spring.length < 0 ? options.springLength : spring.length;
      ${e("var d{var} = body2.pos.{var} - body1.pos.{var};", { indent: 6 })}
      var r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

      if (r === 0) {
        ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
      }

      var d = r - length;
      var coefficient = ((spring.coefficient > 0) ? spring.coefficient : options.springCoefficient) * d / r;

      ${e("body1.force.{var} += coefficient * d{var}", { indent: 6 })};
      body1.springCount += 1;
      body1.springLength += r;

      ${e("body2.force.{var} -= coefficient * d{var}", { indent: 6 })};
      body2.springCount += 1;
      body2.springLength += r;
    }
  };
`;
}
var BG = i1.exports, r1 = { exports: {} };
const zG = Fc;
r1.exports = jG;
r1.exports.generateIntegratorFunctionBody = oN;
function jG(r) {
  let e = oN(r);
  return new Function("bodies", "timeStep", "adaptiveTimeStepWeight", e);
}
function oN(r) {
  let e = zG(r);
  return `
  var length = bodies.length;
  if (length === 0) return 0;

  ${e("var d{var} = 0, t{var} = 0;", { indent: 2 })}

  for (var i = 0; i < length; ++i) {
    var body = bodies[i];
    if (body.isPinned) continue;

    if (adaptiveTimeStepWeight && body.springCount) {
      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);
    }

    var coeff = timeStep / body.mass;

    ${e("body.velocity.{var} += coeff * body.force.{var};", { indent: 4 })}
    ${e("var v{var} = body.velocity.{var};", { indent: 4 })}
    var v = Math.sqrt(${e("v{var} * v{var}", { join: " + " })});

    if (v > 1) {
      // We normalize it so that we move within timeStep range. 
      // for the case when v <= 1 - we let velocity to fade out.
      ${e("body.velocity.{var} = v{var} / v;", { indent: 6 })}
    }

    ${e("d{var} = timeStep * body.velocity.{var};", { indent: 4 })}

    ${e("body.pos.{var} += d{var};", { indent: 4 })}

    ${e("t{var} += Math.abs(d{var});", { indent: 4 })}
  }

  return (${e("t{var} * t{var}", { join: " + " })})/length;
`;
}
var VG = r1.exports, r0, Yw;
function GG() {
  if (Yw) return r0;
  Yw = 1, r0 = r;
  function r(e, i, n, s) {
    this.from = e, this.to = i, this.length = n, this.coefficient = s;
  }
  return r0;
}
var n0, Kw;
function HG() {
  if (Kw) return n0;
  Kw = 1, n0 = r;
  function r(e, i) {
    var n;
    if (e || (e = {}), i) {
      for (n in i)
        if (i.hasOwnProperty(n)) {
          var s = e.hasOwnProperty(n), a = typeof i[n], o = !s || typeof e[n] !== a;
          o ? e[n] = i[n] : a === "object" && (e[n] = r(e[n], i[n]));
        }
    }
    return e;
  }
  return n0;
}
var hh = { exports: {} }, Zw;
function WG() {
  if (Zw) return hh.exports;
  Zw = 1, hh.exports = r, hh.exports.random = r, hh.exports.randomIterator = l;
  function r(u) {
    var c = typeof u == "number" ? u : +/* @__PURE__ */ new Date();
    return new e(c);
  }
  function e(u) {
    this.seed = u;
  }
  e.prototype.next = o, e.prototype.nextDouble = a, e.prototype.uniform = a, e.prototype.gaussian = i;
  function i() {
    var u, c, h;
    do
      c = this.nextDouble() * 2 - 1, h = this.nextDouble() * 2 - 1, u = c * c + h * h;
    while (u >= 1 || u === 0);
    return c * Math.sqrt(-2 * Math.log(u) / u);
  }
  e.prototype.levy = n;
  function n() {
    var u = 1.5, c = Math.pow(
      s(1 + u) * Math.sin(Math.PI * u / 2) / (s((1 + u) / 2) * u * Math.pow(2, (u - 1) / 2)),
      1 / u
    );
    return this.gaussian() * c / Math.pow(Math.abs(this.gaussian()), 1 / u);
  }
  function s(u) {
    return Math.sqrt(2 * Math.PI / u) * Math.pow(1 / Math.E * (u + 1 / (12 * u - 1 / (10 * u))), u);
  }
  function a() {
    var u = this.seed;
    return u = u + 2127912214 + (u << 12) & 4294967295, u = (u ^ 3345072700 ^ u >>> 19) & 4294967295, u = u + 374761393 + (u << 5) & 4294967295, u = (u + 3550635116 ^ u << 9) & 4294967295, u = u + 4251993797 + (u << 3) & 4294967295, u = (u ^ 3042594569 ^ u >>> 16) & 4294967295, this.seed = u, (u & 268435455) / 268435456;
  }
  function o(u) {
    return Math.floor(this.nextDouble() * u);
  }
  function l(u, c) {
    var h = c || r();
    if (typeof h.next != "function")
      throw new Error("customRandom does not match expected API: next() function is missing");
    return {
      forEach: p,
      /**
       * Shuffles array randomly, in place.
       */
      shuffle: d
    };
    function d() {
      var f, m, y;
      for (f = u.length - 1; f > 0; --f)
        m = h.next(f + 1), y = u[m], u[m] = u[f], u[f] = y;
      return u;
    }
    function p(f) {
      var m, y, v;
      for (m = u.length - 1; m > 0; --m)
        y = h.next(m + 1), v = u[y], u[y] = u[m], u[m] = v, f(v);
      u.length && f(u[0]);
    }
  }
  return hh.exports;
}
var lN = QG, qG = CG, XG = NG, $G = OG, YG = kG, KG = BG, ZG = VG, Qw = {};
function QG(r) {
  var e = GG(), i = HG(), n = Z_;
  if (r) {
    if (r.springCoeff !== void 0) throw new Error("springCoeff was renamed to springCoefficient");
    if (r.dragCoeff !== void 0) throw new Error("dragCoeff was renamed to dragCoefficient");
  }
  r = i(r, {
    /**
     * Ideal length for links (springs in physical model).
     */
    springLength: 10,
    /**
     * Hook's law coefficient. 1 - solid spring.
     */
    springCoefficient: 0.8,
    /**
     * Coulomb's law coefficient. It's used to repel nodes thus should be negative
     * if you make it positive nodes start attract each other :).
     */
    gravity: -12,
    /**
     * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).
     * The closer it's to 1 the more nodes algorithm will have to go through.
     * Setting it to one makes Barnes Hut simulation no different from
     * brute-force forces calculation (each node is considered).
     */
    theta: 0.8,
    /**
     * Drag force coefficient. Used to slow down system, thus should be less than 1.
     * The closer it is to 0 the less tight system will be.
     */
    dragCoefficient: 0.9,
    // TODO: Need to rename this to something better. E.g. `dragCoefficient`
    /**
     * Default time step (dt) for forces integration
     */
    timeStep: 0.5,
    /**
     * Adaptive time step uses average spring length to compute actual time step:
     * See: https://twitter.com/anvaka/status/1293067160755957760
     */
    adaptiveTimeStepWeight: 0,
    /**
     * This parameter defines number of dimensions of the space where simulation
     * is performed. 
     */
    dimensions: 2,
    /**
     * In debug mode more checks are performed, this will help you catch errors
     * quickly, however for production build it is recommended to turn off this flag
     * to speed up computation.
     */
    debug: !1
  });
  var s = Qw[r.dimensions];
  if (!s) {
    var a = r.dimensions;
    s = {
      Body: qG(a, r.debug),
      createQuadTree: XG(a),
      createBounds: $G(a),
      createDragForce: YG(a),
      createSpringForce: KG(a),
      integrate: ZG(a)
    }, Qw[a] = s;
  }
  var o = s.Body, l = s.createQuadTree, u = s.createBounds, c = s.createDragForce, h = s.createSpringForce, d = s.integrate, p = (I) => new o(I), f = WG().random(42), m = [], y = [], v = l(r, f), g = u(m, r, f), _ = h(r, f), x = c(r), b = 0, T = [], S = /* @__PURE__ */ new Map(), w = 0;
  A("nbody", k), A("spring", C);
  var M = {
    /**
     * Array of bodies, registered with current simulator
     *
     * Note: To add new body, use addBody() method. This property is only
     * exposed for testing/performance purposes.
     */
    bodies: m,
    quadTree: v,
    /**
     * Array of springs, registered with current simulator
     *
     * Note: To add new spring, use addSpring() method. This property is only
     * exposed for testing/performance purposes.
     */
    springs: y,
    /**
     * Returns settings with which current simulator was initialized
     */
    settings: r,
    /**
     * Adds a new force to simulation
     */
    addForce: A,
    /**
     * Removes a force from the simulation.
     */
    removeForce: N,
    /**
     * Returns a map of all registered forces.
     */
    getForces: U,
    /**
     * Performs one step of force simulation.
     *
     * @returns {boolean} true if system is considered stable; False otherwise.
     */
    step: function() {
      for (var I = 0; I < T.length; ++I)
        T[I](w);
      var O = d(m, r.timeStep, r.adaptiveTimeStepWeight);
      return w += 1, O;
    },
    /**
     * Adds body to the system
     *
     * @param {ngraph.physics.primitives.Body} body physical body
     *
     * @returns {ngraph.physics.primitives.Body} added body
     */
    addBody: function(I) {
      if (!I)
        throw new Error("Body is required");
      return m.push(I), I;
    },
    /**
     * Adds body to the system at given position
     *
     * @param {Object} pos position of a body
     *
     * @returns {ngraph.physics.primitives.Body} added body
     */
    addBodyAt: function(I) {
      if (!I)
        throw new Error("Body position is required");
      var O = p(I);
      return m.push(O), O;
    },
    /**
     * Removes body from the system
     *
     * @param {ngraph.physics.primitives.Body} body to remove
     *
     * @returns {Boolean} true if body found and removed. falsy otherwise;
     */
    removeBody: function(I) {
      if (I) {
        var O = m.indexOf(I);
        if (!(O < 0))
          return m.splice(O, 1), m.length === 0 && g.reset(), !0;
      }
    },
    /**
     * Adds a spring to this simulation.
     *
     * @returns {Object} - a handle for a spring. If you want to later remove
     * spring pass it to removeSpring() method.
     */
    addSpring: function(I, O, W, V) {
      if (!I || !O)
        throw new Error("Cannot add null spring to force simulator");
      typeof W != "number" && (W = -1);
      var Q = new e(I, O, W, V >= 0 ? V : -1);
      return y.push(Q), Q;
    },
    /**
     * Returns amount of movement performed on last step() call
     */
    getTotalMovement: function() {
      return b;
    },
    /**
     * Removes spring from the system
     *
     * @param {Object} spring to remove. Spring is an object returned by addSpring
     *
     * @returns {Boolean} true if spring found and removed. falsy otherwise;
     */
    removeSpring: function(I) {
      if (I) {
        var O = y.indexOf(I);
        if (O > -1)
          return y.splice(O, 1), !0;
      }
    },
    getBestNewBodyPosition: function(I) {
      return g.getBestNewPosition(I);
    },
    /**
     * Returns bounding box which covers all bodies
     */
    getBBox: E,
    getBoundingBox: E,
    invalidateBBox: function() {
      console.warn("invalidateBBox() is deprecated, bounds always recomputed on `getBBox()` call");
    },
    // TODO: Move the force specific stuff to force
    gravity: function(I) {
      return I !== void 0 ? (r.gravity = I, v.options({ gravity: I }), this) : r.gravity;
    },
    theta: function(I) {
      return I !== void 0 ? (r.theta = I, v.options({ theta: I }), this) : r.theta;
    },
    /**
     * Returns pseudo-random number generator instance.
     */
    random: f
  };
  return JG(r, M), n(M), M;
  function E() {
    return g.update(), g.box;
  }
  function A(I, O) {
    if (S.has(I)) throw new Error("Force " + I + " is already added");
    S.set(I, O), T.push(O);
  }
  function N(I) {
    var O = T.indexOf(S.get(I));
    O < 0 || (T.splice(O, 1), S.delete(I));
  }
  function U() {
    return S;
  }
  function k() {
    if (m.length !== 0) {
      v.insertBodies(m);
      for (var I = m.length; I--; ) {
        var O = m[I];
        O.isPinned || (O.reset(), v.updateBodyForce(O), x.update(O));
      }
    }
  }
  function C() {
    for (var I = y.length; I--; )
      _.update(y[I]);
  }
}
function JG(r, e) {
  for (var i in r)
    e8(r, e, i);
}
function e8(r, e, i) {
  if (r.hasOwnProperty(i) && typeof e[i] != "function") {
    var n = Number.isFinite(r[i]);
    n ? e[i] = function(s) {
      if (s !== void 0) {
        if (!Number.isFinite(s)) throw new Error("Value of " + i + " should be a valid number.");
        return r[i] = s, e;
      }
      return r[i];
    } : e[i] = function(s) {
      return s !== void 0 ? (r[i] = s, e) : r[i];
    };
  }
}
Q_.exports = i8;
Q_.exports.simulator = lN;
var t8 = Z_;
function i8(r, e) {
  if (!r)
    throw new Error("Graph structure cannot be undefined");
  var i = e && e.createSimulator || lN, n = i(e);
  if (Array.isArray(e)) throw new Error("Physics settings is expected to be an object");
  var s = r.version > 19 ? k : U;
  e && typeof e.nodeMass == "function" && (s = e.nodeMass);
  var a = /* @__PURE__ */ new Map(), o = {}, l = 0, u = n.settings.springTransform || r8;
  x(), v();
  var c = !1, h = {
    /**
     * Performs one step of iterative layout algorithm
     *
     * @returns {boolean} true if the system should be considered stable; False otherwise.
     * The system is stable if no further call to `step()` can improve the layout.
     */
    step: function() {
      if (l === 0)
        return d(!0), !0;
      var C = n.step();
      h.lastMove = C, h.fire("step");
      var I = C / l, O = I <= 0.01;
      return d(O), O;
    },
    /**
     * For a given `nodeId` returns position
     */
    getNodePosition: function(C) {
      return N(C).pos;
    },
    /**
     * Sets position of a node to a given coordinates
     * @param {string} nodeId node identifier
     * @param {number} x position of a node
     * @param {number} y position of a node
     * @param {number=} z position of node (only if applicable to body)
     */
    setNodePosition: function(C) {
      var I = N(C);
      I.setPosition.apply(I, Array.prototype.slice.call(arguments, 1));
    },
    /**
     * @returns {Object} Link position by link id
     * @returns {Object.from} {x, y} coordinates of link start
     * @returns {Object.to} {x, y} coordinates of link end
     */
    getLinkPosition: function(C) {
      var I = o[C];
      if (I)
        return {
          from: I.from.pos,
          to: I.to.pos
        };
    },
    /**
     * @returns {Object} area required to fit in the graph. Object contains
     * `x1`, `y1` - top left coordinates
     * `x2`, `y2` - bottom right coordinates
     */
    getGraphRect: function() {
      return n.getBBox();
    },
    /**
     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)
     */
    forEachBody: p,
    /*
     * Requests layout algorithm to pin/unpin node to its current position
     * Pinned nodes should not be affected by layout algorithm and always
     * remain at their position
     */
    pinNode: function(C, I) {
      var O = N(C.id);
      O.isPinned = !!I;
    },
    /**
     * Checks whether given graph's node is currently pinned
     */
    isNodePinned: function(C) {
      return N(C.id).isPinned;
    },
    /**
     * Request to release all resources
     */
    dispose: function() {
      r.off("changed", _), h.fire("disposed");
    },
    /**
     * Gets physical body for a given node id. If node is not found undefined
     * value is returned.
     */
    getBody: y,
    /**
     * Gets spring for a given edge.
     *
     * @param {string} linkId link identifer. If two arguments are passed then
     * this argument is treated as formNodeId
     * @param {string=} toId when defined this parameter denotes head of the link
     * and first argument is treated as tail of the link (fromId)
     */
    getSpring: m,
    /**
     * Returns length of cumulative force vector. The closer this to zero - the more stable the system is
     */
    getForceVectorLength: f,
    /**
     * [Read only] Gets current physics simulator
     */
    simulator: n,
    /**
     * Gets the graph that was used for layout
     */
    graph: r,
    /**
     * Gets amount of movement performed during last step operation
     */
    lastMove: 0
  };
  return t8(h), h;
  function d(C) {
    c !== C && (c = C, g(C));
  }
  function p(C) {
    a.forEach(C);
  }
  function f() {
    var C = 0, I = 0;
    return p(function(O) {
      C += Math.abs(O.force.x), I += Math.abs(O.force.y);
    }), Math.sqrt(C * C + I * I);
  }
  function m(C, I) {
    var O;
    if (I === void 0)
      typeof C != "object" ? O = C : O = C.id;
    else {
      var W = r.hasLink(C, I);
      if (!W) return;
      O = W.id;
    }
    return o[O];
  }
  function y(C) {
    return a.get(C);
  }
  function v() {
    r.on("changed", _);
  }
  function g(C) {
    h.fire("stable", C);
  }
  function _(C) {
    for (var I = 0; I < C.length; ++I) {
      var O = C[I];
      O.changeType === "add" ? (O.node && b(O.node.id), O.link && S(O.link)) : O.changeType === "remove" && (O.node && T(O.node), O.link && w(O.link));
    }
    l = r.getNodesCount();
  }
  function x() {
    l = 0, r.forEachNode(function(C) {
      b(C.id), l += 1;
    }), r.forEachLink(S);
  }
  function b(C) {
    var I = a.get(C);
    if (!I) {
      var O = r.getNode(C);
      if (!O)
        throw new Error("initBody() was called with unknown node id");
      var W = O.position;
      if (!W) {
        var V = M(O);
        W = n.getBestNewBodyPosition(V);
      }
      I = n.addBodyAt(W), I.id = C, a.set(C, I), E(C), A(O) && (I.isPinned = !0);
    }
  }
  function T(C) {
    var I = C.id, O = a.get(I);
    O && (a.delete(I), n.removeBody(O));
  }
  function S(C) {
    E(C.fromId), E(C.toId);
    var I = a.get(C.fromId), O = a.get(C.toId), W = n.addSpring(I, O, C.length);
    u(C, W), o[C.id] = W;
  }
  function w(C) {
    var I = o[C.id];
    if (I) {
      var O = r.getNode(C.fromId), W = r.getNode(C.toId);
      O && E(O.id), W && E(W.id), delete o[C.id], n.removeSpring(I);
    }
  }
  function M(C) {
    var I = [];
    if (!C.links)
      return I;
    for (var O = Math.min(C.links.length, 2), W = 0; W < O; ++W) {
      var V = C.links[W], Q = V.fromId !== C.id ? a.get(V.fromId) : a.get(V.toId);
      Q && Q.pos && I.push(Q);
    }
    return I;
  }
  function E(C) {
    var I = a.get(C);
    if (I.mass = s(C), Number.isNaN(I.mass))
      throw new Error("Node mass should be a number");
  }
  function A(C) {
    return C && (C.isPinned || C.data && C.data.isPinned);
  }
  function N(C) {
    var I = a.get(C);
    return I || (b(C), I = a.get(C)), I;
  }
  function U(C) {
    var I = r.getLinks(C);
    return I ? 1 + I.length / 3 : 1;
  }
  function k(C) {
    var I = r.getLinks(C);
    return I ? 1 + I.size / 3 : 1;
  }
}
function r8() {
}
var n8 = Q_.exports;
const s8 = /* @__PURE__ */ v_(n8);
function Em(r) {
  var e = typeof r;
  return r != null && (e == "object" || e == "function");
}
var a8 = typeof global == "object" && global && global.Object === Object && global, o8 = typeof self == "object" && self && self.Object === Object && self, uN = a8 || o8 || Function("return this")(), s0 = function() {
  return uN.Date.now();
}, l8 = /\s/;
function u8(r) {
  for (var e = r.length; e-- && l8.test(r.charAt(e)); )
    ;
  return e;
}
var c8 = /^\s+/;
function h8(r) {
  return r && r.slice(0, u8(r) + 1).replace(c8, "");
}
var Mm = uN.Symbol, cN = Object.prototype, d8 = cN.hasOwnProperty, p8 = cN.toString, dh = Mm ? Mm.toStringTag : void 0;
function f8(r) {
  var e = d8.call(r, dh), i = r[dh];
  try {
    r[dh] = void 0;
    var n = !0;
  } catch {
  }
  var s = p8.call(r);
  return n && (e ? r[dh] = i : delete r[dh]), s;
}
var m8 = Object.prototype, g8 = m8.toString;
function y8(r) {
  return g8.call(r);
}
var v8 = "[object Null]", b8 = "[object Undefined]", Jw = Mm ? Mm.toStringTag : void 0;
function x8(r) {
  return r == null ? r === void 0 ? b8 : v8 : Jw && Jw in Object(r) ? f8(r) : y8(r);
}
function _8(r) {
  return r != null && typeof r == "object";
}
var T8 = "[object Symbol]";
function S8(r) {
  return typeof r == "symbol" || _8(r) && x8(r) == T8;
}
var eE = NaN, w8 = /^[-+]0x[0-9a-f]+$/i, E8 = /^0b[01]+$/i, M8 = /^0o[0-7]+$/i, A8 = parseInt;
function tE(r) {
  if (typeof r == "number")
    return r;
  if (S8(r))
    return eE;
  if (Em(r)) {
    var e = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = Em(e) ? e + "" : e;
  }
  if (typeof r != "string")
    return r === 0 ? r : +r;
  r = h8(r);
  var i = E8.test(r);
  return i || M8.test(r) ? A8(r.slice(2), i ? 2 : 8) : w8.test(r) ? eE : +r;
}
var C8 = "Expected a function", R8 = Math.max, N8 = Math.min;
function hN(r, e, i) {
  var n, s, a, o, l, u, c = 0, h = !1, d = !1, p = !0;
  if (typeof r != "function")
    throw new TypeError(C8);
  e = tE(e) || 0, Em(i) && (h = !!i.leading, d = "maxWait" in i, a = d ? R8(tE(i.maxWait) || 0, e) : a, p = "trailing" in i ? !!i.trailing : p);
  function f(S) {
    var w = n, M = s;
    return n = s = void 0, c = S, o = r.apply(M, w), o;
  }
  function m(S) {
    return c = S, l = setTimeout(g, e), h ? f(S) : o;
  }
  function y(S) {
    var w = S - u, M = S - c, E = e - w;
    return d ? N8(E, a - M) : E;
  }
  function v(S) {
    var w = S - u, M = S - c;
    return u === void 0 || w >= e || w < 0 || d && M >= a;
  }
  function g() {
    var S = s0();
    if (v(S))
      return _(S);
    l = setTimeout(g, y(S));
  }
  function _(S) {
    return l = void 0, p && n ? f(S) : (n = s = void 0, o);
  }
  function x() {
    l !== void 0 && clearTimeout(l), c = 0, n = u = s = l = void 0;
  }
  function b() {
    return l === void 0 ? o : _(s0());
  }
  function T() {
    var S = s0(), w = v(S);
    if (n = arguments, s = this, u = S, w) {
      if (l === void 0)
        return m(u);
      if (d)
        return clearTimeout(l), l = setTimeout(g, e), f(u);
    }
    return l === void 0 && (l = setTimeout(g, e)), o;
  }
  return T.cancel = x, T.flush = b, T;
}
function iE(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function P8(r) {
  if (Array.isArray(r)) return r;
}
function I8(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function O8(r, e, i) {
  return Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function D8(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function L8() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function k8(r, e) {
  return P8(r) || D8(r, e) || U8(r, e) || L8();
}
function U8(r, e) {
  if (r) {
    if (typeof r == "string") return iE(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? iE(r, e) : void 0;
  }
}
var F8 = /* @__PURE__ */ O8(function r(e, i) {
  var n = i.default, s = n === void 0 ? null : n, a = i.triggerUpdate, o = a === void 0 ? !0 : a, l = i.onChange, u = l === void 0 ? function(c, h) {
  } : l;
  I8(this, r), this.name = e, this.defaultVal = s, this.triggerUpdate = o, this.onChange = u;
});
function Pl(r) {
  var e = r.stateInit, i = e === void 0 ? function() {
    return {};
  } : e, n = r.props, s = n === void 0 ? {} : n, a = r.methods, o = a === void 0 ? {} : a, l = r.aliases, u = l === void 0 ? {} : l, c = r.init, h = c === void 0 ? function() {
  } : c, d = r.update, p = d === void 0 ? function() {
  } : d, f = Object.keys(s).map(function(m) {
    return new F8(m, s[m]);
  });
  return function m() {
    for (var y = arguments.length, v = new Array(y), g = 0; g < y; g++)
      v[g] = arguments[g];
    var _ = !!(this instanceof m && this.constructor), x = _ ? v.shift() : void 0, b = v[0], T = b === void 0 ? {} : b, S = Object.assign(
      {},
      i instanceof Function ? i(T) : i,
      // Support plain objects for backwards compatibility
      {
        initialised: !1
      }
    ), w = {};
    function M(N) {
      return E(N, T), A(), M;
    }
    var E = function(N, U) {
      h.call(M, N, S, U), S.initialised = !0;
    }, A = hN(function() {
      S.initialised && (p.call(M, S, w), w = {});
    }, 1);
    return f.forEach(function(N) {
      M[N.name] = U(N);
      function U(k) {
        var C = k.name, I = k.triggerUpdate, O = I === void 0 ? !1 : I, W = k.onChange, V = W === void 0 ? function(B, q) {
        } : W, Q = k.defaultVal, F = Q === void 0 ? null : Q;
        return function(B) {
          var q = S[C];
          if (!arguments.length)
            return q;
          var G = B === void 0 ? F : B;
          return S[C] = G, V.call(M, G, S, q), !w.hasOwnProperty(C) && (w[C] = q), O && A(), M;
        };
      }
    }), Object.keys(o).forEach(function(N) {
      M[N] = function() {
        for (var U, k = arguments.length, C = new Array(k), I = 0; I < k; I++)
          C[I] = arguments[I];
        return (U = o[N]).call.apply(U, [M, S].concat(C));
      };
    }), Object.entries(u).forEach(function(N) {
      var U = k8(N, 2), k = U[0], C = U[1];
      return M[k] = M[C];
    }), M.resetProps = function() {
      return f.forEach(function(N) {
        M[N.name](N.defaultVal);
      }), M;
    }, M.resetProps(), S._rerender = A, _ && x && M(x), M;
  };
}
var et = function(r) {
  return typeof r == "function" ? r : typeof r == "string" ? function(e) {
    return e[r];
  } : function(e) {
    return r;
  };
};
class rE extends Map {
  constructor(e, i = j8) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: i } }), e != null) for (const [n, s] of e) this.set(n, s);
  }
  get(e) {
    return super.get(nE(this, e));
  }
  has(e) {
    return super.has(nE(this, e));
  }
  set(e, i) {
    return super.set(B8(this, e), i);
  }
  delete(e) {
    return super.delete(z8(this, e));
  }
}
function nE({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) ? r.get(n) : i;
}
function B8({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) ? r.get(n) : (r.set(n, i), i);
}
function z8({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) && (i = r.get(n), r.delete(n)), i;
}
function j8(r) {
  return r !== null && typeof r == "object" ? r.valueOf() : r;
}
function Vb(r, e) {
  let i;
  if (e === void 0)
    for (const n of r)
      n != null && (i < n || i === void 0 && n >= n) && (i = n);
  else {
    let n = -1;
    for (let s of r)
      (s = e(s, ++n, r)) != null && (i < s || i === void 0 && s >= s) && (i = s);
  }
  return i;
}
function Gb(r, e) {
  let i;
  if (e === void 0)
    for (const n of r)
      n != null && (i > n || i === void 0 && n >= n) && (i = n);
  else {
    let n = -1;
    for (let s of r)
      (s = e(s, ++n, r)) != null && (i > s || i === void 0 && s >= s) && (i = s);
  }
  return i;
}
function V8(r, e) {
  let i = 0;
  for (let n of r)
    (n = +n) && (i += n);
  return i;
}
function Hb(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function G8(r) {
  if (Array.isArray(r)) return r;
}
function H8(r) {
  if (Array.isArray(r)) return Hb(r);
}
function dN(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function W8(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function q8(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function ur(r, e) {
  return r.get(dN(r, e));
}
function nu(r, e, i) {
  W8(r, e), e.set(r, i);
}
function zp(r, e, i) {
  return r.set(dN(r, e), i), i;
}
function X8(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, iH(n.key), n);
  }
}
function $8(r, e, i) {
  return e && X8(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function Y8(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function K8(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function Z8() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Q8() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function J8(r, e) {
  return G8(r) || K8(r, e) || pN(r, e) || Z8();
}
function eH(r) {
  return H8(r) || Y8(r) || pN(r) || Q8();
}
function tH(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function iH(r) {
  var e = tH(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function pN(r, e) {
  if (r) {
    if (typeof r == "string") return Hb(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Hb(r, e) : void 0;
  }
}
var su = /* @__PURE__ */ new WeakMap(), ph = /* @__PURE__ */ new WeakMap(), au = /* @__PURE__ */ new WeakMap(), a0 = /* @__PURE__ */ new WeakMap(), o0 = /* @__PURE__ */ new WeakMap(), l0 = /* @__PURE__ */ new WeakMap(), rH = /* @__PURE__ */ function() {
  function r() {
    q8(this, r), nu(this, su, /* @__PURE__ */ new Map()), nu(this, ph, /* @__PURE__ */ new Map()), nu(this, au, function(e) {
      return e;
    }), nu(this, a0, function() {
      return {};
    }), nu(this, o0, function() {
    }), nu(this, l0, function() {
    });
  }
  return $8(r, [{
    key: "getObj",
    value: function(e) {
      return ur(su, this).get(ur(au, this).call(this, e));
    }
  }, {
    key: "getData",
    value: function(e) {
      return ur(ph, this).get(e);
    }
  }, {
    key: "entries",
    value: function() {
      return eH(ur(ph, this).entries()).map(function(e) {
        var i = J8(e, 2), n = i[0], s = i[1];
        return [s, n];
      });
    }
  }, {
    key: "id",
    value: function(e) {
      return zp(au, this, et(e)), this;
    }
  }, {
    key: "onCreateObj",
    value: function(e) {
      return zp(a0, this, e), this;
    }
  }, {
    key: "onUpdateObj",
    value: function(e) {
      return zp(o0, this, e), this;
    }
  }, {
    key: "onRemoveObj",
    value: function(e) {
      return zp(l0, this, e), this;
    }
  }, {
    key: "digest",
    value: function(e) {
      var i = this;
      e.filter(function(s) {
        return !ur(su, i).has(ur(au, i).call(i, s));
      }).forEach(function(s) {
        var a = ur(a0, i).call(i, s);
        ur(su, i).set(ur(au, i).call(i, s), a), ur(ph, i).set(a, s);
      });
      var n = new Map(e.map(function(s) {
        return [ur(au, i).call(i, s), s];
      }));
      return ur(su, this).forEach(function(s, a) {
        n.has(a) ? ur(o0, i).call(i, s, n.get(a)) : (ur(l0, i).call(i, s, a), ur(su, i).delete(a), ur(ph, i).delete(s));
      }), this;
    }
  }, {
    key: "clear",
    value: function() {
      return this.digest([]), this;
    }
  }]);
}();
function nH(r, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(r);
      break;
    default:
      this.range(e).domain(r);
      break;
  }
  return this;
}
const sE = Symbol("implicit");
function n1() {
  var r = new rE(), e = [], i = [], n = sE;
  function s(a) {
    let o = r.get(a);
    if (o === void 0) {
      if (n !== sE) return n;
      r.set(a, o = e.push(a) - 1);
    }
    return i[o % i.length];
  }
  return s.domain = function(a) {
    if (!arguments.length) return e.slice();
    e = [], r = new rE();
    for (const o of a)
      r.has(o) || r.set(o, e.push(o) - 1);
    return s;
  }, s.range = function(a) {
    return arguments.length ? (i = Array.from(a), s) : i.slice();
  }, s.unknown = function(a) {
    return arguments.length ? (n = a, s) : n;
  }, s.copy = function() {
    return n1(e, i).unknown(n);
  }, nH.apply(s, arguments), s;
}
function s1(r, e, i) {
  r.prototype = e.prototype = i, i.constructor = r;
}
function fN(r, e) {
  var i = Object.create(r.prototype);
  for (var n in e) i[n] = e[n];
  return i;
}
function Xd() {
}
var fd = 0.7, Am = 1 / fd, qu = "\\s*([+-]?\\d+)\\s*", md = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", ys = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", sH = /^#([0-9a-f]{3,8})$/, aH = new RegExp(`^rgb\\(${qu},${qu},${qu}\\)$`), oH = new RegExp(`^rgb\\(${ys},${ys},${ys}\\)$`), lH = new RegExp(`^rgba\\(${qu},${qu},${qu},${md}\\)$`), uH = new RegExp(`^rgba\\(${ys},${ys},${ys},${md}\\)$`), cH = new RegExp(`^hsl\\(${md},${ys},${ys}\\)$`), hH = new RegExp(`^hsla\\(${md},${ys},${ys},${md}\\)$`), aE = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
s1(Xd, gd, {
  copy(r) {
    return Object.assign(new this.constructor(), this, r);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: oE,
  // Deprecated! Use color.formatHex.
  formatHex: oE,
  formatHex8: dH,
  formatHsl: pH,
  formatRgb: lE,
  toString: lE
});
function oE() {
  return this.rgb().formatHex();
}
function dH() {
  return this.rgb().formatHex8();
}
function pH() {
  return mN(this).formatHsl();
}
function lE() {
  return this.rgb().formatRgb();
}
function gd(r) {
  var e, i;
  return r = (r + "").trim().toLowerCase(), (e = sH.exec(r)) ? (i = e[1].length, e = parseInt(e[1], 16), i === 6 ? uE(e) : i === 3 ? new kr(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : i === 8 ? jp(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : i === 4 ? jp(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = aH.exec(r)) ? new kr(e[1], e[2], e[3], 1) : (e = oH.exec(r)) ? new kr(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = lH.exec(r)) ? jp(e[1], e[2], e[3], e[4]) : (e = uH.exec(r)) ? jp(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = cH.exec(r)) ? dE(e[1], e[2] / 100, e[3] / 100, 1) : (e = hH.exec(r)) ? dE(e[1], e[2] / 100, e[3] / 100, e[4]) : aE.hasOwnProperty(r) ? uE(aE[r]) : r === "transparent" ? new kr(NaN, NaN, NaN, 0) : null;
}
function uE(r) {
  return new kr(r >> 16 & 255, r >> 8 & 255, r & 255, 1);
}
function jp(r, e, i, n) {
  return n <= 0 && (r = e = i = NaN), new kr(r, e, i, n);
}
function fH(r) {
  return r instanceof Xd || (r = gd(r)), r ? (r = r.rgb(), new kr(r.r, r.g, r.b, r.opacity)) : new kr();
}
function Wb(r, e, i, n) {
  return arguments.length === 1 ? fH(r) : new kr(r, e, i, n ?? 1);
}
function kr(r, e, i, n) {
  this.r = +r, this.g = +e, this.b = +i, this.opacity = +n;
}
s1(kr, Wb, fN(Xd, {
  brighter(r) {
    return r = r == null ? Am : Math.pow(Am, r), new kr(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? fd : Math.pow(fd, r), new kr(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new kr(ml(this.r), ml(this.g), ml(this.b), Cm(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: cE,
  // Deprecated! Use color.formatHex.
  formatHex: cE,
  formatHex8: mH,
  formatRgb: hE,
  toString: hE
}));
function cE() {
  return `#${al(this.r)}${al(this.g)}${al(this.b)}`;
}
function mH() {
  return `#${al(this.r)}${al(this.g)}${al(this.b)}${al((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function hE() {
  const r = Cm(this.opacity);
  return `${r === 1 ? "rgb(" : "rgba("}${ml(this.r)}, ${ml(this.g)}, ${ml(this.b)}${r === 1 ? ")" : `, ${r})`}`;
}
function Cm(r) {
  return isNaN(r) ? 1 : Math.max(0, Math.min(1, r));
}
function ml(r) {
  return Math.max(0, Math.min(255, Math.round(r) || 0));
}
function al(r) {
  return r = ml(r), (r < 16 ? "0" : "") + r.toString(16);
}
function dE(r, e, i, n) {
  return n <= 0 ? r = e = i = NaN : i <= 0 || i >= 1 ? r = e = NaN : e <= 0 && (r = NaN), new Wn(r, e, i, n);
}
function mN(r) {
  if (r instanceof Wn) return new Wn(r.h, r.s, r.l, r.opacity);
  if (r instanceof Xd || (r = gd(r)), !r) return new Wn();
  if (r instanceof Wn) return r;
  r = r.rgb();
  var e = r.r / 255, i = r.g / 255, n = r.b / 255, s = Math.min(e, i, n), a = Math.max(e, i, n), o = NaN, l = a - s, u = (a + s) / 2;
  return l ? (e === a ? o = (i - n) / l + (i < n) * 6 : i === a ? o = (n - e) / l + 2 : o = (e - i) / l + 4, l /= u < 0.5 ? a + s : 2 - a - s, o *= 60) : l = u > 0 && u < 1 ? 0 : o, new Wn(o, l, u, r.opacity);
}
function gH(r, e, i, n) {
  return arguments.length === 1 ? mN(r) : new Wn(r, e, i, n ?? 1);
}
function Wn(r, e, i, n) {
  this.h = +r, this.s = +e, this.l = +i, this.opacity = +n;
}
s1(Wn, gH, fN(Xd, {
  brighter(r) {
    return r = r == null ? Am : Math.pow(Am, r), new Wn(this.h, this.s, this.l * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? fd : Math.pow(fd, r), new Wn(this.h, this.s, this.l * r, this.opacity);
  },
  rgb() {
    var r = this.h % 360 + (this.h < 0) * 360, e = isNaN(r) || isNaN(this.s) ? 0 : this.s, i = this.l, n = i + (i < 0.5 ? i : 1 - i) * e, s = 2 * i - n;
    return new kr(
      u0(r >= 240 ? r - 240 : r + 120, s, n),
      u0(r, s, n),
      u0(r < 120 ? r + 240 : r - 120, s, n),
      this.opacity
    );
  },
  clamp() {
    return new Wn(pE(this.h), Vp(this.s), Vp(this.l), Cm(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const r = Cm(this.opacity);
    return `${r === 1 ? "hsl(" : "hsla("}${pE(this.h)}, ${Vp(this.s) * 100}%, ${Vp(this.l) * 100}%${r === 1 ? ")" : `, ${r})`}`;
  }
}));
function pE(r) {
  return r = (r || 0) % 360, r < 0 ? r + 360 : r;
}
function Vp(r) {
  return Math.max(0, Math.min(1, r || 0));
}
function u0(r, e, i) {
  return (r < 60 ? e + (i - e) * r / 60 : r < 180 ? i : r < 240 ? e + (i - e) * (240 - r) / 60 : e) * 255;
}
const gN = (r) => () => r;
function yH(r, e) {
  return function(i) {
    return r + i * e;
  };
}
function vH(r, e, i) {
  return r = Math.pow(r, i), e = Math.pow(e, i) - r, i = 1 / i, function(n) {
    return Math.pow(r + n * e, i);
  };
}
function bH(r) {
  return (r = +r) == 1 ? yN : function(e, i) {
    return i - e ? vH(e, i, r) : gN(isNaN(e) ? i : e);
  };
}
function yN(r, e) {
  var i = e - r;
  return i ? yH(r, i) : gN(isNaN(r) ? e : r);
}
const fE = function r(e) {
  var i = bH(e);
  function n(s, a) {
    var o = i((s = Wb(s)).r, (a = Wb(a)).r), l = i(s.g, a.g), u = i(s.b, a.b), c = yN(s.opacity, a.opacity);
    return function(h) {
      return s.r = o(h), s.g = l(h), s.b = u(h), s.opacity = c(h), s + "";
    };
  }
  return n.gamma = r, n;
}(1);
function Ya(r, e) {
  return r = +r, e = +e, function(i) {
    return r * (1 - i) + e * i;
  };
}
var qb = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, c0 = new RegExp(qb.source, "g");
function xH(r) {
  return function() {
    return r;
  };
}
function _H(r) {
  return function(e) {
    return r(e) + "";
  };
}
function TH(r, e) {
  var i = qb.lastIndex = c0.lastIndex = 0, n, s, a, o = -1, l = [], u = [];
  for (r = r + "", e = e + ""; (n = qb.exec(r)) && (s = c0.exec(e)); )
    (a = s.index) > i && (a = e.slice(i, a), l[o] ? l[o] += a : l[++o] = a), (n = n[0]) === (s = s[0]) ? l[o] ? l[o] += s : l[++o] = s : (l[++o] = null, u.push({ i: o, x: Ya(n, s) })), i = c0.lastIndex;
  return i < e.length && (a = e.slice(i), l[o] ? l[o] += a : l[++o] = a), l.length < 2 ? u[0] ? _H(u[0].x) : xH(e) : (e = u.length, function(c) {
    for (var h = 0, d; h < e; ++h) l[(d = u[h]).i] = d.x(c);
    return l.join("");
  });
}
var mE = 180 / Math.PI, vN = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function bN(r, e, i, n, s, a) {
  var o, l, u;
  return (o = Math.sqrt(r * r + e * e)) && (r /= o, e /= o), (u = r * i + e * n) && (i -= r * u, n -= e * u), (l = Math.sqrt(i * i + n * n)) && (i /= l, n /= l, u /= l), r * n < e * i && (r = -r, e = -e, u = -u, o = -o), {
    translateX: s,
    translateY: a,
    rotate: Math.atan2(e, r) * mE,
    skewX: Math.atan(u) * mE,
    scaleX: o,
    scaleY: l
  };
}
var Gp;
function SH(r) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(r + "");
  return e.isIdentity ? vN : bN(e.a, e.b, e.c, e.d, e.e, e.f);
}
function wH(r) {
  return r == null || (Gp || (Gp = document.createElementNS("http://www.w3.org/2000/svg", "g")), Gp.setAttribute("transform", r), !(r = Gp.transform.baseVal.consolidate())) ? vN : (r = r.matrix, bN(r.a, r.b, r.c, r.d, r.e, r.f));
}
function xN(r, e, i, n) {
  function s(c) {
    return c.length ? c.pop() + " " : "";
  }
  function a(c, h, d, p, f, m) {
    if (c !== d || h !== p) {
      var y = f.push("translate(", null, e, null, i);
      m.push({ i: y - 4, x: Ya(c, d) }, { i: y - 2, x: Ya(h, p) });
    } else (d || p) && f.push("translate(" + d + e + p + i);
  }
  function o(c, h, d, p) {
    c !== h ? (c - h > 180 ? h += 360 : h - c > 180 && (c += 360), p.push({ i: d.push(s(d) + "rotate(", null, n) - 2, x: Ya(c, h) })) : h && d.push(s(d) + "rotate(" + h + n);
  }
  function l(c, h, d, p) {
    c !== h ? p.push({ i: d.push(s(d) + "skewX(", null, n) - 2, x: Ya(c, h) }) : h && d.push(s(d) + "skewX(" + h + n);
  }
  function u(c, h, d, p, f, m) {
    if (c !== d || h !== p) {
      var y = f.push(s(f) + "scale(", null, ",", null, ")");
      m.push({ i: y - 4, x: Ya(c, d) }, { i: y - 2, x: Ya(h, p) });
    } else (d !== 1 || p !== 1) && f.push(s(f) + "scale(" + d + "," + p + ")");
  }
  return function(c, h) {
    var d = [], p = [];
    return c = r(c), h = r(h), a(c.translateX, c.translateY, h.translateX, h.translateY, d, p), o(c.rotate, h.rotate, d, p), l(c.skewX, h.skewX, d, p), u(c.scaleX, c.scaleY, h.scaleX, h.scaleY, d, p), c = h = null, function(f) {
      for (var m = -1, y = p.length, v; ++m < y; ) d[(v = p[m]).i] = v.x(f);
      return d.join("");
    };
  };
}
var EH = xN(SH, "px, ", "px)", "deg)"), MH = xN(wH, ", ", ")", ")"), AH = 1e-12;
function gE(r) {
  return ((r = Math.exp(r)) + 1 / r) / 2;
}
function CH(r) {
  return ((r = Math.exp(r)) - 1 / r) / 2;
}
function RH(r) {
  return ((r = Math.exp(2 * r)) - 1) / (r + 1);
}
const NH = function r(e, i, n) {
  function s(a, o) {
    var l = a[0], u = a[1], c = a[2], h = o[0], d = o[1], p = o[2], f = h - l, m = d - u, y = f * f + m * m, v, g;
    if (y < AH)
      g = Math.log(p / c) / e, v = function(w) {
        return [
          l + w * f,
          u + w * m,
          c * Math.exp(e * w * g)
        ];
      };
    else {
      var _ = Math.sqrt(y), x = (p * p - c * c + n * y) / (2 * c * i * _), b = (p * p - c * c - n * y) / (2 * p * i * _), T = Math.log(Math.sqrt(x * x + 1) - x), S = Math.log(Math.sqrt(b * b + 1) - b);
      g = (S - T) / e, v = function(w) {
        var M = w * g, E = gE(T), A = c / (i * _) * (E * RH(e * M + T) - CH(T));
        return [
          l + A * f,
          u + A * m,
          c * E / gE(e * M + T)
        ];
      };
    }
    return v.duration = g * 1e3 * e / Math.SQRT2, v;
  }
  return s.rho = function(a) {
    var o = Math.max(1e-3, +a), l = o * o, u = l * l;
    return r(o, l, u);
  }, s;
}(Math.SQRT2, 2, 4);
function PH(r) {
  for (var e = r.length / 6 | 0, i = new Array(e), n = 0; n < e; ) i[n] = "#" + r.slice(n * 6, ++n * 6);
  return i;
}
const _N = PH("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
function Rm(r) {
  "@babel/helpers - typeof";
  return Rm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Rm(r);
}
var IH = /^\s+/, OH = /\s+$/;
function rt(r, e) {
  if (r = r || "", e = e || {}, r instanceof rt)
    return r;
  if (!(this instanceof rt))
    return new rt(r, e);
  var i = DH(r);
  this._originalInput = r, this._r = i.r, this._g = i.g, this._b = i.b, this._a = i.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e.format || i.format, this._gradientType = e.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = i.ok;
}
rt.prototype = {
  isDark: function() {
    return this.getBrightness() < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  isValid: function() {
    return this._ok;
  },
  getOriginalInput: function() {
    return this._originalInput;
  },
  getFormat: function() {
    return this._format;
  },
  getAlpha: function() {
    return this._a;
  },
  getBrightness: function() {
    var r = this.toRgb();
    return (r.r * 299 + r.g * 587 + r.b * 114) / 1e3;
  },
  getLuminance: function() {
    var r = this.toRgb(), e, i, n, s, a, o;
    return e = r.r / 255, i = r.g / 255, n = r.b / 255, e <= 0.03928 ? s = e / 12.92 : s = Math.pow((e + 0.055) / 1.055, 2.4), i <= 0.03928 ? a = i / 12.92 : a = Math.pow((i + 0.055) / 1.055, 2.4), n <= 0.03928 ? o = n / 12.92 : o = Math.pow((n + 0.055) / 1.055, 2.4), 0.2126 * s + 0.7152 * a + 0.0722 * o;
  },
  setAlpha: function(r) {
    return this._a = TN(r), this._roundA = Math.round(100 * this._a) / 100, this;
  },
  toHsv: function() {
    var r = vE(this._r, this._g, this._b);
    return {
      h: r.h * 360,
      s: r.s,
      v: r.v,
      a: this._a
    };
  },
  toHsvString: function() {
    var r = vE(this._r, this._g, this._b), e = Math.round(r.h * 360), i = Math.round(r.s * 100), n = Math.round(r.v * 100);
    return this._a == 1 ? "hsv(" + e + ", " + i + "%, " + n + "%)" : "hsva(" + e + ", " + i + "%, " + n + "%, " + this._roundA + ")";
  },
  toHsl: function() {
    var r = yE(this._r, this._g, this._b);
    return {
      h: r.h * 360,
      s: r.s,
      l: r.l,
      a: this._a
    };
  },
  toHslString: function() {
    var r = yE(this._r, this._g, this._b), e = Math.round(r.h * 360), i = Math.round(r.s * 100), n = Math.round(r.l * 100);
    return this._a == 1 ? "hsl(" + e + ", " + i + "%, " + n + "%)" : "hsla(" + e + ", " + i + "%, " + n + "%, " + this._roundA + ")";
  },
  toHex: function(r) {
    return bE(this._r, this._g, this._b, r);
  },
  toHexString: function(r) {
    return "#" + this.toHex(r);
  },
  toHex8: function(r) {
    return FH(this._r, this._g, this._b, this._a, r);
  },
  toHex8String: function(r) {
    return "#" + this.toHex8(r);
  },
  toRgb: function() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function() {
    return {
      r: Math.round(fi(this._r, 255) * 100) + "%",
      g: Math.round(fi(this._g, 255) * 100) + "%",
      b: Math.round(fi(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(fi(this._r, 255) * 100) + "%, " + Math.round(fi(this._g, 255) * 100) + "%, " + Math.round(fi(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(fi(this._r, 255) * 100) + "%, " + Math.round(fi(this._g, 255) * 100) + "%, " + Math.round(fi(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function() {
    return this._a === 0 ? "transparent" : this._a < 1 ? !1 : KH[bE(this._r, this._g, this._b, !0)] || !1;
  },
  toFilter: function(r) {
    var e = "#" + xE(this._r, this._g, this._b, this._a), i = e, n = this._gradientType ? "GradientType = 1, " : "";
    if (r) {
      var s = rt(r);
      i = "#" + xE(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + n + "startColorstr=" + e + ",endColorstr=" + i + ")";
  },
  toString: function(r) {
    var e = !!r;
    r = r || this._format;
    var i = !1, n = this._a < 1 && this._a >= 0, s = !e && n && (r === "hex" || r === "hex6" || r === "hex3" || r === "hex4" || r === "hex8" || r === "name");
    return s ? r === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (r === "rgb" && (i = this.toRgbString()), r === "prgb" && (i = this.toPercentageRgbString()), (r === "hex" || r === "hex6") && (i = this.toHexString()), r === "hex3" && (i = this.toHexString(!0)), r === "hex4" && (i = this.toHex8String(!0)), r === "hex8" && (i = this.toHex8String()), r === "name" && (i = this.toName()), r === "hsl" && (i = this.toHslString()), r === "hsv" && (i = this.toHsvString()), i || this.toHexString());
  },
  clone: function() {
    return rt(this.toString());
  },
  _applyModification: function(r, e) {
    var i = r.apply(null, [this].concat([].slice.call(e)));
    return this._r = i._r, this._g = i._g, this._b = i._b, this.setAlpha(i._a), this;
  },
  lighten: function() {
    return this._applyModification(VH, arguments);
  },
  brighten: function() {
    return this._applyModification(GH, arguments);
  },
  darken: function() {
    return this._applyModification(HH, arguments);
  },
  desaturate: function() {
    return this._applyModification(BH, arguments);
  },
  saturate: function() {
    return this._applyModification(zH, arguments);
  },
  greyscale: function() {
    return this._applyModification(jH, arguments);
  },
  spin: function() {
    return this._applyModification(WH, arguments);
  },
  _applyCombination: function(r, e) {
    return r.apply(null, [this].concat([].slice.call(e)));
  },
  analogous: function() {
    return this._applyCombination($H, arguments);
  },
  complement: function() {
    return this._applyCombination(qH, arguments);
  },
  monochromatic: function() {
    return this._applyCombination(YH, arguments);
  },
  splitcomplement: function() {
    return this._applyCombination(XH, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function() {
    return this._applyCombination(_E, [3]);
  },
  tetrad: function() {
    return this._applyCombination(_E, [4]);
  }
};
rt.fromRatio = function(r, e) {
  if (Rm(r) == "object") {
    var i = {};
    for (var n in r)
      r.hasOwnProperty(n) && (n === "a" ? i[n] = r[n] : i[n] = Vh(r[n]));
    r = i;
  }
  return rt(r, e);
};
function DH(r) {
  var e = {
    r: 0,
    g: 0,
    b: 0
  }, i = 1, n = null, s = null, a = null, o = !1, l = !1;
  return typeof r == "string" && (r = e9(r)), Rm(r) == "object" && (Is(r.r) && Is(r.g) && Is(r.b) ? (e = LH(r.r, r.g, r.b), o = !0, l = String(r.r).substr(-1) === "%" ? "prgb" : "rgb") : Is(r.h) && Is(r.s) && Is(r.v) ? (n = Vh(r.s), s = Vh(r.v), e = UH(r.h, n, s), o = !0, l = "hsv") : Is(r.h) && Is(r.s) && Is(r.l) && (n = Vh(r.s), a = Vh(r.l), e = kH(r.h, n, a), o = !0, l = "hsl"), r.hasOwnProperty("a") && (i = r.a)), i = TN(i), {
    ok: o,
    format: r.format || l,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: i
  };
}
function LH(r, e, i) {
  return {
    r: fi(r, 255) * 255,
    g: fi(e, 255) * 255,
    b: fi(i, 255) * 255
  };
}
function yE(r, e, i) {
  r = fi(r, 255), e = fi(e, 255), i = fi(i, 255);
  var n = Math.max(r, e, i), s = Math.min(r, e, i), a, o, l = (n + s) / 2;
  if (n == s)
    a = o = 0;
  else {
    var u = n - s;
    switch (o = l > 0.5 ? u / (2 - n - s) : u / (n + s), n) {
      case r:
        a = (e - i) / u + (e < i ? 6 : 0);
        break;
      case e:
        a = (i - r) / u + 2;
        break;
      case i:
        a = (r - e) / u + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s: o,
    l
  };
}
function kH(r, e, i) {
  var n, s, a;
  r = fi(r, 360), e = fi(e, 100), i = fi(i, 100);
  function o(c, h, d) {
    return d < 0 && (d += 1), d > 1 && (d -= 1), d < 1 / 6 ? c + (h - c) * 6 * d : d < 1 / 2 ? h : d < 2 / 3 ? c + (h - c) * (2 / 3 - d) * 6 : c;
  }
  if (e === 0)
    n = s = a = i;
  else {
    var l = i < 0.5 ? i * (1 + e) : i + e - i * e, u = 2 * i - l;
    n = o(u, l, r + 1 / 3), s = o(u, l, r), a = o(u, l, r - 1 / 3);
  }
  return {
    r: n * 255,
    g: s * 255,
    b: a * 255
  };
}
function vE(r, e, i) {
  r = fi(r, 255), e = fi(e, 255), i = fi(i, 255);
  var n = Math.max(r, e, i), s = Math.min(r, e, i), a, o, l = n, u = n - s;
  if (o = n === 0 ? 0 : u / n, n == s)
    a = 0;
  else {
    switch (n) {
      case r:
        a = (e - i) / u + (e < i ? 6 : 0);
        break;
      case e:
        a = (i - r) / u + 2;
        break;
      case i:
        a = (r - e) / u + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s: o,
    v: l
  };
}
function UH(r, e, i) {
  r = fi(r, 360) * 6, e = fi(e, 100), i = fi(i, 100);
  var n = Math.floor(r), s = r - n, a = i * (1 - e), o = i * (1 - s * e), l = i * (1 - (1 - s) * e), u = n % 6, c = [i, o, a, a, l, i][u], h = [l, i, i, o, a, a][u], d = [a, a, l, i, i, o][u];
  return {
    r: c * 255,
    g: h * 255,
    b: d * 255
  };
}
function bE(r, e, i, n) {
  var s = [$n(Math.round(r).toString(16)), $n(Math.round(e).toString(16)), $n(Math.round(i).toString(16))];
  return n && s[0].charAt(0) == s[0].charAt(1) && s[1].charAt(0) == s[1].charAt(1) && s[2].charAt(0) == s[2].charAt(1) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) : s.join("");
}
function FH(r, e, i, n, s) {
  var a = [$n(Math.round(r).toString(16)), $n(Math.round(e).toString(16)), $n(Math.round(i).toString(16)), $n(SN(n))];
  return s && a[0].charAt(0) == a[0].charAt(1) && a[1].charAt(0) == a[1].charAt(1) && a[2].charAt(0) == a[2].charAt(1) && a[3].charAt(0) == a[3].charAt(1) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("");
}
function xE(r, e, i, n) {
  var s = [$n(SN(n)), $n(Math.round(r).toString(16)), $n(Math.round(e).toString(16)), $n(Math.round(i).toString(16))];
  return s.join("");
}
rt.equals = function(r, e) {
  return !r || !e ? !1 : rt(r).toRgbString() == rt(e).toRgbString();
};
rt.random = function() {
  return rt.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function BH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.s -= e / 100, i.s = Rg(i.s), rt(i);
}
function zH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.s += e / 100, i.s = Rg(i.s), rt(i);
}
function jH(r) {
  return rt(r).desaturate(100);
}
function VH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.l += e / 100, i.l = Rg(i.l), rt(i);
}
function GH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toRgb();
  return i.r = Math.max(0, Math.min(255, i.r - Math.round(255 * -(e / 100)))), i.g = Math.max(0, Math.min(255, i.g - Math.round(255 * -(e / 100)))), i.b = Math.max(0, Math.min(255, i.b - Math.round(255 * -(e / 100)))), rt(i);
}
function HH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.l -= e / 100, i.l = Rg(i.l), rt(i);
}
function WH(r, e) {
  var i = rt(r).toHsl(), n = (i.h + e) % 360;
  return i.h = n < 0 ? 360 + n : n, rt(i);
}
function qH(r) {
  var e = rt(r).toHsl();
  return e.h = (e.h + 180) % 360, rt(e);
}
function _E(r, e) {
  if (isNaN(e) || e <= 0)
    throw new Error("Argument to polyad must be a positive number");
  for (var i = rt(r).toHsl(), n = [rt(r)], s = 360 / e, a = 1; a < e; a++)
    n.push(rt({
      h: (i.h + a * s) % 360,
      s: i.s,
      l: i.l
    }));
  return n;
}
function XH(r) {
  var e = rt(r).toHsl(), i = e.h;
  return [rt(r), rt({
    h: (i + 72) % 360,
    s: e.s,
    l: e.l
  }), rt({
    h: (i + 216) % 360,
    s: e.s,
    l: e.l
  })];
}
function $H(r, e, i) {
  e = e || 6, i = i || 30;
  var n = rt(r).toHsl(), s = 360 / i, a = [rt(r)];
  for (n.h = (n.h - (s * e >> 1) + 720) % 360; --e; )
    n.h = (n.h + s) % 360, a.push(rt(n));
  return a;
}
function YH(r, e) {
  e = e || 6;
  for (var i = rt(r).toHsv(), n = i.h, s = i.s, a = i.v, o = [], l = 1 / e; e--; )
    o.push(rt({
      h: n,
      s,
      v: a
    })), a = (a + l) % 1;
  return o;
}
rt.mix = function(r, e, i) {
  i = i === 0 ? 0 : i || 50;
  var n = rt(r).toRgb(), s = rt(e).toRgb(), a = i / 100, o = {
    r: (s.r - n.r) * a + n.r,
    g: (s.g - n.g) * a + n.g,
    b: (s.b - n.b) * a + n.b,
    a: (s.a - n.a) * a + n.a
  };
  return rt(o);
};
rt.readability = function(r, e) {
  var i = rt(r), n = rt(e);
  return (Math.max(i.getLuminance(), n.getLuminance()) + 0.05) / (Math.min(i.getLuminance(), n.getLuminance()) + 0.05);
};
rt.isReadable = function(r, e, i) {
  var n = rt.readability(r, e), s, a;
  switch (a = !1, s = t9(i), s.level + s.size) {
    case "AAsmall":
    case "AAAlarge":
      a = n >= 4.5;
      break;
    case "AAlarge":
      a = n >= 3;
      break;
    case "AAAsmall":
      a = n >= 7;
      break;
  }
  return a;
};
rt.mostReadable = function(r, e, i) {
  var n = null, s = 0, a, o, l, u;
  i = i || {}, o = i.includeFallbackColors, l = i.level, u = i.size;
  for (var c = 0; c < e.length; c++)
    a = rt.readability(r, e[c]), a > s && (s = a, n = rt(e[c]));
  return rt.isReadable(r, n, {
    level: l,
    size: u
  }) || !o ? n : (i.includeFallbackColors = !1, rt.mostReadable(r, ["#fff", "#000"], i));
};
var Xb = rt.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
}, KH = rt.hexNames = ZH(Xb);
function ZH(r) {
  var e = {};
  for (var i in r)
    r.hasOwnProperty(i) && (e[r[i]] = i);
  return e;
}
function TN(r) {
  return r = parseFloat(r), (isNaN(r) || r < 0 || r > 1) && (r = 1), r;
}
function fi(r, e) {
  QH(r) && (r = "100%");
  var i = JH(r);
  return r = Math.min(e, Math.max(0, parseFloat(r))), i && (r = parseInt(r * e, 10) / 100), Math.abs(r - e) < 1e-6 ? 1 : r % e / parseFloat(e);
}
function Rg(r) {
  return Math.min(1, Math.max(0, r));
}
function tn(r) {
  return parseInt(r, 16);
}
function QH(r) {
  return typeof r == "string" && r.indexOf(".") != -1 && parseFloat(r) === 1;
}
function JH(r) {
  return typeof r == "string" && r.indexOf("%") != -1;
}
function $n(r) {
  return r.length == 1 ? "0" + r : "" + r;
}
function Vh(r) {
  return r <= 1 && (r = r * 100 + "%"), r;
}
function SN(r) {
  return Math.round(parseFloat(r) * 255).toString(16);
}
function TE(r) {
  return tn(r) / 255;
}
var Ln = function() {
  var r = "[-\\+]?\\d+%?", e = "[-\\+]?\\d*\\.\\d+%?", i = "(?:" + e + ")|(?:" + r + ")", n = "[\\s|\\(]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")\\s*\\)?", s = "[\\s|\\(]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(i),
    rgb: new RegExp("rgb" + n),
    rgba: new RegExp("rgba" + s),
    hsl: new RegExp("hsl" + n),
    hsla: new RegExp("hsla" + s),
    hsv: new RegExp("hsv" + n),
    hsva: new RegExp("hsva" + s),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function Is(r) {
  return !!Ln.CSS_UNIT.exec(r);
}
function e9(r) {
  r = r.replace(IH, "").replace(OH, "").toLowerCase();
  var e = !1;
  if (Xb[r])
    r = Xb[r], e = !0;
  else if (r == "transparent")
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  var i;
  return (i = Ln.rgb.exec(r)) ? {
    r: i[1],
    g: i[2],
    b: i[3]
  } : (i = Ln.rgba.exec(r)) ? {
    r: i[1],
    g: i[2],
    b: i[3],
    a: i[4]
  } : (i = Ln.hsl.exec(r)) ? {
    h: i[1],
    s: i[2],
    l: i[3]
  } : (i = Ln.hsla.exec(r)) ? {
    h: i[1],
    s: i[2],
    l: i[3],
    a: i[4]
  } : (i = Ln.hsv.exec(r)) ? {
    h: i[1],
    s: i[2],
    v: i[3]
  } : (i = Ln.hsva.exec(r)) ? {
    h: i[1],
    s: i[2],
    v: i[3],
    a: i[4]
  } : (i = Ln.hex8.exec(r)) ? {
    r: tn(i[1]),
    g: tn(i[2]),
    b: tn(i[3]),
    a: TE(i[4]),
    format: e ? "name" : "hex8"
  } : (i = Ln.hex6.exec(r)) ? {
    r: tn(i[1]),
    g: tn(i[2]),
    b: tn(i[3]),
    format: e ? "name" : "hex"
  } : (i = Ln.hex4.exec(r)) ? {
    r: tn(i[1] + "" + i[1]),
    g: tn(i[2] + "" + i[2]),
    b: tn(i[3] + "" + i[3]),
    a: TE(i[4] + "" + i[4]),
    format: e ? "name" : "hex8"
  } : (i = Ln.hex3.exec(r)) ? {
    r: tn(i[1] + "" + i[1]),
    g: tn(i[2] + "" + i[2]),
    b: tn(i[3] + "" + i[3]),
    format: e ? "name" : "hex"
  } : !1;
}
function t9(r) {
  var e, i;
  return r = r || {
    level: "AA",
    size: "small"
  }, e = (r.level || "AA").toUpperCase(), i = (r.size || "small").toLowerCase(), e !== "AA" && e !== "AAA" && (e = "AA"), i !== "small" && i !== "large" && (i = "small"), {
    level: e,
    size: i
  };
}
function $b(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function i9(r) {
  if (Array.isArray(r)) return r;
}
function r9(r) {
  if (Array.isArray(r)) return $b(r);
}
function wN(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function n9(r) {
  if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function EN(r, e, i) {
  return e = vc(e), d9(r, a1() ? Reflect.construct(e, i || [], vc(r).constructor) : e.apply(r, i));
}
function s9(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function MN(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function h0(r, e) {
  return r.get(wN(r, e));
}
function SE(r, e, i) {
  s9(r, e), e.set(r, i);
}
function wE(r, e, i) {
  return r.set(wN(r, e), i), i;
}
function AN(r, e, i) {
  if (a1()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return s;
}
function a9(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, NN(n.key), n);
  }
}
function CN(r, e, i) {
  return e && a9(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function Ng(r, e, i) {
  return (e = NN(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function Yb() {
  return Yb = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(r, e, i) {
    var n = p9(r, e);
    if (n) {
      var s = Object.getOwnPropertyDescriptor(n, e);
      return s.get ? s.get.call(arguments.length < 3 ? r : i) : s.value;
    }
  }, Yb.apply(null, arguments);
}
function vc(r) {
  return vc = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, vc(r);
}
function RN(r, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  r.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: r,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(r, "prototype", {
    writable: !1
  }), e && Kb(r, e);
}
function a1() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (a1 = function() {
    return !!r;
  })();
}
function o9(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function l9(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function u9() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function c9() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function EE(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function h9(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? EE(Object(i), !0).forEach(function(n) {
      Ng(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : EE(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function d9(r, e) {
  if (e && (typeof e == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return n9(r);
}
function Kb(r, e) {
  return Kb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Kb(r, e);
}
function Qh(r, e) {
  return i9(r) || l9(r, e) || PN(r, e) || u9();
}
function p9(r, e) {
  for (; !{}.hasOwnProperty.call(r, e) && (r = vc(r)) !== null; ) ;
  return r;
}
function d0(r, e, i, n) {
  var s = Yb(vc(r.prototype), e, i);
  return typeof s == "function" ? function(a) {
    return s.apply(i, a);
  } : s;
}
function jn(r) {
  return r9(r) || o9(r) || PN(r) || c9();
}
function f9(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function NN(r) {
  var e = f9(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Zb(r) {
  "@babel/helpers - typeof";
  return Zb = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Zb(r);
}
function PN(r, e) {
  if (r) {
    if (typeof r == "string") return $b(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? $b(r, e) : void 0;
  }
}
var IN = function(r) {
  r instanceof Array ? r.forEach(IN) : (r.map && r.map.dispose(), r.dispose());
}, ON = function(r) {
  r.geometry && r.geometry.dispose(), r.material && IN(r.material), r.texture && r.texture.dispose(), r.children && r.children.forEach(ON);
}, Qb = function(r) {
  for (; r.children.length; ) {
    var e = r.children[0];
    r.remove(e), ON(e);
  }
}, p0 = /* @__PURE__ */ new WeakMap(), Hp = /* @__PURE__ */ new WeakMap(), fh = /* @__PURE__ */ function(r) {
  function e(i) {
    var n, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = s.dataBindAttr, o = a === void 0 ? "__data" : a, l = s.objBindAttr, u = l === void 0 ? "__threeObj" : l;
    return MN(this, e), n = EN(this, e), Ng(n, "scene", void 0), SE(n, p0, void 0), SE(n, Hp, void 0), n.scene = i, wE(p0, n, o), wE(Hp, n, u), n.onRemoveObj(function() {
    }), n;
  }
  return RN(e, r), CN(e, [{
    key: "onCreateObj",
    value: function(i) {
      var n = this;
      return d0(e, "onCreateObj", this)([function(s) {
        var a = i(s);
        return s[h0(Hp, n)] = a, a[h0(p0, n)] = s, n.scene.add(a), a;
      }]), this;
    }
  }, {
    key: "onRemoveObj",
    value: function(i) {
      var n = this;
      return d0(e, "onRemoveObj", this)([function(s, a) {
        var o = d0(e, "getData", n)([s]);
        i(s, a), n.scene.remove(s), Qb(s), delete o[h0(Hp, n)];
      }]), this;
    }
  }]);
}(rH), mh = function(r) {
  return isNaN(r) ? parseInt(rt(r).toHex(), 16) : r;
}, f0 = function(r) {
  return isNaN(r) ? rt(r).getAlpha() : 1;
}, m9 = n1(_N);
function ME(r, e, i) {
  !e || typeof i != "string" || r.filter(function(n) {
    return !n[i];
  }).forEach(function(n) {
    n[i] = m9(e(n));
  });
}
function g9(r, e) {
  var i = r.nodes, n = r.links, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = s.nodeFilter, o = a === void 0 ? function() {
    return !0;
  } : a, l = s.onLoopError, u = l === void 0 ? function(f) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(f.join(" -> "), ".");
  } : l, c = {};
  i.forEach(function(f) {
    return c[e(f)] = {
      data: f,
      out: [],
      depth: -1,
      skip: !o(f)
    };
  }), n.forEach(function(f) {
    var m = f.source, y = f.target, v = b(m), g = b(y);
    if (!c.hasOwnProperty(v)) throw "Missing source node with id: ".concat(v);
    if (!c.hasOwnProperty(g)) throw "Missing target node with id: ".concat(g);
    var _ = c[v], x = c[g];
    _.out.push(x);
    function b(T) {
      return Zb(T) === "object" ? e(T) : T;
    }
  });
  var h = [];
  p(Object.values(c));
  var d = Object.assign.apply(Object, [{}].concat(jn(Object.entries(c).filter(function(f) {
    var m = Qh(f, 2), y = m[1];
    return !y.skip;
  }).map(function(f) {
    var m = Qh(f, 2), y = m[0], v = m[1];
    return Ng({}, y, v.depth);
  }))));
  return d;
  function p(f) {
    for (var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, v = function() {
      var x = f[g];
      if (m.indexOf(x) !== -1) {
        var b = [].concat(jn(m.slice(m.indexOf(x))), [x]).map(function(T) {
          return e(T.data);
        });
        return h.some(function(T) {
          return T.length === b.length && T.every(function(S, w) {
            return S === b[w];
          });
        }) || (h.push(b), u(b)), 1;
      }
      y > x.depth && (x.depth = y, p(x.out, [].concat(jn(m), [x]), y + (x.skip ? 0 : 1)));
    }, g = 0, _ = f.length; g < _; g++)
      v();
  }
}
var dt = window.THREE ? window.THREE : {
  Group: sl,
  Mesh: Lr,
  MeshLambertMaterial: Jj,
  Color: Ut,
  BufferGeometry: un,
  BufferAttribute: xn,
  Matrix4: ui,
  Vector3: X,
  SphereGeometry: RR,
  CylinderGeometry: Mg,
  TubeGeometry: H_,
  ConeGeometry: G_,
  Line: Uj,
  LineBasicMaterial: MR,
  QuadraticBezierCurve3: j_,
  CubicBezierCurve3: CR,
  Box3: Rl
}, AE = {
  graph: EG,
  forcelayout: s8
}, y9 = 2, m0 = new dt.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute", Wp = new dt.BufferGeometry().applyMatrix4 ? "applyMatrix4" : "applyMatrix", v9 = Pl({
  props: {
    jsonUrl: {
      onChange: function(r, e) {
        var i = this;
        r && !e.fetchingJson && (e.fetchingJson = !0, e.onLoading(), fetch(r).then(function(n) {
          return n.json();
        }).then(function(n) {
          e.fetchingJson = !1, e.onFinishLoading(n), i.graphData(n);
        }));
      },
      triggerUpdate: !1
    },
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        e.engineRunning = !1;
      }
    },
    numDimensions: {
      default: 3,
      onChange: function(r, e) {
        var i = e.d3ForceLayout.force("charge");
        i && i.strength(r > 2 ? -60 : -30), r < 3 && n(e.graphData.nodes, "z"), r < 2 && n(e.graphData.nodes, "y");
        function n(s, a) {
          s.forEach(function(o) {
            delete o[a], delete o["v".concat(a)];
          });
        }
      }
    },
    dagMode: {
      onChange: function(r, e) {
        !r && e.forceEngine === "d3" && (e.graphData.nodes || []).forEach(function(i) {
          return i.fx = i.fy = i.fz = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function(r) {
        return !0;
      }
    },
    onDagError: {
      triggerUpdate: !1
    },
    nodeRelSize: {
      default: 4
    },
    // volume per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val"
    },
    nodeResolution: {
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeColor: {
      default: "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      default: 0.75
    },
    nodeVisibility: {
      default: !0
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      default: !1
    },
    nodePositionUpdate: {
      triggerUpdate: !1
    },
    // custom function to call for updating the node's position. Signature: (threeObj, { x, y, z}, node). If the function returns a truthy value, the regular node position update will not run.
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0
    },
    linkColor: {
      default: "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      default: 0.2
    },
    linkWidth: {},
    // Rounded to nearest decimal. For falsy values use dimensionless line with 1px regardless of distance.
    linkResolution: {
      default: 6
    },
    // how many radial segments in each line tube's geometry
    linkCurvature: {
      default: 0,
      triggerUpdate: !1
    },
    // line curvature radius (0: straight, 1: semi-circle)
    linkCurveRotation: {
      default: 0,
      triggerUpdate: !1
    },
    // line curve rotation along the line axis (0: interection with XY plane, PI: upside down)
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      default: !1
    },
    linkPositionUpdate: {
      triggerUpdate: !1
    },
    // custom function to call for updating the link's position. Signature: (threeObj, { start: { x, y, z},  end: { x, y, z }}, link). If the function returns a truthy value, the regular link position update will not run.
    linkDirectionalArrowLength: {
      default: 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      default: 0.5,
      triggerUpdate: !1
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01,
      triggerUpdate: !1
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    forceEngine: {
      default: "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      default: 0
    },
    d3AlphaDecay: {
      default: 0.0228,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.alphaDecay(r);
      }
    },
    d3AlphaTarget: {
      default: 0,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.alphaTarget(r);
      }
    },
    d3VelocityDecay: {
      default: 0.4,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.velocityDecay(r);
      }
    },
    ngraphPhysics: {
      default: {
        // defaults from https://github.com/anvaka/ngraph.physics.simulator/blob/master/index.js
        timeStep: 20,
        gravity: -1.2,
        theta: 0.8,
        springLength: 30,
        springCoefficient: 8e-4,
        dragCoefficient: 0.02
      }
    },
    warmupTicks: {
      default: 0,
      triggerUpdate: !1
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      default: 1 / 0,
      triggerUpdate: !1
    },
    cooldownTime: {
      default: 15e3,
      triggerUpdate: !1
    },
    // ms
    onLoading: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishLoading: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineTick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineStop: {
      default: function() {
      },
      triggerUpdate: !1
    }
  },
  methods: {
    refresh: function(r) {
      return r._flushObjects = !0, r._rerender(), this;
    },
    // Expose d3 forces for external manipulation
    d3Force: function(r, e, i) {
      return i === void 0 ? r.d3ForceLayout.force(e) : (r.d3ForceLayout.force(e, i), this);
    },
    d3ReheatSimulation: function(r) {
      return r.d3ForceLayout.alpha(1), this.resetCountdown(), this;
    },
    // reset cooldown state
    resetCountdown: function(r) {
      return r.cntTicks = 0, r.startTickTime = /* @__PURE__ */ new Date(), r.engineRunning = !0, this;
    },
    tickFrame: function(r) {
      var e = r.forceEngine !== "ngraph";
      return r.engineRunning && i(), n(), s(), this;
      function i() {
        ++r.cntTicks > r.cooldownTicks || /* @__PURE__ */ new Date() - r.startTickTime > r.cooldownTime || e && r.d3AlphaMin > 0 && r.d3ForceLayout.alpha() < r.d3AlphaMin ? (r.engineRunning = !1, r.onEngineStop()) : (r.layout[e ? "tick" : "step"](), r.onEngineTick());
        var a = et(r.nodeThreeObjectExtend);
        r.nodeDataMapper.entries().forEach(function(d) {
          var p = Qh(d, 2), f = p[0], m = p[1];
          if (m) {
            var y = e ? f : r.layout.getNodePosition(f[r.nodeId]), v = a(f);
            (!r.nodePositionUpdate || !r.nodePositionUpdate(v ? m.children[0] : m, {
              x: y.x,
              y: y.y,
              z: y.z
            }, f) || v) && (m.position.x = y.x, m.position.y = y.y || 0, m.position.z = y.z || 0);
          }
        });
        var o = et(r.linkWidth), l = et(r.linkCurvature), u = et(r.linkCurveRotation), c = et(r.linkThreeObjectExtend);
        r.linkDataMapper.entries().forEach(function(d) {
          var p = Qh(d, 2), f = p[0], m = p[1];
          if (m) {
            var y = e ? f : r.layout.getLinkPosition(r.layout.graph.getLink(f.source, f.target).id), v = y[e ? "source" : "from"], g = y[e ? "target" : "to"];
            if (!(!v || !g || !v.hasOwnProperty("x") || !g.hasOwnProperty("x"))) {
              h(f);
              var _ = c(f);
              if (!(r.linkPositionUpdate && r.linkPositionUpdate(
                _ ? m.children[1] : m,
                // pass child custom object if extending the default
                {
                  start: {
                    x: v.x,
                    y: v.y,
                    z: v.z
                  },
                  end: {
                    x: g.x,
                    y: g.y,
                    z: g.z
                  }
                },
                f
              ) && !_)) {
                var x = 30, b = f.__curve, T = m.children.length ? m.children[0] : m;
                if (T.type === "Line") {
                  if (b) {
                    var S = b.getPoints(x);
                    T.geometry.getAttribute("position").array.length !== S.length * 3 && T.geometry[m0]("position", new dt.BufferAttribute(new Float32Array(S.length * 3), 3)), T.geometry.setFromPoints(S);
                  } else {
                    var w = T.geometry.getAttribute("position");
                    (!w || !w.array || w.array.length !== 6) && T.geometry[m0]("position", w = new dt.BufferAttribute(new Float32Array(2 * 3), 3)), w.array[0] = v.x, w.array[1] = v.y || 0, w.array[2] = v.z || 0, w.array[3] = g.x, w.array[4] = g.y || 0, w.array[5] = g.z || 0, w.needsUpdate = !0;
                  }
                  T.geometry.computeBoundingSphere();
                } else if (T.type === "Mesh")
                  if (b) {
                    T.geometry.type.match(/^Tube(Buffer)?Geometry$/) || (T.position.set(0, 0, 0), T.rotation.set(0, 0, 0), T.scale.set(1, 1, 1));
                    var M = Math.ceil(o(f) * 10) / 10, E = M / 2, A = new dt.TubeGeometry(b, x, E, r.linkResolution, !1);
                    T.geometry.dispose(), T.geometry = A;
                  } else {
                    if (!T.geometry.type.match(/^Cylinder(Buffer)?Geometry$/)) {
                      var N = Math.ceil(o(f) * 10) / 10, U = N / 2, k = new dt.CylinderGeometry(U, U, 1, r.linkResolution, 1, !1);
                      k[Wp](new dt.Matrix4().makeTranslation(0, 1 / 2, 0)), k[Wp](new dt.Matrix4().makeRotationX(Math.PI / 2)), T.geometry.dispose(), T.geometry = k;
                    }
                    var C = new dt.Vector3(v.x, v.y || 0, v.z || 0), I = new dt.Vector3(g.x, g.y || 0, g.z || 0), O = C.distanceTo(I);
                    T.position.x = C.x, T.position.y = C.y, T.position.z = C.z, T.scale.z = O, T.parent.localToWorld(I), T.lookAt(I);
                  }
              }
            }
          }
        });
        function h(d) {
          var p = e ? d : r.layout.getLinkPosition(r.layout.graph.getLink(d.source, d.target).id), f = p[e ? "source" : "from"], m = p[e ? "target" : "to"];
          if (!(!f || !m || !f.hasOwnProperty("x") || !m.hasOwnProperty("x"))) {
            var y = l(d);
            if (!y)
              d.__curve = null;
            else {
              var v = new dt.Vector3(f.x, f.y || 0, f.z || 0), g = new dt.Vector3(m.x, m.y || 0, m.z || 0), _ = v.distanceTo(g), x, b = u(d);
              if (_ > 0) {
                var T = m.x - f.x, S = m.y - f.y || 0, w = new dt.Vector3().subVectors(g, v), M = w.clone().multiplyScalar(y).cross(T !== 0 || S !== 0 ? new dt.Vector3(0, 0, 1) : new dt.Vector3(0, 1, 0)).applyAxisAngle(w.normalize(), b).add(new dt.Vector3().addVectors(v, g).divideScalar(2));
                x = new dt.QuadraticBezierCurve3(v, M, g);
              } else {
                var E = y * 70, A = -b, N = A + Math.PI / 2;
                x = new dt.CubicBezierCurve3(v, new dt.Vector3(E * Math.cos(N), E * Math.sin(N), 0).add(v), new dt.Vector3(E * Math.cos(A), E * Math.sin(A), 0).add(v), g);
              }
              d.__curve = x;
            }
          }
        }
      }
      function n() {
        var a = et(r.linkDirectionalArrowRelPos), o = et(r.linkDirectionalArrowLength), l = et(r.nodeVal);
        r.arrowDataMapper.entries().forEach(function(u) {
          var c = Qh(u, 2), h = c[0], d = c[1];
          if (d) {
            var p = e ? h : r.layout.getLinkPosition(r.layout.graph.getLink(h.source, h.target).id), f = p[e ? "source" : "from"], m = p[e ? "target" : "to"];
            if (!(!f || !m || !f.hasOwnProperty("x") || !m.hasOwnProperty("x"))) {
              var y = Math.cbrt(Math.max(0, l(f) || 1)) * r.nodeRelSize, v = Math.cbrt(Math.max(0, l(m) || 1)) * r.nodeRelSize, g = o(h), _ = a(h), x = h.__curve ? function(E) {
                return h.__curve.getPoint(E);
              } : function(E) {
                var A = function(N, U, k, C) {
                  return U[N] + (k[N] - U[N]) * C || 0;
                };
                return {
                  x: A("x", f, m, E),
                  y: A("y", f, m, E),
                  z: A("z", f, m, E)
                };
              }, b = h.__curve ? h.__curve.getLength() : Math.sqrt(["x", "y", "z"].map(function(E) {
                return Math.pow((m[E] || 0) - (f[E] || 0), 2);
              }).reduce(function(E, A) {
                return E + A;
              }, 0)), T = y + g + (b - y - v - g) * _, S = x(T / b), w = x((T - g) / b);
              ["x", "y", "z"].forEach(function(E) {
                return d.position[E] = w[E];
              });
              var M = AN(dt.Vector3, jn(["x", "y", "z"].map(function(E) {
                return S[E];
              })));
              d.parent.localToWorld(M), d.lookAt(M);
            }
          }
        });
      }
      function s() {
        var a = et(r.linkDirectionalParticleSpeed);
        r.graphData.links.forEach(function(o) {
          var l = r.particlesDataMapper.getObj(o), u = l && l.children, c = o.__singleHopPhotonsObj && o.__singleHopPhotonsObj.children;
          if (!((!c || !c.length) && (!u || !u.length))) {
            var h = e ? o : r.layout.getLinkPosition(r.layout.graph.getLink(o.source, o.target).id), d = h[e ? "source" : "from"], p = h[e ? "target" : "to"];
            if (!(!d || !p || !d.hasOwnProperty("x") || !p.hasOwnProperty("x"))) {
              var f = a(o), m = o.__curve ? function(v) {
                return o.__curve.getPoint(v);
              } : function(v) {
                var g = function(_, x, b, T) {
                  return x[_] + (b[_] - x[_]) * T || 0;
                };
                return {
                  x: g("x", d, p, v),
                  y: g("y", d, p, v),
                  z: g("z", d, p, v)
                };
              }, y = [].concat(jn(u || []), jn(c || []));
              y.forEach(function(v, g) {
                var _ = v.parent.__linkThreeObjType === "singleHopPhotons";
                if (v.hasOwnProperty("__progressRatio") || (v.__progressRatio = _ ? 0 : g / u.length), v.__progressRatio += f, v.__progressRatio >= 1)
                  if (!_)
                    v.__progressRatio = v.__progressRatio % 1;
                  else {
                    v.parent.remove(v), Qb(v);
                    return;
                  }
                var x = v.__progressRatio, b = m(x);
                ["x", "y", "z"].forEach(function(T) {
                  return v.position[T] = b[T];
                });
              });
            }
          }
        });
      }
    },
    emitParticle: function(r, e) {
      if (e && r.graphData.links.includes(e)) {
        if (!e.__singleHopPhotonsObj) {
          var i = new dt.Group();
          i.__linkThreeObjType = "singleHopPhotons", e.__singleHopPhotonsObj = i, r.graphScene.add(i);
        }
        var n = et(r.linkDirectionalParticleWidth), s = Math.ceil(n(e) * 10) / 10 / 2, a = r.linkDirectionalParticleResolution, o = new dt.SphereGeometry(s, a, a), l = et(r.linkColor), u = et(r.linkDirectionalParticleColor), c = u(e) || l(e) || "#f0f0f0", h = new dt.Color(mh(c)), d = r.linkOpacity * 3, p = new dt.MeshLambertMaterial({
          color: h,
          transparent: !0,
          opacity: d
        });
        e.__singleHopPhotonsObj.add(new dt.Mesh(o, p));
      }
      return this;
    },
    getGraphBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      };
      if (!r.initialised) return null;
      var i = function n(s) {
        var a = [];
        if (s.geometry) {
          s.geometry.computeBoundingBox();
          var o = new dt.Box3();
          o.copy(s.geometry.boundingBox).applyMatrix4(s.matrixWorld), a.push(o);
        }
        return a.concat.apply(a, jn((s.children || []).filter(
          function(l) {
            return !l.hasOwnProperty("__graphObjType") || l.__graphObjType === "node" && e(l.__data);
          }
          // exclude filtered out nodes
        ).map(n)));
      }(r.graphScene);
      return i.length ? Object.assign.apply(Object, jn(["x", "y", "z"].map(function(n) {
        return Ng({}, n, [Gb(i, function(s) {
          return s.min[n];
        }), Vb(i, function(s) {
          return s.max[n];
        })]);
      }))) : null;
    }
  },
  stateInit: function() {
    return {
      d3ForceLayout: HR().force("link", jR()).force("charge", WR()).force("center", DR()).force("dagRadial", null).stop(),
      engineRunning: !1
    };
  },
  init: function(r, e) {
    e.graphScene = r, e.nodeDataMapper = new fh(r, {
      objBindAttr: "__threeObj"
    }), e.linkDataMapper = new fh(r, {
      objBindAttr: "__lineObj"
    }), e.arrowDataMapper = new fh(r, {
      objBindAttr: "__arrowObj"
    }), e.particlesDataMapper = new fh(r, {
      objBindAttr: "__photonsObj"
    });
  },
  update: function(r, e) {
    var i = function(G) {
      return G.some(function(z) {
        return e.hasOwnProperty(z);
      });
    };
    if (r.engineRunning = !1, typeof r.onUpdate == "function" && r.onUpdate(), r.nodeAutoColorBy !== null && i(["nodeAutoColorBy", "graphData", "nodeColor"]) && ME(r.graphData.nodes, et(r.nodeAutoColorBy), r.nodeColor), r.linkAutoColorBy !== null && i(["linkAutoColorBy", "graphData", "linkColor"]) && ME(r.graphData.links, et(r.linkAutoColorBy), r.linkColor), r._flushObjects || i(["graphData", "nodeThreeObject", "nodeThreeObjectExtend", "nodeVal", "nodeColor", "nodeVisibility", "nodeRelSize", "nodeResolution", "nodeOpacity"])) {
      var n = et(r.nodeThreeObject), s = et(r.nodeThreeObjectExtend), a = et(r.nodeVal), o = et(r.nodeColor), l = et(r.nodeVisibility), u = {}, c = {};
      (r._flushObjects || i([
        // recreate objects if any of these props have changed
        "nodeThreeObject",
        "nodeThreeObjectExtend"
      ])) && r.nodeDataMapper.clear(), r.nodeDataMapper.onCreateObj(function(G) {
        var z = n(G), Y = s(G);
        z && r.nodeThreeObject === z && (z = z.clone());
        var se;
        return z && !Y ? se = z : (se = new dt.Mesh(), se.__graphDefaultObj = !0, z && Y && se.add(z)), se.__graphObjType = "node", se;
      }).onUpdateObj(function(G, z) {
        if (G.__graphDefaultObj) {
          var Y = a(z) || 1, se = Math.cbrt(Y) * r.nodeRelSize, ne = r.nodeResolution;
          (!G.geometry.type.match(/^Sphere(Buffer)?Geometry$/) || G.geometry.parameters.radius !== se || G.geometry.parameters.widthSegments !== ne) && (u.hasOwnProperty(Y) || (u[Y] = new dt.SphereGeometry(se, ne, ne)), G.geometry.dispose(), G.geometry = u[Y]);
          var fe = o(z), Se = new dt.Color(mh(fe || "#ffffaa")), Pe = r.nodeOpacity * f0(fe);
          (G.material.type !== "MeshLambertMaterial" || !G.material.color.equals(Se) || G.material.opacity !== Pe) && (c.hasOwnProperty(fe) || (c[fe] = new dt.MeshLambertMaterial({
            color: Se,
            transparent: !0,
            opacity: Pe
          })), G.material.dispose(), G.material = c[fe]);
        }
      }).digest(r.graphData.nodes.filter(l));
    }
    if (r._flushObjects || i(["graphData", "linkThreeObject", "linkThreeObjectExtend", "linkMaterial", "linkColor", "linkWidth", "linkVisibility", "linkResolution", "linkOpacity", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution"])) {
      var h = et(r.linkThreeObject), d = et(r.linkThreeObjectExtend), p = et(r.linkMaterial), f = et(r.linkVisibility), m = et(r.linkColor), y = et(r.linkWidth), v = {}, g = {}, _ = {}, x = r.graphData.links.filter(f);
      if ((r._flushObjects || i([
        // recreate objects if any of these props have changed
        "linkThreeObject",
        "linkThreeObjectExtend",
        "linkWidth"
      ])) && r.linkDataMapper.clear(), r.linkDataMapper.onRemoveObj(function(G) {
        var z = G.__data && G.__data.__singleHopPhotonsObj;
        z && (z.parent.remove(z), Qb(z), delete G.__data.__singleHopPhotonsObj);
      }).onCreateObj(function(G) {
        var z = h(G), Y = d(G);
        z && r.linkThreeObject === z && (z = z.clone());
        var se;
        if (!z || Y) {
          var ne = !!y(G);
          if (ne)
            se = new dt.Mesh();
          else {
            var fe = new dt.BufferGeometry();
            fe[m0]("position", new dt.BufferAttribute(new Float32Array(2 * 3), 3)), se = new dt.Line(fe);
          }
        }
        var Se;
        return z ? Y ? (Se = new dt.Group(), Se.__graphDefaultObj = !0, Se.add(se), Se.add(z)) : Se = z : (Se = se, Se.__graphDefaultObj = !0), Se.renderOrder = 10, Se.__graphObjType = "link", Se;
      }).onUpdateObj(function(G, z) {
        if (G.__graphDefaultObj) {
          var Y = G.children.length ? G.children[0] : G, se = Math.ceil(y(z) * 10) / 10, ne = !!se;
          if (ne) {
            var fe = se / 2, Se = r.linkResolution;
            if (!Y.geometry.type.match(/^Cylinder(Buffer)?Geometry$/) || Y.geometry.parameters.radiusTop !== fe || Y.geometry.parameters.radialSegments !== Se) {
              if (!v.hasOwnProperty(se)) {
                var Pe = new dt.CylinderGeometry(fe, fe, 1, Se, 1, !1);
                Pe[Wp](new dt.Matrix4().makeTranslation(0, 1 / 2, 0)), Pe[Wp](new dt.Matrix4().makeRotationX(Math.PI / 2)), v[se] = Pe;
              }
              Y.geometry.dispose(), Y.geometry = v[se];
            }
          }
          var lt = p(z);
          if (lt)
            Y.material = lt;
          else {
            var xe = m(z), vt = new dt.Color(mh(xe || "#f0f0f0")), Z = r.linkOpacity * f0(xe), Ht = ne ? "MeshLambertMaterial" : "LineBasicMaterial";
            if (Y.material.type !== Ht || !Y.material.color.equals(vt) || Y.material.opacity !== Z) {
              var nt = ne ? g : _;
              nt.hasOwnProperty(xe) || (nt[xe] = new dt[Ht]({
                color: vt,
                transparent: Z < 1,
                opacity: Z,
                depthWrite: Z >= 1
                // Prevent transparency issues
              })), Y.material.dispose(), Y.material = nt[xe];
            }
          }
        }
      }).digest(x), r.linkDirectionalArrowLength || e.hasOwnProperty("linkDirectionalArrowLength")) {
        var b = et(r.linkDirectionalArrowLength), T = et(r.linkDirectionalArrowColor);
        r.arrowDataMapper.onCreateObj(function() {
          var G = new dt.Mesh(void 0, new dt.MeshLambertMaterial({
            transparent: !0
          }));
          return G.__linkThreeObjType = "arrow", G;
        }).onUpdateObj(function(G, z) {
          var Y = b(z), se = r.linkDirectionalArrowResolution;
          if (!G.geometry.type.match(/^Cone(Buffer)?Geometry$/) || G.geometry.parameters.height !== Y || G.geometry.parameters.radialSegments !== se) {
            var ne = new dt.ConeGeometry(Y * 0.25, Y, se);
            ne.translate(0, Y / 2, 0), ne.rotateX(Math.PI / 2), G.geometry.dispose(), G.geometry = ne;
          }
          var fe = T(z) || m(z) || "#f0f0f0";
          G.material.color = new dt.Color(mh(fe)), G.material.opacity = r.linkOpacity * 3 * f0(fe);
        }).digest(x.filter(b));
      }
      if (r.linkDirectionalParticles || e.hasOwnProperty("linkDirectionalParticles")) {
        var S = et(r.linkDirectionalParticles), w = et(r.linkDirectionalParticleWidth), M = et(r.linkDirectionalParticleColor), E = {}, A = {};
        r.particlesDataMapper.onCreateObj(function() {
          var G = new dt.Group();
          return G.__linkThreeObjType = "photons", G.__photonDataMapper = new fh(G), G;
        }).onUpdateObj(function(G, z) {
          var Y = Math.round(Math.abs(S(z))), se = !!G.children.length && G.children[0], ne = Math.ceil(w(z) * 10) / 10 / 2, fe = r.linkDirectionalParticleResolution, Se;
          se && se.geometry.parameters.radius === ne && se.geometry.parameters.widthSegments === fe ? Se = se.geometry : (A.hasOwnProperty(ne) || (A[ne] = new dt.SphereGeometry(ne, fe, fe)), Se = A[ne], se && se.geometry.dispose());
          var Pe = M(z) || m(z) || "#f0f0f0", lt = new dt.Color(mh(Pe)), xe = r.linkOpacity * 3, vt;
          se && se.material.color.equals(lt) && se.material.opacity === xe ? vt = se.material : (E.hasOwnProperty(Pe) || (E[Pe] = new dt.MeshLambertMaterial({
            color: lt,
            transparent: !0,
            opacity: xe
          })), vt = E[Pe], se && se.material.dispose()), G.__photonDataMapper.id(function(Z) {
            return Z.idx;
          }).onCreateObj(function() {
            return new dt.Mesh(Se, vt);
          }).onUpdateObj(function(Z) {
            Z.geometry = Se, Z.material = vt;
          }).digest(jn(new Array(Y)).map(function(Z, Ht) {
            return {
              idx: Ht
            };
          }));
        }).digest(x.filter(S));
      }
    }
    if (r._flushObjects = !1, i(["graphData", "nodeId", "linkSource", "linkTarget", "numDimensions", "forceEngine", "dagMode", "dagNodeFilter", "dagLevelDistance"])) {
      r.engineRunning = !1, r.graphData.links.forEach(function(G) {
        G.source = G[r.linkSource], G.target = G[r.linkTarget];
      });
      var N = r.forceEngine !== "ngraph", U;
      if (N) {
        (U = r.d3ForceLayout).stop().alpha(1).numDimensions(r.numDimensions).nodes(r.graphData.nodes);
        var k = r.d3ForceLayout.force("link");
        k && k.id(function(G) {
          return G[r.nodeId];
        }).links(r.graphData.links);
        var C = r.dagMode && g9(r.graphData, function(G) {
          return G[r.nodeId];
        }, {
          nodeFilter: r.dagNodeFilter,
          onLoopError: r.onDagError || void 0
        }), I = Math.max.apply(Math, jn(Object.values(C || []))), O = r.dagLevelDistance || r.graphData.nodes.length / (I || 1) * y9 * (["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? 0.7 : 1);
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(e.dagMode)) {
          var W = ["lr", "rl"].includes(e.dagMode) ? "fx" : ["td", "bu"].includes(e.dagMode) ? "fy" : "fz";
          r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(G) {
            return delete G[W];
          });
        }
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(r.dagMode)) {
          var V = ["rl", "td", "zout"].includes(r.dagMode), Q = function(G) {
            return (C[G[r.nodeId]] - I / 2) * O * (V ? -1 : 1);
          }, F = ["lr", "rl"].includes(r.dagMode) ? "fx" : ["td", "bu"].includes(r.dagMode) ? "fy" : "fz";
          r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(G) {
            return G[F] = Q(G);
          });
        }
        r.d3ForceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? qR(function(G) {
          var z = C[G[r.nodeId]] || -1;
          return (r.dagMode === "radialin" ? I - z : z) * O;
        }).strength(function(G) {
          return r.dagNodeFilter(G) ? 1 : 0;
        }) : null);
      } else {
        var B = AE.graph();
        r.graphData.nodes.forEach(function(G) {
          B.addNode(G[r.nodeId]);
        }), r.graphData.links.forEach(function(G) {
          B.addLink(G.source, G.target);
        }), U = AE.forcelayout(B, h9({
          dimensions: r.numDimensions
        }, r.ngraphPhysics)), U.graph = B;
      }
      for (var q = 0; q < r.warmupTicks && !(N && r.d3AlphaMin > 0 && r.d3ForceLayout.alpha() < r.d3AlphaMin); q++)
        U[N ? "tick" : "step"]();
      r.layout = U, this.resetCountdown();
    }
    r.engineRunning = !0, r.onFinishUpdate();
  }
});
function b9(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = /* @__PURE__ */ function(s) {
    function a() {
      var o;
      MN(this, a);
      for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
        u[c] = arguments[c];
      return o = EN(this, a, [].concat(u)), o.__kapsuleInstance = AN(r, [].concat(jn(i ? [o] : []), u)), o;
    }
    return RN(a, s), CN(a);
  }(e);
  return Object.keys(r()).forEach(function(s) {
    return n.prototype[s] = function() {
      var a, o = (a = this.__kapsuleInstance)[s].apply(a, arguments);
      return o === this.__kapsuleInstance ? this : o;
    };
  }), n;
}
var x9 = window.THREE ? window.THREE : {
  Group: sl
}, Ou = b9(v9, x9.Group, !0);
if (typeof AFRAME > "u")
  throw new Error("Component attempted to register before AFRAME was available.");
var g0 = function(r) {
  return typeof r == "string" ? JSON.parse(r) : r;
}, kn = function(r) {
  if (typeof r == "function") return r;
  var e = eval;
  try {
    var i = e("(" + r + ")");
    return i;
  } catch {
  }
  return null;
}, Ti = function(r) {
  return isNaN(parseFloat(r)) ? kn(r) ? kn(r) : r : parseFloat(r);
};
AFRAME.components.hasOwnProperty("forcegraph") || AFRAME.registerComponent("forcegraph", {
  schema: {
    jsonUrl: {
      type: "string",
      default: ""
    },
    nodes: {
      parse: g0,
      default: []
    },
    links: {
      parse: g0,
      default: []
    },
    numDimensions: {
      type: "number",
      default: 3
    },
    dagMode: {
      type: "string",
      default: ""
    },
    dagLevelDistance: {
      type: "number",
      default: 0
    },
    dagNodeFilter: {
      parse: kn,
      default: function() {
        return !0;
      }
    },
    onDagError: {
      parse: kn,
      default: void 0
    },
    nodeRelSize: {
      type: "number",
      default: 4
    },
    // volume per val unit
    nodeId: {
      type: "string",
      default: "id"
    },
    nodeVal: {
      parse: Ti,
      default: "val"
    },
    nodeResolution: {
      type: "number",
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeVisibility: {
      parse: Ti,
      default: !0
    },
    nodeColor: {
      parse: Ti,
      default: "color"
    },
    nodeAutoColorBy: {
      parse: Ti,
      default: ""
    },
    // color nodes with the same field equally
    nodeOpacity: {
      type: "number",
      default: 0.75
    },
    nodeThreeObject: {
      parse: Ti,
      default: null
    },
    nodeThreeObjectExtend: {
      parse: Ti,
      default: !1
    },
    linkSource: {
      type: "string",
      default: "source"
    },
    linkTarget: {
      type: "string",
      default: "target"
    },
    linkVisibility: {
      parse: Ti,
      default: !0
    },
    linkColor: {
      parse: Ti,
      default: "color"
    },
    linkAutoColorBy: {
      parse: Ti,
      default: ""
    },
    // color links with the same field equally
    linkOpacity: {
      type: "number",
      default: 0.2
    },
    linkWidth: {
      parse: Ti,
      default: 0
    },
    linkResolution: {
      type: "number",
      default: 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      parse: Ti,
      default: 0
    },
    linkCurveRotation: {
      parse: Ti,
      default: 0
    },
    linkMaterial: {
      parse: Ti,
      default: null
    },
    linkThreeObject: {
      parse: Ti,
      default: null
    },
    linkThreeObjectExtend: {
      parse: Ti,
      default: !1
    },
    linkPositionUpdate: {
      parse: kn,
      default: null
    },
    linkDirectionalArrowLength: {
      parse: Ti,
      default: 0
    },
    linkDirectionalArrowColor: {
      parse: Ti,
      default: null
    },
    linkDirectionalArrowRelPos: {
      parse: Ti,
      default: 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      type: "number",
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      parse: Ti,
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      parse: Ti,
      default: 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      parse: Ti,
      default: 0.5
    },
    linkDirectionalParticleColor: {
      parse: Ti,
      default: null
    },
    linkDirectionalParticleResolution: {
      type: "number",
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    onNodeHover: {
      parse: kn,
      default: function() {
      }
    },
    onLinkHover: {
      parse: kn,
      default: function() {
      }
    },
    onNodeClick: {
      parse: kn,
      default: function() {
      }
    },
    onLinkClick: {
      parse: kn,
      default: function() {
      }
    },
    forceEngine: {
      type: "string",
      default: "d3"
    },
    // 'd3' or 'ngraph'
    d3AlphaMin: {
      type: "number",
      default: 0
    },
    d3AlphaDecay: {
      type: "number",
      default: 0.0228
    },
    d3VelocityDecay: {
      type: "number",
      default: 0.4
    },
    ngraphPhysics: {
      parse: g0,
      default: null
    },
    warmupTicks: {
      type: "int",
      default: 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      type: "int",
      default: 1e18
    },
    // Simulate infinity (int parser doesn't accept Infinity object)
    cooldownTime: {
      type: "int",
      default: 15e3
    },
    // ms
    onEngineTick: {
      parse: kn,
      default: function() {
      }
    },
    onEngineStop: {
      parse: kn,
      default: function() {
      }
    }
  },
  // Bind component methods
  getGraphBbox: function(r) {
    return this.forceGraph || (this.forceGraph = new Ou()), this.forceGraph.getGraphBbox(r);
  },
  emitParticle: function() {
    this.forceGraph || (this.forceGraph = new Ou());
    var r = this.forceGraph, e = r.emitParticle.apply(r, arguments);
    return e === r ? this : e;
  },
  d3Force: function() {
    this.forceGraph || (this.forceGraph = new Ou());
    var r = this.forceGraph, e = r.d3Force.apply(r, arguments);
    return e === r ? this : e;
  },
  d3ReheatSimulation: function() {
    return this.forceGraph && this.forceGraph.d3ReheatSimulation(), this;
  },
  refresh: function() {
    return this.forceGraph && this.forceGraph.refresh(), this;
  },
  init: function() {
    var r = this, e = this.state = {};
    e.infoEl = document.createElement("a-text"), e.infoEl.setAttribute("position", "0 -0.1 -1"), e.infoEl.setAttribute("width", 1), e.infoEl.setAttribute("align", "center"), e.infoEl.setAttribute("color", "lavender");
    var i = document.querySelector("a-entity[camera], a-camera");
    i.appendChild(e.infoEl), e.cameraObj = i.object3D.children.filter(function(n) {
      return n.type === "PerspectiveCamera";
    })[0], this.el.sceneEl.addEventListener("camera-set-active", function(n) {
      e.cameraObj = n.detail.cameraEl.components.camera.camera;
    }), this.forceGraph || (this.forceGraph = new Ou()), this.forceGraph.onFinishUpdate(function() {
      return r.el.setObject3D("forcegraphGroup", r.forceGraph);
    }).onLoading(function() {
      return e.infoEl.setAttribute("value", "Loading...");
    }).onFinishLoading(function() {
      return e.infoEl.setAttribute("value", "");
    }), this.el.addEventListener("raycaster-intersected", function(n) {
      return e.hoverDetail = n.detail;
    }), this.el.addEventListener("raycaster-intersected-cleared", function(n) {
      return e.hoverDetail = n.detail;
    }), this.el.addEventListener("click", function() {
      return e.hoverObj && r.data["on" + (e.hoverObj.__graphObjType === "node" ? "Node" : "Link") + "Click"](e.hoverObj.__data);
    });
  },
  remove: function() {
    this.state.infoEl.remove(), this.el.removeObject3D("forcegraphGroup");
  },
  update: function(r) {
    var e = this, i = this.data, n = AFRAME.utils.diff(i, r), s = ["jsonUrl", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeVisibility", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "forceEngine", "d3AlphaMin", "d3AphaDecay", "d3VelocityDecay", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"];
    s.filter(function(a) {
      return a in n;
    }).forEach(function(a) {
      e.forceGraph[a](i[a] !== "" ? i[a] : null);
    }), ("nodes" in n || "links" in n) && e.forceGraph.graphData({
      nodes: i.nodes,
      links: i.links
    });
  },
  tick: function(r, e) {
    for (var i = this.state, n = this.data, s = i.hoverDetail ? i.hoverDetail.getIntersection ? i.hoverDetail.getIntersection(this.el) : i.hoverDetail.intersection || void 0 : void 0, a = s ? s.object : void 0; a && !a.hasOwnProperty("__graphObjType"); ) a = a.parent;
    if (a !== i.hoverObj) {
      var o = i.hoverObj ? i.hoverObj.__graphObjType : null, l = i.hoverObj ? i.hoverObj.__data : null, u = a ? a.__graphObjType : null, c = a ? a.__data : null;
      o && o !== u && n["on" + (o === "node" ? "Node" : "Link") + "Hover"](null, l), u && n["on" + (u === "node" ? "Node" : "Link") + "Hover"](c, o === u ? l : null), i.hoverObj = a;
    }
    this.forceGraph.tickFrame();
  }
});
function Jb(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function _9(r) {
  if (Array.isArray(r)) return r;
}
function T9(r) {
  if (Array.isArray(r)) return Jb(r);
}
function em(r, e, i) {
  return (e = C9(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function S9(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function w9(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function E9() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function M9() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function CE(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function RE(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? CE(Object(i), !0).forEach(function(n) {
      em(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : CE(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function qp(r, e) {
  return _9(r) || w9(r, e) || DN(r, e) || E9();
}
function Xp(r) {
  return T9(r) || S9(r) || DN(r) || M9();
}
function A9(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function C9(r) {
  var e = A9(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function DN(r, e) {
  if (r) {
    if (typeof r == "string") return Jb(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Jb(r, e) : void 0;
  }
}
var R9 = Pl({
  props: {
    width: {},
    height: {},
    yOffset: {
      default: 1.5
    },
    // marker size units
    glScale: {
      default: 200
    },
    // gl units per marker width
    jsonUrl: {},
    graphData: {
      default: {
        nodes: [],
        links: []
      }
    },
    numDimensions: {
      default: 3
    },
    dagMode: {},
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function() {
        return !0;
      }
    },
    onDagError: {
      default: void 0
    },
    nodeRelSize: {
      default: 4
    },
    // volume per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val"
    },
    nodeResolution: {
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeVisibility: {
      default: !0
    },
    nodeColor: {
      default: "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      default: 0.75
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      default: !1
    },
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0
    },
    linkColor: {
      default: "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      default: 0.2
    },
    linkWidth: {
      default: 0
    },
    linkResolution: {
      default: 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      default: 0
    },
    linkCurveRotation: {
      default: 0
    },
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      default: !1
    },
    linkPositionUpdate: {},
    linkDirectionalArrowLength: {
      default: 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      default: 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    onNodeHover: {},
    onNodeClick: {},
    onLinkHover: {},
    onLinkClick: {},
    forceEngine: {
      default: "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      default: 0
    },
    d3AlphaDecay: {
      default: 0.0228
    },
    d3VelocityDecay: {
      default: 0.4
    },
    ngraphPhysics: {},
    warmupTicks: {
      default: 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {},
    cooldownTime: {
      default: 15e3
    },
    // ms
    onEngineTick: {},
    onEngineStop: {}
  },
  methods: RE(RE({}, Object.assign.apply(Object, [{}].concat(Xp(["getGraphBbox", "emitParticle", "d3Force", "d3ReheatSimulation", "refresh"].map(function(r) {
    return em({}, r, function(e) {
      for (var i = e.forcegraph.components.forcegraph, n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
        s[a - 1] = arguments[a];
      var o = i[r].apply(i, s);
      return o === i ? this : o;
    });
  }))))), {}, {
    _destructor: function() {
      this.graphData({
        nodes: [],
        links: []
      });
    }
  }),
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.markerAttrs, s = n === void 0 ? {
      preset: "hiro"
    } : n;
    r.innerHTML = "", e.container = document.createElement("div"), r.appendChild(e.container);
    var a = document.createElement("a-scene");
    a.setAttribute("embedded", ""), a.setAttribute("vr-mode-ui", "enabled: false"), a.setAttribute("arjs", "debugUIEnabled: false;");
    var o = document.createElement("a-marker");
    Object.entries(s).forEach(function(c) {
      var h = qp(c, 2), d = h[0], p = h[1];
      return o.setAttribute(d, p);
    }), a.appendChild(o);
    var l;
    a.appendChild(l = document.createElement("a-entity")), l.setAttribute(
      "cursor"
      /*, 'rayOrigin: mouse'*/
    ), l.setAttribute("raycaster", "objects: [forcegraph]"), e.forcegraph = document.createElement("a-entity"), e.forcegraph.setAttribute("forcegraph", null), o.appendChild(e.forcegraph);
    var u = document.createElement("a-entity");
    u.setAttribute("camera", ""), a.appendChild(u), e.container.appendChild(a);
  },
  update: function(r, e) {
    e.hasOwnProperty("width") && r.width && (r.container.style.width = "".concat(r.width, "px")), e.hasOwnProperty("height") && r.height && (r.container.style.height = "".concat(r.height, "px")), e.hasOwnProperty("glScale") && r.forcegraph.setAttribute("scale", Xp(new Array(3)).map(function() {
      return 1 / r.glScale;
    }).join(" ")), e.hasOwnProperty("yOffset") && r.forcegraph.setAttribute("position", "0 ".concat(r.yOffset, " 0"));
    var i = ["jsonUrl", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeVisibility", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "onNodeHover", "onNodeClick", "onLinkHover", "onLinkClick", "forceEngine", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"], n = Object.assign.apply(Object, [{}].concat(Xp(Object.entries(r).filter(function(s) {
      var a = qp(s, 2), o = a[0], l = a[1];
      return e.hasOwnProperty(o) && i.indexOf(o) !== -1 && l !== void 0 && l !== null;
    }).map(function(s) {
      var a = qp(s, 2), o = a[0], l = a[1];
      return em({}, o, l);
    })), Xp(Object.entries(r.graphData).map(function(s) {
      var a = qp(s, 2), o = a[0], l = a[1];
      return em({}, o, l);
    }))));
    r.forcegraph.setAttribute("forcegraph", n);
  }
});
const Xu = new qs(), Qs = new ke(), LN = new X(), y0 = new ke(), tm = new ke(), Nm = new X(), ex = new X(), kN = new ui(), UN = new X(), FN = new X();
let Dr = null, ns = null;
const Js = [], uo = {
  NONE: -1,
  PAN: 0,
  ROTATE: 1
};
class N9 extends Ag {
  constructor(e, i, n = null) {
    super(i, n), this.objects = e, this.recursive = !0, this.transformGroup = !1, this.rotateSpeed = 1, this.raycaster = new OR(), this.mouseButtons = { LEFT: tr.PAN, MIDDLE: tr.PAN, RIGHT: tr.ROTATE }, this.touches = { ONE: ia.PAN }, this._onPointerMove = P9.bind(this), this._onPointerDown = I9.bind(this), this._onPointerCancel = O9.bind(this), this._onContextMenu = D9.bind(this), n !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointerup", this._onPointerCancel), this.domElement.addEventListener("pointerleave", this._onPointerCancel), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointerup", this._onPointerCancel), this.domElement.removeEventListener("pointerleave", this._onPointerCancel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "auto", this.domElement.style.cursor = "";
  }
  dispose() {
    this.disconnect();
  }
  _updatePointer(e) {
    const i = this.domElement.getBoundingClientRect();
    Qs.x = (e.clientX - i.left) / i.width * 2 - 1, Qs.y = -(e.clientY - i.top) / i.height * 2 + 1;
  }
  _updateState(e) {
    let i;
    if (e.pointerType === "touch")
      i = this.touches.ONE;
    else
      switch (e.button) {
        case 0:
          i = this.mouseButtons.LEFT;
          break;
        case 1:
          i = this.mouseButtons.MIDDLE;
          break;
        case 2:
          i = this.mouseButtons.RIGHT;
          break;
        default:
          i = null;
      }
    switch (i) {
      case tr.PAN:
      case ia.PAN:
        this.state = uo.PAN;
        break;
      case tr.ROTATE:
      case ia.ROTATE:
        this.state = uo.ROTATE;
        break;
      default:
        this.state = uo.NONE;
    }
  }
  getRaycaster() {
    return console.warn("THREE.DragControls: getRaycaster() has been deprecated. Use controls.raycaster instead."), this.raycaster;
  }
  setObjects(e) {
    console.warn("THREE.DragControls: setObjects() has been deprecated. Use controls.objects instead."), this.objects = e;
  }
  getObjects() {
    return console.warn("THREE.DragControls: getObjects() has been deprecated. Use controls.objects instead."), this.objects;
  }
  activate() {
    console.warn("THREE.DragControls: activate() has been renamed to connect()."), this.connect();
  }
  deactivate() {
    console.warn("THREE.DragControls: deactivate() has been renamed to disconnect()."), this.disconnect();
  }
  set mode(e) {
    console.warn("THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.");
  }
  get mode() {
    console.warn("THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.");
  }
}
function P9(r) {
  const e = this.object, i = this.domElement, n = this.raycaster;
  if (this.enabled !== !1) {
    if (this._updatePointer(r), n.setFromCamera(Qs, e), Dr)
      this.state === uo.PAN ? n.ray.intersectPlane(Xu, Nm) && Dr.position.copy(Nm.sub(LN).applyMatrix4(kN)) : this.state === uo.ROTATE && (y0.subVectors(Qs, tm).multiplyScalar(this.rotateSpeed), Dr.rotateOnWorldAxis(UN, y0.x), Dr.rotateOnWorldAxis(FN.normalize(), -y0.y)), this.dispatchEvent({ type: "drag", object: Dr }), tm.copy(Qs);
    else if (r.pointerType === "mouse" || r.pointerType === "pen")
      if (Js.length = 0, n.setFromCamera(Qs, e), n.intersectObjects(this.objects, this.recursive, Js), Js.length > 0) {
        const s = Js[0].object;
        Xu.setFromNormalAndCoplanarPoint(e.getWorldDirection(Xu.normal), ex.setFromMatrixPosition(s.matrixWorld)), ns !== s && ns !== null && (this.dispatchEvent({ type: "hoveroff", object: ns }), i.style.cursor = "auto", ns = null), ns !== s && (this.dispatchEvent({ type: "hoveron", object: s }), i.style.cursor = "pointer", ns = s);
      } else
        ns !== null && (this.dispatchEvent({ type: "hoveroff", object: ns }), i.style.cursor = "auto", ns = null);
    tm.copy(Qs);
  }
}
function I9(r) {
  const e = this.object, i = this.domElement, n = this.raycaster;
  this.enabled !== !1 && (this._updatePointer(r), this._updateState(r), Js.length = 0, n.setFromCamera(Qs, e), n.intersectObjects(this.objects, this.recursive, Js), Js.length > 0 && (this.transformGroup === !0 ? Dr = BN(Js[0].object) : Dr = Js[0].object, Xu.setFromNormalAndCoplanarPoint(e.getWorldDirection(Xu.normal), ex.setFromMatrixPosition(Dr.matrixWorld)), n.ray.intersectPlane(Xu, Nm) && (this.state === uo.PAN ? (kN.copy(Dr.parent.matrixWorld).invert(), LN.copy(Nm).sub(ex.setFromMatrixPosition(Dr.matrixWorld))) : this.state === uo.ROTATE && (UN.set(0, 1, 0).applyQuaternion(e.quaternion).normalize(), FN.set(1, 0, 0).applyQuaternion(e.quaternion).normalize())), i.style.cursor = "move", this.dispatchEvent({ type: "dragstart", object: Dr })), tm.copy(Qs));
}
function O9() {
  this.enabled !== !1 && (Dr && (this.dispatchEvent({ type: "dragend", object: Dr }), Dr = null), this.domElement.style.cursor = ns ? "pointer" : "auto", this.state = uo.NONE);
}
function D9(r) {
  this.enabled !== !1 && r.preventDefault();
}
function BN(r, e = null) {
  return r.isGroup && (e = r), r.parent === null ? e : BN(r.parent, e);
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Pg = "170", L9 = 0, k9 = 1, U9 = 2, F9 = 1, $p = 3, bc = 0, Zn = 1, $u = 2, xc = 0, co = 1, Pm = 2, Im = 3, Om = 4, zN = 5, Ja = 100, jN = 101, VN = 102, B9 = 103, z9 = 104, GN = 200, HN = 201, WN = 202, qN = 203, Dm = 204, Lm = 205, XN = 206, $N = 207, YN = 208, KN = 209, ZN = 210, QN = 0, JN = 1, eP = 2, km = 3, tP = 4, iP = 5, rP = 6, nP = 7, Ig = 0, j9 = 1, V9 = 2, Yu = 0, G9 = 1, H9 = 2, W9 = 3, q9 = 4, X9 = 6, $9 = 7, o1 = 300, Tl = 301, _c = 302, $d = 303, Yd = 304, tx = 306, Um = 1e3, Du = 1001, Fm = 1002, mr = 1003, ix = 1004, Ku = 1005, on = 1006, rx = 1007, da = 1008, ho = 1009, Jh = 1010, ed = 1011, Lu = 1012, Tr = 1013, Ji = 1014, an = 1015, pa = 1016, Y9 = 1017, K9 = 1018, Kd = 1020, sP = 35902, Z9 = 1021, l1 = 1022, Bc = 1023, Q9 = 1024, J9 = 1025, gl = 1026, Tc = 1027, u1 = 1028, c1 = 1029, yd = 1030, h1 = 1031, e7 = 1032, d1 = 1033, v0 = 33776, im = 33777, rm = 33778, nm = 33779, NE = 35840, PE = 35841, IE = 35842, OE = 35843, DE = 36196, nx = 37492, sx = 37496, ax = 37808, ox = 37809, lx = 37810, ux = 37811, cx = 37812, hx = 37813, dx = 37814, px = 37815, fx = 37816, mx = 37817, gx = 37818, yx = 37819, vx = 37820, bx = 37821, b0 = 36492, t7 = 36283, LE = 36284, kE = 36285, UE = 36286, vo = 0, i7 = 1, Sl = "", ct = "srgb", po = "srgb-linear", aP = "linear", vd = "srgb", r7 = 0, Go = 7680, n7 = 7681, s7 = 7682, a7 = 7683, o7 = 34055, l7 = 34056, u7 = 5386, c7 = 512, h7 = 513, d7 = 514, p7 = 515, f7 = 516, m7 = 517, g7 = 518, xx = 519, oP = 512, p1 = 513, lP = 514, uP = 515, cP = 516, hP = 517, dP = 518, pP = 519, Bm = 35044, ku = 35048, Yn = 2e3, wl = 2001;
class zc {
  addEventListener(e, i) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(i) === -1 && n[e].push(i);
  }
  hasEventListener(e, i) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(i) !== -1;
  }
  removeEventListener(e, i) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const s = n.indexOf(i);
      s !== -1 && n.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const n = i.slice(0);
      for (let s = 0, a = n.length; s < a; s++)
        n[s].call(this, e);
      e.target = null;
    }
  }
}
const cr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let FE = 1234567;
const td = Math.PI / 180, bd = 180 / Math.PI;
function fa() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (cr[r & 255] + cr[r >> 8 & 255] + cr[r >> 16 & 255] + cr[r >> 24 & 255] + "-" + cr[e & 255] + cr[e >> 8 & 255] + "-" + cr[e >> 16 & 15 | 64] + cr[e >> 24 & 255] + "-" + cr[i & 63 | 128] + cr[i >> 8 & 255] + "-" + cr[i >> 16 & 255] + cr[i >> 24 & 255] + cr[n & 255] + cr[n >> 8 & 255] + cr[n >> 16 & 255] + cr[n >> 24 & 255]).toLowerCase();
}
function er(r, e, i) {
  return Math.max(e, Math.min(i, r));
}
function f1(r, e) {
  return (r % e + e) % e;
}
function y7(r, e, i, n, s) {
  return n + (r - e) * (s - n) / (i - e);
}
function v7(r, e, i) {
  return r !== e ? (i - r) / (e - r) : 0;
}
function id(r, e, i) {
  return (1 - i) * r + i * e;
}
function b7(r, e, i, n) {
  return id(r, e, 1 - Math.exp(-i * n));
}
function x7(r, e = 1) {
  return e - Math.abs(f1(r, e * 2) - e);
}
function _7(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * (3 - 2 * r));
}
function T7(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * r * (r * (r * 6 - 15) + 10));
}
function S7(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function w7(r, e) {
  return r + Math.random() * (e - r);
}
function E7(r) {
  return r * (0.5 - Math.random());
}
function M7(r) {
  r !== void 0 && (FE = r);
  let e = FE += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function A7(r) {
  return r * td;
}
function C7(r) {
  return r * bd;
}
function R7(r) {
  return (r & r - 1) === 0 && r !== 0;
}
function N7(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function P7(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function I7(r, e, i, n, s) {
  const a = Math.cos, o = Math.sin, l = a(i / 2), u = o(i / 2), c = a((e + n) / 2), h = o((e + n) / 2), d = a((e - n) / 2), p = o((e - n) / 2), f = a((n - e) / 2), m = o((n - e) / 2);
  switch (s) {
    case "XYX":
      r.set(l * h, u * d, u * p, l * c);
      break;
    case "YZY":
      r.set(u * p, l * h, u * d, l * c);
      break;
    case "ZXZ":
      r.set(u * d, u * p, l * h, l * c);
      break;
    case "XZX":
      r.set(l * h, u * m, u * f, l * c);
      break;
    case "YXY":
      r.set(u * f, l * h, u * m, l * c);
      break;
    case "ZYZ":
      r.set(u * m, u * f, l * h, l * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function Er(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function wt(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const O7 = {
  DEG2RAD: td,
  RAD2DEG: bd,
  generateUUID: fa,
  clamp: er,
  euclideanModulo: f1,
  mapLinear: y7,
  inverseLerp: v7,
  lerp: id,
  damp: b7,
  pingpong: x7,
  smoothstep: _7,
  smootherstep: T7,
  randInt: S7,
  randFloat: w7,
  randFloatSpread: E7,
  seededRandom: M7,
  degToRad: A7,
  radToDeg: C7,
  isPowerOfTwo: R7,
  ceilPowerOfTwo: N7,
  floorPowerOfTwo: P7,
  setQuaternionFromProperEuler: I7,
  normalize: wt,
  denormalize: Er
};
class Vt {
  constructor(e = 0, i = 0) {
    Vt.prototype.isVector2 = !0, this.x = e, this.y = i;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, i) {
    return this.x = e, this.y = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * i + s[3] * n + s[6], this.y = s[1] * i + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(er(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y;
    return i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this;
  }
  rotateAround(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = this.x - e.x, o = this.y - e.y;
    return this.x = a * n - o * s + e.x, this.y = a * s + o * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class qr {
  constructor(e, i, n, s, a, o, l, u, c) {
    qr.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c);
  }
  set(e, i, n, s, a, o, l, u, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = l, h[3] = i, h[4] = a, h[5] = u, h[6] = n, h[7] = o, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrix3Column(this, 0), i.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[4],
      i[8],
      i[1],
      i[5],
      i[9],
      i[2],
      i[6],
      i[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[3], u = n[6], c = n[1], h = n[4], d = n[7], p = n[2], f = n[5], m = n[8], y = s[0], v = s[3], g = s[6], _ = s[1], x = s[4], b = s[7], T = s[2], S = s[5], w = s[8];
    return a[0] = o * y + l * _ + u * T, a[3] = o * v + l * x + u * S, a[6] = o * g + l * b + u * w, a[1] = c * y + h * _ + d * T, a[4] = c * v + h * x + d * S, a[7] = c * g + h * b + d * w, a[2] = p * y + f * _ + m * T, a[5] = p * v + f * x + m * S, a[8] = p * g + f * b + m * w, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= e, i[4] *= e, i[7] *= e, i[2] *= e, i[5] *= e, i[8] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8];
    return i * o * h - i * l * c - n * a * h + n * l * u + s * a * c - s * o * u;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = h * o - l * c, p = l * u - h * a, f = c * a - o * u, m = i * d + n * p + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const y = 1 / m;
    return e[0] = d * y, e[1] = (s * c - h * n) * y, e[2] = (l * n - s * o) * y, e[3] = p * y, e[4] = (h * i - s * u) * y, e[5] = (s * a - l * i) * y, e[6] = f * y, e[7] = (n * u - c * i) * y, e[8] = (o * i - n * a) * y, this;
  }
  transpose() {
    let e;
    const i = this.elements;
    return e = i[1], i[1] = i[3], i[3] = e, e = i[2], i[2] = i[6], i[6] = e, e = i[5], i[5] = i[7], i[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const i = this.elements;
    return e[0] = i[0], e[1] = i[3], e[2] = i[6], e[3] = i[1], e[4] = i[4], e[5] = i[7], e[6] = i[2], e[7] = i[5], e[8] = i[8], this;
  }
  setUvTransform(e, i, n, s, a, o, l) {
    const u = Math.cos(a), c = Math.sin(a);
    return this.set(
      n * u,
      n * c,
      -n * (u * o + c * l) + o + e,
      -s * c,
      s * u,
      -s * (-c * o + u * l) + l + i,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, i) {
    return this.premultiply(x0.makeScale(e, i)), this;
  }
  rotate(e) {
    return this.premultiply(x0.makeRotation(-e)), this;
  }
  translate(e, i) {
    return this.premultiply(x0.makeTranslation(e, i)), this;
  }
  // for 2D Transforms
  makeTranslation(e, i) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      i,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      n,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i) {
    return this.set(
      e,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const x0 = /* @__PURE__ */ new qr();
function D7(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function _x(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function L7() {
  const r = _x("canvas");
  return r.style.display = "block", r;
}
const BE = {};
function k7(r) {
  r in BE || (BE[r] = !0, console.warn(r));
}
const Li = {
  enabled: !0,
  workingColorSpace: po,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(r, e, i) {
    return this.enabled === !1 || e === i || !e || !i || (this.spaces[e].transfer === vd && (r.r = ma(r.r), r.g = ma(r.g), r.b = ma(r.b)), this.spaces[e].primaries !== this.spaces[i].primaries && (r.applyMatrix3(this.spaces[e].toXYZ), r.applyMatrix3(this.spaces[i].fromXYZ)), this.spaces[i].transfer === vd && (r.r = Zu(r.r), r.g = Zu(r.g), r.b = Zu(r.b))), r;
  },
  fromWorkingColorSpace: function(r, e) {
    return this.convert(r, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(r, e) {
    return this.convert(r, e, this.workingColorSpace);
  },
  getPrimaries: function(r) {
    return this.spaces[r].primaries;
  },
  getTransfer: function(r) {
    return r === Sl ? aP : this.spaces[r].transfer;
  },
  getLuminanceCoefficients: function(r, e = this.workingColorSpace) {
    return r.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(r) {
    Object.assign(this.spaces, r);
  },
  // Internal APIs
  _getMatrix: function(r, e, i) {
    return r.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(r) {
    return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(r = this.workingColorSpace) {
    return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
  }
};
function ma(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Zu(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const zE = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], jE = [0.2126, 0.7152, 0.0722], VE = [0.3127, 0.329], GE = /* @__PURE__ */ new qr().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), HE = /* @__PURE__ */ new qr().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
Li.define({
  [po]: {
    primaries: zE,
    whitePoint: VE,
    transfer: aP,
    toXYZ: GE,
    fromXYZ: HE,
    luminanceCoefficients: jE,
    workingColorSpaceConfig: { unpackColorSpace: ct },
    outputColorSpaceConfig: { drawingBufferColorSpace: ct }
  },
  [ct]: {
    primaries: zE,
    whitePoint: VE,
    transfer: vd,
    toXYZ: GE,
    fromXYZ: HE,
    luminanceCoefficients: jE,
    outputColorSpaceConfig: { drawingBufferColorSpace: ct }
  }
});
let ou;
class U7 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let i;
    if (e instanceof HTMLCanvasElement)
      i = e;
    else {
      ou === void 0 && (ou = _x("canvas")), ou.width = e.width, ou.height = e.height;
      const n = ou.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), i = ou;
    }
    return i.width > 2048 || i.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), i.toDataURL("image/jpeg", 0.6)) : i.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const i = _x("canvas");
      i.width = e.width, i.height = e.height;
      const n = i.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const s = n.getImageData(0, 0, e.width, e.height), a = s.data;
      for (let o = 0; o < a.length; o++)
        a[o] = ma(a[o] / 255) * 255;
      return n.putImageData(s, 0, 0), i;
    } else if (e.data) {
      const i = e.data.slice(0);
      for (let n = 0; n < i.length; n++)
        i instanceof Uint8Array || i instanceof Uint8ClampedArray ? i[n] = Math.floor(ma(i[n] / 255) * 255) : i[n] = ma(i[n]);
      return {
        data: i,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let F7 = 0;
class fP {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: F7++ }), this.uuid = fa(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, s = this.data;
    if (s !== null) {
      let a;
      if (Array.isArray(s)) {
        a = [];
        for (let o = 0, l = s.length; o < l; o++)
          s[o].isDataTexture ? a.push(_0(s[o].image)) : a.push(_0(s[o]));
      } else
        a = _0(s);
      n.url = a;
    }
    return i || (e.images[this.uuid] = n), n;
  }
}
function _0(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? U7.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let B7 = 0;
class Ar extends zc {
  constructor(e = Ar.DEFAULT_IMAGE, i = Ar.DEFAULT_MAPPING, n = Du, s = Du, a = on, o = da, l = Bc, u = ho, c = Ar.DEFAULT_ANISOTROPY, h = Sl) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: B7++ }), this.uuid = fa(), this.name = "", this.source = new fP(e), this.mipmaps = [], this.mapping = i, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = a, this.minFilter = o, this.anisotropy = c, this.format = l, this.internalFormat = null, this.type = u, this.offset = new Vt(0, 0), this.repeat = new Vt(1, 1), this.center = new Vt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new qr(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), i || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== o1) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Um:
          e.x = e.x - Math.floor(e.x);
          break;
        case Du:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Fm:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Um:
          e.y = e.y - Math.floor(e.y);
          break;
        case Du:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Fm:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Ar.DEFAULT_IMAGE = null;
Ar.DEFAULT_MAPPING = o1;
Ar.DEFAULT_ANISOTROPY = 1;
class Yt {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    Yt.prototype.isVector4 = !0, this.x = e, this.y = i, this.z = n, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, i, n, s) {
    return this.x = e, this.y = i, this.z = n, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      case 3:
        this.w = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this.w = e.w + i.w, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this.w += e.w * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this.w = e.w - i.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = this.w, o = e.elements;
    return this.x = o[0] * i + o[4] * n + o[8] * s + o[12] * a, this.y = o[1] * i + o[5] * n + o[9] * s + o[13] * a, this.z = o[2] * i + o[6] * n + o[10] * s + o[14] * a, this.w = o[3] * i + o[7] * n + o[11] * s + o[15] * a, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const i = Math.sqrt(1 - e.w * e.w);
    return i < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / i, this.y = e.y / i, this.z = e.z / i), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let i, n, s, a;
    const o = e.elements, l = o[0], u = o[4], c = o[8], h = o[1], d = o[5], p = o[9], f = o[2], m = o[6], y = o[10];
    if (Math.abs(u - h) < 0.01 && Math.abs(c - f) < 0.01 && Math.abs(p - m) < 0.01) {
      if (Math.abs(u + h) < 0.1 && Math.abs(c + f) < 0.1 && Math.abs(p + m) < 0.1 && Math.abs(l + d + y - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      i = Math.PI;
      const g = (l + 1) / 2, _ = (d + 1) / 2, x = (y + 1) / 2, b = (u + h) / 4, T = (c + f) / 4, S = (p + m) / 4;
      return g > _ && g > x ? g < 0.01 ? (n = 0, s = 0.707106781, a = 0.707106781) : (n = Math.sqrt(g), s = b / n, a = T / n) : _ > x ? _ < 0.01 ? (n = 0.707106781, s = 0, a = 0.707106781) : (s = Math.sqrt(_), n = b / s, a = S / s) : x < 0.01 ? (n = 0.707106781, s = 0.707106781, a = 0) : (a = Math.sqrt(x), n = T / a, s = S / a), this.set(n, s, a, i), this;
    }
    let v = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (h - u) * (h - u));
    return Math.abs(v) < 1e-3 && (v = 1), this.x = (m - p) / v, this.y = (c - f) / v, this.z = (h - u) / v, this.w = Math.acos((l + d + y - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this.w = i[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this.w = Math.max(e.w, Math.min(i.w, this.w)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this.w = Math.max(e, Math.min(i, this.w)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this.w += (e.w - this.w) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this.w = e.w + (i.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this.w = e[i + 3], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e[i + 3] = this.w, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this.w = e.getW(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class jc extends zc {
  constructor(e = 1, i = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = i, this.depth = 1, this.scissor = new Yt(0, 0, e, i), this.scissorTest = !1, this.viewport = new Yt(0, 0, e, i);
    const s = { width: e, height: i, depth: 1 };
    n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: on,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, n);
    const a = new Ar(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
    a.flipY = !1, a.generateMipmaps = n.generateMipmaps, a.internalFormat = n.internalFormat, this.textures = [];
    const o = n.count;
    for (let l = 0; l < o; l++)
      this.textures[l] = a.clone(), this.textures[l].isRenderTargetTexture = !0;
    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, i, n = 1) {
    if (this.width !== e || this.height !== i || this.depth !== n) {
      this.width = e, this.height = i, this.depth = n;
      for (let s = 0, a = this.textures.length; s < a; s++)
        this.textures[s].image.width = e, this.textures[s].image.height = i, this.textures[s].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, i), this.scissor.set(0, 0, e, i);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let n = 0, s = e.textures.length; n < s; n++)
      this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
    const i = Object.assign({}, e.texture.image);
    return this.texture.source = new fP(i), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class z7 extends jc {
  constructor(e = 1, i = 1, n = {}) {
    super(e, i, n), this.isWebGLRenderTarget = !0;
  }
}
class j7 extends Ar {
  constructor(e = null, i = 1, n = 1, s = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: i, height: n, depth: s }, this.magFilter = mr, this.minFilter = mr, this.wrapR = Du, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Zd {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    this.isQuaternion = !0, this._x = e, this._y = i, this._z = n, this._w = s;
  }
  static slerpFlat(e, i, n, s, a, o, l) {
    let u = n[s + 0], c = n[s + 1], h = n[s + 2], d = n[s + 3];
    const p = a[o + 0], f = a[o + 1], m = a[o + 2], y = a[o + 3];
    if (l === 0) {
      e[i + 0] = u, e[i + 1] = c, e[i + 2] = h, e[i + 3] = d;
      return;
    }
    if (l === 1) {
      e[i + 0] = p, e[i + 1] = f, e[i + 2] = m, e[i + 3] = y;
      return;
    }
    if (d !== y || u !== p || c !== f || h !== m) {
      let v = 1 - l;
      const g = u * p + c * f + h * m + d * y, _ = g >= 0 ? 1 : -1, x = 1 - g * g;
      if (x > Number.EPSILON) {
        const T = Math.sqrt(x), S = Math.atan2(T, g * _);
        v = Math.sin(v * S) / T, l = Math.sin(l * S) / T;
      }
      const b = l * _;
      if (u = u * v + p * b, c = c * v + f * b, h = h * v + m * b, d = d * v + y * b, v === 1 - l) {
        const T = 1 / Math.sqrt(u * u + c * c + h * h + d * d);
        u *= T, c *= T, h *= T, d *= T;
      }
    }
    e[i] = u, e[i + 1] = c, e[i + 2] = h, e[i + 3] = d;
  }
  static multiplyQuaternionsFlat(e, i, n, s, a, o) {
    const l = n[s], u = n[s + 1], c = n[s + 2], h = n[s + 3], d = a[o], p = a[o + 1], f = a[o + 2], m = a[o + 3];
    return e[i] = l * m + h * d + u * f - c * p, e[i + 1] = u * m + h * p + c * d - l * f, e[i + 2] = c * m + h * f + l * p - u * d, e[i + 3] = h * m - l * d - u * p - c * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, i, n, s) {
    return this._x = e, this._y = i, this._z = n, this._w = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, i = !0) {
    const n = e._x, s = e._y, a = e._z, o = e._order, l = Math.cos, u = Math.sin, c = l(n / 2), h = l(s / 2), d = l(a / 2), p = u(n / 2), f = u(s / 2), m = u(a / 2);
    switch (o) {
      case "XYZ":
        this._x = p * h * d + c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "YXZ":
        this._x = p * h * d + c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d + p * f * m;
        break;
      case "ZXY":
        this._x = p * h * d - c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "ZYX":
        this._x = p * h * d - c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d + p * f * m;
        break;
      case "YZX":
        this._x = p * h * d + c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "XZY":
        this._x = p * h * d - c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d + p * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return i === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, i) {
    const n = i / 2, s = Math.sin(n);
    return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const i = e.elements, n = i[0], s = i[4], a = i[8], o = i[1], l = i[5], u = i[9], c = i[2], h = i[6], d = i[10], p = n + l + d;
    if (p > 0) {
      const f = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / f, this._x = (h - u) * f, this._y = (a - c) * f, this._z = (o - s) * f;
    } else if (n > l && n > d) {
      const f = 2 * Math.sqrt(1 + n - l - d);
      this._w = (h - u) / f, this._x = 0.25 * f, this._y = (s + o) / f, this._z = (a + c) / f;
    } else if (l > d) {
      const f = 2 * Math.sqrt(1 + l - n - d);
      this._w = (a - c) / f, this._x = (s + o) / f, this._y = 0.25 * f, this._z = (u + h) / f;
    } else {
      const f = 2 * Math.sqrt(1 + d - n - l);
      this._w = (o - s) / f, this._x = (a + c) / f, this._y = (u + h) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, i) {
    let n = e.dot(i) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * i.z - e.z * i.y, this._y = e.z * i.x - e.x * i.z, this._z = e.x * i.y - e.y * i.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(er(this.dot(e), -1, 1)));
  }
  rotateTowards(e, i) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const s = Math.min(1, i / n);
    return this.slerp(e, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, i) {
    const n = e._x, s = e._y, a = e._z, o = e._w, l = i._x, u = i._y, c = i._z, h = i._w;
    return this._x = n * h + o * l + s * c - a * u, this._y = s * h + o * u + a * l - n * c, this._z = a * h + o * c + n * u - s * l, this._w = o * h - n * l - s * u - a * c, this._onChangeCallback(), this;
  }
  slerp(e, i) {
    if (i === 0) return this;
    if (i === 1) return this.copy(e);
    const n = this._x, s = this._y, a = this._z, o = this._w;
    let l = o * e._w + n * e._x + s * e._y + a * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = o, this._x = n, this._y = s, this._z = a, this;
    const u = 1 - l * l;
    if (u <= Number.EPSILON) {
      const f = 1 - i;
      return this._w = f * o + i * this._w, this._x = f * n + i * this._x, this._y = f * s + i * this._y, this._z = f * a + i * this._z, this.normalize(), this;
    }
    const c = Math.sqrt(u), h = Math.atan2(c, l), d = Math.sin((1 - i) * h) / c, p = Math.sin(i * h) / c;
    return this._w = o * d + this._w * p, this._x = n * d + this._x * p, this._y = s * d + this._y * p, this._z = a * d + this._z * p, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, i, n) {
    return this.copy(e).slerp(i, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), i = 2 * Math.PI * Math.random(), n = Math.random(), s = Math.sqrt(1 - n), a = Math.sqrt(n);
    return this.set(
      s * Math.sin(e),
      s * Math.cos(e),
      a * Math.sin(i),
      a * Math.cos(i)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, i = 0) {
    return this._x = e[i], this._y = e[i + 1], this._z = e[i + 2], this._w = e[i + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._w, e;
  }
  fromBufferAttribute(e, i) {
    return this._x = e.getX(i), this._y = e.getY(i), this._z = e.getZ(i), this._w = e.getW(i), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class ue {
  constructor(e = 0, i = 0, n = 0) {
    ue.prototype.isVector3 = !0, this.x = e, this.y = i, this.z = n;
  }
  set(e, i, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = i, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, i) {
    return this.x = e.x * i.x, this.y = e.y * i.y, this.z = e.z * i.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(WE.setFromEuler(e));
  }
  applyAxisAngle(e, i) {
    return this.applyQuaternion(WE.setFromAxisAngle(e, i));
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[3] * n + a[6] * s, this.y = a[1] * i + a[4] * n + a[7] * s, this.z = a[2] * i + a[5] * n + a[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements, o = 1 / (a[3] * i + a[7] * n + a[11] * s + a[15]);
    return this.x = (a[0] * i + a[4] * n + a[8] * s + a[12]) * o, this.y = (a[1] * i + a[5] * n + a[9] * s + a[13]) * o, this.z = (a[2] * i + a[6] * n + a[10] * s + a[14]) * o, this;
  }
  applyQuaternion(e) {
    const i = this.x, n = this.y, s = this.z, a = e.x, o = e.y, l = e.z, u = e.w, c = 2 * (o * s - l * n), h = 2 * (l * i - a * s), d = 2 * (a * n - o * i);
    return this.x = i + u * c + o * d - l * h, this.y = n + u * h + l * c - a * d, this.z = s + u * d + a * h - o * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[4] * n + a[8] * s, this.y = a[1] * i + a[5] * n + a[9] * s, this.z = a[2] * i + a[6] * n + a[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, i) {
    const n = e.x, s = e.y, a = e.z, o = i.x, l = i.y, u = i.z;
    return this.x = s * u - a * l, this.y = a * o - n * u, this.z = n * l - s * o, this;
  }
  projectOnVector(e) {
    const i = e.lengthSq();
    if (i === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / i;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return T0.copy(this).projectOnVector(e), this.sub(T0);
  }
  reflect(e) {
    return this.sub(T0.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(er(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
    return i * i + n * n + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, i, n) {
    const s = Math.sin(i) * e;
    return this.x = s * Math.sin(n), this.y = Math.cos(i) * e, this.z = s * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, i, n) {
    return this.x = e * Math.sin(i), this.y = n, this.z = e * Math.cos(i), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this;
  }
  setFromMatrixScale(e) {
    const i = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = i, this.y = n, this.z = s, this;
  }
  setFromMatrixColumn(e, i) {
    return this.fromArray(e.elements, i * 4);
  }
  setFromMatrix3Column(e, i) {
    return this.fromArray(e.elements, i * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, i = Math.random() * 2 - 1, n = Math.sqrt(1 - i * i);
    return this.x = n * Math.cos(e), this.y = i, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const T0 = /* @__PURE__ */ new ue(), WE = /* @__PURE__ */ new Zd();
class Qd {
  constructor(e = new ue(1 / 0, 1 / 0, 1 / 0), i = new ue(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = i;
  }
  set(e, i) {
    return this.min.copy(e), this.max.copy(i), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let i = 0, n = e.length; i < n; i += 3)
      this.expandByPoint(In.fromArray(e, i));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let i = 0, n = e.count; i < n; i++)
      this.expandByPoint(In.fromBufferAttribute(e, i));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let i = 0, n = e.length; i < n; i++)
      this.expandByPoint(e[i]);
    return this;
  }
  setFromCenterAndSize(e, i) {
    const n = In.copy(i).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, i = !1) {
    return this.makeEmpty(), this.expandByObject(e, i);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, i = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const a = n.getAttribute("position");
      if (i === !0 && a !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, l = a.count; o < l; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, In) : In.fromBufferAttribute(a, o), In.applyMatrix4(e.matrixWorld), this.expandByPoint(In);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Yp.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Yp.copy(n.boundingBox)), Yp.applyMatrix4(e.matrixWorld), this.union(Yp);
    }
    const s = e.children;
    for (let a = 0, o = s.length; a < o; a++)
      this.expandByObject(s[a], i);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, i) {
    return i.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, In), In.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let i, n;
    return e.normal.x > 0 ? (i = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (i = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (i += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (i += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (i += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (i += e.normal.z * this.max.z, n += e.normal.z * this.min.z), i <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(gh), Kp.subVectors(this.max, gh), lu.subVectors(e.a, gh), uu.subVectors(e.b, gh), cu.subVectors(e.c, gh), Ua.subVectors(uu, lu), Fa.subVectors(cu, uu), Lo.subVectors(lu, cu);
    let i = [
      0,
      -Ua.z,
      Ua.y,
      0,
      -Fa.z,
      Fa.y,
      0,
      -Lo.z,
      Lo.y,
      Ua.z,
      0,
      -Ua.x,
      Fa.z,
      0,
      -Fa.x,
      Lo.z,
      0,
      -Lo.x,
      -Ua.y,
      Ua.x,
      0,
      -Fa.y,
      Fa.x,
      0,
      -Lo.y,
      Lo.x,
      0
    ];
    return !S0(i, lu, uu, cu, Kp) || (i = [1, 0, 0, 0, 1, 0, 0, 0, 1], !S0(i, lu, uu, cu, Kp)) ? !1 : (Zp.crossVectors(Ua, Fa), i = [Zp.x, Zp.y, Zp.z], S0(i, lu, uu, cu, Kp));
  }
  clampPoint(e, i) {
    return i.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, In).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(In).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Os[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Os[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Os[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Os[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Os[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Os[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Os[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Os[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Os), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Os = [
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue()
], In = /* @__PURE__ */ new ue(), Yp = /* @__PURE__ */ new Qd(), lu = /* @__PURE__ */ new ue(), uu = /* @__PURE__ */ new ue(), cu = /* @__PURE__ */ new ue(), Ua = /* @__PURE__ */ new ue(), Fa = /* @__PURE__ */ new ue(), Lo = /* @__PURE__ */ new ue(), gh = /* @__PURE__ */ new ue(), Kp = /* @__PURE__ */ new ue(), Zp = /* @__PURE__ */ new ue(), ko = /* @__PURE__ */ new ue();
function S0(r, e, i, n, s) {
  for (let a = 0, o = r.length - 3; a <= o; a += 3) {
    ko.fromArray(r, a);
    const l = s.x * Math.abs(ko.x) + s.y * Math.abs(ko.y) + s.z * Math.abs(ko.z), u = e.dot(ko), c = i.dot(ko), h = n.dot(ko);
    if (Math.max(-Math.max(u, c, h), Math.min(u, c, h)) > l)
      return !1;
  }
  return !0;
}
const V7 = /* @__PURE__ */ new Qd(), yh = /* @__PURE__ */ new ue(), w0 = /* @__PURE__ */ new ue();
class m1 {
  constructor(e = new ue(), i = -1) {
    this.isSphere = !0, this.center = e, this.radius = i;
  }
  set(e, i) {
    return this.center.copy(e), this.radius = i, this;
  }
  setFromPoints(e, i) {
    const n = this.center;
    i !== void 0 ? n.copy(i) : V7.setFromPoints(e).getCenter(n);
    let s = 0;
    for (let a = 0, o = e.length; a < o; a++)
      s = Math.max(s, n.distanceToSquared(e[a]));
    return this.radius = Math.sqrt(s), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const i = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= i * i;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, i) {
    const n = this.center.distanceToSquared(e);
    return i.copy(e), n > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)), i;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    yh.subVectors(e, this.center);
    const i = yh.lengthSq();
    if (i > this.radius * this.radius) {
      const n = Math.sqrt(i), s = (n - this.radius) * 0.5;
      this.center.addScaledVector(yh, s / n), this.radius += s;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (w0.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(yh.copy(e.center).add(w0)), this.expandByPoint(yh.copy(e.center).sub(w0))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ds = /* @__PURE__ */ new ue(), E0 = /* @__PURE__ */ new ue(), Qp = /* @__PURE__ */ new ue(), Ba = /* @__PURE__ */ new ue(), M0 = /* @__PURE__ */ new ue(), Jp = /* @__PURE__ */ new ue(), A0 = /* @__PURE__ */ new ue();
class G7 {
  constructor(e = new ue(), i = new ue(0, 0, -1)) {
    this.origin = e, this.direction = i;
  }
  set(e, i) {
    return this.origin.copy(e), this.direction.copy(i), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, i) {
    return i.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ds)), this;
  }
  closestPointToPoint(e, i) {
    i.subVectors(e, this.origin);
    const n = i.dot(this.direction);
    return n < 0 ? i.copy(this.origin) : i.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const i = Ds.subVectors(e, this.origin).dot(this.direction);
    return i < 0 ? this.origin.distanceToSquared(e) : (Ds.copy(this.origin).addScaledVector(this.direction, i), Ds.distanceToSquared(e));
  }
  distanceSqToSegment(e, i, n, s) {
    E0.copy(e).add(i).multiplyScalar(0.5), Qp.copy(i).sub(e).normalize(), Ba.copy(this.origin).sub(E0);
    const a = e.distanceTo(i) * 0.5, o = -this.direction.dot(Qp), l = Ba.dot(this.direction), u = -Ba.dot(Qp), c = Ba.lengthSq(), h = Math.abs(1 - o * o);
    let d, p, f, m;
    if (h > 0)
      if (d = o * u - l, p = o * l - u, m = a * h, d >= 0)
        if (p >= -m)
          if (p <= m) {
            const y = 1 / h;
            d *= y, p *= y, f = d * (d + o * p + 2 * l) + p * (o * d + p + 2 * u) + c;
          } else
            p = a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
        else
          p = -a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
      else
        p <= -m ? (d = Math.max(0, -(-o * a + l)), p = d > 0 ? -a : Math.min(Math.max(-a, -u), a), f = -d * d + p * (p + 2 * u) + c) : p <= m ? (d = 0, p = Math.min(Math.max(-a, -u), a), f = p * (p + 2 * u) + c) : (d = Math.max(0, -(o * a + l)), p = d > 0 ? a : Math.min(Math.max(-a, -u), a), f = -d * d + p * (p + 2 * u) + c);
    else
      p = o > 0 ? -a : a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
    return n && n.copy(this.origin).addScaledVector(this.direction, d), s && s.copy(E0).addScaledVector(Qp, p), f;
  }
  intersectSphere(e, i) {
    Ds.subVectors(e.center, this.origin);
    const n = Ds.dot(this.direction), s = Ds.dot(Ds) - n * n, a = e.radius * e.radius;
    if (s > a) return null;
    const o = Math.sqrt(a - s), l = n - o, u = n + o;
    return u < 0 ? null : l < 0 ? this.at(u, i) : this.at(l, i);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const i = e.normal.dot(this.direction);
    if (i === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / i;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, i) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, i);
  }
  intersectsPlane(e) {
    const i = e.distanceToPoint(this.origin);
    return i === 0 || e.normal.dot(this.direction) * i < 0;
  }
  intersectBox(e, i) {
    let n, s, a, o, l, u;
    const c = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin;
    return c >= 0 ? (n = (e.min.x - p.x) * c, s = (e.max.x - p.x) * c) : (n = (e.max.x - p.x) * c, s = (e.min.x - p.x) * c), h >= 0 ? (a = (e.min.y - p.y) * h, o = (e.max.y - p.y) * h) : (a = (e.max.y - p.y) * h, o = (e.min.y - p.y) * h), n > o || a > s || ((a > n || isNaN(n)) && (n = a), (o < s || isNaN(s)) && (s = o), d >= 0 ? (l = (e.min.z - p.z) * d, u = (e.max.z - p.z) * d) : (l = (e.max.z - p.z) * d, u = (e.min.z - p.z) * d), n > u || l > s) || ((l > n || n !== n) && (n = l), (u < s || s !== s) && (s = u), s < 0) ? null : this.at(n >= 0 ? n : s, i);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Ds) !== null;
  }
  intersectTriangle(e, i, n, s, a) {
    M0.subVectors(i, e), Jp.subVectors(n, e), A0.crossVectors(M0, Jp);
    let o = this.direction.dot(A0), l;
    if (o > 0) {
      if (s) return null;
      l = 1;
    } else if (o < 0)
      l = -1, o = -o;
    else
      return null;
    Ba.subVectors(this.origin, e);
    const u = l * this.direction.dot(Jp.crossVectors(Ba, Jp));
    if (u < 0)
      return null;
    const c = l * this.direction.dot(M0.cross(Ba));
    if (c < 0 || u + c > o)
      return null;
    const h = -l * Ba.dot(A0);
    return h < 0 ? null : this.at(h / o, a);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class gi {
  constructor(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v) {
    gi.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v);
  }
  set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v) {
    const g = this.elements;
    return g[0] = e, g[4] = i, g[8] = n, g[12] = s, g[1] = a, g[5] = o, g[9] = l, g[13] = u, g[2] = c, g[6] = h, g[10] = d, g[14] = p, g[3] = f, g[7] = m, g[11] = y, g[15] = v, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new gi().fromArray(this.elements);
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], i[9] = n[9], i[10] = n[10], i[11] = n[11], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15], this;
  }
  copyPosition(e) {
    const i = this.elements, n = e.elements;
    return i[12] = n[12], i[13] = n[13], i[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[3],
      i[6],
      0,
      i[1],
      i[4],
      i[7],
      0,
      i[2],
      i[5],
      i[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrixColumn(this, 0), i.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, i, n) {
    return this.set(
      e.x,
      i.x,
      n.x,
      0,
      e.y,
      i.y,
      n.y,
      0,
      e.z,
      i.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const i = this.elements, n = e.elements, s = 1 / hu.setFromMatrixColumn(e, 0).length(), a = 1 / hu.setFromMatrixColumn(e, 1).length(), o = 1 / hu.setFromMatrixColumn(e, 2).length();
    return i[0] = n[0] * s, i[1] = n[1] * s, i[2] = n[2] * s, i[3] = 0, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[7] = 0, i[8] = n[8] * o, i[9] = n[9] * o, i[10] = n[10] * o, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z, o = Math.cos(n), l = Math.sin(n), u = Math.cos(s), c = Math.sin(s), h = Math.cos(a), d = Math.sin(a);
    if (e.order === "XYZ") {
      const p = o * h, f = o * d, m = l * h, y = l * d;
      i[0] = u * h, i[4] = -u * d, i[8] = c, i[1] = f + m * c, i[5] = p - y * c, i[9] = -l * u, i[2] = y - p * c, i[6] = m + f * c, i[10] = o * u;
    } else if (e.order === "YXZ") {
      const p = u * h, f = u * d, m = c * h, y = c * d;
      i[0] = p + y * l, i[4] = m * l - f, i[8] = o * c, i[1] = o * d, i[5] = o * h, i[9] = -l, i[2] = f * l - m, i[6] = y + p * l, i[10] = o * u;
    } else if (e.order === "ZXY") {
      const p = u * h, f = u * d, m = c * h, y = c * d;
      i[0] = p - y * l, i[4] = -o * d, i[8] = m + f * l, i[1] = f + m * l, i[5] = o * h, i[9] = y - p * l, i[2] = -o * c, i[6] = l, i[10] = o * u;
    } else if (e.order === "ZYX") {
      const p = o * h, f = o * d, m = l * h, y = l * d;
      i[0] = u * h, i[4] = m * c - f, i[8] = p * c + y, i[1] = u * d, i[5] = y * c + p, i[9] = f * c - m, i[2] = -c, i[6] = l * u, i[10] = o * u;
    } else if (e.order === "YZX") {
      const p = o * u, f = o * c, m = l * u, y = l * c;
      i[0] = u * h, i[4] = y - p * d, i[8] = m * d + f, i[1] = d, i[5] = o * h, i[9] = -l * h, i[2] = -c * h, i[6] = f * d + m, i[10] = p - y * d;
    } else if (e.order === "XZY") {
      const p = o * u, f = o * c, m = l * u, y = l * c;
      i[0] = u * h, i[4] = -d, i[8] = c * h, i[1] = p * d + y, i[5] = o * h, i[9] = f * d - m, i[2] = m * d - f, i[6] = l * h, i[10] = y * d + p;
    }
    return i[3] = 0, i[7] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(H7, e, W7);
  }
  lookAt(e, i, n) {
    const s = this.elements;
    return Zr.subVectors(e, i), Zr.lengthSq() === 0 && (Zr.z = 1), Zr.normalize(), za.crossVectors(n, Zr), za.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Zr.x += 1e-4 : Zr.z += 1e-4, Zr.normalize(), za.crossVectors(n, Zr)), za.normalize(), ef.crossVectors(Zr, za), s[0] = za.x, s[4] = ef.x, s[8] = Zr.x, s[1] = za.y, s[5] = ef.y, s[9] = Zr.y, s[2] = za.z, s[6] = ef.z, s[10] = Zr.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[4], u = n[8], c = n[12], h = n[1], d = n[5], p = n[9], f = n[13], m = n[2], y = n[6], v = n[10], g = n[14], _ = n[3], x = n[7], b = n[11], T = n[15], S = s[0], w = s[4], M = s[8], E = s[12], A = s[1], N = s[5], U = s[9], k = s[13], C = s[2], I = s[6], O = s[10], W = s[14], V = s[3], Q = s[7], F = s[11], B = s[15];
    return a[0] = o * S + l * A + u * C + c * V, a[4] = o * w + l * N + u * I + c * Q, a[8] = o * M + l * U + u * O + c * F, a[12] = o * E + l * k + u * W + c * B, a[1] = h * S + d * A + p * C + f * V, a[5] = h * w + d * N + p * I + f * Q, a[9] = h * M + d * U + p * O + f * F, a[13] = h * E + d * k + p * W + f * B, a[2] = m * S + y * A + v * C + g * V, a[6] = m * w + y * N + v * I + g * Q, a[10] = m * M + y * U + v * O + g * F, a[14] = m * E + y * k + v * W + g * B, a[3] = _ * S + x * A + b * C + T * V, a[7] = _ * w + x * N + b * I + T * Q, a[11] = _ * M + x * U + b * O + T * F, a[15] = _ * E + x * k + b * W + T * B, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[4] *= e, i[8] *= e, i[12] *= e, i[1] *= e, i[5] *= e, i[9] *= e, i[13] *= e, i[2] *= e, i[6] *= e, i[10] *= e, i[14] *= e, i[3] *= e, i[7] *= e, i[11] *= e, i[15] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[4], s = e[8], a = e[12], o = e[1], l = e[5], u = e[9], c = e[13], h = e[2], d = e[6], p = e[10], f = e[14], m = e[3], y = e[7], v = e[11], g = e[15];
    return m * (+a * u * d - s * c * d - a * l * p + n * c * p + s * l * f - n * u * f) + y * (+i * u * f - i * c * p + a * o * p - s * o * f + s * c * h - a * u * h) + v * (+i * c * d - i * l * f - a * o * d + n * o * f + a * l * h - n * c * h) + g * (-s * l * h - i * u * d + i * l * p + s * o * d - n * o * p + n * u * h);
  }
  transpose() {
    const e = this.elements;
    let i;
    return i = e[1], e[1] = e[4], e[4] = i, i = e[2], e[2] = e[8], e[8] = i, i = e[6], e[6] = e[9], e[9] = i, i = e[3], e[3] = e[12], e[12] = i, i = e[7], e[7] = e[13], e[13] = i, i = e[11], e[11] = e[14], e[14] = i, this;
  }
  setPosition(e, i, n) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = i, s[14] = n), this;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = e[9], p = e[10], f = e[11], m = e[12], y = e[13], v = e[14], g = e[15], _ = d * v * c - y * p * c + y * u * f - l * v * f - d * u * g + l * p * g, x = m * p * c - h * v * c - m * u * f + o * v * f + h * u * g - o * p * g, b = h * y * c - m * d * c + m * l * f - o * y * f - h * l * g + o * d * g, T = m * d * u - h * y * u - m * l * p + o * y * p + h * l * v - o * d * v, S = i * _ + n * x + s * b + a * T;
    if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / S;
    return e[0] = _ * w, e[1] = (y * p * a - d * v * a - y * s * f + n * v * f + d * s * g - n * p * g) * w, e[2] = (l * v * a - y * u * a + y * s * c - n * v * c - l * s * g + n * u * g) * w, e[3] = (d * u * a - l * p * a - d * s * c + n * p * c + l * s * f - n * u * f) * w, e[4] = x * w, e[5] = (h * v * a - m * p * a + m * s * f - i * v * f - h * s * g + i * p * g) * w, e[6] = (m * u * a - o * v * a - m * s * c + i * v * c + o * s * g - i * u * g) * w, e[7] = (o * p * a - h * u * a + h * s * c - i * p * c - o * s * f + i * u * f) * w, e[8] = b * w, e[9] = (m * d * a - h * y * a - m * n * f + i * y * f + h * n * g - i * d * g) * w, e[10] = (o * y * a - m * l * a + m * n * c - i * y * c - o * n * g + i * l * g) * w, e[11] = (h * l * a - o * d * a - h * n * c + i * d * c + o * n * f - i * l * f) * w, e[12] = T * w, e[13] = (h * y * s - m * d * s + m * n * p - i * y * p - h * n * v + i * d * v) * w, e[14] = (m * l * s - o * y * s - m * n * u + i * y * u + o * n * v - i * l * v) * w, e[15] = (o * d * s - h * l * s + h * n * u - i * d * u - o * n * p + i * l * p) * w, this;
  }
  scale(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z;
    return i[0] *= n, i[4] *= s, i[8] *= a, i[1] *= n, i[5] *= s, i[9] *= a, i[2] *= n, i[6] *= s, i[10] *= a, i[3] *= n, i[7] *= s, i[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(i, n, s));
  }
  makeTranslation(e, i, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      i,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = 1 - n, o = e.x, l = e.y, u = e.z, c = a * o, h = a * l;
    return this.set(
      c * o + n,
      c * l - s * u,
      c * u + s * l,
      0,
      c * l + s * u,
      h * l + n,
      h * u - s * o,
      0,
      c * u - s * l,
      h * u + s * o,
      a * u * u + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, i, n, s, a, o) {
    return this.set(
      1,
      n,
      a,
      0,
      e,
      1,
      o,
      0,
      i,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, i, n) {
    const s = this.elements, a = i._x, o = i._y, l = i._z, u = i._w, c = a + a, h = o + o, d = l + l, p = a * c, f = a * h, m = a * d, y = o * h, v = o * d, g = l * d, _ = u * c, x = u * h, b = u * d, T = n.x, S = n.y, w = n.z;
    return s[0] = (1 - (y + g)) * T, s[1] = (f + b) * T, s[2] = (m - x) * T, s[3] = 0, s[4] = (f - b) * S, s[5] = (1 - (p + g)) * S, s[6] = (v + _) * S, s[7] = 0, s[8] = (m + x) * w, s[9] = (v - _) * w, s[10] = (1 - (p + y)) * w, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, i, n) {
    const s = this.elements;
    let a = hu.set(s[0], s[1], s[2]).length();
    const o = hu.set(s[4], s[5], s[6]).length(), l = hu.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (a = -a), e.x = s[12], e.y = s[13], e.z = s[14], On.copy(this);
    const u = 1 / a, c = 1 / o, h = 1 / l;
    return On.elements[0] *= u, On.elements[1] *= u, On.elements[2] *= u, On.elements[4] *= c, On.elements[5] *= c, On.elements[6] *= c, On.elements[8] *= h, On.elements[9] *= h, On.elements[10] *= h, i.setFromRotationMatrix(On), n.x = a, n.y = o, n.z = l, this;
  }
  makePerspective(e, i, n, s, a, o, l = Yn) {
    const u = this.elements, c = 2 * a / (i - e), h = 2 * a / (n - s), d = (i + e) / (i - e), p = (n + s) / (n - s);
    let f, m;
    if (l === Yn)
      f = -(o + a) / (o - a), m = -2 * o * a / (o - a);
    else if (l === wl)
      f = -o / (o - a), m = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return u[0] = c, u[4] = 0, u[8] = d, u[12] = 0, u[1] = 0, u[5] = h, u[9] = p, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = f, u[14] = m, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this;
  }
  makeOrthographic(e, i, n, s, a, o, l = Yn) {
    const u = this.elements, c = 1 / (i - e), h = 1 / (n - s), d = 1 / (o - a), p = (i + e) * c, f = (n + s) * h;
    let m, y;
    if (l === Yn)
      m = (o + a) * d, y = -2 * d;
    else if (l === wl)
      m = a * d, y = -1 * d;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return u[0] = 2 * c, u[4] = 0, u[8] = 0, u[12] = -p, u[1] = 0, u[5] = 2 * h, u[9] = 0, u[13] = -f, u[2] = 0, u[6] = 0, u[10] = y, u[14] = -m, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this;
  }
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 16; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e[i + 9] = n[9], e[i + 10] = n[10], e[i + 11] = n[11], e[i + 12] = n[12], e[i + 13] = n[13], e[i + 14] = n[14], e[i + 15] = n[15], e;
  }
}
const hu = /* @__PURE__ */ new ue(), On = /* @__PURE__ */ new gi(), H7 = /* @__PURE__ */ new ue(0, 0, 0), W7 = /* @__PURE__ */ new ue(1, 1, 1), za = /* @__PURE__ */ new ue(), ef = /* @__PURE__ */ new ue(), Zr = /* @__PURE__ */ new ue(), qE = /* @__PURE__ */ new gi(), XE = /* @__PURE__ */ new Zd();
class Qn {
  constructor(e = 0, i = 0, n = 0, s = Qn.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = i, this._z = n, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, i, n, s = this._order) {
    return this._x = e, this._y = i, this._z = n, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, i = this._order, n = !0) {
    const s = e.elements, a = s[0], o = s[4], l = s[8], u = s[1], c = s[5], h = s[9], d = s[2], p = s[6], f = s[10];
    switch (i) {
      case "XYZ":
        this._y = Math.asin(er(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(p, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-er(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(u, c)) : (this._y = Math.atan2(-d, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(er(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(u, a));
        break;
      case "ZYX":
        this._y = Math.asin(-er(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(u, a)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin(er(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-d, a)) : (this._x = 0, this._y = Math.atan2(l, f));
        break;
      case "XZY":
        this._z = Math.asin(-er(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + i);
    }
    return this._order = i, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, i, n) {
    return qE.makeRotationFromQuaternion(e), this.setFromRotationMatrix(qE, i, n);
  }
  setFromVector3(e, i = this._order) {
    return this.set(e.x, e.y, e.z, i);
  }
  reorder(e) {
    return XE.setFromEuler(this), this.setFromQuaternion(XE, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Qn.DEFAULT_ORDER = "XYZ";
class q7 {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let X7 = 0;
const $E = /* @__PURE__ */ new ue(), du = /* @__PURE__ */ new Zd(), Ls = /* @__PURE__ */ new gi(), tf = /* @__PURE__ */ new ue(), vh = /* @__PURE__ */ new ue(), $7 = /* @__PURE__ */ new ue(), Y7 = /* @__PURE__ */ new Zd(), YE = /* @__PURE__ */ new ue(1, 0, 0), KE = /* @__PURE__ */ new ue(0, 1, 0), ZE = /* @__PURE__ */ new ue(0, 0, 1), QE = { type: "added" }, K7 = { type: "removed" }, pu = { type: "childadded", child: null }, C0 = { type: "childremoved", child: null };
class Ki extends zc {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: X7++ }), this.uuid = fa(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ki.DEFAULT_UP.clone();
    const e = new ue(), i = new Qn(), n = new Zd(), s = new ue(1, 1, 1);
    function a() {
      n.setFromEuler(i, !1);
    }
    function o() {
      i.setFromQuaternion(n, void 0, !1);
    }
    i._onChange(a), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      modelViewMatrix: {
        value: new gi()
      },
      normalMatrix: {
        value: new qr()
      }
    }), this.matrix = new gi(), this.matrixWorld = new gi(), this.matrixAutoUpdate = Ki.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Ki.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new q7(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, i) {
    this.quaternion.setFromAxisAngle(e, i);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, i) {
    return du.setFromAxisAngle(e, i), this.quaternion.multiply(du), this;
  }
  rotateOnWorldAxis(e, i) {
    return du.setFromAxisAngle(e, i), this.quaternion.premultiply(du), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(YE, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(KE, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(ZE, e);
  }
  translateOnAxis(e, i) {
    return $E.copy(e).applyQuaternion(this.quaternion), this.position.add($E.multiplyScalar(i)), this;
  }
  translateX(e) {
    return this.translateOnAxis(YE, e);
  }
  translateY(e) {
    return this.translateOnAxis(KE, e);
  }
  translateZ(e) {
    return this.translateOnAxis(ZE, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Ls.copy(this.matrixWorld).invert());
  }
  lookAt(e, i, n) {
    e.isVector3 ? tf.copy(e) : tf.set(e, i, n);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), vh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ls.lookAt(vh, tf, this.up) : Ls.lookAt(tf, vh, this.up), this.quaternion.setFromRotationMatrix(Ls), s && (Ls.extractRotation(s.matrixWorld), du.setFromRotationMatrix(Ls), this.quaternion.premultiply(du.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.add(arguments[i]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(QE), pu.child = e, this.dispatchEvent(pu), pu.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const i = this.children.indexOf(e);
    return i !== -1 && (e.parent = null, this.children.splice(i, 1), e.dispatchEvent(K7), C0.child = e, this.dispatchEvent(C0), C0.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Ls.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Ls.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ls), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(QE), pu.child = e, this.dispatchEvent(pu), pu.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, i) {
    if (this[e] === i) return this;
    for (let n = 0, s = this.children.length; n < s; n++) {
      const a = this.children[n].getObjectByProperty(e, i);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, i, n = []) {
    this[e] === i && n.push(this);
    const s = this.children;
    for (let a = 0, o = s.length; a < o; a++)
      s[a].getObjectsByProperty(e, i, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(vh, e, $7), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(vh, Y7, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const i = this.matrixWorld.elements;
    return e.set(i[8], i[9], i[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const i = this.parent;
    i !== null && (e(i), i.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, i) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), i === !0) {
      const s = this.children;
      for (let a = 0, o = s.length; a < o; a++)
        s[a].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string", n = {};
    i && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
      center: s.boundingSphere.center.toArray(),
      radius: s.boundingSphere.radius
    }), this.boundingBox !== null && (s.boundingBox = {
      min: s.boundingBox.min.toArray(),
      max: s.boundingBox.max.toArray()
    }));
    function a(l, u) {
      return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = a(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const u = l.shapes;
        if (Array.isArray(u))
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c];
            a(e.shapes, d);
          }
        else
          a(e.shapes, u);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let u = 0, c = this.material.length; u < c; u++)
          l.push(a(e.materials, this.material[u]));
        s.material = l;
      } else
        s.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let l = 0; l < this.children.length; l++)
        s.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const u = this.animations[l];
        s.animations.push(a(e.animations, u));
      }
    }
    if (i) {
      const l = o(e.geometries), u = o(e.materials), c = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), f = o(e.animations), m = o(e.nodes);
      l.length > 0 && (n.geometries = l), u.length > 0 && (n.materials = u), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), d.length > 0 && (n.shapes = d), p.length > 0 && (n.skeletons = p), f.length > 0 && (n.animations = f), m.length > 0 && (n.nodes = m);
    }
    return n.object = s, n;
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, i = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), i === !0)
      for (let n = 0; n < e.children.length; n++) {
        const s = e.children[n];
        this.add(s.clone());
      }
    return this;
  }
}
Ki.DEFAULT_UP = /* @__PURE__ */ new ue(0, 1, 0);
Ki.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ki.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Dn = /* @__PURE__ */ new ue(), ks = /* @__PURE__ */ new ue(), R0 = /* @__PURE__ */ new ue(), Us = /* @__PURE__ */ new ue(), fu = /* @__PURE__ */ new ue(), mu = /* @__PURE__ */ new ue(), JE = /* @__PURE__ */ new ue(), N0 = /* @__PURE__ */ new ue(), P0 = /* @__PURE__ */ new ue(), I0 = /* @__PURE__ */ new ue(), O0 = /* @__PURE__ */ new Yt(), D0 = /* @__PURE__ */ new Yt(), L0 = /* @__PURE__ */ new Yt();
class qn {
  constructor(e = new ue(), i = new ue(), n = new ue()) {
    this.a = e, this.b = i, this.c = n;
  }
  static getNormal(e, i, n, s) {
    s.subVectors(n, i), Dn.subVectors(e, i), s.cross(Dn);
    const a = s.lengthSq();
    return a > 0 ? s.multiplyScalar(1 / Math.sqrt(a)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, i, n, s, a) {
    Dn.subVectors(s, i), ks.subVectors(n, i), R0.subVectors(e, i);
    const o = Dn.dot(Dn), l = Dn.dot(ks), u = Dn.dot(R0), c = ks.dot(ks), h = ks.dot(R0), d = o * c - l * l;
    if (d === 0)
      return a.set(0, 0, 0), null;
    const p = 1 / d, f = (c * u - l * h) * p, m = (o * h - l * u) * p;
    return a.set(1 - f - m, m, f);
  }
  static containsPoint(e, i, n, s) {
    return this.getBarycoord(e, i, n, s, Us) === null ? !1 : Us.x >= 0 && Us.y >= 0 && Us.x + Us.y <= 1;
  }
  static getInterpolation(e, i, n, s, a, o, l, u) {
    return this.getBarycoord(e, i, n, s, Us) === null ? (u.x = 0, u.y = 0, "z" in u && (u.z = 0), "w" in u && (u.w = 0), null) : (u.setScalar(0), u.addScaledVector(a, Us.x), u.addScaledVector(o, Us.y), u.addScaledVector(l, Us.z), u);
  }
  static getInterpolatedAttribute(e, i, n, s, a, o) {
    return O0.setScalar(0), D0.setScalar(0), L0.setScalar(0), O0.fromBufferAttribute(e, i), D0.fromBufferAttribute(e, n), L0.fromBufferAttribute(e, s), o.setScalar(0), o.addScaledVector(O0, a.x), o.addScaledVector(D0, a.y), o.addScaledVector(L0, a.z), o;
  }
  static isFrontFacing(e, i, n, s) {
    return Dn.subVectors(n, i), ks.subVectors(e, i), Dn.cross(ks).dot(s) < 0;
  }
  set(e, i, n) {
    return this.a.copy(e), this.b.copy(i), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, i, n, s) {
    return this.a.copy(e[i]), this.b.copy(e[n]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, i, n, s) {
    return this.a.fromBufferAttribute(e, i), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Dn.subVectors(this.c, this.b), ks.subVectors(this.a, this.b), Dn.cross(ks).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return qn.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, i) {
    return qn.getBarycoord(e, this.a, this.b, this.c, i);
  }
  getInterpolation(e, i, n, s, a) {
    return qn.getInterpolation(e, this.a, this.b, this.c, i, n, s, a);
  }
  containsPoint(e) {
    return qn.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return qn.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, i) {
    const n = this.a, s = this.b, a = this.c;
    let o, l;
    fu.subVectors(s, n), mu.subVectors(a, n), N0.subVectors(e, n);
    const u = fu.dot(N0), c = mu.dot(N0);
    if (u <= 0 && c <= 0)
      return i.copy(n);
    P0.subVectors(e, s);
    const h = fu.dot(P0), d = mu.dot(P0);
    if (h >= 0 && d <= h)
      return i.copy(s);
    const p = u * d - h * c;
    if (p <= 0 && u >= 0 && h <= 0)
      return o = u / (u - h), i.copy(n).addScaledVector(fu, o);
    I0.subVectors(e, a);
    const f = fu.dot(I0), m = mu.dot(I0);
    if (m >= 0 && f <= m)
      return i.copy(a);
    const y = f * c - u * m;
    if (y <= 0 && c >= 0 && m <= 0)
      return l = c / (c - m), i.copy(n).addScaledVector(mu, l);
    const v = h * m - f * d;
    if (v <= 0 && d - h >= 0 && f - m >= 0)
      return JE.subVectors(a, s), l = (d - h) / (d - h + (f - m)), i.copy(s).addScaledVector(JE, l);
    const g = 1 / (v + y + p);
    return o = y * g, l = p * g, i.copy(n).addScaledVector(fu, o).addScaledVector(mu, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const mP = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, ja = { h: 0, s: 0, l: 0 }, rf = { h: 0, s: 0, l: 0 };
function k0(r, e, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? r + (e - r) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - i) : r;
}
class Kt {
  constructor(e, i, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, i, n);
  }
  set(e, i, n) {
    if (i === void 0 && n === void 0) {
      const s = e;
      s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
    } else
      this.setRGB(e, i, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, i = ct) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Li.toWorkingColorSpace(this, i), this;
  }
  setRGB(e, i, n, s = Li.workingColorSpace) {
    return this.r = e, this.g = i, this.b = n, Li.toWorkingColorSpace(this, s), this;
  }
  setHSL(e, i, n, s = Li.workingColorSpace) {
    if (e = f1(e, 1), i = er(i, 0, 1), n = er(n, 0, 1), i === 0)
      this.r = this.g = this.b = n;
    else {
      const a = n <= 0.5 ? n * (1 + i) : n + i - n * i, o = 2 * n - a;
      this.r = k0(o, a, e + 1 / 3), this.g = k0(o, a, e), this.b = k0(o, a, e - 1 / 3);
    }
    return Li.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, i = ct) {
    function n(a) {
      a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let a;
      const o = s[1], l = s[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setRGB(
              Math.min(255, parseInt(a[1], 10)) / 255,
              Math.min(255, parseInt(a[2], 10)) / 255,
              Math.min(255, parseInt(a[3], 10)) / 255,
              i
            );
          if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setRGB(
              Math.min(100, parseInt(a[1], 10)) / 100,
              Math.min(100, parseInt(a[2], 10)) / 100,
              Math.min(100, parseInt(a[3], 10)) / 100,
              i
            );
          break;
        case "hsl":
        case "hsla":
          if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setHSL(
              parseFloat(a[1]) / 360,
              parseFloat(a[2]) / 100,
              parseFloat(a[3]) / 100,
              i
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const a = s[1], o = a.length;
      if (o === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          i
        );
      if (o === 6)
        return this.setHex(parseInt(a, 16), i);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, i);
    return this;
  }
  setColorName(e, i = ct) {
    const n = mP[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, i) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = ma(e.r), this.g = ma(e.g), this.b = ma(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Zu(e.r), this.g = Zu(e.g), this.b = Zu(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = ct) {
    return Li.fromWorkingColorSpace(hr.copy(this), e), Math.round(er(hr.r * 255, 0, 255)) * 65536 + Math.round(er(hr.g * 255, 0, 255)) * 256 + Math.round(er(hr.b * 255, 0, 255));
  }
  getHexString(e = ct) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, i = Li.workingColorSpace) {
    Li.fromWorkingColorSpace(hr.copy(this), i);
    const n = hr.r, s = hr.g, a = hr.b, o = Math.max(n, s, a), l = Math.min(n, s, a);
    let u, c;
    const h = (l + o) / 2;
    if (l === o)
      u = 0, c = 0;
    else {
      const d = o - l;
      switch (c = h <= 0.5 ? d / (o + l) : d / (2 - o - l), o) {
        case n:
          u = (s - a) / d + (s < a ? 6 : 0);
          break;
        case s:
          u = (a - n) / d + 2;
          break;
        case a:
          u = (n - s) / d + 4;
          break;
      }
      u /= 6;
    }
    return e.h = u, e.s = c, e.l = h, e;
  }
  getRGB(e, i = Li.workingColorSpace) {
    return Li.fromWorkingColorSpace(hr.copy(this), i), e.r = hr.r, e.g = hr.g, e.b = hr.b, e;
  }
  getStyle(e = ct) {
    Li.fromWorkingColorSpace(hr.copy(this), e);
    const i = hr.r, n = hr.g, s = hr.b;
    return e !== ct ? `color(${e} ${i.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(i * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
  }
  offsetHSL(e, i, n) {
    return this.getHSL(ja), this.setHSL(ja.h + e, ja.s + i, ja.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, i) {
    return this.r = e.r + i.r, this.g = e.g + i.g, this.b = e.b + i.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, i) {
    return this.r += (e.r - this.r) * i, this.g += (e.g - this.g) * i, this.b += (e.b - this.b) * i, this;
  }
  lerpColors(e, i, n) {
    return this.r = e.r + (i.r - e.r) * n, this.g = e.g + (i.g - e.g) * n, this.b = e.b + (i.b - e.b) * n, this;
  }
  lerpHSL(e, i) {
    this.getHSL(ja), e.getHSL(rf);
    const n = id(ja.h, rf.h, i), s = id(ja.s, rf.s, i), a = id(ja.l, rf.l, i);
    return this.setHSL(n, s, a), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const i = this.r, n = this.g, s = this.b, a = e.elements;
    return this.r = a[0] * i + a[3] * n + a[6] * s, this.g = a[1] * i + a[4] * n + a[7] * s, this.b = a[2] * i + a[5] * n + a[8] * s, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, i = 0) {
    return this.r = e[i], this.g = e[i + 1], this.b = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.r, e[i + 1] = this.g, e[i + 2] = this.b, e;
  }
  fromBufferAttribute(e, i) {
    return this.r = e.getX(i), this.g = e.getY(i), this.b = e.getZ(i), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const hr = /* @__PURE__ */ new Kt();
Kt.NAMES = mP;
let Z7 = 0;
class Gr extends zc {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(e) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Z7++ }), this.uuid = fa(), this.name = "", this.blending = co, this.side = bc, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Dm, this.blendDst = Lm, this.blendEquation = Ja, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Kt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = km, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = xx, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Go, this.stencilZFail = Go, this.stencilZPass = Go, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const i in e) {
        const n = e[i];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${i}' has value of undefined.`);
          continue;
        }
        const s = this[i];
        if (s === void 0) {
          console.warn(`THREE.Material: '${i}' is not a property of THREE.${this.type}.`);
          continue;
        }
        s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[i] = n;
      }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    i && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== co && (n.blending = this.blending), this.side !== bc && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Dm && (n.blendSrc = this.blendSrc), this.blendDst !== Lm && (n.blendDst = this.blendDst), this.blendEquation !== Ja && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== km && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== xx && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Go && (n.stencilFail = this.stencilFail), this.stencilZFail !== Go && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Go && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function s(a) {
      const o = [];
      for (const l in a) {
        const u = a[l];
        delete u.metadata, o.push(u);
      }
      return o;
    }
    if (i) {
      const a = s(e.textures), o = s(e.images);
      a.length > 0 && (n.textures = a), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const i = e.clippingPlanes;
    let n = null;
    if (i !== null) {
      const s = i.length;
      n = new Array(s);
      for (let a = 0; a !== s; ++a)
        n[a] = i[a].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class Og extends Gr {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Kt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qn(), this.combine = Ig, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const ea = /* @__PURE__ */ Q7();
function Q7() {
  const r = new ArrayBuffer(4), e = new Float32Array(r), i = new Uint32Array(r), n = new Uint32Array(512), s = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    const c = u - 127;
    c < -27 ? (n[u] = 0, n[u | 256] = 32768, s[u] = 24, s[u | 256] = 24) : c < -14 ? (n[u] = 1024 >> -c - 14, n[u | 256] = 1024 >> -c - 14 | 32768, s[u] = -c - 1, s[u | 256] = -c - 1) : c <= 15 ? (n[u] = c + 15 << 10, n[u | 256] = c + 15 << 10 | 32768, s[u] = 13, s[u | 256] = 13) : c < 128 ? (n[u] = 31744, n[u | 256] = 64512, s[u] = 24, s[u | 256] = 24) : (n[u] = 31744, n[u | 256] = 64512, s[u] = 13, s[u | 256] = 13);
  }
  const a = new Uint32Array(2048), o = new Uint32Array(64), l = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let c = u << 13, h = 0;
    for (; !(c & 8388608); )
      c <<= 1, h -= 8388608;
    c &= -8388609, h += 947912704, a[u] = c | h;
  }
  for (let u = 1024; u < 2048; ++u)
    a[u] = 939524096 + (u - 1024 << 13);
  for (let u = 1; u < 31; ++u)
    o[u] = u << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let u = 33; u < 63; ++u)
    o[u] = 2147483648 + (u - 32 << 23);
  o[63] = 3347054592;
  for (let u = 1; u < 64; ++u)
    u !== 32 && (l[u] = 1024);
  return {
    floatView: e,
    uint32View: i,
    baseTable: n,
    shiftTable: s,
    mantissaTable: a,
    exponentTable: o,
    offsetTable: l
  };
}
function Qr(r) {
  Math.abs(r) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), r = er(r, -65504, 65504), ea.floatView[0] = r;
  const e = ea.uint32View[0], i = e >> 23 & 511;
  return ea.baseTable[i] + ((e & 8388607) >> ea.shiftTable[i]);
}
function nf(r) {
  const e = r >> 10;
  return ea.uint32View[0] = ea.mantissaTable[ea.offsetTable[e] + (r & 1023)] + ea.exponentTable[e], ea.floatView[0];
}
const Ii = /* @__PURE__ */ new ue(), sf = /* @__PURE__ */ new Vt();
class _n {
  constructor(e, i, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = i, this.count = e !== void 0 ? e.length / i : 0, this.normalized = n, this.usage = Bm, this.updateRanges = [], this.gpuType = an, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, i) {
    this.updateRanges.push({ start: e, count: i });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, i, n) {
    e *= this.itemSize, n *= i.itemSize;
    for (let s = 0, a = this.itemSize; s < a; s++)
      this.array[e + s] = i.array[n + s];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let i = 0, n = this.count; i < n; i++)
        sf.fromBufferAttribute(this, i), sf.applyMatrix3(e), this.setXY(i, sf.x, sf.y);
    else if (this.itemSize === 3)
      for (let i = 0, n = this.count; i < n; i++)
        Ii.fromBufferAttribute(this, i), Ii.applyMatrix3(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Ii.fromBufferAttribute(this, i), Ii.applyMatrix4(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Ii.fromBufferAttribute(this, i), Ii.applyNormalMatrix(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Ii.fromBufferAttribute(this, i), Ii.transformDirection(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  set(e, i = 0) {
    return this.array.set(e, i), this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.itemSize + i];
    return this.normalized && (n = Er(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = wt(n, this.array)), this.array[e * this.itemSize + i] = n, this;
  }
  getX(e) {
    let i = this.array[e * this.itemSize];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setX(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize] = i, this;
  }
  getY(e) {
    let i = this.array[e * this.itemSize + 1];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setY(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 1] = i, this;
  }
  getZ(e) {
    let i = this.array[e * this.itemSize + 2];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setZ(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 2] = i, this;
  }
  getW(e) {
    let i = this.array[e * this.itemSize + 3];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setW(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 3] = i, this;
  }
  setXY(e, i, n) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array), a = wt(a, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this.array[e + 2] = s, this.array[e + 3] = a, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Bm && (e.usage = this.usage), e;
  }
}
class gP extends _n {
  constructor(e, i, n) {
    super(new Uint16Array(e), i, n);
  }
}
class yP extends _n {
  constructor(e, i, n) {
    super(new Uint32Array(e), i, n);
  }
}
class vP extends _n {
  constructor(e, i, n) {
    super(new Uint16Array(e), i, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let i = nf(this.array[e * this.itemSize]);
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setX(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize] = Qr(i), this;
  }
  getY(e) {
    let i = nf(this.array[e * this.itemSize + 1]);
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setY(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 1] = Qr(i), this;
  }
  getZ(e) {
    let i = nf(this.array[e * this.itemSize + 2]);
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setZ(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 2] = Qr(i), this;
  }
  getW(e) {
    let i = nf(this.array[e * this.itemSize + 3]);
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setW(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.array[e * this.itemSize + 3] = Qr(i), this;
  }
  setXY(e, i, n) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array)), this.array[e + 0] = Qr(i), this.array[e + 1] = Qr(n), this;
  }
  setXYZ(e, i, n, s) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array)), this.array[e + 0] = Qr(i), this.array[e + 1] = Qr(n), this.array[e + 2] = Qr(s), this;
  }
  setXYZW(e, i, n, s, a) {
    return e *= this.itemSize, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array), a = wt(a, this.array)), this.array[e + 0] = Qr(i), this.array[e + 1] = Qr(n), this.array[e + 2] = Qr(s), this.array[e + 3] = Qr(a), this;
  }
}
class ga extends _n {
  constructor(e, i, n) {
    super(new Float32Array(e), i, n);
  }
}
let J7 = 0;
const dn = /* @__PURE__ */ new gi(), U0 = /* @__PURE__ */ new Ki(), gu = /* @__PURE__ */ new ue(), Jr = /* @__PURE__ */ new Qd(), bh = /* @__PURE__ */ new Qd(), qi = /* @__PURE__ */ new ue();
class Il extends zc {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: J7++ }), this.uuid = fa(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (D7(e) ? yP : gP)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, i) {
    return this.attributes[e] = i, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, i, n = 0) {
    this.groups.push({
      start: e,
      count: i,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, i) {
    this.drawRange.start = e, this.drawRange.count = i;
  }
  applyMatrix4(e) {
    const i = this.attributes.position;
    i !== void 0 && (i.applyMatrix4(e), i.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const a = new qr().getNormalMatrix(e);
      n.applyNormalMatrix(a), n.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return dn.makeRotationFromQuaternion(e), this.applyMatrix4(dn), this;
  }
  rotateX(e) {
    return dn.makeRotationX(e), this.applyMatrix4(dn), this;
  }
  rotateY(e) {
    return dn.makeRotationY(e), this.applyMatrix4(dn), this;
  }
  rotateZ(e) {
    return dn.makeRotationZ(e), this.applyMatrix4(dn), this;
  }
  translate(e, i, n) {
    return dn.makeTranslation(e, i, n), this.applyMatrix4(dn), this;
  }
  scale(e, i, n) {
    return dn.makeScale(e, i, n), this.applyMatrix4(dn), this;
  }
  lookAt(e) {
    return U0.lookAt(e), U0.updateMatrix(), this.applyMatrix4(U0.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(gu).negate(), this.translate(gu.x, gu.y, gu.z), this;
  }
  setFromPoints(e) {
    const i = this.getAttribute("position");
    if (i === void 0) {
      const n = [];
      for (let s = 0, a = e.length; s < a; s++) {
        const o = e[s];
        n.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new ga(n, 3));
    } else {
      for (let n = 0, s = i.count; n < s; n++) {
        const a = e[n];
        i.setXYZ(n, a.x, a.y, a.z || 0);
      }
      e.length > i.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), i.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Qd());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new ue(-1 / 0, -1 / 0, -1 / 0),
        new ue(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), i)
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n];
          Jr.setFromBufferAttribute(a), this.morphTargetsRelative ? (qi.addVectors(this.boundingBox.min, Jr.min), this.boundingBox.expandByPoint(qi), qi.addVectors(this.boundingBox.max, Jr.max), this.boundingBox.expandByPoint(qi)) : (this.boundingBox.expandByPoint(Jr.min), this.boundingBox.expandByPoint(Jr.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new m1());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new ue(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (Jr.setFromBufferAttribute(e), i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a];
          bh.setFromBufferAttribute(l), this.morphTargetsRelative ? (qi.addVectors(Jr.min, bh.min), Jr.expandByPoint(qi), qi.addVectors(Jr.max, bh.max), Jr.expandByPoint(qi)) : (Jr.expandByPoint(bh.min), Jr.expandByPoint(bh.max));
        }
      Jr.getCenter(n);
      let s = 0;
      for (let a = 0, o = e.count; a < o; a++)
        qi.fromBufferAttribute(e, a), s = Math.max(s, n.distanceToSquared(qi));
      if (i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a], u = this.morphTargetsRelative;
          for (let c = 0, h = l.count; c < h; c++)
            qi.fromBufferAttribute(l, c), u && (gu.fromBufferAttribute(e, c), qi.add(gu)), s = Math.max(s, n.distanceToSquared(qi));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, i = this.attributes;
    if (e === null || i.position === void 0 || i.normal === void 0 || i.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = i.position, s = i.normal, a = i.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new _n(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"), l = [], u = [];
    for (let M = 0; M < n.count; M++)
      l[M] = new ue(), u[M] = new ue();
    const c = new ue(), h = new ue(), d = new ue(), p = new Vt(), f = new Vt(), m = new Vt(), y = new ue(), v = new ue();
    function g(M, E, A) {
      c.fromBufferAttribute(n, M), h.fromBufferAttribute(n, E), d.fromBufferAttribute(n, A), p.fromBufferAttribute(a, M), f.fromBufferAttribute(a, E), m.fromBufferAttribute(a, A), h.sub(c), d.sub(c), f.sub(p), m.sub(p);
      const N = 1 / (f.x * m.y - m.x * f.y);
      isFinite(N) && (y.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(N), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(N), l[M].add(y), l[E].add(y), l[A].add(y), u[M].add(v), u[E].add(v), u[A].add(v));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{
      start: 0,
      count: e.count
    }]);
    for (let M = 0, E = _.length; M < E; ++M) {
      const A = _[M], N = A.start, U = A.count;
      for (let k = N, C = N + U; k < C; k += 3)
        g(
          e.getX(k + 0),
          e.getX(k + 1),
          e.getX(k + 2)
        );
    }
    const x = new ue(), b = new ue(), T = new ue(), S = new ue();
    function w(M) {
      T.fromBufferAttribute(s, M), S.copy(T);
      const E = l[M];
      x.copy(E), x.sub(T.multiplyScalar(T.dot(E))).normalize(), b.crossVectors(S, E);
      const A = b.dot(u[M]) < 0 ? -1 : 1;
      o.setXYZW(M, x.x, x.y, x.z, A);
    }
    for (let M = 0, E = _.length; M < E; ++M) {
      const A = _[M], N = A.start, U = A.count;
      for (let k = N, C = N + U; k < C; k += 3)
        w(e.getX(k + 0)), w(e.getX(k + 1)), w(e.getX(k + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, i = this.getAttribute("position");
    if (i !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new _n(new Float32Array(i.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let p = 0, f = n.count; p < f; p++)
          n.setXYZ(p, 0, 0, 0);
      const s = new ue(), a = new ue(), o = new ue(), l = new ue(), u = new ue(), c = new ue(), h = new ue(), d = new ue();
      if (e)
        for (let p = 0, f = e.count; p < f; p += 3) {
          const m = e.getX(p + 0), y = e.getX(p + 1), v = e.getX(p + 2);
          s.fromBufferAttribute(i, m), a.fromBufferAttribute(i, y), o.fromBufferAttribute(i, v), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, y), c.fromBufferAttribute(n, v), l.add(h), u.add(h), c.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(y, u.x, u.y, u.z), n.setXYZ(v, c.x, c.y, c.z);
        }
      else
        for (let p = 0, f = i.count; p < f; p += 3)
          s.fromBufferAttribute(i, p + 0), a.fromBufferAttribute(i, p + 1), o.fromBufferAttribute(i, p + 2), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), n.setXYZ(p + 0, h.x, h.y, h.z), n.setXYZ(p + 1, h.x, h.y, h.z), n.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let i = 0, n = e.count; i < n; i++)
      qi.fromBufferAttribute(e, i), qi.normalize(), e.setXYZ(i, qi.x, qi.y, qi.z);
  }
  toNonIndexed() {
    function e(l, u) {
      const c = l.array, h = l.itemSize, d = l.normalized, p = new c.constructor(u.length * h);
      let f = 0, m = 0;
      for (let y = 0, v = u.length; y < v; y++) {
        l.isInterleavedBufferAttribute ? f = u[y] * l.data.stride + l.offset : f = u[y] * h;
        for (let g = 0; g < h; g++)
          p[m++] = c[f++];
      }
      return new _n(p, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const i = new Il(), n = this.index.array, s = this.attributes;
    for (const l in s) {
      const u = s[l], c = e(u, n);
      i.setAttribute(l, c);
    }
    const a = this.morphAttributes;
    for (const l in a) {
      const u = [], c = a[l];
      for (let h = 0, d = c.length; h < d; h++) {
        const p = c[h], f = e(p, n);
        u.push(f);
      }
      i.morphAttributes[l] = u;
    }
    i.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const c = o[l];
      i.addGroup(c.start, c.count, c.materialIndex);
    }
    return i;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const u = this.parameters;
      for (const c in u)
        u[c] !== void 0 && (e[c] = u[c]);
      return e;
    }
    e.data = { attributes: {} };
    const i = this.index;
    i !== null && (e.data.index = {
      type: i.array.constructor.name,
      array: Array.prototype.slice.call(i.array)
    });
    const n = this.attributes;
    for (const u in n) {
      const c = n[u];
      e.data.attributes[u] = c.toJSON(e.data);
    }
    const s = {};
    let a = !1;
    for (const u in this.morphAttributes) {
      const c = this.morphAttributes[u], h = [];
      for (let d = 0, p = c.length; d < p; d++) {
        const f = c[d];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (s[u] = h, a = !0);
    }
    a && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const i = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(i));
    const s = e.attributes;
    for (const c in s) {
      const h = s[c];
      this.setAttribute(c, h.clone(i));
    }
    const a = e.morphAttributes;
    for (const c in a) {
      const h = [], d = a[c];
      for (let p = 0, f = d.length; p < f; p++)
        h.push(d[p].clone(i));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = e.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const eM = /* @__PURE__ */ new gi(), Uo = /* @__PURE__ */ new G7(), af = /* @__PURE__ */ new m1(), tM = /* @__PURE__ */ new ue(), of = /* @__PURE__ */ new ue(), lf = /* @__PURE__ */ new ue(), uf = /* @__PURE__ */ new ue(), F0 = /* @__PURE__ */ new ue(), cf = /* @__PURE__ */ new ue(), iM = /* @__PURE__ */ new ue(), hf = /* @__PURE__ */ new ue();
class El extends Ki {
  constructor(e = new Il(), i = new Og()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = i, this.updateMorphTargets();
  }
  copy(e, i) {
    return super.copy(e, i), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, i = Object.keys(e);
    if (i.length > 0) {
      const n = e[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
        }
      }
    }
  }
  getVertexPosition(e, i) {
    const n = this.geometry, s = n.attributes.position, a = n.morphAttributes.position, o = n.morphTargetsRelative;
    i.fromBufferAttribute(s, e);
    const l = this.morphTargetInfluences;
    if (a && l) {
      cf.set(0, 0, 0);
      for (let u = 0, c = a.length; u < c; u++) {
        const h = l[u], d = a[u];
        h !== 0 && (F0.fromBufferAttribute(d, e), o ? cf.addScaledVector(F0, h) : cf.addScaledVector(F0.sub(i), h));
      }
      i.add(cf);
    }
    return i;
  }
  raycast(e, i) {
    const n = this.geometry, s = this.material, a = this.matrixWorld;
    s !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), af.copy(n.boundingSphere), af.applyMatrix4(a), Uo.copy(e.ray).recast(e.near), !(af.containsPoint(Uo.origin) === !1 && (Uo.intersectSphere(af, tM) === null || Uo.origin.distanceToSquared(tM) > (e.far - e.near) ** 2)) && (eM.copy(a).invert(), Uo.copy(e.ray).applyMatrix4(eM), !(n.boundingBox !== null && Uo.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, i, Uo)));
  }
  _computeIntersections(e, i, n) {
    let s;
    const a = this.geometry, o = this.material, l = a.index, u = a.attributes.position, c = a.attributes.uv, h = a.attributes.uv1, d = a.attributes.normal, p = a.groups, f = a.drawRange;
    if (l !== null)
      if (Array.isArray(o))
        for (let m = 0, y = p.length; m < y; m++) {
          const v = p[m], g = o[v.materialIndex], _ = Math.max(v.start, f.start), x = Math.min(l.count, Math.min(v.start + v.count, f.start + f.count));
          for (let b = _, T = x; b < T; b += 3) {
            const S = l.getX(b), w = l.getX(b + 1), M = l.getX(b + 2);
            s = df(this, g, e, n, c, h, d, S, w, M), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = v.materialIndex, i.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), y = Math.min(l.count, f.start + f.count);
        for (let v = m, g = y; v < g; v += 3) {
          const _ = l.getX(v), x = l.getX(v + 1), b = l.getX(v + 2);
          s = df(this, o, e, n, c, h, d, _, x, b), s && (s.faceIndex = Math.floor(v / 3), i.push(s));
        }
      }
    else if (u !== void 0)
      if (Array.isArray(o))
        for (let m = 0, y = p.length; m < y; m++) {
          const v = p[m], g = o[v.materialIndex], _ = Math.max(v.start, f.start), x = Math.min(u.count, Math.min(v.start + v.count, f.start + f.count));
          for (let b = _, T = x; b < T; b += 3) {
            const S = b, w = b + 1, M = b + 2;
            s = df(this, g, e, n, c, h, d, S, w, M), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = v.materialIndex, i.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), y = Math.min(u.count, f.start + f.count);
        for (let v = m, g = y; v < g; v += 3) {
          const _ = v, x = v + 1, b = v + 2;
          s = df(this, o, e, n, c, h, d, _, x, b), s && (s.faceIndex = Math.floor(v / 3), i.push(s));
        }
      }
  }
}
function eW(r, e, i, n, s, a, o, l) {
  let u;
  if (e.side === Zn ? u = n.intersectTriangle(o, a, s, !0, l) : u = n.intersectTriangle(s, a, o, e.side === bc, l), u === null) return null;
  hf.copy(l), hf.applyMatrix4(r.matrixWorld);
  const c = i.ray.origin.distanceTo(hf);
  return c < i.near || c > i.far ? null : {
    distance: c,
    point: hf.clone(),
    object: r
  };
}
function df(r, e, i, n, s, a, o, l, u, c) {
  r.getVertexPosition(l, of), r.getVertexPosition(u, lf), r.getVertexPosition(c, uf);
  const h = eW(r, e, i, n, of, lf, uf, iM);
  if (h) {
    const d = new ue();
    qn.getBarycoord(iM, of, lf, uf, d), s && (h.uv = qn.getInterpolatedAttribute(s, l, u, c, d, new Vt())), a && (h.uv1 = qn.getInterpolatedAttribute(a, l, u, c, d, new Vt())), o && (h.normal = qn.getInterpolatedAttribute(o, l, u, c, d, new ue()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const p = {
      a: l,
      b: u,
      c,
      normal: new ue(),
      materialIndex: 0
    };
    qn.getNormal(of, lf, uf, p.normal), h.face = p, h.barycoord = d;
  }
  return h;
}
class Jd extends Il {
  constructor(e = 1, i = 1, n = 1, s = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: i,
      depth: n,
      widthSegments: s,
      heightSegments: a,
      depthSegments: o
    };
    const l = this;
    s = Math.floor(s), a = Math.floor(a), o = Math.floor(o);
    const u = [], c = [], h = [], d = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, n, i, e, o, a, 0), m("z", "y", "x", 1, -1, n, i, -e, o, a, 1), m("x", "z", "y", 1, 1, e, n, i, s, o, 2), m("x", "z", "y", 1, -1, e, n, -i, s, o, 3), m("x", "y", "z", 1, -1, e, i, n, s, a, 4), m("x", "y", "z", -1, -1, e, i, -n, s, a, 5), this.setIndex(u), this.setAttribute("position", new ga(c, 3)), this.setAttribute("normal", new ga(h, 3)), this.setAttribute("uv", new ga(d, 2));
    function m(y, v, g, _, x, b, T, S, w, M, E) {
      const A = b / w, N = T / M, U = b / 2, k = T / 2, C = S / 2, I = w + 1, O = M + 1;
      let W = 0, V = 0;
      const Q = new ue();
      for (let F = 0; F < O; F++) {
        const B = F * N - k;
        for (let q = 0; q < I; q++) {
          const G = q * A - U;
          Q[y] = G * _, Q[v] = B * x, Q[g] = C, c.push(Q.x, Q.y, Q.z), Q[y] = 0, Q[v] = 0, Q[g] = S > 0 ? 1 : -1, h.push(Q.x, Q.y, Q.z), d.push(q / w), d.push(1 - F / M), W += 1;
        }
      }
      for (let F = 0; F < M; F++)
        for (let B = 0; B < w; B++) {
          const q = p + B + I * F, G = p + B + I * (F + 1), z = p + (B + 1) + I * (F + 1), Y = p + (B + 1) + I * F;
          u.push(q, G, Y), u.push(G, z, Y), V += 6;
        }
      l.addGroup(f, V, E), f += V, p += W;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Jd(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function bP(r) {
  const e = {};
  for (const i in r) {
    e[i] = {};
    for (const n in r[i]) {
      const s = r[i][n];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][n] = null) : e[i][n] = s.clone() : Array.isArray(s) ? e[i][n] = s.slice() : e[i][n] = s;
    }
  }
  return e;
}
function tW(r) {
  const e = [];
  for (let i = 0; i < r.length; i++)
    e.push(r[i].clone());
  return e;
}
var iW = (
  /* glsl */
  `
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`
), rW = (
  /* glsl */
  `
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`
);
class nW extends Gr {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = iW, this.fragmentShader = rW, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = bP(e.uniforms), this.uniformsGroups = tW(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    i.glslVersion = this.glslVersion, i.uniforms = {};
    for (const s in this.uniforms) {
      const a = this.uniforms[s].value;
      a && a.isTexture ? i.uniforms[s] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? i.uniforms[s] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? i.uniforms[s] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? i.uniforms[s] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? i.uniforms[s] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? i.uniforms[s] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? i.uniforms[s] = {
        type: "m4",
        value: a.toArray()
      } : i.uniforms[s] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (i.defines = this.defines), i.vertexShader = this.vertexShader, i.fragmentShader = this.fragmentShader, i.lights = this.lights, i.clipping = this.clipping;
    const n = {};
    for (const s in this.extensions)
      this.extensions[s] === !0 && (n[s] = !0);
    return Object.keys(n).length > 0 && (i.extensions = n), i;
  }
}
class xP extends Ki {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new gi(), this.projectionMatrix = new gi(), this.projectionMatrixInverse = new gi(), this.coordinateSystem = Yn;
  }
  copy(e, i) {
    return super.copy(e, i), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, i) {
    super.updateWorldMatrix(e, i), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Va = /* @__PURE__ */ new ue(), rM = /* @__PURE__ */ new Vt(), nM = /* @__PURE__ */ new Vt();
class $s extends xP {
  constructor(e = 50, i = 1, n = 0.1, s = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = s, this.focus = 10, this.aspect = i, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, i) {
    return super.copy(e, i), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const i = 0.5 * this.getFilmHeight() / e;
    this.fov = bd * 2 * Math.atan(i), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(td * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return bd * 2 * Math.atan(
      Math.tan(td * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, i, n) {
    Va.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Va.x, Va.y).multiplyScalar(-e / Va.z), Va.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Va.x, Va.y).multiplyScalar(-e / Va.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, i) {
    return this.getViewBounds(e, rM, nM), i.subVectors(nM, rM);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, i, n, s, a, o) {
    this.aspect = e / i, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = i, this.view.offsetX = n, this.view.offsetY = s, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let i = e * Math.tan(td * 0.5 * this.fov) / this.zoom, n = 2 * i, s = this.aspect * n, a = -0.5 * s;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = o.fullWidth, c = o.fullHeight;
      a += o.offsetX * s / u, i -= o.offsetY * n / c, s *= o.width / u, n *= o.height / c;
    }
    const l = this.filmOffset;
    l !== 0 && (a += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + s, i, i - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.fov = this.fov, i.object.zoom = this.zoom, i.object.near = this.near, i.object.far = this.far, i.object.focus = this.focus, i.object.aspect = this.aspect, this.view !== null && (i.object.view = Object.assign({}, this.view)), i.object.filmGauge = this.filmGauge, i.object.filmOffset = this.filmOffset, i;
  }
}
const yu = -90, vu = 1;
class _P extends Ki {
  constructor(e, i, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const s = new $s(yu, vu, e, i);
    s.layers = this.layers, this.add(s);
    const a = new $s(yu, vu, e, i);
    a.layers = this.layers, this.add(a);
    const o = new $s(yu, vu, e, i);
    o.layers = this.layers, this.add(o);
    const l = new $s(yu, vu, e, i);
    l.layers = this.layers, this.add(l);
    const u = new $s(yu, vu, e, i);
    u.layers = this.layers, this.add(u);
    const c = new $s(yu, vu, e, i);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, i = this.children.concat(), [n, s, a, o, l, u] = i;
    for (const c of i) this.remove(c);
    if (e === Yn)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), a.up.set(0, 0, -1), a.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), u.up.set(0, 1, 0), u.lookAt(0, 0, -1);
    else if (e === wl)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), a.up.set(0, 0, 1), a.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), u.up.set(0, -1, 0), u.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const c of i)
      this.add(c), c.updateMatrixWorld();
  }
  update(e, i) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: s } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [a, o, l, u, c, h] = this.children, d = e.getRenderTarget(), p = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = !1;
    const y = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, s), e.render(i, a), e.setRenderTarget(n, 1, s), e.render(i, o), e.setRenderTarget(n, 2, s), e.render(i, l), e.setRenderTarget(n, 3, s), e.render(i, u), e.setRenderTarget(n, 4, s), e.render(i, c), n.texture.generateMipmaps = y, e.setRenderTarget(n, 5, s), e.render(i, h), e.setRenderTarget(d, p, f), e.xr.enabled = m, n.texture.needsPMREMUpdate = !0;
  }
}
class g1 extends Ar {
  constructor(e, i, n, s, a, o, l, u, c, h) {
    e = e !== void 0 ? e : [], i = i !== void 0 ? i : Tl, super(e, i, n, s, a, o, l, u, c, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class sW extends z7 {
  constructor(e = 1, i = {}) {
    super(e, e, i), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, s = [n, n, n, n, n, n];
    this.texture = new g1(s, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : on;
  }
  fromEquirectangularTexture(e, i) {
    this.texture.type = i.type, this.texture.colorSpace = i.colorSpace, this.texture.generateMipmaps = i.generateMipmaps, this.texture.minFilter = i.minFilter, this.texture.magFilter = i.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, s = new Jd(5, 5, 5), a = new nW({
      name: "CubemapFromEquirect",
      uniforms: bP(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: Zn,
      blending: xc
    });
    a.uniforms.tEquirect.value = i;
    const o = new El(s, a), l = i.minFilter;
    return i.minFilter === da && (i.minFilter = on), new _P(1, 10, this).update(e, o), i.minFilter = l, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, i, n, s) {
    const a = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(i, n, s);
    e.setRenderTarget(a);
  }
}
class TP extends Ki {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Qn(), this.environmentIntensity = 1, this.environmentRotation = new Qn(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, i) {
    return super.copy(e, i), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return this.fog !== null && (i.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (i.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (i.object.backgroundIntensity = this.backgroundIntensity), i.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (i.object.environmentIntensity = this.environmentIntensity), i.object.environmentRotation = this.environmentRotation.toArray(), i;
  }
}
class SP {
  constructor(e, i) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = i, this.count = e !== void 0 ? e.length / i : 0, this.usage = Bm, this.updateRanges = [], this.version = 0, this.uuid = fa();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, i) {
    this.updateRanges.push({ start: e, count: i });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, i, n) {
    e *= this.stride, n *= i.stride;
    for (let s = 0, a = this.stride; s < a; s++)
      this.array[e + s] = i.array[n + s];
    return this;
  }
  set(e, i = 0) {
    return this.array.set(e, i), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fa()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const i = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(i, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fa()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const br = /* @__PURE__ */ new ue();
class y1 {
  constructor(e, i, n, s = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = i, this.offset = n, this.normalized = s;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.data.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.applyMatrix4(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.applyNormalMatrix(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.transformDirection(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.data.stride + this.offset + i];
    return this.normalized && (n = Er(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = wt(n, this.array)), this.data.array[e * this.data.stride + this.offset + i] = n, this;
  }
  setX(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.data.array[e * this.data.stride + this.offset] = i, this;
  }
  setY(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = i, this;
  }
  setZ(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = i, this;
  }
  setW(e, i) {
    return this.normalized && (i = wt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = i, this;
  }
  getX(e) {
    let i = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  getY(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  getZ(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  getW(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setXY(e, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = wt(i, this.array), n = wt(n, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = wt(i, this.array), n = wt(n, this.array), s = wt(s, this.array), a = wt(a, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = a, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return new _n(new this.array.constructor(i), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new y1(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: i,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class wP extends Gr {
  static get type() {
    return "SpriteMaterial";
  }
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.color = new Kt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
class aW extends Ar {
  constructor(e = null, i = 1, n = 1, s, a, o, l, u, c = mr, h = mr, d, p) {
    super(null, o, l, u, c, h, s, a, d, p), this.isDataTexture = !0, this.image = { data: e, width: i, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class oW extends _n {
  constructor(e, i, n, s = 1) {
    super(e, i, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const B0 = /* @__PURE__ */ new ue(), lW = /* @__PURE__ */ new ue(), uW = /* @__PURE__ */ new qr();
class Ka {
  constructor(e = new ue(1, 0, 0), i = 0) {
    this.isPlane = !0, this.normal = e, this.constant = i;
  }
  set(e, i) {
    return this.normal.copy(e), this.constant = i, this;
  }
  setComponents(e, i, n, s) {
    return this.normal.set(e, i, n), this.constant = s, this;
  }
  setFromNormalAndCoplanarPoint(e, i) {
    return this.normal.copy(e), this.constant = -i.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, i, n) {
    const s = B0.subVectors(n, i).cross(lW.subVectors(e, i)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, i) {
    return i.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, i) {
    const n = e.delta(B0), s = this.normal.dot(n);
    if (s === 0)
      return this.distanceToPoint(e.start) === 0 ? i.copy(e.start) : null;
    const a = -(e.start.dot(this.normal) + this.constant) / s;
    return a < 0 || a > 1 ? null : i.copy(e.start).addScaledVector(n, a);
  }
  intersectsLine(e) {
    const i = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return i < 0 && n > 0 || n < 0 && i > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, i) {
    const n = i || uW.getNormalMatrix(e), s = this.coplanarPoint(B0).applyMatrix4(e), a = this.normal.applyMatrix3(n).normalize();
    return this.constant = -s.dot(a), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Fo = /* @__PURE__ */ new m1(), pf = /* @__PURE__ */ new ue();
class EP {
  constructor(e = new Ka(), i = new Ka(), n = new Ka(), s = new Ka(), a = new Ka(), o = new Ka()) {
    this.planes = [e, i, n, s, a, o];
  }
  set(e, i, n, s, a, o) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(i), l[2].copy(n), l[3].copy(s), l[4].copy(a), l[5].copy(o), this;
  }
  copy(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++)
      i[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, i = Yn) {
    const n = this.planes, s = e.elements, a = s[0], o = s[1], l = s[2], u = s[3], c = s[4], h = s[5], d = s[6], p = s[7], f = s[8], m = s[9], y = s[10], v = s[11], g = s[12], _ = s[13], x = s[14], b = s[15];
    if (n[0].setComponents(u - a, p - c, v - f, b - g).normalize(), n[1].setComponents(u + a, p + c, v + f, b + g).normalize(), n[2].setComponents(u + o, p + h, v + m, b + _).normalize(), n[3].setComponents(u - o, p - h, v - m, b - _).normalize(), n[4].setComponents(u - l, p - d, v - y, b - x).normalize(), i === Yn)
      n[5].setComponents(u + l, p + d, v + y, b + x).normalize();
    else if (i === wl)
      n[5].setComponents(l, d, y, x).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + i);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Fo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const i = e.geometry;
      i.boundingSphere === null && i.computeBoundingSphere(), Fo.copy(i.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Fo);
  }
  intersectsSprite(e) {
    return Fo.center.set(0, 0, 0), Fo.radius = 0.7071067811865476, Fo.applyMatrix4(e.matrixWorld), this.intersectsSphere(Fo);
  }
  intersectsSphere(e) {
    const i = this.planes, n = e.center, s = -e.radius;
    for (let a = 0; a < 6; a++)
      if (i[a].distanceToPoint(n) < s)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++) {
      const s = i[n];
      if (pf.x = s.normal.x > 0 ? e.max.x : e.min.x, pf.y = s.normal.y > 0 ? e.max.y : e.min.y, pf.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(pf) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++)
      if (i[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class v1 extends Gr {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.color = new Kt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
class MP extends Gr {
  static get type() {
    return "PointsMaterial";
  }
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.color = new Kt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
class cW extends Ar {
  constructor(e, i) {
    super({ width: e, height: i }), this.isFramebufferTexture = !0, this.magFilter = mr, this.minFilter = mr, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class Vc extends Ar {
  constructor(e, i, n, s, a, o, l, u, c, h = gl) {
    if (h !== gl && h !== Tc)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && h === gl && (n = Ji), n === void 0 && h === Tc && (n = Kd), super(null, s, a, o, l, u, h, n, c), this.isDepthTexture = !0, this.image = { width: e, height: i }, this.magFilter = l !== void 0 ? l : mr, this.minFilter = u !== void 0 ? u : mr, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return this.compareFunction !== null && (i.compareFunction = this.compareFunction), i;
  }
}
class b1 extends Il {
  constructor(e = 1, i = 32, n = 16, s = 0, a = Math.PI * 2, o = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: i,
      heightSegments: n,
      phiStart: s,
      phiLength: a,
      thetaStart: o,
      thetaLength: l
    }, i = Math.max(3, Math.floor(i)), n = Math.max(2, Math.floor(n));
    const u = Math.min(o + l, Math.PI);
    let c = 0;
    const h = [], d = new ue(), p = new ue(), f = [], m = [], y = [], v = [];
    for (let g = 0; g <= n; g++) {
      const _ = [], x = g / n;
      let b = 0;
      g === 0 && o === 0 ? b = 0.5 / i : g === n && u === Math.PI && (b = -0.5 / i);
      for (let T = 0; T <= i; T++) {
        const S = T / i;
        d.x = -e * Math.cos(s + S * a) * Math.sin(o + x * l), d.y = e * Math.cos(o + x * l), d.z = e * Math.sin(s + S * a) * Math.sin(o + x * l), m.push(d.x, d.y, d.z), p.copy(d).normalize(), y.push(p.x, p.y, p.z), v.push(S + b, 1 - x), _.push(c++);
      }
      h.push(_);
    }
    for (let g = 0; g < n; g++)
      for (let _ = 0; _ < i; _++) {
        const x = h[g][_ + 1], b = h[g][_], T = h[g + 1][_], S = h[g + 1][_ + 1];
        (g !== 0 || o > 0) && f.push(x, b, S), (g !== n - 1 || u < Math.PI) && f.push(b, T, S);
      }
    this.setIndex(f), this.setAttribute("position", new ga(m, 3)), this.setAttribute("normal", new ga(y, 3)), this.setAttribute("uv", new ga(v, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new b1(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class AP extends Gr {
  static get type() {
    return "ShadowMaterial";
  }
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.color = new Kt(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class x1 extends Gr {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.color = new Kt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qn(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class CP extends x1 {
  static get type() {
    return "MeshPhysicalMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return er(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(i) {
        this.ior = (1 + 0.4 * i) / (1 - 0.4 * i);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Kt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Kt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Kt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class RP extends Gr {
  static get type() {
    return "MeshPhongMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.color = new Kt(16777215), this.specular = new Kt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qn(), this.combine = Ig, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class NP extends Gr {
  static get type() {
    return "MeshToonMaterial";
  }
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.color = new Kt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class PP extends Gr {
  static get type() {
    return "MeshNormalMaterial";
  }
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class IP extends Gr {
  static get type() {
    return "MeshLambertMaterial";
  }
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.color = new Kt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qn(), this.combine = Ig, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class OP extends Gr {
  static get type() {
    return "MeshMatcapMaterial";
  }
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.color = new Kt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class DP extends v1 {
  static get type() {
    return "LineDashedMaterial";
  }
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
class Ol extends Ki {
  constructor(e, i = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Kt(e), this.intensity = i;
  }
  dispose() {
  }
  copy(e, i) {
    return super.copy(e, i), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.color = this.color.getHex(), i.object.intensity = this.intensity, this.groundColor !== void 0 && (i.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (i.object.distance = this.distance), this.angle !== void 0 && (i.object.angle = this.angle), this.decay !== void 0 && (i.object.decay = this.decay), this.penumbra !== void 0 && (i.object.penumbra = this.penumbra), this.shadow !== void 0 && (i.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (i.object.target = this.target.uuid), i;
  }
}
class hW extends Ol {
  constructor(e, i, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Ki.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Kt(i);
  }
  copy(e, i) {
    return super.copy(e, i), this.groundColor.copy(e.groundColor), this;
  }
}
const z0 = /* @__PURE__ */ new gi(), sM = /* @__PURE__ */ new ue(), aM = /* @__PURE__ */ new ue();
class _1 {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vt(512, 512), this.map = null, this.mapPass = null, this.matrix = new gi(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new EP(), this._frameExtents = new Vt(1, 1), this._viewportCount = 1, this._viewports = [
      new Yt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const i = this.camera, n = this.matrix;
    sM.setFromMatrixPosition(e.matrixWorld), i.position.copy(sM), aM.setFromMatrixPosition(e.target.matrixWorld), i.lookAt(aM), i.updateMatrixWorld(), z0.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(z0), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(z0);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class dW extends _1 {
  constructor() {
    super(new $s(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const i = this.camera, n = bd * 2 * e.angle * this.focus, s = this.mapSize.width / this.mapSize.height, a = e.distance || i.far;
    (n !== i.fov || s !== i.aspect || a !== i.far) && (i.fov = n, i.aspect = s, i.far = a, i.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class LP extends Ol {
  constructor(e, i, n = 0, s = Math.PI / 3, a = 0, o = 2) {
    super(e, i), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Ki.DEFAULT_UP), this.updateMatrix(), this.target = new Ki(), this.distance = n, this.angle = s, this.penumbra = a, this.decay = o, this.map = null, this.shadow = new dW();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, i) {
    return super.copy(e, i), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const oM = /* @__PURE__ */ new gi(), xh = /* @__PURE__ */ new ue(), j0 = /* @__PURE__ */ new ue();
class pW extends _1 {
  constructor() {
    super(new $s(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Vt(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Yt(2, 1, 1, 1),
      // negative X
      new Yt(0, 1, 1, 1),
      // positive Z
      new Yt(3, 1, 1, 1),
      // negative Z
      new Yt(1, 1, 1, 1),
      // positive Y
      new Yt(3, 0, 1, 1),
      // negative Y
      new Yt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new ue(1, 0, 0),
      new ue(-1, 0, 0),
      new ue(0, 0, 1),
      new ue(0, 0, -1),
      new ue(0, 1, 0),
      new ue(0, -1, 0)
    ], this._cubeUps = [
      new ue(0, 1, 0),
      new ue(0, 1, 0),
      new ue(0, 1, 0),
      new ue(0, 1, 0),
      new ue(0, 0, 1),
      new ue(0, 0, -1)
    ];
  }
  updateMatrices(e, i = 0) {
    const n = this.camera, s = this.matrix, a = e.distance || n.far;
    a !== n.far && (n.far = a, n.updateProjectionMatrix()), xh.setFromMatrixPosition(e.matrixWorld), n.position.copy(xh), j0.copy(n.position), j0.add(this._cubeDirections[i]), n.up.copy(this._cubeUps[i]), n.lookAt(j0), n.updateMatrixWorld(), s.makeTranslation(-xh.x, -xh.y, -xh.z), oM.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(oM);
  }
}
class fW extends Ol {
  constructor(e, i, n = 0, s = 2) {
    super(e, i), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = s, this.shadow = new pW();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, i) {
    return super.copy(e, i), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class T1 extends xP {
  constructor(e = -1, i = 1, n = 1, s = -1, a = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = i, this.top = n, this.bottom = s, this.near = a, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, i) {
    return super.copy(e, i), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, i, n, s, a, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = i, this.view.offsetX = n, this.view.offsetY = s, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), i = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
    let a = n - e, o = n + e, l = s + i, u = s - i;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      a += c * this.view.offsetX, o = a + c * this.view.width, l -= h * this.view.offsetY, u = l - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(a, o, l, u, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.zoom = this.zoom, i.object.left = this.left, i.object.right = this.right, i.object.top = this.top, i.object.bottom = this.bottom, i.object.near = this.near, i.object.far = this.far, this.view !== null && (i.object.view = Object.assign({}, this.view)), i;
  }
}
class mW extends _1 {
  constructor() {
    super(new T1(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class gW extends Ol {
  constructor(e, i) {
    super(e, i), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Ki.DEFAULT_UP), this.updateMatrix(), this.target = new Ki(), this.shadow = new mW();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class yW extends Ol {
  constructor(e, i) {
    super(e, i), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class vW extends Ol {
  constructor(e, i, n = 10, s = 10) {
    super(e, i), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = s;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.width = this.width, i.object.height = this.height, i;
  }
}
class bW {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new ue());
  }
  set(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].copy(e[i]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, i) {
    const n = e.x, s = e.y, a = e.z, o = this.coefficients;
    return i.copy(o[0]).multiplyScalar(0.282095), i.addScaledVector(o[1], 0.488603 * s), i.addScaledVector(o[2], 0.488603 * a), i.addScaledVector(o[3], 0.488603 * n), i.addScaledVector(o[4], 1.092548 * (n * s)), i.addScaledVector(o[5], 1.092548 * (s * a)), i.addScaledVector(o[6], 0.315392 * (3 * a * a - 1)), i.addScaledVector(o[7], 1.092548 * (n * a)), i.addScaledVector(o[8], 0.546274 * (n * n - s * s)), i;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, i) {
    const n = e.x, s = e.y, a = e.z, o = this.coefficients;
    return i.copy(o[0]).multiplyScalar(0.886227), i.addScaledVector(o[1], 2 * 0.511664 * s), i.addScaledVector(o[2], 2 * 0.511664 * a), i.addScaledVector(o[3], 2 * 0.511664 * n), i.addScaledVector(o[4], 2 * 0.429043 * n * s), i.addScaledVector(o[5], 2 * 0.429043 * s * a), i.addScaledVector(o[6], 0.743125 * a * a - 0.247708), i.addScaledVector(o[7], 2 * 0.429043 * n * a), i.addScaledVector(o[8], 0.429043 * (n * n - s * s)), i;
  }
  add(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].add(e.coefficients[i]);
    return this;
  }
  addScaledSH(e, i) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], i);
    return this;
  }
  scale(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].multiplyScalar(e);
    return this;
  }
  lerp(e, i) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], i);
    return this;
  }
  equals(e) {
    for (let i = 0; i < 9; i++)
      if (!this.coefficients[i].equals(e.coefficients[i]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, i = 0) {
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].fromArray(e, i + s * 3);
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].toArray(e, i + s * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, i) {
    const n = e.x, s = e.y, a = e.z;
    i[0] = 0.282095, i[1] = 0.488603 * s, i[2] = 0.488603 * a, i[3] = 0.488603 * n, i[4] = 1.092548 * n * s, i[5] = 1.092548 * s * a, i[6] = 0.315392 * (3 * a * a - 1), i[7] = 1.092548 * n * a, i[8] = 0.546274 * (n * n - s * s);
  }
}
class xW extends Ol {
  constructor(e = new bW(), i = 1) {
    super(void 0, i), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.sh = this.sh.toArray(), i;
  }
}
class _W extends SP {
  constructor(e, i, n = 1) {
    super(e, i), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const i = super.clone(e);
    return i.meshPerAttribute = this.meshPerAttribute, i;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.isInstancedInterleavedBuffer = !0, i.meshPerAttribute = this.meshPerAttribute, i;
  }
}
const TW = [
  "alphaMap",
  "alphaTest",
  "anisotropy",
  "anisotropyMap",
  "anisotropyRotation",
  "aoMap",
  "attenuationColor",
  "attenuationDistance",
  "bumpMap",
  "clearcoat",
  "clearcoatMap",
  "clearcoatNormalMap",
  "clearcoatNormalScale",
  "clearcoatRoughness",
  "color",
  "dispersion",
  "displacementMap",
  "emissive",
  "emissiveMap",
  "envMap",
  "gradientMap",
  "ior",
  "iridescence",
  "iridescenceIOR",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "lightMap",
  "map",
  "matcap",
  "metalness",
  "metalnessMap",
  "normalMap",
  "normalScale",
  "opacity",
  "roughness",
  "roughnessMap",
  "sheen",
  "sheenColor",
  "sheenColorMap",
  "sheenRoughnessMap",
  "shininess",
  "specular",
  "specularColor",
  "specularColorMap",
  "specularIntensity",
  "specularIntensityMap",
  "specularMap",
  "thickness",
  "transmission",
  "transmissionMap"
];
class SW {
  constructor(e) {
    this.renderObjects = /* @__PURE__ */ new WeakMap(), this.hasNode = this.containsNode(e), this.hasAnimation = e.object.isSkinnedMesh === !0, this.refreshUniforms = TW, this.renderId = 0;
  }
  firstInitialization(e) {
    return this.renderObjects.has(e) === !1 ? (this.getRenderObjectData(e), !0) : !1;
  }
  getRenderObjectData(e) {
    let i = this.renderObjects.get(e);
    if (i === void 0) {
      const { geometry: n, material: s } = e;
      if (i = {
        material: this.getMaterialData(s),
        geometry: {
          attributes: this.getAttributesData(n.attributes),
          indexVersion: n.index ? n.index.version : null,
          drawRange: { start: n.drawRange.start, count: n.drawRange.count }
        },
        worldMatrix: e.object.matrixWorld.clone()
      }, e.object.center && (i.center = e.object.center.clone()), e.object.morphTargetInfluences && (i.morphTargetInfluences = e.object.morphTargetInfluences.slice()), e.bundle !== null && (i.version = e.bundle.version), i.material.transmission > 0) {
        const { width: a, height: o } = e.context;
        i.bufferWidth = a, i.bufferHeight = o;
      }
      this.renderObjects.set(e, i);
    }
    return i;
  }
  getAttributesData(e) {
    const i = {};
    for (const n in e) {
      const s = e[n];
      i[n] = {
        version: s.version
      };
    }
    return i;
  }
  containsNode(e) {
    const i = e.material;
    for (const n in i)
      if (i[n] && i[n].isNode)
        return !0;
    return e.renderer.nodes.modelViewMatrix !== null || e.renderer.nodes.modelNormalViewMatrix !== null;
  }
  getMaterialData(e) {
    const i = {};
    for (const n of this.refreshUniforms) {
      const s = e[n];
      s != null && (typeof s == "object" && s.clone !== void 0 ? s.isTexture === !0 ? i[n] = { id: s.id, version: s.version } : i[n] = s.clone() : i[n] = s);
    }
    return i;
  }
  equals(e) {
    const { object: i, material: n, geometry: s } = e, a = this.getRenderObjectData(e);
    if (a.worldMatrix.equals(i.matrixWorld) !== !0)
      return a.worldMatrix.copy(i.matrixWorld), !1;
    const o = a.material;
    for (const y in o) {
      const v = o[y], g = n[y];
      if (v.equals !== void 0) {
        if (v.equals(g) === !1)
          return v.copy(g), !1;
      } else if (g.isTexture === !0) {
        if (v.id !== g.id || v.version !== g.version)
          return v.id = g.id, v.version = g.version, !1;
      } else if (v !== g)
        return o[y] = g, !1;
    }
    if (o.transmission > 0) {
      const { width: y, height: v } = e.context;
      if (a.bufferWidth !== y || a.bufferHeight !== v)
        return a.bufferWidth = y, a.bufferHeight = v, !1;
    }
    const l = a.geometry, u = s.attributes, c = l.attributes, h = Object.keys(c), d = Object.keys(u);
    if (h.length !== d.length)
      return a.geometry.attributes = this.getAttributesData(u), !1;
    for (const y of h) {
      const v = c[y], g = u[y];
      if (g === void 0)
        return delete c[y], !1;
      if (v.version !== g.version)
        return v.version = g.version, !1;
    }
    const p = s.index, f = l.indexVersion, m = p ? p.version : null;
    if (f !== m)
      return l.indexVersion = m, !1;
    if (l.drawRange.start !== s.drawRange.start || l.drawRange.count !== s.drawRange.count)
      return l.drawRange.start = s.drawRange.start, l.drawRange.count = s.drawRange.count, !1;
    if (a.morphTargetInfluences) {
      let y = !1;
      for (let v = 0; v < a.morphTargetInfluences.length; v++)
        a.morphTargetInfluences[v] !== i.morphTargetInfluences[v] && (y = !0);
      if (y) return !0;
    }
    return a.center && a.center.equals(i.center) === !1 ? (a.center.copy(i.center), !0) : (e.bundle !== null && (a.version = e.bundle.version), !0);
  }
  needsRefresh(e, i) {
    if (this.hasNode || this.hasAnimation || this.firstInitialization(e))
      return !0;
    const { renderId: n } = i;
    if (this.renderId !== n)
      return this.renderId = n, !0;
    const s = e.object.static === !0, a = e.bundle !== null && e.bundle.static === !0 && this.getRenderObjectData(e).version === e.bundle.version;
    return s || a ? !1 : this.equals(e) !== !0;
  }
}
function xd(r, e = 0) {
  let i = 3735928559 ^ e, n = 1103547991 ^ e;
  if (r instanceof Array)
    for (let s = 0, a; s < r.length; s++)
      a = r[s], i = Math.imul(i ^ a, 2654435761), n = Math.imul(n ^ a, 1597334677);
  else
    for (let s = 0, a; s < r.length; s++)
      a = r.charCodeAt(s), i = Math.imul(i ^ a, 2654435761), n = Math.imul(n ^ a, 1597334677);
  return i = Math.imul(i ^ i >>> 16, 2246822507), i ^= Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507), n ^= Math.imul(i ^ i >>> 13, 3266489909), 4294967296 * (2097151 & n) + (i >>> 0);
}
const wW = (r) => xd(r), kP = (r) => xd(r), zm = (...r) => xd(r);
function UP(r, e = !1) {
  const i = [];
  r.isNode === !0 && (i.push(r.id), r = r.getSelf());
  for (const { property: n, childNode: s } of jm(r))
    i.push(i, xd(n.slice(0, -4)), s.getCacheKey(e));
  return xd(i);
}
function* jm(r, e = !1) {
  for (const i in r) {
    if (i.startsWith("_") === !0) continue;
    const n = r[i];
    if (Array.isArray(n) === !0)
      for (let s = 0; s < n.length; s++) {
        const a = n[s];
        a && (a.isNode === !0 || e && typeof a.toJSON == "function") && (yield { property: i, index: s, childNode: a });
      }
    else if (n && n.isNode === !0)
      yield { property: i, childNode: n };
    else if (typeof n == "object")
      for (const s in n) {
        const a = n[s];
        a && (a.isNode === !0 || e && typeof a.toJSON == "function") && (yield { property: i, index: s, childNode: a });
      }
  }
}
function Vm(r) {
  if (r == null) return null;
  const e = typeof r;
  return r.isNode === !0 ? "node" : e === "number" ? "float" : e === "boolean" ? "bool" : e === "string" ? "string" : e === "function" ? "shader" : r.isVector2 === !0 ? "vec2" : r.isVector3 === !0 ? "vec3" : r.isVector4 === !0 ? "vec4" : r.isMatrix3 === !0 ? "mat3" : r.isMatrix4 === !0 ? "mat4" : r.isColor === !0 ? "color" : r instanceof ArrayBuffer ? "ArrayBuffer" : null;
}
function FP(r, ...e) {
  const i = r ? r.slice(-4) : void 0;
  return e.length === 1 && (i === "vec2" ? e = [e[0], e[0]] : i === "vec3" ? e = [e[0], e[0], e[0]] : i === "vec4" && (e = [e[0], e[0], e[0], e[0]])), r === "color" ? new Kt(...e) : i === "vec2" ? new Vt(...e) : i === "vec3" ? new ue(...e) : i === "vec4" ? new Yt(...e) : i === "mat3" ? new qr(...e) : i === "mat4" ? new gi(...e) : r === "bool" ? e[0] || !1 : r === "float" || r === "int" || r === "uint" ? e[0] || 0 : r === "string" ? e[0] || "" : r === "ArrayBuffer" ? MW(e[0]) : null;
}
function EW(r) {
  let e = "";
  const i = new Uint8Array(r);
  for (let n = 0; n < i.length; n++)
    e += String.fromCharCode(i[n]);
  return btoa(e);
}
function MW(r) {
  return Uint8Array.from(atob(r), (e) => e.charCodeAt(0)).buffer;
}
const lM = {
  VERTEX: "vertex"
}, Nt = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
}, AW = ["fragment", "vertex"], uM = ["setup", "analyze", "generate"], cM = [...AW, "compute"], Gc = ["x", "y", "z", "w"];
let CW = 0;
class Mt extends zc {
  static get type() {
    return "Node";
  }
  constructor(e = null) {
    super(), this.nodeType = e, this.updateType = Nt.NONE, this.updateBeforeType = Nt.NONE, this.updateAfterType = Nt.NONE, this.uuid = O7.generateUUID(), this.version = 0, this._cacheKey = null, this._cacheKeyVersion = 0, this.global = !1, this.isNode = !0, Object.defineProperty(this, "id", { value: CW++ });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get type() {
    return this.constructor.type;
  }
  onUpdate(e, i) {
    return this.updateType = i, this.update = e.bind(this.getSelf()), this;
  }
  onFrameUpdate(e) {
    return this.onUpdate(e, Nt.FRAME);
  }
  onRenderUpdate(e) {
    return this.onUpdate(e, Nt.RENDER);
  }
  onObjectUpdate(e) {
    return this.onUpdate(e, Nt.OBJECT);
  }
  onReference(e) {
    return this.updateReference = e.bind(this.getSelf()), this;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return this.global;
  }
  *getChildren() {
    for (const { childNode: e } of jm(this))
      yield e;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(e) {
    e(this);
    for (const i of this.getChildren())
      i.traverse(e);
  }
  getCacheKey(e = !1) {
    return e = e || this.version !== this._cacheKeyVersion, (e === !0 || this._cacheKey === null) && (this._cacheKey = UP(this, e), this._cacheKeyVersion = this.version), this._cacheKey;
  }
  getScope() {
    return this;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  getElementType(e) {
    const i = this.getNodeType(e);
    return e.getElementType(i);
  }
  getNodeType(e) {
    const i = e.getNodeProperties(this);
    return i.outputNode ? i.outputNode.getNodeType(e) : this.nodeType;
  }
  getShared(e) {
    const i = this.getHash(e);
    return e.getNodeFromHash(i) || this;
  }
  setup(e) {
    const i = e.getNodeProperties(this);
    let n = 0;
    for (const s of this.getChildren())
      i["node" + n++] = s;
    return null;
  }
  analyze(e) {
    if (e.increaseUsage(this) === 1) {
      const i = e.getNodeProperties(this);
      for (const n of Object.values(i))
        n && n.isNode === !0 && n.build(e);
    }
  }
  generate(e, i) {
    const { outputNode: n } = e.getNodeProperties(this);
    if (n && n.isNode === !0)
      return n.build(e, i);
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  updateAfter() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(e, i = null) {
    const n = this.getShared(e);
    if (this !== n)
      return n.build(e, i);
    e.addNode(this), e.addChain(this);
    let s = null;
    const a = e.getBuildStage();
    if (a === "setup") {
      this.updateReference(e);
      const o = e.getNodeProperties(this);
      if (o.initialized !== !0) {
        e.stack.nodes.length, o.initialized = !0, o.outputNode = this.setup(e), o.outputNode !== null && e.stack.nodes.length;
        for (const l of Object.values(o))
          l && l.isNode === !0 && l.build(e);
      }
    } else if (a === "analyze")
      this.analyze(e);
    else if (a === "generate")
      if (this.generate.length === 1) {
        const o = this.getNodeType(e), l = e.getDataFromNode(this);
        s = l.snippet, s === void 0 ? (s = this.generate(e) || "", l.snippet = s) : l.flowCodes !== void 0 && e.context.nodeBlock !== void 0 && e.addFlowCodeHierarchy(this, e.context.nodeBlock), s = e.format(s, o, i);
      } else
        s = this.generate(e, i) || "";
    return e.removeChain(this), e.addSequentialNode(this), s;
  }
  getSerializeChildren() {
    return jm(this);
  }
  serialize(e) {
    const i = this.getSerializeChildren(), n = {};
    for (const { property: s, index: a, childNode: o } of i)
      a !== void 0 ? (n[s] === void 0 && (n[s] = Number.isInteger(a) ? [] : {}), n[s][a] = o.toJSON(e.meta).uuid) : n[s] = o.toJSON(e.meta).uuid;
    Object.keys(n).length > 0 && (e.inputNodes = n);
  }
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const i = e.meta.nodes;
      for (const n in e.inputNodes)
        if (Array.isArray(e.inputNodes[n])) {
          const s = [];
          for (const a of e.inputNodes[n])
            s.push(i[a]);
          this[n] = s;
        } else if (typeof e.inputNodes[n] == "object") {
          const s = {};
          for (const a in e.inputNodes[n]) {
            const o = e.inputNodes[n][a];
            s[a] = i[o];
          }
          this[n] = s;
        } else {
          const s = e.inputNodes[n];
          this[n] = i[s];
        }
    }
  }
  toJSON(e) {
    const { uuid: i, type: n } = this, s = e === void 0 || typeof e == "string";
    s && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    let a = e.nodes[i];
    a === void 0 && (a = {
      uuid: i,
      type: n,
      meta: e,
      metadata: {
        version: 4.6,
        type: "Node",
        generator: "Node.toJSON"
      }
    }, s !== !0 && (e.nodes[a.uuid] = a), this.serialize(a), delete a.meta);
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
    if (s) {
      const l = o(e.textures), u = o(e.images), c = o(e.nodes);
      l.length > 0 && (a.textures = l), u.length > 0 && (a.images = u), c.length > 0 && (a.nodes = c);
    }
    return a;
  }
}
class ep extends Mt {
  static get type() {
    return "ArrayElementNode";
  }
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(e, i) {
    super(), this.node = e, this.indexNode = i, this.isArrayElementNode = !0;
  }
  getNodeType(e) {
    return this.node.getElementType(e);
  }
  generate(e) {
    const i = this.node.build(e), n = this.indexNode.build(e, "uint");
    return `${i}[ ${n} ]`;
  }
}
class BP extends Mt {
  static get type() {
    return "ConvertNode";
  }
  constructor(e, i) {
    super(), this.node = e, this.convertTo = i;
  }
  getNodeType(e) {
    const i = this.node.getNodeType(e);
    let n = null;
    for (const s of this.convertTo.split("|"))
      (n === null || e.getTypeLength(i) === e.getTypeLength(s)) && (n = s);
    return n;
  }
  serialize(e) {
    super.serialize(e), e.convertTo = this.convertTo;
  }
  deserialize(e) {
    super.deserialize(e), this.convertTo = e.convertTo;
  }
  generate(e, i) {
    const n = this.node, s = this.getNodeType(e), a = n.build(e, s);
    return e.format(a, s, i);
  }
}
class zi extends Mt {
  static get type() {
    return "TempNode";
  }
  constructor(e) {
    super(e), this.isTempNode = !0;
  }
  hasDependencies(e) {
    return e.getDataFromNode(this).usageCount > 1;
  }
  build(e, i) {
    if (e.getBuildStage() === "generate") {
      const n = e.getVectorType(this.getNodeType(e, i)), s = e.getDataFromNode(this);
      if (s.propertyName !== void 0)
        return e.format(s.propertyName, n, i);
      if (n !== "void" && i !== "void" && this.hasDependencies(e)) {
        const a = super.build(e, n), o = e.getVarFromNode(this, null, n), l = e.getPropertyName(o);
        return e.addLineFlowCode(`${l} = ${a}`, this), s.snippet = a, s.propertyName = l, e.format(s.propertyName, n, i);
      }
    }
    return super.build(e, i);
  }
}
class RW extends zi {
  static get type() {
    return "JoinNode";
  }
  constructor(e = [], i = null) {
    super(i), this.nodes = e;
  }
  getNodeType(e) {
    return this.nodeType !== null ? e.getVectorType(this.nodeType) : e.getTypeFromLength(this.nodes.reduce((i, n) => i + e.getTypeLength(n.getNodeType(e)), 0));
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.nodes, a = e.getComponentType(n), o = [];
    for (const u of s) {
      let c = u.build(e);
      const h = e.getComponentType(u.getNodeType(e));
      h !== a && (c = e.format(c, h, a)), o.push(c);
    }
    const l = `${e.getType(n)}( ${o.join(", ")} )`;
    return e.format(l, n, i);
  }
}
const NW = Gc.join("");
class hM extends Mt {
  static get type() {
    return "SplitNode";
  }
  constructor(e, i = "x") {
    super(), this.node = e, this.components = i, this.isSplitNode = !0;
  }
  getVectorLength() {
    let e = this.components.length;
    for (const i of this.components)
      e = Math.max(Gc.indexOf(i) + 1, e);
    return e;
  }
  getComponentType(e) {
    return e.getComponentType(this.node.getNodeType(e));
  }
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length, this.getComponentType(e));
  }
  generate(e, i) {
    const n = this.node, s = e.getTypeLength(n.getNodeType(e));
    let a = null;
    if (s > 1) {
      let o = null;
      this.getVectorLength() >= s && (o = e.getTypeFromLength(this.getVectorLength(), this.getComponentType(e)));
      const l = n.build(e, o);
      this.components.length === s && this.components === NW.slice(0, this.components.length) ? a = e.format(l, o, i) : a = e.format(`${l}.${this.components}`, this.getNodeType(e), i);
    } else
      a = n.build(e, i);
    return a;
  }
  serialize(e) {
    super.serialize(e), e.components = this.components;
  }
  deserialize(e) {
    super.deserialize(e), this.components = e.components;
  }
}
class PW extends zi {
  static get type() {
    return "SetNode";
  }
  constructor(e, i, n) {
    super(), this.sourceNode = e, this.components = i, this.targetNode = n;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { sourceNode: i, components: n, targetNode: s } = this, a = this.getNodeType(e), o = e.getTypeFromLength(n.length, s.getNodeType(e)), l = s.build(e, o), u = i.build(e, a), c = e.getTypeLength(a), h = [];
    for (let d = 0; d < c; d++) {
      const p = Gc[d];
      p === n[0] ? (h.push(l), d += n.length - 1) : h.push(u + "." + p);
    }
    return `${e.getType(a)}( ${h.join(", ")} )`;
  }
}
class IW extends zi {
  static get type() {
    return "FlipNode";
  }
  constructor(e, i) {
    super(), this.sourceNode = e, this.components = i;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { components: i, sourceNode: n } = this, s = this.getNodeType(e), a = n.build(e), o = e.getVarFromNode(this), l = e.getPropertyName(o);
    e.addLineFlowCode(l + " = " + a, this);
    const u = e.getTypeLength(s), c = [];
    let h = 0;
    for (let d = 0; d < u; d++) {
      const p = Gc[d];
      p === i[h] ? (c.push("1.0 - " + (l + "." + p)), h++) : c.push(l + "." + p);
    }
    return `${e.getType(s)}( ${c.join(", ")} )`;
  }
}
class S1 extends Mt {
  static get type() {
    return "InputNode";
  }
  constructor(e, i = null) {
    super(i), this.isInputNode = !0, this.value = e, this.precision = null;
  }
  getNodeType() {
    return this.nodeType === null ? Vm(this.value) : this.nodeType;
  }
  getInputType(e) {
    return this.getNodeType(e);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  serialize(e) {
    super.serialize(e), e.value = this.value, this.value && this.value.toArray && (e.value = this.value.toArray()), e.valueType = Vm(this.value), e.nodeType = this.nodeType, e.valueType === "ArrayBuffer" && (e.value = EW(e.value)), e.precision = this.precision;
  }
  deserialize(e) {
    super.deserialize(e), this.nodeType = e.nodeType, this.value = Array.isArray(e.value) ? FP(e.valueType, ...e.value) : e.value, this.precision = e.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
class wa extends S1 {
  static get type() {
    return "ConstNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isConstNode = !0;
  }
  generateConst(e) {
    return e.generateConst(this.getNodeType(e), this.value);
  }
  generate(e, i) {
    const n = this.getNodeType(e);
    return e.format(this.generateConst(e), n, i);
  }
}
let Sc = null;
const Uu = /* @__PURE__ */ new Map();
function ge(r, e) {
  if (Uu.has(r)) {
    console.warn(`Redefinition of method chaining ${r}`);
    return;
  }
  if (typeof e != "function") throw new Error(`Node element ${r} is not a function`);
  Uu.set(r, e);
}
const zP = (r) => r.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), dM = (r) => zP(r).split("").sort().join(""), jP = {
  setup(r, e) {
    const i = e.shift();
    return r(kg(i), ...e);
  },
  get(r, e, i) {
    if (typeof e == "string" && r[e] === void 0) {
      if (r.isStackNode !== !0 && e === "assign")
        return (...n) => (Sc.assign(i, ...n), i);
      if (Uu.has(e)) {
        const n = Uu.get(e);
        return r.isStackNode ? (...s) => i.add(n(...s)) : (...s) => n(i, ...s);
      } else {
        if (e === "self")
          return r;
        if (e.endsWith("Assign") && Uu.has(e.slice(0, e.length - 6))) {
          const n = Uu.get(e.slice(0, e.length - 6));
          return r.isStackNode ? (...s) => i.assign(s[0], n(...s)) : (...s) => i.assign(n(i, ...s));
        } else {
          if (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0)
            return e = zP(e), De(new hM(i, e));
          if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = dM(e.slice(3).toLowerCase()), (n) => De(new PW(r, e, n));
          if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = dM(e.slice(4).toLowerCase()), () => De(new IW(De(r), e));
          if (e === "width" || e === "height" || e === "depth")
            return e === "width" ? e = "x" : e === "height" ? e = "y" : e === "depth" && (e = "z"), De(new hM(r, e));
          if (/^\d+$/.test(e) === !0)
            return De(new ep(i, new wa(Number(e), "uint")));
        }
      }
    }
    return Reflect.get(r, e, i);
  },
  set(r, e, i, n) {
    return typeof e == "string" && r[e] === void 0 && (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0 || e === "width" || e === "height" || e === "depth" || /^\d+$/.test(e) === !0) ? (n[e].assign(i), !0) : Reflect.set(r, e, i, n);
  }
}, V0 = /* @__PURE__ */ new WeakMap(), pM = /* @__PURE__ */ new WeakMap(), OW = function(r, e = null) {
  const i = Vm(r);
  if (i === "node") {
    let n = V0.get(r);
    return n === void 0 && (n = new Proxy(r, jP), V0.set(r, n), V0.set(n, n)), n;
  } else {
    if (e === null && (i === "float" || i === "boolean") || i && i !== "shader" && i !== "string")
      return De(Tx(r, e));
    if (i === "shader")
      return Fe(r);
  }
  return r;
}, DW = function(r, e = null) {
  for (const i in r)
    r[i] = De(r[i], e);
  return r;
}, LW = function(r, e = null) {
  const i = r.length;
  for (let n = 0; n < i; n++)
    r[n] = De(r[n], e);
  return r;
}, kW = function(r, e = null, i = null, n = null) {
  const s = (a) => De(n !== null ? Object.assign(a, n) : a);
  return e === null ? (...a) => s(new r(...Qu(a))) : i !== null ? (i = De(i), (...a) => s(new r(e, ...Qu(a), i))) : (...a) => s(new r(e, ...Qu(a)));
}, UW = function(r, ...e) {
  return De(new r(...Qu(e)));
};
class FW extends Mt {
  constructor(e, i) {
    super(), this.shaderNode = e, this.inputNodes = i;
  }
  getNodeType(e) {
    return this.shaderNode.nodeType || this.getOutputNode(e).getNodeType(e);
  }
  call(e) {
    const { shaderNode: i, inputNodes: n } = this, s = e.getNodeProperties(i);
    if (s.onceOutput) return s.onceOutput;
    let a = null;
    if (i.layout) {
      let o = pM.get(e.constructor);
      o === void 0 && (o = /* @__PURE__ */ new WeakMap(), pM.set(e.constructor, o));
      let l = o.get(i);
      l === void 0 && (l = De(e.buildFunctionNode(i)), o.set(i, l)), e.currentFunctionNode !== null && e.currentFunctionNode.includes.push(l), a = De(l.call(n));
    } else {
      const o = i.jsFunc, l = n !== null ? o(n, e) : o(e);
      a = De(l);
    }
    return i.once && (s.onceOutput = a), a;
  }
  getOutputNode(e) {
    const i = e.getNodeProperties(this);
    return i.outputNode === null && (i.outputNode = this.setupOutput(e)), i.outputNode;
  }
  setup(e) {
    return this.getOutputNode(e);
  }
  setupOutput(e) {
    return e.addStack(), e.stack.outputNode = this.call(e), e.removeStack();
  }
  generate(e, i) {
    return this.getOutputNode(e).build(e, i);
  }
}
class BW extends Mt {
  constructor(e, i) {
    super(i), this.jsFunc = e, this.layout = null, this.global = !0, this.once = !1;
  }
  setLayout(e) {
    return this.layout = e, this;
  }
  call(e = null) {
    return kg(e), De(new FW(this, e));
  }
  setup() {
    return this.call();
  }
}
const zW = [!1, !0], jW = [0, 1, 2, 3], VW = [-1, -2], VP = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2], w1 = /* @__PURE__ */ new Map();
for (const r of zW) w1.set(r, new wa(r));
const E1 = /* @__PURE__ */ new Map();
for (const r of jW) E1.set(r, new wa(r, "uint"));
const M1 = new Map([...E1].map((r) => new wa(r.value, "int")));
for (const r of VW) M1.set(r, new wa(r, "int"));
const Dg = new Map([...M1].map((r) => new wa(r.value)));
for (const r of VP) Dg.set(r, new wa(r));
for (const r of VP) Dg.set(-r, new wa(-r));
const Lg = { bool: w1, uint: E1, ints: M1, float: Dg }, fM = new Map([...w1, ...Dg]), Tx = (r, e) => fM.has(r) ? fM.get(r) : r.isNode === !0 ? r : new wa(r, e), GW = (r) => {
  try {
    return r.getNodeType();
  } catch {
    return;
  }
}, ji = function(r, e = null) {
  return (...i) => {
    if ((i.length === 0 || !["bool", "float", "int", "uint"].includes(r) && i.every((s) => typeof s != "object")) && (i = [FP(r, ...i)]), i.length === 1 && e !== null && e.has(i[0]))
      return De(e.get(i[0]));
    if (i.length === 1) {
      const s = Tx(i[0], r);
      return GW(s) === r ? De(s) : De(new BP(s, r));
    }
    const n = i.map((s) => Tx(s));
    return De(new RW(n, r));
  };
}, mM = (r) => typeof r == "object" && r !== null ? r.value : r, HW = (r) => r != null ? r.nodeType || r.convertTo || (typeof r == "string" ? r : null) : null;
function sm(r, e) {
  return new Proxy(new BW(r, e), jP);
}
const De = (r, e = null) => (
  /* new */
  OW(r, e)
), kg = (r, e = null) => new DW(r, e), Qu = (r, e = null) => new LW(r, e), Ae = (...r) => new kW(...r), Ve = (...r) => new UW(...r), Fe = (r, e) => {
  const i = new sm(r, e), n = (...s) => {
    let a;
    return kg(s), s[0] && s[0].isNode ? a = [...s] : a = s[0], i.call(a);
  };
  return n.shaderNode = i, n.setLayout = (s) => (i.setLayout(s), n), n.once = () => (i.once = !0, n), n;
};
ge("toGlobal", (r) => (r.global = !0, r));
const Gm = (r) => {
  Sc = r;
}, GP = () => Sc, rr = (...r) => Sc.If(...r);
function WW(r) {
  return Sc && Sc.add(r), r;
}
ge("append", WW);
const qW = new ji("color"), be = new ji("float", Lg.float), Mi = new ji("int", Lg.ints), XW = new ji("uint", Lg.uint), $W = new ji("bool", Lg.bool), He = new ji("vec2"), Ys = new ji("ivec2"), YW = new ji("uvec2"), KW = new ji("bvec2"), ye = new ji("vec3"), ZW = new ji("ivec3"), QW = new ji("uvec3"), JW = new ji("bvec3"), xt = new ji("vec4"), eq = new ji("ivec4"), tq = new ji("uvec4"), iq = new ji("bvec4"), A1 = new ji("mat2"), Cr = new ji("mat3"), Ju = new ji("mat4");
ge("toColor", qW);
ge("toFloat", be);
ge("toInt", Mi);
ge("toUint", XW);
ge("toBool", $W);
ge("toVec2", He);
ge("toIVec2", Ys);
ge("toUVec2", YW);
ge("toBVec2", KW);
ge("toVec3", ye);
ge("toIVec3", ZW);
ge("toUVec3", QW);
ge("toBVec3", JW);
ge("toVec4", xt);
ge("toIVec4", eq);
ge("toUVec4", tq);
ge("toBVec4", iq);
ge("toMat2", A1);
ge("toMat3", Cr);
ge("toMat4", Ju);
const rq = /* @__PURE__ */ Ae(ep), nq = (r, e) => De(new BP(De(r), e));
ge("element", rq);
ge("convert", nq);
class HP extends Mt {
  static get type() {
    return "UniformGroupNode";
  }
  constructor(e, i = !1, n = 1) {
    super("string"), this.name = e, this.version = 0, this.shared = i, this.order = n, this.isUniformGroup = !0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  serialize(e) {
    super.serialize(e), e.name = this.name, e.version = this.version, e.shared = this.shared;
  }
  deserialize(e) {
    super.deserialize(e), this.name = e.name, this.version = e.version, this.shared = e.shared;
  }
}
const sq = (r) => new HP(r), WP = (r, e = 0) => new HP(r, !0, e), aq = /* @__PURE__ */ WP("frame"), kt = /* @__PURE__ */ WP("render"), qP = /* @__PURE__ */ sq("object");
class tp extends S1 {
  static get type() {
    return "UniformNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isUniformNode = !0, this.name = "", this.groupNode = qP;
  }
  label(e) {
    return this.name = e, this;
  }
  setGroup(e) {
    return this.groupNode = e, this;
  }
  getGroup() {
    return this.groupNode;
  }
  getUniformHash(e) {
    return this.getHash(e);
  }
  onUpdate(e, i) {
    const n = this.getSelf();
    return e = e.bind(n), super.onUpdate((s) => {
      const a = e(s, n);
      a !== void 0 && (this.value = a);
    }, i);
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.getUniformHash(e);
    let a = e.getNodeFromHash(s);
    a === void 0 && (e.setHashNode(this, s), a = this);
    const o = a.getInputType(e), l = e.getUniformFromNode(a, o, e.shaderStage, this.name || e.context.label), u = e.getPropertyName(l);
    return e.context.label !== void 0 && delete e.context.label, e.format(u, n, i);
  }
}
const _t = (r, e) => {
  const i = HW(e || r), n = r && r.isNode === !0 ? r.node && r.node.value || r.value : r;
  return De(new tp(n, i));
};
class Zt extends Mt {
  static get type() {
    return "PropertyNode";
  }
  constructor(e, i = null, n = !1) {
    super(e), this.name = i, this.varying = n, this.isPropertyNode = !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  isGlobal() {
    return !0;
  }
  generate(e) {
    let i;
    return this.varying === !0 ? (i = e.getVaryingFromNode(this, this.name), i.needsInterpolation = !0) : i = e.getVarFromNode(this, this.name), e.getPropertyName(i);
  }
}
const Ru = (r, e) => De(new Zt(r, e)), Hm = (r, e) => De(new Zt(r, e, !0)), qt = /* @__PURE__ */ Ve(Zt, "vec4", "DiffuseColor"), gM = /* @__PURE__ */ Ve(Zt, "vec3", "EmissiveColor"), ta = /* @__PURE__ */ Ve(Zt, "float", "Roughness"), Wm = /* @__PURE__ */ Ve(Zt, "float", "Metalness"), Sx = /* @__PURE__ */ Ve(Zt, "float", "Clearcoat"), qm = /* @__PURE__ */ Ve(Zt, "float", "ClearcoatRoughness"), Fu = /* @__PURE__ */ Ve(Zt, "vec3", "Sheen"), C1 = /* @__PURE__ */ Ve(Zt, "float", "SheenRoughness"), R1 = /* @__PURE__ */ Ve(Zt, "float", "Iridescence"), XP = /* @__PURE__ */ Ve(Zt, "float", "IridescenceIOR"), $P = /* @__PURE__ */ Ve(Zt, "float", "IridescenceThickness"), wx = /* @__PURE__ */ Ve(Zt, "float", "AlphaT"), Ho = /* @__PURE__ */ Ve(Zt, "float", "Anisotropy"), am = /* @__PURE__ */ Ve(Zt, "vec3", "AnisotropyT"), ec = /* @__PURE__ */ Ve(Zt, "vec3", "AnisotropyB"), rn = /* @__PURE__ */ Ve(Zt, "color", "SpecularColor"), Xm = /* @__PURE__ */ Ve(Zt, "float", "SpecularF90"), Ex = /* @__PURE__ */ Ve(Zt, "float", "Shininess"), oq = /* @__PURE__ */ Ve(Zt, "vec4", "Output"), G0 = /* @__PURE__ */ Ve(Zt, "float", "dashSize"), yM = /* @__PURE__ */ Ve(Zt, "float", "gapSize"), om = /* @__PURE__ */ Ve(Zt, "float", "IOR"), Mx = /* @__PURE__ */ Ve(Zt, "float", "Transmission"), YP = /* @__PURE__ */ Ve(Zt, "float", "Thickness"), KP = /* @__PURE__ */ Ve(Zt, "float", "AttenuationDistance"), ZP = /* @__PURE__ */ Ve(Zt, "color", "AttenuationColor"), QP = /* @__PURE__ */ Ve(Zt, "float", "Dispersion");
class lq extends zi {
  static get type() {
    return "AssignNode";
  }
  constructor(e, i) {
    super(), this.targetNode = e, this.sourceNode = i;
  }
  hasDependencies() {
    return !1;
  }
  getNodeType(e, i) {
    return i !== "void" ? this.targetNode.getNodeType(e) : "void";
  }
  needsSplitAssign(e) {
    const { targetNode: i } = this;
    if (e.isAvailable("swizzleAssign") === !1 && i.isSplitNode && i.components.length > 1) {
      const n = e.getTypeLength(i.node.getNodeType(e));
      return Gc.join("").slice(0, n) !== i.components;
    }
    return !1;
  }
  generate(e, i) {
    const { targetNode: n, sourceNode: s } = this, a = this.needsSplitAssign(e), o = n.getNodeType(e), l = n.context({ assign: !0 }).build(e), u = s.build(e, o), c = s.getNodeType(e), h = e.getDataFromNode(this);
    let d;
    if (h.initialized === !0)
      i !== "void" && (d = l);
    else if (a) {
      const p = e.getVarFromNode(this, null, o), f = e.getPropertyName(p);
      e.addLineFlowCode(`${f} = ${u}`, this);
      const m = n.node.context({ assign: !0 }).build(e);
      for (let y = 0; y < n.components.length; y++) {
        const v = n.components[y];
        e.addLineFlowCode(`${m}.${v} = ${f}[ ${y} ]`, this);
      }
      i !== "void" && (d = l);
    } else
      d = `${l} = ${u}`, (i === "void" || c === "void") && (e.addLineFlowCode(d, this), i !== "void" && (d = l));
    return h.initialized = !0, e.format(d, o, i);
  }
}
const uq = /* @__PURE__ */ Ae(lq);
ge("assign", uq);
class cq extends zi {
  static get type() {
    return "FunctionCallNode";
  }
  constructor(e = null, i = {}) {
    super(), this.functionNode = e, this.parameters = i;
  }
  setParameters(e) {
    return this.parameters = e, this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(e) {
    return this.functionNode.getNodeType(e);
  }
  generate(e) {
    const i = [], n = this.functionNode, s = n.getInputs(e), a = this.parameters, o = (l, u) => {
      const c = u.type, h = c === "pointer";
      let d;
      return h ? d = "&" + l.build(e) : d = l.build(e, c), d;
    };
    if (Array.isArray(a))
      for (let l = 0; l < a.length; l++)
        i.push(o(a[l], s[l]));
    else
      for (const l of s) {
        const u = a[l.name];
        if (u !== void 0)
          i.push(o(u, l));
        else
          throw new Error(`FunctionCallNode: Input '${l.name}' not found in FunctionNode.`);
      }
    return `${n.build(e, "property")}( ${i.join(", ")} )`;
  }
}
const hq = (r, ...e) => (e = e.length > 1 || e[0] && e[0].isNode === !0 ? Qu(e) : kg(e[0]), De(new cq(De(r), e)));
ge("call", hq);
class yi extends zi {
  static get type() {
    return "OperatorNode";
  }
  constructor(e, i, n, ...s) {
    if (super(), s.length > 0) {
      let a = new yi(e, i, n);
      for (let o = 0; o < s.length - 1; o++)
        a = new yi(e, a, s[o]);
      i = a, n = s[s.length - 1];
    }
    this.op = e, this.aNode = i, this.bNode = n;
  }
  getNodeType(e, i) {
    const n = this.op, s = this.aNode, a = this.bNode, o = s.getNodeType(e), l = typeof a < "u" ? a.getNodeType(e) : null;
    if (o === "void" || l === "void")
      return "void";
    if (n === "%")
      return o;
    if (n === "~" || n === "&" || n === "|" || n === "^" || n === ">>" || n === "<<")
      return e.getIntegerType(o);
    if (n === "!" || n === "==" || n === "&&" || n === "||" || n === "^^")
      return "bool";
    if (n === "<" || n === ">" || n === "<=" || n === ">=") {
      const u = i ? e.getTypeLength(i) : Math.max(e.getTypeLength(o), e.getTypeLength(l));
      return u > 1 ? `bvec${u}` : "bool";
    } else
      return o === "float" && e.isMatrix(l) ? l : e.isMatrix(o) && e.isVector(l) ? e.getVectorFromMatrix(o) : e.isVector(o) && e.isMatrix(l) ? e.getVectorFromMatrix(l) : e.getTypeLength(l) > e.getTypeLength(o) ? l : o;
  }
  generate(e, i) {
    const n = this.op, s = this.aNode, a = this.bNode, o = this.getNodeType(e, i);
    let l = null, u = null;
    o !== "void" ? (l = s.getNodeType(e), u = typeof a < "u" ? a.getNodeType(e) : null, n === "<" || n === ">" || n === "<=" || n === ">=" || n === "==" ? e.isVector(l) ? u = l : l !== u && (l = u = "float") : n === ">>" || n === "<<" ? (l = o, u = e.changeComponentType(u, "uint")) : e.isMatrix(l) && e.isVector(u) ? u = e.getVectorFromMatrix(l) : e.isVector(l) && e.isMatrix(u) ? l = e.getVectorFromMatrix(u) : l = u = o) : l = u = o;
    const c = s.build(e, l), h = typeof a < "u" ? a.build(e, u) : null, d = e.getTypeLength(i), p = e.getFunctionOperator(n);
    if (i !== "void")
      return n === "<" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("lessThan", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} < ${h} )`, o, i) : n === "<=" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("lessThanEqual", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} <= ${h} )`, o, i) : n === ">" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("greaterThan", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} > ${h} )`, o, i) : n === ">=" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("greaterThanEqual", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} >= ${h} )`, o, i) : n === "!" || n === "~" ? e.format(`(${n}${c})`, l, i) : p ? e.format(`${p}( ${c}, ${h} )`, o, i) : e.format(`( ${c} ${n} ${h} )`, o, i);
    if (l !== "void")
      return p ? e.format(`${p}( ${c}, ${h} )`, o, i) : e.format(`${c} ${n} ${h}`, o, i);
  }
  serialize(e) {
    super.serialize(e), e.op = this.op;
  }
  deserialize(e) {
    super.deserialize(e), this.op = e.op;
  }
}
const Rr = /* @__PURE__ */ Ae(yi, "+"), sn = /* @__PURE__ */ Ae(yi, "-"), Dt = /* @__PURE__ */ Ae(yi, "*"), bo = /* @__PURE__ */ Ae(yi, "/"), JP = /* @__PURE__ */ Ae(yi, "%"), dq = /* @__PURE__ */ Ae(yi, "=="), pq = /* @__PURE__ */ Ae(yi, "!="), fq = /* @__PURE__ */ Ae(yi, "<"), mq = /* @__PURE__ */ Ae(yi, ">"), gq = /* @__PURE__ */ Ae(yi, "<="), yq = /* @__PURE__ */ Ae(yi, ">="), vq = /* @__PURE__ */ Ae(yi, "&&"), bq = /* @__PURE__ */ Ae(yi, "||"), xq = /* @__PURE__ */ Ae(yi, "!"), _q = /* @__PURE__ */ Ae(yi, "^^"), Tq = /* @__PURE__ */ Ae(yi, "&"), Sq = /* @__PURE__ */ Ae(yi, "~"), wq = /* @__PURE__ */ Ae(yi, "|"), Eq = /* @__PURE__ */ Ae(yi, "^"), Mq = /* @__PURE__ */ Ae(yi, "<<"), Aq = /* @__PURE__ */ Ae(yi, ">>");
ge("add", Rr);
ge("sub", sn);
ge("mul", Dt);
ge("div", bo);
ge("modInt", JP);
ge("equal", dq);
ge("notEqual", pq);
ge("lessThan", fq);
ge("greaterThan", mq);
ge("lessThanEqual", gq);
ge("greaterThanEqual", yq);
ge("and", vq);
ge("or", bq);
ge("not", xq);
ge("xor", _q);
ge("bitAnd", Tq);
ge("bitNot", Sq);
ge("bitOr", wq);
ge("bitXor", Eq);
ge("shiftLeft", Mq);
ge("shiftRight", Aq);
const Cq = (...r) => (console.warn("TSL.OperatorNode: .remainder() has been renamed to .modInt()."), JP(...r));
ge("remainder", Cq);
class re extends zi {
  static get type() {
    return "MathNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.method = e, this.aNode = i, this.bNode = n, this.cNode = s;
  }
  getInputType(e) {
    const i = this.aNode.getNodeType(e), n = this.bNode ? this.bNode.getNodeType(e) : null, s = this.cNode ? this.cNode.getNodeType(e) : null, a = e.isMatrix(i) ? 0 : e.getTypeLength(i), o = e.isMatrix(n) ? 0 : e.getTypeLength(n), l = e.isMatrix(s) ? 0 : e.getTypeLength(s);
    return a > o && a > l ? i : o > l ? n : l > a ? s : i;
  }
  getNodeType(e) {
    const i = this.method;
    return i === re.LENGTH || i === re.DISTANCE || i === re.DOT ? "float" : i === re.CROSS ? "vec3" : i === re.ALL ? "bool" : i === re.EQUALS ? e.changeComponentType(this.aNode.getNodeType(e), "bool") : i === re.MOD ? this.aNode.getNodeType(e) : this.getInputType(e);
  }
  generate(e, i) {
    const n = this.method, s = this.getNodeType(e), a = this.getInputType(e), o = this.aNode, l = this.bNode, u = this.cNode, c = e.renderer.isWebGLRenderer === !0;
    if (n === re.TRANSFORM_DIRECTION) {
      let h = o, d = l;
      e.isMatrix(h.getNodeType(e)) ? d = xt(ye(d), 0) : h = xt(ye(h), 0);
      const p = Dt(h, d).xyz;
      return Td(p).build(e, i);
    } else {
      if (n === re.NEGATE)
        return e.format("( - " + o.build(e, a) + " )", s, i);
      if (n === re.ONE_MINUS)
        return sn(1, o).build(e, i);
      if (n === re.RECIPROCAL)
        return bo(1, o).build(e, i);
      if (n === re.DIFFERENCE)
        return Gn(sn(o, l)).build(e, i);
      {
        const h = [];
        return n === re.CROSS || n === re.MOD ? h.push(
          o.build(e, s),
          l.build(e, s)
        ) : c && n === re.STEP ? h.push(
          o.build(e, e.getTypeLength(o.getNodeType(e)) === 1 ? "float" : a),
          l.build(e, a)
        ) : c && (n === re.MIN || n === re.MAX) || n === re.MOD ? h.push(
          o.build(e, a),
          l.build(e, e.getTypeLength(l.getNodeType(e)) === 1 ? "float" : a)
        ) : n === re.REFRACT ? h.push(
          o.build(e, a),
          l.build(e, a),
          u.build(e, "float")
        ) : n === re.MIX ? h.push(
          o.build(e, a),
          l.build(e, a),
          u.build(e, e.getTypeLength(u.getNodeType(e)) === 1 ? "float" : a)
        ) : (h.push(o.build(e, a)), l !== null && h.push(l.build(e, a)), u !== null && h.push(u.build(e, a))), e.format(`${e.getMethod(n, s)}( ${h.join(", ")} )`, s, i);
      }
    }
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
re.ALL = "all";
re.ANY = "any";
re.EQUALS = "equals";
re.RADIANS = "radians";
re.DEGREES = "degrees";
re.EXP = "exp";
re.EXP2 = "exp2";
re.LOG = "log";
re.LOG2 = "log2";
re.SQRT = "sqrt";
re.INVERSE_SQRT = "inversesqrt";
re.FLOOR = "floor";
re.CEIL = "ceil";
re.NORMALIZE = "normalize";
re.FRACT = "fract";
re.SIN = "sin";
re.COS = "cos";
re.TAN = "tan";
re.ASIN = "asin";
re.ACOS = "acos";
re.ATAN = "atan";
re.ABS = "abs";
re.SIGN = "sign";
re.LENGTH = "length";
re.NEGATE = "negate";
re.ONE_MINUS = "oneMinus";
re.DFDX = "dFdx";
re.DFDY = "dFdy";
re.ROUND = "round";
re.RECIPROCAL = "reciprocal";
re.TRUNC = "trunc";
re.FWIDTH = "fwidth";
re.BITCAST = "bitcast";
re.TRANSPOSE = "transpose";
re.ATAN2 = "atan2";
re.MIN = "min";
re.MAX = "max";
re.MOD = "mod";
re.STEP = "step";
re.REFLECT = "reflect";
re.DISTANCE = "distance";
re.DIFFERENCE = "difference";
re.DOT = "dot";
re.CROSS = "cross";
re.POW = "pow";
re.TRANSFORM_DIRECTION = "transformDirection";
re.MIX = "mix";
re.CLAMP = "clamp";
re.REFRACT = "refract";
re.SMOOTHSTEP = "smoothstep";
re.FACEFORWARD = "faceforward";
const Rq = /* @__PURE__ */ be(1e-6), Nq = /* @__PURE__ */ be(Math.PI), eI = /* @__PURE__ */ Ae(re, re.ALL), Pq = /* @__PURE__ */ Ae(re, re.ANY), Iq = /* @__PURE__ */ Ae(re, re.EQUALS), Oq = /* @__PURE__ */ Ae(re, re.RADIANS), Dq = /* @__PURE__ */ Ae(re, re.DEGREES), tI = /* @__PURE__ */ Ae(re, re.EXP), _d = /* @__PURE__ */ Ae(re, re.EXP2), iI = /* @__PURE__ */ Ae(re, re.LOG), ya = /* @__PURE__ */ Ae(re, re.LOG2), N1 = /* @__PURE__ */ Ae(re, re.SQRT), Lq = /* @__PURE__ */ Ae(re, re.INVERSE_SQRT), yl = /* @__PURE__ */ Ae(re, re.FLOOR), P1 = /* @__PURE__ */ Ae(re, re.CEIL), Td = /* @__PURE__ */ Ae(re, re.NORMALIZE), To = /* @__PURE__ */ Ae(re, re.FRACT), Vn = /* @__PURE__ */ Ae(re, re.SIN), Za = /* @__PURE__ */ Ae(re, re.COS), kq = /* @__PURE__ */ Ae(re, re.TAN), Uq = /* @__PURE__ */ Ae(re, re.ASIN), Fq = /* @__PURE__ */ Ae(re, re.ACOS), Bq = /* @__PURE__ */ Ae(re, re.ATAN), Gn = /* @__PURE__ */ Ae(re, re.ABS), rI = /* @__PURE__ */ Ae(re, re.SIGN), fo = /* @__PURE__ */ Ae(re, re.LENGTH), zq = /* @__PURE__ */ Ae(re, re.NEGATE), jq = /* @__PURE__ */ Ae(re, re.ONE_MINUS), nI = /* @__PURE__ */ Ae(re, re.DFDX), sI = /* @__PURE__ */ Ae(re, re.DFDY), Vq = /* @__PURE__ */ Ae(re, re.ROUND), Gq = /* @__PURE__ */ Ae(re, re.RECIPROCAL), Hq = /* @__PURE__ */ Ae(re, re.TRUNC), Wq = /* @__PURE__ */ Ae(re, re.FWIDTH);
re.BITCAST;
const qq = /* @__PURE__ */ Ae(re, re.TRANSPOSE), Xq = /* @__PURE__ */ Ae(re, re.ATAN2), Sd = /* @__PURE__ */ Ae(re, re.MIN), Sn = /* @__PURE__ */ Ae(re, re.MAX), aI = /* @__PURE__ */ Ae(re, re.MOD), oI = /* @__PURE__ */ Ae(re, re.STEP), $q = /* @__PURE__ */ Ae(re, re.REFLECT), Yq = /* @__PURE__ */ Ae(re, re.DISTANCE), Kq = /* @__PURE__ */ Ae(re, re.DIFFERENCE), I1 = /* @__PURE__ */ Ae(re, re.DOT), lI = /* @__PURE__ */ Ae(re, re.CROSS), Ug = /* @__PURE__ */ Ae(re, re.POW), uI = /* @__PURE__ */ Ae(re, re.POW, 2), Zq = /* @__PURE__ */ Ae(re, re.POW, 3), Qq = /* @__PURE__ */ Ae(re, re.POW, 4), Jq = /* @__PURE__ */ Ae(re, re.TRANSFORM_DIRECTION), eX = (r) => Dt(rI(r), Ug(Gn(r), 1 / 3)), tX = (r) => I1(r, r), li = /* @__PURE__ */ Ae(re, re.MIX), xa = (r, e = 0, i = 1) => De(new re(re.CLAMP, De(r), De(e), De(i))), iX = (r) => xa(r), cI = /* @__PURE__ */ Ae(re, re.REFRACT), Ml = /* @__PURE__ */ Ae(re, re.SMOOTHSTEP), rX = /* @__PURE__ */ Ae(re, re.FACEFORWARD), nX = /* @__PURE__ */ Fe(([r]) => {
  const e = 43758.5453, i = I1(r.xy, He(12.9898, 78.233)), n = aI(i, Nq);
  return To(Vn(n).mul(e));
}), sX = (r, e, i) => li(e, i, r), aX = (r, e, i) => Ml(e, i, r);
ge("all", eI);
ge("any", Pq);
ge("equals", Iq);
ge("radians", Oq);
ge("degrees", Dq);
ge("exp", tI);
ge("exp2", _d);
ge("log", iI);
ge("log2", ya);
ge("sqrt", N1);
ge("inverseSqrt", Lq);
ge("floor", yl);
ge("ceil", P1);
ge("normalize", Td);
ge("fract", To);
ge("sin", Vn);
ge("cos", Za);
ge("tan", kq);
ge("asin", Uq);
ge("acos", Fq);
ge("atan", Bq);
ge("abs", Gn);
ge("sign", rI);
ge("length", fo);
ge("lengthSq", tX);
ge("negate", zq);
ge("oneMinus", jq);
ge("dFdx", nI);
ge("dFdy", sI);
ge("round", Vq);
ge("reciprocal", Gq);
ge("trunc", Hq);
ge("fwidth", Wq);
ge("atan2", Xq);
ge("min", Sd);
ge("max", Sn);
ge("mod", aI);
ge("step", oI);
ge("reflect", $q);
ge("distance", Yq);
ge("dot", I1);
ge("cross", lI);
ge("pow", Ug);
ge("pow2", uI);
ge("pow3", Zq);
ge("pow4", Qq);
ge("transformDirection", Jq);
ge("mix", sX);
ge("clamp", xa);
ge("refract", cI);
ge("smoothstep", aX);
ge("faceForward", rX);
ge("difference", Kq);
ge("saturate", iX);
ge("cbrt", eX);
ge("transpose", qq);
ge("rand", nX);
class oX extends Mt {
  static get type() {
    return "ConditionalNode";
  }
  constructor(e, i, n = null) {
    super(), this.condNode = e, this.ifNode = i, this.elseNode = n;
  }
  getNodeType(e) {
    const i = this.ifNode.getNodeType(e);
    if (this.elseNode !== null) {
      const n = this.elseNode.getNodeType(e);
      if (e.getTypeLength(n) > e.getTypeLength(i))
        return n;
    }
    return i;
  }
  setup(e) {
    const i = this.condNode.cache(), n = this.ifNode.cache(), s = this.elseNode ? this.elseNode.cache() : null, a = e.context.nodeBlock;
    e.getDataFromNode(n).parentNodeBlock = a, s !== null && (e.getDataFromNode(s).parentNodeBlock = a);
    const o = e.getNodeProperties(this);
    o.condNode = i, o.ifNode = n.context({ nodeBlock: n }), o.elseNode = s ? s.context({ nodeBlock: s }) : null;
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = e.getDataFromNode(this);
    if (s.nodeProperty !== void 0)
      return s.nodeProperty;
    const { condNode: a, ifNode: o, elseNode: l } = e.getNodeProperties(this), u = i !== "void", c = u ? Ru(n).build(e) : "";
    s.nodeProperty = c;
    const h = a.build(e, "bool");
    e.addFlowCode(`
${e.tab}if ( ${h} ) {

`).addFlowTab();
    let d = o.build(e, n);
    if (d && (u ? d = c + " = " + d + ";" : d = "return " + d + ";"), e.removeFlowTab().addFlowCode(e.tab + "	" + d + `

` + e.tab + "}"), l !== null) {
      e.addFlowCode(` else {

`).addFlowTab();
      let p = l.build(e, n);
      p && (u ? p = c + " = " + p + ";" : p = "return " + p + ";"), e.removeFlowTab().addFlowCode(e.tab + "	" + p + `

` + e.tab + `}

`);
    } else
      e.addFlowCode(`

`);
    return e.format(c, n, i);
  }
}
const Ur = /* @__PURE__ */ Ae(oX);
ge("select", Ur);
const lX = (...r) => (console.warn("TSL.ConditionalNode: cond() has been renamed to select()."), Ur(...r));
ge("cond", lX);
class hI extends Mt {
  static get type() {
    return "ContextNode";
  }
  constructor(e, i = {}) {
    super(), this.isContextNode = !0, this.node = e, this.value = i;
  }
  getScope() {
    return this.node.getScope();
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  analyze(e) {
    this.node.build(e);
  }
  setup(e) {
    const i = e.getContext();
    e.setContext({ ...e.context, ...this.value });
    const n = this.node.build(e);
    return e.setContext(i), n;
  }
  generate(e, i) {
    const n = e.getContext();
    e.setContext({ ...e.context, ...this.value });
    const s = this.node.build(e, i);
    return e.setContext(n), s;
  }
}
const O1 = /* @__PURE__ */ Ae(hI), uX = (r, e) => O1(r, { label: e });
ge("context", O1);
ge("label", uX);
class cX extends Mt {
  static get type() {
    return "VarNode";
  }
  constructor(e, i = null) {
    super(), this.node = e, this.name = i, this.global = !0, this.isVarNode = !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { node: i, name: n } = this, s = e.getVarFromNode(this, n, e.getVectorType(this.getNodeType(e))), a = e.getPropertyName(s), o = i.build(e, s.type);
    return e.addLineFlowCode(`${a} = ${o}`, this), a;
  }
}
const dI = /* @__PURE__ */ Ae(cX);
ge("toVar", (...r) => dI(...r).append());
const hX = (r) => (console.warn('TSL: "temp" is deprecated. Use ".toVar()" instead.'), dI(r));
ge("temp", hX);
class dX extends Mt {
  static get type() {
    return "VaryingNode";
  }
  constructor(e, i = null) {
    super(), this.node = e, this.name = i, this.isVaryingNode = !0;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setupVarying(e) {
    const i = e.getNodeProperties(this);
    let n = i.varying;
    if (n === void 0) {
      const s = this.name, a = this.getNodeType(e);
      i.varying = n = e.getVaryingFromNode(this, s, a), i.node = this.node;
    }
    return n.needsInterpolation || (n.needsInterpolation = e.shaderStage === "fragment"), n;
  }
  setup(e) {
    this.setupVarying(e);
  }
  analyze(e) {
    return this.setupVarying(e), this.node.analyze(e);
  }
  generate(e) {
    const i = e.getNodeProperties(this), n = this.setupVarying(e);
    if (i.propertyName === void 0) {
      const s = this.getNodeType(e), a = e.getPropertyName(n, lM.VERTEX);
      e.flowNodeFromShaderStage(lM.VERTEX, this.node, s, a), i.propertyName = a;
    }
    return e.getPropertyName(n);
  }
}
const Ea = /* @__PURE__ */ Ae(dX);
ge("varying", Ea);
const pX = /* @__PURE__ */ Fe(([r]) => {
  const e = r.mul(0.9478672986).add(0.0521327014).pow(2.4), i = r.mul(0.0773993808), n = r.lessThanEqual(0.04045);
  return li(e, i, n);
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), fX = /* @__PURE__ */ Fe(([r]) => {
  const e = r.pow(0.41666).mul(1.055).sub(0.055), i = r.mul(12.92), n = r.lessThanEqual(31308e-7);
  return li(e, i, n);
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), ip = "WorkingColorSpace", D1 = "OutputColorSpace";
class Fg extends zi {
  static get type() {
    return "ColorSpaceNode";
  }
  constructor(e, i, n) {
    super("vec4"), this.colorNode = e, this.source = i, this.target = n;
  }
  resolveColorSpace(e, i) {
    return i === ip ? Li.workingColorSpace : i === D1 ? e.context.outputColorSpace || e.renderer.outputColorSpace : i;
  }
  setup(e) {
    const { colorNode: i } = this, n = this.resolveColorSpace(e, this.source), s = this.resolveColorSpace(e, this.target);
    let a = i;
    return Li.enabled === !1 || n === s || !n || !s || (Li.getTransfer(n) === vd && (a = xt(pX(a.rgb), a.a)), Li.getPrimaries(n) !== Li.getPrimaries(s) && (a = xt(
      Cr(Li._getMatrix(new qr(), n, s)).mul(a.rgb),
      a.a
    )), Li.getTransfer(s) === vd && (a = xt(fX(a.rgb), a.a))), a;
  }
}
const mX = (r) => De(new Fg(De(r), ip, D1)), gX = (r) => De(new Fg(De(r), D1, ip)), yX = (r, e) => De(new Fg(De(r), ip, e)), pI = (r, e) => De(new Fg(De(r), e, ip));
ge("toOutputColorSpace", mX);
ge("toWorkingColorSpace", gX);
ge("workingToColorSpace", yX);
ge("colorSpaceToWorking", pI);
let vX = class extends ep {
  static get type() {
    return "ReferenceElementNode";
  }
  constructor(r, e) {
    super(r, e), this.referenceNode = r, this.isReferenceElementNode = !0;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(r) {
    const e = super.generate(r), i = this.referenceNode.getNodeType(), n = this.getNodeType();
    return r.format(e, i, n);
  }
};
class fI extends Mt {
  static get type() {
    return "ReferenceBaseNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.property = e, this.uniformType = i, this.object = n, this.count = s, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.updateType = Nt.OBJECT;
  }
  setGroup(e) {
    return this.group = e, this;
  }
  element(e) {
    return De(new vX(this, De(e)));
  }
  setNodeType(e) {
    const i = _t(null, e).getSelf();
    this.group !== null && i.setGroup(this.group), this.node = i;
  }
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  getValueFromReference(e = this.reference) {
    const { properties: i } = this;
    let n = e[i[0]];
    for (let s = 1; s < i.length; s++)
      n = n[i[s]];
    return n;
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setup() {
    return this.updateValue(), this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const bX = (r, e, i) => De(new fI(r, e, i));
class xX extends fI {
  static get type() {
    return "RendererReferenceNode";
  }
  constructor(e, i, n = null) {
    super(e, i, n), this.renderer = n, this.setGroup(kt);
  }
  updateReference(e) {
    return this.reference = this.renderer !== null ? this.renderer : e.renderer, this.reference;
  }
}
const _X = (r, e, i) => De(new xX(r, e, i));
class TX extends zi {
  static get type() {
    return "ToneMappingNode";
  }
  constructor(e, i = wX, n = null) {
    super("vec3"), this.toneMapping = e, this.exposureNode = i, this.colorNode = n;
  }
  getCacheKey() {
    return zm(super.getCacheKey(), this.toneMapping);
  }
  setup(e) {
    const i = this.colorNode || e.context.color, n = this.toneMapping;
    if (n === Yu) return i;
    let s = null;
    const a = e.renderer.library.getToneMappingFunction(n);
    return a !== null ? s = xt(a(i.rgb, this.exposureNode), i.a) : (console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", n), s = i), s;
  }
}
const SX = (r, e, i) => De(new TX(r, De(e), De(i))), wX = /* @__PURE__ */ _X("toneMappingExposure", "float");
ge("toneMapping", (r, e, i) => SX(e, i, r));
class EX extends S1 {
  static get type() {
    return "BufferAttributeNode";
  }
  constructor(e, i = null, n = 0, s = 0) {
    super(e, i), this.isBufferNode = !0, this.bufferType = i, this.bufferStride = n, this.bufferOffset = s, this.usage = Bm, this.instanced = !1, this.attribute = null, this.global = !0, e && e.isBufferAttribute === !0 && (this.attribute = e, this.usage = e.usage, this.instanced = e.isInstancedBufferAttribute);
  }
  getHash(e) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let i = e.globalCache.getData(this.value);
      return i === void 0 && (i = {
        node: this
      }, e.globalCache.setData(this.value, i)), i.node.uuid;
    }
    return this.uuid;
  }
  getNodeType(e) {
    return this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)), this.bufferType;
  }
  setup(e) {
    if (this.attribute !== null) return;
    const i = this.getNodeType(e), n = this.value, s = e.getTypeLength(i), a = this.bufferStride || s, o = this.bufferOffset, l = n.isInterleavedBuffer === !0 ? n : new SP(n, a), u = new y1(l, s, o);
    l.setUsage(this.usage), this.attribute = u, this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(e) {
    const i = this.getNodeType(e), n = e.getBufferAttributeFromNode(this, i), s = e.getPropertyName(n);
    let a = null;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? (this.name = s, a = s) : a = Ea(this).build(e, i), a;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(e) {
    return this.usage = e, this.attribute && this.attribute.isBufferAttribute === !0 && (this.attribute.usage = e), this;
  }
  setInstanced(e) {
    return this.instanced = e, this;
  }
}
const L1 = (r, e, i, n) => De(new EX(r, e, i, n)), MX = (r, e, i, n) => L1(r, e, i, n).setUsage(ku), vM = (r, e, i, n) => L1(r, e, i, n).setInstanced(!0), bM = (r, e, i, n) => MX(r, e, i, n).setInstanced(!0);
ge("toAttribute", (r) => L1(r.value));
class AX extends Mt {
  static get type() {
    return "ComputeNode";
  }
  constructor(e, i, n = [64]) {
    super("void"), this.isComputeNode = !0, this.computeNode = e, this.count = i, this.workgroupSize = n, this.dispatchCount = 0, this.version = 1, this.updateBeforeType = Nt.OBJECT, this.onInitFunction = null, this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  updateDispatchCount() {
    const { count: e, workgroupSize: i } = this;
    let n = i[0];
    for (let s = 1; s < i.length; s++)
      n *= i[s];
    this.dispatchCount = Math.ceil(e / n);
  }
  onInit(e) {
    return this.onInitFunction = e, this;
  }
  updateBefore({ renderer: e }) {
    e.compute(this);
  }
  generate(e) {
    const { shaderStage: i } = e;
    if (i === "compute") {
      const n = this.computeNode.build(e, "void");
      n !== "" && e.addLineFlowCode(n, this);
    }
  }
}
const CX = (r, e, i) => De(new AX(De(r), e, i));
ge("compute", CX);
class RX extends Mt {
  static get type() {
    return "CacheNode";
  }
  constructor(e, i = !0) {
    super(), this.node = e, this.parent = i, this.isCacheNode = !0;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  build(e, ...i) {
    const n = e.getCache(), s = e.getCacheFromNode(this, this.parent);
    e.setCache(s);
    const a = this.node.build(e, ...i);
    return e.setCache(n), a;
  }
}
const lm = (r, ...e) => De(new RX(De(r), ...e));
ge("cache", lm);
class NX extends Mt {
  static get type() {
    return "BypassNode";
  }
  constructor(e, i) {
    super(), this.isBypassNode = !0, this.outputNode = e, this.callNode = i;
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const i = this.callNode.build(e, "void");
    return i !== "" && e.addLineFlowCode(i, this), this.outputNode.build(e);
  }
}
const PX = /* @__PURE__ */ Ae(NX);
ge("bypass", PX);
class mI extends Mt {
  static get type() {
    return "RemapNode";
  }
  constructor(e, i, n, s = be(0), a = be(1)) {
    super(), this.node = e, this.inLowNode = i, this.inHighNode = n, this.outLowNode = s, this.outHighNode = a, this.doClamp = !0;
  }
  setup() {
    const { node: e, inLowNode: i, inHighNode: n, outLowNode: s, outHighNode: a, doClamp: o } = this;
    let l = e.sub(i).div(n.sub(i));
    return o === !0 && (l = l.clamp()), l.mul(a.sub(s)).add(s);
  }
}
const IX = /* @__PURE__ */ Ae(mI, null, null, { doClamp: !1 }), OX = /* @__PURE__ */ Ae(mI);
ge("remap", IX);
ge("remapClamp", OX);
class DX extends Mt {
  static get type() {
    return "ExpressionNode";
  }
  constructor(e = "", i = "void") {
    super(i), this.snippet = e;
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.snippet;
    if (n === "void")
      e.addLineFlowCode(s, this);
    else
      return e.format(`( ${s} )`, n, i);
  }
}
const wd = /* @__PURE__ */ Ae(DX), LX = (r) => (r ? Ur(r, wd("discard")) : wd("discard")).append();
ge("discard", LX);
class kX extends zi {
  static get type() {
    return "RenderOutputNode";
  }
  constructor(e, i, n) {
    super("vec4"), this.colorNode = e, this.toneMapping = i, this.outputColorSpace = n, this.isRenderOutput = !0;
  }
  setup({ context: e }) {
    let i = this.colorNode || e.color;
    const n = (this.toneMapping !== null ? this.toneMapping : e.toneMapping) || Yu, s = (this.outputColorSpace !== null ? this.outputColorSpace : e.outputColorSpace) || Sl;
    return n !== Yu && (i = i.toneMapping(n)), s !== Sl && s !== Li.workingColorSpace && (i = i.workingToColorSpace(s)), i;
  }
}
const UX = (r, e = null, i = null) => De(new kX(De(r), e, i));
ge("renderOutput", UX);
class FX extends Mt {
  static get type() {
    return "AttributeNode";
  }
  constructor(e, i = null) {
    super(i), this.global = !0, this._attributeName = e;
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let i = this.nodeType;
    if (i === null) {
      const n = this.getAttributeName(e);
      if (e.hasGeometryAttribute(n)) {
        const s = e.geometry.getAttribute(n);
        i = e.getTypeFromAttribute(s);
      } else
        i = "float";
    }
    return i;
  }
  setAttributeName(e) {
    return this._attributeName = e, this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const i = this.getAttributeName(e), n = this.getNodeType(e);
    if (e.hasGeometryAttribute(i) === !0) {
      const s = e.geometry.getAttribute(i), a = e.getTypeFromAttribute(s), o = e.getAttribute(i, a);
      return e.shaderStage === "vertex" ? e.format(o.name, a, n) : Ea(this).build(e, n);
    } else
      return console.warn(`AttributeNode: Vertex attribute "${i}" not found on geometry.`), e.generateConst(n);
  }
  serialize(e) {
    super.serialize(e), e.global = this.global, e._attributeName = this._attributeName;
  }
  deserialize(e) {
    super.deserialize(e), this.global = e.global, this._attributeName = e._attributeName;
  }
}
const _a = (r, e) => De(new FX(r, e)), Bg = (r) => _a("uv" + (r > 0 ? r : ""), "vec2");
class BX extends Mt {
  static get type() {
    return "TextureSizeNode";
  }
  constructor(e, i = null) {
    super("uvec2"), this.isTextureSizeNode = !0, this.textureNode = e, this.levelNode = i;
  }
  generate(e, i) {
    const n = this.textureNode.build(e, "property"), s = this.levelNode === null ? "0" : this.levelNode.build(e, "int");
    return e.format(`${e.getMethod("textureDimensions")}( ${n}, ${s} )`, this.getNodeType(e), i);
  }
}
const rd = /* @__PURE__ */ Ae(BX);
class zX extends tp {
  static get type() {
    return "MaxMipLevelNode";
  }
  constructor(e) {
    super(0), this._textureNode = e, this.updateType = Nt.FRAME;
  }
  get textureNode() {
    return this._textureNode;
  }
  get texture() {
    return this._textureNode.value;
  }
  update() {
    const e = this.texture, i = e.images, n = i && i.length > 0 ? i[0] && i[0].image || i[0] : e.image;
    if (n && n.width !== void 0) {
      const { width: s, height: a } = n;
      this.value = Math.log2(Math.max(s, a));
    }
  }
}
const jX = /* @__PURE__ */ Ae(zX);
class rp extends tp {
  static get type() {
    return "TextureNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e), this.isTextureNode = !0, this.uvNode = i, this.levelNode = n, this.biasNode = s, this.compareNode = null, this.depthNode = null, this.gradNode = null, this.sampler = !0, this.updateMatrix = !1, this.updateType = Nt.NONE, this.referenceNode = null, this._value = e, this._matrixUniform = null, this.setUpdateMatrix(i === null);
  }
  set value(e) {
    this.referenceNode ? this.referenceNode.value = e : this._value = e;
  }
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : this.value.type === Ji ? "uvec4" : this.value.type === Tr ? "ivec4" : "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return Bg(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(e) {
    return this._matrixUniform === null && (this._matrixUniform = _t(this.value.matrix)), this._matrixUniform.mul(ye(e, 1)).xy;
  }
  setUpdateMatrix(e) {
    return this.updateMatrix = e, this.updateType = e ? Nt.FRAME : Nt.NONE, this;
  }
  setupUV(e, i) {
    const n = this.value;
    return e.isFlipY() && (n.isRenderTargetTexture === !0 || n.isFramebufferTexture === !0 || n.isDepthTexture === !0) && (this.sampler ? i = i.flipY() : i = i.setY(Mi(rd(this, this.levelNode).y).sub(i.y).sub(1))), i;
  }
  setup(e) {
    const i = e.getNodeProperties(this);
    i.referenceNode = this.referenceNode;
    let n = this.uvNode;
    (n === null || e.context.forceUVContext === !0) && e.context.getUV && (n = e.context.getUV(this)), n || (n = this.getDefaultUV()), this.updateMatrix === !0 && (n = this.getTransformedUV(n)), n = this.setupUV(e, n);
    let s = this.levelNode;
    s === null && e.context.getTextureLevel && (s = e.context.getTextureLevel(this)), i.uvNode = n, i.levelNode = s, i.biasNode = this.biasNode, i.compareNode = this.compareNode, i.gradNode = this.gradNode, i.depthNode = this.depthNode;
  }
  generateUV(e, i) {
    return i.build(e, this.sampler === !0 ? "vec2" : "ivec2");
  }
  generateSnippet(e, i, n, s, a, o, l, u) {
    const c = this.value;
    let h;
    return s ? h = e.generateTextureLevel(c, i, n, s, o) : a ? h = e.generateTextureBias(c, i, n, a, o) : u ? h = e.generateTextureGrad(c, i, n, u, o) : l ? h = e.generateTextureCompare(c, i, n, l, o) : this.sampler === !1 ? h = e.generateTextureLoad(c, i, n, o) : h = e.generateTexture(c, i, n, o), h;
  }
  generate(e, i) {
    const n = e.getNodeProperties(this), s = this.value;
    if (!s || s.isTexture !== !0)
      throw new Error("TextureNode: Need a three.js texture.");
    const a = super.generate(e, "property");
    if (i === "sampler")
      return a + "_sampler";
    if (e.isReference(i))
      return a;
    {
      const o = e.getDataFromNode(this);
      let l = o.propertyName;
      if (l === void 0) {
        const { uvNode: h, levelNode: d, biasNode: p, compareNode: f, depthNode: m, gradNode: y } = n, v = this.generateUV(e, h), g = d ? d.build(e, "float") : null, _ = p ? p.build(e, "float") : null, x = m ? m.build(e, "int") : null, b = f ? f.build(e, "float") : null, T = y ? [y[0].build(e, "vec2"), y[1].build(e, "vec2")] : null, S = e.getVarFromNode(this);
        l = e.getPropertyName(S);
        const w = this.generateSnippet(e, a, v, g, _, x, b, T);
        e.addLineFlowCode(`${l} = ${w}`, this), o.snippet = w, o.propertyName = l;
      }
      let u = l;
      const c = this.getNodeType(e);
      return e.needsToWorkingColorSpace(s) && (u = pI(wd(u, c), s.colorSpace).setup(e).build(e, c)), e.format(u, c, i);
    }
  }
  setSampler(e) {
    return this.sampler = e, this;
  }
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  uv(e) {
    const i = this.clone();
    return i.uvNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  blur(e) {
    const i = this.clone();
    return i.biasNode = De(e).mul(jX(i)), i.referenceNode = this.getSelf(), De(i);
  }
  level(e) {
    const i = this.clone();
    return i.levelNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  size(e) {
    return rd(this, e);
  }
  bias(e) {
    const i = this.clone();
    return i.biasNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  compare(e) {
    const i = this.clone();
    return i.compareNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  grad(e, i) {
    const n = this.clone();
    return n.gradNode = [De(e), De(i)], n.referenceNode = this.getSelf(), De(n);
  }
  depth(e) {
    const i = this.clone();
    return i.depthNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  // --
  serialize(e) {
    super.serialize(e), e.value = this.value.toJSON(e.meta).uuid, e.sampler = this.sampler, e.updateMatrix = this.updateMatrix, e.updateType = this.updateType;
  }
  deserialize(e) {
    super.deserialize(e), this.value = e.meta.textures[e.value], this.sampler = e.sampler, this.updateMatrix = e.updateMatrix, this.updateType = e.updateType;
  }
  update() {
    const e = this.value, i = this._matrixUniform;
    i !== null && (i.value = e.matrix), e.matrixAutoUpdate === !0 && e.updateMatrix();
  }
  clone() {
    const e = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
    return e.sampler = this.sampler, e;
  }
}
const Ci = /* @__PURE__ */ Ae(rp), Un = (...r) => Ci(...r).setSampler(!1), Ko = /* @__PURE__ */ _t("float").label("cameraNear").setGroup(kt).onRenderUpdate(({ camera: r }) => r.near), Zo = /* @__PURE__ */ _t("float").label("cameraFar").setGroup(kt).onRenderUpdate(({ camera: r }) => r.far), $m = /* @__PURE__ */ _t("mat4").label("cameraProjectionMatrix").setGroup(kt).onRenderUpdate(({ camera: r }) => r.projectionMatrix), Ma = /* @__PURE__ */ _t("mat4").label("cameraViewMatrix").setGroup(kt).onRenderUpdate(({ camera: r }) => r.matrixWorldInverse), VX = /* @__PURE__ */ _t(new ue()).label("cameraPosition").setGroup(kt).onRenderUpdate(({ camera: r }, e) => e.value.setFromMatrixPosition(r.matrixWorld));
class wi extends Mt {
  static get type() {
    return "Object3DNode";
  }
  constructor(e, i = null) {
    super(), this.scope = e, this.object3d = i, this.updateType = Nt.OBJECT, this._uniformNode = new tp(null);
  }
  getNodeType() {
    const e = this.scope;
    if (e === wi.WORLD_MATRIX)
      return "mat4";
    if (e === wi.POSITION || e === wi.VIEW_POSITION || e === wi.DIRECTION || e === wi.SCALE)
      return "vec3";
  }
  update(e) {
    const i = this.object3d, n = this._uniformNode, s = this.scope;
    if (s === wi.WORLD_MATRIX)
      n.value = i.matrixWorld;
    else if (s === wi.POSITION)
      n.value = n.value || new ue(), n.value.setFromMatrixPosition(i.matrixWorld);
    else if (s === wi.SCALE)
      n.value = n.value || new ue(), n.value.setFromMatrixScale(i.matrixWorld);
    else if (s === wi.DIRECTION)
      n.value = n.value || new ue(), i.getWorldDirection(n.value);
    else if (s === wi.VIEW_POSITION) {
      const a = e.camera;
      n.value = n.value || new ue(), n.value.setFromMatrixPosition(i.matrixWorld), n.value.applyMatrix4(a.matrixWorldInverse);
    }
  }
  generate(e) {
    const i = this.scope;
    return i === wi.WORLD_MATRIX ? this._uniformNode.nodeType = "mat4" : (i === wi.POSITION || i === wi.VIEW_POSITION || i === wi.DIRECTION || i === wi.SCALE) && (this._uniformNode.nodeType = "vec3"), this._uniformNode.build(e);
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
wi.WORLD_MATRIX = "worldMatrix";
wi.POSITION = "position";
wi.SCALE = "scale";
wi.VIEW_POSITION = "viewPosition";
wi.DIRECTION = "direction";
class wc extends wi {
  static get type() {
    return "ModelNode";
  }
  constructor(e) {
    super(e);
  }
  update(e) {
    this.object3d = e.object, super.update(e);
  }
}
wc.DIRECTION;
const Al = /* @__PURE__ */ Ve(wc, wc.WORLD_MATRIX);
wc.POSITION;
wc.SCALE;
wc.VIEW_POSITION;
const GX = /* @__PURE__ */ _t(new qr()).onObjectUpdate(({ object: r }, e) => e.value.getNormalMatrix(r.matrixWorld)), zg = /* @__PURE__ */ Ma.mul(Al).toVar("modelViewMatrix"), gI = /* @__PURE__ */ _a("position", "vec3"), nr = /* @__PURE__ */ gI.varying("positionLocal"), xM = /* @__PURE__ */ gI.varying("positionPrevious"), Ax = /* @__PURE__ */ Al.mul(nr).xyz.varying("v_positionWorld"), yI = /* @__PURE__ */ nr.transformDirection(Al).varying("v_positionWorldDirection").normalize().toVar("positionWorldDirection"), ir = /* @__PURE__ */ zg.mul(nr).xyz.varying("v_positionView"), vi = /* @__PURE__ */ ir.negate().varying("v_positionViewDirection").normalize().toVar("positionViewDirection");
class HX extends Mt {
  static get type() {
    return "FrontFacingNode";
  }
  constructor() {
    super("bool"), this.isFrontFacingNode = !0;
  }
  generate(e) {
    const { renderer: i, material: n } = e;
    return i.coordinateSystem === Yn && n.side === Zn ? "false" : e.getFrontFacing();
  }
}
const WX = /* @__PURE__ */ Ve(HX), jg = /* @__PURE__ */ be(WX).mul(2).sub(1), vI = /* @__PURE__ */ _a("normal", "vec3"), _s = /* @__PURE__ */ Fe((r) => r.geometry.hasAttribute("normal") === !1 ? (console.warn('TSL.NormalNode: Vertex attribute "normal" not found on geometry.'), ye(0, 1, 0)) : vI, "vec3").once()().toVar("normalLocal"), qX = /* @__PURE__ */ ir.dFdx().cross(ir.dFdy()).normalize().toVar("normalFlat"), Jn = /* @__PURE__ */ Fe((r) => {
  let e;
  return r.material.flatShading === !0 ? e = qX : e = Ea(xI(_s), "v_normalView").normalize(), e;
}, "vec3").once()().toVar("normalView"), bI = /* @__PURE__ */ Ea(Jn.transformDirection(Ma), "v_normalWorld").normalize().toVar("normalWorld"), Ui = /* @__PURE__ */ Fe((r) => r.context.setupNormal(), "vec3").once()().mul(jg).toVar("transformedNormalView"), k1 = /* @__PURE__ */ Ui.transformDirection(Ma).toVar("transformedNormalWorld"), Gh = /* @__PURE__ */ Fe((r) => r.context.setupClearcoatNormal(), "vec3").once()().mul(jg).toVar("transformedClearcoatNormalView"), XX = /* @__PURE__ */ Fe(([r, e = Al]) => {
  const i = Cr(e), n = r.div(ye(i[0].dot(i[0]), i[1].dot(i[1]), i[2].dot(i[2])));
  return i.mul(n).xyz;
}), xI = /* @__PURE__ */ Fe(([r], e) => {
  const i = e.renderer.nodes.modelNormalViewMatrix;
  if (i !== null)
    return i.transformDirection(r);
  const n = GX.mul(r);
  return Ma.transformDirection(n);
}), $X = /* @__PURE__ */ _t(0).onReference(({ material: r }) => r).onRenderUpdate(({ material: r }) => r.refractionRatio), YX = /* @__PURE__ */ vi.negate().reflect(Ui), KX = /* @__PURE__ */ vi.negate().refract(Ui, $X), ZX = /* @__PURE__ */ YX.transformDirection(Ma).toVar("reflectVector"), QX = /* @__PURE__ */ KX.transformDirection(Ma).toVar("reflectVector");
class JX extends rp {
  static get type() {
    return "CubeTextureNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e, i, n, s), this.isCubeTextureNode = !0;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    const e = this.value;
    return e.mapping === Tl ? ZX : e.mapping === _c ? QX : (console.error('THREE.CubeTextureNode: Mapping "%s" not supported.', e.mapping), ye(0, 0, 0));
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  setupUV(e, i) {
    const n = this.value;
    return e.renderer.coordinateSystem === wl || !n.isRenderTargetTexture ? ye(i.x.negate(), i.yz) : i;
  }
  generateUV(e, i) {
    return i.build(e, "vec3");
  }
}
const Ed = /* @__PURE__ */ Ae(JX);
class _I extends tp {
  static get type() {
    return "BufferNode";
  }
  constructor(e, i, n = 0) {
    super(e, i), this.isBufferNode = !0, this.bufferType = i, this.bufferCount = n;
  }
  getElementType(e) {
    return this.getNodeType(e);
  }
  getInputType() {
    return "buffer";
  }
}
const U1 = (r, e, i) => De(new _I(r, e, i));
class e$ extends ep {
  static get type() {
    return "UniformArrayElementNode";
  }
  constructor(e, i) {
    super(e, i), this.isArrayBufferElementNode = !0;
  }
  generate(e) {
    const i = super.generate(e), n = this.getNodeType();
    return e.format(i, "vec4", n);
  }
}
class t$ extends _I {
  static get type() {
    return "UniformArrayNode";
  }
  constructor(e, i = null) {
    super(null, "vec4"), this.array = e, this.elementType = i, this._elementType = null, this._elementLength = 0, this.updateType = Nt.RENDER, this.isArrayBufferNode = !0;
  }
  getElementType() {
    return this.elementType || this._elementType;
  }
  getElementLength() {
    return this._elementLength;
  }
  update() {
    const { array: e, value: i } = this, n = this.getElementLength(), s = this.getElementType();
    if (n === 1)
      for (let a = 0; a < e.length; a++) {
        const o = a * 4;
        i[o] = e[a];
      }
    else if (s === "color")
      for (let a = 0; a < e.length; a++) {
        const o = a * 4, l = e[a];
        i[o] = l.r, i[o + 1] = l.g, i[o + 2] = l.b || 0;
      }
    else
      for (let a = 0; a < e.length; a++) {
        const o = a * 4, l = e[a];
        i[o] = l.x, i[o + 1] = l.y, i[o + 2] = l.z || 0, i[o + 3] = l.w || 0;
      }
  }
  setup(e) {
    const i = this.array.length;
    this._elementType = this.elementType === null ? Vm(this.array[0]) : this.elementType, this._elementLength = e.getTypeLength(this._elementType);
    let n = Float32Array;
    return this._elementType.charAt(0) === "i" ? n = Int32Array : this._elementType.charAt(0) === "u" && (n = Uint32Array), this.value = new n(i * 4), this.bufferCount = i, this.bufferType = e.changeComponentType("vec4", e.getComponentType(this._elementType)), super.setup(e);
  }
  element(e) {
    return De(new e$(this, De(e)));
  }
}
const Md = (r, e) => De(new t$(r, e));
class i$ extends ep {
  static get type() {
    return "ReferenceElementNode";
  }
  constructor(e, i) {
    super(e, i), this.referenceNode = e, this.isReferenceElementNode = !0;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(e) {
    const i = super.generate(e), n = this.referenceNode.getNodeType(), s = this.getNodeType();
    return e.format(i, n, s);
  }
}
class F1 extends Mt {
  static get type() {
    return "ReferenceNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.property = e, this.uniformType = i, this.object = n, this.count = s, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.name = null, this.updateType = Nt.OBJECT;
  }
  element(e) {
    return De(new i$(this, De(e)));
  }
  setGroup(e) {
    return this.group = e, this;
  }
  label(e) {
    return this.name = e, this;
  }
  setNodeType(e) {
    let i = null;
    this.count !== null ? i = U1(null, e, this.count) : Array.isArray(this.getValueFromReference()) ? i = Md(null, e) : e === "texture" ? i = Ci(null) : e === "cubeTexture" ? i = Ed(null) : i = _t(null, e), this.group !== null && i.setGroup(this.group), this.name !== null && i.label(this.name), this.node = i.getSelf();
  }
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  getValueFromReference(e = this.reference) {
    const { properties: i } = this;
    let n = e[i[0]];
    for (let s = 1; s < i.length; s++)
      n = n[i[s]];
    return n;
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setup() {
    return this.updateValue(), this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const bi = (r, e, i) => De(new F1(r, e, i)), _M = (r, e, i, n) => De(new F1(r, e, n, i));
class r$ extends F1 {
  static get type() {
    return "MaterialReferenceNode";
  }
  constructor(e, i, n = null) {
    super(e, i, n), this.material = n, this.isMaterialReferenceNode = !0;
  }
  /*setNodeType( node ) {
  
  		super.setNodeType( node );
  
  		this.node.groupNode = renderGroup;
  
  	}*/
  updateReference(e) {
    return this.reference = this.material !== null ? this.material : e.material, this.reference;
  }
}
const eo = (r, e, i) => De(new r$(r, e, i)), TI = /* @__PURE__ */ Fe((r) => (r.geometry.hasAttribute("tangent") === !1 && r.geometry.computeTangents(), _a("tangent", "vec4")))(), B1 = /* @__PURE__ */ TI.xyz.toVar("tangentLocal"), SI = /* @__PURE__ */ zg.mul(xt(B1, 0)).xyz.varying("v_tangentView").normalize().toVar("tangentView"), n$ = (r) => r.mul(TI.w).xyz, s$ = /* @__PURE__ */ Ea(n$(Jn.cross(SI)), "v_bitangentView").normalize().toVar("bitangentView"), Hh = /* @__PURE__ */ Cr(SI, s$, Jn), a$ = /* @__PURE__ */ (() => {
  let r = ec.cross(vi);
  return r = r.cross(ec).normalize(), r = li(r, Ui, Ho.mul(ta.oneMinus()).oneMinus().pow2().pow2()).normalize(), r;
})(), o$ = /* @__PURE__ */ Fe((r) => {
  const { eye_pos: e, surf_norm: i, mapN: n, uv: s } = r, a = e.dFdx(), o = e.dFdy(), l = s.dFdx(), u = s.dFdy(), c = i, h = o.cross(c), d = c.cross(a), p = h.mul(l.x).add(d.mul(u.x)), f = h.mul(l.y).add(d.mul(u.y)), m = p.dot(p).max(f.dot(f)), y = jg.mul(m.inverseSqrt());
  return Rr(p.mul(n.x, y), f.mul(n.y, y), c.mul(n.z)).normalize();
});
class l$ extends zi {
  static get type() {
    return "NormalMapNode";
  }
  constructor(e, i = null) {
    super("vec3"), this.node = e, this.scaleNode = i, this.normalMapType = vo;
  }
  setup(e) {
    const { normalMapType: i, scaleNode: n } = this;
    let s = this.node.mul(2).sub(1);
    n !== null && (s = ye(s.xy.mul(n), s.z));
    let a = null;
    return i === i7 ? a = xI(s) : i === vo && (e.hasGeometryAttribute("tangent") === !0 ? a = Hh.mul(s).normalize() : a = o$({
      eye_pos: ir,
      surf_norm: Jn,
      mapN: s,
      uv: Bg()
    })), a;
  }
}
const TM = /* @__PURE__ */ Ae(l$), u$ = Fe(({ textureNode: r, bumpScale: e }) => {
  const i = (s) => r.cache().context({ getUV: (a) => s(a.uvNode || Bg()), forceUVContext: !0 }), n = be(i((s) => s));
  return He(
    be(i((s) => s.add(s.dFdx()))).sub(n),
    be(i((s) => s.add(s.dFdy()))).sub(n)
  ).mul(e);
}), c$ = Fe((r) => {
  const { surf_pos: e, surf_norm: i, dHdxy: n } = r, s = e.dFdx().normalize(), a = e.dFdy().normalize(), o = i, l = a.cross(o), u = o.cross(s), c = s.dot(l).mul(jg), h = c.sign().mul(n.x.mul(l).add(n.y.mul(u)));
  return c.abs().mul(i).sub(h).normalize();
});
class h$ extends zi {
  static get type() {
    return "BumpMapNode";
  }
  constructor(e, i = null) {
    super("vec3"), this.textureNode = e, this.scaleNode = i;
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1, i = u$({ textureNode: this.textureNode, bumpScale: e });
    return c$({
      surf_pos: ir,
      surf_norm: Jn,
      dHdxy: i
    });
  }
}
const d$ = /* @__PURE__ */ Ae(h$), SM = /* @__PURE__ */ new Map();
class pe extends Mt {
  static get type() {
    return "MaterialNode";
  }
  constructor(e) {
    super(), this.scope = e;
  }
  getCache(e, i) {
    let n = SM.get(e);
    return n === void 0 && (n = eo(e, i), SM.set(e, n)), n;
  }
  getFloat(e) {
    return this.getCache(e, "float");
  }
  getColor(e) {
    return this.getCache(e, "color");
  }
  getTexture(e) {
    return this.getCache(e === "map" ? "map" : e + "Map", "texture");
  }
  setup(e) {
    const i = e.context.material, n = this.scope;
    let s = null;
    if (n === pe.COLOR) {
      const a = i.color !== void 0 ? this.getColor(n) : ye();
      i.map && i.map.isTexture === !0 ? s = a.mul(this.getTexture("map")) : s = a;
    } else if (n === pe.OPACITY) {
      const a = this.getFloat(n);
      i.alphaMap && i.alphaMap.isTexture === !0 ? s = a.mul(this.getTexture("alpha")) : s = a;
    } else if (n === pe.SPECULAR_STRENGTH)
      i.specularMap && i.specularMap.isTexture === !0 ? s = this.getTexture("specular").r : s = be(1);
    else if (n === pe.SPECULAR_INTENSITY) {
      const a = this.getFloat(n);
      i.specularMap ? s = a.mul(this.getTexture(n).a) : s = a;
    } else if (n === pe.SPECULAR_COLOR) {
      const a = this.getColor(n);
      i.specularColorMap && i.specularColorMap.isTexture === !0 ? s = a.mul(this.getTexture(n).rgb) : s = a;
    } else if (n === pe.ROUGHNESS) {
      const a = this.getFloat(n);
      i.roughnessMap && i.roughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).g) : s = a;
    } else if (n === pe.METALNESS) {
      const a = this.getFloat(n);
      i.metalnessMap && i.metalnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).b) : s = a;
    } else if (n === pe.EMISSIVE) {
      const a = this.getFloat("emissiveIntensity"), o = this.getColor(n).mul(a);
      i.emissiveMap && i.emissiveMap.isTexture === !0 ? s = o.mul(this.getTexture(n)) : s = o;
    } else if (n === pe.NORMAL)
      i.normalMap ? (s = TM(this.getTexture("normal"), this.getCache("normalScale", "vec2")), s.normalMapType = i.normalMapType) : i.bumpMap ? s = d$(this.getTexture("bump").r, this.getFloat("bumpScale")) : s = Jn;
    else if (n === pe.CLEARCOAT) {
      const a = this.getFloat(n);
      i.clearcoatMap && i.clearcoatMap.isTexture === !0 ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === pe.CLEARCOAT_ROUGHNESS) {
      const a = this.getFloat(n);
      i.clearcoatRoughnessMap && i.clearcoatRoughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === pe.CLEARCOAT_NORMAL)
      i.clearcoatNormalMap ? s = TM(this.getTexture(n), this.getCache(n + "Scale", "vec2")) : s = Jn;
    else if (n === pe.SHEEN) {
      const a = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      i.sheenColorMap && i.sheenColorMap.isTexture === !0 ? s = a.mul(this.getTexture("sheenColor").rgb) : s = a;
    } else if (n === pe.SHEEN_ROUGHNESS) {
      const a = this.getFloat(n);
      i.sheenRoughnessMap && i.sheenRoughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).a) : s = a, s = s.clamp(0.07, 1);
    } else if (n === pe.ANISOTROPY)
      if (i.anisotropyMap && i.anisotropyMap.isTexture === !0) {
        const a = this.getTexture(n);
        s = A1(_h.x, _h.y, _h.y.negate(), _h.x).mul(a.rg.mul(2).sub(He(1)).normalize().mul(a.b));
      } else
        s = _h;
    else if (n === pe.IRIDESCENCE_THICKNESS) {
      const a = bi("1", "float", i.iridescenceThicknessRange);
      if (i.iridescenceThicknessMap) {
        const o = bi("0", "float", i.iridescenceThicknessRange);
        s = a.sub(o).mul(this.getTexture(n).g).add(o);
      } else
        s = a;
    } else if (n === pe.TRANSMISSION) {
      const a = this.getFloat(n);
      i.transmissionMap ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === pe.THICKNESS) {
      const a = this.getFloat(n);
      i.thicknessMap ? s = a.mul(this.getTexture(n).g) : s = a;
    } else if (n === pe.IOR)
      s = this.getFloat(n);
    else if (n === pe.LIGHT_MAP)
      s = this.getTexture(n).rgb.mul(this.getFloat("lightMapIntensity"));
    else if (n === pe.AO_MAP)
      s = this.getTexture(n).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
    else {
      const a = this.getNodeType(e);
      s = this.getCache(n, a);
    }
    return s;
  }
}
pe.ALPHA_TEST = "alphaTest";
pe.COLOR = "color";
pe.OPACITY = "opacity";
pe.SHININESS = "shininess";
pe.SPECULAR = "specular";
pe.SPECULAR_STRENGTH = "specularStrength";
pe.SPECULAR_INTENSITY = "specularIntensity";
pe.SPECULAR_COLOR = "specularColor";
pe.REFLECTIVITY = "reflectivity";
pe.ROUGHNESS = "roughness";
pe.METALNESS = "metalness";
pe.NORMAL = "normal";
pe.CLEARCOAT = "clearcoat";
pe.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
pe.CLEARCOAT_NORMAL = "clearcoatNormal";
pe.EMISSIVE = "emissive";
pe.ROTATION = "rotation";
pe.SHEEN = "sheen";
pe.SHEEN_ROUGHNESS = "sheenRoughness";
pe.ANISOTROPY = "anisotropy";
pe.IRIDESCENCE = "iridescence";
pe.IRIDESCENCE_IOR = "iridescenceIOR";
pe.IRIDESCENCE_THICKNESS = "iridescenceThickness";
pe.IOR = "ior";
pe.TRANSMISSION = "transmission";
pe.THICKNESS = "thickness";
pe.ATTENUATION_DISTANCE = "attenuationDistance";
pe.ATTENUATION_COLOR = "attenuationColor";
pe.LINE_SCALE = "scale";
pe.LINE_DASH_SIZE = "dashSize";
pe.LINE_GAP_SIZE = "gapSize";
pe.LINE_WIDTH = "linewidth";
pe.LINE_DASH_OFFSET = "dashOffset";
pe.POINT_WIDTH = "pointWidth";
pe.DISPERSION = "dispersion";
pe.LIGHT_MAP = "light";
pe.AO_MAP = "ao";
const p$ = /* @__PURE__ */ Ve(pe, pe.ALPHA_TEST), f$ = /* @__PURE__ */ Ve(pe, pe.COLOR), m$ = /* @__PURE__ */ Ve(pe, pe.SHININESS), g$ = /* @__PURE__ */ Ve(pe, pe.EMISSIVE), wI = /* @__PURE__ */ Ve(pe, pe.OPACITY), y$ = /* @__PURE__ */ Ve(pe, pe.SPECULAR), wM = /* @__PURE__ */ Ve(pe, pe.SPECULAR_INTENSITY), v$ = /* @__PURE__ */ Ve(pe, pe.SPECULAR_COLOR), um = /* @__PURE__ */ Ve(pe, pe.SPECULAR_STRENGTH), H0 = /* @__PURE__ */ Ve(pe, pe.REFLECTIVITY), b$ = /* @__PURE__ */ Ve(pe, pe.ROUGHNESS), x$ = /* @__PURE__ */ Ve(pe, pe.METALNESS), _$ = /* @__PURE__ */ Ve(pe, pe.NORMAL).context({ getUV: null }), T$ = /* @__PURE__ */ Ve(pe, pe.CLEARCOAT), S$ = /* @__PURE__ */ Ve(pe, pe.CLEARCOAT_ROUGHNESS), w$ = /* @__PURE__ */ Ve(pe, pe.CLEARCOAT_NORMAL).context({ getUV: null }), E$ = /* @__PURE__ */ Ve(pe, pe.ROTATION), M$ = /* @__PURE__ */ Ve(pe, pe.SHEEN), A$ = /* @__PURE__ */ Ve(pe, pe.SHEEN_ROUGHNESS), C$ = /* @__PURE__ */ Ve(pe, pe.ANISOTROPY), R$ = /* @__PURE__ */ Ve(pe, pe.IRIDESCENCE), N$ = /* @__PURE__ */ Ve(pe, pe.IRIDESCENCE_IOR), P$ = /* @__PURE__ */ Ve(pe, pe.IRIDESCENCE_THICKNESS), I$ = /* @__PURE__ */ Ve(pe, pe.TRANSMISSION), O$ = /* @__PURE__ */ Ve(pe, pe.THICKNESS), D$ = /* @__PURE__ */ Ve(pe, pe.IOR), L$ = /* @__PURE__ */ Ve(pe, pe.ATTENUATION_DISTANCE), k$ = /* @__PURE__ */ Ve(pe, pe.ATTENUATION_COLOR), U$ = /* @__PURE__ */ Ve(pe, pe.LINE_SCALE), F$ = /* @__PURE__ */ Ve(pe, pe.LINE_DASH_SIZE), B$ = /* @__PURE__ */ Ve(pe, pe.LINE_GAP_SIZE);
pe.LINE_WIDTH;
pe.LINE_DASH_OFFSET;
pe.POINT_WIDTH;
const z$ = /* @__PURE__ */ Ve(pe, pe.DISPERSION), EI = /* @__PURE__ */ Ve(pe, pe.LIGHT_MAP), j$ = /* @__PURE__ */ Ve(pe, pe.AO_MAP), _h = /* @__PURE__ */ _t(new Vt()).onReference(function(r) {
  return r.material;
}).onRenderUpdate(function({ material: r }) {
  this.value.set(r.anisotropy * Math.cos(r.anisotropyRotation), r.anisotropy * Math.sin(r.anisotropyRotation));
});
class V$ extends zi {
  static get type() {
    return "ModelViewProjectionNode";
  }
  constructor(e = null) {
    super("vec4"), this.positionNode = e;
  }
  setup(e) {
    if (e.shaderStage === "fragment")
      return Ea(e.context.mvp);
    const i = this.positionNode || nr, n = e.renderer.nodes.modelViewMatrix || zg;
    return $m.mul(n).mul(i);
  }
}
const Cx = /* @__PURE__ */ Ae(V$);
class Ai extends Mt {
  static get type() {
    return "IndexNode";
  }
  constructor(e) {
    super("uint"), this.scope = e, this.isInstanceIndexNode = !0;
  }
  generate(e) {
    const i = this.getNodeType(e), n = this.scope;
    let s;
    if (n === Ai.VERTEX)
      s = e.getVertexIndex();
    else if (n === Ai.INSTANCE)
      s = e.getInstanceIndex();
    else if (n === Ai.DRAW)
      s = e.getDrawIndex();
    else if (n === Ai.INVOCATION_LOCAL)
      s = e.getInvocationLocalIndex();
    else if (n === Ai.INVOCATION_SUBGROUP)
      s = e.getInvocationSubgroupIndex();
    else if (n === Ai.SUBGROUP)
      s = e.getSubgroupIndex();
    else
      throw new Error("THREE.IndexNode: Unknown scope: " + n);
    let a;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? a = s : a = Ea(this).build(e, i), a;
  }
}
Ai.VERTEX = "vertex";
Ai.INSTANCE = "instance";
Ai.SUBGROUP = "subgroup";
Ai.INVOCATION_LOCAL = "invocationLocal";
Ai.INVOCATION_SUBGROUP = "invocationSubgroup";
Ai.DRAW = "draw";
const G$ = /* @__PURE__ */ Ve(Ai, Ai.VERTEX), z1 = /* @__PURE__ */ Ve(Ai, Ai.INSTANCE);
Ai.SUBGROUP;
Ai.INVOCATION_SUBGROUP;
Ai.INVOCATION_LOCAL;
const H$ = /* @__PURE__ */ Ve(Ai, Ai.DRAW);
class W$ extends Mt {
  static get type() {
    return "InstanceNode";
  }
  constructor(e) {
    super("void"), this.instanceMesh = e, this.instanceMatrixNode = null, this.instanceColorNode = null, this.updateType = Nt.FRAME, this.buffer = null, this.bufferColor = null;
  }
  setup(e) {
    let i = this.instanceMatrixNode, n = this.instanceColorNode;
    const s = this.instanceMesh;
    if (i === null) {
      const l = s.instanceMatrix;
      if (s.count <= 1e3)
        i = U1(l.array, "mat4", Math.max(s.count, 1)).element(z1);
      else {
        const u = new _W(l.array, 16, 1);
        this.buffer = u;
        const c = l.usage === ku ? bM : vM, h = [
          // F.Signature -> bufferAttribute( array, type, stride, offset )
          c(u, "vec4", 16, 0),
          c(u, "vec4", 16, 4),
          c(u, "vec4", 16, 8),
          c(u, "vec4", 16, 12)
        ];
        i = Ju(...h);
      }
      this.instanceMatrixNode = i;
    }
    const a = s.instanceColor;
    if (a && n === null) {
      const l = new oW(a.array, 3), u = a.usage === ku ? bM : vM;
      this.bufferColor = l, n = ye(u(l, "vec3", 3, 0)), this.instanceColorNode = n;
    }
    const o = i.mul(nr).xyz;
    if (nr.assign(o), e.hasGeometryAttribute("normal")) {
      const l = XX(_s, i);
      _s.assign(l);
    }
    this.instanceColorNode !== null && Hm("vec3", "vInstanceColor").assign(this.instanceColorNode);
  }
  update() {
    this.instanceMesh.instanceMatrix.usage !== ku && this.buffer != null && this.instanceMesh.instanceMatrix.version !== this.buffer.version && (this.buffer.version = this.instanceMesh.instanceMatrix.version), this.instanceMesh.instanceColor && this.instanceMesh.instanceColor.usage !== ku && this.bufferColor != null && this.instanceMesh.instanceColor.version !== this.bufferColor.version && (this.bufferColor.version = this.instanceMesh.instanceColor.version);
  }
}
const q$ = /* @__PURE__ */ Ae(W$);
class X$ extends Mt {
  static get type() {
    return "BatchNode";
  }
  constructor(e) {
    super("void"), this.batchMesh = e, this.batchingIdNode = null;
  }
  setup(e) {
    this.batchingIdNode === null && (e.getDrawIndex() === null ? this.batchingIdNode = z1 : this.batchingIdNode = H$);
    const i = Fe(([f]) => {
      const m = rd(Un(this.batchMesh._indirectTexture), 0), y = Mi(f).modInt(Mi(m)), v = Mi(f).div(Mi(m));
      return Un(this.batchMesh._indirectTexture, Ys(y, v)).x;
    }).setLayout({
      name: "getIndirectIndex",
      type: "uint",
      inputs: [
        { name: "id", type: "int" }
      ]
    })(Mi(this.batchingIdNode)), n = this.batchMesh._matricesTexture, s = rd(Un(n), 0), a = be(i).mul(4).toInt().toVar(), o = a.modInt(s), l = a.div(Mi(s)), u = Ju(
      Un(n, Ys(o, l)),
      Un(n, Ys(o.add(1), l)),
      Un(n, Ys(o.add(2), l)),
      Un(n, Ys(o.add(3), l))
    ), c = this.batchMesh._colorsTexture;
    if (c !== null) {
      const f = Fe(([m]) => {
        const y = rd(Un(c), 0).x, v = m, g = v.modInt(y), _ = v.div(y);
        return Un(c, Ys(g, _)).rgb;
      }).setLayout({
        name: "getBatchingColor",
        type: "vec3",
        inputs: [
          { name: "id", type: "int" }
        ]
      })(i);
      Hm("vec3", "vBatchColor").assign(f);
    }
    const h = Cr(u);
    nr.assign(u.mul(nr));
    const d = _s.div(ye(h[0].dot(h[0]), h[1].dot(h[1]), h[2].dot(h[2]))), p = h.mul(d).xyz;
    _s.assign(p), e.hasGeometryAttribute("tangent") && B1.mulAssign(h);
  }
}
const $$ = /* @__PURE__ */ Ae(X$), EM = /* @__PURE__ */ new WeakMap();
class Y$ extends Mt {
  static get type() {
    return "SkinningNode";
  }
  constructor(e, i = !1) {
    super("void"), this.skinnedMesh = e, this.useReference = i, this.updateType = Nt.OBJECT, this.skinIndexNode = _a("skinIndex", "uvec4"), this.skinWeightNode = _a("skinWeight", "vec4");
    let n, s, a;
    i ? (n = bi("bindMatrix", "mat4"), s = bi("bindMatrixInverse", "mat4"), a = _M("skeleton.boneMatrices", "mat4", e.skeleton.bones.length)) : (n = _t(e.bindMatrix, "mat4"), s = _t(e.bindMatrixInverse, "mat4"), a = U1(e.skeleton.boneMatrices, "mat4", e.skeleton.bones.length)), this.bindMatrixNode = n, this.bindMatrixInverseNode = s, this.boneMatricesNode = a, this.previousBoneMatricesNode = null;
  }
  getSkinnedPosition(e = this.boneMatricesNode, i = nr) {
    const { skinIndexNode: n, skinWeightNode: s, bindMatrixNode: a, bindMatrixInverseNode: o } = this, l = e.element(n.x), u = e.element(n.y), c = e.element(n.z), h = e.element(n.w), d = a.mul(i), p = Rr(
      l.mul(s.x).mul(d),
      u.mul(s.y).mul(d),
      c.mul(s.z).mul(d),
      h.mul(s.w).mul(d)
    );
    return o.mul(p).xyz;
  }
  getSkinnedNormal(e = this.boneMatricesNode, i = _s) {
    const { skinIndexNode: n, skinWeightNode: s, bindMatrixNode: a, bindMatrixInverseNode: o } = this, l = e.element(n.x), u = e.element(n.y), c = e.element(n.z), h = e.element(n.w);
    let d = Rr(
      s.x.mul(l),
      s.y.mul(u),
      s.z.mul(c),
      s.w.mul(h)
    );
    return d = o.mul(d).mul(a), d.transformDirection(i).xyz;
  }
  getPreviousSkinnedPosition(e) {
    const i = e.object;
    return this.previousBoneMatricesNode === null && (i.skeleton.previousBoneMatrices = new Float32Array(i.skeleton.boneMatrices), this.previousBoneMatricesNode = _M("skeleton.previousBoneMatrices", "mat4", i.skeleton.bones.length)), this.getSkinnedPosition(this.previousBoneMatricesNode, xM);
  }
  needsPreviousBoneMatrices(e) {
    const i = e.renderer.getMRT();
    return i && i.has("velocity");
  }
  setup(e) {
    this.needsPreviousBoneMatrices(e) && xM.assign(this.getPreviousSkinnedPosition(e));
    const i = this.getSkinnedPosition();
    if (nr.assign(i), e.hasGeometryAttribute("normal")) {
      const n = this.getSkinnedNormal();
      _s.assign(n), e.hasGeometryAttribute("tangent") && B1.assign(n);
    }
  }
  generate(e, i) {
    if (i !== "void")
      return nr.build(e, i);
  }
  update(e) {
    const i = (this.useReference ? e.object : this.skinnedMesh).skeleton;
    EM.get(i) !== e.frameId && (EM.set(i, e.frameId), this.previousBoneMatricesNode !== null && i.previousBoneMatrices.set(i.boneMatrices), i.update());
  }
}
const K$ = (r) => De(new Y$(r, !0));
class Z$ extends Mt {
  static get type() {
    return "LoopNode";
  }
  constructor(e = []) {
    super(), this.params = e;
  }
  getVarName(e) {
    return String.fromCharCode(105 + e);
  }
  getProperties(e) {
    const i = e.getNodeProperties(this);
    if (i.stackNode !== void 0) return i;
    const n = {};
    for (let a = 0, o = this.params.length - 1; a < o; a++) {
      const l = this.params[a], u = l.isNode !== !0 && l.name || this.getVarName(a), c = l.isNode !== !0 && l.type || "int";
      n[u] = wd(u, c);
    }
    const s = e.addStack();
    return i.returnsNode = this.params[this.params.length - 1](n, s, e), i.stackNode = s, e.removeStack(), i;
  }
  getNodeType(e) {
    const { returnsNode: i } = this.getProperties(e);
    return i ? i.getNodeType(e) : "void";
  }
  setup(e) {
    this.getProperties(e);
  }
  generate(e) {
    const i = this.getProperties(e), n = this.params, s = i.stackNode;
    for (let l = 0, u = n.length - 1; l < u; l++) {
      const c = n[l];
      let h = null, d = null, p = null, f = null, m = null, y = null;
      c.isNode ? (f = "int", p = this.getVarName(l), h = "0", d = c.build(e, f), m = "<") : (f = c.type || "int", p = c.name || this.getVarName(l), h = c.start, d = c.end, m = c.condition, y = c.update, typeof h == "number" ? h = e.generateConst(f, h) : h && h.isNode && (h = h.build(e, f)), typeof d == "number" ? d = e.generateConst(f, d) : d && d.isNode && (d = d.build(e, f)), h !== void 0 && d === void 0 ? (h = h + " - 1", d = "0", m = ">=") : d !== void 0 && h === void 0 && (h = "0", m = "<"), m === void 0 && (Number(h) > Number(d) ? m = ">=" : m = "<"));
      const v = { start: h, end: d }, g = v.start, _ = v.end;
      let x = "", b = "", T = "";
      y || (f === "int" || f === "uint" ? m.includes("<") ? y = "++" : y = "--" : m.includes("<") ? y = "+= 1." : y = "-= 1."), x += e.getVar(f, p) + " = " + g, b += p + " " + m + " " + _, T += p + " " + y;
      const S = `for ( ${x}; ${b}; ${T} )`;
      e.addFlowCode((l === 0 ? `
` : "") + e.tab + S + ` {

`).addFlowTab();
    }
    const a = s.build(e, "void"), o = i.returnsNode ? i.returnsNode.build(e) : "";
    e.removeFlowTab().addFlowCode(`
` + e.tab + a);
    for (let l = 0, u = this.params.length - 1; l < u; l++)
      e.addFlowCode((l === 0 ? "" : e.tab) + `}

`).removeFlowTab();
    return e.addFlowTab(), o;
  }
}
const ps = (...r) => De(new Z$(Qu(r, "int"))).append(), Q$ = () => wd("break").append(), W0 = /* @__PURE__ */ new WeakMap(), en = /* @__PURE__ */ new Yt(), MM = /* @__PURE__ */ Fe(({ bufferMap: r, influence: e, stride: i, width: n, depth: s, offset: a }) => {
  const o = Mi(G$).mul(i).add(a), l = o.div(n), u = o.sub(l.mul(n));
  return Un(r, Ys(u, l)).depth(s).mul(e);
});
function J$(r) {
  const e = r.morphAttributes.position !== void 0, i = r.morphAttributes.normal !== void 0, n = r.morphAttributes.color !== void 0, s = r.morphAttributes.position || r.morphAttributes.normal || r.morphAttributes.color, a = s !== void 0 ? s.length : 0;
  let o = W0.get(r);
  if (o === void 0 || o.count !== a) {
    let l = function() {
      v.dispose(), W0.delete(r), r.removeEventListener("dispose", l);
    };
    o !== void 0 && o.texture.dispose();
    const u = r.morphAttributes.position || [], c = r.morphAttributes.normal || [], h = r.morphAttributes.color || [];
    let d = 0;
    e === !0 && (d = 1), i === !0 && (d = 2), n === !0 && (d = 3);
    let p = r.attributes.position.count * d, f = 1;
    const m = 4096;
    p > m && (f = Math.ceil(p / m), p = m);
    const y = new Float32Array(p * f * 4 * a), v = new j7(y, p, f, a);
    v.type = an, v.needsUpdate = !0;
    const g = d * 4;
    for (let _ = 0; _ < a; _++) {
      const x = u[_], b = c[_], T = h[_], S = p * f * 4 * _;
      for (let w = 0; w < x.count; w++) {
        const M = w * g;
        e === !0 && (en.fromBufferAttribute(x, w), y[S + M + 0] = en.x, y[S + M + 1] = en.y, y[S + M + 2] = en.z, y[S + M + 3] = 0), i === !0 && (en.fromBufferAttribute(b, w), y[S + M + 4] = en.x, y[S + M + 5] = en.y, y[S + M + 6] = en.z, y[S + M + 7] = 0), n === !0 && (en.fromBufferAttribute(T, w), y[S + M + 8] = en.x, y[S + M + 9] = en.y, y[S + M + 10] = en.z, y[S + M + 11] = T.itemSize === 4 ? en.w : 1);
      }
    }
    o = {
      count: a,
      texture: v,
      stride: d,
      size: new Vt(p, f)
    }, W0.set(r, o), r.addEventListener("dispose", l);
  }
  return o;
}
class eY extends Mt {
  static get type() {
    return "MorphNode";
  }
  constructor(e) {
    super("void"), this.mesh = e, this.morphBaseInfluence = _t(1), this.updateType = Nt.OBJECT;
  }
  setup(e) {
    const { geometry: i } = e, n = i.morphAttributes.position !== void 0, s = i.hasAttribute("normal") && i.morphAttributes.normal !== void 0, a = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color, o = a !== void 0 ? a.length : 0, { texture: l, stride: u, size: c } = J$(i);
    n === !0 && nr.mulAssign(this.morphBaseInfluence), s === !0 && _s.mulAssign(this.morphBaseInfluence);
    const h = Mi(c.width);
    ps(o, ({ i: d }) => {
      const p = be(0).toVar();
      this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0 ? p.assign(Un(this.mesh.morphTexture, Ys(Mi(d).add(1), Mi(z1))).r) : p.assign(bi("morphTargetInfluences", "float").element(d).toVar()), n === !0 && nr.addAssign(MM({
        bufferMap: l,
        influence: p,
        stride: u,
        width: h,
        depth: d,
        offset: Mi(0)
      })), s === !0 && _s.addAssign(MM({
        bufferMap: l,
        influence: p,
        stride: u,
        width: h,
        depth: d,
        offset: Mi(1)
      }));
    });
  }
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative ? e.value = 1 : e.value = 1 - this.mesh.morphTargetInfluences.reduce((i, n) => i + n, 0);
  }
}
const tY = /* @__PURE__ */ Ae(eY);
class Hc extends Mt {
  static get type() {
    return "LightingNode";
  }
  constructor() {
    super("vec3"), this.isLightingNode = !0;
  }
  generate() {
    console.warn("Abstract function.");
  }
}
class iY extends Hc {
  static get type() {
    return "AONode";
  }
  constructor(e = null) {
    super(), this.aoNode = e;
  }
  setup(e) {
    e.context.ambientOcclusion.mulAssign(this.aoNode);
  }
}
class rY extends hI {
  static get type() {
    return "LightingContextNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e), this.lightingModel = i, this.backdropNode = n, this.backdropAlphaNode = s, this._value = null;
  }
  getContext() {
    const { backdropNode: e, backdropAlphaNode: i } = this, n = ye().toVar("directDiffuse"), s = ye().toVar("directSpecular"), a = ye().toVar("indirectDiffuse"), o = ye().toVar("indirectSpecular"), l = {
      directDiffuse: n,
      directSpecular: s,
      indirectDiffuse: a,
      indirectSpecular: o
    };
    return {
      radiance: ye().toVar("radiance"),
      irradiance: ye().toVar("irradiance"),
      iblIrradiance: ye().toVar("iblIrradiance"),
      ambientOcclusion: be(1).toVar("ambientOcclusion"),
      reflectedLight: l,
      backdrop: e,
      backdropAlpha: i
    };
  }
  setup(e) {
    return this.value = this._value || (this._value = this.getContext()), this.value.lightingModel = this.lightingModel || e.context.lightingModel, super.setup(e);
  }
}
const nY = /* @__PURE__ */ Ae(rY);
class sY extends Hc {
  static get type() {
    return "IrradianceNode";
  }
  constructor(e) {
    super(), this.node = e;
  }
  setup(e) {
    e.context.irradiance.addAssign(this.node);
  }
}
let Th, Sh;
class ki extends Mt {
  static get type() {
    return "ScreenNode";
  }
  constructor(e) {
    super(), this.scope = e, this.isViewportNode = !0;
  }
  getNodeType() {
    return this.scope === ki.VIEWPORT ? "vec4" : "vec2";
  }
  getUpdateType() {
    let e = Nt.NONE;
    return (this.scope === ki.SIZE || this.scope === ki.VIEWPORT) && (e = Nt.RENDER), this.updateType = e, e;
  }
  update({ renderer: e }) {
    const i = e.getRenderTarget();
    this.scope === ki.VIEWPORT ? i !== null ? Sh.copy(i.viewport) : (e.getViewport(Sh), Sh.multiplyScalar(e.getPixelRatio())) : i !== null ? (Th.width = i.width, Th.height = i.height) : e.getDrawingBufferSize(Th);
  }
  setup() {
    const e = this.scope;
    let i = null;
    return e === ki.SIZE ? i = _t(Th || (Th = new Vt())) : e === ki.VIEWPORT ? i = _t(Sh || (Sh = new Yt())) : i = He(j1.div(Rx)), i;
  }
  generate(e) {
    if (this.scope === ki.COORDINATE) {
      let i = e.getFragCoord();
      if (e.isFlipY()) {
        const n = e.getNodeProperties(Rx).outputNode.build(e);
        i = `${e.getType("vec2")}( ${i}.x, ${n}.y - ${i}.y )`;
      }
      return i;
    }
    return super.generate(e);
  }
}
ki.COORDINATE = "coordinate";
ki.VIEWPORT = "viewport";
ki.SIZE = "size";
ki.UV = "uv";
const Ad = /* @__PURE__ */ Ve(ki, ki.UV), Rx = /* @__PURE__ */ Ve(ki, ki.SIZE), j1 = /* @__PURE__ */ Ve(ki, ki.COORDINATE), MI = /* @__PURE__ */ Ve(ki, ki.VIEWPORT);
MI.zw;
MI.xy;
const wh = /* @__PURE__ */ new Vt();
class AI extends rp {
  static get type() {
    return "ViewportTextureNode";
  }
  constructor(e = Ad, i = null, n = null) {
    n === null && (n = new cW(), n.minFilter = da), super(n, e, i), this.generateMipmaps = !1, this.isOutputTextureNode = !0, this.updateBeforeType = Nt.FRAME;
  }
  updateBefore(e) {
    const i = e.renderer;
    i.getDrawingBufferSize(wh);
    const n = this.value;
    (n.image.width !== wh.width || n.image.height !== wh.height) && (n.image.width = wh.width, n.image.height = wh.height, n.needsUpdate = !0);
    const s = n.generateMipmaps;
    n.generateMipmaps = this.generateMipmaps, i.copyFramebufferToTexture(n), n.generateMipmaps = s;
  }
  clone() {
    const e = new this.constructor(this.uvNode, this.levelNode, this.value);
    return e.generateMipmaps = this.generateMipmaps, e;
  }
}
const CI = /* @__PURE__ */ Ae(AI, null, null, { generateMipmaps: !0 });
let q0 = null;
class aY extends AI {
  static get type() {
    return "ViewportDepthTextureNode";
  }
  constructor(e = Ad, i = null) {
    q0 === null && (q0 = new Vc()), super(e, i, q0);
  }
}
const oY = /* @__PURE__ */ Ae(aY);
class Fr extends Mt {
  static get type() {
    return "ViewportDepthNode";
  }
  constructor(e, i = null) {
    super("float"), this.scope = e, this.valueNode = i, this.isViewportDepthNode = !0;
  }
  generate(e) {
    const { scope: i } = this;
    return i === Fr.DEPTH_BASE ? e.getFragDepth() : super.generate(e);
  }
  setup({ camera: e }) {
    const { scope: i } = this, n = this.valueNode;
    let s = null;
    if (i === Fr.DEPTH_BASE)
      n !== null && (s = PI().assign(n));
    else if (i === Fr.DEPTH)
      e.isPerspectiveCamera ? s = lY(ir.z, Ko, Zo) : s = nd(ir.z, Ko, Zo);
    else if (i === Fr.LINEAR_DEPTH)
      if (n !== null)
        if (e.isPerspectiveCamera) {
          const a = RI(n, Ko, Zo);
          s = nd(a, Ko, Zo);
        } else
          s = n;
      else
        s = nd(ir.z, Ko, Zo);
    return s;
  }
}
Fr.DEPTH_BASE = "depthBase";
Fr.DEPTH = "depth";
Fr.LINEAR_DEPTH = "linearDepth";
const nd = (r, e, i) => r.add(e).div(e.sub(i)), lY = (r, e, i) => e.add(r).mul(i).div(i.sub(e).mul(r)), RI = (r, e, i) => e.mul(i).div(i.sub(e).mul(r).sub(i)), NI = (r, e, i) => {
  e = e.max(1e-6).toVar();
  const n = ya(r.div(e).add(1)), s = ya(i.div(e).add(1));
  return n.div(s);
}, PI = /* @__PURE__ */ Ae(Fr, Fr.DEPTH_BASE), II = /* @__PURE__ */ Ve(Fr, Fr.DEPTH);
Fr.LINEAR_DEPTH;
oY();
II.assign = (r) => PI(r);
class xo extends Mt {
  static get type() {
    return "ClippingNode";
  }
  constructor(e = xo.DEFAULT) {
    super(), this.scope = e;
  }
  setup(e) {
    super.setup(e);
    const i = e.clippingContext, { localClipIntersection: n, localClippingCount: s, globalClippingCount: a } = i, o = a + s, l = n ? o - s : o;
    return this.scope === xo.ALPHA_TO_COVERAGE ? this.setupAlphaToCoverage(i.planes, o, l) : this.setupDefault(i.planes, o, l);
  }
  setupAlphaToCoverage(e, i, n) {
    return Fe(() => {
      const s = Md(e), a = Ru("float", "distanceToPlane"), o = Ru("float", "distanceToGradient"), l = Ru("float", "clipOpacity");
      l.assign(1);
      let u;
      if (ps(n, ({ i: c }) => {
        u = s.element(c), a.assign(ir.dot(u.xyz).negate().add(u.w)), o.assign(a.fwidth().div(2)), l.mulAssign(Ml(o.negate(), o, a)), l.equal(0).discard();
      }), n < i) {
        const c = Ru("float", "unionclipOpacity");
        c.assign(1), ps({ start: n, end: i }, ({ i: h }) => {
          u = s.element(h), a.assign(ir.dot(u.xyz).negate().add(u.w)), o.assign(a.fwidth().div(2)), c.mulAssign(Ml(o.negate(), o, a).oneMinus());
        }), l.mulAssign(c.oneMinus());
      }
      qt.a.mulAssign(l), qt.a.equal(0).discard();
    })();
  }
  setupDefault(e, i, n) {
    return Fe(() => {
      const s = Md(e);
      let a;
      if (ps(n, ({ i: o }) => {
        a = s.element(o), ir.dot(a.xyz).greaterThan(a.w).discard();
      }), n < i) {
        const o = Ru("bool", "clipped");
        o.assign(!0), ps({ start: n, end: i }, ({ i: l }) => {
          a = s.element(l), o.assign(ir.dot(a.xyz).greaterThan(a.w).and(o));
        }), o.discard();
      }
    })();
  }
}
xo.ALPHA_TO_COVERAGE = "alphaToCoverage";
xo.DEFAULT = "default";
const uY = () => De(new xo()), cY = () => De(new xo(xo.ALPHA_TO_COVERAGE)), hY = 0.05, AM = /* @__PURE__ */ Fe(([r]) => To(Dt(1e4, Vn(Dt(17, r.x).add(Dt(0.1, r.y)))).mul(Rr(0.1, Gn(Vn(Dt(13, r.y).add(r.x))))))), CM = /* @__PURE__ */ Fe(([r]) => AM(He(AM(r.xy), r.z))), dY = /* @__PURE__ */ Fe(([r]) => {
  const e = Sn(
    fo(nI(r.xyz)),
    fo(sI(r.xyz))
  ).toVar("maxDeriv"), i = be(1).div(be(hY).mul(e)).toVar("pixScale"), n = He(
    _d(yl(ya(i))),
    _d(P1(ya(i)))
  ).toVar("pixScales"), s = He(
    CM(yl(n.x.mul(r.xyz))),
    CM(yl(n.y.mul(r.xyz)))
  ).toVar("alpha"), a = To(ya(i)).toVar("lerpFactor"), o = Rr(Dt(a.oneMinus(), s.x), Dt(a, s.y)).toVar("x"), l = Sd(a, a.oneMinus()).toVar("a"), u = ye(
    o.mul(o).div(Dt(2, l).mul(sn(1, l))),
    o.sub(Dt(0.5, l)).div(sn(1, l)),
    sn(1, sn(1, o).mul(sn(1, o)).div(Dt(2, l).mul(sn(1, l))))
  ).toVar("cases"), c = o.lessThan(l.oneMinus()).select(o.lessThan(l).select(u.x, u.y), u.z);
  return xa(c, 1e-6, 1);
});
class Bi extends Gr {
  static get type() {
    return "NodeMaterial";
  }
  constructor() {
    super(), this.isNodeMaterial = !0, this.type = this.constructor.type, this.forceSinglePass = !1, this.fog = !0, this.lights = !1, this.lightsNode = null, this.envNode = null, this.aoNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.positionNode = null, this.geometryNode = null, this.depthNode = null, this.shadowNode = null, this.shadowPositionNode = null, this.outputNode = null, this.mrtNode = null, this.fragmentNode = null, this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + UP(this);
  }
  build(e) {
    this.setup(e);
  }
  setupObserver(e) {
    return new SW(e);
  }
  setup(e) {
    e.context.setupNormal = () => this.setupNormal(e), e.addStack(), e.stack.outputNode = this.vertexNode || this.setupPosition(e), this.geometryNode !== null && (e.stack.outputNode = e.stack.outputNode.bypass(this.geometryNode)), e.addFlow("vertex", e.removeStack()), e.addStack();
    let i;
    const n = this.setupClipping(e);
    if (this.depthWrite === !0 && this.setupDepth(e), this.fragmentNode === null) {
      this.setupDiffuseColor(e), this.setupVariants(e);
      const s = this.setupLighting(e);
      n !== null && e.stack.add(n);
      const a = xt(s, qt.a).max(0);
      if (i = this.setupOutput(e, a), oq.assign(i), this.outputNode !== null && (i = this.outputNode), e.renderer.getRenderTarget() !== null) {
        const o = e.renderer.getMRT(), l = this.mrtNode;
        o !== null ? (i = o, l !== null && (i = o.merge(l))) : l !== null && (i = l);
      }
    } else {
      let s = this.fragmentNode;
      s.isOutputStructNode !== !0 && (s = xt(s)), i = this.setupOutput(e, s);
    }
    e.stack.outputNode = i, e.addFlow("fragment", e.removeStack()), e.monitor = this.setupObserver(e);
  }
  setupClipping(e) {
    if (e.clippingContext === null) return null;
    const { globalClippingCount: i, localClippingCount: n } = e.clippingContext;
    let s = null;
    if (i || n) {
      const a = e.renderer.samples;
      this.alphaToCoverage && a > 1 ? s = cY() : e.stack.add(uY());
    }
    return s;
  }
  setupDepth(e) {
    const { renderer: i, camera: n } = e;
    let s = this.depthNode;
    if (s === null) {
      const a = i.getMRT();
      a && a.has("depth") ? s = a.get("depth") : i.logarithmicDepthBuffer === !0 && (n.isPerspectiveCamera ? s = NI(Cx().w, Ko, Zo) : s = nd(ir.z, Ko, Zo));
    }
    s !== null && II.assign(s).append();
  }
  setupPosition(e) {
    const { object: i } = e, n = i.geometry;
    if (e.addStack(), (n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color) && tY(i).append(), i.isSkinnedMesh === !0 && K$(i).append(), this.displacementMap) {
      const a = eo("displacementMap", "texture"), o = eo("displacementScale", "float"), l = eo("displacementBias", "float");
      nr.addAssign(_s.normalize().mul(a.x.mul(o).add(l)));
    }
    i.isBatchedMesh && $$(i).append(), i.instanceMatrix && i.instanceMatrix.isInstancedBufferAttribute === !0 && q$(i).append(), this.positionNode !== null && nr.assign(this.positionNode);
    const s = Cx();
    return e.context.vertex = e.removeStack(), e.context.mvp = s, s;
  }
  setupDiffuseColor({ object: e, geometry: i }) {
    let n = this.colorNode ? xt(this.colorNode) : f$;
    this.vertexColors === !0 && i.hasAttribute("color") && (n = xt(n.xyz.mul(_a("color", "vec3")), n.a)), e.instanceColor && (n = Hm("vec3", "vInstanceColor").mul(n)), e.isBatchedMesh && e._colorsTexture && (n = Hm("vec3", "vBatchColor").mul(n)), qt.assign(n);
    const s = this.opacityNode ? be(this.opacityNode) : wI;
    if (qt.a.assign(qt.a.mul(s)), this.alphaTestNode !== null || this.alphaTest > 0) {
      const a = this.alphaTestNode !== null ? be(this.alphaTestNode) : p$;
      qt.a.lessThanEqual(a).discard();
    }
    this.alphaHash === !0 && qt.a.lessThan(dY(nr)).discard(), this.transparent === !1 && this.blending === co && this.alphaToCoverage === !1 && qt.a.assign(1);
  }
  setupVariants() {
  }
  setupOutgoingLight() {
    return this.lights === !0 ? ye(0) : qt.rgb;
  }
  setupNormal() {
    return this.normalNode ? ye(this.normalNode) : _$;
  }
  setupEnvironment() {
    let e = null;
    return this.envNode ? e = this.envNode : this.envMap && (e = this.envMap.isCubeTexture ? eo("envMap", "cubeTexture") : eo("envMap", "texture")), e;
  }
  setupLightMap(e) {
    let i = null;
    return e.material.lightMap && (i = new sY(EI)), i;
  }
  setupLights(e) {
    const i = [], n = this.setupEnvironment(e);
    n && n.isLightingNode && i.push(n);
    const s = this.setupLightMap(e);
    if (s && s.isLightingNode && i.push(s), this.aoNode !== null || e.material.aoMap) {
      const o = this.aoNode !== null ? this.aoNode : j$;
      i.push(new iY(o));
    }
    let a = this.lightsNode || e.lightsNode;
    return i.length > 0 && (a = e.renderer.lighting.createNode([...a.getLights(), ...i])), a;
  }
  setupLightingModel() {
  }
  setupLighting(e) {
    const { material: i } = e, { backdropNode: n, backdropAlphaNode: s, emissiveNode: a } = this, o = this.lights === !0 || this.lightsNode !== null ? this.setupLights(e) : null;
    let l = this.setupOutgoingLight(e);
    if (o && o.getScope().hasLights) {
      const u = this.setupLightingModel(e);
      l = nY(o, u, n, s);
    } else n !== null && (l = ye(s !== null ? li(l, n, s) : n));
    return (a && a.isNode === !0 || i.emissive && i.emissive.isColor === !0) && (gM.assign(ye(a || g$)), l = l.add(gM)), l;
  }
  setupOutput(e, i) {
    if (this.fog === !0) {
      const n = e.fogNode;
      n && (i = xt(n.mix(i.rgb, n.colorNode), i.a));
    }
    return i;
  }
  setDefaultValues(e) {
    for (const n in e) {
      const s = e[n];
      this[n] === void 0 && (this[n] = s, s && s.clone && (this[n] = s.clone()));
    }
    const i = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const n in i)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, n) === void 0 && i[n].get !== void 0 && Object.defineProperty(this.constructor.prototype, n, i[n]);
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    i && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    const n = Gr.prototype.toJSON.call(this, e), s = jm(this);
    n.inputNodes = {};
    for (const { property: o, childNode: l } of s)
      n.inputNodes[o] = l.toJSON(e).uuid;
    function a(o) {
      const l = [];
      for (const u in o) {
        const c = o[u];
        delete c.metadata, l.push(c);
      }
      return l;
    }
    if (i) {
      const o = a(e.textures), l = a(e.images), u = a(e.nodes);
      o.length > 0 && (n.textures = o), l.length > 0 && (n.images = l), u.length > 0 && (n.nodes = u);
    }
    return n;
  }
  copy(e) {
    return this.lightsNode = e.lightsNode, this.envNode = e.envNode, this.colorNode = e.colorNode, this.normalNode = e.normalNode, this.opacityNode = e.opacityNode, this.backdropNode = e.backdropNode, this.backdropAlphaNode = e.backdropAlphaNode, this.alphaTestNode = e.alphaTestNode, this.positionNode = e.positionNode, this.geometryNode = e.geometryNode, this.depthNode = e.depthNode, this.shadowNode = e.shadowNode, this.shadowPositionNode = e.shadowPositionNode, this.outputNode = e.outputNode, this.mrtNode = e.mrtNode, this.fragmentNode = e.fragmentNode, this.vertexNode = e.vertexNode, super.copy(e);
  }
}
const pY = /* @__PURE__ */ new v1();
class fY extends Bi {
  static get type() {
    return "LineBasicNodeMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicNodeMaterial = !0, this.lights = !1, this.setDefaultValues(pY), this.setValues(e);
  }
}
const mY = /* @__PURE__ */ new DP();
class gY extends Bi {
  static get type() {
    return "LineDashedNodeMaterial";
  }
  constructor(e) {
    super(), this.isLineDashedNodeMaterial = !0, this.lights = !1, this.setDefaultValues(mY), this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setValues(e);
  }
  setupVariants() {
    const e = this.offsetNode, i = this.dashScaleNode ? be(this.dashScaleNode) : U$, n = this.dashSizeNode ? be(this.dashSizeNode) : F$, s = this.dashSizeNode ? be(this.dashGapNode) : B$;
    G0.assign(n), yM.assign(s);
    const a = Ea(_a("lineDistance").mul(i));
    (e ? a.add(e) : a).mod(G0.add(yM)).greaterThan(G0).discard();
  }
}
const yY = (r) => De(r).mul(0.5).add(0.5), vY = /* @__PURE__ */ new PP();
class bY extends Bi {
  static get type() {
    return "MeshNormalNodeMaterial";
  }
  constructor(e) {
    super(), this.lights = !1, this.isMeshNormalNodeMaterial = !0, this.setDefaultValues(vY), this.setValues(e);
  }
  setupDiffuseColor() {
    const e = this.opacityNode ? be(this.opacityNode) : wI;
    qt.assign(xt(yY(Ui), e));
  }
}
class xY extends zi {
  static get type() {
    return "EquirectUVNode";
  }
  constructor(e = yI) {
    super("vec2"), this.dirNode = e;
  }
  setup() {
    const e = this.dirNode, i = e.z.atan2(e.x).mul(1 / (Math.PI * 2)).add(0.5), n = e.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return He(i, n);
  }
}
const OI = /* @__PURE__ */ Ae(xY);
class DI extends sW {
  constructor(e = 1, i = {}) {
    super(e, i), this.isCubeRenderTarget = !0;
  }
  fromEquirectangularTexture(e, i) {
    const n = i.minFilter, s = i.generateMipmaps;
    i.generateMipmaps = !0, this.texture.type = i.type, this.texture.colorSpace = i.colorSpace, this.texture.generateMipmaps = i.generateMipmaps, this.texture.minFilter = i.minFilter, this.texture.magFilter = i.magFilter;
    const a = new Jd(5, 5, 5), o = OI(yI), l = new Bi();
    l.colorNode = Ci(i, o, 0), l.side = Zn, l.blending = xc;
    const u = new El(a, l), c = new TP();
    c.add(u), i.minFilter === da && (i.minFilter = on);
    const h = new _P(1, 10, this), d = e.getMRT();
    return e.setMRT(null), h.update(e, c), e.setMRT(d), i.minFilter = n, i.currentGenerateMipmaps = s, u.geometry.dispose(), u.material.dispose(), this;
  }
}
const sd = /* @__PURE__ */ new WeakMap();
class _Y extends zi {
  static get type() {
    return "CubeMapNode";
  }
  constructor(e) {
    super("vec3"), this.envNode = e, this._cubeTexture = null, this._cubeTextureNode = Ed();
    const i = new g1();
    i.isRenderTargetTexture = !0, this._defaultTexture = i, this.updateBeforeType = Nt.RENDER;
  }
  updateBefore(e) {
    const { renderer: i, material: n } = e, s = this.envNode;
    if (s.isTextureNode || s.isMaterialReferenceNode) {
      const a = s.isTextureNode ? s.value : n[s.property];
      if (a && a.isTexture) {
        const o = a.mapping;
        if (o === $d || o === Yd) {
          if (sd.has(a)) {
            const l = sd.get(a);
            RM(l, a.mapping), this._cubeTexture = l;
          } else {
            const l = a.image;
            if (TY(l)) {
              const u = new DI(l.height);
              u.fromEquirectangularTexture(i, a), RM(u.texture, a.mapping), this._cubeTexture = u.texture, sd.set(a, u.texture), a.addEventListener("dispose", LI);
            } else
              this._cubeTexture = this._defaultTexture;
          }
          this._cubeTextureNode.value = this._cubeTexture;
        } else
          this._cubeTextureNode = this.envNode;
      }
    }
  }
  setup(e) {
    return this.updateBefore(e), this._cubeTextureNode;
  }
}
function TY(r) {
  return r == null ? !1 : r.height > 0;
}
function LI(r) {
  const e = r.target;
  e.removeEventListener("dispose", LI);
  const i = sd.get(e);
  i !== void 0 && (sd.delete(e), i.dispose());
}
function RM(r, e) {
  e === $d ? r.mapping = Tl : e === Yd && (r.mapping = _c);
}
const kI = /* @__PURE__ */ Ae(_Y);
class V1 extends Hc {
  static get type() {
    return "BasicEnvironmentNode";
  }
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    e.context.environment = kI(this.envNode);
  }
}
class SY extends Hc {
  static get type() {
    return "BasicLightMapNode";
  }
  constructor(e = null) {
    super(), this.lightMapNode = e;
  }
  setup(e) {
    const i = be(1 / Math.PI);
    e.context.irradianceLightMap = this.lightMapNode.mul(i);
  }
}
class Vg {
  start() {
  }
  finish() {
  }
  direct() {
  }
  directRectArea() {
  }
  indirect() {
  }
  ambientOcclusion() {
  }
}
class UI extends Vg {
  constructor() {
    super();
  }
  indirect(e, i, n) {
    const s = e.ambientOcclusion, a = e.reflectedLight, o = n.context.irradianceLightMap;
    a.indirectDiffuse.assign(xt(0)), o ? a.indirectDiffuse.addAssign(o) : a.indirectDiffuse.addAssign(xt(1, 1, 1, 0)), a.indirectDiffuse.mulAssign(s), a.indirectDiffuse.mulAssign(qt.rgb);
  }
  finish(e, i, n) {
    const s = n.material, a = e.outgoingLight, o = n.context.environment;
    if (o)
      switch (s.combine) {
        case Ig:
          a.rgb.assign(li(a.rgb, a.rgb.mul(o.rgb), um.mul(H0)));
          break;
        case j9:
          a.rgb.assign(li(a.rgb, o.rgb, um.mul(H0)));
          break;
        case V9:
          a.rgb.addAssign(o.rgb.mul(um.mul(H0)));
          break;
        default:
          console.warn("THREE.BasicLightingModel: Unsupported .combine value:", s.combine);
          break;
      }
  }
}
const wY = /* @__PURE__ */ new Og();
class EY extends Bi {
  static get type() {
    return "MeshBasicNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicNodeMaterial = !0, this.lights = !0, this.setDefaultValues(wY), this.setValues(e);
  }
  setupNormal() {
    return Jn;
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new V1(i) : null;
  }
  setupLightMap(e) {
    let i = null;
    return e.material.lightMap && (i = new SY(EI)), i;
  }
  setupOutgoingLight() {
    return qt.rgb;
  }
  setupLightingModel() {
    return new UI();
  }
}
const Cd = /* @__PURE__ */ Fe(({ f0: r, f90: e, dotVH: i }) => {
  const n = i.mul(-5.55473).sub(6.98316).mul(i).exp2();
  return r.mul(n.oneMinus()).add(e.mul(n));
}), Ec = /* @__PURE__ */ Fe((r) => r.diffuseColor.mul(1 / Math.PI)), MY = () => be(0.25), AY = /* @__PURE__ */ Fe(({ dotNH: r }) => Ex.mul(be(0.5)).add(1).mul(be(1 / Math.PI)).mul(r.pow(Ex))), CY = /* @__PURE__ */ Fe(({ lightDirection: r }) => {
  const e = r.add(vi).normalize(), i = Ui.dot(e).clamp(), n = vi.dot(e).clamp(), s = Cd({ f0: rn, f90: 1, dotVH: n }), a = MY(), o = AY({ dotNH: i });
  return s.mul(a).mul(o);
});
class FI extends UI {
  constructor(e = !0) {
    super(), this.specular = e;
  }
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }) {
    const s = Ui.dot(e).clamp().mul(i);
    n.directDiffuse.addAssign(s.mul(Ec({ diffuseColor: qt.rgb }))), this.specular === !0 && n.directSpecular.addAssign(s.mul(CY({ lightDirection: e })).mul(um));
  }
  indirect({ ambientOcclusion: e, irradiance: i, reflectedLight: n }) {
    n.indirectDiffuse.addAssign(i.mul(Ec({ diffuseColor: qt }))), n.indirectDiffuse.mulAssign(e);
  }
}
const RY = /* @__PURE__ */ new IP();
class NY extends Bi {
  static get type() {
    return "MeshLambertNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshLambertNodeMaterial = !0, this.lights = !0, this.setDefaultValues(RY), this.setValues(e);
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new V1(i) : null;
  }
  setupLightingModel() {
    return new FI(!1);
  }
}
const PY = /* @__PURE__ */ new RP();
class IY extends Bi {
  static get type() {
    return "MeshPhongNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhongNodeMaterial = !0, this.lights = !0, this.shininessNode = null, this.specularNode = null, this.setDefaultValues(PY), this.setValues(e);
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new V1(i) : null;
  }
  setupLightingModel() {
    return new FI();
  }
  setupVariants() {
    const e = (this.shininessNode ? be(this.shininessNode) : m$).max(1e-4);
    Ex.assign(e);
    const i = this.specularNode || y$;
    rn.assign(i);
  }
  copy(e) {
    return this.shininessNode = e.shininessNode, this.specularNode = e.specularNode, super.copy(e);
  }
}
const OY = /* @__PURE__ */ Fe((r) => {
  if (r.geometry.hasAttribute("normal") === !1)
    return be(0);
  const e = Jn.dFdx().abs().max(Jn.dFdy().abs());
  return e.x.max(e.y).max(e.z);
}), BI = /* @__PURE__ */ Fe((r) => {
  const { roughness: e } = r, i = OY();
  let n = e.max(0.0525);
  return n = n.add(i), n = n.min(1), n;
}), DY = /* @__PURE__ */ Fe(({ alpha: r, dotNL: e, dotNV: i }) => {
  const n = r.pow2(), s = e.mul(n.add(n.oneMinus().mul(i.pow2())).sqrt()), a = i.mul(n.add(n.oneMinus().mul(e.pow2())).sqrt());
  return bo(0.5, s.add(a).max(Rq));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
}), LY = /* @__PURE__ */ Fe(({ alphaT: r, alphaB: e, dotTV: i, dotBV: n, dotTL: s, dotBL: a, dotNV: o, dotNL: l }) => {
  const u = l.mul(ye(r.mul(i), e.mul(n), o).length()), c = o.mul(ye(r.mul(s), e.mul(a), l).length());
  return bo(0.5, u.add(c)).saturate();
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
}), kY = /* @__PURE__ */ Fe(({ alpha: r, dotNH: e }) => {
  const i = r.pow2(), n = e.pow2().mul(i.oneMinus()).oneMinus();
  return i.div(n.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), UY = /* @__PURE__ */ be(1 / Math.PI), FY = /* @__PURE__ */ Fe(({ alphaT: r, alphaB: e, dotNH: i, dotTH: n, dotBH: s }) => {
  const a = r.mul(e), o = ye(e.mul(n), r.mul(s), a.mul(i)), l = o.dot(o), u = a.div(l);
  return UY.mul(a.mul(u.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
}), NM = /* @__PURE__ */ Fe((r) => {
  const { lightDirection: e, f0: i, f90: n, roughness: s, f: a, USE_IRIDESCENCE: o, USE_ANISOTROPY: l } = r, u = r.normalView || Ui, c = s.pow2(), h = e.add(vi).normalize(), d = u.dot(e).clamp(), p = u.dot(vi).clamp(), f = u.dot(h).clamp(), m = vi.dot(h).clamp();
  let y = Cd({ f0: i, f90: n, dotVH: m }), v, g;
  if (mM(o) && (y = R1.mix(y, a)), mM(l)) {
    const _ = am.dot(e), x = am.dot(vi), b = am.dot(h), T = ec.dot(e), S = ec.dot(vi), w = ec.dot(h);
    v = LY({ alphaT: wx, alphaB: c, dotTV: x, dotBV: S, dotTL: _, dotBL: T, dotNV: p, dotNL: d }), g = FY({ alphaT: wx, alphaB: c, dotNH: f, dotTH: b, dotBH: w });
  } else
    v = DY({ alpha: c, dotNL: d, dotNV: p }), g = kY({ alpha: c, dotNH: f });
  return y.mul(v).mul(g);
}), zI = /* @__PURE__ */ Fe(({ roughness: r, dotNV: e }) => {
  const i = xt(-1, -0.0275, -0.572, 0.022), n = xt(1, 0.0425, 1.04, -0.04), s = r.mul(i).add(n), a = s.x.mul(s.x).min(e.mul(-9.28).exp2()).mul(s.x).add(s.y);
  return He(-1.04, 1.04).mul(a).add(s.zw);
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
}), jI = /* @__PURE__ */ Fe((r) => {
  const { dotNV: e, specularColor: i, specularF90: n, roughness: s } = r, a = zI({ dotNV: e, roughness: s });
  return i.mul(a.x).add(n.mul(a.y));
}), BY = /* @__PURE__ */ Fe(({ f: r, f90: e, dotVH: i }) => {
  const n = i.oneMinus().saturate(), s = n.mul(n), a = n.mul(s, s).clamp(0, 0.9999);
  return r.sub(ye(e).mul(a)).div(a.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
}), zY = /* @__PURE__ */ Fe(({ roughness: r, dotNH: e }) => {
  const i = r.pow2(), n = be(1).div(i), s = e.pow2().oneMinus().max(78125e-7);
  return be(2).add(n).mul(s.pow(n.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), jY = /* @__PURE__ */ Fe(({ dotNV: r, dotNL: e }) => be(1).div(be(4).mul(e.add(r).sub(e.mul(r))))).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
}), VY = /* @__PURE__ */ Fe(({ lightDirection: r }) => {
  const e = r.add(vi).normalize(), i = Ui.dot(r).clamp(), n = Ui.dot(vi).clamp(), s = Ui.dot(e).clamp(), a = zY({ roughness: C1, dotNH: s }), o = jY({ dotNV: n, dotNL: i });
  return Fu.mul(a).mul(o);
}), GY = /* @__PURE__ */ Fe(({ N: r, V: e, roughness: i }) => {
  const n = 78125e-7, s = r.dot(e).saturate(), a = He(i, s.oneMinus().sqrt());
  return a.assign(a.mul(0.984375).add(n)), a;
}).setLayout({
  name: "LTC_Uv",
  type: "vec2",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "roughness", type: "float" }
  ]
}), HY = /* @__PURE__ */ Fe(({ f: r }) => {
  const e = r.length();
  return Sn(e.mul(e).add(r.z).div(e.add(1)), 0);
}).setLayout({
  name: "LTC_ClippedSphereFormFactor",
  type: "float",
  inputs: [
    { name: "f", type: "vec3" }
  ]
}), ff = /* @__PURE__ */ Fe(({ v1: r, v2: e }) => {
  const i = r.dot(e), n = i.abs().toVar(), s = n.mul(0.0145206).add(0.4965155).mul(n).add(0.8543985).toVar(), a = n.add(4.1616724).mul(n).add(3.417594).toVar(), o = s.div(a), l = i.greaterThan(0).select(o, Sn(i.mul(i).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(o));
  return r.cross(e).mul(l);
}).setLayout({
  name: "LTC_EdgeVectorFormFactor",
  type: "vec3",
  inputs: [
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" }
  ]
}), PM = /* @__PURE__ */ Fe(({ N: r, V: e, P: i, mInv: n, p0: s, p1: a, p2: o, p3: l }) => {
  const u = a.sub(s).toVar(), c = l.sub(s).toVar(), h = u.cross(c), d = ye().toVar();
  return rr(h.dot(i.sub(s)).greaterThanEqual(0), () => {
    const p = e.sub(r.mul(e.dot(r))).normalize(), f = r.cross(p).negate(), m = n.mul(Cr(p, f, r).transpose()).toVar(), y = m.mul(s.sub(i)).normalize().toVar(), v = m.mul(a.sub(i)).normalize().toVar(), g = m.mul(o.sub(i)).normalize().toVar(), _ = m.mul(l.sub(i)).normalize().toVar(), x = ye(0).toVar();
    x.addAssign(ff({ v1: y, v2: v })), x.addAssign(ff({ v1: v, v2: g })), x.addAssign(ff({ v1: g, v2: _ })), x.addAssign(ff({ v1: _, v2: y })), d.assign(ye(HY({ f: x })));
  }), d;
}).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "P", type: "vec3" },
    { name: "mInv", type: "mat3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" }
  ]
}), Gg = 1 / 6, VI = (r) => Dt(Gg, Dt(r, Dt(r, r.negate().add(3)).sub(3)).add(1)), Nx = (r) => Dt(Gg, Dt(r, Dt(r, Dt(3, r).sub(6))).add(4)), GI = (r) => Dt(Gg, Dt(r, Dt(r, Dt(-3, r).add(3)).add(3)).add(1)), Px = (r) => Dt(Gg, Ug(r, 3)), IM = (r) => VI(r).add(Nx(r)), OM = (r) => GI(r).add(Px(r)), DM = (r) => Rr(-1, Nx(r).div(VI(r).add(Nx(r)))), LM = (r) => Rr(1, Px(r).div(GI(r).add(Px(r)))), kM = (r, e, i) => {
  const n = r.uvNode, s = Dt(n, e.zw).add(0.5), a = yl(s), o = To(s), l = IM(o.x), u = OM(o.x), c = DM(o.x), h = LM(o.x), d = DM(o.y), p = LM(o.y), f = He(a.x.add(c), a.y.add(d)).sub(0.5).mul(e.xy), m = He(a.x.add(h), a.y.add(d)).sub(0.5).mul(e.xy), y = He(a.x.add(c), a.y.add(p)).sub(0.5).mul(e.xy), v = He(a.x.add(h), a.y.add(p)).sub(0.5).mul(e.xy), g = IM(o.y).mul(Rr(l.mul(r.uv(f).level(i)), u.mul(r.uv(m).level(i)))), _ = OM(o.y).mul(Rr(l.mul(r.uv(y).level(i)), u.mul(r.uv(v).level(i))));
  return g.add(_);
}, WY = /* @__PURE__ */ Fe(([r, e = be(3)]) => {
  const i = He(r.size(Mi(e))), n = He(r.size(Mi(e.add(1)))), s = bo(1, i), a = bo(1, n), o = kM(r, xt(s, i), yl(e)), l = kM(r, xt(a, n), P1(e));
  return To(e).mix(o, l);
}), UM = /* @__PURE__ */ Fe(([r, e, i, n, s]) => {
  const a = ye(cI(e.negate(), Td(r), bo(1, n))), o = ye(
    fo(s[0].xyz),
    fo(s[1].xyz),
    fo(s[2].xyz)
  );
  return Td(a).mul(i.mul(o));
}).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" }
  ]
}), qY = /* @__PURE__ */ Fe(([r, e]) => r.mul(xa(e.mul(2).sub(2), 0, 1))).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" }
  ]
}), XY = /* @__PURE__ */ CI(), $Y = /* @__PURE__ */ CI(), FM = /* @__PURE__ */ Fe(([r, e, i], { material: n }) => {
  const s = (n.side == Zn ? XY : $Y).uv(r), a = ya(Rx.x).mul(qY(e, i));
  return WY(s, a);
}), BM = /* @__PURE__ */ Fe(([r, e, i]) => (rr(i.notEqual(0), () => {
  const n = iI(e).negate().div(i);
  return tI(n.negate().mul(r));
}), ye(1))).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" }
  ]
}), YY = /* @__PURE__ */ Fe(([r, e, i, n, s, a, o, l, u, c, h, d, p, f, m]) => {
  let y, v;
  if (m) {
    y = xt().toVar(), v = ye().toVar();
    const T = h.sub(1).mul(m.mul(0.025)), S = ye(h.sub(T), h, h.add(T));
    ps({ start: 0, end: 3 }, ({ i: w }) => {
      const M = S.element(w), E = UM(r, e, d, M, l), A = o.add(E), N = c.mul(u.mul(xt(A, 1))), U = He(N.xy.div(N.w)).toVar();
      U.addAssign(1), U.divAssign(2), U.assign(He(U.x, U.y.oneMinus()));
      const k = FM(U, i, M);
      y.element(w).assign(k.element(w)), y.a.addAssign(k.a), v.element(w).assign(n.element(w).mul(BM(fo(E), p, f).element(w)));
    }), y.a.divAssign(3);
  } else {
    const T = UM(r, e, d, h, l), S = o.add(T), w = c.mul(u.mul(xt(S, 1))), M = He(w.xy.div(w.w)).toVar();
    M.addAssign(1), M.divAssign(2), M.assign(He(M.x, M.y.oneMinus())), y = FM(M, i, h), v = n.mul(BM(fo(T), p, f));
  }
  const g = v.rgb.mul(y.rgb), _ = r.dot(e).clamp(), x = ye(jI({
    // n, v, specularColor, specularF90, roughness
    dotNV: _,
    specularColor: s,
    specularF90: a,
    roughness: i
  })), b = v.r.add(v.g, v.b).div(3);
  return xt(x.oneMinus().mul(g), y.a.oneMinus().mul(b).oneMinus());
}), KY = /* @__PURE__ */ Cr(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
), ZY = (r) => {
  const e = r.sqrt();
  return ye(1).add(e).div(ye(1).sub(e));
}, zM = (r, e) => r.sub(e).div(r.add(e)).pow2(), QY = (r, e) => {
  const i = r.mul(2 * Math.PI * 1e-9), n = ye(54856e-17, 44201e-17, 52481e-17), s = ye(1681e3, 1795300, 2208400), a = ye(43278e5, 93046e5, 66121e5), o = be(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(i.mul(2239900).add(e.x).cos()).mul(i.pow2().mul(-45282e5).exp());
  let l = n.mul(a.mul(2 * Math.PI).sqrt()).mul(s.mul(i).add(e).cos()).mul(i.pow2().negate().mul(a).exp());
  return l = ye(l.x.add(o), l.y, l.z).div(10685e-11), KY.mul(l);
}, JY = /* @__PURE__ */ Fe(({ outsideIOR: r, eta2: e, cosTheta1: i, thinFilmThickness: n, baseF0: s }) => {
  const a = li(r, e, Ml(0, 0.03, n)), o = r.div(a).pow2().mul(i.pow2().oneMinus()).oneMinus();
  rr(o.lessThan(0), () => ye(1));
  const l = o.sqrt(), u = zM(a, r), c = Cd({ f0: u, f90: 1, dotVH: i }), h = c.oneMinus(), d = a.lessThan(r).select(Math.PI, 0), p = be(Math.PI).sub(d), f = ZY(s.clamp(0, 0.9999)), m = zM(f, a.toVec3()), y = Cd({ f0: m, f90: 1, dotVH: l }), v = ye(
    f.x.lessThan(a).select(Math.PI, 0),
    f.y.lessThan(a).select(Math.PI, 0),
    f.z.lessThan(a).select(Math.PI, 0)
  ), g = a.mul(n, l, 2), _ = ye(p).add(v), x = c.mul(y).clamp(1e-5, 0.9999), b = x.sqrt(), T = h.pow2().mul(y).div(ye(1).sub(x)), S = c.add(T).toVar(), w = T.sub(h).toVar();
  return ps({ start: 1, end: 2, condition: "<=", name: "m" }, ({ m: M }) => {
    w.mulAssign(b);
    const E = QY(be(M).mul(g), be(M).mul(_)).mul(2);
    S.addAssign(w.mul(E));
  }), S.max(ye(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
}), eK = /* @__PURE__ */ Fe(({ normal: r, viewDir: e, roughness: i }) => {
  const n = r.dot(e).saturate(), s = i.pow2(), a = Ur(
    i.lessThan(0.25),
    be(-339.2).mul(s).add(be(161.4).mul(i)).sub(25.9),
    be(-8.48).mul(s).add(be(14.3).mul(i)).sub(9.95)
  ), o = Ur(
    i.lessThan(0.25),
    be(44).mul(s).sub(be(23.7).mul(i)).add(3.26),
    be(1.97).mul(s).sub(be(3.27).mul(i)).add(0.72)
  );
  return Ur(i.lessThan(0.25), 0, be(0.1).mul(i).sub(0.025)).add(a.mul(n).add(o).exp()).mul(1 / Math.PI).saturate();
}), X0 = ye(0.04), $0 = be(1);
class HI extends Vg {
  constructor(e = !1, i = !1, n = !1, s = !1, a = !1, o = !1) {
    super(), this.clearcoat = e, this.sheen = i, this.iridescence = n, this.anisotropy = s, this.transmission = a, this.dispersion = o, this.clearcoatRadiance = null, this.clearcoatSpecularDirect = null, this.clearcoatSpecularIndirect = null, this.sheenSpecularDirect = null, this.sheenSpecularIndirect = null, this.iridescenceFresnel = null, this.iridescenceF0 = null;
  }
  start(e) {
    if (this.clearcoat === !0 && (this.clearcoatRadiance = ye().toVar("clearcoatRadiance"), this.clearcoatSpecularDirect = ye().toVar("clearcoatSpecularDirect"), this.clearcoatSpecularIndirect = ye().toVar("clearcoatSpecularIndirect")), this.sheen === !0 && (this.sheenSpecularDirect = ye().toVar("sheenSpecularDirect"), this.sheenSpecularIndirect = ye().toVar("sheenSpecularIndirect")), this.iridescence === !0) {
      const i = Ui.dot(vi).clamp();
      this.iridescenceFresnel = JY({
        outsideIOR: be(1),
        eta2: XP,
        cosTheta1: i,
        thinFilmThickness: $P,
        baseF0: rn
      }), this.iridescenceF0 = BY({ f: this.iridescenceFresnel, f90: 1, dotVH: i });
    }
    if (this.transmission === !0) {
      const i = Ax, n = VX.sub(Ax).normalize(), s = k1;
      e.backdrop = YY(
        s,
        n,
        ta,
        qt,
        rn,
        Xm,
        // specularF90
        i,
        // positionWorld
        Al,
        // modelMatrix
        Ma,
        // viewMatrix
        $m,
        // projMatrix
        om,
        YP,
        ZP,
        KP,
        this.dispersion ? QP : null
      ), e.backdropAlpha = Mx, qt.a.mulAssign(li(1, e.backdrop.a, Mx));
    }
  }
  // Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(e, i, n) {
    const s = Ui.dot(vi).clamp(), a = zI({ roughness: ta, dotNV: s }), o = (this.iridescenceF0 ? R1.mix(rn, this.iridescenceF0) : rn).mul(a.x).add(n.mul(a.y)), l = a.x.add(a.y).oneMinus(), u = rn.add(rn.oneMinus().mul(0.047619)), c = o.mul(u).div(l.mul(u).oneMinus());
    e.addAssign(o), i.addAssign(c.mul(l));
  }
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }) {
    const s = Ui.dot(e).clamp().mul(i);
    if (this.sheen === !0 && this.sheenSpecularDirect.addAssign(s.mul(VY({ lightDirection: e }))), this.clearcoat === !0) {
      const a = Gh.dot(e).clamp().mul(i);
      this.clearcoatSpecularDirect.addAssign(a.mul(NM({ lightDirection: e, f0: X0, f90: $0, roughness: qm, normalView: Gh })));
    }
    n.directDiffuse.addAssign(s.mul(Ec({ diffuseColor: qt.rgb }))), n.directSpecular.addAssign(s.mul(NM({ lightDirection: e, f0: rn, f90: 1, roughness: ta, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy })));
  }
  directRectArea({ lightColor: e, lightPosition: i, halfWidth: n, halfHeight: s, reflectedLight: a, ltc_1: o, ltc_2: l }) {
    const u = i.add(n).sub(s), c = i.sub(n).sub(s), h = i.sub(n).add(s), d = i.add(n).add(s), p = Ui, f = vi, m = ir.toVar(), y = GY({ N: p, V: f, roughness: ta }), v = o.uv(y).toVar(), g = l.uv(y).toVar(), _ = Cr(
      ye(v.x, 0, v.y),
      ye(0, 1, 0),
      ye(v.z, 0, v.w)
    ).toVar(), x = rn.mul(g.x).add(rn.oneMinus().mul(g.y)).toVar();
    a.directSpecular.addAssign(e.mul(x).mul(PM({ N: p, V: f, P: m, mInv: _, p0: u, p1: c, p2: h, p3: d }))), a.directDiffuse.addAssign(e.mul(qt).mul(PM({ N: p, V: f, P: m, mInv: Cr(1, 0, 0, 0, 1, 0, 0, 0, 1), p0: u, p1: c, p2: h, p3: d })));
  }
  indirect(e, i, n) {
    this.indirectDiffuse(e, i, n), this.indirectSpecular(e, i, n), this.ambientOcclusion(e, i, n);
  }
  indirectDiffuse({ irradiance: e, reflectedLight: i }) {
    i.indirectDiffuse.addAssign(e.mul(Ec({ diffuseColor: qt })));
  }
  indirectSpecular({ radiance: e, iblIrradiance: i, reflectedLight: n }) {
    if (this.sheen === !0 && this.sheenSpecularIndirect.addAssign(i.mul(
      Fu,
      eK({
        normal: Ui,
        viewDir: vi,
        roughness: C1
      })
    )), this.clearcoat === !0) {
      const c = Gh.dot(vi).clamp(), h = jI({
        dotNV: c,
        specularColor: X0,
        specularF90: $0,
        roughness: qm
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(h));
    }
    const s = ye().toVar("singleScattering"), a = ye().toVar("multiScattering"), o = i.mul(1 / Math.PI);
    this.computeMultiscattering(s, a, Xm);
    const l = s.add(a), u = qt.mul(l.r.max(l.g).max(l.b).oneMinus());
    n.indirectSpecular.addAssign(e.mul(s)), n.indirectSpecular.addAssign(a.mul(o)), n.indirectDiffuse.addAssign(u.mul(o));
  }
  ambientOcclusion({ ambientOcclusion: e, reflectedLight: i }) {
    const n = Ui.dot(vi).clamp().add(e), s = ta.mul(-16).oneMinus().negate().exp2(), a = e.sub(n.pow(s).oneMinus()).clamp();
    this.clearcoat === !0 && this.clearcoatSpecularIndirect.mulAssign(e), this.sheen === !0 && this.sheenSpecularIndirect.mulAssign(e), i.indirectDiffuse.mulAssign(e), i.indirectSpecular.mulAssign(a);
  }
  finish(e) {
    const { outgoingLight: i } = e;
    if (this.clearcoat === !0) {
      const n = Gh.dot(vi).clamp(), s = Cd({
        dotVH: n,
        f0: X0,
        f90: $0
      }), a = i.mul(Sx.mul(s).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(Sx));
      i.assign(a);
    }
    if (this.sheen === !0) {
      const n = Fu.r.max(Fu.g).max(Fu.b).mul(0.157).oneMinus(), s = i.mul(n).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      i.assign(s);
    }
  }
}
const jM = /* @__PURE__ */ be(1), Ix = /* @__PURE__ */ be(-2), mf = /* @__PURE__ */ be(0.8), Y0 = /* @__PURE__ */ be(-1), gf = /* @__PURE__ */ be(0.4), K0 = /* @__PURE__ */ be(2), yf = /* @__PURE__ */ be(0.305), Z0 = /* @__PURE__ */ be(3), VM = /* @__PURE__ */ be(0.21), tK = /* @__PURE__ */ be(4), GM = /* @__PURE__ */ be(4), iK = /* @__PURE__ */ be(16), rK = /* @__PURE__ */ Fe(([r]) => {
  const e = ye(Gn(r)).toVar(), i = be(-1).toVar();
  return rr(e.x.greaterThan(e.z), () => {
    rr(e.x.greaterThan(e.y), () => {
      i.assign(Ur(r.x.greaterThan(0), 0, 3));
    }).Else(() => {
      i.assign(Ur(r.y.greaterThan(0), 1, 4));
    });
  }).Else(() => {
    rr(e.z.greaterThan(e.y), () => {
      i.assign(Ur(r.z.greaterThan(0), 2, 5));
    }).Else(() => {
      i.assign(Ur(r.y.greaterThan(0), 1, 4));
    });
  }), i;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
}), nK = /* @__PURE__ */ Fe(([r, e]) => {
  const i = He().toVar();
  return rr(e.equal(0), () => {
    i.assign(He(r.z, r.y).div(Gn(r.x)));
  }).ElseIf(e.equal(1), () => {
    i.assign(He(r.x.negate(), r.z.negate()).div(Gn(r.y)));
  }).ElseIf(e.equal(2), () => {
    i.assign(He(r.x.negate(), r.y).div(Gn(r.z)));
  }).ElseIf(e.equal(3), () => {
    i.assign(He(r.z.negate(), r.y).div(Gn(r.x)));
  }).ElseIf(e.equal(4), () => {
    i.assign(He(r.x.negate(), r.z).div(Gn(r.y)));
  }).Else(() => {
    i.assign(He(r.x, r.y).div(Gn(r.z)));
  }), Dt(0.5, i.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
}), sK = /* @__PURE__ */ Fe(([r]) => {
  const e = be(0).toVar();
  return rr(r.greaterThanEqual(mf), () => {
    e.assign(jM.sub(r).mul(Y0.sub(Ix)).div(jM.sub(mf)).add(Ix));
  }).ElseIf(r.greaterThanEqual(gf), () => {
    e.assign(mf.sub(r).mul(K0.sub(Y0)).div(mf.sub(gf)).add(Y0));
  }).ElseIf(r.greaterThanEqual(yf), () => {
    e.assign(gf.sub(r).mul(Z0.sub(K0)).div(gf.sub(yf)).add(K0));
  }).ElseIf(r.greaterThanEqual(VM), () => {
    e.assign(yf.sub(r).mul(tK.sub(Z0)).div(yf.sub(VM)).add(Z0));
  }).Else(() => {
    e.assign(be(-2).mul(ya(Dt(1.16, r))));
  }), e;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
}), aK = /* @__PURE__ */ Fe(([r, e]) => {
  const i = r.toVar();
  i.assign(Dt(2, i).sub(1));
  const n = ye(i, 1).toVar();
  return rr(e.equal(0), () => {
    n.assign(n.zyx);
  }).ElseIf(e.equal(1), () => {
    n.assign(n.xzy), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(2), () => {
    n.x.mulAssign(-1);
  }).ElseIf(e.equal(3), () => {
    n.assign(n.zyx), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(4), () => {
    n.assign(n.xzy), n.xy.mulAssign(-1);
  }).ElseIf(e.equal(5), () => {
    n.z.mulAssign(-1);
  }), n;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
}), oK = /* @__PURE__ */ Fe(([r, e, i, n, s, a]) => {
  const o = be(i), l = ye(e), u = xa(sK(o), Ix, a), c = To(u), h = yl(u), d = ye(Ox(r, l, h, n, s, a)).toVar();
  return rr(c.notEqual(0), () => {
    const p = ye(Ox(r, l, h.add(1), n, s, a)).toVar();
    d.assign(li(d, p, c));
  }), d;
}), Ox = /* @__PURE__ */ Fe(([r, e, i, n, s, a]) => {
  const o = be(i).toVar(), l = ye(e), u = be(rK(l)).toVar(), c = be(Sn(GM.sub(o), 0)).toVar();
  o.assign(Sn(o, GM));
  const h = be(_d(o)).toVar(), d = He(nK(l, u).mul(h.sub(2)).add(1)).toVar();
  return rr(u.greaterThan(2), () => {
    d.y.addAssign(h), u.subAssign(3);
  }), d.x.addAssign(u.mul(h)), d.x.addAssign(c.mul(Dt(3, iK))), d.y.addAssign(Dt(4, _d(a).sub(h))), d.x.mulAssign(n), d.y.mulAssign(s), r.uv(d).grad(He(), He());
}), Q0 = /* @__PURE__ */ Fe(({ envMap: r, mipInt: e, outputDirection: i, theta: n, axis: s, CUBEUV_TEXEL_WIDTH: a, CUBEUV_TEXEL_HEIGHT: o, CUBEUV_MAX_MIP: l }) => {
  const u = Za(n), c = i.mul(u).add(s.cross(i).mul(Vn(n))).add(s.mul(s.dot(i).mul(u.oneMinus())));
  return Ox(r, c, e, a, o, l);
}), lK = /* @__PURE__ */ Fe(({ n: r, latitudinal: e, poleAxis: i, outputDirection: n, weights: s, samples: a, dTheta: o, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }) => {
  const p = ye(Ur(e, i, lI(i, n))).toVar();
  rr(eI(p.equals(ye(0))), () => {
    p.assign(ye(n.z, 0, n.x.negate()));
  }), p.assign(Td(p));
  const f = ye().toVar();
  return f.addAssign(s.element(Mi(0)).mul(Q0({ theta: 0, axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }))), ps({ start: Mi(1), end: r }, ({ i: m }) => {
    rr(m.greaterThanEqual(a), () => {
      Q$();
    });
    const y = be(o.mul(be(m))).toVar();
    f.addAssign(s.element(m).mul(Q0({ theta: y.mul(-1), axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }))), f.addAssign(s.element(m).mul(Q0({ theta: y, axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d })));
  }), xt(f, 1);
});
let Ym = null;
const HM = /* @__PURE__ */ new WeakMap();
function uK(r) {
  const e = Math.log2(r) - 2, i = 1 / r;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: i, maxMip: e };
}
function cK(r) {
  let e = HM.get(r);
  if ((e !== void 0 ? e.pmremVersion : -1) !== r.pmremVersion) {
    const i = r.image;
    if (r.isCubeTexture)
      if (dK(i))
        e = Ym.fromCubemap(r, e);
      else
        return null;
    else if (pK(i))
      e = Ym.fromEquirectangular(r, e);
    else
      return null;
    e.pmremVersion = r.pmremVersion, HM.set(r, e);
  }
  return e.texture;
}
class hK extends zi {
  static get type() {
    return "PMREMNode";
  }
  constructor(e, i = null, n = null) {
    super("vec3"), this._value = e, this._pmrem = null, this.uvNode = i, this.levelNode = n, this._generator = null;
    const s = new Ar();
    s.isRenderTargetTexture = !0, this._texture = Ci(s), this._width = _t(0), this._height = _t(0), this._maxMip = _t(0), this.updateBeforeType = Nt.RENDER;
  }
  set value(e) {
    this._value = e, this._pmrem = null;
  }
  get value() {
    return this._value;
  }
  updateFromTexture(e) {
    const i = uK(e.image.height);
    this._texture.value = e, this._width.value = i.texelWidth, this._height.value = i.texelHeight, this._maxMip.value = i.maxMip;
  }
  updateBefore() {
    let e = this._pmrem;
    const i = e ? e.pmremVersion : -1, n = this._value;
    i !== n.pmremVersion && (n.isPMREMTexture === !0 ? e = n : e = cK(n), e !== null && (this._pmrem = e, this.updateFromTexture(e)));
  }
  setup(e) {
    Ym === null && (Ym = e.createPMREMGenerator()), this.updateBefore(e);
    let i = this.uvNode;
    i === null && e.context.getUV && (i = e.context.getUV(this));
    const n = this.value;
    e.renderer.coordinateSystem === Yn && n.isPMREMTexture !== !0 && n.isRenderTargetTexture === !0 && (i = ye(i.x.negate(), i.yz));
    let s = this.levelNode;
    return s === null && e.context.getTextureLevel && (s = e.context.getTextureLevel(this)), oK(this._texture, i, s, this._width, this._height, this._maxMip);
  }
}
function dK(r) {
  if (r == null) return !1;
  let e = 0;
  const i = 6;
  for (let n = 0; n < i; n++)
    r[n] !== void 0 && e++;
  return e === i;
}
function pK(r) {
  return r == null ? !1 : r.height > 0;
}
const WI = /* @__PURE__ */ Ae(hK), WM = /* @__PURE__ */ new WeakMap();
class fK extends Hc {
  static get type() {
    return "EnvironmentNode";
  }
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    const { material: i } = e;
    let n = this.envNode;
    if (n.isTextureNode || n.isMaterialReferenceNode) {
      const d = n.isTextureNode ? n.value : i[n.property];
      let p = WM.get(d);
      p === void 0 && (p = WI(d), WM.set(d, p)), n = p;
    }
    const s = i.envMap ? bi("envMapIntensity", "float", e.material) : bi("environmentIntensity", "float", e.scene), a = i.useAnisotropy === !0 || i.anisotropy > 0 ? a$ : Ui, o = n.context(qM(ta, a)).mul(s), l = n.context(mK(k1)).mul(Math.PI).mul(s), u = lm(o), c = lm(l);
    e.context.radiance.addAssign(u), e.context.iblIrradiance.addAssign(c);
    const h = e.context.lightingModel.clearcoatRadiance;
    if (h) {
      const d = n.context(qM(qm, Gh)).mul(s), p = lm(d);
      h.addAssign(p);
    }
  }
}
const qM = (r, e) => {
  let i = null;
  return {
    getUV: () => (i === null && (i = vi.negate().reflect(e), i = r.mul(r).mix(i, e).normalize(), i = i.transformDirection(Ma)), i),
    getTextureLevel: () => r
  };
}, mK = (r) => ({
  getUV: () => r,
  getTextureLevel: () => be(1)
}), gK = /* @__PURE__ */ new x1();
class qI extends Bi {
  static get type() {
    return "MeshStandardNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardNodeMaterial = !0, this.lights = !0, this.emissiveNode = null, this.metalnessNode = null, this.roughnessNode = null, this.setDefaultValues(gK), this.setValues(e);
  }
  setupEnvironment(e) {
    let i = super.setupEnvironment(e);
    return i === null && e.environmentNode && (i = e.environmentNode), i ? new fK(i) : null;
  }
  setupLightingModel() {
    return new HI();
  }
  setupSpecular() {
    const e = li(ye(0.04), qt.rgb, Wm);
    rn.assign(e), Xm.assign(1);
  }
  setupVariants() {
    const e = this.metalnessNode ? be(this.metalnessNode) : x$;
    Wm.assign(e);
    let i = this.roughnessNode ? be(this.roughnessNode) : b$;
    i = BI({ roughness: i }), ta.assign(i), this.setupSpecular(), qt.assign(xt(qt.rgb.mul(e.oneMinus()), qt.a));
  }
  copy(e) {
    return this.emissiveNode = e.emissiveNode, this.metalnessNode = e.metalnessNode, this.roughnessNode = e.roughnessNode, super.copy(e);
  }
}
const yK = /* @__PURE__ */ new CP();
class vK extends qI {
  static get type() {
    return "MeshPhysicalNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhysicalNodeMaterial = !0, this.clearcoatNode = null, this.clearcoatRoughnessNode = null, this.clearcoatNormalNode = null, this.sheenNode = null, this.sheenRoughnessNode = null, this.iridescenceNode = null, this.iridescenceIORNode = null, this.iridescenceThicknessNode = null, this.specularIntensityNode = null, this.specularColorNode = null, this.iorNode = null, this.transmissionNode = null, this.thicknessNode = null, this.attenuationDistanceNode = null, this.attenuationColorNode = null, this.dispersionNode = null, this.anisotropyNode = null, this.setDefaultValues(yK), this.setValues(e);
  }
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  get useDispersion() {
    return this.dispersion > 0 || this.dispersionNode !== null;
  }
  setupSpecular() {
    const e = this.iorNode ? be(this.iorNode) : D$;
    om.assign(e), rn.assign(li(Sd(uI(om.sub(1).div(om.add(1))).mul(v$), ye(1)).mul(wM), qt.rgb, Wm)), Xm.assign(li(wM, 1, Wm));
  }
  setupLightingModel() {
    return new HI(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
  }
  setupVariants(e) {
    if (super.setupVariants(e), this.useClearcoat) {
      const i = this.clearcoatNode ? be(this.clearcoatNode) : T$, n = this.clearcoatRoughnessNode ? be(this.clearcoatRoughnessNode) : S$;
      Sx.assign(i), qm.assign(BI({ roughness: n }));
    }
    if (this.useSheen) {
      const i = this.sheenNode ? ye(this.sheenNode) : M$, n = this.sheenRoughnessNode ? be(this.sheenRoughnessNode) : A$;
      Fu.assign(i), C1.assign(n);
    }
    if (this.useIridescence) {
      const i = this.iridescenceNode ? be(this.iridescenceNode) : R$, n = this.iridescenceIORNode ? be(this.iridescenceIORNode) : N$, s = this.iridescenceThicknessNode ? be(this.iridescenceThicknessNode) : P$;
      R1.assign(i), XP.assign(n), $P.assign(s);
    }
    if (this.useAnisotropy) {
      const i = (this.anisotropyNode ? He(this.anisotropyNode) : C$).toVar();
      Ho.assign(i.length()), rr(Ho.equal(0), () => {
        i.assign(He(1, 0));
      }).Else(() => {
        i.divAssign(He(Ho)), Ho.assign(Ho.saturate());
      }), wx.assign(Ho.pow2().mix(ta.pow2(), 1)), am.assign(Hh[0].mul(i.x).add(Hh[1].mul(i.y))), ec.assign(Hh[1].mul(i.x).sub(Hh[0].mul(i.y)));
    }
    if (this.useTransmission) {
      const i = this.transmissionNode ? be(this.transmissionNode) : I$, n = this.thicknessNode ? be(this.thicknessNode) : O$, s = this.attenuationDistanceNode ? be(this.attenuationDistanceNode) : L$, a = this.attenuationColorNode ? ye(this.attenuationColorNode) : k$;
      if (Mx.assign(i), YP.assign(n), KP.assign(s), ZP.assign(a), this.useDispersion) {
        const o = this.dispersionNode ? be(this.dispersionNode) : z$;
        QP.assign(o);
      }
    }
  }
  setupClearcoatNormal() {
    return this.clearcoatNormalNode ? ye(this.clearcoatNormalNode) : w$;
  }
  setup(e) {
    e.context.setupClearcoatNormal = () => this.setupClearcoatNormal(e), super.setup(e);
  }
  copy(e) {
    return this.clearcoatNode = e.clearcoatNode, this.clearcoatRoughnessNode = e.clearcoatRoughnessNode, this.clearcoatNormalNode = e.clearcoatNormalNode, this.sheenNode = e.sheenNode, this.sheenRoughnessNode = e.sheenRoughnessNode, this.iridescenceNode = e.iridescenceNode, this.iridescenceIORNode = e.iridescenceIORNode, this.iridescenceThicknessNode = e.iridescenceThicknessNode, this.specularIntensityNode = e.specularIntensityNode, this.specularColorNode = e.specularColorNode, this.transmissionNode = e.transmissionNode, this.thicknessNode = e.thicknessNode, this.attenuationDistanceNode = e.attenuationDistanceNode, this.attenuationColorNode = e.attenuationColorNode, this.dispersionNode = e.dispersionNode, this.anisotropyNode = e.anisotropyNode, super.copy(e);
  }
}
const bK = /* @__PURE__ */ Fe(({ normal: r, lightDirection: e, builder: i }) => {
  const n = r.dot(e), s = He(n.mul(0.5).add(0.5), 0);
  if (i.material.gradientMap) {
    const a = eo("gradientMap", "texture").context({ getUV: () => s });
    return ye(a.r);
  } else {
    const a = s.fwidth().mul(0.5);
    return li(ye(0.7), ye(1), Ml(be(0.7).sub(a.x), be(0.7).add(a.x), s.x));
  }
});
class xK extends Vg {
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }, s, a) {
    const o = bK({ normal: vI, lightDirection: e, builder: a }).mul(i);
    n.directDiffuse.addAssign(o.mul(Ec({ diffuseColor: qt.rgb })));
  }
  indirect({ ambientOcclusion: e, irradiance: i, reflectedLight: n }) {
    n.indirectDiffuse.addAssign(i.mul(Ec({ diffuseColor: qt }))), n.indirectDiffuse.mulAssign(e);
  }
}
const _K = /* @__PURE__ */ new NP();
class TK extends Bi {
  static get type() {
    return "MeshToonNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshToonNodeMaterial = !0, this.lights = !0, this.setDefaultValues(_K), this.setValues(e);
  }
  setupLightingModel() {
    return new xK();
  }
}
class SK extends zi {
  static get type() {
    return "MatcapUVNode";
  }
  constructor() {
    super("vec2");
  }
  setup() {
    const e = ye(vi.z, 0, vi.x.negate()).normalize(), i = vi.cross(e);
    return He(e.dot(Ui), i.dot(Ui)).mul(0.495).add(0.5);
  }
}
const wK = /* @__PURE__ */ Ve(SK), EK = /* @__PURE__ */ new OP();
class MK extends Bi {
  static get type() {
    return "MeshMatcapNodeMaterial";
  }
  constructor(e) {
    super(), this.lights = !1, this.isMeshMatcapNodeMaterial = !0, this.setDefaultValues(EK), this.setValues(e);
  }
  setupVariants(e) {
    const i = wK;
    let n;
    e.material.matcap ? n = eo("matcap", "texture").context({ getUV: () => i }) : n = ye(li(0.2, 0.8, i.y)), qt.rgb.mulAssign(n.rgb);
  }
}
const AK = /* @__PURE__ */ new MP();
class CK extends Bi {
  static get type() {
    return "PointsNodeMaterial";
  }
  constructor(e) {
    super(), this.isPointsNodeMaterial = !0, this.lights = !1, this.transparent = !0, this.sizeNode = null, this.setDefaultValues(AK), this.setValues(e);
  }
  copy(e) {
    return this.sizeNode = e.sizeNode, super.copy(e);
  }
}
class RK extends zi {
  static get type() {
    return "RotateNode";
  }
  constructor(e, i) {
    super(), this.positionNode = e, this.rotationNode = i;
  }
  getNodeType(e) {
    return this.positionNode.getNodeType(e);
  }
  setup(e) {
    const { rotationNode: i, positionNode: n } = this;
    if (this.getNodeType(e) === "vec2") {
      const s = i.cos(), a = i.sin();
      return A1(
        s,
        a,
        a.negate(),
        s
      ).mul(n);
    } else {
      const s = i, a = Ju(xt(1, 0, 0, 0), xt(0, Za(s.x), Vn(s.x).negate(), 0), xt(0, Vn(s.x), Za(s.x), 0), xt(0, 0, 0, 1)), o = Ju(xt(Za(s.y), 0, Vn(s.y), 0), xt(0, 1, 0, 0), xt(Vn(s.y).negate(), 0, Za(s.y), 0), xt(0, 0, 0, 1)), l = Ju(xt(Za(s.z), Vn(s.z).negate(), 0, 0), xt(Vn(s.z), Za(s.z), 0, 0), xt(0, 0, 1, 0), xt(0, 0, 0, 1));
      return a.mul(o).mul(l).mul(xt(n, 1)).xyz;
    }
  }
}
const NK = /* @__PURE__ */ Ae(RK), PK = /* @__PURE__ */ new wP();
class IK extends Bi {
  static get type() {
    return "SpriteNodeMaterial";
  }
  constructor(e) {
    super(), this.isSpriteNodeMaterial = !0, this.lights = !1, this._useSizeAttenuation = !0, this.positionNode = null, this.rotationNode = null, this.scaleNode = null, this.setDefaultValues(PK), this.setValues(e);
  }
  setupPosition({ object: e, camera: i, context: n }) {
    const s = this.sizeAttenuation, { positionNode: a, rotationNode: o, scaleNode: l } = this, u = nr;
    let c = zg.mul(ye(a || 0)), h = He(Al[0].xyz.length(), Al[1].xyz.length());
    if (l !== null && (h = h.mul(l)), !s)
      if (i.isPerspectiveCamera)
        h = h.mul(c.z.negate());
      else {
        const y = be(2).div($m.element(1).element(1));
        h = h.mul(y.mul(2));
      }
    let d = u.xy;
    if (e.center && e.center.isVector2 === !0) {
      const y = bX("center", "vec2");
      d = d.sub(y.sub(0.5));
    }
    d = d.mul(h);
    const p = be(o || E$), f = NK(d, p);
    c = xt(c.xy.add(f), c.zw);
    const m = $m.mul(c);
    return n.vertex = u, m;
  }
  copy(e) {
    return this.positionNode = e.positionNode, this.rotationNode = e.rotationNode, this.scaleNode = e.scaleNode, super.copy(e);
  }
  get sizeAttenuation() {
    return this._useSizeAttenuation;
  }
  set sizeAttenuation(e) {
    this._useSizeAttenuation !== e && (this._useSizeAttenuation = e, this.needsUpdate = !0);
  }
}
class OK extends Vg {
  constructor() {
    super(), this.shadowNode = be(1).toVar("shadowMask");
  }
  direct({ shadowMask: e }) {
    this.shadowNode.mulAssign(e);
  }
  finish(e) {
    qt.a.mulAssign(this.shadowNode.oneMinus()), e.outgoingLight.rgb.assign(qt.rgb);
  }
}
const DK = /* @__PURE__ */ new AP();
class LK extends Bi {
  static get type() {
    return "ShadowNodeMaterial";
  }
  constructor(e) {
    super(), this.isShadowNodeMaterial = !0, this.lights = !0, this.setDefaultValues(DK), this.setValues(e);
  }
  setupLightingModel() {
    return new OK();
  }
}
Fe(({ texture: r, uv: e }) => {
  const i = ye().toVar();
  return rr(e.x.lessThan(1e-4), () => {
    i.assign(ye(1, 0, 0));
  }).ElseIf(e.y.lessThan(1e-4), () => {
    i.assign(ye(0, 1, 0));
  }).ElseIf(e.z.lessThan(1e-4), () => {
    i.assign(ye(0, 0, 1));
  }).ElseIf(e.x.greaterThan(1 - 1e-4), () => {
    i.assign(ye(-1, 0, 0));
  }).ElseIf(e.y.greaterThan(1 - 1e-4), () => {
    i.assign(ye(0, -1, 0));
  }).ElseIf(e.z.greaterThan(1 - 1e-4), () => {
    i.assign(ye(0, 0, -1));
  }).Else(() => {
    const n = r.uv(e.add(ye(-0.01, 0, 0))).r.sub(r.uv(e.add(ye(0.01, 0, 0))).r), s = r.uv(e.add(ye(0, -0.01, 0))).r.sub(r.uv(e.add(ye(0, 0.01, 0))).r), a = r.uv(e.add(ye(0, 0, -0.01))).r.sub(r.uv(e.add(ye(0, 0, 0.01))).r);
    i.assign(ye(n, s, a));
  }), i.normalize();
});
class kK {
  constructor(e, i) {
    this.nodes = e, this.info = i, this.animationLoop = null, this.requestId = null, this._init();
  }
  _init() {
    const e = (i, n) => {
      this.requestId = self.requestAnimationFrame(e), this.info.autoReset === !0 && this.info.reset(), this.nodes.nodeFrame.update(), this.info.frame = this.nodes.nodeFrame.frameId, this.animationLoop !== null && this.animationLoop(i, n);
    };
    e();
  }
  dispose() {
    self.cancelAnimationFrame(this.requestId), this.requestId = null;
  }
  setAnimationLoop(e) {
    this.animationLoop = e;
  }
}
class Ts {
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
  }
  get(e) {
    let i = this.weakMap;
    for (let n = 0; n < e.length; n++)
      if (i = i.get(e[n]), i === void 0) return;
    return i.get(e[e.length - 1]);
  }
  set(e, i) {
    let n = this.weakMap;
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      n.has(a) === !1 && n.set(a, /* @__PURE__ */ new WeakMap()), n = n.get(a);
    }
    return n.set(e[e.length - 1], i);
  }
  delete(e) {
    let i = this.weakMap;
    for (let n = 0; n < e.length; n++)
      if (i = i.get(e[n]), i === void 0) return !1;
    return i.delete(e[e.length - 1]);
  }
}
const J0 = /* @__PURE__ */ new Ka();
class Dx {
  constructor() {
    this.version = 0, this.globalClippingCount = 0, this.localClippingCount = 0, this.localClippingEnabled = !1, this.localClipIntersection = !1, this.planes = [], this.parentVersion = 0, this.viewNormalMatrix = new qr(), this.cacheKey = 0;
  }
  projectPlanes(e, i) {
    const n = e.length, s = this.planes;
    for (let a = 0; a < n; a++) {
      J0.copy(e[a]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
      const o = s[i + a], l = J0.normal;
      o.x = -l.x, o.y = -l.y, o.z = -l.z, o.w = J0.constant;
    }
  }
  updateGlobal(e, i) {
    const n = e.clippingPlanes;
    this.viewMatrix = i.matrixWorldInverse, this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
    let s = !1;
    if (Array.isArray(n) && n.length !== 0) {
      const a = n.length;
      if (a !== this.globalClippingCount) {
        const o = [];
        for (let l = 0; l < a; l++)
          o.push(new Yt());
        this.globalClippingCount = a, this.planes = o, s = !0;
      }
      this.projectPlanes(n, 0);
    } else this.globalClippingCount !== 0 && (this.globalClippingCount = 0, this.planes = [], s = !0);
    e.localClippingEnabled !== this.localClippingEnabled && (this.localClippingEnabled = e.localClippingEnabled, s = !0), s && (this.version++, this.cacheKey = zm(this.globalClippingCount, this.localClippingEnabled === !0 ? 1 : 0));
  }
  update(e, i) {
    let n = !1;
    if (this !== e && e.version !== this.parentVersion && (this.globalClippingCount = i.isShadowNodeMaterial ? 0 : e.globalClippingCount, this.localClippingEnabled = e.localClippingEnabled, this.planes = Array.from(e.planes), this.parentVersion = e.version, this.viewMatrix = e.viewMatrix, this.viewNormalMatrix = e.viewNormalMatrix, n = !0), this.localClippingEnabled) {
      const s = i.clippingPlanes;
      if (Array.isArray(s) && s.length !== 0) {
        const a = s.length, o = this.planes, l = this.globalClippingCount;
        if (n || a !== this.localClippingCount) {
          o.length = l + a;
          for (let u = 0; u < a; u++)
            o[l + u] = new Yt();
          this.localClippingCount = a, n = !0;
        }
        this.projectPlanes(s, l);
      } else this.localClippingCount !== 0 && (this.localClippingCount = 0, n = !0);
      this.localClipIntersection !== i.clipIntersection && (this.localClipIntersection = i.clipIntersection, n = !0);
    }
    n && (this.version += e.version, this.cacheKey = zm(e.cacheKey, this.localClippingCount, this.localClipIntersection === !0 ? 1 : 0));
  }
}
let UK = 0;
function FK(r) {
  const e = Object.keys(r);
  let i = Object.getPrototypeOf(r);
  for (; i; ) {
    const n = Object.getOwnPropertyDescriptors(i);
    for (const s in n)
      if (n[s] !== void 0) {
        const a = n[s];
        a && typeof a.get == "function" && e.push(s);
      }
    i = Object.getPrototypeOf(i);
  }
  return e;
}
class BK {
  constructor(e, i, n, s, a, o, l, u, c) {
    this._nodes = e, this._geometries = i, this.id = UK++, this.renderer = n, this.object = s, this.material = a, this.scene = o, this.camera = l, this.lightsNode = u, this.context = c, this.geometry = s.geometry, this.version = a.version, this.drawRange = null, this.attributes = null, this.pipeline = null, this.vertexBuffers = null, this.drawParams = null, this.bundle = null, this.updateClipping(c.clippingContext), this.clippingContextVersion = this.clippingContext.version, this.initialNodesCacheKey = this.getDynamicCacheKey(), this.initialCacheKey = this.getCacheKey(), this._nodeBuilderState = null, this._bindings = null, this._monitor = null, this.onDispose = null, this.isRenderObject = !0, this.onMaterialDispose = () => {
      this.dispose();
    }, this.material.addEventListener("dispose", this.onMaterialDispose);
  }
  updateClipping(e) {
    const i = this.material;
    let n = this.clippingContext;
    Array.isArray(i.clippingPlanes) ? ((n === e || !n) && (n = new Dx(), this.clippingContext = n), n.update(e, i)) : this.clippingContext !== e && (this.clippingContext = e);
  }
  get clippingNeedsUpdate() {
    return this.clippingContext.version === this.clippingContextVersion ? !1 : (this.clippingContextVersion = this.clippingContext.version, !0);
  }
  getNodeBuilderState() {
    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
  }
  getMonitor() {
    return this._monitor || (this._monitor = this.getNodeBuilderState().monitor);
  }
  getBindings() {
    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
  }
  getIndex() {
    return this._geometries.getIndex(this);
  }
  getIndirect() {
    return this._geometries.getIndirect(this);
  }
  getChainArray() {
    return [this.object, this.material, this.context, this.lightsNode];
  }
  getAttributes() {
    if (this.attributes !== null) return this.attributes;
    const e = this.getNodeBuilderState().nodeAttributes, i = this.geometry, n = [], s = /* @__PURE__ */ new Set();
    for (const a of e) {
      const o = a.node && a.node.attribute ? a.node.attribute : i.getAttribute(a.name);
      if (o === void 0) continue;
      n.push(o);
      const l = o.isInterleavedBufferAttribute ? o.data : o;
      s.add(l);
    }
    return this.attributes = n, this.vertexBuffers = Array.from(s.values()), n;
  }
  getVertexBuffers() {
    return this.vertexBuffers === null && this.getAttributes(), this.vertexBuffers;
  }
  getDrawParameters() {
    const { object: e, material: i, geometry: n, group: s, drawRange: a } = this, o = this.drawParams || (this.drawParams = {
      vertexCount: 0,
      firstVertex: 0,
      instanceCount: 0,
      firstInstance: 0
    }), l = this.getIndex(), u = l !== null, c = n.isInstancedBufferGeometry ? n.instanceCount : e.count > 1 ? e.count : 1;
    if (c === 0) return null;
    if (o.instanceCount = c, e.isBatchedMesh === !0) return o;
    let h = 1;
    i.wireframe === !0 && !e.isPoints && !e.isLineSegments && !e.isLine && !e.isLineLoop && (h = 2);
    let d = a.start * h, p = (a.start + a.count) * h;
    s !== null && (d = Math.max(d, s.start * h), p = Math.min(p, (s.start + s.count) * h));
    const f = n.attributes.position;
    let m = 1 / 0;
    u ? m = l.count : f != null && (m = f.count), d = Math.max(d, 0), p = Math.min(p, m);
    const y = p - d;
    return y < 0 || y === 1 / 0 ? null : (o.vertexCount = y, o.firstVertex = d, o);
  }
  getGeometryCacheKey() {
    const { geometry: e } = this;
    let i = "";
    for (const n of Object.keys(e.attributes).sort()) {
      const s = e.attributes[n];
      i += n + ",", s.data && (i += s.data.stride + ","), s.offset && (i += s.offset + ","), s.itemSize && (i += s.itemSize + ","), s.normalized && (i += "n,");
    }
    return e.index && (i += "index,"), i;
  }
  getMaterialCacheKey() {
    const { object: e, material: i } = this;
    let n = i.customProgramCacheKey();
    for (const s of FK(i)) {
      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(s)) continue;
      const a = i[s];
      let o;
      if (a !== null) {
        const l = typeof a;
        l === "number" ? o = a !== 0 ? "1" : "0" : l === "object" ? (o = "{", a.isTexture && (o += a.mapping), o += "}") : o = String(a);
      } else
        o = String(a);
      n += /*property + ':' +*/
      o + ",";
    }
    return n += this.clippingContext.cacheKey + ",", e.geometry && (n += this.getGeometryCacheKey()), e.skeleton && (n += e.skeleton.bones.length + ","), e.morphTargetInfluences && (n += e.morphTargetInfluences.length + ","), e.isBatchedMesh && (n += e._matricesTexture.uuid + ",", e._colorsTexture !== null && (n += e._colorsTexture.uuid + ",")), e.count > 1 && (n += e.uuid + ","), wW(n);
  }
  get needsUpdate() {
    return (
      /*this.object.static !== true &&*/
      this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate
    );
  }
  getDynamicCacheKey() {
    let e = this._nodes.getCacheKey(this.scene, this.lightsNode);
    return this.object.receiveShadow && (e += 1), e;
  }
  getCacheKey() {
    return this.getMaterialCacheKey() + this.getDynamicCacheKey();
  }
  dispose() {
    this.material.removeEventListener("dispose", this.onMaterialDispose), this.onDispose();
  }
}
const bu = [];
class zK {
  constructor(e, i, n, s, a, o) {
    this.renderer = e, this.nodes = i, this.geometries = n, this.pipelines = s, this.bindings = a, this.info = o, this.chainMaps = {};
  }
  get(e, i, n, s, a, o, l) {
    const u = this.getChainMap(l);
    bu[0] = e, bu[1] = i, bu[2] = o, bu[3] = a;
    let c = u.get(bu);
    return c === void 0 ? (c = this.createRenderObject(this.nodes, this.geometries, this.renderer, e, i, n, s, a, o, l), u.set(bu, c)) : (c.updateClipping(o.clippingContext), (c.version !== i.version || c.needsUpdate) && (c.initialCacheKey !== c.getCacheKey() ? (c.dispose(), c = this.get(e, i, n, s, a, o, l)) : c.version = i.version)), c;
  }
  getChainMap(e = "default") {
    return this.chainMaps[e] || (this.chainMaps[e] = new Ts());
  }
  dispose() {
    this.chainMaps = {};
  }
  createRenderObject(e, i, n, s, a, o, l, u, c, h) {
    const d = this.getChainMap(h), p = new BK(e, i, n, s, a, o, l, u, c);
    return p.onDispose = () => {
      this.pipelines.delete(p), this.bindings.delete(p), this.nodes.delete(p), d.delete(p.getChainArray());
    }, p;
  }
}
class So {
  constructor() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
  get(e) {
    let i = this.data.get(e);
    return i === void 0 && (i = {}, this.data.set(e, i)), i;
  }
  delete(e) {
    let i;
    return this.data.has(e) && (i = this.data.get(e), this.data.delete(e)), i;
  }
  has(e) {
    return this.data.has(e);
  }
  dispose() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
}
const fs = {
  VERTEX: 1,
  INDEX: 2,
  STORAGE: 3,
  INDIRECT: 4
}, to = 16, jK = 211, VK = 212;
class GK extends So {
  constructor(e) {
    super(), this.backend = e;
  }
  delete(e) {
    const i = super.delete(e);
    return i !== void 0 && this.backend.destroyAttribute(e), i;
  }
  update(e, i) {
    const n = this.get(e);
    if (n.version === void 0)
      i === fs.VERTEX ? this.backend.createAttribute(e) : i === fs.INDEX ? this.backend.createIndexAttribute(e) : i === fs.STORAGE ? this.backend.createStorageAttribute(e) : i === fs.INDIRECT && this.backend.createIndirectStorageAttribute(e), n.version = this._getBufferAttribute(e).version;
    else {
      const s = this._getBufferAttribute(e);
      (n.version < s.version || s.usage === ku) && (this.backend.updateAttribute(e), n.version = s.version);
    }
  }
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
function HK(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function XI(r) {
  return r.index !== null ? r.index.version : r.attributes.position.version;
}
function XM(r) {
  const e = [], i = r.index, n = r.attributes.position;
  if (i !== null) {
    const a = i.array;
    for (let o = 0, l = a.length; o < l; o += 3) {
      const u = a[o + 0], c = a[o + 1], h = a[o + 2];
      e.push(u, c, c, h, h, u);
    }
  } else {
    const a = n.array;
    for (let o = 0, l = a.length / 3 - 1; o < l; o += 3) {
      const u = o + 0, c = o + 1, h = o + 2;
      e.push(u, c, c, h, h, u);
    }
  }
  const s = new (HK(e) ? yP : gP)(e, 1);
  return s.version = XI(r), s;
}
class WK extends So {
  constructor(e, i) {
    super(), this.attributes = e, this.info = i, this.wireframes = /* @__PURE__ */ new WeakMap(), this.attributeCall = /* @__PURE__ */ new WeakMap();
  }
  has(e) {
    const i = e.geometry;
    return super.has(i) && this.get(i).initialized === !0;
  }
  updateForRender(e) {
    this.has(e) === !1 && this.initGeometry(e), this.updateAttributes(e);
  }
  initGeometry(e) {
    const i = e.geometry, n = this.get(i);
    n.initialized = !0, this.info.memory.geometries++;
    const s = () => {
      this.info.memory.geometries--;
      const a = i.index, o = e.getAttributes();
      a !== null && this.attributes.delete(a);
      for (const u of o)
        this.attributes.delete(u);
      const l = this.wireframes.get(i);
      l !== void 0 && this.attributes.delete(l), i.removeEventListener("dispose", s);
    };
    i.addEventListener("dispose", s);
  }
  updateAttributes(e) {
    const i = e.getAttributes();
    for (const a of i)
      a.isStorageBufferAttribute || a.isStorageInstancedBufferAttribute ? this.updateAttribute(a, fs.STORAGE) : this.updateAttribute(a, fs.VERTEX);
    const n = this.getIndex(e);
    n !== null && this.updateAttribute(n, fs.INDEX);
    const s = e.geometry.indirect;
    s !== null && this.updateAttribute(s, fs.INDIRECT);
  }
  updateAttribute(e, i) {
    const n = this.info.render.calls;
    e.isInterleavedBufferAttribute ? this.attributeCall.get(e) === void 0 ? (this.attributes.update(e, i), this.attributeCall.set(e, n)) : this.attributeCall.get(e.data) !== n && (this.attributes.update(e, i), this.attributeCall.set(e.data, n), this.attributeCall.set(e, n)) : this.attributeCall.get(e) !== n && (this.attributes.update(e, i), this.attributeCall.set(e, n));
  }
  getIndirect(e) {
    return e.geometry.indirect;
  }
  getIndex(e) {
    const { geometry: i, material: n } = e;
    let s = i.index;
    if (n.wireframe === !0) {
      const a = this.wireframes;
      let o = a.get(i);
      o === void 0 ? (o = XM(i), a.set(i, o)) : o.version !== XI(i) && (this.attributes.delete(o), o = XM(i), a.set(i, o)), s = o;
    }
    return s;
  }
}
class qK {
  constructor() {
    this.autoReset = !0, this.frame = 0, this.calls = 0, this.render = {
      calls: 0,
      frameCalls: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
      timestamp: 0,
      previousFrameCalls: 0,
      timestampCalls: 0
    }, this.compute = {
      calls: 0,
      frameCalls: 0,
      timestamp: 0,
      previousFrameCalls: 0,
      timestampCalls: 0
    }, this.memory = {
      geometries: 0,
      textures: 0
    };
  }
  update(e, i, n) {
    this.render.drawCalls++, e.isMesh || e.isSprite ? this.render.triangles += n * (i / 3) : e.isPoints ? this.render.points += n * i : e.isLineSegments ? this.render.lines += n * (i / 2) : e.isLine ? this.render.lines += n * (i - 1) : console.error("THREE.WebGPUInfo: Unknown object type.");
  }
  updateTimestamp(e, i) {
    this[e].timestampCalls === 0 && (this[e].timestamp = 0), this[e].timestamp += i, this[e].timestampCalls++, this[e].timestampCalls >= this[e].previousFrameCalls && (this[e].timestampCalls = 0);
  }
  reset() {
    const e = this.render.frameCalls;
    this.render.previousFrameCalls = e;
    const i = this.compute.frameCalls;
    this.compute.previousFrameCalls = i, this.render.drawCalls = 0, this.render.frameCalls = 0, this.compute.frameCalls = 0, this.render.triangles = 0, this.render.points = 0, this.render.lines = 0;
  }
  dispose() {
    this.reset(), this.calls = 0, this.render.calls = 0, this.compute.calls = 0, this.render.timestamp = 0, this.compute.timestamp = 0, this.memory.geometries = 0, this.memory.textures = 0;
  }
}
class $I {
  constructor(e) {
    this.cacheKey = e, this.usedTimes = 0;
  }
}
class XK extends $I {
  constructor(e, i, n) {
    super(e), this.vertexProgram = i, this.fragmentProgram = n;
  }
}
class $K extends $I {
  constructor(e, i) {
    super(e), this.computeProgram = i, this.isComputePipeline = !0;
  }
}
let YK = 0;
class ev {
  constructor(e, i, n = null, s = null) {
    this.id = YK++, this.code = e, this.stage = i, this.transforms = n, this.attributes = s, this.usedTimes = 0;
  }
}
class KK extends So {
  constructor(e, i) {
    super(), this.backend = e, this.nodes = i, this.bindings = null, this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  getForCompute(e, i) {
    const { backend: n } = this, s = this.get(e);
    if (this._needsComputeUpdate(e)) {
      const a = s.pipeline;
      a && (a.usedTimes--, a.computeProgram.usedTimes--);
      const o = this.nodes.getForCompute(e);
      let l = this.programs.compute.get(o.computeShader);
      l === void 0 && (a && a.computeProgram.usedTimes === 0 && this._releaseProgram(a.computeProgram), l = new ev(o.computeShader, "compute", o.transforms, o.nodeAttributes), this.programs.compute.set(o.computeShader, l), n.createProgram(l));
      const u = this._getComputeCacheKey(e, l);
      let c = this.caches.get(u);
      c === void 0 && (a && a.usedTimes === 0 && this._releasePipeline(a), c = this._getComputePipeline(e, l, u, i)), c.usedTimes++, l.usedTimes++, s.version = e.version, s.pipeline = c;
    }
    return s.pipeline;
  }
  getForRender(e, i = null) {
    const { backend: n } = this, s = this.get(e);
    if (this._needsRenderUpdate(e)) {
      const a = s.pipeline;
      a && (a.usedTimes--, a.vertexProgram.usedTimes--, a.fragmentProgram.usedTimes--);
      const o = e.getNodeBuilderState();
      let l = this.programs.vertex.get(o.vertexShader);
      l === void 0 && (a && a.vertexProgram.usedTimes === 0 && this._releaseProgram(a.vertexProgram), l = new ev(o.vertexShader, "vertex"), this.programs.vertex.set(o.vertexShader, l), n.createProgram(l));
      let u = this.programs.fragment.get(o.fragmentShader);
      u === void 0 && (a && a.fragmentProgram.usedTimes === 0 && this._releaseProgram(a.fragmentProgram), u = new ev(o.fragmentShader, "fragment"), this.programs.fragment.set(o.fragmentShader, u), n.createProgram(u));
      const c = this._getRenderCacheKey(e, l, u);
      let h = this.caches.get(c);
      h === void 0 ? (a && a.usedTimes === 0 && this._releasePipeline(a), h = this._getRenderPipeline(e, l, u, c, i)) : e.pipeline = h, h.usedTimes++, l.usedTimes++, u.usedTimes++, s.pipeline = h;
    }
    return s.pipeline;
  }
  delete(e) {
    const i = this.get(e).pipeline;
    return i && (i.usedTimes--, i.usedTimes === 0 && this._releasePipeline(i), i.isComputePipeline ? (i.computeProgram.usedTimes--, i.computeProgram.usedTimes === 0 && this._releaseProgram(i.computeProgram)) : (i.fragmentProgram.usedTimes--, i.vertexProgram.usedTimes--, i.vertexProgram.usedTimes === 0 && this._releaseProgram(i.vertexProgram), i.fragmentProgram.usedTimes === 0 && this._releaseProgram(i.fragmentProgram))), super.delete(e);
  }
  dispose() {
    super.dispose(), this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  updateForRender(e) {
    this.getForRender(e);
  }
  _getComputePipeline(e, i, n, s) {
    n = n || this._getComputeCacheKey(e, i);
    let a = this.caches.get(n);
    return a === void 0 && (a = new $K(n, i), this.caches.set(n, a), this.backend.createComputePipeline(a, s)), a;
  }
  _getRenderPipeline(e, i, n, s, a) {
    s = s || this._getRenderCacheKey(e, i, n);
    let o = this.caches.get(s);
    return o === void 0 && (o = new XK(s, i, n), this.caches.set(s, o), e.pipeline = o, this.backend.createRenderPipeline(e, a)), o;
  }
  _getComputeCacheKey(e, i) {
    return e.id + "," + i.id;
  }
  _getRenderCacheKey(e, i, n) {
    return i.id + "," + n.id + "," + this.backend.getRenderCacheKey(e);
  }
  _releasePipeline(e) {
    this.caches.delete(e.cacheKey);
  }
  _releaseProgram(e) {
    const i = e.code, n = e.stage;
    this.programs[n].delete(i);
  }
  _needsComputeUpdate(e) {
    const i = this.get(e);
    return i.pipeline === void 0 || i.version !== e.version;
  }
  _needsRenderUpdate(e) {
    return this.get(e).pipeline === void 0 || this.backend.needsRenderUpdate(e);
  }
}
class ZK extends So {
  constructor(e, i, n, s, a, o) {
    super(), this.backend = e, this.textures = n, this.pipelines = a, this.attributes = s, this.nodes = i, this.info = o, this.pipelines.bindings = this;
  }
  getForRender(e) {
    const i = e.getBindings();
    for (const n of i) {
      const s = this.get(n);
      s.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, i), s.bindGroup = n);
    }
    return i;
  }
  getForCompute(e) {
    const i = this.nodes.getForCompute(e).bindings;
    for (const n of i) {
      const s = this.get(n);
      s.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, i), s.bindGroup = n);
    }
    return i;
  }
  updateForCompute(e) {
    this._updateBindings(this.getForCompute(e));
  }
  updateForRender(e) {
    this._updateBindings(this.getForRender(e));
  }
  _updateBindings(e) {
    for (const i of e)
      this._update(i, e);
  }
  _init(e) {
    for (const i of e.bindings)
      if (i.isSampledTexture)
        this.textures.updateTexture(i.texture);
      else if (i.isStorageBuffer) {
        const n = i.attribute, s = n.isIndirectStorageBufferAttribute ? fs.INDIRECT : fs.STORAGE;
        this.attributes.update(n, s);
      }
  }
  _update(e, i) {
    const { backend: n } = this;
    let s = !1;
    for (const a of e.bindings)
      if (!(a.isNodeUniformsGroup && !this.nodes.updateGroup(a))) {
        if (a.isUniformBuffer)
          a.update() && n.updateBinding(a);
        else if (a.isSampler)
          a.update();
        else if (a.isSampledTexture) {
          a.needsBindingsUpdate(this.textures.get(a.texture).generation) && (s = !0);
          const o = a.update(), l = a.texture;
          o && this.textures.updateTexture(l);
          const u = n.get(l);
          if (n.isWebGPUBackend === !0 && u.texture === void 0 && u.externalTexture === void 0 && (console.error("Bindings._update: binding should be available:", a, o, l, a.textureNode.value, s), this.textures.updateTexture(l), s = !0), l.isStorageTexture === !0) {
            const c = this.get(l);
            a.store === !0 ? c.needsMipmap = !0 : this.textures.needsMipmaps(l) && c.needsMipmap === !0 && (this.backend.generateMipmaps(l), c.needsMipmap = !1);
          }
        }
      }
    s === !0 && this.backend.updateBindings(e, i);
  }
}
function QK(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
}
function $M(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
}
function YM(r) {
  return (r.transmission > 0 || r.transmissionNode) && r.side === $u && r.forceSinglePass === !1;
}
class JK {
  constructor(e, i, n) {
    this.renderItems = [], this.renderItemsIndex = 0, this.opaque = [], this.transparentDoublePass = [], this.transparent = [], this.bundles = [], this.lightsNode = e.getNode(i, n), this.lightsArray = [], this.scene = i, this.camera = n, this.occlusionQueryCount = 0;
  }
  begin() {
    return this.renderItemsIndex = 0, this.opaque.length = 0, this.transparentDoublePass.length = 0, this.transparent.length = 0, this.bundles.length = 0, this.lightsArray.length = 0, this.occlusionQueryCount = 0, this;
  }
  getNextRenderItem(e, i, n, s, a, o) {
    let l = this.renderItems[this.renderItemsIndex];
    return l === void 0 ? (l = {
      id: e.id,
      object: e,
      geometry: i,
      material: n,
      groupOrder: s,
      renderOrder: e.renderOrder,
      z: a,
      group: o
    }, this.renderItems[this.renderItemsIndex] = l) : (l.id = e.id, l.object = e, l.geometry = i, l.material = n, l.groupOrder = s, l.renderOrder = e.renderOrder, l.z = a, l.group = o), this.renderItemsIndex++, l;
  }
  push(e, i, n, s, a, o) {
    const l = this.getNextRenderItem(e, i, n, s, a, o);
    e.occlusionTest === !0 && this.occlusionQueryCount++, n.transparent === !0 || n.transmission > 0 ? (YM(n) && this.transparentDoublePass.push(l), this.transparent.push(l)) : this.opaque.push(l);
  }
  unshift(e, i, n, s, a, o) {
    const l = this.getNextRenderItem(e, i, n, s, a, o);
    n.transparent === !0 || n.transmission > 0 ? (YM(n) && this.transparentDoublePass.unshift(l), this.transparent.unshift(l)) : this.opaque.unshift(l);
  }
  pushBundle(e) {
    this.bundles.push(e);
  }
  pushLight(e) {
    this.lightsArray.push(e);
  }
  sort(e, i) {
    this.opaque.length > 1 && this.opaque.sort(e || QK), this.transparentDoublePass.length > 1 && this.transparentDoublePass.sort(i || $M), this.transparent.length > 1 && this.transparent.sort(i || $M);
  }
  finish() {
    this.lightsNode.setLights(this.lightsArray);
    for (let e = this.renderItemsIndex, i = this.renderItems.length; e < i; e++) {
      const n = this.renderItems[e];
      if (n.id === null) break;
      n.id = null, n.object = null, n.geometry = null, n.material = null, n.groupOrder = null, n.renderOrder = null, n.z = null, n.group = null;
    }
  }
}
class eZ {
  constructor(e) {
    this.lighting = e, this.lists = new Ts();
  }
  get(e, i) {
    const n = this.lists, s = [e, i];
    let a = n.get(s);
    return a === void 0 && (a = new JK(this.lighting, e, i), n.set(s, a)), a;
  }
  dispose() {
    this.lists = new Ts();
  }
}
let tZ = 0;
class iZ {
  constructor() {
    this.id = tZ++, this.color = !0, this.clearColor = !0, this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 }, this.depth = !0, this.clearDepth = !0, this.clearDepthValue = 1, this.stencil = !1, this.clearStencil = !0, this.clearStencilValue = 1, this.viewport = !1, this.viewportValue = new Yt(), this.scissor = !1, this.scissorValue = new Yt(), this.textures = null, this.depthTexture = null, this.activeCubeFace = 0, this.sampleCount = 1, this.width = 0, this.height = 0, this.isRenderContext = !0;
  }
  getCacheKey() {
    return YI(this);
  }
}
function YI(r) {
  const { textures: e, activeCubeFace: i } = r, n = [i];
  for (const s of e)
    n.push(s.id);
  return kP(n);
}
class rZ {
  constructor() {
    this.chainMaps = {};
  }
  get(e, i, n = null) {
    const s = [e, i];
    let a;
    if (n === null)
      a = "default";
    else {
      const u = n.texture.format;
      a = `${n.textures.length}:${u}:${n.samples}:${n.depthBuffer}:${n.stencilBuffer}`;
    }
    const o = this.getChainMap(a);
    let l = o.get(s);
    return l === void 0 && (l = new iZ(), o.set(s, l)), n !== null && (l.sampleCount = n.samples === 0 ? 1 : n.samples), l;
  }
  getChainMap(e) {
    return this.chainMaps[e] || (this.chainMaps[e] = new Ts());
  }
  dispose() {
    this.chainMaps = {};
  }
}
const nZ = /* @__PURE__ */ new ue();
class sZ extends So {
  constructor(e, i, n) {
    super(), this.renderer = e, this.backend = i, this.info = n;
  }
  updateRenderTarget(e, i = 0) {
    const n = this.get(e), s = e.samples === 0 ? 1 : e.samples, a = n.depthTextureMips || (n.depthTextureMips = {}), o = e.textures, l = this.getSize(o[0]), u = l.width >> i, c = l.height >> i;
    let h = e.depthTexture || a[i];
    const d = e.depthBuffer === !0 || e.stencilBuffer === !0;
    let p = !1;
    h === void 0 && d && (h = new Vc(), h.format = e.stencilBuffer ? Tc : gl, h.type = e.stencilBuffer ? Kd : Ji, h.image.width = u, h.image.height = c, a[i] = h), (n.width !== l.width || l.height !== n.height) && (p = !0, h && (h.needsUpdate = !0, h.image.width = u, h.image.height = c)), n.width = l.width, n.height = l.height, n.textures = o, n.depthTexture = h || null, n.depth = e.depthBuffer, n.stencil = e.stencilBuffer, n.renderTarget = e, n.sampleCount !== s && (p = !0, h && (h.needsUpdate = !0), n.sampleCount = s);
    const f = { sampleCount: s };
    for (let m = 0; m < o.length; m++) {
      const y = o[m];
      p && (y.needsUpdate = !0), this.updateTexture(y, f);
    }
    if (h && this.updateTexture(h, f), n.initialized !== !0) {
      n.initialized = !0;
      const m = () => {
        e.removeEventListener("dispose", m);
        for (let y = 0; y < o.length; y++)
          this._destroyTexture(o[y]);
        h && this._destroyTexture(h), this.delete(e);
      };
      e.addEventListener("dispose", m);
    }
  }
  updateTexture(e, i = {}) {
    const n = this.get(e);
    if (n.initialized === !0 && n.version === e.version) return;
    const s = e.isRenderTargetTexture || e.isDepthTexture || e.isFramebufferTexture, a = this.backend;
    if (s && n.initialized === !0 && (a.destroySampler(e), a.destroyTexture(e)), e.isFramebufferTexture) {
      const c = this.renderer.getRenderTarget();
      c ? e.type = c.texture.type : e.type = ho;
    }
    const { width: o, height: l, depth: u } = this.getSize(e);
    if (i.width = o, i.height = l, i.depth = u, i.needsMipmaps = this.needsMipmaps(e), i.levels = i.needsMipmaps ? this.getMipLevels(e, o, l) : 1, s || e.isStorageTexture === !0)
      a.createSampler(e), a.createTexture(e, i), n.generation = e.version;
    else if (n.initialized !== !0 && a.createSampler(e), e.version > 0) {
      const c = e.image;
      if (c === void 0)
        console.warn("THREE.Renderer: Texture marked for update but image is undefined.");
      else if (c.complete === !1)
        console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");
      else {
        if (e.images) {
          const h = [];
          for (const d of e.images)
            h.push(d);
          i.images = h;
        } else
          i.image = c;
        (n.isDefaultTexture === void 0 || n.isDefaultTexture === !0) && (a.createTexture(e, i), n.isDefaultTexture = !1, n.generation = e.version), e.source.dataReady === !0 && a.updateTexture(e, i), i.needsMipmaps && e.mipmaps.length === 0 && a.generateMipmaps(e);
      }
    } else
      a.createDefaultTexture(e), n.isDefaultTexture = !0, n.generation = e.version;
    if (n.initialized !== !0) {
      n.initialized = !0, n.generation = e.version, this.info.memory.textures++;
      const c = () => {
        e.removeEventListener("dispose", c), this._destroyTexture(e), this.info.memory.textures--;
      };
      e.addEventListener("dispose", c);
    }
    n.version = e.version;
  }
  getSize(e, i = nZ) {
    let n = e.images ? e.images[0] : e.image;
    return n ? (n.image !== void 0 && (n = n.image), i.width = n.width, i.height = n.height, i.depth = e.isCubeTexture ? 6 : n.depth || 1) : i.width = i.height = i.depth = 1, i;
  }
  getMipLevels(e, i, n) {
    let s;
    return e.isCompressedTexture ? s = e.mipmaps.length : s = Math.floor(Math.log2(Math.max(i, n))) + 1, s;
  }
  needsMipmaps(e) {
    return this.isEnvironmentTexture(e) || e.isCompressedTexture === !0 || e.generateMipmaps;
  }
  isEnvironmentTexture(e) {
    const i = e.mapping;
    return i === $d || i === Yd || i === Tl || i === _c;
  }
  _destroyTexture(e) {
    this.backend.destroySampler(e), this.backend.destroyTexture(e), this.delete(e);
  }
}
class G1 extends Kt {
  constructor(e, i, n, s = 1) {
    super(e, i, n), this.a = s;
  }
  set(e, i, n, s = 1) {
    return this.a = s, super.set(e, i, n);
  }
  copy(e) {
    return e.a !== void 0 && (this.a = e.a), super.copy(e);
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
}
class aZ extends Zt {
  static get type() {
    return "ParameterNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isParameterNode = !0;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
class oZ extends Mt {
  static get type() {
    return "StackNode";
  }
  constructor(e = null) {
    super(), this.nodes = [], this.outputNode = null, this.parent = e, this._currentCond = null, this.isStackNode = !0;
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : "void";
  }
  add(e) {
    return this.nodes.push(e), this;
  }
  If(e, i) {
    const n = new sm(i);
    return this._currentCond = Ur(e, n), this.add(this._currentCond);
  }
  ElseIf(e, i) {
    const n = new sm(i), s = Ur(e, n);
    return this._currentCond.elseNode = s, this._currentCond = s, this;
  }
  Else(e) {
    return this._currentCond.elseNode = new sm(e), this;
  }
  build(e, ...i) {
    const n = GP();
    Gm(this);
    for (const s of this.nodes)
      s.build(e, "void");
    return Gm(n), this.outputNode ? this.outputNode.build(e, ...i) : super.build(e, ...i);
  }
  //
  else(...e) {
    return console.warn("TSL.StackNode: .else() has been renamed to .Else()."), this.Else(...e);
  }
  elseif(...e) {
    return console.warn("TSL.StackNode: .elseif() has been renamed to .ElseIf()."), this.ElseIf(...e);
  }
}
const tv = /* @__PURE__ */ Ae(oZ);
new Ka();
new ue();
new ue();
new ue();
new gi();
new ue(0, 0, -1);
new Yt();
new ue();
new ue();
new Yt();
new Vt();
const lZ = new jc();
Ad.flipX();
lZ.depthTexture = new Vc(1, 1);
const iv = /* @__PURE__ */ new T1(-1, 1, 1, -1, 0, 1);
class uZ extends Il {
  constructor(e = !1) {
    super();
    const i = e === !1 ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new ga([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new ga(i, 2));
  }
}
const cZ = /* @__PURE__ */ new uZ();
class KI extends El {
  constructor(e = null) {
    super(cZ, e), this.camera = iv, this.isQuadMesh = !0;
  }
  renderAsync(e) {
    return e.renderAsync(this, iv);
  }
  render(e) {
    e.render(this, iv);
  }
}
const Eh = /* @__PURE__ */ new Qn(), rv = /* @__PURE__ */ new gi();
class Br extends Mt {
  static get type() {
    return "SceneNode";
  }
  constructor(e = Br.BACKGROUND_BLURRINESS, i = null) {
    super(), this.scope = e, this.scene = i;
  }
  setup(e) {
    const i = this.scope, n = this.scene !== null ? this.scene : e.scene;
    let s;
    return i === Br.BACKGROUND_BLURRINESS ? s = bi("backgroundBlurriness", "float", n) : i === Br.BACKGROUND_INTENSITY ? s = bi("backgroundIntensity", "float", n) : i === Br.BACKGROUND_ROTATION ? s = _t("mat4").label("backgroundRotation").setGroup(kt).onRenderUpdate(() => {
      const a = n.background;
      return a !== null && a.isTexture && a.mapping !== o1 ? (Eh.copy(n.backgroundRotation), Eh.x *= -1, Eh.y *= -1, Eh.z *= -1, rv.makeRotationFromEuler(Eh)) : rv.identity(), rv;
    }) : console.error("THREE.SceneNode: Unknown scope:", i), s;
  }
}
Br.BACKGROUND_BLURRINESS = "backgroundBlurriness";
Br.BACKGROUND_INTENSITY = "backgroundIntensity";
Br.BACKGROUND_ROTATION = "backgroundRotation";
const hZ = /* @__PURE__ */ Ve(Br, Br.BACKGROUND_BLURRINESS), KM = /* @__PURE__ */ Ve(Br, Br.BACKGROUND_INTENSITY), dZ = /* @__PURE__ */ Ve(Br, Br.BACKGROUND_ROTATION), Bu = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
}, Zi = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
}, Qi = {
  Store: "store"
}, Oi = {
  Load: "load",
  Clear: "clear"
}, nv = {
  CCW: "ccw"
}, sv = {
  None: "none",
  Front: "front",
  Back: "back"
}, Mc = {
  Uint16: "uint16",
  Uint32: "uint32"
}, $ = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
}, av = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
}, Qo = {
  Linear: "linear",
  Nearest: "nearest"
}, yt = {
  Zero: "zero",
  One: "one",
  Src: "src",
  OneMinusSrc: "one-minus-src",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  Dst: "dst",
  OneMinusDstColor: "one-minus-dst",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  Constant: "constant",
  OneMinusConstant: "one-minus-constant"
}, Bo = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
}, ZM = {
  None: 0,
  All: 15
}, Ga = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
}, Lx = {
  Storage: "storage",
  ReadOnlyStorage: "read-only-storage"
}, QM = {
  WriteOnly: "write-only",
  ReadOnly: "read-only"
}, Mh = {
  Float: "float",
  UnfilterableFloat: "unfilterable-float",
  Depth: "depth",
  SInt: "sint",
  UInt: "uint"
}, JM = {
  TwoD: "2d",
  ThreeD: "3d"
}, gn = {
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  ThreeD: "3d"
}, pZ = {
  All: "all"
}, vf = {
  Vertex: "vertex",
  Instance: "instance"
}, kx = {
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable",
  ClipDistances: "clip-distances",
  DualSourceBlending: "dual-source-blending",
  Subgroups: "subgroups"
}, fZ = /* @__PURE__ */ new Vt();
class mZ extends rp {
  static get type() {
    return "PassTextureNode";
  }
  constructor(e, i) {
    super(i), this.passNode = e, this.setUpdateMatrix(!1);
  }
  setup(e) {
    return e.object.isQuadMesh && this.passNode.build(e), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
}
class eA extends mZ {
  static get type() {
    return "PassMultipleTextureNode";
  }
  constructor(e, i, n = !1) {
    super(e, null), this.textureName = i, this.previousTexture = n;
  }
  updateTexture() {
    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
  }
  setup(e) {
    return this.updateTexture(), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.textureName, this.previousTexture);
  }
}
class Hg extends zi {
  static get type() {
    return "PassNode";
  }
  constructor(e, i, n, s = {}) {
    super("vec4"), this.scope = e, this.scene = i, this.camera = n, this.options = s, this._pixelRatio = 1, this._width = 1, this._height = 1;
    const a = new Vc();
    a.isRenderTargetTexture = !0, a.name = "depth";
    const o = new jc(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: pa, ...s });
    o.texture.name = "output", o.depthTexture = a, this.renderTarget = o, this.updateBeforeType = Nt.FRAME, this._textures = {
      output: o.texture,
      depth: a
    }, this._textureNodes = {}, this._linearDepthNodes = {}, this._viewZNodes = {}, this._previousTextures = {}, this._previousTextureNodes = {}, this._cameraNear = _t(0), this._cameraFar = _t(0), this._mrt = null, this.isPassNode = !0;
  }
  setMRT(e) {
    return this._mrt = e, this;
  }
  getMRT() {
    return this._mrt;
  }
  isGlobal() {
    return !0;
  }
  getTexture(e) {
    let i = this._textures[e];
    return i === void 0 && (i = this.renderTarget.texture.clone(), i.isRenderTargetTexture = !0, i.name = e, this._textures[e] = i, this.renderTarget.textures.push(i)), i;
  }
  getPreviousTexture(e) {
    let i = this._previousTextures[e];
    return i === void 0 && (i = this.getTexture(e).clone(), i.isRenderTargetTexture = !0, this._previousTextures[e] = i), i;
  }
  toggleTexture(e) {
    const i = this._previousTextures[e];
    if (i !== void 0) {
      const n = this._textures[e], s = this.renderTarget.textures.indexOf(n);
      this.renderTarget.textures[s] = i, this._textures[e] = i, this._previousTextures[e] = n, this._textureNodes[e].updateTexture(), this._previousTextureNodes[e].updateTexture();
    }
  }
  getTextureNode(e = "output") {
    let i = this._textureNodes[e];
    return i === void 0 && (i = De(new eA(this, e)), i.updateTexture(), this._textureNodes[e] = i), i;
  }
  getPreviousTextureNode(e = "output") {
    let i = this._previousTextureNodes[e];
    return i === void 0 && (this._textureNodes[e] === void 0 && this.getTextureNode(e), i = De(new eA(this, e, !0)), i.updateTexture(), this._previousTextureNodes[e] = i), i;
  }
  getViewZNode(e = "depth") {
    let i = this._viewZNodes[e];
    if (i === void 0) {
      const n = this._cameraNear, s = this._cameraFar;
      this._viewZNodes[e] = i = RI(this.getTextureNode(e), n, s);
    }
    return i;
  }
  getLinearDepthNode(e = "depth") {
    let i = this._linearDepthNodes[e];
    if (i === void 0) {
      const n = this._cameraNear, s = this._cameraFar, a = this.getViewZNode(e);
      this._linearDepthNodes[e] = i = nd(a, n, s);
    }
    return i;
  }
  setup({ renderer: e }) {
    return this.renderTarget.samples = this.options.samples === void 0 ? e.samples : this.options.samples, e.backend.isWebGLBackend === !0 && (this.renderTarget.samples = 0), this.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1, this.scope === Hg.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
  }
  updateBefore(e) {
    const { renderer: i } = e, { scene: n, camera: s } = this;
    this._pixelRatio = i.getPixelRatio();
    const a = i.getSize(fZ);
    this.setSize(a.width, a.height);
    const o = i.getRenderTarget(), l = i.getMRT();
    this._cameraNear.value = s.near, this._cameraFar.value = s.far;
    for (const u in this._previousTextures)
      this.toggleTexture(u);
    i.setRenderTarget(this.renderTarget), i.setMRT(this._mrt), i.render(n, s), i.setRenderTarget(o), i.setMRT(l);
  }
  setSize(e, i) {
    this._width = e, this._height = i;
    const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget.setSize(n, s);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget.dispose();
  }
}
Hg.COLOR = "color";
Hg.DEPTH = "depth";
const gZ = /* @__PURE__ */ Fe(([r, e]) => r.mul(e).clamp()).setLayout({
  name: "linearToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), yZ = /* @__PURE__ */ Fe(([r, e]) => (r = r.mul(e), r.div(r.add(1)).clamp())).setLayout({
  name: "reinhardToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), vZ = /* @__PURE__ */ Fe(([r, e]) => {
  r = r.mul(e), r = r.sub(4e-3).max(0);
  const i = r.mul(r.mul(6.2).add(0.5)), n = r.mul(r.mul(6.2).add(1.7)).add(0.06);
  return i.div(n).pow(2.2);
}).setLayout({
  name: "cineonToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), bZ = /* @__PURE__ */ Fe(([r]) => {
  const e = r.mul(r.add(0.0245786)).sub(90537e-9), i = r.mul(r.add(0.432951).mul(0.983729)).add(0.238081);
  return e.div(i);
}), xZ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = Cr(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  ), n = Cr(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  return r = r.mul(e).div(0.6), r = i.mul(r), r = bZ(r), r = n.mul(r), r.clamp();
}).setLayout({
  name: "acesFilmicToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), _Z = /* @__PURE__ */ Cr(ye(1.6605, -0.1246, -0.0182), ye(-0.5876, 1.1329, -0.1006), ye(-0.0728, -83e-4, 1.1187)), TZ = /* @__PURE__ */ Cr(ye(0.6274, 0.0691, 0.0164), ye(0.3293, 0.9195, 0.088), ye(0.0433, 0.0113, 0.8956)), SZ = /* @__PURE__ */ Fe(([r]) => {
  const e = ye(r).toVar(), i = ye(e.mul(e)).toVar(), n = ye(i.mul(i)).toVar();
  return be(15.5).mul(n.mul(i)).sub(Dt(40.14, n.mul(e))).add(Dt(31.96, n).sub(Dt(6.868, i.mul(e))).add(Dt(0.4298, i).add(Dt(0.1191, e).sub(232e-5))));
}), wZ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = ye(r).toVar(), n = Cr(ye(0.856627153315983, 0.137318972929847, 0.11189821299995), ye(0.0951212405381588, 0.761241990602591, 0.0767994186031903), ye(0.0482516061458583, 0.101439036467562, 0.811302368396859)), s = Cr(ye(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), ye(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), ye(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405)), a = be(-12.47393), o = be(4.026069);
  return i.mulAssign(e), i.assign(TZ.mul(i)), i.assign(n.mul(i)), i.assign(Sn(i, 1e-10)), i.assign(ya(i)), i.assign(i.sub(a).div(o.sub(a))), i.assign(xa(i, 0, 1)), i.assign(SZ(i)), i.assign(s.mul(i)), i.assign(Ug(Sn(ye(0), i), ye(2.2))), i.assign(_Z.mul(i)), i.assign(xa(i, 0, 1)), i;
}).setLayout({
  name: "agxToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), EZ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = be(0.76), n = be(0.15);
  r = r.mul(e);
  const s = Sd(r.r, Sd(r.g, r.b)), a = Ur(s.lessThan(0.08), s.sub(Dt(6.25, s.mul(s))), 0.04);
  r.subAssign(a);
  const o = Sn(r.r, Sn(r.g, r.b));
  rr(o.lessThan(i), () => r);
  const l = sn(1, i), u = sn(1, l.mul(l).div(o.add(l.sub(i))));
  r.mulAssign(u.div(o));
  const c = sn(1, bo(1, n.mul(o.sub(u)).add(1)));
  return li(r, ye(u), c);
}).setLayout({
  name: "neutralToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
class pr extends Mt {
  static get type() {
    return "CodeNode";
  }
  constructor(e = "", i = [], n = "") {
    super("code"), this.isCodeNode = !0, this.code = e, this.language = n, this.includes = i;
  }
  isGlobal() {
    return !0;
  }
  setIncludes(e) {
    return this.includes = e, this;
  }
  getIncludes() {
    return this.includes;
  }
  generate(e) {
    const i = this.getIncludes(e);
    for (const s of i)
      s.build(e);
    const n = e.getCodeFromNode(this, this.getNodeType(e));
    return n.code = this.code, n.code;
  }
  serialize(e) {
    super.serialize(e), e.code = this.code, e.language = this.language;
  }
  deserialize(e) {
    super.deserialize(e), this.code = e.code, this.language = e.language;
  }
}
class MZ extends pr {
  static get type() {
    return "FunctionNode";
  }
  constructor(e = "", i = [], n = "") {
    super(e, i, n);
  }
  getNodeType(e) {
    return this.getNodeFunction(e).type;
  }
  getInputs(e) {
    return this.getNodeFunction(e).inputs;
  }
  getNodeFunction(e) {
    const i = e.getDataFromNode(this);
    let n = i.nodeFunction;
    return n === void 0 && (n = e.parser.parseFunction(this.code), i.nodeFunction = n), n;
  }
  generate(e, i) {
    super.generate(e);
    const n = this.getNodeFunction(e), s = n.name, a = n.type, o = e.getCodeFromNode(this, a);
    s !== "" && (o.name = s);
    const l = e.getPropertyName(o), u = this.getNodeFunction(e).getCode(l);
    return o.code = u + `
`, i === "property" ? l : e.format(`${l}()`, a, i);
  }
}
class ZI extends Mt {
  static get type() {
    return "FogNode";
  }
  constructor(e, i) {
    super("float"), this.isFogNode = !0, this.colorNode = e, this.factorNode = i;
  }
  getViewZNode(e) {
    let i;
    const n = e.context.getViewZ;
    return n !== void 0 && (i = n(this)), (i || ir.z).negate();
  }
  setup() {
    return this.factorNode;
  }
}
class AZ extends ZI {
  static get type() {
    return "FogRangeNode";
  }
  constructor(e, i, n) {
    super(e), this.isFogRangeNode = !0, this.nearNode = i, this.farNode = n;
  }
  setup(e) {
    const i = this.getViewZNode(e);
    return Ml(this.nearNode, this.farNode, i);
  }
}
const CZ = /* @__PURE__ */ Ae(AZ);
class RZ extends ZI {
  static get type() {
    return "FogExp2Node";
  }
  constructor(e, i) {
    super(e), this.isFogExp2Node = !0, this.densityNode = i;
  }
  setup(e) {
    const i = this.getViewZNode(e), n = this.densityNode;
    return n.mul(n, i, i).negate().exp().oneMinus();
  }
}
const NZ = /* @__PURE__ */ Ae(RZ);
class PZ extends Mt {
  constructor(e) {
    super(), this.scope = e;
  }
  generate(e) {
    const { scope: i } = this, { renderer: n } = e;
    n.backend.isWebGLBackend === !0 ? e.addFlowCode(`	// ${i}Barrier 
`) : e.addLineFlowCode(`${i}Barrier()`, this);
  }
}
Ae(PZ);
class ws extends zi {
  static get type() {
    return "AtomicFunctionNode";
  }
  constructor(e, i, n, s = null) {
    super("uint"), this.method = e, this.pointerNode = i, this.valueNode = n, this.storeNode = s;
  }
  getInputType(e) {
    return this.pointerNode.getNodeType(e);
  }
  getNodeType(e) {
    return this.getInputType(e);
  }
  generate(e) {
    const i = this.method, n = this.getNodeType(e), s = this.getInputType(e), a = this.pointerNode, o = this.valueNode, l = [];
    l.push(`&${a.build(e, s)}`), l.push(o.build(e, s));
    const u = `${e.getMethod(i, n)}( ${l.join(", ")} )`;
    if (this.storeNode !== null) {
      const c = this.storeNode.build(e, s);
      e.addLineFlowCode(`${c} = ${u}`, this);
    } else
      e.addLineFlowCode(u, this);
  }
}
ws.ATOMIC_LOAD = "atomicLoad";
ws.ATOMIC_STORE = "atomicStore";
ws.ATOMIC_ADD = "atomicAdd";
ws.ATOMIC_SUB = "atomicSub";
ws.ATOMIC_MAX = "atomicMax";
ws.ATOMIC_MIN = "atomicMin";
ws.ATOMIC_AND = "atomicAnd";
ws.ATOMIC_OR = "atomicOr";
ws.ATOMIC_XOR = "atomicXor";
Ae(ws);
let bf;
function H1(r) {
  bf = bf || /* @__PURE__ */ new WeakMap();
  let e = bf.get(r);
  return e === void 0 && bf.set(r, e = {}), e;
}
function QI(r) {
  const e = H1(r);
  return e.position || (e.position = _t(new ue()).setGroup(kt).onRenderUpdate((i, n) => n.value.setFromMatrixPosition(r.matrixWorld)));
}
function IZ(r) {
  const e = H1(r);
  return e.targetPosition || (e.targetPosition = _t(new ue()).setGroup(kt).onRenderUpdate((i, n) => n.value.setFromMatrixPosition(r.target.matrixWorld)));
}
function W1(r) {
  const e = H1(r);
  return e.viewPosition || (e.viewPosition = _t(new ue()).setGroup(kt).onRenderUpdate(({ camera: i }, n) => {
    n.value = n.value || new ue(), n.value.setFromMatrixPosition(r.matrixWorld), n.value.applyMatrix4(i.matrixWorldInverse);
  }));
}
const JI = (r) => Ma.transformDirection(QI(r).sub(IZ(r))), OZ = (r) => r.sort((e, i) => e.id - i.id), DZ = (r, e) => {
  for (const i of e)
    if (i.isAnalyticLightNode && i.light.id === r)
      return i;
  return null;
}, ov = /* @__PURE__ */ new WeakMap();
class e3 extends Mt {
  static get type() {
    return "LightsNode";
  }
  constructor() {
    super("vec3"), this.totalDiffuseNode = ye().toVar("totalDiffuse"), this.totalSpecularNode = ye().toVar("totalSpecular"), this.outgoingLightNode = ye().toVar("outgoingLight"), this._lights = [], this._lightNodes = null, this._lightNodesHash = null, this.global = !0;
  }
  getHash(e) {
    if (this._lightNodesHash === null) {
      this._lightNodes === null && this.setupLightsNode(e);
      const i = [];
      for (const n of this._lightNodes)
        i.push(n.getSelf().getHash());
      this._lightNodesHash = "lights-" + i.join(",");
    }
    return this._lightNodesHash;
  }
  analyze(e) {
    const i = e.getDataFromNode(this);
    for (const n of i.nodes)
      n.build(e);
  }
  setupLightsNode(e) {
    const i = [], n = this._lightNodes, s = OZ(this._lights), a = e.renderer.library;
    for (const o of s)
      if (o.isNode)
        i.push(De(o));
      else {
        let l = null;
        if (n !== null && (l = DZ(o.id, n)), l === null) {
          const u = a.getLightNodeClass(o.constructor);
          if (u === null) {
            console.warn(`LightsNode.setupNodeLights: Light node not found for ${o.constructor.name}`);
            continue;
          }
          let c = null;
          ov.has(o) ? c = ov.get(o) : (c = De(new u(o)), ov.set(o, c)), i.push(c);
        }
      }
    this._lightNodes = i;
  }
  setupLights(e, i) {
    for (const n of i)
      n.build(e);
  }
  setup(e) {
    this._lightNodes === null && this.setupLightsNode(e);
    const i = e.context, n = i.lightingModel;
    let s = this.outgoingLightNode;
    if (n) {
      const { _lightNodes: a, totalDiffuseNode: o, totalSpecularNode: l } = this;
      i.outgoingLight = s;
      const u = e.addStack(), c = e.getDataFromNode(this);
      c.nodes = u.nodes, n.start(i, u, e), this.setupLights(e, a), n.indirect(i, u, e);
      const { backdrop: h, backdropAlpha: d } = i, { directDiffuse: p, directSpecular: f, indirectDiffuse: m, indirectSpecular: y } = i.reflectedLight;
      let v = p.add(m);
      h !== null && (d !== null ? v = ye(d.mix(v, h)) : v = ye(h), i.material.transparent = !0), o.assign(v), l.assign(f.add(y)), s.assign(o.add(l)), n.finish(i, u, e), s = s.bypass(e.removeStack());
    }
    return s;
  }
  setLights(e) {
    return this._lights = e, this._lightNodes = null, this._lightNodesHash = null, this;
  }
  getLights() {
    return this._lights;
  }
  get hasLights() {
    return this._lights.length > 0;
  }
}
const LZ = Fe(({ depthTexture: r, shadowCoord: e }) => Ci(r, e.xy).compare(e.z)), kZ = Fe(({ depthTexture: r, shadowCoord: e, shadow: i }) => {
  const n = (y, v) => Ci(r, y).compare(v), s = bi("mapSize", "vec2", i).setGroup(kt), a = bi("radius", "float", i).setGroup(kt), o = He(1).div(s), l = o.x.negate().mul(a), u = o.y.negate().mul(a), c = o.x.mul(a), h = o.y.mul(a), d = l.div(2), p = u.div(2), f = c.div(2), m = h.div(2);
  return Rr(
    n(e.xy.add(He(l, u)), e.z),
    n(e.xy.add(He(0, u)), e.z),
    n(e.xy.add(He(c, u)), e.z),
    n(e.xy.add(He(d, p)), e.z),
    n(e.xy.add(He(0, p)), e.z),
    n(e.xy.add(He(f, p)), e.z),
    n(e.xy.add(He(l, 0)), e.z),
    n(e.xy.add(He(d, 0)), e.z),
    n(e.xy, e.z),
    n(e.xy.add(He(f, 0)), e.z),
    n(e.xy.add(He(c, 0)), e.z),
    n(e.xy.add(He(d, m)), e.z),
    n(e.xy.add(He(0, m)), e.z),
    n(e.xy.add(He(f, m)), e.z),
    n(e.xy.add(He(l, h)), e.z),
    n(e.xy.add(He(0, h)), e.z),
    n(e.xy.add(He(c, h)), e.z)
  ).mul(1 / 17);
}), UZ = Fe(({ depthTexture: r, shadowCoord: e, shadow: i }) => {
  const n = (h, d) => Ci(r, h).compare(d), s = bi("mapSize", "vec2", i).setGroup(kt), a = He(1).div(s), o = a.x, l = a.y, u = e.xy, c = To(u.mul(s).add(0.5));
  return u.subAssign(c.mul(a)), Rr(
    n(u, e.z),
    n(u.add(He(o, 0)), e.z),
    n(u.add(He(0, l)), e.z),
    n(u.add(a), e.z),
    li(
      n(u.add(He(o.negate(), 0)), e.z),
      n(u.add(He(o.mul(2), 0)), e.z),
      c.x
    ),
    li(
      n(u.add(He(o.negate(), l)), e.z),
      n(u.add(He(o.mul(2), l)), e.z),
      c.x
    ),
    li(
      n(u.add(He(0, l.negate())), e.z),
      n(u.add(He(0, l.mul(2))), e.z),
      c.y
    ),
    li(
      n(u.add(He(o, l.negate())), e.z),
      n(u.add(He(o, l.mul(2))), e.z),
      c.y
    ),
    li(
      li(
        n(u.add(He(o.negate(), l.negate())), e.z),
        n(u.add(He(o.mul(2), l.negate())), e.z),
        c.x
      ),
      li(
        n(u.add(He(o.negate(), l.mul(2))), e.z),
        n(u.add(He(o.mul(2), l.mul(2))), e.z),
        c.x
      ),
      c.y
    )
  ).mul(1 / 9);
}), FZ = Fe(({ depthTexture: r, shadowCoord: e }) => {
  const i = be(1).toVar(), n = Ci(r).uv(e.xy).rg, s = oI(e.z, n.x);
  return rr(s.notEqual(be(1)), () => {
    const a = e.z.sub(n.x), o = Sn(0, n.y.mul(n.y));
    let l = o.div(o.add(a.mul(a)));
    l = xa(sn(l, 0.3).div(0.95 - 0.3)), i.assign(xa(Sn(s, l)));
  }), i;
}), BZ = Fe(({ samples: r, radius: e, size: i, shadowPass: n }) => {
  const s = be(0).toVar(), a = be(0).toVar(), o = r.lessThanEqual(be(1)).select(be(0), be(2).div(r.sub(1))), l = r.lessThanEqual(be(1)).select(be(0), be(-1));
  ps({ start: Mi(0), end: Mi(r), type: "int", condition: "<" }, ({ i: c }) => {
    const h = l.add(be(c).mul(o)), d = n.uv(Rr(j1.xy, He(0, h).mul(e)).div(i)).x;
    s.addAssign(d), a.addAssign(d.mul(d));
  }), s.divAssign(r), a.divAssign(r);
  const u = N1(a.sub(s.mul(s)));
  return He(s, u);
}), zZ = Fe(({ samples: r, radius: e, size: i, shadowPass: n }) => {
  const s = be(0).toVar(), a = be(0).toVar(), o = r.lessThanEqual(be(1)).select(be(0), be(2).div(r.sub(1))), l = r.lessThanEqual(be(1)).select(be(0), be(-1));
  ps({ start: Mi(0), end: Mi(r), type: "int", condition: "<" }, ({ i: c }) => {
    const h = l.add(be(c).mul(o)), d = n.uv(Rr(j1.xy, He(h, 0).mul(e)).div(i));
    s.addAssign(d.x), a.addAssign(Rr(d.y.mul(d.y), d.x.mul(d.x)));
  }), s.divAssign(r), a.divAssign(r);
  const u = N1(a.sub(s.mul(s)));
  return He(s, u);
}), jZ = [LZ, kZ, UZ, FZ];
let xu = null;
const xf = /* @__PURE__ */ new KI();
class VZ extends Mt {
  static get type() {
    return "ShadowNode";
  }
  constructor(e, i = null) {
    super(), this.light = e, this.shadow = i || e.shadow, this.shadowMap = null, this.vsmShadowMapVertical = null, this.vsmShadowMapHorizontal = null, this.vsmMaterialVertical = null, this.vsmMaterialHorizontal = null, this.updateBeforeType = Nt.RENDER, this._node = null, this.isShadowNode = !0;
  }
  setupShadow(e) {
    const { object: i, renderer: n } = e;
    xu === null && (xu = new Bi(), xu.fragmentNode = xt(0, 0, 0, 1), xu.isShadowNodeMaterial = !0, xu.name = "ShadowMaterial");
    const s = this.shadow, a = n.shadowMap.type, o = new Vc(s.mapSize.width, s.mapSize.height);
    o.compareFunction = p1;
    const l = e.createRenderTarget(s.mapSize.width, s.mapSize.height);
    if (l.depthTexture = o, s.camera.updateProjectionMatrix(), a === $p) {
      o.compareFunction = null, this.vsmShadowMapVertical = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: yd, type: pa }), this.vsmShadowMapHorizontal = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: yd, type: pa });
      const _ = Ci(o), x = Ci(this.vsmShadowMapVertical.texture), b = bi("blurSamples", "float", s).setGroup(kt), T = bi("radius", "float", s).setGroup(kt), S = bi("mapSize", "vec2", s).setGroup(kt);
      let w = this.vsmMaterialVertical || (this.vsmMaterialVertical = new Bi());
      w.fragmentNode = BZ({ samples: b, radius: T, size: S, shadowPass: _ }).context(e.getSharedContext()), w.name = "VSMVertical", w = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new Bi()), w.fragmentNode = zZ({ samples: b, radius: T, size: S, shadowPass: x }).context(e.getSharedContext()), w.name = "VSMHorizontal";
    }
    const u = bi("intensity", "float", s).setGroup(kt), c = bi("bias", "float", s).setGroup(kt), h = bi("normalBias", "float", s).setGroup(kt), d = i.material.shadowPositionNode || Ax;
    let p = _t(s.matrix).setGroup(kt).mul(d.add(k1.mul(h))), f;
    if (s.camera.isOrthographicCamera || n.logarithmicDepthBuffer !== !0)
      p = p.xyz.div(p.w), f = p.z, n.coordinateSystem === wl && (f = f.mul(2).sub(1));
    else {
      const _ = p.w;
      p = p.xy.div(_);
      const x = _t("float").onRenderUpdate(() => s.camera.near), b = _t("float").onRenderUpdate(() => s.camera.far);
      f = NI(_, x, b);
    }
    p = ye(
      p.x,
      p.y.oneMinus(),
      // follow webgpu standards
      f.add(c)
    );
    const m = p.x.greaterThanEqual(0).and(p.x.lessThanEqual(1)).and(p.y.greaterThanEqual(0)).and(p.y.lessThanEqual(1)).and(p.z.lessThanEqual(1)), y = s.filterNode || jZ[n.shadowMap.type] || null;
    if (y === null)
      throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
    const v = Ci(l.texture, p), g = m.select(y({ depthTexture: a === $p ? this.vsmShadowMapHorizontal.texture : o, shadowCoord: p, shadow: s }), be(1));
    return this.shadowMap = l, this.shadow.map = l, li(1, g.rgb.mix(v, 1), u.mul(v.a));
  }
  setup(e) {
    if (e.renderer.shadowMap.enabled !== !1)
      return this._node !== null ? this._node : this._node = this.setupShadow(e);
  }
  updateShadow(e) {
    const { shadowMap: i, light: n, shadow: s } = this, { renderer: a, scene: o, camera: l } = e, u = a.shadowMap.type, c = i.depthTexture.version;
    this._depthVersionCached = c;
    const h = o.overrideMaterial;
    o.overrideMaterial = xu, i.setSize(s.mapSize.width, s.mapSize.height), s.updateMatrices(n), s.camera.layers.mask = l.layers.mask;
    const d = a.getRenderTarget(), p = a.getRenderObjectFunction();
    a.setRenderObjectFunction((f, ...m) => {
      (f.castShadow === !0 || f.receiveShadow && u === $p) && a.renderObject(f, ...m);
    }), a.setRenderTarget(i), a.render(o, s.camera), a.setRenderObjectFunction(p), n.isPointLight !== !0 && u === $p && this.vsmPass(a), a.setRenderTarget(d), o.overrideMaterial = h;
  }
  vsmPass(e) {
    const { shadow: i } = this;
    this.vsmShadowMapVertical.setSize(i.mapSize.width, i.mapSize.height), this.vsmShadowMapHorizontal.setSize(i.mapSize.width, i.mapSize.height), e.setRenderTarget(this.vsmShadowMapVertical), xf.material = this.vsmMaterialVertical, xf.render(e), e.setRenderTarget(this.vsmShadowMapHorizontal), xf.material = this.vsmMaterialHorizontal, xf.render(e);
  }
  dispose() {
    this.shadowMap.dispose(), this.shadowMap = null, this.vsmShadowMapVertical !== null && (this.vsmShadowMapVertical.dispose(), this.vsmShadowMapVertical = null, this.vsmMaterialVertical.dispose(), this.vsmMaterialVertical = null), this.vsmShadowMapHorizontal !== null && (this.vsmShadowMapHorizontal.dispose(), this.vsmShadowMapHorizontal = null, this.vsmMaterialHorizontal.dispose(), this.vsmMaterialHorizontal = null), this.updateBeforeType = Nt.NONE;
  }
  updateBefore(e) {
    const { shadow: i } = this;
    (i.needsUpdate || i.autoUpdate) && (this.updateShadow(e), this.shadowMap.depthTexture.version === this._depthVersionCached && (i.needsUpdate = !1));
  }
}
const GZ = (r, e) => De(new VZ(r, e));
class Dl extends Hc {
  static get type() {
    return "AnalyticLightNode";
  }
  constructor(e = null) {
    super(), this.updateType = Nt.FRAME, this.light = e, this.color = new Kt(), this.colorNode = _t(this.color).setGroup(kt), this.baseColorNode = null, this.shadowNode = null, this.shadowColorNode = null, this.isAnalyticLightNode = !0;
  }
  getCacheKey() {
    return zm(super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0);
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(e) {
    const { renderer: i } = e;
    if (i.shadowMap.enabled === !1) return;
    let n = this.shadowColorNode;
    if (n === null) {
      const s = this.light.shadow.shadowNode;
      let a;
      s !== void 0 ? a = De(s) : a = GZ(this.light), this.shadowNode = a, this.shadowColorNode = n = this.colorNode.mul(a), this.baseColorNode = this.colorNode;
    }
    this.colorNode = n;
  }
  setup(e) {
    this.colorNode = this.baseColorNode || this.colorNode, this.light.castShadow ? e.object.receiveShadow && this.setupShadow(e) : this.shadowNode !== null && this.shadowNode.dispose();
  }
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
const t3 = /* @__PURE__ */ Fe((r) => {
  const { lightDistance: e, cutoffDistance: i, decayExponent: n } = r, s = e.pow(n).max(0.01).reciprocal();
  return i.greaterThan(0).select(
    s.mul(e.div(i).pow4().oneMinus().clamp().pow2()),
    s
  );
}), HZ = Fe(({ color: r, lightViewPosition: e, cutoffDistance: i, decayExponent: n }, s) => {
  const a = s.context.lightingModel, o = e.sub(ir), l = o.normalize(), u = o.length(), c = t3({
    lightDistance: u,
    cutoffDistance: i,
    decayExponent: n
  }), h = r.mul(c), d = s.context.reflectedLight;
  a.direct({
    lightDirection: l,
    lightColor: h,
    reflectedLight: d
  }, s.stack, s);
});
class WZ extends Dl {
  static get type() {
    return "PointLightNode";
  }
  constructor(e = null) {
    super(e), this.cutoffDistanceNode = _t(0).setGroup(kt), this.decayExponentNode = _t(0).setGroup(kt);
  }
  update(e) {
    const { light: i } = this;
    super.update(e), this.cutoffDistanceNode.value = i.distance, this.decayExponentNode.value = i.decay;
  }
  setup() {
    HZ({
      color: this.colorNode,
      lightViewPosition: W1(this.light),
      cutoffDistance: this.cutoffDistanceNode,
      decayExponent: this.decayExponentNode
    }).append();
  }
}
const qZ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = r.x, n = r.y, s = r.z;
  let a = e.element(0).mul(0.886227);
  return a = a.add(e.element(1).mul(2 * 0.511664).mul(n)), a = a.add(e.element(2).mul(2 * 0.511664).mul(s)), a = a.add(e.element(3).mul(2 * 0.511664).mul(i)), a = a.add(e.element(4).mul(2 * 0.429043).mul(i).mul(n)), a = a.add(e.element(5).mul(2 * 0.429043).mul(n).mul(s)), a = a.add(e.element(6).mul(s.mul(s).mul(0.743125).sub(0.247708))), a = a.add(e.element(7).mul(2 * 0.429043).mul(i).mul(s)), a = a.add(e.element(8).mul(0.429043).mul(Dt(i, i).sub(Dt(n, n)))), a;
}), Fs = /* @__PURE__ */ new G1();
class XZ extends So {
  constructor(e, i) {
    super(), this.renderer = e, this.nodes = i;
  }
  update(e, i, n) {
    const s = this.renderer, a = this.nodes.getBackgroundNode(e) || e.background;
    let o = !1;
    if (a === null)
      s._clearColor.getRGB(Fs, po), Fs.a = s._clearColor.a;
    else if (a.isColor === !0)
      a.getRGB(Fs, po), Fs.a = 1, o = !0;
    else if (a.isNode === !0) {
      const l = this.get(e), u = a;
      Fs.copy(s._clearColor);
      let c = l.backgroundMesh;
      if (c === void 0) {
        const d = O1(xt(u).mul(KM), {
          // @TODO: Add Texture2D support using node context
          getUV: () => dZ.mul(bI),
          getTextureLevel: () => hZ
        });
        let p = Cx();
        p = p.setZ(p.w);
        const f = new Bi();
        f.name = "Background.material", f.side = Zn, f.depthTest = !1, f.depthWrite = !1, f.fog = !1, f.lights = !1, f.vertexNode = p, f.colorNode = d, l.backgroundMeshNode = d, l.backgroundMesh = c = new El(new b1(1, 32, 32), f), c.frustumCulled = !1, c.name = "Background.mesh", c.onBeforeRender = function(m, y, v) {
          this.matrixWorld.copyPosition(v.matrixWorld);
        };
      }
      const h = u.getCacheKey();
      l.backgroundCacheKey !== h && (l.backgroundMeshNode.node = xt(u).mul(KM), l.backgroundMeshNode.needsUpdate = !0, c.material.needsUpdate = !0, l.backgroundCacheKey = h), i.unshift(c, c.geometry, c.material, 0, 0, null);
    } else
      console.error("THREE.Renderer: Unsupported background configuration.", a);
    if (s.autoClear === !0 || o === !0) {
      const l = n.clearColorValue;
      l.r = Fs.r, l.g = Fs.g, l.b = Fs.b, l.a = Fs.a, (s.backend.isWebGLBackend === !0 || s.alpha === !0) && (l.r *= l.a, l.g *= l.a, l.b *= l.a), n.depthClearValue = s._clearDepth, n.stencilClearValue = s._clearStencil, n.clearColor = s.autoClearColor === !0, n.clearDepth = s.autoClearDepth === !0, n.clearStencil = s.autoClearStencil === !0;
    } else
      n.clearColor = !1, n.clearDepth = !1, n.clearStencil = !1;
  }
}
let $Z = 0;
class Ux {
  constructor(e = "", i = [], n = 0, s = []) {
    this.name = e, this.bindings = i, this.index = n, this.bindingsReference = s, this.id = $Z++;
  }
}
class YZ {
  constructor(e, i, n, s, a, o, l, u, c, h = []) {
    this.vertexShader = e, this.fragmentShader = i, this.computeShader = n, this.transforms = h, this.nodeAttributes = s, this.bindings = a, this.updateNodes = o, this.updateBeforeNodes = l, this.updateAfterNodes = u, this.monitor = c, this.usedTimes = 0;
  }
  createBindings() {
    const e = [];
    for (const i of this.bindings)
      if (i.bindings[0].groupNode.shared !== !0) {
        const n = new Ux(i.name, [], i.index, i);
        e.push(n);
        for (const s of i.bindings)
          n.bindings.push(s.clone());
      } else
        e.push(i);
    return e;
  }
}
class tA {
  constructor(e, i, n = null) {
    this.isNodeAttribute = !0, this.name = e, this.type = i, this.node = n;
  }
}
class KZ {
  constructor(e, i, n) {
    this.isNodeUniform = !0, this.name = e, this.type = i, this.node = n.getSelf();
  }
  get value() {
    return this.node.value;
  }
  set value(e) {
    this.node.value = e;
  }
  get id() {
    return this.node.id;
  }
  get groupNode() {
    return this.node.groupNode;
  }
}
class i3 {
  constructor(e, i) {
    this.isNodeVar = !0, this.name = e, this.type = i;
  }
}
class ZZ extends i3 {
  constructor(e, i) {
    super(e, i), this.needsInterpolation = !1, this.isNodeVarying = !0;
  }
}
class QZ {
  constructor(e, i, n = "") {
    this.name = e, this.type = i, this.code = n, Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
}
let JZ = 0;
class lv {
  constructor(e = null) {
    this.id = JZ++, this.nodesData = /* @__PURE__ */ new WeakMap(), this.parent = e;
  }
  getData(e) {
    let i = this.nodesData.get(e);
    return i === void 0 && this.parent !== null && (i = this.parent.getData(e)), i;
  }
  setData(e, i) {
    this.nodesData.set(e, i);
  }
}
class Ll {
  constructor(e, i) {
    this.name = e, this.value = i, this.boundary = 0, this.itemSize = 0, this.offset = 0;
  }
  setValue(e) {
    this.value = e;
  }
  getValue() {
    return this.value;
  }
}
class eQ extends Ll {
  constructor(e, i = 0) {
    super(e, i), this.isNumberUniform = !0, this.boundary = 4, this.itemSize = 1;
  }
}
class tQ extends Ll {
  constructor(e, i = new Vt()) {
    super(e, i), this.isVector2Uniform = !0, this.boundary = 8, this.itemSize = 2;
  }
}
class iQ extends Ll {
  constructor(e, i = new ue()) {
    super(e, i), this.isVector3Uniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class rQ extends Ll {
  constructor(e, i = new Yt()) {
    super(e, i), this.isVector4Uniform = !0, this.boundary = 16, this.itemSize = 4;
  }
}
class nQ extends Ll {
  constructor(e, i = new Kt()) {
    super(e, i), this.isColorUniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class sQ extends Ll {
  constructor(e, i = new qr()) {
    super(e, i), this.isMatrix3Uniform = !0, this.boundary = 48, this.itemSize = 12;
  }
}
class aQ extends Ll {
  constructor(e, i = new gi()) {
    super(e, i), this.isMatrix4Uniform = !0, this.boundary = 64, this.itemSize = 16;
  }
}
class oQ extends eQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class lQ extends tQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class uQ extends iQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class cQ extends rQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class hQ extends nQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class dQ extends sQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class pQ extends aQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
const zu = 4, iA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Jo = 20, uv = /* @__PURE__ */ new T1(-1, 1, 1, -1, 0, 1), fQ = /* @__PURE__ */ new $s(90, 1), rA = /* @__PURE__ */ new Kt();
let cv = null, hv = 0, dv = 0;
const Wo = (1 + Math.sqrt(5)) / 2, _u = 1 / Wo, nA = [
  /* @__PURE__ */ new ue(-Wo, _u, 0),
  /* @__PURE__ */ new ue(Wo, _u, 0),
  /* @__PURE__ */ new ue(-_u, 0, Wo),
  /* @__PURE__ */ new ue(_u, 0, Wo),
  /* @__PURE__ */ new ue(0, Wo, -_u),
  /* @__PURE__ */ new ue(0, Wo, _u),
  /* @__PURE__ */ new ue(-1, 1, -1),
  /* @__PURE__ */ new ue(1, 1, -1),
  /* @__PURE__ */ new ue(-1, 1, 1),
  /* @__PURE__ */ new ue(1, 1, 1)
], mQ = [
  3,
  1,
  5,
  0,
  4,
  2
], pv = aK(Bg(), _a("faceIndex")).normalize(), q1 = ye(pv.x, pv.y.negate(), pv.z);
class gQ {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._lodMeshes = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._backgroundBox = null;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, i = 0, n = 0.1, s = 100) {
    cv = this._renderer.getRenderTarget(), hv = this._renderer.getActiveCubeFace(), dv = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const a = this._allocateTargets();
    return a.depthBuffer = !0, this._sceneToCubeUV(e, n, s, a), i > 0 && this._blur(a, 0, 0, i), this._applyPMREM(a), this._cleanup(a), a;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, i = null) {
    return this._fromTexture(e, i);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, i = null) {
    return this._fromTexture(e, i);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  async compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = aA(), await this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  async compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = oA(), await this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose(), this._backgroundBox !== null && (this._backgroundBox.geometry.dispose(), this._backgroundBox.material.dispose());
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(cv, hv, dv), e.scissorTest = !1, _f(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, i) {
    e.mapping === Tl || e.mapping === _c ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), cv = this._renderer.getRenderTarget(), hv = this._renderer.getActiveCubeFace(), dv = this._renderer.getActiveMipmapLevel();
    const n = i || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), i = 4 * this._cubeSize, n = {
      magFilter: on,
      minFilter: on,
      generateMipmaps: !1,
      type: pa,
      format: Bc,
      colorSpace: po
      //depthBuffer: false
    }, s = sA(e, i, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== i) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = sA(e, i, n);
      const { _lodMax: a } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = yQ(a)), this._blurMaterial = vQ(a, e, i);
    }
    return s;
  }
  async _compileMaterial(e) {
    const i = new El(this._lodPlanes[0], e);
    await this._renderer.compile(i, uv);
  }
  _sceneToCubeUV(e, i, n, s) {
    const a = fQ;
    a.near = i, a.far = n;
    const o = [-1, 1, -1, -1, -1, -1], l = [1, 1, 1, -1, -1, -1], u = this._renderer, c = u.autoClear;
    u.getClearColor(rA), u.autoClear = !1;
    let h = this._backgroundBox;
    if (h === null) {
      const f = new Og({
        name: "PMREM.Background",
        side: Zn,
        depthWrite: !1,
        depthTest: !1
      });
      h = new El(new Jd(), f);
    }
    let d = !1;
    const p = e.background;
    p ? p.isColor && (h.material.color.copy(p), e.background = null, d = !0) : (h.material.color.copy(rA), d = !0), u.setRenderTarget(s), u.clear(), d && u.render(h, a);
    for (let f = 0; f < 6; f++) {
      const m = f % 3;
      m === 0 ? (a.up.set(0, o[f], 0), a.lookAt(l[f], 0, 0)) : m === 1 ? (a.up.set(0, 0, o[f]), a.lookAt(0, l[f], 0)) : (a.up.set(0, o[f], 0), a.lookAt(0, 0, l[f]));
      const y = this._cubeSize;
      _f(s, m * y, f > 2 ? y : 0, y, y), u.render(e, a);
    }
    u.autoClear = c, e.background = p;
  }
  _textureToCubeUV(e, i) {
    const n = this._renderer, s = e.mapping === Tl || e.mapping === _c;
    s ? this._cubemapMaterial === null && (this._cubemapMaterial = aA(e)) : this._equirectMaterial === null && (this._equirectMaterial = oA(e));
    const a = s ? this._cubemapMaterial : this._equirectMaterial;
    a.fragmentNode.value = e;
    const o = this._lodMeshes[0];
    o.material = a;
    const l = this._cubeSize;
    _f(i, 0, 0, 3 * l, 2 * l), n.setRenderTarget(i), n.render(o, uv);
  }
  _applyPMREM(e) {
    const i = this._renderer, n = i.autoClear;
    i.autoClear = !1;
    const s = this._lodPlanes.length;
    for (let a = 1; a < s; a++) {
      const o = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1]), l = nA[(s - a - 1) % nA.length];
      this._blur(e, a - 1, a, o, l);
    }
    i.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, i, n, s, a) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      i,
      n,
      s,
      "latitudinal",
      a
    ), this._halfBlur(
      o,
      e,
      n,
      n,
      s,
      "longitudinal",
      a
    );
  }
  _halfBlur(e, i, n, s, a, o, l) {
    const u = this._renderer, c = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const h = 3, d = this._lodMeshes[s];
    d.material = c;
    const p = c.uniforms, f = this._sizeLods[n] - 1, m = isFinite(a) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * Jo - 1), y = a / m, v = isFinite(a) ? 1 + Math.floor(h * y) : Jo;
    v > Jo && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Jo}`);
    const g = [];
    let _ = 0;
    for (let w = 0; w < Jo; ++w) {
      const M = w / y, E = Math.exp(-M * M / 2);
      g.push(E), w === 0 ? _ += E : w < v && (_ += 2 * E);
    }
    for (let w = 0; w < g.length; w++)
      g[w] = g[w] / _;
    e.texture.frame = (e.texture.frame || 0) + 1, p.envMap.value = e.texture, p.samples.value = v, p.weights.array = g, p.latitudinal.value = o === "latitudinal" ? 1 : 0, l && (p.poleAxis.value = l);
    const { _lodMax: x } = this;
    p.dTheta.value = m, p.mipInt.value = x - n;
    const b = this._sizeLods[s], T = 3 * b * (s > x - zu ? s - x + zu : 0), S = 4 * (this._cubeSize - b);
    _f(i, T, S, 3 * b, 2 * b), u.setRenderTarget(i), u.render(d, uv);
  }
}
function yQ(r) {
  const e = [], i = [], n = [], s = [];
  let a = r;
  const o = r - zu + 1 + iA.length;
  for (let l = 0; l < o; l++) {
    const u = Math.pow(2, a);
    i.push(u);
    let c = 1 / u;
    l > r - zu ? c = iA[l - r + zu - 1] : l === 0 && (c = 0), n.push(c);
    const h = 1 / (u - 2), d = -h, p = 1 + h, f = [d, d, p, d, p, p, d, d, p, p, d, p], m = 6, y = 6, v = 3, g = 2, _ = 1, x = new Float32Array(v * y * m), b = new Float32Array(g * y * m), T = new Float32Array(_ * y * m);
    for (let w = 0; w < m; w++) {
      const M = w % 3 * 2 / 3 - 1, E = w > 2 ? 0 : -1, A = [
        M,
        E,
        0,
        M + 2 / 3,
        E,
        0,
        M + 2 / 3,
        E + 1,
        0,
        M,
        E,
        0,
        M + 2 / 3,
        E + 1,
        0,
        M,
        E + 1,
        0
      ], N = mQ[w];
      x.set(A, v * y * N), b.set(f, g * y * N);
      const U = [N, N, N, N, N, N];
      T.set(U, _ * y * N);
    }
    const S = new Il();
    S.setAttribute("position", new _n(x, v)), S.setAttribute("uv", new _n(b, g)), S.setAttribute("faceIndex", new _n(T, _)), e.push(S), s.push(new El(S, null)), a > zu && a--;
  }
  return { lodPlanes: e, sizeLods: i, sigmas: n, lodMeshes: s };
}
function sA(r, e, i) {
  const n = new jc(r, e, i);
  return n.texture.mapping = tx, n.texture.name = "PMREM.cubeUv", n.texture.isPMREMTexture = !0, n.scissorTest = !0, n;
}
function _f(r, e, i, n, s) {
  r.viewport.set(e, i, n, s), r.scissor.set(e, i, n, s);
}
function X1(r) {
  const e = new Bi();
  return e.depthTest = !1, e.depthWrite = !1, e.blending = xc, e.name = `PMREM_${r}`, e;
}
function vQ(r, e, i) {
  const n = Md(new Array(Jo).fill(0)), s = _t(new ue(0, 1, 0)), a = _t(0), o = be(Jo), l = _t(0), u = _t(1), c = Ci(null), h = _t(0), d = be(1 / e), p = be(1 / i), f = be(r), m = {
    n: o,
    latitudinal: l,
    weights: n,
    poleAxis: s,
    outputDirection: q1,
    dTheta: a,
    samples: u,
    envMap: c,
    mipInt: h,
    CUBEUV_TEXEL_WIDTH: d,
    CUBEUV_TEXEL_HEIGHT: p,
    CUBEUV_MAX_MIP: f
  }, y = X1("blur");
  return y.uniforms = m, y.fragmentNode = lK({ ...m, latitudinal: l.equal(1) }), y;
}
function aA(r) {
  const e = X1("cubemap");
  return e.fragmentNode = Ed(r, q1), e;
}
function oA(r) {
  const e = X1("equirect");
  return e.fragmentNode = Ci(r, OI(q1), 0), e;
}
const lA = /* @__PURE__ */ new WeakMap(), bQ = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]), xQ = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]), Tf = (r) => /e/g.test(r) ? String(r).replace(/\+/g, "") : (r = Number(r), r + (r % 1 ? "" : ".0"));
class r3 {
  constructor(e, i, n) {
    this.object = e, this.material = e && e.material || null, this.geometry = e && e.geometry || null, this.renderer = i, this.parser = n, this.scene = null, this.camera = null, this.nodes = [], this.sequentialNodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.updateAfterNodes = [], this.hashNodes = {}, this.monitor = null, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.clippingContext = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = { vertex: [], fragment: [], compute: [] }, this.flowCode = { vertex: "", fragment: "", compute: "" }, this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }, this.structs = { vertex: [], fragment: [], compute: [], index: 0 }, this.bindings = { vertex: {}, fragment: {}, compute: {} }, this.bindingsIndexes = {}, this.bindGroups = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.codes = {}, this.vars = {}, this.flow = { code: "" }, this.chaining = [], this.stack = tv(), this.stacks = [], this.tab = "	", this.currentFunctionNode = null, this.context = {
      material: this.material
    }, this.cache = new lv(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null, this.useComparisonMethod = !1;
  }
  getBindGroupsCache() {
    let e = lA.get(this.renderer);
    return e === void 0 && (e = new Ts(), lA.set(this.renderer, e)), e;
  }
  createRenderTarget(e, i, n) {
    return new jc(e, i, n);
  }
  createCubeRenderTarget(e, i) {
    return new DI(e, i);
  }
  createPMREMGenerator() {
    return new gQ(this.renderer);
  }
  includes(e) {
    return this.nodes.includes(e);
  }
  _getBindGroup(e, i) {
    const n = this.getBindGroupsCache(), s = [];
    let a = !0;
    for (const l of i)
      s.push(l), a = a && l.groupNode.shared !== !0;
    let o;
    return a ? (o = n.get(s), o === void 0 && (o = new Ux(e, s, this.bindingsIndexes[e].group, s), n.set(s, o))) : o = new Ux(e, s, this.bindingsIndexes[e].group, s), o;
  }
  getBindGroupArray(e, i) {
    const n = this.bindings[i];
    let s = n[e];
    return s === void 0 && (this.bindingsIndexes[e] === void 0 && (this.bindingsIndexes[e] = { binding: 0, group: Object.keys(this.bindingsIndexes).length }), n[e] = s = []), s;
  }
  getBindings() {
    let e = this.bindGroups;
    if (e === null) {
      const i = {}, n = this.bindings;
      for (const s of cM)
        for (const a in n[s]) {
          const o = n[s][a];
          (i[a] || (i[a] = [])).push(...o);
        }
      e = [];
      for (const s in i) {
        const a = i[s], o = this._getBindGroup(s, a);
        e.push(o);
      }
      this.bindGroups = e;
    }
    return e;
  }
  sortBindingGroups() {
    const e = this.getBindings();
    e.sort((i, n) => i.bindings[0].groupNode.order - n.bindings[0].groupNode.order);
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      this.bindingsIndexes[n.name].group = i, n.index = i;
    }
  }
  setHashNode(e, i) {
    this.hashNodes[i] = e;
  }
  addNode(e) {
    this.nodes.includes(e) === !1 && (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
  }
  addSequentialNode(e) {
    this.sequentialNodes.includes(e) === !1 && this.sequentialNodes.push(e);
  }
  buildUpdateNodes() {
    for (const e of this.nodes)
      e.getUpdateType() !== Nt.NONE && this.updateNodes.push(e.getSelf());
    for (const e of this.sequentialNodes) {
      const i = e.getUpdateBeforeType(), n = e.getUpdateAfterType();
      i !== Nt.NONE && this.updateBeforeNodes.push(e.getSelf()), n !== Nt.NONE && this.updateAfterNodes.push(e.getSelf());
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  isFilteredTexture(e) {
    return e.magFilter === on || e.magFilter === rx || e.magFilter === Ku || e.magFilter === da || e.minFilter === on || e.minFilter === rx || e.minFilter === Ku || e.minFilter === da;
  }
  addChain(e) {
    this.chaining.push(e);
  }
  removeChain(e) {
    if (this.chaining.pop() !== e)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  getMethod(e) {
    return e;
  }
  getNodeFromHash(e) {
    return this.hashNodes[e];
  }
  addFlow(e, i) {
    return this.flowNodes[e].push(i), i;
  }
  setContext(e) {
    this.context = e;
  }
  getContext() {
    return this.context;
  }
  getSharedContext() {
    return { ...this.context }, this.context;
  }
  setCache(e) {
    this.cache = e;
  }
  getCache() {
    return this.cache;
  }
  getCacheFromNode(e, i = !0) {
    const n = this.getDataFromNode(e);
    return n.cache === void 0 && (n.cache = new lv(i ? this.getCache() : null)), n.cache;
  }
  isAvailable() {
    return !1;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getDrawIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return !1;
  }
  increaseUsage(e) {
    const i = this.getDataFromNode(e);
    return i.usageCount = i.usageCount === void 0 ? 1 : i.usageCount + 1, i.usageCount;
  }
  generateTexture() {
    console.warn("Abstract function.");
  }
  generateTextureLod() {
    console.warn("Abstract function.");
  }
  generateConst(e, i = null) {
    if (i === null && (e === "float" || e === "int" || e === "uint" ? i = 0 : e === "bool" ? i = !1 : e === "color" ? i = new Kt() : e === "vec2" ? i = new Vt() : e === "vec3" ? i = new ue() : e === "vec4" && (i = new Yt())), e === "float") return Tf(i);
    if (e === "int") return `${Math.round(i)}`;
    if (e === "uint") return i >= 0 ? `${Math.round(i)}u` : "0u";
    if (e === "bool") return i ? "true" : "false";
    if (e === "color") return `${this.getType("vec3")}( ${Tf(i.r)}, ${Tf(i.g)}, ${Tf(i.b)} )`;
    const n = this.getTypeLength(e), s = this.getComponentType(e), a = (o) => this.generateConst(s, o);
    if (n === 2)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)} )`;
    if (n === 3)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)}, ${a(i.z)} )`;
    if (n === 4)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)}, ${a(i.z)}, ${a(i.w)} )`;
    if (n > 4 && i && (i.isMatrix3 || i.isMatrix4))
      return `${this.getType(e)}( ${i.elements.map(a).join(", ")} )`;
    if (n > 4)
      return `${this.getType(e)}()`;
    throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`);
  }
  getType(e) {
    return e === "color" ? "vec3" : e;
  }
  hasGeometryAttribute(e) {
    return this.geometry && this.geometry.getAttribute(e) !== void 0;
  }
  getAttribute(e, i) {
    const n = this.attributes;
    for (const a of n)
      if (a.name === e)
        return a;
    const s = new tA(e, i);
    return n.push(s), s;
  }
  getPropertyName(e) {
    return e.name;
  }
  isVector(e) {
    return /vec\d/.test(e);
  }
  isMatrix(e) {
    return /mat\d/.test(e);
  }
  isReference(e) {
    return e === "void" || e === "property" || e === "sampler" || e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "depthTexture" || e === "texture3D";
  }
  needsToWorkingColorSpace() {
    return !1;
  }
  getComponentTypeFromTexture(e) {
    const i = e.type;
    if (e.isDataTexture) {
      if (i === Tr) return "int";
      if (i === Ji) return "uint";
    }
    return "float";
  }
  getElementType(e) {
    return e === "mat2" ? "vec2" : e === "mat3" ? "vec3" : e === "mat4" ? "vec4" : this.getComponentType(e);
  }
  getComponentType(e) {
    if (e = this.getVectorType(e), e === "float" || e === "bool" || e === "int" || e === "uint") return e;
    const i = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
    return i === null ? null : i[1] === "b" ? "bool" : i[1] === "i" ? "int" : i[1] === "u" ? "uint" : "float";
  }
  getVectorType(e) {
    return e === "color" ? "vec3" : e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "texture3D" ? "vec4" : e;
  }
  getTypeFromLength(e, i = "float") {
    if (e === 1) return i;
    const n = bQ.get(e);
    return (i === "float" ? "" : i[0]) + n;
  }
  getTypeFromArray(e) {
    return xQ.get(e.constructor);
  }
  getTypeFromAttribute(e) {
    let i = e;
    e.isInterleavedBufferAttribute && (i = e.data);
    const n = i.array, s = e.itemSize, a = e.normalized;
    let o;
    return !(e instanceof vP) && a !== !0 && (o = this.getTypeFromArray(n)), this.getTypeFromLength(s, o);
  }
  getTypeLength(e) {
    const i = this.getVectorType(e), n = /vec([2-4])/.exec(i);
    return n !== null ? Number(n[1]) : i === "float" || i === "bool" || i === "int" || i === "uint" ? 1 : /mat2/.test(e) === !0 ? 4 : /mat3/.test(e) === !0 ? 9 : /mat4/.test(e) === !0 ? 16 : 0;
  }
  getVectorFromMatrix(e) {
    return e.replace("mat", "vec");
  }
  changeComponentType(e, i) {
    return this.getTypeFromLength(this.getTypeLength(e), i);
  }
  getIntegerType(e) {
    const i = this.getComponentType(e);
    return i === "int" || i === "uint" ? e : this.changeComponentType(e, "int");
  }
  addStack() {
    return this.stack = tv(this.stack), this.stacks.push(GP() || this.stack), Gm(this.stack), this.stack;
  }
  removeStack() {
    const e = this.stack;
    return this.stack = e.parent, Gm(this.stacks.pop()), e;
  }
  getDataFromNode(e, i = this.shaderStage, n = null) {
    n = n === null ? e.isGlobal(this) ? this.globalCache : this.cache : n;
    let s = n.getData(e);
    return s === void 0 && (s = {}, n.setData(e, s)), s[i] === void 0 && (s[i] = {}), s[i];
  }
  getNodeProperties(e, i = "any") {
    const n = this.getDataFromNode(e, i);
    return n.properties || (n.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(e, i) {
    const n = this.getDataFromNode(e);
    let s = n.bufferAttribute;
    if (s === void 0) {
      const a = this.uniforms.index++;
      s = new tA("nodeAttribute" + a, i, e), this.bufferAttributes.push(s), n.bufferAttribute = s;
    }
    return s;
  }
  getStructTypeFromNode(e, i = this.shaderStage) {
    const n = this.getDataFromNode(e, i);
    if (n.structType === void 0) {
      const s = this.structs.index++;
      e.name = `StructType${s}`, this.structs[i].push(e), n.structType = e;
    }
    return e;
  }
  getUniformFromNode(e, i, n = this.shaderStage, s = null) {
    const a = this.getDataFromNode(e, n, this.globalCache);
    let o = a.uniform;
    if (o === void 0) {
      const l = this.uniforms.index++;
      o = new KZ(s || "nodeUniform" + l, i, e), this.uniforms[n].push(o), a.uniform = o;
    }
    return o;
  }
  getVarFromNode(e, i = null, n = e.getNodeType(this), s = this.shaderStage) {
    const a = this.getDataFromNode(e, s);
    let o = a.variable;
    if (o === void 0) {
      const l = this.vars[s] || (this.vars[s] = []);
      i === null && (i = "nodeVar" + l.length), o = new i3(i, n), l.push(o), a.variable = o;
    }
    return o;
  }
  getVaryingFromNode(e, i = null, n = e.getNodeType(this)) {
    const s = this.getDataFromNode(e, "any");
    let a = s.varying;
    if (a === void 0) {
      const o = this.varyings, l = o.length;
      i === null && (i = "nodeVarying" + l), a = new ZZ(i, n), o.push(a), s.varying = a;
    }
    return a;
  }
  getCodeFromNode(e, i, n = this.shaderStage) {
    const s = this.getDataFromNode(e);
    let a = s.code;
    if (a === void 0) {
      const o = this.codes[n] || (this.codes[n] = []), l = o.length;
      a = new QZ("nodeCode" + l, i), o.push(a), s.code = a;
    }
    return a;
  }
  addFlowCodeHierarchy(e, i) {
    const { flowCodes: n, flowCodeBlock: s } = this.getDataFromNode(e);
    let a = !0, o = i;
    for (; o; ) {
      if (s.get(o) === !0) {
        a = !1;
        break;
      }
      o = this.getDataFromNode(o).parentNodeBlock;
    }
    if (a)
      for (const l of n)
        this.addLineFlowCode(l);
  }
  addLineFlowCodeBlock(e, i, n) {
    const s = this.getDataFromNode(e), a = s.flowCodes || (s.flowCodes = []), o = s.flowCodeBlock || (s.flowCodeBlock = /* @__PURE__ */ new WeakMap());
    a.push(i), o.set(n, !0);
  }
  addLineFlowCode(e, i = null) {
    return e === "" ? this : (i !== null && this.context.nodeBlock && this.addLineFlowCodeBlock(i, e, this.context.nodeBlock), e = this.tab + e, /;\s*$/.test(e) || (e = e + `;
`), this.flow.code += e, this);
  }
  addFlowCode(e) {
    return this.flow.code += e, this;
  }
  addFlowTab() {
    return this.tab += "	", this;
  }
  removeFlowTab() {
    return this.tab = this.tab.slice(0, -1), this;
  }
  getFlowData(e) {
    return this.flowsData.get(e);
  }
  flowNode(e) {
    const i = e.getNodeType(this), n = this.flowChildNode(e, i);
    return this.flowsData.set(e, n), n;
  }
  buildFunctionNode(e) {
    const i = new MZ(), n = this.currentFunctionNode;
    return this.currentFunctionNode = i, i.code = this.buildFunctionCode(e), this.currentFunctionNode = n, i;
  }
  flowShaderNode(e) {
    const i = e.layout, n = {
      [Symbol.iterator]() {
        let o = 0;
        const l = Object.values(this);
        return {
          next: () => ({
            value: l[o],
            done: o++ >= l.length
          })
        };
      }
    };
    for (const o of i.inputs)
      n[o.name] = new aZ(o.type, o.name);
    e.layout = null;
    const s = e.call(n), a = this.flowStagesNode(s, i.type);
    return e.layout = i, a;
  }
  flowStagesNode(e, i = null) {
    const n = this.flow, s = this.vars, a = this.cache, o = this.buildStage, l = this.stack, u = {
      code: ""
    };
    this.flow = u, this.vars = {}, this.cache = new lv(), this.stack = tv();
    for (const c of uM)
      this.setBuildStage(c), u.result = e.build(this, i);
    return u.vars = this.getVars(this.shaderStage), this.flow = n, this.vars = s, this.cache = a, this.stack = l, this.setBuildStage(o), u;
  }
  getFunctionOperator() {
    return null;
  }
  flowChildNode(e, i = null) {
    const n = this.flow, s = {
      code: ""
    };
    return this.flow = s, s.result = e.build(this, i), this.flow = n, s;
  }
  flowNodeFromShaderStage(e, i, n = null, s = null) {
    const a = this.shaderStage;
    this.setShaderStage(e);
    const o = this.flowChildNode(i, n);
    return s !== null && (o.code += `${this.tab + s} = ${o.result};
`), this.flowCode[e] = this.flowCode[e] + o.code, this.setShaderStage(a), o;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(e, i) {
    return `${this.getType(e)} ${i}`;
  }
  getVars(e) {
    let i = "";
    const n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i += `${this.getVar(s.type, s.name)}; `;
    return i;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(e) {
    const i = this.codes[e];
    let n = "";
    if (i !== void 0)
      for (const s of i)
        n += s.code + `
`;
    return n;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(e) {
    this.shaderStage = e;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(e) {
    this.buildStage = e;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    const { object: e, material: i, renderer: n } = this;
    if (i !== null) {
      let s = n.library.fromMaterial(i);
      s === null && (console.error(`NodeMaterial: Material "${i.type}" is not compatible.`), s = new Bi()), s.build(this);
    } else
      this.addFlow("compute", e);
    for (const s of uM) {
      this.setBuildStage(s), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const a of cM) {
        this.setShaderStage(a);
        const o = this.flowNodes[a];
        for (const l of o)
          s === "generate" ? this.flowNode(l) : l.build(this);
      }
    }
    return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
  }
  getNodeUniform(e, i) {
    if (i === "float" || i === "int" || i === "uint") return new oQ(e);
    if (i === "vec2" || i === "ivec2" || i === "uvec2") return new lQ(e);
    if (i === "vec3" || i === "ivec3" || i === "uvec3") return new uQ(e);
    if (i === "vec4" || i === "ivec4" || i === "uvec4") return new cQ(e);
    if (i === "color") return new hQ(e);
    if (i === "mat3") return new dQ(e);
    if (i === "mat4") return new pQ(e);
    throw new Error(`Uniform "${i}" not declared.`);
  }
  createNodeMaterial(e = "NodeMaterial") {
    throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${e}() instead.`);
  }
  format(e, i, n) {
    if (i = this.getVectorType(i), n = this.getVectorType(n), i === n || n === null || this.isReference(n))
      return e;
    const s = this.getTypeLength(i), a = this.getTypeLength(n);
    return s === 16 && a === 9 ? `${this.getType(n)}(${e}[0].xyz, ${e}[1].xyz, ${e}[2].xyz)` : s === 9 && a === 4 ? `${this.getType(n)}(${e}[0].xy, ${e}[1].xy)` : s > 4 || a > 4 || a === 0 ? e : s === a ? `${this.getType(n)}( ${e} )` : s > a ? this.format(`${e}.${"xyz".slice(0, a)}`, this.getTypeFromLength(a, this.getComponentType(i)), n) : a === 4 && s > 1 ? `${this.getType(n)}( ${this.format(e, i, "vec3")}, 1.0 )` : s === 2 ? `${this.getType(n)}( ${this.format(e, i, "vec2")}, 0.0 )` : (s === 1 && a > 1 && i !== this.getComponentType(n) && (e = `${this.getType(this.getComponentType(n))}( ${e} )`), `${this.getType(n)}( ${e} )`);
  }
  getSignature() {
    return `// Three.js r${Pg} - Node System
`;
  }
}
class uA {
  constructor() {
    this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.startTime = null, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.updateAfterMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
  }
  _getMaps(e, i) {
    let n = e.get(i);
    return n === void 0 && (n = {
      renderMap: /* @__PURE__ */ new WeakMap(),
      frameMap: /* @__PURE__ */ new WeakMap()
    }, e.set(i, n)), n;
  }
  updateBeforeNode(e) {
    const i = e.getUpdateBeforeType(), n = e.updateReference(this);
    if (i === Nt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateBeforeMap, n);
      s.get(n) !== this.frameId && e.updateBefore(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Nt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateBeforeMap, n);
      s.get(n) !== this.renderId && e.updateBefore(this) !== !1 && s.set(n, this.renderId);
    } else i === Nt.OBJECT && e.updateBefore(this);
  }
  updateAfterNode(e) {
    const i = e.getUpdateAfterType(), n = e.updateReference(this);
    if (i === Nt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateAfterMap, n);
      s.get(n) !== this.frameId && e.updateAfter(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Nt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateAfterMap, n);
      s.get(n) !== this.renderId && e.updateAfter(this) !== !1 && s.set(n, this.renderId);
    } else i === Nt.OBJECT && e.updateAfter(this);
  }
  updateNode(e) {
    const i = e.getUpdateType(), n = e.updateReference(this);
    if (i === Nt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateMap, n);
      s.get(n) !== this.frameId && e.update(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Nt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateMap, n);
      s.get(n) !== this.renderId && e.update(this) !== !1 && s.set(n, this.renderId);
    } else i === Nt.OBJECT && e.update(this);
  }
  update() {
    this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
  }
}
class $1 {
  constructor(e, i, n = null, s = "", a = !1) {
    this.type = e, this.name = i, this.count = n, this.qualifier = s, this.isConst = a;
  }
}
$1.isNodeFunctionInput = !0;
class _Q extends Dl {
  static get type() {
    return "DirectionalLightNode";
  }
  constructor(e = null) {
    super(e);
  }
  setup(e) {
    super.setup(e);
    const i = e.context.lightingModel, n = this.colorNode, s = JI(this.light), a = e.context.reflectedLight;
    i.direct({
      lightDirection: s,
      lightColor: n,
      reflectedLight: a
    }, e.stack, e);
  }
}
const fv = /* @__PURE__ */ new gi(), Sf = /* @__PURE__ */ new gi();
let Ah = null;
class TQ extends Dl {
  static get type() {
    return "RectAreaLightNode";
  }
  constructor(e = null) {
    super(e), this.halfHeight = _t(new ue()).setGroup(kt), this.halfWidth = _t(new ue()).setGroup(kt), this.updateType = Nt.RENDER;
  }
  update(e) {
    super.update(e);
    const { light: i } = this, n = e.camera.matrixWorldInverse;
    Sf.identity(), fv.copy(i.matrixWorld), fv.premultiply(n), Sf.extractRotation(fv), this.halfWidth.value.set(i.width * 0.5, 0, 0), this.halfHeight.value.set(0, i.height * 0.5, 0), this.halfWidth.value.applyMatrix4(Sf), this.halfHeight.value.applyMatrix4(Sf);
  }
  setup(e) {
    super.setup(e);
    let i, n;
    e.isAvailable("float32Filterable") ? (i = Ci(Ah.LTC_FLOAT_1), n = Ci(Ah.LTC_FLOAT_2)) : (i = Ci(Ah.LTC_HALF_1), n = Ci(Ah.LTC_HALF_2));
    const { colorNode: s, light: a } = this, o = e.context.lightingModel, l = W1(a), u = e.context.reflectedLight;
    o.directRectArea({
      lightColor: s,
      lightPosition: l,
      halfWidth: this.halfWidth,
      halfHeight: this.halfHeight,
      reflectedLight: u,
      ltc_1: i,
      ltc_2: n
    }, e.stack, e);
  }
  static setLTC(e) {
    Ah = e;
  }
}
class n3 extends Dl {
  static get type() {
    return "SpotLightNode";
  }
  constructor(e = null) {
    super(e), this.coneCosNode = _t(0).setGroup(kt), this.penumbraCosNode = _t(0).setGroup(kt), this.cutoffDistanceNode = _t(0).setGroup(kt), this.decayExponentNode = _t(0).setGroup(kt);
  }
  update(e) {
    super.update(e);
    const { light: i } = this;
    this.coneCosNode.value = Math.cos(i.angle), this.penumbraCosNode.value = Math.cos(i.angle * (1 - i.penumbra)), this.cutoffDistanceNode.value = i.distance, this.decayExponentNode.value = i.decay;
  }
  getSpotAttenuation(e) {
    const { coneCosNode: i, penumbraCosNode: n } = this;
    return Ml(i, n, e);
  }
  setup(e) {
    super.setup(e);
    const i = e.context.lightingModel, { colorNode: n, cutoffDistanceNode: s, decayExponentNode: a, light: o } = this, l = W1(o).sub(ir), u = l.normalize(), c = u.dot(JI(o)), h = this.getSpotAttenuation(c), d = l.length(), p = t3({
      lightDistance: d,
      cutoffDistance: s,
      decayExponent: a
    }), f = n.mul(h).mul(p), m = e.context.reflectedLight;
    i.direct({
      lightDirection: u,
      lightColor: f,
      reflectedLight: m
    }, e.stack, e);
  }
}
class SQ extends n3 {
  static get type() {
    return "IESSpotLightNode";
  }
  getSpotAttenuation(e) {
    const i = this.light.iesMap;
    let n = null;
    if (i && i.isTexture === !0) {
      const s = e.acos().mul(1 / Math.PI);
      n = Ci(i, He(s, 0), 0).r;
    } else
      n = super.getSpotAttenuation(e);
    return n;
  }
}
class wQ extends Dl {
  static get type() {
    return "AmbientLightNode";
  }
  constructor(e = null) {
    super(e);
  }
  setup({ context: e }) {
    e.irradiance.addAssign(this.colorNode);
  }
}
class EQ extends Dl {
  static get type() {
    return "HemisphereLightNode";
  }
  constructor(e = null) {
    super(e), this.lightPositionNode = QI(e), this.lightDirectionNode = this.lightPositionNode.normalize(), this.groundColorNode = _t(new Kt()).setGroup(kt);
  }
  update(e) {
    const { light: i } = this;
    super.update(e), this.lightPositionNode.object3d = i, this.groundColorNode.value.copy(i.groundColor).multiplyScalar(i.intensity);
  }
  setup(e) {
    const { colorNode: i, groundColorNode: n, lightDirectionNode: s } = this, a = Jn.dot(s).mul(0.5).add(0.5), o = li(n, i, a);
    e.context.irradiance.addAssign(o);
  }
}
class MQ extends Dl {
  static get type() {
    return "LightProbeNode";
  }
  constructor(e = null) {
    super(e);
    const i = [];
    for (let n = 0; n < 9; n++) i.push(new ue());
    this.lightProbe = Md(i);
  }
  update(e) {
    const { light: i } = this;
    super.update(e);
    for (let n = 0; n < 9; n++)
      this.lightProbe.array[n].copy(i.sh.coefficients[n]).multiplyScalar(i.intensity);
  }
  setup(e) {
    const i = qZ(bI, this.lightProbe);
    e.context.irradiance.addAssign(i);
  }
}
class s3 {
  parseFunction() {
    console.warn("Abstract function.");
  }
}
class Y1 {
  constructor(e, i, n = "", s = "") {
    this.type = e, this.inputs = i, this.name = n, this.precision = s;
  }
  getCode() {
    console.warn("Abstract function.");
  }
}
Y1.isNodeFunction = !0;
const AQ = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, CQ = /[a-z_0-9]+/ig, cA = "#pragma main", RQ = (r) => {
  r = r.trim();
  const e = r.indexOf(cA), i = e !== -1 ? r.slice(e + cA.length) : r, n = i.match(AQ);
  if (n !== null && n.length === 5) {
    const s = n[4], a = [];
    let o = null;
    for (; (o = CQ.exec(s)) !== null; )
      a.push(o);
    const l = [];
    let u = 0;
    for (; u < a.length; ) {
      const m = a[u][0] === "const";
      m === !0 && u++;
      let y = a[u][0];
      y === "in" || y === "out" || y === "inout" ? u++ : y = "";
      const v = a[u++][0];
      let g = Number.parseInt(a[u][0]);
      Number.isNaN(g) === !1 ? u++ : g = null;
      const _ = a[u++][0];
      l.push(new $1(v, _, g, y, m));
    }
    const c = i.substring(n[0].length), h = n[3] !== void 0 ? n[3] : "", d = n[2], p = n[1] !== void 0 ? n[1] : "", f = e !== -1 ? r.slice(0, e) : "";
    return {
      type: d,
      inputs: l,
      name: h,
      precision: p,
      inputsCode: s,
      blockCode: c,
      headerCode: f
    };
  } else
    throw new Error("FunctionNode: Function is not a GLSL code.");
};
class NQ extends Y1 {
  constructor(e) {
    const { type: i, inputs: n, name: s, precision: a, inputsCode: o, blockCode: l, headerCode: u } = RQ(e);
    super(i, n, s, a), this.inputsCode = o, this.blockCode = l, this.headerCode = u;
  }
  getCode(e = this.name) {
    let i;
    const n = this.blockCode;
    if (n !== "") {
      const { type: s, inputsCode: a, headerCode: o, precision: l } = this;
      let u = `${s} ${e} ( ${a.trim()} )`;
      l !== "" && (u = `${l} ${u}`), i = o + u + n;
    } else
      i = "";
    return i;
  }
}
class PQ extends s3 {
  parseFunction(e) {
    return new NQ(e);
  }
}
const hA = /* @__PURE__ */ new WeakMap();
class IQ extends So {
  constructor(e, i) {
    super(), this.renderer = e, this.backend = i, this.nodeFrame = new uA(), this.nodeBuilderCache = /* @__PURE__ */ new Map(), this.callHashCache = new Ts(), this.groupsData = new Ts();
  }
  updateGroup(e) {
    const i = e.groupNode, n = i.name;
    if (n === qP.name) return !0;
    if (n === kt.name) {
      const o = this.get(e), l = this.nodeFrame.renderId;
      return o.renderId !== l ? (o.renderId = l, !0) : !1;
    }
    if (n === aq.name) {
      const o = this.get(e), l = this.nodeFrame.frameId;
      return o.frameId !== l ? (o.frameId = l, !0) : !1;
    }
    const s = [i, e];
    let a = this.groupsData.get(s);
    return a === void 0 && this.groupsData.set(s, a = {}), a.version !== i.version ? (a.version = i.version, !0) : !1;
  }
  getForRenderCacheKey(e) {
    return e.initialCacheKey;
  }
  getForRender(e) {
    const i = this.get(e);
    let n = i.nodeBuilderState;
    if (n === void 0) {
      const { nodeBuilderCache: s } = this, a = this.getForRenderCacheKey(e);
      if (n = s.get(a), n === void 0) {
        const o = this.backend.createNodeBuilder(e.object, this.renderer);
        o.scene = e.scene, o.material = e.material, o.camera = e.camera, o.context.material = e.material, o.lightsNode = e.lightsNode, o.environmentNode = this.getEnvironmentNode(e.scene), o.fogNode = this.getFogNode(e.scene), o.clippingContext = e.clippingContext, o.build(), n = this._createNodeBuilderState(o), s.set(a, n);
      }
      n.usedTimes++, i.nodeBuilderState = n;
    }
    return n;
  }
  delete(e) {
    if (e.isRenderObject) {
      const i = this.get(e).nodeBuilderState;
      i.usedTimes--, i.usedTimes === 0 && this.nodeBuilderCache.delete(this.getForRenderCacheKey(e));
    }
    return super.delete(e);
  }
  getForCompute(e) {
    const i = this.get(e);
    let n = i.nodeBuilderState;
    if (n === void 0) {
      const s = this.backend.createNodeBuilder(e, this.renderer);
      s.build(), n = this._createNodeBuilderState(s), i.nodeBuilderState = n;
    }
    return n;
  }
  _createNodeBuilderState(e) {
    return new YZ(
      e.vertexShader,
      e.fragmentShader,
      e.computeShader,
      e.getAttributesArray(),
      e.getBindings(),
      e.updateNodes,
      e.updateBeforeNodes,
      e.updateAfterNodes,
      e.monitor,
      e.transforms
    );
  }
  getEnvironmentNode(e) {
    return e.environmentNode || this.get(e).environmentNode || null;
  }
  getBackgroundNode(e) {
    return e.backgroundNode || this.get(e).backgroundNode || null;
  }
  getFogNode(e) {
    return e.fogNode || this.get(e).fogNode || null;
  }
  getCacheKey(e, i) {
    const n = [e, i], s = this.renderer.info.calls;
    let a = this.callHashCache.get(n);
    if (a === void 0 || a.callId !== s) {
      const o = this.getEnvironmentNode(e), l = this.getFogNode(e), u = [];
      i && u.push(i.getCacheKey(!0)), o && u.push(o.getCacheKey()), l && u.push(l.getCacheKey()), u.push(this.renderer.shadowMap.enabled ? 1 : 0), a = {
        callId: s,
        cacheKey: kP(u)
      }, this.callHashCache.set(n, a);
    }
    return a.cacheKey;
  }
  updateScene(e) {
    this.updateEnvironment(e), this.updateFog(e), this.updateBackground(e);
  }
  get isToneMappingState() {
    return !this.renderer.getRenderTarget();
  }
  updateBackground(e) {
    const i = this.get(e), n = e.background;
    if (n) {
      const s = e.backgroundBlurriness === 0 && i.backgroundBlurriness > 0 || e.backgroundBlurriness > 0 && i.backgroundBlurriness === 0;
      if (i.background !== n || s) {
        let a = null;
        if (n.isCubeTexture === !0 || n.mapping === $d || n.mapping === Yd || n.mapping === tx)
          if (e.backgroundBlurriness > 0 || n.mapping === tx)
            a = WI(n);
          else {
            let o;
            n.isCubeTexture === !0 ? o = Ed(n) : o = Ci(n), a = kI(o);
          }
        else n.isTexture === !0 ? a = Ci(n, Ad.flipY()).setUpdateMatrix(!0) : n.isColor !== !0 && console.error("WebGPUNodes: Unsupported background configuration.", n);
        i.backgroundNode = a, i.background = n, i.backgroundBlurriness = e.backgroundBlurriness;
      }
    } else i.backgroundNode && (delete i.backgroundNode, delete i.background);
  }
  updateFog(e) {
    const i = this.get(e), n = e.fog;
    if (n) {
      if (i.fog !== n) {
        let s = null;
        if (n.isFogExp2) {
          const a = bi("color", "color", n).setGroup(kt), o = bi("density", "float", n).setGroup(kt);
          s = NZ(a, o);
        } else if (n.isFog) {
          const a = bi("color", "color", n).setGroup(kt), o = bi("near", "float", n).setGroup(kt), l = bi("far", "float", n).setGroup(kt);
          s = CZ(a, o, l);
        } else
          console.error("WebGPUNodes: Unsupported fog configuration.", n);
        i.fogNode = s, i.fog = n;
      }
    } else
      delete i.fogNode, delete i.fog;
  }
  updateEnvironment(e) {
    const i = this.get(e), n = e.environment;
    if (n) {
      if (i.environment !== n) {
        let s = null;
        n.isCubeTexture === !0 ? s = Ed(n) : n.isTexture === !0 ? s = Ci(n) : console.error("Nodes: Unsupported environment configuration.", n), i.environmentNode = s, i.environment = n;
      }
    } else i.environmentNode && (delete i.environmentNode, delete i.environment);
  }
  getNodeFrame(e = this.renderer, i = null, n = null, s = null, a = null) {
    const o = this.nodeFrame;
    return o.renderer = e, o.scene = i, o.object = n, o.camera = s, o.material = a, o;
  }
  getNodeFrameForRender(e) {
    return this.getNodeFrame(e.renderer, e.scene, e.object, e.camera, e.material);
  }
  getOutputCacheKey() {
    const e = this.renderer;
    return e.toneMapping + "," + e.currentColorSpace;
  }
  hasOutputChange(e) {
    return hA.get(e) !== this.getOutputCacheKey();
  }
  getOutputNode(e) {
    const i = this.renderer, n = this.getOutputCacheKey(), s = Ci(e, Ad).renderOutput(i.toneMapping, i.currentColorSpace);
    return hA.set(e, n), s;
  }
  updateBefore(e) {
    const i = e.getNodeBuilderState();
    for (const n of i.updateBeforeNodes)
      this.getNodeFrameForRender(e).updateBeforeNode(n);
  }
  updateAfter(e) {
    const i = e.getNodeBuilderState();
    for (const n of i.updateAfterNodes)
      this.getNodeFrameForRender(e).updateAfterNode(n);
  }
  updateForCompute(e) {
    const i = this.getNodeFrame(), n = this.getForCompute(e);
    for (const s of n.updateNodes)
      i.updateNode(s);
  }
  updateForRender(e) {
    const i = this.getNodeFrameForRender(e), n = e.getNodeBuilderState();
    for (const s of n.updateNodes)
      i.updateNode(s);
  }
  needsRefresh(e) {
    const i = this.getNodeFrameForRender(e);
    return e.getMonitor().needsRefresh(e, i);
  }
  dispose() {
    super.dispose(), this.nodeFrame = new uA(), this.nodeBuilderCache = /* @__PURE__ */ new Map();
  }
}
class OQ {
  constructor(e, i) {
    this.scene = e, this.camera = i;
  }
  clone() {
    return Object.assign(new this.constructor(), this);
  }
}
class DQ {
  constructor() {
    this.lists = new Ts();
  }
  get(e, i) {
    const n = this.lists, s = [e, i];
    let a = n.get(s);
    return a === void 0 && (a = new OQ(e, i), n.set(s, a)), a;
  }
  dispose() {
    this.lists = new Ts();
  }
}
class a3 {
  constructor() {
    this.lightNodes = /* @__PURE__ */ new WeakMap(), this.materialNodes = /* @__PURE__ */ new Map(), this.toneMappingNodes = /* @__PURE__ */ new Map();
  }
  fromMaterial(e) {
    if (e.isNodeMaterial) return e;
    let i = null;
    const n = this.getMaterialNodeClass(e.type);
    if (n !== null) {
      i = new n();
      for (const s in e)
        i[s] = e[s];
    }
    return i;
  }
  addToneMapping(e, i) {
    this.addType(e, i, this.toneMappingNodes);
  }
  getToneMappingFunction(e) {
    return this.toneMappingNodes.get(e) || null;
  }
  getMaterialNodeClass(e) {
    return this.materialNodes.get(e) || null;
  }
  addMaterial(e, i) {
    this.addType(e, i.type, this.materialNodes);
  }
  getLightNodeClass(e) {
    return this.lightNodes.get(e) || null;
  }
  addLight(e, i) {
    this.addClass(e, i, this.lightNodes);
  }
  addType(e, i, n) {
    if (n.has(i)) {
      console.warn(`Redefinition of node ${i}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof i == "function" || typeof i == "object") throw new Error(`Base class ${i} is not a class.`);
    n.set(i, e);
  }
  addClass(e, i, n) {
    if (n.has(i)) {
      console.warn(`Redefinition of node ${i.name}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof i != "function") throw new Error(`Base class ${i.name} is not a class.`);
    n.set(i, e);
  }
}
const LQ = /* @__PURE__ */ new e3();
class kQ extends Ts {
  constructor() {
    super();
  }
  createNode(e = []) {
    return new e3().setLights(e);
  }
  getNode(e, i) {
    if (e.isQuadMesh) return LQ;
    const n = [e, i];
    let s = this.get(n);
    return s === void 0 && (s = this.createNode(), this.set(n, s)), s;
  }
}
const dA = /* @__PURE__ */ new TP(), wf = /* @__PURE__ */ new Vt(), mv = /* @__PURE__ */ new Yt(), gv = /* @__PURE__ */ new EP(), Ef = /* @__PURE__ */ new gi(), Ha = /* @__PURE__ */ new Yt();
class UQ {
  constructor(e, i = {}) {
    this.isRenderer = !0;
    const {
      logarithmicDepthBuffer: n = !1,
      alpha: s = !0,
      depth: a = !0,
      stencil: o = !1,
      antialias: l = !1,
      samples: u = 0,
      getFallback: c = null
    } = i;
    this.domElement = e.getDomElement(), this.backend = e, this.samples = u || l === !0 ? 4 : 0, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.alpha = s, this.logarithmicDepthBuffer = n, this.outputColorSpace = ct, this.toneMapping = Yu, this.toneMappingExposure = 1, this.sortObjects = !0, this.depth = a, this.stencil = o, this.clippingPlanes = [], this.info = new qK(), this.nodes = {
      modelViewMatrix: null,
      modelNormalViewMatrix: null
    }, this.library = new a3(), this.lighting = new kQ(), this._getFallback = c, this._pixelRatio = 1, this._width = this.domElement.width, this._height = this.domElement.height, this._viewport = new Yt(0, 0, this._width, this._height), this._scissor = new Yt(0, 0, this._width, this._height), this._scissorTest = !1, this._attributes = null, this._geometries = null, this._nodes = null, this._animation = null, this._bindings = null, this._objects = null, this._pipelines = null, this._bundles = null, this._renderLists = null, this._renderContexts = null, this._textures = null, this._background = null, this._quad = new KI(new Bi()), this._quad.material.type = "Renderer_output", this._currentRenderContext = null, this._opaqueSort = null, this._transparentSort = null, this._frameBufferTarget = null;
    const h = this.alpha === !0 ? 0 : 1;
    this._clearColor = new G1(0, 0, 0, h), this._clearDepth = 1, this._clearStencil = 0, this._renderTarget = null, this._activeCubeFace = 0, this._activeMipmapLevel = 0, this._mrt = null, this._renderObjectFunction = null, this._currentRenderObjectFunction = null, this._currentRenderBundle = null, this._handleObjectFunction = this._renderObjectDirect, this._isDeviceLost = !1, this.onDeviceLost = this._onDeviceLost, this._initialized = !1, this._initPromise = null, this._compilationPromises = null, this.transparent = !0, this.opaque = !0, this.shadowMap = {
      enabled: !1,
      type: F9
    }, this.xr = {
      enabled: !1
    }, this.debug = {
      checkShaderErrors: !0,
      onShaderError: null,
      getShaderAsync: async (d, p, f) => {
        await this.compileAsync(d, p);
        const m = this._renderLists.get(d, p), y = this._renderContexts.get(d, p, this._renderTarget), v = d.overrideMaterial || f.material, g = this._objects.get(f, v, d, p, m.lightsNode, y), { fragmentShader: _, vertexShader: x } = g.getNodeBuilderState();
        return { fragmentShader: _, vertexShader: x };
      }
    };
  }
  async init() {
    if (this._initialized)
      throw new Error("Renderer: Backend has already been initialized.");
    return this._initPromise !== null ? this._initPromise : (this._initPromise = new Promise(async (e, i) => {
      let n = this.backend;
      try {
        await n.init(this);
      } catch (s) {
        if (this._getFallback !== null)
          try {
            this.backend = n = this._getFallback(s), await n.init(this);
          } catch (a) {
            i(a);
            return;
          }
        else {
          i(s);
          return;
        }
      }
      this._nodes = new IQ(this, n), this._animation = new kK(this._nodes, this.info), this._attributes = new GK(n), this._background = new XZ(this, this._nodes), this._geometries = new WK(this._attributes, this.info), this._textures = new sZ(this, n, this.info), this._pipelines = new KK(n, this._nodes), this._bindings = new ZK(n, this._nodes, this._textures, this._attributes, this._pipelines, this.info), this._objects = new zK(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info), this._renderLists = new eZ(this.lighting), this._bundles = new DQ(), this._renderContexts = new rZ(), this._initialized = !0, e();
    }), this._initPromise);
  }
  get coordinateSystem() {
    return this.backend.coordinateSystem;
  }
  async compileAsync(e, i, n = null) {
    if (this._isDeviceLost === !0) return;
    this._initialized === !1 && await this.init();
    const s = this._nodes.nodeFrame, a = s.renderId, o = this._currentRenderContext, l = this._currentRenderObjectFunction, u = this._compilationPromises, c = e.isScene === !0 ? e : dA;
    n === null && (n = e);
    const h = this._renderTarget, d = this._renderContexts.get(n, i, h), p = this._activeMipmapLevel, f = [];
    this._currentRenderContext = d, this._currentRenderObjectFunction = this.renderObject, this._handleObjectFunction = this._createObjectPipeline, this._compilationPromises = f, s.renderId++, s.update(), d.depth = this.depth, d.stencil = this.stencil, d.clippingContext || (d.clippingContext = new Dx()), d.clippingContext.updateGlobal(this, i), c.onBeforeRender(this, e, i, h);
    const m = this._renderLists.get(e, i);
    if (m.begin(), this._projectObject(e, i, 0, m), n !== e && n.traverseVisible(function(_) {
      _.isLight && _.layers.test(i.layers) && m.pushLight(_);
    }), m.finish(), h !== null) {
      this._textures.updateRenderTarget(h, p);
      const _ = this._textures.get(h);
      d.textures = _.textures, d.depthTexture = _.depthTexture;
    } else
      d.textures = null, d.depthTexture = null;
    this._nodes.updateScene(c), this._background.update(c, m, d);
    const y = m.opaque, v = m.transparent, g = m.lightsNode;
    this.opaque === !0 && y.length > 0 && this._renderObjects(y, i, c, g), this.transparent === !0 && v.length > 0 && this._renderTransparents(v, i, c, g), s.renderId = a, this._currentRenderContext = o, this._currentRenderObjectFunction = l, this._compilationPromises = u, this._handleObjectFunction = this._renderObjectDirect, await Promise.all(f);
  }
  async renderAsync(e, i) {
    this._initialized === !1 && await this.init();
    const n = this._renderScene(e, i);
    await this.backend.resolveTimestampAsync(n, "render");
  }
  async waitForGPU() {
    await this.backend.waitForGPU();
  }
  setMRT(e) {
    return this._mrt = e, this;
  }
  getMRT() {
    return this._mrt;
  }
  _onDeviceLost(e) {
    let i = `THREE.WebGPURenderer: ${e.api} Device Lost:

Message: ${e.message}`;
    e.reason && (i += `
Reason: ${e.reason}`), console.error(i), this._isDeviceLost = !0;
  }
  _renderBundle(e, i, n) {
    const { bundleGroup: s, camera: a, renderList: o } = e, l = this._currentRenderContext, u = this._bundles.get(s, a), c = this.backend.get(u);
    c.renderContexts === void 0 && (c.renderContexts = /* @__PURE__ */ new Set());
    const h = s.version !== c.version, d = c.renderContexts.has(l) === !1 || h;
    if (c.renderContexts.add(l), d) {
      this.backend.beginBundle(l), (c.renderObjects === void 0 || h) && (c.renderObjects = []), this._currentRenderBundle = u;
      const p = o.opaque;
      this.opaque === !0 && p.length > 0 && this._renderObjects(p, a, i, n), this._currentRenderBundle = null, this.backend.finishBundle(l, u), c.version = s.version;
    } else {
      const { renderObjects: p } = c;
      for (let f = 0, m = p.length; f < m; f++) {
        const y = p[f];
        this._nodes.needsRefresh(y) && (this._nodes.updateBefore(y), this._nodes.updateForRender(y), this._bindings.updateForRender(y), this._nodes.updateAfter(y));
      }
    }
    this.backend.addBundle(l, u);
  }
  render(e, i) {
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."), this.renderAsync(e, i);
    this._renderScene(e, i);
  }
  _getFrameBufferTarget() {
    const { currentToneMapping: e, currentColorSpace: i } = this;
    if (e === Yu && i === po) return null;
    const { width: n, height: s } = this.getDrawingBufferSize(wf), { depth: a, stencil: o } = this;
    let l = this._frameBufferTarget;
    return l === null && (l = new jc(n, s, {
      depthBuffer: a,
      stencilBuffer: o,
      type: pa,
      // FloatType
      format: Bc,
      colorSpace: po,
      generateMipmaps: !1,
      minFilter: on,
      magFilter: on,
      samples: this.samples
    }), l.isPostProcessingRenderTarget = !0, this._frameBufferTarget = l), l.depthBuffer = a, l.stencilBuffer = o, l.setSize(n, s), l.viewport.copy(this._viewport), l.scissor.copy(this._scissor), l.viewport.multiplyScalar(this._pixelRatio), l.scissor.multiplyScalar(this._pixelRatio), l.scissorTest = this._scissorTest, l;
  }
  _renderScene(e, i, n = !0) {
    if (this._isDeviceLost === !0) return;
    const s = n ? this._getFrameBufferTarget() : null, a = this._nodes.nodeFrame, o = a.renderId, l = this._currentRenderContext, u = this._currentRenderObjectFunction, c = e.isScene === !0 ? e : dA, h = this._renderTarget, d = this._activeCubeFace, p = this._activeMipmapLevel;
    let f;
    s !== null ? (f = s, this.setRenderTarget(f)) : f = h;
    const m = this._renderContexts.get(e, i, f);
    this._currentRenderContext = m, this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject, this.info.calls++, this.info.render.calls++, this.info.render.frameCalls++, a.renderId = this.info.calls;
    const y = this.coordinateSystem;
    i.coordinateSystem !== y && (i.coordinateSystem = y, i.updateProjectionMatrix()), e.matrixWorldAutoUpdate === !0 && e.updateMatrixWorld(), i.parent === null && i.matrixWorldAutoUpdate === !0 && i.updateMatrixWorld();
    let v = this._viewport, g = this._scissor, _ = this._pixelRatio;
    f !== null && (v = f.viewport, g = f.scissor, _ = 1), this.getDrawingBufferSize(wf), mv.set(0, 0, wf.width, wf.height);
    const x = v.minDepth === void 0 ? 0 : v.minDepth, b = v.maxDepth === void 0 ? 1 : v.maxDepth;
    m.viewportValue.copy(v).multiplyScalar(_).floor(), m.viewportValue.width >>= p, m.viewportValue.height >>= p, m.viewportValue.minDepth = x, m.viewportValue.maxDepth = b, m.viewport = m.viewportValue.equals(mv) === !1, m.scissorValue.copy(g).multiplyScalar(_).floor(), m.scissor = this._scissorTest && m.scissorValue.equals(mv) === !1, m.scissorValue.width >>= p, m.scissorValue.height >>= p, m.clippingContext || (m.clippingContext = new Dx()), m.clippingContext.updateGlobal(this, i), c.onBeforeRender(this, e, i, f), Ef.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), gv.setFromProjectionMatrix(Ef, y);
    const T = this._renderLists.get(e, i);
    if (T.begin(), this._projectObject(e, i, 0, T), T.finish(), this.sortObjects === !0 && T.sort(this._opaqueSort, this._transparentSort), f !== null) {
      this._textures.updateRenderTarget(f, p);
      const N = this._textures.get(f);
      m.textures = N.textures, m.depthTexture = N.depthTexture, m.width = N.width, m.height = N.height, m.renderTarget = f, m.depth = f.depthBuffer, m.stencil = f.stencilBuffer;
    } else
      m.textures = null, m.depthTexture = null, m.width = this.domElement.width, m.height = this.domElement.height, m.depth = this.depth, m.stencil = this.stencil;
    m.width >>= p, m.height >>= p, m.activeCubeFace = d, m.activeMipmapLevel = p, m.occlusionQueryCount = T.occlusionQueryCount, this._nodes.updateScene(c), this._background.update(c, T, m), this.backend.beginRender(m);
    const {
      bundles: S,
      lightsNode: w,
      transparentDoublePass: M,
      transparent: E,
      opaque: A
    } = T;
    if (S.length > 0 && this._renderBundles(S, c, w), this.opaque === !0 && A.length > 0 && this._renderObjects(A, i, c, w), this.transparent === !0 && E.length > 0 && this._renderTransparents(E, M, i, c, w), this.backend.finishRender(m), a.renderId = o, this._currentRenderContext = l, this._currentRenderObjectFunction = u, s !== null) {
      this.setRenderTarget(h, d, p);
      const N = this._quad;
      this._nodes.hasOutputChange(f.texture) && (N.material.fragmentNode = this._nodes.getOutputNode(f.texture), N.material.needsUpdate = !0), this._renderScene(N, N.camera, !1);
    }
    return c.onAfterRender(this, e, i, f), m;
  }
  getMaxAnisotropy() {
    return this.backend.getMaxAnisotropy();
  }
  getActiveCubeFace() {
    return this._activeCubeFace;
  }
  getActiveMipmapLevel() {
    return this._activeMipmapLevel;
  }
  async setAnimationLoop(e) {
    this._initialized === !1 && await this.init(), this._animation.setAnimationLoop(e);
  }
  async getArrayBufferAsync(e) {
    return await this.backend.getArrayBufferAsync(e);
  }
  getContext() {
    return this.backend.getContext();
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  getDrawingBufferSize(e) {
    return e.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
  }
  getSize(e) {
    return e.set(this._width, this._height);
  }
  setPixelRatio(e = 1) {
    this._pixelRatio !== e && (this._pixelRatio = e, this.setSize(this._width, this._height, !1));
  }
  setDrawingBufferSize(e, i, n) {
    this._width = e, this._height = i, this._pixelRatio = n, this.domElement.width = Math.floor(e * n), this.domElement.height = Math.floor(i * n), this.setViewport(0, 0, e, i), this._initialized && this.backend.updateSize();
  }
  setSize(e, i, n = !0) {
    this._width = e, this._height = i, this.domElement.width = Math.floor(e * this._pixelRatio), this.domElement.height = Math.floor(i * this._pixelRatio), n === !0 && (this.domElement.style.width = e + "px", this.domElement.style.height = i + "px"), this.setViewport(0, 0, e, i), this._initialized && this.backend.updateSize();
  }
  setOpaqueSort(e) {
    this._opaqueSort = e;
  }
  setTransparentSort(e) {
    this._transparentSort = e;
  }
  getScissor(e) {
    const i = this._scissor;
    return e.x = i.x, e.y = i.y, e.width = i.width, e.height = i.height, e;
  }
  setScissor(e, i, n, s) {
    const a = this._scissor;
    e.isVector4 ? a.copy(e) : a.set(e, i, n, s);
  }
  getScissorTest() {
    return this._scissorTest;
  }
  setScissorTest(e) {
    this._scissorTest = e, this.backend.setScissorTest(e);
  }
  getViewport(e) {
    return e.copy(this._viewport);
  }
  setViewport(e, i, n, s, a = 0, o = 1) {
    const l = this._viewport;
    e.isVector4 ? l.copy(e) : l.set(e, i, n, s), l.minDepth = a, l.maxDepth = o;
  }
  getClearColor(e) {
    return e.copy(this._clearColor);
  }
  setClearColor(e, i = 1) {
    this._clearColor.set(e), this._clearColor.a = i;
  }
  getClearAlpha() {
    return this._clearColor.a;
  }
  setClearAlpha(e) {
    this._clearColor.a = e;
  }
  getClearDepth() {
    return this._clearDepth;
  }
  setClearDepth(e) {
    this._clearDepth = e;
  }
  getClearStencil() {
    return this._clearStencil;
  }
  setClearStencil(e) {
    this._clearStencil = e;
  }
  isOccluded(e) {
    const i = this._currentRenderContext;
    return i && this.backend.isOccluded(i, e);
  }
  clear(e = !0, i = !0, n = !0) {
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."), this.clearAsync(e, i, n);
    const s = this._renderTarget || this._getFrameBufferTarget();
    let a = null;
    if (s !== null && (this._textures.updateRenderTarget(s), a = this._textures.get(s)), this.backend.clear(e, i, n, a), s !== null && this._renderTarget === null) {
      const o = this._quad;
      this._nodes.hasOutputChange(s.texture) && (o.material.fragmentNode = this._nodes.getOutputNode(s.texture), o.material.needsUpdate = !0), this._renderScene(o, o.camera, !1);
    }
  }
  clearColor() {
    return this.clear(!0, !1, !1);
  }
  clearDepth() {
    return this.clear(!1, !0, !1);
  }
  clearStencil() {
    return this.clear(!1, !1, !0);
  }
  async clearAsync(e = !0, i = !0, n = !0) {
    this._initialized === !1 && await this.init(), this.clear(e, i, n);
  }
  clearColorAsync() {
    return this.clearAsync(!0, !1, !1);
  }
  clearDepthAsync() {
    return this.clearAsync(!1, !0, !1);
  }
  clearStencilAsync() {
    return this.clearAsync(!1, !1, !0);
  }
  get currentToneMapping() {
    return this._renderTarget !== null ? Yu : this.toneMapping;
  }
  get currentColorSpace() {
    return this._renderTarget !== null ? po : this.outputColorSpace;
  }
  dispose() {
    this.info.dispose(), this.backend.dispose(), this._animation.dispose(), this._objects.dispose(), this._pipelines.dispose(), this._nodes.dispose(), this._bindings.dispose(), this._renderLists.dispose(), this._renderContexts.dispose(), this._textures.dispose(), this.setRenderTarget(null), this.setAnimationLoop(null);
  }
  setRenderTarget(e, i = 0, n = 0) {
    this._renderTarget = e, this._activeCubeFace = i, this._activeMipmapLevel = n;
  }
  getRenderTarget() {
    return this._renderTarget;
  }
  setRenderObjectFunction(e) {
    this._renderObjectFunction = e;
  }
  getRenderObjectFunction() {
    return this._renderObjectFunction;
  }
  compute(e) {
    if (this.isDeviceLost === !0) return;
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."), this.computeAsync(e);
    const i = this._nodes.nodeFrame, n = i.renderId;
    this.info.calls++, this.info.compute.calls++, this.info.compute.frameCalls++, i.renderId = this.info.calls;
    const s = this.backend, a = this._pipelines, o = this._bindings, l = this._nodes, u = Array.isArray(e) ? e : [e];
    if (u[0] === void 0 || u[0].isComputeNode !== !0)
      throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
    s.beginCompute(e);
    for (const c of u) {
      if (a.has(c) === !1) {
        const p = () => {
          c.removeEventListener("dispose", p), a.delete(c), o.delete(c), l.delete(c);
        };
        c.addEventListener("dispose", p);
        const f = c.onInitFunction;
        f !== null && f.call(c, { renderer: this });
      }
      l.updateForCompute(c), o.updateForCompute(c);
      const h = o.getForCompute(c), d = a.getForCompute(c, h);
      s.compute(e, c, h, d);
    }
    s.finishCompute(e), i.renderId = n;
  }
  async computeAsync(e) {
    this._initialized === !1 && await this.init(), this.compute(e), await this.backend.resolveTimestampAsync(e, "compute");
  }
  async hasFeatureAsync(e) {
    return this._initialized === !1 && await this.init(), this.backend.hasFeature(e);
  }
  hasFeature(e) {
    return this._initialized === !1 ? (console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."), !1) : this.backend.hasFeature(e);
  }
  copyFramebufferToTexture(e, i = null) {
    if (i !== null)
      if (i.isVector2)
        i = Ha.set(i.x, i.y, e.image.width, e.image.height).floor();
      else if (i.isVector4)
        i = Ha.copy(i).floor();
      else {
        console.error("THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.");
        return;
      }
    else
      i = Ha.set(0, 0, e.image.width, e.image.height);
    let n = this._currentRenderContext, s;
    n !== null ? s = n.renderTarget : (s = this._renderTarget || this._getFrameBufferTarget(), s !== null && (this._textures.updateRenderTarget(s), n = this._textures.get(s))), this._textures.updateTexture(e, { renderTarget: s }), this.backend.copyFramebufferToTexture(e, n, i);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    this._textures.updateTexture(e), this._textures.updateTexture(i), this.backend.copyTextureToTexture(e, i, n, s, a);
  }
  readRenderTargetPixelsAsync(e, i, n, s, a, o = 0, l = 0) {
    return this.backend.copyTextureToBuffer(e.textures[o], i, n, s, a, l);
  }
  _projectObject(e, i, n, s) {
    if (e.visible === !1) return;
    if (e.layers.test(i.layers)) {
      if (e.isGroup)
        n = e.renderOrder;
      else if (e.isLOD)
        e.autoUpdate === !0 && e.update(i);
      else if (e.isLight)
        s.pushLight(e);
      else if (e.isSprite) {
        if (!e.frustumCulled || gv.intersectsSprite(e)) {
          this.sortObjects === !0 && Ha.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Ef);
          const { geometry: o, material: l } = e;
          l.visible && s.push(e, o, l, n, Ha.z, null);
        }
      } else if (e.isLineLoop)
        console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
      else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || gv.intersectsObject(e))) {
        const { geometry: o, material: l } = e;
        if (this.sortObjects === !0 && (o.boundingSphere === null && o.computeBoundingSphere(), Ha.copy(o.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(Ef)), Array.isArray(l)) {
          const u = o.groups;
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c], p = l[d.materialIndex];
            p && p.visible && s.push(e, o, p, n, Ha.z, d);
          }
        } else l.visible && s.push(e, o, l, n, Ha.z, null);
      }
    }
    if (e.isBundleGroup === !0 && this.backend.beginBundle !== void 0) {
      const o = s;
      s = this._renderLists.get(e, i), s.begin(), o.pushBundle({
        bundleGroup: e,
        camera: i,
        renderList: s
      }), s.finish();
    }
    const a = e.children;
    for (let o = 0, l = a.length; o < l; o++)
      this._projectObject(a[o], i, n, s);
  }
  _renderBundles(e, i, n) {
    for (const s of e)
      this._renderBundle(s, i, n);
  }
  _renderTransparents(e, i, n, s, a) {
    if (i.length > 0) {
      for (const { material: o } of i)
        o.side = Zn;
      this._renderObjects(i, n, s, a, "backSide");
      for (const { material: o } of i)
        o.side = bc;
      this._renderObjects(e, n, s, a);
      for (const { material: o } of i)
        o.side = $u;
    } else
      this._renderObjects(e, n, s, a);
  }
  _renderObjects(e, i, n, s, a = null) {
    for (let o = 0, l = e.length; o < l; o++) {
      const u = e[o], { object: c, geometry: h, material: d, group: p } = u;
      if (i.isArrayCamera) {
        const f = i.cameras;
        for (let m = 0, y = f.length; m < y; m++) {
          const v = f[m];
          if (c.layers.test(v.layers)) {
            const g = v.viewport, _ = g.minDepth === void 0 ? 0 : g.minDepth, x = g.maxDepth === void 0 ? 1 : g.maxDepth, b = this._currentRenderContext.viewportValue;
            b.copy(g).multiplyScalar(this._pixelRatio).floor(), b.minDepth = _, b.maxDepth = x, this.backend.updateViewport(this._currentRenderContext), this._currentRenderObjectFunction(c, n, v, h, d, p, s, a);
          }
        }
      } else
        this._currentRenderObjectFunction(c, n, i, h, d, p, s, a);
    }
  }
  renderObject(e, i, n, s, a, o, l, u = null) {
    let c, h, d;
    if (e.onBeforeRender(this, i, n, s, a, o), i.overrideMaterial !== null) {
      const p = i.overrideMaterial;
      a.positionNode && a.positionNode.isNode && (c = p.positionNode, p.positionNode = a.positionNode), p.isShadowNodeMaterial && (p.side = a.shadowSide === null ? a.side : a.shadowSide, a.depthNode && a.depthNode.isNode && (d = p.depthNode, p.depthNode = a.depthNode), a.shadowNode && a.shadowNode.isNode && (h = p.fragmentNode, p.fragmentNode = a.shadowNode), this.localClippingEnabled && (a.clipShadows ? (p.clippingPlanes !== a.clippingPlanes && (p.clippingPlanes = a.clippingPlanes, p.needsUpdate = !0), p.clipIntersection !== a.clipIntersection && (p.clipIntersection = a.clipIntersection)) : Array.isArray(p.clippingPlanes) && (p.clippingPlanes = null, p.needsUpdate = !0))), a = p;
    }
    a.transparent === !0 && a.side === $u && a.forceSinglePass === !1 ? (a.side = Zn, this._handleObjectFunction(e, a, i, n, l, o, "backSide"), a.side = bc, this._handleObjectFunction(e, a, i, n, l, o, u), a.side = $u) : this._handleObjectFunction(e, a, i, n, l, o, u), c !== void 0 && (i.overrideMaterial.positionNode = c), d !== void 0 && (i.overrideMaterial.depthNode = d), h !== void 0 && (i.overrideMaterial.fragmentNode = h), e.onAfterRender(this, i, n, s, a, o);
  }
  _renderObjectDirect(e, i, n, s, a, o, l) {
    const u = this._objects.get(e, i, n, s, a, this._currentRenderContext, l);
    u.drawRange = e.geometry.drawRange, u.group = o;
    const c = this._nodes.needsRefresh(u);
    c && (this._nodes.updateBefore(u), this._geometries.updateForRender(u), this._nodes.updateForRender(u), this._bindings.updateForRender(u)), this._pipelines.updateForRender(u), this._currentRenderBundle !== null && (this.backend.get(this._currentRenderBundle).renderObjects.push(u), u.bundle = this._currentRenderBundle.scene), this.backend.draw(u, this.info), c && this._nodes.updateAfter(u);
  }
  _createObjectPipeline(e, i, n, s, a, o) {
    const l = this._objects.get(e, i, n, s, a, this._currentRenderContext, o);
    this._nodes.updateBefore(l), this._geometries.updateForRender(l), this._nodes.updateForRender(l), this._bindings.updateForRender(l), this._pipelines.getForRender(l, this._compilationPromises), this._nodes.updateAfter(l);
  }
  get compile() {
    return this.compileAsync;
  }
}
class K1 {
  constructor(e = "") {
    this.name = e, this.visibility = 0;
  }
  setVisibility(e) {
    this.visibility |= e;
  }
  clone() {
    return Object.assign(new this.constructor(), this);
  }
}
function FQ(r) {
  return r + (to - r % to) % to;
}
class o3 extends K1 {
  constructor(e, i = null) {
    super(e), this.isBuffer = !0, this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT, this._buffer = i;
  }
  get byteLength() {
    return FQ(this._buffer.byteLength);
  }
  get buffer() {
    return this._buffer;
  }
  update() {
    return !0;
  }
}
class l3 extends o3 {
  constructor(e, i = null) {
    super(e, i), this.isUniformBuffer = !0;
  }
}
let BQ = 0;
class u3 extends l3 {
  constructor(e, i) {
    super("UniformBuffer_" + BQ++, e ? e.value : null), this.nodeUniform = e, this.groupNode = i;
  }
  get buffer() {
    return this.nodeUniform.value;
  }
}
class zQ extends l3 {
  constructor(e) {
    super(e), this.isUniformsGroup = !0, this._values = null, this.uniforms = [];
  }
  addUniform(e) {
    return this.uniforms.push(e), this;
  }
  removeUniform(e) {
    const i = this.uniforms.indexOf(e);
    return i !== -1 && this.uniforms.splice(i, 1), this;
  }
  get values() {
    return this._values === null && (this._values = Array.from(this.buffer)), this._values;
  }
  get buffer() {
    let e = this._buffer;
    if (e === null) {
      const i = this.byteLength;
      e = new Float32Array(new ArrayBuffer(i)), this._buffer = e;
    }
    return e;
  }
  get byteLength() {
    let e = 0;
    for (let i = 0, n = this.uniforms.length; i < n; i++) {
      const s = this.uniforms[i], { boundary: a, itemSize: o } = s, l = e % to, u = to - l;
      l !== 0 && u - a < 0 ? e += to - l : l % a !== 0 && (e += l % a), s.offset = e / this.bytesPerElement, e += o * this.bytesPerElement;
    }
    return Math.ceil(e / to) * to;
  }
  update() {
    let e = !1;
    for (const i of this.uniforms)
      this.updateByType(i) === !0 && (e = !0);
    return e;
  }
  updateByType(e) {
    if (e.isNumberUniform) return this.updateNumber(e);
    if (e.isVector2Uniform) return this.updateVector2(e);
    if (e.isVector3Uniform) return this.updateVector3(e);
    if (e.isVector4Uniform) return this.updateVector4(e);
    if (e.isColorUniform) return this.updateColor(e);
    if (e.isMatrix3Uniform) return this.updateMatrix3(e);
    if (e.isMatrix4Uniform) return this.updateMatrix4(e);
    console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.", e);
  }
  updateNumber(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a] !== s) {
      const o = this.buffer;
      o[a] = n[a] = s, i = !0;
    }
    return i;
  }
  updateVector2(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, i = !0;
    }
    return i;
  }
  updateVector3(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y || n[a + 2] !== s.z) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, o[a + 2] = n[a + 2] = s.z, i = !0;
    }
    return i;
  }
  updateVector4(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y || n[a + 2] !== s.z || n[a + 4] !== s.w) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, o[a + 2] = n[a + 2] = s.z, o[a + 3] = n[a + 3] = s.w, i = !0;
    }
    return i;
  }
  updateColor(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.r || n[a + 1] !== s.g || n[a + 2] !== s.b) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.r, o[a + 1] = n[a + 1] = s.g, o[a + 2] = n[a + 2] = s.b, i = !0;
    }
    return i;
  }
  updateMatrix3(e) {
    let i = !1;
    const n = this.values, s = e.getValue().elements, a = e.offset;
    if (n[a + 0] !== s[0] || n[a + 1] !== s[1] || n[a + 2] !== s[2] || n[a + 4] !== s[3] || n[a + 5] !== s[4] || n[a + 6] !== s[5] || n[a + 8] !== s[6] || n[a + 9] !== s[7] || n[a + 10] !== s[8]) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s[0], o[a + 1] = n[a + 1] = s[1], o[a + 2] = n[a + 2] = s[2], o[a + 4] = n[a + 4] = s[3], o[a + 5] = n[a + 5] = s[4], o[a + 6] = n[a + 6] = s[5], o[a + 8] = n[a + 8] = s[6], o[a + 9] = n[a + 9] = s[7], o[a + 10] = n[a + 10] = s[8], i = !0;
    }
    return i;
  }
  updateMatrix4(e) {
    let i = !1;
    const n = this.values, s = e.getValue().elements, a = e.offset;
    return VQ(n, s, a) === !1 && (this.buffer.set(s, a), jQ(n, s, a), i = !0), i;
  }
}
function jQ(r, e, i) {
  for (let n = 0, s = e.length; n < s; n++)
    r[i + n] = e[n];
}
function VQ(r, e, i) {
  for (let n = 0, s = e.length; n < s; n++)
    if (r[i + n] !== e[n]) return !1;
  return !0;
}
let GQ = 0;
class c3 extends zQ {
  constructor(e, i) {
    super(e), this.id = GQ++, this.groupNode = i, this.isNodeUniformsGroup = !0;
  }
  getNodes() {
    const e = [];
    for (const i of this.uniforms) {
      const n = i.nodeUniform.node;
      if (!n) throw new Error("NodeUniformsGroup: Uniform has no node.");
      e.push(n);
    }
    return e;
  }
}
let HQ = 0;
class WQ extends K1 {
  constructor(e, i) {
    super(e), this.id = HQ++, this.texture = i, this.version = i ? i.version : 0, this.store = !1, this.generation = null, this.isSampledTexture = !0;
  }
  needsBindingsUpdate(e) {
    const { texture: i } = this;
    return e !== this.generation ? (this.generation = e, !0) : i.isVideoTexture;
  }
  update() {
    const { texture: e, version: i } = this;
    return i !== e.version ? (this.version = e.version, !0) : !1;
  }
}
class Wg extends WQ {
  constructor(e, i, n, s = null) {
    super(e, i ? i.value : null), this.textureNode = i, this.groupNode = n, this.access = s;
  }
  needsBindingsUpdate(e) {
    return this.textureNode.value !== this.texture || super.needsBindingsUpdate(e);
  }
  update() {
    const { textureNode: e } = this;
    return this.texture !== e.value ? (this.texture = e.value, !0) : super.update();
  }
}
class h3 extends Wg {
  constructor(e, i, n, s) {
    super(e, i, n, s), this.isSampledCubeTexture = !0;
  }
}
class d3 extends Wg {
  constructor(e, i, n, s) {
    super(e, i, n, s), this.isSampledTexture3D = !0;
  }
}
const qQ = {
  atan2: "atan",
  textureDimensions: "textureSize",
  equals: "equal"
}, XQ = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
}, pA = {
  swizzleAssign: !0,
  storageBuffer: !1
}, fA = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;
class $Q extends r3 {
  constructor(e, i) {
    super(e, i, new PQ()), this.uniformGroups = {}, this.transforms = [], this.extensions = {}, this.useComparisonMethod = !0;
  }
  needsColorSpaceToLinearSRGB(e) {
    return e.isVideoTexture === !0 && e.colorSpace !== Sl;
  }
  getMethod(e) {
    return qQ[e] || e;
  }
  getOutputStructName() {
    return "";
  }
  buildFunctionCode(e) {
    const i = e.layout, n = this.flowShaderNode(e), s = [];
    for (const a of i.inputs)
      s.push(this.getType(a.type) + " " + a.name);
    return `${this.getType(i.type)} ${i.name}( ${s.join(", ")} ) {

	${n.vars}

${n.code}
	return ${n.result};

}`;
  }
  setupPBO(e) {
    const i = e.value;
    if (i.pbo === void 0) {
      const n = i.array, s = i.count * i.itemSize, { itemSize: a } = i, o = i.array.constructor.name.toLowerCase().includes("int");
      let l = o ? c1 : u1;
      a === 2 ? l = o ? h1 : yd : a === 3 ? l = o ? e7 : l1 : a === 4 && (l = o ? d1 : Bc);
      const u = {
        Float32Array: an,
        Uint8Array: ho,
        Uint16Array: Lu,
        Uint32Array: Ji,
        Int8Array: Jh,
        Int16Array: ed,
        Int32Array: Tr,
        Uint8ClampedArray: ho
      }, c = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(s / a))));
      let h = Math.ceil(s / a / c);
      c * h * a < s && h++;
      const d = c * h * a, p = new n.constructor(d);
      p.set(n, 0), i.array = p;
      const f = new aW(i.array, c, h, l, u[i.array.constructor.name] || an);
      f.needsUpdate = !0, f.isPBOTexture = !0;
      const m = new rp(f, null, null);
      m.setPrecision("high"), i.pboNode = m, i.pbo = m.value, this.getUniformFromNode(i.pboNode, "texture", this.shaderStage, this.context.label);
    }
  }
  getPropertyName(e, i = this.shaderStage) {
    return e.isNodeUniform && e.node.isTextureNode !== !0 && e.node.isBufferNode !== !0 ? i.charAt(0) + "_" + e.name : super.getPropertyName(e, i);
  }
  generatePBO(e) {
    const { node: i, indexNode: n } = e, s = i.value;
    if (this.renderer.backend.has(s)) {
      const h = this.renderer.backend.get(s);
      h.pbo = s.pbo;
    }
    const a = this.getUniformFromNode(s.pboNode, "texture", this.shaderStage, this.context.label), o = this.getPropertyName(a);
    this.increaseUsage(n);
    const l = n.build(this, "uint"), u = this.getDataFromNode(e);
    let c = u.propertyName;
    if (c === void 0) {
      const h = this.getVarFromNode(e);
      c = this.getPropertyName(h);
      const d = this.getDataFromNode(i);
      let p = d.propertySizeName;
      p === void 0 && (p = c + "Size", this.getVarFromNode(i, p, "uint"), this.addLineFlowCode(`${p} = uint( textureSize( ${o}, 0 ).x )`, e), d.propertySizeName = p);
      const { itemSize: f } = s, m = "." + Gc.join("").slice(0, f), y = `ivec2(${l} % ${p}, ${l} / ${p})`, v = this.generateTextureLoad(null, o, y, null, "0");
      let g = "vec4";
      s.pbo.type === Ji ? g = "uvec4" : s.pbo.type === Tr && (g = "ivec4"), this.addLineFlowCode(`${c} = ${g}(${v})${m}`, e), u.propertyName = c;
    }
    return c;
  }
  generateTextureLoad(e, i, n, s, a = "0") {
    return s ? `texelFetch( ${i}, ivec3( ${n}, ${s} ), ${a} )` : `texelFetch( ${i}, ${n}, ${a} )`;
  }
  generateTexture(e, i, n, s) {
    return e.isDepthTexture ? `texture( ${i}, ${n} ).x` : (s && (n = `vec3( ${n}, ${s} )`), `texture( ${i}, ${n} )`);
  }
  generateTextureLevel(e, i, n, s) {
    return `textureLod( ${i}, ${n}, ${s} )`;
  }
  generateTextureBias(e, i, n, s) {
    return `texture( ${i}, ${n}, ${s} )`;
  }
  generateTextureGrad(e, i, n, s) {
    return `textureGrad( ${i}, ${n}, ${s[0]}, ${s[1]} )`;
  }
  generateTextureCompare(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `texture( ${i}, vec3( ${n}, ${s} ) )`;
    console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${o} shader.`);
  }
  getVars(e) {
    const i = [], n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`${this.getVar(s.type, s.name)};`);
    return i.join(`
	`);
  }
  getUniforms(e) {
    const i = this.uniforms[e], n = [], s = {};
    for (const o of i) {
      let l = null, u = !1;
      if (o.type === "texture") {
        const h = o.node.value;
        let d = "";
        h.isDataTexture === !0 && (h.type === Ji ? d = "u" : h.type === Tr && (d = "i")), h.compareFunction ? l = `sampler2DShadow ${o.name};` : h.isDataArrayTexture === !0 || h.isCompressedArrayTexture === !0 ? l = `${d}sampler2DArray ${o.name};` : l = `${d}sampler2D ${o.name};`;
      } else if (o.type === "cubeTexture")
        l = `samplerCube ${o.name};`;
      else if (o.type === "texture3D")
        l = `sampler3D ${o.name};`;
      else if (o.type === "buffer") {
        const h = o.node, d = this.getType(h.bufferType), p = h.bufferCount, f = p > 0 ? p : "";
        l = `${h.name} {
	${d} ${o.name}[${f}];
};
`;
      } else
        l = `${this.getVectorType(o.type)} ${this.getPropertyName(o, e)};`, u = !0;
      const c = o.node.precision;
      if (c !== null && (l = XQ[c] + " " + l), u) {
        l = "	" + l;
        const h = o.groupNode.name;
        (s[h] || (s[h] = [])).push(l);
      } else
        l = "uniform " + l, n.push(l);
    }
    let a = "";
    for (const o in s) {
      const l = s[o];
      a += this._getGLSLUniformStruct(e + "_" + o, l.join(`
`)) + `
`;
    }
    return a += n.join(`
`), a;
  }
  getTypeFromAttribute(e) {
    let i = super.getTypeFromAttribute(e);
    if (/^[iu]/.test(i) && e.gpuType !== Tr) {
      let n = e;
      e.isInterleavedBufferAttribute && (n = e.data);
      const s = n.array;
      s instanceof Uint32Array || s instanceof Int32Array || (i = i.slice(1));
    }
    return i;
  }
  getAttributes(e) {
    let i = "";
    if (e === "vertex" || e === "compute") {
      const n = this.getAttributesArray();
      let s = 0;
      for (const a of n)
        i += `layout( location = ${s++} ) in ${a.type} ${a.name};
`;
    }
    return i;
  }
  getStructMembers(e) {
    const i = [], n = e.getMemberTypes();
    for (let s = 0; s < n.length; s++) {
      const a = n[s];
      i.push(`layout( location = ${s} ) out ${a} m${s};`);
    }
    return i.join(`
`);
  }
  getStructs(e) {
    const i = [], n = this.structs[e];
    if (n.length === 0)
      return `layout( location = 0 ) out vec4 fragColor;
`;
    for (let s = 0, a = n.length; s < a; s++) {
      const o = n[s];
      let l = `
`;
      l += this.getStructMembers(o), l += `
`, i.push(l);
    }
    return i.join(`

`);
  }
  getVaryings(e) {
    let i = "";
    const n = this.varyings;
    if (e === "vertex" || e === "compute")
      for (const s of n) {
        e === "compute" && (s.needsInterpolation = !0);
        const a = s.type, o = a.includes("int") || a.includes("uv") || a.includes("iv") ? "flat " : "";
        i += `${o}${s.needsInterpolation ? "out" : "/*out*/"} ${a} ${s.name};
`;
      }
    else if (e === "fragment") {
      for (const s of n)
        if (s.needsInterpolation) {
          const a = s.type, o = a.includes("int") || a.includes("uv") || a.includes("iv") ? "flat " : "";
          i += `${o}in ${a} ${s.name};
`;
        }
    }
    return i;
  }
  getVertexIndex() {
    return "uint( gl_VertexID )";
  }
  getInstanceIndex() {
    return "uint( gl_InstanceID )";
  }
  getInvocationLocalIndex() {
    return `uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce((e, i) => e * i, 1)}u`;
  }
  getDrawIndex() {
    return this.renderer.backend.extensions.has("WEBGL_multi_draw") ? "uint( gl_DrawID )" : null;
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord.xy";
  }
  getFragDepth() {
    return "gl_FragDepth";
  }
  enableExtension(e, i, n = this.shaderStage) {
    const s = this.extensions[n] || (this.extensions[n] = /* @__PURE__ */ new Map());
    s.has(e) === !1 && s.set(e, {
      name: e,
      behavior: i
    });
  }
  getExtensions(e) {
    const i = [];
    if (e === "vertex") {
      const s = this.renderer.backend.extensions;
      this.object.isBatchedMesh && s.has("WEBGL_multi_draw") && this.enableExtension("GL_ANGLE_multi_draw", "require", e);
    }
    const n = this.extensions[e];
    if (n !== void 0)
      for (const { name: s, behavior: a } of n.values())
        i.push(`#extension ${s} : ${a}`);
    return i.join(`
`);
  }
  isAvailable(e) {
    let i = pA[e];
    if (i === void 0) {
      if (e === "float32Filterable") {
        const n = this.renderer.backend.extensions;
        n.has("OES_texture_float_linear") ? (n.get("OES_texture_float_linear"), i = !0) : i = !1;
      }
      pA[e] = i;
    }
    return i;
  }
  isFlipY() {
    return !0;
  }
  registerTransform(e, i) {
    this.transforms.push({ varyingName: e, attributeNode: i });
  }
  getTransforms() {
    const e = this.transforms;
    let i = "";
    for (let n = 0; n < e.length; n++) {
      const s = e[n], a = this.getPropertyName(s.attributeNode);
      i += `${s.varyingName} = ${a};
	`;
    }
    return i;
  }
  _getGLSLUniformStruct(e, i) {
    return `
layout( std140 ) uniform ${e} {
${i}
};`;
  }
  _getGLSLVertexCode(e) {
    return `#version 300 es

${this.getSignature()}

// extensions 
${e.extensions}

// precision
${fA}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// attributes
${e.attributes}

// codes
${e.codes}

void main() {

	// vars
	${e.vars}

	// transforms
	${e.transforms}

	// flow
	${e.flow}

	gl_PointSize = 1.0;

}
`;
  }
  _getGLSLFragmentCode(e) {
    return `#version 300 es

${this.getSignature()}

// precision
${fA}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// codes
${e.codes}

${e.structs}

void main() {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const i in e) {
      let n = `// code

`;
      n += this.flowCode[i];
      const s = this.flowNodes[i], a = s[s.length - 1];
      for (const l of s) {
        const u = this.getFlowData(
          l
          /*, shaderStage*/
        ), c = l.name;
        c && (n.length > 0 && (n += `
`), n += `	// flow -> ${c}
	`), n += `${u.code}
	`, l === a && i !== "compute" && (n += `// result
	`, i === "vertex" ? (n += "gl_Position = ", n += `${u.result};`) : i === "fragment" && (l.outputNode.isOutputStructNode || (n += "fragColor = ", n += `${u.result};`)));
      }
      const o = e[i];
      o.extensions = this.getExtensions(i), o.uniforms = this.getUniforms(i), o.attributes = this.getAttributes(i), o.varyings = this.getVaryings(i), o.vars = this.getVars(i), o.structs = this.getStructs(i), o.codes = this.getCodes(i), o.transforms = this.getTransforms(i), o.flow = n;
    }
    this.material !== null ? (this.vertexShader = this._getGLSLVertexCode(e.vertex), this.fragmentShader = this._getGLSLFragmentCode(e.fragment)) : this.computeShader = this._getGLSLVertexCode(e.compute);
  }
  getUniformFromNode(e, i, n, s = null) {
    const a = super.getUniformFromNode(e, i, n, s), o = this.getDataFromNode(e, n, this.globalCache);
    let l = o.uniformGPU;
    if (l === void 0) {
      const u = e.groupNode, c = u.name, h = this.getBindGroupArray(c, n);
      if (i === "texture")
        l = new Wg(a.name, a.node, u), h.push(l);
      else if (i === "cubeTexture")
        l = new h3(a.name, a.node, u), h.push(l);
      else if (i === "texture3D")
        l = new d3(a.name, a.node, u), h.push(l);
      else if (i === "buffer") {
        e.name = `NodeBuffer_${e.id}`, a.name = `buffer${e.id}`;
        const d = new u3(e, u);
        d.name = e.name, h.push(d), l = d;
      } else {
        const d = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let p = d[c];
        p === void 0 && (p = new c3(n + "_" + c, u), d[c] = p, h.push(p)), l = this.getNodeUniform(a, i), p.addUniform(l);
      }
      o.uniformGPU = l;
    }
    return a;
  }
}
let yv = null, vv = null, Tu = null;
class p3 {
  constructor(e = {}) {
    this.parameters = Object.assign({}, e), this.data = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.domElement = null;
  }
  async init(e) {
    this.renderer = e;
  }
  // render context
  begin() {
  }
  finish() {
  }
  // render object
  draw() {
  }
  // program
  createProgram() {
  }
  destroyProgram() {
  }
  // bindings
  createBindings() {
  }
  updateBindings() {
  }
  // pipeline
  createRenderPipeline() {
  }
  createComputePipeline() {
  }
  destroyPipeline() {
  }
  // cache key
  needsRenderUpdate() {
  }
  // return Boolean ( fast test )
  getRenderCacheKey() {
  }
  // return String
  // node builder
  createNodeBuilder() {
  }
  // return NodeBuilder (ADD IT)
  // textures
  createSampler() {
  }
  createDefaultTexture() {
  }
  createTexture() {
  }
  copyTextureToBuffer() {
  }
  // attributes
  createAttribute() {
  }
  createIndexAttribute() {
  }
  updateAttribute() {
  }
  destroyAttribute() {
  }
  // canvas
  getContext() {
  }
  updateSize() {
  }
  // utils
  resolveTimestampAsync() {
  }
  hasFeatureAsync() {
  }
  // return Boolean
  hasFeature() {
  }
  // return Boolean
  getInstanceCount(e) {
    const { object: i, geometry: n } = e;
    return n.isInstancedBufferGeometry ? n.instanceCount : i.count > 1 ? i.count : 1;
  }
  getDrawingBufferSize() {
    return yv = yv || new Vt(), this.renderer.getDrawingBufferSize(yv);
  }
  getScissor() {
    return vv = vv || new Yt(), this.renderer.getScissor(vv);
  }
  setScissorTest() {
  }
  getClearColor() {
    const e = this.renderer;
    return Tu = Tu || new G1(), e.getClearColor(Tu), Tu.getRGB(Tu, this.renderer.currentColorSpace), Tu;
  }
  getDomElement() {
    let e = this.domElement;
    return e === null && (e = this.parameters.canvas !== void 0 ? this.parameters.canvas : L7(), "setAttribute" in e && e.setAttribute("data-engine", `three.js r${Pg} webgpu`), this.domElement = e), e;
  }
  // resource properties
  set(e, i) {
    this.data.set(e, i);
  }
  get(e) {
    let i = this.data.get(e);
    return i === void 0 && (i = {}, this.data.set(e, i)), i;
  }
  has(e) {
    return this.data.has(e);
  }
  delete(e) {
    this.data.delete(e);
  }
  dispose() {
  }
}
let YQ = 0;
class KQ {
  constructor(e, i) {
    this.buffers = [e.bufferGPU, i], this.type = e.type, this.bufferType = e.bufferType, this.pbo = e.pbo, this.byteLength = e.byteLength, this.bytesPerElement = e.BYTES_PER_ELEMENT, this.version = e.version, this.isInteger = e.isInteger, this.activeBufferIndex = 0, this.baseId = e.id;
  }
  get id() {
    return `${this.baseId}|${this.activeBufferIndex}`;
  }
  get bufferGPU() {
    return this.buffers[this.activeBufferIndex];
  }
  get transformBuffer() {
    return this.buffers[this.activeBufferIndex ^ 1];
  }
  switchBuffers() {
    this.activeBufferIndex ^= 1;
  }
}
class ZQ {
  constructor(e) {
    this.backend = e;
  }
  createAttribute(e, i) {
    const n = this.backend, { gl: s } = n, a = e.array, o = e.usage || s.STATIC_DRAW, l = e.isInterleavedBufferAttribute ? e.data : e, u = n.get(l);
    let c = u.bufferGPU;
    c === void 0 && (c = this._createBuffer(s, i, a, o), u.bufferGPU = c, u.bufferType = i, u.version = l.version);
    let h;
    if (a instanceof Float32Array)
      h = s.FLOAT;
    else if (a instanceof Uint16Array)
      e.isFloat16BufferAttribute ? h = s.HALF_FLOAT : h = s.UNSIGNED_SHORT;
    else if (a instanceof Int16Array)
      h = s.SHORT;
    else if (a instanceof Uint32Array)
      h = s.UNSIGNED_INT;
    else if (a instanceof Int32Array)
      h = s.INT;
    else if (a instanceof Int8Array)
      h = s.BYTE;
    else if (a instanceof Uint8Array)
      h = s.UNSIGNED_BYTE;
    else if (a instanceof Uint8ClampedArray)
      h = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + a);
    let d = {
      bufferGPU: c,
      bufferType: i,
      type: h,
      byteLength: a.byteLength,
      bytesPerElement: a.BYTES_PER_ELEMENT,
      version: e.version,
      pbo: e.pbo,
      isInteger: h === s.INT || h === s.UNSIGNED_INT || e.gpuType === Tr,
      id: YQ++
    };
    if (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute) {
      const p = this._createBuffer(s, i, a, o);
      d = new KQ(d, p);
    }
    n.set(e, d);
  }
  updateAttribute(e) {
    const i = this.backend, { gl: n } = i, s = e.array, a = e.isInterleavedBufferAttribute ? e.data : e, o = i.get(a), l = o.bufferType, u = e.isInterleavedBufferAttribute ? e.data.updateRanges : e.updateRanges;
    if (n.bindBuffer(l, o.bufferGPU), u.length === 0)
      n.bufferSubData(l, 0, s);
    else {
      for (let c = 0, h = u.length; c < h; c++) {
        const d = u[c];
        n.bufferSubData(
          l,
          d.start * s.BYTES_PER_ELEMENT,
          s,
          d.start,
          d.count
        );
      }
      a.clearUpdateRanges();
    }
    n.bindBuffer(l, null), o.version = a.version;
  }
  destroyAttribute(e) {
    const i = this.backend, { gl: n } = i;
    e.isInterleavedBufferAttribute && i.delete(e.data);
    const s = i.get(e);
    n.deleteBuffer(s.bufferGPU), i.delete(e);
  }
  async getArrayBufferAsync(e) {
    const i = this.backend, { gl: n } = i, s = e.isInterleavedBufferAttribute ? e.data : e, { bufferGPU: a } = i.get(s), o = e.array, l = o.byteLength;
    n.bindBuffer(n.COPY_READ_BUFFER, a);
    const u = n.createBuffer();
    n.bindBuffer(n.COPY_WRITE_BUFFER, u), n.bufferData(n.COPY_WRITE_BUFFER, l, n.STREAM_READ), n.copyBufferSubData(n.COPY_READ_BUFFER, n.COPY_WRITE_BUFFER, 0, 0, l), await i.utils._clientWaitAsync();
    const c = new e.array.constructor(o.length);
    return n.bindBuffer(n.COPY_WRITE_BUFFER, u), n.getBufferSubData(n.COPY_WRITE_BUFFER, 0, c), n.deleteBuffer(u), n.bindBuffer(n.COPY_READ_BUFFER, null), n.bindBuffer(n.COPY_WRITE_BUFFER, null), c.buffer;
  }
  _createBuffer(e, i, n, s) {
    const a = e.createBuffer();
    return e.bindBuffer(i, a), e.bufferData(i, n, s), e.bindBuffer(i, null), a;
  }
}
let mA = !1, bv, Ch;
class QQ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.enabled = {}, this.currentFlipSided = null, this.currentCullFace = null, this.currentProgram = null, this.currentBlendingEnabled = !1, this.currentBlending = null, this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentPremultipledAlpha = null, this.currentPolygonOffsetFactor = null, this.currentPolygonOffsetUnits = null, this.currentColorMask = null, this.currentDepthFunc = null, this.currentDepthMask = null, this.currentStencilFunc = null, this.currentStencilRef = null, this.currentStencilFuncMask = null, this.currentStencilFail = null, this.currentStencilZFail = null, this.currentStencilZPass = null, this.currentStencilMask = null, this.currentLineWidth = null, this.currentBoundFramebuffers = {}, this.currentDrawbuffers = /* @__PURE__ */ new WeakMap(), this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), this.currentTextureSlot = null, this.currentBoundTextures = {}, this.currentBoundBufferBases = {}, mA === !1 && (this._init(this.gl), mA = !0);
  }
  _init(e) {
    bv = {
      [Ja]: e.FUNC_ADD,
      [jN]: e.FUNC_SUBTRACT,
      [VN]: e.FUNC_REVERSE_SUBTRACT
    }, Ch = {
      [GN]: e.ZERO,
      [HN]: e.ONE,
      [WN]: e.SRC_COLOR,
      [Dm]: e.SRC_ALPHA,
      [ZN]: e.SRC_ALPHA_SATURATE,
      [YN]: e.DST_COLOR,
      [XN]: e.DST_ALPHA,
      [qN]: e.ONE_MINUS_SRC_COLOR,
      [Lm]: e.ONE_MINUS_SRC_ALPHA,
      [KN]: e.ONE_MINUS_DST_COLOR,
      [$N]: e.ONE_MINUS_DST_ALPHA
    };
  }
  enable(e) {
    const { enabled: i } = this;
    i[e] !== !0 && (this.gl.enable(e), i[e] = !0);
  }
  disable(e) {
    const { enabled: i } = this;
    i[e] !== !1 && (this.gl.disable(e), i[e] = !1);
  }
  setFlipSided(e) {
    if (this.currentFlipSided !== e) {
      const { gl: i } = this;
      e ? i.frontFace(i.CW) : i.frontFace(i.CCW), this.currentFlipSided = e;
    }
  }
  setCullFace(e) {
    const { gl: i } = this;
    e !== L9 ? (this.enable(i.CULL_FACE), e !== this.currentCullFace && (e === k9 ? i.cullFace(i.BACK) : e === U9 ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : this.disable(i.CULL_FACE), this.currentCullFace = e;
  }
  setLineWidth(e) {
    const { currentLineWidth: i, gl: n } = this;
    e !== i && (n.lineWidth(e), this.currentLineWidth = e);
  }
  setBlending(e, i, n, s, a, o, l, u) {
    const { gl: c } = this;
    if (e === xc) {
      this.currentBlendingEnabled === !0 && (this.disable(c.BLEND), this.currentBlendingEnabled = !1);
      return;
    }
    if (this.currentBlendingEnabled === !1 && (this.enable(c.BLEND), this.currentBlendingEnabled = !0), e !== zN) {
      if (e !== this.currentBlending || u !== this.currentPremultipledAlpha) {
        if ((this.currentBlendEquation !== Ja || this.currentBlendEquationAlpha !== Ja) && (c.blendEquation(c.FUNC_ADD), this.currentBlendEquation = Ja, this.currentBlendEquationAlpha = Ja), u)
          switch (e) {
            case co:
              c.blendFuncSeparate(c.ONE, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA);
              break;
            case Pm:
              c.blendFunc(c.ONE, c.ONE);
              break;
            case Im:
              c.blendFuncSeparate(c.ZERO, c.ONE_MINUS_SRC_COLOR, c.ZERO, c.ONE);
              break;
            case Om:
              c.blendFuncSeparate(c.ZERO, c.SRC_COLOR, c.ZERO, c.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
              break;
          }
        else
          switch (e) {
            case co:
              c.blendFuncSeparate(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA);
              break;
            case Pm:
              c.blendFunc(c.SRC_ALPHA, c.ONE);
              break;
            case Im:
              c.blendFuncSeparate(c.ZERO, c.ONE_MINUS_SRC_COLOR, c.ZERO, c.ONE);
              break;
            case Om:
              c.blendFunc(c.ZERO, c.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
              break;
          }
        this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentBlending = e, this.currentPremultipledAlpha = u;
      }
      return;
    }
    a = a || i, o = o || n, l = l || s, (i !== this.currentBlendEquation || a !== this.currentBlendEquationAlpha) && (c.blendEquationSeparate(bv[i], bv[a]), this.currentBlendEquation = i, this.currentBlendEquationAlpha = a), (n !== this.currentBlendSrc || s !== this.currentBlendDst || o !== this.currentBlendSrcAlpha || l !== this.currentBlendDstAlpha) && (c.blendFuncSeparate(Ch[n], Ch[s], Ch[o], Ch[l]), this.currentBlendSrc = n, this.currentBlendDst = s, this.currentBlendSrcAlpha = o, this.currentBlendDstAlpha = l), this.currentBlending = e, this.currentPremultipledAlpha = !1;
  }
  setColorMask(e) {
    this.currentColorMask !== e && (this.gl.colorMask(e, e, e, e), this.currentColorMask = e);
  }
  setDepthTest(e) {
    const { gl: i } = this;
    e ? this.enable(i.DEPTH_TEST) : this.disable(i.DEPTH_TEST);
  }
  setDepthMask(e) {
    this.currentDepthMask !== e && (this.gl.depthMask(e), this.currentDepthMask = e);
  }
  setDepthFunc(e) {
    if (this.currentDepthFunc !== e) {
      const { gl: i } = this;
      switch (e) {
        case QN:
          i.depthFunc(i.NEVER);
          break;
        case JN:
          i.depthFunc(i.ALWAYS);
          break;
        case eP:
          i.depthFunc(i.LESS);
          break;
        case km:
          i.depthFunc(i.LEQUAL);
          break;
        case tP:
          i.depthFunc(i.EQUAL);
          break;
        case iP:
          i.depthFunc(i.GEQUAL);
          break;
        case rP:
          i.depthFunc(i.GREATER);
          break;
        case nP:
          i.depthFunc(i.NOTEQUAL);
          break;
        default:
          i.depthFunc(i.LEQUAL);
      }
      this.currentDepthFunc = e;
    }
  }
  setStencilTest(e) {
    const { gl: i } = this;
    e ? this.enable(i.STENCIL_TEST) : this.disable(i.STENCIL_TEST);
  }
  setStencilMask(e) {
    this.currentStencilMask !== e && (this.gl.stencilMask(e), this.currentStencilMask = e);
  }
  setStencilFunc(e, i, n) {
    (this.currentStencilFunc !== e || this.currentStencilRef !== i || this.currentStencilFuncMask !== n) && (this.gl.stencilFunc(e, i, n), this.currentStencilFunc = e, this.currentStencilRef = i, this.currentStencilFuncMask = n);
  }
  setStencilOp(e, i, n) {
    (this.currentStencilFail !== e || this.currentStencilZFail !== i || this.currentStencilZPass !== n) && (this.gl.stencilOp(e, i, n), this.currentStencilFail = e, this.currentStencilZFail = i, this.currentStencilZPass = n);
  }
  setMaterial(e, i) {
    const { gl: n } = this;
    e.side === $u ? this.disable(n.CULL_FACE) : this.enable(n.CULL_FACE);
    let s = e.side === Zn;
    i && (s = !s), this.setFlipSided(s), e.blending === co && e.transparent === !1 ? this.setBlending(xc) : this.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), this.setDepthFunc(e.depthFunc), this.setDepthTest(e.depthTest), this.setDepthMask(e.depthWrite), this.setColorMask(e.colorWrite);
    const a = e.stencilWrite;
    this.setStencilTest(a), a && (this.setStencilMask(e.stencilWriteMask), this.setStencilFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), this.setStencilOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), this.setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), e.alphaToCoverage === !0 && this.backend.renderer.samples > 1 ? this.enable(n.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  setPolygonOffset(e, i, n) {
    const { gl: s } = this;
    e ? (this.enable(s.POLYGON_OFFSET_FILL), (this.currentPolygonOffsetFactor !== i || this.currentPolygonOffsetUnits !== n) && (s.polygonOffset(i, n), this.currentPolygonOffsetFactor = i, this.currentPolygonOffsetUnits = n)) : this.disable(s.POLYGON_OFFSET_FILL);
  }
  useProgram(e) {
    return this.currentProgram !== e ? (this.gl.useProgram(e), this.currentProgram = e, !0) : !1;
  }
  // framebuffer
  bindFramebuffer(e, i) {
    const { gl: n, currentBoundFramebuffers: s } = this;
    return s[e] !== i ? (n.bindFramebuffer(e, i), s[e] = i, e === n.DRAW_FRAMEBUFFER && (s[n.FRAMEBUFFER] = i), e === n.FRAMEBUFFER && (s[n.DRAW_FRAMEBUFFER] = i), !0) : !1;
  }
  drawBuffers(e, i) {
    const { gl: n } = this;
    let s = [], a = !1;
    if (e.textures !== null) {
      s = this.currentDrawbuffers.get(i), s === void 0 && (s = [], this.currentDrawbuffers.set(i, s));
      const o = e.textures;
      if (s.length !== o.length || s[0] !== n.COLOR_ATTACHMENT0) {
        for (let l = 0, u = o.length; l < u; l++)
          s[l] = n.COLOR_ATTACHMENT0 + l;
        s.length = o.length, a = !0;
      }
    } else
      s[0] !== n.BACK && (s[0] = n.BACK, a = !0);
    a && n.drawBuffers(s);
  }
  // texture
  activeTexture(e) {
    const { gl: i, currentTextureSlot: n, maxTextures: s } = this;
    e === void 0 && (e = i.TEXTURE0 + s - 1), n !== e && (i.activeTexture(e), this.currentTextureSlot = e);
  }
  bindTexture(e, i, n) {
    const { gl: s, currentTextureSlot: a, currentBoundTextures: o, maxTextures: l } = this;
    n === void 0 && (a === null ? n = s.TEXTURE0 + l - 1 : n = a);
    let u = o[n];
    u === void 0 && (u = { type: void 0, texture: void 0 }, o[n] = u), (u.type !== e || u.texture !== i) && (a !== n && (s.activeTexture(n), this.currentTextureSlot = n), s.bindTexture(e, i), u.type = e, u.texture = i);
  }
  bindBufferBase(e, i, n) {
    const { gl: s } = this, a = `${e}-${i}`;
    return this.currentBoundBufferBases[a] !== n ? (s.bindBufferBase(e, i, n), this.currentBoundBufferBases[a] = n, !0) : !1;
  }
  unbindTexture() {
    const { gl: e, currentTextureSlot: i, currentBoundTextures: n } = this, s = n[i];
    s !== void 0 && s.type !== void 0 && (e.bindTexture(s.type, null), s.type = void 0, s.texture = void 0);
  }
}
class JQ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.extensions = e.extensions;
  }
  convert(e, i = Sl) {
    const { gl: n, extensions: s } = this;
    let a;
    if (e === ho) return n.UNSIGNED_BYTE;
    if (e === Y9) return n.UNSIGNED_SHORT_4_4_4_4;
    if (e === K9) return n.UNSIGNED_SHORT_5_5_5_1;
    if (e === sP) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (e === Jh) return n.BYTE;
    if (e === ed) return n.SHORT;
    if (e === Lu) return n.UNSIGNED_SHORT;
    if (e === Tr) return n.INT;
    if (e === Ji) return n.UNSIGNED_INT;
    if (e === an) return n.FLOAT;
    if (e === pa)
      return n.HALF_FLOAT;
    if (e === Z9) return n.ALPHA;
    if (e === l1) return n.RGB;
    if (e === Bc) return n.RGBA;
    if (e === Q9) return n.LUMINANCE;
    if (e === J9) return n.LUMINANCE_ALPHA;
    if (e === gl) return n.DEPTH_COMPONENT;
    if (e === Tc) return n.DEPTH_STENCIL;
    if (e === u1) return n.RED;
    if (e === c1) return n.RED_INTEGER;
    if (e === yd) return n.RG;
    if (e === h1) return n.RG_INTEGER;
    if (e === d1) return n.RGBA_INTEGER;
    if (e === v0 || e === im || e === rm || e === nm)
      if (i === ct)
        if (a = s.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (e === v0) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (e === im) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (e === rm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (e === nm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = s.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (e === v0) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (e === im) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (e === rm) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (e === nm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (e === NE || e === PE || e === IE || e === OE)
      if (a = s.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (e === NE) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (e === PE) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (e === IE) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (e === OE) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (e === DE || e === nx || e === sx)
      if (a = s.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (e === DE || e === nx) return i === ct ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (e === sx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (e === ax || e === ox || e === lx || e === ux || e === cx || e === hx || e === dx || e === px || e === fx || e === mx || e === gx || e === yx || e === vx || e === bx)
      if (a = s.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (e === ax) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (e === ox) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (e === lx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (e === ux) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (e === cx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (e === hx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (e === dx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (e === px) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (e === fx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (e === mx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (e === gx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (e === yx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (e === vx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (e === bx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (e === b0)
      if (a = s.get("EXT_texture_compression_bptc"), a !== null) {
        if (e === b0) return i === ct ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    if (e === t7 || e === LE || e === kE || e === UE)
      if (a = s.get("EXT_texture_compression_rgtc"), a !== null) {
        if (e === b0) return a.COMPRESSED_RED_RGTC1_EXT;
        if (e === LE) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (e === kE) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (e === UE) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return e === Kd ? n.UNSIGNED_INT_24_8 : n[e] !== void 0 ? n[e] : null;
  }
  _clientWaitAsync() {
    const { gl: e } = this, i = e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE, 0);
    return e.flush(), new Promise((n, s) => {
      function a() {
        const o = e.clientWaitSync(i, e.SYNC_FLUSH_COMMANDS_BIT, 0);
        if (o === e.WAIT_FAILED) {
          e.deleteSync(i), s();
          return;
        }
        if (o === e.TIMEOUT_EXPIRED) {
          requestAnimationFrame(a);
          return;
        }
        e.deleteSync(i), n();
      }
      a();
    });
  }
}
let gA = !1, Mf, xv, yA;
class eJ {
  constructor(e) {
    this.backend = e, this.gl = e.gl, this.extensions = e.extensions, this.defaultTextures = {}, gA === !1 && (this._init(this.gl), gA = !0);
  }
  _init(e) {
    Mf = {
      [Um]: e.REPEAT,
      [Du]: e.CLAMP_TO_EDGE,
      [Fm]: e.MIRRORED_REPEAT
    }, xv = {
      [mr]: e.NEAREST,
      [ix]: e.NEAREST_MIPMAP_NEAREST,
      [Ku]: e.NEAREST_MIPMAP_LINEAR,
      [on]: e.LINEAR,
      [rx]: e.LINEAR_MIPMAP_NEAREST,
      [da]: e.LINEAR_MIPMAP_LINEAR
    }, yA = {
      [oP]: e.NEVER,
      [pP]: e.ALWAYS,
      [p1]: e.LESS,
      [uP]: e.LEQUAL,
      [lP]: e.EQUAL,
      [dP]: e.GEQUAL,
      [cP]: e.GREATER,
      [hP]: e.NOTEQUAL
    };
  }
  filterFallback(e) {
    const { gl: i } = this;
    return e === mr || e === ix || e === Ku ? i.NEAREST : i.LINEAR;
  }
  getGLTextureType(e) {
    const { gl: i } = this;
    let n;
    return e.isCubeTexture === !0 ? n = i.TEXTURE_CUBE_MAP : e.isDataArrayTexture === !0 || e.isCompressedArrayTexture === !0 ? n = i.TEXTURE_2D_ARRAY : e.isData3DTexture === !0 ? n = i.TEXTURE_3D : n = i.TEXTURE_2D, n;
  }
  getInternalFormat(e, i, n, s, a = !1) {
    const { gl: o, extensions: l } = this;
    if (e !== null) {
      if (o[e] !== void 0) return o[e];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e + "'");
    }
    let u = i;
    return i === o.RED && (n === o.FLOAT && (u = o.R32F), n === o.HALF_FLOAT && (u = o.R16F), n === o.UNSIGNED_BYTE && (u = o.R8), n === o.UNSIGNED_SHORT && (u = o.R16), n === o.UNSIGNED_INT && (u = o.R32UI), n === o.BYTE && (u = o.R8I), n === o.SHORT && (u = o.R16I), n === o.INT && (u = o.R32I)), i === o.RED_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.R8UI), n === o.UNSIGNED_SHORT && (u = o.R16UI), n === o.UNSIGNED_INT && (u = o.R32UI), n === o.BYTE && (u = o.R8I), n === o.SHORT && (u = o.R16I), n === o.INT && (u = o.R32I)), i === o.RG && (n === o.FLOAT && (u = o.RG32F), n === o.HALF_FLOAT && (u = o.RG16F), n === o.UNSIGNED_BYTE && (u = o.RG8), n === o.UNSIGNED_SHORT && (u = o.RG16), n === o.UNSIGNED_INT && (u = o.RG32UI), n === o.BYTE && (u = o.RG8I), n === o.SHORT && (u = o.RG16I), n === o.INT && (u = o.RG32I)), i === o.RG_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RG8UI), n === o.UNSIGNED_SHORT && (u = o.RG16UI), n === o.UNSIGNED_INT && (u = o.RG32UI), n === o.BYTE && (u = o.RG8I), n === o.SHORT && (u = o.RG16I), n === o.INT && (u = o.RG32I)), i === o.RGB && (n === o.FLOAT && (u = o.RGB32F), n === o.HALF_FLOAT && (u = o.RGB16F), n === o.UNSIGNED_BYTE && (u = o.RGB8), n === o.UNSIGNED_SHORT && (u = o.RGB16), n === o.UNSIGNED_INT && (u = o.RGB32UI), n === o.BYTE && (u = o.RGB8I), n === o.SHORT && (u = o.RGB16I), n === o.INT && (u = o.RGB32I), n === o.UNSIGNED_BYTE && (u = s === ct && a === !1 ? o.SRGB8 : o.RGB8), n === o.UNSIGNED_SHORT_5_6_5 && (u = o.RGB565), n === o.UNSIGNED_SHORT_5_5_5_1 && (u = o.RGB5_A1), n === o.UNSIGNED_SHORT_4_4_4_4 && (u = o.RGB4), n === o.UNSIGNED_INT_5_9_9_9_REV && (u = o.RGB9_E5)), i === o.RGB_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RGB8UI), n === o.UNSIGNED_SHORT && (u = o.RGB16UI), n === o.UNSIGNED_INT && (u = o.RGB32UI), n === o.BYTE && (u = o.RGB8I), n === o.SHORT && (u = o.RGB16I), n === o.INT && (u = o.RGB32I)), i === o.RGBA && (n === o.FLOAT && (u = o.RGBA32F), n === o.HALF_FLOAT && (u = o.RGBA16F), n === o.UNSIGNED_BYTE && (u = o.RGBA8), n === o.UNSIGNED_SHORT && (u = o.RGBA16), n === o.UNSIGNED_INT && (u = o.RGBA32UI), n === o.BYTE && (u = o.RGBA8I), n === o.SHORT && (u = o.RGBA16I), n === o.INT && (u = o.RGBA32I), n === o.UNSIGNED_BYTE && (u = s === ct && a === !1 ? o.SRGB8_ALPHA8 : o.RGBA8), n === o.UNSIGNED_SHORT_4_4_4_4 && (u = o.RGBA4), n === o.UNSIGNED_SHORT_5_5_5_1 && (u = o.RGB5_A1)), i === o.RGBA_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RGBA8UI), n === o.UNSIGNED_SHORT && (u = o.RGBA16UI), n === o.UNSIGNED_INT && (u = o.RGBA32UI), n === o.BYTE && (u = o.RGBA8I), n === o.SHORT && (u = o.RGBA16I), n === o.INT && (u = o.RGBA32I)), i === o.DEPTH_COMPONENT && (n === o.UNSIGNED_INT && (u = o.DEPTH24_STENCIL8), n === o.FLOAT && (u = o.DEPTH_COMPONENT32F)), i === o.DEPTH_STENCIL && n === o.UNSIGNED_INT_24_8 && (u = o.DEPTH24_STENCIL8), (u === o.R16F || u === o.R32F || u === o.RG16F || u === o.RG32F || u === o.RGBA16F || u === o.RGBA32F) && l.get("EXT_color_buffer_float"), u;
  }
  setTextureParameters(e, i) {
    const { gl: n, extensions: s, backend: a } = this;
    n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, i.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, i.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE), n.texParameteri(e, n.TEXTURE_WRAP_S, Mf[i.wrapS]), n.texParameteri(e, n.TEXTURE_WRAP_T, Mf[i.wrapT]), (e === n.TEXTURE_3D || e === n.TEXTURE_2D_ARRAY) && n.texParameteri(e, n.TEXTURE_WRAP_R, Mf[i.wrapR]), n.texParameteri(e, n.TEXTURE_MAG_FILTER, xv[i.magFilter]);
    const o = i.mipmaps !== void 0 && i.mipmaps.length > 0, l = i.minFilter === on && o ? da : i.minFilter;
    if (n.texParameteri(e, n.TEXTURE_MIN_FILTER, xv[l]), i.compareFunction && (n.texParameteri(e, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(e, n.TEXTURE_COMPARE_FUNC, yA[i.compareFunction])), s.has("EXT_texture_filter_anisotropic") === !0) {
      if (i.magFilter === mr || i.minFilter !== Ku && i.minFilter !== da || i.type === an && s.has("OES_texture_float_linear") === !1) return;
      if (i.anisotropy > 1) {
        const u = s.get("EXT_texture_filter_anisotropic");
        n.texParameterf(e, u.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i.anisotropy, a.getMaxAnisotropy()));
      }
    }
  }
  createDefaultTexture(e) {
    const { gl: i, backend: n, defaultTextures: s } = this, a = this.getGLTextureType(e);
    let o = s[a];
    o === void 0 && (o = i.createTexture(), n.state.bindTexture(a, o), i.texParameteri(a, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(a, i.TEXTURE_MAG_FILTER, i.NEAREST), s[a] = o), n.set(e, {
      textureGPU: o,
      glTextureType: a,
      isDefault: !0
    });
  }
  createTexture(e, i) {
    const { gl: n, backend: s } = this, { levels: a, width: o, height: l, depth: u } = i, c = s.utils.convert(e.format, e.colorSpace), h = s.utils.convert(e.type), d = this.getInternalFormat(e.internalFormat, c, h, e.colorSpace, e.isVideoTexture), p = n.createTexture(), f = this.getGLTextureType(e);
    s.state.bindTexture(f, p), this.setTextureParameters(f, e), e.isDataArrayTexture || e.isCompressedArrayTexture ? n.texStorage3D(n.TEXTURE_2D_ARRAY, a, d, o, l, u) : e.isData3DTexture ? n.texStorage3D(n.TEXTURE_3D, a, d, o, l, u) : e.isVideoTexture || n.texStorage2D(f, a, d, o, l), s.set(e, {
      textureGPU: p,
      glTextureType: f,
      glFormat: c,
      glType: h,
      glInternalFormat: d
    });
  }
  copyBufferToTexture(e, i) {
    const { gl: n, backend: s } = this, { textureGPU: a, glTextureType: o, glFormat: l, glType: u } = s.get(i), { width: c, height: h } = i.source.data;
    n.bindBuffer(n.PIXEL_UNPACK_BUFFER, e), s.state.bindTexture(o, a), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), n.texSubImage2D(o, 0, 0, 0, c, h, l, u, 0), n.bindBuffer(n.PIXEL_UNPACK_BUFFER, null), s.state.unbindTexture();
  }
  updateTexture(e, i) {
    const { gl: n } = this, { width: s, height: a } = i, { textureGPU: o, glTextureType: l, glFormat: u, glType: c, glInternalFormat: h } = this.backend.get(e);
    if (e.isRenderTargetTexture || o === void 0)
      return;
    const d = (p) => p.isDataTexture ? p.image.data : p instanceof ImageBitmap || p instanceof OffscreenCanvas || p instanceof HTMLImageElement || p instanceof HTMLCanvasElement ? p : p.data;
    if (this.backend.state.bindTexture(l, o), this.setTextureParameters(l, e), e.isCompressedTexture) {
      const p = e.mipmaps, f = i.image;
      for (let m = 0; m < p.length; m++) {
        const y = p[m];
        e.isCompressedArrayTexture ? e.format !== n.RGBA ? u !== null ? n.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, m, 0, 0, 0, y.width, y.height, f.depth, u, y.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texSubImage3D(n.TEXTURE_2D_ARRAY, m, 0, 0, 0, y.width, y.height, f.depth, u, c, y.data) : u !== null ? n.compressedTexSubImage2D(n.TEXTURE_2D, m, 0, 0, y.width, y.height, u, y.data) : console.warn("Unsupported compressed texture format");
      }
    } else if (e.isCubeTexture) {
      const p = i.images;
      for (let f = 0; f < 6; f++) {
        const m = d(p[f]);
        n.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, 0, 0, s, a, u, c, m);
      }
    } else if (e.isDataArrayTexture) {
      const p = i.image;
      n.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, u, c, p.data);
    } else if (e.isData3DTexture) {
      const p = i.image;
      n.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, u, c, p.data);
    } else if (e.isVideoTexture)
      e.update(), n.texImage2D(l, 0, h, u, c, i.image);
    else {
      const p = d(i.image);
      n.texSubImage2D(l, 0, 0, 0, s, a, u, c, p);
    }
  }
  generateMipmaps(e) {
    const { gl: i, backend: n } = this, { textureGPU: s, glTextureType: a } = n.get(e);
    n.state.bindTexture(a, s), i.generateMipmap(a);
  }
  deallocateRenderBuffers(e) {
    const { gl: i, backend: n } = this;
    if (e) {
      const s = n.get(e);
      if (s.renderBufferStorageSetup = void 0, s.framebuffers) {
        for (const a in s.framebuffers)
          i.deleteFramebuffer(s.framebuffers[a]);
        delete s.framebuffers;
      }
      if (s.depthRenderbuffer && (i.deleteRenderbuffer(s.depthRenderbuffer), delete s.depthRenderbuffer), s.stencilRenderbuffer && (i.deleteRenderbuffer(s.stencilRenderbuffer), delete s.stencilRenderbuffer), s.msaaFrameBuffer && (i.deleteFramebuffer(s.msaaFrameBuffer), delete s.msaaFrameBuffer), s.msaaRenderbuffers) {
        for (let a = 0; a < s.msaaRenderbuffers.length; a++)
          i.deleteRenderbuffer(s.msaaRenderbuffers[a]);
        delete s.msaaRenderbuffers;
      }
    }
  }
  destroyTexture(e) {
    const { gl: i, backend: n } = this, { textureGPU: s, renderTarget: a } = n.get(e);
    this.deallocateRenderBuffers(a), i.deleteTexture(s), n.delete(e);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    const { gl: o, backend: l } = this, { state: u } = this.backend, { textureGPU: c, glTextureType: h, glType: d, glFormat: p } = l.get(i);
    let f, m, y, v, g, _;
    n !== null ? (f = n.max.x - n.min.x, m = n.max.y - n.min.y, y = n.min.x, v = n.min.y) : (f = e.image.width, m = e.image.height, y = 0, v = 0), s !== null ? (g = s.x, _ = s.y) : (g = 0, _ = 0), u.bindTexture(h, c), o.pixelStorei(o.UNPACK_ALIGNMENT, i.unpackAlignment), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, i.flipY), o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), o.pixelStorei(o.UNPACK_ALIGNMENT, i.unpackAlignment);
    const x = o.getParameter(o.UNPACK_ROW_LENGTH), b = o.getParameter(o.UNPACK_IMAGE_HEIGHT), T = o.getParameter(o.UNPACK_SKIP_PIXELS), S = o.getParameter(o.UNPACK_SKIP_ROWS), w = o.getParameter(o.UNPACK_SKIP_IMAGES), M = e.isCompressedTexture ? e.mipmaps[a] : e.image;
    if (o.pixelStorei(o.UNPACK_ROW_LENGTH, M.width), o.pixelStorei(o.UNPACK_IMAGE_HEIGHT, M.height), o.pixelStorei(o.UNPACK_SKIP_PIXELS, y), o.pixelStorei(o.UNPACK_SKIP_ROWS, v), e.isRenderTargetTexture || e.isDepthTexture) {
      const E = l.get(e), A = l.get(i), N = l.get(E.renderTarget), U = l.get(A.renderTarget), k = N.framebuffers[E.cacheKey], C = U.framebuffers[A.cacheKey];
      u.bindFramebuffer(o.READ_FRAMEBUFFER, k), u.bindFramebuffer(o.DRAW_FRAMEBUFFER, C);
      let I = o.COLOR_BUFFER_BIT;
      e.isDepthTexture && (I = o.DEPTH_BUFFER_BIT), o.blitFramebuffer(y, v, f, m, g, _, f, m, I, o.NEAREST), u.bindFramebuffer(o.READ_FRAMEBUFFER, null), u.bindFramebuffer(o.DRAW_FRAMEBUFFER, null);
    } else
      e.isDataTexture ? o.texSubImage2D(o.TEXTURE_2D, a, g, _, f, m, p, d, M.data) : e.isCompressedTexture ? o.compressedTexSubImage2D(o.TEXTURE_2D, a, g, _, M.width, M.height, p, M.data) : o.texSubImage2D(o.TEXTURE_2D, a, g, _, f, m, p, d, M);
    o.pixelStorei(o.UNPACK_ROW_LENGTH, x), o.pixelStorei(o.UNPACK_IMAGE_HEIGHT, b), o.pixelStorei(o.UNPACK_SKIP_PIXELS, T), o.pixelStorei(o.UNPACK_SKIP_ROWS, S), o.pixelStorei(o.UNPACK_SKIP_IMAGES, w), a === 0 && i.generateMipmaps && o.generateMipmap(o.TEXTURE_2D), u.unbindTexture();
  }
  copyFramebufferToTexture(e, i, n) {
    const { gl: s } = this, { state: a } = this.backend, { textureGPU: o } = this.backend.get(e), { x: l, y: u, z: c, w: h } = n, d = e.isDepthTexture === !0 || i.renderTarget && i.renderTarget.samples > 0, p = i.renderTarget ? i.renderTarget.height : this.backend.gerDrawingBufferSize().y;
    if (d) {
      const f = l !== 0 || u !== 0;
      let m, y;
      if (e.isDepthTexture === !0 ? (m = s.DEPTH_BUFFER_BIT, y = s.DEPTH_ATTACHMENT, i.stencil && (m |= s.STENCIL_BUFFER_BIT)) : (m = s.COLOR_BUFFER_BIT, y = s.COLOR_ATTACHMENT0), f) {
        const v = this.backend.get(i.renderTarget), g = v.framebuffers[i.getCacheKey()], _ = v.msaaFrameBuffer;
        a.bindFramebuffer(s.DRAW_FRAMEBUFFER, g), a.bindFramebuffer(s.READ_FRAMEBUFFER, _);
        const x = p - u - h;
        s.blitFramebuffer(l, x, l + c, x + h, l, x, l + c, x + h, m, s.NEAREST), a.bindFramebuffer(s.READ_FRAMEBUFFER, g), a.bindTexture(s.TEXTURE_2D, o), s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, l, x, c, h), a.unbindTexture();
      } else {
        const v = s.createFramebuffer();
        a.bindFramebuffer(s.DRAW_FRAMEBUFFER, v), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, y, s.TEXTURE_2D, o, 0), s.blitFramebuffer(0, 0, c, h, 0, 0, c, h, m, s.NEAREST), s.deleteFramebuffer(v);
      }
    } else
      a.bindTexture(s.TEXTURE_2D, o), s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, l, p - h - u, c, h), a.unbindTexture();
    e.generateMipmaps && this.generateMipmaps(e), this.backend._setFramebuffer(i);
  }
  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  setupRenderBufferStorage(e, i) {
    const { gl: n } = this, s = i.renderTarget, { samples: a, depthTexture: o, depthBuffer: l, stencilBuffer: u, width: c, height: h } = s;
    if (n.bindRenderbuffer(n.RENDERBUFFER, e), l && !u) {
      let d = n.DEPTH_COMPONENT24;
      a > 0 ? (o && o.isDepthTexture && o.type === n.FLOAT && (d = n.DEPTH_COMPONENT32F), n.renderbufferStorageMultisample(n.RENDERBUFFER, a, d, c, h)) : n.renderbufferStorage(n.RENDERBUFFER, d, c, h), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, e);
    } else l && u && (a > 0 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, a, n.DEPTH24_STENCIL8, c, h) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, c, h), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, e));
  }
  async copyTextureToBuffer(e, i, n, s, a, o) {
    const { backend: l, gl: u } = this, { textureGPU: c, glFormat: h, glType: d } = this.backend.get(e), p = u.createFramebuffer();
    u.bindFramebuffer(u.READ_FRAMEBUFFER, p);
    const f = e.isCubeTexture ? u.TEXTURE_CUBE_MAP_POSITIVE_X + o : u.TEXTURE_2D;
    u.framebufferTexture2D(u.READ_FRAMEBUFFER, u.COLOR_ATTACHMENT0, f, c, 0);
    const m = this._getTypedArrayType(d), y = this._getBytesPerTexel(d, h), v = s * a * y, g = u.createBuffer();
    u.bindBuffer(u.PIXEL_PACK_BUFFER, g), u.bufferData(u.PIXEL_PACK_BUFFER, v, u.STREAM_READ), u.readPixels(i, n, s, a, h, d, 0), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), await l.utils._clientWaitAsync();
    const _ = new m(v / m.BYTES_PER_ELEMENT);
    return u.bindBuffer(u.PIXEL_PACK_BUFFER, g), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, _), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), u.deleteFramebuffer(p), _;
  }
  _getTypedArrayType(e) {
    const { gl: i } = this;
    if (e === i.UNSIGNED_BYTE) return Uint8Array;
    if (e === i.UNSIGNED_SHORT_4_4_4_4 || e === i.UNSIGNED_SHORT_5_5_5_1 || e === i.UNSIGNED_SHORT_5_6_5 || e === i.UNSIGNED_SHORT) return Uint16Array;
    if (e === i.UNSIGNED_INT) return Uint32Array;
    if (e === i.HALF_FLOAT) return Uint16Array;
    if (e === i.FLOAT) return Float32Array;
    throw new Error(`Unsupported WebGL type: ${e}`);
  }
  _getBytesPerTexel(e, i) {
    const { gl: n } = this;
    let s = 0;
    if (e === n.UNSIGNED_BYTE && (s = 1), (e === n.UNSIGNED_SHORT_4_4_4_4 || e === n.UNSIGNED_SHORT_5_5_5_1 || e === n.UNSIGNED_SHORT_5_6_5 || e === n.UNSIGNED_SHORT || e === n.HALF_FLOAT) && (s = 2), (e === n.UNSIGNED_INT || e === n.FLOAT) && (s = 4), i === n.RGBA) return s * 4;
    if (i === n.RGB) return s * 3;
    if (i === n.ALPHA) return s;
  }
}
class tJ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.availableExtensions = this.gl.getSupportedExtensions(), this.extensions = {};
  }
  get(e) {
    let i = this.extensions[e];
    return i === void 0 && (i = this.gl.getExtension(e), this.extensions[e] = i), i;
  }
  has(e) {
    return this.availableExtensions.includes(e);
  }
}
class iJ {
  constructor(e) {
    this.backend = e, this.maxAnisotropy = null;
  }
  getMaxAnisotropy() {
    if (this.maxAnisotropy !== null) return this.maxAnisotropy;
    const e = this.backend.gl, i = this.backend.extensions;
    if (i.has("EXT_texture_filter_anisotropic") === !0) {
      const n = i.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      this.maxAnisotropy = 0;
    return this.maxAnisotropy;
  }
}
const vA = {
  WEBGL_multi_draw: "WEBGL_multi_draw",
  WEBGL_compressed_texture_astc: "texture-compression-astc",
  WEBGL_compressed_texture_etc: "texture-compression-etc2",
  WEBGL_compressed_texture_etc1: "texture-compression-etc1",
  WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBKIT_WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBGL_compressed_texture_s3tc: "texture-compression-bc",
  EXT_texture_compression_bptc: "texture-compression-bptc",
  EXT_disjoint_timer_query_webgl2: "timestamp-query"
};
class rJ {
  constructor(e) {
    this.gl = e.gl, this.extensions = e.extensions, this.info = e.renderer.info, this.mode = null, this.index = 0, this.type = null, this.object = null;
  }
  render(e, i) {
    const { gl: n, mode: s, object: a, type: o, info: l, index: u } = this;
    u !== 0 ? n.drawElements(s, i, o, e) : n.drawArrays(s, e, i), l.update(a, i, s, 1);
  }
  renderInstances(e, i, n) {
    const { gl: s, mode: a, type: o, index: l, object: u, info: c } = this;
    n !== 0 && (l !== 0 ? s.drawElementsInstanced(a, i, o, e, n) : s.drawArraysInstanced(a, e, i, n), c.update(u, i, a, n));
  }
  renderMultiDraw(e, i, n) {
    const { extensions: s, mode: a, object: o, info: l } = this;
    if (n === 0) return;
    const u = s.get("WEBGL_multi_draw");
    if (u === null)
      for (let c = 0; c < n; c++)
        this.render(e[c], i[c]);
    else {
      this.index !== 0 ? u.multiDrawElementsWEBGL(a, i, 0, this.type, e, 0, n) : u.multiDrawArraysWEBGL(a, e, 0, i, 0, n);
      let c = 0;
      for (let h = 0; h < n; h++)
        c += i[h];
      l.update(o, c, a, 1);
    }
  }
  renderMultiDrawInstances(e, i, n, s) {
    const { extensions: a, mode: o, object: l, info: u } = this;
    if (n === 0) return;
    const c = a.get("WEBGL_multi_draw");
    if (c === null)
      for (let h = 0; h < n; h++)
        this.renderInstances(e[h], i[h], s[h]);
    else {
      this.index !== 0 ? c.multiDrawElementsInstancedWEBGL(o, i, 0, this.type, e, 0, s, 0, n) : c.multiDrawArraysInstancedWEBGL(o, e, 0, i, 0, s, 0, n);
      let h = 0;
      for (let d = 0; d < n; d++)
        h += i[d] * s[d];
      u.update(l, h, o, 1);
    }
  }
  //
}
class bA extends p3 {
  constructor(e = {}) {
    super(e), this.isWebGLBackend = !0;
  }
  init(e) {
    super.init(e);
    const i = this.parameters, n = i.context !== void 0 ? i.context : e.domElement.getContext("webgl2");
    function s(a) {
      a.preventDefault();
      const o = {
        api: "WebGL",
        message: a.statusMessage || "Unknown reason",
        reason: null,
        originalEvent: a
      };
      e.onDeviceLost(o);
    }
    this._onContextLost = s, e.domElement.addEventListener("webglcontextlost", s, !1), this.gl = n, this.extensions = new tJ(this), this.capabilities = new iJ(this), this.attributeUtils = new ZQ(this), this.textureUtils = new eJ(this), this.bufferRenderer = new rJ(this), this.state = new QQ(this), this.utils = new JQ(this), this.vaoCache = {}, this.transformFeedbackCache = {}, this.discard = !1, this.trackTimestamp = i.trackTimestamp === !0, this.extensions.get("EXT_color_buffer_float"), this.extensions.get("WEBGL_clip_cull_distance"), this.extensions.get("OES_texture_float_linear"), this.extensions.get("EXT_color_buffer_half_float"), this.extensions.get("WEBGL_multisampled_render_to_texture"), this.extensions.get("WEBGL_render_shared_exponent"), this.extensions.get("WEBGL_multi_draw"), this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2"), this.parallel = this.extensions.get("KHR_parallel_shader_compile"), this._knownBindings = /* @__PURE__ */ new WeakSet(), this._currentContext = null;
  }
  get coordinateSystem() {
    return Yn;
  }
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  async waitForGPU() {
    await this.utils._clientWaitAsync();
  }
  initTimestampQuery(e) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const i = this.get(e);
    if (this.queryRunning) {
      i.queryQueue || (i.queryQueue = []), i.queryQueue.push(e);
      return;
    }
    i.activeQuery && (this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT), i.activeQuery = null), i.activeQuery = this.gl.createQuery(), i.activeQuery !== null && (this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT, i.activeQuery), this.queryRunning = !0);
  }
  // timestamp utils
  prepareTimestampBuffer(e) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const i = this.get(e);
    if (i.activeQuery && (this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT), i.gpuQueries || (i.gpuQueries = []), i.gpuQueries.push({ query: i.activeQuery }), i.activeQuery = null, this.queryRunning = !1, i.queryQueue && i.queryQueue.length > 0)) {
      const n = i.queryQueue.shift();
      this.initTimestampQuery(n);
    }
  }
  async resolveTimestampAsync(e, i = "render") {
    if (!this.disjoint || !this.trackTimestamp) return;
    const n = this.get(e);
    n.gpuQueries || (n.gpuQueries = []);
    for (let s = 0; s < n.gpuQueries.length; s++) {
      const a = n.gpuQueries[s], o = this.gl.getQueryParameter(a.query, this.gl.QUERY_RESULT_AVAILABLE), l = this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);
      if (o && !l) {
        const u = this.gl.getQueryParameter(a.query, this.gl.QUERY_RESULT), c = Number(u) / 1e6;
        this.gl.deleteQuery(a.query), n.gpuQueries.splice(s, 1), s--, this.renderer.info.updateTimestamp(i, c);
      }
    }
  }
  getContext() {
    return this.gl;
  }
  beginRender(e) {
    const { gl: i } = this, n = this.get(e);
    if (this.initTimestampQuery(e), n.previousContext = this._currentContext, this._currentContext = e, this._setFramebuffer(e), this.clear(e.clearColor, e.clearDepth, e.clearStencil, e, !1), e.viewport ? this.updateViewport(e) : i.viewport(0, 0, i.drawingBufferWidth, i.drawingBufferHeight), e.scissor) {
      const { x: a, y: o, width: l, height: u } = e.scissorValue;
      i.scissor(a, e.height - u - o, l, u);
    }
    const s = e.occlusionQueryCount;
    s > 0 && (n.currentOcclusionQueries = n.occlusionQueries, n.currentOcclusionQueryObjects = n.occlusionQueryObjects, n.lastOcclusionObject = null, n.occlusionQueries = new Array(s), n.occlusionQueryObjects = new Array(s), n.occlusionQueryIndex = 0);
  }
  finishRender(e) {
    const { gl: i, state: n } = this, s = this.get(e), a = s.previousContext, o = e.occlusionQueryCount;
    o > 0 && (o > s.occlusionQueryIndex && i.endQuery(i.ANY_SAMPLES_PASSED), this.resolveOccludedAsync(e));
    const l = e.textures;
    if (l !== null)
      for (let u = 0; u < l.length; u++) {
        const c = l[u];
        c.generateMipmaps && this.generateMipmaps(c);
      }
    if (this._currentContext = a, e.textures !== null && e.renderTarget) {
      const u = this.get(e.renderTarget), { samples: c } = e.renderTarget;
      if (c > 0) {
        const h = u.framebuffers[e.getCacheKey()], d = i.COLOR_BUFFER_BIT, p = u.msaaFrameBuffer, f = e.textures;
        n.bindFramebuffer(i.READ_FRAMEBUFFER, p), n.bindFramebuffer(i.DRAW_FRAMEBUFFER, h);
        for (let m = 0; m < f.length; m++)
          if (e.scissor) {
            const { x: y, y: v, width: g, height: _ } = e.scissorValue, x = e.height - _ - v;
            i.blitFramebuffer(y, x, y + g, x + _, y, x, y + g, x + _, d, i.NEAREST), i.invalidateSubFramebuffer(i.READ_FRAMEBUFFER, u.invalidationArray, y, x, g, _);
          } else
            i.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, d, i.NEAREST), i.invalidateFramebuffer(i.READ_FRAMEBUFFER, u.invalidationArray);
      }
    }
    a !== null && (this._setFramebuffer(a), a.viewport ? this.updateViewport(a) : i.viewport(0, 0, i.drawingBufferWidth, i.drawingBufferHeight)), this.prepareTimestampBuffer(e);
  }
  resolveOccludedAsync(e) {
    const i = this.get(e), { currentOcclusionQueries: n, currentOcclusionQueryObjects: s } = i;
    if (n && s) {
      const a = /* @__PURE__ */ new WeakSet(), { gl: o } = this;
      i.currentOcclusionQueryObjects = null, i.currentOcclusionQueries = null;
      const l = () => {
        let u = 0;
        for (let c = 0; c < n.length; c++) {
          const h = n[c];
          h !== null && o.getQueryParameter(h, o.QUERY_RESULT_AVAILABLE) && (o.getQueryParameter(h, o.QUERY_RESULT) > 0 && a.add(s[c]), n[c] = null, o.deleteQuery(h), u++);
        }
        u < n.length ? requestAnimationFrame(l) : i.occluded = a;
      };
      l();
    }
  }
  isOccluded(e, i) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(i);
  }
  updateViewport(e) {
    const i = this.gl, { x: n, y: s, width: a, height: o } = e.viewportValue;
    i.viewport(n, e.height - o - s, a, o);
  }
  setScissorTest(e) {
    const i = this.gl;
    e ? i.enable(i.SCISSOR_TEST) : i.disable(i.SCISSOR_TEST);
  }
  clear(e, i, n, s = null, a = !0) {
    const { gl: o } = this;
    if (s === null) {
      const u = this.getClearColor();
      u.r *= u.a, u.g *= u.a, u.b *= u.a, s = {
        textures: null,
        clearColorValue: u
      };
    }
    let l = 0;
    if (e && (l |= o.COLOR_BUFFER_BIT), i && (l |= o.DEPTH_BUFFER_BIT), n && (l |= o.STENCIL_BUFFER_BIT), l !== 0) {
      let u;
      if (s.clearColorValue ? u = s.clearColorValue : (u = this.getClearColor(), u.r *= u.a, u.g *= u.a, u.b *= u.a), i && this.state.setDepthMask(!0), s.textures === null)
        o.clearColor(u.r, u.g, u.b, u.a), o.clear(l);
      else {
        if (a && this._setFramebuffer(s), e)
          for (let c = 0; c < s.textures.length; c++)
            o.clearBufferfv(o.COLOR, c, [u.r, u.g, u.b, u.a]);
        i && n ? o.clearBufferfi(o.DEPTH_STENCIL, 0, 1, 0) : i ? o.clearBufferfv(o.DEPTH, 0, [1]) : n && o.clearBufferiv(o.STENCIL, 0, [0]);
      }
    }
  }
  beginCompute(e) {
    const { state: i, gl: n } = this;
    i.bindFramebuffer(n.FRAMEBUFFER, null), this.initTimestampQuery(e);
  }
  compute(e, i, n, s) {
    const { state: a, gl: o } = this;
    this.discard || (o.enable(o.RASTERIZER_DISCARD), this.discard = !0);
    const { programGPU: l, transformBuffers: u, attributes: c } = this.get(s), h = this._getVaoKey(null, c), d = this.vaoCache[h];
    d === void 0 ? this._createVao(null, c) : o.bindVertexArray(d), a.useProgram(l), this._bindUniforms(n);
    const p = this._getTransformFeedback(u);
    o.bindTransformFeedback(o.TRANSFORM_FEEDBACK, p), o.beginTransformFeedback(o.POINTS), c[0].isStorageInstancedBufferAttribute ? o.drawArraysInstanced(o.POINTS, 0, 1, i.count) : o.drawArrays(o.POINTS, 0, i.count), o.endTransformFeedback(), o.bindTransformFeedback(o.TRANSFORM_FEEDBACK, null);
    for (let f = 0; f < u.length; f++) {
      const m = u[f];
      m.pbo && this.textureUtils.copyBufferToTexture(m.transformBuffer, m.pbo), m.switchBuffers();
    }
  }
  finishCompute(e) {
    const i = this.gl;
    this.discard = !1, i.disable(i.RASTERIZER_DISCARD), this.prepareTimestampBuffer(e), this._currentContext && this._setFramebuffer(this._currentContext);
  }
  draw(e) {
    const { object: i, pipeline: n, material: s, context: a } = e, { programGPU: o } = this.get(n), { gl: l, state: u } = this, c = this.get(a), h = e.getDrawParameters();
    if (h === null) return;
    this._bindUniforms(e.getBindings());
    const d = i.isMesh && i.matrixWorld.determinant() < 0;
    u.setMaterial(s, d), u.useProgram(o);
    let p = e.staticVao;
    if (p === void 0) {
      const x = this._getVaoKey(e.getIndex(), e.getAttributes());
      if (p = this.vaoCache[x], p === void 0) {
        let b;
        ({ vaoGPU: p, staticVao: b } = this._createVao(e.getIndex(), e.getAttributes())), b && (e.staticVao = p);
      }
    }
    l.bindVertexArray(p);
    const f = e.getIndex(), m = c.lastOcclusionObject;
    if (m !== i && m !== void 0) {
      if (m !== null && m.occlusionTest === !0 && (l.endQuery(l.ANY_SAMPLES_PASSED), c.occlusionQueryIndex++), i.occlusionTest === !0) {
        const x = l.createQuery();
        l.beginQuery(l.ANY_SAMPLES_PASSED, x), c.occlusionQueries[c.occlusionQueryIndex] = x, c.occlusionQueryObjects[c.occlusionQueryIndex] = i;
      }
      c.lastOcclusionObject = i;
    }
    const y = this.bufferRenderer;
    i.isPoints ? y.mode = l.POINTS : i.isLineSegments ? y.mode = l.LINES : i.isLine ? y.mode = l.LINE_STRIP : i.isLineLoop ? y.mode = l.LINE_LOOP : s.wireframe === !0 ? (u.setLineWidth(s.wireframeLinewidth * this.renderer.getPixelRatio()), y.mode = l.LINES) : y.mode = l.TRIANGLES;
    const { vertexCount: v, instanceCount: g } = h;
    let { firstVertex: _ } = h;
    if (y.object = i, f !== null) {
      _ *= f.array.BYTES_PER_ELEMENT;
      const x = this.get(f);
      y.index = f.count, y.type = x.type;
    } else
      y.index = 0;
    i.isBatchedMesh ? i._multiDrawInstances !== null ? y.renderMultiDrawInstances(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount, i._multiDrawInstances) : this.hasFeature("WEBGL_multi_draw") ? y.renderMultiDraw(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount) : k7("THREE.WebGLRenderer: WEBGL_multi_draw not supported.") : g > 1 ? y.renderInstances(_, v, g) : y.render(_, v), l.bindVertexArray(null);
  }
  needsRenderUpdate() {
    return !1;
  }
  getRenderCacheKey() {
    return "";
  }
  // textures
  createDefaultTexture(e) {
    this.textureUtils.createDefaultTexture(e);
  }
  createTexture(e, i) {
    this.textureUtils.createTexture(e, i);
  }
  updateTexture(e, i) {
    this.textureUtils.updateTexture(e, i);
  }
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  destroyTexture(e) {
    this.textureUtils.destroyTexture(e);
  }
  copyTextureToBuffer(e, i, n, s, a, o) {
    return this.textureUtils.copyTextureToBuffer(e, i, n, s, a, o);
  }
  createSampler() {
  }
  destroySampler() {
  }
  // node builder
  createNodeBuilder(e, i) {
    return new $Q(e, i);
  }
  // program
  createProgram(e) {
    const i = this.gl, { stage: n, code: s } = e, a = n === "fragment" ? i.createShader(i.FRAGMENT_SHADER) : i.createShader(i.VERTEX_SHADER);
    i.shaderSource(a, s), i.compileShader(a), this.set(e, {
      shaderGPU: a
    });
  }
  destroyProgram() {
    console.warn("Abstract class.");
  }
  createRenderPipeline(e, i) {
    const n = this.gl, s = e.pipeline, { fragmentProgram: a, vertexProgram: o } = s, l = n.createProgram(), u = this.get(a).shaderGPU, c = this.get(o).shaderGPU;
    if (n.attachShader(l, u), n.attachShader(l, c), n.linkProgram(l), this.set(s, {
      programGPU: l,
      fragmentShader: u,
      vertexShader: c
    }), i !== null && this.parallel) {
      const h = new Promise((d) => {
        const p = this.parallel, f = () => {
          n.getProgramParameter(l, p.COMPLETION_STATUS_KHR) ? (this._completeCompile(e, s), d()) : requestAnimationFrame(f);
        };
        f();
      });
      i.push(h);
      return;
    }
    this._completeCompile(e, s);
  }
  _handleSource(e, i) {
    const n = e.split(`
`), s = [], a = Math.max(i - 6, 0), o = Math.min(i + 6, n.length);
    for (let l = a; l < o; l++) {
      const u = l + 1;
      s.push(`${u === i ? ">" : " "} ${u}: ${n[l]}`);
    }
    return s.join(`
`);
  }
  _getShaderErrors(e, i, n) {
    const s = e.getShaderParameter(i, e.COMPILE_STATUS), a = e.getShaderInfoLog(i).trim();
    if (s && a === "") return "";
    const o = /ERROR: 0:(\d+)/.exec(a);
    if (o) {
      const l = parseInt(o[1]);
      return n.toUpperCase() + `

` + a + `

` + this._handleSource(e.getShaderSource(i), l);
    } else
      return a;
  }
  _logProgramError(e, i, n) {
    if (this.renderer.debug.checkShaderErrors) {
      const s = this.gl, a = s.getProgramInfoLog(e).trim();
      if (s.getProgramParameter(e, s.LINK_STATUS) === !1)
        if (typeof this.renderer.debug.onShaderError == "function")
          this.renderer.debug.onShaderError(s, e, n, i);
        else {
          const o = this._getShaderErrors(s, n, "vertex"), l = this._getShaderErrors(s, i, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(e, s.VALIDATE_STATUS) + `

Program Info Log: ` + a + `
` + o + `
` + l
          );
        }
      else a !== "" && console.warn("THREE.WebGLProgram: Program Info Log:", a);
    }
  }
  _completeCompile(e, i) {
    const { state: n, gl: s } = this, a = this.get(i), { programGPU: o, fragmentShader: l, vertexShader: u } = a;
    s.getProgramParameter(o, s.LINK_STATUS) === !1 && this._logProgramError(o, l, u), n.useProgram(o);
    const c = e.getBindings();
    this._setupBindings(c, o), this.set(i, {
      programGPU: o
    });
  }
  createComputePipeline(e, i) {
    const { state: n, gl: s } = this, a = {
      stage: "fragment",
      code: `#version 300 es
precision highp float;
void main() {}`
    };
    this.createProgram(a);
    const { computeProgram: o } = e, l = s.createProgram(), u = this.get(a).shaderGPU, c = this.get(o).shaderGPU, h = o.transforms, d = [], p = [];
    for (let v = 0; v < h.length; v++) {
      const g = h[v];
      d.push(g.varyingName), p.push(g.attributeNode);
    }
    s.attachShader(l, u), s.attachShader(l, c), s.transformFeedbackVaryings(
      l,
      d,
      s.SEPARATE_ATTRIBS
    ), s.linkProgram(l), s.getProgramParameter(l, s.LINK_STATUS) === !1 && this._logProgramError(l, u, c), n.useProgram(l), this._setupBindings(i, l);
    const f = o.attributes, m = [], y = [];
    for (let v = 0; v < f.length; v++) {
      const g = f[v].node.attribute;
      m.push(g), this.has(g) || this.attributeUtils.createAttribute(g, s.ARRAY_BUFFER);
    }
    for (let v = 0; v < p.length; v++) {
      const g = p[v].attribute;
      this.has(g) || this.attributeUtils.createAttribute(g, s.ARRAY_BUFFER);
      const _ = this.get(g);
      y.push(_);
    }
    this.set(e, {
      programGPU: l,
      transformBuffers: y,
      attributes: m
    });
  }
  createBindings(e, i) {
    if (this._knownBindings.has(i) === !1) {
      this._knownBindings.add(i);
      let n = 0, s = 0;
      for (const a of i) {
        this.set(a, {
          textures: s,
          uniformBuffers: n
        });
        for (const o of a.bindings)
          o.isUniformBuffer && n++, o.isSampledTexture && s++;
      }
    }
    this.updateBindings(e, i);
  }
  updateBindings(e) {
    const { gl: i } = this, n = this.get(e);
    let s = n.uniformBuffers, a = n.textures;
    for (const o of e.bindings)
      if (o.isUniformsGroup || o.isUniformBuffer) {
        const l = o.buffer, u = i.createBuffer();
        i.bindBuffer(i.UNIFORM_BUFFER, u), i.bufferData(i.UNIFORM_BUFFER, l, i.DYNAMIC_DRAW), this.set(o, {
          index: s++,
          bufferGPU: u
        });
      } else if (o.isSampledTexture) {
        const { textureGPU: l, glTextureType: u } = this.get(o.texture);
        this.set(o, {
          index: a++,
          textureGPU: l,
          glTextureType: u
        });
      }
  }
  updateBinding(e) {
    const i = this.gl;
    if (e.isUniformsGroup || e.isUniformBuffer) {
      const n = this.get(e).bufferGPU, s = e.buffer;
      i.bindBuffer(i.UNIFORM_BUFFER, n), i.bufferData(i.UNIFORM_BUFFER, s, i.DYNAMIC_DRAW);
    }
  }
  // attributes
  createIndexAttribute(e) {
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ELEMENT_ARRAY_BUFFER);
  }
  createAttribute(e) {
    if (this.has(e)) return;
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ARRAY_BUFFER);
  }
  createStorageAttribute(e) {
    if (this.has(e)) return;
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ARRAY_BUFFER);
  }
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  updateSize() {
  }
  hasFeature(e) {
    const i = Object.keys(vA).filter((s) => vA[s] === e), n = this.extensions;
    for (let s = 0; s < i.length; s++)
      if (n.has(i[s])) return !0;
    return !1;
  }
  getMaxAnisotropy() {
    return this.capabilities.getMaxAnisotropy();
  }
  copyTextureToTexture(e, i, n, s, a) {
    this.textureUtils.copyTextureToTexture(e, i, n, s, a);
  }
  copyFramebufferToTexture(e, i, n) {
    this.textureUtils.copyFramebufferToTexture(e, i, n);
  }
  _setFramebuffer(e) {
    const { gl: i, state: n } = this;
    let s = null;
    if (e.textures !== null) {
      const a = e.renderTarget, o = this.get(a), { samples: l, depthBuffer: u, stencilBuffer: c } = a, h = a.isWebGLCubeRenderTarget === !0;
      let d = o.msaaFrameBuffer, p = o.depthRenderbuffer;
      const f = YI(e);
      let m;
      if (h ? (o.cubeFramebuffers || (o.cubeFramebuffers = {}), m = o.cubeFramebuffers[f]) : (o.framebuffers || (o.framebuffers = {}), m = o.framebuffers[f]), m === void 0) {
        m = i.createFramebuffer(), n.bindFramebuffer(i.FRAMEBUFFER, m);
        const y = e.textures;
        if (h) {
          o.cubeFramebuffers[f] = m;
          const { textureGPU: v } = this.get(y[0]), g = this.renderer._activeCubeFace;
          i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + g, v, 0);
        } else {
          o.framebuffers[f] = m;
          for (let v = 0; v < y.length; v++) {
            const g = y[v], _ = this.get(g);
            _.renderTarget = e.renderTarget, _.cacheKey = f;
            const x = i.COLOR_ATTACHMENT0 + v;
            i.framebufferTexture2D(i.FRAMEBUFFER, x, i.TEXTURE_2D, _.textureGPU, 0);
          }
          n.drawBuffers(e, m);
        }
        if (e.depthTexture !== null) {
          const v = this.get(e.depthTexture), g = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
          v.renderTarget = e.renderTarget, v.cacheKey = f, i.framebufferTexture2D(i.FRAMEBUFFER, g, i.TEXTURE_2D, v.textureGPU, 0);
        }
      }
      if (l > 0) {
        if (d === void 0) {
          const y = [];
          d = i.createFramebuffer(), n.bindFramebuffer(i.FRAMEBUFFER, d);
          const v = [], g = e.textures;
          for (let _ = 0; _ < g.length; _++) {
            if (v[_] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, v[_]), y.push(i.COLOR_ATTACHMENT0 + _), u) {
              const T = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
              y.push(T);
            }
            const x = e.textures[_], b = this.get(x);
            i.renderbufferStorageMultisample(i.RENDERBUFFER, l, b.glInternalFormat, e.width, e.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + _, i.RENDERBUFFER, v[_]);
          }
          if (o.msaaFrameBuffer = d, o.msaaRenderbuffers = v, p === void 0) {
            p = i.createRenderbuffer(), this.textureUtils.setupRenderBufferStorage(p, e), o.depthRenderbuffer = p;
            const _ = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
            y.push(_);
          }
          o.invalidationArray = y;
        }
        s = o.msaaFrameBuffer;
      } else
        s = m;
    }
    n.bindFramebuffer(i.FRAMEBUFFER, s);
  }
  _getVaoKey(e, i) {
    let n = [];
    if (e !== null) {
      const s = this.get(e);
      n += ":" + s.id;
    }
    for (let s = 0; s < i.length; s++) {
      const a = this.get(i[s]);
      n += ":" + a.id;
    }
    return n;
  }
  _createVao(e, i) {
    const { gl: n } = this, s = n.createVertexArray();
    let a = "", o = !0;
    if (n.bindVertexArray(s), e !== null) {
      const l = this.get(e);
      n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, l.bufferGPU), a += ":" + l.id;
    }
    for (let l = 0; l < i.length; l++) {
      const u = i[l], c = this.get(u);
      a += ":" + c.id, n.bindBuffer(n.ARRAY_BUFFER, c.bufferGPU), n.enableVertexAttribArray(l), (u.isStorageBufferAttribute || u.isStorageInstancedBufferAttribute) && (o = !1);
      let h, d;
      u.isInterleavedBufferAttribute === !0 ? (h = u.data.stride * c.bytesPerElement, d = u.offset * c.bytesPerElement) : (h = 0, d = 0), c.isInteger ? n.vertexAttribIPointer(l, u.itemSize, c.type, h, d) : n.vertexAttribPointer(l, u.itemSize, c.type, u.normalized, h, d), u.isInstancedBufferAttribute && !u.isInterleavedBufferAttribute ? n.vertexAttribDivisor(l, u.meshPerAttribute) : u.isInterleavedBufferAttribute && u.data.isInstancedInterleavedBuffer && n.vertexAttribDivisor(l, u.data.meshPerAttribute);
    }
    return n.bindBuffer(n.ARRAY_BUFFER, null), this.vaoCache[a] = s, { vaoGPU: s, staticVao: o };
  }
  _getTransformFeedback(e) {
    let i = "";
    for (let a = 0; a < e.length; a++)
      i += ":" + e[a].id;
    let n = this.transformFeedbackCache[i];
    if (n !== void 0)
      return n;
    const { gl: s } = this;
    n = s.createTransformFeedback(), s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, n);
    for (let a = 0; a < e.length; a++) {
      const o = e[a];
      s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER, a, o.transformBuffer);
    }
    return s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, null), this.transformFeedbackCache[i] = n, n;
  }
  _setupBindings(e, i) {
    const n = this.gl;
    for (const s of e)
      for (const a of s.bindings) {
        const o = this.get(a).index;
        if (a.isUniformsGroup || a.isUniformBuffer) {
          const l = n.getUniformBlockIndex(i, a.name);
          n.uniformBlockBinding(i, l, o);
        } else if (a.isSampledTexture) {
          const l = n.getUniformLocation(i, a.name);
          n.uniform1i(l, o);
        }
      }
  }
  _bindUniforms(e) {
    const { gl: i, state: n } = this;
    for (const s of e)
      for (const a of s.bindings) {
        const o = this.get(a), l = o.index;
        a.isUniformsGroup || a.isUniformBuffer ? n.bindBufferBase(i.UNIFORM_BUFFER, l, o.bufferGPU) : a.isSampledTexture && n.bindTexture(o.glTextureType, o.textureGPU, i.TEXTURE0 + l);
      }
  }
  dispose() {
    this.renderer.domElement.removeEventListener("webglcontextlost", this._onContextLost);
  }
}
class nJ extends K1 {
  constructor(e, i) {
    super(e), this.texture = i, this.version = i ? i.version : 0, this.isSampler = !0;
  }
}
class sJ extends nJ {
  constructor(e, i, n) {
    super(e, i ? i.value : null), this.textureNode = i, this.groupNode = n;
  }
  update() {
    this.texture = this.textureNode.value;
  }
}
class aJ extends o3 {
  constructor(e, i) {
    super(e, i ? i.array : null), this.attribute = i, this.isStorageBuffer = !0;
  }
}
let oJ = 0;
class lJ extends aJ {
  constructor(e, i) {
    super("StorageBuffer_" + oJ++, e ? e.value : null), this.nodeUniform = e, this.access = e ? e.access : Lx.Storage, this.groupNode = i;
  }
  get buffer() {
    return this.nodeUniform.value;
  }
}
class uJ extends So {
  constructor(e) {
    super(), this.device = e;
    const i = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`, n = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`, s = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
    this.mipmapSampler = e.createSampler({ minFilter: Qo.Linear }), this.flipYSampler = e.createSampler({ minFilter: Qo.Nearest }), this.transferPipelines = {}, this.flipYPipelines = {}, this.mipmapVertexShaderModule = e.createShaderModule({
      label: "mipmapVertex",
      code: i
    }), this.mipmapFragmentShaderModule = e.createShaderModule({
      label: "mipmapFragment",
      code: n
    }), this.flipYFragmentShaderModule = e.createShaderModule({
      label: "flipYFragment",
      code: s
    });
  }
  getTransferPipeline(e) {
    let i = this.transferPipelines[e];
    return i === void 0 && (i = this.device.createRenderPipeline({
      label: `mipmap-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.mipmapFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: Bu.TriangleStrip,
        stripIndexFormat: Mc.Uint32
      },
      layout: "auto"
    }), this.transferPipelines[e] = i), i;
  }
  getFlipYPipeline(e) {
    let i = this.flipYPipelines[e];
    return i === void 0 && (i = this.device.createRenderPipeline({
      label: `flipY-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.flipYFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: Bu.TriangleStrip,
        stripIndexFormat: Mc.Uint32
      },
      layout: "auto"
    }), this.flipYPipelines[e] = i), i;
  }
  flipY(e, i, n = 0) {
    const s = i.format, { width: a, height: o } = i.size, l = this.getTransferPipeline(s), u = this.getFlipYPipeline(s), c = this.device.createTexture({
      size: { width: a, height: o, depthOrArrayLayers: 1 },
      format: s,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    }), h = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: gn.TwoD,
      baseArrayLayer: n
    }), d = c.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: gn.TwoD,
      baseArrayLayer: 0
    }), p = this.device.createCommandEncoder({}), f = (m, y, v) => {
      const g = m.getBindGroupLayout(0), _ = this.device.createBindGroup({
        layout: g,
        entries: [{
          binding: 0,
          resource: this.flipYSampler
        }, {
          binding: 1,
          resource: y
        }]
      }), x = p.beginRenderPass({
        colorAttachments: [{
          view: v,
          loadOp: Oi.Clear,
          storeOp: Qi.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      x.setPipeline(m), x.setBindGroup(0, _), x.draw(4, 1, 0, 0), x.end();
    };
    f(l, h, d), f(u, d, h), this.device.queue.submit([p.finish()]), c.destroy();
  }
  generateMipmaps(e, i, n = 0) {
    const s = this.get(e);
    s.useCount === void 0 && (s.useCount = 0, s.layers = []);
    const a = s.layers[n] || this._mipmapCreateBundles(e, i, n), o = this.device.createCommandEncoder({});
    this._mipmapRunBundles(o, a), this.device.queue.submit([o.finish()]), s.useCount !== 0 && (s.layers[n] = a), s.useCount++;
  }
  _mipmapCreateBundles(e, i, n) {
    const s = this.getTransferPipeline(i.format), a = s.getBindGroupLayout(0);
    let o = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: gn.TwoD,
      baseArrayLayer: n
    });
    const l = [];
    for (let u = 1; u < i.mipLevelCount; u++) {
      const c = this.device.createBindGroup({
        layout: a,
        entries: [{
          binding: 0,
          resource: this.mipmapSampler
        }, {
          binding: 1,
          resource: o
        }]
      }), h = e.createView({
        baseMipLevel: u,
        mipLevelCount: 1,
        dimension: gn.TwoD,
        baseArrayLayer: n
      }), d = {
        colorAttachments: [{
          view: h,
          loadOp: Oi.Clear,
          storeOp: Qi.Store,
          clearValue: [0, 0, 0, 0]
        }]
      }, p = this.device.createRenderBundleEncoder({
        colorFormats: [i.format]
      });
      p.setPipeline(s), p.setBindGroup(0, c), p.draw(4, 1, 0, 0), l.push({
        renderBundles: [p.finish()],
        passDescriptor: d
      }), o = h;
    }
    return l;
  }
  _mipmapRunBundles(e, i) {
    const n = i.length;
    for (let s = 0; s < n; s++) {
      const a = i[s], o = e.beginRenderPass(a.passDescriptor);
      o.executeBundles(a.renderBundles), o.end();
    }
  }
}
const cJ = {
  [oP]: "never",
  [p1]: "less",
  [lP]: "equal",
  [uP]: "less-equal",
  [cP]: "greater",
  [dP]: "greater-equal",
  [pP]: "always",
  [hP]: "not-equal"
}, hJ = [0, 1, 3, 2, 4, 5];
class dJ {
  constructor(e) {
    this.backend = e, this._passUtils = null, this.defaultTexture = {}, this.defaultCubeTexture = {}, this.defaultVideoFrame = null, this.colorBuffer = null, this.depthTexture = new Vc(), this.depthTexture.name = "depthBuffer";
  }
  createSampler(e) {
    const i = this.backend, n = i.device, s = i.get(e), a = {
      addressModeU: this._convertAddressMode(e.wrapS),
      addressModeV: this._convertAddressMode(e.wrapT),
      addressModeW: this._convertAddressMode(e.wrapR),
      magFilter: this._convertFilterMode(e.magFilter),
      minFilter: this._convertFilterMode(e.minFilter),
      mipmapFilter: this._convertFilterMode(e.minFilter),
      maxAnisotropy: 1
    };
    a.magFilter === Qo.Linear && a.minFilter === Qo.Linear && a.mipmapFilter === Qo.Linear && (a.maxAnisotropy = e.anisotropy), e.isDepthTexture && e.compareFunction !== null && (a.compare = cJ[e.compareFunction]), s.sampler = n.createSampler(a);
  }
  createDefaultTexture(e) {
    let i;
    const n = Fx(e);
    e.isCubeTexture ? i = this._getDefaultCubeTextureGPU(n) : e.isVideoTexture ? this.backend.get(e).externalTexture = this._getDefaultVideoFrame() : i = this._getDefaultTextureGPU(n), this.backend.get(e).texture = i;
  }
  createTexture(e, i = {}) {
    const n = this.backend, s = n.get(e);
    if (s.initialized)
      throw new Error("WebGPUTextureUtils: Texture already initialized.");
    i.needsMipmaps === void 0 && (i.needsMipmaps = !1), i.levels === void 0 && (i.levels = 1), i.depth === void 0 && (i.depth = 1);
    const { width: a, height: o, depth: l, levels: u } = i;
    e.isFramebufferTexture && (i.renderTarget ? i.format = this.backend.utils.getCurrentColorFormat(i.renderTarget) : i.format = this.backend.utils.getPreferredCanvasFormat());
    const c = this._getDimension(e), h = e.internalFormat || i.format || Fx(e, n.device);
    s.format = h;
    let d = i.sampleCount !== void 0 ? i.sampleCount : 1;
    d = n.utils.getSampleCount(d);
    const p = e.isRenderTargetTexture && !e.isMultisampleRenderTargetTexture ? 1 : d;
    let f = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
    e.isStorageTexture === !0 && (f |= GPUTextureUsage.STORAGE_BINDING), e.isCompressedTexture !== !0 && e.isCompressedArrayTexture !== !0 && (f |= GPUTextureUsage.RENDER_ATTACHMENT);
    const m = {
      label: e.name,
      size: {
        width: a,
        height: o,
        depthOrArrayLayers: l
      },
      mipLevelCount: u,
      sampleCount: p,
      dimension: c,
      format: h,
      usage: f
    };
    if (e.isVideoTexture) {
      const y = e.source.data, v = new VideoFrame(y);
      m.size.width = v.displayWidth, m.size.height = v.displayHeight, v.close(), s.externalTexture = y;
    } else {
      if (h === void 0)
        return console.warn("WebGPURenderer: Texture format not supported."), this.createDefaultTexture(e);
      s.texture = n.device.createTexture(m);
    }
    if (e.isRenderTargetTexture && d > 1 && !e.isMultisampleRenderTargetTexture) {
      const y = Object.assign({}, m);
      y.label = y.label + "-msaa", y.sampleCount = d, s.msaaTexture = n.device.createTexture(y);
    }
    s.initialized = !0, s.textureDescriptorGPU = m;
  }
  destroyTexture(e) {
    const i = this.backend, n = i.get(e);
    n.texture.destroy(), n.msaaTexture !== void 0 && n.msaaTexture.destroy(), i.delete(e);
  }
  destroySampler(e) {
    const i = this.backend.get(e);
    delete i.sampler;
  }
  generateMipmaps(e) {
    const i = this.backend.get(e);
    if (e.isCubeTexture)
      for (let n = 0; n < 6; n++)
        this._generateMipmaps(i.texture, i.textureDescriptorGPU, n);
    else {
      const n = e.image.depth || 1;
      for (let s = 0; s < n; s++)
        this._generateMipmaps(i.texture, i.textureDescriptorGPU, s);
    }
  }
  getColorBuffer() {
    this.colorBuffer && this.colorBuffer.destroy();
    const e = this.backend, { width: i, height: n } = e.getDrawingBufferSize();
    return this.colorBuffer = e.device.createTexture({
      label: "colorBuffer",
      size: {
        width: i,
        height: n,
        depthOrArrayLayers: 1
      },
      sampleCount: e.utils.getSampleCount(e.renderer.samples),
      format: e.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
    }), this.colorBuffer;
  }
  getDepthBuffer(e = !0, i = !1) {
    const n = this.backend, { width: s, height: a } = n.getDrawingBufferSize(), o = this.depthTexture, l = n.get(o).texture;
    let u, c;
    if (i ? (u = Tc, c = Kd) : e && (u = gl, c = Ji), l !== void 0) {
      if (o.image.width === s && o.image.height === a && o.format === u && o.type === c)
        return l;
      this.destroyTexture(o);
    }
    return o.name = "depthBuffer", o.format = u, o.type = c, o.image.width = s, o.image.height = a, this.createTexture(o, { sampleCount: n.utils.getSampleCount(n.renderer.samples), width: s, height: a }), n.get(o).texture;
  }
  updateTexture(e, i) {
    const n = this.backend.get(e), { textureDescriptorGPU: s } = n;
    if (!(e.isRenderTargetTexture || s === void 0)) {
      if (e.isDataTexture)
        this._copyBufferToTexture(i.image, n.texture, s, 0, e.flipY);
      else if (e.isDataArrayTexture || e.isData3DTexture)
        for (let a = 0; a < i.image.depth; a++)
          this._copyBufferToTexture(i.image, n.texture, s, a, e.flipY, a);
      else if (e.isCompressedTexture || e.isCompressedArrayTexture)
        this._copyCompressedBufferToTexture(e.mipmaps, n.texture, s);
      else if (e.isCubeTexture)
        this._copyCubeMapToTexture(i.images, n.texture, s, e.flipY);
      else if (e.isVideoTexture) {
        const a = e.source.data;
        n.externalTexture = a;
      } else
        this._copyImageToTexture(i.image, n.texture, s, 0, e.flipY);
      n.version = e.version, e.onUpdate && e.onUpdate(e);
    }
  }
  async copyTextureToBuffer(e, i, n, s, a, o) {
    const l = this.backend.device, u = this.backend.get(e), c = u.texture, h = u.textureDescriptorGPU.format, d = this._getBytesPerTexel(h);
    let p = s * d;
    p = Math.ceil(p / 256) * 256;
    const f = l.createBuffer(
      {
        size: s * a * d,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }
    ), m = l.createCommandEncoder();
    m.copyTextureToBuffer(
      {
        texture: c,
        origin: { x: i, y: n, z: o }
      },
      {
        buffer: f,
        bytesPerRow: p
      },
      {
        width: s,
        height: a
      }
    );
    const y = this._getTypedArrayType(h);
    l.queue.submit([m.finish()]), await f.mapAsync(GPUMapMode.READ);
    const v = f.getMappedRange();
    return new y(v);
  }
  _isEnvironmentTexture(e) {
    const i = e.mapping;
    return i === $d || i === Yd || i === Tl || i === _c;
  }
  _getDefaultTextureGPU(e) {
    let i = this.defaultTexture[e];
    if (i === void 0) {
      const n = new Ar();
      n.minFilter = mr, n.magFilter = mr, this.createTexture(n, { width: 1, height: 1, format: e }), this.defaultTexture[e] = i = n;
    }
    return this.backend.get(i).texture;
  }
  _getDefaultCubeTextureGPU(e) {
    let i = this.defaultTexture[e];
    if (i === void 0) {
      const n = new g1();
      n.minFilter = mr, n.magFilter = mr, this.createTexture(n, { width: 1, height: 1, depth: 6 }), this.defaultCubeTexture[e] = i = n;
    }
    return this.backend.get(i).texture;
  }
  _getDefaultVideoFrame() {
    let e = this.defaultVideoFrame;
    if (e === null) {
      const i = {
        timestamp: 0,
        codedWidth: 1,
        codedHeight: 1,
        format: "RGBA"
      };
      this.defaultVideoFrame = e = new VideoFrame(new Uint8Array([0, 0, 0, 255]), i);
    }
    return e;
  }
  _copyCubeMapToTexture(e, i, n, s) {
    for (let a = 0; a < 6; a++) {
      const o = e[a], l = s === !0 ? hJ[a] : a;
      o.isDataTexture ? this._copyBufferToTexture(o.image, i, n, l, s) : this._copyImageToTexture(o, i, n, l, s);
    }
  }
  _copyImageToTexture(e, i, n, s, a) {
    this.backend.device.queue.copyExternalImageToTexture(
      {
        source: e
      },
      {
        texture: i,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: s }
      },
      {
        width: e.width,
        height: e.height,
        depthOrArrayLayers: 1
      }
    ), a === !0 && this._flipY(i, n, s);
  }
  _getPassUtils() {
    let e = this._passUtils;
    return e === null && (this._passUtils = e = new uJ(this.backend.device)), e;
  }
  _generateMipmaps(e, i, n = 0) {
    this._getPassUtils().generateMipmaps(e, i, n);
  }
  _flipY(e, i, n = 0) {
    this._getPassUtils().flipY(e, i, n);
  }
  _copyBufferToTexture(e, i, n, s, a, o = 0) {
    const l = this.backend.device, u = e.data, c = this._getBytesPerTexel(n.format), h = e.width * c;
    l.queue.writeTexture(
      {
        texture: i,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: s }
      },
      u,
      {
        offset: e.width * e.height * c * o,
        bytesPerRow: h
      },
      {
        width: e.width,
        height: e.height,
        depthOrArrayLayers: 1
      }
    ), a === !0 && this._flipY(i, n, s);
  }
  _copyCompressedBufferToTexture(e, i, n) {
    const s = this.backend.device, a = this._getBlockData(n.format), o = n.size.depthOrArrayLayers > 1;
    for (let l = 0; l < e.length; l++) {
      const u = e[l], c = u.width, h = u.height, d = o ? n.size.depthOrArrayLayers : 1, p = Math.ceil(c / a.width) * a.byteLength, f = p * Math.ceil(h / a.height);
      for (let m = 0; m < d; m++)
        s.queue.writeTexture(
          {
            texture: i,
            mipLevel: l,
            origin: { x: 0, y: 0, z: m }
          },
          u.data,
          {
            offset: m * f,
            bytesPerRow: p,
            rowsPerImage: Math.ceil(h / a.height)
          },
          {
            width: Math.ceil(c / a.width) * a.width,
            height: Math.ceil(h / a.height) * a.height,
            depthOrArrayLayers: 1
          }
        );
    }
  }
  _getBlockData(e) {
    if (e === $.BC1RGBAUnorm || e === $.BC1RGBAUnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.BC2RGBAUnorm || e === $.BC2RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC3RGBAUnorm || e === $.BC3RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC4RUnorm || e === $.BC4RSNorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.BC5RGUnorm || e === $.BC5RGSnorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC6HRGBUFloat || e === $.BC6HRGBFloat) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC7RGBAUnorm || e === $.BC7RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.ETC2RGB8Unorm || e === $.ETC2RGB8UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.ETC2RGB8A1Unorm || e === $.ETC2RGB8A1UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.ETC2RGBA8Unorm || e === $.ETC2RGBA8UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.EACR11Unorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.EACR11Snorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.EACRG11Unorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.EACRG11Snorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.ASTC4x4Unorm || e === $.ASTC4x4UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.ASTC5x4Unorm || e === $.ASTC5x4UnormSRGB) return { byteLength: 16, width: 5, height: 4 };
    if (e === $.ASTC5x5Unorm || e === $.ASTC5x5UnormSRGB) return { byteLength: 16, width: 5, height: 5 };
    if (e === $.ASTC6x5Unorm || e === $.ASTC6x5UnormSRGB) return { byteLength: 16, width: 6, height: 5 };
    if (e === $.ASTC6x6Unorm || e === $.ASTC6x6UnormSRGB) return { byteLength: 16, width: 6, height: 6 };
    if (e === $.ASTC8x5Unorm || e === $.ASTC8x5UnormSRGB) return { byteLength: 16, width: 8, height: 5 };
    if (e === $.ASTC8x6Unorm || e === $.ASTC8x6UnormSRGB) return { byteLength: 16, width: 8, height: 6 };
    if (e === $.ASTC8x8Unorm || e === $.ASTC8x8UnormSRGB) return { byteLength: 16, width: 8, height: 8 };
    if (e === $.ASTC10x5Unorm || e === $.ASTC10x5UnormSRGB) return { byteLength: 16, width: 10, height: 5 };
    if (e === $.ASTC10x6Unorm || e === $.ASTC10x6UnormSRGB) return { byteLength: 16, width: 10, height: 6 };
    if (e === $.ASTC10x8Unorm || e === $.ASTC10x8UnormSRGB) return { byteLength: 16, width: 10, height: 8 };
    if (e === $.ASTC10x10Unorm || e === $.ASTC10x10UnormSRGB) return { byteLength: 16, width: 10, height: 10 };
    if (e === $.ASTC12x10Unorm || e === $.ASTC12x10UnormSRGB) return { byteLength: 16, width: 12, height: 10 };
    if (e === $.ASTC12x12Unorm || e === $.ASTC12x12UnormSRGB) return { byteLength: 16, width: 12, height: 12 };
  }
  _convertAddressMode(e) {
    let i = av.ClampToEdge;
    return e === Um ? i = av.Repeat : e === Fm && (i = av.MirrorRepeat), i;
  }
  _convertFilterMode(e) {
    let i = Qo.Linear;
    return (e === mr || e === ix || e === Ku) && (i = Qo.Nearest), i;
  }
  _getBytesPerTexel(e) {
    if (e === $.R8Unorm || e === $.R8Snorm || e === $.R8Uint || e === $.R8Sint) return 1;
    if (e === $.R16Uint || e === $.R16Sint || e === $.R16Float || e === $.RG8Unorm || e === $.RG8Snorm || e === $.RG8Uint || e === $.RG8Sint) return 2;
    if (e === $.R32Uint || e === $.R32Sint || e === $.R32Float || e === $.RG16Uint || e === $.RG16Sint || e === $.RG16Float || e === $.RGBA8Unorm || e === $.RGBA8UnormSRGB || e === $.RGBA8Snorm || e === $.RGBA8Uint || e === $.RGBA8Sint || e === $.BGRA8Unorm || e === $.BGRA8UnormSRGB || // Packed 32-bit formats
    e === $.RGB9E5UFloat || e === $.RGB10A2Unorm || e === $.RG11B10UFloat || e === $.Depth32Float || e === $.Depth24Plus || e === $.Depth24PlusStencil8 || e === $.Depth32FloatStencil8) return 4;
    if (e === $.RG32Uint || e === $.RG32Sint || e === $.RG32Float || e === $.RGBA16Uint || e === $.RGBA16Sint || e === $.RGBA16Float) return 8;
    if (e === $.RGBA32Uint || e === $.RGBA32Sint || e === $.RGBA32Float) return 16;
  }
  _getTypedArrayType(e) {
    if (e === $.R8Uint) return Uint8Array;
    if (e === $.R8Sint) return Int8Array;
    if (e === $.R8Unorm) return Uint8Array;
    if (e === $.R8Snorm) return Int8Array;
    if (e === $.RG8Uint) return Uint8Array;
    if (e === $.RG8Sint) return Int8Array;
    if (e === $.RG8Unorm) return Uint8Array;
    if (e === $.RG8Snorm) return Int8Array;
    if (e === $.RGBA8Uint) return Uint8Array;
    if (e === $.RGBA8Sint) return Int8Array;
    if (e === $.RGBA8Unorm) return Uint8Array;
    if (e === $.RGBA8Snorm) return Int8Array;
    if (e === $.R16Uint) return Uint16Array;
    if (e === $.R16Sint) return Int16Array;
    if (e === $.RG16Uint) return Uint16Array;
    if (e === $.RG16Sint) return Int16Array;
    if (e === $.RGBA16Uint) return Uint16Array;
    if (e === $.RGBA16Sint) return Int16Array;
    if (e === $.R16Float || e === $.RG16Float || e === $.RGBA16Float) return Uint16Array;
    if (e === $.R32Uint) return Uint32Array;
    if (e === $.R32Sint) return Int32Array;
    if (e === $.R32Float) return Float32Array;
    if (e === $.RG32Uint) return Uint32Array;
    if (e === $.RG32Sint) return Int32Array;
    if (e === $.RG32Float) return Float32Array;
    if (e === $.RGBA32Uint) return Uint32Array;
    if (e === $.RGBA32Sint) return Int32Array;
    if (e === $.RGBA32Float) return Float32Array;
    if (e === $.BGRA8Unorm || e === $.BGRA8UnormSRGB) return Uint8Array;
    if (e === $.RGB10A2Unorm || e === $.RGB9E5UFloat || e === $.RG11B10UFloat) return Uint32Array;
    if (e === $.Depth32Float) return Float32Array;
    if (e === $.Depth24Plus || e === $.Depth24PlusStencil8) return Uint32Array;
    if (e === $.Depth32FloatStencil8) return Float32Array;
  }
  _getDimension(e) {
    let i;
    return e.isData3DTexture ? i = JM.ThreeD : i = JM.TwoD, i;
  }
}
function Fx(r, e = null) {
  const i = r.format, n = r.type, s = r.colorSpace;
  let a;
  if (r.isCompressedTexture === !0 || r.isCompressedArrayTexture === !0)
    switch (i) {
      case im:
        a = s === ct ? $.BC1RGBAUnormSRGB : $.BC1RGBAUnorm;
        break;
      case rm:
        a = s === ct ? $.BC2RGBAUnormSRGB : $.BC2RGBAUnorm;
        break;
      case nm:
        a = s === ct ? $.BC3RGBAUnormSRGB : $.BC3RGBAUnorm;
        break;
      case nx:
        a = s === ct ? $.ETC2RGB8UnormSRGB : $.ETC2RGB8Unorm;
        break;
      case sx:
        a = s === ct ? $.ETC2RGBA8UnormSRGB : $.ETC2RGBA8Unorm;
        break;
      case ax:
        a = s === ct ? $.ASTC4x4UnormSRGB : $.ASTC4x4Unorm;
        break;
      case ox:
        a = s === ct ? $.ASTC5x4UnormSRGB : $.ASTC5x4Unorm;
        break;
      case lx:
        a = s === ct ? $.ASTC5x5UnormSRGB : $.ASTC5x5Unorm;
        break;
      case ux:
        a = s === ct ? $.ASTC6x5UnormSRGB : $.ASTC6x5Unorm;
        break;
      case cx:
        a = s === ct ? $.ASTC6x6UnormSRGB : $.ASTC6x6Unorm;
        break;
      case hx:
        a = s === ct ? $.ASTC8x5UnormSRGB : $.ASTC8x5Unorm;
        break;
      case dx:
        a = s === ct ? $.ASTC8x6UnormSRGB : $.ASTC8x6Unorm;
        break;
      case px:
        a = s === ct ? $.ASTC8x8UnormSRGB : $.ASTC8x8Unorm;
        break;
      case fx:
        a = s === ct ? $.ASTC10x5UnormSRGB : $.ASTC10x5Unorm;
        break;
      case mx:
        a = s === ct ? $.ASTC10x6UnormSRGB : $.ASTC10x6Unorm;
        break;
      case gx:
        a = s === ct ? $.ASTC10x8UnormSRGB : $.ASTC10x8Unorm;
        break;
      case yx:
        a = s === ct ? $.ASTC10x10UnormSRGB : $.ASTC10x10Unorm;
        break;
      case vx:
        a = s === ct ? $.ASTC12x10UnormSRGB : $.ASTC12x10Unorm;
        break;
      case bx:
        a = s === ct ? $.ASTC12x12UnormSRGB : $.ASTC12x12Unorm;
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", i);
    }
  else
    switch (i) {
      case Bc:
        switch (n) {
          case Jh:
            a = $.RGBA8Snorm;
            break;
          case ed:
            a = $.RGBA16Sint;
            break;
          case Lu:
            a = $.RGBA16Uint;
            break;
          case Ji:
            a = $.RGBA32Uint;
            break;
          case Tr:
            a = $.RGBA32Sint;
            break;
          case ho:
            a = s === ct ? $.RGBA8UnormSRGB : $.RGBA8Unorm;
            break;
          case pa:
            a = $.RGBA16Float;
            break;
          case an:
            a = $.RGBA32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.", n);
        }
        break;
      case l1:
        switch (n) {
          case sP:
            a = $.RGB9E5UFloat;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBFormat.", n);
        }
        break;
      case u1:
        switch (n) {
          case Jh:
            a = $.R8Snorm;
            break;
          case ed:
            a = $.R16Sint;
            break;
          case Lu:
            a = $.R16Uint;
            break;
          case Ji:
            a = $.R32Uint;
            break;
          case Tr:
            a = $.R32Sint;
            break;
          case ho:
            a = $.R8Unorm;
            break;
          case pa:
            a = $.R16Float;
            break;
          case an:
            a = $.R32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedFormat.", n);
        }
        break;
      case yd:
        switch (n) {
          case Jh:
            a = $.RG8Snorm;
            break;
          case ed:
            a = $.RG16Sint;
            break;
          case Lu:
            a = $.RG16Uint;
            break;
          case Ji:
            a = $.RG32Uint;
            break;
          case Tr:
            a = $.RG32Sint;
            break;
          case ho:
            a = $.RG8Unorm;
            break;
          case pa:
            a = $.RG16Float;
            break;
          case an:
            a = $.RG32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGFormat.", n);
        }
        break;
      case gl:
        switch (n) {
          case Lu:
            a = $.Depth16Unorm;
            break;
          case Ji:
            a = $.Depth24Plus;
            break;
          case an:
            a = $.Depth32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthFormat.", n);
        }
        break;
      case Tc:
        switch (n) {
          case Kd:
            a = $.Depth24PlusStencil8;
            break;
          case an:
            e && e.features.has(kx.Depth32FloatStencil8) === !1 && console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'), a = $.Depth32FloatStencil8;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", n);
        }
        break;
      case c1:
        switch (n) {
          case Tr:
            a = $.R32Sint;
            break;
          case Ji:
            a = $.R32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.", n);
        }
        break;
      case h1:
        switch (n) {
          case Tr:
            a = $.RG32Sint;
            break;
          case Ji:
            a = $.RG32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.", n);
        }
        break;
      case d1:
        switch (n) {
          case Tr:
            a = $.RGBA32Sint;
            break;
          case Ji:
            a = $.RGBA32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.", n);
        }
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", i);
    }
  return a;
}
const pJ = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i, fJ = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig, xA = {
  f32: "float",
  i32: "int",
  u32: "uint",
  bool: "bool",
  "vec2<f32>": "vec2",
  "vec2<i32>": "ivec2",
  "vec2<u32>": "uvec2",
  "vec2<bool>": "bvec2",
  vec2f: "vec2",
  vec2i: "ivec2",
  vec2u: "uvec2",
  vec2b: "bvec2",
  "vec3<f32>": "vec3",
  "vec3<i32>": "ivec3",
  "vec3<u32>": "uvec3",
  "vec3<bool>": "bvec3",
  vec3f: "vec3",
  vec3i: "ivec3",
  vec3u: "uvec3",
  vec3b: "bvec3",
  "vec4<f32>": "vec4",
  "vec4<i32>": "ivec4",
  "vec4<u32>": "uvec4",
  "vec4<bool>": "bvec4",
  vec4f: "vec4",
  vec4i: "ivec4",
  vec4u: "uvec4",
  vec4b: "bvec4",
  "mat2x2<f32>": "mat2",
  mat2x2f: "mat2",
  "mat3x3<f32>": "mat3",
  mat3x3f: "mat3",
  "mat4x4<f32>": "mat4",
  mat4x4f: "mat4",
  sampler: "sampler",
  texture_1d: "texture",
  texture_2d: "texture",
  texture_2d_array: "texture",
  texture_multisampled_2d: "cubeTexture",
  texture_depth_2d: "depthTexture",
  texture_3d: "texture3D",
  texture_cube: "cubeTexture",
  texture_cube_array: "cubeTexture",
  texture_storage_1d: "storageTexture",
  texture_storage_2d: "storageTexture",
  texture_storage_2d_array: "storageTexture",
  texture_storage_3d: "storageTexture"
}, mJ = (r) => {
  r = r.trim();
  const e = r.match(pJ);
  if (e !== null && e.length === 4) {
    const i = e[2], n = [];
    let s = null;
    for (; (s = fJ.exec(i)) !== null; )
      n.push({ name: s[1], type: s[2] });
    const a = [];
    for (let c = 0; c < n.length; c++) {
      const { name: h, type: d } = n[c];
      let p = d;
      p.startsWith("ptr") ? p = "pointer" : (p.startsWith("texture") && (p = d.split("<")[0]), p = xA[p]), a.push(new $1(p, h));
    }
    const o = r.substring(e[0].length), l = e[3] || "void", u = e[1] !== void 0 ? e[1] : "";
    return {
      type: xA[l] || l,
      inputs: a,
      name: u,
      inputsCode: i,
      blockCode: o,
      outputType: l
    };
  } else
    throw new Error("FunctionNode: Function is not a WGSL code.");
};
class gJ extends Y1 {
  constructor(e) {
    const { type: i, inputs: n, name: s, inputsCode: a, blockCode: o, outputType: l } = mJ(e);
    super(i, n, s), this.inputsCode = a, this.blockCode = o, this.outputType = l;
  }
  getCode(e = this.name) {
    const i = this.outputType !== "void" ? "-> " + this.outputType : "";
    return `fn ${e} ( ${this.inputsCode.trim()} ) ${i}` + this.blockCode;
  }
}
class yJ extends s3 {
  parseFunction(e) {
    return new gJ(e);
  }
}
const Su = self.GPUShaderStage, Af = {
  vertex: Su ? Su.VERTEX : 1,
  fragment: Su ? Su.FRAGMENT : 2,
  compute: Su ? Su.COMPUTE : 4
}, _A = {
  instance: !0,
  swizzleAssign: !1,
  storageBuffer: !0
}, vJ = {
  "^^": "tsl_xor"
}, bJ = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat2: "mat2x2<f32>",
  mat3: "mat3x3<f32>",
  mat4: "mat4x4<f32>"
}, Ws = {
  tsl_xor: new pr("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
  mod_float: new pr("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
  mod_vec2: new pr("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
  mod_vec3: new pr("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
  mod_vec4: new pr("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
  equals_bool: new pr("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
  equals_bvec2: new pr("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
  equals_bvec3: new pr("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
  equals_bvec4: new pr("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
  repeatWrapping: new pr(
    /* wgsl */
    `
fn tsl_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {

	let uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );

	return ( ( uvScaled % dimension ) + dimension ) % dimension;

}
`
  ),
  biquadraticTexture: new pr(
    /* wgsl */
    `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, level : i32 ) -> vec4f {

	let iRes = vec2i( textureDimensions( map, level ) );
	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2i( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2i( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2i( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2i( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`
  )
}, Wh = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod_float: "tsl_mod_float",
  mod_vec2: "tsl_mod_vec2",
  mod_vec3: "tsl_mod_vec3",
  mod_vec4: "tsl_mod_vec4",
  equals_bool: "tsl_equals_bool",
  equals_bvec2: "tsl_equals_bvec2",
  equals_bvec3: "tsl_equals_bvec3",
  equals_bvec4: "tsl_equals_bvec4",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>"
};
/Windows/g.test(navigator.userAgent) && (Ws.pow_float = new pr("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"), Ws.pow_vec2 = new pr("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }", [Ws.pow_float]), Ws.pow_vec3 = new pr("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }", [Ws.pow_float]), Ws.pow_vec4 = new pr("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }", [Ws.pow_float]), Wh.pow_float = "tsl_pow_float", Wh.pow_vec2 = "tsl_pow_vec2", Wh.pow_vec3 = "tsl_pow_vec3", Wh.pow_vec4 = "tsl_pow_vec4");
let f3 = "";
/Firefox|Deno/g.test(navigator.userAgent) !== !0 && (f3 += `diagnostic( off, derivative_uniformity );
`);
class xJ extends r3 {
  constructor(e, i) {
    super(e, i, new yJ()), this.uniformGroups = {}, this.builtins = {}, this.directives = {}, this.scopedArrays = /* @__PURE__ */ new Map();
  }
  needsToWorkingColorSpace(e) {
    return e.isVideoTexture === !0 && e.colorSpace !== Sl;
  }
  _generateTextureSample(e, i, n, s, a = this.shaderStage) {
    return a === "fragment" ? s ? `textureSample( ${i}, ${i}_sampler, ${n}, ${s} )` : `textureSample( ${i}, ${i}_sampler, ${n} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, i, n) : this.generateTextureLod(e, i, n, "0");
  }
  _generateVideoSample(e, i, n = this.shaderStage) {
    if (n === "fragment")
      return `textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${i}.x, 1.0 - ${i}.y ) )`;
    console.error(`WebGPURenderer: THREE.VideoTexture does not support ${n} shader.`);
  }
  _generateTextureSampleLevel(e, i, n, s, a, o = this.shaderStage) {
    return o === "fragment" && this.isUnfilterable(e) === !1 ? `textureSampleLevel( ${i}, ${i}_sampler, ${n}, ${s} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, i, n, s) : this.generateTextureLod(e, i, n, s);
  }
  generateFilteredTexture(e, i, n, s = "0") {
    return this._include("biquadraticTexture"), `tsl_biquadraticTexture( ${i}, ${n}, i32( ${s} ) )`;
  }
  generateTextureLod(e, i, n, s = "0") {
    this._include("repeatWrapping");
    const a = e.isMultisampleRenderTargetTexture === !0 ? `textureDimensions( ${i} )` : `textureDimensions( ${i}, 0 )`;
    return `textureLoad( ${i}, tsl_repeatWrapping( ${n}, ${a} ), i32( ${s} ) )`;
  }
  generateTextureLoad(e, i, n, s, a = "0u") {
    return s ? `textureLoad( ${i}, ${n}, ${s}, ${a} )` : `textureLoad( ${i}, ${n}, ${a} )`;
  }
  generateTextureStore(e, i, n, s) {
    return `textureStore( ${i}, ${n}, ${s} )`;
  }
  isUnfilterable(e) {
    return this.getComponentTypeFromTexture(e) !== "float" || !this.isAvailable("float32Filterable") && e.isDataTexture === !0 && e.type === an || e.isMultisampleRenderTargetTexture === !0;
  }
  generateTexture(e, i, n, s, a = this.shaderStage) {
    let o = null;
    return e.isVideoTexture === !0 ? o = this._generateVideoSample(i, n, a) : this.isUnfilterable(e) ? o = this.generateTextureLod(e, i, n, "0", s, a) : o = this._generateTextureSample(e, i, n, s, a), o;
  }
  generateTextureGrad(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleGrad( ${i}, ${i}_sampler, ${n},  ${s[0]}, ${s[1]} )`;
    console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${o} shader.`);
  }
  generateTextureCompare(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleCompare( ${i}, ${i}_sampler, ${n}, ${s} )`;
    console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${o} shader.`);
  }
  generateTextureLevel(e, i, n, s, a, o = this.shaderStage) {
    let l = null;
    return e.isVideoTexture === !0 ? l = this._generateVideoSample(i, n, o) : l = this._generateTextureSampleLevel(e, i, n, s, a, o), l;
  }
  generateTextureBias(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleBias( ${i}, ${i}_sampler, ${n}, ${s} )`;
    console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${o} shader.`);
  }
  getPropertyName(e, i = this.shaderStage) {
    if (e.isNodeVarying === !0 && e.needsInterpolation === !0) {
      if (i === "vertex")
        return `varyings.${e.name}`;
    } else if (e.isNodeUniform === !0) {
      const n = e.name, s = e.type;
      return s === "texture" || s === "cubeTexture" || s === "storageTexture" || s === "texture3D" ? n : s === "buffer" || s === "storageBuffer" || s === "indirectStorageBuffer" ? `NodeBuffer_${e.id}.${n}` : e.groupNode.name + "." + n;
    }
    return super.getPropertyName(e);
  }
  getOutputStructName() {
    return "output";
  }
  _getUniformGroupCount(e) {
    return Object.keys(this.uniforms[e]).length;
  }
  getFunctionOperator(e) {
    const i = vJ[e];
    return i !== void 0 ? (this._include(i), i) : null;
  }
  getStorageAccess(e) {
    if (e.isStorageTextureNode)
      switch (e.access) {
        case QM.ReadOnly:
          return "read";
        case QM.WriteOnly:
          return "write";
        default:
          return "read_write";
      }
    else
      switch (e.access) {
        case Lx.Storage:
          return "read_write";
        case Lx.ReadOnlyStorage:
          return "read";
        default:
          return "write";
      }
  }
  getUniformFromNode(e, i, n, s = null) {
    const a = super.getUniformFromNode(e, i, n, s), o = this.getDataFromNode(e, n, this.globalCache);
    if (o.uniformGPU === void 0) {
      let l;
      const u = e.groupNode, c = u.name, h = this.getBindGroupArray(c, n);
      if (i === "texture" || i === "cubeTexture" || i === "storageTexture" || i === "texture3D") {
        let d = null;
        if (i === "texture" || i === "storageTexture" ? d = new Wg(a.name, a.node, u, e.access ? e.access : null) : i === "cubeTexture" ? d = new h3(a.name, a.node, u, e.access ? e.access : null) : i === "texture3D" && (d = new d3(a.name, a.node, u, e.access ? e.access : null)), d.store = e.isStorageTextureNode === !0, d.setVisibility(Af[n]), n === "fragment" && this.isUnfilterable(e.value) === !1 && d.store === !1) {
          const p = new sJ(`${a.name}_sampler`, a.node, u);
          p.setVisibility(Af[n]), h.push(p, d), l = [p, d];
        } else
          h.push(d), l = [d];
      } else if (i === "buffer" || i === "storageBuffer" || i === "indirectStorageBuffer") {
        const d = i === "buffer" ? u3 : lJ, p = new d(e, u);
        p.setVisibility(Af[n]), h.push(p), l = p;
      } else {
        const d = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let p = d[c];
        p === void 0 && (p = new c3(c, u), p.setVisibility(Af[n]), d[c] = p, h.push(p)), l = this.getNodeUniform(a, i), p.addUniform(l);
      }
      o.uniformGPU = l;
    }
    return a;
  }
  getBuiltin(e, i, n, s = this.shaderStage) {
    const a = this.builtins[s] || (this.builtins[s] = /* @__PURE__ */ new Map());
    return a.has(e) === !1 && a.set(e, {
      name: e,
      property: i,
      type: n
    }), i;
  }
  hasBuiltin(e, i = this.shaderStage) {
    return this.builtins[i] !== void 0 && this.builtins[i].has(e);
  }
  getVertexIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute") : "vertexIndex";
  }
  buildFunctionCode(e) {
    const i = e.layout, n = this.flowShaderNode(e), s = [];
    for (const o of i.inputs)
      s.push(o.name + " : " + this.getType(o.type));
    let a = `fn ${i.name}( ${s.join(", ")} ) -> ${this.getType(i.type)} {
${n.vars}
${n.code}
`;
    return n.result && (a += `	return ${n.result};
`), a += `
}
`, a;
  }
  getInstanceIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute") : "instanceIndex";
  }
  getInvocationLocalIndex() {
    return this.getBuiltin("local_invocation_index", "invocationLocalIndex", "u32", "attribute");
  }
  getSubgroupSize() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
  }
  getInvocationSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_invocation_id", "invocationSubgroupIndex", "u32", "attribute");
  }
  getSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute");
  }
  getDrawIndex() {
    return null;
  }
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
  }
  getFragDepth() {
    return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
  }
  isFlipY() {
    return !1;
  }
  enableDirective(e, i = this.shaderStage) {
    (this.directives[i] || (this.directives[i] = /* @__PURE__ */ new Set())).add(e);
  }
  getDirectives(e) {
    const i = [], n = this.directives[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`enable ${s};`);
    return i.join(`
`);
  }
  enableSubGroups() {
    this.enableDirective("subgroups");
  }
  enableSubgroupsF16() {
    this.enableDirective("subgroups-f16");
  }
  enableClipDistances() {
    this.enableDirective("clip_distances");
  }
  enableShaderF16() {
    this.enableDirective("f16");
  }
  enableDualSourceBlending() {
    this.enableDirective("dual_source_blending");
  }
  getBuiltins(e) {
    const i = [], n = this.builtins[e];
    if (n !== void 0)
      for (const { name: s, property: a, type: o } of n.values())
        i.push(`@builtin( ${s} ) ${a} : ${o}`);
    return i.join(`,
	`);
  }
  getScopedArray(e, i, n, s) {
    return this.scopedArrays.has(e) === !1 && this.scopedArrays.set(e, {
      name: e,
      scope: i,
      bufferType: n,
      bufferCount: s
    }), e;
  }
  getScopedArrays(e) {
    if (e !== "compute")
      return;
    const i = [];
    for (const { name: n, scope: s, bufferType: a, bufferCount: o } of this.scopedArrays.values()) {
      const l = this.getType(a);
      i.push(`var<${s}> ${n}: array< ${l}, ${o} >;`);
    }
    return i.join(`
`);
  }
  getAttributes(e) {
    const i = [];
    if (e === "compute" && (this.getBuiltin("global_invocation_id", "id", "vec3<u32>", "attribute"), this.getBuiltin("workgroup_id", "workgroupId", "vec3<u32>", "attribute"), this.getBuiltin("local_invocation_id", "localId", "vec3<u32>", "attribute"), this.getBuiltin("num_workgroups", "numWorkgroups", "vec3<u32>", "attribute"), this.renderer.hasFeature("subgroups") && (this.enableDirective("subgroups", e), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute"))), e === "vertex" || e === "compute") {
      const n = this.getBuiltins("attribute");
      n && i.push(n);
      const s = this.getAttributesArray();
      for (let a = 0, o = s.length; a < o; a++) {
        const l = s[a], u = l.name, c = this.getType(l.type);
        i.push(`@location( ${a} ) ${u} : ${c}`);
      }
    }
    return i.join(`,
	`);
  }
  getStructMembers(e) {
    const i = [], n = e.getMemberTypes();
    for (let a = 0; a < n.length; a++) {
      const o = n[a];
      i.push(`	@location( ${a} ) m${a} : ${o}<f32>`);
    }
    const s = this.getBuiltins("output");
    return s && i.push("	" + s), i.join(`,
`);
  }
  getStructs(e) {
    const i = [], n = this.structs[e];
    for (let s = 0, a = n.length; s < a; s++) {
      const o = n[s], l = o.name;
      let u = `struct ${l} {
`;
      u += this.getStructMembers(o), u += `
}`, i.push(u), i.push(`
var<private> output : ${l};

`);
    }
    return i.join(`

`);
  }
  getVar(e, i) {
    return `var ${i} : ${this.getType(e)}`;
  }
  getVars(e) {
    const i = [], n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`	${this.getVar(s.type, s.name)};`);
    return `
${i.join(`
`)}
`;
  }
  getVaryings(e) {
    const i = [];
    if (e === "vertex" && this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex"), e === "vertex" || e === "fragment") {
      const a = this.varyings, o = this.vars[e];
      for (let l = 0; l < a.length; l++) {
        const u = a[l];
        if (u.needsInterpolation) {
          let c = `@location( ${l} )`;
          /^(int|uint|ivec|uvec)/.test(u.type) && (c += " @interpolate( flat )"), i.push(`${c} ${u.name} : ${this.getType(u.type)}`);
        } else e === "vertex" && o.includes(u) === !1 && o.push(u);
      }
    }
    const n = this.getBuiltins(e);
    n && i.push(n);
    const s = i.join(`,
	`);
    return e === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + s) : s;
  }
  getUniforms(e) {
    const i = this.uniforms[e], n = [], s = [], a = [], o = {};
    for (const u of i) {
      const c = u.groupNode.name, h = this.bindingsIndexes[c];
      if (u.type === "texture" || u.type === "cubeTexture" || u.type === "storageTexture" || u.type === "texture3D") {
        const d = u.node.value;
        e === "fragment" && this.isUnfilterable(d) === !1 && u.node.isStorageTextureNode !== !0 && (d.isDepthTexture === !0 && d.compareFunction !== null ? n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name}_sampler : sampler_comparison;`) : n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name}_sampler : sampler;`));
        let p, f = "";
        if (d.isMultisampleRenderTargetTexture === !0 && (f = "_multisampled"), d.isCubeTexture === !0)
          p = "texture_cube<f32>";
        else if (d.isDataArrayTexture === !0 || d.isCompressedArrayTexture === !0)
          p = "texture_2d_array<f32>";
        else if (d.isDepthTexture === !0)
          p = `texture_depth${f}_2d`;
        else if (d.isVideoTexture === !0)
          p = "texture_external";
        else if (d.isData3DTexture === !0)
          p = "texture_3d<f32>";
        else if (u.node.isStorageTextureNode === !0) {
          const m = Fx(d), y = this.getStorageAccess(u.node);
          p = `texture_storage_2d<${m}, ${y}>`;
        } else {
          const m = this.getComponentTypeFromTexture(d).charAt(0);
          p = `texture${f}_2d<${m}32>`;
        }
        n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name} : ${p};`);
      } else if (u.type === "buffer" || u.type === "storageBuffer" || u.type === "indirectStorageBuffer") {
        const d = u.node, p = this.getType(d.bufferType), f = d.bufferCount, m = f > 0 && u.type === "buffer" ? ", " + f : "", y = d.isAtomic ? `atomic<${p}>` : `${p}`, v = `	${u.name} : array< ${y}${m} >
`, g = d.isStorageBufferNode ? `storage, ${this.getStorageAccess(d)}` : "uniform";
        s.push(this._getWGSLStructBinding("NodeBuffer_" + d.id, v, g, h.binding++, h.group));
      } else {
        const d = this.getType(this.getVectorType(u.type)), p = u.groupNode.name;
        (o[p] || (o[p] = {
          index: h.binding++,
          id: h.group,
          snippets: []
        })).snippets.push(`	${u.name} : ${d}`);
      }
    }
    for (const u in o) {
      const c = o[u];
      a.push(this._getWGSLStructBinding(u, c.snippets.join(`,
`), "uniform", c.index, c.id));
    }
    let l = n.join(`
`);
    return l += s.join(`
`), l += a.join(`
`), l;
  }
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const i in e) {
      const n = e[i];
      n.uniforms = this.getUniforms(i), n.attributes = this.getAttributes(i), n.varyings = this.getVaryings(i), n.structs = this.getStructs(i), n.vars = this.getVars(i), n.codes = this.getCodes(i), n.directives = this.getDirectives(i), n.scopedArrays = this.getScopedArrays(i);
      let s = `// code

`;
      s += this.flowCode[i];
      const a = this.flowNodes[i], o = a[a.length - 1], l = o.outputNode, u = l !== void 0 && l.isOutputStructNode === !0;
      for (const c of a) {
        const h = this.getFlowData(
          c
          /*, shaderStage*/
        ), d = c.name;
        if (d && (s.length > 0 && (s += `
`), s += `	// flow -> ${d}
	`), s += `${h.code}
	`, c === o && i !== "compute") {
          if (s += `// result

	`, i === "vertex")
            s += `varyings.Vertex = ${h.result};`;
          else if (i === "fragment")
            if (u)
              n.returnType = l.nodeType, s += `return ${h.result};`;
            else {
              let p = "	@location(0) color: vec4<f32>";
              const f = this.getBuiltins("output");
              f && (p += `,
	` + f), n.returnType = "OutputStruct", n.structs += this._getWGSLStruct("OutputStruct", p), n.structs += `
var<private> output : OutputStruct;

`, s += `output.color = ${h.result};

	return output;`;
            }
        }
      }
      n.flow = s;
    }
    this.material !== null ? (this.vertexShader = this._getWGSLVertexCode(e.vertex), this.fragmentShader = this._getWGSLFragmentCode(e.fragment)) : this.computeShader = this._getWGSLComputeCode(e.compute, (this.object.workgroupSize || [64]).join(", "));
  }
  getMethod(e, i = null) {
    let n;
    return i !== null && (n = this._getWGSLMethod(e + "_" + i)), n === void 0 && (n = this._getWGSLMethod(e)), n || e;
  }
  getType(e) {
    return bJ[e] || e;
  }
  isAvailable(e) {
    let i = _A[e];
    return i === void 0 && (e === "float32Filterable" && (i = this.renderer.hasFeature("float32-filterable")), _A[e] = i), i;
  }
  _getWGSLMethod(e) {
    return Ws[e] !== void 0 && this._include(e), Wh[e];
  }
  _include(e) {
    const i = Ws[e];
    return i.build(this), this.currentFunctionNode !== null && this.currentFunctionNode.includes.push(i), i;
  }
  _getWGSLVertexCode(e) {
    return `${this.getSignature()}
// directives
${e.directives}

// uniforms
${e.uniforms}

// varyings
${e.varyings}
var<private> varyings : VaryingsStruct;

// codes
${e.codes}

@vertex
fn main( ${e.attributes} ) -> VaryingsStruct {

	// vars
	${e.vars}

	// flow
	${e.flow}

	return varyings;

}
`;
  }
  _getWGSLFragmentCode(e) {
    return `${this.getSignature()}
// global
${f3}

// uniforms
${e.uniforms}

// structs
${e.structs}

// codes
${e.codes}

@fragment
fn main( ${e.varyings} ) -> ${e.returnType} {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  _getWGSLComputeCode(e, i) {
    return `${this.getSignature()}
// directives
${e.directives}

// system
var<private> instanceIndex : u32;

// locals
${e.scopedArrays}

// uniforms
${e.uniforms}

// codes
${e.codes}

@compute @workgroup_size( ${i} )
fn main( ${e.attributes} ) {

	// system
	instanceIndex = id.x + id.y * numWorkgroups.x * u32(${i}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${i});

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  _getWGSLStruct(e, i) {
    return `
struct ${e} {
${i}
};`;
  }
  _getWGSLStructBinding(e, i, n, s = 0, a = 0) {
    const o = e + "Struct";
    return `${this._getWGSLStruct(o, i)}
@binding( ${s} ) @group( ${a} )
var<${n}> ${e} : ${o};`;
  }
}
class _J {
  constructor(e) {
    this.backend = e;
  }
  getCurrentDepthStencilFormat(e) {
    let i;
    return e.depthTexture !== null ? i = this.getTextureFormatGPU(e.depthTexture) : e.depth && e.stencil ? i = $.Depth24PlusStencil8 : e.depth && (i = $.Depth24Plus), i;
  }
  getTextureFormatGPU(e) {
    return this.backend.get(e).format;
  }
  getCurrentColorFormat(e) {
    let i;
    return e.textures !== null ? i = this.getTextureFormatGPU(e.textures[0]) : i = this.getPreferredCanvasFormat(), i;
  }
  getCurrentColorSpace(e) {
    return e.textures !== null ? e.textures[0].colorSpace : this.backend.renderer.outputColorSpace;
  }
  getPrimitiveTopology(e, i) {
    if (e.isPoints) return Bu.PointList;
    if (e.isLineSegments || e.isMesh && i.wireframe === !0) return Bu.LineList;
    if (e.isLine) return Bu.LineStrip;
    if (e.isMesh) return Bu.TriangleList;
  }
  getSampleCount(e) {
    let i = 1;
    return e > 1 && (i = Math.pow(2, Math.floor(Math.log2(e))), i === 2 && (i = 4)), i;
  }
  getSampleCountRenderContext(e) {
    return e.textures !== null ? this.getSampleCount(e.sampleCount) : this.getSampleCount(this.backend.renderer.samples);
  }
  getPreferredCanvasFormat() {
    return navigator.userAgent.includes("Quest") ? $.BGRA8Unorm : navigator.gpu.getPreferredCanvasFormat();
  }
}
const TJ = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]), SJ = /* @__PURE__ */ new Map([
  [vP, ["float16"]]
]), wJ = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Int16Array, "sint32"],
  // patch for INT16
  [Uint32Array, "uint32"],
  [Uint16Array, "uint32"],
  // patch for UINT16
  [Float32Array, "float32"]
]);
class EJ {
  constructor(e) {
    this.backend = e;
  }
  createAttribute(e, i) {
    const n = this._getBufferAttribute(e), s = this.backend, a = s.get(n);
    let o = a.buffer;
    if (o === void 0) {
      const l = s.device;
      let u = n.array;
      if (e.normalized === !1 && (u.constructor === Int16Array || u.constructor === Uint16Array)) {
        const h = new Uint32Array(u.length);
        for (let d = 0; d < u.length; d++)
          h[d] = u[d];
        u = h;
      }
      if (n.array = u, (n.isStorageBufferAttribute || n.isStorageInstancedBufferAttribute) && n.itemSize === 3) {
        u = new u.constructor(n.count * 4);
        for (let h = 0; h < n.count; h++)
          u.set(n.array.subarray(h * 3, h * 3 + 3), h * 4);
        n.itemSize = 4, n.array = u;
      }
      const c = u.byteLength + (4 - u.byteLength % 4) % 4;
      o = l.createBuffer({
        label: n.name,
        size: c,
        usage: i,
        mappedAtCreation: !0
      }), new u.constructor(o.getMappedRange()).set(u), o.unmap(), a.buffer = o;
    }
  }
  updateAttribute(e) {
    const i = this._getBufferAttribute(e), n = this.backend, s = n.device, a = n.get(i).buffer, o = i.array, l = i.updateRanges;
    if (l.length === 0)
      s.queue.writeBuffer(
        a,
        0,
        o,
        0
      );
    else {
      for (let u = 0, c = l.length; u < c; u++) {
        const h = l[u];
        s.queue.writeBuffer(
          a,
          0,
          o,
          h.start * o.BYTES_PER_ELEMENT,
          h.count * o.BYTES_PER_ELEMENT
        );
      }
      i.clearUpdateRanges();
    }
  }
  createShaderVertexBuffers(e) {
    const i = e.getAttributes(), n = /* @__PURE__ */ new Map();
    for (let s = 0; s < i.length; s++) {
      const a = i[s], o = a.array.BYTES_PER_ELEMENT, l = this._getBufferAttribute(a);
      let u = n.get(l);
      if (u === void 0) {
        let d, p;
        a.isInterleavedBufferAttribute === !0 ? (d = a.data.stride * o, p = a.data.isInstancedInterleavedBuffer ? vf.Instance : vf.Vertex) : (d = a.itemSize * o, p = a.isInstancedBufferAttribute ? vf.Instance : vf.Vertex), a.normalized === !1 && (a.array.constructor === Int16Array || a.array.constructor === Uint16Array) && (d = 4), u = {
          arrayStride: d,
          attributes: [],
          stepMode: p
        }, n.set(l, u);
      }
      const c = this._getVertexFormat(a), h = a.isInterleavedBufferAttribute === !0 ? a.offset * o : 0;
      u.attributes.push({
        shaderLocation: s,
        offset: h,
        format: c
      });
    }
    return Array.from(n.values());
  }
  destroyAttribute(e) {
    const i = this.backend;
    i.get(this._getBufferAttribute(e)).buffer.destroy(), i.delete(e);
  }
  async getArrayBufferAsync(e) {
    const i = this.backend, n = i.device, s = i.get(this._getBufferAttribute(e)).buffer, a = s.size, o = n.createBuffer({
      label: e.name,
      size: a,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    }), l = n.createCommandEncoder({});
    l.copyBufferToBuffer(
      s,
      0,
      o,
      0,
      a
    ), o.unmap();
    const u = l.finish();
    return n.queue.submit([u]), await o.mapAsync(GPUMapMode.READ), o.getMappedRange();
  }
  _getVertexFormat(e) {
    const { itemSize: i, normalized: n } = e, s = e.array.constructor, a = e.constructor;
    let o;
    if (i == 1)
      o = wJ.get(s);
    else {
      const l = (SJ.get(a) || TJ.get(s))[n ? 1 : 0];
      if (l) {
        const u = s.BYTES_PER_ELEMENT * i, c = Math.floor((u + 3) / 4) * 4 / s.BYTES_PER_ELEMENT;
        if (c % 1)
          throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
        o = `${l}x${c}`;
      }
    }
    return o || console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet."), o;
  }
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
class MJ {
  constructor(e) {
    this.backend = e, this.bindGroupLayoutCache = /* @__PURE__ */ new WeakMap();
  }
  createBindingsLayout(e) {
    const i = this.backend.device, n = [];
    let s = 0;
    for (const a of e.bindings) {
      const o = {
        binding: s++,
        visibility: a.visibility
      };
      if (a.isUniformBuffer || a.isStorageBuffer) {
        const l = {};
        a.isStorageBuffer && (l.type = a.access), o.buffer = l;
      } else if (a.isSampler) {
        const l = {};
        a.texture.isDepthTexture && a.texture.compareFunction !== null && (l.type = "comparison"), o.sampler = l;
      } else if (a.isSampledTexture && a.texture.isVideoTexture)
        o.externalTexture = {};
      else if (a.isSampledTexture && a.store) {
        const l = this.backend.get(a.texture).texture.format, u = a.access;
        o.storageTexture = { format: l, access: u };
      } else if (a.isSampledTexture) {
        const l = {};
        if (a.texture.isMultisampleRenderTargetTexture === !0 && (l.multisampled = !0), a.texture.isDepthTexture)
          l.sampleType = Mh.Depth;
        else if (a.texture.isDataTexture || a.texture.isDataArrayTexture || a.texture.isData3DTexture) {
          const u = a.texture.type;
          u === Tr ? l.sampleType = Mh.SInt : u === Ji ? l.sampleType = Mh.UInt : u === an && (this.backend.hasFeature("float32-filterable") ? l.sampleType = Mh.Float : l.sampleType = Mh.UnfilterableFloat);
        }
        a.isSampledCubeTexture ? l.viewDimension = gn.Cube : a.texture.isDataArrayTexture || a.texture.isCompressedArrayTexture ? l.viewDimension = gn.TwoDArray : a.isSampledTexture3D && (l.viewDimension = gn.ThreeD), o.texture = l;
      } else
        console.error(`WebGPUBindingUtils: Unsupported binding "${a}".`);
      n.push(o);
    }
    return i.createBindGroupLayout({ entries: n });
  }
  createBindings(e) {
    const { backend: i, bindGroupLayoutCache: n } = this, s = i.get(e);
    let a = n.get(e.bindingsReference);
    a === void 0 && (a = this.createBindingsLayout(e), n.set(e.bindingsReference, a));
    const o = this.createBindGroup(e, a);
    s.layout = a, s.group = o;
  }
  updateBinding(e) {
    const i = this.backend, n = i.device, s = e.buffer, a = i.get(e).buffer;
    n.queue.writeBuffer(a, 0, s, 0);
  }
  createBindGroup(e, i) {
    const n = this.backend, s = n.device;
    let a = 0;
    const o = [];
    for (const l of e.bindings) {
      if (l.isUniformBuffer) {
        const u = n.get(l);
        if (u.buffer === void 0) {
          const c = l.byteLength, h = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, d = s.createBuffer({
            label: "bindingBuffer_" + l.name,
            size: c,
            usage: h
          });
          u.buffer = d;
        }
        o.push({ binding: a, resource: { buffer: u.buffer } });
      } else if (l.isStorageBuffer) {
        const u = n.get(l);
        if (u.buffer === void 0) {
          const c = l.attribute;
          u.buffer = n.get(c).buffer;
        }
        o.push({ binding: a, resource: { buffer: u.buffer } });
      } else if (l.isSampler) {
        const u = n.get(l.texture);
        o.push({ binding: a, resource: u.sampler });
      } else if (l.isSampledTexture) {
        const u = n.get(l.texture);
        let c;
        if (u.externalTexture !== void 0)
          c = s.importExternalTexture({ source: u.externalTexture });
        else {
          const h = l.store ? 1 : u.texture.mipLevelCount, d = `view-${u.texture.width}-${u.texture.height}-${h}`;
          if (c = u[d], c === void 0) {
            const p = pZ.All;
            let f;
            l.isSampledCubeTexture ? f = gn.Cube : l.isSampledTexture3D ? f = gn.ThreeD : l.texture.isDataArrayTexture || l.texture.isCompressedArrayTexture ? f = gn.TwoDArray : f = gn.TwoD, c = u[d] = u.texture.createView({ aspect: p, dimension: f, mipLevelCount: h });
          }
        }
        o.push({ binding: a, resource: c });
      }
      a++;
    }
    return s.createBindGroup({
      label: "bindGroup_" + e.name,
      layout: i,
      entries: o
    });
  }
}
class AJ {
  constructor(e) {
    this.backend = e;
  }
  _getSampleCount(e) {
    return this.backend.utils.getSampleCountRenderContext(e);
  }
  createRenderPipeline(e, i) {
    const { object: n, material: s, geometry: a, pipeline: o } = e, { vertexProgram: l, fragmentProgram: u } = o, c = this.backend, h = c.device, d = c.utils, p = c.get(o), f = [];
    for (const k of e.getBindings()) {
      const C = c.get(k);
      f.push(C.layout);
    }
    const m = c.attributeUtils.createShaderVertexBuffers(e);
    let y;
    s.transparent === !0 && s.blending !== xc && (y = this._getBlending(s));
    let v = {};
    s.stencilWrite === !0 && (v = {
      compare: this._getStencilCompare(s),
      failOp: this._getStencilOperation(s.stencilFail),
      depthFailOp: this._getStencilOperation(s.stencilZFail),
      passOp: this._getStencilOperation(s.stencilZPass)
    });
    const g = this._getColorWriteMask(s), _ = [];
    if (e.context.textures !== null) {
      const k = e.context.textures;
      for (let C = 0; C < k.length; C++) {
        const I = d.getTextureFormatGPU(k[C]);
        _.push({
          format: I,
          blend: y,
          writeMask: g
        });
      }
    } else {
      const k = d.getCurrentColorFormat(e.context);
      _.push({
        format: k,
        blend: y,
        writeMask: g
      });
    }
    const x = c.get(l).module, b = c.get(u).module, T = this._getPrimitiveState(n, a, s), S = this._getDepthCompare(s), w = d.getCurrentDepthStencilFormat(e.context), M = this._getSampleCount(e.context), E = {
      label: `renderPipeline_${s.name || s.type}_${s.id}`,
      vertex: Object.assign({}, x, { buffers: m }),
      fragment: Object.assign({}, b, { targets: _ }),
      primitive: T,
      multisample: {
        count: M,
        alphaToCoverageEnabled: s.alphaToCoverage && M > 1
      },
      layout: h.createPipelineLayout({
        bindGroupLayouts: f
      })
    }, A = {}, N = e.context.depth, U = e.context.stencil;
    if ((N === !0 || U === !0) && (N === !0 && (A.format = w, A.depthWriteEnabled = s.depthWrite, A.depthCompare = S), U === !0 && (A.stencilFront = v, A.stencilBack = {}, A.stencilReadMask = s.stencilFuncMask, A.stencilWriteMask = s.stencilWriteMask), E.depthStencil = A), i === null)
      p.pipeline = h.createRenderPipeline(E);
    else {
      const k = new Promise((C) => {
        h.createRenderPipelineAsync(E).then((I) => {
          p.pipeline = I, C();
        });
      });
      i.push(k);
    }
  }
  createBundleEncoder(e) {
    const i = this.backend, { utils: n, device: s } = i, a = n.getCurrentDepthStencilFormat(e), o = n.getCurrentColorFormat(e), l = this._getSampleCount(e), u = {
      label: "renderBundleEncoder",
      colorFormats: [o],
      depthStencilFormat: a,
      sampleCount: l
    };
    return s.createRenderBundleEncoder(u);
  }
  createComputePipeline(e, i) {
    const n = this.backend, s = n.device, a = n.get(e.computeProgram).module, o = n.get(e), l = [];
    for (const u of i) {
      const c = n.get(u);
      l.push(c.layout);
    }
    o.pipeline = s.createComputePipeline({
      compute: a,
      layout: s.createPipelineLayout({
        bindGroupLayouts: l
      })
    });
  }
  _getBlending(e) {
    let i, n;
    const s = e.blending, a = e.blendSrc, o = e.blendDst, l = e.blendEquation;
    if (s === zN) {
      const u = e.blendSrcAlpha !== null ? e.blendSrcAlpha : a, c = e.blendDstAlpha !== null ? e.blendDstAlpha : o, h = e.blendEquationAlpha !== null ? e.blendEquationAlpha : l;
      i = {
        srcFactor: this._getBlendFactor(a),
        dstFactor: this._getBlendFactor(o),
        operation: this._getBlendOperation(l)
      }, n = {
        srcFactor: this._getBlendFactor(u),
        dstFactor: this._getBlendFactor(c),
        operation: this._getBlendOperation(h)
      };
    } else {
      const u = e.premultipliedAlpha, c = (h, d, p, f) => {
        i = {
          srcFactor: h,
          dstFactor: d,
          operation: Bo.Add
        }, n = {
          srcFactor: p,
          dstFactor: f,
          operation: Bo.Add
        };
      };
      if (u)
        switch (s) {
          case co:
            c(yt.One, yt.OneMinusSrcAlpha, yt.One, yt.OneMinusSrcAlpha);
            break;
          case Pm:
            c(yt.One, yt.One, yt.One, yt.One);
            break;
          case Im:
            c(yt.Zero, yt.OneMinusSrc, yt.Zero, yt.One);
            break;
          case Om:
            c(yt.Zero, yt.Src, yt.Zero, yt.SrcAlpha);
            break;
        }
      else
        switch (s) {
          case co:
            c(yt.SrcAlpha, yt.OneMinusSrcAlpha, yt.One, yt.OneMinusSrcAlpha);
            break;
          case Pm:
            c(yt.SrcAlpha, yt.One, yt.SrcAlpha, yt.One);
            break;
          case Im:
            c(yt.Zero, yt.OneMinusSrc, yt.Zero, yt.One);
            break;
          case Om:
            c(yt.Zero, yt.Src, yt.Zero, yt.Src);
            break;
        }
    }
    if (i !== void 0 && n !== void 0)
      return { color: i, alpha: n };
    console.error("THREE.WebGPURenderer: Invalid blending: ", s);
  }
  _getBlendFactor(e) {
    let i;
    switch (e) {
      case GN:
        i = yt.Zero;
        break;
      case HN:
        i = yt.One;
        break;
      case WN:
        i = yt.Src;
        break;
      case qN:
        i = yt.OneMinusSrc;
        break;
      case Dm:
        i = yt.SrcAlpha;
        break;
      case Lm:
        i = yt.OneMinusSrcAlpha;
        break;
      case YN:
        i = yt.Dst;
        break;
      case KN:
        i = yt.OneMinusDstColor;
        break;
      case XN:
        i = yt.DstAlpha;
        break;
      case $N:
        i = yt.OneMinusDstAlpha;
        break;
      case ZN:
        i = yt.SrcAlphaSaturated;
        break;
      case jK:
        i = yt.Constant;
        break;
      case VK:
        i = yt.OneMinusConstant;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend factor not supported.", e);
    }
    return i;
  }
  _getStencilCompare(e) {
    let i;
    const n = e.stencilFunc;
    switch (n) {
      case c7:
        i = Zi.Never;
        break;
      case xx:
        i = Zi.Always;
        break;
      case h7:
        i = Zi.Less;
        break;
      case p7:
        i = Zi.LessEqual;
        break;
      case d7:
        i = Zi.Equal;
        break;
      case g7:
        i = Zi.GreaterEqual;
        break;
      case f7:
        i = Zi.Greater;
        break;
      case m7:
        i = Zi.NotEqual;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil function.", n);
    }
    return i;
  }
  _getStencilOperation(e) {
    let i;
    switch (e) {
      case Go:
        i = Ga.Keep;
        break;
      case r7:
        i = Ga.Zero;
        break;
      case n7:
        i = Ga.Replace;
        break;
      case u7:
        i = Ga.Invert;
        break;
      case s7:
        i = Ga.IncrementClamp;
        break;
      case a7:
        i = Ga.DecrementClamp;
        break;
      case o7:
        i = Ga.IncrementWrap;
        break;
      case l7:
        i = Ga.DecrementWrap;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil operation.", i);
    }
    return i;
  }
  _getBlendOperation(e) {
    let i;
    switch (e) {
      case Ja:
        i = Bo.Add;
        break;
      case jN:
        i = Bo.Subtract;
        break;
      case VN:
        i = Bo.ReverseSubtract;
        break;
      case B9:
        i = Bo.Min;
        break;
      case z9:
        i = Bo.Max;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.", e);
    }
    return i;
  }
  _getPrimitiveState(e, i, n) {
    const s = {}, a = this.backend.utils;
    switch (s.topology = a.getPrimitiveTopology(e, n), i.index !== null && e.isLine === !0 && e.isLineSegments !== !0 && (s.stripIndexFormat = i.index.array instanceof Uint16Array ? Mc.Uint16 : Mc.Uint32), n.side) {
      case bc:
        s.frontFace = nv.CCW, s.cullMode = sv.Back;
        break;
      case Zn:
        s.frontFace = nv.CCW, s.cullMode = sv.Front;
        break;
      case $u:
        s.frontFace = nv.CCW, s.cullMode = sv.None;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.", n.side);
        break;
    }
    return s;
  }
  _getColorWriteMask(e) {
    return e.colorWrite === !0 ? ZM.All : ZM.None;
  }
  _getDepthCompare(e) {
    let i;
    if (e.depthTest === !1)
      i = Zi.Always;
    else {
      const n = e.depthFunc;
      switch (n) {
        case QN:
          i = Zi.Never;
          break;
        case JN:
          i = Zi.Always;
          break;
        case eP:
          i = Zi.Less;
          break;
        case km:
          i = Zi.LessEqual;
          break;
        case tP:
          i = Zi.Equal;
          break;
        case iP:
          i = Zi.GreaterEqual;
          break;
        case rP:
          i = Zi.Greater;
          break;
        case nP:
          i = Zi.NotEqual;
          break;
        default:
          console.error("THREE.WebGPUPipelineUtils: Invalid depth function.", n);
      }
    }
    return i;
  }
}
class CJ extends p3 {
  constructor(e = {}) {
    super(e), this.isWebGPUBackend = !0, this.parameters.alpha = e.alpha === void 0 ? !0 : e.alpha, this.parameters.requiredLimits = e.requiredLimits === void 0 ? {} : e.requiredLimits, this.trackTimestamp = e.trackTimestamp === !0, this.device = null, this.context = null, this.colorBuffer = null, this.defaultRenderPassdescriptor = null, this.utils = new _J(this), this.attributeUtils = new EJ(this), this.bindingUtils = new MJ(this), this.pipelineUtils = new AJ(this), this.textureUtils = new dJ(this), this.occludedResolveCache = /* @__PURE__ */ new Map();
  }
  async init(e) {
    await super.init(e);
    const i = this.parameters;
    let n;
    if (i.device === void 0) {
      const o = {
        powerPreference: i.powerPreference
      }, l = await navigator.gpu.requestAdapter(o);
      if (l === null)
        throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
      const u = Object.values(kx), c = [];
      for (const d of u)
        l.features.has(d) && c.push(d);
      const h = {
        requiredFeatures: c,
        requiredLimits: i.requiredLimits
      };
      n = await l.requestDevice(h);
    } else
      n = i.device;
    n.lost.then((o) => {
      const l = {
        api: "WebGPU",
        message: o.message || "Unknown reason",
        reason: o.reason || null,
        originalEvent: o
      };
      e.onDeviceLost(l);
    });
    const s = i.context !== void 0 ? i.context : e.domElement.getContext("webgpu");
    this.device = n, this.context = s;
    const a = i.alpha ? "premultiplied" : "opaque";
    this.trackTimestamp = this.trackTimestamp && this.hasFeature(kx.TimestampQuery), this.context.configure({
      device: this.device,
      format: this.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
      alphaMode: a
    }), this.updateSize();
  }
  get coordinateSystem() {
    return wl;
  }
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  getContext() {
    return this.context;
  }
  _getDefaultRenderPassDescriptor() {
    let e = this.defaultRenderPassdescriptor;
    if (e === null) {
      const n = this.renderer;
      e = {
        colorAttachments: [{
          view: null
        }]
      }, (this.renderer.depth === !0 || this.renderer.stencil === !0) && (e.depthStencilAttachment = {
        view: this.textureUtils.getDepthBuffer(n.depth, n.stencil).createView()
      });
      const s = e.colorAttachments[0];
      this.renderer.samples > 0 ? s.view = this.colorBuffer.createView() : s.resolveTarget = void 0, this.defaultRenderPassdescriptor = e;
    }
    const i = e.colorAttachments[0];
    return this.renderer.samples > 0 ? i.resolveTarget = this.context.getCurrentTexture().createView() : i.view = this.context.getCurrentTexture().createView(), e;
  }
  _getRenderPassDescriptor(e) {
    const i = e.renderTarget, n = this.get(i);
    let s = n.descriptors;
    if (s === void 0 || n.width !== i.width || n.height !== i.height || n.activeMipmapLevel !== i.activeMipmapLevel || n.samples !== i.samples) {
      s = {}, n.descriptors = s;
      const l = () => {
        i.removeEventListener("dispose", l), this.delete(i);
      };
      i.addEventListener("dispose", l);
    }
    const a = e.getCacheKey();
    let o = s[a];
    if (o === void 0) {
      const l = e.textures, u = [];
      for (let c = 0; c < l.length; c++) {
        const h = this.get(l[c]), d = h.texture.createView({
          baseMipLevel: e.activeMipmapLevel,
          mipLevelCount: 1,
          baseArrayLayer: e.activeCubeFace,
          dimension: gn.TwoD
        });
        let p, f;
        h.msaaTexture !== void 0 ? (p = h.msaaTexture.createView(), f = d) : (p = d, f = void 0), u.push({
          view: p,
          resolveTarget: f,
          loadOp: Oi.Load,
          storeOp: Qi.Store
        });
      }
      if (o = {
        colorAttachments: u
      }, e.depth) {
        const c = {
          view: this.get(e.depthTexture).texture.createView()
        };
        o.depthStencilAttachment = c;
      }
      s[a] = o, n.width = i.width, n.height = i.height, n.samples = i.samples, n.activeMipmapLevel = i.activeMipmapLevel;
    }
    return o;
  }
  beginRender(e) {
    const i = this.get(e), n = this.device, s = e.occlusionQueryCount;
    let a;
    s > 0 && (i.currentOcclusionQuerySet && i.currentOcclusionQuerySet.destroy(), i.currentOcclusionQueryBuffer && i.currentOcclusionQueryBuffer.destroy(), i.currentOcclusionQuerySet = i.occlusionQuerySet, i.currentOcclusionQueryBuffer = i.occlusionQueryBuffer, i.currentOcclusionQueryObjects = i.occlusionQueryObjects, a = n.createQuerySet({ type: "occlusion", count: s }), i.occlusionQuerySet = a, i.occlusionQueryIndex = 0, i.occlusionQueryObjects = new Array(s), i.lastOcclusionObject = null);
    let o;
    e.textures === null ? o = this._getDefaultRenderPassDescriptor() : o = this._getRenderPassDescriptor(e), this.initTimestampQuery(e, o), o.occlusionQuerySet = a;
    const l = o.depthStencilAttachment;
    if (e.textures !== null) {
      const h = o.colorAttachments;
      for (let d = 0; d < h.length; d++) {
        const p = h[d];
        e.clearColor ? (p.clearValue = d === 0 ? e.clearColorValue : { r: 0, g: 0, b: 0, a: 1 }, p.loadOp = Oi.Clear, p.storeOp = Qi.Store) : (p.loadOp = Oi.Load, p.storeOp = Qi.Store);
      }
    } else {
      const h = o.colorAttachments[0];
      e.clearColor ? (h.clearValue = e.clearColorValue, h.loadOp = Oi.Clear, h.storeOp = Qi.Store) : (h.loadOp = Oi.Load, h.storeOp = Qi.Store);
    }
    e.depth && (e.clearDepth ? (l.depthClearValue = e.clearDepthValue, l.depthLoadOp = Oi.Clear, l.depthStoreOp = Qi.Store) : (l.depthLoadOp = Oi.Load, l.depthStoreOp = Qi.Store)), e.stencil && (e.clearStencil ? (l.stencilClearValue = e.clearStencilValue, l.stencilLoadOp = Oi.Clear, l.stencilStoreOp = Qi.Store) : (l.stencilLoadOp = Oi.Load, l.stencilStoreOp = Qi.Store));
    const u = n.createCommandEncoder({ label: "renderContext_" + e.id }), c = u.beginRenderPass(o);
    if (i.descriptor = o, i.encoder = u, i.currentPass = c, i.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, i.renderBundles = [], e.viewport && this.updateViewport(e), e.scissor) {
      const { x: h, y: d, width: p, height: f } = e.scissorValue;
      c.setScissorRect(h, d, p, f);
    }
  }
  finishRender(e) {
    const i = this.get(e), n = e.occlusionQueryCount;
    if (i.renderBundles.length > 0 && i.currentPass.executeBundles(i.renderBundles), n > i.occlusionQueryIndex && i.currentPass.endOcclusionQuery(), i.currentPass.end(), n > 0) {
      const s = n * 8;
      let a = this.occludedResolveCache.get(s);
      a === void 0 && (a = this.device.createBuffer(
        {
          size: s,
          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
        }
      ), this.occludedResolveCache.set(s, a));
      const o = this.device.createBuffer(
        {
          size: s,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        }
      );
      i.encoder.resolveQuerySet(i.occlusionQuerySet, 0, n, a, 0), i.encoder.copyBufferToBuffer(a, 0, o, 0, s), i.occlusionQueryBuffer = o, this.resolveOccludedAsync(e);
    }
    if (this.prepareTimestampBuffer(e, i.encoder), this.device.queue.submit([i.encoder.finish()]), e.textures !== null) {
      const s = e.textures;
      for (let a = 0; a < s.length; a++) {
        const o = s[a];
        o.generateMipmaps === !0 && this.textureUtils.generateMipmaps(o);
      }
    }
  }
  isOccluded(e, i) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(i);
  }
  async resolveOccludedAsync(e) {
    const i = this.get(e), { currentOcclusionQueryBuffer: n, currentOcclusionQueryObjects: s } = i;
    if (n && s) {
      const a = /* @__PURE__ */ new WeakSet();
      i.currentOcclusionQueryObjects = null, i.currentOcclusionQueryBuffer = null, await n.mapAsync(GPUMapMode.READ);
      const o = n.getMappedRange(), l = new BigUint64Array(o);
      for (let u = 0; u < s.length; u++)
        l[u] !== BigInt(0) && a.add(s[u]);
      n.destroy(), i.occluded = a;
    }
  }
  updateViewport(e) {
    const { currentPass: i } = this.get(e), { x: n, y: s, width: a, height: o, minDepth: l, maxDepth: u } = e.viewportValue;
    i.setViewport(n, s, a, o, l, u);
  }
  clear(e, i, n, s = null) {
    const a = this.device, o = this.renderer;
    let l = [], u, c, h, d;
    if (e) {
      const f = this.getClearColor();
      if (this.renderer.alpha === !0) {
        const m = f.a;
        c = { r: f.r * m, g: f.g * m, b: f.b * m, a: m };
      } else
        c = { r: f.r, g: f.g, b: f.b, a: f.a };
    }
    if (s === null) {
      h = o.depth, d = o.stencil;
      const f = this._getDefaultRenderPassDescriptor();
      if (e) {
        l = f.colorAttachments;
        const m = l[0];
        m.clearValue = c, m.loadOp = Oi.Clear, m.storeOp = Qi.Store;
      }
      (h || d) && (u = f.depthStencilAttachment);
    } else {
      if (h = s.depth, d = s.stencil, e)
        for (const f of s.textures) {
          const m = this.get(f), y = m.texture.createView();
          let v, g;
          m.msaaTexture !== void 0 ? (v = m.msaaTexture.createView(), g = y) : (v = y, g = void 0), l.push({
            view: v,
            resolveTarget: g,
            clearValue: c,
            loadOp: Oi.Clear,
            storeOp: Qi.Store
          });
        }
      (h || d) && (u = {
        view: this.get(s.depthTexture).texture.createView()
      });
    }
    h && (i ? (u.depthLoadOp = Oi.Clear, u.depthClearValue = o.getClearDepth(), u.depthStoreOp = Qi.Store) : (u.depthLoadOp = Oi.Load, u.depthStoreOp = Qi.Store)), d && (n ? (u.stencilLoadOp = Oi.Clear, u.stencilClearValue = o.getClearStencil(), u.stencilStoreOp = Qi.Store) : (u.stencilLoadOp = Oi.Load, u.stencilStoreOp = Qi.Store));
    const p = a.createCommandEncoder({});
    p.beginRenderPass({
      colorAttachments: l,
      depthStencilAttachment: u
    }).end(), a.queue.submit([p.finish()]);
  }
  // compute
  beginCompute(e) {
    const i = this.get(e), n = {};
    this.initTimestampQuery(e, n), i.cmdEncoderGPU = this.device.createCommandEncoder(), i.passEncoderGPU = i.cmdEncoderGPU.beginComputePass(n);
  }
  compute(e, i, n, s) {
    const { passEncoderGPU: a } = this.get(e), o = this.get(s).pipeline;
    a.setPipeline(o);
    for (let h = 0, d = n.length; h < d; h++) {
      const p = n[h], f = this.get(p);
      a.setBindGroup(h, f.group);
    }
    const l = this.device.limits.maxComputeWorkgroupsPerDimension, u = this.get(i);
    u.dispatchSize === void 0 && (u.dispatchSize = { x: 0, y: 1, z: 1 });
    const { dispatchSize: c } = u;
    i.dispatchCount > l ? (c.x = Math.min(i.dispatchCount, l), c.y = Math.ceil(i.dispatchCount / l)) : c.x = i.dispatchCount, a.dispatchWorkgroups(
      c.x,
      c.y,
      c.z
    );
  }
  finishCompute(e) {
    const i = this.get(e);
    i.passEncoderGPU.end(), this.prepareTimestampBuffer(e, i.cmdEncoderGPU), this.device.queue.submit([i.cmdEncoderGPU.finish()]);
  }
  async waitForGPU() {
    await this.device.queue.onSubmittedWorkDone();
  }
  // render object
  draw(e, i) {
    const { object: n, context: s, pipeline: a } = e, o = e.getBindings(), l = this.get(s), u = this.get(a).pipeline, c = l.currentSets, h = l.currentPass, d = e.getDrawParameters();
    if (d === null) return;
    c.pipeline !== u && (h.setPipeline(u), c.pipeline = u);
    const p = c.bindingGroups;
    for (let v = 0, g = o.length; v < g; v++) {
      const _ = o[v], x = this.get(_);
      p[_.index] !== _.id && (h.setBindGroup(_.index, x.group), p[_.index] = _.id);
    }
    const f = e.getIndex(), m = f !== null;
    if (m === !0 && c.index !== f) {
      const v = this.get(f).buffer, g = f.array instanceof Uint16Array ? Mc.Uint16 : Mc.Uint32;
      h.setIndexBuffer(v, g), c.index = f;
    }
    const y = e.getVertexBuffers();
    for (let v = 0, g = y.length; v < g; v++) {
      const _ = y[v];
      if (c.attributes[v] !== _) {
        const x = this.get(_).buffer;
        h.setVertexBuffer(v, x), c.attributes[v] = _;
      }
    }
    if (l.occlusionQuerySet !== void 0) {
      const v = l.lastOcclusionObject;
      v !== n && (v !== null && v.occlusionTest === !0 && (h.endOcclusionQuery(), l.occlusionQueryIndex++), n.occlusionTest === !0 && (h.beginOcclusionQuery(l.occlusionQueryIndex), l.occlusionQueryObjects[l.occlusionQueryIndex] = n), l.lastOcclusionObject = n);
    }
    if (n.isBatchedMesh === !0) {
      const v = n._multiDrawStarts, g = n._multiDrawCounts, _ = n._multiDrawCount, x = n._multiDrawInstances, b = m ? f.array.BYTES_PER_ELEMENT : 1;
      for (let T = 0; T < _; T++) {
        const S = x ? x[T] : 1, w = S > 1 ? 0 : T;
        h.drawIndexed(g[T], S, v[T] / b, 0, w);
      }
    } else if (m === !0) {
      const { vertexCount: v, instanceCount: g, firstVertex: _ } = d, x = e.getIndirect();
      if (x !== null) {
        const b = this.get(x).buffer;
        h.drawIndexedIndirect(b, 0);
      } else
        h.drawIndexed(v, g, _, 0, 0);
      i.update(n, v, g);
    } else {
      const { vertexCount: v, instanceCount: g, firstVertex: _ } = d, x = e.getIndirect();
      if (x !== null) {
        const b = this.get(x).buffer;
        h.drawIndirect(b, 0);
      } else
        h.draw(v, g, _, 0);
      i.update(n, v, g);
    }
  }
  // cache key
  needsRenderUpdate(e) {
    const i = this.get(e), { object: n, material: s } = e, a = this.utils, o = a.getSampleCountRenderContext(e.context), l = a.getCurrentColorSpace(e.context), u = a.getCurrentColorFormat(e.context), c = a.getCurrentDepthStencilFormat(e.context), h = a.getPrimitiveTopology(n, s);
    let d = !1;
    return (i.material !== s || i.materialVersion !== s.version || i.transparent !== s.transparent || i.blending !== s.blending || i.premultipliedAlpha !== s.premultipliedAlpha || i.blendSrc !== s.blendSrc || i.blendDst !== s.blendDst || i.blendEquation !== s.blendEquation || i.blendSrcAlpha !== s.blendSrcAlpha || i.blendDstAlpha !== s.blendDstAlpha || i.blendEquationAlpha !== s.blendEquationAlpha || i.colorWrite !== s.colorWrite || i.depthWrite !== s.depthWrite || i.depthTest !== s.depthTest || i.depthFunc !== s.depthFunc || i.stencilWrite !== s.stencilWrite || i.stencilFunc !== s.stencilFunc || i.stencilFail !== s.stencilFail || i.stencilZFail !== s.stencilZFail || i.stencilZPass !== s.stencilZPass || i.stencilFuncMask !== s.stencilFuncMask || i.stencilWriteMask !== s.stencilWriteMask || i.side !== s.side || i.alphaToCoverage !== s.alphaToCoverage || i.sampleCount !== o || i.colorSpace !== l || i.colorFormat !== u || i.depthStencilFormat !== c || i.primitiveTopology !== h || i.clippingContextCacheKey !== e.clippingContext.cacheKey) && (i.material = s, i.materialVersion = s.version, i.transparent = s.transparent, i.blending = s.blending, i.premultipliedAlpha = s.premultipliedAlpha, i.blendSrc = s.blendSrc, i.blendDst = s.blendDst, i.blendEquation = s.blendEquation, i.blendSrcAlpha = s.blendSrcAlpha, i.blendDstAlpha = s.blendDstAlpha, i.blendEquationAlpha = s.blendEquationAlpha, i.colorWrite = s.colorWrite, i.depthWrite = s.depthWrite, i.depthTest = s.depthTest, i.depthFunc = s.depthFunc, i.stencilWrite = s.stencilWrite, i.stencilFunc = s.stencilFunc, i.stencilFail = s.stencilFail, i.stencilZFail = s.stencilZFail, i.stencilZPass = s.stencilZPass, i.stencilFuncMask = s.stencilFuncMask, i.stencilWriteMask = s.stencilWriteMask, i.side = s.side, i.alphaToCoverage = s.alphaToCoverage, i.sampleCount = o, i.colorSpace = l, i.colorFormat = u, i.depthStencilFormat = c, i.primitiveTopology = h, i.clippingContextCacheKey = e.clippingContext.cacheKey, d = !0), d;
  }
  getRenderCacheKey(e) {
    const { object: i, material: n } = e, s = this.utils, a = e.context;
    return [
      n.transparent,
      n.blending,
      n.premultipliedAlpha,
      n.blendSrc,
      n.blendDst,
      n.blendEquation,
      n.blendSrcAlpha,
      n.blendDstAlpha,
      n.blendEquationAlpha,
      n.colorWrite,
      n.depthWrite,
      n.depthTest,
      n.depthFunc,
      n.stencilWrite,
      n.stencilFunc,
      n.stencilFail,
      n.stencilZFail,
      n.stencilZPass,
      n.stencilFuncMask,
      n.stencilWriteMask,
      n.side,
      s.getSampleCountRenderContext(a),
      s.getCurrentColorSpace(a),
      s.getCurrentColorFormat(a),
      s.getCurrentDepthStencilFormat(a),
      s.getPrimitiveTopology(i, n),
      e.getGeometryCacheKey(),
      e.clippingContext.cacheKey
    ].join();
  }
  // textures
  createSampler(e) {
    this.textureUtils.createSampler(e);
  }
  destroySampler(e) {
    this.textureUtils.destroySampler(e);
  }
  createDefaultTexture(e) {
    this.textureUtils.createDefaultTexture(e);
  }
  createTexture(e, i) {
    this.textureUtils.createTexture(e, i);
  }
  updateTexture(e, i) {
    this.textureUtils.updateTexture(e, i);
  }
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  destroyTexture(e) {
    this.textureUtils.destroyTexture(e);
  }
  copyTextureToBuffer(e, i, n, s, a, o) {
    return this.textureUtils.copyTextureToBuffer(e, i, n, s, a, o);
  }
  initTimestampQuery(e, i) {
    if (!this.trackTimestamp) return;
    const n = this.get(e);
    if (!n.timeStampQuerySet) {
      const s = this.device.createQuerySet({ type: "timestamp", count: 2 });
      Object.assign(i, {
        timestampWrites: {
          querySet: s,
          beginningOfPassWriteIndex: 0,
          // Write timestamp in index 0 when pass begins.
          endOfPassWriteIndex: 1
          // Write timestamp in index 1 when pass ends.
        }
      }), n.timeStampQuerySet = s;
    }
  }
  // timestamp utils
  prepareTimestampBuffer(e, i) {
    if (!this.trackTimestamp) return;
    const n = this.get(e), s = 2 * BigInt64Array.BYTES_PER_ELEMENT;
    n.currentTimestampQueryBuffers === void 0 && (n.currentTimestampQueryBuffers = {
      resolveBuffer: this.device.createBuffer({
        label: "timestamp resolve buffer",
        size: s,
        usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
      }),
      resultBuffer: this.device.createBuffer({
        label: "timestamp result buffer",
        size: s,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }),
      isMappingPending: !1
    });
    const { resolveBuffer: a, resultBuffer: o, isMappingPending: l } = n.currentTimestampQueryBuffers;
    l !== !0 && (i.resolveQuerySet(n.timeStampQuerySet, 0, 2, a, 0), i.copyBufferToBuffer(a, 0, o, 0, s));
  }
  async resolveTimestampAsync(e, i = "render") {
    if (!this.trackTimestamp) return;
    const n = this.get(e);
    if (n.currentTimestampQueryBuffers === void 0) return;
    const { resultBuffer: s, isMappingPending: a } = n.currentTimestampQueryBuffers;
    a !== !0 && (n.currentTimestampQueryBuffers.isMappingPending = !0, s.mapAsync(GPUMapMode.READ).then(() => {
      const o = new BigUint64Array(s.getMappedRange()), l = Number(o[1] - o[0]) / 1e6;
      this.renderer.info.updateTimestamp(i, l), s.unmap(), n.currentTimestampQueryBuffers.isMappingPending = !1;
    }));
  }
  // node builder
  createNodeBuilder(e, i) {
    return new xJ(e, i);
  }
  // program
  createProgram(e) {
    const i = this.get(e);
    i.module = {
      module: this.device.createShaderModule({ code: e.code, label: e.stage }),
      entryPoint: "main"
    };
  }
  destroyProgram(e) {
    this.delete(e);
  }
  // pipelines
  createRenderPipeline(e, i) {
    this.pipelineUtils.createRenderPipeline(e, i);
  }
  createComputePipeline(e, i) {
    this.pipelineUtils.createComputePipeline(e, i);
  }
  beginBundle(e) {
    const i = this.get(e);
    i._currentPass = i.currentPass, i._currentSets = i.currentSets, i.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, i.currentPass = this.pipelineUtils.createBundleEncoder(e);
  }
  finishBundle(e, i) {
    const n = this.get(e), s = n.currentPass.finish();
    this.get(i).bundleGPU = s, n.currentSets = n._currentSets, n.currentPass = n._currentPass;
  }
  addBundle(e, i) {
    this.get(e).renderBundles.push(this.get(i).bundleGPU);
  }
  // bindings
  createBindings(e) {
    this.bindingUtils.createBindings(e);
  }
  updateBindings(e) {
    this.bindingUtils.createBindings(e);
  }
  updateBinding(e) {
    this.bindingUtils.updateBinding(e);
  }
  // attributes
  createIndexAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createIndirectStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  // canvas
  updateSize() {
    this.colorBuffer = this.textureUtils.getColorBuffer(), this.defaultRenderPassdescriptor = null;
  }
  // utils public
  getMaxAnisotropy() {
    return 16;
  }
  hasFeature(e) {
    return this.device.features.has(e);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    let o = 0, l = 0, u = 0, c = 0, h = 0, d = 0, p = e.image.width, f = e.image.height;
    n !== null && (c = n.x, h = n.y, d = n.z || 0, p = n.width, f = n.height), s !== null && (o = s.x, l = s.y, u = s.z || 0);
    const m = this.device.createCommandEncoder({ label: "copyTextureToTexture_" + e.id + "_" + i.id }), y = this.get(e).texture, v = this.get(i).texture;
    m.copyTextureToTexture(
      {
        texture: y,
        mipLevel: a,
        origin: { x: c, y: h, z: d }
      },
      {
        texture: v,
        mipLevel: a,
        origin: { x: o, y: l, z: u }
      },
      [
        p,
        f,
        1
      ]
    ), this.device.queue.submit([m.finish()]);
  }
  copyFramebufferToTexture(e, i, n) {
    const s = this.get(i);
    let a = null;
    i.renderTarget ? e.isDepthTexture ? a = this.get(i.depthTexture).texture : a = this.get(i.textures[0]).texture : e.isDepthTexture ? a = this.textureUtils.getDepthBuffer(i.depth, i.stencil) : a = this.context.getCurrentTexture();
    const o = this.get(e).texture;
    if (a.format !== o.format) {
      console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.", a.format, o.format);
      return;
    }
    let l;
    if (s.currentPass ? (s.currentPass.end(), l = s.encoder) : l = this.device.createCommandEncoder({ label: "copyFramebufferToTexture_" + e.id }), l.copyTextureToTexture(
      {
        texture: a,
        origin: { x: n.x, y: n.y, z: 0 }
      },
      {
        texture: o
      },
      [
        n.z,
        n.w
      ]
    ), e.generateMipmaps && this.textureUtils.generateMipmaps(e), s.currentPass) {
      const { descriptor: u } = s;
      for (let c = 0; c < u.colorAttachments.length; c++)
        u.colorAttachments[c].loadOp = Oi.Load;
      i.depth && (u.depthStencilAttachment.depthLoadOp = Oi.Load), i.stencil && (u.depthStencilAttachment.stencilLoadOp = Oi.Load), s.currentPass = l.beginRenderPass(u), s.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
    } else
      this.device.queue.submit([l.finish()]);
  }
}
class RJ extends LP {
  constructor(e, i, n, s, a, o) {
    super(e, i, n, s, a, o), this.iesMap = null;
  }
  copy(e, i) {
    return super.copy(e, i), this.iesMap = e.iesMap, this;
  }
}
class NJ extends a3 {
  constructor() {
    super(), this.addMaterial(IY, RP), this.addMaterial(qI, x1), this.addMaterial(vK, CP), this.addMaterial(TK, NP), this.addMaterial(EY, Og), this.addMaterial(NY, IP), this.addMaterial(bY, PP), this.addMaterial(MK, OP), this.addMaterial(fY, v1), this.addMaterial(gY, DP), this.addMaterial(CK, MP), this.addMaterial(IK, wP), this.addMaterial(LK, AP), this.addLight(WZ, fW), this.addLight(_Q, gW), this.addLight(TQ, vW), this.addLight(n3, LP), this.addLight(wQ, yW), this.addLight(EQ, hW), this.addLight(MQ, xW), this.addLight(SQ, RJ), this.addToneMapping(gZ, G9), this.addToneMapping(yZ, H9), this.addToneMapping(vZ, W9), this.addToneMapping(xZ, q9), this.addToneMapping(wZ, X9), this.addToneMapping(EZ, $9);
  }
}
class PJ extends UQ {
  constructor(e = {}) {
    let i;
    e.forceWebGL ? i = bA : (i = CJ, e.getFallback = () => (console.warn("THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend."), new bA(e)));
    const n = new i(e);
    super(n, e), this.library = new NJ(), this.isWebGPURenderer = !0;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Pg
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Pg);
const _v = { type: "change" }, Z1 = { type: "start" }, Q1 = { type: "end" }, TA = 1e-6, Xt = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 }, Cf = new ke(), Wa = new ke(), IJ = new X(), Rf = new X(), Tv = new X(), wu = new bs(), SA = new X(), Nf = new X(), Sv = new X(), Pf = new X();
class OJ extends Ag {
  constructor(e, i = null) {
    super(e, i), this.enabled = !0, this.screen = { left: 0, top: 0, width: 0, height: 0 }, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = 0.3, this.noRotate = !1, this.noZoom = !1, this.noPan = !1, this.staticMoving = !1, this.dynamicDampingFactor = 0.2, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.keys = [
      "KeyA",
      "KeyS",
      "KeyD"
      /*D*/
    ], this.mouseButtons = { LEFT: tr.ROTATE, MIDDLE: tr.DOLLY, RIGHT: tr.PAN }, this.state = Xt.NONE, this.keyState = Xt.NONE, this.target = new X(), this._lastPosition = new X(), this._lastZoom = 1, this._touchZoomDistanceStart = 0, this._touchZoomDistanceEnd = 0, this._lastAngle = 0, this._eye = new X(), this._movePrev = new ke(), this._moveCurr = new ke(), this._lastAxis = new X(), this._zoomStart = new ke(), this._zoomEnd = new ke(), this._panStart = new ke(), this._panEnd = new ke(), this._pointers = [], this._pointerPositions = {}, this._onPointerMove = LJ.bind(this), this._onPointerDown = DJ.bind(this), this._onPointerUp = kJ.bind(this), this._onPointerCancel = UJ.bind(this), this._onContextMenu = HJ.bind(this), this._onMouseWheel = GJ.bind(this), this._onKeyDown = BJ.bind(this), this._onKeyUp = FJ.bind(this), this._onTouchStart = WJ.bind(this), this._onTouchMove = qJ.bind(this), this._onTouchEnd = XJ.bind(this), this._onMouseDown = zJ.bind(this), this._onMouseMove = jJ.bind(this), this._onMouseUp = VJ.bind(this), this._target0 = this.target.clone(), this._position0 = this.object.position.clone(), this._up0 = this.object.up.clone(), this._zoom0 = this.object.zoom, i !== null && (this.connect(), this.handleResize()), this.update();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown), window.addEventListener("keyup", this._onKeyUp), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  handleResize() {
    const e = this.domElement.getBoundingClientRect(), i = this.domElement.ownerDocument.documentElement;
    this.screen.left = e.left + window.pageXOffset - i.clientLeft, this.screen.top = e.top + window.pageYOffset - i.clientTop, this.screen.width = e.width, this.screen.height = e.height;
  }
  update() {
    this._eye.subVectors(this.object.position, this.target), this.noRotate || this._rotateCamera(), this.noZoom || this._zoomCamera(), this.noPan || this._panCamera(), this.object.position.addVectors(this.target, this._eye), this.object.isPerspectiveCamera ? (this._checkDistances(), this.object.lookAt(this.target), this._lastPosition.distanceToSquared(this.object.position) > TA && (this.dispatchEvent(_v), this._lastPosition.copy(this.object.position))) : this.object.isOrthographicCamera ? (this.object.lookAt(this.target), (this._lastPosition.distanceToSquared(this.object.position) > TA || this._lastZoom !== this.object.zoom) && (this.dispatchEvent(_v), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type.");
  }
  reset() {
    this.state = Xt.NONE, this.keyState = Xt.NONE, this.target.copy(this._target0), this.object.position.copy(this._position0), this.object.up.copy(this._up0), this.object.zoom = this._zoom0, this.object.updateProjectionMatrix(), this._eye.subVectors(this.object.position, this.target), this.object.lookAt(this.target), this.dispatchEvent(_v), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom;
  }
  _panCamera() {
    if (Wa.copy(this._panEnd).sub(this._panStart), Wa.lengthSq()) {
      if (this.object.isOrthographicCamera) {
        const e = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth, i = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;
        Wa.x *= e, Wa.y *= i;
      }
      Wa.multiplyScalar(this._eye.length() * this.panSpeed), Rf.copy(this._eye).cross(this.object.up).setLength(Wa.x), Rf.add(IJ.copy(this.object.up).setLength(Wa.y)), this.object.position.add(Rf), this.target.add(Rf), this.staticMoving ? this._panStart.copy(this._panEnd) : this._panStart.add(Wa.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
    }
  }
  _rotateCamera() {
    Pf.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
    let e = Pf.length();
    e ? (this._eye.copy(this.object.position).sub(this.target), SA.copy(this._eye).normalize(), Nf.copy(this.object.up).normalize(), Sv.crossVectors(Nf, SA).normalize(), Nf.setLength(this._moveCurr.y - this._movePrev.y), Sv.setLength(this._moveCurr.x - this._movePrev.x), Pf.copy(Nf.add(Sv)), Tv.crossVectors(Pf, this._eye).normalize(), e *= this.rotateSpeed, wu.setFromAxisAngle(Tv, e), this._eye.applyQuaternion(wu), this.object.up.applyQuaternion(wu), this._lastAxis.copy(Tv), this._lastAngle = e) : !this.staticMoving && this._lastAngle && (this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor), this._eye.copy(this.object.position).sub(this.target), wu.setFromAxisAngle(this._lastAxis, this._lastAngle), this._eye.applyQuaternion(wu), this.object.up.applyQuaternion(wu)), this._movePrev.copy(this._moveCurr);
  }
  _zoomCamera() {
    let e;
    this.state === Xt.TOUCH_ZOOM_PAN ? (e = this._touchZoomDistanceStart / this._touchZoomDistanceEnd, this._touchZoomDistanceStart = this._touchZoomDistanceEnd, this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = Ub.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (e = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed, e !== 1 && e > 0 && (this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = Ub.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")), this.staticMoving ? this._zoomStart.copy(this._zoomEnd) : this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor);
  }
  _getMouseOnScreen(e, i) {
    return Cf.set(
      (e - this.screen.left) / this.screen.width,
      (i - this.screen.top) / this.screen.height
    ), Cf;
  }
  _getMouseOnCircle(e, i) {
    return Cf.set(
      (e - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5),
      (this.screen.height + 2 * (this.screen.top - i)) / this.screen.width
      // screen.width intentional
    ), Cf;
  }
  _addPointer(e) {
    this._pointers.push(e);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i].pointerId == e.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
  }
  _trackPointer(e) {
    let i = this._pointerPositions[e.pointerId];
    i === void 0 && (i = new ke(), this._pointerPositions[e.pointerId] = i), i.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const i = e.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[i.pointerId];
  }
  _checkDistances() {
    (!this.noZoom || !this.noPan) && (this._eye.lengthSq() > this.maxDistance * this.maxDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance)), this._zoomStart.copy(this._zoomEnd)), this._eye.lengthSq() < this.minDistance * this.minDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance)), this._zoomStart.copy(this._zoomEnd)));
  }
}
function DJ(r) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(r.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), this._addPointer(r), r.pointerType === "touch" ? this._onTouchStart(r) : this._onMouseDown(r));
}
function LJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchMove(r) : this._onMouseMove(r));
}
function kJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchEnd(r) : this._onMouseUp(), this._removePointer(r), this._pointers.length === 0 && (this.domElement.releasePointerCapture(r.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp)));
}
function UJ(r) {
  this._removePointer(r);
}
function FJ() {
  this.enabled !== !1 && (this.keyState = Xt.NONE, window.addEventListener("keydown", this._onKeyDown));
}
function BJ(r) {
  this.enabled !== !1 && (window.removeEventListener("keydown", this._onKeyDown), this.keyState === Xt.NONE && (r.code === this.keys[Xt.ROTATE] && !this.noRotate ? this.keyState = Xt.ROTATE : r.code === this.keys[Xt.ZOOM] && !this.noZoom ? this.keyState = Xt.ZOOM : r.code === this.keys[Xt.PAN] && !this.noPan && (this.keyState = Xt.PAN)));
}
function zJ(r) {
  let e;
  switch (r.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case tr.DOLLY:
      this.state = Xt.ZOOM;
      break;
    case tr.ROTATE:
      this.state = Xt.ROTATE;
      break;
    case tr.PAN:
      this.state = Xt.PAN;
      break;
    default:
      this.state = Xt.NONE;
  }
  const i = this.keyState !== Xt.NONE ? this.keyState : this.state;
  i === Xt.ROTATE && !this.noRotate ? (this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY)), this._movePrev.copy(this._moveCurr)) : i === Xt.ZOOM && !this.noZoom ? (this._zoomStart.copy(this._getMouseOnScreen(r.pageX, r.pageY)), this._zoomEnd.copy(this._zoomStart)) : i === Xt.PAN && !this.noPan && (this._panStart.copy(this._getMouseOnScreen(r.pageX, r.pageY)), this._panEnd.copy(this._panStart)), this.dispatchEvent(Z1);
}
function jJ(r) {
  const e = this.keyState !== Xt.NONE ? this.keyState : this.state;
  e === Xt.ROTATE && !this.noRotate ? (this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY))) : e === Xt.ZOOM && !this.noZoom ? this._zoomEnd.copy(this._getMouseOnScreen(r.pageX, r.pageY)) : e === Xt.PAN && !this.noPan && this._panEnd.copy(this._getMouseOnScreen(r.pageX, r.pageY));
}
function VJ() {
  this.state = Xt.NONE, this.dispatchEvent(Q1);
}
function GJ(r) {
  if (this.enabled !== !1 && this.noZoom !== !0) {
    switch (r.preventDefault(), r.deltaMode) {
      case 2:
        this._zoomStart.y -= r.deltaY * 0.025;
        break;
      case 1:
        this._zoomStart.y -= r.deltaY * 0.01;
        break;
      default:
        this._zoomStart.y -= r.deltaY * 25e-5;
        break;
    }
    this.dispatchEvent(Z1), this.dispatchEvent(Q1);
  }
}
function HJ(r) {
  this.enabled !== !1 && r.preventDefault();
}
function WJ(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      this.state = Xt.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY)), this._movePrev.copy(this._moveCurr);
      break;
    default:
      this.state = Xt.TOUCH_ZOOM_PAN;
      const e = this._pointers[0].pageX - this._pointers[1].pageX, i = this._pointers[0].pageY - this._pointers[1].pageY;
      this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(e * e + i * i);
      const n = (this._pointers[0].pageX + this._pointers[1].pageX) / 2, s = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;
      this._panStart.copy(this._getMouseOnScreen(n, s)), this._panEnd.copy(this._panStart);
      break;
  }
  this.dispatchEvent(Z1);
}
function qJ(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY));
      break;
    default:
      const e = this._getSecondPointerPosition(r), i = r.pageX - e.x, n = r.pageY - e.y;
      this._touchZoomDistanceEnd = Math.sqrt(i * i + n * n);
      const s = (r.pageX + e.x) / 2, a = (r.pageY + e.y) / 2;
      this._panEnd.copy(this._getMouseOnScreen(s, a));
      break;
  }
}
function XJ(r) {
  switch (this._pointers.length) {
    case 0:
      this.state = Xt.NONE;
      break;
    case 1:
      this.state = Xt.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY)), this._movePrev.copy(this._moveCurr);
      break;
    case 2:
      this.state = Xt.TOUCH_ZOOM_PAN;
      for (let e = 0; e < this._pointers.length; e++)
        if (this._pointers[e].pointerId !== r.pointerId) {
          const i = this._pointerPositions[this._pointers[e].pointerId];
          this._moveCurr.copy(this._getMouseOnCircle(i.x, i.y)), this._movePrev.copy(this._moveCurr);
          break;
        }
      break;
  }
  this.dispatchEvent(Q1);
}
const wA = { type: "change" }, J1 = { type: "start" }, m3 = { type: "end" }, If = new Sg(), EA = new qs(), $J = Math.cos(70 * Ub.DEG2RAD), Vi = new X(), Ir = 2 * Math.PI, ti = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
}, wv = 1e-6;
class YJ extends Ag {
  constructor(e, i = null) {
    super(e, i), this.state = ti.NONE, this.enabled = !0, this.target = new X(), this.cursor = new X(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: tr.ROTATE, MIDDLE: tr.DOLLY, RIGHT: tr.PAN }, this.touches = { ONE: ia.ROTATE, TWO: ia.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new X(), this._lastQuaternion = new bs(), this._lastTargetPosition = new X(), this._quat = new bs().setFromUnitVectors(e.up, new X(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new kw(), this._sphericalDelta = new kw(), this._scale = 1, this._panOffset = new X(), this._rotateStart = new ke(), this._rotateEnd = new ke(), this._rotateDelta = new ke(), this._panStart = new ke(), this._panEnd = new ke(), this._panDelta = new ke(), this._dollyStart = new ke(), this._dollyEnd = new ke(), this._dollyDelta = new ke(), this._dollyDirection = new X(), this._mouse = new ke(), this._performCursorZoom = !1, this._pointers = [], this._pointerPositions = {}, this._controlActive = !1, this._onPointerMove = ZJ.bind(this), this._onPointerDown = KJ.bind(this), this._onPointerUp = QJ.bind(this), this._onContextMenu = see.bind(this), this._onMouseWheel = tee.bind(this), this._onKeyDown = iee.bind(this), this._onTouchStart = ree.bind(this), this._onTouchMove = nee.bind(this), this._onMouseDown = JJ.bind(this), this._onMouseMove = eee.bind(this), this._interceptControlDown = aee.bind(this), this._interceptControlUp = oee.bind(this), this.domElement !== null && this.connect(), this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, { passive: !0, capture: !0 }), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, { capture: !0 }), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
  }
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
  }
  saveState() {
    this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(wA), this.update(), this.state = ti.NONE;
  }
  update(e = null) {
    const i = this.object.position;
    Vi.copy(i).sub(this.target), Vi.applyQuaternion(this._quat), this._spherical.setFromVector3(Vi), this.autoRotate && this.state === ti.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
    let n = this.minAzimuthAngle, s = this.maxAzimuthAngle;
    isFinite(n) && isFinite(s) && (n < -Math.PI ? n += Ir : n > Math.PI && (n -= Ir), s < -Math.PI ? s += Ir : s > Math.PI && (s -= Ir), n <= s ? this._spherical.theta = Math.max(n, Math.min(s, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (n + s) / 2 ? Math.max(n, this._spherical.theta) : Math.min(s, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
    let a = !1;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const o = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), a = o != this._spherical.radius;
    }
    if (Vi.setFromSpherical(this._spherical), Vi.applyQuaternion(this._quatInverse), i.copy(this.target).add(Vi), this.object.lookAt(this.target), this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
      let o = null;
      if (this.object.isPerspectiveCamera) {
        const l = Vi.length();
        o = this._clampDistance(l * this._scale);
        const u = l - o;
        this.object.position.addScaledVector(this._dollyDirection, u), this.object.updateMatrixWorld(), a = !!u;
      } else if (this.object.isOrthographicCamera) {
        const l = new X(this._mouse.x, this._mouse.y, 0);
        l.unproject(this.object);
        const u = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), a = u !== this.object.zoom;
        const c = new X(this._mouse.x, this._mouse.y, 0);
        c.unproject(this.object), this.object.position.sub(c).add(l), this.object.updateMatrixWorld(), o = Vi.length();
      } else
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = !1;
      o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : (If.origin.copy(this.object.position), If.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(If.direction)) < $J ? this.object.lookAt(this.target) : (EA.setFromNormalAndCoplanarPoint(this.object.up, this.target), If.intersectPlane(EA, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const o = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), o !== this.object.zoom && (this.object.updateProjectionMatrix(), a = !0);
    }
    return this._scale = 1, this._performCursorZoom = !1, a || this._lastPosition.distanceToSquared(this.object.position) > wv || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > wv || this._lastTargetPosition.distanceToSquared(this.target) > wv ? (this.dispatchEvent(wA), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), !0) : !1;
  }
  _getAutoRotationAngle(e) {
    return e !== null ? Ir / 60 * this.autoRotateSpeed * e : Ir / 60 / 60 * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const i = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * i);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, i) {
    Vi.setFromMatrixColumn(i, 0), Vi.multiplyScalar(-e), this._panOffset.add(Vi);
  }
  _panUp(e, i) {
    this.screenSpacePanning === !0 ? Vi.setFromMatrixColumn(i, 1) : (Vi.setFromMatrixColumn(i, 0), Vi.crossVectors(this.object.up, Vi)), Vi.multiplyScalar(e), this._panOffset.add(Vi);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(e, i) {
    const n = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const s = this.object.position;
      Vi.copy(s).sub(this.target);
      let a = Vi.length();
      a *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * a / n.clientHeight, this.object.matrix), this._panUp(2 * i * a / n.clientHeight, this.object.matrix);
    } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / n.clientWidth, this.object.matrix), this._panUp(i * (this.object.top - this.object.bottom) / this.object.zoom / n.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = !1);
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _updateZoomParameters(e, i) {
    if (!this.zoomToCursor)
      return;
    this._performCursorZoom = !0;
    const n = this.domElement.getBoundingClientRect(), s = e - n.left, a = i - n.top, o = n.width, l = n.height;
    this._mouse.x = s / o * 2 - 1, this._mouse.y = -(a / l) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const i = this.domElement;
    this._rotateLeft(Ir * this._rotateDelta.x / i.clientHeight), this._rotateUp(Ir * this._rotateDelta.y / i.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
  }
  _handleKeyDown(e) {
    let i = !1;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(Ir * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, this.keyPanSpeed), i = !0;
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(-Ir * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, -this.keyPanSpeed), i = !0;
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(Ir * this.rotateSpeed / this.domElement.clientHeight) : this._pan(this.keyPanSpeed, 0), i = !0;
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(-Ir * this.rotateSpeed / this.domElement.clientHeight) : this._pan(-this.keyPanSpeed, 0), i = !0;
        break;
    }
    i && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1)
      this._rotateStart.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._rotateStart.set(n, s);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1)
      this._panStart.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._panStart.set(n, s);
    }
  }
  _handleTouchStartDolly(e) {
    const i = this._getSecondPointerPosition(e), n = e.pageX - i.x, s = e.pageY - i.y, a = Math.sqrt(n * n + s * s);
    this._dollyStart.set(0, a);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1)
      this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const n = this._getSecondPointerPosition(e), s = 0.5 * (e.pageX + n.x), a = 0.5 * (e.pageY + n.y);
      this._rotateEnd.set(s, a);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const i = this.domElement;
    this._rotateLeft(Ir * this._rotateDelta.x / i.clientHeight), this._rotateUp(Ir * this._rotateDelta.y / i.clientHeight), this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1)
      this._panEnd.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._panEnd.set(n, s);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const i = this._getSecondPointerPosition(e), n = e.pageX - i.x, s = e.pageY - i.y, a = Math.sqrt(n * n + s * s);
    this._dollyEnd.set(0, a), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
    const o = (e.pageX + i.x) * 0.5, l = (e.pageY + i.y) * 0.5;
    this._updateZoomParameters(o, l);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
  }
  // pointers
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i] == e.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
  }
  _isTrackingPointer(e) {
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i] == e.pointerId) return !0;
    return !1;
  }
  _trackPointer(e) {
    let i = this._pointerPositions[e.pointerId];
    i === void 0 && (i = new ke(), this._pointerPositions[e.pointerId] = i), i.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const i = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[i];
  }
  //
  _customWheelEvent(e) {
    const i = e.deltaMode, n = {
      clientX: e.clientX,
      clientY: e.clientY,
      deltaY: e.deltaY
    };
    switch (i) {
      case 1:
        n.deltaY *= 16;
        break;
      case 2:
        n.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (n.deltaY *= 10), n;
  }
}
function KJ(r) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(r.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(r) && (this._addPointer(r), r.pointerType === "touch" ? this._onTouchStart(r) : this._onMouseDown(r)));
}
function ZJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchMove(r) : this._onMouseMove(r));
}
function QJ(r) {
  switch (this._removePointer(r), this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(r.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(m3), this.state = ti.NONE;
      break;
    case 1:
      const e = this._pointers[0], i = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: i.x, pageY: i.y });
      break;
  }
}
function JJ(r) {
  let e;
  switch (r.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case tr.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseDownDolly(r), this.state = ti.DOLLY;
      break;
    case tr.ROTATE:
      if (r.ctrlKey || r.metaKey || r.shiftKey) {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(r), this.state = ti.PAN;
      } else {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(r), this.state = ti.ROTATE;
      }
      break;
    case tr.PAN:
      if (r.ctrlKey || r.metaKey || r.shiftKey) {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(r), this.state = ti.ROTATE;
      } else {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(r), this.state = ti.PAN;
      }
      break;
    default:
      this.state = ti.NONE;
  }
  this.state !== ti.NONE && this.dispatchEvent(J1);
}
function eee(r) {
  switch (this.state) {
    case ti.ROTATE:
      if (this.enableRotate === !1) return;
      this._handleMouseMoveRotate(r);
      break;
    case ti.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseMoveDolly(r);
      break;
    case ti.PAN:
      if (this.enablePan === !1) return;
      this._handleMouseMovePan(r);
      break;
  }
}
function tee(r) {
  this.enabled === !1 || this.enableZoom === !1 || this.state !== ti.NONE || (r.preventDefault(), this.dispatchEvent(J1), this._handleMouseWheel(this._customWheelEvent(r)), this.dispatchEvent(m3));
}
function iee(r) {
  this.enabled === !1 || this.enablePan === !1 || this._handleKeyDown(r);
}
function ree(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case ia.ROTATE:
          if (this.enableRotate === !1) return;
          this._handleTouchStartRotate(r), this.state = ti.TOUCH_ROTATE;
          break;
        case ia.PAN:
          if (this.enablePan === !1) return;
          this._handleTouchStartPan(r), this.state = ti.TOUCH_PAN;
          break;
        default:
          this.state = ti.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case ia.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1) return;
          this._handleTouchStartDollyPan(r), this.state = ti.TOUCH_DOLLY_PAN;
          break;
        case ia.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1) return;
          this._handleTouchStartDollyRotate(r), this.state = ti.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = ti.NONE;
      }
      break;
    default:
      this.state = ti.NONE;
  }
  this.state !== ti.NONE && this.dispatchEvent(J1);
}
function nee(r) {
  switch (this._trackPointer(r), this.state) {
    case ti.TOUCH_ROTATE:
      if (this.enableRotate === !1) return;
      this._handleTouchMoveRotate(r), this.update();
      break;
    case ti.TOUCH_PAN:
      if (this.enablePan === !1) return;
      this._handleTouchMovePan(r), this.update();
      break;
    case ti.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1) return;
      this._handleTouchMoveDollyPan(r), this.update();
      break;
    case ti.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1) return;
      this._handleTouchMoveDollyRotate(r), this.update();
      break;
    default:
      this.state = ti.NONE;
  }
}
function see(r) {
  this.enabled !== !1 && r.preventDefault();
}
function aee(r) {
  r.key === "Control" && (this._controlActive = !0, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
function oee(r) {
  r.key === "Control" && (this._controlActive = !1, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
const lee = { type: "change" }, MA = 1e-6, AA = new bs();
class uee extends Ag {
  constructor(e, i = null) {
    super(e, i), this.movementSpeed = 1, this.rollSpeed = 5e-3, this.dragToLook = !1, this.autoForward = !1, this._moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 }, this._moveVector = new X(0, 0, 0), this._rotationVector = new X(0, 0, 0), this._lastQuaternion = new bs(), this._lastPosition = new X(), this._status = 0, this._onKeyDown = cee.bind(this), this._onKeyUp = hee.bind(this), this._onPointerMove = pee.bind(this), this._onPointerDown = dee.bind(this), this._onPointerUp = fee.bind(this), this._onPointerCancel = mee.bind(this), this._onContextMenu = gee.bind(this), i !== null && this.connect();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown), window.addEventListener("keyup", this._onKeyUp), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("contextmenu", this._onContextMenu);
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("contextmenu", this._onContextMenu);
  }
  dispose() {
    this.disconnect();
  }
  update(e) {
    if (this.enabled === !1) return;
    const i = this.object, n = e * this.movementSpeed, s = e * this.rollSpeed;
    i.translateX(this._moveVector.x * n), i.translateY(this._moveVector.y * n), i.translateZ(this._moveVector.z * n), AA.set(this._rotationVector.x * s, this._rotationVector.y * s, this._rotationVector.z * s, 1).normalize(), i.quaternion.multiply(AA), (this._lastPosition.distanceToSquared(i.position) > MA || 8 * (1 - this._lastQuaternion.dot(i.quaternion)) > MA) && (this.dispatchEvent(lee), this._lastQuaternion.copy(i.quaternion), this._lastPosition.copy(i.position));
  }
  // private
  _updateMovementVector() {
    const e = this._moveState.forward || this.autoForward && !this._moveState.back ? 1 : 0;
    this._moveVector.x = -this._moveState.left + this._moveState.right, this._moveVector.y = -this._moveState.down + this._moveState.up, this._moveVector.z = -e + this._moveState.back;
  }
  _updateRotationVector() {
    this._rotationVector.x = -this._moveState.pitchDown + this._moveState.pitchUp, this._rotationVector.y = -this._moveState.yawRight + this._moveState.yawLeft, this._rotationVector.z = -this._moveState.rollRight + this._moveState.rollLeft;
  }
  _getContainerDimensions() {
    return this.domElement != document ? {
      size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
      offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
    } : {
      size: [window.innerWidth, window.innerHeight],
      offset: [0, 0]
    };
  }
}
function cee(r) {
  if (!(r.altKey || this.enabled === !1)) {
    switch (r.code) {
      case "ShiftLeft":
      case "ShiftRight":
        this.movementSpeedMultiplier = 0.1;
        break;
      case "KeyW":
        this._moveState.forward = 1;
        break;
      case "KeyS":
        this._moveState.back = 1;
        break;
      case "KeyA":
        this._moveState.left = 1;
        break;
      case "KeyD":
        this._moveState.right = 1;
        break;
      case "KeyR":
        this._moveState.up = 1;
        break;
      case "KeyF":
        this._moveState.down = 1;
        break;
      case "ArrowUp":
        this._moveState.pitchUp = 1;
        break;
      case "ArrowDown":
        this._moveState.pitchDown = 1;
        break;
      case "ArrowLeft":
        this._moveState.yawLeft = 1;
        break;
      case "ArrowRight":
        this._moveState.yawRight = 1;
        break;
      case "KeyQ":
        this._moveState.rollLeft = 1;
        break;
      case "KeyE":
        this._moveState.rollRight = 1;
        break;
    }
    this._updateMovementVector(), this._updateRotationVector();
  }
}
function hee(r) {
  if (this.enabled !== !1) {
    switch (r.code) {
      case "ShiftLeft":
      case "ShiftRight":
        this.movementSpeedMultiplier = 1;
        break;
      case "KeyW":
        this._moveState.forward = 0;
        break;
      case "KeyS":
        this._moveState.back = 0;
        break;
      case "KeyA":
        this._moveState.left = 0;
        break;
      case "KeyD":
        this._moveState.right = 0;
        break;
      case "KeyR":
        this._moveState.up = 0;
        break;
      case "KeyF":
        this._moveState.down = 0;
        break;
      case "ArrowUp":
        this._moveState.pitchUp = 0;
        break;
      case "ArrowDown":
        this._moveState.pitchDown = 0;
        break;
      case "ArrowLeft":
        this._moveState.yawLeft = 0;
        break;
      case "ArrowRight":
        this._moveState.yawRight = 0;
        break;
      case "KeyQ":
        this._moveState.rollLeft = 0;
        break;
      case "KeyE":
        this._moveState.rollRight = 0;
        break;
    }
    this._updateMovementVector(), this._updateRotationVector();
  }
}
function dee(r) {
  if (this.enabled !== !1)
    if (this.dragToLook)
      this._status++;
    else {
      switch (r.button) {
        case 0:
          this._moveState.forward = 1;
          break;
        case 2:
          this._moveState.back = 1;
          break;
      }
      this._updateMovementVector();
    }
}
function pee(r) {
  if (this.enabled !== !1 && (!this.dragToLook || this._status > 0)) {
    const e = this._getContainerDimensions(), i = e.size[0] / 2, n = e.size[1] / 2;
    this._moveState.yawLeft = -(r.pageX - e.offset[0] - i) / i, this._moveState.pitchDown = (r.pageY - e.offset[1] - n) / n, this._updateRotationVector();
  }
}
function fee(r) {
  if (this.enabled !== !1) {
    if (this.dragToLook)
      this._status--, this._moveState.yawLeft = this._moveState.pitchDown = 0;
    else {
      switch (r.button) {
        case 0:
          this._moveState.forward = 0;
          break;
        case 2:
          this._moveState.back = 0;
          break;
      }
      this._updateMovementVector();
    }
    this._updateRotationVector();
  }
}
function mee() {
  this.enabled !== !1 && (this.dragToLook ? (this._status = 0, this._moveState.yawLeft = this._moveState.pitchDown = 0) : (this._moveState.forward = 0, this._moveState.back = 0, this._updateMovementVector()), this._updateRotationVector());
}
function gee(r) {
  this.enabled !== !1 && r.preventDefault();
}
const yee = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class qg {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const vee = new F_(-1, 1, 1, -1, 0, 1);
class bee extends un {
  constructor() {
    super(), this.setAttribute("position", new Ri([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Ri([0, 2, 0, 0, 2, 0], 2));
  }
}
const xee = new bee();
class _ee {
  constructor(e) {
    this._mesh = new Lr(xee, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, vee);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class Tee extends qg {
  constructor(e, i) {
    super(), this.textureID = i !== void 0 ? i : "tDiffuse", e instanceof xs ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = mR.clone(e.uniforms), this.material = new xs({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new _ee(this.material);
  }
  render(e, i, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(i), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class CA extends qg {
  constructor(e, i) {
    super(), this.scene = e, this.camera = i, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, i, n) {
    const s = e.getContext(), a = e.state;
    a.buffers.color.setMask(!1), a.buffers.depth.setMask(!1), a.buffers.color.setLocked(!0), a.buffers.depth.setLocked(!0);
    let o, l;
    this.inverse ? (o = 0, l = 1) : (o = 1, l = 0), a.buffers.stencil.setTest(!0), a.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), a.buffers.stencil.setFunc(s.ALWAYS, o, 4294967295), a.buffers.stencil.setClear(l), a.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), a.buffers.color.setLocked(!1), a.buffers.depth.setLocked(!1), a.buffers.color.setMask(!0), a.buffers.depth.setMask(!0), a.buffers.stencil.setLocked(!1), a.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), a.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), a.buffers.stencil.setLocked(!0);
  }
}
class See extends qg {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class wee {
  constructor(e, i) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), i === void 0) {
      const n = e.getSize(new ke());
      this._width = n.width, this._height = n.height, i = new go(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: Lc }), i.texture.name = "EffectComposer.rt1";
    } else
      this._width = i.width, this._height = i.height;
    this.renderTarget1 = i, this.renderTarget2 = i.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new Tee(yee), this.copyPass.material.blending = la, this.clock = new IR();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, i) {
    this.passes.splice(i, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const i = this.passes.indexOf(e);
    i !== -1 && this.passes.splice(i, 1);
  }
  isLastEnabledPass(e) {
    for (let i = e + 1; i < this.passes.length; i++)
      if (this.passes[i].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const i = this.renderer.getRenderTarget();
    let n = !1;
    for (let s = 0, a = this.passes.length; s < a; s++) {
      const o = this.passes[s];
      if (o.enabled !== !1) {
        if (o.renderToScreen = this.renderToScreen && this.isLastEnabledPass(s), o.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), o.needsSwap) {
          if (n) {
            const l = this.renderer.getContext(), u = this.renderer.state.buffers.stencil;
            u.setFunc(l.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), u.setFunc(l.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        CA !== void 0 && (o instanceof CA ? n = !0 : o instanceof See && (n = !1));
      }
    }
    this.renderer.setRenderTarget(i);
  }
  reset(e) {
    if (e === void 0) {
      const i = this.renderer.getSize(new ke());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = i.width, this._height = i.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, i) {
    this._width = e, this._height = i;
    const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, s), this.renderTarget2.setSize(n, s);
    for (let a = 0; a < this.passes.length; a++)
      this.passes[a].setSize(n, s);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class Eee extends qg {
  constructor(e, i, n = null, s = null, a = null) {
    super(), this.scene = e, this.camera = i, this.overrideMaterial = n, this.clearColor = s, this.clearAlpha = a, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Ut();
  }
  render(e, i, n) {
    const s = e.autoClear;
    e.autoClear = !1;
    let a, o;
    this.overrideMaterial !== null && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (a = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(a), this.overrideMaterial !== null && (this.scene.overrideMaterial = o), e.autoClear = s;
  }
}
function Hr() {
  return Hr = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i) ({}).hasOwnProperty.call(i, n) && (r[n] = i[n]);
    }
    return r;
  }, Hr.apply(null, arguments);
}
function Mee(r) {
  if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function Rd(r, e) {
  return Rd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Rd(r, e);
}
function Aee(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Rd(r, e);
}
function Bx(r) {
  return Bx = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Bx(r);
}
function Cee(r) {
  try {
    return Function.toString.call(r).indexOf("[native code]") !== -1;
  } catch {
    return typeof r == "function";
  }
}
function g3() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (g3 = function() {
    return !!r;
  })();
}
function Ree(r, e, i) {
  if (g3()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return i && Rd(s, i.prototype), s;
}
function zx(r) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return zx = function(i) {
    if (i === null || !Cee(i)) return i;
    if (typeof i != "function") throw new TypeError("Super expression must either be null or a function");
    if (e !== void 0) {
      if (e.has(i)) return e.get(i);
      e.set(i, n);
    }
    function n() {
      return Ree(i, arguments, Bx(this).constructor);
    }
    return n.prototype = Object.create(i.prototype, {
      constructor: {
        value: n,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Rd(n, i);
  }, zx(r);
}
var Nee = {
  1: `Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).

`,
  2: `Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).

`,
  3: `Passed an incorrect argument to a color function, please pass a string representation of a color.

`,
  4: `Couldn't generate valid rgb string from %s, it returned %s.

`,
  5: `Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.

`,
  6: `Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).

`,
  7: `Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).

`,
  8: `Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.

`,
  9: `Please provide a number of steps to the modularScale helper.

`,
  10: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
  11: `Invalid value passed as base to modularScale, expected number or em string but got "%s"

`,
  12: `Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.

`,
  13: `Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.

`,
  14: `Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.

`,
  15: `Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.

`,
  16: `You must provide a template to this method.

`,
  17: `You passed an unsupported selector state to this method.

`,
  18: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
  19: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
  20: `expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
  21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  23: `fontFace expects a name of a font-family.

`,
  24: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
  25: `fontFace expects localFonts to be an array.

`,
  26: `fontFace expects fileFormats to be an array.

`,
  27: `radialGradient requries at least 2 color-stops to properly render.

`,
  28: `Please supply a filename to retinaImage() as the first argument.

`,
  29: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
  30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  31: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation

`,
  32: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])
To pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')

`,
  33: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation

`,
  34: `borderRadius expects a radius value as a string or number as the second argument.

`,
  35: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
  36: `Property must be a string value.

`,
  37: `Syntax Error at %s.

`,
  38: `Formula contains a function that needs parentheses at %s.

`,
  39: `Formula is missing closing parenthesis at %s.

`,
  40: `Formula has too many closing parentheses at %s.

`,
  41: `All values in a formula must have the same unit or be unitless.

`,
  42: `Please provide a number of steps to the modularScale helper.

`,
  43: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
  44: `Invalid value passed as base to modularScale, expected number or em/rem string but got %s.

`,
  45: `Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.

`,
  46: `Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.

`,
  47: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
  48: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
  49: `Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
  50: `Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.

`,
  51: `Expects the first argument object to have the properties prop, fromSize, and toSize.

`,
  52: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
  53: `fontFace expects localFonts to be an array.

`,
  54: `fontFace expects fileFormats to be an array.

`,
  55: `fontFace expects a name of a font-family.

`,
  56: `linearGradient requries at least 2 color-stops to properly render.

`,
  57: `radialGradient requries at least 2 color-stops to properly render.

`,
  58: `Please supply a filename to retinaImage() as the first argument.

`,
  59: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
  60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  61: `Property must be a string value.

`,
  62: `borderRadius expects a radius value as a string or number as the second argument.

`,
  63: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
  64: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.

`,
  65: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').

`,
  66: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.

`,
  67: `You must provide a template to this method.

`,
  68: `You passed an unsupported selector state to this method.

`,
  69: `Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.

`,
  70: `Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.

`,
  71: `Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.

`,
  72: `Passed invalid base value %s to %s(), please pass a value like "12px" or 12.

`,
  73: `Please provide a valid CSS variable.

`,
  74: `CSS variable not found and no default was provided.

`,
  75: `important requires a valid style object, got a %s instead.

`,
  76: `fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.

`,
  77: `remToPx expects a value in "rem" but you provided it in "%s".

`,
  78: `base must be set in "px" or "%" but you set it in "%s".
`
};
function Pee() {
  for (var r = arguments.length, e = new Array(r), i = 0; i < r; i++)
    e[i] = arguments[i];
  var n = e[0], s = [], a;
  for (a = 1; a < e.length; a += 1)
    s.push(e[a]);
  return s.forEach(function(o) {
    n = n.replace(/%[a-z]/, o);
  }), n;
}
var ms = /* @__PURE__ */ function(r) {
  Aee(e, r);
  function e(i) {
    var n;
    if (process.env.NODE_ENV === "production")
      n = r.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + i + " for more information.") || this;
    else {
      for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), o = 1; o < s; o++)
        a[o - 1] = arguments[o];
      n = r.call(this, Pee.apply(void 0, [Nee[i]].concat(a))) || this;
    }
    return Mee(n);
  }
  return e;
}(/* @__PURE__ */ zx(Error));
function Ev(r) {
  return Math.round(r * 255);
}
function Iee(r, e, i) {
  return Ev(r) + "," + Ev(e) + "," + Ev(i);
}
function Km(r, e, i, n) {
  if (n === void 0 && (n = Iee), e === 0)
    return n(i, i, i);
  var s = (r % 360 + 360) % 360 / 60, a = (1 - Math.abs(2 * i - 1)) * e, o = a * (1 - Math.abs(s % 2 - 1)), l = 0, u = 0, c = 0;
  s >= 0 && s < 1 ? (l = a, u = o) : s >= 1 && s < 2 ? (l = o, u = a) : s >= 2 && s < 3 ? (u = a, c = o) : s >= 3 && s < 4 ? (u = o, c = a) : s >= 4 && s < 5 ? (l = o, c = a) : s >= 5 && s < 6 && (l = a, c = o);
  var h = i - a / 2, d = l + h, p = u + h, f = c + h;
  return n(d, p, f);
}
var RA = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function Oee(r) {
  if (typeof r != "string") return r;
  var e = r.toLowerCase();
  return RA[e] ? "#" + RA[e] : r;
}
var Dee = /^#[a-fA-F0-9]{6}$/, Lee = /^#[a-fA-F0-9]{8}$/, kee = /^#[a-fA-F0-9]{3}$/, Uee = /^#[a-fA-F0-9]{4}$/, Mv = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i, Fee = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i, Bee = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, zee = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function Ac(r) {
  if (typeof r != "string")
    throw new ms(3);
  var e = Oee(r);
  if (e.match(Dee))
    return {
      red: parseInt("" + e[1] + e[2], 16),
      green: parseInt("" + e[3] + e[4], 16),
      blue: parseInt("" + e[5] + e[6], 16)
    };
  if (e.match(Lee)) {
    var i = parseFloat((parseInt("" + e[7] + e[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + e[1] + e[2], 16),
      green: parseInt("" + e[3] + e[4], 16),
      blue: parseInt("" + e[5] + e[6], 16),
      alpha: i
    };
  }
  if (e.match(kee))
    return {
      red: parseInt("" + e[1] + e[1], 16),
      green: parseInt("" + e[2] + e[2], 16),
      blue: parseInt("" + e[3] + e[3], 16)
    };
  if (e.match(Uee)) {
    var n = parseFloat((parseInt("" + e[4] + e[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + e[1] + e[1], 16),
      green: parseInt("" + e[2] + e[2], 16),
      blue: parseInt("" + e[3] + e[3], 16),
      alpha: n
    };
  }
  var s = Mv.exec(e);
  if (s)
    return {
      red: parseInt("" + s[1], 10),
      green: parseInt("" + s[2], 10),
      blue: parseInt("" + s[3], 10)
    };
  var a = Fee.exec(e.substring(0, 50));
  if (a)
    return {
      red: parseInt("" + a[1], 10),
      green: parseInt("" + a[2], 10),
      blue: parseInt("" + a[3], 10),
      alpha: parseFloat("" + a[4]) > 1 ? parseFloat("" + a[4]) / 100 : parseFloat("" + a[4])
    };
  var o = Bee.exec(e);
  if (o) {
    var l = parseInt("" + o[1], 10), u = parseInt("" + o[2], 10) / 100, c = parseInt("" + o[3], 10) / 100, h = "rgb(" + Km(l, u, c) + ")", d = Mv.exec(h);
    if (!d)
      throw new ms(4, e, h);
    return {
      red: parseInt("" + d[1], 10),
      green: parseInt("" + d[2], 10),
      blue: parseInt("" + d[3], 10)
    };
  }
  var p = zee.exec(e.substring(0, 50));
  if (p) {
    var f = parseInt("" + p[1], 10), m = parseInt("" + p[2], 10) / 100, y = parseInt("" + p[3], 10) / 100, v = "rgb(" + Km(f, m, y) + ")", g = Mv.exec(v);
    if (!g)
      throw new ms(4, e, v);
    return {
      red: parseInt("" + g[1], 10),
      green: parseInt("" + g[2], 10),
      blue: parseInt("" + g[3], 10),
      alpha: parseFloat("" + p[4]) > 1 ? parseFloat("" + p[4]) / 100 : parseFloat("" + p[4])
    };
  }
  throw new ms(5);
}
function jee(r) {
  var e = r.red / 255, i = r.green / 255, n = r.blue / 255, s = Math.max(e, i, n), a = Math.min(e, i, n), o = (s + a) / 2;
  if (s === a)
    return r.alpha !== void 0 ? {
      hue: 0,
      saturation: 0,
      lightness: o,
      alpha: r.alpha
    } : {
      hue: 0,
      saturation: 0,
      lightness: o
    };
  var l, u = s - a, c = o > 0.5 ? u / (2 - s - a) : u / (s + a);
  switch (s) {
    case e:
      l = (i - n) / u + (i < n ? 6 : 0);
      break;
    case i:
      l = (n - e) / u + 2;
      break;
    default:
      l = (e - i) / u + 4;
      break;
  }
  return l *= 60, r.alpha !== void 0 ? {
    hue: l,
    saturation: c,
    lightness: o,
    alpha: r.alpha
  } : {
    hue: l,
    saturation: c,
    lightness: o
  };
}
function wo(r) {
  return jee(Ac(r));
}
var Vee = function(r) {
  return r.length === 7 && r[1] === r[2] && r[3] === r[4] && r[5] === r[6] ? "#" + r[1] + r[3] + r[5] : r;
}, jx = Vee;
function qo(r) {
  var e = r.toString(16);
  return e.length === 1 ? "0" + e : e;
}
function Av(r) {
  return qo(Math.round(r * 255));
}
function Gee(r, e, i) {
  return jx("#" + Av(r) + Av(e) + Av(i));
}
function y3(r, e, i) {
  return Km(r, e, i, Gee);
}
function Hee(r, e, i) {
  if (typeof r == "object" && e === void 0 && i === void 0)
    return y3(r.hue, r.saturation, r.lightness);
  throw new ms(1);
}
function Wee(r, e, i, n) {
  if (typeof r == "object" && e === void 0 && i === void 0 && n === void 0)
    return r.alpha >= 1 ? y3(r.hue, r.saturation, r.lightness) : "rgba(" + Km(r.hue, r.saturation, r.lightness) + "," + r.alpha + ")";
  throw new ms(2);
}
function v3(r, e, i) {
  if (typeof r == "number" && typeof e == "number" && typeof i == "number")
    return jx("#" + qo(r) + qo(e) + qo(i));
  if (typeof r == "object" && e === void 0 && i === void 0)
    return jx("#" + qo(r.red) + qo(r.green) + qo(r.blue));
  throw new ms(6);
}
function Xg(r, e, i, n) {
  if (typeof r == "object" && e === void 0 && i === void 0 && n === void 0)
    return r.alpha >= 1 ? v3(r.red, r.green, r.blue) : "rgba(" + r.red + "," + r.green + "," + r.blue + "," + r.alpha + ")";
  throw new ms(7);
}
var qee = function(r) {
  return typeof r.red == "number" && typeof r.green == "number" && typeof r.blue == "number" && (typeof r.alpha != "number" || typeof r.alpha > "u");
}, Xee = function(r) {
  return typeof r.red == "number" && typeof r.green == "number" && typeof r.blue == "number" && typeof r.alpha == "number";
}, $ee = function(r) {
  return typeof r.hue == "number" && typeof r.saturation == "number" && typeof r.lightness == "number" && (typeof r.alpha != "number" || typeof r.alpha > "u");
}, Yee = function(r) {
  return typeof r.hue == "number" && typeof r.saturation == "number" && typeof r.lightness == "number" && typeof r.alpha == "number";
};
function Eo(r) {
  if (typeof r != "object") throw new ms(8);
  if (Xee(r)) return Xg(r);
  if (qee(r)) return v3(r);
  if (Yee(r)) return Wee(r);
  if ($ee(r)) return Hee(r);
  throw new ms(8);
}
function b3(r, e, i) {
  return function() {
    var n = i.concat(Array.prototype.slice.call(arguments));
    return n.length >= e ? r.apply(this, n) : b3(r, e, n);
  };
}
function cn(r) {
  return b3(r, r.length, []);
}
function Kee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return Eo(Hr({}, i, {
    hue: i.hue + parseFloat(r)
  }));
}
cn(Kee);
function Wc(r, e, i) {
  return Math.max(r, Math.min(e, i));
}
function Zee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return Eo(Hr({}, i, {
    lightness: Wc(0, 1, i.lightness - parseFloat(r))
  }));
}
cn(Zee);
function Qee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return Eo(Hr({}, i, {
    saturation: Wc(0, 1, i.saturation - parseFloat(r))
  }));
}
cn(Qee);
function Jee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return Eo(Hr({}, i, {
    lightness: Wc(0, 1, i.lightness + parseFloat(r))
  }));
}
cn(Jee);
function ete(r, e, i) {
  if (e === "transparent") return i;
  if (i === "transparent") return e;
  if (r === 0) return i;
  var n = Ac(e), s = Hr({}, n, {
    alpha: typeof n.alpha == "number" ? n.alpha : 1
  }), a = Ac(i), o = Hr({}, a, {
    alpha: typeof a.alpha == "number" ? a.alpha : 1
  }), l = s.alpha - o.alpha, u = parseFloat(r) * 2 - 1, c = u * l === -1 ? u : u + l, h = 1 + u * l, d = (c / h + 1) / 2, p = 1 - d, f = {
    red: Math.floor(s.red * d + o.red * p),
    green: Math.floor(s.green * d + o.green * p),
    blue: Math.floor(s.blue * d + o.blue * p),
    alpha: s.alpha * parseFloat(r) + o.alpha * (1 - parseFloat(r))
  };
  return Xg(f);
}
var tte = cn(ete), x3 = tte;
function ite(r, e) {
  if (e === "transparent") return e;
  var i = Ac(e), n = typeof i.alpha == "number" ? i.alpha : 1, s = Hr({}, i, {
    alpha: Wc(0, 1, (n * 100 + parseFloat(r) * 100) / 100)
  });
  return Xg(s);
}
var rte = cn(ite), nte = rte;
function ste(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return Eo(Hr({}, i, {
    saturation: Wc(0, 1, i.saturation + parseFloat(r))
  }));
}
cn(ste);
function ate(r, e) {
  return e === "transparent" ? e : Eo(Hr({}, wo(e), {
    hue: parseFloat(r)
  }));
}
cn(ate);
function ote(r, e) {
  return e === "transparent" ? e : Eo(Hr({}, wo(e), {
    lightness: parseFloat(r)
  }));
}
cn(ote);
function lte(r, e) {
  return e === "transparent" ? e : Eo(Hr({}, wo(e), {
    saturation: parseFloat(r)
  }));
}
cn(lte);
function ute(r, e) {
  return e === "transparent" ? e : x3(parseFloat(r), "rgb(0, 0, 0)", e);
}
cn(ute);
function cte(r, e) {
  return e === "transparent" ? e : x3(parseFloat(r), "rgb(255, 255, 255)", e);
}
cn(cte);
function hte(r, e) {
  if (e === "transparent") return e;
  var i = Ac(e), n = typeof i.alpha == "number" ? i.alpha : 1, s = Hr({}, i, {
    alpha: Wc(0, 1, +(n * 100 - parseFloat(r) * 100).toFixed(2) / 100)
  });
  return Xg(s);
}
cn(hte);
var va = Object.freeze({
  Linear: Object.freeze({
    None: function(r) {
      return r;
    },
    In: function(r) {
      return r;
    },
    Out: function(r) {
      return r;
    },
    InOut: function(r) {
      return r;
    }
  }),
  Quadratic: Object.freeze({
    In: function(r) {
      return r * r;
    },
    Out: function(r) {
      return r * (2 - r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(r) {
      return r * r * r;
    },
    Out: function(r) {
      return --r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(r) {
      return r * r * r * r;
    },
    Out: function(r) {
      return 1 - --r * r * r * r;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(r) {
      return r * r * r * r * r;
    },
    Out: function(r) {
      return --r * r * r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(r) {
      return 1 - Math.sin((1 - r) * Math.PI / 2);
    },
    Out: function(r) {
      return Math.sin(r * Math.PI / 2);
    },
    InOut: function(r) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - r)));
    }
  }),
  Exponential: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : Math.pow(1024, r - 1);
    },
    Out: function(r) {
      return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(r) {
      return 1 - Math.sqrt(1 - r * r);
    },
    Out: function(r) {
      return Math.sqrt(1 - --r * r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : -Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI);
    },
    Out: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : Math.pow(2, -10 * r) * Math.sin((r - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2, r < 1 ? -0.5 * Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In: function(r) {
      var e = 1.70158;
      return r === 1 ? 1 : r * r * ((e + 1) * r - e);
    },
    Out: function(r) {
      var e = 1.70158;
      return r === 0 ? 0 : --r * r * ((e + 1) * r + e) + 1;
    },
    InOut: function(r) {
      var e = 2.5949095;
      return (r *= 2) < 1 ? 0.5 * (r * r * ((e + 1) * r - e)) : 0.5 * ((r -= 2) * r * ((e + 1) * r + e) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(r) {
      return 1 - va.Bounce.Out(1 - r);
    },
    Out: function(r) {
      return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
    },
    InOut: function(r) {
      return r < 0.5 ? va.Bounce.In(r * 2) * 0.5 : va.Bounce.Out(r * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(r) {
    return r === void 0 && (r = 4), r = r < Number.EPSILON ? Number.EPSILON : r, r = r > 1e4 ? 1e4 : r, {
      In: function(e) {
        return Math.pow(e, r);
      },
      Out: function(e) {
        return 1 - Math.pow(1 - e, r);
      },
      InOut: function(e) {
        return e < 0.5 ? Math.pow(e * 2, r) / 2 : (1 - Math.pow(2 - e * 2, r)) / 2 + 0.5;
      }
    };
  }
}), qh = function() {
  return performance.now();
}, eT = (
  /** @class */
  function() {
    function r() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      this._tweens = {}, this._tweensAddedDuringUpdate = {}, this.add.apply(this, e);
    }
    return r.prototype.getAll = function() {
      var e = this;
      return Object.keys(this._tweens).map(function(i) {
        return e._tweens[i];
      });
    }, r.prototype.removeAll = function() {
      this._tweens = {};
    }, r.prototype.add = function() {
      for (var e, i = [], n = 0; n < arguments.length; n++)
        i[n] = arguments[n];
      for (var s = 0, a = i; s < a.length; s++) {
        var o = a[s];
        (e = o._group) === null || e === void 0 || e.remove(o), o._group = this, this._tweens[o.getId()] = o, this._tweensAddedDuringUpdate[o.getId()] = o;
      }
    }, r.prototype.remove = function() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      for (var n = 0, s = e; n < s.length; n++) {
        var a = s[n];
        a._group = void 0, delete this._tweens[a.getId()], delete this._tweensAddedDuringUpdate[a.getId()];
      }
    }, r.prototype.allStopped = function() {
      return this.getAll().every(function(e) {
        return !e.isPlaying();
      });
    }, r.prototype.update = function(e, i) {
      e === void 0 && (e = qh()), i === void 0 && (i = !0);
      var n = Object.keys(this._tweens);
      if (n.length !== 0)
        for (; n.length > 0; ) {
          this._tweensAddedDuringUpdate = {};
          for (var s = 0; s < n.length; s++) {
            var a = this._tweens[n[s]], o = !i;
            a && a.update(e, o) === !1 && !i && this.remove(a);
          }
          n = Object.keys(this._tweensAddedDuringUpdate);
        }
    }, r;
  }()
), Vx = {
  Linear: function(r, e) {
    var i = r.length - 1, n = i * e, s = Math.floor(n), a = Vx.Utils.Linear;
    return e < 0 ? a(r[0], r[1], n) : e > 1 ? a(r[i], r[i - 1], i - n) : a(r[s], r[s + 1 > i ? i : s + 1], n - s);
  },
  Utils: {
    Linear: function(r, e, i) {
      return (e - r) * i + r;
    }
  }
}, _3 = (
  /** @class */
  function() {
    function r() {
    }
    return r.nextId = function() {
      return r._nextId++;
    }, r._nextId = 0, r;
  }()
), Gx = new eT(), Zm = (
  /** @class */
  function() {
    function r(e, i) {
      this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = va.Linear.None, this._interpolationFunction = Vx.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = _3.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1, this._object = e, typeof i == "object" ? (this._group = i, i.add(this)) : i === !0 && (this._group = Gx, Gx.add(this));
    }
    return r.prototype.getId = function() {
      return this._id;
    }, r.prototype.isPlaying = function() {
      return this._isPlaying;
    }, r.prototype.isPaused = function() {
      return this._isPaused;
    }, r.prototype.getDuration = function() {
      return this._duration;
    }, r.prototype.to = function(e, i) {
      if (i === void 0 && (i = 1e3), this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      return this._valuesEnd = e, this._propertiesAreSetUp = !1, this._duration = i < 0 ? 0 : i, this;
    }, r.prototype.duration = function(e) {
      return e === void 0 && (e = 1e3), this._duration = e < 0 ? 0 : e, this;
    }, r.prototype.dynamic = function(e) {
      return e === void 0 && (e = !1), this._isDynamic = e, this;
    }, r.prototype.start = function(e, i) {
      if (e === void 0 && (e = qh()), i === void 0 && (i = !1), this._isPlaying)
        return this;
      if (this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var n in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n];
      }
      if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = e, this._startTime += this._delayTime, !this._propertiesAreSetUp || i) {
        if (this._propertiesAreSetUp = !0, !this._isDynamic) {
          var s = {};
          for (var a in this._valuesEnd)
            s[a] = this._valuesEnd[a];
          this._valuesEnd = s;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, i);
      }
      return this;
    }, r.prototype.startFromCurrentValues = function(e) {
      return this.start(e, !0);
    }, r.prototype._setupProperties = function(e, i, n, s, a) {
      for (var o in n) {
        var l = e[o], u = Array.isArray(l), c = u ? "array" : typeof l, h = !u && Array.isArray(n[o]);
        if (!(c === "undefined" || c === "function")) {
          if (h) {
            var d = n[o];
            if (d.length === 0)
              continue;
            for (var p = [l], f = 0, m = d.length; f < m; f += 1) {
              var y = this._handleRelativeValue(l, d[f]);
              if (isNaN(y)) {
                h = !1, console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              p.push(y);
            }
            h && (n[o] = p);
          }
          if ((c === "object" || u) && l && !h) {
            i[o] = u ? [] : {};
            var v = l;
            for (var g in v)
              i[o][g] = v[g];
            s[o] = u ? [] : {};
            var d = n[o];
            if (!this._isDynamic) {
              var _ = {};
              for (var g in d)
                _[g] = d[g];
              n[o] = d = _;
            }
            this._setupProperties(v, i[o], d, s[o], a);
          } else
            (typeof i[o] > "u" || a) && (i[o] = l), u || (i[o] *= 1), h ? s[o] = n[o].slice().reverse() : s[o] = i[o] || 0;
        }
      }
    }, r.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, r.prototype.end = function() {
      return this._goToEnd = !0, this.update(this._startTime + this._duration), this;
    }, r.prototype.pause = function(e) {
      return e === void 0 && (e = qh()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = e, this);
    }, r.prototype.resume = function(e) {
      return e === void 0 && (e = qh()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += e - this._pauseStart, this._pauseStart = 0, this);
    }, r.prototype.stopChainedTweens = function() {
      for (var e = 0, i = this._chainedTweens.length; e < i; e++)
        this._chainedTweens[e].stop();
      return this;
    }, r.prototype.group = function(e) {
      return e ? (e.add(this), this) : (console.warn("tween.group() without args has been removed, use group.add(tween) instead."), this);
    }, r.prototype.remove = function() {
      var e;
      return (e = this._group) === null || e === void 0 || e.remove(this), this;
    }, r.prototype.delay = function(e) {
      return e === void 0 && (e = 0), this._delayTime = e, this;
    }, r.prototype.repeat = function(e) {
      return e === void 0 && (e = 0), this._initialRepeat = e, this._repeat = e, this;
    }, r.prototype.repeatDelay = function(e) {
      return this._repeatDelayTime = e, this;
    }, r.prototype.yoyo = function(e) {
      return e === void 0 && (e = !1), this._yoyo = e, this;
    }, r.prototype.easing = function(e) {
      return e === void 0 && (e = va.Linear.None), this._easingFunction = e, this;
    }, r.prototype.interpolation = function(e) {
      return e === void 0 && (e = Vx.Linear), this._interpolationFunction = e, this;
    }, r.prototype.chain = function() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      return this._chainedTweens = e, this;
    }, r.prototype.onStart = function(e) {
      return this._onStartCallback = e, this;
    }, r.prototype.onEveryStart = function(e) {
      return this._onEveryStartCallback = e, this;
    }, r.prototype.onUpdate = function(e) {
      return this._onUpdateCallback = e, this;
    }, r.prototype.onRepeat = function(e) {
      return this._onRepeatCallback = e, this;
    }, r.prototype.onComplete = function(e) {
      return this._onCompleteCallback = e, this;
    }, r.prototype.onStop = function(e) {
      return this._onStopCallback = e, this;
    }, r.prototype.update = function(e, i) {
      var n = this, s;
      if (e === void 0 && (e = qh()), i === void 0 && (i = r.autoStartOnUpdate), this._isPaused)
        return !0;
      var a;
      if (!this._goToEnd && !this._isPlaying)
        if (i)
          this.start(e, !0);
        else
          return !1;
      if (this._goToEnd = !1, e < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0);
      var o = e - this._startTime, l = this._duration + ((s = this._repeatDelayTime) !== null && s !== void 0 ? s : this._delayTime), u = this._duration + this._repeat * l, c = function() {
        if (n._duration === 0 || o > u)
          return 1;
        var y = Math.trunc(o / l), v = o - y * l, g = Math.min(v / n._duration, 1);
        return g === 0 && o === n._duration ? 1 : g;
      }, h = c(), d = this._easingFunction(h);
      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, d), this._onUpdateCallback && this._onUpdateCallback(this._object, h), this._duration === 0 || o >= this._duration)
        if (this._repeat > 0) {
          var p = Math.min(Math.trunc((o - this._duration) / l) + 1, this._repeat);
          isFinite(this._repeat) && (this._repeat -= p);
          for (a in this._valuesStartRepeat)
            !this._yoyo && typeof this._valuesEnd[a] == "string" && (this._valuesStartRepeat[a] = // eslint-disable-next-line
            // @ts-ignore FIXME?
            this._valuesStartRepeat[a] + parseFloat(this._valuesEnd[a])), this._yoyo && this._swapEndStartRepeatValues(a), this._valuesStart[a] = this._valuesStartRepeat[a];
          return this._yoyo && (this._reversed = !this._reversed), this._startTime += l * p, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;
        } else {
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var f = 0, m = this._chainedTweens.length; f < m; f++)
            this._chainedTweens[f].start(this._startTime + this._duration, !1);
          return this._isPlaying = !1, !1;
        }
      return !0;
    }, r.prototype._updateProperties = function(e, i, n, s) {
      for (var a in n)
        if (i[a] !== void 0) {
          var o = i[a] || 0, l = n[a], u = Array.isArray(e[a]), c = Array.isArray(l), h = !u && c;
          h ? e[a] = this._interpolationFunction(l, s) : typeof l == "object" && l ? this._updateProperties(e[a], o, l, s) : (l = this._handleRelativeValue(o, l), typeof l == "number" && (e[a] = o + (l - o) * s));
        }
    }, r.prototype._handleRelativeValue = function(e, i) {
      return typeof i != "string" ? i : i.charAt(0) === "+" || i.charAt(0) === "-" ? e + parseFloat(i) : parseFloat(i);
    }, r.prototype._swapEndStartRepeatValues = function(e) {
      var i = this._valuesStartRepeat[e], n = this._valuesEnd[e];
      typeof n == "string" ? this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(n) : this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = i;
    }, r.autoStartOnUpdate = !1, r;
  }()
);
_3.nextId;
var Ss = Gx;
Ss.getAll.bind(Ss);
Ss.removeAll.bind(Ss);
Ss.add.bind(Ss);
Ss.remove.bind(Ss);
Ss.update.bind(Ss);
var Hx = "http://www.w3.org/1999/xhtml";
const NA = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Hx,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function $g(r) {
  var e = r += "", i = e.indexOf(":");
  return i >= 0 && (e = r.slice(0, i)) !== "xmlns" && (r = r.slice(i + 1)), NA.hasOwnProperty(e) ? { space: NA[e], local: r } : r;
}
function dte(r) {
  return function() {
    var e = this.ownerDocument, i = this.namespaceURI;
    return i === Hx && e.documentElement.namespaceURI === Hx ? e.createElement(r) : e.createElementNS(i, r);
  };
}
function pte(r) {
  return function() {
    return this.ownerDocument.createElementNS(r.space, r.local);
  };
}
function T3(r) {
  var e = $g(r);
  return (e.local ? pte : dte)(e);
}
function fte() {
}
function tT(r) {
  return r == null ? fte : function() {
    return this.querySelector(r);
  };
}
function mte(r) {
  typeof r != "function" && (r = tT(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = new Array(o), u, c, h = 0; h < o; ++h)
      (u = a[h]) && (c = r.call(u, u.__data__, h, a)) && ("__data__" in u && (c.__data__ = u.__data__), l[h] = c);
  return new ln(n, this._parents);
}
function gte(r) {
  return r == null ? [] : Array.isArray(r) ? r : Array.from(r);
}
function yte() {
  return [];
}
function S3(r) {
  return r == null ? yte : function() {
    return this.querySelectorAll(r);
  };
}
function vte(r) {
  return function() {
    return gte(r.apply(this, arguments));
  };
}
function bte(r) {
  typeof r == "function" ? r = vte(r) : r = S3(r);
  for (var e = this._groups, i = e.length, n = [], s = [], a = 0; a < i; ++a)
    for (var o = e[a], l = o.length, u, c = 0; c < l; ++c)
      (u = o[c]) && (n.push(r.call(u, u.__data__, c, o)), s.push(u));
  return new ln(n, s);
}
function w3(r) {
  return function() {
    return this.matches(r);
  };
}
function E3(r) {
  return function(e) {
    return e.matches(r);
  };
}
var xte = Array.prototype.find;
function _te(r) {
  return function() {
    return xte.call(this.children, r);
  };
}
function Tte() {
  return this.firstElementChild;
}
function Ste(r) {
  return this.select(r == null ? Tte : _te(typeof r == "function" ? r : E3(r)));
}
var wte = Array.prototype.filter;
function Ete() {
  return Array.from(this.children);
}
function Mte(r) {
  return function() {
    return wte.call(this.children, r);
  };
}
function Ate(r) {
  return this.selectAll(r == null ? Ete : Mte(typeof r == "function" ? r : E3(r)));
}
function Cte(r) {
  typeof r != "function" && (r = w3(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = [], u, c = 0; c < o; ++c)
      (u = a[c]) && r.call(u, u.__data__, c, a) && l.push(u);
  return new ln(n, this._parents);
}
function M3(r) {
  return new Array(r.length);
}
function Rte() {
  return new ln(this._enter || this._groups.map(M3), this._parents);
}
function Qm(r, e) {
  this.ownerDocument = r.ownerDocument, this.namespaceURI = r.namespaceURI, this._next = null, this._parent = r, this.__data__ = e;
}
Qm.prototype = {
  constructor: Qm,
  appendChild: function(r) {
    return this._parent.insertBefore(r, this._next);
  },
  insertBefore: function(r, e) {
    return this._parent.insertBefore(r, e);
  },
  querySelector: function(r) {
    return this._parent.querySelector(r);
  },
  querySelectorAll: function(r) {
    return this._parent.querySelectorAll(r);
  }
};
function Nte(r) {
  return function() {
    return r;
  };
}
function Pte(r, e, i, n, s, a) {
  for (var o = 0, l, u = e.length, c = a.length; o < c; ++o)
    (l = e[o]) ? (l.__data__ = a[o], n[o] = l) : i[o] = new Qm(r, a[o]);
  for (; o < u; ++o)
    (l = e[o]) && (s[o] = l);
}
function Ite(r, e, i, n, s, a, o) {
  var l, u, c = /* @__PURE__ */ new Map(), h = e.length, d = a.length, p = new Array(h), f;
  for (l = 0; l < h; ++l)
    (u = e[l]) && (p[l] = f = o.call(u, u.__data__, l, e) + "", c.has(f) ? s[l] = u : c.set(f, u));
  for (l = 0; l < d; ++l)
    f = o.call(r, a[l], l, a) + "", (u = c.get(f)) ? (n[l] = u, u.__data__ = a[l], c.delete(f)) : i[l] = new Qm(r, a[l]);
  for (l = 0; l < h; ++l)
    (u = e[l]) && c.get(p[l]) === u && (s[l] = u);
}
function Ote(r) {
  return r.__data__;
}
function Dte(r, e) {
  if (!arguments.length) return Array.from(this, Ote);
  var i = e ? Ite : Pte, n = this._parents, s = this._groups;
  typeof r != "function" && (r = Nte(r));
  for (var a = s.length, o = new Array(a), l = new Array(a), u = new Array(a), c = 0; c < a; ++c) {
    var h = n[c], d = s[c], p = d.length, f = Lte(r.call(h, h && h.__data__, c, n)), m = f.length, y = l[c] = new Array(m), v = o[c] = new Array(m), g = u[c] = new Array(p);
    i(h, d, y, v, g, f, e);
    for (var _ = 0, x = 0, b, T; _ < m; ++_)
      if (b = y[_]) {
        for (_ >= x && (x = _ + 1); !(T = v[x]) && ++x < m; ) ;
        b._next = T || null;
      }
  }
  return o = new ln(o, n), o._enter = l, o._exit = u, o;
}
function Lte(r) {
  return typeof r == "object" && "length" in r ? r : Array.from(r);
}
function kte() {
  return new ln(this._exit || this._groups.map(M3), this._parents);
}
function Ute(r, e, i) {
  var n = this.enter(), s = this, a = this.exit();
  return typeof r == "function" ? (n = r(n), n && (n = n.selection())) : n = n.append(r + ""), e != null && (s = e(s), s && (s = s.selection())), i == null ? a.remove() : i(a), n && s ? n.merge(s).order() : s;
}
function Fte(r) {
  for (var e = r.selection ? r.selection() : r, i = this._groups, n = e._groups, s = i.length, a = n.length, o = Math.min(s, a), l = new Array(s), u = 0; u < o; ++u)
    for (var c = i[u], h = n[u], d = c.length, p = l[u] = new Array(d), f, m = 0; m < d; ++m)
      (f = c[m] || h[m]) && (p[m] = f);
  for (; u < s; ++u)
    l[u] = i[u];
  return new ln(l, this._parents);
}
function Bte() {
  for (var r = this._groups, e = -1, i = r.length; ++e < i; )
    for (var n = r[e], s = n.length - 1, a = n[s], o; --s >= 0; )
      (o = n[s]) && (a && o.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(o, a), a = o);
  return this;
}
function zte(r) {
  r || (r = jte);
  function e(d, p) {
    return d && p ? r(d.__data__, p.__data__) : !d - !p;
  }
  for (var i = this._groups, n = i.length, s = new Array(n), a = 0; a < n; ++a) {
    for (var o = i[a], l = o.length, u = s[a] = new Array(l), c, h = 0; h < l; ++h)
      (c = o[h]) && (u[h] = c);
    u.sort(e);
  }
  return new ln(s, this._parents).order();
}
function jte(r, e) {
  return r < e ? -1 : r > e ? 1 : r >= e ? 0 : NaN;
}
function Vte() {
  var r = arguments[0];
  return arguments[0] = this, r.apply(null, arguments), this;
}
function Gte() {
  return Array.from(this);
}
function Hte() {
  for (var r = this._groups, e = 0, i = r.length; e < i; ++e)
    for (var n = r[e], s = 0, a = n.length; s < a; ++s) {
      var o = n[s];
      if (o) return o;
    }
  return null;
}
function Wte() {
  let r = 0;
  for (const e of this) ++r;
  return r;
}
function qte() {
  return !this.node();
}
function Xte(r) {
  for (var e = this._groups, i = 0, n = e.length; i < n; ++i)
    for (var s = e[i], a = 0, o = s.length, l; a < o; ++a)
      (l = s[a]) && r.call(l, l.__data__, a, s);
  return this;
}
function $te(r) {
  return function() {
    this.removeAttribute(r);
  };
}
function Yte(r) {
  return function() {
    this.removeAttributeNS(r.space, r.local);
  };
}
function Kte(r, e) {
  return function() {
    this.setAttribute(r, e);
  };
}
function Zte(r, e) {
  return function() {
    this.setAttributeNS(r.space, r.local, e);
  };
}
function Qte(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? this.removeAttribute(r) : this.setAttribute(r, i);
  };
}
function Jte(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? this.removeAttributeNS(r.space, r.local) : this.setAttributeNS(r.space, r.local, i);
  };
}
function eie(r, e) {
  var i = $g(r);
  if (arguments.length < 2) {
    var n = this.node();
    return i.local ? n.getAttributeNS(i.space, i.local) : n.getAttribute(i);
  }
  return this.each((e == null ? i.local ? Yte : $te : typeof e == "function" ? i.local ? Jte : Qte : i.local ? Zte : Kte)(i, e));
}
function A3(r) {
  return r.ownerDocument && r.ownerDocument.defaultView || r.document && r || r.defaultView;
}
function tie(r) {
  return function() {
    this.style.removeProperty(r);
  };
}
function iie(r, e, i) {
  return function() {
    this.style.setProperty(r, e, i);
  };
}
function rie(r, e, i) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(r) : this.style.setProperty(r, n, i);
  };
}
function nie(r, e, i) {
  return arguments.length > 1 ? this.each((e == null ? tie : typeof e == "function" ? rie : iie)(r, e, i ?? "")) : Cc(this.node(), r);
}
function Cc(r, e) {
  return r.style.getPropertyValue(e) || A3(r).getComputedStyle(r, null).getPropertyValue(e);
}
function sie(r) {
  return function() {
    delete this[r];
  };
}
function aie(r, e) {
  return function() {
    this[r] = e;
  };
}
function oie(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? delete this[r] : this[r] = i;
  };
}
function lie(r, e) {
  return arguments.length > 1 ? this.each((e == null ? sie : typeof e == "function" ? oie : aie)(r, e)) : this.node()[r];
}
function C3(r) {
  return r.trim().split(/^|\s+/);
}
function iT(r) {
  return r.classList || new R3(r);
}
function R3(r) {
  this._node = r, this._names = C3(r.getAttribute("class") || "");
}
R3.prototype = {
  add: function(r) {
    var e = this._names.indexOf(r);
    e < 0 && (this._names.push(r), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(r) {
    var e = this._names.indexOf(r);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(r) {
    return this._names.indexOf(r) >= 0;
  }
};
function N3(r, e) {
  for (var i = iT(r), n = -1, s = e.length; ++n < s; ) i.add(e[n]);
}
function P3(r, e) {
  for (var i = iT(r), n = -1, s = e.length; ++n < s; ) i.remove(e[n]);
}
function uie(r) {
  return function() {
    N3(this, r);
  };
}
function cie(r) {
  return function() {
    P3(this, r);
  };
}
function hie(r, e) {
  return function() {
    (e.apply(this, arguments) ? N3 : P3)(this, r);
  };
}
function die(r, e) {
  var i = C3(r + "");
  if (arguments.length < 2) {
    for (var n = iT(this.node()), s = -1, a = i.length; ++s < a; ) if (!n.contains(i[s])) return !1;
    return !0;
  }
  return this.each((typeof e == "function" ? hie : e ? uie : cie)(i, e));
}
function pie() {
  this.textContent = "";
}
function fie(r) {
  return function() {
    this.textContent = r;
  };
}
function mie(r) {
  return function() {
    var e = r.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function gie(r) {
  return arguments.length ? this.each(r == null ? pie : (typeof r == "function" ? mie : fie)(r)) : this.node().textContent;
}
function yie() {
  this.innerHTML = "";
}
function vie(r) {
  return function() {
    this.innerHTML = r;
  };
}
function bie(r) {
  return function() {
    var e = r.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function xie(r) {
  return arguments.length ? this.each(r == null ? yie : (typeof r == "function" ? bie : vie)(r)) : this.node().innerHTML;
}
function _ie() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Tie() {
  return this.each(_ie);
}
function Sie() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function wie() {
  return this.each(Sie);
}
function Eie(r) {
  var e = typeof r == "function" ? r : T3(r);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function Mie() {
  return null;
}
function Aie(r, e) {
  var i = typeof r == "function" ? r : T3(r), n = e == null ? Mie : typeof e == "function" ? e : tT(e);
  return this.select(function() {
    return this.insertBefore(i.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function Cie() {
  var r = this.parentNode;
  r && r.removeChild(this);
}
function Rie() {
  return this.each(Cie);
}
function Nie() {
  var r = this.cloneNode(!1), e = this.parentNode;
  return e ? e.insertBefore(r, this.nextSibling) : r;
}
function Pie() {
  var r = this.cloneNode(!0), e = this.parentNode;
  return e ? e.insertBefore(r, this.nextSibling) : r;
}
function Iie(r) {
  return this.select(r ? Pie : Nie);
}
function Oie(r) {
  return arguments.length ? this.property("__data__", r) : this.node().__data__;
}
function Die(r) {
  return function(e) {
    r.call(this, e, this.__data__);
  };
}
function Lie(r) {
  return r.trim().split(/^|\s+/).map(function(e) {
    var i = "", n = e.indexOf(".");
    return n >= 0 && (i = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: i };
  });
}
function kie(r) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var i = 0, n = -1, s = e.length, a; i < s; ++i)
        a = e[i], (!r.type || a.type === r.type) && a.name === r.name ? this.removeEventListener(a.type, a.listener, a.options) : e[++n] = a;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function Uie(r, e, i) {
  return function() {
    var n = this.__on, s, a = Die(e);
    if (n) {
      for (var o = 0, l = n.length; o < l; ++o)
        if ((s = n[o]).type === r.type && s.name === r.name) {
          this.removeEventListener(s.type, s.listener, s.options), this.addEventListener(s.type, s.listener = a, s.options = i), s.value = e;
          return;
        }
    }
    this.addEventListener(r.type, a, i), s = { type: r.type, name: r.name, value: e, listener: a, options: i }, n ? n.push(s) : this.__on = [s];
  };
}
function Fie(r, e, i) {
  var n = Lie(r + ""), s, a = n.length, o;
  if (arguments.length < 2) {
    var l = this.node().__on;
    if (l) {
      for (var u = 0, c = l.length, h; u < c; ++u)
        for (s = 0, h = l[u]; s < a; ++s)
          if ((o = n[s]).type === h.type && o.name === h.name)
            return h.value;
    }
    return;
  }
  for (l = e ? Uie : kie, s = 0; s < a; ++s) this.each(l(n[s], e, i));
  return this;
}
function I3(r, e, i) {
  var n = A3(r), s = n.CustomEvent;
  typeof s == "function" ? s = new s(e, i) : (s = n.document.createEvent("Event"), i ? (s.initEvent(e, i.bubbles, i.cancelable), s.detail = i.detail) : s.initEvent(e, !1, !1)), r.dispatchEvent(s);
}
function Bie(r, e) {
  return function() {
    return I3(this, r, e);
  };
}
function zie(r, e) {
  return function() {
    return I3(this, r, e.apply(this, arguments));
  };
}
function jie(r, e) {
  return this.each((typeof e == "function" ? zie : Bie)(r, e));
}
function* Vie() {
  for (var r = this._groups, e = 0, i = r.length; e < i; ++e)
    for (var n = r[e], s = 0, a = n.length, o; s < a; ++s)
      (o = n[s]) && (yield o);
}
var O3 = [null];
function ln(r, e) {
  this._groups = r, this._parents = e;
}
function np() {
  return new ln([[document.documentElement]], O3);
}
function Gie() {
  return this;
}
ln.prototype = np.prototype = {
  constructor: ln,
  select: mte,
  selectAll: bte,
  selectChild: Ste,
  selectChildren: Ate,
  filter: Cte,
  data: Dte,
  enter: Rte,
  exit: kte,
  join: Ute,
  merge: Fte,
  selection: Gie,
  order: Bte,
  sort: zte,
  call: Vte,
  nodes: Gte,
  node: Hte,
  size: Wte,
  empty: qte,
  each: Xte,
  attr: eie,
  style: nie,
  property: lie,
  classed: die,
  text: gie,
  html: xie,
  raise: Tie,
  lower: wie,
  append: Eie,
  insert: Aie,
  remove: Rie,
  clone: Iie,
  datum: Oie,
  on: Fie,
  dispatch: jie,
  [Symbol.iterator]: Vie
};
function vn(r) {
  return typeof r == "string" ? new ln([[document.querySelector(r)]], [document.documentElement]) : new ln([[r]], O3);
}
function Hie(r) {
  let e;
  for (; e = r.sourceEvent; ) r = e;
  return r;
}
function as(r, e) {
  if (r = Hie(r), e === void 0 && (e = r.currentTarget), e) {
    var i = e.ownerSVGElement || e;
    if (i.createSVGPoint) {
      var n = i.createSVGPoint();
      return n.x = r.clientX, n.y = r.clientY, n = n.matrixTransform(e.getScreenCTM().inverse()), [n.x, n.y];
    }
    if (e.getBoundingClientRect) {
      var s = e.getBoundingClientRect();
      return [r.clientX - s.left - e.clientLeft, r.clientY - s.top - e.clientTop];
    }
  }
  return [r.pageX, r.pageY];
}
var sp, mi, D3, L3, el, PA, k3, U3, F3, rT, Wx, qx, Nd = {}, B3 = [], Wie = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Yg = Array.isArray;
function gs(r, e) {
  for (var i in e) r[i] = e[i];
  return r;
}
function nT(r) {
  r && r.parentNode && r.parentNode.removeChild(r);
}
function qie(r, e, i) {
  var n, s, a, o = {};
  for (a in e) a == "key" ? n = e[a] : a == "ref" ? s = e[a] : o[a] = e[a];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? sp.call(arguments, 2) : i), typeof r == "function" && r.defaultProps != null) for (a in r.defaultProps) o[a] === void 0 && (o[a] = r.defaultProps[a]);
  return ad(r, o, n, s, null);
}
function ad(r, e, i, n, s) {
  var a = { type: r, props: e, key: i, ref: n, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: s ?? ++D3, __i: -1, __u: 0 };
  return s == null && mi.vnode != null && mi.vnode(a), a;
}
function Kg(r) {
  return r.children;
}
function cm(r, e) {
  this.props = r, this.context = e;
}
function Rc(r, e) {
  if (e == null) return r.__ ? Rc(r.__, r.__i + 1) : null;
  for (var i; e < r.__k.length; e++) if ((i = r.__k[e]) != null && i.__e != null) return i.__e;
  return typeof r.type == "function" ? Rc(r) : null;
}
function z3(r) {
  var e, i;
  if ((r = r.__) != null && r.__c != null) {
    for (r.__e = r.__c.base = null, e = 0; e < r.__k.length; e++) if ((i = r.__k[e]) != null && i.__e != null) {
      r.__e = r.__c.base = i.__e;
      break;
    }
    return z3(r);
  }
}
function IA(r) {
  (!r.__d && (r.__d = !0) && el.push(r) && !Jm.__r++ || PA !== mi.debounceRendering) && ((PA = mi.debounceRendering) || k3)(Jm);
}
function Jm() {
  for (var r, e, i, n, s, a, o, l = 1; el.length; ) el.length > l && el.sort(U3), r = el.shift(), l = el.length, r.__d && (i = void 0, s = (n = (e = r).__v).__e, a = [], o = [], e.__P && ((i = gs({}, n)).__v = n.__v + 1, mi.vnode && mi.vnode(i), sT(e.__P, i, n, e.__n, e.__P.namespaceURI, 32 & n.__u ? [s] : null, a, s ?? Rc(n), !!(32 & n.__u), o), i.__v = n.__v, i.__.__k[i.__i] = i, G3(a, i, o), i.__e != s && z3(i)));
  Jm.__r = 0;
}
function j3(r, e, i, n, s, a, o, l, u, c, h) {
  var d, p, f, m, y, v, g = n && n.__k || B3, _ = e.length;
  for (u = Xie(i, e, g, u, _), d = 0; d < _; d++) (f = i.__k[d]) != null && (p = f.__i === -1 ? Nd : g[f.__i] || Nd, f.__i = d, v = sT(r, f, p, s, a, o, l, u, c, h), m = f.__e, f.ref && p.ref != f.ref && (p.ref && aT(p.ref, null, f), h.push(f.ref, f.__c || m, f)), y == null && m != null && (y = m), 4 & f.__u || p.__k === f.__k ? u = V3(f, u, r) : typeof f.type == "function" && v !== void 0 ? u = v : m && (u = m.nextSibling), f.__u &= -7);
  return i.__e = y, u;
}
function Xie(r, e, i, n, s) {
  var a, o, l, u, c, h = i.length, d = h, p = 0;
  for (r.__k = new Array(s), a = 0; a < s; a++) (o = e[a]) != null && typeof o != "boolean" && typeof o != "function" ? (u = a + p, (o = r.__k[a] = typeof o == "string" || typeof o == "number" || typeof o == "bigint" || o.constructor == String ? ad(null, o, null, null, null) : Yg(o) ? ad(Kg, { children: o }, null, null, null) : o.constructor === void 0 && o.__b > 0 ? ad(o.type, o.props, o.key, o.ref ? o.ref : null, o.__v) : o).__ = r, o.__b = r.__b + 1, l = null, (c = o.__i = $ie(o, i, u, d)) !== -1 && (d--, (l = i[c]) && (l.__u |= 2)), l == null || l.__v === null ? (c == -1 && (s > h ? p-- : s < h && p++), typeof o.type != "function" && (o.__u |= 4)) : c != u && (c == u - 1 ? p-- : c == u + 1 ? p++ : (c > u ? p-- : p++, o.__u |= 4))) : r.__k[a] = null;
  if (d) for (a = 0; a < h; a++) (l = i[a]) != null && !(2 & l.__u) && (l.__e == n && (n = Rc(l)), W3(l, l));
  return n;
}
function V3(r, e, i) {
  var n, s;
  if (typeof r.type == "function") {
    for (n = r.__k, s = 0; n && s < n.length; s++) n[s] && (n[s].__ = r, e = V3(n[s], e, i));
    return e;
  }
  r.__e != e && (e && r.type && !i.contains(e) && (e = Rc(r)), i.insertBefore(r.__e, e || null), e = r.__e);
  do
    e = e && e.nextSibling;
  while (e != null && e.nodeType == 8);
  return e;
}
function $ie(r, e, i, n) {
  var s, a, o = r.key, l = r.type, u = e[i];
  if (u === null && r.key == null || u && o == u.key && l === u.type && !(2 & u.__u)) return i;
  if (n > (u != null && !(2 & u.__u) ? 1 : 0)) for (s = i - 1, a = i + 1; s >= 0 || a < e.length; ) {
    if (s >= 0) {
      if ((u = e[s]) && !(2 & u.__u) && o == u.key && l === u.type) return s;
      s--;
    }
    if (a < e.length) {
      if ((u = e[a]) && !(2 & u.__u) && o == u.key && l === u.type) return a;
      a++;
    }
  }
  return -1;
}
function OA(r, e, i) {
  e[0] == "-" ? r.setProperty(e, i ?? "") : r[e] = i == null ? "" : typeof i != "number" || Wie.test(e) ? i : i + "px";
}
function Of(r, e, i, n, s) {
  var a;
  e: if (e == "style") if (typeof i == "string") r.style.cssText = i;
  else {
    if (typeof n == "string" && (r.style.cssText = n = ""), n) for (e in n) i && e in i || OA(r.style, e, "");
    if (i) for (e in i) n && i[e] === n[e] || OA(r.style, e, i[e]);
  }
  else if (e[0] == "o" && e[1] == "n") a = e != (e = e.replace(F3, "$1")), e = e.toLowerCase() in r || e == "onFocusOut" || e == "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), r.l || (r.l = {}), r.l[e + a] = i, i ? n ? i.t = n.t : (i.t = rT, r.addEventListener(e, a ? qx : Wx, a)) : r.removeEventListener(e, a ? qx : Wx, a);
  else {
    if (s == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in r) try {
      r[e] = i ?? "";
      break e;
    } catch {
    }
    typeof i == "function" || (i == null || i === !1 && e[4] != "-" ? r.removeAttribute(e) : r.setAttribute(e, e == "popover" && i == 1 ? "" : i));
  }
}
function DA(r) {
  return function(e) {
    if (this.l) {
      var i = this.l[e.type + r];
      if (e.u == null) e.u = rT++;
      else if (e.u < i.t) return;
      return i(mi.event ? mi.event(e) : e);
    }
  };
}
function sT(r, e, i, n, s, a, o, l, u, c) {
  var h, d, p, f, m, y, v, g, _, x, b, T, S, w, M, E, A, N = e.type;
  if (e.constructor !== void 0) return null;
  128 & i.__u && (u = !!(32 & i.__u), a = [l = e.__e = i.__e]), (h = mi.__b) && h(e);
  e: if (typeof N == "function") try {
    if (g = e.props, _ = "prototype" in N && N.prototype.render, x = (h = N.contextType) && n[h.__c], b = h ? x ? x.props.value : h.__ : n, i.__c ? v = (d = e.__c = i.__c).__ = d.__E : (_ ? e.__c = d = new N(g, b) : (e.__c = d = new cm(g, b), d.constructor = N, d.render = Kie), x && x.sub(d), d.props = g, d.state || (d.state = {}), d.context = b, d.__n = n, p = d.__d = !0, d.__h = [], d._sb = []), _ && d.__s == null && (d.__s = d.state), _ && N.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = gs({}, d.__s)), gs(d.__s, N.getDerivedStateFromProps(g, d.__s))), f = d.props, m = d.state, d.__v = e, p) _ && N.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(), _ && d.componentDidMount != null && d.__h.push(d.componentDidMount);
    else {
      if (_ && N.getDerivedStateFromProps == null && g !== f && d.componentWillReceiveProps != null && d.componentWillReceiveProps(g, b), !d.__e && (d.shouldComponentUpdate != null && d.shouldComponentUpdate(g, d.__s, b) === !1 || e.__v == i.__v)) {
        for (e.__v != i.__v && (d.props = g, d.state = d.__s, d.__d = !1), e.__e = i.__e, e.__k = i.__k, e.__k.some(function(U) {
          U && (U.__ = e);
        }), T = 0; T < d._sb.length; T++) d.__h.push(d._sb[T]);
        d._sb = [], d.__h.length && o.push(d);
        break e;
      }
      d.componentWillUpdate != null && d.componentWillUpdate(g, d.__s, b), _ && d.componentDidUpdate != null && d.__h.push(function() {
        d.componentDidUpdate(f, m, y);
      });
    }
    if (d.context = b, d.props = g, d.__P = r, d.__e = !1, S = mi.__r, w = 0, _) {
      for (d.state = d.__s, d.__d = !1, S && S(e), h = d.render(d.props, d.state, d.context), M = 0; M < d._sb.length; M++) d.__h.push(d._sb[M]);
      d._sb = [];
    } else do
      d.__d = !1, S && S(e), h = d.render(d.props, d.state, d.context), d.state = d.__s;
    while (d.__d && ++w < 25);
    d.state = d.__s, d.getChildContext != null && (n = gs(gs({}, n), d.getChildContext())), _ && !p && d.getSnapshotBeforeUpdate != null && (y = d.getSnapshotBeforeUpdate(f, m)), E = h, h != null && h.type === Kg && h.key == null && (E = H3(h.props.children)), l = j3(r, Yg(E) ? E : [E], e, i, n, s, a, o, l, u, c), d.base = e.__e, e.__u &= -161, d.__h.length && o.push(d), v && (d.__E = d.__ = null);
  } catch (U) {
    if (e.__v = null, u || a != null) if (U.then) {
      for (e.__u |= u ? 160 : 128; l && l.nodeType == 8 && l.nextSibling; ) l = l.nextSibling;
      a[a.indexOf(l)] = null, e.__e = l;
    } else for (A = a.length; A--; ) nT(a[A]);
    else e.__e = i.__e, e.__k = i.__k;
    mi.__e(U, e, i);
  }
  else a == null && e.__v == i.__v ? (e.__k = i.__k, e.__e = i.__e) : l = e.__e = Yie(i.__e, e, i, n, s, a, o, u, c);
  return (h = mi.diffed) && h(e), 128 & e.__u ? void 0 : l;
}
function G3(r, e, i) {
  for (var n = 0; n < i.length; n++) aT(i[n], i[++n], i[++n]);
  mi.__c && mi.__c(e, r), r.some(function(s) {
    try {
      r = s.__h, s.__h = [], r.some(function(a) {
        a.call(s);
      });
    } catch (a) {
      mi.__e(a, s.__v);
    }
  });
}
function H3(r) {
  return typeof r != "object" || r == null ? r : Yg(r) ? r.map(H3) : gs({}, r);
}
function Yie(r, e, i, n, s, a, o, l, u) {
  var c, h, d, p, f, m, y, v = i.props, g = e.props, _ = e.type;
  if (_ == "svg" ? s = "http://www.w3.org/2000/svg" : _ == "math" ? s = "http://www.w3.org/1998/Math/MathML" : s || (s = "http://www.w3.org/1999/xhtml"), a != null) {
    for (c = 0; c < a.length; c++) if ((f = a[c]) && "setAttribute" in f == !!_ && (_ ? f.localName == _ : f.nodeType == 3)) {
      r = f, a[c] = null;
      break;
    }
  }
  if (r == null) {
    if (_ == null) return document.createTextNode(g);
    r = document.createElementNS(s, _, g.is && g), l && (mi.__m && mi.__m(e, a), l = !1), a = null;
  }
  if (_ === null) v === g || l && r.data === g || (r.data = g);
  else {
    if (a = a && sp.call(r.childNodes), v = i.props || Nd, !l && a != null) for (v = {}, c = 0; c < r.attributes.length; c++) v[(f = r.attributes[c]).name] = f.value;
    for (c in v) if (f = v[c], c != "children") {
      if (c == "dangerouslySetInnerHTML") d = f;
      else if (!(c in g)) {
        if (c == "value" && "defaultValue" in g || c == "checked" && "defaultChecked" in g) continue;
        Of(r, c, null, f, s);
      }
    }
    for (c in g) f = g[c], c == "children" ? p = f : c == "dangerouslySetInnerHTML" ? h = f : c == "value" ? m = f : c == "checked" ? y = f : l && typeof f != "function" || v[c] === f || Of(r, c, f, v[c], s);
    if (h) l || d && (h.__html === d.__html || h.__html === r.innerHTML) || (r.innerHTML = h.__html), e.__k = [];
    else if (d && (r.innerHTML = ""), j3(e.type === "template" ? r.content : r, Yg(p) ? p : [p], e, i, n, _ == "foreignObject" ? "http://www.w3.org/1999/xhtml" : s, a, o, a ? a[0] : i.__k && Rc(i, 0), l, u), a != null) for (c = a.length; c--; ) nT(a[c]);
    l || (c = "value", _ == "progress" && m == null ? r.removeAttribute("value") : m !== void 0 && (m !== r[c] || _ == "progress" && !m || _ == "option" && m !== v[c]) && Of(r, c, m, v[c], s), c = "checked", y !== void 0 && y !== r[c] && Of(r, c, y, v[c], s));
  }
  return r;
}
function aT(r, e, i) {
  try {
    if (typeof r == "function") {
      var n = typeof r.__u == "function";
      n && r.__u(), n && e == null || (r.__u = r(e));
    } else r.current = e;
  } catch (s) {
    mi.__e(s, i);
  }
}
function W3(r, e, i) {
  var n, s;
  if (mi.unmount && mi.unmount(r), (n = r.ref) && (n.current && n.current !== r.__e || aT(n, null, e)), (n = r.__c) != null) {
    if (n.componentWillUnmount) try {
      n.componentWillUnmount();
    } catch (a) {
      mi.__e(a, e);
    }
    n.base = n.__P = null;
  }
  if (n = r.__k) for (s = 0; s < n.length; s++) n[s] && W3(n[s], e, i || typeof r.type != "function");
  i || nT(r.__e), r.__c = r.__ = r.__e = void 0;
}
function Kie(r, e, i) {
  return this.constructor(r, i);
}
function Zie(r, e, i) {
  var n, s, a, o;
  e == document && (e = document.documentElement), mi.__ && mi.__(r, e), s = (n = !1) ? null : e.__k, a = [], o = [], sT(e, r = e.__k = qie(Kg, null, [r]), s || Nd, Nd, e.namespaceURI, s ? null : e.firstChild ? sp.call(e.childNodes) : null, a, s ? s.__e : e.firstChild, n, o), G3(a, r, o);
}
function q3(r, e, i) {
  var n, s, a, o, l = gs({}, r.props);
  for (a in r.type && r.type.defaultProps && (o = r.type.defaultProps), e) a == "key" ? n = e[a] : a == "ref" ? s = e[a] : l[a] = e[a] === void 0 && o !== void 0 ? o[a] : e[a];
  return arguments.length > 2 && (l.children = arguments.length > 3 ? sp.call(arguments, 2) : i), ad(r.type, l, n || r.key, s || r.ref, null);
}
sp = B3.slice, mi = { __e: function(r, e, i, n) {
  for (var s, a, o; e = e.__; ) if ((s = e.__c) && !s.__) try {
    if ((a = s.constructor) && a.getDerivedStateFromError != null && (s.setState(a.getDerivedStateFromError(r)), o = s.__d), s.componentDidCatch != null && (s.componentDidCatch(r, n || {}), o = s.__d), o) return s.__E = s;
  } catch (l) {
    r = l;
  }
  throw r;
} }, D3 = 0, L3 = function(r) {
  return r != null && r.constructor == null;
}, cm.prototype.setState = function(r, e) {
  var i;
  i = this.__s != null && this.__s !== this.state ? this.__s : this.__s = gs({}, this.state), typeof r == "function" && (r = r(gs({}, i), this.props)), r && gs(i, r), r != null && this.__v && (e && this._sb.push(e), IA(this));
}, cm.prototype.forceUpdate = function(r) {
  this.__v && (this.__e = !0, r && this.__h.push(r), IA(this));
}, cm.prototype.render = Kg, el = [], k3 = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, U3 = function(r, e) {
  return r.__v.__b - e.__v.__b;
}, Jm.__r = 0, F3 = /(PointerCapture)$|Capture$/i, rT = 0, Wx = DA(!1), qx = DA(!0);
function LA(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Qie(r) {
  if (Array.isArray(r)) return r;
}
function Jie(r, e, i) {
  return (e = sre(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function ere(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function tre() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function kA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function ire(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? kA(Object(i), !0).forEach(function(n) {
      Jie(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : kA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function rre(r, e) {
  return Qie(r) || ere(r, e) || are(r, e) || tre();
}
function nre(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function sre(r) {
  var e = nre(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function eg(r) {
  "@babel/helpers - typeof";
  return eg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, eg(r);
}
function are(r, e) {
  if (r) {
    if (typeof r == "string") return LA(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? LA(r, e) : void 0;
  }
}
var Xx = function(r) {
  if (eg(r) !== "object") return r;
  var e = q3(r);
  if (e.props) {
    var i;
    e.props = ire({}, e.props), e != null && (i = e.props) !== null && i !== void 0 && i.children && (e.props.children = Array.isArray(e.props.children) ? e.props.children.map(Xx) : Xx(e.props.children));
  }
  return e;
}, ore = function(r) {
  return L3(q3(r));
}, lre = function(r, e) {
  delete e.__k, Zie(Xx(r), e);
};
function ure(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var cre = `.float-tooltip-kap {
  position: absolute;
  width: max-content; /* prevent shrinking near right edge */
  max-width: max(50%, 150px);
  padding: 3px 5px;
  border-radius: 3px;
  font: 12px sans-serif;
  color: #eee;
  background: rgba(0,0,0,0.6);
  pointer-events: none;
}
`;
ure(cre);
var X3 = Pl({
  props: {
    content: {
      default: !1
    },
    offsetX: {
      triggerUpdate: !1
    },
    // null or number
    offsetY: {
      triggerUpdate: !1
    }
    // null or number
  },
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.style, s = n === void 0 ? {} : n, a = !!r && eg(r) === "object" && !!r.node && typeof r.node == "function", o = vn(a ? r.node() : r);
    o.style("position") === "static" && o.style("position", "relative"), e.tooltipEl = o.append("div").attr("class", "float-tooltip-kap"), Object.entries(s).forEach(function(u) {
      var c = rre(u, 2), h = c[0], d = c[1];
      return e.tooltipEl.style(h, d);
    }), e.tooltipEl.style("left", "-10000px").style("display", "none");
    var l = "tooltip-".concat(Math.round(Math.random() * 1e12));
    e.mouseInside = !1, o.on("mousemove.".concat(l), function(u) {
      e.mouseInside = !0;
      var c = as(u), h = o.node(), d = h.offsetWidth, p = h.offsetHeight, f = [e.offsetX === null || e.offsetX === void 0 ? "-".concat(c[0] / d * 100, "%") : typeof e.offsetX == "number" ? "calc(-50% + ".concat(e.offsetX, "px)") : e.offsetX, e.offsetY === null || e.offsetY === void 0 ? p > 130 && p - c[1] < 100 ? "calc(-100% - 6px)" : "21px" : typeof e.offsetY == "number" ? e.offsetY < 0 ? "calc(-100% - ".concat(Math.abs(e.offsetY), "px)") : "".concat(e.offsetY, "px") : e.offsetY];
      e.tooltipEl.style("left", c[0] + "px").style("top", c[1] + "px").style("transform", "translate(".concat(f.join(","), ")")), e.content && e.tooltipEl.style("display", "inline");
    }), o.on("mouseover.".concat(l), function() {
      e.mouseInside = !0, e.content && e.tooltipEl.style("display", "inline");
    }), o.on("mouseout.".concat(l), function() {
      e.mouseInside = !1, e.tooltipEl.style("display", "none");
    });
  },
  update: function(r) {
    r.tooltipEl.style("display", r.content && r.mouseInside ? "inline" : "none"), r.content ? r.content instanceof HTMLElement ? (r.tooltipEl.text(""), r.tooltipEl.append(function() {
      return r.content;
    })) : typeof r.content == "string" ? r.tooltipEl.html(r.content) : ore(r.content) ? (r.tooltipEl.text(""), lre(r.content, r.tooltipEl.node())) : (r.tooltipEl.style("display", "none"), console.warn("Tooltip content is invalid, skipping.", r.content, r.content.toString())) : r.tooltipEl.text("");
  }
});
function hre(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var dre = `.scene-nav-info {
  position: absolute;
  bottom: 5px;
  width: 100%;
  text-align: center;
  color: slategrey;
  opacity: 0.7;
  font-size: 10px;
  font-family: sans-serif;
  pointer-events: none;
  user-select: none;
}

.scene-container canvas:focus {
  outline: none;
}`;
hre(dre);
function $x(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function pre(r) {
  if (Array.isArray(r)) return r;
}
function fre(r) {
  if (Array.isArray(r)) return $x(r);
}
function mre(r, e, i) {
  return (e = Tre(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function gre(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function yre(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function vre() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function bre() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function xre(r, e) {
  return pre(r) || yre(r, e) || $3(r, e) || vre();
}
function zo(r) {
  return fre(r) || gre(r) || $3(r) || bre();
}
function _re(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Tre(r) {
  var e = _re(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function $3(r, e) {
  if (r) {
    if (typeof r == "string") return $x(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? $x(r, e) : void 0;
  }
}
var pi = window.THREE ? window.THREE : {
  WebGLRenderer: Ij,
  Scene: Oj,
  PerspectiveCamera: yn,
  Raycaster: OR,
  SRGBColorSpace: nn,
  TextureLoader: rV,
  Vector2: ke,
  Vector3: X,
  Box3: Rl,
  Color: Ut,
  Mesh: Lr,
  SphereGeometry: RR,
  MeshBasicMaterial: wg,
  BackSide: Mr,
  Clock: IR
}, Y3 = Pl({
  props: {
    width: {
      default: window.innerWidth,
      onChange: function(r, e, i) {
        isNaN(r) && (e.width = i);
      }
    },
    height: {
      default: window.innerHeight,
      onChange: function(r, e, i) {
        isNaN(r) && (e.height = i);
      }
    },
    viewOffset: {
      default: [0, 0]
    },
    backgroundColor: {
      default: "#000011"
    },
    backgroundImageUrl: {},
    onBackgroundImageLoaded: {},
    showNavInfo: {
      default: !0
    },
    skyRadius: {
      default: 5e4
    },
    objects: {
      default: []
    },
    lights: {
      default: []
    },
    enablePointerInteraction: {
      default: !0,
      onChange: function(r, e) {
        e.hoverObj = null, e.tooltip && e.tooltip.content(null);
      },
      triggerUpdate: !1
    },
    lineHoverPrecision: {
      default: 1,
      triggerUpdate: !1
    },
    pointsHoverPrecision: {
      default: 1,
      triggerUpdate: !1
    },
    hoverOrderComparator: {
      triggerUpdate: !1
    },
    // keep existing order by default
    hoverFilter: {
      default: function() {
        return !0;
      },
      triggerUpdate: !1
    },
    // exclude objects from interaction
    tooltipContent: {
      triggerUpdate: !1
    },
    hoverDuringDrag: {
      default: !1,
      triggerUpdate: !1
    },
    clickAfterDrag: {
      default: !1,
      triggerUpdate: !1
    },
    onHover: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onClick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onRightClick: {
      triggerUpdate: !1
    }
  },
  methods: {
    tick: function(r) {
      if (r.initialised) {
        if (r.controls.update && r.controls.update(Math.min(1, r.clock.getDelta())), r.postProcessingComposer ? r.postProcessingComposer.render() : r.renderer.render(r.scene, r.camera), r.extraRenderers.forEach(function(s) {
          return s.render(r.scene, r.camera);
        }), r.enablePointerInteraction) {
          var e = null;
          if (r.hoverDuringDrag || !r.isPointerDragging) {
            var i = this.intersectingObjects(r.pointerPos.x, r.pointerPos.y);
            r.hoverOrderComparator && i.sort(function(s, a) {
              return r.hoverOrderComparator(s.object, a.object);
            });
            var n = i.find(function(s) {
              return r.hoverFilter(s.object);
            }) || null;
            e = n ? n.object : null, r.intersection = n || null;
          }
          e !== r.hoverObj && (r.onHover(e, r.hoverObj, r.intersection), r.tooltip.content(e && et(r.tooltipContent)(e, r.intersection) || null), r.hoverObj = e);
        }
        r.tweenGroup.update();
      }
      return this;
    },
    getPointerPos: function(r) {
      var e = r.pointerPos, i = e.x, n = e.y;
      return {
        x: i,
        y: n
      };
    },
    cameraPosition: function(r, e, i, n) {
      var s = r.camera;
      if (e && r.initialised) {
        var a = e, o = i || {
          x: 0,
          y: 0,
          z: 0
        };
        if (!n)
          c(a), h(o);
        else {
          var l = Object.assign({}, s.position), u = d();
          r.tweenGroup.add(new Zm(l).to(a, n).easing(va.Quadratic.Out).onUpdate(c).start()), r.tweenGroup.add(new Zm(u).to(o, n / 3).easing(va.Quadratic.Out).onUpdate(h).start());
        }
        return this;
      }
      return Object.assign({}, s.position, {
        lookAt: d()
      });
      function c(p) {
        var f = p.x, m = p.y, y = p.z;
        f !== void 0 && (s.position.x = f), m !== void 0 && (s.position.y = m), y !== void 0 && (s.position.z = y);
      }
      function h(p) {
        var f = new pi.Vector3(p.x, p.y, p.z);
        r.controls.target ? r.controls.target = f : s.lookAt(f);
      }
      function d() {
        return Object.assign(new pi.Vector3(0, 0, -1e3).applyQuaternion(s.quaternion).add(s.position));
      }
    },
    zoomToFit: function(r) {
      for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, n = arguments.length, s = new Array(n > 3 ? n - 3 : 0), a = 3; a < n; a++)
        s[a - 3] = arguments[a];
      return this.fitToBbox(this.getBbox.apply(this, s), e, i);
    },
    fitToBbox: function(r, e) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10, s = r.camera;
      if (e) {
        var a = new pi.Vector3(0, 0, 0), o = Math.max.apply(Math, zo(Object.entries(e).map(function(p) {
          var f = xre(p, 2), m = f[0], y = f[1];
          return Math.max.apply(Math, zo(y.map(function(v) {
            return Math.abs(a[m] - v);
          })));
        }))) * 2, l = (1 - n * 2 / r.height) * s.fov, u = o / Math.atan(l * Math.PI / 180), c = u / s.aspect, h = Math.max(u, c);
        if (h > 0) {
          var d = a.clone().sub(s.position).normalize().multiplyScalar(-h);
          this.cameraPosition(d, a, i);
        }
      }
      return this;
    },
    getBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      }, i = new pi.Box3(new pi.Vector3(0, 0, 0), new pi.Vector3(0, 0, 0)), n = r.objects.filter(e);
      return n.length ? (n.forEach(function(s) {
        return i.expandByObject(s);
      }), Object.assign.apply(Object, zo(["x", "y", "z"].map(function(s) {
        return mre({}, s, [i.min[s], i.max[s]]);
      })))) : null;
    },
    getScreenCoords: function(r, e, i, n) {
      var s = new pi.Vector3(e, i, n);
      return s.project(this.camera()), {
        // align relative pos to canvas dimensions
        x: (s.x + 1) * r.width / 2,
        y: -(s.y - 1) * r.height / 2
      };
    },
    getSceneCoords: function(r, e, i) {
      var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s = new pi.Vector2(e / r.width * 2 - 1, -(i / r.height) * 2 + 1), a = new pi.Raycaster();
      return a.setFromCamera(s, r.camera), Object.assign({}, a.ray.at(n, new pi.Vector3()));
    },
    intersectingObjects: function(r, e, i) {
      var n = new pi.Vector2(e / r.width * 2 - 1, -(i / r.height) * 2 + 1), s = new pi.Raycaster();
      return s.params.Line.threshold = r.lineHoverPrecision, s.params.Points.threshold = r.pointsHoverPrecision, s.setFromCamera(n, r.camera), s.intersectObjects(r.objects, !0);
    },
    renderer: function(r) {
      return r.renderer;
    },
    scene: function(r) {
      return r.scene;
    },
    camera: function(r) {
      return r.camera;
    },
    postProcessingComposer: function(r) {
      return r.postProcessingComposer;
    },
    controls: function(r) {
      return r.controls;
    },
    tbControls: function(r) {
      return r.controls;
    }
    // to be deprecated
  },
  stateInit: function() {
    return {
      scene: new pi.Scene(),
      camera: new pi.PerspectiveCamera(),
      clock: new pi.Clock(),
      tweenGroup: new eT()
    };
  },
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.controlType, s = n === void 0 ? "trackball" : n, a = i.useWebGPU, o = a === void 0 ? !1 : a, l = i.rendererConfig, u = l === void 0 ? {} : l, c = i.extraRenderers, h = c === void 0 ? [] : c, d = i.waitForLoadComplete, p = d === void 0 ? !0 : d;
    r.innerHTML = "", r.appendChild(e.container = document.createElement("div")), e.container.className = "scene-container", e.container.style.position = "relative", e.container.appendChild(e.navInfo = document.createElement("div")), e.navInfo.className = "scene-nav-info", e.navInfo.textContent = {
      orbit: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      trackball: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      fly: "WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw"
    }[s] || "", e.navInfo.style.display = e.showNavInfo ? null : "none", e.tooltip = new X3(e.container), e.pointerPos = new pi.Vector2(), e.pointerPos.x = -2, e.pointerPos.y = -2, ["pointermove", "pointerdown"].forEach(function(f) {
      return e.container.addEventListener(f, function(m) {
        if (f === "pointerdown" && (e.isPointerPressed = !0), !e.isPointerDragging && m.type === "pointermove" && (m.pressure > 0 || e.isPointerPressed) && (m.pointerType !== "touch" || m.movementX === void 0 || [m.movementX, m.movementY].some(function(g) {
          return Math.abs(g) > 1;
        })) && (e.isPointerDragging = !0), e.enablePointerInteraction) {
          var y = v(e.container);
          e.pointerPos.x = m.pageX - y.left, e.pointerPos.y = m.pageY - y.top;
        }
        function v(g) {
          var _ = g.getBoundingClientRect(), x = window.pageXOffset || document.documentElement.scrollLeft, b = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: _.top + b,
            left: _.left + x
          };
        }
      }, {
        passive: !0
      });
    }), e.container.addEventListener("pointerup", function(f) {
      e.isPointerPressed = !1, !(e.isPointerDragging && (e.isPointerDragging = !1, !e.clickAfterDrag)) && requestAnimationFrame(function() {
        f.button === 0 && e.onClick(e.hoverObj || null, f, e.intersection), f.button === 2 && e.onRightClick && e.onRightClick(e.hoverObj || null, f, e.intersection);
      });
    }, {
      passive: !0,
      capture: !0
    }), e.container.addEventListener("contextmenu", function(f) {
      e.onRightClick && f.preventDefault();
    }), e.renderer = new (o ? PJ : pi.WebGLRenderer)(Object.assign({
      antialias: !0,
      alpha: !0
    }, u)), e.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio)), e.container.appendChild(e.renderer.domElement), e.extraRenderers = h, e.extraRenderers.forEach(function(f) {
      f.domElement.style.position = "absolute", f.domElement.style.top = "0px", f.domElement.style.pointerEvents = "none", e.container.appendChild(f.domElement);
    }), e.postProcessingComposer = new wee(e.renderer), e.postProcessingComposer.addPass(new Eee(e.scene, e.camera)), e.controls = new {
      trackball: OJ,
      orbit: YJ,
      fly: uee
    }[s](e.camera, e.renderer.domElement), s === "fly" && (e.controls.movementSpeed = 300, e.controls.rollSpeed = Math.PI / 6, e.controls.dragToLook = !0), (s === "trackball" || s === "orbit") && (e.controls.minDistance = 0.1, e.controls.maxDistance = e.skyRadius, e.controls.addEventListener("start", function() {
      e.controlsEngaged = !0;
    }), e.controls.addEventListener("change", function() {
      e.controlsEngaged && (e.controlsDragging = !0);
    }), e.controls.addEventListener("end", function() {
      e.controlsEngaged = !1, e.controlsDragging = !1;
    })), [e.renderer, e.postProcessingComposer].concat(zo(e.extraRenderers)).forEach(function(f) {
      return f.setSize(e.width, e.height);
    }), e.camera.aspect = e.width / e.height, e.camera.updateProjectionMatrix(), e.camera.position.z = 1e3, e.scene.add(e.skysphere = new pi.Mesh()), e.skysphere.visible = !1, e.loadComplete = e.scene.visible = !p, window.scene = e.scene;
  },
  update: function(r, e) {
    if (r.width && r.height && (e.hasOwnProperty("width") || e.hasOwnProperty("height"))) {
      var i, n = r.width, s = r.height;
      r.container.style.width = "".concat(n, "px"), r.container.style.height = "".concat(s, "px"), [r.renderer, r.postProcessingComposer].concat(zo(r.extraRenderers)).forEach(function(p) {
        return p.setSize(n, s);
      }), r.camera.aspect = n / s;
      var a = r.viewOffset.slice(0, 2);
      a.some(function(p) {
        return p;
      }) && (i = r.camera).setViewOffset.apply(i, [n, s].concat(zo(a), [n, s])), r.camera.updateProjectionMatrix();
    }
    if (e.hasOwnProperty("viewOffset")) {
      var o, l = r.width, u = r.height, c = r.viewOffset.slice(0, 2);
      c.some(function(p) {
        return p;
      }) ? (o = r.camera).setViewOffset.apply(o, [l, u].concat(zo(c), [l, u])) : r.camera.clearViewOffset();
    }
    if (e.hasOwnProperty("skyRadius") && r.skyRadius && (r.controls.hasOwnProperty("maxDistance") && e.skyRadius && (r.controls.maxDistance = Math.min(r.controls.maxDistance, r.skyRadius)), r.camera.far = r.skyRadius * 2.5, r.camera.updateProjectionMatrix(), r.skysphere.geometry = new pi.SphereGeometry(r.skyRadius)), e.hasOwnProperty("backgroundColor")) {
      var h = Ac(r.backgroundColor).alpha;
      h === void 0 && (h = 1), r.renderer.setClearColor(new pi.Color(nte(1, r.backgroundColor)), h);
    }
    e.hasOwnProperty("backgroundImageUrl") && (r.backgroundImageUrl ? new pi.TextureLoader().load(r.backgroundImageUrl, function(p) {
      p.colorSpace = pi.SRGBColorSpace, r.skysphere.material = new pi.MeshBasicMaterial({
        map: p,
        side: pi.BackSide
      }), r.skysphere.visible = !0, r.onBackgroundImageLoaded && setTimeout(r.onBackgroundImageLoaded), !r.loadComplete && d();
    }) : (r.skysphere.visible = !1, r.skysphere.material.map = null, !r.loadComplete && d())), e.hasOwnProperty("showNavInfo") && (r.navInfo.style.display = r.showNavInfo ? null : "none"), e.hasOwnProperty("lights") && ((e.lights || []).forEach(function(p) {
      return r.scene.remove(p);
    }), r.lights.forEach(function(p) {
      return r.scene.add(p);
    })), e.hasOwnProperty("objects") && ((e.objects || []).forEach(function(p) {
      return r.scene.remove(p);
    }), r.objects.forEach(function(p) {
      return r.scene.add(p);
    }));
    function d() {
      r.loadComplete = r.scene.visible = !0;
    }
  }
});
function Sre(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var wre = `.graph-info-msg {
  top: 50%;
  width: 100%;
  text-align: center;
  color: lavender;
  opacity: 0.7;
  font-size: 22px;
  position: absolute;
  font-family: Sans-serif;
}

.scene-container .clickable {
  cursor: pointer;
}

.scene-container .grabbable {
  cursor: move;
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

.scene-container .grabbable:active {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
}`;
Sre(wre);
function Yx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Ere(r) {
  if (Array.isArray(r)) return Yx(r);
}
function ap(r, e, i) {
  return (e = Rre(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function Mre(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function Are() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function UA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function Df(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? UA(Object(i), !0).forEach(function(n) {
      ap(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : UA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function Zg(r) {
  return Ere(r) || Mre(r) || Nre(r) || Are();
}
function Cre(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Rre(r) {
  var e = Cre(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Nre(r, e) {
  if (r) {
    if (typeof r == "string") return Yx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Yx(r, e) : void 0;
  }
}
function K3(r, e) {
  var i = new e();
  return i._destructor && i._destructor(), {
    linkProp: function(n) {
      return {
        default: i[n](),
        onChange: function(s, a) {
          a[r][n](s);
        },
        triggerUpdate: !1
      };
    },
    linkMethod: function(n) {
      return function(s) {
        for (var a = s[r], o = arguments.length, l = new Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)
          l[u - 1] = arguments[u];
        var c = a[n].apply(a, l);
        return c === a ? this : c;
      };
    }
  };
}
var Cv = window.THREE ? window.THREE : {
  AmbientLight: oV,
  DirectionalLight: aV,
  REVISION: bg
}, Pre = 170, Z3 = K3("forceGraph", Ou), Ire = Object.assign.apply(Object, Zg(["jsonUrl", "graphData", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeVisibility", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "forceEngine", "d3AlphaDecay", "d3VelocityDecay", "d3AlphaMin", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(r) {
  return ap({}, r, Z3.linkProp(r));
}))), Ore = Object.assign.apply(Object, Zg(["refresh", "getGraphBbox", "d3Force", "d3ReheatSimulation", "emitParticle"].map(function(r) {
  return ap({}, r, Z3.linkMethod(r));
}))), hm = K3("renderObjs", Y3), Dre = Object.assign.apply(Object, Zg(["width", "height", "backgroundColor", "showNavInfo", "enablePointerInteraction"].map(function(r) {
  return ap({}, r, hm.linkProp(r));
}))), Lre = Object.assign.apply(Object, Zg(["lights", "cameraPosition", "postProcessingComposer"].map(function(r) {
  return ap({}, r, hm.linkMethod(r));
})).concat([{
  graph2ScreenCoords: hm.linkMethod("getScreenCoords"),
  screen2GraphCoords: hm.linkMethod("getSceneCoords")
}])), kre = Pl({
  props: Df(Df({
    nodeLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkHoverPrecision: {
      default: 1,
      onChange: function(r, e) {
        return e.renderObjs.lineHoverPrecision(r);
      },
      triggerUpdate: !1
    },
    enableNavigationControls: {
      default: !0,
      onChange: function(r, e) {
        var i = e.renderObjs.controls();
        i && (i.enabled = r, r && i.domElement && i.domElement.dispatchEvent(new PointerEvent("pointerup")));
      },
      triggerUpdate: !1
    },
    enableNodeDrag: {
      default: !0,
      triggerUpdate: !1
    },
    onNodeDrag: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeDragEnd: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeClick: {
      triggerUpdate: !1
    },
    onNodeRightClick: {
      triggerUpdate: !1
    },
    onNodeHover: {
      triggerUpdate: !1
    },
    onLinkClick: {
      triggerUpdate: !1
    },
    onLinkRightClick: {
      triggerUpdate: !1
    },
    onLinkHover: {
      triggerUpdate: !1
    },
    onBackgroundClick: {
      triggerUpdate: !1
    },
    onBackgroundRightClick: {
      triggerUpdate: !1
    }
  }, Ire), Dre),
  methods: Df(Df({
    zoomToFit: function(r, e, i) {
      for (var n, s = arguments.length, a = new Array(s > 3 ? s - 3 : 0), o = 3; o < s; o++)
        a[o - 3] = arguments[o];
      return r.renderObjs.fitToBbox((n = r.forceGraph).getGraphBbox.apply(n, a), e, i), this;
    },
    pauseAnimation: function(r) {
      return r.animationFrameRequestId !== null && (cancelAnimationFrame(r.animationFrameRequestId), r.animationFrameRequestId = null), this;
    },
    resumeAnimation: function(r) {
      return r.animationFrameRequestId === null && this._animationCycle(), this;
    },
    _animationCycle: function(r) {
      r.enablePointerInteraction && (this.renderer().domElement.style.cursor = null), r.forceGraph.tickFrame(), r.renderObjs.tick(), r.animationFrameRequestId = requestAnimationFrame(this._animationCycle);
    },
    scene: function(r) {
      return r.renderObjs.scene();
    },
    // Expose scene
    camera: function(r) {
      return r.renderObjs.camera();
    },
    // Expose camera
    renderer: function(r) {
      return r.renderObjs.renderer();
    },
    // Expose renderer
    controls: function(r) {
      return r.renderObjs.controls();
    },
    // Expose controls
    tbControls: function(r) {
      return r.renderObjs.tbControls();
    },
    // To be deprecated
    _destructor: function() {
      this.pauseAnimation(), this.graphData({
        nodes: [],
        links: []
      });
    }
  }, Ore), Lre),
  stateInit: function(r) {
    var e = r.controlType, i = r.rendererConfig, n = r.extraRenderers, s = new Ou();
    return {
      forceGraph: s,
      renderObjs: Y3({
        controlType: e,
        rendererConfig: i,
        extraRenderers: n
      }).objects([s]).lights([new Cv.AmbientLight(13421772, Math.PI), new Cv.DirectionalLight(16777215, 0.6 * Math.PI)])
    };
  },
  init: function(r, e) {
    r.innerHTML = "", r.appendChild(e.container = document.createElement("div")), e.container.style.position = "relative";
    var i = document.createElement("div");
    e.container.appendChild(i), e.renderObjs(i);
    var n = e.renderObjs.camera(), s = e.renderObjs.renderer(), a = e.renderObjs.controls();
    a.enabled = !!e.enableNavigationControls, e.lastSetCameraZ = n.position.z;
    var o;
    e.container.appendChild(o = document.createElement("div")), o.className = "graph-info-msg", o.textContent = "", e.forceGraph.onLoading(function() {
      o.textContent = "Loading...";
    }).onFinishLoading(function() {
      o.textContent = "";
    }).onUpdate(function() {
      e.graphData = e.forceGraph.graphData(), n.position.x === 0 && n.position.y === 0 && n.position.z === e.lastSetCameraZ && e.graphData.nodes.length && (n.lookAt(e.forceGraph.position), e.lastSetCameraZ = n.position.z = Math.cbrt(e.graphData.nodes.length) * Pre);
    }).onFinishUpdate(function() {
      if (e._dragControls) {
        var l = e.graphData.nodes.find(function(c) {
          return c.__initialFixedPos && !c.__disposeControlsAfterDrag;
        });
        l ? l.__disposeControlsAfterDrag = !0 : e._dragControls.dispose(), e._dragControls = void 0;
      }
      if (e.enableNodeDrag && e.enablePointerInteraction && e.forceEngine === "d3") {
        var u = e._dragControls = new N9(e.graphData.nodes.map(function(c) {
          return c.__threeObj;
        }).filter(function(c) {
          return c;
        }), n, s.domElement);
        u.addEventListener("dragstart", function(c) {
          var h = Bs(c.object);
          if (h) {
            a.enabled = !1, c.object.__initialPos = c.object.position.clone(), c.object.__prevPos = c.object.position.clone();
            var d = h.__data;
            !d.__initialFixedPos && (d.__initialFixedPos = {
              fx: d.fx,
              fy: d.fy,
              fz: d.fz
            }), !d.__initialPos && (d.__initialPos = {
              x: d.x,
              y: d.y,
              z: d.z
            }), ["x", "y", "z"].forEach(function(p) {
              return d["f".concat(p)] = d[p];
            }), s.domElement.classList.add("grabbable");
          }
        }), u.addEventListener("drag", function(c) {
          var h = Bs(c.object);
          if (h) {
            if (!c.object.hasOwnProperty("__graphObjType")) {
              var d = c.object.__initialPos, p = c.object.__prevPos, f = c.object.position;
              h.position.add(f.clone().sub(p)), p.copy(f), f.copy(d);
            }
            var m = h.__data, y = h.position, v = {
              x: y.x - m.x,
              y: y.y - m.y,
              z: y.z - m.z
            };
            ["x", "y", "z"].forEach(function(g) {
              return m["f".concat(g)] = m[g] = y[g];
            }), e.forceGraph.d3AlphaTarget(0.3).resetCountdown(), m.__dragged = !0, e.onNodeDrag(m, v);
          }
        }), u.addEventListener("dragend", function(c) {
          var h = Bs(c.object);
          if (h) {
            delete c.object.__initialPos, delete c.object.__prevPos;
            var d = h.__data;
            d.__disposeControlsAfterDrag && (u.dispose(), delete d.__disposeControlsAfterDrag);
            var p = d.__initialFixedPos, f = d.__initialPos, m = {
              x: f.x - d.x,
              y: f.y - d.y,
              z: f.z - d.z
            };
            p && (["x", "y", "z"].forEach(function(y) {
              var v = "f".concat(y);
              p[v] === void 0 && delete d[v];
            }), delete d.__initialFixedPos, delete d.__initialPos, d.__dragged && (delete d.__dragged, e.onNodeDragEnd(d, m))), e.forceGraph.d3AlphaTarget(0).resetCountdown(), e.enableNavigationControls && (a.enabled = !0, a.domElement && a.domElement.ownerDocument && a.domElement.ownerDocument.dispatchEvent(
              // simulate mouseup to ensure the controls don't take over after dragend
              new PointerEvent("pointerup", {
                pointerType: "touch"
              })
            )), s.domElement.classList.remove("grabbable");
          }
        });
      }
    }), Cv.REVISION < 155 && (e.renderObjs.renderer().useLegacyLights = !1), e.renderObjs.hoverOrderComparator(function(l, u) {
      var c = Bs(l);
      if (!c) return 1;
      var h = Bs(u);
      if (!h) return -1;
      var d = function(p) {
        return p.__graphObjType === "node";
      };
      return d(h) - d(c);
    }).tooltipContent(function(l) {
      var u = Bs(l);
      return u && et(e["".concat(u.__graphObjType, "Label")])(u.__data) || "";
    }).hoverDuringDrag(!1).onHover(function(l) {
      var u = Bs(l);
      if (u !== e.hoverObj) {
        var c = e.hoverObj ? e.hoverObj.__graphObjType : null, h = e.hoverObj ? e.hoverObj.__data : null, d = u ? u.__graphObjType : null, p = u ? u.__data : null;
        if (c && c !== d) {
          var f = e["on".concat(c === "node" ? "Node" : "Link", "Hover")];
          f && f(null, h);
        }
        if (d) {
          var m = e["on".concat(d === "node" ? "Node" : "Link", "Hover")];
          m && m(p, c === d ? h : null);
        }
        s.domElement.classList[u && e["on".concat(d === "node" ? "Node" : "Link", "Click")] || !u && e.onBackgroundClick ? "add" : "remove"]("clickable"), e.hoverObj = u;
      }
    }).clickAfterDrag(!1).onClick(function(l, u) {
      var c = Bs(l);
      if (c) {
        var h = e["on".concat(c.__graphObjType === "node" ? "Node" : "Link", "Click")];
        h && h(c.__data, u);
      } else
        e.onBackgroundClick && e.onBackgroundClick(u);
    }).onRightClick(function(l, u) {
      var c = Bs(l);
      if (c) {
        var h = e["on".concat(c.__graphObjType === "node" ? "Node" : "Link", "RightClick")];
        h && h(c.__data, u);
      } else
        e.onBackgroundRightClick && e.onBackgroundRightClick(u);
    }), this._animationCycle();
  }
});
function Bs(r) {
  for (var e = r; e && !e.hasOwnProperty("__graphObjType"); )
    e = e.parent;
  return e;
}
const Ure = { passive: !1 }, Pd = { capture: !0, passive: !1 };
function Rv(r) {
  r.stopImmediatePropagation();
}
function tc(r) {
  r.preventDefault(), r.stopImmediatePropagation();
}
function Q3(r) {
  var e = r.document.documentElement, i = vn(r).on("dragstart.drag", tc, Pd);
  "onselectstart" in e ? i.on("selectstart.drag", tc, Pd) : (e.__noselect = e.style.MozUserSelect, e.style.MozUserSelect = "none");
}
function J3(r, e) {
  var i = r.document.documentElement, n = vn(r).on("dragstart.drag", null);
  e && (n.on("click.drag", tc, Pd), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in i ? n.on("selectstart.drag", null) : (i.style.MozUserSelect = i.__noselect, delete i.__noselect);
}
const Lf = (r) => () => r;
function Kx(r, {
  sourceEvent: e,
  subject: i,
  target: n,
  identifier: s,
  active: a,
  x: o,
  y: l,
  dx: u,
  dy: c,
  dispatch: h
}) {
  Object.defineProperties(this, {
    type: { value: r, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    subject: { value: i, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    identifier: { value: s, enumerable: !0, configurable: !0 },
    active: { value: a, enumerable: !0, configurable: !0 },
    x: { value: o, enumerable: !0, configurable: !0 },
    y: { value: l, enumerable: !0, configurable: !0 },
    dx: { value: u, enumerable: !0, configurable: !0 },
    dy: { value: c, enumerable: !0, configurable: !0 },
    _: { value: h }
  });
}
Kx.prototype.on = function() {
  var r = this._.on.apply(this._, arguments);
  return r === this._ ? this : r;
};
function Fre(r) {
  return !r.ctrlKey && !r.button;
}
function Bre() {
  return this.parentNode;
}
function zre(r, e) {
  return e ?? { x: r.x, y: r.y };
}
function jre() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Vre() {
  var r = Fre, e = Bre, i = zre, n = jre, s = {}, a = Wd("start", "drag", "end"), o = 0, l, u, c, h, d = 0;
  function p(b) {
    b.on("mousedown.drag", f).filter(n).on("touchstart.drag", v).on("touchmove.drag", g, Ure).on("touchend.drag touchcancel.drag", _).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function f(b, T) {
    if (!(h || !r.call(this, b, T))) {
      var S = x(this, e.call(this, b, T), b, T, "mouse");
      S && (vn(b.view).on("mousemove.drag", m, Pd).on("mouseup.drag", y, Pd), Q3(b.view), Rv(b), c = !1, l = b.clientX, u = b.clientY, S("start", b));
    }
  }
  function m(b) {
    if (tc(b), !c) {
      var T = b.clientX - l, S = b.clientY - u;
      c = T * T + S * S > d;
    }
    s.mouse("drag", b);
  }
  function y(b) {
    vn(b.view).on("mousemove.drag mouseup.drag", null), J3(b.view, c), tc(b), s.mouse("end", b);
  }
  function v(b, T) {
    if (r.call(this, b, T)) {
      var S = b.changedTouches, w = e.call(this, b, T), M = S.length, E, A;
      for (E = 0; E < M; ++E)
        (A = x(this, w, b, T, S[E].identifier, S[E])) && (Rv(b), A("start", b, S[E]));
    }
  }
  function g(b) {
    var T = b.changedTouches, S = T.length, w, M;
    for (w = 0; w < S; ++w)
      (M = s[T[w].identifier]) && (tc(b), M("drag", b, T[w]));
  }
  function _(b) {
    var T = b.changedTouches, S = T.length, w, M;
    for (h && clearTimeout(h), h = setTimeout(function() {
      h = null;
    }, 500), w = 0; w < S; ++w)
      (M = s[T[w].identifier]) && (Rv(b), M("end", b, T[w]));
  }
  function x(b, T, S, w, M, E) {
    var A = a.copy(), N = as(E || S, T), U, k, C;
    if ((C = i.call(b, new Kx("beforestart", {
      sourceEvent: S,
      target: p,
      identifier: M,
      active: o,
      x: N[0],
      y: N[1],
      dx: 0,
      dy: 0,
      dispatch: A
    }), w)) != null)
      return U = C.x - N[0] || 0, k = C.y - N[1] || 0, function I(O, W, V) {
        var Q = N, F;
        switch (O) {
          case "start":
            s[M] = I, F = o++;
            break;
          case "end":
            delete s[M], --o;
          case "drag":
            N = as(V || W, T), F = o;
            break;
        }
        A.call(
          O,
          b,
          new Kx(O, {
            sourceEvent: W,
            subject: C,
            target: p,
            identifier: M,
            active: F,
            x: N[0] + U,
            y: N[1] + k,
            dx: N[0] - Q[0],
            dy: N[1] - Q[1],
            dispatch: A
          }),
          w
        );
      };
  }
  return p.filter = function(b) {
    return arguments.length ? (r = typeof b == "function" ? b : Lf(!!b), p) : r;
  }, p.container = function(b) {
    return arguments.length ? (e = typeof b == "function" ? b : Lf(b), p) : e;
  }, p.subject = function(b) {
    return arguments.length ? (i = typeof b == "function" ? b : Lf(b), p) : i;
  }, p.touchable = function(b) {
    return arguments.length ? (n = typeof b == "function" ? b : Lf(!!b), p) : n;
  }, p.on = function() {
    var b = a.on.apply(a, arguments);
    return b === a ? p : b;
  }, p.clickDistance = function(b) {
    return arguments.length ? (d = (b = +b) * b, p) : Math.sqrt(d);
  }, p;
}
var Gre = Wd("start", "end", "cancel", "interrupt"), Hre = [], eO = 0, FA = 1, Zx = 2, dm = 3, BA = 4, Qx = 5, pm = 6;
function Qg(r, e, i, n, s, a) {
  var o = r.__transition;
  if (!o) r.__transition = {};
  else if (i in o) return;
  Wre(r, i, {
    name: e,
    index: n,
    // For context during callback.
    group: s,
    // For context during callback.
    on: Gre,
    tween: Hre,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: eO
  });
}
function oT(r, e) {
  var i = ts(r, e);
  if (i.state > eO) throw new Error("too late; already scheduled");
  return i;
}
function Es(r, e) {
  var i = ts(r, e);
  if (i.state > dm) throw new Error("too late; already running");
  return i;
}
function ts(r, e) {
  var i = r.__transition;
  if (!i || !(i = i[e])) throw new Error("transition not found");
  return i;
}
function Wre(r, e, i) {
  var n = r.__transition, s;
  n[e] = i, i.timer = K_(a, 0, i.time);
  function a(c) {
    i.state = FA, i.timer.restart(o, i.delay, i.time), i.delay <= c && o(c - i.delay);
  }
  function o(c) {
    var h, d, p, f;
    if (i.state !== FA) return u();
    for (h in n)
      if (f = n[h], f.name === i.name) {
        if (f.state === dm) return Gw(o);
        f.state === BA ? (f.state = pm, f.timer.stop(), f.on.call("interrupt", r, r.__data__, f.index, f.group), delete n[h]) : +h < e && (f.state = pm, f.timer.stop(), f.on.call("cancel", r, r.__data__, f.index, f.group), delete n[h]);
      }
    if (Gw(function() {
      i.state === dm && (i.state = BA, i.timer.restart(l, i.delay, i.time), l(c));
    }), i.state = Zx, i.on.call("start", r, r.__data__, i.index, i.group), i.state === Zx) {
      for (i.state = dm, s = new Array(p = i.tween.length), h = 0, d = -1; h < p; ++h)
        (f = i.tween[h].value.call(r, r.__data__, i.index, i.group)) && (s[++d] = f);
      s.length = d + 1;
    }
  }
  function l(c) {
    for (var h = c < i.duration ? i.ease.call(null, c / i.duration) : (i.timer.restart(u), i.state = Qx, 1), d = -1, p = s.length; ++d < p; )
      s[d].call(r, h);
    i.state === Qx && (i.on.call("end", r, r.__data__, i.index, i.group), u());
  }
  function u() {
    i.state = pm, i.timer.stop(), delete n[e];
    for (var c in n) return;
    delete r.__transition;
  }
}
function fm(r, e) {
  var i = r.__transition, n, s, a = !0, o;
  if (i) {
    e = e == null ? null : e + "";
    for (o in i) {
      if ((n = i[o]).name !== e) {
        a = !1;
        continue;
      }
      s = n.state > Zx && n.state < Qx, n.state = pm, n.timer.stop(), n.on.call(s ? "interrupt" : "cancel", r, r.__data__, n.index, n.group), delete i[o];
    }
    a && delete r.__transition;
  }
}
function qre(r) {
  return this.each(function() {
    fm(this, r);
  });
}
function Xre(r, e) {
  var i, n;
  return function() {
    var s = Es(this, r), a = s.tween;
    if (a !== i) {
      n = i = a;
      for (var o = 0, l = n.length; o < l; ++o)
        if (n[o].name === e) {
          n = n.slice(), n.splice(o, 1);
          break;
        }
    }
    s.tween = n;
  };
}
function $re(r, e, i) {
  var n, s;
  if (typeof i != "function") throw new Error();
  return function() {
    var a = Es(this, r), o = a.tween;
    if (o !== n) {
      s = (n = o).slice();
      for (var l = { name: e, value: i }, u = 0, c = s.length; u < c; ++u)
        if (s[u].name === e) {
          s[u] = l;
          break;
        }
      u === c && s.push(l);
    }
    a.tween = s;
  };
}
function Yre(r, e) {
  var i = this._id;
  if (r += "", arguments.length < 2) {
    for (var n = ts(this.node(), i).tween, s = 0, a = n.length, o; s < a; ++s)
      if ((o = n[s]).name === r)
        return o.value;
    return null;
  }
  return this.each((e == null ? Xre : $re)(i, r, e));
}
function lT(r, e, i) {
  var n = r._id;
  return r.each(function() {
    var s = Es(this, n);
    (s.value || (s.value = {}))[e] = i.apply(this, arguments);
  }), function(s) {
    return ts(s, n).value[e];
  };
}
function tO(r, e) {
  var i;
  return (typeof e == "number" ? Ya : e instanceof gd ? fE : (i = gd(e)) ? (e = i, fE) : TH)(r, e);
}
function Kre(r) {
  return function() {
    this.removeAttribute(r);
  };
}
function Zre(r) {
  return function() {
    this.removeAttributeNS(r.space, r.local);
  };
}
function Qre(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = this.getAttribute(r);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function Jre(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = this.getAttributeNS(r.space, r.local);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function ene(r, e, i) {
  var n, s, a;
  return function() {
    var o, l = i(this), u;
    return l == null ? void this.removeAttribute(r) : (o = this.getAttribute(r), u = l + "", o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l)));
  };
}
function tne(r, e, i) {
  var n, s, a;
  return function() {
    var o, l = i(this), u;
    return l == null ? void this.removeAttributeNS(r.space, r.local) : (o = this.getAttributeNS(r.space, r.local), u = l + "", o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l)));
  };
}
function ine(r, e) {
  var i = $g(r), n = i === "transform" ? MH : tO;
  return this.attrTween(r, typeof e == "function" ? (i.local ? tne : ene)(i, n, lT(this, "attr." + r, e)) : e == null ? (i.local ? Zre : Kre)(i) : (i.local ? Jre : Qre)(i, n, e));
}
function rne(r, e) {
  return function(i) {
    this.setAttribute(r, e.call(this, i));
  };
}
function nne(r, e) {
  return function(i) {
    this.setAttributeNS(r.space, r.local, e.call(this, i));
  };
}
function sne(r, e) {
  var i, n;
  function s() {
    var a = e.apply(this, arguments);
    return a !== n && (i = (n = a) && nne(r, a)), i;
  }
  return s._value = e, s;
}
function ane(r, e) {
  var i, n;
  function s() {
    var a = e.apply(this, arguments);
    return a !== n && (i = (n = a) && rne(r, a)), i;
  }
  return s._value = e, s;
}
function one(r, e) {
  var i = "attr." + r;
  if (arguments.length < 2) return (i = this.tween(i)) && i._value;
  if (e == null) return this.tween(i, null);
  if (typeof e != "function") throw new Error();
  var n = $g(r);
  return this.tween(i, (n.local ? sne : ane)(n, e));
}
function lne(r, e) {
  return function() {
    oT(this, r).delay = +e.apply(this, arguments);
  };
}
function une(r, e) {
  return e = +e, function() {
    oT(this, r).delay = e;
  };
}
function cne(r) {
  var e = this._id;
  return arguments.length ? this.each((typeof r == "function" ? lne : une)(e, r)) : ts(this.node(), e).delay;
}
function hne(r, e) {
  return function() {
    Es(this, r).duration = +e.apply(this, arguments);
  };
}
function dne(r, e) {
  return e = +e, function() {
    Es(this, r).duration = e;
  };
}
function pne(r) {
  var e = this._id;
  return arguments.length ? this.each((typeof r == "function" ? hne : dne)(e, r)) : ts(this.node(), e).duration;
}
function fne(r, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    Es(this, r).ease = e;
  };
}
function mne(r) {
  var e = this._id;
  return arguments.length ? this.each(fne(e, r)) : ts(this.node(), e).ease;
}
function gne(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    if (typeof i != "function") throw new Error();
    Es(this, r).ease = i;
  };
}
function yne(r) {
  if (typeof r != "function") throw new Error();
  return this.each(gne(this._id, r));
}
function vne(r) {
  typeof r != "function" && (r = w3(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = [], u, c = 0; c < o; ++c)
      (u = a[c]) && r.call(u, u.__data__, c, a) && l.push(u);
  return new Ta(n, this._parents, this._name, this._id);
}
function bne(r) {
  if (r._id !== this._id) throw new Error();
  for (var e = this._groups, i = r._groups, n = e.length, s = i.length, a = Math.min(n, s), o = new Array(n), l = 0; l < a; ++l)
    for (var u = e[l], c = i[l], h = u.length, d = o[l] = new Array(h), p, f = 0; f < h; ++f)
      (p = u[f] || c[f]) && (d[f] = p);
  for (; l < n; ++l)
    o[l] = e[l];
  return new Ta(o, this._parents, this._name, this._id);
}
function xne(r) {
  return (r + "").trim().split(/^|\s+/).every(function(e) {
    var i = e.indexOf(".");
    return i >= 0 && (e = e.slice(0, i)), !e || e === "start";
  });
}
function _ne(r, e, i) {
  var n, s, a = xne(e) ? oT : Es;
  return function() {
    var o = a(this, r), l = o.on;
    l !== n && (s = (n = l).copy()).on(e, i), o.on = s;
  };
}
function Tne(r, e) {
  var i = this._id;
  return arguments.length < 2 ? ts(this.node(), i).on.on(r) : this.each(_ne(i, r, e));
}
function Sne(r) {
  return function() {
    var e = this.parentNode;
    for (var i in this.__transition) if (+i !== r) return;
    e && e.removeChild(this);
  };
}
function wne() {
  return this.on("end.remove", Sne(this._id));
}
function Ene(r) {
  var e = this._name, i = this._id;
  typeof r != "function" && (r = tT(r));
  for (var n = this._groups, s = n.length, a = new Array(s), o = 0; o < s; ++o)
    for (var l = n[o], u = l.length, c = a[o] = new Array(u), h, d, p = 0; p < u; ++p)
      (h = l[p]) && (d = r.call(h, h.__data__, p, l)) && ("__data__" in h && (d.__data__ = h.__data__), c[p] = d, Qg(c[p], e, i, p, c, ts(h, i)));
  return new Ta(a, this._parents, e, i);
}
function Mne(r) {
  var e = this._name, i = this._id;
  typeof r != "function" && (r = S3(r));
  for (var n = this._groups, s = n.length, a = [], o = [], l = 0; l < s; ++l)
    for (var u = n[l], c = u.length, h, d = 0; d < c; ++d)
      if (h = u[d]) {
        for (var p = r.call(h, h.__data__, d, u), f, m = ts(h, i), y = 0, v = p.length; y < v; ++y)
          (f = p[y]) && Qg(f, e, i, y, p, m);
        a.push(p), o.push(h);
      }
  return new Ta(a, o, e, i);
}
var Ane = np.prototype.constructor;
function Cne() {
  return new Ane(this._groups, this._parents);
}
function Rne(r, e) {
  var i, n, s;
  return function() {
    var a = Cc(this, r), o = (this.style.removeProperty(r), Cc(this, r));
    return a === o ? null : a === i && o === n ? s : s = e(i = a, n = o);
  };
}
function iO(r) {
  return function() {
    this.style.removeProperty(r);
  };
}
function Nne(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = Cc(this, r);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function Pne(r, e, i) {
  var n, s, a;
  return function() {
    var o = Cc(this, r), l = i(this), u = l + "";
    return l == null && (u = l = (this.style.removeProperty(r), Cc(this, r))), o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l));
  };
}
function Ine(r, e) {
  var i, n, s, a = "style." + e, o = "end." + a, l;
  return function() {
    var u = Es(this, r), c = u.on, h = u.value[a] == null ? l || (l = iO(e)) : void 0;
    (c !== i || s !== h) && (n = (i = c).copy()).on(o, s = h), u.on = n;
  };
}
function One(r, e, i) {
  var n = (r += "") == "transform" ? EH : tO;
  return e == null ? this.styleTween(r, Rne(r, n)).on("end.style." + r, iO(r)) : typeof e == "function" ? this.styleTween(r, Pne(r, n, lT(this, "style." + r, e))).each(Ine(this._id, r)) : this.styleTween(r, Nne(r, n, e), i).on("end.style." + r, null);
}
function Dne(r, e, i) {
  return function(n) {
    this.style.setProperty(r, e.call(this, n), i);
  };
}
function Lne(r, e, i) {
  var n, s;
  function a() {
    var o = e.apply(this, arguments);
    return o !== s && (n = (s = o) && Dne(r, o, i)), n;
  }
  return a._value = e, a;
}
function kne(r, e, i) {
  var n = "style." + (r += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  return this.tween(n, Lne(r, e, i ?? ""));
}
function Une(r) {
  return function() {
    this.textContent = r;
  };
}
function Fne(r) {
  return function() {
    var e = r(this);
    this.textContent = e ?? "";
  };
}
function Bne(r) {
  return this.tween("text", typeof r == "function" ? Fne(lT(this, "text", r)) : Une(r == null ? "" : r + ""));
}
function zne(r) {
  return function(e) {
    this.textContent = r.call(this, e);
  };
}
function jne(r) {
  var e, i;
  function n() {
    var s = r.apply(this, arguments);
    return s !== i && (e = (i = s) && zne(s)), e;
  }
  return n._value = r, n;
}
function Vne(r) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (r == null) return this.tween(e, null);
  if (typeof r != "function") throw new Error();
  return this.tween(e, jne(r));
}
function Gne() {
  for (var r = this._name, e = this._id, i = rO(), n = this._groups, s = n.length, a = 0; a < s; ++a)
    for (var o = n[a], l = o.length, u, c = 0; c < l; ++c)
      if (u = o[c]) {
        var h = ts(u, e);
        Qg(u, r, i, c, o, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new Ta(n, this._parents, r, i);
}
function Hne() {
  var r, e, i = this, n = i._id, s = i.size();
  return new Promise(function(a, o) {
    var l = { value: o }, u = { value: function() {
      --s === 0 && a();
    } };
    i.each(function() {
      var c = Es(this, n), h = c.on;
      h !== r && (e = (r = h).copy(), e._.cancel.push(l), e._.interrupt.push(l), e._.end.push(u)), c.on = e;
    }), s === 0 && a();
  });
}
var Wne = 0;
function Ta(r, e, i, n) {
  this._groups = r, this._parents = e, this._name = i, this._id = n;
}
function rO() {
  return ++Wne;
}
var zs = np.prototype;
Ta.prototype = {
  constructor: Ta,
  select: Ene,
  selectAll: Mne,
  selectChild: zs.selectChild,
  selectChildren: zs.selectChildren,
  filter: vne,
  merge: bne,
  selection: Cne,
  transition: Gne,
  call: zs.call,
  nodes: zs.nodes,
  node: zs.node,
  size: zs.size,
  empty: zs.empty,
  each: zs.each,
  on: Tne,
  attr: ine,
  attrTween: one,
  style: One,
  styleTween: kne,
  text: Bne,
  textTween: Vne,
  remove: wne,
  tween: Yre,
  delay: cne,
  duration: pne,
  ease: mne,
  easeVarying: yne,
  end: Hne,
  [Symbol.iterator]: zs[Symbol.iterator]
};
function qne(r) {
  return ((r *= 2) <= 1 ? r * r * r : (r -= 2) * r * r + 2) / 2;
}
var Xne = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: qne
};
function $ne(r, e) {
  for (var i; !(i = r.__transition) || !(i = i[e]); )
    if (!(r = r.parentNode))
      throw new Error(`transition ${e} not found`);
  return i;
}
function Yne(r) {
  var e, i;
  r instanceof Ta ? (e = r._id, r = r._name) : (e = rO(), (i = Xne).time = Y_(), r = r == null ? null : r + "");
  for (var n = this._groups, s = n.length, a = 0; a < s; ++a)
    for (var o = n[a], l = o.length, u, c = 0; c < l; ++c)
      (u = o[c]) && Qg(u, r, e, c, o, i || $ne(u, e));
  return new Ta(n, this._parents, r, e);
}
np.prototype.interrupt = qre;
np.prototype.transition = Yne;
const kf = (r) => () => r;
function Kne(r, {
  sourceEvent: e,
  target: i,
  transform: n,
  dispatch: s
}) {
  Object.defineProperties(this, {
    type: { value: r, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    target: { value: i, enumerable: !0, configurable: !0 },
    transform: { value: n, enumerable: !0, configurable: !0 },
    _: { value: s }
  });
}
function aa(r, e, i) {
  this.k = r, this.x = e, this.y = i;
}
aa.prototype = {
  constructor: aa,
  scale: function(r) {
    return r === 1 ? this : new aa(this.k * r, this.x, this.y);
  },
  translate: function(r, e) {
    return r === 0 & e === 0 ? this : new aa(this.k, this.x + this.k * r, this.y + this.k * e);
  },
  apply: function(r) {
    return [r[0] * this.k + this.x, r[1] * this.k + this.y];
  },
  applyX: function(r) {
    return r * this.k + this.x;
  },
  applyY: function(r) {
    return r * this.k + this.y;
  },
  invert: function(r) {
    return [(r[0] - this.x) / this.k, (r[1] - this.y) / this.k];
  },
  invertX: function(r) {
    return (r - this.x) / this.k;
  },
  invertY: function(r) {
    return (r - this.y) / this.k;
  },
  rescaleX: function(r) {
    return r.copy().domain(r.range().map(this.invertX, this).map(r.invert, r));
  },
  rescaleY: function(r) {
    return r.copy().domain(r.range().map(this.invertY, this).map(r.invert, r));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var uT = new aa(1, 0, 0);
ss.prototype = aa.prototype;
function ss(r) {
  for (; !r.__zoom; ) if (!(r = r.parentNode)) return uT;
  return r.__zoom;
}
function Nv(r) {
  r.stopImmediatePropagation();
}
function Rh(r) {
  r.preventDefault(), r.stopImmediatePropagation();
}
function Zne(r) {
  return (!r.ctrlKey || r.type === "wheel") && !r.button;
}
function Qne() {
  var r = this;
  return r instanceof SVGElement ? (r = r.ownerSVGElement || r, r.hasAttribute("viewBox") ? (r = r.viewBox.baseVal, [[r.x, r.y], [r.x + r.width, r.y + r.height]]) : [[0, 0], [r.width.baseVal.value, r.height.baseVal.value]]) : [[0, 0], [r.clientWidth, r.clientHeight]];
}
function zA() {
  return this.__zoom || uT;
}
function Jne(r) {
  return -r.deltaY * (r.deltaMode === 1 ? 0.05 : r.deltaMode ? 1 : 2e-3) * (r.ctrlKey ? 10 : 1);
}
function ese() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function tse(r, e, i) {
  var n = r.invertX(e[0][0]) - i[0][0], s = r.invertX(e[1][0]) - i[1][0], a = r.invertY(e[0][1]) - i[0][1], o = r.invertY(e[1][1]) - i[1][1];
  return r.translate(
    s > n ? (n + s) / 2 : Math.min(0, n) || Math.max(0, s),
    o > a ? (a + o) / 2 : Math.min(0, a) || Math.max(0, o)
  );
}
function ise() {
  var r = Zne, e = Qne, i = tse, n = Jne, s = ese, a = [0, 1 / 0], o = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], l = 250, u = NH, c = Wd("start", "zoom", "end"), h, d, p, f = 500, m = 150, y = 0, v = 10;
  function g(C) {
    C.property("__zoom", zA).on("wheel.zoom", M, { passive: !1 }).on("mousedown.zoom", E).on("dblclick.zoom", A).filter(s).on("touchstart.zoom", N).on("touchmove.zoom", U).on("touchend.zoom touchcancel.zoom", k).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  g.transform = function(C, I, O, W) {
    var V = C.selection ? C.selection() : C;
    V.property("__zoom", zA), C !== V ? T(C, I, O, W) : V.interrupt().each(function() {
      S(this, arguments).event(W).start().zoom(null, typeof I == "function" ? I.apply(this, arguments) : I).end();
    });
  }, g.scaleBy = function(C, I, O, W) {
    g.scaleTo(C, function() {
      var V = this.__zoom.k, Q = typeof I == "function" ? I.apply(this, arguments) : I;
      return V * Q;
    }, O, W);
  }, g.scaleTo = function(C, I, O, W) {
    g.transform(C, function() {
      var V = e.apply(this, arguments), Q = this.__zoom, F = O == null ? b(V) : typeof O == "function" ? O.apply(this, arguments) : O, B = Q.invert(F), q = typeof I == "function" ? I.apply(this, arguments) : I;
      return i(x(_(Q, q), F, B), V, o);
    }, O, W);
  }, g.translateBy = function(C, I, O, W) {
    g.transform(C, function() {
      return i(this.__zoom.translate(
        typeof I == "function" ? I.apply(this, arguments) : I,
        typeof O == "function" ? O.apply(this, arguments) : O
      ), e.apply(this, arguments), o);
    }, null, W);
  }, g.translateTo = function(C, I, O, W, V) {
    g.transform(C, function() {
      var Q = e.apply(this, arguments), F = this.__zoom, B = W == null ? b(Q) : typeof W == "function" ? W.apply(this, arguments) : W;
      return i(uT.translate(B[0], B[1]).scale(F.k).translate(
        typeof I == "function" ? -I.apply(this, arguments) : -I,
        typeof O == "function" ? -O.apply(this, arguments) : -O
      ), Q, o);
    }, W, V);
  };
  function _(C, I) {
    return I = Math.max(a[0], Math.min(a[1], I)), I === C.k ? C : new aa(I, C.x, C.y);
  }
  function x(C, I, O) {
    var W = I[0] - O[0] * C.k, V = I[1] - O[1] * C.k;
    return W === C.x && V === C.y ? C : new aa(C.k, W, V);
  }
  function b(C) {
    return [(+C[0][0] + +C[1][0]) / 2, (+C[0][1] + +C[1][1]) / 2];
  }
  function T(C, I, O, W) {
    C.on("start.zoom", function() {
      S(this, arguments).event(W).start();
    }).on("interrupt.zoom end.zoom", function() {
      S(this, arguments).event(W).end();
    }).tween("zoom", function() {
      var V = this, Q = arguments, F = S(V, Q).event(W), B = e.apply(V, Q), q = O == null ? b(B) : typeof O == "function" ? O.apply(V, Q) : O, G = Math.max(B[1][0] - B[0][0], B[1][1] - B[0][1]), z = V.__zoom, Y = typeof I == "function" ? I.apply(V, Q) : I, se = u(z.invert(q).concat(G / z.k), Y.invert(q).concat(G / Y.k));
      return function(ne) {
        if (ne === 1) ne = Y;
        else {
          var fe = se(ne), Se = G / fe[2];
          ne = new aa(Se, q[0] - fe[0] * Se, q[1] - fe[1] * Se);
        }
        F.zoom(null, ne);
      };
    });
  }
  function S(C, I, O) {
    return !O && C.__zooming || new w(C, I);
  }
  function w(C, I) {
    this.that = C, this.args = I, this.active = 0, this.sourceEvent = null, this.extent = e.apply(C, I), this.taps = 0;
  }
  w.prototype = {
    event: function(C) {
      return C && (this.sourceEvent = C), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(C, I) {
      return this.mouse && C !== "mouse" && (this.mouse[1] = I.invert(this.mouse[0])), this.touch0 && C !== "touch" && (this.touch0[1] = I.invert(this.touch0[0])), this.touch1 && C !== "touch" && (this.touch1[1] = I.invert(this.touch1[0])), this.that.__zoom = I, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(C) {
      var I = vn(this.that).datum();
      c.call(
        C,
        this.that,
        new Kne(C, {
          sourceEvent: this.sourceEvent,
          target: g,
          transform: this.that.__zoom,
          dispatch: c
        }),
        I
      );
    }
  };
  function M(C, ...I) {
    if (!r.apply(this, arguments)) return;
    var O = S(this, I).event(C), W = this.__zoom, V = Math.max(a[0], Math.min(a[1], W.k * Math.pow(2, n.apply(this, arguments)))), Q = as(C);
    if (O.wheel)
      (O.mouse[0][0] !== Q[0] || O.mouse[0][1] !== Q[1]) && (O.mouse[1] = W.invert(O.mouse[0] = Q)), clearTimeout(O.wheel);
    else {
      if (W.k === V) return;
      O.mouse = [Q, W.invert(Q)], fm(this), O.start();
    }
    Rh(C), O.wheel = setTimeout(F, m), O.zoom("mouse", i(x(_(W, V), O.mouse[0], O.mouse[1]), O.extent, o));
    function F() {
      O.wheel = null, O.end();
    }
  }
  function E(C, ...I) {
    if (p || !r.apply(this, arguments)) return;
    var O = C.currentTarget, W = S(this, I, !0).event(C), V = vn(C.view).on("mousemove.zoom", q, !0).on("mouseup.zoom", G, !0), Q = as(C, O), F = C.clientX, B = C.clientY;
    Q3(C.view), Nv(C), W.mouse = [Q, this.__zoom.invert(Q)], fm(this), W.start();
    function q(z) {
      if (Rh(z), !W.moved) {
        var Y = z.clientX - F, se = z.clientY - B;
        W.moved = Y * Y + se * se > y;
      }
      W.event(z).zoom("mouse", i(x(W.that.__zoom, W.mouse[0] = as(z, O), W.mouse[1]), W.extent, o));
    }
    function G(z) {
      V.on("mousemove.zoom mouseup.zoom", null), J3(z.view, W.moved), Rh(z), W.event(z).end();
    }
  }
  function A(C, ...I) {
    if (r.apply(this, arguments)) {
      var O = this.__zoom, W = as(C.changedTouches ? C.changedTouches[0] : C, this), V = O.invert(W), Q = O.k * (C.shiftKey ? 0.5 : 2), F = i(x(_(O, Q), W, V), e.apply(this, I), o);
      Rh(C), l > 0 ? vn(this).transition().duration(l).call(T, F, W, C) : vn(this).call(g.transform, F, W, C);
    }
  }
  function N(C, ...I) {
    if (r.apply(this, arguments)) {
      var O = C.touches, W = O.length, V = S(this, I, C.changedTouches.length === W).event(C), Q, F, B, q;
      for (Nv(C), F = 0; F < W; ++F)
        B = O[F], q = as(B, this), q = [q, this.__zoom.invert(q), B.identifier], V.touch0 ? !V.touch1 && V.touch0[2] !== q[2] && (V.touch1 = q, V.taps = 0) : (V.touch0 = q, Q = !0, V.taps = 1 + !!h);
      h && (h = clearTimeout(h)), Q && (V.taps < 2 && (d = q[0], h = setTimeout(function() {
        h = null;
      }, f)), fm(this), V.start());
    }
  }
  function U(C, ...I) {
    if (this.__zooming) {
      var O = S(this, I).event(C), W = C.changedTouches, V = W.length, Q, F, B, q;
      for (Rh(C), Q = 0; Q < V; ++Q)
        F = W[Q], B = as(F, this), O.touch0 && O.touch0[2] === F.identifier ? O.touch0[0] = B : O.touch1 && O.touch1[2] === F.identifier && (O.touch1[0] = B);
      if (F = O.that.__zoom, O.touch1) {
        var G = O.touch0[0], z = O.touch0[1], Y = O.touch1[0], se = O.touch1[1], ne = (ne = Y[0] - G[0]) * ne + (ne = Y[1] - G[1]) * ne, fe = (fe = se[0] - z[0]) * fe + (fe = se[1] - z[1]) * fe;
        F = _(F, Math.sqrt(ne / fe)), B = [(G[0] + Y[0]) / 2, (G[1] + Y[1]) / 2], q = [(z[0] + se[0]) / 2, (z[1] + se[1]) / 2];
      } else if (O.touch0) B = O.touch0[0], q = O.touch0[1];
      else return;
      O.zoom("touch", i(x(F, B, q), O.extent, o));
    }
  }
  function k(C, ...I) {
    if (this.__zooming) {
      var O = S(this, I).event(C), W = C.changedTouches, V = W.length, Q, F;
      for (Nv(C), p && clearTimeout(p), p = setTimeout(function() {
        p = null;
      }, f), Q = 0; Q < V; ++Q)
        F = W[Q], O.touch0 && O.touch0[2] === F.identifier ? delete O.touch0 : O.touch1 && O.touch1[2] === F.identifier && delete O.touch1;
      if (O.touch1 && !O.touch0 && (O.touch0 = O.touch1, delete O.touch1), O.touch0) O.touch0[1] = this.__zoom.invert(O.touch0[0]);
      else if (O.end(), O.taps === 2 && (F = as(F, this), Math.hypot(d[0] - F[0], d[1] - F[1]) < v)) {
        var B = vn(this).on("dblclick.zoom");
        B && B.apply(this, arguments);
      }
    }
  }
  return g.wheelDelta = function(C) {
    return arguments.length ? (n = typeof C == "function" ? C : kf(+C), g) : n;
  }, g.filter = function(C) {
    return arguments.length ? (r = typeof C == "function" ? C : kf(!!C), g) : r;
  }, g.touchable = function(C) {
    return arguments.length ? (s = typeof C == "function" ? C : kf(!!C), g) : s;
  }, g.extent = function(C) {
    return arguments.length ? (e = typeof C == "function" ? C : kf([[+C[0][0], +C[0][1]], [+C[1][0], +C[1][1]]]), g) : e;
  }, g.scaleExtent = function(C) {
    return arguments.length ? (a[0] = +C[0], a[1] = +C[1], g) : [a[0], a[1]];
  }, g.translateExtent = function(C) {
    return arguments.length ? (o[0][0] = +C[0][0], o[1][0] = +C[1][0], o[0][1] = +C[0][1], o[1][1] = +C[1][1], g) : [[o[0][0], o[0][1]], [o[1][0], o[1][1]]];
  }, g.constrain = function(C) {
    return arguments.length ? (i = C, g) : i;
  }, g.duration = function(C) {
    return arguments.length ? (l = +C, g) : l;
  }, g.interpolate = function(C) {
    return arguments.length ? (u = C, g) : u;
  }, g.on = function() {
    var C = c.on.apply(c, arguments);
    return C === c ? g : C;
  }, g.clickDistance = function(C) {
    return arguments.length ? (y = (C = +C) * C, g) : Math.sqrt(y);
  }, g.tapDistance = function(C) {
    return arguments.length ? (v = +C, g) : v;
  }, g;
}
var rse = "Expected a function";
function nse(r, e, i) {
  var n = !0, s = !0;
  if (typeof r != "function")
    throw new TypeError(rse);
  return Em(i) && (n = "leading" in i ? !!i.leading : n, s = "trailing" in i ? !!i.trailing : s), hN(r, e, {
    leading: n,
    maxWait: e,
    trailing: s
  });
}
function Jx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function sse(r) {
  if (Array.isArray(r)) return Jx(r);
}
function nO(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function ase(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function ose(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function pn(r, e) {
  return r.get(nO(r, e));
}
function jA(r, e, i) {
  ase(r, e), e.set(r, i);
}
function VA(r, e, i) {
  return r.set(nO(r, e), i), i;
}
function lse(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, fse(n.key), n);
  }
}
function use(r, e, i) {
  return e && lse(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function cse(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function hse() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function dse(r) {
  return sse(r) || cse(r) || mse(r) || hse();
}
function pse(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function fse(r) {
  var e = pse(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function mse(r, e) {
  if (r) {
    if (typeof r == "string") return Jx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Jx(r, e) : void 0;
  }
}
var gse = 123, yse = function(r) {
  return "#".concat(Math.min(r, Math.pow(2, 24)).toString(16).padStart(6, "0"));
}, sO = function(r, e, i) {
  return (r << 16) + (e << 8) + i;
}, vse = function(r) {
  var e = rt(r).toRgb(), i = e.r, n = e.g, s = e.b;
  return sO(i, n, s);
}, GA = function(r, e) {
  return r * gse % Math.pow(2, e);
}, jo = /* @__PURE__ */ new WeakMap(), js = /* @__PURE__ */ new WeakMap(), bse = /* @__PURE__ */ function() {
  function r() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6;
    ose(this, r), jA(this, jo, void 0), jA(this, js, void 0), VA(js, this, e), this.reset();
  }
  return use(r, [{
    key: "reset",
    value: function() {
      VA(jo, this, ["__reserved for background__"]);
    }
  }, {
    key: "register",
    value: function(e) {
      if (pn(jo, this).length >= Math.pow(2, 24 - pn(js, this)))
        return null;
      var i = pn(jo, this).length, n = GA(i, pn(js, this)), s = yse(i + (n << 24 - pn(js, this)));
      return pn(jo, this).push(e), s;
    }
  }, {
    key: "lookup",
    value: function(e) {
      if (!e) return null;
      var i = typeof e == "string" ? vse(e) : sO.apply(void 0, dse(e));
      if (!i) return null;
      var n = i & Math.pow(2, 24 - pn(js, this)) - 1, s = i >> 24 - pn(js, this) & Math.pow(2, pn(js, this)) - 1;
      return GA(n, pn(js, this)) !== s || n >= pn(jo, this).length ? null : pn(jo, this)[n];
    }
    // How many bits to reserve for checksum. Will eat away into the usable size of the registry.
  }]);
}();
const { abs: Nh, cos: Vs, sin: Eu, acos: xse, atan2: Ph, sqrt: qa, pow: fn } = Math;
function Ih(r) {
  return r < 0 ? -fn(-r, 1 / 3) : fn(r, 1 / 3);
}
const aO = Math.PI, Uf = 2 * aO, Xa = aO / 2, _se = 1e-6, Pv = Number.MAX_SAFE_INTEGER || 9007199254740991, Iv = Number.MIN_SAFE_INTEGER || -9007199254740991, Tse = { x: 0, y: 0, z: 0 }, Oe = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(r, e) {
    const i = e(r);
    let n = i.x * i.x + i.y * i.y;
    return typeof i.z < "u" && (n += i.z * i.z), qa(n);
  },
  compute: function(r, e, i) {
    if (r === 0)
      return e[0].t = 0, e[0];
    const n = e.length - 1;
    if (r === 1)
      return e[n].t = 1, e[n];
    const s = 1 - r;
    let a = e;
    if (n === 0)
      return e[0].t = r, e[0];
    if (n === 1) {
      const l = {
        x: s * a[0].x + r * a[1].x,
        y: s * a[0].y + r * a[1].y,
        t: r
      };
      return i && (l.z = s * a[0].z + r * a[1].z), l;
    }
    if (n < 4) {
      let l = s * s, u = r * r, c, h, d, p = 0;
      n === 2 ? (a = [a[0], a[1], a[2], Tse], c = l, h = s * r * 2, d = u) : n === 3 && (c = l * s, h = l * r * 3, d = s * u * 3, p = r * u);
      const f = {
        x: c * a[0].x + h * a[1].x + d * a[2].x + p * a[3].x,
        y: c * a[0].y + h * a[1].y + d * a[2].y + p * a[3].y,
        t: r
      };
      return i && (f.z = c * a[0].z + h * a[1].z + d * a[2].z + p * a[3].z), f;
    }
    const o = JSON.parse(JSON.stringify(e));
    for (; o.length > 1; ) {
      for (let l = 0; l < o.length - 1; l++)
        o[l] = {
          x: o[l].x + (o[l + 1].x - o[l].x) * r,
          y: o[l].y + (o[l + 1].y - o[l].y) * r
        }, typeof o[l].z < "u" && (o[l].z = o[l].z + (o[l + 1].z - o[l].z) * r);
      o.splice(o.length - 1, 1);
    }
    return o[0].t = r, o[0];
  },
  computeWithRatios: function(r, e, i, n) {
    const s = 1 - r, a = i, o = e;
    let l = a[0], u = a[1], c = a[2], h = a[3], d;
    if (l *= s, u *= r, o.length === 2)
      return d = l + u, {
        x: (l * o[0].x + u * o[1].x) / d,
        y: (l * o[0].y + u * o[1].y) / d,
        z: n ? (l * o[0].z + u * o[1].z) / d : !1,
        t: r
      };
    if (l *= s, u *= 2 * s, c *= r * r, o.length === 3)
      return d = l + u + c, {
        x: (l * o[0].x + u * o[1].x + c * o[2].x) / d,
        y: (l * o[0].y + u * o[1].y + c * o[2].y) / d,
        z: n ? (l * o[0].z + u * o[1].z + c * o[2].z) / d : !1,
        t: r
      };
    if (l *= s, u *= 1.5 * s, c *= 3 * s, h *= r * r * r, o.length === 4)
      return d = l + u + c + h, {
        x: (l * o[0].x + u * o[1].x + c * o[2].x + h * o[3].x) / d,
        y: (l * o[0].y + u * o[1].y + c * o[2].y + h * o[3].y) / d,
        z: n ? (l * o[0].z + u * o[1].z + c * o[2].z + h * o[3].z) / d : !1,
        t: r
      };
  },
  derive: function(r, e) {
    const i = [];
    for (let n = r, s = n.length, a = s - 1; s > 1; s--, a--) {
      const o = [];
      for (let l = 0, u; l < a; l++)
        u = {
          x: a * (n[l + 1].x - n[l].x),
          y: a * (n[l + 1].y - n[l].y)
        }, e && (u.z = a * (n[l + 1].z - n[l].z)), o.push(u);
      i.push(o), n = o;
    }
    return i;
  },
  between: function(r, e, i) {
    return e <= r && r <= i || Oe.approximately(r, e) || Oe.approximately(r, i);
  },
  approximately: function(r, e, i) {
    return Nh(r - e) <= (i || _se);
  },
  length: function(r) {
    const e = Oe.Tvalues.length;
    let i = 0;
    for (let n = 0, s; n < e; n++)
      s = 0.5 * Oe.Tvalues[n] + 0.5, i += Oe.Cvalues[n] * Oe.arcfn(s, r);
    return 0.5 * i;
  },
  map: function(r, e, i, n, s) {
    const a = i - e, o = s - n, l = r - e, u = l / a;
    return n + o * u;
  },
  lerp: function(r, e, i) {
    const n = {
      x: e.x + r * (i.x - e.x),
      y: e.y + r * (i.y - e.y)
    };
    return e.z !== void 0 && i.z !== void 0 && (n.z = e.z + r * (i.z - e.z)), n;
  },
  pointToString: function(r) {
    let e = r.x + "/" + r.y;
    return typeof r.z < "u" && (e += "/" + r.z), e;
  },
  pointsToString: function(r) {
    return "[" + r.map(Oe.pointToString).join(", ") + "]";
  },
  copy: function(r) {
    return JSON.parse(JSON.stringify(r));
  },
  angle: function(r, e, i) {
    const n = e.x - r.x, s = e.y - r.y, a = i.x - r.x, o = i.y - r.y, l = n * o - s * a, u = n * a + s * o;
    return Ph(l, u);
  },
  // round as string, to avoid rounding errors
  round: function(r, e) {
    const i = "" + r, n = i.indexOf(".");
    return parseFloat(i.substring(0, n + 1 + e));
  },
  dist: function(r, e) {
    const i = r.x - e.x, n = r.y - e.y;
    return qa(i * i + n * n);
  },
  closest: function(r, e) {
    let i = fn(2, 63), n, s;
    return r.forEach(function(a, o) {
      s = Oe.dist(e, a), s < i && (i = s, n = o);
    }), { mdist: i, mpos: n };
  },
  abcratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const i = fn(r, e) + fn(1 - r, e), n = i - 1;
    return Nh(n / i);
  },
  projectionratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const i = fn(1 - r, e), n = fn(r, e) + i;
    return i / n;
  },
  lli8: function(r, e, i, n, s, a, o, l) {
    const u = (r * n - e * i) * (s - o) - (r - i) * (s * l - a * o), c = (r * n - e * i) * (a - l) - (e - n) * (s * l - a * o), h = (r - i) * (a - l) - (e - n) * (s - o);
    return h == 0 ? !1 : { x: u / h, y: c / h };
  },
  lli4: function(r, e, i, n) {
    const s = r.x, a = r.y, o = e.x, l = e.y, u = i.x, c = i.y, h = n.x, d = n.y;
    return Oe.lli8(s, a, o, l, u, c, h, d);
  },
  lli: function(r, e) {
    return Oe.lli4(r, r.c, e, e.c);
  },
  makeline: function(r, e) {
    return new oi(
      r.x,
      r.y,
      (r.x + e.x) / 2,
      (r.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(r) {
    let e = Pv, i = Pv, n = Iv, s = Iv;
    return r.forEach(function(a) {
      const o = a.bbox();
      e > o.x.min && (e = o.x.min), i > o.y.min && (i = o.y.min), n < o.x.max && (n = o.x.max), s < o.y.max && (s = o.y.max);
    }), {
      x: { min: e, mid: (e + n) / 2, max: n, size: n - e },
      y: { min: i, mid: (i + s) / 2, max: s, size: s - i }
    };
  },
  shapeintersections: function(r, e, i, n, s) {
    if (!Oe.bboxoverlap(e, n)) return [];
    const a = [], o = [r.startcap, r.forward, r.back, r.endcap], l = [i.startcap, i.forward, i.back, i.endcap];
    return o.forEach(function(u) {
      u.virtual || l.forEach(function(c) {
        if (c.virtual) return;
        const h = u.intersects(c, s);
        h.length > 0 && (h.c1 = u, h.c2 = c, h.s1 = r, h.s2 = i, a.push(h));
      });
    }), a;
  },
  makeshape: function(r, e, i) {
    const n = e.points.length, s = r.points.length, a = Oe.makeline(e.points[n - 1], r.points[0]), o = Oe.makeline(r.points[s - 1], e.points[0]), l = {
      startcap: a,
      forward: r,
      back: e,
      endcap: o,
      bbox: Oe.findbbox([a, r, e, o])
    };
    return l.intersections = function(u) {
      return Oe.shapeintersections(
        l,
        l.bbox,
        u,
        u.bbox,
        i
      );
    }, l;
  },
  getminmax: function(r, e, i) {
    if (!i) return { min: 0, max: 0 };
    let n = Pv, s = Iv, a, o;
    i.indexOf(0) === -1 && (i = [0].concat(i)), i.indexOf(1) === -1 && i.push(1);
    for (let l = 0, u = i.length; l < u; l++)
      a = i[l], o = r.get(a), o[e] < n && (n = o[e]), o[e] > s && (s = o[e]);
    return { min: n, mid: (n + s) / 2, max: s, size: s - n };
  },
  align: function(r, e) {
    const i = e.p1.x, n = e.p1.y, s = -Ph(e.p2.y - n, e.p2.x - i), a = function(o) {
      return {
        x: (o.x - i) * Vs(s) - (o.y - n) * Eu(s),
        y: (o.x - i) * Eu(s) + (o.y - n) * Vs(s)
      };
    };
    return r.map(a);
  },
  roots: function(r, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const i = r.length - 1, n = Oe.align(r, e), s = function(w) {
      return 0 <= w && w <= 1;
    };
    if (i === 2) {
      const w = n[0].y, M = n[1].y, E = n[2].y, A = w - 2 * M + E;
      if (A !== 0) {
        const N = -qa(M * M - w * E), U = -w + M, k = -(N + U) / A, C = -(-N + U) / A;
        return [k, C].filter(s);
      } else if (M !== E && A === 0)
        return [(2 * M - E) / (2 * M - 2 * E)].filter(s);
      return [];
    }
    const a = n[0].y, o = n[1].y, l = n[2].y, u = n[3].y;
    let c = -a + 3 * o - 3 * l + u, h = 3 * a - 6 * o + 3 * l, d = -3 * a + 3 * o, p = a;
    if (Oe.approximately(c, 0)) {
      if (Oe.approximately(h, 0))
        return Oe.approximately(d, 0) ? [] : [-p / d].filter(s);
      const w = qa(d * d - 4 * h * p), M = 2 * h;
      return [(w - d) / M, (-d - w) / M].filter(s);
    }
    h /= c, d /= c, p /= c;
    const f = (3 * d - h * h) / 3, m = f / 3, y = (2 * h * h * h - 9 * h * d + 27 * p) / 27, v = y / 2, g = v * v + m * m * m;
    let _, x, b, T, S;
    if (g < 0) {
      const w = -f / 3, M = w * w * w, E = qa(M), A = -y / (2 * E), N = A < -1 ? -1 : A > 1 ? 1 : A, U = xse(N), k = Ih(E), C = 2 * k;
      return b = C * Vs(U / 3) - h / 3, T = C * Vs((U + Uf) / 3) - h / 3, S = C * Vs((U + 2 * Uf) / 3) - h / 3, [b, T, S].filter(s);
    } else {
      if (g === 0)
        return _ = v < 0 ? Ih(-v) : -Ih(v), b = 2 * _ - h / 3, T = -_ - h / 3, [b, T].filter(s);
      {
        const w = qa(g);
        return _ = Ih(-v + w), x = Ih(v + w), [_ - x - h / 3].filter(s);
      }
    }
  },
  droots: function(r) {
    if (r.length === 3) {
      const e = r[0], i = r[1], n = r[2], s = e - 2 * i + n;
      if (s !== 0) {
        const a = -qa(i * i - e * n), o = -e + i, l = -(a + o) / s, u = -(-a + o) / s;
        return [l, u];
      } else if (i !== n && s === 0)
        return [(2 * i - n) / (2 * (i - n))];
      return [];
    }
    if (r.length === 2) {
      const e = r[0], i = r[1];
      return e !== i ? [e / (e - i)] : [];
    }
    return [];
  },
  curvature: function(r, e, i, n, s) {
    let a, o, l, u, c = 0, h = 0;
    const d = Oe.compute(r, e), p = Oe.compute(r, i), f = d.x * d.x + d.y * d.y;
    if (n ? (a = qa(
      fn(d.y * p.z - p.y * d.z, 2) + fn(d.z * p.x - p.z * d.x, 2) + fn(d.x * p.y - p.x * d.y, 2)
    ), o = fn(f + d.z * d.z, 3 / 2)) : (a = d.x * p.y - d.y * p.x, o = fn(f, 3 / 2)), a === 0 || o === 0)
      return { k: 0, r: 0 };
    if (c = a / o, h = o / a, !s) {
      const m = Oe.curvature(r - 1e-3, e, i, n, !0).k, y = Oe.curvature(r + 1e-3, e, i, n, !0).k;
      u = (y - c + (c - m)) / 2, l = (Nh(y - c) + Nh(c - m)) / 2;
    }
    return { k: c, r: h, dk: u, adk: l };
  },
  inflections: function(r) {
    if (r.length < 4) return [];
    const e = Oe.align(r, { p1: r[0], p2: r.slice(-1)[0] }), i = e[2].x * e[1].y, n = e[3].x * e[1].y, s = e[1].x * e[2].y, a = e[3].x * e[2].y, o = 18 * (-3 * i + 2 * n + 3 * s - a), l = 18 * (3 * i - n - 3 * s), u = 18 * (s - i);
    if (Oe.approximately(o, 0)) {
      if (!Oe.approximately(l, 0)) {
        let p = -u / l;
        if (0 <= p && p <= 1) return [p];
      }
      return [];
    }
    const c = 2 * o;
    if (Oe.approximately(c, 0)) return [];
    const h = l * l - 4 * o * u;
    if (h < 0) return [];
    const d = Math.sqrt(h);
    return [(d - l) / c, -(l + d) / c].filter(function(p) {
      return 0 <= p && p <= 1;
    });
  },
  bboxoverlap: function(r, e) {
    const i = ["x", "y"], n = i.length;
    for (let s = 0, a, o, l, u; s < n; s++)
      if (a = i[s], o = r[a].mid, l = e[a].mid, u = (r[a].size + e[a].size) / 2, Nh(o - l) >= u) return !1;
    return !0;
  },
  expandbox: function(r, e) {
    e.x.min < r.x.min && (r.x.min = e.x.min), e.y.min < r.y.min && (r.y.min = e.y.min), e.z && e.z.min < r.z.min && (r.z.min = e.z.min), e.x.max > r.x.max && (r.x.max = e.x.max), e.y.max > r.y.max && (r.y.max = e.y.max), e.z && e.z.max > r.z.max && (r.z.max = e.z.max), r.x.mid = (r.x.min + r.x.max) / 2, r.y.mid = (r.y.min + r.y.max) / 2, r.z && (r.z.mid = (r.z.min + r.z.max) / 2), r.x.size = r.x.max - r.x.min, r.y.size = r.y.max - r.y.min, r.z && (r.z.size = r.z.max - r.z.min);
  },
  pairiteration: function(r, e, i) {
    const n = r.bbox(), s = e.bbox(), a = 1e5, o = i || 0.5;
    if (n.x.size + n.y.size < o && s.x.size + s.y.size < o)
      return [
        (a * (r._t1 + r._t2) / 2 | 0) / a + "/" + (a * (e._t1 + e._t2) / 2 | 0) / a
      ];
    let l = r.split(0.5), u = e.split(0.5), c = [
      { left: l.left, right: u.left },
      { left: l.left, right: u.right },
      { left: l.right, right: u.right },
      { left: l.right, right: u.left }
    ];
    c = c.filter(function(d) {
      return Oe.bboxoverlap(d.left.bbox(), d.right.bbox());
    });
    let h = [];
    return c.length === 0 || (c.forEach(function(d) {
      h = h.concat(
        Oe.pairiteration(d.left, d.right, o)
      );
    }), h = h.filter(function(d, p) {
      return h.indexOf(d) === p;
    })), h;
  },
  getccenter: function(r, e, i) {
    const n = e.x - r.x, s = e.y - r.y, a = i.x - e.x, o = i.y - e.y, l = n * Vs(Xa) - s * Eu(Xa), u = n * Eu(Xa) + s * Vs(Xa), c = a * Vs(Xa) - o * Eu(Xa), h = a * Eu(Xa) + o * Vs(Xa), d = (r.x + e.x) / 2, p = (r.y + e.y) / 2, f = (e.x + i.x) / 2, m = (e.y + i.y) / 2, y = d + l, v = p + u, g = f + c, _ = m + h, x = Oe.lli8(d, p, y, v, f, m, g, _), b = Oe.dist(x, r);
    let T = Ph(r.y - x.y, r.x - x.x), S = Ph(e.y - x.y, e.x - x.x), w = Ph(i.y - x.y, i.x - x.x), M;
    return T < w ? ((T > S || S > w) && (T += Uf), T > w && (M = w, w = T, T = M)) : w < S && S < T ? (M = w, w = T, T = M) : w += Uf, x.s = T, x.e = w, x.r = b, x;
  },
  numberSort: function(r, e) {
    return r - e;
  }
};
class od {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return Oe.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, i) {
      return e + i;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var i = e[0].bbox(), n = 1; n < e.length; n++)
      Oe.expandbox(i, e[n].bbox());
    return i;
  }
  offset(e) {
    const i = [];
    return this.curves.forEach(function(n) {
      i.push(...n.offset(e));
    }), new od(i);
  }
}
const { abs: Oh, min: HA, max: WA, cos: Sse, sin: wse, acos: Ese, sqrt: Dh } = Math, Mse = Math.PI;
class oi {
  constructor(e) {
    let i = e && e.forEach ? e : Array.from(arguments).slice(), n = !1;
    if (typeof i[0] == "object") {
      n = i.length;
      const f = [];
      i.forEach(function(m) {
        ["x", "y", "z"].forEach(function(y) {
          typeof m[y] < "u" && f.push(m[y]);
        });
      }), i = f;
    }
    let s = !1;
    const a = i.length;
    if (n) {
      if (n > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        s = !0;
      }
    } else if (a !== 6 && a !== 8 && a !== 9 && a !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const o = this._3d = !s && (a === 9 || a === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let f = 0, m = o ? 3 : 2; f < a; f += m) {
      var u = {
        x: i[f],
        y: i[f + 1]
      };
      o && (u.z = i[f + 2]), l.push(u);
    }
    const c = this.order = l.length - 1, h = this.dims = ["x", "y"];
    o && h.push("z"), this.dimlen = h.length;
    const d = Oe.align(l, { p1: l[0], p2: l[c] }), p = Oe.dist(l[0], l[c]);
    this._linear = d.reduce((f, m) => f + Oh(m.y), 0) < p / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, i, n, s) {
    if (typeof s > "u" && (s = 0.5), s === 0)
      return new oi(i, i, n);
    if (s === 1)
      return new oi(e, i, i);
    const a = oi.getABC(2, e, i, n, s);
    return new oi(e, a.A, n);
  }
  static cubicFromPoints(e, i, n, s, a) {
    typeof s > "u" && (s = 0.5);
    const o = oi.getABC(3, e, i, n, s);
    typeof a > "u" && (a = Oe.dist(i, o.C));
    const l = a * (1 - s) / s, u = Oe.dist(e, n), c = (n.x - e.x) / u, h = (n.y - e.y) / u, d = a * c, p = a * h, f = l * c, m = l * h, y = { x: i.x - d, y: i.y - p }, v = { x: i.x + f, y: i.y + m }, g = o.A, _ = { x: g.x + (y.x - g.x) / (1 - s), y: g.y + (y.y - g.y) / (1 - s) }, x = { x: g.x + (v.x - g.x) / s, y: g.y + (v.y - g.y) / s }, b = { x: e.x + (_.x - e.x) / s, y: e.y + (_.y - e.y) / s }, T = {
      x: n.x + (x.x - n.x) / (1 - s),
      y: n.y + (x.y - n.y) / (1 - s)
    };
    return new oi(e, b, T, n);
  }
  static getUtils() {
    return Oe;
  }
  getUtils() {
    return oi.getUtils();
  }
  static get PolyBezier() {
    return od;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return Oe.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, i = e[0].x, n = e[0].y, s = ["M", i, n, this.order === 2 ? "Q" : "C"];
    for (let a = 1, o = e.length; a < o; a++)
      s.push(e[a].x), s.push(e[a].y);
    return s.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, i) {
      return "" + i + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = Oe.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, i = Oe.angle(e[0], e[this.order], e[1]);
    this.clockwise = i > 0;
  }
  length() {
    return Oe.length(this.derivative.bind(this));
  }
  static getABC(e = 2, i, n, s, a = 0.5) {
    const o = Oe.projectionratio(a, e), l = 1 - o, u = {
      x: o * i.x + l * s.x,
      y: o * i.y + l * s.y
    }, c = Oe.abcratio(a, e);
    return { A: {
      x: n.x + (n.x - u.x) / c,
      y: n.y + (n.y - u.y) / c
    }, B: n, C: u, S: i, E: s };
  }
  getABC(e, i) {
    i = i || this.get(e);
    let n = this.points[0], s = this.points[this.order];
    return oi.getABC(this.order, n, i, s, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let i = 0, n, s; i < e; i++)
      s = i / (e - 1), n = this.compute(s), n.t = s, this._lut.push(n);
    return this._lut;
  }
  on(e, i) {
    i = i || 5;
    const n = this.getLUT(), s = [];
    for (let a = 0, o, l = 0; a < n.length; a++)
      o = n[a], Oe.dist(o, e) < i && (s.push(o), l += a / n.length);
    return s.length ? t /= s.length : !1;
  }
  project(e) {
    const i = this.getLUT(), n = i.length - 1, s = Oe.closest(i, e), a = s.mpos, o = (a - 1) / n, l = (a + 1) / n, u = 0.1 / n;
    let c = s.mdist, h = o, d = h, p;
    c += 1;
    for (let f; h < l + u; h += u)
      p = this.compute(h), f = Oe.dist(e, p), f < c && (c = f, d = h);
    return d = d < 0 ? 0 : d > 1 ? 1 : d, p = this.compute(d), p.t = d, p.d = c, p;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? Oe.computeWithRatios(e, this.points, this.ratios, this._3d) : Oe.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, i = [e[0]], n = e.length;
    for (let s = 1, a, o; s < n; s++)
      a = e[s], o = e[s - 1], i[s] = {
        x: (n - s) / n * a.x + s / n * o.x,
        y: (n - s) / n * a.y + s / n * o.y
      };
    return i[n] = e[n - 1], new oi(i);
  }
  derivative(e) {
    return Oe.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return Oe.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new oi(Oe.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return Oe.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return Oe.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const i = this.derivative(e), n = Dh(i.x * i.x + i.y * i.y);
    return { t: e, x: -i.y / n, y: i.x / n };
  }
  __normal3(e) {
    const i = this.derivative(e), n = this.derivative(e + 0.01), s = Dh(i.x * i.x + i.y * i.y + i.z * i.z), a = Dh(n.x * n.x + n.y * n.y + n.z * n.z);
    i.x /= s, i.y /= s, i.z /= s, n.x /= a, n.y /= a, n.z /= a;
    const o = {
      x: n.y * i.z - n.z * i.y,
      y: n.z * i.x - n.x * i.z,
      z: n.x * i.y - n.y * i.x
    }, l = Dh(o.x * o.x + o.y * o.y + o.z * o.z);
    o.x /= l, o.y /= l, o.z /= l;
    const u = [
      o.x * o.x,
      o.x * o.y - o.z,
      o.x * o.z + o.y,
      o.x * o.y + o.z,
      o.y * o.y,
      o.y * o.z - o.x,
      o.x * o.z - o.y,
      o.y * o.z + o.x,
      o.z * o.z
    ];
    return {
      t: e,
      x: u[0] * i.x + u[1] * i.y + u[2] * i.z,
      y: u[3] * i.x + u[4] * i.y + u[5] * i.z,
      z: u[6] * i.x + u[7] * i.y + u[8] * i.z
    };
  }
  hull(e) {
    let i = this.points, n = [], s = [], a = 0;
    for (s[a++] = i[0], s[a++] = i[1], s[a++] = i[2], this.order === 3 && (s[a++] = i[3]); i.length > 1; ) {
      n = [];
      for (let o = 0, l, u = i.length - 1; o < u; o++)
        l = Oe.lerp(e, i[o], i[o + 1]), s[a++] = l, n.push(l);
      i = n;
    }
    return s;
  }
  split(e, i) {
    if (e === 0 && i)
      return this.split(i).left;
    if (i === 1)
      return this.split(e).right;
    const n = this.hull(e), s = {
      left: this.order === 2 ? new oi([n[0], n[3], n[5]]) : new oi([n[0], n[4], n[7], n[9]]),
      right: this.order === 2 ? new oi([n[5], n[4], n[2]]) : new oi([n[9], n[8], n[6], n[3]]),
      span: n
    };
    return s.left._t1 = Oe.map(0, 0, 1, this._t1, this._t2), s.left._t2 = Oe.map(e, 0, 1, this._t1, this._t2), s.right._t1 = Oe.map(e, 0, 1, this._t1, this._t2), s.right._t2 = Oe.map(1, 0, 1, this._t1, this._t2), i ? (i = Oe.map(i, e, 1, 0, 1), s.right.split(i).left) : s;
  }
  extrema() {
    const e = {};
    let i = [];
    return this.dims.forEach(
      (function(n) {
        let s = function(o) {
          return o[n];
        }, a = this.dpoints[0].map(s);
        e[n] = Oe.droots(a), this.order === 3 && (a = this.dpoints[1].map(s), e[n] = e[n].concat(Oe.droots(a))), e[n] = e[n].filter(function(o) {
          return o >= 0 && o <= 1;
        }), i = i.concat(e[n].sort(Oe.numberSort));
      }).bind(this)
    ), e.values = i.sort(Oe.numberSort).filter(function(n, s) {
      return i.indexOf(n) === s;
    }), e;
  }
  bbox() {
    const e = this.extrema(), i = {};
    return this.dims.forEach(
      (function(n) {
        i[n] = Oe.getminmax(this, n, e[n]);
      }).bind(this)
    ), i;
  }
  overlaps(e) {
    const i = this.bbox(), n = e.bbox();
    return Oe.bboxoverlap(i, n);
  }
  offset(e, i) {
    if (typeof i < "u") {
      const n = this.get(e), s = this.normal(e), a = {
        c: n,
        n: s,
        x: n.x + s.x * i,
        y: n.y + s.y * i
      };
      return this._3d && (a.z = n.z + s.z * i), a;
    }
    if (this._linear) {
      const n = this.normal(0), s = this.points.map(function(a) {
        const o = {
          x: a.x + e * n.x,
          y: a.y + e * n.y
        };
        return a.z && n.z && (o.z = a.z + e * n.z), o;
      });
      return [new oi(s)];
    }
    return this.reduce().map(function(n) {
      return n._linear ? n.offset(e)[0] : n.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const s = Oe.angle(this.points[0], this.points[3], this.points[1]), a = Oe.angle(this.points[0], this.points[3], this.points[2]);
      if (s > 0 && a < 0 || s < 0 && a > 0) return !1;
    }
    const e = this.normal(0), i = this.normal(1);
    let n = e.x * i.x + e.y * i.y;
    return this._3d && (n += e.z * i.z), Oh(Ese(n)) < Mse / 3;
  }
  reduce() {
    let e, i = 0, n = 0, s = 0.01, a, o = [], l = [], u = this.extrema().values;
    for (u.indexOf(0) === -1 && (u = [0].concat(u)), u.indexOf(1) === -1 && u.push(1), i = u[0], e = 1; e < u.length; e++)
      n = u[e], a = this.split(i, n), a._t1 = i, a._t2 = n, o.push(a), i = n;
    return o.forEach(function(c) {
      for (i = 0, n = 0; n <= 1; )
        for (n = i + s; n <= 1 + s; n += s)
          if (a = c.split(i, n), !a.simple()) {
            if (n -= s, Oh(i - n) < s)
              return [];
            a = c.split(i, n), a._t1 = Oe.map(i, 0, 1, c._t1, c._t2), a._t2 = Oe.map(n, 0, 1, c._t1, c._t2), l.push(a), i = n;
            break;
          }
      i < 1 && (a = c.split(i, 1), a._t1 = Oe.map(i, 0, 1, c._t1, c._t2), a._t2 = c._t2, l.push(a));
    }), l;
  }
  translate(e, i, n) {
    n = typeof n == "number" ? n : i;
    const s = this.order;
    let a = this.points.map((o, l) => (1 - l / s) * i + l / s * n);
    return new oi(
      this.points.map((o, l) => ({
        x: o.x + e.x * a[l],
        y: o.y + e.y * a[l]
      }))
    );
  }
  scale(e) {
    const i = this.order;
    let n = !1;
    if (typeof e == "function" && (n = e), n && i === 2)
      return this.raise().scale(n);
    const s = this.clockwise, a = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        n ? n(0) : e,
        n ? n(1) : e
      );
    const o = n ? n(0) : e, l = n ? n(1) : e, u = [this.offset(0, 10), this.offset(1, 10)], c = [], h = Oe.lli4(u[0], u[0].c, u[1], u[1].c);
    if (!h)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(d) {
      const p = c[d * i] = Oe.copy(a[d * i]);
      p.x += (d ? l : o) * u[d].n.x, p.y += (d ? l : o) * u[d].n.y;
    }), n ? ([0, 1].forEach(function(d) {
      if (!(i === 2 && d)) {
        var p = a[d + 1], f = {
          x: p.x - h.x,
          y: p.y - h.y
        }, m = n ? n((d + 1) / i) : e;
        n && !s && (m = -m);
        var y = Dh(f.x * f.x + f.y * f.y);
        f.x /= y, f.y /= y, c[d + 1] = {
          x: p.x + m * f.x,
          y: p.y + m * f.y
        };
      }
    }), new oi(c)) : ([0, 1].forEach((d) => {
      if (i === 2 && d) return;
      const p = c[d * i], f = this.derivative(d), m = { x: p.x + f.x, y: p.y + f.y };
      c[d + 1] = Oe.lli4(p, m, h, a[d + 1]);
    }), new oi(c));
  }
  outline(e, i, n, s) {
    if (i = i === void 0 ? e : i, this._linear) {
      const T = this.normal(0), S = this.points[0], w = this.points[this.points.length - 1];
      let M, E, A;
      n === void 0 && (n = e, s = i), M = { x: S.x + T.x * e, y: S.y + T.y * e }, A = { x: w.x + T.x * n, y: w.y + T.y * n }, E = { x: (M.x + A.x) / 2, y: (M.y + A.y) / 2 };
      const N = [M, E, A];
      M = { x: S.x - T.x * i, y: S.y - T.y * i }, A = { x: w.x - T.x * s, y: w.y - T.y * s }, E = { x: (M.x + A.x) / 2, y: (M.y + A.y) / 2 };
      const U = [A, E, M], k = Oe.makeline(U[2], N[0]), C = Oe.makeline(N[2], U[0]), I = [k, new oi(N), C, new oi(U)];
      return new od(I);
    }
    const a = this.reduce(), o = a.length, l = [];
    let u = [], c, h = 0, d = this.length();
    const p = typeof n < "u" && typeof s < "u";
    function f(T, S, w, M, E) {
      return function(A) {
        const N = M / w, U = (M + E) / w, k = S - T;
        return Oe.map(A, 0, 1, T + N * k, T + U * k);
      };
    }
    a.forEach(function(T) {
      const S = T.length();
      p ? (l.push(
        T.scale(f(e, n, d, h, S))
      ), u.push(
        T.scale(f(-i, -s, d, h, S))
      )) : (l.push(T.scale(e)), u.push(T.scale(-i))), h += S;
    }), u = u.map(function(T) {
      return c = T.points, c[3] ? T.points = [c[3], c[2], c[1], c[0]] : T.points = [c[2], c[1], c[0]], T;
    }).reverse();
    const m = l[0].points[0], y = l[o - 1].points[l[o - 1].points.length - 1], v = u[o - 1].points[u[o - 1].points.length - 1], g = u[0].points[0], _ = Oe.makeline(v, m), x = Oe.makeline(y, g), b = [_].concat(l).concat([x]).concat(u);
    return new od(b);
  }
  outlineshapes(e, i, n) {
    i = i || e;
    const s = this.outline(e, i).curves, a = [];
    for (let o = 1, l = s.length; o < l / 2; o++) {
      const u = Oe.makeshape(
        s[o],
        s[l - o],
        n
      );
      u.startcap.virtual = o > 1, u.endcap.virtual = o < l / 2 - 1, a.push(u);
    }
    return a;
  }
  intersects(e, i) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof oi && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      i
    )) : this.selfintersects(i);
  }
  lineIntersects(e) {
    const i = HA(e.p1.x, e.p2.x), n = HA(e.p1.y, e.p2.y), s = WA(e.p1.x, e.p2.x), a = WA(e.p1.y, e.p2.y);
    return Oe.roots(this.points, e).filter((o) => {
      var l = this.get(o);
      return Oe.between(l.x, i, s) && Oe.between(l.y, n, a);
    });
  }
  selfintersects(e) {
    const i = this.reduce(), n = i.length - 2, s = [];
    for (let a = 0, o, l, u; a < n; a++)
      l = i.slice(a, a + 1), u = i.slice(a + 2), o = this.curveintersects(l, u, e), s.push(...o);
    return s;
  }
  curveintersects(e, i, n) {
    const s = [];
    e.forEach(function(o) {
      i.forEach(function(l) {
        o.overlaps(l) && s.push({ left: o, right: l });
      });
    });
    let a = [];
    return s.forEach(function(o) {
      const l = Oe.pairiteration(
        o.left,
        o.right,
        n
      );
      l.length > 0 && (a = a.concat(l));
    }), a;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, i, n, s) {
    const a = (s - n) / 4, o = this.get(n + a), l = this.get(s - a), u = Oe.dist(e, i), c = Oe.dist(e, o), h = Oe.dist(e, l);
    return Oh(c - u) + Oh(h - u);
  }
  _iterate(e, i) {
    let n = 0, s = 1, a;
    do {
      a = 0, s = 1;
      let o = this.get(n), l, u, c, h, d = !1, p = !1, f, m = s, y = 1;
      do
        if (p = d, h = c, m = (n + s) / 2, l = this.get(m), u = this.get(s), c = Oe.getccenter(o, l, u), c.interval = {
          start: n,
          end: s
        }, d = this._error(c, o, n, s) <= e, f = p && !d, f || (y = s), d) {
          if (s >= 1) {
            if (c.interval.end = y = 1, h = c, s > 1) {
              let v = {
                x: c.x + c.r * Sse(c.e),
                y: c.y + c.r * wse(c.e)
              };
              c.e += Oe.angle({ x: c.x, y: c.y }, v, this.get(1));
            }
            break;
          }
          s = s + (s - n) / 2;
        } else
          s = m;
      while (!f && a++ < 100);
      if (a >= 100)
        break;
      h = h || c, i.push(h), n = y;
    } while (s < 1);
    return i;
  }
}
function e_(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Ase(r) {
  if (Array.isArray(r)) return r;
}
function Cse(r) {
  if (Array.isArray(r)) return e_(r);
}
function Rse(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function Nse(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function Pse() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ise() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ose(r, e) {
  if (r == null) return {};
  var i, n, s = Dse(r, e);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(r);
    for (n = 0; n < a.length; n++) i = a[n], e.includes(i) || {}.propertyIsEnumerable.call(r, i) && (s[i] = r[i]);
  }
  return s;
}
function Dse(r, e) {
  if (r == null) return {};
  var i = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    i[n] = r[n];
  }
  return i;
}
function Lse(r, e) {
  return Ase(r) || Nse(r, e) || oO(r, e) || Pse();
}
function kse(r) {
  return Cse(r) || Rse(r) || oO(r) || Ise();
}
function Use(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function Fse(r) {
  var e = Use(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function oO(r, e) {
  if (r) {
    if (typeof r == "string") return e_(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? e_(r, e) : void 0;
  }
}
var Bse = function() {
  var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = (e instanceof Array ? e.length ? e : [void 0] : [e]).map(function(l) {
    return {
      keyAccessor: l,
      isProp: !(l instanceof Function)
    };
  }), a = r.reduce(function(l, u) {
    var c = l, h = u;
    return s.forEach(function(d, p) {
      var f = d.keyAccessor, m = d.isProp, y;
      if (m) {
        var v = h, g = v[f], _ = Ose(v, [f].map(Fse));
        y = g, h = _;
      } else
        y = f(h, p);
      p + 1 < s.length ? (c.hasOwnProperty(y) || (c[y] = {}), c = c[y]) : i ? (c.hasOwnProperty(y) || (c[y] = []), c[y].push(h)) : c[y] = h;
    }), l;
  }, {});
  i instanceof Function && function l(u) {
    var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    c === s.length ? Object.keys(u).forEach(function(h) {
      return u[h] = i(u[h]);
    }) : Object.values(u).forEach(function(h) {
      return l(h, c + 1);
    });
  }(a);
  var o = a;
  return n && (o = [], function l(u) {
    var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    c.length === s.length ? o.push({
      keys: c,
      vals: u
    }) : Object.entries(u).forEach(function(h) {
      var d = Lse(h, 2), p = d[0], f = d[1];
      return l(f, [].concat(kse(c), [p]));
    });
  }(a), e instanceof Array && e.length === 0 && o.length === 1 && (o[0].keys = [])), o;
};
function zse(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var jse = `.force-graph-container canvas {
  display: block;
  user-select: none;
  outline: none;
  -webkit-tap-highlight-color: transparent;
}

.force-graph-container .clickable {
  cursor: pointer;
}

.force-graph-container .grabbable {
  cursor: move;
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

.force-graph-container .grabbable:active {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
}
`;
zse(jse);
function t_(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Vse(r) {
  if (Array.isArray(r)) return r;
}
function Gse(r) {
  if (Array.isArray(r)) return t_(r);
}
function qA(r, e, i) {
  if (lO()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return s;
}
function Id(r, e, i) {
  return (e = Yse(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function lO() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (lO = function() {
    return !!r;
  })();
}
function Hse(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function Wse(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function qse() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Xse() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function XA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function Mu(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? XA(Object(i), !0).forEach(function(n) {
      Id(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : XA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function ld(r, e) {
  return Vse(r) || Wse(r, e) || uO(r, e) || qse();
}
function bn(r) {
  return Gse(r) || Hse(r) || uO(r) || Xse();
}
function $se(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Yse(r) {
  var e = $se(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function i_(r) {
  "@babel/helpers - typeof";
  return i_ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, i_(r);
}
function uO(r, e) {
  if (r) {
    if (typeof r == "string") return t_(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? t_(r, e) : void 0;
  }
}
var Kse = n1(_N);
function $A(r, e, i) {
  !e || typeof i != "string" || r.filter(function(n) {
    return !n[i];
  }).forEach(function(n) {
    n[i] = Kse(e(n));
  });
}
function Zse(r, e) {
  var i = r.nodes, n = r.links, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = s.nodeFilter, o = a === void 0 ? function() {
    return !0;
  } : a, l = s.onLoopError, u = l === void 0 ? function(f) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(f.join(" -> "), ".");
  } : l, c = {};
  i.forEach(function(f) {
    return c[e(f)] = {
      data: f,
      out: [],
      depth: -1,
      skip: !o(f)
    };
  }), n.forEach(function(f) {
    var m = f.source, y = f.target, v = b(m), g = b(y);
    if (!c.hasOwnProperty(v)) throw "Missing source node with id: ".concat(v);
    if (!c.hasOwnProperty(g)) throw "Missing target node with id: ".concat(g);
    var _ = c[v], x = c[g];
    _.out.push(x);
    function b(T) {
      return i_(T) === "object" ? e(T) : T;
    }
  });
  var h = [];
  p(Object.values(c));
  var d = Object.assign.apply(Object, [{}].concat(bn(Object.entries(c).filter(function(f) {
    var m = ld(f, 2), y = m[1];
    return !y.skip;
  }).map(function(f) {
    var m = ld(f, 2), y = m[0], v = m[1];
    return Id({}, y, v.depth);
  }))));
  return d;
  function p(f) {
    for (var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, v = function() {
      var x = f[g];
      if (m.indexOf(x) !== -1) {
        var b = [].concat(bn(m.slice(m.indexOf(x))), [x]).map(function(T) {
          return e(T.data);
        });
        return h.some(function(T) {
          return T.length === b.length && T.every(function(S, w) {
            return S === b[w];
          });
        }) || (h.push(b), u(b)), 1;
      }
      y > x.depth && (x.depth = y, p(x.out, [].concat(bn(m), [x]), y + (x.skip ? 0 : 1)));
    }, g = 0, _ = f.length; g < _; g++)
      v();
  }
}
var Qse = 2, dr = function(r, e) {
  return e.onNeedsRedraw && e.onNeedsRedraw();
}, YA = function(r, e) {
  if (!e.isShadow) {
    var i = et(e.linkDirectionalParticles);
    e.graphData.links.forEach(function(n) {
      var s = Math.round(Math.abs(i(n)));
      s ? n.__photons = bn(Array(s)).map(function() {
        return {};
      }) : delete n.__photons;
    });
  }
}, tg = Pl({
  props: {
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        e.engineRunning = !1, YA(r, e);
      }
    },
    dagMode: {
      onChange: function(r, e) {
        !r && (e.graphData.nodes || []).forEach(function(i) {
          return i.fx = i.fy = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function(r) {
        return !0;
      }
    },
    onDagError: {
      triggerUpdate: !1
    },
    nodeRelSize: {
      default: 4,
      triggerUpdate: !1,
      onChange: dr
    },
    // area per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val",
      triggerUpdate: !1,
      onChange: dr
    },
    nodeColor: {
      default: "color",
      triggerUpdate: !1,
      onChange: dr
    },
    nodeAutoColorBy: {},
    nodeCanvasObject: {
      triggerUpdate: !1,
      onChange: dr
    },
    nodeCanvasObjectMode: {
      default: function() {
        return "replace";
      },
      triggerUpdate: !1,
      onChange: dr
    },
    nodeVisibility: {
      default: !0,
      triggerUpdate: !1,
      onChange: dr
    },
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0,
      triggerUpdate: !1,
      onChange: dr
    },
    linkColor: {
      default: "color",
      triggerUpdate: !1,
      onChange: dr
    },
    linkAutoColorBy: {},
    linkLineDash: {
      triggerUpdate: !1,
      onChange: dr
    },
    linkWidth: {
      default: 1,
      triggerUpdate: !1,
      onChange: dr
    },
    linkCurvature: {
      default: 0,
      triggerUpdate: !1,
      onChange: dr
    },
    linkCanvasObject: {
      triggerUpdate: !1,
      onChange: dr
    },
    linkCanvasObjectMode: {
      default: function() {
        return "replace";
      },
      triggerUpdate: !1,
      onChange: dr
    },
    linkDirectionalArrowLength: {
      default: 0,
      triggerUpdate: !1,
      onChange: dr
    },
    linkDirectionalArrowColor: {
      triggerUpdate: !1,
      onChange: dr
    },
    linkDirectionalArrowRelPos: {
      default: 0.5,
      triggerUpdate: !1,
      onChange: dr
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalParticles: {
      default: 0,
      triggerUpdate: !1,
      onChange: YA
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01,
      triggerUpdate: !1
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 4,
      triggerUpdate: !1
    },
    linkDirectionalParticleColor: {
      triggerUpdate: !1
    },
    globalScale: {
      default: 1,
      triggerUpdate: !1
    },
    d3AlphaMin: {
      default: 0,
      triggerUpdate: !1
    },
    d3AlphaDecay: {
      default: 0.0228,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.alphaDecay(r);
      }
    },
    d3AlphaTarget: {
      default: 0,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.alphaTarget(r);
      }
    },
    d3VelocityDecay: {
      default: 0.4,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.velocityDecay(r);
      }
    },
    warmupTicks: {
      default: 0,
      triggerUpdate: !1
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      default: 1 / 0,
      triggerUpdate: !1
    },
    cooldownTime: {
      default: 15e3,
      triggerUpdate: !1
    },
    // ms
    onUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineTick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineStop: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNeedsRedraw: {
      triggerUpdate: !1
    },
    isShadow: {
      default: !1,
      triggerUpdate: !1
    }
  },
  methods: {
    // Expose d3 forces for external manipulation
    d3Force: function(r, e, i) {
      return i === void 0 ? r.forceLayout.force(e) : (r.forceLayout.force(e, i), this);
    },
    d3ReheatSimulation: function(r) {
      return r.forceLayout.alpha(1), this.resetCountdown(), this;
    },
    // reset cooldown state
    resetCountdown: function(r) {
      return r.cntTicks = 0, r.startTickTime = /* @__PURE__ */ new Date(), r.engineRunning = !0, this;
    },
    isEngineRunning: function(r) {
      return !!r.engineRunning;
    },
    tickFrame: function(r) {
      return !r.isShadow && e(), n(), !r.isShadow && s(), !r.isShadow && a(), i(), this;
      function e() {
        r.engineRunning && (++r.cntTicks > r.cooldownTicks || /* @__PURE__ */ new Date() - r.startTickTime > r.cooldownTime || r.d3AlphaMin > 0 && r.forceLayout.alpha() < r.d3AlphaMin ? (r.engineRunning = !1, r.onEngineStop()) : (r.forceLayout.tick(), r.onEngineTick()));
      }
      function i() {
        var o = et(r.nodeVisibility), l = et(r.nodeVal), u = et(r.nodeColor), c = et(r.nodeCanvasObjectMode), h = r.ctx, d = r.isShadow / r.globalScale, p = r.graphData.nodes.filter(o);
        h.save(), p.forEach(function(f) {
          var m = c(f);
          if (r.nodeCanvasObject && (m === "before" || m === "replace") && (r.nodeCanvasObject(f, h, r.globalScale), m === "replace")) {
            h.restore();
            return;
          }
          var y = Math.sqrt(Math.max(0, l(f) || 1)) * r.nodeRelSize + d;
          h.beginPath(), h.arc(f.x, f.y, y, 0, 2 * Math.PI, !1), h.fillStyle = u(f) || "rgba(31, 120, 180, 0.92)", h.fill(), r.nodeCanvasObject && m === "after" && r.nodeCanvasObject(f, r.ctx, r.globalScale);
        }), h.restore();
      }
      function n() {
        var o = et(r.linkVisibility), l = et(r.linkColor), u = et(r.linkWidth), c = et(r.linkLineDash), h = et(r.linkCurvature), d = et(r.linkCanvasObjectMode), p = r.ctx, f = r.isShadow * 2, m = r.graphData.links.filter(o);
        m.forEach(T);
        var y = [], v = [], g = m;
        if (r.linkCanvasObject) {
          var _ = [], x = [];
          m.forEach(function(S) {
            return ({
              before: y,
              after: v,
              replace: _
            }[d(S)] || x).push(S);
          }), g = [].concat(bn(y), v, x), y = y.concat(_);
        }
        p.save(), y.forEach(function(S) {
          return r.linkCanvasObject(S, p, r.globalScale);
        }), p.restore();
        var b = Bse(g, [l, u, c]);
        p.save(), Object.entries(b).forEach(function(S) {
          var w = ld(S, 2), M = w[0], E = w[1], A = !M || M === "undefined" ? "rgba(0,0,0,0.15)" : M;
          Object.entries(E).forEach(function(N) {
            var U = ld(N, 2), k = U[0], C = U[1], I = (k || 1) / r.globalScale + f;
            Object.entries(C).forEach(function(O) {
              var W = ld(O, 2);
              W[0];
              var V = W[1], Q = c(V[0]);
              p.beginPath(), V.forEach(function(F) {
                var B = F.source, q = F.target;
                if (!(!B || !q || !B.hasOwnProperty("x") || !q.hasOwnProperty("x"))) {
                  p.moveTo(B.x, B.y);
                  var G = F.__controlPoints;
                  G ? p[G.length === 2 ? "quadraticCurveTo" : "bezierCurveTo"].apply(p, bn(G).concat([q.x, q.y])) : p.lineTo(q.x, q.y);
                }
              }), p.strokeStyle = A, p.lineWidth = I, p.setLineDash(Q || []), p.stroke();
            });
          });
        }), p.restore(), p.save(), v.forEach(function(S) {
          return r.linkCanvasObject(S, p, r.globalScale);
        }), p.restore();
        function T(S) {
          var w = h(S);
          if (!w) {
            S.__controlPoints = null;
            return;
          }
          var M = S.source, E = S.target;
          if (!(!M || !E || !M.hasOwnProperty("x") || !E.hasOwnProperty("x"))) {
            var A = Math.sqrt(Math.pow(E.x - M.x, 2) + Math.pow(E.y - M.y, 2));
            if (A > 0) {
              var N = Math.atan2(E.y - M.y, E.x - M.x), U = A * w, k = {
                // control point
                x: (M.x + E.x) / 2 + U * Math.cos(N - Math.PI / 2),
                y: (M.y + E.y) / 2 + U * Math.sin(N - Math.PI / 2)
              };
              S.__controlPoints = [k.x, k.y];
            } else {
              var C = w * 70;
              S.__controlPoints = [E.x, E.y - C, E.x + C, E.y];
            }
          }
        }
      }
      function s() {
        var o = 1.6, l = 0.2, u = et(r.linkDirectionalArrowLength), c = et(r.linkDirectionalArrowRelPos), h = et(r.linkVisibility), d = et(r.linkDirectionalArrowColor || r.linkColor), p = et(r.nodeVal), f = r.ctx;
        f.save(), r.graphData.links.filter(h).forEach(function(m) {
          var y = u(m);
          if (!(!y || y < 0)) {
            var v = m.source, g = m.target;
            if (!(!v || !g || !v.hasOwnProperty("x") || !g.hasOwnProperty("x"))) {
              var _ = Math.sqrt(Math.max(0, p(v) || 1)) * r.nodeRelSize, x = Math.sqrt(Math.max(0, p(g) || 1)) * r.nodeRelSize, b = Math.min(1, Math.max(0, c(m))), T = d(m) || "rgba(0,0,0,0.28)", S = y / o / 2, w = m.__controlPoints && qA(oi, [v.x, v.y].concat(bn(m.__controlPoints), [g.x, g.y])), M = w ? function(I) {
                return w.get(I);
              } : function(I) {
                return {
                  // straight line: interpolate linearly
                  x: v.x + (g.x - v.x) * I || 0,
                  y: v.y + (g.y - v.y) * I || 0
                };
              }, E = w ? w.length() : Math.sqrt(Math.pow(g.x - v.x, 2) + Math.pow(g.y - v.y, 2)), A = _ + y + (E - _ - x - y) * b, N = M(A / E), U = M((A - y) / E), k = M((A - y * (1 - l)) / E), C = Math.atan2(N.y - U.y, N.x - U.x) - Math.PI / 2;
              f.beginPath(), f.moveTo(N.x, N.y), f.lineTo(U.x + S * Math.cos(C), U.y + S * Math.sin(C)), f.lineTo(k.x, k.y), f.lineTo(U.x - S * Math.cos(C), U.y - S * Math.sin(C)), f.fillStyle = T, f.fill();
            }
          }
        }), f.restore();
      }
      function a() {
        var o = et(r.linkDirectionalParticles), l = et(r.linkDirectionalParticleSpeed), u = et(r.linkDirectionalParticleWidth), c = et(r.linkVisibility), h = et(r.linkDirectionalParticleColor || r.linkColor), d = r.ctx;
        d.save(), r.graphData.links.filter(c).forEach(function(p) {
          var f = o(p);
          if (!(!p.hasOwnProperty("__photons") || !p.__photons.length)) {
            var m = p.source, y = p.target;
            if (!(!m || !y || !m.hasOwnProperty("x") || !y.hasOwnProperty("x"))) {
              var v = l(p), g = p.__photons || [], _ = Math.max(0, u(p) / 2) / Math.sqrt(r.globalScale), x = h(p) || "rgba(0,0,0,0.28)";
              d.fillStyle = x;
              var b = p.__controlPoints ? qA(oi, [m.x, m.y].concat(bn(p.__controlPoints), [y.x, y.y])) : null, T = 0, S = !1;
              g.forEach(function(w) {
                var M = !!w.__singleHop;
                if (w.hasOwnProperty("__progressRatio") || (w.__progressRatio = M ? 0 : T / f), !M && T++, w.__progressRatio += v, w.__progressRatio >= 1)
                  if (!M)
                    w.__progressRatio = w.__progressRatio % 1;
                  else {
                    S = !0;
                    return;
                  }
                var E = w.__progressRatio, A = b ? b.get(E) : {
                  // straight line: interpolate linearly
                  x: m.x + (y.x - m.x) * E || 0,
                  y: m.y + (y.y - m.y) * E || 0
                };
                d.beginPath(), d.arc(A.x, A.y, _, 0, 2 * Math.PI, !1), d.fill();
              }), S && (p.__photons = p.__photons.filter(function(w) {
                return !w.__singleHop || w.__progressRatio <= 1;
              }));
            }
          }
        }), d.restore();
      }
    },
    emitParticle: function(r, e) {
      return e && (!e.__photons && (e.__photons = []), e.__photons.push({
        __singleHop: !0
      })), this;
    }
  },
  stateInit: function() {
    return {
      forceLayout: HR().force("link", jR()).force("charge", WR()).force("center", DR()).force("dagRadial", null).stop(),
      engineRunning: !1
    };
  },
  init: function(r, e) {
    e.ctx = r;
  },
  update: function(r, e) {
    r.engineRunning = !1, r.onUpdate(), r.nodeAutoColorBy !== null && $A(r.graphData.nodes, et(r.nodeAutoColorBy), r.nodeColor), r.linkAutoColorBy !== null && $A(r.graphData.links, et(r.linkAutoColorBy), r.linkColor), r.graphData.links.forEach(function(d) {
      d.source = d[r.linkSource], d.target = d[r.linkTarget];
    }), r.forceLayout.stop().alpha(1).nodes(r.graphData.nodes);
    var i = r.forceLayout.force("link");
    i && i.id(function(d) {
      return d[r.nodeId];
    }).links(r.graphData.links);
    var n = r.dagMode && Zse(r.graphData, function(d) {
      return d[r.nodeId];
    }, {
      nodeFilter: r.dagNodeFilter,
      onLoopError: r.onDagError || void 0
    }), s = Math.max.apply(Math, bn(Object.values(n || []))), a = r.dagLevelDistance || r.graphData.nodes.length / (s || 1) * Qse * (["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? 0.7 : 1);
    if (["lr", "rl", "td", "bu"].includes(e.dagMode)) {
      var o = ["lr", "rl"].includes(e.dagMode) ? "fx" : "fy";
      r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(d) {
        return delete d[o];
      });
    }
    if (["lr", "rl", "td", "bu"].includes(r.dagMode)) {
      var l = ["rl", "bu"].includes(r.dagMode), u = function(d) {
        return (n[d[r.nodeId]] - s / 2) * a * (l ? -1 : 1);
      }, c = ["lr", "rl"].includes(r.dagMode) ? "fx" : "fy";
      r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(d) {
        return d[c] = u(d);
      });
    }
    r.forceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? qR(function(d) {
      var p = n[d[r.nodeId]] || -1;
      return (r.dagMode === "radialin" ? s - p : p) * a;
    }).strength(function(d) {
      return r.dagNodeFilter(d) ? 1 : 0;
    }) : null);
    for (var h = 0; h < r.warmupTicks && !(r.d3AlphaMin > 0 && r.forceLayout.alpha() < r.d3AlphaMin); h++)
      r.forceLayout.tick();
    this.resetCountdown(), r.onFinishUpdate();
  }
});
function cO(r, e) {
  var i = r instanceof Array ? r : [r], n = new e();
  return n._destructor && n._destructor(), {
    linkProp: function(s) {
      return {
        default: n[s](),
        onChange: function(a, o) {
          i.forEach(function(l) {
            return o[l][s](a);
          });
        },
        triggerUpdate: !1
      };
    },
    linkMethod: function(s) {
      return function(a) {
        for (var o = arguments.length, l = new Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)
          l[u - 1] = arguments[u];
        var c = [];
        return i.forEach(function(h) {
          var d = a[h], p = d[s].apply(d, l);
          p !== d && c.push(p);
        }), c.length ? c[0] : this;
      };
    }
  };
}
var Jse = 800, eae = 4, tae = 5, hO = cO("forceGraph", tg), iae = cO(["forceGraph", "shadowGraph"], tg), rae = Object.assign.apply(Object, bn(["nodeColor", "nodeAutoColorBy", "nodeCanvasObject", "nodeCanvasObjectMode", "linkColor", "linkAutoColorBy", "linkLineDash", "linkWidth", "linkCanvasObject", "linkCanvasObjectMode", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(r) {
  return Id({}, r, hO.linkProp(r));
})).concat(bn(["nodeRelSize", "nodeId", "nodeVal", "nodeVisibility", "linkSource", "linkTarget", "linkVisibility", "linkCurvature"].map(function(r) {
  return Id({}, r, iae.linkProp(r));
})))), nae = Object.assign.apply(Object, bn(["d3Force", "d3ReheatSimulation", "emitParticle"].map(function(r) {
  return Id({}, r, hO.linkMethod(r));
})));
function Ov(r) {
  if (r.canvas) {
    var e = r.canvas.width, i = r.canvas.height;
    e === 300 && i === 150 && (e = i = 0);
    var n = window.devicePixelRatio;
    e /= n, i /= n, [r.canvas, r.shadowCanvas].forEach(function(a) {
      a.style.width = "".concat(r.width, "px"), a.style.height = "".concat(r.height, "px"), a.width = r.width * n, a.height = r.height * n, !e && !i && a.getContext("2d").scale(n, n);
    });
    var s = ss(r.canvas).k;
    r.zoom.translateBy(r.zoom.__baseElem, (r.width - e) / 2 / s, (r.height - i) / 2 / s), r.needsRedraw = !0;
  }
}
function dO(r) {
  var e = window.devicePixelRatio;
  r.setTransform(e, 0, 0, e, 0, 0);
}
function KA(r, e, i) {
  r.save(), dO(r), r.clearRect(0, 0, e, i), r.restore();
}
var sae = Pl({
  props: Mu({
    width: {
      default: window.innerWidth,
      onChange: function(r, e) {
        return Ov(e);
      },
      triggerUpdate: !1
    },
    height: {
      default: window.innerHeight,
      onChange: function(r, e) {
        return Ov(e);
      },
      triggerUpdate: !1
    },
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        [r.nodes, r.links].every(function(n) {
          return (n || []).every(function(s) {
            return !s.hasOwnProperty("__indexColor");
          });
        }) && e.colorTracker.reset(), [{
          type: "Node",
          objs: r.nodes
        }, {
          type: "Link",
          objs: r.links
        }].forEach(i), e.forceGraph.graphData(r), e.shadowGraph.graphData(r);
        function i(n) {
          var s = n.type, a = n.objs;
          a.filter(function(o) {
            if (!o.hasOwnProperty("__indexColor")) return !0;
            var l = e.colorTracker.lookup(o.__indexColor);
            return !l || !l.hasOwnProperty("d") || l.d !== o;
          }).forEach(function(o) {
            o.__indexColor = e.colorTracker.register({
              type: s,
              d: o
            });
          });
        }
      },
      triggerUpdate: !1
    },
    backgroundColor: {
      onChange: function(r, e) {
        e.canvas && r && (e.canvas.style.background = r);
      },
      triggerUpdate: !1
    },
    nodeLabel: {
      default: "name",
      triggerUpdate: !1
    },
    nodePointerAreaPaint: {
      onChange: function(r, e) {
        e.shadowGraph.nodeCanvasObject(r ? function(i, n, s) {
          return r(i, i.__indexColor, n, s);
        } : null), e.flushShadowCanvas && e.flushShadowCanvas();
      },
      triggerUpdate: !1
    },
    linkPointerAreaPaint: {
      onChange: function(r, e) {
        e.shadowGraph.linkCanvasObject(r ? function(i, n, s) {
          return r(i, i.__indexColor, n, s);
        } : null), e.flushShadowCanvas && e.flushShadowCanvas();
      },
      triggerUpdate: !1
    },
    linkLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkHoverPrecision: {
      default: 4,
      triggerUpdate: !1
    },
    minZoom: {
      default: 0.01,
      onChange: function(r, e) {
        e.zoom.scaleExtent([r, e.zoom.scaleExtent()[1]]);
      },
      triggerUpdate: !1
    },
    maxZoom: {
      default: 1e3,
      onChange: function(r, e) {
        e.zoom.scaleExtent([e.zoom.scaleExtent()[0], r]);
      },
      triggerUpdate: !1
    },
    enableNodeDrag: {
      default: !0,
      triggerUpdate: !1
    },
    enableZoomInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    enablePanInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    enableZoomPanInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    // to be deprecated
    enablePointerInteraction: {
      default: !0,
      onChange: function(r, e) {
        e.hoverObj = null;
      },
      triggerUpdate: !1
    },
    autoPauseRedraw: {
      default: !0,
      triggerUpdate: !1
    },
    onNodeDrag: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeDragEnd: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeClick: {
      triggerUpdate: !1
    },
    onNodeRightClick: {
      triggerUpdate: !1
    },
    onNodeHover: {
      triggerUpdate: !1
    },
    onLinkClick: {
      triggerUpdate: !1
    },
    onLinkRightClick: {
      triggerUpdate: !1
    },
    onLinkHover: {
      triggerUpdate: !1
    },
    onBackgroundClick: {
      triggerUpdate: !1
    },
    onBackgroundRightClick: {
      triggerUpdate: !1
    },
    onZoom: {
      triggerUpdate: !1
    },
    onZoomEnd: {
      triggerUpdate: !1
    },
    onRenderFramePre: {
      triggerUpdate: !1
    },
    onRenderFramePost: {
      triggerUpdate: !1
    }
  }, rae),
  aliases: {
    // Prop names supported for backwards compatibility
    stopAnimation: "pauseAnimation"
  },
  methods: Mu({
    graph2ScreenCoords: function(r, e, i) {
      var n = ss(r.canvas);
      return {
        x: e * n.k + n.x,
        y: i * n.k + n.y
      };
    },
    screen2GraphCoords: function(r, e, i) {
      var n = ss(r.canvas);
      return {
        x: (e - n.x) / n.k,
        y: (i - n.y) / n.k
      };
    },
    centerAt: function(r, e, i, n) {
      if (!r.canvas) return null;
      if (e !== void 0 || i !== void 0) {
        var s = Object.assign({}, e !== void 0 ? {
          x: e
        } : {}, i !== void 0 ? {
          y: i
        } : {});
        return n ? r.tweenGroup.add(new Zm(a()).to(s, n).easing(va.Quadratic.Out).onUpdate(o).start()) : o(s), this;
      }
      return a();
      function a() {
        var l = ss(r.canvas);
        return {
          x: (r.width / 2 - l.x) / l.k,
          y: (r.height / 2 - l.y) / l.k
        };
      }
      function o(l) {
        var u = l.x, c = l.y;
        r.zoom.translateTo(r.zoom.__baseElem, u === void 0 ? a().x : u, c === void 0 ? a().y : c), r.needsRedraw = !0;
      }
    },
    zoom: function(r, e, i) {
      if (!r.canvas) return null;
      if (e !== void 0)
        return i ? r.tweenGroup.add(new Zm({
          k: n()
        }).to({
          k: e
        }, i).easing(va.Quadratic.Out).onUpdate(function(a) {
          var o = a.k;
          return s(o);
        }).start()) : s(e), this;
      return n();
      function n() {
        return ss(r.canvas).k;
      }
      function s(a) {
        r.zoom.scaleTo(r.zoom.__baseElem, a), r.needsRedraw = !0;
      }
    },
    zoomToFit: function(r) {
      for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, n = arguments.length, s = new Array(n > 3 ? n - 3 : 0), a = 3; a < n; a++)
        s[a - 3] = arguments[a];
      var o = this.getGraphBbox.apply(this, s);
      if (o) {
        var l = {
          x: (o.x[0] + o.x[1]) / 2,
          y: (o.y[0] + o.y[1]) / 2
        }, u = Math.max(1e-12, Math.min(1e12, (r.width - i * 2) / (o.x[1] - o.x[0]), (r.height - i * 2) / (o.y[1] - o.y[0])));
        this.centerAt(l.x, l.y, e), this.zoom(u, e);
      }
      return this;
    },
    getGraphBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      }, i = et(r.nodeVal), n = function(a) {
        return Math.sqrt(Math.max(0, i(a) || 1)) * r.nodeRelSize;
      }, s = r.graphData.nodes.filter(e).map(function(a) {
        return {
          x: a.x,
          y: a.y,
          r: n(a)
        };
      });
      return s.length ? {
        x: [Gb(s, function(a) {
          return a.x - a.r;
        }), Vb(s, function(a) {
          return a.x + a.r;
        })],
        y: [Gb(s, function(a) {
          return a.y - a.r;
        }), Vb(s, function(a) {
          return a.y + a.r;
        })]
      } : null;
    },
    pauseAnimation: function(r) {
      return r.animationFrameRequestId && (cancelAnimationFrame(r.animationFrameRequestId), r.animationFrameRequestId = null), this;
    },
    resumeAnimation: function(r) {
      return r.animationFrameRequestId || this._animationCycle(), this;
    },
    _destructor: function() {
      this.pauseAnimation(), this.graphData({
        nodes: [],
        links: []
      });
    }
  }, nae),
  stateInit: function() {
    return {
      lastSetZoom: 1,
      zoom: ise(),
      forceGraph: new tg(),
      shadowGraph: new tg().cooldownTicks(0).nodeColor("__indexColor").linkColor("__indexColor").isShadow(!0),
      colorTracker: new bse(),
      // indexed objects for rgb lookup
      tweenGroup: new eT()
    };
  },
  init: function(r, e) {
    var i = this;
    r.innerHTML = "";
    var n = document.createElement("div");
    n.classList.add("force-graph-container"), n.style.position = "relative", r.appendChild(n), e.canvas = document.createElement("canvas"), e.backgroundColor && (e.canvas.style.background = e.backgroundColor), n.appendChild(e.canvas), e.shadowCanvas = document.createElement("canvas");
    var s = e.canvas.getContext("2d"), a = e.shadowCanvas.getContext("2d", {
      willReadFrequently: !0
    }), o = {
      x: -1e12,
      y: -1e12
    }, l = function() {
      var c = null, h = window.devicePixelRatio, d = o.x > 0 && o.y > 0 ? a.getImageData(o.x * h, o.y * h, 1, 1) : null;
      return d && (c = e.colorTracker.lookup(d.data)), c;
    };
    vn(e.canvas).call(Vre().subject(function() {
      if (!e.enableNodeDrag)
        return null;
      var c = l();
      return c && c.type === "Node" ? c.d : null;
    }).on("start", function(c) {
      var h = c.subject;
      h.__initialDragPos = {
        x: h.x,
        y: h.y,
        fx: h.fx,
        fy: h.fy
      }, c.active || (h.fx = h.x, h.fy = h.y), e.canvas.classList.add("grabbable");
    }).on("drag", function(c) {
      var h = c.subject, d = h.__initialDragPos, p = c, f = ss(e.canvas).k, m = {
        x: d.x + (p.x - d.x) / f - h.x,
        y: d.y + (p.y - d.y) / f - h.y
      };
      ["x", "y"].forEach(function(y) {
        return h["f".concat(y)] = h[y] = d[y] + (p[y] - d[y]) / f;
      }), !(!h.__dragged && tae >= Math.sqrt(V8(["x", "y"].map(function(y) {
        return Math.pow(c[y] - d[y], 2);
      })))) && (e.forceGraph.d3AlphaTarget(0.3).resetCountdown(), e.isPointerDragging = !0, h.__dragged = !0, e.onNodeDrag(h, m));
    }).on("end", function(c) {
      var h = c.subject, d = h.__initialDragPos, p = {
        x: h.x - d.x,
        y: h.y - d.y
      };
      d.fx === void 0 && (h.fx = void 0), d.fy === void 0 && (h.fy = void 0), delete h.__initialDragPos, e.forceGraph.d3AlphaTarget() && e.forceGraph.d3AlphaTarget(0).resetCountdown(), e.canvas.classList.remove("grabbable"), e.isPointerDragging = !1, h.__dragged && (delete h.__dragged, e.onNodeDragEnd(h, p));
    })), e.zoom(e.zoom.__baseElem = vn(e.canvas)), e.zoom.__baseElem.on("dblclick.zoom", null), e.zoom.filter(function(c) {
      return (
        // disable zoom interaction
        !c.button && e.enableZoomPanInteraction && (c.type !== "wheel" || et(e.enableZoomInteraction)(c)) && (c.type === "wheel" || et(e.enablePanInteraction)(c))
      );
    }).on("zoom", function(c) {
      var h = c.transform;
      [s, a].forEach(function(d) {
        dO(d), d.translate(h.x, h.y), d.scale(h.k, h.k);
      }), e.onZoom && e.onZoom(Mu(Mu({}, h), i.centerAt())), e.needsRedraw = !0;
    }).on("end", function(c) {
      return e.onZoomEnd && e.onZoomEnd(Mu(Mu({}, c.transform), i.centerAt()));
    }), Ov(e), e.forceGraph.onNeedsRedraw(function() {
      return e.needsRedraw = !0;
    }).onFinishUpdate(function() {
      ss(e.canvas).k === e.lastSetZoom && e.graphData.nodes.length && (e.zoom.scaleTo(e.zoom.__baseElem, e.lastSetZoom = eae / Math.cbrt(e.graphData.nodes.length)), e.needsRedraw = !0);
    }), e.tooltip = new X3(n), ["pointermove", "pointerdown"].forEach(function(c) {
      return n.addEventListener(c, function(h) {
        c === "pointerdown" && (e.isPointerPressed = !0, e.pointerDownEvent = h), !e.isPointerDragging && h.type === "pointermove" && e.onBackgroundClick && (h.pressure > 0 || e.isPointerPressed) && (h.pointerType !== "touch" || h.movementX === void 0 || [h.movementX, h.movementY].some(function(f) {
          return Math.abs(f) > 1;
        })) && (e.isPointerDragging = !0);
        var d = p(n);
        o.x = h.pageX - d.left, o.y = h.pageY - d.top;
        function p(f) {
          var m = f.getBoundingClientRect(), y = window.pageXOffset || document.documentElement.scrollLeft, v = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: m.top + v,
            left: m.left + y
          };
        }
      }, {
        passive: !0
      });
    }), n.addEventListener("pointerup", function(c) {
      if (e.isPointerPressed = !1, e.isPointerDragging) {
        e.isPointerDragging = !1;
        return;
      }
      var h = [c, e.pointerDownEvent];
      requestAnimationFrame(function() {
        if (c.button === 0)
          if (e.hoverObj) {
            var d = e["on".concat(e.hoverObj.type, "Click")];
            d && d.apply(void 0, [e.hoverObj.d].concat(h));
          } else
            e.onBackgroundClick && e.onBackgroundClick.apply(e, h);
        if (c.button === 2)
          if (e.hoverObj) {
            var p = e["on".concat(e.hoverObj.type, "RightClick")];
            p && p.apply(void 0, [e.hoverObj.d].concat(h));
          } else
            e.onBackgroundRightClick && e.onBackgroundRightClick.apply(e, h);
      });
    }, {
      passive: !0
    }), n.addEventListener("contextmenu", function(c) {
      return !e.onBackgroundRightClick && !e.onNodeRightClick && !e.onLinkRightClick ? !0 : (c.preventDefault(), !1);
    }), e.forceGraph(s), e.shadowGraph(a);
    var u = nse(function() {
      KA(a, e.width, e.height), e.shadowGraph.linkWidth(function(h) {
        return et(e.linkWidth)(h) + e.linkHoverPrecision;
      });
      var c = ss(e.canvas);
      e.shadowGraph.globalScale(c.k).tickFrame();
    }, Jse);
    e.flushShadowCanvas = u.flush, (this._animationCycle = function c() {
      var h = !e.autoPauseRedraw || !!e.needsRedraw || e.forceGraph.isEngineRunning() || e.graphData.links.some(function(_) {
        return _.__photons && _.__photons.length;
      });
      if (e.needsRedraw = !1, e.enablePointerInteraction) {
        var d = e.isPointerDragging ? null : l();
        if (d !== e.hoverObj) {
          var p = e.hoverObj, f = p ? p.type : null, m = d ? d.type : null;
          if (f && f !== m) {
            var y = e["on".concat(f, "Hover")];
            y && y(null, p.d);
          }
          if (m) {
            var v = e["on".concat(m, "Hover")];
            v && v(d.d, f === m ? p.d : null);
          }
          e.tooltip.content(d && et(e["".concat(d.type.toLowerCase(), "Label")])(d.d) || null), e.canvas.classList[d && e["on".concat(m, "Click")] || !d && e.onBackgroundClick ? "add" : "remove"]("clickable"), e.hoverObj = d;
        }
        h && u();
      }
      if (h) {
        KA(s, e.width, e.height);
        var g = ss(e.canvas).k;
        e.onRenderFramePre && e.onRenderFramePre(s, g), e.forceGraph.globalScale(g).tickFrame(), e.onRenderFramePost && e.onRenderFramePost(s, g);
      }
      e.tweenGroup.update(), e.animationFrameRequestId = requestAnimationFrame(c);
    })();
  },
  update: function(r) {
  }
}), Jg = {
  width: ie.number,
  height: ie.number,
  graphData: ie.shape({
    nodes: ie.arrayOf(ie.object).isRequired,
    links: ie.arrayOf(ie.object).isRequired
  }),
  backgroundColor: ie.string,
  nodeRelSize: ie.number,
  nodeId: ie.string,
  nodeLabel: ie.oneOfType([ie.string, ie.func]),
  nodeVal: ie.oneOfType([ie.number, ie.string, ie.func]),
  nodeVisibility: ie.oneOfType([ie.bool, ie.string, ie.func]),
  nodeColor: ie.oneOfType([ie.string, ie.func]),
  nodeAutoColorBy: ie.oneOfType([ie.string, ie.func]),
  onNodeHover: ie.func,
  onNodeClick: ie.func,
  linkSource: ie.string,
  linkTarget: ie.string,
  linkLabel: ie.oneOfType([ie.string, ie.func]),
  linkVisibility: ie.oneOfType([ie.bool, ie.string, ie.func]),
  linkColor: ie.oneOfType([ie.string, ie.func]),
  linkAutoColorBy: ie.oneOfType([ie.string, ie.func]),
  linkWidth: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkCurvature: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalArrowLength: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalArrowColor: ie.oneOfType([ie.string, ie.func]),
  linkDirectionalArrowRelPos: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticles: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticleSpeed: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticleWidth: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticleColor: ie.oneOfType([ie.string, ie.func]),
  onLinkHover: ie.func,
  onLinkClick: ie.func,
  dagMode: ie.oneOf(["td", "bu", "lr", "rl", "zin", "zout", "radialin", "radialout"]),
  dagLevelDistance: ie.number,
  dagNodeFilter: ie.func,
  onDagError: ie.func,
  d3AlphaMin: ie.number,
  d3AlphaDecay: ie.number,
  d3VelocityDecay: ie.number,
  warmupTicks: ie.number,
  cooldownTicks: ie.number,
  cooldownTime: ie.number,
  onEngineTick: ie.func,
  onEngineStop: ie.func,
  getGraphBbox: ie.func
}, pO = {
  zoomToFit: ie.func,
  onNodeRightClick: ie.func,
  onNodeDrag: ie.func,
  onNodeDragEnd: ie.func,
  onLinkRightClick: ie.func,
  linkHoverPrecision: ie.number,
  onBackgroundClick: ie.func,
  onBackgroundRightClick: ie.func,
  enablePointerInteraction: ie.bool,
  enableNodeDrag: ie.bool
}, cT = {
  showNavInfo: ie.bool,
  nodeOpacity: ie.number,
  nodeResolution: ie.number,
  nodeThreeObject: ie.oneOfType([ie.object, ie.string, ie.func]),
  nodeThreeObjectExtend: ie.oneOfType([ie.bool, ie.string, ie.func]),
  linkOpacity: ie.number,
  linkResolution: ie.number,
  linkCurveRotation: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkMaterial: ie.oneOfType([ie.object, ie.string, ie.func]),
  linkThreeObject: ie.oneOfType([ie.object, ie.string, ie.func]),
  linkThreeObjectExtend: ie.oneOfType([ie.bool, ie.string, ie.func]),
  linkPositionUpdate: ie.func,
  linkDirectionalArrowResolution: ie.number,
  linkDirectionalParticleResolution: ie.number,
  forceEngine: ie.oneOf(["d3", "ngraph"]),
  ngraphPhysics: ie.object,
  numDimensions: ie.oneOf([1, 2, 3])
}, aae = Object.assign({}, Jg, pO, {
  linkLineDash: ie.oneOfType([ie.arrayOf(ie.number), ie.string, ie.func]),
  nodeCanvasObjectMode: ie.oneOfType([ie.string, ie.func]),
  nodeCanvasObject: ie.func,
  nodePointerAreaPaint: ie.func,
  linkCanvasObjectMode: ie.oneOfType([ie.string, ie.func]),
  linkCanvasObject: ie.func,
  linkPointerAreaPaint: ie.func,
  autoPauseRedraw: ie.bool,
  minZoom: ie.number,
  maxZoom: ie.number,
  enableZoomInteraction: ie.oneOfType([ie.bool, ie.func]),
  enablePanInteraction: ie.oneOfType([ie.bool, ie.func]),
  onZoom: ie.func,
  onZoomEnd: ie.func,
  onRenderFramePre: ie.func,
  onRenderFramePost: ie.func
}), oae = Object.assign({}, Jg, pO, cT, {
  enableNavigationControls: ie.bool,
  controlType: ie.oneOf(["trackball", "orbit", "fly"]),
  rendererConfig: ie.object,
  extraRenderers: ie.arrayOf(ie.shape({
    render: ie.func.isRequired
  }))
}), lae = Object.assign({}, Jg, cT, {
  nodeDesc: ie.oneOfType([ie.string, ie.func]),
  linkDesc: ie.oneOfType([ie.string, ie.func])
}), uae = Object.assign({}, Jg, cT, {
  markerAttrs: ie.object,
  yOffset: ie.number,
  glScale: ie.number
});
const fO = vg(S2, {
  methodNames: [
    // bind methods
    "getGraphBbox",
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "refresh"
  ]
});
fO.displayName = "ForceGraphVR";
fO.propTypes = lae;
const mO = vg(R9, {
  methodNames: [
    // bind methods
    "getGraphBbox",
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "refresh"
  ],
  initPropNames: ["markerAttrs"]
});
mO.displayName = "ForceGraphAR";
mO.propTypes = uae;
const hT = vg(kre, {
  methodNames: [
    // bind methods
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "stopAnimation",
    "pauseAnimation",
    "resumeAnimation",
    "cameraPosition",
    "zoomToFit",
    "getGraphBbox",
    "screen2GraphCoords",
    "graph2ScreenCoords",
    "postProcessingComposer",
    "lights",
    "scene",
    "camera",
    "renderer",
    "controls",
    "refresh"
  ],
  initPropNames: ["controlType", "rendererConfig", "extraRenderers"]
});
hT.displayName = "ForceGraph3D";
hT.propTypes = oae;
const dT = vg(sae, {
  methodNames: [
    // bind methods
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "stopAnimation",
    "pauseAnimation",
    "resumeAnimation",
    "centerAt",
    "zoom",
    "zoomToFit",
    "getGraphBbox",
    "screen2GraphCoords",
    "graph2ScreenCoords"
  ]
});
dT.displayName = "ForceGraph2D";
dT.propTypes = aae;
const cae = {
  position: "absolute",
  pointerEvents: "none",
  background: Ei.PREDICATE,
  color: "#fff",
  border: `2px solid ${Ei.PREDICATE}`,
  borderRadius: 8,
  padding: "6px 14px",
  fontSize: 15,
  fontWeight: "bold",
  zIndex: 1e3,
  boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
  whiteSpace: "nowrap",
  maxWidth: 260,
  overflow: "hidden",
  textOverflow: "ellipsis"
}, hae = 16, ZA = 32, dae = ({
  graphData: r,
  onNodeClick: e,
  onEngineStop: i,
  fgRef: n,
  children: s,
  selectedTriple: a,
  endpoint: o,
  disableNodeDetailsSidebar: l = !1
}) => {
  const u = gr(), [c, h] = ve(null), [d, p] = ve(null), [f, m] = ve({ x: 0, y: 0 }), [y, v] = ve({ width: 100, height: 100 }), [g, _] = ve(/* @__PURE__ */ new Map());
  Ft(() => {
    const w = () => {
      u.current && v({
        width: u.current.clientWidth,
        height: u.current.clientHeight
      });
    };
    return w(), window.addEventListener("resize", w), () => window.removeEventListener("resize", w);
  }, []), Ft(() => {
    r.nodes.forEach((w) => {
      if (w.image && !g.has(w.image)) {
        const M = new Image();
        M.crossOrigin = "anonymous", M.src = w.image, M.onload = () => {
          _((E) => new Map(E).set(w.image, M)), n.current && n.current.emit("redraw");
        };
      }
    });
  }, [r.nodes]);
  const x = Or(() => {
    h(null), p(null);
  }, []), b = Or((w) => {
    if (u.current) {
      const M = u.current.getBoundingClientRect();
      m({
        x: w.clientX - M.left,
        y: w.clientY - M.top
      });
    }
  }, []), T = Or(() => {
    h(null), p(null);
  }, []), S = () => {
    if (!u.current) return { left: f.x, top: f.y };
    const w = u.current.getBoundingClientRect(), M = 180, E = 36;
    let A = f.x + hae, N = f.y - ZA;
    return A + M > w.width && (A = w.width - M - 8), A < 0 && (A = 8), N < 0 && (N = f.y + ZA), N + E > w.height && (N = w.height - E - 8), { left: A, top: N };
  };
  return /* @__PURE__ */ ae.jsxs(
    "div",
    {
      ref: u,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      onMouseMove: b,
      children: [
        /* @__PURE__ */ ae.jsx(
          dT,
          {
            ref: n,
            graphData: r,
            width: y.width,
            height: y.height,
            nodeCanvasObject: (w, M, E) => {
              const A = 44 / E * Math.pow(E, 0.15);
              if (w.type === "object")
                if (w.image) {
                  if (M.save(), M.beginPath(), M.rect(w.x - A / 2, w.y - A / 2, A, A), M.closePath(), M.strokeStyle = w.color, M.lineWidth = 3 / E, M.stroke(), M.clip(), !w.__img) {
                    const N = new window.Image();
                    N.crossOrigin = "anonymous", N.src = w.image, N.onload = () => {
                      w.__imgLoaded = !0, n && n.current && n.current.emit && n.current.emit("redraw");
                    }, w.__img = N, w.__imgLoaded = !1;
                  }
                  w.__imgLoaded ? M.drawImage(
                    w.__img,
                    w.x - A / 2,
                    w.y - A / 2,
                    A,
                    A
                  ) : (M.fillStyle = w.color || "#888", M.fillRect(w.x - A / 2, w.y - A / 2, A, A)), M.restore();
                } else {
                  M.save(), M.beginPath(), M.rect(w.x - A / 2, w.y - A / 2, A, A), M.closePath(), M.fillStyle = w.color + "CC", M.fill(), M.strokeStyle = w.color, M.lineWidth = 3 / E, M.stroke();
                  const N = (w.label || "?").substring(0, 3), U = 20 / E;
                  M.font = `bold ${U}px Sans-Serif`, M.fillStyle = "#fff", M.textAlign = "center", M.textBaseline = "middle", M.fillText(N, w.x, w.y + A * 0.04), M.restore();
                }
              else if (w.image) {
                if (!w.__img) {
                  const N = new window.Image();
                  N.src = w.image, N.onload = () => {
                    w.__imgLoaded = !0, n && n.current && n.current.emit && n.current.emit("redraw");
                  }, w.__img = N, w.__imgLoaded = !1;
                }
                M.save(), M.beginPath(), M.arc(w.x, w.y, A / 2, 0, 2 * Math.PI, !1), M.closePath(), M.lineWidth = 3 / E, M.strokeStyle = w.color, M.stroke(), M.clip(), w.__imgLoaded ? M.drawImage(
                  w.__img,
                  w.x - A / 2,
                  w.y - A / 2,
                  A,
                  A
                ) : (M.fillStyle = w.color || "#888", M.fill()), M.restore();
              } else {
                M.save(), M.beginPath(), M.arc(w.x, w.y, A / 2, 0, 2 * Math.PI, !1), M.closePath(), M.fillStyle = w.color + "CC", M.fill(), M.strokeStyle = w.color, M.lineWidth = 3 / E, M.stroke();
                const N = (w.label || "?").substring(0, 3), U = 20 / E;
                M.font = `bold ${U}px Sans-Serif`, M.fillStyle = "#fff", M.textAlign = "center", M.textBaseline = "middle", M.fillText(N, w.x, w.y + A * 0.04), M.restore();
              }
            },
            nodePointerAreaPaint: (w, M, E, A) => {
              const N = 44 / A * Math.pow(A, 0.15);
              E.fillStyle = M, w.type === "object" ? (E.beginPath(), E.rect(w.x - N / 2, w.y - N / 2, N, N), E.closePath(), E.fill()) : (E.beginPath(), E.arc(w.x, w.y, N / 2, 0, 2 * Math.PI, !1), E.closePath(), E.fill());
            },
            linkColor: () => "rgba(255, 211, 42, 0.15)",
            linkDirectionalParticles: 1,
            linkDirectionalParticleSpeed: 0.01,
            linkDirectionalParticleColor: () => "rgba(255,255,255,0.5)",
            nodeAutoColorBy: "type",
            onNodeClick: e,
            onEngineStop: i,
            onNodeHover: p,
            onLinkHover: h,
            onBackgroundClick: T,
            onZoom: x
          }
        ),
        c && c.label ? /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              ...cae,
              ...S(),
              pointerEvents: "none"
            },
            children: c.label
          }
        ) : d && d.label ? /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: f.x + 18,
              top: f.y - 10,
              background: "#232326",
              color: "#fff",
              border: "1.5px solid #ffd32a",
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 1e3,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: d.label
          }
        ) : null,
        a && !l && /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: 80,
              right: 30,
              width: 350,
              zIndex: 9999,
              maxHeight: "80vh",
              background: "#18181b",
              borderRadius: "10px",
              border: "3px solid #ffd32a",
              boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
              overflowY: "auto"
            },
            children: /* @__PURE__ */ ae.jsx(
              E_,
              {
                triple: a,
                endpoint: o,
                onClose: () => e(null)
              }
            )
          }
        ),
        /* @__PURE__ */ ae.jsx("div", { style: { position: "relative", zIndex: 2e3 }, children: s })
      ]
    }
  );
};
var pae = typeof window < "u" && window.THREE ? window.THREE : {
  Sprite: kj
};
pae.Sprite;
const fae = ({
  graphData: r,
  onNodeClick: e,
  onEngineStop: i,
  fgRef: n,
  children: s,
  selectedTriple: a,
  endpoint: o,
  disableNodeDetailsSidebar: l = !1
}) => {
  const u = gr(), [c, h] = ve({ width: 100, height: 100 }), [d, p] = ve(null), [f, m] = ve(null), [y, v] = ve({ x: 0, y: 0 }), g = gr(/* @__PURE__ */ new Map());
  Ft(() => {
    const x = () => {
      u.current && h({
        width: u.current.clientWidth,
        height: u.current.clientHeight
      });
    };
    return x(), window.addEventListener("resize", x), () => window.removeEventListener("resize", x);
  }, []);
  const _ = (x) => {
    if (g.current.has(x.id))
      return g.current.get(x.id);
    const b = 128, T = document.createElement("canvas");
    T.width = T.height = b;
    const S = T.getContext("2d");
    if (S.clearRect(0, 0, b, b), x.image) {
      const E = new window.Image();
      E.crossOrigin = "anonymous", E.src = x.image, E.onload = () => {
        if (S.clearRect(0, 0, b, b), x.type === "object") {
          S.fillStyle = Nu(x.type) + "CC", S.fillRect(0, 0, b, b);
          const A = Math.max(b / E.width, b / E.height), N = E.width * A, U = E.height * A;
          S.drawImage(E, b / 2 - N / 2, b / 2 - U / 2, N, U);
        } else {
          S.save(), S.beginPath(), S.arc(b / 2, b / 2, b / 2, 0, 2 * Math.PI), S.closePath(), S.clip(), S.fillStyle = Nu(x.type) + "CC", S.fillRect(0, 0, b, b);
          const A = Math.max(b / E.width, b / E.height), N = E.width * A, U = E.height * A;
          S.drawImage(E, b / 2 - N / 2, b / 2 - U / 2, N, U), S.restore();
        }
        w.needsUpdate = !0, n.current && n.current.emit("redraw");
      };
    } else {
      x.type === "object" ? (S.fillStyle = Nu(x.type) + "CC", S.fillRect(0, 0, b, b)) : (S.save(), S.beginPath(), S.arc(b / 2, b / 2, b / 2, 0, 2 * Math.PI), S.closePath(), S.clip(), S.fillStyle = Nu(x.type) + "CC", S.fillRect(0, 0, b, b), S.restore());
      const E = (x.label || "?").substring(0, 3);
      S.font = "bold 48px Sans-Serif", S.fillStyle = "#fff", S.textAlign = "center", S.textBaseline = "middle", S.fillText(E, b / 2, b / 2 + 6);
    }
    const w = new wn(T);
    w.needsUpdate = !0;
    const M = new wg({
      map: w,
      transparent: !0
    });
    return g.current.set(x.id, M), M;
  };
  return /* @__PURE__ */ ae.jsxs(
    "div",
    {
      ref: u,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      onMouseMove: (x) => {
        if (u.current) {
          const b = u.current.getBoundingClientRect();
          v({
            x: x.clientX - b.left,
            y: x.clientY - b.top
          });
        }
      },
      children: [
        /* @__PURE__ */ ae.jsx(
          hT,
          {
            ref: n,
            graphData: r,
            width: c.width,
            height: c.height,
            controlType: "fly",
            backgroundColor: "rgba(0,0,0,0)",
            nodeLabel: "",
            onNodeClick: e,
            linkColor: () => "rgba(255, 211, 42, 0.15)",
            linkDirectionalParticles: 2,
            linkDirectionalParticleSpeed: 25e-4,
            linkDirectionalParticleColor: () => "rgba(255,255,255,0.5)",
            nodeAutoColorBy: "type",
            nodeThreeObject: (x) => {
              const b = new sl(), T = _(x);
              let S;
              return x.type === "object" ? S = new Lr(
                new Hd(16, 16),
                T
              ) : S = new Lr(
                new V_(16 / 2, 48),
                T
              ), b.add(S), b;
            },
            onEngineStop: i,
            onNodeHover: p,
            onLinkHover: m,
            onBackgroundClick: () => {
              m(null), p(null);
            },
            onZoom: () => {
              m(null), p(null);
            }
          }
        ),
        a && !l && /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: 80,
              right: 30,
              width: 350,
              zIndex: 9999,
              maxHeight: "80vh",
              background: "#18181b",
              borderRadius: "10px",
              border: "3px solid #ffd32a",
              boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
              overflowY: "auto"
            },
            children: /* @__PURE__ */ ae.jsx(
              E_,
              {
                triple: a,
                endpoint: o,
                onClose: () => e(null)
              }
            )
          }
        ),
        /* @__PURE__ */ ae.jsx("div", { style: { position: "relative", zIndex: 2e3 }, children: s }),
        f && f.label ? /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: y.x + 18,
              top: y.y - 10,
              background: Ei.PREDICATE,
              color: "#fff",
              border: `1.5px solid ${Ei.PREDICATE}`,
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 1e3,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: f.label
          }
        ) : d && d.label ? /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: y.x + 18,
              top: y.y - 10,
              background: "#232326",
              color: "#fff",
              border: "1.5px solid #ffd32a",
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 1e3,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: d.label
          }
        ) : null
      ]
    }
  );
};
var gO = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, QA = si.createContext && /* @__PURE__ */ si.createContext(gO), mae = ["attr", "size", "title"];
function gae(r, e) {
  if (r == null) return {};
  var i = yae(r, e), n, s;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(r);
    for (s = 0; s < a.length; s++)
      n = a[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (i[n] = r[n]);
  }
  return i;
}
function yae(r, e) {
  if (r == null) return {};
  var i = {};
  for (var n in r)
    if (Object.prototype.hasOwnProperty.call(r, n)) {
      if (e.indexOf(n) >= 0) continue;
      i[n] = r[n];
    }
  return i;
}
function ig() {
  return ig = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n]);
    }
    return r;
  }, ig.apply(this, arguments);
}
function JA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function rg(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? JA(Object(i), !0).forEach(function(n) {
      vae(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : JA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function vae(r, e, i) {
  return e = bae(e), e in r ? Object.defineProperty(r, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = i, r;
}
function bae(r) {
  var e = xae(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function xae(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function yO(r) {
  return r && r.map((e, i) => /* @__PURE__ */ si.createElement(e.tag, rg({
    key: i
  }, e.attr), yO(e.child)));
}
function pT(r) {
  return (e) => /* @__PURE__ */ si.createElement(_ae, ig({
    attr: rg({}, r.attr)
  }, e), yO(r.child));
}
function _ae(r) {
  var e = (i) => {
    var {
      attr: n,
      size: s,
      title: a
    } = r, o = gae(r, mae), l = s || i.size || "1em", u;
    return i.className && (u = i.className), r.className && (u = (u ? u + " " : "") + r.className), /* @__PURE__ */ si.createElement("svg", ig({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, i.attr, n, o, {
      className: u,
      style: rg(rg({
        color: r.color || i.color
      }, i.style), r.style),
      height: l,
      width: l,
      xmlns: "http://www.w3.org/2000/svg"
    }), a && /* @__PURE__ */ si.createElement("title", null, a), r.children);
  };
  return QA !== void 0 ? /* @__PURE__ */ si.createElement(QA.Consumer, null, (i) => e(i)) : e(gO);
}
function Tae(r) {
  return pT({ attr: { viewBox: "0 0 256 256", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M200,154a29.87,29.87,0,0,0-19.5,7.23L154.88,141.3A29.83,29.83,0,0,0,158,128a30.52,30.52,0,0,0-.22-3.6L174,119a30,30,0,1,0-4-15,30.52,30.52,0,0,0,.22,3.6L154,113a29.91,29.91,0,0,0-32.42-14.31l-8.14-18.3a30,30,0,1,0-11,4.88l8.14,18.3A29.92,29.92,0,0,0,102.06,143L74,168a30.08,30.08,0,1,0,8,9L110,152a29.91,29.91,0,0,0,37.47-1.23l25.62,19.93A30,30,0,1,0,200,154Zm0-68a18,18,0,1,1-18,18A18,18,0,0,1,200,86ZM78,56A18,18,0,1,1,96,74,18,18,0,0,1,78,56ZM56,210a18,18,0,1,1,18-18A18,18,0,0,1,56,210Zm72-64a18,18,0,1,1,18-18A18,18,0,0,1,128,146Zm72,56a18,18,0,1,1,18-18A18,18,0,0,1,200,202Z" }, child: [] }] })(r);
}
function Sae(r) {
  return pT({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z" }, child: [] }] })(r);
}
function wae(r) {
  return pT({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z" }, child: [] }] })(r);
}
const e2 = {
  background: "#ffd32a",
  color: "#18181b",
  border: "none",
  borderRadius: 12,
  width: 44,
  height: 44,
  fontSize: 22,
  fontWeight: "bold",
  boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
  cursor: "pointer",
  marginBottom: 0,
  marginTop: 0,
  textTransform: "uppercase",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: 0,
  transition: "background 0.2s, color 0.2s, transform 0.1s"
}, Eae = {
  background: "#ffe066",
  color: "#18181b",
  transform: "translateY(-2px) scale(1.03)"
}, Mae = ({
  onReset: r,
  onBack: e,
  onForward: i,
  canGoBack: n,
  canGoForward: s
}) => {
  const [a, o] = si.useState(""), l = (u) => a === u ? { ...e2, ...Eae } : e2;
  return /* @__PURE__ */ ae.jsxs(
    "div",
    {
      style: {
        position: "absolute",
        top: "18px",
        left: "18px",
        zIndex: 50,
        display: "flex",
        flexDirection: "row",
        gap: "12px",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              width: 44,
              height: 44
              // Espace vide pour maintenir l'alignement
            }
          }
        ),
        /* @__PURE__ */ ae.jsx(
          "button",
          {
            style: { ...l("graph"), width: 54 },
            onClick: r,
            "aria-label": "Return to graph",
            onMouseEnter: () => o("graph"),
            onMouseLeave: () => o(""),
            children: /* @__PURE__ */ ae.jsx(Tae, { size: 28 })
          }
        ),
        /* @__PURE__ */ ae.jsx(
          "button",
          {
            style: { ...l("prev"), opacity: n ? 1 : 0.5 },
            onClick: e,
            disabled: !n,
            "aria-label": "Previous",
            onMouseEnter: () => o("prev"),
            onMouseLeave: () => o(""),
            children: /* @__PURE__ */ ae.jsx(Sae, {})
          }
        ),
        /* @__PURE__ */ ae.jsx(
          "button",
          {
            style: { ...l("next"), opacity: s ? 1 : 0.5 },
            onClick: i,
            disabled: !s,
            "aria-label": "Next",
            onMouseEnter: () => o("next"),
            onMouseLeave: () => o(""),
            children: /* @__PURE__ */ ae.jsx(wae, {})
          }
        )
      ]
    }
  );
}, Aae = ({ viewMode: r, onViewModeChange: e }) => /* @__PURE__ */ ae.jsxs(
  "div",
  {
    className: "agent-navbar",
    style: {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      background: "#18181b",
      border: "2px solid #ffd32a",
      borderRadius: "10px",
      padding: "6px 16px",
      color: "#ffd32a",
      fontWeight: "bold",
      fontSize: "15px",
      boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
    },
    children: [
      /* @__PURE__ */ ae.jsx("label", { htmlFor: "viewMode", style: { color: "#ffd32a", marginRight: 8 }, children: "View Mode:" }),
      /* @__PURE__ */ ae.jsxs(
        "select",
        {
          id: "viewMode",
          value: r,
          onChange: (i) => e(i.target.value),
          style: {
            background: "#232326",
            color: "#ffd32a",
            border: "1.5px solid #ffd32a",
            borderRadius: 6,
            padding: "4px 10px",
            fontWeight: "bold",
            fontSize: 15,
            outline: "none",
            cursor: "pointer"
          },
          children: [
            /* @__PURE__ */ ae.jsx("option", { value: "2D", children: "2D" }),
            /* @__PURE__ */ ae.jsx("option", { value: "3D", children: "3D" }),
            /* @__PURE__ */ ae.jsx("option", { value: "VR", children: "VR" })
          ]
        }
      )
    ]
  }
), mm = (r) => {
  const e = [], i = [], n = /* @__PURE__ */ new Map();
  return r.forEach(({ subject: s, predicate: a, object: o }) => {
    if (!n.has(s.id)) {
      const l = {
        id: s.id,
        label: s.label,
        image: s.image,
        isTriple: !1,
        color: Nu("subject"),
        type: "subject"
      };
      n.set(s.id, l), e.push(l);
    }
    if (!n.has(o.id)) {
      const l = {
        id: o.id,
        label: o.label,
        image: o.image,
        isTriple: !1,
        color: Nu("object"),
        type: "object"
      };
      n.set(o.id, l), e.push(l);
    }
    i.push({
      source: s.id,
      target: o.id,
      type: "subject-to-object",
      label: a.label,
      predicateId: a.id
    });
  }), { nodes: e, links: i };
}, Cae = "0x5dc0a2335c12343d8e0f71b62a73fbf70d06fcbaf647f57d82a189873ad90da3", Rae = (r, e = "base", i, n) => {
  const s = i || Cae, [a, o] = ve({ nodes: [], links: [] }), [l, u] = ve(null), [c, h] = ve(!0), [d, p] = ve(null), [f, m] = ve(!1), [y, v] = ve([]), [g, _] = ve(0), x = gr(null), [b, T] = ve(""), [S, w] = ve(""), [M, E] = ve(""), [A, N] = ve(!1), [U, k] = ve(!1), C = Or(async () => {
    m(!0);
    try {
      let B;
      e === "agent" ? B = await VU(s, r) : B = await w_(r);
      const q = mm(B);
      o(q), u(q);
    } catch (B) {
      console.error("Error loading graph data:", B);
    } finally {
      m(!1);
    }
  }, [r, e]), I = Or(() => {
    o(l), p(null), T(""), w(""), E(""), k(!1);
  }, [l]), O = Or(
    async (B, q, G) => {
      if (B === null) {
        p(null);
        return;
      }
      if (p(B), n && n(B), q && q.current)
        try {
          const z = {
            x: B.x,
            y: B.y,
            z: B.z || 0
          }, Y = await zU(B.id, r), se = mm(Y), ne = se.nodes.find((fe) => fe.id === B.id);
          ne && (ne.x = z.x, ne.y = z.y, G === "3D" && (ne.z = z.z), ne.fx = z.x, ne.fy = z.y, G === "3D" && (ne.fz = z.z)), v((fe) => {
            const Se = fe.slice(
              0,
              g + 1
            );
            return Se.push({ graphData: a, selectedTriple: B }), Se;
          }), _((fe) => fe + 1), o(se);
        } catch (z) {
          console.error("Error fetching triples:", z);
        }
    },
    [r, a, g]
  ), W = Or((B, q) => {
    switch (x.current && clearTimeout(x.current), B) {
      case "subject":
        T(q);
        break;
      case "predicate":
        w(q);
        break;
      case "object":
        E(q);
        break;
    }
    x.current = setTimeout(() => {
      k(!0);
    }, 500);
  }, []), V = Or(async () => {
    if (U) {
      if (!b && !S && !M) {
        I();
        return;
      }
      N(!0);
      try {
        const B = await Pu({
          subject: b,
          predicate: S,
          object: M
        }, r);
        if (!B || B.length === 0) {
          o({ nodes: [], links: [] });
          return;
        }
        const q = mm(B);
        o(q), v((G) => {
          const z = G.slice(0, g + 1);
          return z.push({ graphData: q, selectedTriple: null }), z;
        }), _((G) => G + 1);
      } catch (B) {
        console.error("Error searching triples:", B);
      } finally {
        N(!1), k(!1);
      }
    }
  }, [
    b,
    S,
    M,
    r,
    I,
    g,
    U
  ]), Q = Or(() => {
    if (g > 0) {
      const { graphData: B, selectedTriple: q } = y[g - 1];
      o(B), p(q), _((G) => G - 1);
    }
  }, [g, y]), F = Or(() => {
    if (g < y.length - 1) {
      const { graphData: B, selectedTriple: q } = y[g + 1];
      o(B), p(q), _((G) => G + 1);
    }
  }, [g, y]);
  return {
    graphData: a,
    initialGraphData: l,
    isInitialLoad: c,
    selectedTriple: d,
    isLoading: f,
    isSearching: A,
    subjectFilter: b,
    predicateFilter: S,
    objectFilter: M,
    shouldSearch: U,
    canGoBack: g > 0,
    canGoForward: g < y.length - 1,
    setSelectedTriple: p,
    setIsInitialLoad: h,
    loadInitialData: C,
    resetGraph: I,
    handleNodeClick: O,
    handleFilterChange: W,
    applyFilters: V,
    goBack: Q,
    goForward: F,
    setGraphData: o,
    graphHistory: y,
    setGraphHistory: v,
    currentHistoryIndex: g,
    setCurrentHistoryIndex: _
  };
};
let Lh = {
  endpoint: null,
  data: null,
  timestamp: null
};
const Nae = 15 * 60 * 1e3, Pae = async (r) => {
  const e = Date.now();
  if (Lh.data && Lh.endpoint === r && e - Lh.timestamp < Nae)
    return Lh.data;
  const i = await w_(r);
  return Lh = {
    endpoint: r,
    data: i,
    timestamp: e
  }, i;
}, Iae = async (r, e = "base", i = 10) => {
  if (!r || r.length < 1)
    return { subjects: [], predicates: [], objects: [], triples: [] };
  const n = r.toLowerCase().trim();
  if (["is", "of", "in", "at", "by", "to"].includes(n))
    try {
      const s = await Pu({ predicate: n }, e);
      if (s && s.length > 0)
        return {
          subjects: [...new Set(s.map((a) => a.subject.label))].slice(0, i),
          predicates: [n],
          objects: [...new Set(s.map((a) => a.object.label))].slice(0, i),
          triples: s.map((a) => ({
            subject: a.subject.label,
            predicate: a.predicate.label,
            object: a.object.label
          })).slice(0, i)
        };
    } catch {
    }
  try {
    const s = (await Pae(e)).filter((f) => n.length <= 3 ? f.subject && f.subject.label && f.subject.label.toLowerCase().indexOf(n) !== -1 || f.predicate && f.predicate.label && f.predicate.label.toLowerCase().indexOf(n) !== -1 || f.object && f.object.label && f.object.label.toLowerCase().indexOf(n) !== -1 : f.subject && f.subject.label && f.subject.label.toLowerCase().includes(n) || f.predicate && f.predicate.label && f.predicate.label.toLowerCase().includes(n) || f.object && f.object.label && f.object.label.toLowerCase().includes(n));
    if (s.length > 0) {
      const f = (x) => {
        if (!x) return 0;
        const b = x.toLowerCase();
        let T = 100 - Math.min(x.length, 50);
        return b.startsWith(n) && (T += 200), b === n && (T += 300), !/^0x[0-9a-f]{8,}$/i.test(b) && !/[0-9a-f]{30,}/i.test(b) && (T += 150), /^[A-Za-z0-9]+ - [A-Za-z0-9 ]+$/.test(x) && (T += 100), T;
      }, m = [...new Set(
        s.filter((x) => x.subject && x.subject.label && x.subject.label.toLowerCase().indexOf(n) !== -1).map((x) => x.subject.label)
      )].sort((x, b) => f(b) - f(x));
      let y = [...new Set(
        s.filter((x) => x.predicate && x.predicate.label && x.predicate.label.toLowerCase().indexOf(n) !== -1).map((x) => x.predicate.label)
      )].sort((x, b) => x.toLowerCase() === n ? -1 : b.toLowerCase() === n ? 1 : f(b) - f(x));
      const v = [...new Set(
        s.filter((x) => x.object && x.object.label && x.object.label.toLowerCase().indexOf(n) !== -1).map((x) => x.object.label)
      )].sort((x, b) => f(b) - f(x)), g = (x) => {
        if (!x) return 0;
        const b = x.subject ? f(x.subject) : 0, T = x.predicate ? f(x.predicate) : 0, S = x.object ? f(x.object) : 0;
        return Math.max(b, T, S);
      }, _ = s.map((x) => ({
        subject: x.subject.label,
        predicate: x.predicate.label,
        object: x.object.label
      })).sort((x, b) => g(b) - g(x)).slice(0, i);
      return {
        subjects: m.slice(0, i),
        predicates: y.slice(0, i),
        objects: v.slice(0, i),
        triples: _
      };
    }
    const a = await Pu({ subject: r }, e), o = await Pu({ predicate: r }, e), l = await Pu({ object: r }, e);
    let u = [...a || []];
    o && o.length > 0 && (u = [...u, ...o.filter(
      (f) => !u.some((m) => m.id === f.id)
    )]), l && l.length > 0 && (u = [...u, ...l.filter(
      (f) => !u.some((m) => m.id === f.id)
    )]);
    const c = [...new Set(
      u.filter((f) => f.subject && f.subject.label).map((f) => f.subject.label).filter((f) => f.toLowerCase().includes(n))
    )], h = [...new Set(
      u.filter((f) => f.predicate && f.predicate.label).map((f) => f.predicate.label).filter((f) => f.toLowerCase().includes(n))
    )], d = [...new Set(
      u.filter((f) => f.object && f.object.label).map((f) => f.object.label).filter((f) => f.toLowerCase().includes(n))
    )], p = u.map((f) => ({
      subject: f.subject.label,
      predicate: f.predicate.label,
      object: f.object.label
    })).slice(0, i);
    return {
      subjects: c.slice(0, i),
      predicates: h.slice(0, i),
      objects: d.slice(0, i),
      triples: p
    };
  } catch {
    return { subjects: [], predicates: [], objects: [], triples: [] };
  }
}, Oae = ({
  endpoint: r,
  onSearch: e,
  isSearching: i,
  onSearchStart: n
}) => {
  const [s, a] = ve(""), [o, l] = ve({
    subjects: [],
    predicates: [],
    objects: [],
    triples: []
  }), [u, c] = ve({
    subject: "",
    predicate: "",
    object: ""
  }), [h, d] = ve(!1), [p, f] = ve(!1), m = gr(null), y = gr(null);
  Ft(() => {
    const k = (C) => {
      y.current && !y.current.contains(C.target) && d(!1);
    };
    return document.addEventListener("mousedown", k), () => {
      document.removeEventListener("mousedown", k);
    };
  }, []), Ft(() => (s.length >= 2 ? (clearTimeout(m.current), f(!0), d(!0), m.current = setTimeout(async () => {
    try {
      const k = await Iae(s, r);
      l(k), d(!0), f(!1);
    } catch (k) {
      console.error("Error retrieving suggestions:", k), f(!1);
    }
  }, 300)) : (l({
    subjects: [],
    predicates: [],
    objects: [],
    triples: []
  }), d(!1), f(!1)), () => {
    clearTimeout(m.current);
  }), [s, r]);
  const v = (k, C) => {
    c((I) => ({
      ...I,
      [k]: I[k] === C ? "" : C
    }));
  }, g = async () => {
    typeof n == "function" && n();
    try {
      const k = {
        subject: u.subject || "",
        predicate: u.predicate || "",
        object: u.object || ""
      };
      typeof e == "function" && await e(s, k);
    } catch {
    }
  }, _ = u.subject || u.predicate || u.object, x = o.subjects.length > 0 || o.predicates.length > 0 || o.objects.length > 0 || o.triples && o.triples.length > 0, b = {
    container: {
      width: "100%",
      maxWidth: "550px",
      margin: "0 auto",
      position: "relative",
      zIndex: 1e3
    },
    inputWrapper: {
      display: "flex",
      width: "100%",
      boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
      borderRadius: "12px",
      overflow: "hidden",
      backgroundColor: "rgba(30, 30, 40, 0.6)",
      backdropFilter: "blur(5px)",
      border: "1px solid rgba(255, 255, 255, 0.2)"
    },
    input: {
      flex: 1,
      padding: "10px 15px",
      fontSize: "15px",
      border: "none",
      backgroundColor: "transparent",
      color: "white",
      outline: "none",
      fontWeight: "400",
      height: "40px"
    },
    button: {
      padding: "0 22px",
      border: "none",
      cursor: "pointer",
      fontWeight: "bold",
      fontSize: "15px",
      textTransform: "uppercase"
    },
    activeFilters: {
      display: "flex",
      flexWrap: "wrap",
      alignItems: "center",
      marginTop: "12px",
      padding: "8px 12px",
      backgroundColor: "rgba(30, 30, 40, 0.7)",
      borderRadius: "6px",
      border: "1px solid rgba(255, 255, 255, 0.1)",
      backdropFilter: "blur(5px)"
    },
    filtersLabel: {
      fontWeight: "600",
      marginRight: "12px",
      color: "rgba(255, 255, 255, 0.9)",
      fontSize: "13px"
    },
    filtersChips: {
      display: "flex",
      flexWrap: "wrap",
      gap: "6px",
      flex: 1
    },
    filterChip: {
      display: "flex",
      alignItems: "center",
      padding: "3px 8px",
      borderRadius: "16px",
      fontSize: "12px",
      color: "white",
      boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
    },
    subjectChip: {
      backgroundColor: `${Ei.SUBJECT}cc`
    },
    predicateChip: {
      backgroundColor: `${Ei.PREDICATE}cc`
    },
    objectChip: {
      backgroundColor: `${Ei.OBJECT}cc`
    },
    chipButton: {
      background: "none",
      border: "none",
      color: "white",
      marginLeft: "4px",
      cursor: "pointer",
      fontSize: "14px",
      lineHeight: 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "16px",
      height: "16px",
      borderRadius: "50%",
      transition: "background-color 0.2s ease"
    },
    chipButtonHover: {
      backgroundColor: "rgba(255, 255, 255, 0.2)"
    },
    clearButton: {
      padding: "4px 10px",
      backgroundColor: "rgba(255, 70, 70, 0.8)",
      color: "white",
      border: "none",
      borderRadius: "16px",
      cursor: "pointer",
      fontSize: "12px",
      fontWeight: "500",
      boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)",
      transition: "background-color 0.2s ease",
      marginLeft: "auto"
    },
    clearButtonHover: {
      backgroundColor: "rgba(255, 70, 70, 1)"
    },
    suggestionsContainer: {
      position: "absolute",
      top: "calc(100% + 8px)",
      left: 0,
      right: 0,
      backgroundColor: "rgba(25, 25, 35, 0.9)",
      backdropFilter: "blur(10px)",
      border: "1px solid rgba(255, 255, 255, 0.1)",
      borderRadius: "8px",
      maxHeight: "400px",
      overflowY: "auto",
      zIndex: 1001,
      boxShadow: "0 8px 16px rgba(0, 0, 0, 0.3)",
      color: "white"
    },
    suggestionCategory: {
      padding: "14px",
      borderBottom: "1px solid rgba(255, 255, 255, 0.1)"
    },
    categoryHeader: {
      fontWeight: "600",
      marginBottom: "10px",
      color: "rgba(255, 255, 255, 0.8)",
      fontSize: "14px",
      textTransform: "uppercase",
      letterSpacing: "0.5px"
    },
    suggestionList: {
      display: "flex",
      flexWrap: "wrap",
      gap: "8px"
    },
    suggestionItem: {
      padding: "3px 8px",
      borderRadius: "16px",
      backgroundColor: "rgba(255, 255, 255, 0.15)",
      fontSize: "12px",
      cursor: "pointer",
      transition: "all 0.2s ease",
      color: "rgba(255, 255, 255, 0.9)"
    },
    suggestionItemHover: {
      backgroundColor: "rgba(255, 255, 255, 0.25)"
    },
    selectedSuggestion: {
      backgroundColor: "#4A66E8",
      color: "white"
    },
    loadingContainer: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: "25px"
    },
    loader: {
      width: "30px",
      height: "30px",
      border: "3px solid rgba(255,255,255,0.2)",
      borderRadius: "50%",
      borderTop: "3px solid #ffd32a",
      animation: "spin 1s linear infinite"
    },
    noResults: {
      padding: "25px",
      textAlign: "center",
      fontSize: "14px",
      color: "rgba(255,255,255,0.7)"
    },
    tripleSuggestion: {
      padding: "8px 12px",
      borderRadius: "12px",
      fontSize: "13px",
      cursor: "pointer",
      transition: "all 0.2s ease",
      backgroundColor: "rgba(30, 30, 40, 0.55)",
      backdropFilter: "blur(5px)",
      border: "1px solid rgba(255, 255, 255, 0.15)",
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      gap: "6px",
      alignItems: "center",
      justifyContent: "center"
    },
    tripleSuggestionHover: {
      backgroundColor: "rgba(50, 50, 60, 0.65)"
    },
    tripleSubjectPart: {
      color: Ei.SUBJECT,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Ei.SUBJECT}33`
    },
    triplePredicatePart: {
      color: Ei.PREDICATE,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Ei.PREDICATE}33`
    },
    tripleObjectPart: {
      color: Ei.OBJECT,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Ei.OBJECT}33`
    },
    subjectSuggestion: {
      backgroundColor: Ei.SUBJECT,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    },
    predicateSuggestion: {
      backgroundColor: Ei.PREDICATE,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    },
    objectSuggestion: {
      backgroundColor: Ei.OBJECT,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    }
  }, [T, S] = ve(!1), [w, M] = ve(!1), [E, A] = ve(null), [N, U] = ve(null);
  return /* @__PURE__ */ ae.jsxs("div", { style: b.container, children: [
    /* @__PURE__ */ ae.jsx("style", { children: `
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        ` }),
    /* @__PURE__ */ ae.jsxs("div", { style: b.inputWrapper, children: [
      /* @__PURE__ */ ae.jsx(
        "input",
        {
          type: "text",
          value: s,
          onChange: (k) => a(k.target.value),
          placeholder: "Search for triples...",
          style: b.input,
          onFocus: () => {
            s.length >= 2 && d(!0);
          }
        }
      ),
      /* @__PURE__ */ ae.jsx(
        "button",
        {
          onClick: g,
          disabled: i,
          style: {
            ...b.button,
            backgroundColor: "#ffd32a",
            color: "#18181b",
            height: "40px",
            borderRadius: "0 12px 12px 0",
            boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
            transition: "background 0.2s, color 0.2s, transform 0.1s"
          },
          onMouseEnter: (k) => k.currentTarget.style.backgroundColor = "#ffe066",
          onMouseLeave: (k) => k.currentTarget.style.backgroundColor = "#ffd32a",
          children: i ? "Searching..." : "Search"
        }
      )
    ] }),
    _ && /* @__PURE__ */ ae.jsxs("div", { style: b.activeFilters, children: [
      /* @__PURE__ */ ae.jsx("div", { style: b.filtersLabel, children: "Active filters:" }),
      /* @__PURE__ */ ae.jsxs("div", { style: b.filtersChips, children: [
        u.subject && /* @__PURE__ */ ae.jsxs("div", { style: { ...b.filterChip, ...b.subjectChip }, children: [
          /* @__PURE__ */ ae.jsxs("span", { children: [
            "Subject: ",
            u.subject
          ] }),
          /* @__PURE__ */ ae.jsx(
            "button",
            {
              onClick: () => v("subject", u.subject),
              style: {
                ...b.chipButton,
                ...E === "subject" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => A("subject"),
              onMouseLeave: () => A(null),
              children: "×"
            }
          )
        ] }),
        u.predicate && /* @__PURE__ */ ae.jsxs("div", { style: { ...b.filterChip, ...b.predicateChip }, children: [
          /* @__PURE__ */ ae.jsxs("span", { children: [
            "Predicate: ",
            u.predicate
          ] }),
          /* @__PURE__ */ ae.jsx(
            "button",
            {
              onClick: () => v("predicate", u.predicate),
              style: {
                ...b.chipButton,
                ...E === "predicate" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => A("predicate"),
              onMouseLeave: () => A(null),
              children: "×"
            }
          )
        ] }),
        u.object && /* @__PURE__ */ ae.jsxs("div", { style: { ...b.filterChip, ...b.objectChip }, children: [
          /* @__PURE__ */ ae.jsxs("span", { children: [
            "Object: ",
            u.object
          ] }),
          /* @__PURE__ */ ae.jsx(
            "button",
            {
              onClick: () => v("object", u.object),
              style: {
                ...b.chipButton,
                ...E === "object" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => A("object"),
              onMouseLeave: () => A(null),
              children: "×"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ ae.jsx(
        "button",
        {
          onClick: () => c({ subject: "", predicate: "", object: "" }),
          style: {
            ...b.clearButton,
            ...w ? b.clearButtonHover : {}
          },
          onMouseEnter: () => M(!0),
          onMouseLeave: () => M(!1),
          children: "Clear all filters"
        }
      )
    ] }),
    h && /* @__PURE__ */ ae.jsxs("div", { style: b.suggestionsContainer, ref: y, children: [
      p && /* @__PURE__ */ ae.jsx("div", { style: b.loadingContainer, children: /* @__PURE__ */ ae.jsx("div", { style: b.loader }) }),
      !p && !x && s.length >= 2 && /* @__PURE__ */ ae.jsxs("div", { style: b.noResults, children: [
        'Aucune suggestion trouvée pour "',
        s,
        '"'
      ] }),
      !p && o.subjects.length > 0 && /* @__PURE__ */ ae.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ ae.jsx("div", { style: b.categoryHeader, children: "Suggested Subjects" }),
        /* @__PURE__ */ ae.jsx("div", { style: b.suggestionList, children: o.subjects.map((k, C) => /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.subjectSuggestion,
              ...N === `subject-${C}` ? b.suggestionItemHover : {},
              ...u.subject === k ? b.selectedSuggestion : {}
            },
            onClick: () => v("subject", k),
            onMouseEnter: () => U(`subject-${C}`),
            onMouseLeave: () => U(null),
            children: k
          },
          `subject-${C}`
        )) })
      ] }),
      !p && o.predicates.length > 0 && /* @__PURE__ */ ae.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ ae.jsx("div", { style: b.categoryHeader, children: "Suggested Predicates" }),
        /* @__PURE__ */ ae.jsx("div", { style: b.suggestionList, children: o.predicates.map((k, C) => /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.predicateSuggestion,
              ...N === `predicate-${C}` ? b.suggestionItemHover : {},
              ...u.predicate === k ? b.selectedSuggestion : {}
            },
            onClick: () => v("predicate", k),
            onMouseEnter: () => U(`predicate-${C}`),
            onMouseLeave: () => U(null),
            children: k
          },
          `predicate-${C}`
        )) })
      ] }),
      !p && o.objects.length > 0 && /* @__PURE__ */ ae.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ ae.jsx("div", { style: b.categoryHeader, children: "Suggested Objects" }),
        /* @__PURE__ */ ae.jsx("div", { style: b.suggestionList, children: o.objects.map((k, C) => /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.objectSuggestion,
              ...N === `object-${C}` ? b.suggestionItemHover : {},
              ...u.object === k ? b.selectedSuggestion : {}
            },
            onClick: () => v("object", k),
            onMouseEnter: () => U(`object-${C}`),
            onMouseLeave: () => U(null),
            children: k
          },
          `object-${C}`
        )) })
      ] }),
      !p && o.triples && o.triples.length > 0 && /* @__PURE__ */ ae.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ ae.jsx("div", { style: b.categoryHeader, children: "Suggested Triples" }),
        /* @__PURE__ */ ae.jsx("div", { style: b.suggestionList, children: o.triples.map((k, C) => /* @__PURE__ */ ae.jsxs(
          "div",
          {
            style: {
              ...b.tripleSuggestion,
              ...N === `triple-${C}` ? b.tripleSuggestionHover : {}
            },
            onClick: () => {
              c({
                subject: k.subject,
                predicate: k.predicate,
                object: k.object
              });
            },
            onMouseEnter: () => U(`triple-${C}`),
            onMouseLeave: () => U(null),
            children: [
              /* @__PURE__ */ ae.jsx("span", { style: b.tripleSubjectPart, children: k.subject }),
              /* @__PURE__ */ ae.jsx("span", { style: b.triplePredicatePart, children: k.predicate }),
              /* @__PURE__ */ ae.jsx("span", { style: b.tripleObjectPart, children: k.object })
            ]
          },
          `triple-${C}`
        )) })
      ] })
    ] })
  ] });
}, Dae = ({ endpoint: r, walletAddress: e, onNodeSelect: i, onLoadingChange: n, gamesId: s, disableNodeDetailsSidebar: a = !1 }) => {
  const o = gr(), l = gr(), [u, c] = si.useState("2D"), [h, d] = si.useState(!1), [p, f] = ve(!1), [m, y] = ve(!1), [v, g] = ve(!1), [_, x] = ve(null), [b, T] = si.useState("agent"), {
    graphData: S,
    isInitialLoad: w,
    selectedTriple: M,
    isLoading: E,
    isSearching: A,
    subjectFilter: N,
    predicateFilter: U,
    objectFilter: k,
    shouldSearch: C,
    canGoBack: I,
    canGoForward: O,
    setIsInitialLoad: W,
    loadInitialData: V,
    resetGraph: Q,
    handleNodeClick: F,
    handleFilterChange: B,
    applyFilters: q,
    goBack: G,
    goForward: z,
    setGraphData: Y,
    setGraphHistory: se,
    currentHistoryIndex: ne,
    setCurrentHistoryIndex: fe
  } = Rae(r, b, s, i), Se = v && _ ? _ : S, Pe = m || A;
  Ft(() => {
    V();
  }, [V, b]), Ft(() => {
    C && (g(!1), q());
  }, [C, q]);
  const lt = () => {
    w && o.current && W(!1);
  }, xe = async (We, At) => {
    try {
      y(!0);
      const st = {
        subject: At.subject || "",
        predicate: At.predicate || "",
        object: At.object || ""
      }, j = await Pu(st, r);
      if (j && j.length > 0) {
        const D = mm(j);
        g(!1), Y(D), se((le) => {
          const Te = le.slice(0, ne + 1);
          return Te.push({
            graphData: D,
            selectedTriple: null,
            filters: st
          }), Te;
        }), fe((le) => le + 1);
      } else
        Y({ nodes: [], links: [] });
    } catch {
      Y({ nodes: [], links: [] });
    } finally {
      y(!1);
    }
  }, vt = () => {
    y(!0);
  }, Z = () => {
    g(!1), Q();
  }, Ht = (We, At) => {
    g(!1), B(We, At);
  }, nt = () => {
    v && g(!1);
  }, Tt = () => /* @__PURE__ */ ae.jsxs(
    "div",
    {
      style: {
        display: "none",
        alignItems: "center",
        backgroundColor: "#27272a",
        padding: "8px 12px",
        borderRadius: 8,
        marginLeft: 12,
        boxShadow: "0 2px 8px rgba(0,0,0,0.2)"
      },
      children: [
        /* @__PURE__ */ ae.jsx("span", { style: { color: "white", marginRight: 10, fontSize: 14 }, children: "Graph Type:" }),
        /* @__PURE__ */ ae.jsxs(
          "select",
          {
            value: b,
            onChange: (We) => T(We.target.value),
            style: {
              backgroundColor: "#3f3f46",
              color: "white",
              border: "none",
              padding: "4px 8px",
              borderRadius: 4,
              cursor: "pointer"
            },
            children: [
              /* @__PURE__ */ ae.jsx("option", { value: "base", children: "Base" }),
              /* @__PURE__ */ ae.jsx("option", { value: "agent", children: "Agent" })
            ]
          }
        )
      ]
    }
  );
  return /* @__PURE__ */ ae.jsxs(
    "div",
    {
      ref: l,
      className: "graph-visualization-container",
      style: {
        position: "relative",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        width: "100%",
        height: "100vh",
        overflow: "hidden"
      },
      children: [
        (E || Pe || p) && /* @__PURE__ */ ae.jsx(kC, {}),
        /* @__PURE__ */ ae.jsx(
          Mae,
          {
            onReset: Z,
            onBack: () => {
              nt(), G();
            },
            onForward: () => {
              nt(), z();
            },
            canGoBack: I,
            canGoForward: O
          }
        ),
        /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "80px",
              left: "18px",
              zIndex: 50
            },
            children: /* @__PURE__ */ ae.jsx(Aae, { viewMode: u, onViewModeChange: c })
          }
        ),
        /* @__PURE__ */ ae.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "10px",
              left: "50%",
              transform: "translateX(-50%)",
              zIndex: 1e3,
              width: "550px",
              maxWidth: "calc(100% - 350px)"
            },
            children: /* @__PURE__ */ ae.jsx(
              Oae,
              {
                endpoint: r,
                onSearch: xe,
                isSearching: Pe,
                onSearchStart: vt
              }
            )
          }
        ),
        /* @__PURE__ */ ae.jsxs(
          "div",
          {
            className: "agent-navbar",
            style: {
              position: "absolute",
              top: "10px",
              right: "10px",
              zIndex: 10,
              display: "flex",
              flexDirection: "row",
              alignItems: "center",
              gap: "16px"
            },
            children: [
              /* @__PURE__ */ ae.jsx(Tt, {}),
              !h && /* @__PURE__ */ ae.jsx(
                "button",
                {
                  style: {
                    background: "#ffd32a",
                    color: "#18181b",
                    border: "none",
                    borderRadius: 12,
                    width: 120,
                    height: 40,
                    fontSize: 15,
                    fontWeight: "bold",
                    boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
                    cursor: "pointer",
                    textTransform: "uppercase",
                    marginLeft: 12,
                    transition: "background 0.2s, color 0.2s, transform 0.1s"
                  },
                  onMouseEnter: (We) => We.currentTarget.style.background = "#ffe066",
                  onMouseLeave: (We) => We.currentTarget.style.background = "#ffd32a",
                  onClick: () => d((We) => !We),
                  children: "Filters"
                }
              ),
              h && /* @__PURE__ */ ae.jsx(
                "div",
                {
                  style: {
                    marginLeft: 12,
                    display: "flex",
                    alignItems: "center",
                    gap: 16,
                    position: "relative"
                  },
                  children: /* @__PURE__ */ ae.jsx(
                    "div",
                    {
                      style: {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "flex-end",
                        position: "relative"
                      },
                      children: /* @__PURE__ */ ae.jsx(
                        HU,
                        {
                          subjectFilter: N,
                          predicateFilter: U,
                          objectFilter: k,
                          onFilterChange: Ht,
                          onReset: Z,
                          onClose: () => d(!1)
                        }
                      )
                    }
                  )
                }
              )
            ]
          }
        ),
        u === "2D" && /* @__PURE__ */ ae.jsx(
          dae,
          {
            graphData: Se,
            onNodeClick: (We) => {
              nt(), F(We, o, u);
            },
            onEngineStop: lt,
            fgRef: o,
            selectedTriple: M,
            endpoint: r,
            disableNodeDetailsSidebar: a,
            children: /* @__PURE__ */ ae.jsx(QT, {})
          }
        ),
        u === "3D" && /* @__PURE__ */ ae.jsx(
          fae,
          {
            graphData: Se,
            onNodeClick: (We) => {
              nt(), F(We, o, u);
            },
            onEngineStop: lt,
            fgRef: o,
            selectedTriple: M,
            endpoint: r,
            disableNodeDetailsSidebar: a,
            children: /* @__PURE__ */ ae.jsx(QT, {})
          }
        ),
        u === "VR" && /* @__PURE__ */ ae.jsx(
          GU,
          {
            graphData: Se,
            onNodeClick: (We) => {
              nt(), F(We, o, u);
            },
            onBack: () => {
              nt(), G();
            },
            onForward: () => {
              nt(), z();
            },
            selectedTriple: M,
            endpoint: r,
            disableNodeDetailsSidebar: a
          }
        )
      ]
    }
  );
};
function Lae({
  open: r,
  onClose: e,
  children: i
}) {
  return /* @__PURE__ */ P.jsx(
    "div",
    {
      style: {
        position: "absolute",
        top: "15%",
        // Commence plus bas (15% du conteneur parent)
        left: "5%",
        // Décalé vers la droite (5% du conteneur parent)
        height: "60%",
        // Réduite en hauteur (70% au lieu de 100%)
        width: r ? "22.67vw" : 0,
        minWidth: r ? "250px" : 0,
        backgroundColor: "#18181b",
        borderRadius: 18,
        transition: "width 0.35s cubic-bezier(0.4, 1.3, 0.5, 1)",
        zIndex: 1300,
        boxShadow: "2px 0 16px rgba(0, 0, 0, 0.18)",
        border: r ? "2px solid #ffd32a" : "none",
        overflow: "hidden"
      },
      children: r && /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
        /* @__PURE__ */ P.jsx(
          "button",
          {
            style: {
              background: "none",
              border: "none",
              color: "#ffd32a",
              fontSize: 32,
              position: "absolute",
              top: 10,
              right: 18,
              cursor: "pointer",
              zIndex: 1302,
              transition: "color 0.2s"
            },
            onClick: e,
            children: "×"
          }
        ),
        /* @__PURE__ */ P.jsx(
          "div",
          {
            style: {
              padding: "48px 24px 24px 24px",
              overflowY: "auto",
              height: "100%",
              color: "#ffd32a"
            },
            children: i
          }
        )
      ] })
    }
  );
}
const kae = ({ activity: r }) => {
  var d;
  Number(r.shares || 0);
  const e = r.term, i = r.vault_type, n = r.activity_type, s = i === "Triple" || i === "Atom", o = !(e != null && e.triple) || s ? e : (d = e == null ? void 0 : e.triple) == null ? void 0 : d.counter_term, l = () => {
    var p, f, m, y, v, g, _;
    return (f = (p = o == null ? void 0 : o.triple) == null ? void 0 : p.subject) != null && f.label && ((y = (m = o == null ? void 0 : o.triple) == null ? void 0 : m.predicate) != null && y.label) && ((g = (v = o == null ? void 0 : o.triple) == null ? void 0 : v.object) != null && g.label) ? {
      type: "triple",
      subject: o.triple.subject.label,
      predicate: o.triple.predicate.label,
      object: o.triple.object.label
    } : (_ = o == null ? void 0 : o.atom) != null && _.label ? {
      type: "atom",
      label: o.atom.label
    } : { type: "unknown" };
  }, u = () => n === "deposit" ? "Deposit" : "Redeem", c = n === "redemption", h = () => i || "Unknown";
  return /* @__PURE__ */ P.jsx(
    "div",
    {
      style: {
        background: "#232326",
        borderRadius: 14,
        padding: "18px 24px",
        marginBottom: 18,
        boxShadow: "0 2px 12px rgba(0,0,0,0.13)",
        borderLeft: `6px solid ${c ? "#F44336" : s ? "#006FE8" : "#FF9500"}`,
        position: "relative",
        display: "flex",
        flexDirection: "column",
        gap: 2
      },
      className: "activity-card",
      children: /* @__PURE__ */ P.jsx("div", { style: { display: "flex", alignItems: "center" }, children: /* @__PURE__ */ P.jsxs("div", { children: [
        /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8, marginBottom: 4 }, children: [
          /* @__PURE__ */ P.jsx("span", { style: { color: "#ffd32a", fontWeight: 700, minWidth: 110 }, children: "Position:" }),
          (() => {
            const p = l();
            return p.type === "triple" ? /* @__PURE__ */ P.jsx(
              ry,
              {
                subject: p.subject,
                predicate: p.predicate,
                object: p.object,
                fontSize: "13px"
              }
            ) : p.type === "atom" ? /* @__PURE__ */ P.jsx(
              wO,
              {
                label: p.label,
                fontSize: "13px"
              }
            ) : /* @__PURE__ */ P.jsx("span", { style: { color: "#fff", fontSize: "13px" }, children: "Unknown Position" });
          })()
        ] }),
        /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8, marginBottom: 4 }, children: [
          /* @__PURE__ */ P.jsx("span", { style: { color: "#ffd32a", fontWeight: 700, minWidth: 110 }, children: "Action:" }),
          /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
            /* @__PURE__ */ P.jsxs("span", { style: { color: "#fff", fontSize: "13px" }, children: [
              u(),
              " ",
              h()
            ] }),
            /* @__PURE__ */ P.jsx("span", { style: { color: "rgba(255, 255, 255, 0.6)" }, children: "-" }),
            /* @__PURE__ */ P.jsx(Nc, { isFor: s, fontSize: "12px" })
          ] })
        ] })
      ] }) })
    }
  );
}, Uae = (r, e) => {
  if (!r || !e || e === 0)
    return "0.00%";
  const i = Number(r), n = Number(e), s = i / n * 100;
  if (s < 0.01 && s > 0) {
    const a = i.toString(), l = n.toString().length - a.length;
    if (l > 5) {
      const u = Math.pow(10, l), h = i * u / n * 100;
      if (h >= 0.01 && h <= 100)
        return `${h.toFixed(2)}%`;
    }
  }
  return s > 100 ? `${s.toFixed(2)}% ⚠️` : s > 0 && s < 0.01 ? "< 0.01%" : `${s.toFixed(2)}%`;
}, Fae = ({
  positionId: r,
  shares: e,
  redeemAmount: i,
  onAmountChange: n
}) => /* @__PURE__ */ P.jsx("div", { style: {
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-end",
  gap: "6px",
  minWidth: "200px"
}, children: /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "6px", width: "100%" }, children: [
  /* @__PURE__ */ P.jsx(
    "input",
    {
      type: "number",
      value: i || e,
      onChange: (s) => n(r, parseFloat(s.target.value) || 0),
      max: e,
      min: 0,
      step: "0.000001",
      style: {
        width: "100%",
        padding: "4px 8px",
        borderRadius: "4px",
        border: "1px solid #374151",
        backgroundColor: "#232326",
        color: "#fff",
        fontSize: "12px"
      }
    }
  ),
  /* @__PURE__ */ P.jsxs("p", { style: { color: "#9ca3af", fontSize: "10px" }, children: [
    "Max: ",
    e
  ] }),
  /* @__PURE__ */ P.jsx("div", { style: { display: "flex", gap: "4px", flexWrap: "wrap" }, children: [
    { label: "25%", multiplier: 0.25 },
    { label: "50%", multiplier: 0.5 },
    { label: "75%", multiplier: 0.75 },
    { label: "Max", multiplier: 1 }
  ].map(({ label: s, multiplier: a }) => /* @__PURE__ */ P.jsx(
    "button",
    {
      onClick: () => n(r, e * a),
      style: {
        padding: "0px 4px",
        borderRadius: "4px",
        border: "1px solid #374151",
        backgroundColor: "#232326",
        color: "#fff",
        fontSize: "12px",
        cursor: "pointer",
        minWidth: "32px",
        textAlign: "center",
        height: "20px",
        lineHeight: "20px"
      },
      children: s
    },
    s
  )) })
] }) }), Bae = ({
  isSelected: r,
  onSelect: e,
  positionId: i
}) => /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "12px" }, children: [
  r && /* @__PURE__ */ P.jsx("span", { style: { color: "#ffd32a", fontSize: "12px", fontWeight: "bold" }, children: "Amount to Redeem" }),
  /* @__PURE__ */ P.jsxs("label", { style: { display: "flex", alignItems: "center", gap: "6px", cursor: "pointer" }, children: [
    /* @__PURE__ */ P.jsx(
      "input",
      {
        type: "checkbox",
        checked: r,
        onChange: (n) => e(i, n.target.checked),
        style: {
          width: "16px",
          height: "16px",
          accentColor: "#ffd32a"
        }
      }
    ),
    /* @__PURE__ */ P.jsx("span", { style: { color: "#ffd32a", fontSize: "12px", fontWeight: "bold" }, children: "Redeem" })
  ] })
] }), t2 = ({ label: r, value: e }) => /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", gap: 8, marginBottom: 4 }, children: [
  /* @__PURE__ */ P.jsxs("span", { style: { color: "#ffd429", fontWeight: 700, minWidth: 110 }, children: [
    r,
    ":"
  ] }),
  /* @__PURE__ */ P.jsx("span", { style: { color: "#fff" }, children: e || "N/A" })
] }), zae = ({ src: r, alt: e }) => r ? /* @__PURE__ */ P.jsx(
  "img",
  {
    src: r,
    alt: e,
    style: {
      width: 48,
      height: 48,
      borderRadius: "50%",
      objectFit: "cover",
      boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
      marginRight: 10
    }
  }
) : null, jae = ({ position: r, isSelected: e = !1, onSelect: i, onAmountChange: n, redeemAmount: s = 0 }) => {
  var b, T, S, w, M, E, A, N, U, k, C, I;
  const a = Number(r.shares || 0), o = r.term, l = ((b = r.vault) == null ? void 0 : b.deposits) && r.vault.deposits.length > 0, u = ((T = r.vault) == null ? void 0 : T.redemptions) && r.vault.redemptions.length > 0, c = (M = (w = (S = r.vault) == null ? void 0 : S.deposits) == null ? void 0 : w[0]) == null ? void 0 : M.vault_type, h = (N = (A = (E = r.vault) == null ? void 0 : E.redemptions) == null ? void 0 : A[0]) == null ? void 0 : N.vault_type, d = a > 0 && (c === "Triple" || c === "Atom" || h === "Triple" || h === "Atom"), p = !(o != null && o.triple), f = p || d ? o : (U = o == null ? void 0 : o.triple) == null ? void 0 : U.counter_term, m = () => {
    var O, W, V, Q, F, B, q;
    return (W = (O = f == null ? void 0 : f.triple) == null ? void 0 : O.subject) != null && W.label && ((Q = (V = f == null ? void 0 : f.triple) == null ? void 0 : V.predicate) != null && Q.label) && ((B = (F = f == null ? void 0 : f.triple) == null ? void 0 : F.object) != null && B.label) ? {
      type: "triple",
      subject: f.triple.subject.label,
      predicate: f.triple.predicate.label,
      object: f.triple.object.label
    } : (q = f == null ? void 0 : f.atom) != null && q.label ? {
      type: "atom",
      label: f.atom.label
    } : { type: "unknown" };
  }, y = p || d ? o : (k = o == null ? void 0 : o.triple) == null ? void 0 : k.counter_term, v = Uae(a, Number((y == null ? void 0 : y.total_assets) || 0)), g = Number((y == null ? void 0 : y.total_assets) || 0), x = (l && u ? a > 0 ? "Deposit" : "Redeem" : l ? "Deposit" : u ? "Redeem" : "Unknown") === "Redeem";
  return /* @__PURE__ */ P.jsx(
    "div",
    {
      style: {
        background: "#232326",
        borderRadius: 14,
        padding: "18px 24px",
        marginBottom: 4,
        boxShadow: "0 2px 12px rgba(0,0,0,0.13)",
        borderLeft: `6px solid ${x ? "#FFD700" : d ? "#006FE8" : "#FF9500"}`,
        position: "relative",
        display: "flex",
        flexDirection: "column",
        gap: 2
      },
      className: "position-card",
      children: /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "flex-start" }, children: [
        /* @__PURE__ */ P.jsx(zae, { src: (C = r.account) == null ? void 0 : C.image, alt: (I = r.account) == null ? void 0 : I.label }),
        /* @__PURE__ */ P.jsxs("div", { style: { flex: 1 }, children: [
          /* @__PURE__ */ P.jsx("div", { style: { display: "flex", alignItems: "center", gap: 8, marginBottom: 4 }, children: (() => {
            const O = m();
            return O.type === "triple" ? /* @__PURE__ */ P.jsx(
              ry,
              {
                subject: O.subject,
                predicate: O.predicate,
                object: O.object,
                fontSize: "14px"
              }
            ) : O.type === "atom" ? /* @__PURE__ */ P.jsx(
              wO,
              {
                label: O.label,
                fontSize: "14px"
              }
            ) : /* @__PURE__ */ P.jsx("span", { style: { color: "#fff", fontSize: "14px" }, children: "Unknown Position" });
          })() }),
          /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8, marginBottom: 4 }, children: [
            /* @__PURE__ */ P.jsx("span", { style: { color: "#ffd429", fontWeight: 700, minWidth: 110 }, children: "Direction:" }),
            /* @__PURE__ */ P.jsx(Nc, { isFor: d, fontSize: "12px" })
          ] }),
          /* @__PURE__ */ P.jsx(t2, { label: "Shares", value: v }),
          /* @__PURE__ */ P.jsx(t2, { label: "Term Shares", value: g })
        ] }),
        /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", flexDirection: "column", alignItems: "flex-end", gap: "8px" }, children: [
          /* @__PURE__ */ P.jsx(
            Bae,
            {
              isSelected: e,
              onSelect: i || (() => {
              }),
              positionId: r.id
            }
          ),
          e && n && /* @__PURE__ */ P.jsx(
            Fae,
            {
              positionId: r.id,
              shares: a,
              redeemAmount: s,
              onAmountChange: n
            }
          )
        ] })
      ] })
    }
  );
}, Vae = ({
  atomDetails: r,
  connections: e,
  walletAddress: i
}) => {
  var n, s, a, o, l, u, c, h;
  return r ? /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
    /* @__PURE__ */ P.jsx("p", { children: /* @__PURE__ */ P.jsx("strong", { children: r.label || "Not defined" }) }),
    /* @__PURE__ */ P.jsx("div", { style: {
      marginBottom: "10px",
      fontSize: "12px"
    }, children: /* @__PURE__ */ P.jsxs("p", { children: [
      "Following: ",
      e.followers.length,
      " - Followers: ",
      e.follows.length
    ] }) }),
    /* @__PURE__ */ P.jsxs("p", { children: [
      /* @__PURE__ */ P.jsx("strong", { children: "ID / Description :" }),
      " ",
      /* @__PURE__ */ P.jsx("br", {}),
      ((s = (n = r.value) == null ? void 0 : n.person) == null ? void 0 : s.description) || ((o = (a = r.value) == null ? void 0 : a.organization) == null ? void 0 : o.description) || ((u = (l = r.value) == null ? void 0 : l.thing) == null ? void 0 : u.description) || ((h = (c = r.value) == null ? void 0 : c.book) == null ? void 0 : h.description) || "No description available"
    ] })
  ] }) : null;
}, fT = ({ isOpen: r, onClose: e, title: i, children: n }) => (Ft(() => {
  const s = (a) => {
    a.key === "Escape" && e();
  };
  return r && (document.addEventListener("keydown", s), document.body.style.overflow = "hidden"), () => {
    document.removeEventListener("keydown", s), document.body.style.overflow = "unset";
  };
}, [r, e]), r ? /* @__PURE__ */ P.jsx(
  "div",
  {
    style: {
      position: "fixed",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: "rgba(0, 0, 0, 0)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      zIndex: 9999,
      padding: "20px"
    },
    onClick: e,
    children: /* @__PURE__ */ P.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#1a1a1a",
          borderRadius: "16px",
          border: "1px solid rgba(255, 255, 255, 0.1)",
          maxWidth: "700px",
          width: "100%",
          maxHeight: "85vh",
          minHeight: "400px",
          display: "flex",
          flexDirection: "column",
          overflow: "hidden",
          boxShadow: "0 20px 40px rgba(0, 0, 0, 0.5)"
        },
        onClick: (s) => s.stopPropagation(),
        children: [
          /* @__PURE__ */ P.jsxs(
            "div",
            {
              style: {
                padding: "20px 24px",
                borderBottom: "1px solid rgba(255, 255, 255, 0.1)",
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between"
              },
              children: [
                /* @__PURE__ */ P.jsx(
                  "h2",
                  {
                    style: {
                      margin: 0,
                      fontSize: "18px",
                      fontWeight: "600",
                      color: "#fff"
                    },
                    children: i
                  }
                ),
                /* @__PURE__ */ P.jsx(
                  "button",
                  {
                    onClick: e,
                    style: {
                      background: "none",
                      border: "none",
                      color: "rgba(255, 255, 255, 0.6)",
                      fontSize: "24px",
                      cursor: "pointer",
                      padding: "4px",
                      borderRadius: "4px",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      width: "32px",
                      height: "32px",
                      transition: "all 0.2s"
                    },
                    onMouseEnter: (s) => {
                      s.currentTarget.style.color = "#fff", s.currentTarget.style.backgroundColor = "rgba(255, 255, 255, 0.1)";
                    },
                    onMouseLeave: (s) => {
                      s.currentTarget.style.color = "rgba(255, 255, 255, 0.6)", s.currentTarget.style.backgroundColor = "transparent";
                    },
                    children: "×"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ P.jsx(
            "div",
            {
              style: {
                padding: "0",
                overflowY: "auto",
                flex: 1,
                display: "flex",
                flexDirection: "column"
              },
              children: n
            }
          )
        ]
      }
    )
  }
) : null), mT = ({
  currentPage: r,
  totalPages: e,
  onPageChange: i,
  itemsPerPage: n,
  totalItems: s
}) => e <= 1 ? null : /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
  /* @__PURE__ */ P.jsx(
    "button",
    {
      onClick: () => i(r - 1),
      disabled: r === 1,
      style: {
        background: r === 1 ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 255, 255, 0.2)",
        border: "1px solid rgba(255, 255, 255, 0.2)",
        borderRadius: "6px",
        color: r === 1 ? "rgba(255, 255, 255, 0.4)" : "#fff",
        padding: "6px 12px",
        fontSize: "12px",
        cursor: r === 1 ? "not-allowed" : "pointer",
        transition: "all 0.2s"
      },
      onMouseEnter: (a) => {
        r > 1 && (a.currentTarget.style.background = "rgba(255, 255, 255, 0.3)");
      },
      onMouseLeave: (a) => {
        r > 1 && (a.currentTarget.style.background = "rgba(255, 255, 255, 0.2)");
      },
      children: "←"
    }
  ),
  /* @__PURE__ */ P.jsx("div", { style: { display: "flex", gap: "4px" }, children: (() => {
    const l = [];
    l.push(1), r > 3 && l.push("...");
    const u = Math.max(2, r - 1), c = Math.min(e - 1, r + 1);
    for (let h = u; h <= c; h++)
      h !== 1 && h !== e && l.push(h);
    return r < e - 2 && l.push("..."), e > 1 && l.push(e), l;
  })().map((l, u) => l === "..." ? /* @__PURE__ */ P.jsx(
    "span",
    {
      style: {
        color: "rgba(255, 255, 255, 0.6)",
        padding: "6px 4px",
        fontSize: "12px"
      },
      children: "..."
    },
    `ellipsis-${u}`
  ) : /* @__PURE__ */ P.jsx(
    "button",
    {
      onClick: () => i(l),
      style: {
        background: l === r ? "#ffd32a" : "rgba(255, 255, 255, 0.1)",
        border: "1px solid rgba(255, 255, 255, 0.2)",
        borderRadius: "6px",
        color: l === r ? "#18181b" : "#fff",
        padding: "6px 10px",
        fontSize: "12px",
        cursor: "pointer",
        minWidth: "32px",
        transition: "all 0.2s",
        fontWeight: l === r ? "600" : "400"
      },
      onMouseEnter: (c) => {
        l !== r && (c.currentTarget.style.background = "rgba(255, 255, 255, 0.2)");
      },
      onMouseLeave: (c) => {
        l !== r && (c.currentTarget.style.background = "rgba(255, 255, 255, 0.1)");
      },
      children: l
    },
    l
  )) }),
  /* @__PURE__ */ P.jsx(
    "button",
    {
      onClick: () => i(r + 1),
      disabled: r === e,
      style: {
        background: r === e ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 255, 255, 0.2)",
        border: "1px solid rgba(255, 255, 255, 0.2)",
        borderRadius: "6px",
        color: r === e ? "rgba(255, 255, 255, 0.4)" : "#fff",
        padding: "6px 12px",
        fontSize: "12px",
        cursor: r === e ? "not-allowed" : "pointer",
        transition: "all 0.2s"
      },
      onMouseEnter: (a) => {
        r < e && (a.currentTarget.style.background = "rgba(255, 255, 255, 0.3)");
      },
      onMouseLeave: (a) => {
        r < e && (a.currentTarget.style.background = "rgba(255, 255, 255, 0.2)");
      },
      children: "→"
    }
  )
] }), gT = ({
  currentPage: r,
  itemsPerPage: e,
  totalItems: i
}) => {
  const n = (r - 1) * e + 1, s = Math.min(r * e, i);
  return /* @__PURE__ */ P.jsxs("div", { style: { fontSize: "12px", color: "rgba(255, 255, 255, 0.6)" }, children: [
    "Showing ",
    n,
    "-",
    s,
    " of ",
    i
  ] });
};
var ey = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(r) {
    return this.listeners.add(r), this.onSubscribe(), () => {
      this.listeners.delete(r), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, Gae = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (r, e) => setTimeout(r, e),
  clearTimeout: (r) => clearTimeout(r),
  setInterval: (r, e) => setInterval(r, e),
  clearInterval: (r) => clearInterval(r)
}, os, ol, d2, Hae = (d2 = class {
  constructor() {
    // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
    // type at app boot; and if we leave that type, then any new timer provider
    // would need to support ReturnType<typeof setTimeout>, which is infeasible.
    //
    // We settle for type safety for the TimeoutProvider type, and accept that
    // this class is unsafe internally to allow for extension.
    zt(this, os, Gae);
    zt(this, ol, !1);
  }
  setTimeoutProvider(r) {
    process.env.NODE_ENV !== "production" && me(this, ol) && r !== me(this, os) && console.error(
      "[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.",
      { previous: me(this, os), provider: r }
    ), mt(this, os, r), process.env.NODE_ENV !== "production" && mt(this, ol, !1);
  }
  setTimeout(r, e) {
    return process.env.NODE_ENV !== "production" && mt(this, ol, !0), me(this, os).setTimeout(r, e);
  }
  clearTimeout(r) {
    me(this, os).clearTimeout(r);
  }
  setInterval(r, e) {
    return process.env.NODE_ENV !== "production" && mt(this, ol, !0), me(this, os).setInterval(r, e);
  }
  clearInterval(r) {
    me(this, os).clearInterval(r);
  }
}, os = new WeakMap(), ol = new WeakMap(), d2), r_ = new Hae();
function Wae(r) {
  setTimeout(r, 0);
}
var ty = typeof window > "u" || "Deno" in globalThis;
function Fn() {
}
function qae(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function Xae(r) {
  return typeof r == "number" && r >= 0 && r !== 1 / 0;
}
function $ae(r, e) {
  return Math.max(r + (e || 0) - Date.now(), 0);
}
function n_(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function Yae(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function i2(r, e) {
  const {
    type: i = "all",
    exact: n,
    fetchStatus: s,
    predicate: a,
    queryKey: o,
    stale: l
  } = r;
  if (o) {
    if (n) {
      if (e.queryHash !== yT(o, e.options))
        return !1;
    } else if (!Dd(e.queryKey, o))
      return !1;
  }
  if (i !== "all") {
    const u = e.isActive();
    if (i === "active" && !u || i === "inactive" && u)
      return !1;
  }
  return !(typeof l == "boolean" && e.isStale() !== l || s && s !== e.state.fetchStatus || a && !a(e));
}
function r2(r, e) {
  const { exact: i, status: n, predicate: s, mutationKey: a } = r;
  if (a) {
    if (!e.options.mutationKey)
      return !1;
    if (i) {
      if (Od(e.options.mutationKey) !== Od(a))
        return !1;
    } else if (!Dd(e.options.mutationKey, a))
      return !1;
  }
  return !(n && e.state.status !== n || s && !s(e));
}
function yT(r, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || Od)(r);
}
function Od(r) {
  return JSON.stringify(
    r,
    (e, i) => a_(i) ? Object.keys(i).sort().reduce((n, s) => (n[s] = i[s], n), {}) : i
  );
}
function Dd(r, e) {
  return r === e ? !0 : typeof r != typeof e ? !1 : r && e && typeof r == "object" && typeof e == "object" ? Object.keys(e).every((i) => Dd(r[i], e[i])) : !1;
}
var Kae = Object.prototype.hasOwnProperty;
function s_(r, e) {
  if (r === e)
    return r;
  const i = n2(r) && n2(e);
  if (!i && !(a_(r) && a_(e))) return e;
  const s = (i ? r : Object.keys(r)).length, a = i ? e : Object.keys(e), o = a.length, l = i ? new Array(o) : {};
  let u = 0;
  for (let c = 0; c < o; c++) {
    const h = i ? c : a[c], d = r[h], p = e[h];
    if (d === p) {
      l[h] = d, (i ? c < s : Kae.call(r, h)) && u++;
      continue;
    }
    if (d === null || p === null || typeof d != "object" || typeof p != "object") {
      l[h] = p;
      continue;
    }
    const f = s_(d, p);
    l[h] = f, f === d && u++;
  }
  return s === o && u === s ? r : l;
}
function n2(r) {
  return Array.isArray(r) && r.length === Object.keys(r).length;
}
function a_(r) {
  if (!s2(r))
    return !1;
  const e = r.constructor;
  if (e === void 0)
    return !0;
  const i = e.prototype;
  return !(!s2(i) || !i.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(r) !== Object.prototype);
}
function s2(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
function Zae(r) {
  return new Promise((e) => {
    r_.setTimeout(e, r);
  });
}
function Qae(r, e, i) {
  if (typeof i.structuralSharing == "function")
    return i.structuralSharing(r, e);
  if (i.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return s_(r, e);
      } catch (n) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${i.queryHash}]: ${n}`
        ), n;
      }
    return s_(r, e);
  }
  return e;
}
function Jae(r, e, i = 0) {
  const n = [...r, e];
  return i && n.length > i ? n.slice(1) : n;
}
function eoe(r, e, i = 0) {
  const n = [e, ...r];
  return i && n.length > i ? n.slice(0, -1) : n;
}
var ng = Symbol();
function vO(r, e) {
  return process.env.NODE_ENV !== "production" && r.queryFn === ng && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${r.queryHash}'`
  ), !r.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !r.queryFn || r.queryFn === ng ? () => Promise.reject(new Error(`Missing queryFn: '${r.queryHash}'`)) : r.queryFn;
}
var ll, io, ic, p2, toe = (p2 = class extends ey {
  constructor() {
    super();
    zt(this, ll);
    zt(this, io);
    zt(this, ic);
    mt(this, ic, (e) => {
      if (!ty && window.addEventListener) {
        const i = () => e();
        return window.addEventListener("visibilitychange", i, !1), () => {
          window.removeEventListener("visibilitychange", i);
        };
      }
    });
  }
  onSubscribe() {
    me(this, io) || this.setEventListener(me(this, ic));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = me(this, io)) == null || e.call(this), mt(this, io, void 0));
  }
  setEventListener(e) {
    var i;
    mt(this, ic, e), (i = me(this, io)) == null || i.call(this), mt(this, io, e((n) => {
      typeof n == "boolean" ? this.setFocused(n) : this.onFocus();
    }));
  }
  setFocused(e) {
    me(this, ll) !== e && (mt(this, ll, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((i) => {
      i(e);
    });
  }
  isFocused() {
    var e;
    return typeof me(this, ll) == "boolean" ? me(this, ll) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden";
  }
}, ll = new WeakMap(), io = new WeakMap(), ic = new WeakMap(), p2), bO = new toe();
function ioe() {
  let r, e;
  const i = new Promise((s, a) => {
    r = s, e = a;
  });
  i.status = "pending", i.catch(() => {
  });
  function n(s) {
    Object.assign(i, s), delete i.resolve, delete i.reject;
  }
  return i.resolve = (s) => {
    n({
      status: "fulfilled",
      value: s
    }), r(s);
  }, i.reject = (s) => {
    n({
      status: "rejected",
      reason: s
    }), e(s);
  }, i;
}
var roe = Wae;
function noe() {
  let r = [], e = 0, i = (l) => {
    l();
  }, n = (l) => {
    l();
  }, s = roe;
  const a = (l) => {
    e ? r.push(l) : s(() => {
      i(l);
    });
  }, o = () => {
    const l = r;
    r = [], l.length && s(() => {
      n(() => {
        l.forEach((u) => {
          i(u);
        });
      });
    });
  };
  return {
    batch: (l) => {
      let u;
      e++;
      try {
        u = l();
      } finally {
        e--, e || o();
      }
      return u;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (l) => (...u) => {
      a(() => {
        l(...u);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (l) => {
      i = l;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (l) => {
      n = l;
    },
    setScheduler: (l) => {
      s = l;
    }
  };
}
var Sr = noe(), rc, ro, nc, f2, soe = (f2 = class extends ey {
  constructor() {
    super();
    zt(this, rc, !0);
    zt(this, ro);
    zt(this, nc);
    mt(this, nc, (e) => {
      if (!ty && window.addEventListener) {
        const i = () => e(!0), n = () => e(!1);
        return window.addEventListener("online", i, !1), window.addEventListener("offline", n, !1), () => {
          window.removeEventListener("online", i), window.removeEventListener("offline", n);
        };
      }
    });
  }
  onSubscribe() {
    me(this, ro) || this.setEventListener(me(this, nc));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = me(this, ro)) == null || e.call(this), mt(this, ro, void 0));
  }
  setEventListener(e) {
    var i;
    mt(this, nc, e), (i = me(this, ro)) == null || i.call(this), mt(this, ro, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    me(this, rc) !== e && (mt(this, rc, e), this.listeners.forEach((n) => {
      n(e);
    }));
  }
  isOnline() {
    return me(this, rc);
  }
}, rc = new WeakMap(), ro = new WeakMap(), nc = new WeakMap(), f2), sg = new soe();
function aoe(r) {
  return Math.min(1e3 * 2 ** r, 3e4);
}
function xO(r) {
  return (r ?? "online") === "online" ? sg.isOnline() : !0;
}
var o_ = class extends Error {
  constructor(r) {
    super("CancelledError"), this.revert = r == null ? void 0 : r.revert, this.silent = r == null ? void 0 : r.silent;
  }
};
function _O(r) {
  let e = !1, i = 0, n;
  const s = ioe(), a = () => s.status !== "pending", o = (y) => {
    var v;
    if (!a()) {
      const g = new o_(y);
      p(g), (v = r.onCancel) == null || v.call(r, g);
    }
  }, l = () => {
    e = !0;
  }, u = () => {
    e = !1;
  }, c = () => bO.isFocused() && (r.networkMode === "always" || sg.isOnline()) && r.canRun(), h = () => xO(r.networkMode) && r.canRun(), d = (y) => {
    a() || (n == null || n(), s.resolve(y));
  }, p = (y) => {
    a() || (n == null || n(), s.reject(y));
  }, f = () => new Promise((y) => {
    var v;
    n = (g) => {
      (a() || c()) && y(g);
    }, (v = r.onPause) == null || v.call(r);
  }).then(() => {
    var y;
    n = void 0, a() || (y = r.onContinue) == null || y.call(r);
  }), m = () => {
    if (a())
      return;
    let y;
    const v = i === 0 ? r.initialPromise : void 0;
    try {
      y = v ?? r.fn();
    } catch (g) {
      y = Promise.reject(g);
    }
    Promise.resolve(y).then(d).catch((g) => {
      var S;
      if (a())
        return;
      const _ = r.retry ?? (ty ? 0 : 3), x = r.retryDelay ?? aoe, b = typeof x == "function" ? x(i, g) : x, T = _ === !0 || typeof _ == "number" && i < _ || typeof _ == "function" && _(i, g);
      if (e || !T) {
        p(g);
        return;
      }
      i++, (S = r.onFail) == null || S.call(r, i, g), Zae(b).then(() => c() ? void 0 : f()).then(() => {
        e ? p(g) : m();
      });
    });
  };
  return {
    promise: s,
    status: () => s.status,
    cancel: o,
    continue: () => (n == null || n(), s),
    cancelRetry: l,
    continueRetry: u,
    canStart: h,
    start: () => (h() ? m() : f().then(m), s)
  };
}
var ul, m2, TO = (m2 = class {
  constructor() {
    zt(this, ul);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Xae(this.gcTime) && mt(this, ul, r_.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(r) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      r ?? (ty ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    me(this, ul) && (r_.clearTimeout(me(this, ul)), mt(this, ul, void 0));
  }
}, ul = new WeakMap(), m2), cl, sc, mn, hl, Xi, Ld, dl, Bn, Hs, g2, ooe = (g2 = class extends TO {
  constructor(e) {
    super();
    zt(this, Bn);
    zt(this, cl);
    zt(this, sc);
    zt(this, mn);
    zt(this, hl);
    zt(this, Xi);
    zt(this, Ld);
    zt(this, dl);
    mt(this, dl, !1), mt(this, Ld, e.defaultOptions), this.setOptions(e.options), this.observers = [], mt(this, hl, e.client), mt(this, mn, me(this, hl).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, mt(this, cl, a2(this.options)), this.state = e.state ?? me(this, cl), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = me(this, Xi)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    if (this.options = { ...me(this, Ld), ...e }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const i = a2(this.options);
      i.data !== void 0 && (this.setData(i.data, {
        updatedAt: i.dataUpdatedAt,
        manual: !0
      }), mt(this, cl, i));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && me(this, mn).remove(this);
  }
  setData(e, i) {
    const n = Qae(this.state.data, e, this.options);
    return ar(this, Bn, Hs).call(this, {
      data: n,
      type: "success",
      dataUpdatedAt: i == null ? void 0 : i.updatedAt,
      manual: i == null ? void 0 : i.manual
    }), n;
  }
  setState(e, i) {
    ar(this, Bn, Hs).call(this, { type: "setState", state: e, setStateOptions: i });
  }
  cancel(e) {
    var n, s;
    const i = (n = me(this, Xi)) == null ? void 0 : n.promise;
    return (s = me(this, Xi)) == null || s.cancel(e), i ? i.then(Fn).catch(Fn) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(me(this, cl));
  }
  isActive() {
    return this.observers.some(
      (e) => Yae(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === ng || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => n_(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !$ae(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var i;
    const e = this.observers.find((n) => n.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (i = me(this, Xi)) == null || i.continue();
  }
  onOnline() {
    var i;
    const e = this.observers.find((n) => n.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (i = me(this, Xi)) == null || i.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), me(this, mn).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((i) => i !== e), this.observers.length || (me(this, Xi) && (me(this, dl) ? me(this, Xi).cancel({ revert: !0 }) : me(this, Xi).cancelRetry()), this.scheduleGc()), me(this, mn).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || ar(this, Bn, Hs).call(this, { type: "invalidate" });
  }
  async fetch(e, i) {
    var u, c, h, d, p, f, m, y, v, g, _, x;
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    ((u = me(this, Xi)) == null ? void 0 : u.status()) !== "rejected") {
      if (this.state.data !== void 0 && (i != null && i.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (me(this, Xi))
        return me(this, Xi).continueRetry(), me(this, Xi).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const b = this.observers.find((T) => T.options.queryFn);
      b && this.setOptions(b.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const n = new AbortController(), s = (b) => {
      Object.defineProperty(b, "signal", {
        enumerable: !0,
        get: () => (mt(this, dl, !0), n.signal)
      });
    }, a = () => {
      const b = vO(this.options, i), S = (() => {
        const w = {
          client: me(this, hl),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(w), w;
      })();
      return mt(this, dl, !1), this.options.persister ? this.options.persister(
        b,
        S,
        this
      ) : b(S);
    }, l = (() => {
      const b = {
        fetchOptions: i,
        options: this.options,
        queryKey: this.queryKey,
        client: me(this, hl),
        state: this.state,
        fetchFn: a
      };
      return s(b), b;
    })();
    (c = this.options.behavior) == null || c.onFetch(l, this), mt(this, sc, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((h = l.fetchOptions) == null ? void 0 : h.meta)) && ar(this, Bn, Hs).call(this, { type: "fetch", meta: (d = l.fetchOptions) == null ? void 0 : d.meta }), mt(this, Xi, _O({
      initialPromise: i == null ? void 0 : i.initialPromise,
      fn: l.fetchFn,
      onCancel: (b) => {
        b instanceof o_ && b.revert && this.setState({
          ...me(this, sc),
          fetchStatus: "idle"
        }), n.abort();
      },
      onFail: (b, T) => {
        ar(this, Bn, Hs).call(this, { type: "failed", failureCount: b, error: T });
      },
      onPause: () => {
        ar(this, Bn, Hs).call(this, { type: "pause" });
      },
      onContinue: () => {
        ar(this, Bn, Hs).call(this, { type: "continue" });
      },
      retry: l.options.retry,
      retryDelay: l.options.retryDelay,
      networkMode: l.options.networkMode,
      canRun: () => !0
    }));
    try {
      const b = await me(this, Xi).start();
      if (b === void 0)
        throw process.env.NODE_ENV !== "production" && console.error(
          `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
        ), new Error(`${this.queryHash} data is undefined`);
      return this.setData(b), (f = (p = me(this, mn).config).onSuccess) == null || f.call(p, b, this), (y = (m = me(this, mn).config).onSettled) == null || y.call(
        m,
        b,
        this.state.error,
        this
      ), b;
    } catch (b) {
      if (b instanceof o_) {
        if (b.silent)
          return me(this, Xi).promise;
        if (b.revert) {
          if (this.state.data === void 0)
            throw b;
          return this.state.data;
        }
      }
      throw ar(this, Bn, Hs).call(this, {
        type: "error",
        error: b
      }), (g = (v = me(this, mn).config).onError) == null || g.call(
        v,
        b,
        this
      ), (x = (_ = me(this, mn).config).onSettled) == null || x.call(
        _,
        this.state.data,
        b,
        this
      ), b;
    } finally {
      this.scheduleGc();
    }
  }
}, cl = new WeakMap(), sc = new WeakMap(), mn = new WeakMap(), hl = new WeakMap(), Xi = new WeakMap(), Ld = new WeakMap(), dl = new WeakMap(), Bn = new WeakSet(), Hs = function(e) {
  const i = (n) => {
    switch (e.type) {
      case "failed":
        return {
          ...n,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...n,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...n,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...n,
          ...loe(n.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        const s = {
          ...n,
          data: e.data,
          dataUpdateCount: n.dataUpdateCount + 1,
          dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        return mt(this, sc, e.manual ? s : void 0), s;
      case "error":
        const a = e.error;
        return {
          ...n,
          error: a,
          errorUpdateCount: n.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: n.fetchFailureCount + 1,
          fetchFailureReason: a,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...n,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...n,
          ...e.state
        };
    }
  };
  this.state = i(this.state), Sr.batch(() => {
    this.observers.forEach((n) => {
      n.onQueryUpdate();
    }), me(this, mn).notify({ query: this, type: "updated", action: e });
  });
}, g2);
function loe(r, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: xO(e.networkMode) ? "fetching" : "paused",
    ...r === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function a2(r) {
  const e = typeof r.initialData == "function" ? r.initialData() : r.initialData, i = e !== void 0, n = i ? typeof r.initialDataUpdatedAt == "function" ? r.initialDataUpdatedAt() : r.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: i ? n ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: i ? "success" : "pending",
    fetchStatus: "idle"
  };
}
function o2(r) {
  return {
    onFetch: (e, i) => {
      var h, d, p, f, m;
      const n = e.options, s = (p = (d = (h = e.fetchOptions) == null ? void 0 : h.meta) == null ? void 0 : d.fetchMore) == null ? void 0 : p.direction, a = ((f = e.state.data) == null ? void 0 : f.pages) || [], o = ((m = e.state.data) == null ? void 0 : m.pageParams) || [];
      let l = { pages: [], pageParams: [] }, u = 0;
      const c = async () => {
        let y = !1;
        const v = (x) => {
          Object.defineProperty(x, "signal", {
            enumerable: !0,
            get: () => (e.signal.aborted ? y = !0 : e.signal.addEventListener("abort", () => {
              y = !0;
            }), e.signal)
          });
        }, g = vO(e.options, e.fetchOptions), _ = async (x, b, T) => {
          if (y)
            return Promise.reject();
          if (b == null && x.pages.length)
            return Promise.resolve(x);
          const w = (() => {
            const N = {
              client: e.client,
              queryKey: e.queryKey,
              pageParam: b,
              direction: T ? "backward" : "forward",
              meta: e.options.meta
            };
            return v(N), N;
          })(), M = await g(w), { maxPages: E } = e.options, A = T ? eoe : Jae;
          return {
            pages: A(x.pages, M, E),
            pageParams: A(x.pageParams, b, E)
          };
        };
        if (s && a.length) {
          const x = s === "backward", b = x ? uoe : l2, T = {
            pages: a,
            pageParams: o
          }, S = b(n, T);
          l = await _(T, S, x);
        } else {
          const x = r ?? a.length;
          do {
            const b = u === 0 ? o[0] ?? n.initialPageParam : l2(n, l);
            if (u > 0 && b == null)
              break;
            l = await _(l, b), u++;
          } while (u < x);
        }
        return l;
      };
      e.options.persister ? e.fetchFn = () => {
        var y, v;
        return (v = (y = e.options).persister) == null ? void 0 : v.call(
          y,
          c,
          {
            client: e.client,
            queryKey: e.queryKey,
            meta: e.options.meta,
            signal: e.signal
          },
          i
        );
      } : e.fetchFn = c;
    }
  };
}
function l2(r, { pages: e, pageParams: i }) {
  const n = e.length - 1;
  return e.length > 0 ? r.getNextPageParam(
    e[n],
    e,
    i[n],
    i
  ) : void 0;
}
function uoe(r, { pages: e, pageParams: i }) {
  var n;
  return e.length > 0 ? (n = r.getPreviousPageParam) == null ? void 0 : n.call(r, e[0], e, i[0], i) : void 0;
}
var kd, ls, _r, pl, us, $a, y2, coe = (y2 = class extends TO {
  constructor(e) {
    super();
    zt(this, us);
    zt(this, kd);
    zt(this, ls);
    zt(this, _r);
    zt(this, pl);
    mt(this, kd, e.client), this.mutationId = e.mutationId, mt(this, _r, e.mutationCache), mt(this, ls, []), this.state = e.state || hoe(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    me(this, ls).includes(e) || (me(this, ls).push(e), this.clearGcTimeout(), me(this, _r).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    mt(this, ls, me(this, ls).filter((i) => i !== e)), this.scheduleGc(), me(this, _r).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    me(this, ls).length || (this.state.status === "pending" ? this.scheduleGc() : me(this, _r).remove(this));
  }
  continue() {
    var e;
    return ((e = me(this, pl)) == null ? void 0 : e.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    var o, l, u, c, h, d, p, f, m, y, v, g, _, x, b, T, S, w, M, E;
    const i = () => {
      ar(this, us, $a).call(this, { type: "continue" });
    }, n = {
      client: me(this, kd),
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    mt(this, pl, _O({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e, n) : Promise.reject(new Error("No mutationFn found")),
      onFail: (A, N) => {
        ar(this, us, $a).call(this, { type: "failed", failureCount: A, error: N });
      },
      onPause: () => {
        ar(this, us, $a).call(this, { type: "pause" });
      },
      onContinue: i,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => me(this, _r).canRun(this)
    }));
    const s = this.state.status === "pending", a = !me(this, pl).canStart();
    try {
      if (s)
        i();
      else {
        ar(this, us, $a).call(this, { type: "pending", variables: e, isPaused: a }), await ((l = (o = me(this, _r).config).onMutate) == null ? void 0 : l.call(
          o,
          e,
          this,
          n
        ));
        const N = await ((c = (u = this.options).onMutate) == null ? void 0 : c.call(
          u,
          e,
          n
        ));
        N !== this.state.context && ar(this, us, $a).call(this, {
          type: "pending",
          context: N,
          variables: e,
          isPaused: a
        });
      }
      const A = await me(this, pl).start();
      return await ((d = (h = me(this, _r).config).onSuccess) == null ? void 0 : d.call(
        h,
        A,
        e,
        this.state.context,
        this,
        n
      )), await ((f = (p = this.options).onSuccess) == null ? void 0 : f.call(
        p,
        A,
        e,
        this.state.context,
        n
      )), await ((y = (m = me(this, _r).config).onSettled) == null ? void 0 : y.call(
        m,
        A,
        null,
        this.state.variables,
        this.state.context,
        this,
        n
      )), await ((g = (v = this.options).onSettled) == null ? void 0 : g.call(
        v,
        A,
        null,
        e,
        this.state.context,
        n
      )), ar(this, us, $a).call(this, { type: "success", data: A }), A;
    } catch (A) {
      try {
        throw await ((x = (_ = me(this, _r).config).onError) == null ? void 0 : x.call(
          _,
          A,
          e,
          this.state.context,
          this,
          n
        )), await ((T = (b = this.options).onError) == null ? void 0 : T.call(
          b,
          A,
          e,
          this.state.context,
          n
        )), await ((w = (S = me(this, _r).config).onSettled) == null ? void 0 : w.call(
          S,
          void 0,
          A,
          this.state.variables,
          this.state.context,
          this,
          n
        )), await ((E = (M = this.options).onSettled) == null ? void 0 : E.call(
          M,
          void 0,
          A,
          e,
          this.state.context,
          n
        )), A;
      } finally {
        ar(this, us, $a).call(this, { type: "error", error: A });
      }
    } finally {
      me(this, _r).runNext(this);
    }
  }
}, kd = new WeakMap(), ls = new WeakMap(), _r = new WeakMap(), pl = new WeakMap(), us = new WeakSet(), $a = function(e) {
  const i = (n) => {
    switch (e.type) {
      case "failed":
        return {
          ...n,
          failureCount: e.failureCount,
          failureReason: e.error
        };
      case "pause":
        return {
          ...n,
          isPaused: !0
        };
      case "continue":
        return {
          ...n,
          isPaused: !1
        };
      case "pending":
        return {
          ...n,
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...n,
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...n,
          data: void 0,
          error: e.error,
          failureCount: n.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = i(this.state), Sr.batch(() => {
    me(this, ls).forEach((n) => {
      n.onMutationUpdate(e);
    }), me(this, _r).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, y2);
function hoe() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var Ks, zn, Ud, v2, doe = (v2 = class extends ey {
  constructor(e = {}) {
    super();
    zt(this, Ks);
    zt(this, zn);
    zt(this, Ud);
    this.config = e, mt(this, Ks, /* @__PURE__ */ new Set()), mt(this, zn, /* @__PURE__ */ new Map()), mt(this, Ud, 0);
  }
  build(e, i, n) {
    const s = new coe({
      client: e,
      mutationCache: this,
      mutationId: ++op(this, Ud)._,
      options: e.defaultMutationOptions(i),
      state: n
    });
    return this.add(s), s;
  }
  add(e) {
    me(this, Ks).add(e);
    const i = Ff(e);
    if (typeof i == "string") {
      const n = me(this, zn).get(i);
      n ? n.push(e) : me(this, zn).set(i, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (me(this, Ks).delete(e)) {
      const i = Ff(e);
      if (typeof i == "string") {
        const n = me(this, zn).get(i);
        if (n)
          if (n.length > 1) {
            const s = n.indexOf(e);
            s !== -1 && n.splice(s, 1);
          } else n[0] === e && me(this, zn).delete(i);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const i = Ff(e);
    if (typeof i == "string") {
      const n = me(this, zn).get(i), s = n == null ? void 0 : n.find(
        (a) => a.state.status === "pending"
      );
      return !s || s === e;
    } else
      return !0;
  }
  runNext(e) {
    var n;
    const i = Ff(e);
    if (typeof i == "string") {
      const s = (n = me(this, zn).get(i)) == null ? void 0 : n.find((a) => a !== e && a.state.isPaused);
      return (s == null ? void 0 : s.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    Sr.batch(() => {
      me(this, Ks).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), me(this, Ks).clear(), me(this, zn).clear();
    });
  }
  getAll() {
    return Array.from(me(this, Ks));
  }
  find(e) {
    const i = { exact: !0, ...e };
    return this.getAll().find(
      (n) => r2(i, n)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((i) => r2(e, i));
  }
  notify(e) {
    Sr.batch(() => {
      this.listeners.forEach((i) => {
        i(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((i) => i.state.isPaused);
    return Sr.batch(
      () => Promise.all(
        e.map((i) => i.continue().catch(Fn))
      )
    );
  }
}, Ks = new WeakMap(), zn = new WeakMap(), Ud = new WeakMap(), v2);
function Ff(r) {
  var e;
  return (e = r.options.scope) == null ? void 0 : e.id;
}
var cs, b2, poe = (b2 = class extends ey {
  constructor(e = {}) {
    super();
    zt(this, cs);
    this.config = e, mt(this, cs, /* @__PURE__ */ new Map());
  }
  build(e, i, n) {
    const s = i.queryKey, a = i.queryHash ?? yT(s, i);
    let o = this.get(a);
    return o || (o = new ooe({
      client: e,
      queryKey: s,
      queryHash: a,
      options: e.defaultQueryOptions(i),
      state: n,
      defaultOptions: e.getQueryDefaults(s)
    }), this.add(o)), o;
  }
  add(e) {
    me(this, cs).has(e.queryHash) || (me(this, cs).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const i = me(this, cs).get(e.queryHash);
    i && (e.destroy(), i === e && me(this, cs).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    Sr.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return me(this, cs).get(e);
  }
  getAll() {
    return [...me(this, cs).values()];
  }
  find(e) {
    const i = { exact: !0, ...e };
    return this.getAll().find(
      (n) => i2(i, n)
    );
  }
  findAll(e = {}) {
    const i = this.getAll();
    return Object.keys(e).length > 0 ? i.filter((n) => i2(e, n)) : i;
  }
  notify(e) {
    Sr.batch(() => {
      this.listeners.forEach((i) => {
        i(e);
      });
    });
  }
  onFocus() {
    Sr.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    Sr.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, cs = new WeakMap(), b2), Si, no, so, ac, oc, ao, lc, uc, x2, foe = (x2 = class {
  constructor(r = {}) {
    zt(this, Si);
    zt(this, no);
    zt(this, so);
    zt(this, ac);
    zt(this, oc);
    zt(this, ao);
    zt(this, lc);
    zt(this, uc);
    mt(this, Si, r.queryCache || new poe()), mt(this, no, r.mutationCache || new doe()), mt(this, so, r.defaultOptions || {}), mt(this, ac, /* @__PURE__ */ new Map()), mt(this, oc, /* @__PURE__ */ new Map()), mt(this, ao, 0);
  }
  mount() {
    op(this, ao)._++, me(this, ao) === 1 && (mt(this, lc, bO.subscribe(async (r) => {
      r && (await this.resumePausedMutations(), me(this, Si).onFocus());
    })), mt(this, uc, sg.subscribe(async (r) => {
      r && (await this.resumePausedMutations(), me(this, Si).onOnline());
    })));
  }
  unmount() {
    var r, e;
    op(this, ao)._--, me(this, ao) === 0 && ((r = me(this, lc)) == null || r.call(this), mt(this, lc, void 0), (e = me(this, uc)) == null || e.call(this), mt(this, uc, void 0));
  }
  isFetching(r) {
    return me(this, Si).findAll({ ...r, fetchStatus: "fetching" }).length;
  }
  isMutating(r) {
    return me(this, no).findAll({ ...r, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(r) {
    var i;
    const e = this.defaultQueryOptions({ queryKey: r });
    return (i = me(this, Si).get(e.queryHash)) == null ? void 0 : i.state.data;
  }
  ensureQueryData(r) {
    const e = this.defaultQueryOptions(r), i = me(this, Si).build(this, e), n = i.state.data;
    return n === void 0 ? this.fetchQuery(r) : (r.revalidateIfStale && i.isStaleByTime(n_(e.staleTime, i)) && this.prefetchQuery(e), Promise.resolve(n));
  }
  getQueriesData(r) {
    return me(this, Si).findAll(r).map(({ queryKey: e, state: i }) => {
      const n = i.data;
      return [e, n];
    });
  }
  setQueryData(r, e, i) {
    const n = this.defaultQueryOptions({ queryKey: r }), s = me(this, Si).get(
      n.queryHash
    ), a = s == null ? void 0 : s.state.data, o = qae(e, a);
    if (o !== void 0)
      return me(this, Si).build(this, n).setData(o, { ...i, manual: !0 });
  }
  setQueriesData(r, e, i) {
    return Sr.batch(
      () => me(this, Si).findAll(r).map(({ queryKey: n }) => [
        n,
        this.setQueryData(n, e, i)
      ])
    );
  }
  getQueryState(r) {
    var i;
    const e = this.defaultQueryOptions({ queryKey: r });
    return (i = me(this, Si).get(
      e.queryHash
    )) == null ? void 0 : i.state;
  }
  removeQueries(r) {
    const e = me(this, Si);
    Sr.batch(() => {
      e.findAll(r).forEach((i) => {
        e.remove(i);
      });
    });
  }
  resetQueries(r, e) {
    const i = me(this, Si);
    return Sr.batch(() => (i.findAll(r).forEach((n) => {
      n.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...r
      },
      e
    )));
  }
  cancelQueries(r, e = {}) {
    const i = { revert: !0, ...e }, n = Sr.batch(
      () => me(this, Si).findAll(r).map((s) => s.cancel(i))
    );
    return Promise.all(n).then(Fn).catch(Fn);
  }
  invalidateQueries(r, e = {}) {
    return Sr.batch(() => (me(this, Si).findAll(r).forEach((i) => {
      i.invalidate();
    }), (r == null ? void 0 : r.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...r,
        type: (r == null ? void 0 : r.refetchType) ?? (r == null ? void 0 : r.type) ?? "active"
      },
      e
    )));
  }
  refetchQueries(r, e = {}) {
    const i = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, n = Sr.batch(
      () => me(this, Si).findAll(r).filter((s) => !s.isDisabled() && !s.isStatic()).map((s) => {
        let a = s.fetch(void 0, i);
        return i.throwOnError || (a = a.catch(Fn)), s.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(n).then(Fn);
  }
  fetchQuery(r) {
    const e = this.defaultQueryOptions(r);
    e.retry === void 0 && (e.retry = !1);
    const i = me(this, Si).build(this, e);
    return i.isStaleByTime(
      n_(e.staleTime, i)
    ) ? i.fetch(e) : Promise.resolve(i.state.data);
  }
  prefetchQuery(r) {
    return this.fetchQuery(r).then(Fn).catch(Fn);
  }
  fetchInfiniteQuery(r) {
    return r.behavior = o2(r.pages), this.fetchQuery(r);
  }
  prefetchInfiniteQuery(r) {
    return this.fetchInfiniteQuery(r).then(Fn).catch(Fn);
  }
  ensureInfiniteQueryData(r) {
    return r.behavior = o2(r.pages), this.ensureQueryData(r);
  }
  resumePausedMutations() {
    return sg.isOnline() ? me(this, no).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return me(this, Si);
  }
  getMutationCache() {
    return me(this, no);
  }
  getDefaultOptions() {
    return me(this, so);
  }
  setDefaultOptions(r) {
    mt(this, so, r);
  }
  setQueryDefaults(r, e) {
    me(this, ac).set(Od(r), {
      queryKey: r,
      defaultOptions: e
    });
  }
  getQueryDefaults(r) {
    const e = [...me(this, ac).values()], i = {};
    return e.forEach((n) => {
      Dd(r, n.queryKey) && Object.assign(i, n.defaultOptions);
    }), i;
  }
  setMutationDefaults(r, e) {
    me(this, oc).set(Od(r), {
      mutationKey: r,
      defaultOptions: e
    });
  }
  getMutationDefaults(r) {
    const e = [...me(this, oc).values()], i = {};
    return e.forEach((n) => {
      Dd(r, n.mutationKey) && Object.assign(i, n.defaultOptions);
    }), i;
  }
  defaultQueryOptions(r) {
    if (r._defaulted)
      return r;
    const e = {
      ...me(this, so).queries,
      ...this.getQueryDefaults(r.queryKey),
      ...r,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = yT(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === ng && (e.enabled = !1), e;
  }
  defaultMutationOptions(r) {
    return r != null && r._defaulted ? r : {
      ...me(this, so).mutations,
      ...(r == null ? void 0 : r.mutationKey) && this.getMutationDefaults(r.mutationKey),
      ...r,
      _defaulted: !0
    };
  }
  clear() {
    me(this, Si).clear(), me(this, no).clear();
  }
}, Si = new WeakMap(), no = new WeakMap(), so = new WeakMap(), ac = new WeakMap(), oc = new WeakMap(), ao = new WeakMap(), lc = new WeakMap(), uc = new WeakMap(), x2), moe = _2.createContext(
  void 0
), goe = ({
  client: r,
  children: e
}) => (_2.useEffect(() => (r.mount(), () => {
  r.unmount();
}), [r]), /* @__PURE__ */ P.jsx(moe.Provider, { value: r, children: e })), yoe = "https://prod.base-sepolia.intuition-api.com/v1/graphql", voe = "https://prod.base-mainnet-v-1-0.intuition.sh/v1/graphql", boe = voe, u2 = {
  apiUrl: boe
};
function xoe(r) {
  u2 = { ...u2, ...r };
}
var ri = /* @__PURE__ */ ((r) => (r.MAINNET = "mainnet", r.TESTNET = "testnet", r))(ri || {});
const En = {
  mainnet: "https://testnet.intuition.sh/v1/graphql",
  testnet: yoe
  // TODO: change to mainnet
}, iy = async (r, e = ri.MAINNET) => {
  var i;
  try {
    const n = En[e];
    return ((i = (await (await fetch(n, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetActivePositions($accountId: String!) {
            positions(where: { 
              account_id: { _eq: $accountId },
              shares: { _gt: 0 }
            }) {
              id
              shares
              curve_id
              account {
                id
                label
                image
                atom_id
                type
              }
              term {
                id
                total_market_cap
                total_assets
                atom {
                  label
                }
                triple {
                  subject {
                    label
                  }
                  predicate {
                    label
                  }
                  object {
                    label
                  }
                  counter_term {
                    id
                    total_market_cap
                    total_assets
                    atom {
                      label
                    }
                    triple {
                      subject {
                        label
                      }
                      predicate {
                        label
                      }
                      object {
                        label
                      }
                    }
                  }
                }
              }
              vault {
                deposits {
                  vault_type
                }
                redemptions {
                  vault_type
                }
              }
            }
          }
        `,
        variables: { accountId: r }
      })
    })).json()).data) == null ? void 0 : i.positions) || [];
  } catch (n) {
    return console.error("Error fetching active positions:", n), [];
  }
}, _oe = ({
  claim: r,
  walletAddress: e,
  onSelectionChange: i
}) => {
  var m;
  const [n, s] = ve("neutral"), [a, o] = ve(0), [l, u] = ve([]), [c, h] = ve(null);
  Ft(() => {
    (async () => {
      var v;
      if (e)
        try {
          const _ = (await iy(e, ri.MAINNET)).filter((T) => {
            var M, E, A;
            const S = ((M = T.term) == null ? void 0 : M.id) === r.term_id, w = ((E = T.term) == null ? void 0 : E.id) === ((A = r.counter_term) == null ? void 0 : A.id);
            return S || w;
          });
          u(_);
          const x = _.find(
            (T) => {
              var S;
              return ((S = T.term) == null ? void 0 : S.id) === r.term_id && T.shares > 0;
            }
          ), b = _.find(
            (T) => {
              var S, w;
              return ((S = T.term) == null ? void 0 : S.id) === ((w = r.counter_term) == null ? void 0 : w.id) && T.shares > 0;
            }
          );
          console.log("🔍 ClaimDepositControls Debug:", {
            claimId: r.term_id,
            claimCounterId: (v = r.counter_term) == null ? void 0 : v.id,
            userPositions: _.map((T) => {
              var S, w, M, E;
              return {
                termId: (S = T.term) == null ? void 0 : S.id,
                shares: T.shares,
                isFor: ((w = T.term) == null ? void 0 : w.id) === r.term_id,
                isAgainst: ((M = T.term) == null ? void 0 : M.id) === ((E = r.counter_term) == null ? void 0 : E.id)
              };
            }),
            forPosition: x,
            againstPosition: b
          }), s(x ? "for" : b ? "against" : "neutral");
        } catch (g) {
          console.error("Error fetching user positions:", g);
        }
    })();
  }, [e, r.term_id, (m = r.counter_term) == null ? void 0 : m.id]);
  const d = (y) => y === "for" ? !l.some(
    (g) => {
      var _, x;
      return ((_ = g.term) == null ? void 0 : _.id) === ((x = r.counter_term) == null ? void 0 : x.id) && g.shares > 0;
    }
  ) : y === "against" ? !l.some(
    (g) => {
      var _;
      return ((_ = g.term) == null ? void 0 : _.id) === r.term_id && g.shares > 0;
    }
  ) : y === "neutral" ? !l.some(
    (g) => {
      var _, x, b;
      return (((_ = g.term) == null ? void 0 : _.id) === r.term_id || ((x = g.term) == null ? void 0 : x.id) === ((b = r.counter_term) == null ? void 0 : b.id)) && g.shares > 0;
    }
  ) : !0, p = (y) => {
    if ((y === "for" || y === "against") && !d(y)) {
      h(`You already have a ${y === "for" ? "Against" : "For"} position on this claim`);
      return;
    }
    h(null), s(y), y === "neutral" && o(0), i && i(a, y);
  }, f = (y) => {
    const v = parseFloat(y);
    if (isNaN(v) || v < 0) {
      o(0), i && i(0, n);
      return;
    }
    const g = Math.round(v * 1e3) / 1e3;
    o(g), i && i(g, n);
  };
  return /* @__PURE__ */ P.jsxs("div", { style: {
    display: "flex",
    alignItems: "center",
    gap: "8px",
    marginTop: "4px",
    justifyContent: "flex-end"
    // Aligner à droite
  }, children: [
    c && /* @__PURE__ */ P.jsx("div", { style: {
      color: "#ff6b6b",
      fontSize: "10px",
      marginRight: "8px",
      padding: "2px 6px",
      backgroundColor: "rgba(255, 107, 107, 0.1)",
      borderRadius: "3px",
      border: "1px solid rgba(255, 107, 107, 0.3)"
    }, children: c }),
    /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px" }, children: [
      /* @__PURE__ */ P.jsx(
        "input",
        {
          type: "number",
          value: a,
          onChange: (y) => f(y.target.value),
          step: "0.001",
          min: "0",
          placeholder: "0.000",
          style: {
            width: "65px",
            padding: "2px",
            backgroundColor: "rgba(255, 255, 255, 0.05)",
            border: "1px solid rgba(255, 255, 255, 0.1)",
            borderRadius: "6px",
            color: "#fff",
            fontSize: "12px",
            textAlign: "left",
            marginBottom: "2px"
          },
          disabled: n === "neutral"
        }
      ),
      /* @__PURE__ */ P.jsx("span", { style: {
        fontSize: "12px",
        color: "rgba(255, 255, 255, 0.6)",
        fontWeight: "500"
      }, children: "TRUST" })
    ] }),
    /* @__PURE__ */ P.jsx(
      "div",
      {
        style: {
          position: "relative",
          width: "60px",
          height: "20px",
          backgroundColor: "rgba(255, 255, 255, 0.1)",
          borderRadius: "10px",
          cursor: "pointer",
          opacity: d("for") && d("against") && d("neutral") ? 1 : 0.5
        },
        onClick: () => {
          n === "neutral" && d("for") ? p("for") : n === "for" && d("against") ? p("against") : (n === "against" && d("neutral") || n === "for" && !d("against") && d("neutral") || n === "against" && !d("for") && d("neutral")) && p("neutral");
        },
        title: !d("for") || !d("against") || !d("neutral") ? "You already have an active position on this claim" : `Current: ${n.toUpperCase()} - Click to change`,
        children: /* @__PURE__ */ P.jsx("div", { style: {
          position: "absolute",
          top: "2px",
          left: n === "for" ? "2px" : n === "against" ? "42px" : "20px",
          width: "16px",
          height: "16px",
          backgroundColor: n === "for" ? "rgb(0, 111, 232)" : n === "against" ? "rgb(255, 149, 0)" : "rgba(255, 255, 255, 0.3)",
          borderRadius: "50%",
          transition: "all 0.2s ease",
          boxShadow: "0 1px 3px rgba(0, 0, 0, 0.3)"
        } })
      }
    )
  ] });
};
var it = /* @__PURE__ */ ((r) => (r.For = "FOR", r.Against = "AGAINST", r.None = "NONE", r))(it || {});
const Xo = {
  GAMES_ID: "0x5dc0a2335c12343d8e0f71b62a73fbf70d06fcbaf647f57d82a189873ad90da3",
  FOLLOWS: "0x8f9b5dc2e7b8bd12f6762c839830672f1d13c08e72b5f09f194cafc153f2df8a",
  // prédicat --> follows
  IS: "0x2af261bce70c2fc3a1abf882e3e89b23066fcd150bfda27fab69f9f55ed2d9d0",
  // prédicat --> is
  IS_PLAYER_OF: "0x05f1707d8cb50571d01021f09a664826aa1be2ff43504c0cca55eef87142f84f"
  // prédicat --> is player of
}, Toe = {
  PLAYER_GAME: {
    predicateId: Xo.IS_PLAYER_OF,
    // predicat --> is player of !!!
    objectId: Xo.GAMES_ID
    // object --> games (BossFighters)
  },
  PLAYER_QUALITY_1: {
    predicateId: Xo.IS,
    // predicat --> is 
    objectId: "0xc9559c712c264e5f94ce450ed9473c451b6fd01ab6a436a726fbae767cd67b9c"
    // object --> fairplay !!!
  },
  PLAYER_QUALITY_2: {
    predicateId: Xo.IS,
    // predicat --> is 
    objectId: "0x56d28a901a7f2617247f1663b0c25c77ba6403a8141bac43b1e94eb32a2de941"
    // object --> strong boss !!!
  },
  PLAYER_QUALITY_3: {
    predicateId: Xo.IS,
    // predicat --> is 
    objectId: "0xc8433466cda62c0e8bb4fc5433f3faa51949072d6c7b0df50a595c95fb97f1bb"
    // object --> strong fighter !!!
  },
  PLAYER_GUILD: {
    predicateId: Xo.IS_PLAYER_OF,
    // predicat --> is player of !!!
    objectId: null
    // Sera défini dynamiquement en fonction du choix de guilde
  }
}, Soe = [
  { id: "0x4320ae619f6a9c9b79ee8e2a9415585aff1c287f0b72b08c049cf7a5780eb08d", name: "The Alchemists" },
  // id --> The Alchemists !!!
  { id: "0x12d4b4425dcfeaf46af6543e8de0133f22f768a69d56a3aa28662ecb06aa9ca1", name: "Big Time Warriors" },
  // id --> Big Time Warriors !!!
  { id: "0xd9e1d54c0cb904c23e04caea94f9d0dae00874ec18849ca74a832e94c6de01fa", name: "The NEST" },
  // id --> The NEST !!!
  { id: "0xd473ceacf850609ff8881c398e85e59aadbc315588ca78182313cc1af05a2800", name: "Clock Work Gamers" },
  // id --> Clock Work Gamers !!!
  { id: "0x14511bc4065a1e7d67ba7d50d4706a8899a148a2e68b55213794c14e347acaa", name: "Vast Impact Gaming" }
  // id --> Vast Impact Gaming !!!
  // { id: "0x93815368a0d207e11be12da396d51dea4e3f8e637fe49f696648feb451f6f9c7", name: "Kraken Gaming" }, // id --> Kraken Gaming !!!
  // { id: "0x508dee963f045411bd0bf4ab9433f40b72ca4270eb0f31222f299211cffbb0bc", name: "FAM" } // id --> FAM
], l_ = 10000000000000000n, woe = [
  "0x27191de92fe0308355319ec8f2359e5ce85123bd243bf7ffa6eb8028347b3eab",
  // toxic - is map of - bossfights
  "0x561a2c3e4359c8ed1c468aef27691e8e48b4424344a38c7693b9127b1911efc9",
  // toxic - is - fun
  "0x6d7e52c5e80bf6c2873a21cb7013ba0655dc0458c77f2c0e7446c49efdbd0033"
  // toxic - is - immersive
  // "0x9df847b39391899840d7973d9718d8caef5c5467dde9374a96d1f71727bae7c4" // toxic - is - balanced
], kh = {
  COMMON_IDS: Xo,
  PLAYER_TRIPLE_TYPES: Toe,
  OFFICIAL_GUILDS: Soe,
  PREDEFINED_CLAIM_IDS: woe
}, SO = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  network: n = ri.MAINNET
}) => {
  const [s, a] = ve(!1), o = async (u) => {
    var c;
    try {
      const h = En[n], d = await fetch(h, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: `
            query Triple($tripleId: String!) {
              triple(term_id: $tripleId) {
                term_id
                counter_term_id
              }
            }
          `,
          variables: { tripleId: String(u) }
        })
      });
      if (!d.ok)
        return null;
      const p = await d.json();
      return p.errors ? (console.error("❌ GraphQL errors:", p.errors), null) : (c = p.data) != null && c.triple ? {
        id: String(u),
        ...p.data.triple
      } : (console.error("❌ No triple data found"), null);
    } catch (h) {
      return console.error("❌ fetchTripleDetails error:", h), null;
    }
  };
  return {
    depositTriple: async (u) => {
      if (!r || !e)
        return {
          success: !1,
          error: "Wallet not connected"
        };
      if (u.length === 0)
        return {
          success: !1,
          error: "No votes provided"
        };
      for (const c of u)
        if (c.units <= 0)
          return {
            success: !1,
            error: "Units must be greater than 0"
          };
      a(!0);
      try {
        const c = [], h = [], d = [], p = [];
        for (const y of u) {
          const v = await o(y.claimId);
          if (!v)
            return a(!1), {
              success: !1,
              error: `Failed to fetch triple details for claim ${y.claimId}`
            };
          let g;
          if (y.direction === it.For) {
            if (!v.term_id)
              return console.error("❌ term_id is undefined for FOR vote"), { success: !1, error: "term_id not found" };
            g = v.term_id;
          } else {
            if (!v.counter_term_id)
              return console.error("❌ counter_term_id is undefined for AGAINST vote"), { success: !1, error: "counter_term_id not found" };
            g = v.counter_term_id;
          }
          if (!g)
            return console.error("❌ targetId is undefined"), { success: !1, error: "targetId not found" };
          const _ = Math.round(y.units * 1e3), x = l_ * BigInt(_);
          c.push(g), h.push(1n), d.push(x), p.push(0n);
        }
        const f = await r.writeContract({
          address: oo,
          abi: ju,
          functionName: "depositBatch",
          args: [
            e,
            // receiver
            c,
            // termIds array
            h,
            // curveIds array
            d,
            // assets array
            p
            // minShares array
          ],
          value: d.reduce((y, v) => y + v, 0n),
          // Total value
          gas: 500000n * BigInt(u.length)
          // Gas based on number of votes
        });
        let m;
        return r.waitForTransactionReceipt ? m = await r.waitForTransactionReceipt({ hash: f }) : f.wait ? m = await f.wait() : await new Promise((y) => setTimeout(y, 5e3)), a(!1), {
          success: !0,
          hash: typeof f == "string" ? f : f.hash
        };
      } catch (c) {
        return a(!1), {
          success: !1,
          error: c instanceof Error ? c.message : String(c)
        };
      }
    },
    isLoading: s
  };
}, Eoe = ({
  isOpen: r,
  onClose: e,
  activities: i,
  walletAddress: n,
  walletConnected: s,
  publicClient: a
}) => {
  const [o, l] = ve(1), [u, c] = ve({}), [h, d] = ve(!1), p = 10, { depositTriple: f } = SO({
    walletConnected: s,
    walletAddress: n,
    publicClient: a
  }), m = Math.ceil(i.length / p), y = (o - 1) * p, v = y + p, g = i.slice(y, v), _ = () => {
    e(), l(1), c({});
  }, x = (S, w, M) => {
    if (M === "neutral" || w === 0) {
      const E = { ...u };
      delete E[S], c(E);
    } else
      c((E) => ({
        ...E,
        [S]: { trust: w, direction: M }
      }));
  }, b = async () => {
    if (Object.keys(u).length !== 0) {
      d(!0);
      try {
        const w = Object.entries(u).map(([E, A]) => ({
          claimId: E,
          units: A.trust,
          direction: A.direction === "for" ? it.For : it.Against
        })), M = await f(w);
        M.success ? (console.log("✅ Deposit successful:", M.hash), c({})) : console.error("❌ Deposit failed:", M.error);
      } catch (w) {
        console.error("❌ Deposit error:", w);
      } finally {
        d(!1);
      }
    }
  }, T = Object.keys(u).length;
  return /* @__PURE__ */ P.jsx(
    fT,
    {
      isOpen: r,
      onClose: _,
      title: `All Claims (${i.length})`,
      children: /* @__PURE__ */ P.jsxs("div", { style: { padding: "0" }, children: [
        /* @__PURE__ */ P.jsx("div", { style: { padding: "16px 24px 16px" }, children: g.map((S) => {
          var w, M, E, A, N, U;
          return /* @__PURE__ */ P.jsxs(
            "div",
            {
              style: {
                width: "100%",
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                border: "1px solid rgba(255, 255, 255, 0.1)",
                borderRadius: "12px",
                overflow: "hidden",
                marginBottom: "2px",
                backgroundColor: "rgba(255, 255, 255, 0.05)"
              },
              children: [
                /* @__PURE__ */ P.jsxs(
                  "div",
                  {
                    style: {
                      width: "100%",
                      display: "flex",
                      flexDirection: "row",
                      justifyContent: "space-between",
                      alignItems: "center",
                      padding: "16px 16px 10px 16px",
                      gap: "12px"
                    },
                    children: [
                      /* @__PURE__ */ P.jsx("div", { style: { display: "flex", flex: 1, alignItems: "center", gap: "8px" }, children: /* @__PURE__ */ P.jsx(
                        ry,
                        {
                          subject: "",
                          predicate: S.predicate.label,
                          object: S.object.label,
                          fontSize: "12px",
                          showArrows: !1
                        }
                      ) }),
                      /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                        /* @__PURE__ */ P.jsx(
                          Nc,
                          {
                            isFor: !0,
                            count: ((E = (M = (w = S.term) == null ? void 0 : w.positions_aggregate) == null ? void 0 : M.aggregate) == null ? void 0 : E.count) || 0,
                            fontSize: "12px",
                            showCount: !0
                          }
                        ),
                        /* @__PURE__ */ P.jsx(
                          Nc,
                          {
                            isFor: !1,
                            count: ((U = (N = (A = S.counter_term) == null ? void 0 : A.positions_aggregate) == null ? void 0 : N.aggregate) == null ? void 0 : U.count) || 0,
                            fontSize: "12px",
                            showCount: !0
                          }
                        )
                      ] })
                    ]
                  }
                ),
                /* @__PURE__ */ P.jsx("div", { style: { width: "100%", display: "flex", justifyContent: "flex-end", marginBottom: "5px", marginRight: "16px" }, children: /* @__PURE__ */ P.jsx(
                  _oe,
                  {
                    claim: S,
                    walletAddress: n,
                    walletConnected: s,
                    publicClient: a,
                    onSelectionChange: (k, C) => x(S.term_id, k, C)
                  }
                ) })
              ]
            },
            S.term_id
          );
        }) }),
        /* @__PURE__ */ P.jsxs("div", { style: {
          borderTop: "1px solid #374151",
          padding: "16px 24px",
          backgroundColor: "#18181b",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          position: "sticky",
          bottom: 0,
          zIndex: 10
        }, children: [
          /* @__PURE__ */ P.jsx("div", { children: /* @__PURE__ */ P.jsx(
            gT,
            {
              currentPage: o,
              itemsPerPage: p,
              totalItems: i.length
            }
          ) }),
          T > 0 && /* @__PURE__ */ P.jsx("div", { style: { display: "flex", justifyContent: "center", flex: 1 }, children: /* @__PURE__ */ P.jsx(
            "button",
            {
              onClick: b,
              disabled: h,
              style: {
                backgroundColor: "#ffd32a",
                color: "#000",
                border: "none",
                borderRadius: "8px",
                padding: "12px 24px",
                fontSize: "14px",
                fontWeight: "600",
                cursor: h ? "not-allowed" : "pointer",
                opacity: h ? 0.7 : 1,
                transition: "all 0.2s",
                minWidth: "200px"
              },
              onMouseEnter: (S) => {
                h || (S.currentTarget.style.backgroundColor = "#ffed4e");
              },
              onMouseLeave: (S) => {
                h || (S.currentTarget.style.backgroundColor = "#ffd32a");
              },
              children: h ? "Processing..." : `Deposit All Selected (${T})`
            }
          ) }),
          /* @__PURE__ */ P.jsx("div", { children: /* @__PURE__ */ P.jsx(
            mT,
            {
              currentPage: o,
              totalPages: m,
              onPageChange: l,
              itemsPerPage: p,
              totalItems: i.length
            }
          ) })
        ] })
      ] })
    }
  );
}, Moe = ({
  activities: r,
  title: e = "My Claims",
  walletAddress: i,
  walletConnected: n,
  publicClient: s
}) => {
  const [a, o] = ve(!1);
  return /* @__PURE__ */ P.jsxs("div", { style: { marginTop: "10px" }, children: [
    /* @__PURE__ */ P.jsxs("h3", { children: [
      e,
      " (",
      r.length,
      ")"
    ] }),
    r.length > 0 ? /* @__PURE__ */ P.jsxs("div", { style: { maxHeight: "300px", overflowY: "auto" }, children: [
      r.slice(0, 3).map((l) => {
        var u, c, h, d, p, f;
        return /* @__PURE__ */ P.jsx(
          "div",
          {
            style: {
              width: "100%",
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              border: "1px solid rgba(255, 255, 255, 0.1)",
              borderRadius: "12px",
              overflow: "hidden",
              marginBottom: "2px",
              backgroundColor: "rgba(255, 255, 255, 0.05)"
            },
            children: /* @__PURE__ */ P.jsxs(
              "div",
              {
                style: {
                  width: "100%",
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "space-between",
                  alignItems: "center",
                  padding: "16px",
                  gap: "12px"
                },
                children: [
                  /* @__PURE__ */ P.jsx("div", { style: { display: "flex", flex: 1, alignItems: "center", gap: "8px" }, children: /* @__PURE__ */ P.jsx(
                    ry,
                    {
                      subject: "",
                      predicate: l.predicate.label,
                      object: l.object.label,
                      fontSize: "12px",
                      showArrows: !1
                    }
                  ) }),
                  /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                    /* @__PURE__ */ P.jsx(
                      Nc,
                      {
                        isFor: !0,
                        count: ((h = (c = (u = l.term) == null ? void 0 : u.positions_aggregate) == null ? void 0 : c.aggregate) == null ? void 0 : h.count) || 0,
                        fontSize: "12px",
                        showCount: !0
                      }
                    ),
                    /* @__PURE__ */ P.jsx(
                      Nc,
                      {
                        isFor: !1,
                        count: ((f = (p = (d = l.counter_term) == null ? void 0 : d.positions_aggregate) == null ? void 0 : p.aggregate) == null ? void 0 : f.count) || 0,
                        fontSize: "12px",
                        showCount: !0
                      }
                    )
                  ] })
                ]
              }
            )
          },
          l.term_id
        );
      }),
      r.length > 3 && /* @__PURE__ */ P.jsxs(
        "div",
        {
          style: {
            padding: "12px",
            textAlign: "center",
            fontSize: "12px",
            color: "rgba(255, 255, 255, 0.6)",
            fontStyle: "italic",
            cursor: "pointer",
            transition: "color 0.2s"
          },
          onClick: () => o(!0),
          onMouseEnter: (l) => {
            l.currentTarget.style.color = "#fff";
          },
          onMouseLeave: (l) => {
            l.currentTarget.style.color = "rgba(255, 255, 255, 0.6)";
          },
          children: [
            "Show all ",
            r.length,
            " claims"
          ]
        }
      )
    ] }) : /* @__PURE__ */ P.jsx("p", { style: { color: "rgba(255, 255, 255, 0.6)", fontStyle: "italic" }, children: "No claim found" }),
    /* @__PURE__ */ P.jsx(
      Eoe,
      {
        isOpen: a,
        onClose: () => o(!1),
        activities: r,
        walletAddress: i,
        walletConnected: n,
        publicClient: s
      }
    )
  ] });
}, Aoe = () => {
  const [r, e] = ve(/* @__PURE__ */ new Set()), [i, n] = ve({});
  return {
    selectedPositions: r,
    redeemAmounts: i,
    handlePositionSelect: (l, u) => {
      e((c) => {
        const h = new Set(c);
        return u ? h.add(l) : (h.delete(l), n((d) => {
          const p = { ...d };
          return delete p[l], p;
        })), h;
      });
    },
    handleAmountChange: (l, u) => {
      n((c) => ({
        ...c,
        [l]: u
      }));
    },
    clearSelection: () => {
      e(/* @__PURE__ */ new Set()), n({});
    }
  };
}, Coe = ({
  walletConnected: r,
  walletAddress: e
}) => {
  const [i, n] = ve(!1);
  return {
    redeemBatch: async (a) => {
      if (!r || !e)
        throw new Error("Wallet not connected");
      n(!0);
      try {
        const o = await r.writeContract({
          address: oo,
          abi: ju,
          functionName: "redeemBatch",
          args: [
            a.receiver,
            // receiver
            a.termIds,
            // termIds array
            a.curveIds,
            // curveIds array
            a.shares,
            // shares array
            a.minAssets
            // minAssets array
          ],
          gas: 500000n * BigInt(a.termIds.length)
          // Gas based on number of redemptions
        });
        let l;
        return r.waitForTransactionReceipt ? l = await r.waitForTransactionReceipt({ hash: o }) : o.wait ? l = await o.wait() : await new Promise((u) => setTimeout(u, 5e3)), n(!1), {
          success: !0,
          hash: typeof o == "string" ? o : o.hash
        };
      } catch (o) {
        throw n(!1), o;
      }
    },
    isLoading: i
  };
}, Roe = ({ walletConnected: r, walletAddress: e }) => {
  const { redeemBatch: i, isLoading: n } = Coe({
    walletConnected: r,
    walletAddress: e
  });
  return {
    handleRedeemAllSelected: async (a, o, l, u) => {
      if (o.size === 0) return;
      const c = a.filter((h) => o.has(h.id));
      try {
        const h = [], d = [], p = [], f = [];
        for (const m of c) {
          const y = l[m.id] || m.shares, v = m.curve_id;
          h.push(m.term.id), d.push(BigInt(v)), p.push(BigInt(y)), f.push(BigInt(0));
        }
        return await i({
          receiver: u,
          termIds: h,
          curveIds: d,
          shares: p,
          minAssets: f
        }), { success: !0 };
      } catch (h) {
        return console.error("Error redeeming selected positions:", h), { success: !1, error: h };
      }
    },
    isLoading: n
  };
}, Noe = ({ accountId: r, walletConnected: e, walletAddress: i }) => {
  const [n, s] = ve([]), [a, o] = ve(!0), [l, u] = ve(!1), [c, h] = ve(1), d = 7, { selectedPositions: p, redeemAmounts: f, handlePositionSelect: m, handleAmountChange: y, clearSelection: v } = Aoe(), { handleRedeemAllSelected: g, isLoading: _ } = Roe({ walletConnected: e, walletAddress: i });
  Ft(() => {
    (async () => {
      if (r) {
        o(!0);
        try {
          const T = await iy(r);
          s(T);
        } catch (T) {
          console.error("Error loading positions:", T), s([]);
        } finally {
          o(!1);
        }
      }
    })();
  }, [r]);
  const x = async () => {
    const b = await g(n, p, f, r);
    b != null && b.success && v();
  };
  return a ? /* @__PURE__ */ P.jsxs("div", { style: { marginTop: "10px", marginBottom: "10px" }, children: [
    /* @__PURE__ */ P.jsx("h3", { children: "My Positions" }),
    /* @__PURE__ */ P.jsx("p", { children: "Loading positions..." })
  ] }) : /* @__PURE__ */ P.jsxs("div", { style: { marginTop: "10px", marginBottom: "10px" }, children: [
    /* @__PURE__ */ P.jsxs(
      "button",
      {
        onClick: () => u(!0),
        style: {
          background: "#ffd32a",
          color: "#000",
          border: "none",
          borderRadius: "8px",
          padding: "12px 24px",
          fontSize: "14px",
          fontWeight: "bold",
          cursor: "pointer",
          transition: "all 0.2s",
          width: "100%"
        },
        onMouseEnter: (b) => {
          b.currentTarget.style.background = "#ffed4e", b.currentTarget.style.transform = "translateY(-1px)";
        },
        onMouseLeave: (b) => {
          b.currentTarget.style.background = "#ffd32a", b.currentTarget.style.transform = "translateY(0)";
        },
        children: [
          "My Positions (",
          n.length,
          ")"
        ]
      }
    ),
    /* @__PURE__ */ P.jsx(
      fT,
      {
        isOpen: l,
        onClose: () => {
          u(!1), h(1);
        },
        title: `My Positions (${n.length})`,
        children: /* @__PURE__ */ P.jsxs("div", { style: { padding: "0" }, children: [
          (() => {
            const b = (c - 1) * d, T = b + d;
            return n.slice(b, T).map((w, M) => /* @__PURE__ */ P.jsx("div", { style: { padding: "8px 24px 8px" }, children: /* @__PURE__ */ P.jsx(
              jae,
              {
                position: w,
                isSelected: p.has(w.id),
                onSelect: m,
                onAmountChange: y,
                redeemAmount: f[w.id]
              },
              w.id || M
            ) }, w.id || M));
          })(),
          /* @__PURE__ */ P.jsxs("div", { style: {
            borderTop: "1px solid #374151",
            padding: "16px 24px",
            backgroundColor: "#18181b",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            position: "sticky",
            bottom: 0,
            zIndex: 10
          }, children: [
            /* @__PURE__ */ P.jsx("div", { children: /* @__PURE__ */ P.jsx(
              gT,
              {
                currentPage: c,
                itemsPerPage: d,
                totalItems: n.length
              }
            ) }),
            /* @__PURE__ */ P.jsx("div", { children: /* @__PURE__ */ P.jsx(
              Ooe,
              {
                selectedCount: p.size,
                onRedeemAll: x,
                isLoading: _
              }
            ) }),
            /* @__PURE__ */ P.jsx("div", { children: /* @__PURE__ */ P.jsx(
              mT,
              {
                currentPage: c,
                totalPages: Math.ceil(n.length / d),
                onPageChange: h,
                itemsPerPage: d,
                totalItems: n.length
              }
            ) })
          ] })
        ] })
      }
    )
  ] });
}, Poe = async (r, e = ri.MAINNET) => {
  var i, n;
  try {
    const s = En[e], o = await (await fetch(s, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetActivityHistory($accountId: String!) {
            deposits(where: { sender_id: { _eq: $accountId } }) {
              id
              shares
              assets_after_fees
              created_at
              vault_type
              term {
                id
                total_market_cap
                total_assets
                atom {
                  label
                }
                triple {
                  subject {
                    label
                  }
                  predicate {
                    label
                  }
                  object {
                    label
                  }
                  counter_term {
                    id
                    total_market_cap
                    total_assets
                    atom {
                      label
                    }
                    triple {
                      subject {
                        label
                      }
                      predicate {
                        label
                      }
                      object {
                        label
                      }
                    }
                  }
                }
              }
            }
            redemptions(where: { sender_id: { _eq: $accountId } }) {
              id
              shares
              assets
              created_at
              vault_type
              term {
                id
                total_market_cap
                total_assets
                atom {
                  label
                }
                triple {
                  subject {
                    label
                  }
                  predicate {
                    label
                  }
                  object {
                    label
                  }
                  counter_term {
                    id
                    total_market_cap
                    total_assets
                    atom {
                      label
                    }
                    triple {
                      subject {
                        label
                      }
                      predicate {
                        label
                      }
                      object {
                        label
                      }
                    }
                  }
                }
              }
            }
          }
        `,
        variables: { accountId: r }
      })
    })).json(), l = ((i = o.data) == null ? void 0 : i.deposits) || [], u = ((n = o.data) == null ? void 0 : n.redemptions) || [];
    return [
      ...l.map((h) => ({ ...h, activity_type: "deposit" })),
      ...u.map((h) => ({ ...h, activity_type: "redemption" }))
    ].sort((h, d) => new Date(d.created_at).getTime() - new Date(h.created_at).getTime());
  } catch (s) {
    return console.error("Error fetching activity history:", s), [];
  }
}, Ioe = ({ accountId: r }) => {
  const [e, i] = ve([]), [n, s] = ve(!0), [a, o] = ve(!1), [l, u] = ve(1), c = 10;
  return Ft(() => {
    (async () => {
      if (r) {
        s(!0);
        try {
          const d = await Poe(r);
          i(d);
        } catch (d) {
          console.error("Error loading activity history:", d), i([]);
        } finally {
          s(!1);
        }
      }
    })();
  }, [r]), n ? /* @__PURE__ */ P.jsxs("div", { style: { marginTop: "10px" }, children: [
    /* @__PURE__ */ P.jsx("h3", { children: "Activity History" }),
    /* @__PURE__ */ P.jsx("p", { children: "Loading activities..." })
  ] }) : /* @__PURE__ */ P.jsxs("div", { style: { marginTop: "20px" }, children: [
    /* @__PURE__ */ P.jsxs(
      "button",
      {
        onClick: () => o(!0),
        style: {
          background: "#ffd429",
          color: "#000",
          border: "none",
          borderRadius: "8px",
          padding: "12px 24px",
          fontSize: "14px",
          fontWeight: "bold",
          cursor: "pointer",
          transition: "all 0.2s",
          width: "100%"
        },
        onMouseEnter: (h) => {
          h.currentTarget.style.background = "#ffed4e", h.currentTarget.style.transform = "translateY(-1px)";
        },
        onMouseLeave: (h) => {
          h.currentTarget.style.background = "#ffd32a", h.currentTarget.style.transform = "translateY(0)";
        },
        children: [
          "Activity History (",
          e.length,
          ")"
        ]
      }
    ),
    /* @__PURE__ */ P.jsx(
      fT,
      {
        isOpen: a,
        onClose: () => {
          o(!1), u(1);
        },
        title: `Activity History (${e.length})`,
        children: /* @__PURE__ */ P.jsx("div", { style: { padding: "0" }, children: (() => {
          const h = Math.ceil(e.length / c), d = (l - 1) * c, p = d + c, f = e.slice(d, p);
          return /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
            /* @__PURE__ */ P.jsx("div", { style: { padding: "16px 24px 16px" }, children: f.map((m, y) => /* @__PURE__ */ P.jsx(kae, { activity: m }, m.id || y)) }),
            /* @__PURE__ */ P.jsxs("div", { style: {
              borderTop: "1px solid #374151",
              padding: "16px 24px",
              backgroundColor: "#18181b",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              position: "sticky",
              bottom: 0,
              zIndex: 10
            }, children: [
              /* @__PURE__ */ P.jsx("div", { children: /* @__PURE__ */ P.jsx(
                gT,
                {
                  currentPage: l,
                  itemsPerPage: c,
                  totalItems: e.length
                }
              ) }),
              /* @__PURE__ */ P.jsx("div", { children: /* @__PURE__ */ P.jsx(
                mT,
                {
                  currentPage: l,
                  totalPages: h,
                  onPageChange: u,
                  itemsPerPage: c,
                  totalItems: e.length
                }
              ) })
            ] })
          ] });
        })() })
      }
    )
  ] });
}, Ooe = ({
  selectedCount: r,
  onRedeemAll: e,
  isLoading: i
}) => r === 0 ? null : /* @__PURE__ */ P.jsx(
  "button",
  {
    onClick: e,
    disabled: i,
    style: {
      padding: "8px 16px",
      borderRadius: "6px",
      border: "none",
      backgroundColor: i ? "#374151" : "#ffd32a",
      color: i ? "#9ca3af" : "#000",
      fontSize: "14px",
      fontWeight: "bold",
      cursor: i ? "not-allowed" : "pointer"
    },
    children: i ? "Redeeming..." : `Redeem All Selected (${r})`
  }
), gm = ({
  text: r,
  maxLength: e,
  className: i,
  style: n
}) => {
  const s = r.length <= e ? r : r.slice(0, e) + "...";
  return /* @__PURE__ */ P.jsx("span", { className: i, style: n, children: s });
}, ry = ({
  subject: r,
  predicate: e,
  object: i,
  fontSize: n = "13px",
  showArrows: s = !0
}) => /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", flexWrap: "wrap" }, children: [
  r && /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
    /* @__PURE__ */ P.jsxs("div", { style: {
      padding: "4px 8px",
      borderRadius: "12px",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      backgroundColor: "rgba(255, 255, 255, 0.05)",
      fontSize: n,
      color: "#fff",
      display: "flex",
      alignItems: "center",
      gap: "4px"
    }, children: [
      /* @__PURE__ */ P.jsx("div", { style: {
        width: "4px",
        height: "4px",
        borderRadius: "50%",
        backgroundColor: "#FF9500"
      } }),
      /* @__PURE__ */ P.jsx(gm, { text: r, maxLength: 10 })
    ] }),
    s && /* @__PURE__ */ P.jsx("div", { style: { color: "rgba(255, 255, 255, 0.6)", fontSize: "12px" }, children: "→" })
  ] }),
  /* @__PURE__ */ P.jsxs("div", { style: {
    padding: "4px 8px",
    borderRadius: "12px",
    border: "1px solid rgba(255, 255, 255, 0.2)",
    backgroundColor: "rgba(255, 255, 255, 0.05)",
    fontSize: n,
    color: "#fff",
    display: "flex",
    alignItems: "center",
    gap: "4px"
  }, children: [
    /* @__PURE__ */ P.jsx("div", { style: {
      width: "4px",
      height: "4px",
      borderRadius: "50%",
      backgroundColor: "#006FE8"
    } }),
    /* @__PURE__ */ P.jsx(gm, { text: e, maxLength: 8 })
  ] }),
  s && /* @__PURE__ */ P.jsx("div", { style: { color: "rgba(255, 255, 255, 0.6)", fontSize: "12px" }, children: "→" }),
  /* @__PURE__ */ P.jsxs("div", { style: {
    padding: "4px 8px",
    borderRadius: "12px",
    border: "1px solid rgba(255, 255, 255, 0.2)",
    backgroundColor: "rgba(255, 255, 255, 0.05)",
    fontSize: n,
    color: "#fff",
    display: "flex",
    alignItems: "center",
    gap: "4px"
  }, children: [
    /* @__PURE__ */ P.jsx("div", { style: {
      width: "4px",
      height: "4px",
      borderRadius: "50%",
      backgroundColor: "#4CAF50"
    } }),
    /* @__PURE__ */ P.jsx(gm, { text: i, maxLength: 12 })
  ] })
] }), wO = ({ label: r, fontSize: e = "13px", maxLength: i = 15 }) => /* @__PURE__ */ P.jsxs("div", { style: {
  padding: "4px 8px",
  borderRadius: "12px",
  border: "1px solid rgba(255, 255, 255, 0.2)",
  backgroundColor: "rgba(255, 255, 255, 0.05)",
  fontSize: e,
  color: "#fff",
  display: "inline-flex",
  alignItems: "center",
  gap: "4px"
}, children: [
  /* @__PURE__ */ P.jsx("div", { style: {
    width: "4px",
    height: "4px",
    borderRadius: "50%",
    backgroundColor: "#9C27B0"
  } }),
  /* @__PURE__ */ P.jsx(gm, { text: r, maxLength: i })
] }), Nc = ({
  isFor: r,
  count: e,
  fontSize: i = "12px",
  showCount: n = !1
}) => /* @__PURE__ */ P.jsxs("div", { style: {
  display: "flex",
  alignItems: "center",
  gap: "4px",
  padding: "4px 8px",
  borderRadius: "6px",
  backgroundColor: r ? "rgba(0, 111, 232, 0.2)" : "rgba(255, 149, 0, 0.2)",
  border: `1px solid ${r ? "rgba(0, 111, 232, 0.3)" : "rgba(255, 149, 0, 0.3)"}`
}, children: [
  /* @__PURE__ */ P.jsx("div", { style: {
    width: "0",
    height: "0",
    borderLeft: "4px solid transparent",
    borderRight: "4px solid transparent",
    borderBottom: r ? "6px solid #006FE8" : "none",
    borderTop: r ? "none" : "6px solid #FF9500"
  } }),
  /* @__PURE__ */ P.jsx("span", { style: {
    fontSize: i,
    color: r ? "#006FE8" : "#FF9500",
    fontWeight: "600"
  }, children: n && e !== void 0 ? e : r ? "For" : "Against" })
] });
var EO = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, c2 = si.createContext && /* @__PURE__ */ si.createContext(EO), Doe = ["attr", "size", "title"];
function Loe(r, e) {
  if (r == null) return {};
  var i = koe(r, e), n, s;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(r);
    for (s = 0; s < a.length; s++)
      n = a[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (i[n] = r[n]);
  }
  return i;
}
function koe(r, e) {
  if (r == null) return {};
  var i = {};
  for (var n in r)
    if (Object.prototype.hasOwnProperty.call(r, n)) {
      if (e.indexOf(n) >= 0) continue;
      i[n] = r[n];
    }
  return i;
}
function ag() {
  return ag = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n]);
    }
    return r;
  }, ag.apply(this, arguments);
}
function h2(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function og(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? h2(Object(i), !0).forEach(function(n) {
      Uoe(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : h2(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function Uoe(r, e, i) {
  return e = Foe(e), e in r ? Object.defineProperty(r, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = i, r;
}
function Foe(r) {
  var e = Boe(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Boe(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function MO(r) {
  return r && r.map((e, i) => /* @__PURE__ */ si.createElement(e.tag, og({
    key: i
  }, e.attr), MO(e.child)));
}
function AO(r) {
  return (e) => /* @__PURE__ */ si.createElement(zoe, ag({
    attr: og({}, r.attr)
  }, e), MO(r.child));
}
function zoe(r) {
  var e = (i) => {
    var {
      attr: n,
      size: s,
      title: a
    } = r, o = Loe(r, Doe), l = s || i.size || "1em", u;
    return i.className && (u = i.className), r.className && (u = (u ? u + " " : "") + r.className), /* @__PURE__ */ si.createElement("svg", ag({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, i.attr, n, o, {
      className: u,
      style: og(og({
        color: r.color || i.color
      }, i.style), r.style),
      height: l,
      width: l,
      xmlns: "http://www.w3.org/2000/svg"
    }), a && /* @__PURE__ */ si.createElement("title", null, a), r.children);
  };
  return c2 !== void 0 ? /* @__PURE__ */ si.createElement(c2.Consumer, null, (i) => e(i)) : e(EO);
}
function joe(r) {
  return AO({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z" }, child: [] }] })(r);
}
function Voe(r) {
  return AO({ attr: { viewBox: "0 0 640 512" }, child: [{ tag: "path", attr: { d: "M608 320h-64v64h22.4c5.3 0 9.6 3.6 9.6 8v16c0 4.4-4.3 8-9.6 8H73.6c-5.3 0-9.6-3.6-9.6-8v-16c0-4.4 4.3-8 9.6-8H96v-64H32c-17.7 0-32 14.3-32 32v96c0 17.7 14.3 32 32 32h576c17.7 0 32-14.3 32-32v-96c0-17.7-14.3-32-32-32zm-96 64V64.3c0-17.9-14.5-32.3-32.3-32.3H160.4C142.5 32 128 46.5 128 64.3V384h384zM211.2 202l25.5-25.3c4.2-4.2 11-4.2 15.2.1l41.3 41.6 95.2-94.4c4.2-4.2 11-4.2 15.2.1l25.3 25.5c4.2 4.2 4.2 11-.1 15.2L300.5 292c-4.2 4.2-11 4.2-15.2-.1l-74.1-74.7c-4.3-4.2-4.2-11 0-15.2z" }, child: [] }] })(r);
}
const Goe = async (r, e = ri.MAINNET) => {
  var i, n;
  try {
    const s = En[e], l = (n = (i = (await (await fetch(s, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetAtom($atomId: String!) {
            atoms(where: { term_id: { _eq: $atomId } }) {
              term_id
              image
              label
              emoji
              type
              creator_id
              value {
                person {
                  description
                }
                organization {
                  description
                }
                thing {
                  description
                }
                book {
                  description
                }
              }
              term {
                total_market_cap
              }
            }
          }
        `,
        variables: { atomId: r }
      })
    })).json()).data) == null ? void 0 : i.atoms) == null ? void 0 : n[0];
    return l || null;
  } catch (s) {
    return console.error("Error fetching atom details:", s), null;
  }
}, Hoe = async (r, e = ri.MAINNET, i = 1e3) => {
  var n;
  try {
    const s = En[e];
    return ((n = (await (await fetch(s, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query Triples_for_Agent($objectId: String!, $batchSize: Int!) {
            triples(limit: $batchSize, where: { object_id: { _eq: $objectId } }) {
              term_id
              subject {
                term_id
                label
                type
                image
              }
              predicate {
                term_id
                label
                type
                image
              }
              object {
                term_id
                label
                type
                image
              }
              term {
                total_market_cap
                total_assets
                positions_aggregate {
                  aggregate {
                    count
                  }
                }
              }
              counter_term {
                total_market_cap
                total_assets
                positions_aggregate {
                  aggregate {
                    count
                  }
                }
              }
            }
          }
        `,
        variables: { objectId: r, batchSize: i }
      })
    })).json()).data) == null ? void 0 : n.triples) || [];
  } catch (s) {
    return console.error("Error fetching triples for agent:", s), [];
  }
}, Woe = async (r, e, i = ri.MAINNET) => {
  var n, s, a, o;
  try {
    const l = En[i], u = "0x4b5ec64b82fae56c71a469fc902df2096b0dc7c930dd61032e817d583575fe47", h = await (await fetch(l, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetFollowsAndFollowers($predicateId: String!, $userAtomId: String!) {
            follows: triples(
              where: {
                _and: [
                  { predicate_id: { _eq: $predicateId } },
                  { subject_id: { _eq: $userAtomId } }
                ]
              }
            ) {
              term_id
              object {
                term_id
                label
                image
                creator_id
              }
            }
            followers: triples(
              where: {
                _and: [
                  { predicate_id: { _eq: $predicateId } },
                  { object_id: { _eq: $userAtomId } }
                ]
              }
            ) {
              term_id
              creator_id
              subject {
                term_id
                label
                image
              }
            }
          }
        `,
        variables: { predicateId: r, userAtomId: u }
      })
    })).json();
    return {
      follows: ((s = (n = h.data) == null ? void 0 : n.follows) == null ? void 0 : s.map((d) => ({
        ...d,
        object: { ...d.object, id: d.object.term_id }
      }))) || [],
      followers: ((o = (a = h.data) == null ? void 0 : a.followers) == null ? void 0 : o.map((d) => ({
        ...d,
        subject: { ...d.subject, id: d.subject.term_id }
      }))) || []
    };
  } catch (l) {
    return console.error("Error fetching follows and followers:", l), { follows: [], followers: [] };
  }
}, CO = async (r, e = ri.MAINNET) => {
  var i;
  try {
    const n = En[e];
    return ((i = (await (await fetch(n, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
        query ClaimsBySubject($subjectId: String!) {
          triples(where: { subject_id: { _eq: $subjectId } }) {
            term_id
            subject {
              term_id
              label
              type
              image
            }
            predicate {
              term_id
              label
              type
            }
            object {
              term_id
              label
              type
              image
            }
            term {
              total_market_cap
              positions_aggregate(where: { shares: { _gt: 0 } }) {
                aggregate { count }
              }
            }
            counter_term {
              id
              total_market_cap
              positions_aggregate(where: { shares: { _gt: 0 } }) {
                aggregate { count }
              }
            }
          }
        }
      `,
        variables: { subjectId: r }
      })
    })).json()).data) == null ? void 0 : i.triples) || [];
  } catch (n) {
    return console.error("Error fetching claims by subject:", n), [];
  }
}, qoe = async (r, e, i, n = ri.MAINNET) => {
  var l;
  const s = En[n], a = {
    where: {
      subject: {
        creator_id: { _eq: r }
      },
      predicate_id: {
        _eq: e
      },
      object_id: {
        _eq: i
      }
    }
  }, o = `
    query GetTriples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject_id
        predicate_id
        object_id
        subject {
          term_id
          label
          type
          creator_id
          value {
            person {
              description
            }
            organization {
              description
            }
            thing {
              description
            }
            book {
              description
            }
          }
        }
        predicate {
          term_id
          label
          type
        }
        object {
          term_id
          label
          type
        }
        block_number
        created_at
        transaction_hash
      }
    }
  `;
  try {
    const c = await (await fetch(s, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify({
        query: o,
        // ← Utiliser la requête directe
        variables: a
      })
    })).json();
    if (c.errors)
      throw console.error("la Erreurs GraphQL:", c.errors), new Error(((l = c.errors[0]) == null ? void 0 : l.message) || "Erreur GraphQL inconnue");
    return c.data;
  } catch (u) {
    throw console.error(
      `[fetchTriplesByCreator] Erreur lors de la requête directe vers ${s}:`,
      u
    ), u;
  }
}, vT = (r, e, i, n = ri.MAINNET, s) => {
  const { PLAYER_TRIPLE_TYPES: a } = s || { PLAYER_TRIPLE_TYPES: { PLAYER_GAME: { predicateId: "", objectId: "" } } }, o = e || a.PLAYER_GAME.predicateId, l = i || a.PLAYER_GAME.objectId, [u, c] = ve(null), [h, d] = ve(!0), [p, f] = ve(null);
  Ft(() => {
    (async () => {
      if (!r) {
        d(!1);
        return;
      }
      try {
        const v = await qoe(
          r,
          o,
          l,
          n
        );
        c(v);
      } catch (v) {
        console.error(
          `[${n}] Erreur lors de la récupération des triples:`,
          v
        ), f(v instanceof Error ? v : new Error(String(v)));
      } finally {
        d(!1);
      }
    })();
  }, [r, e, i, n]);
  const m = (u == null ? void 0 : u.triples) || [];
  return {
    loading: h,
    error: p,
    triples: m,
    network: n,
    rawData: u
  };
}, Xoe = (r, e = ri.MAINNET, i) => {
  const [n, s] = ve([]), [a, o] = ve([]), [l, u] = ve([]), [c, h] = ve({
    follows: [],
    followers: []
  }), [d, p] = ve(!1), [f, m] = ve(null), { COMMON_IDS: y } = i, { triples: v, loading: g, error: _ } = vT(
    r || "",
    i.PLAYER_TRIPLE_TYPES.PLAYER_GAME.predicateId,
    i.PLAYER_TRIPLE_TYPES.PLAYER_GAME.objectId,
    e
  ), x = v.length > 0 ? v[0].subject : null;
  return Ft(() => {
    if (!r) {
      s([]), o([]), u([]);
      return;
    }
    (async () => {
      p(!0), m(null);
      try {
        const [T, S, w] = await Promise.all([
          Hoe(r, e),
          iy(r, e),
          Woe(y.FOLLOWS, r, e)
          // Ajouter les connections
        ]);
        s(T), o(S), h(w);
      } catch (T) {
        console.error("Error loading sidebar data:", T), m(T instanceof Error ? T.message : "Unknown error");
      } finally {
        p(!1);
      }
    })();
  }, [r, e]), Ft(() => {
    if (!x) {
      u([]);
      return;
    }
    (async () => {
      try {
        const T = await CO(x.term_id, e);
        u(T);
      } catch (T) {
        console.error("Error loading claims:", T), u([]);
      }
    })();
  }, [x, e]), {
    atomDetails: x,
    triples: n,
    positions: a,
    activities: l,
    connections: c,
    loading: d || g,
    error: f || (_ ? _.message : null)
  };
}, $oe = (r, e = ri.MAINNET) => {
  const [i, n] = ve(null), [s, a] = ve(!1), [o, l] = ve(null);
  return Ft(() => {
    if (!(r != null && r.id)) {
      n(null), l(null);
      return;
    }
    (async () => {
      a(!0), l(null);
      try {
        const c = await Goe(r.id, e);
        n(c);
      } catch (c) {
        console.error("Error loading selected atom details:", c), l(c instanceof Error ? c.message : "Unknown error"), n(null);
      } finally {
        a(!1);
      }
    })();
  }, [r == null ? void 0 : r.id, e]), {
    atomDetails: i,
    loading: s,
    error: o
  };
}, Yoe = (r, e = ri.MAINNET) => {
  const [i, n] = ve([]), [s, a] = ve(!1), [o, l] = ve(null);
  return Ft(() => {
    if (!(r != null && r.id)) {
      n([]), l(null);
      return;
    }
    (async () => {
      a(!0), l(null);
      try {
        const c = await CO(r.id, e);
        n(c);
      } catch (c) {
        console.error("Error loading selected atom claims:", c), l(c instanceof Error ? c.message : "Unknown error"), n([]);
      } finally {
        a(!1);
      }
    })();
  }, [r == null ? void 0 : r.id, e]), {
    claims: i,
    loading: s,
    error: o
  };
}, Koe = ({ walletAddress: r, walletConnected: e, walletHooks: i, onOpenVoting: n, constants: s, gamesId: a, wagmiConfig: o }) => {
  const [l, u] = ve(null), [c, h] = ve(!1), d = (Q) => {
    u(Q);
  }, [p, f] = ve("base"), [m, y] = ve(!1), [v, g] = ve(!1), [_, x] = ve(""), b = () => {
    n ? n() : console.warn("onOpenVoting not provided to PlayerMapGraph");
  }, { atomDetails: T, activities: S, connections: w, loading: M, error: E } = Xoe(r, ri.MAINNET, s), { atomDetails: A, loading: N, error: U } = $oe(l, ri.MAINNET), { claims: k, loading: C, error: I } = Yoe(l, ri.MAINNET);
  Ft(() => {
    l && T && ((l == null ? void 0 : l.id) === (T == null ? void 0 : T.id) || (l == null ? void 0 : l.id) === (T == null ? void 0 : T.term_id) ? (h(!0), g(!0)) : (h(!1), g(!0)));
  }, [l, T]);
  const O = {
    background: "#ffd32a",
    color: "#18181b",
    border: "none",
    borderRadius: 12,
    width: 44,
    height: 44,
    fontSize: 22,
    fontWeight: "bold",
    boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
    cursor: "pointer",
    marginBottom: 0,
    marginTop: 0,
    textTransform: "uppercase",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: 0,
    transition: "background 0.2s, color 0.2s, transform 0.1s"
  }, W = {
    background: "#ffe066",
    color: "#18181b",
    transform: "translateY(-2px) scale(1.03)"
  }, V = (Q) => _ === Q ? { ...O, ...W } : O;
  return /* @__PURE__ */ P.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        height: "100%",
        width: "100%",
        position: "relative",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ P.jsx(
          "div",
          {
            style: {
              position: "relative",
              flex: 1,
              width: "100%",
              height: "100%",
              overflow: "hidden"
            },
            children: /* @__PURE__ */ P.jsx(
              Dae,
              {
                endpoint: p,
                onNodeSelect: d,
                onLoadingChange: y,
                walletAddress: r,
                gamesId: a,
                disableNodeDetailsSidebar: !0
              }
            )
          }
        ),
        m && /* @__PURE__ */ P.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              zIndex: 2
            },
            children: /* @__PURE__ */ P.jsx(kC, {})
          }
        ),
        /* @__PURE__ */ P.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "18px",
              left: "18px",
              zIndex: 50,
              display: "flex",
              flexDirection: "row",
              gap: "12px",
              alignItems: "center"
            },
            children: /* @__PURE__ */ P.jsx(
              "button",
              {
                style: V("profile"),
                onClick: () => {
                  h(!0), g(!0);
                },
                "aria-label": "Profile",
                onMouseEnter: () => x("profile"),
                onMouseLeave: () => x(""),
                children: /* @__PURE__ */ P.jsx(joe, {})
              }
            )
          }
        ),
        /* @__PURE__ */ P.jsx(
          "div",
          {
            style: {
              position: "absolute",
              bottom: "50%",
              right: "18px",
              zIndex: 50
            },
            children: /* @__PURE__ */ P.jsxs(
              "button",
              {
                style: {
                  ...V("vote"),
                  fontSize: "18px",
                  fontWeight: "bolder",
                  width: "auto",
                  minWidth: "160px",
                  padding: "0 12px",
                  display: "flex",
                  alignItems: "center",
                  gap: "8px"
                },
                onClick: b,
                "aria-label": "Vote",
                onMouseEnter: () => x("vote"),
                onMouseLeave: () => x(""),
                children: [
                  "GIVE A FEEDBACK ",
                  /* @__PURE__ */ P.jsx(Voe, {})
                ]
              }
            )
          }
        ),
        v && /* @__PURE__ */ P.jsx(
          "div",
          {
            style: {
              position: "absolute",
              inset: 0,
              backgroundColor: "rgba(0, 0, 0, 0.35)",
              zIndex: 1200,
              pointerEvents: "auto"
            },
            onClick: () => g(!1)
          }
        ),
        /* @__PURE__ */ P.jsxs(
          Lae,
          {
            open: v,
            onClose: () => g(!1),
            children: [
              (M || N || C) && /* @__PURE__ */ P.jsx("p", { children: "Loading data..." }),
              (E || U || I) && /* @__PURE__ */ P.jsxs("p", { style: { color: "red" }, children: [
                "Error : ",
                E || U || I
              ] }),
              !M && !E && !N && !U && !C && !I && /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
                /* @__PURE__ */ P.jsx(
                  Vae,
                  {
                    atomDetails: c ? T : A,
                    connections: c ? w : { follows: [], followers: [] },
                    walletAddress: r
                  }
                ),
                /* @__PURE__ */ P.jsx(
                  Moe,
                  {
                    activities: c ? S : k,
                    title: c ? "My Claims" : "Claims",
                    walletAddress: r,
                    walletConnected: e,
                    publicClient: o == null ? void 0 : o.publicClient
                  }
                ),
                c && /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
                  /* @__PURE__ */ P.jsx(
                    Noe,
                    {
                      accountId: r || "",
                      walletConnected: e,
                      walletAddress: r
                    }
                  ),
                  /* @__PURE__ */ P.jsx(Ioe, { accountId: r || "" })
                ] })
              ] })
            ]
          }
        )
      ]
    }
  );
}, RO = ({
  isOpen: r,
  onConnectWallet: e
}) => r ? /* @__PURE__ */ P.jsx(
  "div",
  {
    style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "rgba(0, 0, 0, 0.7)",
      backdropFilter: "blur(5px)",
      zIndex: 1e3,
      width: "100%",
      height: "100%"
    },
    children: /* @__PURE__ */ P.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#1a1a2e",
          padding: "30px",
          borderRadius: "10px",
          textAlign: "center",
          maxWidth: "500px",
          boxShadow: "0 0 15px rgba(108, 92, 231, 0.5)"
        },
        children: [
          /* @__PURE__ */ P.jsx("h2", { style: { color: "#6c5ce7", marginBottom: "20px" }, children: "Wallet Required" }),
          /* @__PURE__ */ P.jsx("p", { style: { fontSize: "18px", marginBottom: "25px", color: "#fff" }, children: "Please connect your wallet to access this feature" }),
          /* @__PURE__ */ P.jsx(
            "button",
            {
              onClick: e,
              style: {
                padding: "12px 24px",
                backgroundColor: "#6c5ce7",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
                fontSize: "16px"
              },
              children: "Connect Wallet"
            }
          )
        ]
      }
    )
  }
) : null, Zoe = ({
  isOpen: r,
  onCreatePlayer: e,
  onClose: i
}) => r ? /* @__PURE__ */ P.jsx(
  "div",
  {
    style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "rgba(0, 0, 0, 1)",
      backdropFilter: "blur(1px)",
      zIndex: 1e3,
      width: "100%",
      height: "100%"
    },
    children: /* @__PURE__ */ P.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#1a1a2e",
          padding: "30px",
          borderRadius: "10px",
          textAlign: "center",
          maxWidth: "500px",
          boxShadow: "0 0 15px rgba(0, 128, 255, 0.7)",
          position: "relative"
        },
        children: [
          i && /* @__PURE__ */ P.jsx(
            "button",
            {
              onClick: i,
              style: {
                position: "absolute",
                top: "10px",
                right: "10px",
                backgroundColor: "transparent",
                border: "none",
                fontSize: "20px",
                color: "#666",
                cursor: "pointer"
              },
              children: "×"
            }
          ),
          /* @__PURE__ */ P.jsx("h2", { style: { color: "#FFD32A", marginBottom: "20px" }, children: "Player Required" }),
          /* @__PURE__ */ P.jsx("p", { style: { fontSize: "18px", marginBottom: "25px", color: "#fff" }, children: "You need to create a player before you can vote on claims" }),
          /* @__PURE__ */ P.jsx(
            "button",
            {
              onClick: e,
              style: {
                padding: "12px 24px",
                backgroundColor: "#1976d2",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
                fontSize: "16px"
              },
              children: "Create Player"
            }
          )
        ]
      }
    )
  }
) : null, Qoe = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  network: n = ri.MAINNET,
  onSuccess: s
}) => {
  const [a, o] = ve(!1), [l, u] = ve({
    status: "idle",
    message: ""
  }), { depositTriple: c, isLoading: h } = SO({
    walletConnected: r,
    walletAddress: e,
    publicClient: i,
    network: n
  });
  return {
    submitVotes: async (p) => {
      var m;
      if (!p.some((y) => y.units > 0))
        return u({
          status: "error",
          message: "Please place at least one vote."
        }), null;
      if (!r || !e)
        return u({
          status: "error",
          message: "Wallet not connected."
        }), null;
      try {
        o(!0), u({
          status: "pending",
          message: "Transaction in progress..."
        });
        const v = p.filter((_) => _.units > 0).map((_) => ({
          claimId: `0x${_.id.toString(16).padStart(64, "0")}`,
          units: _.units,
          direction: _.direction
        })), g = await c(v);
        if (g.success)
          return u({
            status: "success",
            message: `Transaction successful! Hash: ${(m = g.hash) == null ? void 0 : m.substring(0, 10)}...`
          }), s && s(), g;
        {
          let _ = g.error || "An error occurred.";
          return _.includes("user rejected") ? u({
            status: "error",
            message: "Transaction cancelled: User rejected the request."
          }) : u({
            status: "error",
            message: `Error: ${_}`
          }), null;
        }
      } catch (y) {
        return console.error("Error submitting votes:", y), u({
          status: "error",
          message: y instanceof Error ? y.message : "An error occurred."
        }), null;
      } finally {
        o(!1);
      }
    },
    isSubmitting: a,
    isDepositLoading: h,
    transactionStatus: l,
    setTransactionStatus: u
  };
}, Joe = ({
  network: r = ri.MAINNET,
  onError: e
} = {}) => {
  const [i, n] = ve(!1);
  return {
    fetchTripleDetails: async (a) => {
      var o, l, u, c, h, d, p;
      n(!0);
      try {
        const f = En[r], m = await fetch(f, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: `
          query Triple($tripleId: String!) {
            triple(term_id: $tripleId) {
              term_id
              subject_id
              predicate_id
              object_id
              subject {
                term_id
                label
              }
              predicate {
                term_id
                label
              }
              object {
                term_id
                label
              }
              term_id
              term {
                total_market_cap
                total_assets
              }
              counter_term_id
              counter_term {
                total_market_cap
                total_assets
              }
            }
          }
        `,
            variables: { tripleId: a.toString() }
            // Convertir en string pour v2
          })
        });
        if (!m.ok)
          throw new Error(`GraphQL request failed with status ${m.status}`);
        const y = await m.json();
        if (y.errors)
          throw new Error(`GraphQL errors: ${JSON.stringify(y.errors)}`);
        if (!((o = y.data) != null && o.triple))
          return e && e(`Triple with ID ${a} not found`), n(!1), null;
        const v = ((c = (u = (l = y.data.triple.term) == null ? void 0 : l.positions_aggregate) == null ? void 0 : u.aggregate) == null ? void 0 : c.count) || 0, g = ((p = (d = (h = y.data.triple.counter_term) == null ? void 0 : h.positions_aggregate) == null ? void 0 : d.aggregate) == null ? void 0 : p.count) || 0;
        return n(!1), {
          id: String(a),
          subject: y.data.triple.subject,
          predicate: y.data.triple.predicate,
          object: y.data.triple.object,
          term_id: y.data.triple.term_id,
          counter_term_id: y.data.triple.counter_term_id,
          term_position_count: v,
          counter_term_position_count: g
        };
      } catch (f) {
        return e && e(`Error fetching details for triple ${a}: ${f instanceof Error ? f.message : String(f)}`), n(!1), null;
      }
    },
    isLoading: i
  };
}, ele = (r) => {
  const [e, i] = ve(null), [n, s] = ve(!0), [a, o] = ve(null);
  return Ft(() => {
    (async () => {
      if (!r) {
        s(!1);
        return;
      }
      try {
        s(!0);
        const h = await (await fetch(En[ri.MAINNET], {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            query: `
          query GetTriplesWithPositions($accountId: String!) {
            triples {
              term_id
              counter_term_id
              subject_id
              predicate_id
              object_id
              positions(where: { account_id: { _eq: $accountId } }) {
                account_id
                term_id
                shares
                account {
                  id
                  label
                }
              }
              term {
                id
                total_market_cap
                total_assets
                positions(where: { account_id: { _eq: $accountId } }) {
                  account_id
                  shares
                }
              }
              counter_term {
                id
                total_market_cap
                total_assets
                positions(where: { account_id: { _eq: $accountId } }) {
                  account_id
                  shares
                }
              }
            }
          }
        `,
            variables: { accountId: r }
          })
        })).json();
        if (h.errors)
          throw console.error("GraphQL Errors:", h.errors), new Error(h.errors[0].message);
        const d = {
          triples: h.data.triples,
          positions: h.data.triples.flatMap((p) => {
            var f, m;
            return [
              ...p.positions || [],
              ...((f = p.term) == null ? void 0 : f.positions) || [],
              ...((m = p.counter_term) == null ? void 0 : m.positions) || []
            ];
          })
        };
        i(d), s(!1);
      } catch (u) {
        console.error("Erreur lors de la récupération des triples:", u), o(u), s(!1);
      }
    })();
  }, [r]), { data: e, loading: n, error: a };
}, tle = ({
  network: r = ri.MAINNET,
  walletAddress: e = "",
  onError: i,
  constants: n
}) => {
  const [s, a] = ve([]), [o, l] = ve(!0), { PREDEFINED_CLAIM_IDS: u } = n, [c, h] = ve(0), [d, p] = ve({}), { fetchTripleDetails: f } = Joe({
    network: r,
    onError: i
  }), { data: m, loading: y } = ele(e);
  Ft(() => {
    if (m && !y && e) {
      const T = {};
      m.positions && Array.isArray(m.positions) && m.positions.forEach((S) => {
        if (!S.triple_id) return;
        const w = S.triple_id;
        if (S.is_for !== void 0) {
          const M = S.is_for ? it.For : it.Against;
          T[String(w)] = M;
        } else S.term_id && S.counter_term_id;
      }), m.triples && Array.isArray(m.triples) && m.triples.forEach((S) => {
        var N, U;
        if (!S.id)
          return;
        if (S.positions && Array.isArray(S.positions)) {
          const k = S.positions.find(
            (C) => {
              var I, O;
              return ((O = (I = C.account) == null ? void 0 : I.id) == null ? void 0 : O.toLowerCase()) === e.toLowerCase();
            }
          );
          k && (k.is_for !== void 0 ? T[String(S.id)] = k.is_for ? it.For : it.Against : k.term_id && S.term_id === k.term_id ? T[String(S.id)] = it.For : k.term_id && S.counter_term_id === k.term_id && (T[String(S.id)] = it.Against));
        }
        const w = ((N = S.term) == null ? void 0 : N.positions) || [], M = ((U = S.counter_term) == null ? void 0 : U.positions) || [], E = w.find((k) => {
          var C, I;
          return ((I = (C = k.account) == null ? void 0 : C.id) == null ? void 0 : I.toLowerCase()) === e.toLowerCase();
        }), A = M.find((k) => {
          var C, I;
          return ((I = (C = k.account) == null ? void 0 : C.id) == null ? void 0 : I.toLowerCase()) === e.toLowerCase();
        });
        E ? T[String(S.id)] = it.For : A && (T[String(S.id)] = it.Against);
      }), m.position_triples && Array.isArray(m.position_triples) && m.position_triples.forEach((S) => {
        var M, E, A, N;
        if (!S.triple_id && !((M = S.triple) != null && M.id)) return;
        const w = S.triple_id || ((E = S.triple) == null ? void 0 : E.id);
        S.is_for !== void 0 ? T[String(w)] = S.is_for ? it.For : it.Against : S.term_id && ((A = S.triple) == null ? void 0 : A.term_id) === S.term_id ? T[String(w)] = it.For : S.term_id && ((N = S.triple) == null ? void 0 : N.counter_term_id) === S.term_id && (T[String(w)] = it.Against);
      }), p(T), a(
        (S) => S.map((w) => {
          const M = T[String(w.id)] || it.None, E = M !== it.None;
          return {
            ...w,
            userHasPosition: E,
            userPositionDirection: M
          };
        })
      );
    }
  }, [m, y, e]), Ft(() => {
    try {
      v();
    } catch (T) {
      console.error("Error in loadTripleDetails:", T);
    }
  }, []), Ft(() => {
    const T = s.reduce((S, w) => S + w.units, 0);
    h(T);
  }, [s]);
  const v = async () => {
    l(!0);
    try {
      const T = u.map(async (M) => {
        var N, U, k;
        const E = await f(M);
        if (!E)
          return {
            id: BigInt(M),
            subject: `Claim ${M}`,
            predicate: "is",
            object: "Unknown",
            units: 0,
            direction: it.None,
            userHasPosition: !1,
            userPositionDirection: it.None
          };
        const A = d[String(M)] || it.None;
        return {
          id: BigInt(E.id),
          subject: ((N = E.subject) == null ? void 0 : N.label) || `Subject ${M}`,
          predicate: ((U = E.predicate) == null ? void 0 : U.label) || "is",
          object: ((k = E.object) == null ? void 0 : k.label) || `Object ${M}`,
          units: 0,
          direction: it.None,
          term_id: E.term_id,
          term_position_count: E.term_position_count || 0,
          counter_term_id: E.counter_term_id,
          counter_term_position_count: E.counter_term_position_count || 0,
          userHasPosition: A !== it.None,
          userPositionDirection: A
        };
      }), S = await Promise.all(T);
      S.every((M) => M.object === "Unknown") && i && i("Error: Failed to fetch triple details. Please check your network connection or try again later."), a(S);
    } catch {
      i && i("Error: Failed to fetch triple details");
    } finally {
      l(!1);
    }
  }, g = (T, S, w) => {
    if (S !== it.None && !b(T, S)) {
      const E = s.find((A) => A.id === T);
      if (E && E.userHasPosition && E.userPositionDirection !== it.None) {
        i && i(`Cannot vote ${S === it.For ? "for" : "against"} this claim as you already have an ${E.userPositionDirection === it.For ? "affirmative" : "opposing"} position on it.`);
        return;
      }
    }
    a(
      (M) => M.map((E) => E.id === T ? E.userHasPosition && E.userPositionDirection !== it.None && S !== it.None && E.userPositionDirection !== S ? E : E.direction !== S && E.direction !== it.None ? { ...E, units: w, direction: S } : w === 0 ? { ...E, units: 0, direction: it.None } : { ...E, units: w, direction: S } : E)
    );
  }, _ = () => {
    a(
      (T) => T.map((S) => ({
        ...S,
        units: 0,
        direction: it.None
      }))
    );
  }, x = s.filter((T) => T.units > 0).length, b = (T, S) => {
    const w = s.find((E) => E.id === T);
    return !w || !w.userHasPosition ? !0 : w.userPositionDirection === it.None || w.userPositionDirection === S;
  };
  return {
    voteItems: s,
    setVoteItems: a,
    isLoading: o || y,
    totalUnits: c,
    numberOfTransactions: x,
    handleChangeUnits: g,
    resetAllVotes: _,
    loadTripleDetails: v,
    isVoteDirectionAllowed: b,
    userPositions: d
  };
}, NO = (r) => (r * 0.01).toFixed(2), ile = (r) => (r * 5e-5).toFixed(5), rle = ({
  numberOfTransactions: r,
  totalUnits: e,
  onResetAll: i
}) => /* @__PURE__ */ P.jsxs(
  "div",
  {
    style: {
      backgroundColor: "#10172d",
      padding: "10px",
      borderRadius: "8px",
      marginBottom: "25px",
      display: "flex",
      flexDirection: "column",
      border: "1px solid #1e3b70"
    },
    children: [
      /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", justifyContent: "space-between", marginBottom: "15px" }, children: [
        /* @__PURE__ */ P.jsxs("div", { children: [
          /* @__PURE__ */ P.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Unit value:" }),
          /* @__PURE__ */ P.jsxs("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: [
            NO(e),
            " tTRUST"
          ] })
        ] }),
        /* @__PURE__ */ P.jsxs("div", { children: [
          /* @__PURE__ */ P.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Number of transactions:" }),
          /* @__PURE__ */ P.jsx("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: r })
        ] }),
        /* @__PURE__ */ P.jsxs("div", { children: [
          /* @__PURE__ */ P.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Estimated gas cost:" }),
          /* @__PURE__ */ P.jsxs("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: [
            "~",
            ile(r),
            " tTRUST"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ P.jsxs("div", { style: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center"
      }, children: [
        /* @__PURE__ */ P.jsxs("div", { style: { fontSize: "1em", fontWeight: "bold" }, children: [
          "Total units selected:",
          /* @__PURE__ */ P.jsxs("span", { style: { fontSize: "1.6em", marginLeft: "10px", color: "#FFD32A" }, children: [
            e,
            " ",
            e === 1 ? "unit" : "units"
          ] })
        ] }),
        e > 0 && /* @__PURE__ */ P.jsx(
          "button",
          {
            onClick: i,
            style: {
              backgroundColor: "transparent",
              border: "1px solid #6b7280",
              color: "#FFF",
              padding: "6px 12px",
              borderRadius: "4px",
              cursor: "pointer",
              fontSize: "0.9em"
            },
            children: "Reset all"
          }
        )
      ] })
    ]
  }
), nle = ({ onClose: r }) => /* @__PURE__ */ P.jsxs(
  "div",
  {
    style: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      marginBottom: "25px",
      borderBottom: "1px solid #1e3b70"
    },
    children: [
      /* @__PURE__ */ P.jsx("h2", { style: { fontSize: "1.3em", color: "#FFD32A", margin: 0, fontWeight: "bold" }, children: "VOTE ON CLAIMS" }),
      r && /* @__PURE__ */ P.jsx(
        "button",
        {
          onClick: r,
          style: {
            backgroundColor: "transparent",
            border: "none",
            color: "#FFF",
            cursor: "pointer",
            fontSize: "1.5em"
          },
          children: "×"
        }
      )
    ]
  }
), sle = ({
  walletAddress: r,
  tripleId: e,
  network: i = ri.MAINNET
}) => {
  const [n, s] = ve(!1), [a, o] = ve(null), [l, u] = ve(!0), [c, h] = ve(null), [d, p] = ve(0), [f, m] = ve(0);
  return Ft(() => {
    (async () => {
      var v, g, _, x, b, T, S, w, M, E, A, N, U, k, C, I, O, W, V;
      if (!r || !e) {
        u(!1);
        return;
      }
      try {
        u(!0);
        const Q = En[i], F = await fetch(Q, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: `
              query GetTripleUserPosition($tripleId: String!, $walletAddress: String!) {
                # Get the triple with vault information
                triple(term_id: $tripleId) {
                  term_id
                  subject {
                    label
                  }
                  predicate {
                    label
                  }
                  object {
                    label
                  }
                  term_id
                  counter_term_id
                  
                  # Get vault positions (user only)
                  term {
                    id
                    positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}, shares: {_gt: 0}}) {
                      aggregate {
                        count
                      }
                      nodes {
                        id
                      }
                    }
                  }
                  
                  # Get counter vault positions (user only)
                  counter_term {
                    id
                    positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}, shares: {_gt: 0}}) {
                      aggregate {
                        count
                      }
                      nodes {
                        id
                      }
                    }
                  }
                }
              }
            `,
            variables: {
              tripleId: String(e),
              walletAddress: r.toLowerCase()
            }
          })
        });
        if (!F.ok)
          throw new Error(`GraphQL request failed with status ${F.status}`);
        const B = await F.json();
        if (B.errors)
          throw console.error("GraphQL errors:", B.errors), new Error(`GraphQL errors: ${JSON.stringify(B.errors)}`);
        const q = (v = B.data) == null ? void 0 : v.triple;
        if (!q) {
          s(!1), o(null), u(!1);
          return;
        }
        const G = ((x = (_ = (g = q.term) == null ? void 0 : g.positions_aggregate) == null ? void 0 : _.aggregate) == null ? void 0 : x.count) > 0 || ((S = (T = (b = q.term) == null ? void 0 : b.positions_aggregate) == null ? void 0 : T.nodes) == null ? void 0 : S.length) > 0, z = ((E = (M = (w = q.counter_term) == null ? void 0 : w.positions_aggregate) == null ? void 0 : M.aggregate) == null ? void 0 : E.count) > 0 || ((U = (N = (A = q.counter_term) == null ? void 0 : A.positions_aggregate) == null ? void 0 : N.nodes) == null ? void 0 : U.length) > 0;
        p(((I = (C = (k = q.term) == null ? void 0 : k.positions_aggregate) == null ? void 0 : C.aggregate) == null ? void 0 : I.count) || 0), m(((V = (W = (O = q.counter_term) == null ? void 0 : O.positions_aggregate) == null ? void 0 : W.aggregate) == null ? void 0 : V.count) || 0);
        const Y = G || z;
        s(Y), Y && o(G), u(!1);
      } catch (Q) {
        console.error("Error checking triple position:", Q), h(Q), u(!1);
      }
    })();
  }, [r, e, i]), { hasPosition: n, isFor: a, loading: l, error: c, termPositionCount: d, counterTermPositionCount: f };
}, ale = ({
  voteItem: r,
  onChangeUnits: e,
  isVoteDirectionAllowed: i = () => !0,
  walletAddress: n = "",
  network: s = ri.MAINNET,
  constants: a
}) => {
  const { UNIT_VALUE: o } = a, {
    id: l,
    subject: u,
    predicate: c,
    object: h,
    units: d,
    direction: p,
    term_position_count: f = 0,
    counter_term_position_count: m = 0,
    userHasPosition: y = !1,
    userPositionDirection: v = it.None
  } = r, [g, _] = ve(0), [x, b] = ve(!1), [T, S] = ve(!1), {
    hasPosition: w,
    isFor: M,
    loading: E,
    termPositionCount: A,
    counterTermPositionCount: N
  } = sle({
    walletAddress: n,
    tripleId: `0x${l.toString(16).padStart(64, "0")}`,
    network: s
  }), U = E ? y : w, k = E ? v : M !== null ? M ? it.For : it.Against : it.None, C = 20;
  Ft(() => {
    p === it.For ? _(d) : p === it.Against ? _(-d) : _(0);
  }, [d, p]);
  const I = i ? i(l, it.For) : !U || k === it.For, O = i ? i(l, it.Against) : !U || k === it.Against, W = () => {
    if (!I)
      return;
    const ne = Math.min(g + 1, C);
    _(ne), e(l, it.For, ne);
  }, V = () => {
    if (!I || g <= 0)
      return;
    const ne = g - 1;
    _(ne), ne === 0 ? e(l, it.None, 0) : e(l, it.For, ne);
  }, Q = () => {
    if (!O)
      return;
    const ne = Math.max(g - 1, -C);
    _(ne), e(l, it.Against, Math.abs(ne));
  }, F = () => {
    if (!O || g >= 0)
      return;
    const ne = g + 1;
    _(ne), ne === 0 ? e(l, it.None, 0) : e(l, it.Against, Math.abs(ne));
  }, B = p === it.For && d > 0, q = p === it.Against && d > 0, G = Number(o) / 10 ** 18 * d, z = U && k !== it.None, Y = z && k === it.Against ? "You cannot vote FOR this claim because you already have an AGAINST position" : "", se = z && k === it.For ? "You cannot vote AGAINST this claim because you already have a FOR position" : "";
  return /* @__PURE__ */ P.jsxs(
    "div",
    {
      style: {
        padding: "20px",
        marginBottom: "20px",
        borderRadius: "8px",
        backgroundColor: "#0c1228",
        position: "relative",
        border: z ? k === it.For ? "2px solid #4CAF50" : "2px solid #F44336" : "1px solid #1e3b70",
        boxShadow: "0 4px 10px rgba(0, 0, 0, 0.3)"
      },
      children: [
        d > 0 && /* @__PURE__ */ P.jsxs("div", { style: {
          position: "absolute",
          top: "5px",
          left: "5px",
          backgroundColor: "#FFD32A",
          color: "#000000",
          padding: "3px 6px",
          fontSize: "10px",
          fontWeight: "bold",
          borderRadius: "4px"
        }, children: [
          G.toFixed(2),
          " tTRUST"
        ] }),
        /* @__PURE__ */ P.jsxs("div", { style: {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        }, children: [
          /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center", position: "relative" }, children: [
            /* @__PURE__ */ P.jsx("div", { style: { fontSize: "0.9em", color: "#E1E1E1", marginRight: "10px" }, children: "For ▲:" }),
            k === it.For || k === it.None ? /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
              /* @__PURE__ */ P.jsx(
                "button",
                {
                  onClick: I && g > 0 ? V : void 0,
                  disabled: !I || g <= 0,
                  style: {
                    width: "30px",
                    height: "30px",
                    backgroundColor: I && g > 0 ? "#1e2030" : "#606060",
                    border: "none",
                    borderRadius: "4px",
                    color: "#ffffff",
                    fontSize: "16px",
                    cursor: I && g > 0 ? "pointer" : "not-allowed",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    opacity: I && g > 0 ? 1 : 0.4,
                    pointerEvents: I && g > 0 ? "auto" : "none",
                    userSelect: "none"
                  },
                  children: "-"
                }
              ),
              /* @__PURE__ */ P.jsx("span", { style: { margin: "0 10px", color: "#ffffff", fontWeight: "bold" }, children: B ? d : 0 }),
              /* @__PURE__ */ P.jsxs(
                "div",
                {
                  style: { position: "relative" },
                  onMouseEnter: () => Y && b(!0),
                  onMouseLeave: () => Y && b(!1),
                  children: [
                    /* @__PURE__ */ P.jsx(
                      "button",
                      {
                        onClick: I ? W : void 0,
                        disabled: !I,
                        style: {
                          width: "30px",
                          height: "30px",
                          backgroundColor: I ? "#1976d2" : "#606060",
                          border: !I && z ? "2px solid #F44336" : "none",
                          borderRadius: "4px",
                          color: "#ffffff",
                          fontSize: "16px",
                          cursor: I ? "pointer" : "not-allowed",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          opacity: I ? 1 : 0.4,
                          pointerEvents: I ? "auto" : "none",
                          userSelect: "none"
                        },
                        children: "+"
                      }
                    ),
                    (!I && z || x && Y) && /* @__PURE__ */ P.jsx("div", { style: {
                      position: "absolute",
                      bottom: "100%",
                      left: "50%",
                      transform: "translateX(-50%)",
                      backgroundColor: "#F44336",
                      color: "white",
                      padding: "5px 10px",
                      borderRadius: "4px",
                      fontSize: "12px",
                      whiteSpace: "nowrap",
                      zIndex: 10,
                      marginBottom: "5px"
                    }, children: Y })
                  ]
                }
              )
            ] }) : /* @__PURE__ */ P.jsx("div", { style: {
              backgroundColor: "#606060",
              borderRadius: "4px",
              color: "#ffffff",
              padding: "5px 10px",
              fontSize: "12px",
              marginLeft: "10px"
            }, children: "You have voted AGAINST ▼" })
          ] }),
          /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", marginBottom: "20px", gap: "5px", marginTop: "20px" }, children: [
            /* @__PURE__ */ P.jsx("span", { style: {
              backgroundColor: "#FFB300",
              padding: "4px 8px",
              borderRadius: "4px",
              fontSize: "0.9em",
              color: "#000000",
              fontWeight: "bold"
            }, children: u }),
            "-",
            /* @__PURE__ */ P.jsx("span", { style: {
              backgroundColor: "#ccd3d3",
              padding: "4px 8px",
              borderRadius: "4px",
              fontSize: "0.9em",
              color: "#000000",
              fontWeight: "bold"
            }, children: c }),
            "-",
            /* @__PURE__ */ P.jsx("span", { style: {
              backgroundColor: "#43A047",
              padding: "4px 8px",
              borderRadius: "4px",
              fontSize: "0.9em",
              color: "#000000",
              fontWeight: "bold"
            }, children: h })
          ] }),
          /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
            /* @__PURE__ */ P.jsx("div", { style: { fontSize: "0.9em", color: "#E1E1E1", marginRight: "10px" }, children: "Against ▼:" }),
            k === it.Against || k === it.None ? /* @__PURE__ */ P.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
              /* @__PURE__ */ P.jsx(
                "button",
                {
                  onClick: O && g < 0 ? F : void 0,
                  disabled: !O || g >= 0,
                  style: {
                    width: "30px",
                    height: "30px",
                    backgroundColor: O && g < 0 ? "#1e2030" : "#606060",
                    border: "none",
                    borderRadius: "4px",
                    color: "#ffffff",
                    fontSize: "16px",
                    cursor: O && g < 0 ? "pointer" : "not-allowed",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    opacity: O && g < 0 ? 1 : 0.4,
                    pointerEvents: O && g < 0 ? "auto" : "none",
                    userSelect: "none"
                  },
                  children: "-"
                }
              ),
              /* @__PURE__ */ P.jsx("span", { style: { margin: "0 10px", color: "#ffffff", fontWeight: "bold" }, children: q ? d : 0 }),
              /* @__PURE__ */ P.jsxs(
                "div",
                {
                  style: { position: "relative" },
                  onMouseEnter: () => se && S(!0),
                  onMouseLeave: () => se && S(!1),
                  children: [
                    /* @__PURE__ */ P.jsx(
                      "button",
                      {
                        onClick: O ? Q : void 0,
                        disabled: !O,
                        style: {
                          width: "30px",
                          height: "30px",
                          backgroundColor: O ? "#dc3545" : "#606060",
                          border: !O && z ? "2px solid #4CAF50" : "none",
                          borderRadius: "4px",
                          color: "#ffffff",
                          fontSize: "16px",
                          cursor: O ? "pointer" : "not-allowed",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          opacity: O ? 1 : 0.4,
                          pointerEvents: O ? "auto" : "none",
                          userSelect: "none"
                        },
                        children: "+"
                      }
                    ),
                    (!O && z || T && se) && /* @__PURE__ */ P.jsx("div", { style: {
                      position: "absolute",
                      bottom: "100%",
                      left: "50%",
                      transform: "translateX(-50%)",
                      backgroundColor: "#F44336",
                      color: "white",
                      padding: "5px 10px",
                      borderRadius: "4px",
                      fontSize: "12px",
                      whiteSpace: "nowrap",
                      zIndex: 10,
                      marginBottom: "5px"
                    }, children: se })
                  ]
                }
              )
            ] }) : /* @__PURE__ */ P.jsx("div", { style: {
              backgroundColor: "#606060",
              borderRadius: "4px",
              color: "#ffffff",
              padding: "5px 10px",
              fontSize: "12px",
              marginLeft: "10px"
            }, children: "You have voted FOR ▲" })
          ] })
        ] }),
        /* @__PURE__ */ P.jsxs("div", { className: "flex flex-row justify-between", children: [
          /* @__PURE__ */ P.jsxs("div", { style: {
            fontSize: "0.7em",
            color: "#4CAF50",
            marginBottom: "8px",
            backgroundColor: "rgba(76, 175, 80, 0.1)",
            padding: "2px 6px",
            borderRadius: "4px",
            fontWeight: "bold"
          }, children: [
            A,
            " positions"
          ] }),
          /* @__PURE__ */ P.jsxs("div", { style: {
            fontSize: "0.7em",
            color: "#F44336",
            marginBottom: "8px",
            backgroundColor: "rgba(244, 67, 54, 0.1)",
            padding: "2px 6px",
            borderRadius: "4px",
            fontWeight: "bold"
          }, children: [
            N,
            " positions"
          ] })
        ] })
      ]
    }
  );
}, ole = ({
  isLoading: r,
  voteItems: e,
  onChangeUnits: i,
  isVoteDirectionAllowed: n,
  walletAddress: s = "",
  network: a = ri.MAINNET,
  constants: o
}) => r ? /* @__PURE__ */ P.jsx("div", { style: { textAlign: "center", padding: "30px", color: "#6b7280", fontSize: "1.1em" }, children: "Loading claims..." }) : /* @__PURE__ */ P.jsx("div", { style: { marginBottom: "25px" }, children: e.map((l) => /* @__PURE__ */ P.jsx(
  ale,
  {
    voteItem: l,
    onChangeUnits: i,
    isVoteDirectionAllowed: n,
    walletAddress: s,
    network: a,
    constants: o
  },
  l.id.toString()
)) }), lle = ({
  onSubmit: r,
  isSubmitting: e,
  isDepositLoading: i,
  totalUnits: n,
  numberOfTransactions: s
}) => /* @__PURE__ */ P.jsxs("div", { style: { textAlign: "center" }, children: [
  /* @__PURE__ */ P.jsx("div", { style: { marginBottom: "15px", fontSize: "0.9em", color: "#6b7280" }, children: s > 0 && `You will initiate ${s} transaction${s > 1 ? "s" : ""}` }),
  /* @__PURE__ */ P.jsx(
    "button",
    {
      onClick: r,
      disabled: e || i || n === 0,
      style: {
        backgroundColor: n > 0 && !e && !i ? "#1976d2" : "#10172d",
        color: "#FFF",
        padding: "12px 30px",
        border: "none",
        borderRadius: "8px",
        fontSize: "1.1em",
        fontWeight: "bold",
        cursor: n > 0 && !e && !i ? "pointer" : "not-allowed",
        width: "100%",
        maxWidth: "350px",
        boxShadow: "0 4px 10px rgba(0, 0, 0, 0.3)",
        transition: "background-color 0.2s ease"
      },
      children: e || i ? "Processing..." : n > 0 ? `Submit votes (${NO(n)} tTRUST)` : "Submit votes"
    }
  )
] }), ule = ({
  transactionStatus: r
}) => r.status === "idle" || r.status === "whitelist_error" ? null : /* @__PURE__ */ P.jsx(
  "div",
  {
    style: {
      marginTop: "25px",
      padding: "20px",
      borderRadius: "8px",
      backgroundColor: r.status === "pending" ? "#10172d" : r.status === "approval_pending" ? "rgba(255, 211, 42, 0.1)" : r.status === "success" ? "rgba(0, 128, 0, 0.1)" : "rgba(255, 0, 0, 0.1)",
      color: r.status === "success" ? "#4CAF50" : r.status === "error" ? "#F44336" : r.status === "approval_pending" ? "#FFD32A" : "#FFF",
      display: "flex",
      flexDirection: "column",
      gap: "10px",
      border: "1px solid #1e3b70"
    },
    children: /* @__PURE__ */ P.jsx("div", { children: r.message })
  }
), cle = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  onClose: n,
  network: s = ri.MAINNET,
  onConnectWallet: a,
  onCreatePlayer: o,
  wagmiConfig: l,
  walletHooks: u,
  constants: c
}) => {
  const [h, d] = ve(!1), [p, f] = ve(!1), [m, y] = ve(!1), { PLAYER_TRIPLE_TYPES: v } = c, {
    loading: g,
    triples: _
  } = vT(
    e || "",
    v.PLAYER_GAME.predicateId,
    v.PLAYER_GAME.objectId,
    s,
    c
    // Passer les constantes personnalisées !
  ), x = _.length > 0;
  Ft(() => {
    y(!!(e && e !== ""));
  }, [e]), Ft(() => {
    f(!!(m && !x && !g));
  }, [m, x, g]);
  const {
    voteItems: b,
    isLoading: T,
    totalUnits: S,
    numberOfTransactions: w,
    handleChangeUnits: M,
    resetAllVotes: E,
    isVoteDirectionAllowed: A
  } = tle({
    network: s,
    walletAddress: e,
    onError: (z) => {
      I({
        status: "error",
        message: z
      });
    },
    constants: c
    // Passer les constantes personnalisées !
  }), {
    submitVotes: N,
    isSubmitting: U,
    isDepositLoading: k,
    transactionStatus: C,
    setTransactionStatus: I
  } = Qoe({
    walletConnected: r,
    walletAddress: e,
    publicClient: i,
    network: s,
    onSuccess: E
  }), O = async () => {
    await N(b);
  }, W = () => {
    f(!1), d(!0), o && o();
  }, V = () => {
    d(!1);
  }, Q = () => {
    f(!1), n && n();
  }, { isCorrectNetwork: F, currentChainId: B, targetChainId: q, allowedChainIds: G } = mC({
    walletConnected: r,
    publicClient: i
  });
  return m ? m && !x && !g ? /* @__PURE__ */ P.jsxs(
    "div",
    {
      style: {
        backgroundColor: "#070b1a",
        minHeight: "50vh",
        color: "#fff",
        padding: "15px",
        border: "1px solid #1e3b70",
        borderRadius: "8px",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: [
        /* @__PURE__ */ P.jsx(
          Zoe,
          {
            isOpen: !0,
            onCreatePlayer: W,
            onClose: Q
          }
        ),
        /* @__PURE__ */ P.jsx(
          yC,
          {
            isOpen: h,
            onClose: V,
            walletConnected: r,
            walletAddress: e,
            wagmiConfig: l,
            walletHooks: u
          }
        )
      ]
    }
  ) : /* @__PURE__ */ P.jsxs(
    "div",
    {
      style: {
        backgroundColor: "#070b1a",
        minHeight: "50vh",
        opacity: "0.9",
        color: "#fff",
        padding: "15px",
        border: "1px solid #1e3b70",
        borderRadius: "8px",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: [
        /* @__PURE__ */ P.jsx(nle, { onClose: n }),
        /* @__PURE__ */ P.jsx(
          rle,
          {
            numberOfTransactions: w,
            totalUnits: S,
            onResetAll: E
          }
        ),
        /* @__PURE__ */ P.jsx(
          ole,
          {
            isLoading: T || g,
            voteItems: b,
            onChangeUnits: M,
            isVoteDirectionAllowed: A,
            walletAddress: e,
            network: s,
            constants: c
          }
        ),
        /* @__PURE__ */ P.jsx(
          lle,
          {
            onSubmit: O,
            isSubmitting: U,
            isDepositLoading: k,
            totalUnits: S,
            numberOfTransactions: w
          }
        ),
        /* @__PURE__ */ P.jsx(ule, { transactionStatus: C }),
        !F && /* @__PURE__ */ P.jsx(
          gC,
          {
            allowedChainIds: G,
            currentChainId: B,
            targetChainId: q
          }
        )
      ]
    }
  ) : /* @__PURE__ */ P.jsx(
    "div",
    {
      style: {
        backgroundColor: "#070b1a",
        minHeight: "50vh",
        opacity: "0.9",
        color: "#fff",
        padding: "15px",
        border: "1px solid #1e3b70",
        borderRadius: "8px",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: /* @__PURE__ */ P.jsx(
        RO,
        {
          isOpen: !0,
          onConnectWallet: a || (() => {
          })
        }
      )
    }
  );
}, hle = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  onClose: n,
  constants: s,
  wagmiConfig: a
}) => (Ft(() => (document.body.style.overflow = "hidden", () => {
  document.body.style.overflow = "auto";
}), []), /* @__PURE__ */ P.jsx(
  "div",
  {
    className: "fixed inset-0 flex items-center justify-center height-700px",
    style: {
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      zIndex: 1e3
    },
    children: /* @__PURE__ */ P.jsx(
      "div",
      {
        style: {
          backgroundColor: "#18181b",
          borderRadius: "12px",
          boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
          maxWidth: "1000px",
          width: "100%",
          maxHeight: "700px",
          height: "700px",
          display: "flex",
          flexDirection: "column",
          overflow: "hidden"
        },
        children: /* @__PURE__ */ P.jsx("div", { style: {
          flex: 1,
          overflow: "auto",
          padding: "0"
        }, children: /* @__PURE__ */ P.jsx(
          cle,
          {
            walletConnected: r,
            walletAddress: e,
            publicClient: i,
            onClose: n,
            network: "mainnet",
            wagmiConfig: a,
            constants: s
          }
        ) })
      }
    )
  }
)), PO = new foe({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: !1
    }
  }
});
LO({
  queryClient: PO
});
const dle = ({
  children: r
}) => /* @__PURE__ */ P.jsx(goe, { client: PO, children: r }), ple = (r) => T2(() => r != null && r.constants ? {
  ...r.constants,
  UNIT_VALUE: l_
  // Toujours depuis Player-map, jamais paramétrable
} : (console.log("🔧 PlayerMap: Using DEFAULT constants from Player-map", {
  COMMON_IDS: kh.COMMON_IDS,
  PLAYER_TRIPLE_TYPES: kh.PLAYER_TRIPLE_TYPES,
  OFFICIAL_GUILDS: kh.OFFICIAL_GUILDS,
  PREDEFINED_CLAIM_IDS: kh.PREDEFINED_CLAIM_IDS
}), {
  ...kh,
  UNIT_VALUE: l_
}), [r == null ? void 0 : r.constants]), fle = "https://testnet.intuition.sh/v1/graphql";
function mle() {
  xoe({ apiUrl: fle });
}
const Ule = ({
  walletConnected: r = !1,
  walletAddress: e = "",
  wagmiConfig: i,
  walletHooks: n,
  onClose: s,
  onCreatePlayer: a,
  onConnectWallet: o,
  config: l
  // Configuration avec constantes personnalisées
}) => {
  Ft(() => {
    mle();
  }, []);
  const u = ple(l), [c, h] = ve(ri.MAINNET), [d, p] = ve(!1), [f, m] = ve(!1), [y, v] = ve(!1), [g, _] = ve([]), [x, b] = ve(!1), T = e || "";
  Ft(() => {
    v(!!(e && e !== ""));
  }, [e]);
  const {
    loading: S,
    error: w,
    triples: M
  } = vT(T, u.PLAYER_TRIPLE_TYPES.PLAYER_GAME.predicateId, u.PLAYER_TRIPLE_TYPES.PLAYER_GAME.objectId, c);
  Ft(() => {
    (async () => {
      if (!y || !e) {
        _([]);
        return;
      }
      b(!0);
      try {
        const V = await iy(e, c), Q = M.length > 0 ? M[0].term_id : null, F = V.filter((B) => {
          var q;
          return ((q = B.term) == null ? void 0 : q.id) === Q;
        });
        _(F);
      } catch (V) {
        console.error("Error fetching positions:", V), _([]);
      } finally {
        b(!1);
      }
    })();
  }, [y, e, c, M]);
  const E = M.length > 0, A = g.length > 0, N = E && A, U = S || x, k = w, C = Or(() => {
    a && a(), p(!0);
  }, [a]), I = Or(() => {
    p(!1), s && s();
  }, [s]), O = Or(() => {
    o && o();
  }, [o]);
  return k ? /* @__PURE__ */ P.jsxs("div", { style: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100%",
    flexDirection: "column",
    gap: "20px"
  }, children: [
    /* @__PURE__ */ P.jsx("h2", { style: { color: "red", textAlign: "center" }, children: "Erreur lors du chargement des données" }),
    /* @__PURE__ */ P.jsx("p", { style: { textAlign: "center", color: "#666" }, children: k.message || "Une erreur inattendue s'est produite" }),
    /* @__PURE__ */ P.jsx(
      "button",
      {
        onClick: () => window.location.reload(),
        style: {
          padding: "10px 20px",
          backgroundColor: "#FFD32A",
          color: "#000",
          border: "none",
          borderRadius: "5px",
          cursor: "pointer"
        },
        children: "Recharger la page"
      }
    )
  ] }) : U ? /* @__PURE__ */ P.jsxs("div", { style: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100%",
    flexDirection: "column",
    gap: "20px"
  }, children: [
    /* @__PURE__ */ P.jsx("div", { style: {
      width: "50px",
      height: "50px",
      border: "4px solid #FFD32A",
      borderTop: "4px solid transparent",
      borderRadius: "50%",
      animation: "spin 1s linear infinite"
    } }),
    /* @__PURE__ */ P.jsx("p", { style: { textAlign: "center", color: "#666" }, children: "Chargement des données du joueur..." })
  ] }) : /* @__PURE__ */ P.jsx(dle, { children: /* @__PURE__ */ P.jsxs("div", { style: { position: "relative", width: "100%", height: "100%" }, children: [
    /* @__PURE__ */ P.jsx(
      RO,
      {
        isOpen: !y,
        onConnectWallet: O
      }
    ),
    (!y || y && !N) && /* @__PURE__ */ P.jsx("div", { style: {
      filter: y ? "none" : "blur(3px)",
      opacity: y ? 1 : 0.7,
      position: "relative"
    }, children: /* @__PURE__ */ P.jsx(
      FO,
      {
        walletConnected: y,
        walletAddress: e,
        wagmiConfig: i,
        walletHooks: n,
        onCreatePlayer: C
      }
    ) }),
    y && N && /* @__PURE__ */ P.jsx(
      Koe,
      {
        walletAddress: e,
        walletConnected: r,
        walletHooks: n,
        onOpenVoting: () => m(!0),
        constants: u,
        gamesId: u.COMMON_IDS.GAMES_ID,
        wagmiConfig: i
      }
    ),
    /* @__PURE__ */ P.jsx(
      yC,
      {
        isOpen: d,
        onClose: I,
        walletConnected: r,
        walletAddress: e,
        wagmiConfig: i,
        walletHooks: n,
        constants: u
      }
    ),
    f && y && N && /* @__PURE__ */ P.jsx(
      hle,
      {
        walletConnected: r,
        walletAddress: e,
        publicClient: i == null ? void 0 : i.publicClient,
        wagmiConfig: i,
        onClose: () => m(!1),
        constants: u
      }
    )
  ] }) });
}, Fle = async (r, e, i = ri.MAINNET) => {
  var n, s, a, o, l, u, c, h, d, p, f, m, y;
  if (!r)
    throw new Error("Wallet address is required");
  try {
    const v = En[i], g = await fetch(v, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetTripleUserPosition($tripleId: numeric!, $walletAddress: String!) {
            # Get the triple with vault information
            triple(term_id: $tripleId) {
              id
              subject {
                label
              }
              predicate {
                label
              }
              object {
                label
              }
              term_id
              counter_term_id
              
              # Get vault positions
              term {
                id
                positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                  aggregate {
                    count
                  }
                  nodes {
                    id
                  }
                }
              }
              
              # Get counter vault positions
              counter_term {
                id
                positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                  aggregate {
                    count
                  }
                  nodes {
                    id
                  }
                }
              }
            }
          }
        `,
        variables: {
          tripleId: Number(e),
          walletAddress: r.toLowerCase()
        }
      })
    });
    if (!g.ok)
      throw new Error(`GraphQL request failed with status ${g.status}`);
    const _ = await g.json();
    if (_.errors)
      throw console.error("GraphQL errors:", _.errors), new Error(`GraphQL errors: ${JSON.stringify(_.errors)}`);
    const x = (n = _.data) == null ? void 0 : n.triple;
    if (!x)
      return {
        hasPosition: !1,
        isFor: null,
        result: _.data
      };
    const b = ((o = (a = (s = x.term) == null ? void 0 : s.positions_aggregate) == null ? void 0 : a.aggregate) == null ? void 0 : o.count) > 0 || ((c = (u = (l = x.term) == null ? void 0 : l.positions_aggregate) == null ? void 0 : u.nodes) == null ? void 0 : c.length) > 0, T = ((p = (d = (h = x.counter_term) == null ? void 0 : h.positions_aggregate) == null ? void 0 : d.aggregate) == null ? void 0 : p.count) > 0 || ((y = (m = (f = x.counter_term) == null ? void 0 : f.positions_aggregate) == null ? void 0 : m.nodes) == null ? void 0 : y.length) > 0, S = b || T;
    return {
      hasPosition: S,
      isFor: S ? b : null,
      result: _.data
      // Return raw data for debugging
    };
  } catch (v) {
    throw console.error("Error checking triple position:", v), v;
  }
}, Ble = {
  /**
   * Initialise la configuration de la bibliothèque Player-map
   * @param config Configuration contenant l'URL de l'API (obligatoire)
   */
  init: (r) => {
    if (!r.apiUrl)
      throw new Error(
        "L'URL de l'API est obligatoire pour initialiser Player-map"
      );
    return fk(r), !0;
  },
  /**
   * Récupère la configuration actuelle
   * @throws Error si la configuration n'a pas été initialisée
   */
  get: fg
}, zle = {
  setAuthToken: YT,
  getAuthToken: g_,
  isAuthenticated: pg,
  clearAuthToken: pk,
  // Fonction d'initialisation pour les applications intégrant la bibliothèque
  initialize: (r) => r ? (YT(r), !0) : !1
};
export {
  cle as ClaimVoting,
  Ule as GraphComponent,
  woe as PREDEFINED_CLAIM_IDS,
  Ble as PlayerMapConfig,
  Koe as PlayerMapGraph,
  FO as PlayerMapHome,
  yC as RegistrationForm,
  l_ as UNIT_VALUE,
  it as VoteDirection,
  hle as VotingModal,
  zle as auth,
  Fle as checkTriplePosition,
  pk as clearAuthToken,
  FO as default,
  g_ as getAuthToken,
  pg as isAuthenticated,
  YT as setAuthToken,
  sle as useCheckSpecificTriplePosition,
  SO as useDepositTriple,
  ele as useDisplayTriplesWithPosition
};
