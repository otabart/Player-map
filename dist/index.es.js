var hS = (r) => {
  throw TypeError(r);
};
var Jg = (r, e, i) => e.has(r) || hS("Cannot " + i);
var me = (r, e, i) => (Jg(r, e, "read from private field"), i ? i.call(r) : e.get(r)), zt = (r, e, i) => e.has(r) ? hS("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, i), gt = (r, e, i, n) => (Jg(r, e, "write to private field"), n ? n.call(r, i) : e.set(r, i), i), ar = (r, e, i) => (Jg(r, e, "access private method"), i);
var ap = (r, e, i, n) => ({
  set _(s) {
    gt(r, e, s, i);
  },
  get _() {
    return me(r, e, n);
  }
});
import * as d2 from "react";
import Yt, { useState as ke, useEffect as ni, useRef as gr, forwardRef as _I, useMemo as TI, useCallback as kr, useImperativeHandle as SI, useLayoutEffect as wI, createContext as EI } from "react";
import p2 from "3d-force-graph-vr";
var Nv = { exports: {} }, $c = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dS;
function MI() {
  if (dS) return $c;
  dS = 1;
  var r = Yt, e = Symbol.for("react.element"), i = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(l, u, c) {
    var h, d = {}, p = null, f = null;
    c !== void 0 && (p = "" + c), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (f = u.ref);
    for (h in u) n.call(u, h) && !a.hasOwnProperty(h) && (d[h] = u[h]);
    if (l && l.defaultProps) for (h in u = l.defaultProps, u) d[h] === void 0 && (d[h] = u[h]);
    return { $$typeof: e, type: l, key: p, ref: f, props: d, _owner: s.current };
  }
  return $c.Fragment = i, $c.jsx = o, $c.jsxs = o, $c;
}
var Kc = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pS;
function AI() {
  return pS || (pS = 1, process.env.NODE_ENV !== "production" && function() {
    var r = Yt, e = Symbol.for("react.element"), i = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), m = Symbol.iterator, v = "@@iterator";
    function y(R) {
      if (R === null || typeof R != "object")
        return null;
      var ee = m && R[m] || R[v];
      return typeof ee == "function" ? ee : null;
    }
    var g = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(R) {
      {
        for (var ee = arguments.length, ce = new Array(ee > 1 ? ee - 1 : 0), Ce = 1; Ce < ee; Ce++)
          ce[Ce - 1] = arguments[Ce];
        x("error", R, ce);
      }
    }
    function x(R, ee, ce) {
      {
        var Ce = g.ReactDebugCurrentFrame, Ze = Ce.getStackAddendum();
        Ze !== "" && (ee += "%s", ce = ce.concat([Ze]));
        var nt = ce.map(function($e) {
          return String($e);
        });
        nt.unshift("Warning: " + ee), Function.prototype.apply.call(console[R], console, nt);
      }
    }
    var b = !1, T = !1, S = !1, w = !1, C = !1, E;
    E = Symbol.for("react.module.reference");
    function A(R) {
      return !!(typeof R == "string" || typeof R == "function" || R === n || R === a || C || R === s || R === c || R === h || w || R === f || b || T || S || typeof R == "object" && R !== null && (R.$$typeof === p || R.$$typeof === d || R.$$typeof === o || R.$$typeof === l || R.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      R.$$typeof === E || R.getModuleId !== void 0));
    }
    function N(R, ee, ce) {
      var Ce = R.displayName;
      if (Ce)
        return Ce;
      var Ze = ee.displayName || ee.name || "";
      return Ze !== "" ? ce + "(" + Ze + ")" : ce;
    }
    function L(R) {
      return R.displayName || "Context";
    }
    function F(R) {
      if (R == null)
        return null;
      if (typeof R.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof R == "function")
        return R.displayName || R.name || null;
      if (typeof R == "string")
        return R;
      switch (R) {
        case n:
          return "Fragment";
        case i:
          return "Portal";
        case a:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case l:
            var ee = R;
            return L(ee) + ".Consumer";
          case o:
            var ce = R;
            return L(ce._context) + ".Provider";
          case u:
            return N(R, R.render, "ForwardRef");
          case d:
            var Ce = R.displayName || null;
            return Ce !== null ? Ce : F(R.type) || "Memo";
          case p: {
            var Ze = R, nt = Ze._payload, $e = Ze._init;
            try {
              return F($e(nt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var M = Object.assign, P = 0, O, V, B, H, U, j, Q;
    function q() {
    }
    q.__reactDisabledLog = !0;
    function G() {
      {
        if (P === 0) {
          O = console.log, V = console.info, B = console.warn, H = console.error, U = console.group, j = console.groupCollapsed, Q = console.groupEnd;
          var R = {
            configurable: !0,
            enumerable: !0,
            value: q,
            writable: !0
          };
          Object.defineProperties(console, {
            info: R,
            log: R,
            warn: R,
            error: R,
            group: R,
            groupCollapsed: R,
            groupEnd: R
          });
        }
        P++;
      }
    }
    function Y() {
      {
        if (P--, P === 0) {
          var R = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: M({}, R, {
              value: O
            }),
            info: M({}, R, {
              value: V
            }),
            warn: M({}, R, {
              value: B
            }),
            error: M({}, R, {
              value: H
            }),
            group: M({}, R, {
              value: U
            }),
            groupCollapsed: M({}, R, {
              value: j
            }),
            groupEnd: M({}, R, {
              value: Q
            })
          });
        }
        P < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ae = g.ReactCurrentDispatcher, ue;
    function ge(R, ee, ce) {
      {
        if (ue === void 0)
          try {
            throw Error();
          } catch (Ze) {
            var Ce = Ze.stack.trim().match(/\n( *(at )?)/);
            ue = Ce && Ce[1] || "";
          }
        return `
` + ue + R;
      }
    }
    var we = !1, Ne;
    {
      var lt = typeof WeakMap == "function" ? WeakMap : Map;
      Ne = new lt();
    }
    function be(R, ee) {
      if (!R || we)
        return "";
      {
        var ce = Ne.get(R);
        if (ce !== void 0)
          return ce;
      }
      var Ce;
      we = !0;
      var Ze = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var nt;
      nt = ae.current, ae.current = null, G();
      try {
        if (ee) {
          var $e = function() {
            throw Error();
          };
          if (Object.defineProperty($e.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct($e, []);
            } catch (Re) {
              Ce = Re;
            }
            Reflect.construct(R, [], $e);
          } else {
            try {
              $e.call();
            } catch (Re) {
              Ce = Re;
            }
            R.call($e.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Re) {
            Ce = Re;
          }
          R();
        }
      } catch (Re) {
        if (Re && Ce && typeof Re.stack == "string") {
          for (var We = Re.stack.split(`
`), k = Ce.stack.split(`
`), W = We.length - 1, te = k.length - 1; W >= 1 && te >= 0 && We[W] !== k[te]; )
            te--;
          for (; W >= 1 && te >= 0; W--, te--)
            if (We[W] !== k[te]) {
              if (W !== 1 || te !== 1)
                do
                  if (W--, te--, te < 0 || We[W] !== k[te]) {
                    var se = `
` + We[W].replace(" at new ", " at ");
                    return R.displayName && se.includes("<anonymous>") && (se = se.replace("<anonymous>", R.displayName)), typeof R == "function" && Ne.set(R, se), se;
                  }
                while (W >= 1 && te >= 0);
              break;
            }
        }
      } finally {
        we = !1, ae.current = nt, Y(), Error.prepareStackTrace = Ze;
      }
      var K = R ? R.displayName || R.name : "", Ee = K ? ge(K) : "";
      return typeof R == "function" && Ne.set(R, Ee), Ee;
    }
    function vt(R, ee, ce) {
      return be(R, !1);
    }
    function Z(R) {
      var ee = R.prototype;
      return !!(ee && ee.isReactComponent);
    }
    function Vt(R, ee, ce) {
      if (R == null)
        return "";
      if (typeof R == "function")
        return be(R, Z(R));
      if (typeof R == "string")
        return ge(R);
      switch (R) {
        case c:
          return ge("Suspense");
        case h:
          return ge("SuspenseList");
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case u:
            return vt(R.render);
          case d:
            return Vt(R.type, ee, ce);
          case p: {
            var Ce = R, Ze = Ce._payload, nt = Ce._init;
            try {
              return Vt(nt(Ze), ee, ce);
            } catch {
            }
          }
        }
      return "";
    }
    var ct = Object.prototype.hasOwnProperty, xt = {}, it = g.ReactDebugCurrentFrame;
    function Dt(R) {
      if (R) {
        var ee = R._owner, ce = Vt(R.type, R._source, ee ? ee.type : null);
        it.setExtraStackFrame(ce);
      } else
        it.setExtraStackFrame(null);
    }
    function at(R, ee, ce, Ce, Ze) {
      {
        var nt = Function.call.bind(ct);
        for (var $e in R)
          if (nt(R, $e)) {
            var We = void 0;
            try {
              if (typeof R[$e] != "function") {
                var k = Error((Ce || "React class") + ": " + ce + " type `" + $e + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof R[$e] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw k.name = "Invariant Violation", k;
              }
              We = R[$e](ee, $e, Ce, ce, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (W) {
              We = W;
            }
            We && !(We instanceof Error) && (Dt(Ze), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ce || "React class", ce, $e, typeof We), Dt(null)), We instanceof Error && !(We.message in xt) && (xt[We.message] = !0, Dt(Ze), _("Failed %s type: %s", ce, We.message), Dt(null));
          }
      }
    }
    var z = Array.isArray;
    function D(R) {
      return z(R);
    }
    function le(R) {
      {
        var ee = typeof Symbol == "function" && Symbol.toStringTag, ce = ee && R[Symbol.toStringTag] || R.constructor.name || "Object";
        return ce;
      }
    }
    function _e(R) {
      try {
        return Ae(R), !1;
      } catch {
        return !0;
      }
    }
    function Ae(R) {
      return "" + R;
    }
    function xe(R) {
      if (_e(R))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", le(R)), Ae(R);
    }
    var Qe = g.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, je, St;
    function Pe(R) {
      if (ct.call(R, "ref")) {
        var ee = Object.getOwnPropertyDescriptor(R, "ref").get;
        if (ee && ee.isReactWarning)
          return !1;
      }
      return R.ref !== void 0;
    }
    function Ye(R) {
      if (ct.call(R, "key")) {
        var ee = Object.getOwnPropertyDescriptor(R, "key").get;
        if (ee && ee.isReactWarning)
          return !1;
      }
      return R.key !== void 0;
    }
    function ut(R, ee) {
      typeof R.ref == "string" && Qe.current;
    }
    function Fe(R, ee) {
      {
        var ce = function() {
          je || (je = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ee));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "key", {
          get: ce,
          configurable: !0
        });
      }
    }
    function Xe(R, ee) {
      {
        var ce = function() {
          St || (St = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ee));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "ref", {
          get: ce,
          configurable: !0
        });
      }
    }
    var Ct = function(R, ee, ce, Ce, Ze, nt, $e) {
      var We = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: R,
        key: ee,
        ref: ce,
        props: $e,
        // Record the component responsible for creating this element.
        _owner: nt
      };
      return We._store = {}, Object.defineProperty(We._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(We, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ce
      }), Object.defineProperty(We, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ze
      }), Object.freeze && (Object.freeze(We.props), Object.freeze(We)), We;
    };
    function mt(R, ee, ce, Ce, Ze) {
      {
        var nt, $e = {}, We = null, k = null;
        ce !== void 0 && (xe(ce), We = "" + ce), Ye(ee) && (xe(ee.key), We = "" + ee.key), Pe(ee) && (k = ee.ref, ut(ee, Ze));
        for (nt in ee)
          ct.call(ee, nt) && !ze.hasOwnProperty(nt) && ($e[nt] = ee[nt]);
        if (R && R.defaultProps) {
          var W = R.defaultProps;
          for (nt in W)
            $e[nt] === void 0 && ($e[nt] = W[nt]);
        }
        if (We || k) {
          var te = typeof R == "function" ? R.displayName || R.name || "Unknown" : R;
          We && Fe($e, te), k && Xe($e, te);
        }
        return Ct(R, We, k, Ze, Ce, Qe.current, $e);
      }
    }
    var kt = g.ReactCurrentOwner, J = g.ReactDebugCurrentFrame;
    function Oe(R) {
      if (R) {
        var ee = R._owner, ce = Vt(R.type, R._source, ee ? ee.type : null);
        J.setExtraStackFrame(ce);
      } else
        J.setExtraStackFrame(null);
    }
    var de;
    de = !1;
    function Se(R) {
      return typeof R == "object" && R !== null && R.$$typeof === e;
    }
    function Ve() {
      {
        if (kt.current) {
          var R = F(kt.current.type);
          if (R)
            return `

Check the render method of \`` + R + "`.";
        }
        return "";
      }
    }
    function Ue(R) {
      return "";
    }
    var Rt = {};
    function si(R) {
      {
        var ee = Ve();
        if (!ee) {
          var ce = typeof R == "string" ? R : R.displayName || R.name;
          ce && (ee = `

Check the top-level render call using <` + ce + ">.");
        }
        return ee;
      }
    }
    function _i(R, ee) {
      {
        if (!R._store || R._store.validated || R.key != null)
          return;
        R._store.validated = !0;
        var ce = si(ee);
        if (Rt[ce])
          return;
        Rt[ce] = !0;
        var Ce = "";
        R && R._owner && R._owner !== kt.current && (Ce = " It was passed a child from " + F(R._owner.type) + "."), Oe(R), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ce, Ce), Oe(null);
      }
    }
    function Bt(R, ee) {
      {
        if (typeof R != "object")
          return;
        if (D(R))
          for (var ce = 0; ce < R.length; ce++) {
            var Ce = R[ce];
            Se(Ce) && _i(Ce, ee);
          }
        else if (Se(R))
          R._store && (R._store.validated = !0);
        else if (R) {
          var Ze = y(R);
          if (typeof Ze == "function" && Ze !== R.entries)
            for (var nt = Ze.call(R), $e; !($e = nt.next()).done; )
              Se($e.value) && _i($e.value, ee);
        }
      }
    }
    function yr(R) {
      {
        var ee = R.type;
        if (ee == null || typeof ee == "string")
          return;
        var ce;
        if (typeof ee == "function")
          ce = ee.propTypes;
        else if (typeof ee == "object" && (ee.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ee.$$typeof === d))
          ce = ee.propTypes;
        else
          return;
        if (ce) {
          var Ce = F(ee);
          at(ce, R.props, "prop", Ce, R);
        } else if (ee.PropTypes !== void 0 && !de) {
          de = !0;
          var Ze = F(ee);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ze || "Unknown");
        }
        typeof ee.getDefaultProps == "function" && !ee.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Kr(R) {
      {
        for (var ee = Object.keys(R.props), ce = 0; ce < ee.length; ce++) {
          var Ce = ee[ce];
          if (Ce !== "children" && Ce !== "key") {
            Oe(R), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ce), Oe(null);
            break;
          }
        }
        R.ref !== null && (Oe(R), _("Invalid attribute `ref` supplied to `React.Fragment`."), Oe(null));
      }
    }
    var Na = {};
    function Pa(R, ee, ce, Ce, Ze, nt) {
      {
        var $e = A(R);
        if (!$e) {
          var We = "";
          (R === void 0 || typeof R == "object" && R !== null && Object.keys(R).length === 0) && (We += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var k = Ue();
          k ? We += k : We += Ve();
          var W;
          R === null ? W = "null" : D(R) ? W = "array" : R !== void 0 && R.$$typeof === e ? (W = "<" + (F(R.type) || "Unknown") + " />", We = " Did you accidentally export a JSX literal instead of a component?") : W = typeof R, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", W, We);
        }
        var te = mt(R, ee, ce, Ze, nt);
        if (te == null)
          return te;
        if ($e) {
          var se = ee.children;
          if (se !== void 0)
            if (Ce)
              if (D(se)) {
                for (var K = 0; K < se.length; K++)
                  Bt(se[K], R);
                Object.freeze && Object.freeze(se);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Bt(se, R);
        }
        if (ct.call(ee, "key")) {
          var Ee = F(R), Re = Object.keys(ee).filter(function(yt) {
            return yt !== "key";
          }), Ke = Re.length > 0 ? "{key: someKey, " + Re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Na[Ee + Ke]) {
            var tt = Re.length > 0 ? "{" + Re.join(": ..., ") + ": ...}" : "{}";
            _(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ke, Ee, tt, Ee), Na[Ee + Ke] = !0;
          }
        }
        return R === n ? Kr(te) : yr(te), te;
      }
    }
    function Rn(R, ee, ce) {
      return Pa(R, ee, ce, !0);
    }
    function Co(R, ee, ce) {
      return Pa(R, ee, ce, !1);
    }
    var Fl = Co, Bl = Rn;
    Kc.Fragment = n, Kc.jsx = Fl, Kc.jsxs = Bl;
  }()), Kc;
}
process.env.NODE_ENV === "production" ? Nv.exports = MI() : Nv.exports = AI();
var ie = Nv.exports;
const f2 = "data:image/svg+xml,%3csvg%20width='300'%20height='50'%20viewBox='0%200%20500%2084'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20width='500'%20height='84'%20fill='url(%23pattern0_10_2)'/%3e%3cdefs%3e%3cpattern%20id='pattern0_10_2'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_10_2'%20transform='scale(0.002%200.0119048)'/%3e%3c/pattern%3e%3cimage%20id='image0_10_2'%20width='500'%20height='84'%20preserveAspectRatio='none'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABUCAYAAAB0vcXQAAAAAXNSR0IArs4c6QAAIABJREFUeF7tXQeYJFW5vfdWro4zw2wgioCoJEUMwDOsGEAFFR/6RFEREAH1IUpQQaIEFcWEiiAGVIKib0URFFBEfQbQJ+CCgODCssvuhE5VXfm+PjVVQ01vz0x3T/eE3arvQ2S6wr3/Def+6fyULPC1YcOGjKZpewiC8JwgCPZkjD07CIIVlNICISRPCMG/JUJImVJa4ZzXov//YBAED3iet0bTtPtVVX2MUore8AXuUvr5VAKpBFIJpBJYaAkADjpGg64eWuieTn4/RMD5vsrl8m6CILyRc/56wsl/EEoEQkhXbclms8S2beL7/oZ6vf6rTCbzy2q1euuyZcs2RO/seEh7Io+lPS96IoIt9SWLeWgXc9u21PmwNPqVzoylMU5za2VXINrNJyuVyrMppScSQt5KCFk+zTtcQsjDhJDHCSElQgg08rLImOdzDk09RwjJEkKWEUKeTQgZEASBQDN3HIcwxggAvlarBZIk/da27Svuv//+H++///4WpXRhgL0bYaXPpBJIJZBKIJVAKoEOJdBXQOecy4Zh/GcQBO8jhLxcEAROOKEBD2LT+AOc819QSv9IKV2TyWTWUEoB6m1d1Wp1med5z1UUZR/XdV8tCMIrGGMZ3/eJ53kEYC8IwngQBN+2bfvr22yzDb5HU3BvS7zpTakEUgmkEghNp6k2tDQmQl8AnXPODMN4G2PsfELILgBYzAhBFIDkd/i+f4PnebcMDAw81ksxcc4Vy7IO9DzvMELIkZIkDQdBwD3PA4jjoHC14zjnDw0NPbFVA3u6Qns57dJ3TfFttTe52rsrFW1/JJBKvz9yXfi39hzQa7XaqznnFxPC9+WchOZwTdVGOeFXm6Z5RaFQeKhVtzdt2pTLZDLPIYQ8k3P+TELIDoQQJTKzi5xzh1I6TiktE0I2BEHwD8YYAuIeb6VxP/TQQ8qKFSveFATBcYyxgxhjOGTSIAjqlmV9yXXdc1euXFlPtfWFn4RpCxa/BBYvBCzels06qku46bP2Lb1hQSTQM0Avl8uDjLEvEkLeEVloKOd8I6X0vGw2eyUhBIA8abnZuHFjVtO0QxhjLyOEHEgI2ZsQwjoNjvN9v+L7/p2MsdsEQbgtm83e26x912q1vSilnyKEHCpJEszx9+i6/oI77rhDXLVqlTdXyafrcq4STJ9PJZBKIJVAKoG5SqAngF6r1V7LOb8qCILt0CDGWKWhWV+azWY/Rwg3KA21YwKfer1eP6yRavY2SunrCCE6Atmmv0KletqfgyD0xYe+crwn8p0/LEkSDhDf13X98SS4V6vVV8iyfKrrul/MZrO3wDVAKZ14SXqlEkglsMQkkB6ll9iApc3tswTmBOgAaNu2P+e67kmKohDDMACs/2NZ1vHLli2Ddh4C+djYWIEx9n7G2AcppTHo96RrUe755Ls47PwTl885/7nv+58qFAp/BLAzSjlv2gOq1eqwIAhfC4IAloT/26p96z0ZkS3kJYsSKxa4UQvw+QX45BYygdNubI0S6BrQOecF0zSv9X3/YKSMqapq+L5/WqFQuDwGRZDGKIpyKmX0I5TQDCLTAMAza+WdDcNmgB7AcT/lHdDAb23cd46u6yGwxwcNBNHZtn1BEAQfJYSMEkJO0nX9ulRz72wM0rtTCcwsgRSW0xmSSmA+JNAVoI+Pjz+DMXaTJEl7oJGyJP/JcZ0jdF1fi/8GaG7cuPFwxtjndF3fMdmRGTTqrvrb7vtgWuecX+O67smFQqEEUOecC7Ztn8A5/1Kk2duO45xXLBYvxG+UUr+rRs36ULrBzSqi9IYF5UXa8sW/BNbgEmjilj9PllYP2wP0xMSqVqugab0d5C6+73NBEG7UNO2dlFIbWL5hw4Zl+Xz+SsbYoa7rclEUN/tGwiwO8J9RYhGoIvCtEGnOUzT8DgA9/A6ldF2DrObDuq7fEGvrlmW9LgiC6wkhGdd1EST3tUKh8MFegXq6LpfWokhbm0oglUAqgaUogfYAPepZvV7fyfO83wmCAD84kPhyTdM+FAeWIWXN87zvSpIEJrfQvN58wdwOf3u1WiW5XA6sbrgFh4E/U0p/Rwj5P9/3/8UYezSXy21MPj86OpoXBGFIFMXdGWNIcXs+53wVIWT7yIwOtXvGcdA0jZTLZV/TtKtWr1594hFHHAEbfLBx48bnZbPZnzRy1XdCRH6Dhe4Luq6f1itQX4qTI21zswTSo1k6J1IJpBJYvBJoG9BHRka203X9TkrpMwOwtXB+Rjab/UxsYq9Wqx9paLifCdngpglNjwEeLG6O4xiiKK5uAPN1uVzuFkqp1Y2YoGU7jrN7EARv5py/mxCye5w2F78vBnlExeP/4x+krzmO8wdZlo/QNO1JHAg2bNiwcz6f/xVy4aM0u0s1Tft4CurdjEz6TCqBVAKpBFIJzKcE2gJ05Jjruv5by7KeyzkPBEH4VCaT+WQE5uKGDRs+VywWEcHOgyCY7Z3ws3++Xq9/c2hoqNpLVkGAe71eP4Axdirn/I0T7vwwrn3StA8gB7BblkWgrQtUeNxyrNcjfx33VSqV3ZHPTgjZjlJaJ4Scoev6F1NQn2ZapkrrfK7X9FupBFIJpBKYVgKzgS+AkNm2/UPHcd4MwBYE4Yu6rp8cgaRcq9WuURTlCPjLZyGFGSGEfELX9asIIUG/Gdocx3keUtE454fiEIJ+oM2u64bsdbIsh8Cuqiqqta13HOcNxWLxHtyDOAEQ1QRBsFwQhDHP896Yz+fv6k30e6cIGN3f6WPppE8lMC8SSCfmvIg5ZVSfHzEv8a/MCOjQbqvV6oc555dCyaWM3pjP5f8TfQbL2gEHHHBlEAQwc4eacNJ/DV85gNO2bT+fz39t7dq1Z+24445hdPl8yQxtMk3zjZTSLxNCto0APfTtx4CONkeuAJRbfaOu63/CfeVy+SXw6cuyjAPNg47jvHCbbbYxQjnMYx/mS1bpd7ZGCfQKjHv1nq1xDNI+b7kSmP91MSOgR6D2W865SAh5NAiCfQcGBkrQVGu12qWe552squqkZh4DOv4d5Zo/6TjOewuFAljZFqzKWalUGpAk6TJK6btgHYgoZjebR5zzfzuO8woUjYGJ3TTNoxtEON/ww+oy5Ke5XA5+epFSOme62C13Eqc9SyWQSiCVwGYSCNENezFjDKWv4drcidKQnwRlsaEQViilcMM+Rjh/SNW0+yilYdR0erUngWkBnXOeaZQ+vS8IgmegoIkkSQdmMpm/ApgrlcpJmqZ9SZIkblnWlHfAhA2zdr1e/61hGIevXLlydDFotADoer2OeuyXRaLZjHMWB5Eg8P9qGOZLV6xYYYBvXlXVy2VZPooQUmtYG84qFAqXzbc/vdNzHudcN03zlYj+B2Ne5AoJXxMVtMEhbU60t/fdd5+84447vkiW5X0453bDvcFAwYsrNNdQqvi+/0Qmk/lJ94e5mXsev9c0zR0YY6+PDl7hQ4IgiEEQoJDPbyMK4Fn7G7+vUqlgwwE1MZ4X4n61t6R6ehcOy4wxhnKBd6mq+uBs43bOOeewc845JxgdHd1eUZSXc87zeD6ymIXvqtfrvykUCg/P9q5OehLLrlarreCcv5wxNgQPVyKZXhIE4Zeqqj7U5XfDcUX/zjjjjNfatr1rIzDXUlUVQAAXXoYx9ntZlv88e7spmXgk5KLI1uv1VzPGtvN9H9k2s7ohZ39/d3f4vo9GyaIoPqiq6u/aDRSO5Wnb9uGc822xHqPOId5JHR0d/eOKFSvu6R+vRuv+xnOxVqs9jzH2XyhxTSndBwuqVQZU01swNmD7vJtzfhvn/Lv5fP6B7iTb/VOJef0aSukzpnsTCodpmnZjv2UMZlPG2JswT5P7EmLCKKU/bDl50YlarXYeIeTMaHP+YC6X+wo6MzIy8iJFUe4KgkDM5XIUL8KFAUL0OnLTGWM/yuVy72wuyNK9WHv3pGVZr25YGlaDD6dZU58A9AB9+Vk2m30DvooNShTFO0VB3K1m1NbWarV9t9tuu/HFaHpPbqqMse8TQpDSB0CfQNqJcbpC07TjQdtLKUV6XkdX/A0ARaVSuViWZRDzuJxzKcEAGFptMMkrlcopy5Yt+9Zf/vIXab/99tus1n2nh5VkY+ODlWVZB3POb/Y8zxcEgWEOSpLEgiBYyxh7n6qqsBDNalmJi/VUKpVjRFG8EhtjVPEvdst0JKse3Bxbv1AV8ERN074FOUelgFu+Pu5nuVx+ra7rV3qeh0NdXK+Acc7rmqYdSyn9/nRj0k27E7I7kFJ6FWMM2SaYezg4A6iEIAiOymaz17QzFhO4+rR3Lp53aPNuu+22WlXVgz3P83Bwi9JM5Qbz40Wapn3i6TPl9O69GATr9fozOOc3CIKwH+ZPEARCksmyDeDpRlyTzzS5KXFwE13Xva7BXIk9d1M7h+F4LVuWdTeldN84Zgjr0nVdKZvNXvjkk09esMMOO9Tbed+cOjQhfHbDDTeIr3zlK4+UZRnxVnvLskxh6OxEnvF+HGctNep//Mn3/cvy+fwPZ1oDc21/qz2mWq3eyBhDHFkr7pTY6ntoJpO5aWKj7WW499MtMgzjhZyQ/6UTB/1QnpATlGjP8/ZpCejlcnk3Qsh9jYkgG4bxx3w+/xK8EuYSURTv4ZyDKW4SyOPPAfwJId/KZDLvnY+JM+1paRZZ1uv1l4LnHcVhpgF1qwF2H89ms5/H0NRqtYMymcwvy+WyA6DM5/NHt7cp9XJqzf6uhQD0fD5/Qr1edz3Pk0RRTC7YcJIHQfBX0zTfMDw8/GSXmtm0HY8BfXR09OBMJnOz67q+KIoMAZqqquLfay3Let/Q0FBHgF6v148RBAFgOAnos0u/L3fMCdBxKGn0Y3ts8FHrmOd59SAIji0UCn0F9Gw2u3u9XofRBBtPoOu6UKlUjioUCm0C+lR5JgF9r732Wi3L8sGWZXlQLHAw1TRNrlarF+Xz+Y4B3XXdGxob8X6I9/F9fzNA79PeHHYwCeiiKIaAXq/XrzNN84MrV67sCNBN07y7kQocAjrk7vu+m81mpWq1emG5XO47oCcOSdj/z0EJ7BiUY/DpdJUkQD0Ul67riIt6pGFN+ditt95641vf+tY+sXlOtDTeYwDogiC8eYb2Y61uaGjpe1NKEQDelwuATgDolIYAHAM6Dkuu624O6BgU0zRvcl33kIaGDl/x/sVi8S9YUIZhXNXwMx8dmW6nHAaik9f/aJoWdnoxmNlnkqhpmijZ+uvoLDWpwSYmEEhtXpHL5dagVjui83VdPyIIgk2lUumNQ0NDf+gYoPq5M0SUu5A7rArTaegNk9wVmUymJxp6uVy+uFAonGCaZgjoSAlsxdzXcNt8K5vN4hA0o3bZ6QpIAno2m70ZG3IUxMgzeobZjt01oEuidKXjOimgtzkosYY+NjZ2oCRJV80HoNfrdS86WHcN6KCxFgThhmw2u59lWf6E0j+5HXSkUbYpqim3NQO6wATRsq3rqtVqx4BuGMbdqqzs6wV+4HleCOi5XK7vgB7vgxs2bNgTAdBROezJAwusnq0UwHbk1QToRNd1YppmkM1m2fj4+K0o+lUsFh9t513d3BPvMZVK5UZRFGcDdPhwrlqzZs0JrayRU77fJRZ0DOgjIyMHybL8K1mWkVP+ZV3XP4SG1Ov1lwVB8Jtm0pbEBv47TdPgt3UXO5jHgjVNExH7NyTN0skFFgTBXblc7qW4v1qtPldTtb+7novVfqemaS/vpcmym8nW/Eyzhk4pXQU/VNLk3ktAh8kdGjoAHaY9ZA40AXqoYQqCMMI5P1lRlO/10rKRBPRcLnczNmRFUZhlWRwL3rKsmQG9aVHFoNSJhh6fkKcxxU07rLGcZmE2XHIa+qICdEZ5wmrfDKRhTEUM6Llcbj9YFJoBvbmQVKvxwj2Rq64llXUrM3Pze/DfgiAg1kF0HGcaQG+NArHJvVqt3q3r+r6e54WA7nmem8/n+wro8RrctGnTkaqqfqmR1jyYFHRzPzsxuTdbMPDfiqyQag1xc4TDtaYoSo1zflQ+n4cbtedXM6DPss4RswC31iGqqv6i540hBBVNO9PQy+XyzfBP+b5fdhxn52KxOI4JY5omcrTDYizJK+rgJvhudF1/oh+d6Nc7oTFalgUSmk9NgDoVnrZOhl81HMc5aWBg4Nucc81xnNNQtc3zvBHHcd5WLBZv71hL71dnWmjojLFVQRAsJKAD4AP4s13XvbtUKr1uxYoVG3slszkDetNYJAGdMXZlFCSlzDRkmP/YzKHVxUyE7WxaKaB3linSyuTeCw0dPvTY5I4DIUzuSQ29HUDH/YgfSgI7TKDxe2YD9Bj0ouDH0Ideq9U61tA7A/QuVcTEYogP57Va7dOiKJ6M/bTVQaUZL6JgyTWEkH8QQtYhsj0IAsT0aBGh13M8z3suBgJyTI4BfMUIvMZag8yjIDSBc35cLpf7ZkxD3qtttkNADy3TjuMAB59XKBTGetWO+D0dAXqtVtuLMfZ3xhg0g0sbJVEBdmBfOwkVyaZpHMxeh2az2b6cSHotkBZabb5er/+UEPKyViltvu8/cPPNN+8JXw247CmliDTGxF2t6zrS2HpqRp5Lf5sijb8vy/JmgB4EQc9M7m1o6OFJmjEWchRwzq/UNO24bmXWvAX1GtDj9zXiRg4RBOEizvmTQRBI041JvNFgY1EUBUE/iPZHENreyX0vChAE6+CaRnAbXDl4ZxjxhY1phgvZAogIRkzHF9sJ7ksGxS2ED31Raegz8EXEh0q4pxqgcJYois/zPK+GbA2MRzy2Sd9vkkI6jiKnlO4niuKAbdsIxAQNNZixmSiKjzLGUJMCAzzpnmw2IcdjH5mlfUTr+77/C9d1vzw4OFhuJxYp1tDL5fLd2Wx2XjT0eJ4ZhoFg6eNjK+A0h9l4kv8MMVaapv0ySk/bbOonMk1Qs+OVnPNjRVE8yLbt8KDVrCFH6ydWWj6QzWa/1stI81aAPuOCnZgkmB5fVVUVdU56muLcDOhxW1r60E3TvIYQ8o4G3SlC13eDxo2a4fV6HSku2Kg2w0Pf96/O5/PHTJ14cz/9zQXY2n92op22bT/H9/2/hZOSEiE200FIQRDYkiR9Utf1T8OXLsvyhaqqfoBzDiKaV0SpRH3PsW9HoklAD4Lg+6qqropSuSadggsA6CGoR3mmALMPRTXnZ406n20cew3os31vloUc9qdaraJs8I8ScZlh6hmlFBv88aqq/rKXbocWB9SwHYhyTwG9PyRWEZ00DlqeaZq3y5K8yqybcPcInuc5uq7LlmVd8Mgjj5y/5557Ou2A8hznXpixUiqV7s7lcn0H9Hj+joyMnK9p2qlxJgj60AToMZD/oHGw+aSqqv/qpJ+x3EZHR587MDBwvmEYb2SMPR3gMPVAHIP6W3O5HNyoPbm6APTwnB6t+YM0TUNl0p5dk4DOKEu6k1oCumEYb2qkGv13o8jJo3Gkummax4BcZZoWbWyYh56Tz+fH5+43bweyeiaXKS/CBK3X6x9tTMyLmtO8wPduGMZD2Wz2WXhobGxsb0VR/k8URQsap6qqKLM6Z3DqRc+aAV3X9FWu504xufcS0Gu12sXZbLalDz3BwBfB+cQkD4LgT4899tghe+yxx9hspvfZZsRSAXSEeWNNpYDe2yj3uZjc57LemgEdB+darearqhoCOiLuOwH02eb5bG2NNfTx8fG7G77kvgJ6vObK5TJKZn+ZUlqILLqhFSIC9DiN65+NctXHNWKr7pytD7MclsN4B6Sn+r7/1YaWP10+eBjxTik9UNf1P7b7zZnk3yWgx/mW/7Zt+/kgY2u3LbPd15GGHr8s7kRExoJk/l1bfAj86CdmMpmv9/sEOlsne/F7tVpdJgjCXyIylnBe4H8cx4E51ajVascODw9fi9Q9ALksy4cLgvCIqqoguEgBfSIoboIOkPN/c87/jzF2WOKAFGrpCJyrVqtfKxaLJ4CcBhpMt+O3KAA92g3iOZDU0CfCF2iYE+/7/qOc8+Oz2WyqoXexXnrtQ+92zuG5dgDdNM0LHn300XnV0PsN6EnSIkmSfpPL5Z5pmuaUGh6xT9v3/Rsx3/P5fE9SuCKZY+8YFEXxes45ArCbr7A4mCAID3ie99K5fzskIIIlxo+j3BMWiNjq+GtUIEWKHhZ7HByZCB7/gqZpH+mVG6ArQI+lVK1WXyEIwh0RiUpzzvq/VVXdZT4Krcxl8bX7LCbr6aef/i7O+dVRup6Y9Jl5nvebgYGBVyCyfeedd37z4ODgda7rbqpWq+8cGhq6dTZts912zOW+djR0PwiuyPYoba2Fhh5omsYQk+D7/scFQbg38iHBTIb5EyA/3LKsDZZlIdgQi77rw9CiAPRowFoBekSkgUhcBAWmgN7jPPRuNPS5asPNgN7I/rk91tA1VRNcz3VUVZUrlcoFjz/++BYF6HHsi2EYq4MgOLQ5YBCHd/ANVKvVq2zb/vDw8HC118oe1jzGoFwug4sAbI5TLrgYZVlGMN1n1q1bd9Zuu+2G1NOOr3iezKChx5U8f8YYu5wQ8kPf9xHUl7xAqISYjP/Qdf134Q9znICtAD2Oy2iZhx63BgNhmuY3KKXHhO2gU/AcDf1vVVW/3OsB61jyPXwgotX7Kwq5RBGrYaejwIuNkiT9B6grx8bGdmwUpXlUEAQwn10xMDDwobkA0/Rd6Gz02wH0zk3urRm7wBTXAtB9TdMEwzRvzWYyrzVN8zMNLma4MqCFg5kvFCdA3ff9Pzz66KMH77rrrtVzzz2Xgq6006FsBnTbsny5k7S1Tj84w/3x+I+Pjx8uy3LoQ4+icLmu6cyyLeTKphp6D4llugH0Xgx5UkOfAuiKJniB5yiKssUBerzWTNMEvSxcsEhPS2rnoWvP9/0fB0FwTJQd1ZfYIrQFe8Zpp52GNOoDmscUwfFIP6xWq3utWLHivrmM+WyAzjn/RaOg1+vq9fqXfd9/f0TVPAmjEW7+U9O0/XrBSz8zoE/DFIfWRHzg6yml+WZAB6WnoiioXgbO4HmrnjaXgZl4dmaAhAl4l112Oc0PgvMFxkIayERUJWgTP5nNZj+L+vCEkG/m8/k3mqa5JpPJoE78gke79wfQp0o9Sf3aDOiiJPkZXQdn/h26rr8SZWglSfpOwPm+NKKgrdfrXNO0kIfY87yv6Lr+gVlN79MMWysNHcQyjuOEeeiGYax1HKdtprju51domtssKA4aOo7xuVwOZE1LEtDbPVIuNWKZ7sd6qsl9Og29XKlc8MQWpKEntHNUo0Qu9BRNFEDGOX/IcZxXDQ4Oru2noheb30dGRlZkMhn4ymHuDpXOaL8OMw0459fCVYq6HN2O90yAjk+6rvvz0dHRt3iex1esWHE/YwxW68krwkcso4s1TTuzG9N7cg1OZ3KHlm7b9gRTXLVaBWe7Aw7zXC53P/5mGMbr8N8JHt3JUwch5GpN05oi27sV2eJ6zrKsXV3XfUiSJM/3fWzSk2QRKJCh6zpoYxXXdY8SBOEbrus+ZVkWaqmDTW/WAiD97O1CA7okSaHJDZucrusHoa+QDeccaYFIbwxN70jlgaxc133Stu33DQ8P/6wbC8fiAfRwk587oLeLnm1YCtIo9/5Vd5xWQ99CTe4J7fwIzvnXCSEDMS7g0CpJEiyVkm3brykWi7/s5x4Xv/v6668XolRiMFCiPDZovAnop23bRtqhp+u6uH79+uduu+22yHnv6moH0HO53OGUUrtWq72qkcYILvdJ7oqmIMGXtBWsN8M+0Bagl8vl9YSQFZIkfVfXdfiR6fj4+CW6riMPfYogOAh6PP+gXC4Hc8cWd3HOC9VqdbWiKC9DTimYfxKHmg3j4+N7bbvttiOVSmV3RVEesG27ZNv2GcPDwwgODAMoFkoorQDdcZ2+EcvEGnqtVnMFQZDgv8pms+Dsvq1QKLwKIPfYY4+JQ0NDZ+dyuTMqlQoOjTK0c1EUA4EJMEX/Znx8/JDtt98+rPLTicWnHUAPguB9Ufnern317Yxn66C4AO4ans/nQw09DYrrbZQ7uNw9zxMFQeiY+rWdMZ3unukAHSlVMa/8YvGhg/q1VqvNics9jqI3TRNVz6YEo6GgDdL1KKXfrtVqHxoaGqr0UztPjkm85iqVyl2NSn4HxnnqcHXBnw8OB8/zPpfL5T7WTSEqvCTeY0ql0o2SJIXFWaIrdDd4nvdzlNWO31+pVL4my/Jx8J0joLqJRvh+VVVfRCk1u51/MaAna5DEhEahhl4qlXaRZflhfMBxnBOLxeJXoT1VKpU/KoqyXzOge543msvltmlv0HqgcnTb8y6fwySpVCof1DTtc7Ztx9Wcwrdxzsu+778zn8/fZBgGXA5/C4JgIAiCbxQKhRPxLKPUmzgCzX/fJ8aE8VqtugJ56EhbmxHQGXWmo8acaTOLyk5O+tCTgA4N3XXd21RVfdWTTz6pb7vttmalUnmWIAjX6rr+fNM0w4WGVJcoIh7z7rP5fP7UWU3vTY1KAX3zUZqWWGbC29n34iybEct4PmNC/4qzpIAe7kthHnqrKPe5AnpsdYzWMHKqt4sVnCi2yBVFUWpUsNwX5bW73Ha7eixuW7lcfp0kSdcxxrIRgVW4XUf/bNQ07TmU0VKne12ngI72rF+/Xi0UCn8XRTE0vcOCkTwANIrmnJfNZs+dYLTrHCOSgB4HMDQD+ltkWf5hBOgvKBaLqKaWN02zFEUxTomGa5wCflwsFhEY0ZeAh65GtscPjY+PPz+Tydxj23Y4WROvBw3UZzKZzJmVSmXI87zv5XP517qeCx77/+gUkHrc7DCdJi7O0hagz7F8arOGjtN6LpeDyf02XdehoatxnAUWnaqqcOGEpnekl8D0HuVow+fWdpnTyRUSWURQbS3mckeKGPxZ8KHXarW1862hR0FDk8QyqPxWKBRSDb1P1dYWG6BDLwKxzJaiocdZq3WfAAAgAElEQVQHxFKpdFqj+BIqqGmxXxjWSKxlz/MQ9f6efgbCTbdXxvU0fNe/16ibe4rilMI6UNVF3/dflc1mb+tmv51NQ4cPPZ/Phxp6vP9Wq9VXMsZ+LoqikgD08HwA/nnf918MF2037Wmloce005Zl7QNa1zMdxzkf0cf5fD4Hc4BpmjAL/DEqh5oEdG7b9n8PDAx8qW1A7/wQ0k0/e/JMYkCWaar2QN2qF0RRRA8mSBMYJb7n35LJZA4Ga1yj3vAnBgcGT3c9d+0ll1yy89lnnw3zPDTQBQkUXMyA/uijj6rDw8PnqIp6uh/4DrJL4OuC6T2TySCV7XZN0+IKfziZzCrDVhp6CugTvvytwYe+GE3uWyCgxyx0N0uSdHBTthPKSaPOx9sHBwev7ckm3OFL4j2gWq2eBUXLtm05YVUOrYG2bV9aKBQ+3o3ZvRNAjzT6MI6qVCp9nVJ6LPajZJcAvo7j/K1UKh2A+vQddneyOEvS5D4F0CuVyncIIQjwAjvcMwEKhmG8UxTF77TgmQZbz8sHBwfv6rQhS+n+0dHRPOhJKaUHJ/jdQwtHEAQP6rr+bJi5KpXKEblc7hrHcdY7jrMqn88/GJMvLER/FwugW5Z1m6ZpoYYOHvLYNGZZ1rMopZDr81AFDoUwoopJ4EHHYfHTxWLxjHYtHSmgd2Byn7h1/k3ufa6Hnmro/TO5x7EC5557bvChD33oHwMDA7ujkmHCn4hUU8+27T2KxeIjbSt5Pdwc429GDJ6/EUWxmDRz43dFVv53vDT+GuTFd/rp2QCdc/5z1PRIHhZi0/vAwMDfBUHYBQVlEKxnWVaY9YK6Dw1r5lnZbPbCTovJzKqhVyqVOwRBeAWlNEw1igD9U6IofiyuHpUQQuD7/rJcLjfWjgbVqfAWy/2PP/64tnLlys+g0hpjLA4qiwF93U033bQTIiwty3qVLMu/bMQebISpdXBw8HcLGem+WAE9OrmG7oBKpXKoIAiroUVGla3w95Aq0vf9xzzPQw7r7XEa1ExzIgX0RQzomezudauOQxu8KgFiKyo9JpZJNfSJ8e+XDz3ey0ql0n6SJP2PKIqIG8JJHBbL0NzeIE35VRAER+ZyuU0LAehR/8OUYcMwHmOMoYDWZNEj3/c9TdUFs24M5/P50U4xpktAD/e6Uqn0almWf0opVSRRIo47ESQXFfJBsa8XDA4O/r2TNs0K6MijJoQ8mxDyA13Xj8QgVqvVb8qy/O4WgD6WyWSGFmrgOun4lHs7NPvDb7Rx48b/Hh4e/qzjOKEfJllgxLbtA3AiXbdu3fNXrlx5j+M4I6ihPTAwsDpOp+i6rW0+2KpLSwHQYXpfuXLlOYqinO44Tmh6b0rt+KWqqjC9h0EtMx0cU0DvDNA5Dk2eVw+C4NhCofD92P/Y5pSb8bZZ89A1XahUt/wo98Vucg84p6wNd1YElGHWjmmab3Uc56uodS6KYlxNDLEwKPV6SS6XQ5BXx+bjXsy7qJ2hm6lULv1YkZU3xeVs8Zvv+66malLdqu+Ry+VQrrWjqxtAj9oUmt4bwdNX+L5/LA5BoL2O0+oa8QgA9r888cQTB3ZCfz0roBuGsYkQgqj1L2SzWdS0RTDRjyRJelMzoKN0aGRu3gIC4mZG+dHR0bcV8oVrPT/MgQgBHYDJGButVquv32abbRBj8AwU3bAsa9y27Y8ODAx8cyFT1xYzoCcnOUzvhBBEpYamdxD4JOI1YAW6MJfLnTWb6T0F9M4APTW5d7SXT3vzTGlrMaCXKpUL1i0CYpm5RLnHAXGWZaGi2jmSJOkIOPU8D/ugSylFqupxuq5f1RuLbYeaVzRCCdC9RBCEU2RZDmm7gV8TGromVqqVwwYHB8GH0dHVLaDH+93dd9+t7rrrrv+QZXknpNOhTYqiEATLwvQuMvFUJrJL25VfO4BeI4RkGtScF2YymU9EgH6bJEmvaOFD/5Ou6y9echp6R0M4cXO5XH490tOQupYEdLDkua77ZuThm6a5g+/7axljtcYJ7Nx8Pv/ZdkzF0zenuwkdv2+xA3o0ycPD4NjY2KGZTGY1fHAA9JjrPTLz/ct13ffk8/nfznRA6j2gdy//ePNLo9zHDpQk6apsNrt7vZ6a3OezfGqv09ZidjjTNC/mnJ8C8hhkPgGYkPuPgDjP8w7OZrO3dLHFTvtIp6sw3gfK5fJJoih+VhRFFdgVFUoJq+CBMS6Xy13dqc96joAe7nXIwpEkCdzzSO9L9pvDSskY2wfxV+3IcFZAr1arYPmBBnoOTCeRyf1/ZVl+YQtAj9ORtgANfWbxlUqlgwqFwq+QuoaJDA0dqVacc5TCOzKTydxsmub2vu8/EqViXZDP5y/qhvGsnYFs556lBOiIDWlUajq7kdb2McZYyPWOU7VpmsHQ0BCsRLdeeumlh5x9Nm5pbXrvJaB3uok0j0cK6HeIq1at8jbLQ0996PNWD71fgG4YxhcJISdFNb6hXcJ0bGuapjTW6QH5fP4P7exP/bonkY/+TlmWEV2ux9gFl0EE6B/KZrOXd0r8NRdAb7JKXmnb9nslSZqSNYYsKtd1f7dmzZpV++23H7BmxmtWQK9UKsdFdJx/ymazf4s09DslSTqwBaDfqev6y7cGDX18fPzlxWLx10lAR7+DIAC5zLsadYdXxxo6IaTWOPmB5/3zc9PQZxvOmX9fCoDeNMl355zfEATBXgg+hKaOaHdMelhGcrncBYIgnDud6X1isTF/dHSkZR56tVZby+eZKS7V0FMNHXnoi4XLfS4m93jdwQ9MCAFOhFzpAHRJkkJAL5VK+w4MDPx1ITEhBnTTNN8CxjpYnIFdsCYAwMFkZxjGGZlMBqbtkEau3WuugB5bJR988MHstttue68oijslvw0XBkDd9/3/zmazX2plem/F5T5t2loLTSPUjiRJOqgFoP9Z1/UXLeTgtTsQc72vUqm8IZfL/bTZ5B4EwXgQBG/J5XJ3mKa5o+/7/4aF3vf9j0UsewtG/7pUAD1pejcMAzXTEUEbRr1H/smwIlsjffLhRsGHdxQKhT+1Mr33UkOf63xJNfQeaugtzCXx3EYg35577bVakeWD0yj3iVnbxyj3OHocXOknxCACk3sM6JVK5SWFQgEFUhbsigG9Xq+/g3OOw0fI6w6LX6yhV6vVk/P5/JfnW0NP7nVPPfXUa3K5HLjeJ8nKIl8/r9frKLs7q+l9Vg29eRSQR33qqaf+BPVu8VuSi5YQ8kAjP/s5WwGg03K5fGQ+n7+mGdBd1x21bfvg4eHhv4yPj+9ULBYfq9Vq457npUFxEVNccx56q5UezyHOuVatVs/XNf0jjuvAPBmWWVVVNfA8j9m2vRpV7aIUGZTtnSScSfjODs7omZuRJgUiB2j5uq6nTHGieKUgCNs3qgTGjrulmYdO4e+aYEEEoO+1117wRy4AoE+cNNoJitsSmOISPvRPN1yNJwdBEAIRQEiSpNCH7rpu1yxsvToBxPuAYRjHU0o/TynVYgrYIAh81KmvGbXjCoXCN+fTh57sX7zfGYaBAMKjGUMQ/EThr8jXj9vvUFX1NTNZEToGdHy4XC5fpSjK0fHgJRpm6LoOvtwt2ocOs/n+++9/kqIolzUDuiAIm+r1+oGFQuEhy7LCAi2NogRjrut+YHBw8AdbXZR7JnNCzTCmFGdpB9CjuRWmdlSr1eeKongd53zPOL8VmzcmPefcbvC+n60oyiXNpvctD9Dn6sl/uupbkiku4DwI38w5Djt9TVurVCoHUko3C4rTNA31qY8q9LAeeqqh91dDj9Maa7Uaipuc5fs+gDJcl6iwhih3UL5qmgYz94JdCUA/v5E+dzraFbPFxVHu1Vr1LQMDAzd22shemNzjbwI3YXpfsWLFvbqu7xQxZU7+HBGXnaDrOuIAWjJldgXotVrtzAYbxHlg3EHeXOJCStHKbDa7qd0w+04FuBjuh9ZYqVQ+qygKCq6E9IFxHnq9Xn8SBW123nlna3R09DWDg4O31Gq1jZ7nvXVgYOA3cyOWmduGvhAm90wmc4LRJaAnzVEjIyOH5/P5HzHKPNux4bagoIUVRRFVi9ZUKpV3LFu2DL66SZfGlgfoc5/9yeIsjLErZVkONfTIfbYggC4IAlwobQD69PM/aXJfOA19EkDRUMxDL1kPHdXWFnseeifKWBwPVKvV3hEEwZcFQSiiemAjroUKghBn/5wry/JFKB8699nb3RviOV+r1b7PGPuvuOgT3pYA9OcPDAz8rdMvzAbolNKfq6o6hSluum/Esi+Xy4dQSuFmhEtjsjx3hDEmpXRPTdMea/UeAHoQBP8Ltqb49ynUr7VaDb5yfCCXy+WOj5jiQDBzDZLfm/zoMIO+AulEnQpmKd0/NjZWyGazNzDKXu16Lsy8k8LjnD+A6j2gNa3VakcjctI0zXX1ev3FQ0NDT6KfC3XYgSI2UW2t1l61tR4UZ9F1/QTTNEMNHYcfaGK2bU+hfp1p7ONJjspsy5cvP58xdoplWa7neWGKDMBAURSQHd2Yz+ffkjS9p4C+uWRnAnQcNoMg6LuGLoriVZqmTaatRWOI1KEJDT3gImUdByctApP71gXoMUkWrC6SJN2gKMpKwzBiQA8ZNBljq+v1+nvBwtbJYaGXeJBwDSD1C/TSkyCJ+rq6pot1qw6GU3CudHT1EtCTCsy6deu+OTg4+J7IfTOlTZzzW3Vdf10rf/+sgF6pVD4my/KF9Xqdj4yMFHfbbbfK6OjoSzRN+wOS35vD7B3HOb1YLH5moQZvsudzU2ZbDmrcp2q1Oqyp2n1+4G+DVLW4OEs0IDfpun4oKtI1ZHa27/unMMYey2QyO8cTq60ZM5f2T/NsJxp6wLnM5gjotm1fLAriCXWr3jWgRzINTe+2bT8XXO9BEOzpum4Y9Q5mKpj4CCF1zvmZuq5/Lja9twJ0aPQLXW2NEDKl2hrqodfr9UcZY8erqvrLfqY2JgGdUnqlqqrbQz3HPAZblWEYnq7rx+bz+W93NF+bJnXzFEzUg18lSdKViqI807Ks8LsYW1mSBcu2jspms9d00//pNHTXdcN66GFkebl8UbFY/ERMAtWvg/VmPnRFXVUzauC4ndTQt4Qo96if9KmnntIYY38dHh7eDTiBAYVsAZyU0hHDMF40MDDw2EJgQgyI9Xp9B0opyrcORntKyASG+aer+t9LldJLUau9rb05cVO8x1QqlRtFUZxSDz3q7+Ya+ix7e2x632677e4jhOyYULbDpkd4c0zDLI+8+Smm9xjQ4wDFSOkJFe+w2trY2NjrFEX5Gf5gmuaBy5cv/z3nXK9UKuMSVPSo0ljcR9/3f4KC7gsxeJ0ORrf3G4YB7uI/gzYwGZFICHE555fpun5auVwelCTpakVRDjNN8w+5XO6A2ZjNum1Pu891AuhxZGy7747vSwSz5QHojLETkNoHDR0WLqSIOI7Ttobe/F6kfTHGftQAbxyuoQGEZVajCXw/TGqKotwXaephFGu5XJ4MiltUgE4JcR2XLwSg12q1VwVBAEDfKQZ0RCdnMhlqWdaJmUzmq3MB9OZ5E4M0uPobmtzXBSasdFwniOdLNC5H6rqOOJOQqrOtuRdtjosa0FV1Va2WAHRNlyvVygWPd8QU1/0Jv19R7hifhx56SNltt91szvntKEAVB5tFYO4ITJAN0zikUCj8oq3x7OVNE8GSoQvO9/2TbNv+LKVUTVRbC8szW5Z1eaFQOKUbt0BXgD5LHxOm99cSQn4mJmu+RkYgQojR2Af3aja9zwroIyMj2ymK8kRUJP3EXC6HhQ4T512SJO0fCicx13zfH8lmsytQhaxfJ+Bejnmn78JmU6/XTxZF8TPwv0SbT/gaznm5QfX67kwm8z+GYayklP5JUZRtDdO4Jp/Lv7uX3Nidtjtpztnc5I4YgImDHtI6MpkMXCthWcTZvzN1o+k3oOMwaRjGBaIofrhRnjZ5oApPro3KTjcUi8W3YlzQ9qhU6OIEdJwA3XkH9HCDq1QqL+WcX5nRM8/yA9/H4QjzGeZHyujHBEG4uJcH0PhwALO6JEmXB0GA4NmQ0Rc+V/AMeJ73Nl3XcVhrH9CjCbqkAH3e6qFPRt2Ha7nXxDLRfhGmrm3cuPF8SZJO0zQNWSjhWmSMxfXGr6xWqx9etmxZbb4VvXjPrVQqqLT2stjcjnmH9iEUp16vHz4wMPDj2fe6KVAX75fxempfQ2/jQ7GcKpXKtymlR8WKc1Jb55zflMlkDkvibLlcfmGjCuj/xm7gzTR0fBt87r7vb0MI+XY+nw/t+q7rfsbzvI80t822bZiWXl8oFLqj++v+INqGmOZ+C+e8UK/X/0dgwssDHkDDgDk4Lkiw3jTN5wwODpYNw3g+pfQe3/dLnPPT8/n8FQsZ4T4zoBOYArsE9KkybQZ0SukJjuOEGjqARBIlwfXcjjX0qP2TUe/gepckaU/45eGrwyYCDukgCIxGyszHdV3/YlyeddFq6AsI6JifnucB0PeNAT0IAheBOJzzr+i6/gHM7dkK4LS7ouIDYr1eP7MRRHo+rAJRVS4uyzLjnCO188hsNvuLbsiXthRAb739zW1T7KeGHgf5btq0ab9MJvNTxhiUuRjQQ6u27/uB67rPLRQK4I3oLgOqCxHEpao3bdq0r6Iot6uqWoAVKtpL0EZY9mxd13eklHZcaS16T18APd6vCSGFWq12LyFke/wtAeihuwCV7AqFwg/iddgWoJdKJQQ8/CfnfKOu68vx8FNPPfVqTdNuFQQhtumH70SUIyHkqlwud1zXg9fuLrEA99m2/Rzf9/+B012sBcbNoJT+TlXV/0AUfBAE76OUXua67nrUiEca20LLYyFM7r0E9OShZHx8/HBoc0EQYIWGXO+R6ZiJongvY+ytSBnEM7Va7WBRFG+Oa3V25UPvYkNJTs8kscwC+9DDQxFoiV3XBaC/1g+gHHsiNHRFUUTTNG8qFovHUEo3zi0rY/KQmIz6/gal9FhYV5C3jDFBhLtt22sEQXhPI9inJUnQbEt9SwH02frZze/9BHS0JxGz8kfLsl6U8POGFrIgCGAtu1jTNFRds7rpQzfPJNw8P5Jl+fCwbKrvT5RpjCOEOf8WAne7bVc/TO4J5WqypLQkST9GzFDMcBdjre/7Y6g3v3z58qfwtxjQYx86ItynRLnjpvHx8aNVVUWlMOI4zguKxeI9mCRI0eKcDzULm1JaMgxjx2222QaUpy3z5boZoIV+BhN3l112Oa0xiMhnjDXDuFmYqOc16A4vgv9cFMVv6rr+xtHR0Xu32WabvbvxR84RQzYT15YE6DC927Z9QWMOTzG9J6qyXavr+tt7BuhznHyLCNAnNaRSqXRlNpM9xg/8MGsAByJBEJC6tk6SJKz5ngToxZveyMjIszOZzNWEkJcgngIHMdd1QzO/WTdvFkXx/bqur+3mELFVAXqHG0O/AT2e2yMjIydkMplPE0KyCVDHksRYwwoDLf6vSRftHJfVtI/HcwhZWqIoIgi1EGdkRQxxobmdc/5iHCK7bUc/AT2pwNTr9e8EQfBOaOVJLd11XZrP528477zz/uucc84J2gL0arW6TBTF9RBSo/73mcVi8VNYQJZlXYHayc3CQJCS4zgfKRQKly20VtrtQLV6DnJolI0Fnz3MSriSRPo4Ib1Y07R/m6a5neM4DzHGRFSW0jTthG78gt20faa1viUAejTJJ03vjLEbGGPPjQEiAejVRs4vTO9fRiCWLMur56ShdzMYiWcWC6BH8gv9nqVS6YxsJnsRNHTf98WoSpYnorKGbX8in89f2It5Gx9mK5XKsZIkgSZUiTd813WdTCYjG4ZxaT6f/2hyE+tE5FsVoHcimD5SvyY1SRzObrjhBn7ooYf+nRCC9Zi03MbKz69d1z0in8+PdIILHZ5fwmYBaO+//35h1113vYcQskccrBeB+UT+Lue3GYbx5uHhYewVXV39BvR4PTz22GOF7bff/l7HcULTe3xBYQbXO2PsCFEUf1gqlfZjjIFqN0ylbqmh44d6vf5nnLAIIX/XdX0f/K1arb6SMXZb0+CFdn7XdR/J5XK7bynBcRi4SqXyflmWsSHFpAlJ2f5S07TXQIvfYYcd3pbP57/DOR91HOe9qqqujnM2u5o1PXpoSwH05KZvmuZbGWOonR6WWY3SCMOod0rpfVbdeqkkSy8QRfFXSxLQu9nNZpkvidS1gxtpa1dyzreDdg4qXUEQfEVWBLNu/r4RDHusoihr5hL7EfsxEc9g2zZS0t6SWD/cdd2QVKZer7+rUCh8t9sDRAro0w96vzX0aD2GgYzIkGi4HC+Blt5gcMT5GmyOuCXcMymln1EU5ewGY1t98xb3ZrLHc2j9+vXXDgwMvC2Oao//jXZG7tKX6rp+11y21/kA9Lh9hmEcQghBzfYw5im2OAC0HccZFUVxD8/zdmgL0E3TRGT35z3Pw2YJQSB9DXzYf2WM7Z04McT/F/edrOv6lzo5jc1FuP18tlarLaeU/rmRuxufkELtXNM0UiqVEIh1Qjab/W6lUhmilF6fzWZfOT4+/uDg4OCzu92ket2fLRHQN2zYkCkWixdJkvRBFyHjnMeFDeJAxUtN0/xJoVD4rWGavhTloWeyWWbUamsR64AAzn6P0SLT0EMLR6lUGtAA6IQcHsUihJkBYPmCT73BAnmOoigomdx1QaFYOx8bGztBUZQvwmqVUADCNEbbtv/i+/4x2Wz2791+a94AvQ3MQVvaY4p74vw999xj3sqnjo2P313I5/fFHo7Dm+d57lyqrTXvT3FEuWEYd+m6HlbjdJynE2UApDBz+76PaPjLYCXqwx4XztVyufxlRVHej3FIpKmFOBiZ/7+naRrinMy5tGG+AD2e36Zp4tD7jtg63ETs9r0gCLDGfh+Dfssod3T40UcfLW6zzTbrwNfLGEO0+9GR2f3oIAiuagHo+NOm9evX7/bMZz6zspR96diUIrrbTzb7zmGm9DwvBG50eGx8bK+B4sDfDcMwfN//fKFQOCsJFm3sB3OZXzM+uyUB+oRWEDBKGQhn9ooIZ8DQNxn1Hk36hx3HuUfTtNc3MjMy0Bq6Coqb06iAmSoINRjk0S9kUFzcjRhoLcuCO+jyUJWi4RkV/xPn9YPd67iGRe7H3Rx4EsQ+LwTNbCaT2RtZMPFmg1QqSqncCKQ9W9O08yIg7IpJcd4AvY150D6gP37+nnvuOW+A3o+0taQ4Yr+14zgvNE1ztaqqKxIusLC0ahwk1zhQnJfNZkEJ27MguWi+cZRzdRznPcjfnqBKmaysNpEnScg4IWS/6ehT2xjiyVvmC9CjPtBSqVQQRfE+xth2SS090ebzG8kzIE8KTe7TAjp+rFQq3yGEHKUoirFhw4Yddtppp3FEdNdqtX9F6QrhoCUubBJX4iTUfy29f1BZrVb3IIQgchq87VPI60VRBFXmqaqqfgXaoizLZw0MDJxeq9UQcwAa3H920/d+9GZLA/R4kuOwWK1W3yYIwrURIUkY9R4v5KhgRPgvzE9oKNlsdsGqrS0SQJ+MdscaJYSAxCLpSgqB13Gch3VdP0aSpDs7SSeLXUylUmlnWZavliUZaZ7wesQpkuH7KaVrGkyK75Fluavo9sQBpSX166Jgimsmlpm3PPQJ6cyHyT0xDuHBtVKpfLxxuD5LlmU1tshEgA5Tcch7EATBTz3PO3FoaOiJTkC0+d54X1u/fv0zMpnMtzzPezksp7Ish7XZE1fMG3KYqqowXc/5mk9AjxtbqVQOEwQBhWTCqPemKz6Mh3+eDdAPlGX5rojeL6RRhDBN0zyGEPINvKAJ0DGZfNu23zQ4OIg6r0vuAm87AqoopS+L4gEmedvRGUmS/vmpT33qOYgwtCxrV8dx7ofWkc1mb6WUvrab6PZ+CWlLBnQcpvL5PE78H0R6N4Ym4TObKEHIWIjyKaBPzLBEtayjKKXfEARBSWpUmO9RkYcNlUrlw8PDw9e2E4Eeb3Ku677M87zLVVXdA77ySqXCsNFGBZ1Csz6l9COg623nvVPWRdOJN9XQp9815hPQowNECOqGYXybMfau+GAdAzrWJaxkWJOc8zFVVc99/PHHrwDjXKd7H+bNr3/9a3nPPfc8qVGs6ZOKouTjXPNcLkdQsSy6QqroRq2C0zOZzOfaZiKcpUHtAzpzYvKuTvuYvD+e55VK5buCIISm9xagPvnIjICOu0ql0q9lWX657/s1y7KeNTw8DE1Usizr7iAI9trsuBAEGLwnZVneT9f1DUvJ9A5aw+XLl58jCMIZcRR104HFqFarxy9fvvx7GzduzEqSdGGxWPygZVkjoigeIUnSrzveqOYy2rNPvlCLma/iLKB+7XUeeqsuJlJU9hIE4XpCCNwfoQYYRbVO1hRuR0Pvk3VkUZnco012wsY+YeH4vKIoJyMXHcFLsZwTAA9T5Q8aVqqzVFX9VyurUzwOqHXQMKWeQSmFjzKZwoTqVkRRlPDA1eB0QEnck6LCHaHFoNvpv7QAXZMrlWqH1K/dSmZ+NfTEvArHs16v39SwvrwOwBqnW8U1vjEXMPfAFOi67kOCIFzNGPuOruvrZuptPNaWZe3SKIb1X5xz1DnfYZq9Afjjy7Ii+L73JdBy98HMD+bFnjLFzdZ/RL0PDQ3d1ziIh6b36a5ZAX18fPxliqL8BoQylNIvyLL8YbwMpUJ1Xb8lIpaZtLvjhZIoEddz/zIyMvKy7bff3poJ1PuxmXa7FEZHR5EKcL0oikm/3+TrfN+/JZfLHRz1fw/4NmRZhqZ+88DAwBsWmuq1ud/NGrqqqqsw2WOfZrQYO6R+nfqV+BsoTjMF0EVBomRuTHEzTvKAU8ooN03zbZTSayPzMQAdh5jNAD2TyTDDMBY8KA6aSi6Xm7fiLC3mRLjx4pAniuIVhBAUFpoE9URAURxk6HPOUWbyds75w0EQlKHJc7Bb0nwAABCXSURBVM5znPNnSJIESlnkmYem1lD40RUdrnwBYbmE/M3zvPciL7nbQLhWmgvWXLJ8ampynwrouWwOzIBhUBxqUWSzWcQHXVguly/YYYcdUOCoOya3pokVxRGwc889lx9//PHXDwwMvEUUROBAeCfmAgAdU6F5jhFC/kEIgQsG1dE2MMYQuIZEjFwEYLtSSl/aYC7dOXatTU6zKTRnIbWyr2u6UK1VL4VFuRu+9lnANcEUJ7054XGOwlLaL5+62XdmAcNKpfJGzvmNyVKpze8A/ka07bBW7DPFIR4NBMjsb/I8DyH0lmVZzxseHn4QA1gul78uSdJxyTS2BKAjze3Hy5YtO7xXk6ZboG7nuVKp9BpBEG5GEFUS8BL70yZBEHC4eQDaeaFQ+IrjOO+SJGnj2NjYIdtuuy3Id+akdbTTzk7uSQI65/z7jYPZvAA6omkppSh36ouCKDiuc1sjXeRVMTVrJ32Y7t7EQSJbr9dhev9AVCwnrCkcmtwngnLCnaERhLWoAN2yrEcppX2vtjaNFhNuSrC4BUEAJje4l8KDXiy32NKRLD0Zb8RJk19TZagpLjgcHJD/6/v+Y/Cba5r2m16AebQvbeZDt23bcxxn4autLSIf+nwBeuIQF84tWIBEUTwpWcyqOZ2sk33g6X14etTDdxs0w4JhGB8dHBz8Qq/M7E0Hyb5Rv85ykAjne7VaRY33t89kdoeLC7+3BHR8BNy4siz/WZIkZtv2XcViEaT3OJHkGlG8IBZ4RrIxSF1AgIKu6wisu64RKHZkrziiO5kE7d6LwhWCINzCGINPEcmUk49GEwk5lGdEfOEoVPP6XC63GnW/GyQn12ua9s62o4Ln0STRDOiyLK9ClFK/NHTXdS/mnJ8wH4AeHzajMqt7+b4/aXrHom4GdFVVmWma/dHQW4zpdGlrvu9zWAts254fQJ9mvsWHz3q9vhMh5GuEEFieQr9jrElNKNZP57+2A+gA+Oi+cJ4pinJ/rVZ7b6FQmFMQXAtLw6IEdMuybsfBOa62hsh+FDCpVDqtttbu7rX5fUkfeiaT2Re0p9DQwd0PDb1cLl9YrVZ7qqE/vWE+XfHM87y3eJ6HGgvbxvMoeUCM/9Z8KGzV8+ZYraZ7Yj19bePw+J5cLndH99Kb+cn2fejtFLrqrJXYz6vV6iD4NhprNiY72+wlWLdYw67rbq6hx6fher2O0pinVatVrmnaKdls9jL8BjCklN4RBAHL6BnquE54So9P+AhYkCTpJw3CirdBg1psPnWYMQRBuA4aZcQmNEVAUYWo67LZbEgrCk5smIdEUVzped6/gyB4SSaTCXl1p+vbPGJ4c9snfejQ0AHoiDiNS41Gbb5C07QOqq1NnT/NJncAOni7EWcB0pJ+aegJjSA+uU5GvUf9S1qbUH+b1a16fwC9xbpsBeiRL5Hrug4GxvkB9Bn2jMTYabZtgyXuZByEkN4PP6eiKOHGkNQGmjWD5s0Y2oFpmr6macg3v85xnFOGh4dBGd1T61XSh/6sZz1rNVxh0NAjAhEkQ6MK2EWaps1rPXTP9W4nhKyyncl0vbA2e6lUumDdunXzmraGOCfG2PwCejTf4pREQkjRtu1PEUKOBZd/xE4Y3oWIdIDPxBxqsp3PgnUJgEccBv65zDCM8+bCAtcOvC4koMftq1arSIW9IU5VizA6/BlyiU3u0wJ69AC4tP8qy/KzKpVKzXXdFwwPD4cpWtVq9RhZlr8hSRJ3HGdqHtvT2u6fG7z+/wnu5nYE1+97MDD1ev0E3/e/BOBJaq3Jb7uu+7exsbH9d955Zwum9lwu93XG2JEonep53knZbPZ7vTIj9rrPzRq6JEmoXzwF0JHD2Qh07Amg12q1UEMXRXHeAR1jgzxXQRA+0KJufYD627ZtLzigY+dSZIW5nrvggJ44FMUpbQcSQj7ted4BiJkBqEeRyZNTcxZABwsc5PwAKg42tMPV0YM9P9P2B9C7a2YyDx2A7npueHBmjOFQ4xQKBbnhCrjgoYcemhbQu/ty6x0j1tA3btx4d6FQ2BeABw0dGKqqqmQYRs996NPtXYmAtmc1SpEj2PjtnuepOCjOrJnPDPCR8mRTSr/FOb+oJa70UqhPH1QWxOTeLF+Y3iHLxBqeBPQY4D3Pa62hxw+Zpnmg7/u/1VSN2o695sknn3zJbrvtVonqpV8ERiBVVaeMRBNrz8YgCN6Nkon98au3N4KIymWMXS4Iwn/Cv5o86TQJ7hFN0w6ilP4boF2tVt8ty/JVoB31PO+HKAbStqm912idfN/0ZtVQe0Uqnqqqx4ADPaopjsUdHrwcx7mzUChc00nOcfLT8Tg+/vjj2rJly94siuJrXdc1okNOIDIx53jO3bquf74XKX2tuhprf+VyeVfG2IdEUZzkDo/XoSAIsud5T/m+f00ul7u/1xpj8/DG70fZUsYYGKzCtB1ciqLIqMrHGPueoij/6Hdb2p168Vi6rnug67of9DwPZvhCssJiC0CP1zvcUncJgvDFhx9++NZ+E6jEbUX++2GHHXZSvV5/kaqq1Qi4EOQ3wDm/Pp/P/6Rfh4qEXOF/xFpD2dBTXNeFVlxF4ZswSEvX85s2bbp+zZo1P1+1atVEPc8+XvFaLpVKn9A0bXfOuRmVrsUhIxsEwY26rv+sH8xtswF7pVJBWW7sE9g794+CKTuRhkEIATPatbZj/2hwYBBBmvN2JTI73i+K4vOjfTQs6BbRT9+rKMpX++G/T3YSckRZ4hC7OD7OJzb0hIbemH/nbRYU17x5VyqVcxog+Mkw+E2SVqPCGO7BJDrggAOu9n3/nTPZT+BDlGX5GhRzyWazI52a4NuD7NbjC57p00477U0wzzRKvu4giii+M8E93LxRcc6fCILgtblcDhGYKFP3WkrpL2BSbORa/qvBjLTvwMAASP6xkreYCnPztjLm40MdTJYObp2Pli/oN5KHtEKhgOIP+zcyCZAauDwIgoGocVWUVxYE4Z9Icbdt5/eDgwPl/hzUF1Qc6cf7JIE77rhDffGLX7xfI3Ib1SkRyQ53ZoEQko+yVqAYlBhjj3POH6GU/p+qaXcz2nv/dJ+6uOCvnRHQ0bqoAhvK070JKWtBEFyYyWTOjH4TTNNEgM2xEcht9r6EqWUUJwxN05A6M2NqWy+kAk2pkSP7Wc75K+P0mmSIf1ydB9+CJsc5P7RQKMBNgPrazwuC4E5CSE4QhDFK6WG6rv9usWhWvZBP+o5UAqkEUgm0JYH09NuWmBbDTbMCegTcecuyfh8EwR4wWTfyWM8Ea1cM6rVa7XMwfTbnpUa/N/dzQ6PW9aeDIPguyuz1UggAXMuykKp1KmMMVJeT7oA4cC8iO5gMzmgQ4T/kuu5h+Xz+gUgz3xU5uBGRQVUURXBdX7cYqqn1Ulbpu1IJTCeBdP9O50YqgaUpgbYAHV0rlUq7MMZ+SwhZGUUZop7yxRFogx72+IYfC7mAYMufQjbRLJrI3G03yrWCLvZ7vu/fMTAwUOpYhDR0VFLX9fYG4UgQBEcIggC/KmeMTelbHCUZR/GiDb7v/8nzvEOXL1++CRaG9evX75HJZH5GCEFqj9Uo1XlusVhE4FfX1ag67lP6wAwS6DHU9Ph16dDNXQKLYUgWQxvmLsn0DVujBNoGdAinUqkg4OI38K0xxhDxc04ul4OjPrzK5fJLGqVWbxQEATlz4bubguTC+2L/deI3BI78JQiCuxhjawgha1zXBaF/eWhoqBK9R/7nP/+ZX7Zs2XaCIIBBCCQZCLI4UBAEBL1NUCBF/vHpCDDANW2apjc2Nvb1crl8yh577BGm1o2MjLxoYGDgZ4ZhIIgDZQC/ksvlTl4yYJ7uQlvj+k373BcJpIupL2JNX9p3CXQE6GhNtVpFCUsk8i8HXsuy/JMHH3zwqH322QfRiPh9mSAIl9m2/XYEoTVrytNo69N2NCa7iG+Ahp0Mq49z8JooBiff10xQ4Pv+esuy3jc8PHxTHNBTLpdfLEnS7b7v65qqOa7nXqJp2ieXDJj3fZosxQ8stk15sbVnKY5p2uZUAqkEZpJAx4CeAHUA4jOhEbuue3cmk3mTruuTZfJc1z2oXq9/DSbwuQxBi+puHb0u8Ty07m+WSqUzV6xYEfru42j1Rm72tg061z8ODQ0NBUHwcZDopGDekZh7cHMKeD0QYvqKVAKpBLZiCXQF6JBXqVQaUBTle5ZlHZLJZBApPo5SiZqmXZ1gpNINwziRUvrRSKPfTNSzUPzNOjStTPrJhwDalNJbkDOfzWbvbZVmg7+Zpvk83/dfkM/nr0yj2WcV+ww3pMA8F+kttWfT0V5qI7ZE25tOtLYGrmtAx9tBHFKtVi+WZfkU0EY2ctZRC/mnpmm+H/SPcQsaUe0A9hMopScTQpB7OHFxQujU2LW2Gp28KU6Liw8GCYB3KaPX8YB/Lqr4FLnYuWqa5qt93/9DFGWfTpWOpb40HkgHdmmM05bSynS+bSkjuXT7MSdAj7sdcc1eHgTBchRp4ZyPNwpeXfLII498ee+99zZj0zbM2IZhHEQIOZpSCoIaNVl+cVoxTrNSwBMMAIcfHQQwEQ/7Pb7v/wBlUXVdB0HBZLlAwzBe6Ps+ige8WJblr2madmJqWl+6kzdteSqBVAKpBFIJPC2BngA6XgcTvCRJn6WUvtdxnDAYznXdjYqiXJzJZC4H62iSYY1znjFNE1XcXtWgkMQ/e0zHrz7TgPm+/ySi40VRvLPBSX1roVB4qNmsDqKYBuif4/s+6suGbHGSJD1Uq9X2HR4eRi3elP1tK1wVqUa1dAe9p2PX05ctXZmmLV/6EugZoMeisCzr9ZzzS0BCI0kSMQyDaJoGJrarbdu+slgsPtJKbA3CfcUwjN0ZY8+JCtsPUErBz1yMABfpa14QBBsZY/8mhPyLc/6viKR/syUZuQMOkSQJhUhQ2x0XtHWHc/7VtWvXnrX77rvXUhrXpT+J0x6kEtgaJJCeO5b4KM/DAPYc0CHyiC72yIZJ/BxCyC4om4cLVc4YY0h5Q/nSW3tdiQ2ad71eh1n9aM75mwVBWI5CEw2CGGpZliOK4reDILi4WCziMDBpiu94mszDwHTcpj49sBV1tU8STF+bSiCVQFsSSDebtsQ00019AfT4gyjrZ1nW213XfR/n/ACUW03UzUU6+T8opTejjq8kSfdls9kH2q1ag/esXbu26HlesMsuu4QVeFABLJ/Pf1UUxXfj7yihGQRBSVEUpKt9ddmyZQ/PCcjnLO70BakEUgmkEkglsPVIYH5PKX0F9OSgVavVPRhjJzRA/K2EkOHI/h0WaMcF9rhGDrjDGHuYUrqRcz5KCEFBl1KjIIxMKdUJIVIjqG2wkU++oyiKuzqOgzq7nxwcHAQ9a/iier3+X5RS1I69pUGCc10QBNcvX758MjBv65lIaU9TCaQSSCWwdUpgfmG0lYwXpgXzBugJrZ0ahrE3pfQNCIjzff+lbOIKA96RhjbbFfGwE9Ri55xfq2nakXG0esN/r61bt25o++23B8nNwkh1tg6kv6cSSCWQSiCVwFYlgafBqH+wNO+A3jyCyFE3TXMPx3H2lCRpz6gO8yDnHJr4UKPgC4LjUCcXjviaKIp1z/PWIijOdd1/EULuKRaLv5rRlN4/+W1VEzLtbCqBVAKpBFIJLF4J/D/xclRhztyp5QAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", CI = ({
  walletConnected: r,
  walletAddress: e,
  wagmiConfig: i,
  walletHooks: n,
  onClose: s,
  isOpen: a,
  onCreatePlayer: o
}) => {
  r && (e || r.account && r.account.address);
  const l = () => {
    o && o();
  };
  return /* @__PURE__ */ ie.jsxs(
    "div",
    {
      style: {
        backgroundColor: "#101020",
        color: "#fff",
        padding: "20px",
        textAlign: "center",
        border: "4px solid #0078D4",
        borderRadius: "5px",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ ie.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "0",
              left: "0",
              width: "100%",
              height: "4px",
              backgroundColor: "#0078D4"
            }
          }
        ),
        /* @__PURE__ */ ie.jsx(
          "div",
          {
            style: {
              position: "absolute",
              bottom: "0",
              left: "0",
              width: "100%",
              height: "4px",
              backgroundColor: "#0078D4"
            }
          }
        ),
        /* @__PURE__ */ ie.jsx(
          "img",
          {
            src: f2,
            alt: "Intuition Logo",
            style: { width: "200px", marginBottom: "10px", marginTop: "20px" }
          }
        ),
        /* @__PURE__ */ ie.jsx(
          "h2",
          {
            style: {
              fontSize: "1.2em",
              margin: "0 0 20px 0",
              color: "#FFD32A"
              // Couleur orange pour le texte BOSS FIGHTERS
            },
            children: "BOSS FIGHTERS COMMUNITY PLAYER MAP"
          }
        ),
        /* @__PURE__ */ ie.jsxs("div", { style: { maxWidth: "80%", margin: "0 auto" }, children: [
          /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "At first, there was nothing. And then, suddenly, the whole community appeared !" }),
          /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Everything of which the Boss Fighters community would one day be composed, would be born in an instant." }),
          /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "A single species of condensed matter, exploding in a vast universe." }),
          /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Although energy would neither be created nor destroyed, the interaction between these newly-created atoms would continue to create something beautiful..." }),
          /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "What had been separate would become whole again. And what would be created in the process would be even more beautiful than what came before..." }),
          /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Our story begins with the atom. The cornerstone of our ecosystem." }),
          /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: 'And our "atoms" start with you !' }),
          /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.9em", lineHeight: "1.5" }, children: "Every contribution will help build our ecosystem and make it healthy..." })
        ] }),
        /* @__PURE__ */ ie.jsxs(
          "div",
          {
            style: {
              border: "1px solid #FFD32A",
              borderRadius: "10px",
              padding: "15px",
              margin: "20px 0",
              display: "inline-block",
              backgroundColor: "rgba(0, 0, 0, 0.3)",
              width: "80%",
              maxWidth: "700px"
            },
            children: [
              /* @__PURE__ */ ie.jsx(
                "p",
                {
                  style: { fontSize: "0.9em", margin: "0 0 10px 0", textAlign: "left" },
                  children: 'Claims in Intuition, also referred to as "Triples" structured in Semantic Triple format :'
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "p",
                {
                  style: { fontSize: "0.9em", margin: "0 0 10px 0", textAlign: "left" },
                  children: "[Subject] ⇒ [Predicate] ⇒ [Object] (For example, a triple could be : [SciFi] [is] [strong Boss])"
                }
              ),
              /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.9em", margin: "0", textAlign: "left" }, children: "This keeps our attestations tidy !" })
            ]
          }
        ),
        /* @__PURE__ */ ie.jsx(
          "button",
          {
            onClick: l,
            style: {
              marginTop: "20px",
              marginBottom: "20px",
              padding: "10px 20px",
              backgroundColor: "#FFD32A",
              color: "#000",
              border: "none",
              cursor: "pointer",
              borderRadius: "5px",
              fontSize: "1em",
              fontWeight: "bold"
            },
            children: "CREATE YOUR PLAYER"
          }
        )
      ]
    }
  );
};
function RI(r, e) {
  const i = r.exec(e);
  return i == null ? void 0 : i.groups;
}
const fS = /^tuple(?<array>(\[(\d*)\])*)$/;
function Pv(r) {
  let e = r.type;
  if (fS.test(r.type) && "components" in r) {
    e = "(";
    const i = r.components.length;
    for (let s = 0; s < i; s++) {
      const a = r.components[s];
      e += Pv(a), s < i - 1 && (e += ", ");
    }
    const n = RI(fS, r.type);
    return e += `)${(n == null ? void 0 : n.array) ?? ""}`, Pv({
      ...r,
      type: e
    });
  }
  return "indexed" in r && r.indexed && (e = `${e} indexed`), r.name ? `${e} ${r.name}` : e;
}
function Qc(r) {
  let e = "";
  const i = r.length;
  for (let n = 0; n < i; n++) {
    const s = r[n];
    e += Pv(s), n !== i - 1 && (e += ", ");
  }
  return e;
}
function NI(r) {
  var e;
  return r.type === "function" ? `function ${r.name}(${Qc(r.inputs)})${r.stateMutability && r.stateMutability !== "nonpayable" ? ` ${r.stateMutability}` : ""}${(e = r.outputs) != null && e.length ? ` returns (${Qc(r.outputs)})` : ""}` : r.type === "event" ? `event ${r.name}(${Qc(r.inputs)})` : r.type === "error" ? `error ${r.name}(${Qc(r.inputs)})` : r.type === "constructor" ? `constructor(${Qc(r.inputs)})${r.stateMutability === "payable" ? " payable" : ""}` : r.type === "fallback" ? `fallback() external${r.stateMutability === "payable" ? " payable" : ""}` : "receive() external payable";
}
function s_(r, { strict: e = !0 } = {}) {
  return !r || typeof r != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(r) : r.startsWith("0x");
}
function mS(r) {
  return s_(r, { strict: !1 }) ? Math.ceil((r.length - 2) / 2) : r.length;
}
const m2 = "2.37.5";
let Zc = {
  getDocsUrl: ({ docsBaseUrl: r, docsPath: e = "", docsSlug: i }) => e ? `${r ?? "https://viem.sh"}${e}${i ? `#${i}` : ""}` : void 0,
  version: `viem@${m2}`
};
class Mn extends Error {
  constructor(e, i = {}) {
    var l;
    const n = (() => {
      var u;
      return i.cause instanceof Mn ? i.cause.details : (u = i.cause) != null && u.message ? i.cause.message : i.details;
    })(), s = i.cause instanceof Mn && i.cause.docsPath || i.docsPath, a = (l = Zc.getDocsUrl) == null ? void 0 : l.call(Zc, { ...i, docsPath: s }), o = [
      e || "An error occurred.",
      "",
      ...i.metaMessages ? [...i.metaMessages, ""] : [],
      ...a ? [`Docs: ${a}`] : [],
      ...n ? [`Details: ${n}`] : [],
      ...Zc.version ? [`Version: ${Zc.version}`] : []
    ].join(`
`);
    super(o, i.cause ? { cause: i.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = n, this.docsPath = s, this.metaMessages = i.metaMessages, this.name = i.name ?? this.name, this.shortMessage = e, this.version = m2;
  }
  walk(e) {
    return g2(this, e);
  }
}
function g2(r, e) {
  return e != null && e(r) ? r : r && typeof r == "object" && "cause" in r && r.cause !== void 0 ? g2(r.cause, e) : e ? null : r;
}
class PI extends Mn {
  constructor({ expectedLength: e, givenLength: i }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${i}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class OI extends Mn {
  constructor({ expectedSize: e, givenSize: i }) {
    super(`Expected bytes${e}, got bytes${i}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class II extends Mn {
  constructor(e) {
    super(`Type "${e}" is not supported for packed encoding.`, {
      name: "UnsupportedPackedAbiType"
    });
  }
}
class y2 extends Mn {
  constructor({ size: e, targetSize: i, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${i}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
function ca(r, { dir: e, size: i = 32 } = {}) {
  return typeof r == "string" ? DI(r, { dir: e, size: i }) : kI(r, { dir: e, size: i });
}
function DI(r, { dir: e, size: i = 32 } = {}) {
  if (i === null)
    return r;
  const n = r.replace("0x", "");
  if (n.length > i * 2)
    throw new y2({
      size: Math.ceil(n.length / 2),
      targetSize: i,
      type: "hex"
    });
  return `0x${n[e === "right" ? "padEnd" : "padStart"](i * 2, "0")}`;
}
function kI(r, { dir: e, size: i = 32 } = {}) {
  if (i === null)
    return r;
  if (r.length > i)
    throw new y2({
      size: r.length,
      targetSize: i,
      type: "bytes"
    });
  const n = new Uint8Array(i);
  for (let s = 0; s < i; s++) {
    const a = e === "right";
    n[a ? s : i - s - 1] = r[a ? s : r.length - s - 1];
  }
  return n;
}
class LI extends Mn {
  constructor({ max: e, min: i, signed: n, size: s, value: a }) {
    super(`Number "${a}" is not in safe ${s ? `${s * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${i} to ${e})` : `(above ${i})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class UI extends Mn {
  constructor({ givenSize: e, maxSize: i }) {
    super(`Size cannot exceed ${i} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function Ud(r, { size: e }) {
  if (mS(r) > e)
    throw new UI({
      givenSize: mS(r),
      maxSize: e
    });
}
const FI = /* @__PURE__ */ Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function v2(r, e = {}) {
  return typeof r == "number" || typeof r == "bigint" ? a_(r, e) : typeof r == "string" ? _2(r, e) : typeof r == "boolean" ? b2(r, e) : x2(r, e);
}
function b2(r, e = {}) {
  const i = `0x${Number(r)}`;
  return typeof e.size == "number" ? (Ud(i, { size: e.size }), ca(i, { size: e.size })) : i;
}
function x2(r, e = {}) {
  let i = "";
  for (let s = 0; s < r.length; s++)
    i += FI[r[s]];
  const n = `0x${i}`;
  return typeof e.size == "number" ? (Ud(n, { size: e.size }), ca(n, { dir: "right", size: e.size })) : n;
}
function a_(r, e = {}) {
  const { signed: i, size: n } = e, s = BigInt(r);
  let a;
  n ? i ? a = (1n << BigInt(n) * 8n - 1n) - 1n : a = 2n ** (BigInt(n) * 8n) - 1n : typeof r == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof a == "bigint" && i ? -a - 1n : 0;
  if (a && s > a || s < o) {
    const u = typeof r == "bigint" ? "n" : "";
    throw new LI({
      max: a ? `${a}${u}` : void 0,
      min: `${o}${u}`,
      signed: i,
      size: n,
      value: `${r}${u}`
    });
  }
  const l = `0x${(i && s < 0 ? (1n << BigInt(n * 8)) + BigInt(s) : s).toString(16)}`;
  return n ? ca(l, { size: n }) : l;
}
const BI = /* @__PURE__ */ new TextEncoder();
function _2(r, e = {}) {
  const i = BI.encode(r);
  return x2(i, e);
}
const zI = /* @__PURE__ */ new TextEncoder();
function T2(r, e = {}) {
  return typeof r == "number" || typeof r == "bigint" ? VI(r, e) : typeof r == "boolean" ? jI(r, e) : s_(r) ? S2(r, e) : w2(r, e);
}
function jI(r, e = {}) {
  const i = new Uint8Array(1);
  return i[0] = Number(r), typeof e.size == "number" ? (Ud(i, { size: e.size }), ca(i, { size: e.size })) : i;
}
const Rs = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function gS(r) {
  if (r >= Rs.zero && r <= Rs.nine)
    return r - Rs.zero;
  if (r >= Rs.A && r <= Rs.F)
    return r - (Rs.A - 10);
  if (r >= Rs.a && r <= Rs.f)
    return r - (Rs.a - 10);
}
function S2(r, e = {}) {
  let i = r;
  e.size && (Ud(i, { size: e.size }), i = ca(i, { dir: "right", size: e.size }));
  let n = i.slice(2);
  n.length % 2 && (n = `0${n}`);
  const s = n.length / 2, a = new Uint8Array(s);
  for (let o = 0, l = 0; o < s; o++) {
    const u = gS(n.charCodeAt(l++)), c = gS(n.charCodeAt(l++));
    if (u === void 0 || c === void 0)
      throw new Mn(`Invalid byte sequence ("${n[l - 2]}${n[l - 1]}" in "${n}").`);
    a[o] = u * 16 + c;
  }
  return a;
}
function VI(r, e) {
  const i = a_(r, e);
  return S2(i);
}
function w2(r, e = {}) {
  const i = zI.encode(r);
  return typeof e.size == "number" ? (Ud(i, { size: e.size }), ca(i, { dir: "right", size: e.size })) : i;
}
const op = /* @__PURE__ */ BigInt(2 ** 32 - 1), yS = /* @__PURE__ */ BigInt(32);
function GI(r, e = !1) {
  return e ? { h: Number(r & op), l: Number(r >> yS & op) } : { h: Number(r >> yS & op) | 0, l: Number(r & op) | 0 };
}
function HI(r, e = !1) {
  const i = r.length;
  let n = new Uint32Array(i), s = new Uint32Array(i);
  for (let a = 0; a < i; a++) {
    const { h: o, l } = GI(r[a], e);
    [n[a], s[a]] = [o, l];
  }
  return [n, s];
}
const WI = (r, e, i) => r << i | e >>> 32 - i, qI = (r, e, i) => e << i | r >>> 32 - i, XI = (r, e, i) => e << i - 32 | r >>> 64 - i, YI = (r, e, i) => r << i - 32 | e >>> 64 - i;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function $I(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function vS(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error("positive integer expected, got " + r);
}
function mm(r, ...e) {
  if (!$I(r))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function bS(r, e = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function KI(r, e) {
  mm(r);
  const i = e.outputLen;
  if (r.length < i)
    throw new Error("digestInto() expects output buffer of length at least " + i);
}
function QI(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function E2(...r) {
  for (let e = 0; e < r.length; e++)
    r[e].fill(0);
}
const ZI = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function JI(r) {
  return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255;
}
function eD(r) {
  for (let e = 0; e < r.length; e++)
    r[e] = JI(r[e]);
  return r;
}
const xS = ZI ? (r) => r : eD;
function tD(r) {
  if (typeof r != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function M2(r) {
  return typeof r == "string" && (r = tD(r)), mm(r), r;
}
class iD {
}
function rD(r) {
  const e = (n) => r().update(M2(n)).digest(), i = r();
  return e.outputLen = i.outputLen, e.blockLen = i.blockLen, e.create = () => r(), e;
}
const nD = BigInt(0), Jc = BigInt(1), sD = BigInt(2), aD = BigInt(7), oD = BigInt(256), lD = BigInt(113), A2 = [], C2 = [], R2 = [];
for (let r = 0, e = Jc, i = 1, n = 0; r < 24; r++) {
  [i, n] = [n, (2 * i + 3 * n) % 5], A2.push(2 * (5 * n + i)), C2.push((r + 1) * (r + 2) / 2 % 64);
  let s = nD;
  for (let a = 0; a < 7; a++)
    e = (e << Jc ^ (e >> aD) * lD) % oD, e & sD && (s ^= Jc << (Jc << /* @__PURE__ */ BigInt(a)) - Jc);
  R2.push(s);
}
const N2 = HI(R2, !0), uD = N2[0], cD = N2[1], _S = (r, e, i) => i > 32 ? XI(r, e, i) : WI(r, e, i), TS = (r, e, i) => i > 32 ? YI(r, e, i) : qI(r, e, i);
function hD(r, e = 24) {
  const i = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      i[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const l = (o + 8) % 10, u = (o + 2) % 10, c = i[u], h = i[u + 1], d = _S(c, h, 1) ^ i[l], p = TS(c, h, 1) ^ i[l + 1];
      for (let f = 0; f < 50; f += 10)
        r[o + f] ^= d, r[o + f + 1] ^= p;
    }
    let s = r[2], a = r[3];
    for (let o = 0; o < 24; o++) {
      const l = C2[o], u = _S(s, a, l), c = TS(s, a, l), h = A2[o];
      s = r[h], a = r[h + 1], r[h] = u, r[h + 1] = c;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let l = 0; l < 10; l++)
        i[l] = r[o + l];
      for (let l = 0; l < 10; l++)
        r[o + l] ^= ~i[(l + 2) % 10] & i[(l + 4) % 10];
    }
    r[0] ^= uD[n], r[1] ^= cD[n];
  }
  E2(i);
}
class o_ extends iD {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, i, n, s = !1, a = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = i, this.outputLen = n, this.enableXOF = s, this.rounds = a, vS(n), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = QI(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    xS(this.state32), hD(this.state32, this.rounds), xS(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    bS(this), e = M2(e), mm(e);
    const { blockLen: i, state: n } = this, s = e.length;
    for (let a = 0; a < s; ) {
      const o = Math.min(i - this.pos, s - a);
      for (let l = 0; l < o; l++)
        n[this.pos++] ^= e[a++];
      this.pos === i && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: i, pos: n, blockLen: s } = this;
    e[n] ^= i, i & 128 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    bS(this, !1), mm(e), this.finish();
    const i = this.state, { blockLen: n } = this;
    for (let s = 0, a = e.length; s < a; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, a - s);
      e.set(i.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return vS(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (KI(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, E2(this.state);
  }
  _cloneInto(e) {
    const { blockLen: i, suffix: n, outputLen: s, rounds: a, enableXOF: o } = this;
    return e || (e = new o_(i, n, s, o, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = n, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const dD = (r, e, i) => rD(() => new o_(e, r, i)), pD = dD(1, 136, 256 / 8);
function l_(r, e) {
  const i = e || "hex", n = pD(s_(r, { strict: !1 }) ? T2(r) : r);
  return i === "bytes" ? n : v2(n);
}
const fD = (r) => l_(T2(r));
function mD(r) {
  return fD(r);
}
function gD(r) {
  let e = !0, i = "", n = 0, s = "", a = !1;
  for (let o = 0; o < r.length; o++) {
    const l = r[o];
    if (["(", ")", ","].includes(l) && (e = !0), l === "(" && n++, l === ")" && n--, !!e) {
      if (n === 0) {
        if (l === " " && ["event", "function", ""].includes(s))
          s = "";
        else if (s += l, l === ")") {
          a = !0;
          break;
        }
        continue;
      }
      if (l === " ") {
        r[o - 1] !== "," && i !== "," && i !== ",(" && (i = "", e = !1);
        continue;
      }
      s += l, i += l;
    }
  }
  if (!a)
    throw new Mn("Unable to normalize signature.");
  return s;
}
const yD = (r) => {
  const e = typeof r == "string" ? r : NI(r);
  return gD(e);
};
function vD(r) {
  return mD(yD(r));
}
const bD = vD;
class xD extends Mn {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class P2 extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const i = super.get(e);
    return super.has(e) && i !== void 0 && (this.delete(e), super.set(e, i)), i;
  }
  set(e, i) {
    if (super.set(e, i), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
const ey = /* @__PURE__ */ new P2(8192);
function _D(r, e) {
  if (ey.has(`${r}.${e}`))
    return ey.get(`${r}.${e}`);
  const i = r.substring(2).toLowerCase(), n = l_(w2(i), "bytes"), s = i.split("");
  for (let o = 0; o < 40; o += 2)
    n[o >> 1] >> 4 >= 8 && s[o] && (s[o] = s[o].toUpperCase()), (n[o >> 1] & 15) >= 8 && s[o + 1] && (s[o + 1] = s[o + 1].toUpperCase());
  const a = `0x${s.join("")}`;
  return ey.set(`${r}.${e}`, a), a;
}
const TD = /^0x[a-fA-F0-9]{40}$/, ty = /* @__PURE__ */ new P2(8192);
function SD(r, e) {
  const { strict: i = !0 } = {}, n = `${r}.${i}`;
  if (ty.has(n))
    return ty.get(n);
  const s = TD.test(r) ? r.toLowerCase() === r ? !0 : i ? _D(r) === r : !0 : !1;
  return ty.set(n, s), s;
}
function O2(r) {
  return `0x${r.reduce((e, i) => e + i.replace("0x", ""), "")}`;
}
const wD = /^(.*)\[([0-9]*)\]$/, ED = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, MD = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function AD(r, e) {
  if (r.length !== e.length)
    throw new PI({
      expectedLength: r.length,
      givenLength: e.length
    });
  const i = [];
  for (let n = 0; n < r.length; n++) {
    const s = r[n], a = e[n];
    i.push(I2(s, a));
  }
  return O2(i);
}
function I2(r, e, i = !1) {
  if (r === "address") {
    const o = e;
    if (!SD(o))
      throw new xD({ address: o });
    return ca(o.toLowerCase(), {
      size: i ? 32 : null
    });
  }
  if (r === "string")
    return _2(e);
  if (r === "bytes")
    return e;
  if (r === "bool")
    return ca(b2(e), { size: i ? 32 : 1 });
  const n = r.match(MD);
  if (n) {
    const [o, l, u = "256"] = n, c = Number.parseInt(u, 10) / 8;
    return a_(e, {
      size: i ? 32 : c,
      signed: l === "int"
    });
  }
  const s = r.match(ED);
  if (s) {
    const [o, l] = s;
    if (Number.parseInt(l, 10) !== (e.length - 2) / 2)
      throw new OI({
        expectedSize: Number.parseInt(l, 10),
        givenSize: (e.length - 2) / 2
      });
    return ca(e, { dir: "right", size: i ? 32 : null });
  }
  const a = r.match(wD);
  if (a && Array.isArray(e)) {
    const [o, l] = a, u = [];
    for (let c = 0; c < e.length; c++)
      u.push(I2(l, e[c], !0));
    return u.length === 0 ? "0x" : O2(u);
  }
  throw new II(r);
}
const ml = "0xB92EA1B47E4ABD0a520E9138BB59dBd1bC6C475B", CD = 13579, iy = BigInt("10000000000000000"), SS = BigInt("10000000000000000"), qh = [
  {
    type: "function",
    name: "BURN_ADDRESS",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "CONTROLLER_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "COUNTER_SALT",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "DEFAULT_ADMIN_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "MAX_BATCH_SIZE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "MIGRATOR_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "ONE_SHARE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "_maxRedeem",
    inputs: [
      {
        name: "sender",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "accumulatedAtomWalletDepositFees",
    inputs: [
      {
        name: "atomWallet",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "accumulatedFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "accumulatedProtocolFees",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "accumulatedFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "approve",
    inputs: [
      {
        name: "sender",
        type: "address",
        internalType: "address"
      },
      {
        name: "approvalType",
        type: "uint8",
        internalType: "enum IMultiVault.ApprovalTypes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "atom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "atomConfig",
    inputs: [],
    outputs: [
      {
        name: "atomCreationProtocolFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomWalletDepositFee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "atomDepositFractionAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "batchSetAtomData",
    inputs: [
      {
        name: "creators",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "atomDataArray",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetTripleData",
    inputs: [
      {
        name: "creators",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "tripleAtomIds",
        type: "bytes32[3][]",
        internalType: "bytes32[3][]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetUserBalances",
    inputs: [
      {
        name: "params",
        type: "tuple",
        internalType: "struct MultiVaultMigrationMode.BatchSetUserBalancesParams",
        components: [
          {
            name: "termIds",
            type: "bytes32[]",
            internalType: "bytes32[]"
          },
          {
            name: "bondingCurveId",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "user",
            type: "address",
            internalType: "address"
          },
          {
            name: "userBalances",
            type: "uint256[]",
            internalType: "uint256[]"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetVaultTotals",
    inputs: [
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "bondingCurveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "vaultTotals",
        type: "tuple[]",
        internalType: "struct MultiVaultMigrationMode.VaultTotals[]",
        components: [
          {
            name: "totalAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalShares",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "bondingCurveConfig",
    inputs: [],
    outputs: [
      {
        name: "registry",
        type: "address",
        internalType: "address"
      },
      {
        name: "defaultCurveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "calculateAtomId",
    inputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "id",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "calculateCounterTripleId",
    inputs: [
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "calculateTripleId",
    inputs: [
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "claimAtomWalletDepositFees",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "computeAtomWalletAddr",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "convertToAssets",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "bondingCurveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "convertToShares",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "createAtoms",
    inputs: [
      {
        name: "data",
        type: "bytes[]",
        internalType: "bytes[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "createTriples",
    inputs: [
      {
        name: "subjectIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "predicateIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "objectIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "currentEpoch",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "currentSharePrice",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "deposit",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minShares",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "depositBatch",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "curveIds",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "minShares",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "entryFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "exitFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "generalConfig",
    inputs: [],
    outputs: [
      {
        name: "admin",
        type: "address",
        internalType: "address"
      },
      {
        name: "protocolMultisig",
        type: "address",
        internalType: "address"
      },
      {
        name: "feeDenominator",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "trustBonding",
        type: "address",
        internalType: "address"
      },
      {
        name: "minDeposit",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minShare",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomDataMaxLength",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "decimalPrecision",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomCreationCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomWarden",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getBondingCurveConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getCounterIdFromTripleId",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "getDefaultCurveId",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getGeneralConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleAdmin",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getShares",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTotalUtilizationForEpoch",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTriple",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleIdFromCounterId",
    inputs: [
      {
        name: "counterId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserUtilizationForEpoch",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVault",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultFees",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultType",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint8",
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getWalletConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "hasRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      {
        name: "_generalConfig",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_atomConfig",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_tripleConfig",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_walletConfig",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      },
      {
        name: "_vaultFees",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_bondingCurveConfig",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "isAtom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isCounterTriple",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTermCreated",
    inputs: [
      {
        name: "id",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTriple",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "lastActiveEpoch",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "pause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "paused",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "personalUtilization",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "utilizationAmount",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewAtomCreate",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFixedFees",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewDeposit",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewRedeem",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewTripleCreate",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFixedFees",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "protocolFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "redeem",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minAssets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "redeemBatch",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "curveIds",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "shares",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "minAssets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "received",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "renounceRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "callerConfirmation",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setAtomConfig",
    inputs: [
      {
        name: "_atomConfig",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setBondingCurveConfig",
    inputs: [
      {
        name: "_bondingCurveConfig",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setGeneralConfig",
    inputs: [
      {
        name: "_generalConfig",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setTermCount",
    inputs: [
      {
        name: "_termCount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setTripleConfig",
    inputs: [
      {
        name: "_tripleConfig",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setVaultFees",
    inputs: [
      {
        name: "_vaultFees",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setWalletConfig",
    inputs: [
      {
        name: "_walletConfig",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [
      {
        name: "interfaceId",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "totalTermsCreated",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "totalUtilization",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "utilizationAmount",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "triple",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "tripleConfig",
    inputs: [],
    outputs: [
      {
        name: "tripleCreationProtocolFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "totalAtomDepositsOnTripleCreation",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomDepositFractionForTriple",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "unpause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "vaultFees",
    inputs: [],
    outputs: [
      {
        name: "entryFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "exitFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "protocolFee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "walletConfig",
    inputs: [],
    outputs: [
      {
        name: "permit2",
        type: "address",
        internalType: "contract IPermit2"
      },
      {
        name: "entryPoint",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWarden",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWalletBeacon",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWalletFactory",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "ApprovalTypeUpdated",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "approvalType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.ApprovalTypes"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomCreated",
    inputs: [
      {
        name: "creator",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "atomData",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      },
      {
        name: "atomWallet",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomDepositFractionDeposited",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomWalletDepositFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomWalletDepositFeesClaimed",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "atomWalletOwner",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "feesClaimed",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ConfigSynced",
    inputs: [
      {
        name: "caller",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Deposited",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "EntryFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ExitFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Initialized",
    inputs: [
      {
        name: "version",
        type: "uint64",
        indexed: !1,
        internalType: "uint64"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Paused",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "PersonalUtilizationAdded",
    inputs: [
      {
        name: "user",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueAdded",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "personalUtilization",
        type: "int256",
        indexed: !1,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "PersonalUtilizationRemoved",
    inputs: [
      {
        name: "user",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueRemoved",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "personalUtilization",
        type: "int256",
        indexed: !1,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ProtocolFeeAccrued",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ProtocolFeeTransferred",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "destination",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Redeemed",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "fees",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleAdminChanged",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "previousAdminRole",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "newAdminRole",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleGranted",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleRevoked",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "SharePriceChanged",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sharePrice",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalAssets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "SharesPullApproval",
    inputs: [
      {
        name: "accountFrom",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "accountTo",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "status",
        type: "bool",
        indexed: !1,
        internalType: "bool"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TermCountSet",
    inputs: [
      {
        name: "termCount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TokensRecovered",
    inputs: [
      {
        name: "token",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "recipient",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TotalUtilizationAdded",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueAdded",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "totalUtilization",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TotalUtilizationRemoved",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueRemoved",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "totalUtilization",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TripleCreated",
    inputs: [
      {
        name: "creator",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "subjectId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Unpaused",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WalletMigrated",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "oldWallet",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "newWallet",
        type: "address",
        indexed: !1,
        internalType: "address"
      },
      {
        name: "sharesMigrated",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WrappedERC20Registered",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "wrappedERC20",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WrapperTransfer",
    inputs: [
      {
        name: "from",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "to",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "error",
    name: "AccessControlBadConfirmation",
    inputs: []
  },
  {
    type: "error",
    name: "AccessControlUnauthorizedAccount",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      },
      {
        name: "neededRole",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "AtomDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "EnforcedPause",
    inputs: []
  },
  {
    type: "error",
    name: "ExpectedPause",
    inputs: []
  },
  {
    type: "error",
    name: "FailedCall",
    inputs: []
  },
  {
    type: "error",
    name: "InsufficientBalance",
    inputs: [
      {
        name: "balance",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "needed",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "InvalidInitialization",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ActionExceedsMaxAssets",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ArraysNotSameLength",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_AtomDataTooLong",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_AtomDoesNotExist",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_AtomExists",
    inputs: [
      {
        name: "atomData",
        type: "bytes",
        internalType: "bytes"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_BurnFromZeroAddress",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_BurnInsufficientBalance",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_CannotApproveOrRevokeSelf",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_DepositBelowMinimumDeposit",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_DepositOrRedeemZeroShares",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_EmptyArray",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientAssets",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientBalance",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientRemainingSharesInVault",
    inputs: [
      {
        name: "remainingShares",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_InsufficientSharesInVault",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InvalidArrayLength",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InvalidBondingCurveId",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_NoAtomDataProvided",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_OnlyAssociatedAtomWallet",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_RedeemerNotApproved",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_SenderNotApproved",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_SlippageExceeded",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_TermDoesNotExist",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_TripleExists",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_ZeroAddress",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ZeroValue",
    inputs: []
  },
  {
    type: "error",
    name: "NotInitializing",
    inputs: []
  },
  {
    type: "error",
    name: "ReentrancyGuardReentrantCall",
    inputs: []
  },
  {
    type: "error",
    name: "TermDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "TripleDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  }
];
function D2(r, e) {
  return function() {
    return r.apply(e, arguments);
  };
}
const { toString: RD } = Object.prototype, { getPrototypeOf: u_ } = Object, { iterator: ng, toStringTag: k2 } = Symbol, sg = /* @__PURE__ */ ((r) => (e) => {
  const i = RD.call(e);
  return r[i] || (r[i] = i.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), rs = (r) => (r = r.toLowerCase(), (e) => sg(e) === r), ag = (r) => (e) => typeof e === r, { isArray: Pc } = Array, hc = ag("undefined");
function Fd(r) {
  return r !== null && !hc(r) && r.constructor !== null && !hc(r.constructor) && Vr(r.constructor.isBuffer) && r.constructor.isBuffer(r);
}
const L2 = rs("ArrayBuffer");
function ND(r) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(r) : e = r && r.buffer && L2(r.buffer), e;
}
const PD = ag("string"), Vr = ag("function"), U2 = ag("number"), Bd = (r) => r !== null && typeof r == "object", OD = (r) => r === !0 || r === !1, Ff = (r) => {
  if (sg(r) !== "object")
    return !1;
  const e = u_(r);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(k2 in r) && !(ng in r);
}, ID = (r) => {
  if (!Bd(r) || Fd(r))
    return !1;
  try {
    return Object.keys(r).length === 0 && Object.getPrototypeOf(r) === Object.prototype;
  } catch {
    return !1;
  }
}, DD = rs("Date"), kD = rs("File"), LD = rs("Blob"), UD = rs("FileList"), FD = (r) => Bd(r) && Vr(r.pipe), BD = (r) => {
  let e;
  return r && (typeof FormData == "function" && r instanceof FormData || Vr(r.append) && ((e = sg(r)) === "formdata" || // detect form-data instance
  e === "object" && Vr(r.toString) && r.toString() === "[object FormData]"));
}, zD = rs("URLSearchParams"), [jD, VD, GD, HD] = ["ReadableStream", "Request", "Response", "Headers"].map(rs), WD = (r) => r.trim ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function zd(r, e, { allOwnKeys: i = !1 } = {}) {
  if (r === null || typeof r > "u")
    return;
  let n, s;
  if (typeof r != "object" && (r = [r]), Pc(r))
    for (n = 0, s = r.length; n < s; n++)
      e.call(null, r[n], n, r);
  else {
    if (Fd(r))
      return;
    const a = i ? Object.getOwnPropertyNames(r) : Object.keys(r), o = a.length;
    let l;
    for (n = 0; n < o; n++)
      l = a[n], e.call(null, r[l], l, r);
  }
}
function F2(r, e) {
  if (Fd(r))
    return null;
  e = e.toLowerCase();
  const i = Object.keys(r);
  let n = i.length, s;
  for (; n-- > 0; )
    if (s = i[n], e === s.toLowerCase())
      return s;
  return null;
}
const il = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, B2 = (r) => !hc(r) && r !== il;
function Ov() {
  const { caseless: r, skipUndefined: e } = B2(this) && this || {}, i = {}, n = (s, a) => {
    const o = r && F2(i, a) || a;
    Ff(i[o]) && Ff(s) ? i[o] = Ov(i[o], s) : Ff(s) ? i[o] = Ov({}, s) : Pc(s) ? i[o] = s.slice() : (!e || !hc(s)) && (i[o] = s);
  };
  for (let s = 0, a = arguments.length; s < a; s++)
    arguments[s] && zd(arguments[s], n);
  return i;
}
const qD = (r, e, i, { allOwnKeys: n } = {}) => (zd(e, (s, a) => {
  i && Vr(s) ? r[a] = D2(s, i) : r[a] = s;
}, { allOwnKeys: n }), r), XD = (r) => (r.charCodeAt(0) === 65279 && (r = r.slice(1)), r), YD = (r, e, i, n) => {
  r.prototype = Object.create(e.prototype, n), r.prototype.constructor = r, Object.defineProperty(r, "super", {
    value: e.prototype
  }), i && Object.assign(r.prototype, i);
}, $D = (r, e, i, n) => {
  let s, a, o;
  const l = {};
  if (e = e || {}, r == null) return e;
  do {
    for (s = Object.getOwnPropertyNames(r), a = s.length; a-- > 0; )
      o = s[a], (!n || n(o, r, e)) && !l[o] && (e[o] = r[o], l[o] = !0);
    r = i !== !1 && u_(r);
  } while (r && (!i || i(r, e)) && r !== Object.prototype);
  return e;
}, KD = (r, e, i) => {
  r = String(r), (i === void 0 || i > r.length) && (i = r.length), i -= e.length;
  const n = r.indexOf(e, i);
  return n !== -1 && n === i;
}, QD = (r) => {
  if (!r) return null;
  if (Pc(r)) return r;
  let e = r.length;
  if (!U2(e)) return null;
  const i = new Array(e);
  for (; e-- > 0; )
    i[e] = r[e];
  return i;
}, ZD = /* @__PURE__ */ ((r) => (e) => r && e instanceof r)(typeof Uint8Array < "u" && u_(Uint8Array)), JD = (r, e) => {
  const n = (r && r[ng]).call(r);
  let s;
  for (; (s = n.next()) && !s.done; ) {
    const a = s.value;
    e.call(r, a[0], a[1]);
  }
}, ek = (r, e) => {
  let i;
  const n = [];
  for (; (i = r.exec(e)) !== null; )
    n.push(i);
  return n;
}, tk = rs("HTMLFormElement"), ik = (r) => r.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(i, n, s) {
    return n.toUpperCase() + s;
  }
), wS = (({ hasOwnProperty: r }) => (e, i) => r.call(e, i))(Object.prototype), rk = rs("RegExp"), z2 = (r, e) => {
  const i = Object.getOwnPropertyDescriptors(r), n = {};
  zd(i, (s, a) => {
    let o;
    (o = e(s, a, r)) !== !1 && (n[a] = o || s);
  }), Object.defineProperties(r, n);
}, nk = (r) => {
  z2(r, (e, i) => {
    if (Vr(r) && ["arguments", "caller", "callee"].indexOf(i) !== -1)
      return !1;
    const n = r[i];
    if (Vr(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + i + "'");
      });
    }
  });
}, sk = (r, e) => {
  const i = {}, n = (s) => {
    s.forEach((a) => {
      i[a] = !0;
    });
  };
  return Pc(r) ? n(r) : n(String(r).split(e)), i;
}, ak = () => {
}, ok = (r, e) => r != null && Number.isFinite(r = +r) ? r : e;
function lk(r) {
  return !!(r && Vr(r.append) && r[k2] === "FormData" && r[ng]);
}
const uk = (r) => {
  const e = new Array(10), i = (n, s) => {
    if (Bd(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (Fd(n))
        return n;
      if (!("toJSON" in n)) {
        e[s] = n;
        const a = Pc(n) ? [] : {};
        return zd(n, (o, l) => {
          const u = i(o, s + 1);
          !hc(u) && (a[l] = u);
        }), e[s] = void 0, a;
      }
    }
    return n;
  };
  return i(r, 0);
}, ck = rs("AsyncFunction"), hk = (r) => r && (Bd(r) || Vr(r)) && Vr(r.then) && Vr(r.catch), j2 = ((r, e) => r ? setImmediate : e ? ((i, n) => (il.addEventListener("message", ({ source: s, data: a }) => {
  s === il && a === i && n.length && n.shift()();
}, !1), (s) => {
  n.push(s), il.postMessage(i, "*");
}))(`axios@${Math.random()}`, []) : (i) => setTimeout(i))(
  typeof setImmediate == "function",
  Vr(il.postMessage)
), dk = typeof queueMicrotask < "u" ? queueMicrotask.bind(il) : typeof process < "u" && process.nextTick || j2, pk = (r) => r != null && Vr(r[ng]), he = {
  isArray: Pc,
  isArrayBuffer: L2,
  isBuffer: Fd,
  isFormData: BD,
  isArrayBufferView: ND,
  isString: PD,
  isNumber: U2,
  isBoolean: OD,
  isObject: Bd,
  isPlainObject: Ff,
  isEmptyObject: ID,
  isReadableStream: jD,
  isRequest: VD,
  isResponse: GD,
  isHeaders: HD,
  isUndefined: hc,
  isDate: DD,
  isFile: kD,
  isBlob: LD,
  isRegExp: rk,
  isFunction: Vr,
  isStream: FD,
  isURLSearchParams: zD,
  isTypedArray: ZD,
  isFileList: UD,
  forEach: zd,
  merge: Ov,
  extend: qD,
  trim: WD,
  stripBOM: XD,
  inherits: YD,
  toFlatObject: $D,
  kindOf: sg,
  kindOfTest: rs,
  endsWith: KD,
  toArray: QD,
  forEachEntry: JD,
  matchAll: ek,
  isHTMLForm: tk,
  hasOwnProperty: wS,
  hasOwnProp: wS,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: z2,
  freezeMethods: nk,
  toObjectSet: sk,
  toCamelCase: ik,
  noop: ak,
  toFiniteNumber: ok,
  findKey: F2,
  global: il,
  isContextDefined: B2,
  isSpecCompliantForm: lk,
  toJSONObject: uk,
  isAsyncFn: ck,
  isThenable: hk,
  setImmediate: j2,
  asap: dk,
  isIterable: pk
};
function Mt(r, e, i, n, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = r, this.name = "AxiosError", e && (this.code = e), i && (this.config = i), n && (this.request = n), s && (this.response = s, this.status = s.status ? s.status : null);
}
he.inherits(Mt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: he.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const V2 = Mt.prototype, G2 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((r) => {
  G2[r] = { value: r };
});
Object.defineProperties(Mt, G2);
Object.defineProperty(V2, "isAxiosError", { value: !0 });
Mt.from = (r, e, i, n, s, a) => {
  const o = Object.create(V2);
  he.toFlatObject(r, o, function(h) {
    return h !== Error.prototype;
  }, (c) => c !== "isAxiosError");
  const l = r && r.message ? r.message : "Error", u = e == null && r ? r.code : e;
  return Mt.call(o, l, u, i, n, s), r && o.cause == null && Object.defineProperty(o, "cause", { value: r, configurable: !0 }), o.name = r && r.name || "Error", a && Object.assign(o, a), o;
};
const fk = null;
function Iv(r) {
  return he.isPlainObject(r) || he.isArray(r);
}
function H2(r) {
  return he.endsWith(r, "[]") ? r.slice(0, -2) : r;
}
function ES(r, e, i) {
  return r ? r.concat(e).map(function(s, a) {
    return s = H2(s), !i && a ? "[" + s + "]" : s;
  }).join(i ? "." : "") : e;
}
function mk(r) {
  return he.isArray(r) && !r.some(Iv);
}
const gk = he.toFlatObject(he, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function og(r, e, i) {
  if (!he.isObject(r))
    throw new TypeError("target must be an object");
  e = e || new FormData(), i = he.toFlatObject(i, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(v, y) {
    return !he.isUndefined(y[v]);
  });
  const n = i.metaTokens, s = i.visitor || h, a = i.dots, o = i.indexes, u = (i.Blob || typeof Blob < "u" && Blob) && he.isSpecCompliantForm(e);
  if (!he.isFunction(s))
    throw new TypeError("visitor must be a function");
  function c(m) {
    if (m === null) return "";
    if (he.isDate(m))
      return m.toISOString();
    if (he.isBoolean(m))
      return m.toString();
    if (!u && he.isBlob(m))
      throw new Mt("Blob is not supported. Use a Buffer instead.");
    return he.isArrayBuffer(m) || he.isTypedArray(m) ? u && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m;
  }
  function h(m, v, y) {
    let g = m;
    if (m && !y && typeof m == "object") {
      if (he.endsWith(v, "{}"))
        v = n ? v : v.slice(0, -2), m = JSON.stringify(m);
      else if (he.isArray(m) && mk(m) || (he.isFileList(m) || he.endsWith(v, "[]")) && (g = he.toArray(m)))
        return v = H2(v), g.forEach(function(x, b) {
          !(he.isUndefined(x) || x === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? ES([v], b, a) : o === null ? v : v + "[]",
            c(x)
          );
        }), !1;
    }
    return Iv(m) ? !0 : (e.append(ES(y, v, a), c(m)), !1);
  }
  const d = [], p = Object.assign(gk, {
    defaultVisitor: h,
    convertValue: c,
    isVisitable: Iv
  });
  function f(m, v) {
    if (!he.isUndefined(m)) {
      if (d.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + v.join("."));
      d.push(m), he.forEach(m, function(g, _) {
        (!(he.isUndefined(g) || g === null) && s.call(
          e,
          g,
          he.isString(_) ? _.trim() : _,
          v,
          p
        )) === !0 && f(g, v ? v.concat(_) : [_]);
      }), d.pop();
    }
  }
  if (!he.isObject(r))
    throw new TypeError("data must be an object");
  return f(r), e;
}
function MS(r) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(r).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function c_(r, e) {
  this._pairs = [], r && og(r, this, e);
}
const W2 = c_.prototype;
W2.append = function(e, i) {
  this._pairs.push([e, i]);
};
W2.toString = function(e) {
  const i = e ? function(n) {
    return e.call(this, n, MS);
  } : MS;
  return this._pairs.map(function(s) {
    return i(s[0]) + "=" + i(s[1]);
  }, "").join("&");
};
function yk(r) {
  return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function q2(r, e, i) {
  if (!e)
    return r;
  const n = i && i.encode || yk;
  he.isFunction(i) && (i = {
    serialize: i
  });
  const s = i && i.serialize;
  let a;
  if (s ? a = s(e, i) : a = he.isURLSearchParams(e) ? e.toString() : new c_(e, i).toString(n), a) {
    const o = r.indexOf("#");
    o !== -1 && (r = r.slice(0, o)), r += (r.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return r;
}
class AS {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, i, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: i,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    he.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const X2 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, vk = typeof URLSearchParams < "u" ? URLSearchParams : c_, bk = typeof FormData < "u" ? FormData : null, xk = typeof Blob < "u" ? Blob : null, _k = {
  isBrowser: !0,
  classes: {
    URLSearchParams: vk,
    FormData: bk,
    Blob: xk
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, h_ = typeof window < "u" && typeof document < "u", Dv = typeof navigator == "object" && navigator || void 0, Tk = h_ && (!Dv || ["ReactNative", "NativeScript", "NS"].indexOf(Dv.product) < 0), Sk = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", wk = h_ && window.location.href || "http://localhost", Ek = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: h_,
  hasStandardBrowserEnv: Tk,
  hasStandardBrowserWebWorkerEnv: Sk,
  navigator: Dv,
  origin: wk
}, Symbol.toStringTag, { value: "Module" })), fr = {
  ...Ek,
  ..._k
};
function Mk(r, e) {
  return og(r, new fr.classes.URLSearchParams(), {
    visitor: function(i, n, s, a) {
      return fr.isNode && he.isBuffer(i) ? (this.append(n, i.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    },
    ...e
  });
}
function Ak(r) {
  return he.matchAll(/\w+|\[(\w*)]/g, r).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function Ck(r) {
  const e = {}, i = Object.keys(r);
  let n;
  const s = i.length;
  let a;
  for (n = 0; n < s; n++)
    a = i[n], e[a] = r[a];
  return e;
}
function Y2(r) {
  function e(i, n, s, a) {
    let o = i[a++];
    if (o === "__proto__") return !0;
    const l = Number.isFinite(+o), u = a >= i.length;
    return o = !o && he.isArray(s) ? s.length : o, u ? (he.hasOwnProp(s, o) ? s[o] = [s[o], n] : s[o] = n, !l) : ((!s[o] || !he.isObject(s[o])) && (s[o] = []), e(i, n, s[o], a) && he.isArray(s[o]) && (s[o] = Ck(s[o])), !l);
  }
  if (he.isFormData(r) && he.isFunction(r.entries)) {
    const i = {};
    return he.forEachEntry(r, (n, s) => {
      e(Ak(n), s, i, 0);
    }), i;
  }
  return null;
}
function Rk(r, e, i) {
  if (he.isString(r))
    try {
      return (e || JSON.parse)(r), he.trim(r);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (i || JSON.stringify)(r);
}
const jd = {
  transitional: X2,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, i) {
    const n = i.getContentType() || "", s = n.indexOf("application/json") > -1, a = he.isObject(e);
    if (a && he.isHTMLForm(e) && (e = new FormData(e)), he.isFormData(e))
      return s ? JSON.stringify(Y2(e)) : e;
    if (he.isArrayBuffer(e) || he.isBuffer(e) || he.isStream(e) || he.isFile(e) || he.isBlob(e) || he.isReadableStream(e))
      return e;
    if (he.isArrayBufferView(e))
      return e.buffer;
    if (he.isURLSearchParams(e))
      return i.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let l;
    if (a) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return Mk(e, this.formSerializer).toString();
      if ((l = he.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const u = this.env && this.env.FormData;
        return og(
          l ? { "files[]": e } : e,
          u && new u(),
          this.formSerializer
        );
      }
    }
    return a || s ? (i.setContentType("application/json", !1), Rk(e)) : e;
  }],
  transformResponse: [function(e) {
    const i = this.transitional || jd.transitional, n = i && i.forcedJSONParsing, s = this.responseType === "json";
    if (he.isResponse(e) || he.isReadableStream(e))
      return e;
    if (e && he.isString(e) && (n && !this.responseType || s)) {
      const o = !(i && i.silentJSONParsing) && s;
      try {
        return JSON.parse(e, this.parseReviver);
      } catch (l) {
        if (o)
          throw l.name === "SyntaxError" ? Mt.from(l, Mt.ERR_BAD_RESPONSE, this, null, this.response) : l;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: fr.classes.FormData,
    Blob: fr.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
he.forEach(["delete", "get", "head", "post", "put", "patch"], (r) => {
  jd.headers[r] = {};
});
const Nk = he.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), Pk = (r) => {
  const e = {};
  let i, n, s;
  return r && r.split(`
`).forEach(function(o) {
    s = o.indexOf(":"), i = o.substring(0, s).trim().toLowerCase(), n = o.substring(s + 1).trim(), !(!i || e[i] && Nk[i]) && (i === "set-cookie" ? e[i] ? e[i].push(n) : e[i] = [n] : e[i] = e[i] ? e[i] + ", " + n : n);
  }), e;
}, CS = Symbol("internals");
function eh(r) {
  return r && String(r).trim().toLowerCase();
}
function Bf(r) {
  return r === !1 || r == null ? r : he.isArray(r) ? r.map(Bf) : String(r);
}
function Ok(r) {
  const e = /* @__PURE__ */ Object.create(null), i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = i.exec(r); )
    e[n[1]] = n[2];
  return e;
}
const Ik = (r) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function ry(r, e, i, n, s) {
  if (he.isFunction(n))
    return n.call(this, e, i);
  if (s && (e = i), !!he.isString(e)) {
    if (he.isString(n))
      return e.indexOf(n) !== -1;
    if (he.isRegExp(n))
      return n.test(e);
  }
}
function Dk(r) {
  return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, i, n) => i.toUpperCase() + n);
}
function kk(r, e) {
  const i = he.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(r, n + i, {
      value: function(s, a, o) {
        return this[n].call(this, e, s, a, o);
      },
      configurable: !0
    });
  });
}
let Gr = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, i, n) {
    const s = this;
    function a(l, u, c) {
      const h = eh(u);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const d = he.findKey(s, h);
      (!d || s[d] === void 0 || c === !0 || c === void 0 && s[d] !== !1) && (s[d || u] = Bf(l));
    }
    const o = (l, u) => he.forEach(l, (c, h) => a(c, h, u));
    if (he.isPlainObject(e) || e instanceof this.constructor)
      o(e, i);
    else if (he.isString(e) && (e = e.trim()) && !Ik(e))
      o(Pk(e), i);
    else if (he.isObject(e) && he.isIterable(e)) {
      let l = {}, u, c;
      for (const h of e) {
        if (!he.isArray(h))
          throw TypeError("Object iterator must return a key-value pair");
        l[c = h[0]] = (u = l[c]) ? he.isArray(u) ? [...u, h[1]] : [u, h[1]] : h[1];
      }
      o(l, i);
    } else
      e != null && a(i, e, n);
    return this;
  }
  get(e, i) {
    if (e = eh(e), e) {
      const n = he.findKey(this, e);
      if (n) {
        const s = this[n];
        if (!i)
          return s;
        if (i === !0)
          return Ok(s);
        if (he.isFunction(i))
          return i.call(this, s, n);
        if (he.isRegExp(i))
          return i.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, i) {
    if (e = eh(e), e) {
      const n = he.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!i || ry(this, this[n], n, i)));
    }
    return !1;
  }
  delete(e, i) {
    const n = this;
    let s = !1;
    function a(o) {
      if (o = eh(o), o) {
        const l = he.findKey(n, o);
        l && (!i || ry(n, n[l], l, i)) && (delete n[l], s = !0);
      }
    }
    return he.isArray(e) ? e.forEach(a) : a(e), s;
  }
  clear(e) {
    const i = Object.keys(this);
    let n = i.length, s = !1;
    for (; n--; ) {
      const a = i[n];
      (!e || ry(this, this[a], a, e, !0)) && (delete this[a], s = !0);
    }
    return s;
  }
  normalize(e) {
    const i = this, n = {};
    return he.forEach(this, (s, a) => {
      const o = he.findKey(n, a);
      if (o) {
        i[o] = Bf(s), delete i[a];
        return;
      }
      const l = e ? Dk(a) : String(a).trim();
      l !== a && delete i[a], i[l] = Bf(s), n[l] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const i = /* @__PURE__ */ Object.create(null);
    return he.forEach(this, (n, s) => {
      n != null && n !== !1 && (i[s] = e && he.isArray(n) ? n.join(", ") : n);
    }), i;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, i]) => e + ": " + i).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...i) {
    const n = new this(e);
    return i.forEach((s) => n.set(s)), n;
  }
  static accessor(e) {
    const n = (this[CS] = this[CS] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function a(o) {
      const l = eh(o);
      n[l] || (kk(s, o), n[l] = !0);
    }
    return he.isArray(e) ? e.forEach(a) : a(e), this;
  }
};
Gr.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
he.reduceDescriptors(Gr.prototype, ({ value: r }, e) => {
  let i = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => r,
    set(n) {
      this[i] = n;
    }
  };
});
he.freezeMethods(Gr);
function ny(r, e) {
  const i = this || jd, n = e || i, s = Gr.from(n.headers);
  let a = n.data;
  return he.forEach(r, function(l) {
    a = l.call(i, a, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), a;
}
function $2(r) {
  return !!(r && r.__CANCEL__);
}
function Oc(r, e, i) {
  Mt.call(this, r ?? "canceled", Mt.ERR_CANCELED, e, i), this.name = "CanceledError";
}
he.inherits(Oc, Mt, {
  __CANCEL__: !0
});
function K2(r, e, i) {
  const n = i.config.validateStatus;
  !i.status || !n || n(i.status) ? r(i) : e(new Mt(
    "Request failed with status code " + i.status,
    [Mt.ERR_BAD_REQUEST, Mt.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4],
    i.config,
    i.request,
    i
  ));
}
function Lk(r) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(r);
  return e && e[1] || "";
}
function Uk(r, e) {
  r = r || 10;
  const i = new Array(r), n = new Array(r);
  let s = 0, a = 0, o;
  return e = e !== void 0 ? e : 1e3, function(u) {
    const c = Date.now(), h = n[a];
    o || (o = c), i[s] = u, n[s] = c;
    let d = a, p = 0;
    for (; d !== s; )
      p += i[d++], d = d % r;
    if (s = (s + 1) % r, s === a && (a = (a + 1) % r), c - o < e)
      return;
    const f = h && c - h;
    return f ? Math.round(p * 1e3 / f) : void 0;
  };
}
function Fk(r, e) {
  let i = 0, n = 1e3 / e, s, a;
  const o = (c, h = Date.now()) => {
    i = h, s = null, a && (clearTimeout(a), a = null), r(...c);
  };
  return [(...c) => {
    const h = Date.now(), d = h - i;
    d >= n ? o(c, h) : (s = c, a || (a = setTimeout(() => {
      a = null, o(s);
    }, n - d)));
  }, () => s && o(s)];
}
const gm = (r, e, i = 3) => {
  let n = 0;
  const s = Uk(50, 250);
  return Fk((a) => {
    const o = a.loaded, l = a.lengthComputable ? a.total : void 0, u = o - n, c = s(u), h = o <= l;
    n = o;
    const d = {
      loaded: o,
      total: l,
      progress: l ? o / l : void 0,
      bytes: u,
      rate: c || void 0,
      estimated: c && l && h ? (l - o) / c : void 0,
      event: a,
      lengthComputable: l != null,
      [e ? "download" : "upload"]: !0
    };
    r(d);
  }, i);
}, RS = (r, e) => {
  const i = r != null;
  return [(n) => e[0]({
    lengthComputable: i,
    total: r,
    loaded: n
  }), e[1]];
}, NS = (r) => (...e) => he.asap(() => r(...e)), Bk = fr.hasStandardBrowserEnv ? /* @__PURE__ */ ((r, e) => (i) => (i = new URL(i, fr.origin), r.protocol === i.protocol && r.host === i.host && (e || r.port === i.port)))(
  new URL(fr.origin),
  fr.navigator && /(msie|trident)/i.test(fr.navigator.userAgent)
) : () => !0, zk = fr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(r, e, i, n, s, a) {
      const o = [r + "=" + encodeURIComponent(e)];
      he.isNumber(i) && o.push("expires=" + new Date(i).toGMTString()), he.isString(n) && o.push("path=" + n), he.isString(s) && o.push("domain=" + s), a === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(r) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(r) {
      this.write(r, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function jk(r) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(r);
}
function Vk(r, e) {
  return e ? r.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : r;
}
function Q2(r, e, i) {
  let n = !jk(e);
  return r && (n || i == !1) ? Vk(r, e) : e;
}
const PS = (r) => r instanceof Gr ? { ...r } : r;
function xl(r, e) {
  e = e || {};
  const i = {};
  function n(c, h, d, p) {
    return he.isPlainObject(c) && he.isPlainObject(h) ? he.merge.call({ caseless: p }, c, h) : he.isPlainObject(h) ? he.merge({}, h) : he.isArray(h) ? h.slice() : h;
  }
  function s(c, h, d, p) {
    if (he.isUndefined(h)) {
      if (!he.isUndefined(c))
        return n(void 0, c, d, p);
    } else return n(c, h, d, p);
  }
  function a(c, h) {
    if (!he.isUndefined(h))
      return n(void 0, h);
  }
  function o(c, h) {
    if (he.isUndefined(h)) {
      if (!he.isUndefined(c))
        return n(void 0, c);
    } else return n(void 0, h);
  }
  function l(c, h, d) {
    if (d in e)
      return n(c, h);
    if (d in r)
      return n(void 0, c);
  }
  const u = {
    url: a,
    method: a,
    data: a,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: l,
    headers: (c, h, d) => s(PS(c), PS(h), d, !0)
  };
  return he.forEach(Object.keys({ ...r, ...e }), function(h) {
    const d = u[h] || s, p = d(r[h], e[h], h);
    he.isUndefined(p) && d !== l || (i[h] = p);
  }), i;
}
const Z2 = (r) => {
  const e = xl({}, r);
  let { data: i, withXSRFToken: n, xsrfHeaderName: s, xsrfCookieName: a, headers: o, auth: l } = e;
  if (e.headers = o = Gr.from(o), e.url = q2(Q2(e.baseURL, e.url, e.allowAbsoluteUrls), r.params, r.paramsSerializer), l && o.set(
    "Authorization",
    "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))
  ), he.isFormData(i)) {
    if (fr.hasStandardBrowserEnv || fr.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if (he.isFunction(i.getHeaders)) {
      const u = i.getHeaders(), c = ["content-type", "content-length"];
      Object.entries(u).forEach(([h, d]) => {
        c.includes(h.toLowerCase()) && o.set(h, d);
      });
    }
  }
  if (fr.hasStandardBrowserEnv && (n && he.isFunction(n) && (n = n(e)), n || n !== !1 && Bk(e.url))) {
    const u = s && a && zk.read(a);
    u && o.set(s, u);
  }
  return e;
}, Gk = typeof XMLHttpRequest < "u", Hk = Gk && function(r) {
  return new Promise(function(i, n) {
    const s = Z2(r);
    let a = s.data;
    const o = Gr.from(s.headers).normalize();
    let { responseType: l, onUploadProgress: u, onDownloadProgress: c } = s, h, d, p, f, m;
    function v() {
      f && f(), m && m(), s.cancelToken && s.cancelToken.unsubscribe(h), s.signal && s.signal.removeEventListener("abort", h);
    }
    let y = new XMLHttpRequest();
    y.open(s.method.toUpperCase(), s.url, !0), y.timeout = s.timeout;
    function g() {
      if (!y)
        return;
      const x = Gr.from(
        "getAllResponseHeaders" in y && y.getAllResponseHeaders()
      ), T = {
        data: !l || l === "text" || l === "json" ? y.responseText : y.response,
        status: y.status,
        statusText: y.statusText,
        headers: x,
        config: r,
        request: y
      };
      K2(function(w) {
        i(w), v();
      }, function(w) {
        n(w), v();
      }, T), y = null;
    }
    "onloadend" in y ? y.onloadend = g : y.onreadystatechange = function() {
      !y || y.readyState !== 4 || y.status === 0 && !(y.responseURL && y.responseURL.indexOf("file:") === 0) || setTimeout(g);
    }, y.onabort = function() {
      y && (n(new Mt("Request aborted", Mt.ECONNABORTED, r, y)), y = null);
    }, y.onerror = function(b) {
      const T = b && b.message ? b.message : "Network Error", S = new Mt(T, Mt.ERR_NETWORK, r, y);
      S.event = b || null, n(S), y = null;
    }, y.ontimeout = function() {
      let b = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const T = s.transitional || X2;
      s.timeoutErrorMessage && (b = s.timeoutErrorMessage), n(new Mt(
        b,
        T.clarifyTimeoutError ? Mt.ETIMEDOUT : Mt.ECONNABORTED,
        r,
        y
      )), y = null;
    }, a === void 0 && o.setContentType(null), "setRequestHeader" in y && he.forEach(o.toJSON(), function(b, T) {
      y.setRequestHeader(T, b);
    }), he.isUndefined(s.withCredentials) || (y.withCredentials = !!s.withCredentials), l && l !== "json" && (y.responseType = s.responseType), c && ([p, m] = gm(c, !0), y.addEventListener("progress", p)), u && y.upload && ([d, f] = gm(u), y.upload.addEventListener("progress", d), y.upload.addEventListener("loadend", f)), (s.cancelToken || s.signal) && (h = (x) => {
      y && (n(!x || x.type ? new Oc(null, r, y) : x), y.abort(), y = null);
    }, s.cancelToken && s.cancelToken.subscribe(h), s.signal && (s.signal.aborted ? h() : s.signal.addEventListener("abort", h)));
    const _ = Lk(s.url);
    if (_ && fr.protocols.indexOf(_) === -1) {
      n(new Mt("Unsupported protocol " + _ + ":", Mt.ERR_BAD_REQUEST, r));
      return;
    }
    y.send(a || null);
  });
}, Wk = (r, e) => {
  const { length: i } = r = r ? r.filter(Boolean) : [];
  if (e || i) {
    let n = new AbortController(), s;
    const a = function(c) {
      if (!s) {
        s = !0, l();
        const h = c instanceof Error ? c : this.reason;
        n.abort(h instanceof Mt ? h : new Oc(h instanceof Error ? h.message : h));
      }
    };
    let o = e && setTimeout(() => {
      o = null, a(new Mt(`timeout ${e} of ms exceeded`, Mt.ETIMEDOUT));
    }, e);
    const l = () => {
      r && (o && clearTimeout(o), o = null, r.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(a) : c.removeEventListener("abort", a);
      }), r = null);
    };
    r.forEach((c) => c.addEventListener("abort", a));
    const { signal: u } = n;
    return u.unsubscribe = () => he.asap(l), u;
  }
}, qk = function* (r, e) {
  let i = r.byteLength;
  if (i < e) {
    yield r;
    return;
  }
  let n = 0, s;
  for (; n < i; )
    s = n + e, yield r.slice(n, s), n = s;
}, Xk = async function* (r, e) {
  for await (const i of Yk(r))
    yield* qk(i, e);
}, Yk = async function* (r) {
  if (r[Symbol.asyncIterator]) {
    yield* r;
    return;
  }
  const e = r.getReader();
  try {
    for (; ; ) {
      const { done: i, value: n } = await e.read();
      if (i)
        break;
      yield n;
    }
  } finally {
    await e.cancel();
  }
}, OS = (r, e, i, n) => {
  const s = Xk(r, e);
  let a = 0, o, l = (u) => {
    o || (o = !0, n && n(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: c, value: h } = await s.next();
        if (c) {
          l(), u.close();
          return;
        }
        let d = h.byteLength;
        if (i) {
          let p = a += d;
          i(p);
        }
        u.enqueue(new Uint8Array(h));
      } catch (c) {
        throw l(c), c;
      }
    },
    cancel(u) {
      return l(u), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, IS = 64 * 1024, { isFunction: lp } = he, J2 = (({ fetch: r, Request: e, Response: i }) => ({
  fetch: r,
  Request: e,
  Response: i
}))(he.global), {
  ReadableStream: DS,
  TextEncoder: kS
} = he.global, LS = (r, ...e) => {
  try {
    return !!r(...e);
  } catch {
    return !1;
  }
}, $k = (r) => {
  const { fetch: e, Request: i, Response: n } = Object.assign({}, J2, r), s = lp(e), a = lp(i), o = lp(n);
  if (!s)
    return !1;
  const l = s && lp(DS), u = s && (typeof kS == "function" ? /* @__PURE__ */ ((m) => (v) => m.encode(v))(new kS()) : async (m) => new Uint8Array(await new i(m).arrayBuffer())), c = a && l && LS(() => {
    let m = !1;
    const v = new i(fr.origin, {
      body: new DS(),
      method: "POST",
      get duplex() {
        return m = !0, "half";
      }
    }).headers.has("Content-Type");
    return m && !v;
  }), h = o && l && LS(() => he.isReadableStream(new n("").body)), d = {
    stream: h && ((m) => m.body)
  };
  s && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((m) => {
    !d[m] && (d[m] = (v, y) => {
      let g = v && v[m];
      if (g)
        return g.call(v);
      throw new Mt(`Response type '${m}' is not supported`, Mt.ERR_NOT_SUPPORT, y);
    });
  });
  const p = async (m) => {
    if (m == null)
      return 0;
    if (he.isBlob(m))
      return m.size;
    if (he.isSpecCompliantForm(m))
      return (await new i(fr.origin, {
        method: "POST",
        body: m
      }).arrayBuffer()).byteLength;
    if (he.isArrayBufferView(m) || he.isArrayBuffer(m))
      return m.byteLength;
    if (he.isURLSearchParams(m) && (m = m + ""), he.isString(m))
      return (await u(m)).byteLength;
  }, f = async (m, v) => {
    const y = he.toFiniteNumber(m.getContentLength());
    return y ?? p(v);
  };
  return async (m) => {
    let {
      url: v,
      method: y,
      data: g,
      signal: _,
      cancelToken: x,
      timeout: b,
      onDownloadProgress: T,
      onUploadProgress: S,
      responseType: w,
      headers: C,
      withCredentials: E = "same-origin",
      fetchOptions: A
    } = Z2(m);
    w = w ? (w + "").toLowerCase() : "text";
    let N = Wk([_, x && x.toAbortSignal()], b), L = null;
    const F = N && N.unsubscribe && (() => {
      N.unsubscribe();
    });
    let M;
    try {
      if (S && c && y !== "get" && y !== "head" && (M = await f(C, g)) !== 0) {
        let U = new i(v, {
          method: "POST",
          body: g,
          duplex: "half"
        }), j;
        if (he.isFormData(g) && (j = U.headers.get("content-type")) && C.setContentType(j), U.body) {
          const [Q, q] = RS(
            M,
            gm(NS(S))
          );
          g = OS(U.body, IS, Q, q);
        }
      }
      he.isString(E) || (E = E ? "include" : "omit");
      const P = a && "credentials" in i.prototype, O = {
        ...A,
        signal: N,
        method: y.toUpperCase(),
        headers: C.normalize().toJSON(),
        body: g,
        duplex: "half",
        credentials: P ? E : void 0
      };
      L = a && new i(v, O);
      let V = await (a ? e(L, A) : e(v, O));
      const B = h && (w === "stream" || w === "response");
      if (h && (T || B && F)) {
        const U = {};
        ["status", "statusText", "headers"].forEach((G) => {
          U[G] = V[G];
        });
        const j = he.toFiniteNumber(V.headers.get("content-length")), [Q, q] = T && RS(
          j,
          gm(NS(T), !0)
        ) || [];
        V = new n(
          OS(V.body, IS, Q, () => {
            q && q(), F && F();
          }),
          U
        );
      }
      w = w || "text";
      let H = await d[he.findKey(d, w) || "text"](V, m);
      return !B && F && F(), await new Promise((U, j) => {
        K2(U, j, {
          data: H,
          headers: Gr.from(V.headers),
          status: V.status,
          statusText: V.statusText,
          config: m,
          request: L
        });
      });
    } catch (P) {
      throw F && F(), P && P.name === "TypeError" && /Load failed|fetch/i.test(P.message) ? Object.assign(
        new Mt("Network Error", Mt.ERR_NETWORK, m, L),
        {
          cause: P.cause || P
        }
      ) : Mt.from(P, P && P.code, m, L);
    }
  };
}, Kk = /* @__PURE__ */ new Map(), eC = (r) => {
  let e = he.merge.call({
    skipUndefined: !0
  }, J2, r ? r.env : null);
  const { fetch: i, Request: n, Response: s } = e, a = [
    n,
    s,
    i
  ];
  let o = a.length, l = o, u, c, h = Kk;
  for (; l--; )
    u = a[l], c = h.get(u), c === void 0 && h.set(u, c = l ? /* @__PURE__ */ new Map() : $k(e)), h = c;
  return c;
};
eC();
const kv = {
  http: fk,
  xhr: Hk,
  fetch: {
    get: eC
  }
};
he.forEach(kv, (r, e) => {
  if (r) {
    try {
      Object.defineProperty(r, "name", { value: e });
    } catch {
    }
    Object.defineProperty(r, "adapterName", { value: e });
  }
});
const US = (r) => `- ${r}`, Qk = (r) => he.isFunction(r) || r === null || r === !1, tC = {
  getAdapter: (r, e) => {
    r = he.isArray(r) ? r : [r];
    const { length: i } = r;
    let n, s;
    const a = {};
    for (let o = 0; o < i; o++) {
      n = r[o];
      let l;
      if (s = n, !Qk(n) && (s = kv[(l = String(n)).toLowerCase()], s === void 0))
        throw new Mt(`Unknown adapter '${l}'`);
      if (s && (he.isFunction(s) || (s = s.get(e))))
        break;
      a[l || "#" + o] = s;
    }
    if (!s) {
      const o = Object.entries(a).map(
        ([u, c]) => `adapter ${u} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let l = i ? o.length > 1 ? `since :
` + o.map(US).join(`
`) : " " + US(o[0]) : "as no adapter specified";
      throw new Mt(
        "There is no suitable adapter to dispatch the request " + l,
        "ERR_NOT_SUPPORT"
      );
    }
    return s;
  },
  adapters: kv
};
function sy(r) {
  if (r.cancelToken && r.cancelToken.throwIfRequested(), r.signal && r.signal.aborted)
    throw new Oc(null, r);
}
function FS(r) {
  return sy(r), r.headers = Gr.from(r.headers), r.data = ny.call(
    r,
    r.transformRequest
  ), ["post", "put", "patch"].indexOf(r.method) !== -1 && r.headers.setContentType("application/x-www-form-urlencoded", !1), tC.getAdapter(r.adapter || jd.adapter, r)(r).then(function(n) {
    return sy(r), n.data = ny.call(
      r,
      r.transformResponse,
      n
    ), n.headers = Gr.from(n.headers), n;
  }, function(n) {
    return $2(n) || (sy(r), n && n.response && (n.response.data = ny.call(
      r,
      r.transformResponse,
      n.response
    ), n.response.headers = Gr.from(n.response.headers))), Promise.reject(n);
  });
}
const iC = "1.12.0", lg = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((r, e) => {
  lg[r] = function(n) {
    return typeof n === r || "a" + (e < 1 ? "n " : " ") + r;
  };
});
const BS = {};
lg.transitional = function(e, i, n) {
  function s(a, o) {
    return "[Axios v" + iC + "] Transitional option '" + a + "'" + o + (n ? ". " + n : "");
  }
  return (a, o, l) => {
    if (e === !1)
      throw new Mt(
        s(o, " has been removed" + (i ? " in " + i : "")),
        Mt.ERR_DEPRECATED
      );
    return i && !BS[o] && (BS[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + i + " and will be removed in the near future"
      )
    )), e ? e(a, o, l) : !0;
  };
};
lg.spelling = function(e) {
  return (i, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function Zk(r, e, i) {
  if (typeof r != "object")
    throw new Mt("options must be an object", Mt.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(r);
  let s = n.length;
  for (; s-- > 0; ) {
    const a = n[s], o = e[a];
    if (o) {
      const l = r[a], u = l === void 0 || o(l, a, r);
      if (u !== !0)
        throw new Mt("option " + a + " must be " + u, Mt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (i !== !0)
      throw new Mt("Unknown option " + a, Mt.ERR_BAD_OPTION);
  }
}
const zf = {
  assertOptions: Zk,
  validators: lg
}, os = zf.validators;
let gl = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new AS(),
      response: new AS()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, i) {
    try {
      return await this._request(e, i);
    } catch (n) {
      if (n instanceof Error) {
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const a = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? a && !String(n.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + a) : n.stack = a;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, i) {
    typeof e == "string" ? (i = i || {}, i.url = e) : i = e || {}, i = xl(this.defaults, i);
    const { transitional: n, paramsSerializer: s, headers: a } = i;
    n !== void 0 && zf.assertOptions(n, {
      silentJSONParsing: os.transitional(os.boolean),
      forcedJSONParsing: os.transitional(os.boolean),
      clarifyTimeoutError: os.transitional(os.boolean)
    }, !1), s != null && (he.isFunction(s) ? i.paramsSerializer = {
      serialize: s
    } : zf.assertOptions(s, {
      encode: os.function,
      serialize: os.function
    }, !0)), i.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? i.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : i.allowAbsoluteUrls = !0), zf.assertOptions(i, {
      baseUrl: os.spelling("baseURL"),
      withXsrfToken: os.spelling("withXSRFToken")
    }, !0), i.method = (i.method || this.defaults.method || "get").toLowerCase();
    let o = a && he.merge(
      a.common,
      a[i.method]
    );
    a && he.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (m) => {
        delete a[m];
      }
    ), i.headers = Gr.concat(o, a);
    const l = [];
    let u = !0;
    this.interceptors.request.forEach(function(v) {
      typeof v.runWhen == "function" && v.runWhen(i) === !1 || (u = u && v.synchronous, l.unshift(v.fulfilled, v.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(v) {
      c.push(v.fulfilled, v.rejected);
    });
    let h, d = 0, p;
    if (!u) {
      const m = [FS.bind(this), void 0];
      for (m.unshift(...l), m.push(...c), p = m.length, h = Promise.resolve(i); d < p; )
        h = h.then(m[d++], m[d++]);
      return h;
    }
    p = l.length;
    let f = i;
    for (d = 0; d < p; ) {
      const m = l[d++], v = l[d++];
      try {
        f = m(f);
      } catch (y) {
        v.call(this, y);
        break;
      }
    }
    try {
      h = FS.call(this, f);
    } catch (m) {
      return Promise.reject(m);
    }
    for (d = 0, p = c.length; d < p; )
      h = h.then(c[d++], c[d++]);
    return h;
  }
  getUri(e) {
    e = xl(this.defaults, e);
    const i = Q2(e.baseURL, e.url, e.allowAbsoluteUrls);
    return q2(i, e.params, e.paramsSerializer);
  }
};
he.forEach(["delete", "get", "head", "options"], function(e) {
  gl.prototype[e] = function(i, n) {
    return this.request(xl(n || {}, {
      method: e,
      url: i,
      data: (n || {}).data
    }));
  };
});
he.forEach(["post", "put", "patch"], function(e) {
  function i(n) {
    return function(a, o, l) {
      return this.request(xl(l || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: o
      }));
    };
  }
  gl.prototype[e] = i(), gl.prototype[e + "Form"] = i(!0);
});
let Jk = class rC {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let i;
    this.promise = new Promise(function(a) {
      i = a;
    });
    const n = this;
    this.promise.then((s) => {
      if (!n._listeners) return;
      let a = n._listeners.length;
      for (; a-- > 0; )
        n._listeners[a](s);
      n._listeners = null;
    }), this.promise.then = (s) => {
      let a;
      const o = new Promise((l) => {
        n.subscribe(l), a = l;
      }).then(s);
      return o.cancel = function() {
        n.unsubscribe(a);
      }, o;
    }, e(function(a, o, l) {
      n.reason || (n.reason = new Oc(a, o, l), i(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const i = this._listeners.indexOf(e);
    i !== -1 && this._listeners.splice(i, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), i = (n) => {
      e.abort(n);
    };
    return this.subscribe(i), e.signal.unsubscribe = () => this.unsubscribe(i), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new rC(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
function eL(r) {
  return function(i) {
    return r.apply(null, i);
  };
}
function tL(r) {
  return he.isObject(r) && r.isAxiosError === !0;
}
const Lv = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Lv).forEach(([r, e]) => {
  Lv[e] = r;
});
function nC(r) {
  const e = new gl(r), i = D2(gl.prototype.request, e);
  return he.extend(i, gl.prototype, e, { allOwnKeys: !0 }), he.extend(i, e, null, { allOwnKeys: !0 }), i.create = function(s) {
    return nC(xl(r, s));
  }, i;
}
const xi = nC(jd);
xi.Axios = gl;
xi.CanceledError = Oc;
xi.CancelToken = Jk;
xi.isCancel = $2;
xi.VERSION = iC;
xi.toFormData = og;
xi.AxiosError = Mt;
xi.Cancel = xi.CanceledError;
xi.all = function(e) {
  return Promise.all(e);
};
xi.spread = eL;
xi.isAxiosError = tL;
xi.mergeConfig = xl;
xi.AxiosHeaders = Gr;
xi.formToJSON = (r) => Y2(he.isHTMLForm(r) ? new FormData(r) : r);
xi.getAdapter = tC.getAdapter;
xi.HttpStatusCode = Lv;
xi.default = xi;
const {
  Axios: Foe,
  AxiosError: Boe,
  CanceledError: zoe,
  isCancel: joe,
  CancelToken: Voe,
  VERSION: Goe,
  all: Hoe,
  Cancel: Woe,
  isAxiosError: qoe,
  spread: Xoe,
  toFormData: Yoe,
  AxiosHeaders: $oe,
  HttpStatusCode: Koe,
  formToJSON: Qoe,
  getAdapter: Zoe,
  mergeConfig: Joe
} = xi, zS = (r) => {
  localStorage.setItem("auth_token", r);
}, d_ = () => localStorage.getItem("auth_token"), ug = () => !!d_(), iL = () => {
  localStorage.removeItem("auth_token");
}, p_ = () => {
  const r = d_();
  return r ? `Bearer ${r}` : "";
};
let Uv = null;
const cg = () => {
  if (!Uv)
    throw new Error(
      "Configuration Player-map non initialisée. Utilisez PlayerMapConfig.init() pour configurer la bibliothèque."
    );
  return { ...Uv };
}, rL = (r) => {
  if (!r.apiUrl)
    throw new Error("L'URL de l'API est requise pour initialiser Player-map");
  Uv = {
    apiUrl: r.apiUrl
  };
}, nL = async (r) => {
  try {
    const e = new FormData();
    if (e.append("file", r), !ug())
      throw new Error("Vous devez être connecté pour téléverser des fichiers");
    const { apiUrl: i } = cg(), n = `${i}/ipfs/upload_file`;
    return (await xi.post(
      n,
      e,
      {
        headers: {
          "Content-Type": "multipart/form-data",
          Authorization: p_()
        }
      }
    )).data.ipfs_url;
  } catch (e) {
    throw e instanceof Error && e.message.includes("Configuration Player-map non initialisée") ? (console.error("Erreur de configuration Player-map:", e.message), new Error("Erreur de configuration: Initialisez la bibliothèque Player-map avec PlayerMapConfig.init() avant utilisation")) : (console.error("Erreur lors du téléversement vers le serveur:", e), new Error("Échec du téléversement de l'image vers IPFS"));
  }
}, sC = (r) => r ? r.startsWith("ipfs://") : !1, sL = async (r) => {
  if (!sC(r)) return r;
  try {
    let e = sessionStorage.getItem("ipfs_gateway");
    if (!e) {
      if (!ug())
        throw new Error("Vous devez être connecté pour accéder à la passerelle IPFS");
      const { apiUrl: n } = cg();
      if (e = (await xi.get(
        `${n}/ipfs/gateway_url`,
        {
          headers: {
            Authorization: p_()
          }
        }
      )).data.gateway_url, e)
        sessionStorage.setItem("ipfs_gateway", e);
      else
        throw new Error("Aucune passerelle IPFS configurée");
    }
    const i = r.replace("ipfs://", "");
    return `https://${e}/ipfs/${i}`;
  } catch (e) {
    throw e instanceof Error && e.message.includes("Configuration Player-map non initialisée") ? (console.error("Erreur de configuration Player-map:", e.message), new Error("Erreur de configuration: Initialisez la bibliothèque Player-map avec PlayerMapConfig.init() avant utilisation")) : (console.error("Erreur lors de la récupération du gateway URL:", e), e);
  }
}, ii = {
  IS_PLAYER_GAMES: {
    predicateId: 0x05f1707d8cb50571d01021f09a664826aa1be2ff43504c0cca55eef87142f84fn,
    // predicat --> is player of !!!
    objectId: 0x5dc0a2335c12343d8e0f71b62a73fbf70d06fcbaf647f57d82a189873ad90da3n
    // object --> games (BossFighters)
  },
  IS_FAIRPLAY: {
    predicateId: 0x2af261bce70c2fc3a1abf882e3e89b23066fcd150bfda27fab69f9f55ed2d9d0n,
    // predicat --> is 
    objectId: 0xc9559c712c264e5f94ce450ed9473c451b6fd01ab6a436a726fbae767cd67b9cn
    // object --> fairplay !!!
  },
  IS_STRONG_BOSS: {
    predicateId: 0x2af261bce70c2fc3a1abf882e3e89b23066fcd150bfda27fab69f9f55ed2d9d0n,
    // predicat --> is 
    objectId: 0x56d28a901a7f2617247f1663b0c25c77ba6403a8141bac43b1e94eb32a2de941n
    // object --> strong boss !!!
  },
  IS_STRONG_FIGHTER: {
    predicateId: 0x2af261bce70c2fc3a1abf882e3e89b23066fcd150bfda27fab69f9f55ed2d9d0n,
    // predicat --> is 
    objectId: 0xc8433466cda62c0e8bb4fc5433f3faa51949072d6c7b0df50a595c95fb97f1bbn
    // object --> strong fighter !!!
  },
  IS_PLAYER_GUILD: {
    predicateId: 0x05f1707d8cb50571d01021f09a664826aa1be2ff43504c0cca55eef87142f84fn,
    // predicat --> is player of !!!
    objectId: null
    // Sera défini dynamiquement en fonction du choix de guilde
  }
}, aL = [
  { id: 0x4320ae619f6a9c9b79ee8e2a9415585aff1c287f0b72b08c049cf7a5780eb08dn, name: "The Alchemists" },
  // id --> The Alchemists !!!
  { id: 0x12d4b4425dcfeaf46af6543e8de0133f22f768a69d56a3aa28662ecb06aa9ca1n, name: "Big Time Warriors" },
  // id --> Big Time Warriors !!!
  { id: 0xd9e1d54c0cb904c23e04caea94f9d0dae00874ec18849ca74a832e94c6de01fan, name: "The NEST" },
  // id --> The NEST !!!
  { id: 0xd473ceacf850609ff8881c398e85e59aadbc315588ca78182313cc1af05a2800n, name: "Clock Work Gamers" },
  // id --> Clock Work Gamers !!!
  { id: 0x14511bc4065a1e7d67ba7d50d4706a8899a148a2e68b55213794c14e347acaaen, name: "Vast Impact Gaming" },
  // id --> Vast Impact Gaming !!!
  { id: 0x93815368a0d207e11be12da396d51dea4e3f8e637fe49f696648feb451f6f9c7n, name: "Kraken Gaming" },
  // id --> Kraken Gaming !!!
  { id: 0x508dee963f045411bd0bf4ab9433f40b72ca4270eb0f31222f299211cffbb0bcn, name: "FAM" }
  // id --> FAM
], oL = ({ src: r }) => {
  const [e, i] = Yt.useState(r), [n, s] = Yt.useState(!0);
  return Yt.useEffect(() => {
    (async () => {
      s(!0);
      try {
        const o = lL(r) ? uL(r) : r;
        i(o);
      } catch (o) {
        console.error("Error loading image:", o);
      } finally {
        s(!1);
      }
    })();
  }, [r]), n ? /* @__PURE__ */ ie.jsx("div", { children: "Loading image..." }) : /* @__PURE__ */ ie.jsx(
    "img",
    {
      src: e,
      alt: "Preview",
      style: {
        maxWidth: "100%",
        maxHeight: "150px",
        borderRadius: "5px"
      }
    }
  );
}, lL = (r) => r.startsWith("ipfs://"), uL = (r) => r.replace("ipfs://", "https://gateway.pinata.cloud/ipfs/"), cL = ({
  step: r,
  isCreatingAtom: e,
  isCreatingTriples: i,
  creationSuccess: n,
  atomId: s,
  tripleCreated: a,
  walletAddress: o,
  hasExistingAtom: l,
  formData: u,
  handleInputChange: c,
  handleSelectChange: h,
  handleFileUpload: d,
  handleSubmit: p,
  isLoading: f,
  isUploading: m,
  fileInputRef: v
}) => /* @__PURE__ */ ie.jsxs(ie.Fragment, { children: [
  /* @__PURE__ */ ie.jsxs("div", { style: { marginBottom: "20px" }, children: [
    /* @__PURE__ */ ie.jsxs(
      "div",
      {
        style: {
          display: "flex",
          justifyContent: "space-between",
          marginBottom: "10px"
        },
        children: [
          /* @__PURE__ */ ie.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
            /* @__PURE__ */ ie.jsx(
              "div",
              {
                style: {
                  width: "30px",
                  height: "30px",
                  borderRadius: "15px",
                  backgroundColor: e || r > 1 ? "#FFD32A" : "#2e2e40",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  margin: "0 auto",
                  color: e || r > 1 ? "#000" : "#fff"
                },
                children: r > 1 ? "✓" : "1"
              }
            ),
            /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Atom Creation" })
          ] }),
          /* @__PURE__ */ ie.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
            /* @__PURE__ */ ie.jsx(
              "div",
              {
                style: {
                  width: "30px",
                  height: "30px",
                  borderRadius: "15px",
                  backgroundColor: i || r > 2 ? "#FFD32A" : "#2e2e40",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  margin: "0 auto",
                  color: i || r > 2 ? "#000" : "#fff"
                },
                children: r > 2 ? "✓" : "2"
              }
            ),
            /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Triples Creation" })
          ] }),
          /* @__PURE__ */ ie.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
            /* @__PURE__ */ ie.jsx(
              "div",
              {
                style: {
                  width: "30px",
                  height: "30px",
                  borderRadius: "15px",
                  backgroundColor: r === 3 ? "#4CAF50" : "#2e2e40",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  margin: "0 auto",
                  color: r === 3 ? "#000" : "#fff"
                },
                children: r === 3 ? "✓" : "3"
              }
            ),
            /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Success" })
          ] })
        ]
      }
    ),
    /* @__PURE__ */ ie.jsx(
      "div",
      {
        style: {
          height: "4px",
          backgroundColor: "#2e2e40",
          position: "relative",
          marginBottom: "20px"
        },
        children: /* @__PURE__ */ ie.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: 0,
              top: 0,
              height: "100%",
              width: `${(r - 1) * 50}%`,
              backgroundColor: "#FFD32A",
              transition: "width 0.3s ease"
            }
          }
        )
      }
    )
  ] }),
  n ? /* @__PURE__ */ ie.jsxs("div", { style: { textAlign: "center", color: "#4CAF50" }, children: [
    /* @__PURE__ */ ie.jsx("h3", { style: { color: "#4CAF50", marginBottom: "10px" }, children: "Success!" }),
    /* @__PURE__ */ ie.jsx("p", { children: "Your player has been created successfully." }),
    /* @__PURE__ */ ie.jsxs("p", { children: [
      "Atom ID: ",
      s
    ] }),
    /* @__PURE__ */ ie.jsxs("p", { children: [
      "Triples created: ",
      a ? "Yes" : "No"
    ] }),
    /* @__PURE__ */ ie.jsx("p", { children: "This window will close automatically..." })
  ] }) : o ? l ? /* @__PURE__ */ ie.jsx("p", { style: { textAlign: "center", color: "#ff4444" }, children: "You already have an atom associated with this wallet" }) : /* @__PURE__ */ ie.jsxs(ie.Fragment, { children: [
    /* @__PURE__ */ ie.jsxs("div", { style: { marginBottom: "15px" }, children: [
      /* @__PURE__ */ ie.jsx(
        "label",
        {
          style: {
            display: "block",
            marginBottom: "5px",
            fontSize: "0.9em",
            textAlign: "left"
          },
          children: "Pseudo"
        }
      ),
      /* @__PURE__ */ ie.jsx(
        "input",
        {
          type: "text",
          name: "pseudo",
          value: u.pseudo,
          onChange: c,
          placeholder: "Enter your pseudo",
          style: {
            width: "100%",
            padding: "8px",
            backgroundColor: "#1e1e30",
            border: "1px solid #333",
            color: "#fff",
            borderRadius: "4px"
          }
        }
      )
    ] }),
    /* @__PURE__ */ ie.jsxs("div", { style: { marginBottom: "15px" }, children: [
      /* @__PURE__ */ ie.jsx(
        "label",
        {
          style: {
            display: "block",
            marginBottom: "5px",
            fontSize: "0.9em",
            textAlign: "left"
          },
          children: "User UID"
        }
      ),
      /* @__PURE__ */ ie.jsx(
        "input",
        {
          type: "text",
          name: "userId",
          value: u.userId,
          onChange: c,
          placeholder: "Enter your BossFighters UID",
          style: {
            width: "100%",
            padding: "8px",
            backgroundColor: "#1e1e30",
            border: "1px solid #333",
            color: "#fff",
            borderRadius: "4px"
          }
        }
      )
    ] }),
    /* @__PURE__ */ ie.jsxs("div", { style: { marginBottom: "15px" }, children: [
      /* @__PURE__ */ ie.jsx(
        "label",
        {
          style: {
            display: "block",
            marginBottom: "5px",
            fontSize: "0.9em",
            textAlign: "left"
          },
          children: "Guild (Optional)"
        }
      ),
      /* @__PURE__ */ ie.jsxs(
        "select",
        {
          name: "guildId",
          value: u.guildId || "",
          onChange: h,
          style: {
            width: "100%",
            padding: "8px",
            backgroundColor: "#1e1e30",
            border: "1px solid #333",
            color: "#fff",
            borderRadius: "4px"
          },
          children: [
            /* @__PURE__ */ ie.jsx("option", { value: "", children: "Select a guild (optional)" }),
            aL.map((y) => /* @__PURE__ */ ie.jsx("option", { value: y.id.toString(), children: y.name }, y.id.toString()))
          ]
        }
      )
    ] }),
    /* @__PURE__ */ ie.jsxs("div", { style: { marginBottom: "15px" }, children: [
      /* @__PURE__ */ ie.jsx(
        "label",
        {
          style: {
            display: "block",
            marginBottom: "5px",
            fontSize: "0.9em",
            textAlign: "left"
          },
          children: "Profile Picture (optional)"
        }
      ),
      /* @__PURE__ */ ie.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            gap: "10px"
          },
          children: [
            /* @__PURE__ */ ie.jsxs("div", { children: [
              /* @__PURE__ */ ie.jsx(
                "button",
                {
                  onClick: () => {
                    var y;
                    return (y = v.current) == null ? void 0 : y.click();
                  },
                  style: {
                    padding: "8px 15px",
                    backgroundColor: "#2e2e40",
                    color: "#fff",
                    border: "1px solid #333",
                    borderRadius: "4px",
                    cursor: "pointer",
                    marginRight: "10px"
                  },
                  disabled: m,
                  children: m ? "Upload in progress..." : "Choose an image"
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "input",
                {
                  ref: v,
                  type: "file",
                  accept: "image/*",
                  onChange: d,
                  style: { display: "none" }
                }
              )
            ] }),
            /* @__PURE__ */ ie.jsx(
              "p",
              {
                style: { fontSize: "0.8em", color: "#aaa", marginTop: "0px" },
                children: "This image will be used as your player's profile picture."
              }
            ),
            u.image && /* @__PURE__ */ ie.jsxs("div", { style: { marginTop: "10px" }, children: [
              /* @__PURE__ */ ie.jsx(
                "p",
                {
                  style: {
                    fontSize: "0.8em",
                    color: "#aaa",
                    marginBottom: "5px"
                  },
                  children: "Image preview:"
                }
              ),
              /* @__PURE__ */ ie.jsx(oL, { src: u.image })
            ] })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ ie.jsx("div", { style: { textAlign: "center" }, children: /* @__PURE__ */ ie.jsx(
      "button",
      {
        onClick: p,
        disabled: f || m,
        style: {
          padding: "8px 20px",
          backgroundColor: "#FFD32A",
          color: "#000",
          border: "none",
          borderRadius: "5px",
          cursor: "pointer",
          fontWeight: "bold",
          opacity: f || m ? 0.7 : 1
        },
        children: f ? e ? "Creating atom..." : i ? "Creating triples..." : "Creating in progress..." : "CREATE YOUR PLAYER"
      }
    ) })
  ] }) : /* @__PURE__ */ ie.jsx("div", { children: /* @__PURE__ */ ie.jsx("p", { style: { textAlign: "center", color: "#ff4444" }, children: "Please connect your wallet first" }) })
] }), hL = async (r) => {
  try {
    if (!ug())
      throw new Error("Vous devez être connecté pour envoyer des données à IPFS");
    const { apiUrl: e } = cg(), i = `${e}/ipfs/hash_data`, n = await xi.post(
      i,
      { data: r },
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: p_()
        }
      }
    );
    return {
      ipfsHash: n.data.ipfs_hash,
      httpUrl: n.data.http_url
    };
  } catch (e) {
    throw e instanceof Error && e.message.includes("Configuration Player-map non initialisée") ? (console.error("Erreur de configuration Player-map:", e.message), new Error("Erreur de configuration: Initialisez la bibliothèque Player-map avec PlayerMapConfig.init() avant utilisation")) : (console.error("Erreur lors du hachage de données vers IPFS:", e), e);
  }
}, dL = ({ walletConnected: r, walletAddress: e, publicClient: i }) => ({
  createAtom: async (s) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const a = {
        "@context": "https://schema.org/",
        "@type": "Thing",
        ...s
      };
      a.image && sC(a.image) && (a.image = await sL(a.image));
      const { ipfsHash: o } = await hL(a), l = v2(o);
      console.log("Contract address:", ml), console.log("VALUE_PER_ATOM:", iy.toString()), console.log("Hex data:", l);
      const u = l;
      console.log("Calculating atom ID using keccak256(encodePacked)...");
      const c = l_(AD(["bytes"], [u])), h = BigInt(c);
      console.log("Calculated atom ID:", h.toString()), console.log("Creating atom with createAtoms...");
      const d = await r.writeContract({
        address: ml,
        abi: qh,
        functionName: "createAtoms",
        args: [
          [u],
          // data: bytes[] - tableau avec un seul élément bytes
          [iy]
          // assets: uint256[] - tableau avec la valeur pour un atome
        ],
        value: iy
      });
      return console.log("Transaction hash:", d), console.log("Atom created successfully with ID:", h.toString()), {
        atomId: h,
        ipfsHash: o
      };
    } catch (a) {
      throw console.error("Error creating atom:", a), a;
    }
  }
}), pL = ({ walletConnected: r, walletAddress: e, publicClient: i }) => {
  const n = async (o, l, u) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const c = i || r;
      return !c || typeof c.readContract != "function" ? (console.warn("No valid read client available to check if triple exists"), !1) : await c.readContract({
        address: ml,
        abi: qh,
        functionName: "isTriple",
        args: [o, l, u]
      });
    } catch (c) {
      if (console.error("Error checking if triple exists:", c), i && i !== r && typeof i.readContract == "function")
        try {
          return await i.readContract({
            address: ml,
            abi: qh,
            functionName: "isTriple",
            args: [o, l, u]
          });
        } catch (h) {
          console.error("Second attempt failed when checking if triple exists:", h);
        }
      return !1;
    }
  }, s = async (o) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const l = o.map((f) => `0x${f.subjectId.toString(16).padStart(64, "0")}`), u = o.map((f) => `0x${f.predicateId.toString(16).padStart(64, "0")}`), c = o.map((f) => `0x${f.objectId.toString(16).padStart(64, "0")}`), h = o.map(() => SS), d = await r.writeContract({
        address: ml,
        abi: qh,
        functionName: "createTriples",
        // Changé de "batchCreateTriple" à "createTriples"
        args: [l, u, c, h],
        // Ajouté le paramètre assets
        value: SS * BigInt(o.length)
        // Valeur pour chaque triple
      });
      let p;
      return r.waitForTransactionReceipt ? p = await r.waitForTransactionReceipt({ hash: d }) : d.wait ? p = await d.wait() : await new Promise((f) => setTimeout(f, 3e3)), {
        hash: typeof d == "string" ? d : d.hash,
        receipt: p
      };
    } catch (l) {
      throw console.error("Error batch creating triples:", l), l;
    }
  };
  return {
    checkTripleExists: n,
    batchCreateTriple: s,
    createPlayerTriples: async (o) => {
      const l = [
        {
          subjectId: o,
          predicateId: ii.IS_PLAYER_GAMES.predicateId,
          objectId: ii.IS_PLAYER_GAMES.objectId
        },
        {
          subjectId: o,
          predicateId: ii.IS_FAIRPLAY.predicateId,
          objectId: ii.IS_FAIRPLAY.objectId
        },
        {
          subjectId: o,
          predicateId: ii.IS_STRONG_BOSS.predicateId,
          objectId: ii.IS_STRONG_BOSS.objectId
        },
        {
          subjectId: o,
          predicateId: ii.IS_STRONG_FIGHTER.predicateId,
          objectId: ii.IS_STRONG_FIGHTER.objectId
        }
      ];
      return s(l);
    }
  };
}, fL = (r, e, i) => {
  const { createAtom: n } = dL({ walletConnected: r, walletAddress: e, publicClient: i }), { batchCreateTriple: s } = pL({ walletConnected: r, walletAddress: e, publicClient: i });
  return {
    createPlayer: async (o) => {
      try {
        const l = await n({
          name: o.pseudo,
          description: o.userId,
          image: o.image
        }), u = l.atomId;
        await new Promise((c) => setTimeout(c, 2e3));
        try {
          const c = [
            {
              subjectId: u,
              predicateId: ii.IS_PLAYER_GAMES.predicateId,
              objectId: ii.IS_PLAYER_GAMES.objectId
            },
            {
              subjectId: u,
              predicateId: ii.IS_FAIRPLAY.predicateId,
              objectId: ii.IS_FAIRPLAY.objectId
            },
            {
              subjectId: u,
              predicateId: ii.IS_STRONG_BOSS.predicateId,
              objectId: ii.IS_STRONG_BOSS.objectId
            },
            {
              subjectId: u,
              predicateId: ii.IS_STRONG_FIGHTER.predicateId,
              objectId: ii.IS_STRONG_FIGHTER.objectId
            }
          ];
          o.guildId && c.push({
            subjectId: u,
            predicateId: ii.IS_PLAYER_GUILD.predicateId,
            objectId: o.guildId
          });
          const h = await s(c);
          return {
            atomId: u,
            ipfsHash: l.ipfsHash,
            tripleCreated: !0,
            transactionHash: h.hash
          };
        } catch (c) {
          return console.error("Erreur lors de la création des triples:", c), {
            atomId: u,
            ipfsHash: l.ipfsHash,
            tripleCreated: !1,
            transactionHash: void 0
          };
        }
      } catch (l) {
        throw console.error("Erreur lors de la création du joueur:", l), l;
      }
    }
  };
}, aC = ({ walletConnected: r, publicClient: e }) => {
  const [i, n] = ke(null), s = [13579], a = Number(CD);
  return ni(() => {
    (async () => {
      if (!(!r || !e))
        try {
          const l = await e.getChainId();
          n(Number(l));
        } catch (l) {
          console.error("Error checking network:", l), n(null);
        }
    })();
  }, [r, e]), {
    isCorrectNetwork: i !== null && s.includes(i),
    currentChainId: i,
    targetChainId: a,
    allowedChainIds: s
  };
}, oC = ({
  currentChainId: r,
  targetChainId: e,
  allowedChainIds: i = [13579]
}) => {
  const n = (s) => {
    switch (s) {
      case 13579:
        return "Intuition Testnet";
      default:
        return `Chain ID: ${s}`;
    }
  };
  return /* @__PURE__ */ ie.jsxs("div", { style: {
    padding: "15px",
    backgroundColor: "#2e2e40",
    borderRadius: "8px",
    margin: "10px 0",
    textAlign: "center"
  }, children: [
    /* @__PURE__ */ ie.jsx("p", { style: { color: "#ff4444", marginBottom: "10px" }, children: "You are not on the correct network" }),
    /* @__PURE__ */ ie.jsxs("p", { style: { color: "#aaa", fontSize: "0.9em", marginBottom: "10px" }, children: [
      "Current network: ",
      r ? n(r) : "Not connected",
      /* @__PURE__ */ ie.jsx("br", {}),
      "Required network: ",
      n(13579)
    ] }),
    /* @__PURE__ */ ie.jsx("p", { style: { color: "#fff", fontSize: "0.9em" }, children: "Please switch to Intuition Testnet (13579) in your wallet to continue" })
  ] });
}, lC = ({
  isOpen: r,
  onClose: e,
  walletConnected: i,
  walletAddress: n,
  wagmiConfig: s,
  walletHooks: a
}) => {
  const [o, l] = ke({
    pseudo: "",
    userId: "",
    image: "",
    guildId: ""
  }), [u, c] = ke(!1), [h, d] = ke(!1), [p, f] = ke(!1), [m, v] = ke(null), y = s == null ? void 0 : s.publicClient, [g, _] = ke(!1), x = gr(null), [b, T] = ke(1), [S, w] = ke(!1), [C, E] = ke(!1), [A, N] = ke(!1), { createPlayer: L } = fL(
    i,
    n || "",
    y
  ), { isCorrectNetwork: F, currentChainId: M, targetChainId: P } = aC({
    walletConnected: i,
    publicClient: s == null ? void 0 : s.publicClient
  });
  ni(() => {
    (async () => {
      if (!(!n || !y))
        try {
          const j = bD("AtomCreated(address,address,bytes,uint256)"), G = (await (await fetch("https://testnet.rpc.intuition.systems", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              jsonrpc: "2.0",
              method: "eth_getLogs",
              params: [{
                address: ml,
                topics: [
                  j,
                  n
                ],
                fromBlock: "0x0",
                toBlock: "latest"
              }],
              id: 1
            })
          })).json()).result || [];
          console.log("Found logs:", G.length), c(G.length > 0);
        } catch (j) {
          console.error("Error checking atom ownership:", j), c(!1);
        }
    })();
  }, [n, y]);
  const O = (U) => {
    const { name: j, value: Q } = U.target;
    l((q) => ({
      ...q,
      [j]: Q
    }));
  }, V = (U) => {
    const { name: j, value: Q } = U.target;
    l((q) => ({
      ...q,
      [j]: Q
    }));
  }, B = async (U) => {
    if (!U.target.files || U.target.files.length === 0)
      return;
    const j = U.target.files[0];
    try {
      _(!0);
      const Q = await nL(j);
      l((q) => ({
        ...q,
        image: Q
      })), _(!1);
    } catch (Q) {
      console.error("Error uploading image:", Q), alert("Error uploading image. Please try again."), _(!1);
    }
  }, H = async () => {
    if (!n || !i) {
      alert("Please connect your wallet first");
      return;
    }
    if (u) {
      alert("You already have an atom!");
      return;
    }
    if (!o.pseudo || !o.userId) {
      alert("Please fill in all fields");
      return;
    }
    try {
      d(!0), w(!0), T(1);
      const U = await L({
        pseudo: o.pseudo,
        userId: o.userId,
        image: o.image || void 0,
        guildId: o.guildId ? BigInt(o.guildId) : void 0
      });
      v(U.atomId.toString()), w(!1), T(2), E(!0), await new Promise((j) => setTimeout(j, 1500)), E(!1), N(U.tripleCreated), T(3), f(!0), d(!1), setTimeout(() => {
        e(), window.location.reload();
      }, 3e3);
    } catch (U) {
      console.error("Error creating player:", U), alert("Error creating player. Please try again."), d(!1), w(!1), E(!1);
    }
  };
  return r ? /* @__PURE__ */ ie.jsx(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(0, 0, 0, 0.7)",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        zIndex: 1e3
      },
      children: /* @__PURE__ */ ie.jsxs(
        "div",
        {
          style: {
            backgroundColor: "#101020",
            color: "#fff",
            padding: "30px",
            borderRadius: "10px",
            maxWidth: "760px",
            width: "90%",
            position: "relative",
            border: "1px solid #FFD32A"
          },
          children: [
            /* @__PURE__ */ ie.jsx(
              "div",
              {
                style: {
                  position: "absolute",
                  top: "40px",
                  right: "10px",
                  fontSize: "10px",
                  color: "#666",
                  textAlign: "left",
                  backgroundColor: "rgba(0,0,0,0.3)",
                  padding: "5px",
                  borderRadius: "3px",
                  maxWidth: "200px",
                  overflow: "hidden"
                },
                children: /* @__PURE__ */ ie.jsxs("div", { children: [
                  "Wallet:",
                  " ",
                  n ? n.slice(0, 6) + "..." + n.slice(-4) : "Not connected"
                ] })
              }
            ),
            /* @__PURE__ */ ie.jsx(
              "button",
              {
                onClick: e,
                style: {
                  position: "absolute",
                  top: "10px",
                  right: "10px",
                  backgroundColor: "transparent",
                  border: "none",
                  fontSize: "20px",
                  color: "#666",
                  cursor: "pointer"
                },
                children: "×"
              }
            ),
            /* @__PURE__ */ ie.jsx(
              "img",
              {
                src: f2,
                alt: "Intuition Logo",
                style: { width: "100px", marginBottom: "10px" }
              }
            ),
            /* @__PURE__ */ ie.jsx(
              "h2",
              {
                style: {
                  fontSize: "1.5em",
                  margin: "0 0 20px 0",
                  textAlign: "center"
                },
                children: "Create Your Player"
              }
            ),
            F ? /* @__PURE__ */ ie.jsx(
              cL,
              {
                step: b,
                isCreatingAtom: S,
                isCreatingTriples: C,
                creationSuccess: p,
                atomId: m,
                tripleCreated: A,
                walletAddress: n,
                hasExistingAtom: u,
                formData: o,
                handleInputChange: O,
                handleSelectChange: V,
                handleFileUpload: B,
                handleSubmit: H,
                isLoading: h,
                isUploading: g,
                fileInputRef: x
              }
            ) : /* @__PURE__ */ ie.jsx(
              oC,
              {
                currentChainId: M,
                targetChainId: P
              }
            )
          ]
        }
      )
    }
  ) : null;
};
var mL = Object.defineProperty, gL = (r, e, i) => e in r ? mL(r, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : r[e] = i, Xh = (r, e, i) => gL(r, typeof e != "symbol" ? e + "" : e, i);
function f_(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Fv = { exports: {} }, th = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jS;
function yL() {
  if (jS) return th;
  jS = 1;
  var r = Yt, e = Symbol.for("react.element"), i = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(l, u, c) {
    var h, d = {}, p = null, f = null;
    c !== void 0 && (p = "" + c), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (f = u.ref);
    for (h in u) n.call(u, h) && !a.hasOwnProperty(h) && (d[h] = u[h]);
    if (l && l.defaultProps) for (h in u = l.defaultProps, u) d[h] === void 0 && (d[h] = u[h]);
    return { $$typeof: e, type: l, key: p, ref: f, props: d, _owner: s.current };
  }
  return th.Fragment = i, th.jsx = o, th.jsxs = o, th;
}
var up = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VS;
function vL() {
  return VS || (VS = 1, process.env.NODE_ENV !== "production" && function() {
    var r = Yt, e = Symbol.for("react.element"), i = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), m = Symbol.iterator, v = "@@iterator";
    function y(R) {
      if (R === null || typeof R != "object")
        return null;
      var ee = m && R[m] || R[v];
      return typeof ee == "function" ? ee : null;
    }
    var g = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(R) {
      {
        for (var ee = arguments.length, ce = new Array(ee > 1 ? ee - 1 : 0), Ce = 1; Ce < ee; Ce++)
          ce[Ce - 1] = arguments[Ce];
        x("error", R, ce);
      }
    }
    function x(R, ee, ce) {
      {
        var Ce = g.ReactDebugCurrentFrame, Ze = Ce.getStackAddendum();
        Ze !== "" && (ee += "%s", ce = ce.concat([Ze]));
        var nt = ce.map(function($e) {
          return String($e);
        });
        nt.unshift("Warning: " + ee), Function.prototype.apply.call(console[R], console, nt);
      }
    }
    var b = !1, T = !1, S = !1, w = !1, C = !1, E;
    E = Symbol.for("react.module.reference");
    function A(R) {
      return !!(typeof R == "string" || typeof R == "function" || R === n || R === a || C || R === s || R === c || R === h || w || R === f || b || T || S || typeof R == "object" && R !== null && (R.$$typeof === p || R.$$typeof === d || R.$$typeof === o || R.$$typeof === l || R.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      R.$$typeof === E || R.getModuleId !== void 0));
    }
    function N(R, ee, ce) {
      var Ce = R.displayName;
      if (Ce)
        return Ce;
      var Ze = ee.displayName || ee.name || "";
      return Ze !== "" ? ce + "(" + Ze + ")" : ce;
    }
    function L(R) {
      return R.displayName || "Context";
    }
    function F(R) {
      if (R == null)
        return null;
      if (typeof R.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof R == "function")
        return R.displayName || R.name || null;
      if (typeof R == "string")
        return R;
      switch (R) {
        case n:
          return "Fragment";
        case i:
          return "Portal";
        case a:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case l:
            var ee = R;
            return L(ee) + ".Consumer";
          case o:
            var ce = R;
            return L(ce._context) + ".Provider";
          case u:
            return N(R, R.render, "ForwardRef");
          case d:
            var Ce = R.displayName || null;
            return Ce !== null ? Ce : F(R.type) || "Memo";
          case p: {
            var Ze = R, nt = Ze._payload, $e = Ze._init;
            try {
              return F($e(nt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var M = Object.assign, P = 0, O, V, B, H, U, j, Q;
    function q() {
    }
    q.__reactDisabledLog = !0;
    function G() {
      {
        if (P === 0) {
          O = console.log, V = console.info, B = console.warn, H = console.error, U = console.group, j = console.groupCollapsed, Q = console.groupEnd;
          var R = {
            configurable: !0,
            enumerable: !0,
            value: q,
            writable: !0
          };
          Object.defineProperties(console, {
            info: R,
            log: R,
            warn: R,
            error: R,
            group: R,
            groupCollapsed: R,
            groupEnd: R
          });
        }
        P++;
      }
    }
    function Y() {
      {
        if (P--, P === 0) {
          var R = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: M({}, R, {
              value: O
            }),
            info: M({}, R, {
              value: V
            }),
            warn: M({}, R, {
              value: B
            }),
            error: M({}, R, {
              value: H
            }),
            group: M({}, R, {
              value: U
            }),
            groupCollapsed: M({}, R, {
              value: j
            }),
            groupEnd: M({}, R, {
              value: Q
            })
          });
        }
        P < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ae = g.ReactCurrentDispatcher, ue;
    function ge(R, ee, ce) {
      {
        if (ue === void 0)
          try {
            throw Error();
          } catch (Ze) {
            var Ce = Ze.stack.trim().match(/\n( *(at )?)/);
            ue = Ce && Ce[1] || "";
          }
        return `
` + ue + R;
      }
    }
    var we = !1, Ne;
    {
      var lt = typeof WeakMap == "function" ? WeakMap : Map;
      Ne = new lt();
    }
    function be(R, ee) {
      if (!R || we)
        return "";
      {
        var ce = Ne.get(R);
        if (ce !== void 0)
          return ce;
      }
      var Ce;
      we = !0;
      var Ze = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var nt;
      nt = ae.current, ae.current = null, G();
      try {
        if (ee) {
          var $e = function() {
            throw Error();
          };
          if (Object.defineProperty($e.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct($e, []);
            } catch (Re) {
              Ce = Re;
            }
            Reflect.construct(R, [], $e);
          } else {
            try {
              $e.call();
            } catch (Re) {
              Ce = Re;
            }
            R.call($e.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Re) {
            Ce = Re;
          }
          R();
        }
      } catch (Re) {
        if (Re && Ce && typeof Re.stack == "string") {
          for (var We = Re.stack.split(`
`), k = Ce.stack.split(`
`), W = We.length - 1, te = k.length - 1; W >= 1 && te >= 0 && We[W] !== k[te]; )
            te--;
          for (; W >= 1 && te >= 0; W--, te--)
            if (We[W] !== k[te]) {
              if (W !== 1 || te !== 1)
                do
                  if (W--, te--, te < 0 || We[W] !== k[te]) {
                    var se = `
` + We[W].replace(" at new ", " at ");
                    return R.displayName && se.includes("<anonymous>") && (se = se.replace("<anonymous>", R.displayName)), typeof R == "function" && Ne.set(R, se), se;
                  }
                while (W >= 1 && te >= 0);
              break;
            }
        }
      } finally {
        we = !1, ae.current = nt, Y(), Error.prepareStackTrace = Ze;
      }
      var K = R ? R.displayName || R.name : "", Ee = K ? ge(K) : "";
      return typeof R == "function" && Ne.set(R, Ee), Ee;
    }
    function vt(R, ee, ce) {
      return be(R, !1);
    }
    function Z(R) {
      var ee = R.prototype;
      return !!(ee && ee.isReactComponent);
    }
    function Vt(R, ee, ce) {
      if (R == null)
        return "";
      if (typeof R == "function")
        return be(R, Z(R));
      if (typeof R == "string")
        return ge(R);
      switch (R) {
        case c:
          return ge("Suspense");
        case h:
          return ge("SuspenseList");
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case u:
            return vt(R.render);
          case d:
            return Vt(R.type, ee, ce);
          case p: {
            var Ce = R, Ze = Ce._payload, nt = Ce._init;
            try {
              return Vt(nt(Ze), ee, ce);
            } catch {
            }
          }
        }
      return "";
    }
    var ct = Object.prototype.hasOwnProperty, xt = {}, it = g.ReactDebugCurrentFrame;
    function Dt(R) {
      if (R) {
        var ee = R._owner, ce = Vt(R.type, R._source, ee ? ee.type : null);
        it.setExtraStackFrame(ce);
      } else
        it.setExtraStackFrame(null);
    }
    function at(R, ee, ce, Ce, Ze) {
      {
        var nt = Function.call.bind(ct);
        for (var $e in R)
          if (nt(R, $e)) {
            var We = void 0;
            try {
              if (typeof R[$e] != "function") {
                var k = Error((Ce || "React class") + ": " + ce + " type `" + $e + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof R[$e] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw k.name = "Invariant Violation", k;
              }
              We = R[$e](ee, $e, Ce, ce, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (W) {
              We = W;
            }
            We && !(We instanceof Error) && (Dt(Ze), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ce || "React class", ce, $e, typeof We), Dt(null)), We instanceof Error && !(We.message in xt) && (xt[We.message] = !0, Dt(Ze), _("Failed %s type: %s", ce, We.message), Dt(null));
          }
      }
    }
    var z = Array.isArray;
    function D(R) {
      return z(R);
    }
    function le(R) {
      {
        var ee = typeof Symbol == "function" && Symbol.toStringTag, ce = ee && R[Symbol.toStringTag] || R.constructor.name || "Object";
        return ce;
      }
    }
    function _e(R) {
      try {
        return Ae(R), !1;
      } catch {
        return !0;
      }
    }
    function Ae(R) {
      return "" + R;
    }
    function xe(R) {
      if (_e(R))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", le(R)), Ae(R);
    }
    var Qe = g.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, je, St;
    function Pe(R) {
      if (ct.call(R, "ref")) {
        var ee = Object.getOwnPropertyDescriptor(R, "ref").get;
        if (ee && ee.isReactWarning)
          return !1;
      }
      return R.ref !== void 0;
    }
    function Ye(R) {
      if (ct.call(R, "key")) {
        var ee = Object.getOwnPropertyDescriptor(R, "key").get;
        if (ee && ee.isReactWarning)
          return !1;
      }
      return R.key !== void 0;
    }
    function ut(R, ee) {
      typeof R.ref == "string" && Qe.current;
    }
    function Fe(R, ee) {
      {
        var ce = function() {
          je || (je = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ee));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "key", {
          get: ce,
          configurable: !0
        });
      }
    }
    function Xe(R, ee) {
      {
        var ce = function() {
          St || (St = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ee));
        };
        ce.isReactWarning = !0, Object.defineProperty(R, "ref", {
          get: ce,
          configurable: !0
        });
      }
    }
    var Ct = function(R, ee, ce, Ce, Ze, nt, $e) {
      var We = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: R,
        key: ee,
        ref: ce,
        props: $e,
        // Record the component responsible for creating this element.
        _owner: nt
      };
      return We._store = {}, Object.defineProperty(We._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(We, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ce
      }), Object.defineProperty(We, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ze
      }), Object.freeze && (Object.freeze(We.props), Object.freeze(We)), We;
    };
    function mt(R, ee, ce, Ce, Ze) {
      {
        var nt, $e = {}, We = null, k = null;
        ce !== void 0 && (xe(ce), We = "" + ce), Ye(ee) && (xe(ee.key), We = "" + ee.key), Pe(ee) && (k = ee.ref, ut(ee));
        for (nt in ee)
          ct.call(ee, nt) && !ze.hasOwnProperty(nt) && ($e[nt] = ee[nt]);
        if (R && R.defaultProps) {
          var W = R.defaultProps;
          for (nt in W)
            $e[nt] === void 0 && ($e[nt] = W[nt]);
        }
        if (We || k) {
          var te = typeof R == "function" ? R.displayName || R.name || "Unknown" : R;
          We && Fe($e, te), k && Xe($e, te);
        }
        return Ct(R, We, k, Ze, Ce, Qe.current, $e);
      }
    }
    var kt = g.ReactCurrentOwner, J = g.ReactDebugCurrentFrame;
    function Oe(R) {
      if (R) {
        var ee = R._owner, ce = Vt(R.type, R._source, ee ? ee.type : null);
        J.setExtraStackFrame(ce);
      } else
        J.setExtraStackFrame(null);
    }
    var de;
    de = !1;
    function Se(R) {
      return typeof R == "object" && R !== null && R.$$typeof === e;
    }
    function Ve() {
      {
        if (kt.current) {
          var R = F(kt.current.type);
          if (R)
            return `

Check the render method of \`` + R + "`.";
        }
        return "";
      }
    }
    function Ue(R) {
      return "";
    }
    var Rt = {};
    function si(R) {
      {
        var ee = Ve();
        if (!ee) {
          var ce = typeof R == "string" ? R : R.displayName || R.name;
          ce && (ee = `

Check the top-level render call using <` + ce + ">.");
        }
        return ee;
      }
    }
    function _i(R, ee) {
      {
        if (!R._store || R._store.validated || R.key != null)
          return;
        R._store.validated = !0;
        var ce = si(ee);
        if (Rt[ce])
          return;
        Rt[ce] = !0;
        var Ce = "";
        R && R._owner && R._owner !== kt.current && (Ce = " It was passed a child from " + F(R._owner.type) + "."), Oe(R), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ce, Ce), Oe(null);
      }
    }
    function Bt(R, ee) {
      {
        if (typeof R != "object")
          return;
        if (D(R))
          for (var ce = 0; ce < R.length; ce++) {
            var Ce = R[ce];
            Se(Ce) && _i(Ce, ee);
          }
        else if (Se(R))
          R._store && (R._store.validated = !0);
        else if (R) {
          var Ze = y(R);
          if (typeof Ze == "function" && Ze !== R.entries)
            for (var nt = Ze.call(R), $e; !($e = nt.next()).done; )
              Se($e.value) && _i($e.value, ee);
        }
      }
    }
    function yr(R) {
      {
        var ee = R.type;
        if (ee == null || typeof ee == "string")
          return;
        var ce;
        if (typeof ee == "function")
          ce = ee.propTypes;
        else if (typeof ee == "object" && (ee.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ee.$$typeof === d))
          ce = ee.propTypes;
        else
          return;
        if (ce) {
          var Ce = F(ee);
          at(ce, R.props, "prop", Ce, R);
        } else if (ee.PropTypes !== void 0 && !de) {
          de = !0;
          var Ze = F(ee);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ze || "Unknown");
        }
        typeof ee.getDefaultProps == "function" && !ee.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Kr(R) {
      {
        for (var ee = Object.keys(R.props), ce = 0; ce < ee.length; ce++) {
          var Ce = ee[ce];
          if (Ce !== "children" && Ce !== "key") {
            Oe(R), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ce), Oe(null);
            break;
          }
        }
        R.ref !== null && (Oe(R), _("Invalid attribute `ref` supplied to `React.Fragment`."), Oe(null));
      }
    }
    var Na = {};
    function Pa(R, ee, ce, Ce, Ze, nt) {
      {
        var $e = A(R);
        if (!$e) {
          var We = "";
          (R === void 0 || typeof R == "object" && R !== null && Object.keys(R).length === 0) && (We += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var k = Ue();
          k ? We += k : We += Ve();
          var W;
          R === null ? W = "null" : D(R) ? W = "array" : R !== void 0 && R.$$typeof === e ? (W = "<" + (F(R.type) || "Unknown") + " />", We = " Did you accidentally export a JSX literal instead of a component?") : W = typeof R, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", W, We);
        }
        var te = mt(R, ee, ce, Ze, nt);
        if (te == null)
          return te;
        if ($e) {
          var se = ee.children;
          if (se !== void 0)
            if (Ce)
              if (D(se)) {
                for (var K = 0; K < se.length; K++)
                  Bt(se[K], R);
                Object.freeze && Object.freeze(se);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Bt(se, R);
        }
        if (ct.call(ee, "key")) {
          var Ee = F(R), Re = Object.keys(ee).filter(function(yt) {
            return yt !== "key";
          }), Ke = Re.length > 0 ? "{key: someKey, " + Re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Na[Ee + Ke]) {
            var tt = Re.length > 0 ? "{" + Re.join(": ..., ") + ": ...}" : "{}";
            _(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ke, Ee, tt, Ee), Na[Ee + Ke] = !0;
          }
        }
        return R === n ? Kr(te) : yr(te), te;
      }
    }
    function Rn(R, ee, ce) {
      return Pa(R, ee, ce, !0);
    }
    function Co(R, ee, ce) {
      return Pa(R, ee, ce, !1);
    }
    var Fl = Co, Bl = Rn;
    up.Fragment = n, up.jsx = Fl, up.jsxs = Bl;
  }()), up;
}
process.env.NODE_ENV === "production" ? Fv.exports = yL() : Fv.exports = vL();
var I = Fv.exports;
const Ei = {
  SUBJECT: "#FFB300",
  // Jaune/orangé accessible
  PREDICATE: "#1976D2",
  // Bleu profond accessible
  OBJECT: "#43A047"
  // Vert foncé accessible
}, Ou = (r) => {
  switch (r) {
    case "subject":
      return Ei.SUBJECT;
    case "predicate":
      return Ei.PREDICATE;
    case "object":
      return Ei.OBJECT;
    default:
      return "#444";
  }
}, GS = () => /* @__PURE__ */ I.jsxs(
  "div",
  {
    style: {
      position: "absolute",
      bottom: 80,
      right: 30,
      zIndex: 1e3,
      background: "#18181b",
      borderRadius: "10px",
      border: "2px solid #ffd32a",
      padding: "16px 24px",
      boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)"
    },
    children: [
      /* @__PURE__ */ I.jsx(
        "h4",
        {
          style: {
            margin: "0 0 16px 0",
            fontSize: "18px",
            color: "#ffd32a",
            fontWeight: "bold",
            letterSpacing: "0.5px"
          },
          children: "Graph Legend"
        }
      ),
      /* @__PURE__ */ I.jsxs(
        "ul",
        {
          style: {
            listStyle: "none",
            padding: 0,
            margin: 0,
            display: "flex",
            flexDirection: "column",
            gap: "12px"
          },
          children: [
            /* @__PURE__ */ I.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ I.jsx(
                    "span",
                    {
                      style: {
                        width: "20px",
                        height: "20px",
                        backgroundColor: Ei.SUBJECT,
                        borderRadius: "50%",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ I.jsx("span", { style: { fontSize: "15px" }, children: "Subject" })
                ]
              }
            ),
            /* @__PURE__ */ I.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ I.jsx(
                    "span",
                    {
                      style: {
                        width: "20px",
                        height: "20px",
                        backgroundColor: Ei.OBJECT,
                        borderRadius: "4px",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ I.jsx("span", { style: { fontSize: "15px" }, children: "Object" })
                ]
              }
            ),
            /* @__PURE__ */ I.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ I.jsx(
                    "span",
                    {
                      style: {
                        width: "24px",
                        height: "12px",
                        backgroundColor: Ei.PREDICATE,
                        borderRadius: "4px",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ I.jsx("span", { style: { fontSize: "15px" }, children: "Predicate" })
                ]
              }
            )
          ]
        }
      )
    ]
  }
);
class Gu extends Error {
  constructor(e, i) {
    const n = `${Gu.extractMessage(e)}: ${JSON.stringify({
      response: e,
      request: i
    })}`;
    super(n), Xh(this, "response"), Xh(this, "request"), Object.setPrototypeOf(this, Gu.prototype), this.response = e, this.request = i, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, Gu);
  }
  static extractMessage(e) {
    var i, n;
    return ((n = (i = e.errors) == null ? void 0 : i[0]) == null ? void 0 : n.message) ?? `GraphQL Error (Code: ${String(e.status)})`;
  }
}
const HS = (r) => r.toUpperCase(), ay = (r) => typeof r == "function" ? r() : r, uC = (r, e) => r.map((i, n) => [i, e[n]]), jl = (r) => {
  let e = {};
  return r instanceof Headers ? e = bL(r) : Array.isArray(r) ? r.forEach(([i, n]) => {
    i && n !== void 0 && (e[i] = n);
  }) : r && (e = r), e;
}, bL = (r) => {
  const e = {};
  return r.forEach((i, n) => {
    e[n] = i;
  }), e;
}, xL = (r) => {
  try {
    const e = r();
    return _L(e) ? e.catch((i) => WS(i)) : e;
  } catch (e) {
    return WS(e);
  }
}, WS = (r) => r instanceof Error ? r : new Error(String(r)), _L = (r) => typeof r == "object" && r !== null && "then" in r && typeof r.then == "function" && "catch" in r && typeof r.catch == "function" && "finally" in r && typeof r.finally == "function", m_ = (r) => {
  throw new Error(`Unhandled case: ${String(r)}`);
}, jf = (r) => typeof r == "object" && r !== null && !Array.isArray(r), TL = (r, e) => r.documents ? r : {
  documents: r,
  requestHeaders: e,
  signal: void 0
}, SL = (r, e, i) => r.query ? r : {
  query: r,
  variables: e,
  requestHeaders: i,
  signal: void 0
};
function Vf(r, e) {
  throw new Error(e);
}
function wL(r) {
  return typeof r == "object" && r !== null;
}
function EL(r, e) {
  throw new Error(
    "Unexpected invariant triggered."
  );
}
const ML = /\r\n|[\n\r]/g;
function Bv(r, e) {
  let i = 0, n = 1;
  for (const s of r.body.matchAll(ML)) {
    if (typeof s.index == "number" || EL(), s.index >= e)
      break;
    i = s.index + s[0].length, n += 1;
  }
  return {
    line: n,
    column: e + 1 - i
  };
}
function AL(r) {
  return cC(
    r.source,
    Bv(r.source, r.start)
  );
}
function cC(r, e) {
  const i = r.locationOffset.column - 1, n = "".padStart(i) + r.body, s = e.line - 1, a = r.locationOffset.line - 1, o = e.line + a, l = e.line === 1 ? i : 0, u = e.column + l, c = `${r.name}:${o}:${u}
`, h = n.split(/\r\n|[\n\r]/g), d = h[s];
  if (d.length > 120) {
    const p = Math.floor(u / 80), f = u % 80, m = [];
    for (let v = 0; v < d.length; v += 80)
      m.push(d.slice(v, v + 80));
    return c + qS([
      [`${o} |`, m[0]],
      ...m.slice(1, p + 1).map((v) => ["|", v]),
      ["|", "^".padStart(f)],
      ["|", m[p + 1]]
    ]);
  }
  return c + qS([
    // Lines specified like this: ["prefix", "string"],
    [`${o - 1} |`, h[s - 1]],
    [`${o} |`, d],
    ["|", "^".padStart(u)],
    [`${o + 1} |`, h[s + 1]]
  ]);
}
function qS(r) {
  const e = r.filter(([n, s]) => s !== void 0), i = Math.max(...e.map(([n]) => n.length));
  return e.map(([n, s]) => n.padStart(i) + (s ? " " + s : "")).join(`
`);
}
function CL(r) {
  const e = r[0];
  return e == null || "kind" in e || "length" in e ? {
    nodes: e,
    source: r[1],
    positions: r[2],
    path: r[3],
    originalError: r[4],
    extensions: r[5]
  } : e;
}
class g_ extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(e, ...i) {
    var n, s, a;
    const { nodes: o, source: l, positions: u, path: c, originalError: h, extensions: d } = CL(i);
    super(e), this.name = "GraphQLError", this.path = c ?? void 0, this.originalError = h ?? void 0, this.nodes = XS(
      Array.isArray(o) ? o : o ? [o] : void 0
    );
    const p = XS(
      (n = this.nodes) === null || n === void 0 ? void 0 : n.map((m) => m.loc).filter((m) => m != null)
    );
    this.source = l ?? (p == null || (s = p[0]) === null || s === void 0 ? void 0 : s.source), this.positions = u ?? (p == null ? void 0 : p.map((m) => m.start)), this.locations = u && l ? u.map((m) => Bv(l, m)) : p == null ? void 0 : p.map((m) => Bv(m.source, m.start));
    const f = wL(
      h == null ? void 0 : h.extensions
    ) ? h == null ? void 0 : h.extensions : void 0;
    this.extensions = (a = d ?? f) !== null && a !== void 0 ? a : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), h != null && h.stack ? Object.defineProperty(this, "stack", {
      value: h.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, g_) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let e = this.message;
    if (this.nodes)
      for (const i of this.nodes)
        i.loc && (e += `

` + AL(i.loc));
    else if (this.source && this.locations)
      for (const i of this.locations)
        e += `

` + cC(this.source, i);
    return e;
  }
  toJSON() {
    const e = {
      message: this.message
    };
    return this.locations != null && (e.locations = this.locations), this.path != null && (e.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (e.extensions = this.extensions), e;
  }
}
function XS(r) {
  return r === void 0 || r.length === 0 ? void 0 : r;
}
function Yi(r, e, i) {
  return new g_(`Syntax Error: ${i}`, {
    source: r,
    positions: [e]
  });
}
class RL {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(e, i, n) {
    this.start = e.start, this.end = i.end, this.startToken = e, this.endToken = i, this.source = n;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class hC {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(e, i, n, s, a, o) {
    this.kind = e, this.start = i, this.end = n, this.line = s, this.column = a, this.value = o, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const dC = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, NL = new Set(Object.keys(dC));
function YS(r) {
  const e = r == null ? void 0 : r.kind;
  return typeof e == "string" && NL.has(e);
}
var rl;
(function(r) {
  r.QUERY = "query", r.MUTATION = "mutation", r.SUBSCRIPTION = "subscription";
})(rl || (rl = {}));
var zv;
(function(r) {
  r.QUERY = "QUERY", r.MUTATION = "MUTATION", r.SUBSCRIPTION = "SUBSCRIPTION", r.FIELD = "FIELD", r.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", r.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", r.INLINE_FRAGMENT = "INLINE_FRAGMENT", r.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", r.SCHEMA = "SCHEMA", r.SCALAR = "SCALAR", r.OBJECT = "OBJECT", r.FIELD_DEFINITION = "FIELD_DEFINITION", r.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", r.INTERFACE = "INTERFACE", r.UNION = "UNION", r.ENUM = "ENUM", r.ENUM_VALUE = "ENUM_VALUE", r.INPUT_OBJECT = "INPUT_OBJECT", r.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(zv || (zv = {}));
var ft;
(function(r) {
  r.NAME = "Name", r.DOCUMENT = "Document", r.OPERATION_DEFINITION = "OperationDefinition", r.VARIABLE_DEFINITION = "VariableDefinition", r.SELECTION_SET = "SelectionSet", r.FIELD = "Field", r.ARGUMENT = "Argument", r.FRAGMENT_SPREAD = "FragmentSpread", r.INLINE_FRAGMENT = "InlineFragment", r.FRAGMENT_DEFINITION = "FragmentDefinition", r.VARIABLE = "Variable", r.INT = "IntValue", r.FLOAT = "FloatValue", r.STRING = "StringValue", r.BOOLEAN = "BooleanValue", r.NULL = "NullValue", r.ENUM = "EnumValue", r.LIST = "ListValue", r.OBJECT = "ObjectValue", r.OBJECT_FIELD = "ObjectField", r.DIRECTIVE = "Directive", r.NAMED_TYPE = "NamedType", r.LIST_TYPE = "ListType", r.NON_NULL_TYPE = "NonNullType", r.SCHEMA_DEFINITION = "SchemaDefinition", r.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", r.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", r.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", r.FIELD_DEFINITION = "FieldDefinition", r.INPUT_VALUE_DEFINITION = "InputValueDefinition", r.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", r.UNION_TYPE_DEFINITION = "UnionTypeDefinition", r.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", r.ENUM_VALUE_DEFINITION = "EnumValueDefinition", r.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", r.DIRECTIVE_DEFINITION = "DirectiveDefinition", r.SCHEMA_EXTENSION = "SchemaExtension", r.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", r.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", r.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", r.UNION_TYPE_EXTENSION = "UnionTypeExtension", r.ENUM_TYPE_EXTENSION = "EnumTypeExtension", r.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(ft || (ft = {}));
function jv(r) {
  return r === 9 || r === 32;
}
function ud(r) {
  return r >= 48 && r <= 57;
}
function pC(r) {
  return r >= 97 && r <= 122 || // A-Z
  r >= 65 && r <= 90;
}
function fC(r) {
  return pC(r) || r === 95;
}
function PL(r) {
  return pC(r) || ud(r) || r === 95;
}
function OL(r) {
  var e;
  let i = Number.MAX_SAFE_INTEGER, n = null, s = -1;
  for (let o = 0; o < r.length; ++o) {
    var a;
    const l = r[o], u = IL(l);
    u !== l.length && (n = (a = n) !== null && a !== void 0 ? a : o, s = o, o !== 0 && u < i && (i = u));
  }
  return r.map((o, l) => l === 0 ? o : o.slice(i)).slice(
    (e = n) !== null && e !== void 0 ? e : 0,
    s + 1
  );
}
function IL(r) {
  let e = 0;
  for (; e < r.length && jv(r.charCodeAt(e)); )
    ++e;
  return e;
}
function DL(r, e) {
  const i = r.replace(/"""/g, '\\"""'), n = i.split(/\r\n|[\n\r]/g), s = n.length === 1, a = n.length > 1 && n.slice(1).every((f) => f.length === 0 || jv(f.charCodeAt(0))), o = i.endsWith('\\"""'), l = r.endsWith('"') && !o, u = r.endsWith("\\"), c = l || u, h = (
    // add leading and trailing new lines only if it improves readability
    !s || r.length > 70 || c || a || o
  );
  let d = "";
  const p = s && jv(r.charCodeAt(0));
  return (h && !p || a) && (d += `
`), d += i, (h || c) && (d += `
`), '"""' + d + '"""';
}
var Te;
(function(r) {
  r.SOF = "<SOF>", r.EOF = "<EOF>", r.BANG = "!", r.DOLLAR = "$", r.AMP = "&", r.PAREN_L = "(", r.PAREN_R = ")", r.SPREAD = "...", r.COLON = ":", r.EQUALS = "=", r.AT = "@", r.BRACKET_L = "[", r.BRACKET_R = "]", r.BRACE_L = "{", r.PIPE = "|", r.BRACE_R = "}", r.NAME = "Name", r.INT = "Int", r.FLOAT = "Float", r.STRING = "String", r.BLOCK_STRING = "BlockString", r.COMMENT = "Comment";
})(Te || (Te = {}));
class kL {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(e) {
    const i = new hC(Te.SOF, 0, 0, 0, 0);
    this.source = e, this.lastToken = i, this.token = i, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let e = this.token;
    if (e.kind !== Te.EOF)
      do
        if (e.next)
          e = e.next;
        else {
          const i = UL(this, e.end);
          e.next = i, i.prev = e, e = i;
        }
      while (e.kind === Te.COMMENT);
    return e;
  }
}
function LL(r) {
  return r === Te.BANG || r === Te.DOLLAR || r === Te.AMP || r === Te.PAREN_L || r === Te.PAREN_R || r === Te.SPREAD || r === Te.COLON || r === Te.EQUALS || r === Te.AT || r === Te.BRACKET_L || r === Te.BRACKET_R || r === Te.BRACE_L || r === Te.PIPE || r === Te.BRACE_R;
}
function Ic(r) {
  return r >= 0 && r <= 55295 || r >= 57344 && r <= 1114111;
}
function hg(r, e) {
  return mC(r.charCodeAt(e)) && gC(r.charCodeAt(e + 1));
}
function mC(r) {
  return r >= 55296 && r <= 56319;
}
function gC(r) {
  return r >= 56320 && r <= 57343;
}
function _l(r, e) {
  const i = r.source.body.codePointAt(e);
  if (i === void 0)
    return Te.EOF;
  if (i >= 32 && i <= 126) {
    const n = String.fromCodePoint(i);
    return n === '"' ? `'"'` : `"${n}"`;
  }
  return "U+" + i.toString(16).toUpperCase().padStart(4, "0");
}
function Di(r, e, i, n, s) {
  const a = r.line, o = 1 + i - r.lineStart;
  return new hC(e, i, n, a, o, s);
}
function UL(r, e) {
  const i = r.source.body, n = i.length;
  let s = e;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    switch (a) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++s;
        continue;
      case 10:
        ++s, ++r.line, r.lineStart = s;
        continue;
      case 13:
        i.charCodeAt(s + 1) === 10 ? s += 2 : ++s, ++r.line, r.lineStart = s;
        continue;
      case 35:
        return FL(r, s);
      case 33:
        return Di(r, Te.BANG, s, s + 1);
      case 36:
        return Di(r, Te.DOLLAR, s, s + 1);
      case 38:
        return Di(r, Te.AMP, s, s + 1);
      case 40:
        return Di(r, Te.PAREN_L, s, s + 1);
      case 41:
        return Di(r, Te.PAREN_R, s, s + 1);
      case 46:
        if (i.charCodeAt(s + 1) === 46 && i.charCodeAt(s + 2) === 46)
          return Di(r, Te.SPREAD, s, s + 3);
        break;
      case 58:
        return Di(r, Te.COLON, s, s + 1);
      case 61:
        return Di(r, Te.EQUALS, s, s + 1);
      case 64:
        return Di(r, Te.AT, s, s + 1);
      case 91:
        return Di(r, Te.BRACKET_L, s, s + 1);
      case 93:
        return Di(r, Te.BRACKET_R, s, s + 1);
      case 123:
        return Di(r, Te.BRACE_L, s, s + 1);
      case 124:
        return Di(r, Te.PIPE, s, s + 1);
      case 125:
        return Di(r, Te.BRACE_R, s, s + 1);
      case 34:
        return i.charCodeAt(s + 1) === 34 && i.charCodeAt(s + 2) === 34 ? HL(r, s) : zL(r, s);
    }
    if (ud(a) || a === 45)
      return BL(r, s, a);
    if (fC(a))
      return WL(r, s);
    throw Yi(
      r.source,
      s,
      a === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Ic(a) || hg(i, s) ? `Unexpected character: ${_l(r, s)}.` : `Invalid character: ${_l(r, s)}.`
    );
  }
  return Di(r, Te.EOF, n, n);
}
function FL(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    if (a === 10 || a === 13)
      break;
    if (Ic(a))
      ++s;
    else if (hg(i, s))
      s += 2;
    else
      break;
  }
  return Di(
    r,
    Te.COMMENT,
    e,
    s,
    i.slice(e + 1, s)
  );
}
function BL(r, e, i) {
  const n = r.source.body;
  let s = e, a = i, o = !1;
  if (a === 45 && (a = n.charCodeAt(++s)), a === 48) {
    if (a = n.charCodeAt(++s), ud(a))
      throw Yi(
        r.source,
        s,
        `Invalid number, unexpected digit after 0: ${_l(
          r,
          s
        )}.`
      );
  } else
    s = oy(r, s, a), a = n.charCodeAt(s);
  if (a === 46 && (o = !0, a = n.charCodeAt(++s), s = oy(r, s, a), a = n.charCodeAt(s)), (a === 69 || a === 101) && (o = !0, a = n.charCodeAt(++s), (a === 43 || a === 45) && (a = n.charCodeAt(++s)), s = oy(r, s, a), a = n.charCodeAt(s)), a === 46 || fC(a))
    throw Yi(
      r.source,
      s,
      `Invalid number, expected digit but got: ${_l(
        r,
        s
      )}.`
    );
  return Di(
    r,
    o ? Te.FLOAT : Te.INT,
    e,
    s,
    n.slice(e, s)
  );
}
function oy(r, e, i) {
  if (!ud(i))
    throw Yi(
      r.source,
      e,
      `Invalid number, expected digit but got: ${_l(
        r,
        e
      )}.`
    );
  const n = r.source.body;
  let s = e + 1;
  for (; ud(n.charCodeAt(s)); )
    ++s;
  return s;
}
function zL(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1, a = s, o = "";
  for (; s < n; ) {
    const l = i.charCodeAt(s);
    if (l === 34)
      return o += i.slice(a, s), Di(r, Te.STRING, e, s + 1, o);
    if (l === 92) {
      o += i.slice(a, s);
      const u = i.charCodeAt(s + 1) === 117 ? i.charCodeAt(s + 2) === 123 ? jL(r, s) : VL(r, s) : GL(r, s);
      o += u.value, s += u.size, a = s;
      continue;
    }
    if (l === 10 || l === 13)
      break;
    if (Ic(l))
      ++s;
    else if (hg(i, s))
      s += 2;
    else
      throw Yi(
        r.source,
        s,
        `Invalid character within String: ${_l(
          r,
          s
        )}.`
      );
  }
  throw Yi(r.source, s, "Unterminated string.");
}
function jL(r, e) {
  const i = r.source.body;
  let n = 0, s = 3;
  for (; s < 12; ) {
    const a = i.charCodeAt(e + s++);
    if (a === 125) {
      if (s < 5 || !Ic(n))
        break;
      return {
        value: String.fromCodePoint(n),
        size: s
      };
    }
    if (n = n << 4 | Lh(a), n < 0)
      break;
  }
  throw Yi(
    r.source,
    e,
    `Invalid Unicode escape sequence: "${i.slice(
      e,
      e + s
    )}".`
  );
}
function VL(r, e) {
  const i = r.source.body, n = $S(i, e + 2);
  if (Ic(n))
    return {
      value: String.fromCodePoint(n),
      size: 6
    };
  if (mC(n) && i.charCodeAt(e + 6) === 92 && i.charCodeAt(e + 7) === 117) {
    const s = $S(i, e + 8);
    if (gC(s))
      return {
        value: String.fromCodePoint(n, s),
        size: 12
      };
  }
  throw Yi(
    r.source,
    e,
    `Invalid Unicode escape sequence: "${i.slice(e, e + 6)}".`
  );
}
function $S(r, e) {
  return Lh(r.charCodeAt(e)) << 12 | Lh(r.charCodeAt(e + 1)) << 8 | Lh(r.charCodeAt(e + 2)) << 4 | Lh(r.charCodeAt(e + 3));
}
function Lh(r) {
  return r >= 48 && r <= 57 ? r - 48 : r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : -1;
}
function GL(r, e) {
  const i = r.source.body;
  switch (i.charCodeAt(e + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw Yi(
    r.source,
    e,
    `Invalid character escape sequence: "${i.slice(
      e,
      e + 2
    )}".`
  );
}
function HL(r, e) {
  const i = r.source.body, n = i.length;
  let s = r.lineStart, a = e + 3, o = a, l = "";
  const u = [];
  for (; a < n; ) {
    const c = i.charCodeAt(a);
    if (c === 34 && i.charCodeAt(a + 1) === 34 && i.charCodeAt(a + 2) === 34) {
      l += i.slice(o, a), u.push(l);
      const h = Di(
        r,
        Te.BLOCK_STRING,
        e,
        a + 3,
        // Return a string of the lines joined with U+000A.
        OL(u).join(`
`)
      );
      return r.line += u.length - 1, r.lineStart = s, h;
    }
    if (c === 92 && i.charCodeAt(a + 1) === 34 && i.charCodeAt(a + 2) === 34 && i.charCodeAt(a + 3) === 34) {
      l += i.slice(o, a), o = a + 1, a += 4;
      continue;
    }
    if (c === 10 || c === 13) {
      l += i.slice(o, a), u.push(l), c === 13 && i.charCodeAt(a + 1) === 10 ? a += 2 : ++a, l = "", o = a, s = a;
      continue;
    }
    if (Ic(c))
      ++a;
    else if (hg(i, a))
      a += 2;
    else
      throw Yi(
        r.source,
        a,
        `Invalid character within String: ${_l(
          r,
          a
        )}.`
      );
  }
  throw Yi(r.source, a, "Unterminated string.");
}
function WL(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    if (PL(a))
      ++s;
    else
      break;
  }
  return Di(
    r,
    Te.NAME,
    e,
    s,
    i.slice(e, s)
  );
}
const qL = 10, yC = 2;
function y_(r) {
  return dg(r, []);
}
function dg(r, e) {
  switch (typeof r) {
    case "string":
      return JSON.stringify(r);
    case "function":
      return r.name ? `[function ${r.name}]` : "[function]";
    case "object":
      return XL(r, e);
    default:
      return String(r);
  }
}
function XL(r, e) {
  if (r === null)
    return "null";
  if (e.includes(r))
    return "[Circular]";
  const i = [...e, r];
  if (YL(r)) {
    const n = r.toJSON();
    if (n !== r)
      return typeof n == "string" ? n : dg(n, i);
  } else if (Array.isArray(r))
    return KL(r, i);
  return $L(r, i);
}
function YL(r) {
  return typeof r.toJSON == "function";
}
function $L(r, e) {
  const i = Object.entries(r);
  return i.length === 0 ? "{}" : e.length > yC ? "[" + QL(r) + "]" : "{ " + i.map(
    ([n, s]) => n + ": " + dg(s, e)
  ).join(", ") + " }";
}
function KL(r, e) {
  if (r.length === 0)
    return "[]";
  if (e.length > yC)
    return "[Array]";
  const i = Math.min(qL, r.length), n = r.length - i, s = [];
  for (let a = 0; a < i; ++a)
    s.push(dg(r[a], e));
  return n === 1 ? s.push("... 1 more item") : n > 1 && s.push(`... ${n} more items`), "[" + s.join(", ") + "]";
}
function QL(r) {
  const e = Object.prototype.toString.call(r).replace(/^\[object /, "").replace(/]$/, "");
  if (e === "Object" && typeof r.constructor == "function") {
    const i = r.constructor.name;
    if (typeof i == "string" && i !== "")
      return i;
  }
  return e;
}
const ZL = globalThis.process && // eslint-disable-next-line no-undef
process.env.NODE_ENV === "production", JL = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  ZL ? function(r, e) {
    return r instanceof e;
  } : function(r, e) {
    if (r instanceof e)
      return !0;
    if (typeof r == "object" && r !== null) {
      var i;
      const n = e.prototype[Symbol.toStringTag], s = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in r ? r[Symbol.toStringTag] : (i = r.constructor) === null || i === void 0 ? void 0 : i.name
      );
      if (n === s) {
        const a = y_(r);
        throw new Error(`Cannot use ${n} "${a}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
let vC = class {
  constructor(r, e = "GraphQL request", i = {
    line: 1,
    column: 1
  }) {
    typeof r == "string" || Vf(!1, `Body must be a string. Received: ${y_(r)}.`), this.body = r, this.name = e, this.locationOffset = i, this.locationOffset.line > 0 || Vf(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || Vf(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function eU(r) {
  return JL(r, vC);
}
function tU(r, e) {
  const i = new iU(r, e), n = i.parseDocument();
  return Object.defineProperty(n, "tokenCount", {
    enumerable: !1,
    value: i.tokenCount
  }), n;
}
class iU {
  constructor(e, i = {}) {
    const n = eU(e) ? e : new vC(e);
    this._lexer = new kL(n), this._options = i, this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const e = this.expectToken(Te.NAME);
    return this.node(e, {
      kind: ft.NAME,
      value: e.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: ft.DOCUMENT,
      definitions: this.many(
        Te.SOF,
        this.parseDefinition,
        Te.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(Te.BRACE_L))
      return this.parseOperationDefinition();
    const e = this.peekDescription(), i = e ? this._lexer.lookahead() : this._lexer.token;
    if (i.kind === Te.NAME) {
      switch (i.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (e)
        throw Yi(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (i.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(i);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const e = this._lexer.token;
    if (this.peek(Te.BRACE_L))
      return this.node(e, {
        kind: ft.OPERATION_DEFINITION,
        operation: rl.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const i = this.parseOperationType();
    let n;
    return this.peek(Te.NAME) && (n = this.parseName()), this.node(e, {
      kind: ft.OPERATION_DEFINITION,
      operation: i,
      name: n,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const e = this.expectToken(Te.NAME);
    switch (e.value) {
      case "query":
        return rl.QUERY;
      case "mutation":
        return rl.MUTATION;
      case "subscription":
        return rl.SUBSCRIPTION;
    }
    throw this.unexpected(e);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      Te.PAREN_L,
      this.parseVariableDefinition,
      Te.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: ft.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(Te.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(Te.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const e = this._lexer.token;
    return this.expectToken(Te.DOLLAR), this.node(e, {
      kind: ft.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: ft.SELECTION_SET,
      selections: this.many(
        Te.BRACE_L,
        this.parseSelection,
        Te.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(Te.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const e = this._lexer.token, i = this.parseName();
    let n, s;
    return this.expectOptionalToken(Te.COLON) ? (n = i, s = this.parseName()) : s = i, this.node(e, {
      kind: ft.FIELD,
      alias: n,
      name: s,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(Te.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(e) {
    const i = e ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(Te.PAREN_L, i, Te.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(e = !1) {
    const i = this._lexer.token, n = this.parseName();
    return this.expectToken(Te.COLON), this.node(i, {
      kind: ft.ARGUMENT,
      name: n,
      value: this.parseValueLiteral(e)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const e = this._lexer.token;
    this.expectToken(Te.SPREAD);
    const i = this.expectOptionalKeyword("on");
    return !i && this.peek(Te.NAME) ? this.node(e, {
      kind: ft.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(e, {
      kind: ft.INLINE_FRAGMENT,
      typeCondition: i ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const e = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(e, {
      kind: ft.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(e, {
      kind: ft.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(e) {
    const i = this._lexer.token;
    switch (i.kind) {
      case Te.BRACKET_L:
        return this.parseList(e);
      case Te.BRACE_L:
        return this.parseObject(e);
      case Te.INT:
        return this.advanceLexer(), this.node(i, {
          kind: ft.INT,
          value: i.value
        });
      case Te.FLOAT:
        return this.advanceLexer(), this.node(i, {
          kind: ft.FLOAT,
          value: i.value
        });
      case Te.STRING:
      case Te.BLOCK_STRING:
        return this.parseStringLiteral();
      case Te.NAME:
        switch (this.advanceLexer(), i.value) {
          case "true":
            return this.node(i, {
              kind: ft.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(i, {
              kind: ft.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(i, {
              kind: ft.NULL
            });
          default:
            return this.node(i, {
              kind: ft.ENUM,
              value: i.value
            });
        }
      case Te.DOLLAR:
        if (e)
          if (this.expectToken(Te.DOLLAR), this._lexer.token.kind === Te.NAME) {
            const n = this._lexer.token.value;
            throw Yi(
              this._lexer.source,
              i.start,
              `Unexpected variable "$${n}" in constant value.`
            );
          } else
            throw this.unexpected(i);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const e = this._lexer.token;
    return this.advanceLexer(), this.node(e, {
      kind: ft.STRING,
      value: e.value,
      block: e.kind === Te.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(e) {
    const i = () => this.parseValueLiteral(e);
    return this.node(this._lexer.token, {
      kind: ft.LIST,
      values: this.any(Te.BRACKET_L, i, Te.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(e) {
    const i = () => this.parseObjectField(e);
    return this.node(this._lexer.token, {
      kind: ft.OBJECT,
      fields: this.any(Te.BRACE_L, i, Te.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(e) {
    const i = this._lexer.token, n = this.parseName();
    return this.expectToken(Te.COLON), this.node(i, {
      kind: ft.OBJECT_FIELD,
      name: n,
      value: this.parseValueLiteral(e)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(e) {
    const i = [];
    for (; this.peek(Te.AT); )
      i.push(this.parseDirective(e));
    return i;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(e) {
    const i = this._lexer.token;
    return this.expectToken(Te.AT), this.node(i, {
      kind: ft.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(e)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const e = this._lexer.token;
    let i;
    if (this.expectOptionalToken(Te.BRACKET_L)) {
      const n = this.parseTypeReference();
      this.expectToken(Te.BRACKET_R), i = this.node(e, {
        kind: ft.LIST_TYPE,
        type: n
      });
    } else
      i = this.parseNamedType();
    return this.expectOptionalToken(Te.BANG) ? this.node(e, {
      kind: ft.NON_NULL_TYPE,
      type: i
    }) : i;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: ft.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(Te.STRING) || this.peek(Te.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("schema");
    const n = this.parseConstDirectives(), s = this.many(
      Te.BRACE_L,
      this.parseOperationTypeDefinition,
      Te.BRACE_R
    );
    return this.node(e, {
      kind: ft.SCHEMA_DEFINITION,
      description: i,
      directives: n,
      operationTypes: s
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const e = this._lexer.token, i = this.parseOperationType();
    this.expectToken(Te.COLON);
    const n = this.parseNamedType();
    return this.node(e, {
      kind: ft.OPERATION_TYPE_DEFINITION,
      operation: i,
      type: n
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("scalar");
    const n = this.parseName(), s = this.parseConstDirectives();
    return this.node(e, {
      kind: ft.SCALAR_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("type");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(e, {
      kind: ft.OBJECT_TYPE_DEFINITION,
      description: i,
      name: n,
      interfaces: s,
      directives: a,
      fields: o
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(Te.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      Te.BRACE_L,
      this.parseFieldDefinition,
      Te.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseName(), s = this.parseArgumentDefs();
    this.expectToken(Te.COLON);
    const a = this.parseTypeReference(), o = this.parseConstDirectives();
    return this.node(e, {
      kind: ft.FIELD_DEFINITION,
      description: i,
      name: n,
      arguments: s,
      type: a,
      directives: o
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      Te.PAREN_L,
      this.parseInputValueDef,
      Te.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseName();
    this.expectToken(Te.COLON);
    const s = this.parseTypeReference();
    let a;
    this.expectOptionalToken(Te.EQUALS) && (a = this.parseConstValueLiteral());
    const o = this.parseConstDirectives();
    return this.node(e, {
      kind: ft.INPUT_VALUE_DEFINITION,
      description: i,
      name: n,
      type: s,
      defaultValue: a,
      directives: o
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("interface");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(e, {
      kind: ft.INTERFACE_TYPE_DEFINITION,
      description: i,
      name: n,
      interfaces: s,
      directives: a,
      fields: o
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("union");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseUnionMemberTypes();
    return this.node(e, {
      kind: ft.UNION_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      types: a
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(Te.EQUALS) ? this.delimitedMany(Te.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("enum");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseEnumValuesDefinition();
    return this.node(e, {
      kind: ft.ENUM_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      values: a
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      Te.BRACE_L,
      this.parseEnumValueDefinition,
      Te.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseEnumValueName(), s = this.parseConstDirectives();
    return this.node(e, {
      kind: ft.ENUM_VALUE_DEFINITION,
      description: i,
      name: n,
      directives: s
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw Yi(
        this._lexer.source,
        this._lexer.token.start,
        `${cp(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("input");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseInputFieldsDefinition();
    return this.node(e, {
      kind: ft.INPUT_OBJECT_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      fields: a
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      Te.BRACE_L,
      this.parseInputValueDef,
      Te.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const e = this._lexer.lookahead();
    if (e.kind === Te.NAME)
      switch (e.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(e);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const i = this.parseConstDirectives(), n = this.optionalMany(
      Te.BRACE_L,
      this.parseOperationTypeDefinition,
      Te.BRACE_R
    );
    if (i.length === 0 && n.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ft.SCHEMA_EXTENSION,
      directives: i,
      operationTypes: n
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const i = this.parseName(), n = this.parseConstDirectives();
    if (n.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ft.SCALAR_TYPE_EXTENSION,
      name: i,
      directives: n
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const i = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ft.OBJECT_TYPE_EXTENSION,
      name: i,
      interfaces: n,
      directives: s,
      fields: a
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const i = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ft.INTERFACE_TYPE_EXTENSION,
      name: i,
      interfaces: n,
      directives: s,
      fields: a
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseUnionMemberTypes();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ft.UNION_TYPE_EXTENSION,
      name: i,
      directives: n,
      types: s
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseEnumValuesDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ft.ENUM_TYPE_EXTENSION,
      name: i,
      directives: n,
      values: s
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseInputFieldsDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ft.INPUT_OBJECT_TYPE_EXTENSION,
      name: i,
      directives: n,
      fields: s
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(Te.AT);
    const n = this.parseName(), s = this.parseArgumentDefs(), a = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const o = this.parseDirectiveLocations();
    return this.node(e, {
      kind: ft.DIRECTIVE_DEFINITION,
      description: i,
      name: n,
      arguments: s,
      repeatable: a,
      locations: o
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(Te.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const e = this._lexer.token, i = this.parseName();
    if (Object.prototype.hasOwnProperty.call(zv, i.value))
      return i;
    throw this.unexpected(e);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(e, i) {
    return this._options.noLocation !== !0 && (i.loc = new RL(
      e,
      this._lexer.lastToken,
      this._lexer.source
    )), i;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(e) {
    return this._lexer.token.kind === e;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(e) {
    const i = this._lexer.token;
    if (i.kind === e)
      return this.advanceLexer(), i;
    throw Yi(
      this._lexer.source,
      i.start,
      `Expected ${bC(e)}, found ${cp(i)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(e) {
    return this._lexer.token.kind === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(e) {
    const i = this._lexer.token;
    if (i.kind === Te.NAME && i.value === e)
      this.advanceLexer();
    else
      throw Yi(
        this._lexer.source,
        i.start,
        `Expected "${e}", found ${cp(i)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(e) {
    const i = this._lexer.token;
    return i.kind === Te.NAME && i.value === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(e) {
    const i = e ?? this._lexer.token;
    return Yi(
      this._lexer.source,
      i.start,
      `Unexpected ${cp(i)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(e, i, n) {
    this.expectToken(e);
    const s = [];
    for (; !this.expectOptionalToken(n); )
      s.push(i.call(this));
    return s;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(e, i, n) {
    if (this.expectOptionalToken(e)) {
      const s = [];
      do
        s.push(i.call(this));
      while (!this.expectOptionalToken(n));
      return s;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(e, i, n) {
    this.expectToken(e);
    const s = [];
    do
      s.push(i.call(this));
    while (!this.expectOptionalToken(n));
    return s;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(e, i) {
    this.expectOptionalToken(e);
    const n = [];
    do
      n.push(i.call(this));
    while (this.expectOptionalToken(e));
    return n;
  }
  advanceLexer() {
    const { maxTokens: e } = this._options, i = this._lexer.advance();
    if (i.kind !== Te.EOF && (++this._tokenCounter, e !== void 0 && this._tokenCounter > e))
      throw Yi(
        this._lexer.source,
        i.start,
        `Document contains more that ${e} tokens. Parsing aborted.`
      );
  }
}
function cp(r) {
  const e = r.value;
  return bC(r.kind) + (e != null ? ` "${e}"` : "");
}
function bC(r) {
  return LL(r) ? `"${r}"` : r;
}
function rU(r) {
  return `"${r.replace(nU, sU)}"`;
}
const nU = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function sU(r) {
  return aU[r.charCodeAt(0)];
}
const aU = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], oU = Object.freeze({});
function lU(r, e, i = dC) {
  const n = /* @__PURE__ */ new Map();
  for (const g of Object.values(ft))
    n.set(g, uU(e, g));
  let s, a = Array.isArray(r), o = [r], l = -1, u = [], c = r, h, d;
  const p = [], f = [];
  do {
    l++;
    const g = l === o.length, _ = g && u.length !== 0;
    if (g) {
      if (h = f.length === 0 ? void 0 : p[p.length - 1], c = d, d = f.pop(), _)
        if (a) {
          c = c.slice();
          let b = 0;
          for (const [T, S] of u) {
            const w = T - b;
            S === null ? (c.splice(w, 1), b++) : c[w] = S;
          }
        } else {
          c = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(c)
          );
          for (const [b, T] of u)
            c[b] = T;
        }
      l = s.index, o = s.keys, u = s.edits, a = s.inArray, s = s.prev;
    } else if (d) {
      if (h = a ? l : o[l], c = d[h], c == null)
        continue;
      p.push(h);
    }
    let x;
    if (!Array.isArray(c)) {
      var m, v;
      YS(c) || Vf(!1, `Invalid AST Node: ${y_(c)}.`);
      const b = g ? (m = n.get(c.kind)) === null || m === void 0 ? void 0 : m.leave : (v = n.get(c.kind)) === null || v === void 0 ? void 0 : v.enter;
      if (x = b == null ? void 0 : b.call(e, c, h, d, p, f), x === oU)
        break;
      if (x === !1) {
        if (!g) {
          p.pop();
          continue;
        }
      } else if (x !== void 0 && (u.push([h, x]), !g))
        if (YS(x))
          c = x;
        else {
          p.pop();
          continue;
        }
    }
    if (x === void 0 && _ && u.push([h, c]), g)
      p.pop();
    else {
      var y;
      s = {
        inArray: a,
        index: l,
        keys: o,
        edits: u,
        prev: s
      }, a = Array.isArray(c), o = a ? c : (y = i[c.kind]) !== null && y !== void 0 ? y : [], l = -1, u = [], d && f.push(d), d = c;
    }
  } while (s !== void 0);
  return u.length !== 0 ? u[u.length - 1][1] : r;
}
function uU(r, e) {
  const i = r[e];
  return typeof i == "object" ? i : typeof i == "function" ? {
    enter: i,
    leave: void 0
  } : {
    enter: r.enter,
    leave: r.leave
  };
}
function cU(r) {
  return lU(r, dU);
}
const hU = 80, dU = {
  Name: {
    leave: (r) => r.value
  },
  Variable: {
    leave: (r) => "$" + r.name
  },
  // Document
  Document: {
    leave: (r) => Je(r.definitions, `

`)
  },
  OperationDefinition: {
    leave(r) {
      const e = Lt("(", Je(r.variableDefinitions, ", "), ")"), i = Je(
        [
          r.operation,
          Je([r.name, e]),
          Je(r.directives, " ")
        ],
        " "
      );
      return (i === "query" ? "" : i + " ") + r.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: r, type: e, defaultValue: i, directives: n }) => r + ": " + e + Lt(" = ", i) + Lt(" ", Je(n, " "))
  },
  SelectionSet: {
    leave: ({ selections: r }) => Pn(r)
  },
  Field: {
    leave({ alias: r, name: e, arguments: i, directives: n, selectionSet: s }) {
      const a = Lt("", r, ": ") + e;
      let o = a + Lt("(", Je(i, ", "), ")");
      return o.length > hU && (o = a + Lt(`(
`, Gf(Je(i, `
`)), `
)`)), Je([o, Je(n, " "), s], " ");
    }
  },
  Argument: {
    leave: ({ name: r, value: e }) => r + ": " + e
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: r, directives: e }) => "..." + r + Lt(" ", Je(e, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: r, directives: e, selectionSet: i }) => Je(
      [
        "...",
        Lt("on ", r),
        Je(e, " "),
        i
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: r, typeCondition: e, variableDefinitions: i, directives: n, selectionSet: s }) => (
      // or removed in the future.
      `fragment ${r}${Lt("(", Je(i, ", "), ")")} on ${e} ${Lt("", Je(n, " "), " ")}` + s
    )
  },
  // Value
  IntValue: {
    leave: ({ value: r }) => r
  },
  FloatValue: {
    leave: ({ value: r }) => r
  },
  StringValue: {
    leave: ({ value: r, block: e }) => e ? DL(r) : rU(r)
  },
  BooleanValue: {
    leave: ({ value: r }) => r ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: r }) => r
  },
  ListValue: {
    leave: ({ values: r }) => "[" + Je(r, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: r }) => "{" + Je(r, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: r, value: e }) => r + ": " + e
  },
  // Directive
  Directive: {
    leave: ({ name: r, arguments: e }) => "@" + r + Lt("(", Je(e, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: r }) => r
  },
  ListType: {
    leave: ({ type: r }) => "[" + r + "]"
  },
  NonNullType: {
    leave: ({ type: r }) => r + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: r, directives: e, operationTypes: i }) => Lt("", r, `
`) + Je(["schema", Je(e, " "), Pn(i)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: r, type: e }) => r + ": " + e
  },
  ScalarTypeDefinition: {
    leave: ({ description: r, name: e, directives: i }) => Lt("", r, `
`) + Je(["scalar", e, Je(i, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: r, name: e, interfaces: i, directives: n, fields: s }) => Lt("", r, `
`) + Je(
      [
        "type",
        e,
        Lt("implements ", Je(i, " & ")),
        Je(n, " "),
        Pn(s)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: r, name: e, arguments: i, type: n, directives: s }) => Lt("", r, `
`) + e + (KS(i) ? Lt(`(
`, Gf(Je(i, `
`)), `
)`) : Lt("(", Je(i, ", "), ")")) + ": " + n + Lt(" ", Je(s, " "))
  },
  InputValueDefinition: {
    leave: ({ description: r, name: e, type: i, defaultValue: n, directives: s }) => Lt("", r, `
`) + Je(
      [e + ": " + i, Lt("= ", n), Je(s, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: r, name: e, interfaces: i, directives: n, fields: s }) => Lt("", r, `
`) + Je(
      [
        "interface",
        e,
        Lt("implements ", Je(i, " & ")),
        Je(n, " "),
        Pn(s)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, types: n }) => Lt("", r, `
`) + Je(
      ["union", e, Je(i, " "), Lt("= ", Je(n, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, values: n }) => Lt("", r, `
`) + Je(["enum", e, Je(i, " "), Pn(n)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: r, name: e, directives: i }) => Lt("", r, `
`) + Je([e, Je(i, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, fields: n }) => Lt("", r, `
`) + Je(["input", e, Je(i, " "), Pn(n)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: r, name: e, arguments: i, repeatable: n, locations: s }) => Lt("", r, `
`) + "directive @" + e + (KS(i) ? Lt(`(
`, Gf(Je(i, `
`)), `
)`) : Lt("(", Je(i, ", "), ")")) + (n ? " repeatable" : "") + " on " + Je(s, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: r, operationTypes: e }) => Je(
      ["extend schema", Je(r, " "), Pn(e)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: r, directives: e }) => Je(["extend scalar", r, Je(e, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: r, interfaces: e, directives: i, fields: n }) => Je(
      [
        "extend type",
        r,
        Lt("implements ", Je(e, " & ")),
        Je(i, " "),
        Pn(n)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: r, interfaces: e, directives: i, fields: n }) => Je(
      [
        "extend interface",
        r,
        Lt("implements ", Je(e, " & ")),
        Je(i, " "),
        Pn(n)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: r, directives: e, types: i }) => Je(
      [
        "extend union",
        r,
        Je(e, " "),
        Lt("= ", Je(i, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: r, directives: e, values: i }) => Je(["extend enum", r, Je(e, " "), Pn(i)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: r, directives: e, fields: i }) => Je(["extend input", r, Je(e, " "), Pn(i)], " ")
  }
};
function Je(r, e = "") {
  var i;
  return (i = r == null ? void 0 : r.filter((n) => n).join(e)) !== null && i !== void 0 ? i : "";
}
function Pn(r) {
  return Lt(`{
`, Gf(Je(r, `
`)), `
}`);
}
function Lt(r, e, i = "") {
  return e != null && e !== "" ? r + e + i : "";
}
function Gf(r) {
  return Lt("  ", r.replace(/\n/g, `
  `));
}
function KS(r) {
  var e;
  return (e = r == null ? void 0 : r.some((i) => i.includes(`
`))) !== null && e !== void 0 ? e : !1;
}
const QS = "Accept", Vv = "Content-Type", Gv = "application/json", xC = "application/graphql-response+json", ZS = (r) => r.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), pU = (r) => {
  const e = r.toLowerCase();
  return e.includes(xC) || e.includes(Gv);
}, JS = (r) => {
  try {
    if (Array.isArray(r))
      return {
        _tag: "Batch",
        executionResults: r.map(e1)
      };
    if (jf(r))
      return {
        _tag: "Single",
        executionResult: e1(r)
      };
    throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(r)}`);
  } catch (e) {
    return e;
  }
}, e1 = (r) => {
  if (typeof r != "object" || r === null)
    throw new Error("Invalid execution result: result is not object");
  let e, i, n;
  if ("errors" in r) {
    if (!jf(r.errors) && !Array.isArray(r.errors))
      throw new Error("Invalid execution result: errors is not plain object OR array");
    e = r.errors;
  }
  if ("data" in r) {
    if (!jf(r.data) && r.data !== null)
      throw new Error("Invalid execution result: data is not plain object");
    i = r.data;
  }
  if ("extensions" in r) {
    if (!jf(r.extensions))
      throw new Error("Invalid execution result: extensions is not plain object");
    n = r.extensions;
  }
  return {
    data: i,
    errors: e,
    extensions: n
  };
}, fU = (r) => r._tag === "Batch" ? r.executionResults.some(t1) : t1(r.executionResult), t1 = (r) => Array.isArray(r.errors) ? r.errors.length > 0 : !!r.errors, _C = (r) => typeof r == "object" && r !== null && "kind" in r && r.kind === ft.OPERATION_DEFINITION, mU = (r) => {
  var e;
  let i;
  const n = r.definitions.filter(_C);
  return n.length === 1 && (i = (e = n[0].name) == null ? void 0 : e.value), i;
}, gU = (r) => {
  let e = !1;
  const i = r.definitions.filter(_C);
  return i.length === 1 && (e = i[0].operation === rl.MUTATION), e;
}, ly = (r, e) => {
  const i = typeof r == "string" ? r : cU(r);
  let n = !1, s;
  if (e)
    return { expression: i, isMutation: n, operationName: s };
  const a = xL(() => typeof r == "string" ? tU(r) : r);
  return a instanceof Error ? { expression: i, isMutation: n, operationName: s } : (s = mU(a), n = gU(a), { expression: i, operationName: s, isMutation: n });
}, v_ = JSON, uy = async (r) => {
  const e = {
    ...r,
    method: r.request._tag === "Single" ? r.request.document.isMutation ? "POST" : HS(r.method ?? "post") : r.request.hasMutations ? "POST" : HS(r.method ?? "post"),
    fetchOptions: {
      ...r.fetchOptions,
      errorPolicy: r.fetchOptions.errorPolicy ?? "none"
    }
  }, i = await vU(e.method)(e);
  if (!i.ok)
    return new Gu({ status: i.status, headers: i.headers }, {
      query: r.request._tag === "Single" ? r.request.document.expression : r.request.query,
      variables: r.request.variables
    });
  const n = await yU(i, r.fetchOptions.jsonSerializer ?? v_);
  if (n instanceof Error)
    throw n;
  const s = {
    status: i.status,
    headers: i.headers
  };
  if (fU(n) && e.fetchOptions.errorPolicy === "none") {
    const a = n._tag === "Batch" ? { ...n.executionResults, ...s } : {
      ...n.executionResult,
      ...s
    };
    return new Gu(a, {
      query: r.request._tag === "Single" ? r.request.document.expression : r.request.query,
      variables: r.request.variables
    });
  }
  switch (n._tag) {
    case "Single":
      return {
        ...s,
        ...i1(e)(n.executionResult)
      };
    case "Batch":
      return {
        ...s,
        data: n.executionResults.map(i1(e))
      };
    default:
      m_(n);
  }
}, i1 = (r) => (e) => ({
  extensions: e.extensions,
  data: e.data,
  errors: r.fetchOptions.errorPolicy === "all" ? e.errors : void 0
}), yU = async (r, e) => {
  const i = r.headers.get(Vv), n = await r.text();
  return i && pU(i) ? JS(e.parse(n)) : JS(n);
}, vU = (r) => async (e) => {
  const i = new Headers(e.headers);
  let n = null, s;
  i.has(QS) || i.set(QS, [xC, Gv].join(", ")), r === "POST" ? (s = (e.fetchOptions.jsonSerializer ?? v_).stringify(bU(e)), typeof s == "string" && !i.has(Vv) && i.set(Vv, Gv)) : n = xU(e);
  const a = { method: r, headers: i, body: s, ...e.fetchOptions };
  let o = new URL(e.url), l = a;
  if (e.middleware) {
    const u = await Promise.resolve(e.middleware({
      ...a,
      url: e.url,
      operationName: e.request._tag === "Single" ? e.request.document.operationName : void 0,
      variables: e.request.variables
    })), { url: c, ...h } = u;
    o = new URL(c), l = h;
  }
  return n && n.forEach((u, c) => {
    o.searchParams.append(c, u);
  }), await (e.fetch ?? fetch)(o, l);
}, bU = (r) => {
  switch (r.request._tag) {
    case "Single":
      return {
        query: r.request.document.expression,
        variables: r.request.variables,
        operationName: r.request.document.operationName
      };
    case "Batch":
      return uC(r.request.query, r.request.variables ?? []).map(([e, i]) => ({
        query: e,
        variables: i
      }));
    default:
      throw m_(r.request);
  }
}, xU = (r) => {
  var e;
  const i = r.fetchOptions.jsonSerializer ?? v_, n = new URLSearchParams();
  switch (r.request._tag) {
    case "Single":
      return n.append("query", ZS(r.request.document.expression)), r.request.variables && n.append("variables", i.stringify(r.request.variables)), r.request.document.operationName && n.append("operationName", r.request.document.operationName), n;
    case "Batch": {
      const s = ((e = r.request.variables) == null ? void 0 : e.map((l) => i.stringify(l))) ?? [], a = r.request.query.map(ZS), o = uC(a, s).map(([l, u]) => ({
        query: l,
        variables: u
      }));
      return n.append("query", i.stringify(o)), n;
    }
    default:
      throw m_(r.request);
  }
};
class TC {
  constructor(e, i = {}) {
    Xh(this, "url"), Xh(this, "requestConfig"), Xh(this, "rawRequest", async (...n) => {
      const [s, a, o] = n, l = SL(s, a, o), { headers: u, fetch: c = globalThis.fetch, method: h = "POST", requestMiddleware: d, responseMiddleware: p, excludeOperationName: f, ...m } = this.requestConfig, { url: v } = this;
      l.signal !== void 0 && (m.signal = l.signal);
      const y = ly(l.query, f), g = await uy({
        url: v,
        request: {
          _tag: "Single",
          document: y,
          variables: l.variables
        },
        headers: {
          ...jl(ay(u)),
          ...jl(l.requestHeaders)
        },
        fetch: c,
        method: h,
        fetchOptions: m,
        middleware: d
      });
      if (p && await p(g, {
        operationName: y.operationName,
        variables: a,
        url: this.url
      }), g instanceof Error)
        throw g;
      return g;
    }), this.url = e, this.requestConfig = i;
  }
  async request(e, ...i) {
    const [n, s] = i, a = _U(e, n, s), { headers: o, fetch: l = globalThis.fetch, method: u = "POST", requestMiddleware: c, responseMiddleware: h, excludeOperationName: d, ...p } = this.requestConfig, { url: f } = this;
    a.signal !== void 0 && (p.signal = a.signal);
    const m = ly(a.document, d), v = await uy({
      url: f,
      request: {
        _tag: "Single",
        document: m,
        variables: a.variables
      },
      headers: {
        ...jl(ay(o)),
        ...jl(a.requestHeaders)
      },
      fetch: l,
      method: u,
      fetchOptions: p,
      middleware: c
    });
    if (h && await h(v, {
      operationName: m.operationName,
      variables: a.variables,
      url: this.url
    }), v instanceof Error)
      throw v;
    return v.data;
  }
  async batchRequests(e, i) {
    const n = TL(e, i), { headers: s, excludeOperationName: a, ...o } = this.requestConfig;
    n.signal !== void 0 && (o.signal = n.signal);
    const l = n.documents.map(({ document: p }) => ly(p, a)), u = l.map(({ expression: p }) => p), c = l.some(({ isMutation: p }) => p), h = n.documents.map(({ variables: p }) => p), d = await uy({
      url: this.url,
      request: {
        _tag: "Batch",
        operationName: void 0,
        query: u,
        hasMutations: c,
        variables: h
      },
      headers: {
        ...jl(ay(s)),
        ...jl(n.requestHeaders)
      },
      fetch: this.requestConfig.fetch ?? globalThis.fetch,
      method: this.requestConfig.method || "POST",
      fetchOptions: o,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware && await this.requestConfig.responseMiddleware(d, {
      operationName: void 0,
      variables: h,
      url: this.url
    }), d instanceof Error)
      throw d;
    return d.data;
  }
  setHeaders(e) {
    return this.requestConfig.headers = e, this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(e, i) {
    const { headers: n } = this.requestConfig;
    return n ? n[e] = i : this.requestConfig.headers = { [e]: i }, this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(e) {
    return this.url = e, this;
  }
}
const _U = (r, e, i) => r.document ? r : {
  document: r,
  variables: e,
  requestHeaders: i,
  signal: void 0
}, Cr = (r, ...e) => r.reduce((i, n, s) => `${i}${n}${s in e ? String(e[s]) : ""}`, ""), SC = {
  base: {
    url: " https://prod.base.intuition-api.com/v1/graphql",
    displayName: "Base Mainnet"
  }
}, Vd = (r) => new TC(SC[r].url), TU = async (r, e = "baseSepolia") => {
  const i = Vd(e);
  let n;
  n = Cr`
    query GetAtom($atomId: numeric!) {
      atom(id: $atomId) {
        id
        image
        label
        emoji
        type
        creator_id
        vault {
          total_shares
        }
      }
    }
  `;
  const s = { atomId: r };
  try {
    return (await i.request(n, s)).atom;
  } catch (a) {
    throw console.error("Error fetching atom details:", a), a;
  }
}, SU = async (r = "baseSepolia") => {
  const e = Vd(r);
  let i, n;
  return i = Cr`
    query {
      triples(limit: 1000) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, n = await e.request(i), {
    items: n.triples
  }.items;
}, wU = async (r, e = "baseSepolia") => {
  const i = Vd(e);
  let n, s, a;
  return n = Cr`
    query Triples($where: triples_bool_exp) {
      triples(where: $where) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, a = {
    where: {
      _or: [
        {
          predicate_id: {
            _eq: r
          }
        },
        {
          subject_id: {
            _eq: r
          }
        },
        {
          object_id: {
            _eq: r
          }
        }
      ]
    }
  }, s = await i.request(n, a), s.triples;
}, EU = async (r, e = "baseSepolia") => {
  const i = Vd(e), n = Cr`
    query SearchTriples($where: triples_bool_exp) {
      triples(where: $where) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, s = {
    _and: []
  };
  r.subject && s._and.push({
    subject: {
      label: {
        _ilike: `%${r.subject}%`
      }
    }
  }), r.predicate && s._and.push({
    predicate: {
      label: {
        _ilike: `%${r.predicate}%`
      }
    }
  }), r.object && s._and.push({
    object: {
      label: {
        _ilike: `%${r.object}%`
      }
    }
  });
  const a = {
    where: s._and.length > 0 ? s : {}
  };
  console.log("Executing search query with variables:", a);
  try {
    const o = await i.request(n, a);
    return console.log("Search query response:", o), o.triples;
  } catch (o) {
    throw console.error("Error executing search query:", o), o;
  }
}, MU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ENDPOINTS: SC,
  createClient: Vd,
  fetchAtomDetails: TU,
  fetchTriples: SU,
  fetchTriplesForNode: wU,
  searchTriples: EU
}, Symbol.toStringTag, { value: "Module" })), wC = {
  baseSepolia: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Intuition Testnet"
  },
  base: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Intuition Testnet"
  }
}, ns = (r) => new TC(wC[r].url), b_ = (r) => ({
  id: r.term_id,
  subject: {
    id: r.subject.term_id,
    label: r.subject.label,
    type: r.subject.type,
    image: r.subject.image
  },
  predicate: {
    id: r.predicate.term_id,
    label: r.predicate.label,
    type: r.predicate.type
  },
  object: {
    id: r.object.term_id,
    label: r.object.label,
    type: r.object.type,
    image: r.object.image
  }
}), AU = async (r, e = "base") => {
  const i = ns(e);
  let n;
  n = Cr`
    query GetAtom($atomId: String!) {
      atoms(where: { term_id: { _eq: $atomId } }) {
        term_id
        image
        label
        emoji
        type
        creator_id
        term {
          total_market_cap
        }
      }
    }
  `;
  const s = { atomId: r };
  try {
    return (await i.request(n, s)).atoms[0];
  } catch (a) {
    throw console.error("Error fetching atom details:", a), a;
  }
}, EC = async (r = "base") => {
  const e = ns(r);
  let i, n;
  return i = Cr`
    query {
      triples(limit: 1000) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, n = await e.request(i), {
    items: n.triples
  }.items;
}, CU = async (r, e = "base") => {
  const i = ns(e);
  let n, s, a;
  return n = Cr`
    query Triples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, a = {
    where: {
      _or: [
        {
          predicate_id: {
            _eq: r
          }
        },
        {
          subject_id: {
            _eq: r
          }
        },
        {
          object_id: {
            _eq: r
          }
        }
      ]
    }
  }, s = await i.request(n, a), s.triples.map(b_);
}, RU = async (r, e = "base") => {
  const i = ns(e), n = Cr`
    query SearchTriples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, s = {
    _and: []
  };
  r.subject && s._and.push({
    subject: {
      label: {
        _ilike: `%${r.subject}%`
      }
    }
  }), r.predicate && s._and.push({
    predicate: {
      label: {
        _ilike: `%${r.predicate}%`
      }
    }
  }), r.object && s._and.push({
    object: {
      label: {
        _ilike: `%${r.object}%`
      }
    }
  });
  const a = {
    where: s._and.length > 0 ? s : {}
  };
  try {
    return (await i.request(n, a)).triples.map(b_);
  } catch (o) {
    throw console.error("Error executing search query:", o), o;
  }
}, MC = async (r, e = "base") => {
  const i = ns(e), n = Cr`
    query ClaimsByAccount($accountId: String!) {
      triples(where: { creator_id: { _eq: $accountId } }) {
        term_id
        subject {
          term_id
          label
          type
          image
        }
        predicate {
          term_id
          label
          type
        }
        object {
          term_id
          label
          type
          image
        }
      }
    }
  `, s = { accountId: "0xDdffF342CE2547338B0F689aA3eC86893340FBdf" };
  return (await i.request(n, s)).triples;
}, NU = async (r, e = "base") => {
  const i = ns(e), n = Cr`
    query TriplesByCreator($creatorId: String!) {
      triples(where: { creator_id: { _eq: $creatorId } }) {
        term_id
        subject {
          label
          term_id
        }
        predicate {
          label
          term_id
        }
        object {
          label
          term_id
        }
      }
    }
  `, s = { creatorId: r };
  return (await i.request(n, s)).triples;
}, AC = async (r, e = "base", i = 1e3) => {
  const n = ns(e), s = Cr`
    query Triples_for_Agent($objectId: String!, $batchSize: Int!) {
      triples(limit: $batchSize, where: { object_id: { _eq: $objectId } }) {
        term_id
        subject {
          term_id
          label
          type
          image
        }
        predicate {
          term_id
          label
          type
          image
        }
        object {
          term_id
          label
          type
          image
        }
      }
    }
  `, a = Cr`
    query Relations_for_Subject($subjectId: String!) {
      triples(where: { subject_id: { _eq: $subjectId } }) {
        term_id
        subject {
          term_id
          label
          type
          image
        }
        predicate {
          term_id
          label
          type
          image
        }
        object {
          term_id
          label
          type
          image
        }
      }
    }
  `, o = {
    batchSize: i,
    objectId: String(r)
  };
  try {
    const l = (await n.request(s, o)).triples, u = [...new Set(l.map((h) => h.subject.term_id))].map(
      (h) => n.request(a, { subjectId: h })
    ), c = (await Promise.all(u)).flatMap((h) => h.triples);
    return [...l, ...c].map(b_);
  } catch (l) {
    return console.error("Error fetching agent-specific triples:", l), EC(e).then((u) => u.filter(
      (c) => c.subject.term_id === r || c.object.term_id === r || c.predicate.term_id === r
    )).catch((u) => {
      throw console.error("Fallback fetch also failed:", u), l;
    });
  }
}, Hv = async (r, e = "base") => {
  const i = ns(e), n = Cr`
    query GetAccountActivity($accountId: String!) {
      positions(where: { account_id: { _eq: $accountId } }) {
        id
        shares
        account {
          id
          label
          image
          atom_id
          type
        }
        term {
          id
          total_market_cap
          total_assets
        }
      }
    }
  `, s = { accountId: "0xDdffF342CE2547338B0F689aA3eC86893340FBdf" };
  return (await i.request(n, s)).positions;
}, PU = async (r, e = "base") => {
  const i = ns(e);
  console.log("🔍 fetchAtomIdByCreator - creatorAddress:", r), console.log("🔍 fetchAtomIdByCreator - endpoint:", e);
  const n = Cr`
    query GetAtomByCreator($creatorAddress: String!) {
      atoms(where: { creator_id: { _eq: $creatorAddress } }) {
        term_id
        label
        creator_id
      }
    }
  `, s = { creatorAddress: r };
  console.log("🔍 fetchAtomIdByCreator - variables:", s);
  try {
    const a = await i.request(n, s);
    return console.log("🔍 fetchAtomIdByCreator - data reçue:", a), console.log("�� fetchAtomIdByCreator - nombre d'atoms trouvés:", a.atoms.length), a.atoms.length > 0 ? (console.log("�� fetchAtomIdByCreator - premier atom:", a.atoms[0]), a.atoms[0].term_id) : (console.warn("⚠️ fetchAtomIdByCreator - Aucun atom trouvé"), null);
  } catch (a) {
    throw console.error("❌ fetchAtomIdByCreator - Erreur:", a), a;
  }
}, CC = async (r, e, i = "base") => {
  const n = ns(i), s = "0x4b5ec64b82fae56c71a469fc902df2096b0dc7c930dd61032e817d583575fe47", a = Cr`
    query GetFollowsAndFollowers($predicateId: String!, $userAtomId: String!) {
      follows: triples(
        where: {
          _and: [
            { predicate_id: { _eq: $predicateId } },
            { subject_id: { _eq: $userAtomId } }
          ]
        }
      ) {
        term_id
        object {
          term_id
          label
          image
          creator_id
        }
      }
      followers: triples(
        where: {
          _and: [
            { predicate_id: { _eq: $predicateId } },
            { object_id: { _eq: $userAtomId } }
          ]
        }
      ) {
        term_id
        creator_id
        subject {
          term_id
          label
          image
        }
      }
    }
  `, o = { predicateId: r, userAtomId: s }, l = await n.request(a, o);
  return {
    follows: l.follows.map((u) => ({
      ...u,
      object: { ...u.object, id: u.object.term_id }
    })),
    followers: l.followers.map((u) => ({
      ...u,
      subject: { ...u.subject, id: u.subject.term_id }
    }))
  };
}, r1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ENDPOINTS: wC,
  createClient: ns,
  fetchAtomDetails: AU,
  fetchAtomIdByCreator: PU,
  fetchClaimsByAccount: MC,
  fetchFollowsAndFollowers: CC,
  fetchPositionsByAccount: Hv,
  fetchTriples: EC,
  fetchTriplesByCreator: NU,
  fetchTriplesForAgent: AC,
  fetchTriplesForNode: CU,
  searchTriples: RU
}, Symbol.toStringTag, { value: "Module" })), cy = {
  railsMockApi: {
    url: "https://api-i7n.thp-lab.org/api/v1/graph",
    displayName: "[OffChain] Playground API",
    module: MU
    // Default to Base module for railsMockApi
  },
  baseSepolia: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Base Testnet",
    module: r1
  },
  base: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Base Mainnet",
    module: r1
  }
}, pg = (r) => {
  if (!cy[r] || !cy[r].module)
    throw new Error(`No module defined for endpoint '${r}'.`);
  return cy[r].module;
}, x_ = async (r = "base") => {
  const e = pg(r);
  try {
    return e.fetchTriples(r);
  } catch (i) {
    throw console.error(`Error fetching triples for endpoint ${r}:`, i), i;
  }
}, OU = async (r, e = "base") => {
  const i = pg(e);
  try {
    return i.fetchTriplesForNode(r, e);
  } catch (n) {
    throw console.error(
      `Error fetching triples for node ${r} with endpoint ${e}:`,
      n
    ), n;
  }
}, IU = async (r, e = "base") => {
  const i = pg(e);
  try {
    return i.fetchAtomDetails(r, e);
  } catch (n) {
    throw console.error(
      `Error fetching atom details for ${r} with endpoint ${e}:`,
      n
    ), n;
  }
}, Iu = async (r, e = "base") => {
  const i = pg(e);
  try {
    return i.searchTriples(r, e);
  } catch (n) {
    throw console.error(`Error searching triples with endpoint ${e}:`, n), n;
  }
}, DU = async (r, e = "baseSepolia") => MC(r, e), kU = async (r, e = "baseSepolia", i = 1e3) => AC(r, e, i), __ = ({ triple: r, endpoint: e, onClose: i }) => {
  var n;
  const [s, a] = ke(null), [o, l] = ke(null), [u, c] = ke(!1), [h, d] = ke(null);
  ni(() => {
    r && (c(!0), d(null), l(null), (async () => {
      try {
        const v = (await x_(e)).filter(
          (y) => {
            var g, _, x;
            return y.id === r.id || ((g = y.subject) == null ? void 0 : g.id) === r.id || ((_ = y.predicate) == null ? void 0 : _.id) === r.id || ((x = y.object) == null ? void 0 : x.id) === r.id;
          }
        );
        if (a(v), r.id) {
          const y = await IU(
            r.id,
            e
          );
          l(y);
        }
      } catch (v) {
        console.error("Error fetching sidebar data:", v), d("Failed to fetch data");
      } finally {
        c(!1);
      }
    })());
  }, [r, e]);
  const p = (v) => `${(v / 1e18).toFixed(4)} ETH`;
  if (!r)
    return null;
  const f = (v, y = 4, g = 4) => !v || v.length <= y + g ? v : `${v.slice(0, y)}...${v.slice(-g)}`, m = async (v) => {
    try {
      await navigator.clipboard.writeText(v), console.log("ID copié:", v);
    } catch (y) {
      console.error("Erreur lors de la copie:", y);
    }
  };
  return /* @__PURE__ */ I.jsxs(
    "div",
    {
      style: {
        background: "#18181b",
        borderRadius: "10px",
        border: "2px solid #ffd32a",
        padding: "24px",
        boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
        color: "#fff",
        maxWidth: "400px",
        width: "100%"
      },
      children: [
        /* @__PURE__ */ I.jsxs(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              marginBottom: "24px"
            },
            children: [
              /* @__PURE__ */ I.jsx(
                "h2",
                {
                  style: {
                    margin: 0,
                    fontSize: "24px",
                    color: "#ffd32a",
                    fontWeight: "bold",
                    letterSpacing: "0.5px"
                  },
                  children: r.label || "No Label"
                }
              ),
              /* @__PURE__ */ I.jsx(
                "button",
                {
                  onClick: i,
                  style: {
                    background: "none",
                    border: "none",
                    color: "#ffd32a",
                    fontSize: "24px",
                    cursor: "pointer",
                    padding: "4px",
                    lineHeight: 1
                  },
                  children: "×"
                }
              )
            ]
          }
        ),
        o && o.image && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "center",
              margin: "24px 0"
            },
            children: /* @__PURE__ */ I.jsx(
              "img",
              {
                src: o.image,
                alt: o.label || "Node image",
                style: {
                  width: "120px",
                  height: "120px",
                  borderRadius: "50%",
                  objectFit: "cover",
                  border: "3px solid #ffd32a",
                  boxShadow: "0 4px 12px rgba(0,0,0,0.2)"
                }
              }
            )
          }
        ),
        u && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              textAlign: "center",
              padding: "20px",
              color: "#ffd32a"
            },
            children: "Loading..."
          }
        ),
        h && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              color: "#ff4444",
              padding: "12px",
              background: "rgba(255,68,68,0.1)",
              borderRadius: "8px",
              marginBottom: "16px"
            },
            children: h
          }
        ),
        o && /* @__PURE__ */ I.jsxs(
          "div",
          {
            style: {
              background: "#232326",
              borderRadius: "8px",
              padding: "16px",
              marginBottom: "24px"
            },
            children: [
              /* @__PURE__ */ I.jsx(
                "h4",
                {
                  style: {
                    color: "#ffd32a",
                    margin: "0 0 16px 0",
                    fontSize: "18px",
                    fontWeight: "bold"
                  },
                  children: "Atom Info"
                }
              ),
              /* @__PURE__ */ I.jsxs(
                "div",
                {
                  style: {
                    display: "grid",
                    gap: "12px"
                  },
                  children: [
                    /* @__PURE__ */ I.jsxs("div", { children: [
                      /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "ID:" }),
                      " ",
                      /* @__PURE__ */ I.jsx(
                        "span",
                        {
                          style: {
                            cursor: "pointer",
                            textDecoration: "underline",
                            color: "#ffd32a"
                          },
                          onClick: () => m(o.term_id),
                          title: `Cliquer pour copier: ${o.term_id}`,
                          children: f(o.term_id)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ I.jsxs("div", { children: [
                      /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Label:" }),
                      " ",
                      o.label
                    ] }),
                    /* @__PURE__ */ I.jsxs("div", { children: [
                      /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Type:" }),
                      " ",
                      o.type
                    ] }),
                    /* @__PURE__ */ I.jsxs("div", { children: [
                      /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Creator:" }),
                      " ",
                      /* @__PURE__ */ I.jsx(
                        "span",
                        {
                          style: {
                            cursor: "pointer",
                            textDecoration: "underline",
                            color: "#ffd32a"
                          },
                          onClick: () => m(o.creator_id),
                          title: `Cliquer pour copier: ${o.creator_id}`,
                          children: f(o.creator_id)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ I.jsxs("div", { children: [
                      /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Vault Shares:" }),
                      " ",
                      p(((n = o.vault) == null ? void 0 : n.total_shares) || 0)
                    ] })
                  ]
                }
              )
            ]
          }
        ),
        s && s.length > 0 && /* @__PURE__ */ I.jsxs(
          "div",
          {
            style: {
              background: "#232326",
              borderRadius: "8px",
              padding: "16px"
            },
            children: [
              /* @__PURE__ */ I.jsx(
                "h4",
                {
                  style: {
                    color: "#ffd32a",
                    margin: "0 0 16px 0",
                    fontSize: "18px",
                    fontWeight: "bold"
                  },
                  children: "Related Data"
                }
              ),
              /* @__PURE__ */ I.jsx(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: "12px"
                  },
                  children: s.map((v) => {
                    var y, g, _;
                    return /* @__PURE__ */ I.jsxs(
                      "div",
                      {
                        style: {
                          padding: "12px",
                          background: "#18181b",
                          borderRadius: "6px",
                          border: "1px solid #ffd32a33"
                        },
                        children: [
                          /* @__PURE__ */ I.jsxs("div", { children: [
                            /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Subject:" }),
                            " ",
                            (y = v.subject) == null ? void 0 : y.label
                          ] }),
                          /* @__PURE__ */ I.jsxs("div", { children: [
                            /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Predicate:" }),
                            " ",
                            (g = v.predicate) == null ? void 0 : g.label
                          ] }),
                          /* @__PURE__ */ I.jsxs("div", { children: [
                            /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Object:" }),
                            " ",
                            (_ = v.object) == null ? void 0 : _.label
                          ] })
                        ]
                      },
                      v.id
                    );
                  })
                }
              )
            ]
          }
        ),
        !u && !(s != null && s.length) && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              textAlign: "center",
              padding: "20px",
              color: "#888",
              background: "#232326",
              borderRadius: "8px"
            },
            children: "No additional related data found."
          }
        )
      ]
    }
  );
}, LU = ({ graphData: r, onNodeClick: e, onBack: i, onForward: n, selectedTriple: s, endpoint: a }) => {
  const o = gr(), l = gr(), [u, c] = ke({ width: 100, height: 100 });
  return ni(() => {
    const h = () => {
      o.current && c({
        width: o.current.clientWidth,
        height: o.current.clientHeight
      });
    };
    return h(), window.addEventListener("resize", h), () => window.removeEventListener("resize", h);
  }, []), ni(() => {
    if (l.current && u.width > 0 && u.height > 0) {
      const h = p2()(l.current);
      h.width(u.width).height(u.height).graphData(r).nodeLabel((d) => d.label || d.id).nodeAutoColorBy("group"), e && h.onNodeClick((d) => {
        console.log("VR Node clicked inside Graph:", d), e(d);
      });
    }
  }, [r, e, u]), /* @__PURE__ */ I.jsxs(
    "div",
    {
      ref: o,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ I.jsx(
          "div",
          {
            ref: l,
            style: { width: "100%", height: "100%" }
          }
        ),
        /* @__PURE__ */ I.jsxs("div", { style: { position: "absolute", bottom: 20, left: 20, zIndex: 100 }, children: [
          /* @__PURE__ */ I.jsx(
            "button",
            {
              onClick: i,
              style: {
                background: "#ffd32a",
                color: "#18181b",
                border: "none",
                borderRadius: 8,
                padding: "10px 20px",
                marginRight: 10,
                cursor: "pointer",
                fontWeight: "bold"
              },
              children: "Back"
            }
          ),
          /* @__PURE__ */ I.jsx(
            "button",
            {
              onClick: n,
              style: {
                background: "#ffd32a",
                color: "#18181b",
                border: "none",
                borderRadius: 8,
                padding: "10px 20px",
                cursor: "pointer",
                fontWeight: "bold"
              },
              children: "Forward"
            }
          )
        ] }),
        s && /* @__PURE__ */ I.jsx("div", { style: {
          position: "absolute",
          top: 80,
          right: 30,
          width: 350,
          zIndex: 9999,
          maxHeight: "80vh",
          background: "#18181b",
          borderRadius: "10px",
          border: "3px solid #ffd32a",
          boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
          overflowY: "auto"
        }, children: /* @__PURE__ */ I.jsx(
          __,
          {
            triple: s,
            endpoint: a,
            onClose: () => e(null)
          }
        ) })
      ]
    }
  );
}, RC = () => {
  const [r, e] = ke([]), i = 200;
  ni(() => {
    let s;
    const a = () => {
      const o = Date.now() / 1e3, l = [];
      for (let u = 0; u < 3; u++) {
        const c = o * 0.8 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 150 + 200,
          y: Math.sin(c) * 150 + 200,
          color: "#00fff2"
        });
      }
      for (let u = 0; u < 3; u++) {
        const c = -o * 1.2 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 100 + 200,
          y: Math.sin(c) * 100 + 200,
          color: "#ff00ff"
        });
      }
      for (let u = 0; u < 3; u++) {
        const c = o * 1.5 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 50 + 200,
          y: Math.sin(c) * 50 + 200,
          color: "#ffff00"
        });
      }
      e(l), s = requestAnimationFrame(a);
    };
    return a(), () => cancelAnimationFrame(s);
  }, []);
  const n = r.flatMap(
    (s, a) => r.slice(a + 1).map((o, l) => {
      const u = o.x - s.x, c = o.y - s.y, h = Math.sqrt(u * u + c * c);
      if (h < i) {
        const d = 1 - h / i;
        return {
          x1: s.x,
          y1: s.y,
          x2: o.x,
          y2: o.y,
          opacity: d * 0.8,
          // Slightly reduce max opacity for subtler effect
          gradient: `link-gradient-${a}-${l}`,
          color1: s.color,
          color2: o.color
        };
      }
      return null;
    }).filter(Boolean)
  );
  return /* @__PURE__ */ I.jsxs("div", { style: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    alignItems: "center",
    background: "rgba(0, 0, 0, 0.9)",
    zIndex: 1e3,
    overflow: "hidden"
  }, children: [
    /* @__PURE__ */ I.jsxs("div", { style: {
      position: "relative",
      width: "400px",
      height: "400px",
      display: "flex",
      flexDirection: "column",
      alignItems: "center"
    }, children: [
      /* @__PURE__ */ I.jsxs("svg", { width: "400", height: "400", children: [
        /* @__PURE__ */ I.jsx("defs", { children: n.map((s) => /* @__PURE__ */ I.jsxs(
          "linearGradient",
          {
            id: s.gradient,
            x1: "0%",
            y1: "0%",
            x2: "100%",
            y2: "0%",
            children: [
              /* @__PURE__ */ I.jsx("stop", { offset: "0%", stopColor: s.color1, stopOpacity: s.opacity }),
              /* @__PURE__ */ I.jsx("stop", { offset: "100%", stopColor: s.color2, stopOpacity: s.opacity })
            ]
          },
          s.gradient
        )) }),
        n.map((s, a) => /* @__PURE__ */ I.jsx(
          "line",
          {
            x1: s.x1,
            y1: s.y1,
            x2: s.x2,
            y2: s.y2,
            stroke: `url(#${s.gradient})`,
            strokeWidth: "3",
            style: {
              filter: "brightness(1.5) blur(1px)"
            }
          },
          a
        ))
      ] }),
      /* @__PURE__ */ I.jsx("div", { style: {
        color: "#00fff2",
        fontSize: "40px",
        fontFamily: "sans-serif",
        letterSpacing: "-2px",
        textShadow: `
            0 0 5px #00fff2,
            0 0 10px #00fff2,
            0 0 20px #00fff2,
            0 0 40px #00fff2
          `,
        animation: "textPulse 1.5s ease-in-out infinite",
        whiteSpace: "nowrap",
        marginTop: "20px"
      }, children: "Connecting I7n Dots..." })
    ] }),
    /* @__PURE__ */ I.jsx("style", { children: `
          @keyframes textPulse {
            0% { 
              opacity: 0.5;
              transform: scale(0.98) translateY(0);
            }
            50% { 
              opacity: 1;
              transform: scale(1.02) translateY(-5px);
            }
            100% { 
              opacity: 0.5;
              transform: scale(0.98) translateY(0);
            }
          }
        ` })
  ] });
}, UU = ({
  subjectFilter: r,
  predicateFilter: e,
  objectFilter: i,
  onFilterChange: n,
  onReset: s,
  onClose: a
}) => /* @__PURE__ */ I.jsxs(
  "div",
  {
    style: {
      display: "flex",
      flexDirection: "column",
      background: "#18181b",
      padding: "16px 24px",
      borderRadius: "10px",
      border: "2px solid #ffd32a",
      boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
      position: "relative"
    },
    children: [
      /* @__PURE__ */ I.jsx(
        "button",
        {
          onClick: a,
          style: {
            position: "absolute",
            top: 4,
            right: 6,
            background: "none",
            border: "none",
            color: "#ffd32a",
            fontSize: 20,
            cursor: "pointer",
            padding: 0,
            lineHeight: 1,
            width: 24,
            height: 24,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            zIndex: 2
          },
          "aria-label": "Close filters",
          children: "×"
        }
      ),
      /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: [
        /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ I.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Subject"
            }
          ),
          /* @__PURE__ */ I.jsx(
            "input",
            {
              type: "text",
              value: r,
              onChange: (o) => n("subject", o.target.value),
              placeholder: "Filter by subject...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ I.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Predicate"
            }
          ),
          /* @__PURE__ */ I.jsx(
            "input",
            {
              type: "text",
              value: e,
              onChange: (o) => n("predicate", o.target.value),
              placeholder: "Filter by predicate...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ I.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Object"
            }
          ),
          /* @__PURE__ */ I.jsx(
            "input",
            {
              type: "text",
              value: i,
              onChange: (o) => n("object", o.target.value),
              placeholder: "Filter by object...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ I.jsx(
          "button",
          {
            style: {
              background: "#ffd32a",
              color: "#18181b",
              border: "none",
              borderRadius: "8px",
              padding: "8px 24px",
              fontSize: "14px",
              fontWeight: "bold",
              cursor: "pointer",
              textTransform: "uppercase",
              transition: "background 0.2s, transform 0.1s",
              alignSelf: "flex-start",
              marginTop: "8px",
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
            },
            onMouseEnter: (o) => {
              o.currentTarget.style.background = "#ffe066", o.currentTarget.style.transform = "translateY(-1px)";
            },
            onMouseLeave: (o) => {
              o.currentTarget.style.background = "#ffd32a", o.currentTarget.style.transform = "translateY(0)";
            },
            onClick: s,
            children: "Reset"
          }
        )
      ] })
    ]
  }
);
function FU(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e === 0) {
        if (Object(i) !== i) return;
        u = !1;
      } else for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function BU(r, e, i) {
  return e = XU(e), e in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function n1(r, e) {
  return VU(r) || FU(r, e) || NC(r, e) || WU();
}
function zU(r) {
  return jU(r) || GU(r) || NC(r) || HU();
}
function jU(r) {
  if (Array.isArray(r)) return Wv(r);
}
function VU(r) {
  if (Array.isArray(r)) return r;
}
function GU(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function NC(r, e) {
  if (r) {
    if (typeof r == "string") return Wv(r, e);
    var i = Object.prototype.toString.call(r).slice(8, -1);
    if (i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set") return Array.from(r);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return Wv(r, e);
  }
}
function Wv(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = new Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function HU() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function WU() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function qU(r, e) {
  if (typeof r != "object" || r === null) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function XU(r) {
  var e = qU(r, "string");
  return typeof e == "symbol" ? e : String(e);
}
var YU = function(r, e) {
  var i = new Set(e);
  return Object.assign.apply(Object, [{}].concat(zU(Object.entries(r).filter(function(n) {
    var s = n1(n, 1), a = s[0];
    return !i.has(a);
  }).map(function(n) {
    var s = n1(n, 2), a = s[0], o = s[1];
    return BU({}, a, o);
  }))));
};
function qv(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function $U(r) {
  if (Array.isArray(r)) return r;
}
function KU(r) {
  if (Array.isArray(r)) return qv(r);
}
function QU(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function ZU(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function JU() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function eF() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function tF(r, e) {
  return $U(r) || ZU(r, e) || PC(r, e) || JU();
}
function s1(r) {
  return KU(r) || QU(r) || PC(r) || eF();
}
function PC(r, e) {
  if (r) {
    if (typeof r == "string") return qv(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? qv(r, e) : void 0;
  }
}
function fg(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = e.wrapperElementType, n = i === void 0 ? "div" : i, s = e.nodeMapper, a = s === void 0 ? function(h) {
    return h;
  } : s, o = e.methodNames, l = o === void 0 ? [] : o, u = e.initPropNames, c = u === void 0 ? [] : u;
  return /* @__PURE__ */ _I(function(h, d) {
    var p = gr(), f = TI(function() {
      var y = Object.fromEntries(c.filter(function(g) {
        return h.hasOwnProperty(g);
      }).map(function(g) {
        return [g, h[g]];
      }));
      return r(y);
    }, []);
    a1(function() {
      f(a(p.current));
    }, wI), a1(function() {
      return f._destructor instanceof Function ? f._destructor : void 0;
    });
    var m = kr(
      function(y) {
        for (var g = arguments.length, _ = new Array(g > 1 ? g - 1 : 0), x = 1; x < g; x++)
          _[x - 1] = arguments[x];
        return f[y] instanceof Function ? f[y].apply(f, _) : void 0;
      },
      [f]
    ), v = gr({});
    return Object.keys(YU(h, [].concat(s1(l), s1(c)))).filter(function(y) {
      return v.current[y] !== h[y];
    }).forEach(function(y) {
      return m(y, h[y]);
    }), v.current = h, SI(d, function() {
      return Object.fromEntries(l.map(function(y) {
        return [y, function() {
          for (var g = arguments.length, _ = new Array(g), x = 0; x < g; x++)
            _[x] = arguments[x];
          return m.apply(void 0, [y].concat(_));
        }];
      }));
    }, [m]), /* @__PURE__ */ Yt.createElement(n, {
      ref: p
    });
  });
}
function a1(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ni, i = gr(), n = gr(!1), s = gr(!1), a = ke(0), o = tF(a, 2);
  o[0];
  var l = o[1];
  n.current && (s.current = !0), e(function() {
    return n.current || (i.current = r(), n.current = !0), l(function(u) {
      return u + 1;
    }), function() {
      s.current && i.current && i.current();
    };
  }, []);
}
var Xv = { exports: {} }, hy = { exports: {} }, Xt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var o1;
function iF() {
  if (o1) return Xt;
  o1 = 1;
  var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, i = r ? Symbol.for("react.portal") : 60106, n = r ? Symbol.for("react.fragment") : 60107, s = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, o = r ? Symbol.for("react.provider") : 60109, l = r ? Symbol.for("react.context") : 60110, u = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, h = r ? Symbol.for("react.forward_ref") : 60112, d = r ? Symbol.for("react.suspense") : 60113, p = r ? Symbol.for("react.suspense_list") : 60120, f = r ? Symbol.for("react.memo") : 60115, m = r ? Symbol.for("react.lazy") : 60116, v = r ? Symbol.for("react.block") : 60121, y = r ? Symbol.for("react.fundamental") : 60117, g = r ? Symbol.for("react.responder") : 60118, _ = r ? Symbol.for("react.scope") : 60119;
  function x(T) {
    if (typeof T == "object" && T !== null) {
      var S = T.$$typeof;
      switch (S) {
        case e:
          switch (T = T.type, T) {
            case u:
            case c:
            case n:
            case a:
            case s:
            case d:
              return T;
            default:
              switch (T = T && T.$$typeof, T) {
                case l:
                case h:
                case m:
                case f:
                case o:
                  return T;
                default:
                  return S;
              }
          }
        case i:
          return S;
      }
    }
  }
  function b(T) {
    return x(T) === c;
  }
  return Xt.AsyncMode = u, Xt.ConcurrentMode = c, Xt.ContextConsumer = l, Xt.ContextProvider = o, Xt.Element = e, Xt.ForwardRef = h, Xt.Fragment = n, Xt.Lazy = m, Xt.Memo = f, Xt.Portal = i, Xt.Profiler = a, Xt.StrictMode = s, Xt.Suspense = d, Xt.isAsyncMode = function(T) {
    return b(T) || x(T) === u;
  }, Xt.isConcurrentMode = b, Xt.isContextConsumer = function(T) {
    return x(T) === l;
  }, Xt.isContextProvider = function(T) {
    return x(T) === o;
  }, Xt.isElement = function(T) {
    return typeof T == "object" && T !== null && T.$$typeof === e;
  }, Xt.isForwardRef = function(T) {
    return x(T) === h;
  }, Xt.isFragment = function(T) {
    return x(T) === n;
  }, Xt.isLazy = function(T) {
    return x(T) === m;
  }, Xt.isMemo = function(T) {
    return x(T) === f;
  }, Xt.isPortal = function(T) {
    return x(T) === i;
  }, Xt.isProfiler = function(T) {
    return x(T) === a;
  }, Xt.isStrictMode = function(T) {
    return x(T) === s;
  }, Xt.isSuspense = function(T) {
    return x(T) === d;
  }, Xt.isValidElementType = function(T) {
    return typeof T == "string" || typeof T == "function" || T === n || T === c || T === a || T === s || T === d || T === p || typeof T == "object" && T !== null && (T.$$typeof === m || T.$$typeof === f || T.$$typeof === o || T.$$typeof === l || T.$$typeof === h || T.$$typeof === y || T.$$typeof === g || T.$$typeof === _ || T.$$typeof === v);
  }, Xt.typeOf = x, Xt;
}
var Zt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l1;
function rF() {
  return l1 || (l1 = 1, process.env.NODE_ENV !== "production" && function() {
    var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, i = r ? Symbol.for("react.portal") : 60106, n = r ? Symbol.for("react.fragment") : 60107, s = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, o = r ? Symbol.for("react.provider") : 60109, l = r ? Symbol.for("react.context") : 60110, u = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, h = r ? Symbol.for("react.forward_ref") : 60112, d = r ? Symbol.for("react.suspense") : 60113, p = r ? Symbol.for("react.suspense_list") : 60120, f = r ? Symbol.for("react.memo") : 60115, m = r ? Symbol.for("react.lazy") : 60116, v = r ? Symbol.for("react.block") : 60121, y = r ? Symbol.for("react.fundamental") : 60117, g = r ? Symbol.for("react.responder") : 60118, _ = r ? Symbol.for("react.scope") : 60119;
    function x(be) {
      return typeof be == "string" || typeof be == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      be === n || be === c || be === a || be === s || be === d || be === p || typeof be == "object" && be !== null && (be.$$typeof === m || be.$$typeof === f || be.$$typeof === o || be.$$typeof === l || be.$$typeof === h || be.$$typeof === y || be.$$typeof === g || be.$$typeof === _ || be.$$typeof === v);
    }
    function b(be) {
      if (typeof be == "object" && be !== null) {
        var vt = be.$$typeof;
        switch (vt) {
          case e:
            var Z = be.type;
            switch (Z) {
              case u:
              case c:
              case n:
              case a:
              case s:
              case d:
                return Z;
              default:
                var Vt = Z && Z.$$typeof;
                switch (Vt) {
                  case l:
                  case h:
                  case m:
                  case f:
                  case o:
                    return Vt;
                  default:
                    return vt;
                }
            }
          case i:
            return vt;
        }
      }
    }
    var T = u, S = c, w = l, C = o, E = e, A = h, N = n, L = m, F = f, M = i, P = a, O = s, V = d, B = !1;
    function H(be) {
      return B || (B = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), U(be) || b(be) === u;
    }
    function U(be) {
      return b(be) === c;
    }
    function j(be) {
      return b(be) === l;
    }
    function Q(be) {
      return b(be) === o;
    }
    function q(be) {
      return typeof be == "object" && be !== null && be.$$typeof === e;
    }
    function G(be) {
      return b(be) === h;
    }
    function Y(be) {
      return b(be) === n;
    }
    function ae(be) {
      return b(be) === m;
    }
    function ue(be) {
      return b(be) === f;
    }
    function ge(be) {
      return b(be) === i;
    }
    function we(be) {
      return b(be) === a;
    }
    function Ne(be) {
      return b(be) === s;
    }
    function lt(be) {
      return b(be) === d;
    }
    Zt.AsyncMode = T, Zt.ConcurrentMode = S, Zt.ContextConsumer = w, Zt.ContextProvider = C, Zt.Element = E, Zt.ForwardRef = A, Zt.Fragment = N, Zt.Lazy = L, Zt.Memo = F, Zt.Portal = M, Zt.Profiler = P, Zt.StrictMode = O, Zt.Suspense = V, Zt.isAsyncMode = H, Zt.isConcurrentMode = U, Zt.isContextConsumer = j, Zt.isContextProvider = Q, Zt.isElement = q, Zt.isForwardRef = G, Zt.isFragment = Y, Zt.isLazy = ae, Zt.isMemo = ue, Zt.isPortal = ge, Zt.isProfiler = we, Zt.isStrictMode = Ne, Zt.isSuspense = lt, Zt.isValidElementType = x, Zt.typeOf = b;
  }()), Zt;
}
var u1;
function OC() {
  return u1 || (u1 = 1, process.env.NODE_ENV === "production" ? hy.exports = iF() : hy.exports = rF()), hy.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var dy, c1;
function nF() {
  if (c1) return dy;
  c1 = 1;
  var r = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, i = Object.prototype.propertyIsEnumerable;
  function n(a) {
    if (a == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(a);
  }
  function s() {
    try {
      if (!Object.assign)
        return !1;
      var a = new String("abc");
      if (a[5] = "de", Object.getOwnPropertyNames(a)[0] === "5")
        return !1;
      for (var o = {}, l = 0; l < 10; l++)
        o["_" + String.fromCharCode(l)] = l;
      var u = Object.getOwnPropertyNames(o).map(function(h) {
        return o[h];
      });
      if (u.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(h) {
        c[h] = h;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return dy = s() ? Object.assign : function(a, o) {
    for (var l, u = n(a), c, h = 1; h < arguments.length; h++) {
      l = Object(arguments[h]);
      for (var d in l)
        e.call(l, d) && (u[d] = l[d]);
      if (r) {
        c = r(l);
        for (var p = 0; p < c.length; p++)
          i.call(l, c[p]) && (u[c[p]] = l[c[p]]);
      }
    }
    return u;
  }, dy;
}
var py, h1;
function T_() {
  if (h1) return py;
  h1 = 1;
  var r = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return py = r, py;
}
var d1, p1;
function IC() {
  return p1 || (p1 = 1, d1 = Function.call.bind(Object.prototype.hasOwnProperty)), d1;
}
var fy, f1;
function sF() {
  if (f1) return fy;
  f1 = 1;
  var r = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = T_(), i = {}, n = IC();
    r = function(a) {
      var o = "Warning: " + a;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function s(a, o, l, u, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var h in a)
        if (n(a, h)) {
          var d;
          try {
            if (typeof a[h] != "function") {
              var p = Error(
                (u || "React class") + ": " + l + " type `" + h + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[h] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = a[h](o, h, u, l, null, e);
          } catch (m) {
            d = m;
          }
          if (d && !(d instanceof Error) && r(
            (u || "React class") + ": type specification of " + l + " `" + h + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in i)) {
            i[d.message] = !0;
            var f = c ? c() : "";
            r(
              "Failed " + l + " type: " + d.message + (f ?? "")
            );
          }
        }
    }
  }
  return s.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (i = {});
  }, fy = s, fy;
}
var my, m1;
function aF() {
  if (m1) return my;
  m1 = 1;
  var r = OC(), e = nF(), i = T_(), n = IC(), s = sF(), a = function() {
  };
  process.env.NODE_ENV !== "production" && (a = function(l) {
    var u = "Warning: " + l;
    typeof console < "u" && console.error(u);
    try {
      throw new Error(u);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return my = function(l, u) {
    var c = typeof Symbol == "function" && Symbol.iterator, h = "@@iterator";
    function d(U) {
      var j = U && (c && U[c] || U[h]);
      if (typeof j == "function")
        return j;
    }
    var p = "<<anonymous>>", f = {
      array: g("array"),
      bigint: g("bigint"),
      bool: g("boolean"),
      func: g("function"),
      number: g("number"),
      object: g("object"),
      string: g("string"),
      symbol: g("symbol"),
      any: _(),
      arrayOf: x,
      element: b(),
      elementType: T(),
      instanceOf: S,
      node: A(),
      objectOf: C,
      oneOf: w,
      oneOfType: E,
      shape: L,
      exact: F
    };
    function m(U, j) {
      return U === j ? U !== 0 || 1 / U === 1 / j : U !== U && j !== j;
    }
    function v(U, j) {
      this.message = U, this.data = j && typeof j == "object" ? j : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function y(U) {
      if (process.env.NODE_ENV !== "production")
        var j = {}, Q = 0;
      function q(Y, ae, ue, ge, we, Ne, lt) {
        if (ge = ge || p, Ne = Ne || ue, lt !== i) {
          if (u) {
            var be = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw be.name = "Invariant Violation", be;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var vt = ge + ":" + ue;
            !j[vt] && // Avoid spamming the console because they are often not actionable except for lib authors
            Q < 3 && (a(
              "You are manually calling a React.PropTypes validation function for the `" + Ne + "` prop on `" + ge + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), j[vt] = !0, Q++);
          }
        }
        return ae[ue] == null ? Y ? ae[ue] === null ? new v("The " + we + " `" + Ne + "` is marked as required " + ("in `" + ge + "`, but its value is `null`.")) : new v("The " + we + " `" + Ne + "` is marked as required in " + ("`" + ge + "`, but its value is `undefined`.")) : null : U(ae, ue, ge, we, Ne);
      }
      var G = q.bind(null, !1);
      return G.isRequired = q.bind(null, !0), G;
    }
    function g(U) {
      function j(Q, q, G, Y, ae, ue) {
        var ge = Q[q], we = O(ge);
        if (we !== U) {
          var Ne = V(ge);
          return new v(
            "Invalid " + Y + " `" + ae + "` of type " + ("`" + Ne + "` supplied to `" + G + "`, expected ") + ("`" + U + "`."),
            { expectedType: U }
          );
        }
        return null;
      }
      return y(j);
    }
    function _() {
      return y(o);
    }
    function x(U) {
      function j(Q, q, G, Y, ae) {
        if (typeof U != "function")
          return new v("Property `" + ae + "` of component `" + G + "` has invalid PropType notation inside arrayOf.");
        var ue = Q[q];
        if (!Array.isArray(ue)) {
          var ge = O(ue);
          return new v("Invalid " + Y + " `" + ae + "` of type " + ("`" + ge + "` supplied to `" + G + "`, expected an array."));
        }
        for (var we = 0; we < ue.length; we++) {
          var Ne = U(ue, we, G, Y, ae + "[" + we + "]", i);
          if (Ne instanceof Error)
            return Ne;
        }
        return null;
      }
      return y(j);
    }
    function b() {
      function U(j, Q, q, G, Y) {
        var ae = j[Q];
        if (!l(ae)) {
          var ue = O(ae);
          return new v("Invalid " + G + " `" + Y + "` of type " + ("`" + ue + "` supplied to `" + q + "`, expected a single ReactElement."));
        }
        return null;
      }
      return y(U);
    }
    function T() {
      function U(j, Q, q, G, Y) {
        var ae = j[Q];
        if (!r.isValidElementType(ae)) {
          var ue = O(ae);
          return new v("Invalid " + G + " `" + Y + "` of type " + ("`" + ue + "` supplied to `" + q + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return y(U);
    }
    function S(U) {
      function j(Q, q, G, Y, ae) {
        if (!(Q[q] instanceof U)) {
          var ue = U.name || p, ge = H(Q[q]);
          return new v("Invalid " + Y + " `" + ae + "` of type " + ("`" + ge + "` supplied to `" + G + "`, expected ") + ("instance of `" + ue + "`."));
        }
        return null;
      }
      return y(j);
    }
    function w(U) {
      if (!Array.isArray(U))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? a(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : a("Invalid argument supplied to oneOf, expected an array.")), o;
      function j(Q, q, G, Y, ae) {
        for (var ue = Q[q], ge = 0; ge < U.length; ge++)
          if (m(ue, U[ge]))
            return null;
        var we = JSON.stringify(U, function(Ne, lt) {
          var be = V(lt);
          return be === "symbol" ? String(lt) : lt;
        });
        return new v("Invalid " + Y + " `" + ae + "` of value `" + String(ue) + "` " + ("supplied to `" + G + "`, expected one of " + we + "."));
      }
      return y(j);
    }
    function C(U) {
      function j(Q, q, G, Y, ae) {
        if (typeof U != "function")
          return new v("Property `" + ae + "` of component `" + G + "` has invalid PropType notation inside objectOf.");
        var ue = Q[q], ge = O(ue);
        if (ge !== "object")
          return new v("Invalid " + Y + " `" + ae + "` of type " + ("`" + ge + "` supplied to `" + G + "`, expected an object."));
        for (var we in ue)
          if (n(ue, we)) {
            var Ne = U(ue, we, G, Y, ae + "." + we, i);
            if (Ne instanceof Error)
              return Ne;
          }
        return null;
      }
      return y(j);
    }
    function E(U) {
      if (!Array.isArray(U))
        return process.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var j = 0; j < U.length; j++) {
        var Q = U[j];
        if (typeof Q != "function")
          return a(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + B(Q) + " at index " + j + "."
          ), o;
      }
      function q(G, Y, ae, ue, ge) {
        for (var we = [], Ne = 0; Ne < U.length; Ne++) {
          var lt = U[Ne], be = lt(G, Y, ae, ue, ge, i);
          if (be == null)
            return null;
          be.data && n(be.data, "expectedType") && we.push(be.data.expectedType);
        }
        var vt = we.length > 0 ? ", expected one of type [" + we.join(", ") + "]" : "";
        return new v("Invalid " + ue + " `" + ge + "` supplied to " + ("`" + ae + "`" + vt + "."));
      }
      return y(q);
    }
    function A() {
      function U(j, Q, q, G, Y) {
        return M(j[Q]) ? null : new v("Invalid " + G + " `" + Y + "` supplied to " + ("`" + q + "`, expected a ReactNode."));
      }
      return y(U);
    }
    function N(U, j, Q, q, G) {
      return new v(
        (U || "React class") + ": " + j + " type `" + Q + "." + q + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G + "`."
      );
    }
    function L(U) {
      function j(Q, q, G, Y, ae) {
        var ue = Q[q], ge = O(ue);
        if (ge !== "object")
          return new v("Invalid " + Y + " `" + ae + "` of type `" + ge + "` " + ("supplied to `" + G + "`, expected `object`."));
        for (var we in U) {
          var Ne = U[we];
          if (typeof Ne != "function")
            return N(G, Y, ae, we, V(Ne));
          var lt = Ne(ue, we, G, Y, ae + "." + we, i);
          if (lt)
            return lt;
        }
        return null;
      }
      return y(j);
    }
    function F(U) {
      function j(Q, q, G, Y, ae) {
        var ue = Q[q], ge = O(ue);
        if (ge !== "object")
          return new v("Invalid " + Y + " `" + ae + "` of type `" + ge + "` " + ("supplied to `" + G + "`, expected `object`."));
        var we = e({}, Q[q], U);
        for (var Ne in we) {
          var lt = U[Ne];
          if (n(U, Ne) && typeof lt != "function")
            return N(G, Y, ae, Ne, V(lt));
          if (!lt)
            return new v(
              "Invalid " + Y + " `" + ae + "` key `" + Ne + "` supplied to `" + G + "`.\nBad object: " + JSON.stringify(Q[q], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(U), null, "  ")
            );
          var be = lt(ue, Ne, G, Y, ae + "." + Ne, i);
          if (be)
            return be;
        }
        return null;
      }
      return y(j);
    }
    function M(U) {
      switch (typeof U) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !U;
        case "object":
          if (Array.isArray(U))
            return U.every(M);
          if (U === null || l(U))
            return !0;
          var j = d(U);
          if (j) {
            var Q = j.call(U), q;
            if (j !== U.entries) {
              for (; !(q = Q.next()).done; )
                if (!M(q.value))
                  return !1;
            } else
              for (; !(q = Q.next()).done; ) {
                var G = q.value;
                if (G && !M(G[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function P(U, j) {
      return U === "symbol" ? !0 : j ? j["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && j instanceof Symbol : !1;
    }
    function O(U) {
      var j = typeof U;
      return Array.isArray(U) ? "array" : U instanceof RegExp ? "object" : P(j, U) ? "symbol" : j;
    }
    function V(U) {
      if (typeof U > "u" || U === null)
        return "" + U;
      var j = O(U);
      if (j === "object") {
        if (U instanceof Date)
          return "date";
        if (U instanceof RegExp)
          return "regexp";
      }
      return j;
    }
    function B(U) {
      var j = V(U);
      switch (j) {
        case "array":
        case "object":
          return "an " + j;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + j;
        default:
          return j;
      }
    }
    function H(U) {
      return !U.constructor || !U.constructor.name ? p : U.constructor.name;
    }
    return f.checkPropTypes = s, f.resetWarningCache = s.resetWarningCache, f.PropTypes = f, f;
  }, my;
}
var gy, g1;
function oF() {
  if (g1) return gy;
  g1 = 1;
  var r = T_();
  function e() {
  }
  function i() {
  }
  return i.resetWarningCache = e, gy = function() {
    function n(o, l, u, c, h, d) {
      if (d !== r) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    n.isRequired = n;
    function s() {
      return n;
    }
    var a = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: s,
      element: n,
      elementType: n,
      instanceOf: s,
      node: n,
      objectOf: s,
      oneOf: s,
      oneOfType: s,
      shape: s,
      exact: s,
      checkPropTypes: i,
      resetWarningCache: e
    };
    return a.PropTypes = a, a;
  }, gy;
}
if (process.env.NODE_ENV !== "production") {
  var lF = OC(), uF = !0;
  Xv.exports = aF()(lF.isElement, uF);
} else
  Xv.exports = oF()();
var cF = Xv.exports;
const re = /* @__PURE__ */ f_(cF);
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const mg = "170", tr = { ROTATE: 0, DOLLY: 1, PAN: 2 }, sa = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, hF = 0, y1 = 1, dF = 2, DC = 1, pF = 2, qs = 3, yo = 0, Mr = 1, ea = 2, ha = 0, Hu = 1, v1 = 2, b1 = 3, x1 = 4, fF = 5, $o = 100, mF = 101, gF = 102, yF = 103, vF = 104, bF = 200, xF = 201, _F = 202, TF = 203, Yv = 204, $v = 205, SF = 206, wF = 207, EF = 208, MF = 209, AF = 210, CF = 211, RF = 212, NF = 213, PF = 214, Kv = 0, Qv = 1, Zv = 2, dc = 3, Jv = 4, eb = 5, tb = 6, ib = 7, S_ = 0, OF = 1, IF = 2, co = 0, DF = 1, kF = 2, LF = 3, UF = 4, FF = 5, BF = 6, zF = 7, kC = 300, pc = 301, fc = 302, rb = 303, nb = 304, gg = 306, sb = 1e3, nl = 1001, ab = 1002, Jn = 1003, jF = 1004, hp = 1005, gs = 1006, yy = 1007, sl = 1008, Ta = 1009, LC = 1010, UC = 1011, cd = 1012, w_ = 1013, Tl = 1014, aa = 1015, Dc = 1016, E_ = 1017, M_ = 1018, mc = 1020, FC = 35902, BC = 1021, zC = 1022, Kn = 1023, jC = 1024, VC = 1025, Wu = 1026, gc = 1027, GC = 1028, A_ = 1029, HC = 1030, C_ = 1031, R_ = 1033, Hf = 33776, Wf = 33777, qf = 33778, Xf = 33779, ob = 35840, lb = 35841, ub = 35842, cb = 35843, hb = 36196, db = 37492, pb = 37496, fb = 37808, mb = 37809, gb = 37810, yb = 37811, vb = 37812, bb = 37813, xb = 37814, _b = 37815, Tb = 37816, Sb = 37817, wb = 37818, Eb = 37819, Mb = 37820, Ab = 37821, Yf = 36492, Cb = 36494, Rb = 36495, WC = 36283, Nb = 36284, Pb = 36285, Ob = 36286, VF = 3200, GF = 3201, qC = 0, HF = 1, to = "", ln = "srgb", kc = "srgb-linear", yg = "linear", ei = "srgb", Vl = 7680, _1 = 519, WF = 512, qF = 513, XF = 514, XC = 515, YF = 516, $F = 517, KF = 518, QF = 519, Ib = 35044, T1 = "300 es", oa = 2e3, ym = 2001;
let Nl = class {
  addEventListener(r, e) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[r] === void 0 && (i[r] = []), i[r].indexOf(e) === -1 && i[r].push(e);
  }
  hasEventListener(r, e) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[r] !== void 0 && i[r].indexOf(e) !== -1;
  }
  removeEventListener(r, e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[r];
    if (i !== void 0) {
      const n = i.indexOf(e);
      n !== -1 && i.splice(n, 1);
    }
  }
  dispatchEvent(r) {
    if (this._listeners === void 0) return;
    const e = this._listeners[r.type];
    if (e !== void 0) {
      r.target = this;
      const i = e.slice(0);
      for (let n = 0, s = i.length; n < s; n++)
        i[n].call(this, r);
      r.target = null;
    }
  }
};
const or = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let S1 = 1234567;
const Yh = Math.PI / 180, hd = 180 / Math.PI;
function da() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (or[r & 255] + or[r >> 8 & 255] + or[r >> 16 & 255] + or[r >> 24 & 255] + "-" + or[e & 255] + or[e >> 8 & 255] + "-" + or[e >> 16 & 15 | 64] + or[e >> 24 & 255] + "-" + or[i & 63 | 128] + or[i >> 8 & 255] + "-" + or[i >> 16 & 255] + or[i >> 24 & 255] + or[n & 255] + or[n >> 8 & 255] + or[n >> 16 & 255] + or[n >> 24 & 255]).toLowerCase();
}
function $i(r, e, i) {
  return Math.max(e, Math.min(i, r));
}
function N_(r, e) {
  return (r % e + e) % e;
}
function ZF(r, e, i, n, s) {
  return n + (r - e) * (s - n) / (i - e);
}
function JF(r, e, i) {
  return r !== e ? (i - r) / (e - r) : 0;
}
function $h(r, e, i) {
  return (1 - i) * r + i * e;
}
function eB(r, e, i, n) {
  return $h(r, e, 1 - Math.exp(-i * n));
}
function tB(r, e = 1) {
  return e - Math.abs(N_(r, e * 2) - e);
}
function iB(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * (3 - 2 * r));
}
function rB(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * r * (r * (r * 6 - 15) + 10));
}
function nB(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function sB(r, e) {
  return r + Math.random() * (e - r);
}
function aB(r) {
  return r * (0.5 - Math.random());
}
function oB(r) {
  r !== void 0 && (S1 = r);
  let e = S1 += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function lB(r) {
  return r * Yh;
}
function uB(r) {
  return r * hd;
}
function cB(r) {
  return (r & r - 1) === 0 && r !== 0;
}
function hB(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function dB(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function pB(r, e, i, n, s) {
  const a = Math.cos, o = Math.sin, l = a(i / 2), u = o(i / 2), c = a((e + n) / 2), h = o((e + n) / 2), d = a((e - n) / 2), p = o((e - n) / 2), f = a((n - e) / 2), m = o((n - e) / 2);
  switch (s) {
    case "XYX":
      r.set(l * h, u * d, u * p, l * c);
      break;
    case "YZY":
      r.set(u * p, l * h, u * d, l * c);
      break;
    case "ZXZ":
      r.set(u * d, u * p, l * h, l * c);
      break;
    case "XZX":
      r.set(l * h, u * m, u * f, l * c);
      break;
    case "YXY":
      r.set(u * f, l * h, u * m, l * c);
      break;
    case "ZYZ":
      r.set(u * m, u * f, l * h, l * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function Xn(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Jt(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Db = {
  DEG2RAD: Yh,
  RAD2DEG: hd,
  generateUUID: da,
  clamp: $i,
  euclideanModulo: N_,
  mapLinear: ZF,
  inverseLerp: JF,
  lerp: $h,
  damp: eB,
  pingpong: tB,
  smoothstep: iB,
  smootherstep: rB,
  randInt: nB,
  randFloat: sB,
  randFloatSpread: aB,
  seededRandom: oB,
  degToRad: lB,
  radToDeg: uB,
  isPowerOfTwo: cB,
  ceilPowerOfTwo: hB,
  floorPowerOfTwo: dB,
  setQuaternionFromProperEuler: pB,
  normalize: Jt,
  denormalize: Xn
};
let Le = class YC {
  constructor(e = 0, i = 0) {
    YC.prototype.isVector2 = !0, this.x = e, this.y = i;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, i) {
    return this.x = e, this.y = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * i + s[3] * n + s[6], this.y = s[1] * i + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos($i(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y;
    return i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this;
  }
  rotateAround(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = this.x - e.x, o = this.y - e.y;
    return this.x = a * n - o * s + e.x, this.y = a * s + o * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}, Ot = class $C {
  constructor(e, i, n, s, a, o, l, u, c) {
    $C.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c);
  }
  set(e, i, n, s, a, o, l, u, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = l, h[3] = i, h[4] = a, h[5] = u, h[6] = n, h[7] = o, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrix3Column(this, 0), i.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[4],
      i[8],
      i[1],
      i[5],
      i[9],
      i[2],
      i[6],
      i[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[3], u = n[6], c = n[1], h = n[4], d = n[7], p = n[2], f = n[5], m = n[8], v = s[0], y = s[3], g = s[6], _ = s[1], x = s[4], b = s[7], T = s[2], S = s[5], w = s[8];
    return a[0] = o * v + l * _ + u * T, a[3] = o * y + l * x + u * S, a[6] = o * g + l * b + u * w, a[1] = c * v + h * _ + d * T, a[4] = c * y + h * x + d * S, a[7] = c * g + h * b + d * w, a[2] = p * v + f * _ + m * T, a[5] = p * y + f * x + m * S, a[8] = p * g + f * b + m * w, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= e, i[4] *= e, i[7] *= e, i[2] *= e, i[5] *= e, i[8] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8];
    return i * o * h - i * l * c - n * a * h + n * l * u + s * a * c - s * o * u;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = h * o - l * c, p = l * u - h * a, f = c * a - o * u, m = i * d + n * p + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / m;
    return e[0] = d * v, e[1] = (s * c - h * n) * v, e[2] = (l * n - s * o) * v, e[3] = p * v, e[4] = (h * i - s * u) * v, e[5] = (s * a - l * i) * v, e[6] = f * v, e[7] = (n * u - c * i) * v, e[8] = (o * i - n * a) * v, this;
  }
  transpose() {
    let e;
    const i = this.elements;
    return e = i[1], i[1] = i[3], i[3] = e, e = i[2], i[2] = i[6], i[6] = e, e = i[5], i[5] = i[7], i[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const i = this.elements;
    return e[0] = i[0], e[1] = i[3], e[2] = i[6], e[3] = i[1], e[4] = i[4], e[5] = i[7], e[6] = i[2], e[7] = i[5], e[8] = i[8], this;
  }
  setUvTransform(e, i, n, s, a, o, l) {
    const u = Math.cos(a), c = Math.sin(a);
    return this.set(
      n * u,
      n * c,
      -n * (u * o + c * l) + o + e,
      -s * c,
      s * u,
      -s * (-c * o + u * l) + l + i,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, i) {
    return this.premultiply(vy.makeScale(e, i)), this;
  }
  rotate(e) {
    return this.premultiply(vy.makeRotation(-e)), this;
  }
  translate(e, i) {
    return this.premultiply(vy.makeTranslation(e, i)), this;
  }
  // for 2D Transforms
  makeTranslation(e, i) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      i,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      n,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i) {
    return this.set(
      e,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
const vy = /* @__PURE__ */ new Ot();
function KC(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function dd(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function fB() {
  const r = dd("canvas");
  return r.style.display = "block", r;
}
const w1 = {};
function Uh(r) {
  r in w1 || (w1[r] = !0, console.warn(r));
}
function mB(r, e, i) {
  return new Promise(function(n, s) {
    function a() {
      switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case r.WAIT_FAILED:
          s();
          break;
        case r.TIMEOUT_EXPIRED:
          setTimeout(a, i);
          break;
        default:
          n();
      }
    }
    setTimeout(a, i);
  });
}
function gB(r) {
  const e = r.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function yB(r) {
  const e = r.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const Gt = {
  enabled: !0,
  workingColorSpace: kc,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(r, e, i) {
    return this.enabled === !1 || e === i || !e || !i || (this.spaces[e].transfer === ei && (r.r = pa(r.r), r.g = pa(r.g), r.b = pa(r.b)), this.spaces[e].primaries !== this.spaces[i].primaries && (r.applyMatrix3(this.spaces[e].toXYZ), r.applyMatrix3(this.spaces[i].fromXYZ)), this.spaces[i].transfer === ei && (r.r = qu(r.r), r.g = qu(r.g), r.b = qu(r.b))), r;
  },
  fromWorkingColorSpace: function(r, e) {
    return this.convert(r, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(r, e) {
    return this.convert(r, e, this.workingColorSpace);
  },
  getPrimaries: function(r) {
    return this.spaces[r].primaries;
  },
  getTransfer: function(r) {
    return r === to ? yg : this.spaces[r].transfer;
  },
  getLuminanceCoefficients: function(r, e = this.workingColorSpace) {
    return r.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(r) {
    Object.assign(this.spaces, r);
  },
  // Internal APIs
  _getMatrix: function(r, e, i) {
    return r.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(r) {
    return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(r = this.workingColorSpace) {
    return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
  }
};
function pa(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function qu(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const E1 = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], M1 = [0.2126, 0.7152, 0.0722], A1 = [0.3127, 0.329], C1 = /* @__PURE__ */ new Ot().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), R1 = /* @__PURE__ */ new Ot().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
Gt.define({
  [kc]: {
    primaries: E1,
    whitePoint: A1,
    transfer: yg,
    toXYZ: C1,
    fromXYZ: R1,
    luminanceCoefficients: M1,
    workingColorSpaceConfig: { unpackColorSpace: ln },
    outputColorSpaceConfig: { drawingBufferColorSpace: ln }
  },
  [ln]: {
    primaries: E1,
    whitePoint: A1,
    transfer: ei,
    toXYZ: C1,
    fromXYZ: R1,
    luminanceCoefficients: M1,
    outputColorSpaceConfig: { drawingBufferColorSpace: ln }
  }
});
let Gl, vB = class {
  static getDataURL(r) {
    if (/^data:/i.test(r.src) || typeof HTMLCanvasElement > "u")
      return r.src;
    let e;
    if (r instanceof HTMLCanvasElement)
      e = r;
    else {
      Gl === void 0 && (Gl = dd("canvas")), Gl.width = r.width, Gl.height = r.height;
      const i = Gl.getContext("2d");
      r instanceof ImageData ? i.putImageData(r, 0, 0) : i.drawImage(r, 0, 0, r.width, r.height), e = Gl;
    }
    return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", r), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
  }
  static sRGBToLinear(r) {
    if (typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap) {
      const e = dd("canvas");
      e.width = r.width, e.height = r.height;
      const i = e.getContext("2d");
      i.drawImage(r, 0, 0, r.width, r.height);
      const n = i.getImageData(0, 0, r.width, r.height), s = n.data;
      for (let a = 0; a < s.length; a++)
        s[a] = pa(s[a] / 255) * 255;
      return i.putImageData(n, 0, 0), e;
    } else if (r.data) {
      const e = r.data.slice(0);
      for (let i = 0; i < e.length; i++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[i] = Math.floor(pa(e[i] / 255) * 255) : e[i] = pa(e[i]);
      return {
        data: e,
        width: r.width,
        height: r.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), r;
  }
}, bB = 0, QC = class {
  constructor(r = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: bB++ }), this.uuid = da(), this.data = r, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  toJSON(r) {
    const e = r === void 0 || typeof r == "string";
    if (!e && r.images[this.uuid] !== void 0)
      return r.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, n = this.data;
    if (n !== null) {
      let s;
      if (Array.isArray(n)) {
        s = [];
        for (let a = 0, o = n.length; a < o; a++)
          n[a].isDataTexture ? s.push(by(n[a].image)) : s.push(by(n[a]));
      } else
        s = by(n);
      i.url = s;
    }
    return e || (r.images[this.uuid] = i), i;
  }
};
function by(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? vB.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let xB = 0, Cn = class $f extends Nl {
  constructor(e = $f.DEFAULT_IMAGE, i = $f.DEFAULT_MAPPING, n = nl, s = nl, a = gs, o = sl, l = Kn, u = Ta, c = $f.DEFAULT_ANISOTROPY, h = to) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: xB++ }), this.uuid = da(), this.name = "", this.source = new QC(e), this.mipmaps = [], this.mapping = i, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = a, this.minFilter = o, this.anisotropy = c, this.format = l, this.internalFormat = null, this.type = u, this.offset = new Le(0, 0), this.repeat = new Le(1, 1), this.center = new Le(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ot(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), i || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== kC) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case sb:
          e.x = e.x - Math.floor(e.x);
          break;
        case nl:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case ab:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case sb:
          e.y = e.y - Math.floor(e.y);
          break;
        case nl:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case ab:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
};
Cn.DEFAULT_IMAGE = null;
Cn.DEFAULT_MAPPING = kC;
Cn.DEFAULT_ANISOTROPY = 1;
let Fi = class ZC {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    ZC.prototype.isVector4 = !0, this.x = e, this.y = i, this.z = n, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, i, n, s) {
    return this.x = e, this.y = i, this.z = n, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      case 3:
        this.w = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this.w = e.w + i.w, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this.w += e.w * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this.w = e.w - i.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = this.w, o = e.elements;
    return this.x = o[0] * i + o[4] * n + o[8] * s + o[12] * a, this.y = o[1] * i + o[5] * n + o[9] * s + o[13] * a, this.z = o[2] * i + o[6] * n + o[10] * s + o[14] * a, this.w = o[3] * i + o[7] * n + o[11] * s + o[15] * a, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const i = Math.sqrt(1 - e.w * e.w);
    return i < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / i, this.y = e.y / i, this.z = e.z / i), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let i, n, s, a;
    const o = e.elements, l = o[0], u = o[4], c = o[8], h = o[1], d = o[5], p = o[9], f = o[2], m = o[6], v = o[10];
    if (Math.abs(u - h) < 0.01 && Math.abs(c - f) < 0.01 && Math.abs(p - m) < 0.01) {
      if (Math.abs(u + h) < 0.1 && Math.abs(c + f) < 0.1 && Math.abs(p + m) < 0.1 && Math.abs(l + d + v - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      i = Math.PI;
      const g = (l + 1) / 2, _ = (d + 1) / 2, x = (v + 1) / 2, b = (u + h) / 4, T = (c + f) / 4, S = (p + m) / 4;
      return g > _ && g > x ? g < 0.01 ? (n = 0, s = 0.707106781, a = 0.707106781) : (n = Math.sqrt(g), s = b / n, a = T / n) : _ > x ? _ < 0.01 ? (n = 0.707106781, s = 0, a = 0.707106781) : (s = Math.sqrt(_), n = b / s, a = S / s) : x < 0.01 ? (n = 0.707106781, s = 0.707106781, a = 0) : (a = Math.sqrt(x), n = T / a, s = S / a), this.set(n, s, a, i), this;
    }
    let y = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (h - u) * (h - u));
    return Math.abs(y) < 1e-3 && (y = 1), this.x = (m - p) / y, this.y = (c - f) / y, this.z = (h - u) / y, this.w = Math.acos((l + d + v - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this.w = i[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this.w = Math.max(e.w, Math.min(i.w, this.w)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this.w = Math.max(e, Math.min(i, this.w)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this.w += (e.w - this.w) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this.w = e.w + (i.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this.w = e[i + 3], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e[i + 3] = this.w, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this.w = e.getW(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}, _B = class extends Nl {
  constructor(r = 1, e = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = r, this.height = e, this.depth = 1, this.scissor = new Fi(0, 0, r, e), this.scissorTest = !1, this.viewport = new Fi(0, 0, r, e);
    const n = { width: r, height: e, depth: 1 };
    i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: gs,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, i);
    const s = new Cn(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    s.flipY = !1, s.generateMipmaps = i.generateMipmaps, s.internalFormat = i.internalFormat, this.textures = [];
    const a = i.count;
    for (let o = 0; o < a; o++)
      this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = !0;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(r) {
    this.textures[0] = r;
  }
  setSize(r, e, i = 1) {
    if (this.width !== r || this.height !== e || this.depth !== i) {
      this.width = r, this.height = e, this.depth = i;
      for (let n = 0, s = this.textures.length; n < s; n++)
        this.textures[n].image.width = r, this.textures[n].image.height = e, this.textures[n].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, r, e), this.scissor.set(0, 0, r, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    this.width = r.width, this.height = r.height, this.depth = r.depth, this.scissor.copy(r.scissor), this.scissorTest = r.scissorTest, this.viewport.copy(r.viewport), this.textures.length = 0;
    for (let i = 0, n = r.textures.length; i < n; i++)
      this.textures[i] = r.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
    const e = Object.assign({}, r.texture.image);
    return this.texture.source = new QC(e), this.depthBuffer = r.depthBuffer, this.stencilBuffer = r.stencilBuffer, this.resolveDepthBuffer = r.resolveDepthBuffer, this.resolveStencilBuffer = r.resolveStencilBuffer, r.depthTexture !== null && (this.depthTexture = r.depthTexture.clone()), this.samples = r.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}, vo = class extends _B {
  constructor(r = 1, e = 1, i = {}) {
    super(r, e, i), this.isWebGLRenderTarget = !0;
  }
}, JC = class extends Cn {
  constructor(r = null, e = 1, i = 1, n = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: r, width: e, height: i, depth: n }, this.magFilter = Jn, this.minFilter = Jn, this.wrapR = nl, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(r) {
    this.layerUpdates.add(r);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
};
class TB extends Cn {
  constructor(e = null, i = 1, n = 1, s = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: i, height: n, depth: s }, this.magFilter = Jn, this.minFilter = Jn, this.wrapR = nl, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
let Ts = class {
  constructor(r = 0, e = 0, i = 0, n = 1) {
    this.isQuaternion = !0, this._x = r, this._y = e, this._z = i, this._w = n;
  }
  static slerpFlat(r, e, i, n, s, a, o) {
    let l = i[n + 0], u = i[n + 1], c = i[n + 2], h = i[n + 3];
    const d = s[a + 0], p = s[a + 1], f = s[a + 2], m = s[a + 3];
    if (o === 0) {
      r[e + 0] = l, r[e + 1] = u, r[e + 2] = c, r[e + 3] = h;
      return;
    }
    if (o === 1) {
      r[e + 0] = d, r[e + 1] = p, r[e + 2] = f, r[e + 3] = m;
      return;
    }
    if (h !== m || l !== d || u !== p || c !== f) {
      let v = 1 - o;
      const y = l * d + u * p + c * f + h * m, g = y >= 0 ? 1 : -1, _ = 1 - y * y;
      if (_ > Number.EPSILON) {
        const b = Math.sqrt(_), T = Math.atan2(b, y * g);
        v = Math.sin(v * T) / b, o = Math.sin(o * T) / b;
      }
      const x = o * g;
      if (l = l * v + d * x, u = u * v + p * x, c = c * v + f * x, h = h * v + m * x, v === 1 - o) {
        const b = 1 / Math.sqrt(l * l + u * u + c * c + h * h);
        l *= b, u *= b, c *= b, h *= b;
      }
    }
    r[e] = l, r[e + 1] = u, r[e + 2] = c, r[e + 3] = h;
  }
  static multiplyQuaternionsFlat(r, e, i, n, s, a) {
    const o = i[n], l = i[n + 1], u = i[n + 2], c = i[n + 3], h = s[a], d = s[a + 1], p = s[a + 2], f = s[a + 3];
    return r[e] = o * f + c * h + l * p - u * d, r[e + 1] = l * f + c * d + u * h - o * p, r[e + 2] = u * f + c * p + o * d - l * h, r[e + 3] = c * f - o * h - l * d - u * p, r;
  }
  get x() {
    return this._x;
  }
  set x(r) {
    this._x = r, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(r) {
    this._y = r, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(r) {
    this._z = r, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(r) {
    this._w = r, this._onChangeCallback();
  }
  set(r, e, i, n) {
    return this._x = r, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(r) {
    return this._x = r.x, this._y = r.y, this._z = r.z, this._w = r.w, this._onChangeCallback(), this;
  }
  setFromEuler(r, e = !0) {
    const i = r._x, n = r._y, s = r._z, a = r._order, o = Math.cos, l = Math.sin, u = o(i / 2), c = o(n / 2), h = o(s / 2), d = l(i / 2), p = l(n / 2), f = l(s / 2);
    switch (a) {
      case "XYZ":
        this._x = d * c * h + u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "YXZ":
        this._x = d * c * h + u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h + d * p * f;
        break;
      case "ZXY":
        this._x = d * c * h - u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "ZYX":
        this._x = d * c * h - u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h + d * p * f;
        break;
      case "YZX":
        this._x = d * c * h + u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "XZY":
        this._x = d * c * h - u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h + d * p * f;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(r, e) {
    const i = e / 2, n = Math.sin(i);
    return this._x = r.x * n, this._y = r.y * n, this._z = r.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(r) {
    const e = r.elements, i = e[0], n = e[4], s = e[8], a = e[1], o = e[5], l = e[9], u = e[2], c = e[6], h = e[10], d = i + o + h;
    if (d > 0) {
      const p = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / p, this._x = (c - l) * p, this._y = (s - u) * p, this._z = (a - n) * p;
    } else if (i > o && i > h) {
      const p = 2 * Math.sqrt(1 + i - o - h);
      this._w = (c - l) / p, this._x = 0.25 * p, this._y = (n + a) / p, this._z = (s + u) / p;
    } else if (o > h) {
      const p = 2 * Math.sqrt(1 + o - i - h);
      this._w = (s - u) / p, this._x = (n + a) / p, this._y = 0.25 * p, this._z = (l + c) / p;
    } else {
      const p = 2 * Math.sqrt(1 + h - i - o);
      this._w = (a - n) / p, this._x = (s + u) / p, this._y = (l + c) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(r, e) {
    let i = r.dot(e) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(r.x) > Math.abs(r.z) ? (this._x = -r.y, this._y = r.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -r.z, this._z = r.y, this._w = i)) : (this._x = r.y * e.z - r.z * e.y, this._y = r.z * e.x - r.x * e.z, this._z = r.x * e.y - r.y * e.x, this._w = i), this.normalize();
  }
  angleTo(r) {
    return 2 * Math.acos(Math.abs($i(this.dot(r), -1, 1)));
  }
  rotateTowards(r, e) {
    const i = this.angleTo(r);
    if (i === 0) return this;
    const n = Math.min(1, e / i);
    return this.slerp(r, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(r) {
    return this._x * r._x + this._y * r._y + this._z * r._z + this._w * r._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let r = this.length();
    return r === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (r = 1 / r, this._x = this._x * r, this._y = this._y * r, this._z = this._z * r, this._w = this._w * r), this._onChangeCallback(), this;
  }
  multiply(r) {
    return this.multiplyQuaternions(this, r);
  }
  premultiply(r) {
    return this.multiplyQuaternions(r, this);
  }
  multiplyQuaternions(r, e) {
    const i = r._x, n = r._y, s = r._z, a = r._w, o = e._x, l = e._y, u = e._z, c = e._w;
    return this._x = i * c + a * o + n * u - s * l, this._y = n * c + a * l + s * o - i * u, this._z = s * c + a * u + i * l - n * o, this._w = a * c - i * o - n * l - s * u, this._onChangeCallback(), this;
  }
  slerp(r, e) {
    if (e === 0) return this;
    if (e === 1) return this.copy(r);
    const i = this._x, n = this._y, s = this._z, a = this._w;
    let o = a * r._w + i * r._x + n * r._y + s * r._z;
    if (o < 0 ? (this._w = -r._w, this._x = -r._x, this._y = -r._y, this._z = -r._z, o = -o) : this.copy(r), o >= 1)
      return this._w = a, this._x = i, this._y = n, this._z = s, this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const p = 1 - e;
      return this._w = p * a + e * this._w, this._x = p * i + e * this._x, this._y = p * n + e * this._y, this._z = p * s + e * this._z, this.normalize(), this;
    }
    const u = Math.sqrt(l), c = Math.atan2(u, o), h = Math.sin((1 - e) * c) / u, d = Math.sin(e * c) / u;
    return this._w = a * h + this._w * d, this._x = i * h + this._x * d, this._y = n * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(r, e, i) {
    return this.copy(r).slerp(e, i);
  }
  random() {
    const r = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), s = Math.sqrt(i);
    return this.set(
      n * Math.sin(r),
      n * Math.cos(r),
      s * Math.sin(e),
      s * Math.cos(e)
    );
  }
  equals(r) {
    return r._x === this._x && r._y === this._y && r._z === this._z && r._w === this._w;
  }
  fromArray(r, e = 0) {
    return this._x = r[e], this._y = r[e + 1], this._z = r[e + 2], this._w = r[e + 3], this._onChangeCallback(), this;
  }
  toArray(r = [], e = 0) {
    return r[e] = this._x, r[e + 1] = this._y, r[e + 2] = this._z, r[e + 3] = this._w, r;
  }
  fromBufferAttribute(r, e) {
    return this._x = r.getX(e), this._y = r.getY(e), this._z = r.getZ(e), this._w = r.getW(e), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(r) {
    return this._onChangeCallback = r, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}, X = class eR {
  constructor(e = 0, i = 0, n = 0) {
    eR.prototype.isVector3 = !0, this.x = e, this.y = i, this.z = n;
  }
  set(e, i, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = i, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, i) {
    return this.x = e.x * i.x, this.y = e.y * i.y, this.z = e.z * i.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(N1.setFromEuler(e));
  }
  applyAxisAngle(e, i) {
    return this.applyQuaternion(N1.setFromAxisAngle(e, i));
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[3] * n + a[6] * s, this.y = a[1] * i + a[4] * n + a[7] * s, this.z = a[2] * i + a[5] * n + a[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements, o = 1 / (a[3] * i + a[7] * n + a[11] * s + a[15]);
    return this.x = (a[0] * i + a[4] * n + a[8] * s + a[12]) * o, this.y = (a[1] * i + a[5] * n + a[9] * s + a[13]) * o, this.z = (a[2] * i + a[6] * n + a[10] * s + a[14]) * o, this;
  }
  applyQuaternion(e) {
    const i = this.x, n = this.y, s = this.z, a = e.x, o = e.y, l = e.z, u = e.w, c = 2 * (o * s - l * n), h = 2 * (l * i - a * s), d = 2 * (a * n - o * i);
    return this.x = i + u * c + o * d - l * h, this.y = n + u * h + l * c - a * d, this.z = s + u * d + a * h - o * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[4] * n + a[8] * s, this.y = a[1] * i + a[5] * n + a[9] * s, this.z = a[2] * i + a[6] * n + a[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, i) {
    const n = e.x, s = e.y, a = e.z, o = i.x, l = i.y, u = i.z;
    return this.x = s * u - a * l, this.y = a * o - n * u, this.z = n * l - s * o, this;
  }
  projectOnVector(e) {
    const i = e.lengthSq();
    if (i === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / i;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return xy.copy(this).projectOnVector(e), this.sub(xy);
  }
  reflect(e) {
    return this.sub(xy.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos($i(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
    return i * i + n * n + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, i, n) {
    const s = Math.sin(i) * e;
    return this.x = s * Math.sin(n), this.y = Math.cos(i) * e, this.z = s * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, i, n) {
    return this.x = e * Math.sin(i), this.y = n, this.z = e * Math.cos(i), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this;
  }
  setFromMatrixScale(e) {
    const i = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = i, this.y = n, this.z = s, this;
  }
  setFromMatrixColumn(e, i) {
    return this.fromArray(e.elements, i * 4);
  }
  setFromMatrix3Column(e, i) {
    return this.fromArray(e.elements, i * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, i = Math.random() * 2 - 1, n = Math.sqrt(1 - i * i);
    return this.x = n * Math.cos(e), this.y = i, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
};
const xy = /* @__PURE__ */ new X(), N1 = /* @__PURE__ */ new Ts();
let Pl = class {
  constructor(r = new X(1 / 0, 1 / 0, 1 / 0), e = new X(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = r, this.max = e;
  }
  set(r, e) {
    return this.min.copy(r), this.max.copy(e), this;
  }
  setFromArray(r) {
    this.makeEmpty();
    for (let e = 0, i = r.length; e < i; e += 3)
      this.expandByPoint(On.fromArray(r, e));
    return this;
  }
  setFromBufferAttribute(r) {
    this.makeEmpty();
    for (let e = 0, i = r.count; e < i; e++)
      this.expandByPoint(On.fromBufferAttribute(r, e));
    return this;
  }
  setFromPoints(r) {
    this.makeEmpty();
    for (let e = 0, i = r.length; e < i; e++)
      this.expandByPoint(r[e]);
    return this;
  }
  setFromCenterAndSize(r, e) {
    const i = On.copy(e).multiplyScalar(0.5);
    return this.min.copy(r).sub(i), this.max.copy(r).add(i), this;
  }
  setFromObject(r, e = !1) {
    return this.makeEmpty(), this.expandByObject(r, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    return this.min.copy(r.min), this.max.copy(r.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(r) {
    return this.isEmpty() ? r.set(0, 0, 0) : r.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(r) {
    return this.isEmpty() ? r.set(0, 0, 0) : r.subVectors(this.max, this.min);
  }
  expandByPoint(r) {
    return this.min.min(r), this.max.max(r), this;
  }
  expandByVector(r) {
    return this.min.sub(r), this.max.add(r), this;
  }
  expandByScalar(r) {
    return this.min.addScalar(-r), this.max.addScalar(r), this;
  }
  expandByObject(r, e = !1) {
    r.updateWorldMatrix(!1, !1);
    const i = r.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (e === !0 && s !== void 0 && r.isInstancedMesh !== !0)
        for (let a = 0, o = s.count; a < o; a++)
          r.isMesh === !0 ? r.getVertexPosition(a, On) : On.fromBufferAttribute(s, a), On.applyMatrix4(r.matrixWorld), this.expandByPoint(On);
      else
        r.boundingBox !== void 0 ? (r.boundingBox === null && r.computeBoundingBox(), dp.copy(r.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), dp.copy(i.boundingBox)), dp.applyMatrix4(r.matrixWorld), this.union(dp);
    }
    const n = r.children;
    for (let s = 0, a = n.length; s < a; s++)
      this.expandByObject(n[s], e);
    return this;
  }
  containsPoint(r) {
    return r.x >= this.min.x && r.x <= this.max.x && r.y >= this.min.y && r.y <= this.max.y && r.z >= this.min.z && r.z <= this.max.z;
  }
  containsBox(r) {
    return this.min.x <= r.min.x && r.max.x <= this.max.x && this.min.y <= r.min.y && r.max.y <= this.max.y && this.min.z <= r.min.z && r.max.z <= this.max.z;
  }
  getParameter(r, e) {
    return e.set(
      (r.x - this.min.x) / (this.max.x - this.min.x),
      (r.y - this.min.y) / (this.max.y - this.min.y),
      (r.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(r) {
    return r.max.x >= this.min.x && r.min.x <= this.max.x && r.max.y >= this.min.y && r.min.y <= this.max.y && r.max.z >= this.min.z && r.min.z <= this.max.z;
  }
  intersectsSphere(r) {
    return this.clampPoint(r.center, On), On.distanceToSquared(r.center) <= r.radius * r.radius;
  }
  intersectsPlane(r) {
    let e, i;
    return r.normal.x > 0 ? (e = r.normal.x * this.min.x, i = r.normal.x * this.max.x) : (e = r.normal.x * this.max.x, i = r.normal.x * this.min.x), r.normal.y > 0 ? (e += r.normal.y * this.min.y, i += r.normal.y * this.max.y) : (e += r.normal.y * this.max.y, i += r.normal.y * this.min.y), r.normal.z > 0 ? (e += r.normal.z * this.min.z, i += r.normal.z * this.max.z) : (e += r.normal.z * this.max.z, i += r.normal.z * this.min.z), e <= -r.constant && i >= -r.constant;
  }
  intersectsTriangle(r) {
    if (this.isEmpty())
      return !1;
    this.getCenter(ih), pp.subVectors(this.max, ih), Hl.subVectors(r.a, ih), Wl.subVectors(r.b, ih), ql.subVectors(r.c, ih), Ia.subVectors(Wl, Hl), Da.subVectors(ql, Wl), Po.subVectors(Hl, ql);
    let e = [
      0,
      -Ia.z,
      Ia.y,
      0,
      -Da.z,
      Da.y,
      0,
      -Po.z,
      Po.y,
      Ia.z,
      0,
      -Ia.x,
      Da.z,
      0,
      -Da.x,
      Po.z,
      0,
      -Po.x,
      -Ia.y,
      Ia.x,
      0,
      -Da.y,
      Da.x,
      0,
      -Po.y,
      Po.x,
      0
    ];
    return !_y(e, Hl, Wl, ql, pp) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !_y(e, Hl, Wl, ql, pp)) ? !1 : (fp.crossVectors(Ia, Da), e = [fp.x, fp.y, fp.z], _y(e, Hl, Wl, ql, pp));
  }
  clampPoint(r, e) {
    return e.copy(r).clamp(this.min, this.max);
  }
  distanceToPoint(r) {
    return this.clampPoint(r, On).distanceTo(r);
  }
  getBoundingSphere(r) {
    return this.isEmpty() ? r.makeEmpty() : (this.getCenter(r.center), r.radius = this.getSize(On).length() * 0.5), r;
  }
  intersect(r) {
    return this.min.max(r.min), this.max.min(r.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(r) {
    return this.min.min(r.min), this.max.max(r.max), this;
  }
  applyMatrix4(r) {
    return this.isEmpty() ? this : (Ns[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(r), Ns[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(r), Ns[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(r), Ns[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(r), Ns[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(r), Ns[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(r), Ns[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(r), Ns[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(r), this.setFromPoints(Ns), this);
  }
  translate(r) {
    return this.min.add(r), this.max.add(r), this;
  }
  equals(r) {
    return r.min.equals(this.min) && r.max.equals(this.max);
  }
};
const Ns = [
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X(),
  /* @__PURE__ */ new X()
], On = /* @__PURE__ */ new X(), dp = /* @__PURE__ */ new Pl(), Hl = /* @__PURE__ */ new X(), Wl = /* @__PURE__ */ new X(), ql = /* @__PURE__ */ new X(), Ia = /* @__PURE__ */ new X(), Da = /* @__PURE__ */ new X(), Po = /* @__PURE__ */ new X(), ih = /* @__PURE__ */ new X(), pp = /* @__PURE__ */ new X(), fp = /* @__PURE__ */ new X(), Oo = /* @__PURE__ */ new X();
function _y(r, e, i, n, s) {
  for (let a = 0, o = r.length - 3; a <= o; a += 3) {
    Oo.fromArray(r, a);
    const l = s.x * Math.abs(Oo.x) + s.y * Math.abs(Oo.y) + s.z * Math.abs(Oo.z), u = e.dot(Oo), c = i.dot(Oo), h = n.dot(Oo);
    if (Math.max(-Math.max(u, c, h), Math.min(u, c, h)) > l)
      return !1;
  }
  return !0;
}
const SB = /* @__PURE__ */ new Pl(), rh = /* @__PURE__ */ new X(), Ty = /* @__PURE__ */ new X();
let vg = class {
  constructor(r = new X(), e = -1) {
    this.isSphere = !0, this.center = r, this.radius = e;
  }
  set(r, e) {
    return this.center.copy(r), this.radius = e, this;
  }
  setFromPoints(r, e) {
    const i = this.center;
    e !== void 0 ? i.copy(e) : SB.setFromPoints(r).getCenter(i);
    let n = 0;
    for (let s = 0, a = r.length; s < a; s++)
      n = Math.max(n, i.distanceToSquared(r[s]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(r) {
    return this.center.copy(r.center), this.radius = r.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(r) {
    return r.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(r) {
    return r.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(r) {
    const e = this.radius + r.radius;
    return r.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(r) {
    return r.intersectsSphere(this);
  }
  intersectsPlane(r) {
    return Math.abs(r.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(r, e) {
    const i = this.center.distanceToSquared(r);
    return e.copy(r), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  }
  getBoundingBox(r) {
    return this.isEmpty() ? (r.makeEmpty(), r) : (r.set(this.center, this.center), r.expandByScalar(this.radius), r);
  }
  applyMatrix4(r) {
    return this.center.applyMatrix4(r), this.radius = this.radius * r.getMaxScaleOnAxis(), this;
  }
  translate(r) {
    return this.center.add(r), this;
  }
  expandByPoint(r) {
    if (this.isEmpty())
      return this.center.copy(r), this.radius = 0, this;
    rh.subVectors(r, this.center);
    const e = rh.lengthSq();
    if (e > this.radius * this.radius) {
      const i = Math.sqrt(e), n = (i - this.radius) * 0.5;
      this.center.addScaledVector(rh, n / i), this.radius += n;
    }
    return this;
  }
  union(r) {
    return r.isEmpty() ? this : this.isEmpty() ? (this.copy(r), this) : (this.center.equals(r.center) === !0 ? this.radius = Math.max(this.radius, r.radius) : (Ty.subVectors(r.center, this.center).setLength(r.radius), this.expandByPoint(rh.copy(r.center).add(Ty)), this.expandByPoint(rh.copy(r.center).sub(Ty))), this);
  }
  equals(r) {
    return r.center.equals(this.center) && r.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const Ps = /* @__PURE__ */ new X(), Sy = /* @__PURE__ */ new X(), mp = /* @__PURE__ */ new X(), ka = /* @__PURE__ */ new X(), wy = /* @__PURE__ */ new X(), gp = /* @__PURE__ */ new X(), Ey = /* @__PURE__ */ new X();
let bg = class {
  constructor(r = new X(), e = new X(0, 0, -1)) {
    this.origin = r, this.direction = e;
  }
  set(r, e) {
    return this.origin.copy(r), this.direction.copy(e), this;
  }
  copy(r) {
    return this.origin.copy(r.origin), this.direction.copy(r.direction), this;
  }
  at(r, e) {
    return e.copy(this.origin).addScaledVector(this.direction, r);
  }
  lookAt(r) {
    return this.direction.copy(r).sub(this.origin).normalize(), this;
  }
  recast(r) {
    return this.origin.copy(this.at(r, Ps)), this;
  }
  closestPointToPoint(r, e) {
    e.subVectors(r, this.origin);
    const i = e.dot(this.direction);
    return i < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(r) {
    return Math.sqrt(this.distanceSqToPoint(r));
  }
  distanceSqToPoint(r) {
    const e = Ps.subVectors(r, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(r) : (Ps.copy(this.origin).addScaledVector(this.direction, e), Ps.distanceToSquared(r));
  }
  distanceSqToSegment(r, e, i, n) {
    Sy.copy(r).add(e).multiplyScalar(0.5), mp.copy(e).sub(r).normalize(), ka.copy(this.origin).sub(Sy);
    const s = r.distanceTo(e) * 0.5, a = -this.direction.dot(mp), o = ka.dot(this.direction), l = -ka.dot(mp), u = ka.lengthSq(), c = Math.abs(1 - a * a);
    let h, d, p, f;
    if (c > 0)
      if (h = a * l - o, d = a * o - l, f = s * c, h >= 0)
        if (d >= -f)
          if (d <= f) {
            const m = 1 / c;
            h *= m, d *= m, p = h * (h + a * d + 2 * o) + d * (a * h + d + 2 * l) + u;
          } else
            d = s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
        else
          d = -s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
      else
        d <= -f ? (h = Math.max(0, -(-a * s + o)), d = h > 0 ? -s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + u) : d <= f ? (h = 0, d = Math.min(Math.max(-s, -l), s), p = d * (d + 2 * l) + u) : (h = Math.max(0, -(a * s + o)), d = h > 0 ? s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + u);
    else
      d = a > 0 ? -s : s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
    return i && i.copy(this.origin).addScaledVector(this.direction, h), n && n.copy(Sy).addScaledVector(mp, d), p;
  }
  intersectSphere(r, e) {
    Ps.subVectors(r.center, this.origin);
    const i = Ps.dot(this.direction), n = Ps.dot(Ps) - i * i, s = r.radius * r.radius;
    if (n > s) return null;
    const a = Math.sqrt(s - n), o = i - a, l = i + a;
    return l < 0 ? null : o < 0 ? this.at(l, e) : this.at(o, e);
  }
  intersectsSphere(r) {
    return this.distanceSqToPoint(r.center) <= r.radius * r.radius;
  }
  distanceToPlane(r) {
    const e = r.normal.dot(this.direction);
    if (e === 0)
      return r.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(r.normal) + r.constant) / e;
    return i >= 0 ? i : null;
  }
  intersectPlane(r, e) {
    const i = this.distanceToPlane(r);
    return i === null ? null : this.at(i, e);
  }
  intersectsPlane(r) {
    const e = r.distanceToPoint(this.origin);
    return e === 0 || r.normal.dot(this.direction) * e < 0;
  }
  intersectBox(r, e) {
    let i, n, s, a, o, l;
    const u = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin;
    return u >= 0 ? (i = (r.min.x - d.x) * u, n = (r.max.x - d.x) * u) : (i = (r.max.x - d.x) * u, n = (r.min.x - d.x) * u), c >= 0 ? (s = (r.min.y - d.y) * c, a = (r.max.y - d.y) * c) : (s = (r.max.y - d.y) * c, a = (r.min.y - d.y) * c), i > a || s > n || ((s > i || isNaN(i)) && (i = s), (a < n || isNaN(n)) && (n = a), h >= 0 ? (o = (r.min.z - d.z) * h, l = (r.max.z - d.z) * h) : (o = (r.max.z - d.z) * h, l = (r.min.z - d.z) * h), i > l || o > n) || ((o > i || i !== i) && (i = o), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(i >= 0 ? i : n, e);
  }
  intersectsBox(r) {
    return this.intersectBox(r, Ps) !== null;
  }
  intersectTriangle(r, e, i, n, s) {
    wy.subVectors(e, r), gp.subVectors(i, r), Ey.crossVectors(wy, gp);
    let a = this.direction.dot(Ey), o;
    if (a > 0) {
      if (n) return null;
      o = 1;
    } else if (a < 0)
      o = -1, a = -a;
    else
      return null;
    ka.subVectors(this.origin, r);
    const l = o * this.direction.dot(gp.crossVectors(ka, gp));
    if (l < 0)
      return null;
    const u = o * this.direction.dot(wy.cross(ka));
    if (u < 0 || l + u > a)
      return null;
    const c = -o * ka.dot(Ey);
    return c < 0 ? null : this.at(c / a, s);
  }
  applyMatrix4(r) {
    return this.origin.applyMatrix4(r), this.direction.transformDirection(r), this;
  }
  equals(r) {
    return r.origin.equals(this.origin) && r.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}, ui = class kb {
  constructor(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y) {
    kb.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y);
  }
  set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y) {
    const g = this.elements;
    return g[0] = e, g[4] = i, g[8] = n, g[12] = s, g[1] = a, g[5] = o, g[9] = l, g[13] = u, g[2] = c, g[6] = h, g[10] = d, g[14] = p, g[3] = f, g[7] = m, g[11] = v, g[15] = y, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new kb().fromArray(this.elements);
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], i[9] = n[9], i[10] = n[10], i[11] = n[11], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15], this;
  }
  copyPosition(e) {
    const i = this.elements, n = e.elements;
    return i[12] = n[12], i[13] = n[13], i[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[3],
      i[6],
      0,
      i[1],
      i[4],
      i[7],
      0,
      i[2],
      i[5],
      i[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrixColumn(this, 0), i.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, i, n) {
    return this.set(
      e.x,
      i.x,
      n.x,
      0,
      e.y,
      i.y,
      n.y,
      0,
      e.z,
      i.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const i = this.elements, n = e.elements, s = 1 / Xl.setFromMatrixColumn(e, 0).length(), a = 1 / Xl.setFromMatrixColumn(e, 1).length(), o = 1 / Xl.setFromMatrixColumn(e, 2).length();
    return i[0] = n[0] * s, i[1] = n[1] * s, i[2] = n[2] * s, i[3] = 0, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[7] = 0, i[8] = n[8] * o, i[9] = n[9] * o, i[10] = n[10] * o, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z, o = Math.cos(n), l = Math.sin(n), u = Math.cos(s), c = Math.sin(s), h = Math.cos(a), d = Math.sin(a);
    if (e.order === "XYZ") {
      const p = o * h, f = o * d, m = l * h, v = l * d;
      i[0] = u * h, i[4] = -u * d, i[8] = c, i[1] = f + m * c, i[5] = p - v * c, i[9] = -l * u, i[2] = v - p * c, i[6] = m + f * c, i[10] = o * u;
    } else if (e.order === "YXZ") {
      const p = u * h, f = u * d, m = c * h, v = c * d;
      i[0] = p + v * l, i[4] = m * l - f, i[8] = o * c, i[1] = o * d, i[5] = o * h, i[9] = -l, i[2] = f * l - m, i[6] = v + p * l, i[10] = o * u;
    } else if (e.order === "ZXY") {
      const p = u * h, f = u * d, m = c * h, v = c * d;
      i[0] = p - v * l, i[4] = -o * d, i[8] = m + f * l, i[1] = f + m * l, i[5] = o * h, i[9] = v - p * l, i[2] = -o * c, i[6] = l, i[10] = o * u;
    } else if (e.order === "ZYX") {
      const p = o * h, f = o * d, m = l * h, v = l * d;
      i[0] = u * h, i[4] = m * c - f, i[8] = p * c + v, i[1] = u * d, i[5] = v * c + p, i[9] = f * c - m, i[2] = -c, i[6] = l * u, i[10] = o * u;
    } else if (e.order === "YZX") {
      const p = o * u, f = o * c, m = l * u, v = l * c;
      i[0] = u * h, i[4] = v - p * d, i[8] = m * d + f, i[1] = d, i[5] = o * h, i[9] = -l * h, i[2] = -c * h, i[6] = f * d + m, i[10] = p - v * d;
    } else if (e.order === "XZY") {
      const p = o * u, f = o * c, m = l * u, v = l * c;
      i[0] = u * h, i[4] = -d, i[8] = c * h, i[1] = p * d + v, i[5] = o * h, i[9] = f * d - m, i[2] = m * d - f, i[6] = l * h, i[10] = v * d + p;
    }
    return i[3] = 0, i[7] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(wB, e, EB);
  }
  lookAt(e, i, n) {
    const s = this.elements;
    return Zr.subVectors(e, i), Zr.lengthSq() === 0 && (Zr.z = 1), Zr.normalize(), La.crossVectors(n, Zr), La.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Zr.x += 1e-4 : Zr.z += 1e-4, Zr.normalize(), La.crossVectors(n, Zr)), La.normalize(), yp.crossVectors(Zr, La), s[0] = La.x, s[4] = yp.x, s[8] = Zr.x, s[1] = La.y, s[5] = yp.y, s[9] = Zr.y, s[2] = La.z, s[6] = yp.z, s[10] = Zr.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[4], u = n[8], c = n[12], h = n[1], d = n[5], p = n[9], f = n[13], m = n[2], v = n[6], y = n[10], g = n[14], _ = n[3], x = n[7], b = n[11], T = n[15], S = s[0], w = s[4], C = s[8], E = s[12], A = s[1], N = s[5], L = s[9], F = s[13], M = s[2], P = s[6], O = s[10], V = s[14], B = s[3], H = s[7], U = s[11], j = s[15];
    return a[0] = o * S + l * A + u * M + c * B, a[4] = o * w + l * N + u * P + c * H, a[8] = o * C + l * L + u * O + c * U, a[12] = o * E + l * F + u * V + c * j, a[1] = h * S + d * A + p * M + f * B, a[5] = h * w + d * N + p * P + f * H, a[9] = h * C + d * L + p * O + f * U, a[13] = h * E + d * F + p * V + f * j, a[2] = m * S + v * A + y * M + g * B, a[6] = m * w + v * N + y * P + g * H, a[10] = m * C + v * L + y * O + g * U, a[14] = m * E + v * F + y * V + g * j, a[3] = _ * S + x * A + b * M + T * B, a[7] = _ * w + x * N + b * P + T * H, a[11] = _ * C + x * L + b * O + T * U, a[15] = _ * E + x * F + b * V + T * j, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[4] *= e, i[8] *= e, i[12] *= e, i[1] *= e, i[5] *= e, i[9] *= e, i[13] *= e, i[2] *= e, i[6] *= e, i[10] *= e, i[14] *= e, i[3] *= e, i[7] *= e, i[11] *= e, i[15] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[4], s = e[8], a = e[12], o = e[1], l = e[5], u = e[9], c = e[13], h = e[2], d = e[6], p = e[10], f = e[14], m = e[3], v = e[7], y = e[11], g = e[15];
    return m * (+a * u * d - s * c * d - a * l * p + n * c * p + s * l * f - n * u * f) + v * (+i * u * f - i * c * p + a * o * p - s * o * f + s * c * h - a * u * h) + y * (+i * c * d - i * l * f - a * o * d + n * o * f + a * l * h - n * c * h) + g * (-s * l * h - i * u * d + i * l * p + s * o * d - n * o * p + n * u * h);
  }
  transpose() {
    const e = this.elements;
    let i;
    return i = e[1], e[1] = e[4], e[4] = i, i = e[2], e[2] = e[8], e[8] = i, i = e[6], e[6] = e[9], e[9] = i, i = e[3], e[3] = e[12], e[12] = i, i = e[7], e[7] = e[13], e[13] = i, i = e[11], e[11] = e[14], e[14] = i, this;
  }
  setPosition(e, i, n) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = i, s[14] = n), this;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = e[9], p = e[10], f = e[11], m = e[12], v = e[13], y = e[14], g = e[15], _ = d * y * c - v * p * c + v * u * f - l * y * f - d * u * g + l * p * g, x = m * p * c - h * y * c - m * u * f + o * y * f + h * u * g - o * p * g, b = h * v * c - m * d * c + m * l * f - o * v * f - h * l * g + o * d * g, T = m * d * u - h * v * u - m * l * p + o * v * p + h * l * y - o * d * y, S = i * _ + n * x + s * b + a * T;
    if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / S;
    return e[0] = _ * w, e[1] = (v * p * a - d * y * a - v * s * f + n * y * f + d * s * g - n * p * g) * w, e[2] = (l * y * a - v * u * a + v * s * c - n * y * c - l * s * g + n * u * g) * w, e[3] = (d * u * a - l * p * a - d * s * c + n * p * c + l * s * f - n * u * f) * w, e[4] = x * w, e[5] = (h * y * a - m * p * a + m * s * f - i * y * f - h * s * g + i * p * g) * w, e[6] = (m * u * a - o * y * a - m * s * c + i * y * c + o * s * g - i * u * g) * w, e[7] = (o * p * a - h * u * a + h * s * c - i * p * c - o * s * f + i * u * f) * w, e[8] = b * w, e[9] = (m * d * a - h * v * a - m * n * f + i * v * f + h * n * g - i * d * g) * w, e[10] = (o * v * a - m * l * a + m * n * c - i * v * c - o * n * g + i * l * g) * w, e[11] = (h * l * a - o * d * a - h * n * c + i * d * c + o * n * f - i * l * f) * w, e[12] = T * w, e[13] = (h * v * s - m * d * s + m * n * p - i * v * p - h * n * y + i * d * y) * w, e[14] = (m * l * s - o * v * s - m * n * u + i * v * u + o * n * y - i * l * y) * w, e[15] = (o * d * s - h * l * s + h * n * u - i * d * u - o * n * p + i * l * p) * w, this;
  }
  scale(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z;
    return i[0] *= n, i[4] *= s, i[8] *= a, i[1] *= n, i[5] *= s, i[9] *= a, i[2] *= n, i[6] *= s, i[10] *= a, i[3] *= n, i[7] *= s, i[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(i, n, s));
  }
  makeTranslation(e, i, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      i,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = 1 - n, o = e.x, l = e.y, u = e.z, c = a * o, h = a * l;
    return this.set(
      c * o + n,
      c * l - s * u,
      c * u + s * l,
      0,
      c * l + s * u,
      h * l + n,
      h * u - s * o,
      0,
      c * u - s * l,
      h * u + s * o,
      a * u * u + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, i, n, s, a, o) {
    return this.set(
      1,
      n,
      a,
      0,
      e,
      1,
      o,
      0,
      i,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, i, n) {
    const s = this.elements, a = i._x, o = i._y, l = i._z, u = i._w, c = a + a, h = o + o, d = l + l, p = a * c, f = a * h, m = a * d, v = o * h, y = o * d, g = l * d, _ = u * c, x = u * h, b = u * d, T = n.x, S = n.y, w = n.z;
    return s[0] = (1 - (v + g)) * T, s[1] = (f + b) * T, s[2] = (m - x) * T, s[3] = 0, s[4] = (f - b) * S, s[5] = (1 - (p + g)) * S, s[6] = (y + _) * S, s[7] = 0, s[8] = (m + x) * w, s[9] = (y - _) * w, s[10] = (1 - (p + v)) * w, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, i, n) {
    const s = this.elements;
    let a = Xl.set(s[0], s[1], s[2]).length();
    const o = Xl.set(s[4], s[5], s[6]).length(), l = Xl.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (a = -a), e.x = s[12], e.y = s[13], e.z = s[14], In.copy(this);
    const u = 1 / a, c = 1 / o, h = 1 / l;
    return In.elements[0] *= u, In.elements[1] *= u, In.elements[2] *= u, In.elements[4] *= c, In.elements[5] *= c, In.elements[6] *= c, In.elements[8] *= h, In.elements[9] *= h, In.elements[10] *= h, i.setFromRotationMatrix(In), n.x = a, n.y = o, n.z = l, this;
  }
  makePerspective(e, i, n, s, a, o, l = oa) {
    const u = this.elements, c = 2 * a / (i - e), h = 2 * a / (n - s), d = (i + e) / (i - e), p = (n + s) / (n - s);
    let f, m;
    if (l === oa)
      f = -(o + a) / (o - a), m = -2 * o * a / (o - a);
    else if (l === ym)
      f = -o / (o - a), m = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return u[0] = c, u[4] = 0, u[8] = d, u[12] = 0, u[1] = 0, u[5] = h, u[9] = p, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = f, u[14] = m, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this;
  }
  makeOrthographic(e, i, n, s, a, o, l = oa) {
    const u = this.elements, c = 1 / (i - e), h = 1 / (n - s), d = 1 / (o - a), p = (i + e) * c, f = (n + s) * h;
    let m, v;
    if (l === oa)
      m = (o + a) * d, v = -2 * d;
    else if (l === ym)
      m = a * d, v = -1 * d;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return u[0] = 2 * c, u[4] = 0, u[8] = 0, u[12] = -p, u[1] = 0, u[5] = 2 * h, u[9] = 0, u[13] = -f, u[2] = 0, u[6] = 0, u[10] = v, u[14] = -m, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this;
  }
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 16; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e[i + 9] = n[9], e[i + 10] = n[10], e[i + 11] = n[11], e[i + 12] = n[12], e[i + 13] = n[13], e[i + 14] = n[14], e[i + 15] = n[15], e;
  }
};
const Xl = /* @__PURE__ */ new X(), In = /* @__PURE__ */ new ui(), wB = /* @__PURE__ */ new X(0, 0, 0), EB = /* @__PURE__ */ new X(1, 1, 1), La = /* @__PURE__ */ new X(), yp = /* @__PURE__ */ new X(), Zr = /* @__PURE__ */ new X(), P1 = /* @__PURE__ */ new ui(), O1 = /* @__PURE__ */ new Ts();
let bo = class tR {
  constructor(e = 0, i = 0, n = 0, s = tR.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = i, this._z = n, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, i, n, s = this._order) {
    return this._x = e, this._y = i, this._z = n, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, i = this._order, n = !0) {
    const s = e.elements, a = s[0], o = s[4], l = s[8], u = s[1], c = s[5], h = s[9], d = s[2], p = s[6], f = s[10];
    switch (i) {
      case "XYZ":
        this._y = Math.asin($i(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(p, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-$i(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(u, c)) : (this._y = Math.atan2(-d, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin($i(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(u, a));
        break;
      case "ZYX":
        this._y = Math.asin(-$i(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(u, a)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin($i(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-d, a)) : (this._x = 0, this._y = Math.atan2(l, f));
        break;
      case "XZY":
        this._z = Math.asin(-$i(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + i);
    }
    return this._order = i, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, i, n) {
    return P1.makeRotationFromQuaternion(e), this.setFromRotationMatrix(P1, i, n);
  }
  setFromVector3(e, i = this._order) {
    return this.set(e.x, e.y, e.z, i);
  }
  reorder(e) {
    return O1.setFromEuler(this), this.setFromQuaternion(O1, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
};
bo.DEFAULT_ORDER = "XYZ";
let P_ = class {
  constructor() {
    this.mask = 1;
  }
  set(r) {
    this.mask = (1 << r | 0) >>> 0;
  }
  enable(r) {
    this.mask |= 1 << r | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(r) {
    this.mask ^= 1 << r | 0;
  }
  disable(r) {
    this.mask &= ~(1 << r | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(r) {
    return (this.mask & r.mask) !== 0;
  }
  isEnabled(r) {
    return (this.mask & (1 << r | 0)) !== 0;
  }
}, MB = 0;
const I1 = /* @__PURE__ */ new X(), Yl = /* @__PURE__ */ new Ts(), Os = /* @__PURE__ */ new ui(), vp = /* @__PURE__ */ new X(), nh = /* @__PURE__ */ new X(), AB = /* @__PURE__ */ new X(), CB = /* @__PURE__ */ new Ts(), D1 = /* @__PURE__ */ new X(1, 0, 0), k1 = /* @__PURE__ */ new X(0, 1, 0), L1 = /* @__PURE__ */ new X(0, 0, 1), U1 = { type: "added" }, RB = { type: "removed" }, $l = { type: "childadded", child: null }, My = { type: "childremoved", child: null };
let Hr = class Kf extends Nl {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: MB++ }), this.uuid = da(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Kf.DEFAULT_UP.clone();
    const e = new X(), i = new bo(), n = new Ts(), s = new X(1, 1, 1);
    function a() {
      n.setFromEuler(i, !1);
    }
    function o() {
      i.setFromQuaternion(n, void 0, !1);
    }
    i._onChange(a), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      modelViewMatrix: {
        value: new ui()
      },
      normalMatrix: {
        value: new Ot()
      }
    }), this.matrix = new ui(), this.matrixWorld = new ui(), this.matrixAutoUpdate = Kf.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Kf.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new P_(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, i) {
    this.quaternion.setFromAxisAngle(e, i);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, i) {
    return Yl.setFromAxisAngle(e, i), this.quaternion.multiply(Yl), this;
  }
  rotateOnWorldAxis(e, i) {
    return Yl.setFromAxisAngle(e, i), this.quaternion.premultiply(Yl), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(D1, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(k1, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(L1, e);
  }
  translateOnAxis(e, i) {
    return I1.copy(e).applyQuaternion(this.quaternion), this.position.add(I1.multiplyScalar(i)), this;
  }
  translateX(e) {
    return this.translateOnAxis(D1, e);
  }
  translateY(e) {
    return this.translateOnAxis(k1, e);
  }
  translateZ(e) {
    return this.translateOnAxis(L1, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Os.copy(this.matrixWorld).invert());
  }
  lookAt(e, i, n) {
    e.isVector3 ? vp.copy(e) : vp.set(e, i, n);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), nh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Os.lookAt(nh, vp, this.up) : Os.lookAt(vp, nh, this.up), this.quaternion.setFromRotationMatrix(Os), s && (Os.extractRotation(s.matrixWorld), Yl.setFromRotationMatrix(Os), this.quaternion.premultiply(Yl.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.add(arguments[i]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(U1), $l.child = e, this.dispatchEvent($l), $l.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const i = this.children.indexOf(e);
    return i !== -1 && (e.parent = null, this.children.splice(i, 1), e.dispatchEvent(RB), My.child = e, this.dispatchEvent(My), My.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Os.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Os.multiply(e.parent.matrixWorld)), e.applyMatrix4(Os), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(U1), $l.child = e, this.dispatchEvent($l), $l.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, i) {
    if (this[e] === i) return this;
    for (let n = 0, s = this.children.length; n < s; n++) {
      const a = this.children[n].getObjectByProperty(e, i);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, i, n = []) {
    this[e] === i && n.push(this);
    const s = this.children;
    for (let a = 0, o = s.length; a < o; a++)
      s[a].getObjectsByProperty(e, i, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nh, e, AB), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nh, CB, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const i = this.matrixWorld.elements;
    return e.set(i[8], i[9], i[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const i = this.parent;
    i !== null && (e(i), i.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, i) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), i === !0) {
      const s = this.children;
      for (let a = 0, o = s.length; a < o; a++)
        s[a].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string", n = {};
    i && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
      center: s.boundingSphere.center.toArray(),
      radius: s.boundingSphere.radius
    }), this.boundingBox !== null && (s.boundingBox = {
      min: s.boundingBox.min.toArray(),
      max: s.boundingBox.max.toArray()
    }));
    function a(l, u) {
      return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = a(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const u = l.shapes;
        if (Array.isArray(u))
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c];
            a(e.shapes, d);
          }
        else
          a(e.shapes, u);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let u = 0, c = this.material.length; u < c; u++)
          l.push(a(e.materials, this.material[u]));
        s.material = l;
      } else
        s.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let l = 0; l < this.children.length; l++)
        s.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const u = this.animations[l];
        s.animations.push(a(e.animations, u));
      }
    }
    if (i) {
      const l = o(e.geometries), u = o(e.materials), c = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), f = o(e.animations), m = o(e.nodes);
      l.length > 0 && (n.geometries = l), u.length > 0 && (n.materials = u), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), d.length > 0 && (n.shapes = d), p.length > 0 && (n.skeletons = p), f.length > 0 && (n.animations = f), m.length > 0 && (n.nodes = m);
    }
    return n.object = s, n;
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, i = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), i === !0)
      for (let n = 0; n < e.children.length; n++) {
        const s = e.children[n];
        this.add(s.clone());
      }
    return this;
  }
};
Hr.DEFAULT_UP = /* @__PURE__ */ new X(0, 1, 0);
Hr.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Hr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Dn = /* @__PURE__ */ new X(), Is = /* @__PURE__ */ new X(), Ay = /* @__PURE__ */ new X(), Ds = /* @__PURE__ */ new X(), Kl = /* @__PURE__ */ new X(), Ql = /* @__PURE__ */ new X(), F1 = /* @__PURE__ */ new X(), Cy = /* @__PURE__ */ new X(), Ry = /* @__PURE__ */ new X(), Ny = /* @__PURE__ */ new X(), Py = /* @__PURE__ */ new Fi(), Oy = /* @__PURE__ */ new Fi(), Iy = /* @__PURE__ */ new Fi();
let Ru = class Nu {
  constructor(e = new X(), i = new X(), n = new X()) {
    this.a = e, this.b = i, this.c = n;
  }
  static getNormal(e, i, n, s) {
    s.subVectors(n, i), Dn.subVectors(e, i), s.cross(Dn);
    const a = s.lengthSq();
    return a > 0 ? s.multiplyScalar(1 / Math.sqrt(a)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, i, n, s, a) {
    Dn.subVectors(s, i), Is.subVectors(n, i), Ay.subVectors(e, i);
    const o = Dn.dot(Dn), l = Dn.dot(Is), u = Dn.dot(Ay), c = Is.dot(Is), h = Is.dot(Ay), d = o * c - l * l;
    if (d === 0)
      return a.set(0, 0, 0), null;
    const p = 1 / d, f = (c * u - l * h) * p, m = (o * h - l * u) * p;
    return a.set(1 - f - m, m, f);
  }
  static containsPoint(e, i, n, s) {
    return this.getBarycoord(e, i, n, s, Ds) === null ? !1 : Ds.x >= 0 && Ds.y >= 0 && Ds.x + Ds.y <= 1;
  }
  static getInterpolation(e, i, n, s, a, o, l, u) {
    return this.getBarycoord(e, i, n, s, Ds) === null ? (u.x = 0, u.y = 0, "z" in u && (u.z = 0), "w" in u && (u.w = 0), null) : (u.setScalar(0), u.addScaledVector(a, Ds.x), u.addScaledVector(o, Ds.y), u.addScaledVector(l, Ds.z), u);
  }
  static getInterpolatedAttribute(e, i, n, s, a, o) {
    return Py.setScalar(0), Oy.setScalar(0), Iy.setScalar(0), Py.fromBufferAttribute(e, i), Oy.fromBufferAttribute(e, n), Iy.fromBufferAttribute(e, s), o.setScalar(0), o.addScaledVector(Py, a.x), o.addScaledVector(Oy, a.y), o.addScaledVector(Iy, a.z), o;
  }
  static isFrontFacing(e, i, n, s) {
    return Dn.subVectors(n, i), Is.subVectors(e, i), Dn.cross(Is).dot(s) < 0;
  }
  set(e, i, n) {
    return this.a.copy(e), this.b.copy(i), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, i, n, s) {
    return this.a.copy(e[i]), this.b.copy(e[n]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, i, n, s) {
    return this.a.fromBufferAttribute(e, i), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Dn.subVectors(this.c, this.b), Is.subVectors(this.a, this.b), Dn.cross(Is).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Nu.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, i) {
    return Nu.getBarycoord(e, this.a, this.b, this.c, i);
  }
  getInterpolation(e, i, n, s, a) {
    return Nu.getInterpolation(e, this.a, this.b, this.c, i, n, s, a);
  }
  containsPoint(e) {
    return Nu.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Nu.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, i) {
    const n = this.a, s = this.b, a = this.c;
    let o, l;
    Kl.subVectors(s, n), Ql.subVectors(a, n), Cy.subVectors(e, n);
    const u = Kl.dot(Cy), c = Ql.dot(Cy);
    if (u <= 0 && c <= 0)
      return i.copy(n);
    Ry.subVectors(e, s);
    const h = Kl.dot(Ry), d = Ql.dot(Ry);
    if (h >= 0 && d <= h)
      return i.copy(s);
    const p = u * d - h * c;
    if (p <= 0 && u >= 0 && h <= 0)
      return o = u / (u - h), i.copy(n).addScaledVector(Kl, o);
    Ny.subVectors(e, a);
    const f = Kl.dot(Ny), m = Ql.dot(Ny);
    if (m >= 0 && f <= m)
      return i.copy(a);
    const v = f * c - u * m;
    if (v <= 0 && c >= 0 && m <= 0)
      return l = c / (c - m), i.copy(n).addScaledVector(Ql, l);
    const y = h * m - f * d;
    if (y <= 0 && d - h >= 0 && f - m >= 0)
      return F1.subVectors(a, s), l = (d - h) / (d - h + (f - m)), i.copy(s).addScaledVector(F1, l);
    const g = 1 / (y + v + p);
    return o = v * g, l = p * g, i.copy(n).addScaledVector(Kl, o).addScaledVector(Ql, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
};
const iR = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Ua = { h: 0, s: 0, l: 0 }, bp = { h: 0, s: 0, l: 0 };
function Dy(r, e, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? r + (e - r) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - i) : r;
}
let Ft = class {
  constructor(r, e, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(r, e, i);
  }
  set(r, e, i) {
    if (e === void 0 && i === void 0) {
      const n = r;
      n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
    } else
      this.setRGB(r, e, i);
    return this;
  }
  setScalar(r) {
    return this.r = r, this.g = r, this.b = r, this;
  }
  setHex(r, e = ln) {
    return r = Math.floor(r), this.r = (r >> 16 & 255) / 255, this.g = (r >> 8 & 255) / 255, this.b = (r & 255) / 255, Gt.toWorkingColorSpace(this, e), this;
  }
  setRGB(r, e, i, n = Gt.workingColorSpace) {
    return this.r = r, this.g = e, this.b = i, Gt.toWorkingColorSpace(this, n), this;
  }
  setHSL(r, e, i, n = Gt.workingColorSpace) {
    if (r = N_(r, 1), e = $i(e, 0, 1), i = $i(i, 0, 1), e === 0)
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + e) : i + e - i * e, a = 2 * i - s;
      this.r = Dy(a, s, r + 1 / 3), this.g = Dy(a, s, r), this.b = Dy(a, s, r - 1 / 3);
    }
    return Gt.toWorkingColorSpace(this, n), this;
  }
  setStyle(r, e = ln) {
    function i(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + r + " will be ignored.");
    }
    let n;
    if (n = /^(\w+)\(([^\)]*)\)/.exec(r)) {
      let s;
      const a = n[1], o = n[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setRGB(
              Math.min(255, parseInt(s[1], 10)) / 255,
              Math.min(255, parseInt(s[2], 10)) / 255,
              Math.min(255, parseInt(s[3], 10)) / 255,
              e
            );
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setRGB(
              Math.min(100, parseInt(s[1], 10)) / 100,
              Math.min(100, parseInt(s[2], 10)) / 100,
              Math.min(100, parseInt(s[3], 10)) / 100,
              e
            );
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setHSL(
              parseFloat(s[1]) / 360,
              parseFloat(s[2]) / 100,
              parseFloat(s[3]) / 100,
              e
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + r);
      }
    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(r)) {
      const s = n[1], a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          e
        );
      if (a === 6)
        return this.setHex(parseInt(s, 16), e);
      console.warn("THREE.Color: Invalid hex color " + r);
    } else if (r && r.length > 0)
      return this.setColorName(r, e);
    return this;
  }
  setColorName(r, e = ln) {
    const i = iR[r.toLowerCase()];
    return i !== void 0 ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + r), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(r) {
    return this.r = r.r, this.g = r.g, this.b = r.b, this;
  }
  copySRGBToLinear(r) {
    return this.r = pa(r.r), this.g = pa(r.g), this.b = pa(r.b), this;
  }
  copyLinearToSRGB(r) {
    return this.r = qu(r.r), this.g = qu(r.g), this.b = qu(r.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(r = ln) {
    return Gt.fromWorkingColorSpace(lr.copy(this), r), Math.round($i(lr.r * 255, 0, 255)) * 65536 + Math.round($i(lr.g * 255, 0, 255)) * 256 + Math.round($i(lr.b * 255, 0, 255));
  }
  getHexString(r = ln) {
    return ("000000" + this.getHex(r).toString(16)).slice(-6);
  }
  getHSL(r, e = Gt.workingColorSpace) {
    Gt.fromWorkingColorSpace(lr.copy(this), e);
    const i = lr.r, n = lr.g, s = lr.b, a = Math.max(i, n, s), o = Math.min(i, n, s);
    let l, u;
    const c = (o + a) / 2;
    if (o === a)
      l = 0, u = 0;
    else {
      const h = a - o;
      switch (u = c <= 0.5 ? h / (a + o) : h / (2 - a - o), a) {
        case i:
          l = (n - s) / h + (n < s ? 6 : 0);
          break;
        case n:
          l = (s - i) / h + 2;
          break;
        case s:
          l = (i - n) / h + 4;
          break;
      }
      l /= 6;
    }
    return r.h = l, r.s = u, r.l = c, r;
  }
  getRGB(r, e = Gt.workingColorSpace) {
    return Gt.fromWorkingColorSpace(lr.copy(this), e), r.r = lr.r, r.g = lr.g, r.b = lr.b, r;
  }
  getStyle(r = ln) {
    Gt.fromWorkingColorSpace(lr.copy(this), r);
    const e = lr.r, i = lr.g, n = lr.b;
    return r !== ln ? `color(${r} ${e.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`;
  }
  offsetHSL(r, e, i) {
    return this.getHSL(Ua), this.setHSL(Ua.h + r, Ua.s + e, Ua.l + i);
  }
  add(r) {
    return this.r += r.r, this.g += r.g, this.b += r.b, this;
  }
  addColors(r, e) {
    return this.r = r.r + e.r, this.g = r.g + e.g, this.b = r.b + e.b, this;
  }
  addScalar(r) {
    return this.r += r, this.g += r, this.b += r, this;
  }
  sub(r) {
    return this.r = Math.max(0, this.r - r.r), this.g = Math.max(0, this.g - r.g), this.b = Math.max(0, this.b - r.b), this;
  }
  multiply(r) {
    return this.r *= r.r, this.g *= r.g, this.b *= r.b, this;
  }
  multiplyScalar(r) {
    return this.r *= r, this.g *= r, this.b *= r, this;
  }
  lerp(r, e) {
    return this.r += (r.r - this.r) * e, this.g += (r.g - this.g) * e, this.b += (r.b - this.b) * e, this;
  }
  lerpColors(r, e, i) {
    return this.r = r.r + (e.r - r.r) * i, this.g = r.g + (e.g - r.g) * i, this.b = r.b + (e.b - r.b) * i, this;
  }
  lerpHSL(r, e) {
    this.getHSL(Ua), r.getHSL(bp);
    const i = $h(Ua.h, bp.h, e), n = $h(Ua.s, bp.s, e), s = $h(Ua.l, bp.l, e);
    return this.setHSL(i, n, s), this;
  }
  setFromVector3(r) {
    return this.r = r.x, this.g = r.y, this.b = r.z, this;
  }
  applyMatrix3(r) {
    const e = this.r, i = this.g, n = this.b, s = r.elements;
    return this.r = s[0] * e + s[3] * i + s[6] * n, this.g = s[1] * e + s[4] * i + s[7] * n, this.b = s[2] * e + s[5] * i + s[8] * n, this;
  }
  equals(r) {
    return r.r === this.r && r.g === this.g && r.b === this.b;
  }
  fromArray(r, e = 0) {
    return this.r = r[e], this.g = r[e + 1], this.b = r[e + 2], this;
  }
  toArray(r = [], e = 0) {
    return r[e] = this.r, r[e + 1] = this.g, r[e + 2] = this.b, r;
  }
  fromBufferAttribute(r, e) {
    return this.r = r.getX(e), this.g = r.getY(e), this.b = r.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const lr = /* @__PURE__ */ new Ft();
Ft.NAMES = iR;
let NB = 0, Ol = class extends Nl {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(r) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: NB++ }), this.uuid = da(), this.name = "", this.blending = Hu, this.side = yo, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Yv, this.blendDst = $v, this.blendEquation = $o, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ft(0, 0, 0), this.blendAlpha = 0, this.depthFunc = dc, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = _1, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Vl, this.stencilZFail = Vl, this.stencilZPass = Vl, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(r) {
    this._alphaTest > 0 != r > 0 && this.version++, this._alphaTest = r;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(r) {
    if (r !== void 0)
      for (const e in r) {
        const i = r[e];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
          continue;
        }
        const n = this[e];
        if (n === void 0) {
          console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
          continue;
        }
        n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i;
      }
  }
  toJSON(r) {
    const e = r === void 0 || typeof r == "string";
    e && (r = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(r).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(r).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(r).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(r).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(r).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(r).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(r).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(r).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(r).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(r).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(r).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(r).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(r).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(r).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(r).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(r).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(r).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(r).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(r).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(r).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(r).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(r).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(r).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(r).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Hu && (i.blending = this.blending), this.side !== yo && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== Yv && (i.blendSrc = this.blendSrc), this.blendDst !== $v && (i.blendDst = this.blendDst), this.blendEquation !== $o && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== dc && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== _1 && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Vl && (i.stencilFail = this.stencilFail), this.stencilZFail !== Vl && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Vl && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function n(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (e) {
      const s = n(r.textures), a = n(r.images);
      s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    this.name = r.name, this.blending = r.blending, this.side = r.side, this.vertexColors = r.vertexColors, this.opacity = r.opacity, this.transparent = r.transparent, this.blendSrc = r.blendSrc, this.blendDst = r.blendDst, this.blendEquation = r.blendEquation, this.blendSrcAlpha = r.blendSrcAlpha, this.blendDstAlpha = r.blendDstAlpha, this.blendEquationAlpha = r.blendEquationAlpha, this.blendColor.copy(r.blendColor), this.blendAlpha = r.blendAlpha, this.depthFunc = r.depthFunc, this.depthTest = r.depthTest, this.depthWrite = r.depthWrite, this.stencilWriteMask = r.stencilWriteMask, this.stencilFunc = r.stencilFunc, this.stencilRef = r.stencilRef, this.stencilFuncMask = r.stencilFuncMask, this.stencilFail = r.stencilFail, this.stencilZFail = r.stencilZFail, this.stencilZPass = r.stencilZPass, this.stencilWrite = r.stencilWrite;
    const e = r.clippingPlanes;
    let i = null;
    if (e !== null) {
      const n = e.length;
      i = new Array(n);
      for (let s = 0; s !== n; ++s)
        i[s] = e[s].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = r.clipIntersection, this.clipShadows = r.clipShadows, this.shadowSide = r.shadowSide, this.colorWrite = r.colorWrite, this.precision = r.precision, this.polygonOffset = r.polygonOffset, this.polygonOffsetFactor = r.polygonOffsetFactor, this.polygonOffsetUnits = r.polygonOffsetUnits, this.dithering = r.dithering, this.alphaTest = r.alphaTest, this.alphaHash = r.alphaHash, this.alphaToCoverage = r.alphaToCoverage, this.premultipliedAlpha = r.premultipliedAlpha, this.forceSinglePass = r.forceSinglePass, this.visible = r.visible, this.toneMapped = r.toneMapped, this.userData = JSON.parse(JSON.stringify(r.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}, xg = class extends Ol {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(r) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Ft(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bo(), this.combine = S_, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.lightMap = r.lightMap, this.lightMapIntensity = r.lightMapIntensity, this.aoMap = r.aoMap, this.aoMapIntensity = r.aoMapIntensity, this.specularMap = r.specularMap, this.alphaMap = r.alphaMap, this.envMap = r.envMap, this.envMapRotation.copy(r.envMapRotation), this.combine = r.combine, this.reflectivity = r.reflectivity, this.refractionRatio = r.refractionRatio, this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.wireframeLinecap = r.wireframeLinecap, this.wireframeLinejoin = r.wireframeLinejoin, this.fog = r.fog, this;
  }
};
const Pi = /* @__PURE__ */ new X(), xp = /* @__PURE__ */ new Le();
let wn = class {
  constructor(r, e, i = !1) {
    if (Array.isArray(r))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = r, this.itemSize = e, this.count = r !== void 0 ? r.length / e : 0, this.normalized = i, this.usage = Ib, this.updateRanges = [], this.gpuType = aa, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  setUsage(r) {
    return this.usage = r, this;
  }
  addUpdateRange(r, e) {
    this.updateRanges.push({ start: r, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(r) {
    return this.name = r.name, this.array = new r.array.constructor(r.array), this.itemSize = r.itemSize, this.count = r.count, this.normalized = r.normalized, this.usage = r.usage, this.gpuType = r.gpuType, this;
  }
  copyAt(r, e, i) {
    r *= this.itemSize, i *= e.itemSize;
    for (let n = 0, s = this.itemSize; n < s; n++)
      this.array[r + n] = e.array[i + n];
    return this;
  }
  copyArray(r) {
    return this.array.set(r), this;
  }
  applyMatrix3(r) {
    if (this.itemSize === 2)
      for (let e = 0, i = this.count; e < i; e++)
        xp.fromBufferAttribute(this, e), xp.applyMatrix3(r), this.setXY(e, xp.x, xp.y);
    else if (this.itemSize === 3)
      for (let e = 0, i = this.count; e < i; e++)
        Pi.fromBufferAttribute(this, e), Pi.applyMatrix3(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  applyMatrix4(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.applyMatrix4(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  applyNormalMatrix(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.applyNormalMatrix(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  transformDirection(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.transformDirection(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  set(r, e = 0) {
    return this.array.set(r, e), this;
  }
  getComponent(r, e) {
    let i = this.array[r * this.itemSize + e];
    return this.normalized && (i = Xn(i, this.array)), i;
  }
  setComponent(r, e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.array[r * this.itemSize + e] = i, this;
  }
  getX(r) {
    let e = this.array[r * this.itemSize];
    return this.normalized && (e = Xn(e, this.array)), e;
  }
  setX(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize] = e, this;
  }
  getY(r) {
    let e = this.array[r * this.itemSize + 1];
    return this.normalized && (e = Xn(e, this.array)), e;
  }
  setY(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize + 1] = e, this;
  }
  getZ(r) {
    let e = this.array[r * this.itemSize + 2];
    return this.normalized && (e = Xn(e, this.array)), e;
  }
  setZ(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize + 2] = e, this;
  }
  getW(r) {
    let e = this.array[r * this.itemSize + 3];
    return this.normalized && (e = Xn(e, this.array)), e;
  }
  setW(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize + 3] = e, this;
  }
  setXY(r, e, i) {
    return r *= this.itemSize, this.normalized && (e = Jt(e, this.array), i = Jt(i, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this;
  }
  setXYZ(r, e, i, n) {
    return r *= this.itemSize, this.normalized && (e = Jt(e, this.array), i = Jt(i, this.array), n = Jt(n, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this.array[r + 2] = n, this;
  }
  setXYZW(r, e, i, n, s) {
    return r *= this.itemSize, this.normalized && (e = Jt(e, this.array), i = Jt(i, this.array), n = Jt(n, this.array), s = Jt(s, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this.array[r + 2] = n, this.array[r + 3] = s, this;
  }
  onUpload(r) {
    return this.onUploadCallback = r, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const r = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (r.name = this.name), this.usage !== Ib && (r.usage = this.usage), r;
  }
}, rR = class extends wn {
  constructor(r, e, i) {
    super(new Uint16Array(r), e, i);
  }
}, nR = class extends wn {
  constructor(r, e, i) {
    super(new Uint32Array(r), e, i);
  }
}, Ri = class extends wn {
  constructor(r, e, i) {
    super(new Float32Array(r), e, i);
  }
}, PB = 0;
const mn = /* @__PURE__ */ new ui(), ky = /* @__PURE__ */ new Hr(), Zl = /* @__PURE__ */ new X(), Jr = /* @__PURE__ */ new Pl(), sh = /* @__PURE__ */ new Pl(), Wi = /* @__PURE__ */ new X();
let pn = class sR extends Nl {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: PB++ }), this.uuid = da(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (KC(e) ? nR : rR)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, i) {
    return this.attributes[e] = i, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, i, n = 0) {
    this.groups.push({
      start: e,
      count: i,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, i) {
    this.drawRange.start = e, this.drawRange.count = i;
  }
  applyMatrix4(e) {
    const i = this.attributes.position;
    i !== void 0 && (i.applyMatrix4(e), i.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const a = new Ot().getNormalMatrix(e);
      n.applyNormalMatrix(a), n.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return mn.makeRotationFromQuaternion(e), this.applyMatrix4(mn), this;
  }
  rotateX(e) {
    return mn.makeRotationX(e), this.applyMatrix4(mn), this;
  }
  rotateY(e) {
    return mn.makeRotationY(e), this.applyMatrix4(mn), this;
  }
  rotateZ(e) {
    return mn.makeRotationZ(e), this.applyMatrix4(mn), this;
  }
  translate(e, i, n) {
    return mn.makeTranslation(e, i, n), this.applyMatrix4(mn), this;
  }
  scale(e, i, n) {
    return mn.makeScale(e, i, n), this.applyMatrix4(mn), this;
  }
  lookAt(e) {
    return ky.lookAt(e), ky.updateMatrix(), this.applyMatrix4(ky.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Zl).negate(), this.translate(Zl.x, Zl.y, Zl.z), this;
  }
  setFromPoints(e) {
    const i = this.getAttribute("position");
    if (i === void 0) {
      const n = [];
      for (let s = 0, a = e.length; s < a; s++) {
        const o = e[s];
        n.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new Ri(n, 3));
    } else {
      for (let n = 0, s = i.count; n < s; n++) {
        const a = e[n];
        i.setXYZ(n, a.x, a.y, a.z || 0);
      }
      e.length > i.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), i.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Pl());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new X(-1 / 0, -1 / 0, -1 / 0),
        new X(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), i)
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n];
          Jr.setFromBufferAttribute(a), this.morphTargetsRelative ? (Wi.addVectors(this.boundingBox.min, Jr.min), this.boundingBox.expandByPoint(Wi), Wi.addVectors(this.boundingBox.max, Jr.max), this.boundingBox.expandByPoint(Wi)) : (this.boundingBox.expandByPoint(Jr.min), this.boundingBox.expandByPoint(Jr.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new vg());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new X(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (Jr.setFromBufferAttribute(e), i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a];
          sh.setFromBufferAttribute(l), this.morphTargetsRelative ? (Wi.addVectors(Jr.min, sh.min), Jr.expandByPoint(Wi), Wi.addVectors(Jr.max, sh.max), Jr.expandByPoint(Wi)) : (Jr.expandByPoint(sh.min), Jr.expandByPoint(sh.max));
        }
      Jr.getCenter(n);
      let s = 0;
      for (let a = 0, o = e.count; a < o; a++)
        Wi.fromBufferAttribute(e, a), s = Math.max(s, n.distanceToSquared(Wi));
      if (i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a], u = this.morphTargetsRelative;
          for (let c = 0, h = l.count; c < h; c++)
            Wi.fromBufferAttribute(l, c), u && (Zl.fromBufferAttribute(e, c), Wi.add(Zl)), s = Math.max(s, n.distanceToSquared(Wi));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, i = this.attributes;
    if (e === null || i.position === void 0 || i.normal === void 0 || i.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = i.position, s = i.normal, a = i.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new wn(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"), l = [], u = [];
    for (let C = 0; C < n.count; C++)
      l[C] = new X(), u[C] = new X();
    const c = new X(), h = new X(), d = new X(), p = new Le(), f = new Le(), m = new Le(), v = new X(), y = new X();
    function g(C, E, A) {
      c.fromBufferAttribute(n, C), h.fromBufferAttribute(n, E), d.fromBufferAttribute(n, A), p.fromBufferAttribute(a, C), f.fromBufferAttribute(a, E), m.fromBufferAttribute(a, A), h.sub(c), d.sub(c), f.sub(p), m.sub(p);
      const N = 1 / (f.x * m.y - m.x * f.y);
      isFinite(N) && (v.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(N), y.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(N), l[C].add(v), l[E].add(v), l[A].add(v), u[C].add(y), u[E].add(y), u[A].add(y));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{
      start: 0,
      count: e.count
    }]);
    for (let C = 0, E = _.length; C < E; ++C) {
      const A = _[C], N = A.start, L = A.count;
      for (let F = N, M = N + L; F < M; F += 3)
        g(
          e.getX(F + 0),
          e.getX(F + 1),
          e.getX(F + 2)
        );
    }
    const x = new X(), b = new X(), T = new X(), S = new X();
    function w(C) {
      T.fromBufferAttribute(s, C), S.copy(T);
      const E = l[C];
      x.copy(E), x.sub(T.multiplyScalar(T.dot(E))).normalize(), b.crossVectors(S, E);
      const A = b.dot(u[C]) < 0 ? -1 : 1;
      o.setXYZW(C, x.x, x.y, x.z, A);
    }
    for (let C = 0, E = _.length; C < E; ++C) {
      const A = _[C], N = A.start, L = A.count;
      for (let F = N, M = N + L; F < M; F += 3)
        w(e.getX(F + 0)), w(e.getX(F + 1)), w(e.getX(F + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, i = this.getAttribute("position");
    if (i !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new wn(new Float32Array(i.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let p = 0, f = n.count; p < f; p++)
          n.setXYZ(p, 0, 0, 0);
      const s = new X(), a = new X(), o = new X(), l = new X(), u = new X(), c = new X(), h = new X(), d = new X();
      if (e)
        for (let p = 0, f = e.count; p < f; p += 3) {
          const m = e.getX(p + 0), v = e.getX(p + 1), y = e.getX(p + 2);
          s.fromBufferAttribute(i, m), a.fromBufferAttribute(i, v), o.fromBufferAttribute(i, y), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, v), c.fromBufferAttribute(n, y), l.add(h), u.add(h), c.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(v, u.x, u.y, u.z), n.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let p = 0, f = i.count; p < f; p += 3)
          s.fromBufferAttribute(i, p + 0), a.fromBufferAttribute(i, p + 1), o.fromBufferAttribute(i, p + 2), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), n.setXYZ(p + 0, h.x, h.y, h.z), n.setXYZ(p + 1, h.x, h.y, h.z), n.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let i = 0, n = e.count; i < n; i++)
      Wi.fromBufferAttribute(e, i), Wi.normalize(), e.setXYZ(i, Wi.x, Wi.y, Wi.z);
  }
  toNonIndexed() {
    function e(l, u) {
      const c = l.array, h = l.itemSize, d = l.normalized, p = new c.constructor(u.length * h);
      let f = 0, m = 0;
      for (let v = 0, y = u.length; v < y; v++) {
        l.isInterleavedBufferAttribute ? f = u[v] * l.data.stride + l.offset : f = u[v] * h;
        for (let g = 0; g < h; g++)
          p[m++] = c[f++];
      }
      return new wn(p, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const i = new sR(), n = this.index.array, s = this.attributes;
    for (const l in s) {
      const u = s[l], c = e(u, n);
      i.setAttribute(l, c);
    }
    const a = this.morphAttributes;
    for (const l in a) {
      const u = [], c = a[l];
      for (let h = 0, d = c.length; h < d; h++) {
        const p = c[h], f = e(p, n);
        u.push(f);
      }
      i.morphAttributes[l] = u;
    }
    i.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const c = o[l];
      i.addGroup(c.start, c.count, c.materialIndex);
    }
    return i;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const u = this.parameters;
      for (const c in u)
        u[c] !== void 0 && (e[c] = u[c]);
      return e;
    }
    e.data = { attributes: {} };
    const i = this.index;
    i !== null && (e.data.index = {
      type: i.array.constructor.name,
      array: Array.prototype.slice.call(i.array)
    });
    const n = this.attributes;
    for (const u in n) {
      const c = n[u];
      e.data.attributes[u] = c.toJSON(e.data);
    }
    const s = {};
    let a = !1;
    for (const u in this.morphAttributes) {
      const c = this.morphAttributes[u], h = [];
      for (let d = 0, p = c.length; d < p; d++) {
        const f = c[d];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (s[u] = h, a = !0);
    }
    a && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const i = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(i));
    const s = e.attributes;
    for (const c in s) {
      const h = s[c];
      this.setAttribute(c, h.clone(i));
    }
    const a = e.morphAttributes;
    for (const c in a) {
      const h = [], d = a[c];
      for (let p = 0, f = d.length; p < f; p++)
        h.push(d[p].clone(i));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = e.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
const B1 = /* @__PURE__ */ new ui(), Io = /* @__PURE__ */ new bg(), _p = /* @__PURE__ */ new vg(), z1 = /* @__PURE__ */ new X(), Tp = /* @__PURE__ */ new X(), Sp = /* @__PURE__ */ new X(), wp = /* @__PURE__ */ new X(), Ly = /* @__PURE__ */ new X(), Ep = /* @__PURE__ */ new X(), j1 = /* @__PURE__ */ new X(), Mp = /* @__PURE__ */ new X();
let Ur = class extends Hr {
  constructor(r = new pn(), e = new xg()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = r, this.material = e, this.updateMorphTargets();
  }
  copy(r, e) {
    return super.copy(r, e), r.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = r.morphTargetInfluences.slice()), r.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, r.morphTargetDictionary)), this.material = Array.isArray(r.material) ? r.material.slice() : r.material, this.geometry = r.geometry, this;
  }
  updateMorphTargets() {
    const r = this.geometry.morphAttributes, e = Object.keys(r);
    if (e.length > 0) {
      const i = r[e[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n].name || String(n);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = n;
        }
      }
    }
  }
  getVertexPosition(r, e) {
    const i = this.geometry, n = i.attributes.position, s = i.morphAttributes.position, a = i.morphTargetsRelative;
    e.fromBufferAttribute(n, r);
    const o = this.morphTargetInfluences;
    if (s && o) {
      Ep.set(0, 0, 0);
      for (let l = 0, u = s.length; l < u; l++) {
        const c = o[l], h = s[l];
        c !== 0 && (Ly.fromBufferAttribute(h, r), a ? Ep.addScaledVector(Ly, c) : Ep.addScaledVector(Ly.sub(e), c));
      }
      e.add(Ep);
    }
    return e;
  }
  raycast(r, e) {
    const i = this.geometry, n = this.material, s = this.matrixWorld;
    n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), _p.copy(i.boundingSphere), _p.applyMatrix4(s), Io.copy(r.ray).recast(r.near), !(_p.containsPoint(Io.origin) === !1 && (Io.intersectSphere(_p, z1) === null || Io.origin.distanceToSquared(z1) > (r.far - r.near) ** 2)) && (B1.copy(s).invert(), Io.copy(r.ray).applyMatrix4(B1), !(i.boundingBox !== null && Io.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(r, e, Io)));
  }
  _computeIntersections(r, e, i) {
    let n;
    const s = this.geometry, a = this.material, o = s.index, l = s.attributes.position, u = s.attributes.uv, c = s.attributes.uv1, h = s.attributes.normal, d = s.groups, p = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let f = 0, m = d.length; f < m; f++) {
          const v = d[f], y = a[v.materialIndex], g = Math.max(v.start, p.start), _ = Math.min(o.count, Math.min(v.start + v.count, p.start + p.count));
          for (let x = g, b = _; x < b; x += 3) {
            const T = o.getX(x), S = o.getX(x + 1), w = o.getX(x + 2);
            n = Ap(this, y, r, i, u, c, h, T, S, w), n && (n.faceIndex = Math.floor(x / 3), n.face.materialIndex = v.materialIndex, e.push(n));
          }
        }
      else {
        const f = Math.max(0, p.start), m = Math.min(o.count, p.start + p.count);
        for (let v = f, y = m; v < y; v += 3) {
          const g = o.getX(v), _ = o.getX(v + 1), x = o.getX(v + 2);
          n = Ap(this, a, r, i, u, c, h, g, _, x), n && (n.faceIndex = Math.floor(v / 3), e.push(n));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let f = 0, m = d.length; f < m; f++) {
          const v = d[f], y = a[v.materialIndex], g = Math.max(v.start, p.start), _ = Math.min(l.count, Math.min(v.start + v.count, p.start + p.count));
          for (let x = g, b = _; x < b; x += 3) {
            const T = x, S = x + 1, w = x + 2;
            n = Ap(this, y, r, i, u, c, h, T, S, w), n && (n.faceIndex = Math.floor(x / 3), n.face.materialIndex = v.materialIndex, e.push(n));
          }
        }
      else {
        const f = Math.max(0, p.start), m = Math.min(l.count, p.start + p.count);
        for (let v = f, y = m; v < y; v += 3) {
          const g = v, _ = v + 1, x = v + 2;
          n = Ap(this, a, r, i, u, c, h, g, _, x), n && (n.faceIndex = Math.floor(v / 3), e.push(n));
        }
      }
  }
};
function OB(r, e, i, n, s, a, o, l) {
  let u;
  if (e.side === Mr ? u = n.intersectTriangle(o, a, s, !0, l) : u = n.intersectTriangle(s, a, o, e.side === yo, l), u === null) return null;
  Mp.copy(l), Mp.applyMatrix4(r.matrixWorld);
  const c = i.ray.origin.distanceTo(Mp);
  return c < i.near || c > i.far ? null : {
    distance: c,
    point: Mp.clone(),
    object: r
  };
}
function Ap(r, e, i, n, s, a, o, l, u, c) {
  r.getVertexPosition(l, Tp), r.getVertexPosition(u, Sp), r.getVertexPosition(c, wp);
  const h = OB(r, e, i, n, Tp, Sp, wp, j1);
  if (h) {
    const d = new X();
    Ru.getBarycoord(j1, Tp, Sp, wp, d), s && (h.uv = Ru.getInterpolatedAttribute(s, l, u, c, d, new Le())), a && (h.uv1 = Ru.getInterpolatedAttribute(a, l, u, c, d, new Le())), o && (h.normal = Ru.getInterpolatedAttribute(o, l, u, c, d, new X()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const p = {
      a: l,
      b: u,
      c,
      normal: new X(),
      materialIndex: 0
    };
    Ru.getNormal(Tp, Sp, wp, p.normal), h.face = p, h.barycoord = d;
  }
  return h;
}
let O_ = class aR extends pn {
  constructor(e = 1, i = 1, n = 1, s = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: i,
      depth: n,
      widthSegments: s,
      heightSegments: a,
      depthSegments: o
    };
    const l = this;
    s = Math.floor(s), a = Math.floor(a), o = Math.floor(o);
    const u = [], c = [], h = [], d = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, n, i, e, o, a, 0), m("z", "y", "x", 1, -1, n, i, -e, o, a, 1), m("x", "z", "y", 1, 1, e, n, i, s, o, 2), m("x", "z", "y", 1, -1, e, n, -i, s, o, 3), m("x", "y", "z", 1, -1, e, i, n, s, a, 4), m("x", "y", "z", -1, -1, e, i, -n, s, a, 5), this.setIndex(u), this.setAttribute("position", new Ri(c, 3)), this.setAttribute("normal", new Ri(h, 3)), this.setAttribute("uv", new Ri(d, 2));
    function m(v, y, g, _, x, b, T, S, w, C, E) {
      const A = b / w, N = T / C, L = b / 2, F = T / 2, M = S / 2, P = w + 1, O = C + 1;
      let V = 0, B = 0;
      const H = new X();
      for (let U = 0; U < O; U++) {
        const j = U * N - F;
        for (let Q = 0; Q < P; Q++) {
          const q = Q * A - L;
          H[v] = q * _, H[y] = j * x, H[g] = M, c.push(H.x, H.y, H.z), H[v] = 0, H[y] = 0, H[g] = S > 0 ? 1 : -1, h.push(H.x, H.y, H.z), d.push(Q / w), d.push(1 - U / C), V += 1;
        }
      }
      for (let U = 0; U < C; U++)
        for (let j = 0; j < w; j++) {
          const Q = p + j + P * U, q = p + j + P * (U + 1), G = p + (j + 1) + P * (U + 1), Y = p + (j + 1) + P * U;
          u.push(Q, q, Y), u.push(q, G, Y), B += 6;
        }
      l.addGroup(f, B, E), f += B, p += V;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new aR(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
};
function yc(r) {
  const e = {};
  for (const i in r) {
    e[i] = {};
    for (const n in r[i]) {
      const s = r[i][n];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][n] = null) : e[i][n] = s.clone() : Array.isArray(s) ? e[i][n] = s.slice() : e[i][n] = s;
    }
  }
  return e;
}
function xr(r) {
  const e = {};
  for (let i = 0; i < r.length; i++) {
    const n = yc(r[i]);
    for (const s in n)
      e[s] = n[s];
  }
  return e;
}
function IB(r) {
  const e = [];
  for (let i = 0; i < r.length; i++)
    e.push(r[i].clone());
  return e;
}
function oR(r) {
  const e = r.getRenderTarget();
  return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Gt.workingColorSpace;
}
const lR = { clone: yc, merge: xr };
var DB = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, kB = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
let Ss = class extends Ol {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(r) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = DB, this.fragmentShader = kB, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, r !== void 0 && this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.fragmentShader = r.fragmentShader, this.vertexShader = r.vertexShader, this.uniforms = yc(r.uniforms), this.uniformsGroups = IB(r.uniformsGroups), this.defines = Object.assign({}, r.defines), this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.fog = r.fog, this.lights = r.lights, this.clipping = r.clipping, this.extensions = Object.assign({}, r.extensions), this.glslVersion = r.glslVersion, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    e.glslVersion = this.glslVersion, e.uniforms = {};
    for (const n in this.uniforms) {
      const s = this.uniforms[n].value;
      s && s.isTexture ? e.uniforms[n] = {
        type: "t",
        value: s.toJSON(r).uuid
      } : s && s.isColor ? e.uniforms[n] = {
        type: "c",
        value: s.getHex()
      } : s && s.isVector2 ? e.uniforms[n] = {
        type: "v2",
        value: s.toArray()
      } : s && s.isVector3 ? e.uniforms[n] = {
        type: "v3",
        value: s.toArray()
      } : s && s.isVector4 ? e.uniforms[n] = {
        type: "v4",
        value: s.toArray()
      } : s && s.isMatrix3 ? e.uniforms[n] = {
        type: "m3",
        value: s.toArray()
      } : s && s.isMatrix4 ? e.uniforms[n] = {
        type: "m4",
        value: s.toArray()
      } : e.uniforms[n] = {
        value: s
      };
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
    const i = {};
    for (const n in this.extensions)
      this.extensions[n] === !0 && (i[n] = !0);
    return Object.keys(i).length > 0 && (e.extensions = i), e;
  }
}, uR = class extends Hr {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ui(), this.projectionMatrix = new ui(), this.projectionMatrixInverse = new ui(), this.coordinateSystem = oa;
  }
  copy(r, e) {
    return super.copy(r, e), this.matrixWorldInverse.copy(r.matrixWorldInverse), this.projectionMatrix.copy(r.projectionMatrix), this.projectionMatrixInverse.copy(r.projectionMatrixInverse), this.coordinateSystem = r.coordinateSystem, this;
  }
  getWorldDirection(r) {
    return super.getWorldDirection(r).negate();
  }
  updateMatrixWorld(r) {
    super.updateMatrixWorld(r), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(r, e) {
    super.updateWorldMatrix(r, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const Fa = /* @__PURE__ */ new X(), V1 = /* @__PURE__ */ new Le(), G1 = /* @__PURE__ */ new Le();
let _n = class extends uR {
  constructor(r = 50, e = 1, i = 0.1, n = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = r, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(r, e) {
    return super.copy(r, e), this.fov = r.fov, this.zoom = r.zoom, this.near = r.near, this.far = r.far, this.focus = r.focus, this.aspect = r.aspect, this.view = r.view === null ? null : Object.assign({}, r.view), this.filmGauge = r.filmGauge, this.filmOffset = r.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(r) {
    const e = 0.5 * this.getFilmHeight() / r;
    this.fov = hd * 2 * Math.atan(e), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const r = Math.tan(Yh * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / r;
  }
  getEffectiveFOV() {
    return hd * 2 * Math.atan(
      Math.tan(Yh * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(r, e, i) {
    Fa.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), e.set(Fa.x, Fa.y).multiplyScalar(-r / Fa.z), Fa.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Fa.x, Fa.y).multiplyScalar(-r / Fa.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(r, e) {
    return this.getViewBounds(r, V1, G1), e.subVectors(G1, V1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(r, e, i, n, s, a) {
    this.aspect = r / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = r, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const r = this.near;
    let e = r * Math.tan(Yh * 0.5 * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, s = -0.5 * n;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth, u = a.fullHeight;
      s += a.offsetX * n / l, e -= a.offsetY * i / u, n *= a.width / l, i *= a.height / u;
    }
    const o = this.filmOffset;
    o !== 0 && (s += r * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + n, e, e - i, r, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
};
const Jl = -90, eu = 1;
let LB = class extends Hr {
  constructor(r, e, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const n = new _n(Jl, eu, r, e);
    n.layers = this.layers, this.add(n);
    const s = new _n(Jl, eu, r, e);
    s.layers = this.layers, this.add(s);
    const a = new _n(Jl, eu, r, e);
    a.layers = this.layers, this.add(a);
    const o = new _n(Jl, eu, r, e);
    o.layers = this.layers, this.add(o);
    const l = new _n(Jl, eu, r, e);
    l.layers = this.layers, this.add(l);
    const u = new _n(Jl, eu, r, e);
    u.layers = this.layers, this.add(u);
  }
  updateCoordinateSystem() {
    const r = this.coordinateSystem, e = this.children.concat(), [i, n, s, a, o, l] = e;
    for (const u of e) this.remove(u);
    if (r === oa)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (r === ym)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + r);
    for (const u of e)
      this.add(u), u.updateMatrixWorld();
  }
  update(r, e) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: n } = this;
    this.coordinateSystem !== r.coordinateSystem && (this.coordinateSystem = r.coordinateSystem, this.updateCoordinateSystem());
    const [s, a, o, l, u, c] = this.children, h = r.getRenderTarget(), d = r.getActiveCubeFace(), p = r.getActiveMipmapLevel(), f = r.xr.enabled;
    r.xr.enabled = !1;
    const m = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, r.setRenderTarget(i, 0, n), r.render(e, s), r.setRenderTarget(i, 1, n), r.render(e, a), r.setRenderTarget(i, 2, n), r.render(e, o), r.setRenderTarget(i, 3, n), r.render(e, l), r.setRenderTarget(i, 4, n), r.render(e, u), i.texture.generateMipmaps = m, r.setRenderTarget(i, 5, n), r.render(e, c), r.setRenderTarget(h, d, p), r.xr.enabled = f, i.texture.needsPMREMUpdate = !0;
  }
}, cR = class extends Cn {
  constructor(r, e, i, n, s, a, o, l, u, c) {
    r = r !== void 0 ? r : [], e = e !== void 0 ? e : pc, super(r, e, i, n, s, a, o, l, u, c), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(r) {
    this.image = r;
  }
}, UB = class extends vo {
  constructor(r = 1, e = {}) {
    super(r, r, e), this.isWebGLCubeRenderTarget = !0;
    const i = { width: r, height: r, depth: 1 }, n = [i, i, i, i, i, i];
    this.texture = new cR(n, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : gs;
  }
  fromEquirectangularTexture(r, e) {
    this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, n = new O_(5, 5, 5), s = new Ss({
      name: "CubemapFromEquirect",
      uniforms: yc(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: Mr,
      blending: ha
    });
    s.uniforms.tEquirect.value = e;
    const a = new Ur(n, s), o = e.minFilter;
    return e.minFilter === sl && (e.minFilter = gs), new LB(1, 10, this).update(r, a), e.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(r, e, i, n) {
    const s = r.getRenderTarget();
    for (let a = 0; a < 6; a++)
      r.setRenderTarget(this, a), r.clear(e, i, n);
    r.setRenderTarget(s);
  }
};
const Uy = /* @__PURE__ */ new X(), FB = /* @__PURE__ */ new X(), BB = /* @__PURE__ */ new Ot();
let $s = class {
  constructor(r = new X(1, 0, 0), e = 0) {
    this.isPlane = !0, this.normal = r, this.constant = e;
  }
  set(r, e) {
    return this.normal.copy(r), this.constant = e, this;
  }
  setComponents(r, e, i, n) {
    return this.normal.set(r, e, i), this.constant = n, this;
  }
  setFromNormalAndCoplanarPoint(r, e) {
    return this.normal.copy(r), this.constant = -e.dot(this.normal), this;
  }
  setFromCoplanarPoints(r, e, i) {
    const n = Uy.subVectors(i, e).cross(FB.subVectors(r, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, r), this;
  }
  copy(r) {
    return this.normal.copy(r.normal), this.constant = r.constant, this;
  }
  normalize() {
    const r = 1 / this.normal.length();
    return this.normal.multiplyScalar(r), this.constant *= r, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(r) {
    return this.normal.dot(r) + this.constant;
  }
  distanceToSphere(r) {
    return this.distanceToPoint(r.center) - r.radius;
  }
  projectPoint(r, e) {
    return e.copy(r).addScaledVector(this.normal, -this.distanceToPoint(r));
  }
  intersectLine(r, e) {
    const i = r.delta(Uy), n = this.normal.dot(i);
    if (n === 0)
      return this.distanceToPoint(r.start) === 0 ? e.copy(r.start) : null;
    const s = -(r.start.dot(this.normal) + this.constant) / n;
    return s < 0 || s > 1 ? null : e.copy(r.start).addScaledVector(i, s);
  }
  intersectsLine(r) {
    const e = this.distanceToPoint(r.start), i = this.distanceToPoint(r.end);
    return e < 0 && i > 0 || i < 0 && e > 0;
  }
  intersectsBox(r) {
    return r.intersectsPlane(this);
  }
  intersectsSphere(r) {
    return r.intersectsPlane(this);
  }
  coplanarPoint(r) {
    return r.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(r, e) {
    const i = e || BB.getNormalMatrix(r), n = this.coplanarPoint(Uy).applyMatrix4(r), s = this.normal.applyMatrix3(i).normalize();
    return this.constant = -n.dot(s), this;
  }
  translate(r) {
    return this.constant -= r.dot(this.normal), this;
  }
  equals(r) {
    return r.normal.equals(this.normal) && r.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const Do = /* @__PURE__ */ new vg(), Cp = /* @__PURE__ */ new X();
let I_ = class {
  constructor(r = new $s(), e = new $s(), i = new $s(), n = new $s(), s = new $s(), a = new $s()) {
    this.planes = [r, e, i, n, s, a];
  }
  set(r, e, i, n, s, a) {
    const o = this.planes;
    return o[0].copy(r), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(s), o[5].copy(a), this;
  }
  copy(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++)
      e[i].copy(r.planes[i]);
    return this;
  }
  setFromProjectionMatrix(r, e = oa) {
    const i = this.planes, n = r.elements, s = n[0], a = n[1], o = n[2], l = n[3], u = n[4], c = n[5], h = n[6], d = n[7], p = n[8], f = n[9], m = n[10], v = n[11], y = n[12], g = n[13], _ = n[14], x = n[15];
    if (i[0].setComponents(l - s, d - u, v - p, x - y).normalize(), i[1].setComponents(l + s, d + u, v + p, x + y).normalize(), i[2].setComponents(l + a, d + c, v + f, x + g).normalize(), i[3].setComponents(l - a, d - c, v - f, x - g).normalize(), i[4].setComponents(l - o, d - h, v - m, x - _).normalize(), e === oa)
      i[5].setComponents(l + o, d + h, v + m, x + _).normalize();
    else if (e === ym)
      i[5].setComponents(o, h, m, _).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
    return this;
  }
  intersectsObject(r) {
    if (r.boundingSphere !== void 0)
      r.boundingSphere === null && r.computeBoundingSphere(), Do.copy(r.boundingSphere).applyMatrix4(r.matrixWorld);
    else {
      const e = r.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(), Do.copy(e.boundingSphere).applyMatrix4(r.matrixWorld);
    }
    return this.intersectsSphere(Do);
  }
  intersectsSprite(r) {
    return Do.center.set(0, 0, 0), Do.radius = 0.7071067811865476, Do.applyMatrix4(r.matrixWorld), this.intersectsSphere(Do);
  }
  intersectsSphere(r) {
    const e = this.planes, i = r.center, n = -r.radius;
    for (let s = 0; s < 6; s++)
      if (e[s].distanceToPoint(i) < n)
        return !1;
    return !0;
  }
  intersectsBox(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = e[i];
      if (Cp.x = n.normal.x > 0 ? r.max.x : r.min.x, Cp.y = n.normal.y > 0 ? r.max.y : r.min.y, Cp.z = n.normal.z > 0 ? r.max.z : r.min.z, n.distanceToPoint(Cp) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++)
      if (e[i].distanceToPoint(r) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function hR() {
  let r = null, e = !1, i = null, n = null;
  function s(a, o) {
    i(a, o), n = r.requestAnimationFrame(s);
  }
  return {
    start: function() {
      e !== !0 && i !== null && (n = r.requestAnimationFrame(s), e = !0);
    },
    stop: function() {
      r.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(a) {
      i = a;
    },
    setContext: function(a) {
      r = a;
    }
  };
}
function zB(r) {
  const e = /* @__PURE__ */ new WeakMap();
  function i(l, u) {
    const c = l.array, h = l.usage, d = c.byteLength, p = r.createBuffer();
    r.bindBuffer(u, p), r.bufferData(u, c, h), l.onUploadCallback();
    let f;
    if (c instanceof Float32Array)
      f = r.FLOAT;
    else if (c instanceof Uint16Array)
      l.isFloat16BufferAttribute ? f = r.HALF_FLOAT : f = r.UNSIGNED_SHORT;
    else if (c instanceof Int16Array)
      f = r.SHORT;
    else if (c instanceof Uint32Array)
      f = r.UNSIGNED_INT;
    else if (c instanceof Int32Array)
      f = r.INT;
    else if (c instanceof Int8Array)
      f = r.BYTE;
    else if (c instanceof Uint8Array)
      f = r.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray)
      f = r.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
    return {
      buffer: p,
      type: f,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: l.version,
      size: d
    };
  }
  function n(l, u, c) {
    const h = u.array, d = u.updateRanges;
    if (r.bindBuffer(c, l), d.length === 0)
      r.bufferSubData(c, 0, h);
    else {
      d.sort((f, m) => f.start - m.start);
      let p = 0;
      for (let f = 1; f < d.length; f++) {
        const m = d[p], v = d[f];
        v.start <= m.start + m.count + 1 ? m.count = Math.max(
          m.count,
          v.start + v.count - m.start
        ) : (++p, d[p] = v);
      }
      d.length = p + 1;
      for (let f = 0, m = d.length; f < m; f++) {
        const v = d[f];
        r.bufferSubData(
          c,
          v.start * h.BYTES_PER_ELEMENT,
          h,
          v.start,
          v.count
        );
      }
      u.clearUpdateRanges();
    }
    u.onUploadCallback();
  }
  function s(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function a(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const u = e.get(l);
    u && (r.deleteBuffer(u.buffer), e.delete(l));
  }
  function o(l, u) {
    if (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute) {
      const h = e.get(l);
      (!h || h.version < l.version) && e.set(l, {
        buffer: l.buffer,
        type: l.type,
        bytesPerElement: l.elementSize,
        version: l.version
      });
      return;
    }
    const c = e.get(l);
    if (c === void 0)
      e.set(l, i(l, u));
    else if (c.version < l.version) {
      if (c.size !== l.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n(c.buffer, l, u), c.version = l.version;
    }
  }
  return {
    get: s,
    remove: a,
    update: o
  };
}
class Gd extends pn {
  constructor(e = 1, i = 1, n = 1, s = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: i,
      widthSegments: n,
      heightSegments: s
    };
    const a = e / 2, o = i / 2, l = Math.floor(n), u = Math.floor(s), c = l + 1, h = u + 1, d = e / l, p = i / u, f = [], m = [], v = [], y = [];
    for (let g = 0; g < h; g++) {
      const _ = g * p - o;
      for (let x = 0; x < c; x++) {
        const b = x * d - a;
        m.push(b, -_, 0), v.push(0, 0, 1), y.push(x / l), y.push(1 - g / u);
      }
    }
    for (let g = 0; g < u; g++)
      for (let _ = 0; _ < l; _++) {
        const x = _ + c * g, b = _ + c * (g + 1), T = _ + 1 + c * (g + 1), S = _ + 1 + c * g;
        f.push(x, b, S), f.push(b, T, S);
      }
    this.setIndex(f), this.setAttribute("position", new Ri(m, 3)), this.setAttribute("normal", new Ri(v, 3)), this.setAttribute("uv", new Ri(y, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Gd(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var jB = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, VB = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, GB = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, HB = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, WB = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, qB = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, XB = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, YB = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, $B = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, KB = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, QB = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, ZB = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, JB = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, e5 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, t5 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, i5 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, r5 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, n5 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, s5 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, a5 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, o5 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, l5 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, u5 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, c5 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, h5 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, d5 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, p5 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, f5 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, m5 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, g5 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, y5 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", v5 = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, b5 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, x5 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, _5 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, T5 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, S5 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, w5 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, E5 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, M5 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, A5 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, C5 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, R5 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, N5 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, P5 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, O5 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, I5 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, D5 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, k5 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, L5 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, U5 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, F5 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, B5 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, z5 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, j5 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, V5 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, G5 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, H5 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, W5 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, q5 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, X5 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Y5 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, $5 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, K5 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Q5 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Z5 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, J5 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, ez = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, tz = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, iz = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, rz = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, nz = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, sz = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, az = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, oz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, lz = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, uz = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, cz = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, hz = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, dz = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, pz = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, fz = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, mz = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, gz = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, yz = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, vz = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, bz = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, xz = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, _z = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Tz = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, Sz = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, wz = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Ez = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Mz = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Az = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Cz = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Rz = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Nz = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Pz = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Oz = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Iz = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, Dz = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, kz = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Lz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Uz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Fz = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Bz = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const zz = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, jz = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Vz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Gz = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Hz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Wz = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, qz = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Xz = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, Yz = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, $z = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, Kz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Qz = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Zz = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Jz = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, e4 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, t4 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, i4 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, r4 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, n4 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, s4 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, a4 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, o4 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, l4 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, u4 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, c4 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, h4 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, d4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, p4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, f4 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, m4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, g4 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, y4 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, v4 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, b4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Nt = {
  alphahash_fragment: jB,
  alphahash_pars_fragment: VB,
  alphamap_fragment: GB,
  alphamap_pars_fragment: HB,
  alphatest_fragment: WB,
  alphatest_pars_fragment: qB,
  aomap_fragment: XB,
  aomap_pars_fragment: YB,
  batching_pars_vertex: $B,
  batching_vertex: KB,
  begin_vertex: QB,
  beginnormal_vertex: ZB,
  bsdfs: JB,
  iridescence_fragment: e5,
  bumpmap_pars_fragment: t5,
  clipping_planes_fragment: i5,
  clipping_planes_pars_fragment: r5,
  clipping_planes_pars_vertex: n5,
  clipping_planes_vertex: s5,
  color_fragment: a5,
  color_pars_fragment: o5,
  color_pars_vertex: l5,
  color_vertex: u5,
  common: c5,
  cube_uv_reflection_fragment: h5,
  defaultnormal_vertex: d5,
  displacementmap_pars_vertex: p5,
  displacementmap_vertex: f5,
  emissivemap_fragment: m5,
  emissivemap_pars_fragment: g5,
  colorspace_fragment: y5,
  colorspace_pars_fragment: v5,
  envmap_fragment: b5,
  envmap_common_pars_fragment: x5,
  envmap_pars_fragment: _5,
  envmap_pars_vertex: T5,
  envmap_physical_pars_fragment: I5,
  envmap_vertex: S5,
  fog_vertex: w5,
  fog_pars_vertex: E5,
  fog_fragment: M5,
  fog_pars_fragment: A5,
  gradientmap_pars_fragment: C5,
  lightmap_pars_fragment: R5,
  lights_lambert_fragment: N5,
  lights_lambert_pars_fragment: P5,
  lights_pars_begin: O5,
  lights_toon_fragment: D5,
  lights_toon_pars_fragment: k5,
  lights_phong_fragment: L5,
  lights_phong_pars_fragment: U5,
  lights_physical_fragment: F5,
  lights_physical_pars_fragment: B5,
  lights_fragment_begin: z5,
  lights_fragment_maps: j5,
  lights_fragment_end: V5,
  logdepthbuf_fragment: G5,
  logdepthbuf_pars_fragment: H5,
  logdepthbuf_pars_vertex: W5,
  logdepthbuf_vertex: q5,
  map_fragment: X5,
  map_pars_fragment: Y5,
  map_particle_fragment: $5,
  map_particle_pars_fragment: K5,
  metalnessmap_fragment: Q5,
  metalnessmap_pars_fragment: Z5,
  morphinstance_vertex: J5,
  morphcolor_vertex: ez,
  morphnormal_vertex: tz,
  morphtarget_pars_vertex: iz,
  morphtarget_vertex: rz,
  normal_fragment_begin: nz,
  normal_fragment_maps: sz,
  normal_pars_fragment: az,
  normal_pars_vertex: oz,
  normal_vertex: lz,
  normalmap_pars_fragment: uz,
  clearcoat_normal_fragment_begin: cz,
  clearcoat_normal_fragment_maps: hz,
  clearcoat_pars_fragment: dz,
  iridescence_pars_fragment: pz,
  opaque_fragment: fz,
  packing: mz,
  premultiplied_alpha_fragment: gz,
  project_vertex: yz,
  dithering_fragment: vz,
  dithering_pars_fragment: bz,
  roughnessmap_fragment: xz,
  roughnessmap_pars_fragment: _z,
  shadowmap_pars_fragment: Tz,
  shadowmap_pars_vertex: Sz,
  shadowmap_vertex: wz,
  shadowmask_pars_fragment: Ez,
  skinbase_vertex: Mz,
  skinning_pars_vertex: Az,
  skinning_vertex: Cz,
  skinnormal_vertex: Rz,
  specularmap_fragment: Nz,
  specularmap_pars_fragment: Pz,
  tonemapping_fragment: Oz,
  tonemapping_pars_fragment: Iz,
  transmission_fragment: Dz,
  transmission_pars_fragment: kz,
  uv_pars_fragment: Lz,
  uv_pars_vertex: Uz,
  uv_vertex: Fz,
  worldpos_vertex: Bz,
  background_vert: zz,
  background_frag: jz,
  backgroundCube_vert: Vz,
  backgroundCube_frag: Gz,
  cube_vert: Hz,
  cube_frag: Wz,
  depth_vert: qz,
  depth_frag: Xz,
  distanceRGBA_vert: Yz,
  distanceRGBA_frag: $z,
  equirect_vert: Kz,
  equirect_frag: Qz,
  linedashed_vert: Zz,
  linedashed_frag: Jz,
  meshbasic_vert: e4,
  meshbasic_frag: t4,
  meshlambert_vert: i4,
  meshlambert_frag: r4,
  meshmatcap_vert: n4,
  meshmatcap_frag: s4,
  meshnormal_vert: a4,
  meshnormal_frag: o4,
  meshphong_vert: l4,
  meshphong_frag: u4,
  meshphysical_vert: c4,
  meshphysical_frag: h4,
  meshtoon_vert: d4,
  meshtoon_frag: p4,
  points_vert: f4,
  points_frag: m4,
  shadow_vert: g4,
  shadow_frag: y4,
  sprite_vert: v4,
  sprite_frag: b4
}, Ge = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Ft(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Ot() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ot() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Ot() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Ot() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Ot() },
    normalScale: { value: /* @__PURE__ */ new Le(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Ot() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Ft(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Ft(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ot() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Ot() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Ft(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Le(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Ot() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ot() },
    alphaTest: { value: 0 }
  }
}, ms = {
  basic: {
    uniforms: /* @__PURE__ */ xr([
      Ge.common,
      Ge.specularmap,
      Ge.envmap,
      Ge.aomap,
      Ge.lightmap,
      Ge.fog
    ]),
    vertexShader: Nt.meshbasic_vert,
    fragmentShader: Nt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ xr([
      Ge.common,
      Ge.specularmap,
      Ge.envmap,
      Ge.aomap,
      Ge.lightmap,
      Ge.emissivemap,
      Ge.bumpmap,
      Ge.normalmap,
      Ge.displacementmap,
      Ge.fog,
      Ge.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ft(0) }
      }
    ]),
    vertexShader: Nt.meshlambert_vert,
    fragmentShader: Nt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ xr([
      Ge.common,
      Ge.specularmap,
      Ge.envmap,
      Ge.aomap,
      Ge.lightmap,
      Ge.emissivemap,
      Ge.bumpmap,
      Ge.normalmap,
      Ge.displacementmap,
      Ge.fog,
      Ge.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ft(0) },
        specular: { value: /* @__PURE__ */ new Ft(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Nt.meshphong_vert,
    fragmentShader: Nt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ xr([
      Ge.common,
      Ge.envmap,
      Ge.aomap,
      Ge.lightmap,
      Ge.emissivemap,
      Ge.bumpmap,
      Ge.normalmap,
      Ge.displacementmap,
      Ge.roughnessmap,
      Ge.metalnessmap,
      Ge.fog,
      Ge.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ft(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Nt.meshphysical_vert,
    fragmentShader: Nt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ xr([
      Ge.common,
      Ge.aomap,
      Ge.lightmap,
      Ge.emissivemap,
      Ge.bumpmap,
      Ge.normalmap,
      Ge.displacementmap,
      Ge.gradientmap,
      Ge.fog,
      Ge.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ft(0) }
      }
    ]),
    vertexShader: Nt.meshtoon_vert,
    fragmentShader: Nt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ xr([
      Ge.common,
      Ge.bumpmap,
      Ge.normalmap,
      Ge.displacementmap,
      Ge.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Nt.meshmatcap_vert,
    fragmentShader: Nt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ xr([
      Ge.points,
      Ge.fog
    ]),
    vertexShader: Nt.points_vert,
    fragmentShader: Nt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ xr([
      Ge.common,
      Ge.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Nt.linedashed_vert,
    fragmentShader: Nt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ xr([
      Ge.common,
      Ge.displacementmap
    ]),
    vertexShader: Nt.depth_vert,
    fragmentShader: Nt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ xr([
      Ge.common,
      Ge.bumpmap,
      Ge.normalmap,
      Ge.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Nt.meshnormal_vert,
    fragmentShader: Nt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ xr([
      Ge.sprite,
      Ge.fog
    ]),
    vertexShader: Nt.sprite_vert,
    fragmentShader: Nt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Ot() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Nt.background_vert,
    fragmentShader: Nt.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Ot() }
    },
    vertexShader: Nt.backgroundCube_vert,
    fragmentShader: Nt.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Nt.cube_vert,
    fragmentShader: Nt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Nt.equirect_vert,
    fragmentShader: Nt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ xr([
      Ge.common,
      Ge.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new X() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Nt.distanceRGBA_vert,
    fragmentShader: Nt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ xr([
      Ge.lights,
      Ge.fog,
      {
        color: { value: /* @__PURE__ */ new Ft(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Nt.shadow_vert,
    fragmentShader: Nt.shadow_frag
  }
};
ms.physical = {
  uniforms: /* @__PURE__ */ xr([
    ms.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Ot() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Ot() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Le(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Ot() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Ot() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Ot() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Ft(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Ot() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Ot() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Ot() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Le() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Ot() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Ft(0) },
      specularColor: { value: /* @__PURE__ */ new Ft(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Ot() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Ot() },
      anisotropyVector: { value: /* @__PURE__ */ new Le() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Ot() }
    }
  ]),
  vertexShader: Nt.meshphysical_vert,
  fragmentShader: Nt.meshphysical_frag
};
const Rp = { r: 0, b: 0, g: 0 }, ko = /* @__PURE__ */ new bo(), x4 = /* @__PURE__ */ new ui();
function _4(r, e, i, n, s, a, o) {
  const l = new Ft(0);
  let u = a === !0 ? 0 : 1, c, h, d = null, p = 0, f = null;
  function m(_) {
    let x = _.isScene === !0 ? _.background : null;
    return x && x.isTexture && (x = (_.backgroundBlurriness > 0 ? i : e).get(x)), x;
  }
  function v(_) {
    let x = !1;
    const b = m(_);
    b === null ? g(l, u) : b && b.isColor && (g(b, 1), x = !0);
    const T = r.xr.getEnvironmentBlendMode();
    T === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : T === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (r.autoClear || x) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil));
  }
  function y(_, x) {
    const b = m(x);
    b && (b.isCubeTexture || b.mapping === gg) ? (h === void 0 && (h = new Ur(
      new O_(1, 1, 1),
      new Ss({
        name: "BackgroundCubeMaterial",
        uniforms: yc(ms.backgroundCube.uniforms),
        vertexShader: ms.backgroundCube.vertexShader,
        fragmentShader: ms.backgroundCube.fragmentShader,
        side: Mr,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(T, S, w) {
      this.matrixWorld.copyPosition(w.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), s.update(h)), ko.copy(x.backgroundRotation), ko.x *= -1, ko.y *= -1, ko.z *= -1, b.isCubeTexture && b.isRenderTargetTexture === !1 && (ko.y *= -1, ko.z *= -1), h.material.uniforms.envMap.value = b, h.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = x.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(x4.makeRotationFromEuler(ko)), h.material.toneMapped = Gt.getTransfer(b.colorSpace) !== ei, (d !== b || p !== b.version || f !== r.toneMapping) && (h.material.needsUpdate = !0, d = b, p = b.version, f = r.toneMapping), h.layers.enableAll(), _.unshift(h, h.geometry, h.material, 0, 0, null)) : b && b.isTexture && (c === void 0 && (c = new Ur(
      new Gd(2, 2),
      new Ss({
        name: "BackgroundMaterial",
        uniforms: yc(ms.background.uniforms),
        vertexShader: ms.background.vertexShader,
        fragmentShader: ms.background.fragmentShader,
        side: yo,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), s.update(c)), c.material.uniforms.t2D.value = b, c.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, c.material.toneMapped = Gt.getTransfer(b.colorSpace) !== ei, b.matrixAutoUpdate === !0 && b.updateMatrix(), c.material.uniforms.uvTransform.value.copy(b.matrix), (d !== b || p !== b.version || f !== r.toneMapping) && (c.material.needsUpdate = !0, d = b, p = b.version, f = r.toneMapping), c.layers.enableAll(), _.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function g(_, x) {
    _.getRGB(Rp, oR(r)), n.buffers.color.setClear(Rp.r, Rp.g, Rp.b, x, o);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(_, x = 1) {
      l.set(_), u = x, g(l, u);
    },
    getClearAlpha: function() {
      return u;
    },
    setClearAlpha: function(_) {
      u = _, g(l, u);
    },
    render: v,
    addToRenderList: y
  };
}
function T4(r, e) {
  const i = r.getParameter(r.MAX_VERTEX_ATTRIBS), n = {}, s = p(null);
  let a = s, o = !1;
  function l(A, N, L, F, M) {
    let P = !1;
    const O = d(F, L, N);
    a !== O && (a = O, c(a.object)), P = f(A, F, L, M), P && m(A, F, L, M), M !== null && e.update(M, r.ELEMENT_ARRAY_BUFFER), (P || o) && (o = !1, b(A, N, L, F), M !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(M).buffer));
  }
  function u() {
    return r.createVertexArray();
  }
  function c(A) {
    return r.bindVertexArray(A);
  }
  function h(A) {
    return r.deleteVertexArray(A);
  }
  function d(A, N, L) {
    const F = L.wireframe === !0;
    let M = n[A.id];
    M === void 0 && (M = {}, n[A.id] = M);
    let P = M[N.id];
    P === void 0 && (P = {}, M[N.id] = P);
    let O = P[F];
    return O === void 0 && (O = p(u()), P[F] = O), O;
  }
  function p(A) {
    const N = [], L = [], F = [];
    for (let M = 0; M < i; M++)
      N[M] = 0, L[M] = 0, F[M] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: N,
      enabledAttributes: L,
      attributeDivisors: F,
      object: A,
      attributes: {},
      index: null
    };
  }
  function f(A, N, L, F) {
    const M = a.attributes, P = N.attributes;
    let O = 0;
    const V = L.getAttributes();
    for (const B in V)
      if (V[B].location >= 0) {
        const H = M[B];
        let U = P[B];
        if (U === void 0 && (B === "instanceMatrix" && A.instanceMatrix && (U = A.instanceMatrix), B === "instanceColor" && A.instanceColor && (U = A.instanceColor)), H === void 0 || H.attribute !== U || U && H.data !== U.data) return !0;
        O++;
      }
    return a.attributesNum !== O || a.index !== F;
  }
  function m(A, N, L, F) {
    const M = {}, P = N.attributes;
    let O = 0;
    const V = L.getAttributes();
    for (const B in V)
      if (V[B].location >= 0) {
        let H = P[B];
        H === void 0 && (B === "instanceMatrix" && A.instanceMatrix && (H = A.instanceMatrix), B === "instanceColor" && A.instanceColor && (H = A.instanceColor));
        const U = {};
        U.attribute = H, H && H.data && (U.data = H.data), M[B] = U, O++;
      }
    a.attributes = M, a.attributesNum = O, a.index = F;
  }
  function v() {
    const A = a.newAttributes;
    for (let N = 0, L = A.length; N < L; N++)
      A[N] = 0;
  }
  function y(A) {
    g(A, 0);
  }
  function g(A, N) {
    const L = a.newAttributes, F = a.enabledAttributes, M = a.attributeDivisors;
    L[A] = 1, F[A] === 0 && (r.enableVertexAttribArray(A), F[A] = 1), M[A] !== N && (r.vertexAttribDivisor(A, N), M[A] = N);
  }
  function _() {
    const A = a.newAttributes, N = a.enabledAttributes;
    for (let L = 0, F = N.length; L < F; L++)
      N[L] !== A[L] && (r.disableVertexAttribArray(L), N[L] = 0);
  }
  function x(A, N, L, F, M, P, O) {
    O === !0 ? r.vertexAttribIPointer(A, N, L, M, P) : r.vertexAttribPointer(A, N, L, F, M, P);
  }
  function b(A, N, L, F) {
    v();
    const M = F.attributes, P = L.getAttributes(), O = N.defaultAttributeValues;
    for (const V in P) {
      const B = P[V];
      if (B.location >= 0) {
        let H = M[V];
        if (H === void 0 && (V === "instanceMatrix" && A.instanceMatrix && (H = A.instanceMatrix), V === "instanceColor" && A.instanceColor && (H = A.instanceColor)), H !== void 0) {
          const U = H.normalized, j = H.itemSize, Q = e.get(H);
          if (Q === void 0) continue;
          const q = Q.buffer, G = Q.type, Y = Q.bytesPerElement, ae = G === r.INT || G === r.UNSIGNED_INT || H.gpuType === w_;
          if (H.isInterleavedBufferAttribute) {
            const ue = H.data, ge = ue.stride, we = H.offset;
            if (ue.isInstancedInterleavedBuffer) {
              for (let Ne = 0; Ne < B.locationSize; Ne++)
                g(B.location + Ne, ue.meshPerAttribute);
              A.isInstancedMesh !== !0 && F._maxInstanceCount === void 0 && (F._maxInstanceCount = ue.meshPerAttribute * ue.count);
            } else
              for (let Ne = 0; Ne < B.locationSize; Ne++)
                y(B.location + Ne);
            r.bindBuffer(r.ARRAY_BUFFER, q);
            for (let Ne = 0; Ne < B.locationSize; Ne++)
              x(
                B.location + Ne,
                j / B.locationSize,
                G,
                U,
                ge * Y,
                (we + j / B.locationSize * Ne) * Y,
                ae
              );
          } else {
            if (H.isInstancedBufferAttribute) {
              for (let ue = 0; ue < B.locationSize; ue++)
                g(B.location + ue, H.meshPerAttribute);
              A.isInstancedMesh !== !0 && F._maxInstanceCount === void 0 && (F._maxInstanceCount = H.meshPerAttribute * H.count);
            } else
              for (let ue = 0; ue < B.locationSize; ue++)
                y(B.location + ue);
            r.bindBuffer(r.ARRAY_BUFFER, q);
            for (let ue = 0; ue < B.locationSize; ue++)
              x(
                B.location + ue,
                j / B.locationSize,
                G,
                U,
                j * Y,
                j / B.locationSize * ue * Y,
                ae
              );
          }
        } else if (O !== void 0) {
          const U = O[V];
          if (U !== void 0)
            switch (U.length) {
              case 2:
                r.vertexAttrib2fv(B.location, U);
                break;
              case 3:
                r.vertexAttrib3fv(B.location, U);
                break;
              case 4:
                r.vertexAttrib4fv(B.location, U);
                break;
              default:
                r.vertexAttrib1fv(B.location, U);
            }
        }
      }
    }
    _();
  }
  function T() {
    C();
    for (const A in n) {
      const N = n[A];
      for (const L in N) {
        const F = N[L];
        for (const M in F)
          h(F[M].object), delete F[M];
        delete N[L];
      }
      delete n[A];
    }
  }
  function S(A) {
    if (n[A.id] === void 0) return;
    const N = n[A.id];
    for (const L in N) {
      const F = N[L];
      for (const M in F)
        h(F[M].object), delete F[M];
      delete N[L];
    }
    delete n[A.id];
  }
  function w(A) {
    for (const N in n) {
      const L = n[N];
      if (L[A.id] === void 0) continue;
      const F = L[A.id];
      for (const M in F)
        h(F[M].object), delete F[M];
      delete L[A.id];
    }
  }
  function C() {
    E(), o = !0, a !== s && (a = s, c(a.object));
  }
  function E() {
    s.geometry = null, s.program = null, s.wireframe = !1;
  }
  return {
    setup: l,
    reset: C,
    resetDefaultState: E,
    dispose: T,
    releaseStatesOfGeometry: S,
    releaseStatesOfProgram: w,
    initAttributes: v,
    enableAttribute: y,
    disableUnusedAttributes: _
  };
}
function S4(r, e, i) {
  let n;
  function s(c) {
    n = c;
  }
  function a(c, h) {
    r.drawArrays(n, c, h), i.update(h, n, 1);
  }
  function o(c, h, d) {
    d !== 0 && (r.drawArraysInstanced(n, c, h, d), i.update(h, n, d));
  }
  function l(c, h, d) {
    if (d === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, h, 0, d);
    let p = 0;
    for (let f = 0; f < d; f++)
      p += h[f];
    i.update(p, n, 1);
  }
  function u(c, h, d, p) {
    if (d === 0) return;
    const f = e.get("WEBGL_multi_draw");
    if (f === null)
      for (let m = 0; m < c.length; m++)
        o(c[m], h[m], p[m]);
    else {
      f.multiDrawArraysInstancedWEBGL(n, c, 0, h, 0, p, 0, d);
      let m = 0;
      for (let v = 0; v < d; v++)
        m += h[v] * p[v];
      i.update(m, n, 1);
    }
  }
  this.setMode = s, this.render = a, this.renderInstances = o, this.renderMultiDraw = l, this.renderMultiDrawInstances = u;
}
function w4(r, e, i, n) {
  let s;
  function a() {
    if (s !== void 0) return s;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const w = e.get("EXT_texture_filter_anisotropic");
      s = r.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      s = 0;
    return s;
  }
  function o(w) {
    return !(w !== Kn && n.convert(w) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function l(w) {
    const C = w === Dc && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(w !== Ta && n.convert(w) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    w !== aa && !C);
  }
  function u(w) {
    if (w === "highp") {
      if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
        return "highp";
      w = "mediump";
    }
    return w === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let c = i.precision !== void 0 ? i.precision : "highp";
  const h = u(c);
  h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
  const d = i.logarithmicDepthBuffer === !0, p = i.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), f = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), m = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), v = r.getParameter(r.MAX_TEXTURE_SIZE), y = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), g = r.getParameter(r.MAX_VERTEX_ATTRIBS), _ = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), x = r.getParameter(r.MAX_VARYING_VECTORS), b = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), T = m > 0, S = r.getParameter(r.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: a,
    getMaxPrecision: u,
    textureFormatReadable: o,
    textureTypeReadable: l,
    precision: c,
    logarithmicDepthBuffer: d,
    reverseDepthBuffer: p,
    maxTextures: f,
    maxVertexTextures: m,
    maxTextureSize: v,
    maxCubemapSize: y,
    maxAttributes: g,
    maxVertexUniforms: _,
    maxVaryings: x,
    maxFragmentUniforms: b,
    vertexTextures: T,
    maxSamples: S
  };
}
function E4(r) {
  const e = this;
  let i = null, n = 0, s = !1, a = !1;
  const o = new $s(), l = new Ot(), u = { value: null, needsUpdate: !1 };
  this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, p) {
    const f = d.length !== 0 || p || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || s;
    return s = p, n = d.length, f;
  }, this.beginShadows = function() {
    a = !0, h(null);
  }, this.endShadows = function() {
    a = !1;
  }, this.setGlobalState = function(d, p) {
    i = h(d, p, 0);
  }, this.setState = function(d, p, f) {
    const m = d.clippingPlanes, v = d.clipIntersection, y = d.clipShadows, g = r.get(d);
    if (!s || m === null || m.length === 0 || a && !y)
      a ? h(null) : c();
    else {
      const _ = a ? 0 : n, x = _ * 4;
      let b = g.clippingState || null;
      u.value = b, b = h(m, p, x, f);
      for (let T = 0; T !== x; ++T)
        b[T] = i[T];
      g.clippingState = b, this.numIntersection = v ? this.numPlanes : 0, this.numPlanes += _;
    }
  };
  function c() {
    u.value !== i && (u.value = i, u.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function h(d, p, f, m) {
    const v = d !== null ? d.length : 0;
    let y = null;
    if (v !== 0) {
      if (y = u.value, m !== !0 || y === null) {
        const g = f + v * 4, _ = p.matrixWorldInverse;
        l.getNormalMatrix(_), (y === null || y.length < g) && (y = new Float32Array(g));
        for (let x = 0, b = f; x !== v; ++x, b += 4)
          o.copy(d[x]).applyMatrix4(_, l), o.normal.toArray(y, b), y[b + 3] = o.constant;
      }
      u.value = y, u.needsUpdate = !0;
    }
    return e.numPlanes = v, e.numIntersection = 0, y;
  }
}
function M4(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function i(o, l) {
    return l === rb ? o.mapping = pc : l === nb && (o.mapping = fc), o;
  }
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping;
      if (l === rb || l === nb)
        if (e.has(o)) {
          const u = e.get(o).texture;
          return i(u, o.mapping);
        } else {
          const u = o.image;
          if (u && u.height > 0) {
            const c = new UB(u.height);
            return c.fromEquirectangularTexture(r, o), e.set(o, c), o.addEventListener("dispose", s), i(c.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function s(o) {
    const l = o.target;
    l.removeEventListener("dispose", s);
    const u = e.get(l);
    u !== void 0 && (e.delete(l), u.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: a
  };
}
let D_ = class extends uR {
  constructor(r = -1, e = 1, i = 1, n = -1, s = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = r, this.right = e, this.top = i, this.bottom = n, this.near = s, this.far = a, this.updateProjectionMatrix();
  }
  copy(r, e) {
    return super.copy(r, e), this.left = r.left, this.right = r.right, this.top = r.top, this.bottom = r.bottom, this.near = r.near, this.far = r.far, this.zoom = r.zoom, this.view = r.view === null ? null : Object.assign({}, r.view), this;
  }
  setViewOffset(r, e, i, n, s, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = r, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const r = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
    let s = i - r, a = i + r, o = n + e, l = n - e;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += u * this.view.offsetX, a = s + u * this.view.width, o -= c * this.view.offsetY, l = o - c * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
};
const Du = 4, H1 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Ko = 20, Fy = /* @__PURE__ */ new D_(), W1 = /* @__PURE__ */ new Ft();
let By = null, zy = 0, jy = 0, Vy = !1;
const Ho = (1 + Math.sqrt(5)) / 2, tu = 1 / Ho, q1 = [
  /* @__PURE__ */ new X(-Ho, tu, 0),
  /* @__PURE__ */ new X(Ho, tu, 0),
  /* @__PURE__ */ new X(-tu, 0, Ho),
  /* @__PURE__ */ new X(tu, 0, Ho),
  /* @__PURE__ */ new X(0, Ho, -tu),
  /* @__PURE__ */ new X(0, Ho, tu),
  /* @__PURE__ */ new X(-1, 1, -1),
  /* @__PURE__ */ new X(1, 1, -1),
  /* @__PURE__ */ new X(-1, 1, 1),
  /* @__PURE__ */ new X(1, 1, 1)
];
let X1 = class {
  constructor(r) {
    this._renderer = r, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(r, e = 0, i = 0.1, n = 100) {
    By = this._renderer.getRenderTarget(), zy = this._renderer.getActiveCubeFace(), jy = this._renderer.getActiveMipmapLevel(), Vy = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(r, i, n, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(r, e = null) {
    return this._fromTexture(r, e);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(r, e = null) {
    return this._fromTexture(r, e);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = K1(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = $1(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(r) {
    this._lodMax = Math.floor(Math.log2(r)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let r = 0; r < this._lodPlanes.length; r++)
      this._lodPlanes[r].dispose();
  }
  _cleanup(r) {
    this._renderer.setRenderTarget(By, zy, jy), this._renderer.xr.enabled = Vy, r.scissorTest = !1, Np(r, 0, 0, r.width, r.height);
  }
  _fromTexture(r, e) {
    r.mapping === pc || r.mapping === fc ? this._setSize(r.image.length === 0 ? 16 : r.image[0].width || r.image[0].image.width) : this._setSize(r.image.width / 4), By = this._renderer.getRenderTarget(), zy = this._renderer.getActiveCubeFace(), jy = this._renderer.getActiveMipmapLevel(), Vy = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const i = e || this._allocateTargets();
    return this._textureToCubeUV(r, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const r = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, i = {
      magFilter: gs,
      minFilter: gs,
      generateMipmaps: !1,
      type: Dc,
      format: Kn,
      colorSpace: kc,
      depthBuffer: !1
    }, n = Y1(r, e, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== r || this._pingPongRenderTarget.height !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Y1(r, e, i);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = A4(s)), this._blurMaterial = C4(s, r, e);
    }
    return n;
  }
  _compileMaterial(r) {
    const e = new Ur(this._lodPlanes[0], r);
    this._renderer.compile(e, Fy);
  }
  _sceneToCubeUV(r, e, i, n) {
    const s = new _n(90, 1, e, i), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], l = this._renderer, u = l.autoClear, c = l.toneMapping;
    l.getClearColor(W1), l.toneMapping = co, l.autoClear = !1;
    const h = new xg({
      name: "PMREM.Background",
      side: Mr,
      depthWrite: !1,
      depthTest: !1
    }), d = new Ur(new O_(), h);
    let p = !1;
    const f = r.background;
    f ? f.isColor && (h.color.copy(f), r.background = null, p = !0) : (h.color.copy(W1), p = !0);
    for (let m = 0; m < 6; m++) {
      const v = m % 3;
      v === 0 ? (s.up.set(0, a[m], 0), s.lookAt(o[m], 0, 0)) : v === 1 ? (s.up.set(0, 0, a[m]), s.lookAt(0, o[m], 0)) : (s.up.set(0, a[m], 0), s.lookAt(0, 0, o[m]));
      const y = this._cubeSize;
      Np(n, v * y, m > 2 ? y : 0, y, y), l.setRenderTarget(n), p && l.render(d, s), l.render(r, s);
    }
    d.geometry.dispose(), d.material.dispose(), l.toneMapping = c, l.autoClear = u, r.background = f;
  }
  _textureToCubeUV(r, e) {
    const i = this._renderer, n = r.mapping === pc || r.mapping === fc;
    n ? (this._cubemapMaterial === null && (this._cubemapMaterial = K1()), this._cubemapMaterial.uniforms.flipEnvMap.value = r.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = $1());
    const s = n ? this._cubemapMaterial : this._equirectMaterial, a = new Ur(this._lodPlanes[0], s), o = s.uniforms;
    o.envMap.value = r;
    const l = this._cubeSize;
    Np(e, 0, 0, 3 * l, 2 * l), i.setRenderTarget(e), i.render(a, Fy);
  }
  _applyPMREM(r) {
    const e = this._renderer, i = e.autoClear;
    e.autoClear = !1;
    const n = this._lodPlanes.length;
    for (let s = 1; s < n; s++) {
      const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]), o = q1[(n - s - 1) % q1.length];
      this._blur(r, s - 1, s, a, o);
    }
    e.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(r, e, i, n, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      r,
      a,
      e,
      i,
      n,
      "latitudinal",
      s
    ), this._halfBlur(
      a,
      r,
      i,
      i,
      n,
      "longitudinal",
      s
    );
  }
  _halfBlur(r, e, i, n, s, a, o) {
    const l = this._renderer, u = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const c = 3, h = new Ur(this._lodPlanes[n], u), d = u.uniforms, p = this._sizeLods[i] - 1, f = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * Ko - 1), m = s / f, v = isFinite(s) ? 1 + Math.floor(c * m) : Ko;
    v > Ko && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Ko}`);
    const y = [];
    let g = 0;
    for (let S = 0; S < Ko; ++S) {
      const w = S / m, C = Math.exp(-w * w / 2);
      y.push(C), S === 0 ? g += C : S < v && (g += 2 * C);
    }
    for (let S = 0; S < y.length; S++)
      y[S] = y[S] / g;
    d.envMap.value = r.texture, d.samples.value = v, d.weights.value = y, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
    const { _lodMax: _ } = this;
    d.dTheta.value = f, d.mipInt.value = _ - i;
    const x = this._sizeLods[n], b = 3 * x * (n > _ - Du ? n - _ + Du : 0), T = 4 * (this._cubeSize - x);
    Np(e, b, T, 3 * x, 2 * x), l.setRenderTarget(e), l.render(h, Fy);
  }
};
function A4(r) {
  const e = [], i = [], n = [];
  let s = r;
  const a = r - Du + 1 + H1.length;
  for (let o = 0; o < a; o++) {
    const l = Math.pow(2, s);
    i.push(l);
    let u = 1 / l;
    o > r - Du ? u = H1[o - r + Du - 1] : o === 0 && (u = 0), n.push(u);
    const c = 1 / (l - 2), h = -c, d = 1 + c, p = [h, h, d, h, d, d, h, h, d, d, h, d], f = 6, m = 6, v = 3, y = 2, g = 1, _ = new Float32Array(v * m * f), x = new Float32Array(y * m * f), b = new Float32Array(g * m * f);
    for (let S = 0; S < f; S++) {
      const w = S % 3 * 2 / 3 - 1, C = S > 2 ? 0 : -1, E = [
        w,
        C,
        0,
        w + 2 / 3,
        C,
        0,
        w + 2 / 3,
        C + 1,
        0,
        w,
        C,
        0,
        w + 2 / 3,
        C + 1,
        0,
        w,
        C + 1,
        0
      ];
      _.set(E, v * m * S), x.set(p, y * m * S);
      const A = [S, S, S, S, S, S];
      b.set(A, g * m * S);
    }
    const T = new pn();
    T.setAttribute("position", new wn(_, v)), T.setAttribute("uv", new wn(x, y)), T.setAttribute("faceIndex", new wn(b, g)), e.push(T), s > Du && s--;
  }
  return { lodPlanes: e, sizeLods: i, sigmas: n };
}
function Y1(r, e, i) {
  const n = new vo(r, e, i);
  return n.texture.mapping = gg, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function Np(r, e, i, n, s) {
  r.viewport.set(e, i, n, s), r.scissor.set(e, i, n, s);
}
function C4(r, e, i) {
  const n = new Float32Array(Ko), s = new X(0, 1, 0);
  return new Ss({
    name: "SphericalGaussianBlur",
    defines: {
      n: Ko,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / i,
      CUBEUV_MAX_MIP: `${r}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: s }
    },
    vertexShader: k_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: ha,
    depthTest: !1,
    depthWrite: !1
  });
}
function $1() {
  return new Ss({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: k_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: ha,
    depthTest: !1,
    depthWrite: !1
  });
}
function K1() {
  return new Ss({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: k_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: ha,
    depthTest: !1,
    depthWrite: !1
  });
}
function k_() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function R4(r) {
  let e = /* @__PURE__ */ new WeakMap(), i = null;
  function n(l) {
    if (l && l.isTexture) {
      const u = l.mapping, c = u === rb || u === nb, h = u === pc || u === fc;
      if (c || h) {
        let d = e.get(l);
        const p = d !== void 0 ? d.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== p)
          return i === null && (i = new X1(r)), d = c ? i.fromEquirectangular(l, d) : i.fromCubemap(l, d), d.texture.pmremVersion = l.pmremVersion, e.set(l, d), d.texture;
        if (d !== void 0)
          return d.texture;
        {
          const f = l.image;
          return c && f && f.height > 0 || h && f && s(f) ? (i === null && (i = new X1(r)), d = c ? i.fromEquirectangular(l) : i.fromCubemap(l), d.texture.pmremVersion = l.pmremVersion, e.set(l, d), l.addEventListener("dispose", a), d.texture) : null;
        }
      }
    }
    return l;
  }
  function s(l) {
    let u = 0;
    const c = 6;
    for (let h = 0; h < c; h++)
      l[h] !== void 0 && u++;
    return u === c;
  }
  function a(l) {
    const u = l.target;
    u.removeEventListener("dispose", a);
    const c = e.get(u);
    c !== void 0 && (e.delete(u), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), i !== null && (i.dispose(), i = null);
  }
  return {
    get: n,
    dispose: o
  };
}
function N4(r) {
  const e = {};
  function i(n) {
    if (e[n] !== void 0)
      return e[n];
    let s;
    switch (n) {
      case "WEBGL_depth_texture":
        s = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        s = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        s = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        s = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        s = r.getExtension(n);
    }
    return e[n] = s, s;
  }
  return {
    has: function(n) {
      return i(n) !== null;
    },
    init: function() {
      i("EXT_color_buffer_float"), i("WEBGL_clip_cull_distance"), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float"), i("WEBGL_multisampled_render_to_texture"), i("WEBGL_render_shared_exponent");
    },
    get: function(n) {
      const s = i(n);
      return s === null && Uh("THREE.WebGLRenderer: " + n + " extension not supported."), s;
    }
  };
}
function P4(r, e, i, n) {
  const s = {}, a = /* @__PURE__ */ new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const m in p.attributes)
      e.remove(p.attributes[m]);
    for (const m in p.morphAttributes) {
      const v = p.morphAttributes[m];
      for (let y = 0, g = v.length; y < g; y++)
        e.remove(v[y]);
    }
    p.removeEventListener("dispose", o), delete s[p.id];
    const f = a.get(p);
    f && (e.remove(f), a.delete(p)), n.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, i.memory.geometries--;
  }
  function l(d, p) {
    return s[p.id] === !0 || (p.addEventListener("dispose", o), s[p.id] = !0, i.memory.geometries++), p;
  }
  function u(d) {
    const p = d.attributes;
    for (const m in p)
      e.update(p[m], r.ARRAY_BUFFER);
    const f = d.morphAttributes;
    for (const m in f) {
      const v = f[m];
      for (let y = 0, g = v.length; y < g; y++)
        e.update(v[y], r.ARRAY_BUFFER);
    }
  }
  function c(d) {
    const p = [], f = d.index, m = d.attributes.position;
    let v = 0;
    if (f !== null) {
      const _ = f.array;
      v = f.version;
      for (let x = 0, b = _.length; x < b; x += 3) {
        const T = _[x + 0], S = _[x + 1], w = _[x + 2];
        p.push(T, S, S, w, w, T);
      }
    } else if (m !== void 0) {
      const _ = m.array;
      v = m.version;
      for (let x = 0, b = _.length / 3 - 1; x < b; x += 3) {
        const T = x + 0, S = x + 1, w = x + 2;
        p.push(T, S, S, w, w, T);
      }
    } else
      return;
    const y = new (KC(p) ? nR : rR)(p, 1);
    y.version = v;
    const g = a.get(d);
    g && e.remove(g), a.set(d, y);
  }
  function h(d) {
    const p = a.get(d);
    if (p) {
      const f = d.index;
      f !== null && p.version < f.version && c(d);
    } else
      c(d);
    return a.get(d);
  }
  return {
    get: l,
    update: u,
    getWireframeAttribute: h
  };
}
function O4(r, e, i) {
  let n;
  function s(p) {
    n = p;
  }
  let a, o;
  function l(p) {
    a = p.type, o = p.bytesPerElement;
  }
  function u(p, f) {
    r.drawElements(n, f, a, p * o), i.update(f, n, 1);
  }
  function c(p, f, m) {
    m !== 0 && (r.drawElementsInstanced(n, f, a, p * o, m), i.update(f, n, m));
  }
  function h(p, f, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, f, 0, a, p, 0, m);
    let v = 0;
    for (let y = 0; y < m; y++)
      v += f[y];
    i.update(v, n, 1);
  }
  function d(p, f, m, v) {
    if (m === 0) return;
    const y = e.get("WEBGL_multi_draw");
    if (y === null)
      for (let g = 0; g < p.length; g++)
        c(p[g] / o, f[g], v[g]);
    else {
      y.multiDrawElementsInstancedWEBGL(n, f, 0, a, p, 0, v, 0, m);
      let g = 0;
      for (let _ = 0; _ < m; _++)
        g += f[_] * v[_];
      i.update(g, n, 1);
    }
  }
  this.setMode = s, this.setIndex = l, this.render = u, this.renderInstances = c, this.renderMultiDraw = h, this.renderMultiDrawInstances = d;
}
function I4(r) {
  const e = {
    geometries: 0,
    textures: 0
  }, i = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(a, o, l) {
    switch (i.calls++, o) {
      case r.TRIANGLES:
        i.triangles += l * (a / 3);
        break;
      case r.LINES:
        i.lines += l * (a / 2);
        break;
      case r.LINE_STRIP:
        i.lines += l * (a - 1);
        break;
      case r.LINE_LOOP:
        i.lines += l * a;
        break;
      case r.POINTS:
        i.points += l * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function s() {
    i.calls = 0, i.triangles = 0, i.points = 0, i.lines = 0;
  }
  return {
    memory: e,
    render: i,
    programs: null,
    autoReset: !0,
    reset: s,
    update: n
  };
}
function D4(r, e, i) {
  const n = /* @__PURE__ */ new WeakMap(), s = new Fi();
  function a(o, l, u) {
    const c = o.morphTargetInfluences, h = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color, d = h !== void 0 ? h.length : 0;
    let p = n.get(l);
    if (p === void 0 || p.count !== d) {
      let f = function() {
        C.dispose(), n.delete(l), l.removeEventListener("dispose", f);
      };
      p !== void 0 && p.texture.dispose();
      const m = l.morphAttributes.position !== void 0, v = l.morphAttributes.normal !== void 0, y = l.morphAttributes.color !== void 0, g = l.morphAttributes.position || [], _ = l.morphAttributes.normal || [], x = l.morphAttributes.color || [];
      let b = 0;
      m === !0 && (b = 1), v === !0 && (b = 2), y === !0 && (b = 3);
      let T = l.attributes.position.count * b, S = 1;
      T > e.maxTextureSize && (S = Math.ceil(T / e.maxTextureSize), T = e.maxTextureSize);
      const w = new Float32Array(T * S * 4 * d), C = new JC(w, T, S, d);
      C.type = aa, C.needsUpdate = !0;
      const E = b * 4;
      for (let A = 0; A < d; A++) {
        const N = g[A], L = _[A], F = x[A], M = T * S * 4 * A;
        for (let P = 0; P < N.count; P++) {
          const O = P * E;
          m === !0 && (s.fromBufferAttribute(N, P), w[M + O + 0] = s.x, w[M + O + 1] = s.y, w[M + O + 2] = s.z, w[M + O + 3] = 0), v === !0 && (s.fromBufferAttribute(L, P), w[M + O + 4] = s.x, w[M + O + 5] = s.y, w[M + O + 6] = s.z, w[M + O + 7] = 0), y === !0 && (s.fromBufferAttribute(F, P), w[M + O + 8] = s.x, w[M + O + 9] = s.y, w[M + O + 10] = s.z, w[M + O + 11] = F.itemSize === 4 ? s.w : 1);
        }
      }
      p = {
        count: d,
        texture: C,
        size: new Le(T, S)
      }, n.set(l, p), l.addEventListener("dispose", f);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      u.getUniforms().setValue(r, "morphTexture", o.morphTexture, i);
    else {
      let f = 0;
      for (let v = 0; v < c.length; v++)
        f += c[v];
      const m = l.morphTargetsRelative ? 1 : 1 - f;
      u.getUniforms().setValue(r, "morphTargetBaseInfluence", m), u.getUniforms().setValue(r, "morphTargetInfluences", c);
    }
    u.getUniforms().setValue(r, "morphTargetsTexture", p.texture, i), u.getUniforms().setValue(r, "morphTargetsTextureSize", p.size);
  }
  return {
    update: a
  };
}
function k4(r, e, i, n) {
  let s = /* @__PURE__ */ new WeakMap();
  function a(u) {
    const c = n.render.frame, h = u.geometry, d = e.get(u, h);
    if (s.get(d) !== c && (e.update(d), s.set(d, c)), u.isInstancedMesh && (u.hasEventListener("dispose", l) === !1 && u.addEventListener("dispose", l), s.get(u) !== c && (i.update(u.instanceMatrix, r.ARRAY_BUFFER), u.instanceColor !== null && i.update(u.instanceColor, r.ARRAY_BUFFER), s.set(u, c))), u.isSkinnedMesh) {
      const p = u.skeleton;
      s.get(p) !== c && (p.update(), s.set(p, c));
    }
    return d;
  }
  function o() {
    s = /* @__PURE__ */ new WeakMap();
  }
  function l(u) {
    const c = u.target;
    c.removeEventListener("dispose", l), i.remove(c.instanceMatrix), c.instanceColor !== null && i.remove(c.instanceColor);
  }
  return {
    update: a,
    dispose: o
  };
}
let dR = class extends Cn {
  constructor(r, e, i, n, s, a, o, l, u, c = Wu) {
    if (c !== Wu && c !== gc)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && c === Wu && (i = Tl), i === void 0 && c === gc && (i = mc), super(null, n, s, a, o, l, c, i, u), this.isDepthTexture = !0, this.image = { width: r, height: e }, this.magFilter = o !== void 0 ? o : Jn, this.minFilter = l !== void 0 ? l : Jn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(r) {
    return super.copy(r), this.compareFunction = r.compareFunction, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
  }
};
const pR = /* @__PURE__ */ new Cn(), Q1 = /* @__PURE__ */ new dR(1, 1), fR = /* @__PURE__ */ new JC(), mR = /* @__PURE__ */ new TB(), gR = /* @__PURE__ */ new cR(), Z1 = [], J1 = [], ew = new Float32Array(16), tw = new Float32Array(9), iw = new Float32Array(4);
function Lc(r, e, i) {
  const n = r[0];
  if (n <= 0 || n > 0) return r;
  const s = e * i;
  let a = Z1[s];
  if (a === void 0 && (a = new Float32Array(s), Z1[s] = a), e !== 0) {
    n.toArray(a, 0);
    for (let o = 1, l = 0; o !== e; ++o)
      l += i, r[o].toArray(a, l);
  }
  return a;
}
function Gi(r, e) {
  if (r.length !== e.length) return !1;
  for (let i = 0, n = r.length; i < n; i++)
    if (r[i] !== e[i]) return !1;
  return !0;
}
function Hi(r, e) {
  for (let i = 0, n = e.length; i < n; i++)
    r[i] = e[i];
}
function _g(r, e) {
  let i = J1[e];
  i === void 0 && (i = new Int32Array(e), J1[e] = i);
  for (let n = 0; n !== e; ++n)
    i[n] = r.allocateTextureUnit();
  return i;
}
function L4(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1f(this.addr, e), i[0] = e);
}
function U4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Gi(i, e)) return;
    r.uniform2fv(this.addr, e), Hi(i, e);
  }
}
function F4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else if (e.r !== void 0)
    (i[0] !== e.r || i[1] !== e.g || i[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
  else {
    if (Gi(i, e)) return;
    r.uniform3fv(this.addr, e), Hi(i, e);
  }
}
function B4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Gi(i, e)) return;
    r.uniform4fv(this.addr, e), Hi(i, e);
  }
}
function z4(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Gi(i, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), Hi(i, e);
  } else {
    if (Gi(i, n)) return;
    iw.set(n), r.uniformMatrix2fv(this.addr, !1, iw), Hi(i, n);
  }
}
function j4(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Gi(i, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), Hi(i, e);
  } else {
    if (Gi(i, n)) return;
    tw.set(n), r.uniformMatrix3fv(this.addr, !1, tw), Hi(i, n);
  }
}
function V4(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Gi(i, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), Hi(i, e);
  } else {
    if (Gi(i, n)) return;
    ew.set(n), r.uniformMatrix4fv(this.addr, !1, ew), Hi(i, n);
  }
}
function G4(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1i(this.addr, e), i[0] = e);
}
function H4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Gi(i, e)) return;
    r.uniform2iv(this.addr, e), Hi(i, e);
  }
}
function W4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else {
    if (Gi(i, e)) return;
    r.uniform3iv(this.addr, e), Hi(i, e);
  }
}
function q4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Gi(i, e)) return;
    r.uniform4iv(this.addr, e), Hi(i, e);
  }
}
function X4(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1ui(this.addr, e), i[0] = e);
}
function Y4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Gi(i, e)) return;
    r.uniform2uiv(this.addr, e), Hi(i, e);
  }
}
function $4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else {
    if (Gi(i, e)) return;
    r.uniform3uiv(this.addr, e), Hi(i, e);
  }
}
function K4(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Gi(i, e)) return;
    r.uniform4uiv(this.addr, e), Hi(i, e);
  }
}
function Q4(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s);
  let a;
  this.type === r.SAMPLER_2D_SHADOW ? (Q1.compareFunction = XC, a = Q1) : a = pR, i.setTexture2D(e || a, s);
}
function Z4(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTexture3D(e || mR, s);
}
function J4(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTextureCube(e || gR, s);
}
function ej(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTexture2DArray(e || fR, s);
}
function tj(r) {
  switch (r) {
    case 5126:
      return L4;
    case 35664:
      return U4;
    case 35665:
      return F4;
    case 35666:
      return B4;
    case 35674:
      return z4;
    case 35675:
      return j4;
    case 35676:
      return V4;
    case 5124:
    case 35670:
      return G4;
    case 35667:
    case 35671:
      return H4;
    case 35668:
    case 35672:
      return W4;
    case 35669:
    case 35673:
      return q4;
    case 5125:
      return X4;
    case 36294:
      return Y4;
    case 36295:
      return $4;
    case 36296:
      return K4;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Q4;
    case 35679:
    case 36299:
    case 36307:
      return Z4;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return J4;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return ej;
  }
}
function ij(r, e) {
  r.uniform1fv(this.addr, e);
}
function rj(r, e) {
  const i = Lc(e, this.size, 2);
  r.uniform2fv(this.addr, i);
}
function nj(r, e) {
  const i = Lc(e, this.size, 3);
  r.uniform3fv(this.addr, i);
}
function sj(r, e) {
  const i = Lc(e, this.size, 4);
  r.uniform4fv(this.addr, i);
}
function aj(r, e) {
  const i = Lc(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, i);
}
function oj(r, e) {
  const i = Lc(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, i);
}
function lj(r, e) {
  const i = Lc(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, i);
}
function uj(r, e) {
  r.uniform1iv(this.addr, e);
}
function cj(r, e) {
  r.uniform2iv(this.addr, e);
}
function hj(r, e) {
  r.uniform3iv(this.addr, e);
}
function dj(r, e) {
  r.uniform4iv(this.addr, e);
}
function pj(r, e) {
  r.uniform1uiv(this.addr, e);
}
function fj(r, e) {
  r.uniform2uiv(this.addr, e);
}
function mj(r, e) {
  r.uniform3uiv(this.addr, e);
}
function gj(r, e) {
  r.uniform4uiv(this.addr, e);
}
function yj(r, e, i) {
  const n = this.cache, s = e.length, a = _g(i, s);
  Gi(n, a) || (r.uniform1iv(this.addr, a), Hi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture2D(e[o] || pR, a[o]);
}
function vj(r, e, i) {
  const n = this.cache, s = e.length, a = _g(i, s);
  Gi(n, a) || (r.uniform1iv(this.addr, a), Hi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture3D(e[o] || mR, a[o]);
}
function bj(r, e, i) {
  const n = this.cache, s = e.length, a = _g(i, s);
  Gi(n, a) || (r.uniform1iv(this.addr, a), Hi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTextureCube(e[o] || gR, a[o]);
}
function xj(r, e, i) {
  const n = this.cache, s = e.length, a = _g(i, s);
  Gi(n, a) || (r.uniform1iv(this.addr, a), Hi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture2DArray(e[o] || fR, a[o]);
}
function _j(r) {
  switch (r) {
    case 5126:
      return ij;
    case 35664:
      return rj;
    case 35665:
      return nj;
    case 35666:
      return sj;
    case 35674:
      return aj;
    case 35675:
      return oj;
    case 35676:
      return lj;
    case 5124:
    case 35670:
      return uj;
    case 35667:
    case 35671:
      return cj;
    case 35668:
    case 35672:
      return hj;
    case 35669:
    case 35673:
      return dj;
    case 5125:
      return pj;
    case 36294:
      return fj;
    case 36295:
      return mj;
    case 36296:
      return gj;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return yj;
    case 35679:
    case 36299:
    case 36307:
      return vj;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return bj;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return xj;
  }
}
class Tj {
  constructor(e, i, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = i.type, this.setValue = tj(i.type);
  }
}
class Sj {
  constructor(e, i, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = i.type, this.size = i.size, this.setValue = _j(i.type);
  }
}
class wj {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, i, n) {
    const s = this.seq;
    for (let a = 0, o = s.length; a !== o; ++a) {
      const l = s[a];
      l.setValue(e, i[l.id], n);
    }
  }
}
const Gy = /(\w+)(\])?(\[|\.)?/g;
function rw(r, e) {
  r.seq.push(e), r.map[e.id] = e;
}
function Ej(r, e, i) {
  const n = r.name, s = n.length;
  for (Gy.lastIndex = 0; ; ) {
    const a = Gy.exec(n), o = Gy.lastIndex;
    let l = a[1];
    const u = a[2] === "]", c = a[3];
    if (u && (l = l | 0), c === void 0 || c === "[" && o + 2 === s) {
      rw(i, c === void 0 ? new Tj(l, r, e) : new Sj(l, r, e));
      break;
    } else {
      let h = i.map[l];
      h === void 0 && (h = new wj(l), rw(i, h)), i = h;
    }
  }
}
class Qf {
  constructor(e, i) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(i, e.ACTIVE_UNIFORMS);
    for (let s = 0; s < n; ++s) {
      const a = e.getActiveUniform(i, s), o = e.getUniformLocation(i, a.name);
      Ej(a, o, this);
    }
  }
  setValue(e, i, n, s) {
    const a = this.map[i];
    a !== void 0 && a.setValue(e, n, s);
  }
  setOptional(e, i, n) {
    const s = i[n];
    s !== void 0 && this.setValue(e, n, s);
  }
  static upload(e, i, n, s) {
    for (let a = 0, o = i.length; a !== o; ++a) {
      const l = i[a], u = n[l.id];
      u.needsUpdate !== !1 && l.setValue(e, u.value, s);
    }
  }
  static seqWithValue(e, i) {
    const n = [];
    for (let s = 0, a = e.length; s !== a; ++s) {
      const o = e[s];
      o.id in i && n.push(o);
    }
    return n;
  }
}
function nw(r, e, i) {
  const n = r.createShader(e);
  return r.shaderSource(n, i), r.compileShader(n), n;
}
const Mj = 37297;
let Aj = 0;
function Cj(r, e) {
  const i = r.split(`
`), n = [], s = Math.max(e - 6, 0), a = Math.min(e + 6, i.length);
  for (let o = s; o < a; o++) {
    const l = o + 1;
    n.push(`${l === e ? ">" : " "} ${l}: ${i[o]}`);
  }
  return n.join(`
`);
}
const sw = /* @__PURE__ */ new Ot();
function Rj(r) {
  Gt._getMatrix(sw, Gt.workingColorSpace, r);
  const e = `mat3( ${sw.elements.map((i) => i.toFixed(4))} )`;
  switch (Gt.getTransfer(r)) {
    case yg:
      return [e, "LinearTransferOETF"];
    case ei:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", r), [e, "LinearTransferOETF"];
  }
}
function aw(r, e, i) {
  const n = r.getShaderParameter(e, r.COMPILE_STATUS), s = r.getShaderInfoLog(e).trim();
  if (n && s === "") return "";
  const a = /ERROR: 0:(\d+)/.exec(s);
  if (a) {
    const o = parseInt(a[1]);
    return i.toUpperCase() + `

` + s + `

` + Cj(r.getShaderSource(e), o);
  } else
    return s;
}
function Nj(r, e) {
  const i = Rj(e);
  return [
    `vec4 ${r}( vec4 value ) {`,
    `	return ${i[1]}( vec4( value.rgb * ${i[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function Pj(r, e) {
  let i;
  switch (e) {
    case DF:
      i = "Linear";
      break;
    case kF:
      i = "Reinhard";
      break;
    case LF:
      i = "Cineon";
      break;
    case UF:
      i = "ACESFilmic";
      break;
    case BF:
      i = "AgX";
      break;
    case zF:
      i = "Neutral";
      break;
    case FF:
      i = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), i = "Linear";
  }
  return "vec3 " + r + "( vec3 color ) { return " + i + "ToneMapping( color ); }";
}
const Pp = /* @__PURE__ */ new X();
function Oj() {
  Gt.getLuminanceCoefficients(Pp);
  const r = Pp.x.toFixed(4), e = Pp.y.toFixed(4), i = Pp.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r}, ${e}, ${i} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function Ij(r) {
  return [
    r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(Fh).join(`
`);
}
function Dj(r) {
  const e = [];
  for (const i in r) {
    const n = r[i];
    n !== !1 && e.push("#define " + i + " " + n);
  }
  return e.join(`
`);
}
function kj(r, e) {
  const i = {}, n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
  for (let s = 0; s < n; s++) {
    const a = r.getActiveAttrib(e, s), o = a.name;
    let l = 1;
    a.type === r.FLOAT_MAT2 && (l = 2), a.type === r.FLOAT_MAT3 && (l = 3), a.type === r.FLOAT_MAT4 && (l = 4), i[o] = {
      type: a.type,
      location: r.getAttribLocation(e, o),
      locationSize: l
    };
  }
  return i;
}
function Fh(r) {
  return r !== "";
}
function ow(r, e) {
  const i = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function lw(r, e) {
  return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const Lj = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Lb(r) {
  return r.replace(Lj, Fj);
}
const Uj = /* @__PURE__ */ new Map();
function Fj(r, e) {
  let i = Nt[e];
  if (i === void 0) {
    const n = Uj.get(e);
    if (n !== void 0)
      i = Nt[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return Lb(i);
}
const Bj = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function uw(r) {
  return r.replace(Bj, zj);
}
function zj(r, e, i, n) {
  let s = "";
  for (let a = parseInt(e); a < parseInt(i); a++)
    s += n.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
  return s;
}
function cw(r) {
  let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
  return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function jj(r) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return r.shadowMapType === DC ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === pF ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === qs && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function Vj(r) {
  let e = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case pc:
      case fc:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case gg:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function Gj(r) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case fc:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function Hj(r) {
  let e = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case S_:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case OF:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case IF:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function Wj(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const i = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 7 * 16)), texelHeight: n, maxMip: i };
}
function qj(r, e, i, n) {
  const s = r.getContext(), a = i.defines;
  let o = i.vertexShader, l = i.fragmentShader;
  const u = jj(i), c = Vj(i), h = Gj(i), d = Hj(i), p = Wj(i), f = Ij(i), m = Dj(a), v = s.createProgram();
  let y, g, _ = i.glslVersion ? "#version " + i.glslVersion + `
` : "";
  i.isRawShaderMaterial ? (y = [
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m
  ].filter(Fh).join(`
`), y.length > 0 && (y += `
`), g = [
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m
  ].filter(Fh).join(`
`), g.length > 0 && (g += `
`)) : (y = [
    cw(i),
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m,
    i.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    i.batching ? "#define USE_BATCHING" : "",
    i.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    i.instancing ? "#define USE_INSTANCING" : "",
    i.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    i.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    i.useFog && i.fog ? "#define USE_FOG" : "",
    i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
    i.map ? "#define USE_MAP" : "",
    i.envMap ? "#define USE_ENVMAP" : "",
    i.envMap ? "#define " + h : "",
    i.lightMap ? "#define USE_LIGHTMAP" : "",
    i.aoMap ? "#define USE_AOMAP" : "",
    i.bumpMap ? "#define USE_BUMPMAP" : "",
    i.normalMap ? "#define USE_NORMALMAP" : "",
    i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    i.anisotropy ? "#define USE_ANISOTROPY" : "",
    i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    i.specularMap ? "#define USE_SPECULARMAP" : "",
    i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    i.metalnessMap ? "#define USE_METALNESSMAP" : "",
    i.alphaMap ? "#define USE_ALPHAMAP" : "",
    i.alphaHash ? "#define USE_ALPHAHASH" : "",
    i.transmission ? "#define USE_TRANSMISSION" : "",
    i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    i.mapUv ? "#define MAP_UV " + i.mapUv : "",
    i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "",
    i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "",
    i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "",
    i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "",
    i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "",
    i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "",
    i.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv : "",
    i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "",
    i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "",
    i.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv : "",
    i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "",
    i.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv : "",
    i.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv : "",
    i.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv : "",
    i.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i.iridescenceThicknessMapUv : "",
    i.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv : "",
    i.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv : "",
    i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "",
    i.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv : "",
    i.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv : "",
    i.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv : "",
    i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "",
    //
    i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "",
    i.vertexColors ? "#define USE_COLOR" : "",
    i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    i.vertexUv1s ? "#define USE_UV1" : "",
    i.vertexUv2s ? "#define USE_UV2" : "",
    i.vertexUv3s ? "#define USE_UV3" : "",
    i.pointsUvs ? "#define USE_POINTS_UV" : "",
    i.flatShading ? "#define FLAT_SHADED" : "",
    i.skinning ? "#define USE_SKINNING" : "",
    i.morphTargets ? "#define USE_MORPHTARGETS" : "",
    i.morphNormals && i.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    i.morphColors ? "#define USE_MORPHCOLORS" : "",
    i.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "",
    i.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "",
    i.doubleSided ? "#define DOUBLE_SIDED" : "",
    i.flipSided ? "#define FLIP_SIDED" : "",
    i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    i.shadowMapEnabled ? "#define " + u : "",
    i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Fh).join(`
`), g = [
    cw(i),
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m,
    i.useFog && i.fog ? "#define USE_FOG" : "",
    i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
    i.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    i.map ? "#define USE_MAP" : "",
    i.matcap ? "#define USE_MATCAP" : "",
    i.envMap ? "#define USE_ENVMAP" : "",
    i.envMap ? "#define " + c : "",
    i.envMap ? "#define " + h : "",
    i.envMap ? "#define " + d : "",
    p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
    p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
    p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
    i.lightMap ? "#define USE_LIGHTMAP" : "",
    i.aoMap ? "#define USE_AOMAP" : "",
    i.bumpMap ? "#define USE_BUMPMAP" : "",
    i.normalMap ? "#define USE_NORMALMAP" : "",
    i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    i.anisotropy ? "#define USE_ANISOTROPY" : "",
    i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    i.clearcoat ? "#define USE_CLEARCOAT" : "",
    i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    i.dispersion ? "#define USE_DISPERSION" : "",
    i.iridescence ? "#define USE_IRIDESCENCE" : "",
    i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    i.specularMap ? "#define USE_SPECULARMAP" : "",
    i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    i.metalnessMap ? "#define USE_METALNESSMAP" : "",
    i.alphaMap ? "#define USE_ALPHAMAP" : "",
    i.alphaTest ? "#define USE_ALPHATEST" : "",
    i.alphaHash ? "#define USE_ALPHAHASH" : "",
    i.sheen ? "#define USE_SHEEN" : "",
    i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    i.transmission ? "#define USE_TRANSMISSION" : "",
    i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "",
    i.vertexColors || i.instancingColor || i.batchingColor ? "#define USE_COLOR" : "",
    i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    i.vertexUv1s ? "#define USE_UV1" : "",
    i.vertexUv2s ? "#define USE_UV2" : "",
    i.vertexUv3s ? "#define USE_UV3" : "",
    i.pointsUvs ? "#define USE_POINTS_UV" : "",
    i.gradientMap ? "#define USE_GRADIENTMAP" : "",
    i.flatShading ? "#define FLAT_SHADED" : "",
    i.doubleSided ? "#define DOUBLE_SIDED" : "",
    i.flipSided ? "#define FLIP_SIDED" : "",
    i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    i.shadowMapEnabled ? "#define " + u : "",
    i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    i.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    i.toneMapping !== co ? "#define TONE_MAPPING" : "",
    i.toneMapping !== co ? Nt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    i.toneMapping !== co ? Pj("toneMapping", i.toneMapping) : "",
    i.dithering ? "#define DITHERING" : "",
    i.opaque ? "#define OPAQUE" : "",
    Nt.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    Nj("linearToOutputTexel", i.outputColorSpace),
    Oj(),
    i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
    `
`
  ].filter(Fh).join(`
`)), o = Lb(o), o = ow(o, i), o = lw(o, i), l = Lb(l), l = ow(l, i), l = lw(l, i), o = uw(o), l = uw(l), i.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, y = [
    f,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + y, g = [
    "#define varying in",
    i.glslVersion === T1 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    i.glslVersion === T1 ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + g);
  const x = _ + y + o, b = _ + g + l, T = nw(s, s.VERTEX_SHADER, x), S = nw(s, s.FRAGMENT_SHADER, b);
  s.attachShader(v, T), s.attachShader(v, S), i.index0AttributeName !== void 0 ? s.bindAttribLocation(v, 0, i.index0AttributeName) : i.morphTargets === !0 && s.bindAttribLocation(v, 0, "position"), s.linkProgram(v);
  function w(N) {
    if (r.debug.checkShaderErrors) {
      const L = s.getProgramInfoLog(v).trim(), F = s.getShaderInfoLog(T).trim(), M = s.getShaderInfoLog(S).trim();
      let P = !0, O = !0;
      if (s.getProgramParameter(v, s.LINK_STATUS) === !1)
        if (P = !1, typeof r.debug.onShaderError == "function")
          r.debug.onShaderError(s, v, T, S);
        else {
          const V = aw(s, T, "vertex"), B = aw(s, S, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(v, s.VALIDATE_STATUS) + `

Material Name: ` + N.name + `
Material Type: ` + N.type + `

Program Info Log: ` + L + `
` + V + `
` + B
          );
        }
      else L !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", L) : (F === "" || M === "") && (O = !1);
      O && (N.diagnostics = {
        runnable: P,
        programLog: L,
        vertexShader: {
          log: F,
          prefix: y
        },
        fragmentShader: {
          log: M,
          prefix: g
        }
      });
    }
    s.deleteShader(T), s.deleteShader(S), C = new Qf(s, v), E = kj(s, v);
  }
  let C;
  this.getUniforms = function() {
    return C === void 0 && w(this), C;
  };
  let E;
  this.getAttributes = function() {
    return E === void 0 && w(this), E;
  };
  let A = i.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return A === !1 && (A = s.getProgramParameter(v, Mj)), A;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), s.deleteProgram(v), this.program = void 0;
  }, this.type = i.shaderType, this.name = i.shaderName, this.id = Aj++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = T, this.fragmentShader = S, this;
}
let Xj = 0;
class Yj {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const i = e.vertexShader, n = e.fragmentShader, s = this._getShaderStage(i), a = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e);
    return o.has(s) === !1 && (o.add(s), s.usedTimes++), o.has(a) === !1 && (o.add(a), a.usedTimes++), this;
  }
  remove(e) {
    const i = this.materialCache.get(e);
    for (const n of i)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const i = this.materialCache;
    let n = i.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), i.set(e, n)), n;
  }
  _getShaderStage(e) {
    const i = this.shaderCache;
    let n = i.get(e);
    return n === void 0 && (n = new $j(e), i.set(e, n)), n;
  }
}
class $j {
  constructor(e) {
    this.id = Xj++, this.code = e, this.usedTimes = 0;
  }
}
function Kj(r, e, i, n, s, a, o) {
  const l = new P_(), u = new Yj(), c = /* @__PURE__ */ new Set(), h = [], d = s.logarithmicDepthBuffer, p = s.vertexTextures;
  let f = s.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function v(E) {
    return c.add(E), E === 0 ? "uv" : `uv${E}`;
  }
  function y(E, A, N, L, F) {
    const M = L.fog, P = F.geometry, O = E.isMeshStandardMaterial ? L.environment : null, V = (E.isMeshStandardMaterial ? i : e).get(E.envMap || O), B = V && V.mapping === gg ? V.image.height : null, H = m[E.type];
    E.precision !== null && (f = s.getMaxPrecision(E.precision), f !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", f, "instead."));
    const U = P.morphAttributes.position || P.morphAttributes.normal || P.morphAttributes.color, j = U !== void 0 ? U.length : 0;
    let Q = 0;
    P.morphAttributes.position !== void 0 && (Q = 1), P.morphAttributes.normal !== void 0 && (Q = 2), P.morphAttributes.color !== void 0 && (Q = 3);
    let q, G, Y, ae;
    if (H) {
      const Bt = ms[H];
      q = Bt.vertexShader, G = Bt.fragmentShader;
    } else
      q = E.vertexShader, G = E.fragmentShader, u.update(E), Y = u.getVertexShaderID(E), ae = u.getFragmentShaderID(E);
    const ue = r.getRenderTarget(), ge = r.state.buffers.depth.getReversed(), we = F.isInstancedMesh === !0, Ne = F.isBatchedMesh === !0, lt = !!E.map, be = !!E.matcap, vt = !!V, Z = !!E.aoMap, Vt = !!E.lightMap, ct = !!E.bumpMap, xt = !!E.normalMap, it = !!E.displacementMap, Dt = !!E.emissiveMap, at = !!E.metalnessMap, z = !!E.roughnessMap, D = E.anisotropy > 0, le = E.clearcoat > 0, _e = E.dispersion > 0, Ae = E.iridescence > 0, xe = E.sheen > 0, Qe = E.transmission > 0, ze = D && !!E.anisotropyMap, je = le && !!E.clearcoatMap, St = le && !!E.clearcoatNormalMap, Pe = le && !!E.clearcoatRoughnessMap, Ye = Ae && !!E.iridescenceMap, ut = Ae && !!E.iridescenceThicknessMap, Fe = xe && !!E.sheenColorMap, Xe = xe && !!E.sheenRoughnessMap, Ct = !!E.specularMap, mt = !!E.specularColorMap, kt = !!E.specularIntensityMap, J = Qe && !!E.transmissionMap, Oe = Qe && !!E.thicknessMap, de = !!E.gradientMap, Se = !!E.alphaMap, Ve = E.alphaTest > 0, Ue = !!E.alphaHash, Rt = !!E.extensions;
    let si = co;
    E.toneMapped && (ue === null || ue.isXRRenderTarget === !0) && (si = r.toneMapping);
    const _i = {
      shaderID: H,
      shaderType: E.type,
      shaderName: E.name,
      vertexShader: q,
      fragmentShader: G,
      defines: E.defines,
      customVertexShaderID: Y,
      customFragmentShaderID: ae,
      isRawShaderMaterial: E.isRawShaderMaterial === !0,
      glslVersion: E.glslVersion,
      precision: f,
      batching: Ne,
      batchingColor: Ne && F._colorsTexture !== null,
      instancing: we,
      instancingColor: we && F.instanceColor !== null,
      instancingMorph: we && F.morphTexture !== null,
      supportsVertexTextures: p,
      outputColorSpace: ue === null ? r.outputColorSpace : ue.isXRRenderTarget === !0 ? ue.texture.colorSpace : kc,
      alphaToCoverage: !!E.alphaToCoverage,
      map: lt,
      matcap: be,
      envMap: vt,
      envMapMode: vt && V.mapping,
      envMapCubeUVHeight: B,
      aoMap: Z,
      lightMap: Vt,
      bumpMap: ct,
      normalMap: xt,
      displacementMap: p && it,
      emissiveMap: Dt,
      normalMapObjectSpace: xt && E.normalMapType === HF,
      normalMapTangentSpace: xt && E.normalMapType === qC,
      metalnessMap: at,
      roughnessMap: z,
      anisotropy: D,
      anisotropyMap: ze,
      clearcoat: le,
      clearcoatMap: je,
      clearcoatNormalMap: St,
      clearcoatRoughnessMap: Pe,
      dispersion: _e,
      iridescence: Ae,
      iridescenceMap: Ye,
      iridescenceThicknessMap: ut,
      sheen: xe,
      sheenColorMap: Fe,
      sheenRoughnessMap: Xe,
      specularMap: Ct,
      specularColorMap: mt,
      specularIntensityMap: kt,
      transmission: Qe,
      transmissionMap: J,
      thicknessMap: Oe,
      gradientMap: de,
      opaque: E.transparent === !1 && E.blending === Hu && E.alphaToCoverage === !1,
      alphaMap: Se,
      alphaTest: Ve,
      alphaHash: Ue,
      combine: E.combine,
      //
      mapUv: lt && v(E.map.channel),
      aoMapUv: Z && v(E.aoMap.channel),
      lightMapUv: Vt && v(E.lightMap.channel),
      bumpMapUv: ct && v(E.bumpMap.channel),
      normalMapUv: xt && v(E.normalMap.channel),
      displacementMapUv: it && v(E.displacementMap.channel),
      emissiveMapUv: Dt && v(E.emissiveMap.channel),
      metalnessMapUv: at && v(E.metalnessMap.channel),
      roughnessMapUv: z && v(E.roughnessMap.channel),
      anisotropyMapUv: ze && v(E.anisotropyMap.channel),
      clearcoatMapUv: je && v(E.clearcoatMap.channel),
      clearcoatNormalMapUv: St && v(E.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Pe && v(E.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Ye && v(E.iridescenceMap.channel),
      iridescenceThicknessMapUv: ut && v(E.iridescenceThicknessMap.channel),
      sheenColorMapUv: Fe && v(E.sheenColorMap.channel),
      sheenRoughnessMapUv: Xe && v(E.sheenRoughnessMap.channel),
      specularMapUv: Ct && v(E.specularMap.channel),
      specularColorMapUv: mt && v(E.specularColorMap.channel),
      specularIntensityMapUv: kt && v(E.specularIntensityMap.channel),
      transmissionMapUv: J && v(E.transmissionMap.channel),
      thicknessMapUv: Oe && v(E.thicknessMap.channel),
      alphaMapUv: Se && v(E.alphaMap.channel),
      //
      vertexTangents: !!P.attributes.tangent && (xt || D),
      vertexColors: E.vertexColors,
      vertexAlphas: E.vertexColors === !0 && !!P.attributes.color && P.attributes.color.itemSize === 4,
      pointsUvs: F.isPoints === !0 && !!P.attributes.uv && (lt || Se),
      fog: !!M,
      useFog: E.fog === !0,
      fogExp2: !!M && M.isFogExp2,
      flatShading: E.flatShading === !0,
      sizeAttenuation: E.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      reverseDepthBuffer: ge,
      skinning: F.isSkinnedMesh === !0,
      morphTargets: P.morphAttributes.position !== void 0,
      morphNormals: P.morphAttributes.normal !== void 0,
      morphColors: P.morphAttributes.color !== void 0,
      morphTargetsCount: j,
      morphTextureStride: Q,
      numDirLights: A.directional.length,
      numPointLights: A.point.length,
      numSpotLights: A.spot.length,
      numSpotLightMaps: A.spotLightMap.length,
      numRectAreaLights: A.rectArea.length,
      numHemiLights: A.hemi.length,
      numDirLightShadows: A.directionalShadowMap.length,
      numPointLightShadows: A.pointShadowMap.length,
      numSpotLightShadows: A.spotShadowMap.length,
      numSpotLightShadowsWithMaps: A.numSpotLightShadowsWithMaps,
      numLightProbes: A.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: E.dithering,
      shadowMapEnabled: r.shadowMap.enabled && N.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: si,
      decodeVideoTexture: lt && E.map.isVideoTexture === !0 && Gt.getTransfer(E.map.colorSpace) === ei,
      decodeVideoTextureEmissive: Dt && E.emissiveMap.isVideoTexture === !0 && Gt.getTransfer(E.emissiveMap.colorSpace) === ei,
      premultipliedAlpha: E.premultipliedAlpha,
      doubleSided: E.side === ea,
      flipSided: E.side === Mr,
      useDepthPacking: E.depthPacking >= 0,
      depthPacking: E.depthPacking || 0,
      index0AttributeName: E.index0AttributeName,
      extensionClipCullDistance: Rt && E.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (Rt && E.extensions.multiDraw === !0 || Ne) && n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: E.customProgramCacheKey()
    };
    return _i.vertexUv1s = c.has(1), _i.vertexUv2s = c.has(2), _i.vertexUv3s = c.has(3), c.clear(), _i;
  }
  function g(E) {
    const A = [];
    if (E.shaderID ? A.push(E.shaderID) : (A.push(E.customVertexShaderID), A.push(E.customFragmentShaderID)), E.defines !== void 0)
      for (const N in E.defines)
        A.push(N), A.push(E.defines[N]);
    return E.isRawShaderMaterial === !1 && (_(A, E), x(A, E), A.push(r.outputColorSpace)), A.push(E.customProgramCacheKey), A.join();
  }
  function _(E, A) {
    E.push(A.precision), E.push(A.outputColorSpace), E.push(A.envMapMode), E.push(A.envMapCubeUVHeight), E.push(A.mapUv), E.push(A.alphaMapUv), E.push(A.lightMapUv), E.push(A.aoMapUv), E.push(A.bumpMapUv), E.push(A.normalMapUv), E.push(A.displacementMapUv), E.push(A.emissiveMapUv), E.push(A.metalnessMapUv), E.push(A.roughnessMapUv), E.push(A.anisotropyMapUv), E.push(A.clearcoatMapUv), E.push(A.clearcoatNormalMapUv), E.push(A.clearcoatRoughnessMapUv), E.push(A.iridescenceMapUv), E.push(A.iridescenceThicknessMapUv), E.push(A.sheenColorMapUv), E.push(A.sheenRoughnessMapUv), E.push(A.specularMapUv), E.push(A.specularColorMapUv), E.push(A.specularIntensityMapUv), E.push(A.transmissionMapUv), E.push(A.thicknessMapUv), E.push(A.combine), E.push(A.fogExp2), E.push(A.sizeAttenuation), E.push(A.morphTargetsCount), E.push(A.morphAttributeCount), E.push(A.numDirLights), E.push(A.numPointLights), E.push(A.numSpotLights), E.push(A.numSpotLightMaps), E.push(A.numHemiLights), E.push(A.numRectAreaLights), E.push(A.numDirLightShadows), E.push(A.numPointLightShadows), E.push(A.numSpotLightShadows), E.push(A.numSpotLightShadowsWithMaps), E.push(A.numLightProbes), E.push(A.shadowMapType), E.push(A.toneMapping), E.push(A.numClippingPlanes), E.push(A.numClipIntersection), E.push(A.depthPacking);
  }
  function x(E, A) {
    l.disableAll(), A.supportsVertexTextures && l.enable(0), A.instancing && l.enable(1), A.instancingColor && l.enable(2), A.instancingMorph && l.enable(3), A.matcap && l.enable(4), A.envMap && l.enable(5), A.normalMapObjectSpace && l.enable(6), A.normalMapTangentSpace && l.enable(7), A.clearcoat && l.enable(8), A.iridescence && l.enable(9), A.alphaTest && l.enable(10), A.vertexColors && l.enable(11), A.vertexAlphas && l.enable(12), A.vertexUv1s && l.enable(13), A.vertexUv2s && l.enable(14), A.vertexUv3s && l.enable(15), A.vertexTangents && l.enable(16), A.anisotropy && l.enable(17), A.alphaHash && l.enable(18), A.batching && l.enable(19), A.dispersion && l.enable(20), A.batchingColor && l.enable(21), E.push(l.mask), l.disableAll(), A.fog && l.enable(0), A.useFog && l.enable(1), A.flatShading && l.enable(2), A.logarithmicDepthBuffer && l.enable(3), A.reverseDepthBuffer && l.enable(4), A.skinning && l.enable(5), A.morphTargets && l.enable(6), A.morphNormals && l.enable(7), A.morphColors && l.enable(8), A.premultipliedAlpha && l.enable(9), A.shadowMapEnabled && l.enable(10), A.doubleSided && l.enable(11), A.flipSided && l.enable(12), A.useDepthPacking && l.enable(13), A.dithering && l.enable(14), A.transmission && l.enable(15), A.sheen && l.enable(16), A.opaque && l.enable(17), A.pointsUvs && l.enable(18), A.decodeVideoTexture && l.enable(19), A.decodeVideoTextureEmissive && l.enable(20), A.alphaToCoverage && l.enable(21), E.push(l.mask);
  }
  function b(E) {
    const A = m[E.type];
    let N;
    if (A) {
      const L = ms[A];
      N = lR.clone(L.uniforms);
    } else
      N = E.uniforms;
    return N;
  }
  function T(E, A) {
    let N;
    for (let L = 0, F = h.length; L < F; L++) {
      const M = h[L];
      if (M.cacheKey === A) {
        N = M, ++N.usedTimes;
        break;
      }
    }
    return N === void 0 && (N = new qj(r, A, E, a), h.push(N)), N;
  }
  function S(E) {
    if (--E.usedTimes === 0) {
      const A = h.indexOf(E);
      h[A] = h[h.length - 1], h.pop(), E.destroy();
    }
  }
  function w(E) {
    u.remove(E);
  }
  function C() {
    u.dispose();
  }
  return {
    getParameters: y,
    getProgramCacheKey: g,
    getUniforms: b,
    acquireProgram: T,
    releaseProgram: S,
    releaseShaderCache: w,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: h,
    dispose: C
  };
}
function Qj() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(o) {
    return r.has(o);
  }
  function i(o) {
    let l = r.get(o);
    return l === void 0 && (l = {}, r.set(o, l)), l;
  }
  function n(o) {
    r.delete(o);
  }
  function s(o, l, u) {
    r.get(o)[l] = u;
  }
  function a() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: i,
    remove: n,
    update: s,
    dispose: a
  };
}
function Zj(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
}
function hw(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
}
function dw() {
  const r = [];
  let e = 0;
  const i = [], n = [], s = [];
  function a() {
    e = 0, i.length = 0, n.length = 0, s.length = 0;
  }
  function o(d, p, f, m, v, y) {
    let g = r[e];
    return g === void 0 ? (g = {
      id: d.id,
      object: d,
      geometry: p,
      material: f,
      groupOrder: m,
      renderOrder: d.renderOrder,
      z: v,
      group: y
    }, r[e] = g) : (g.id = d.id, g.object = d, g.geometry = p, g.material = f, g.groupOrder = m, g.renderOrder = d.renderOrder, g.z = v, g.group = y), e++, g;
  }
  function l(d, p, f, m, v, y) {
    const g = o(d, p, f, m, v, y);
    f.transmission > 0 ? n.push(g) : f.transparent === !0 ? s.push(g) : i.push(g);
  }
  function u(d, p, f, m, v, y) {
    const g = o(d, p, f, m, v, y);
    f.transmission > 0 ? n.unshift(g) : f.transparent === !0 ? s.unshift(g) : i.unshift(g);
  }
  function c(d, p) {
    i.length > 1 && i.sort(d || Zj), n.length > 1 && n.sort(p || hw), s.length > 1 && s.sort(p || hw);
  }
  function h() {
    for (let d = e, p = r.length; d < p; d++) {
      const f = r[d];
      if (f.id === null) break;
      f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
    }
  }
  return {
    opaque: i,
    transmissive: n,
    transparent: s,
    init: a,
    push: l,
    unshift: u,
    finish: h,
    sort: c
  };
}
function Jj() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(n, s) {
    const a = r.get(n);
    let o;
    return a === void 0 ? (o = new dw(), r.set(n, [o])) : s >= a.length ? (o = new dw(), a.push(o)) : o = a[s], o;
  }
  function i() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: i
  };
}
function e6() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let i;
      switch (e.type) {
        case "DirectionalLight":
          i = {
            direction: new X(),
            color: new Ft()
          };
          break;
        case "SpotLight":
          i = {
            position: new X(),
            direction: new X(),
            color: new Ft(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          i = {
            position: new X(),
            color: new Ft(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          i = {
            direction: new X(),
            skyColor: new Ft(),
            groundColor: new Ft()
          };
          break;
        case "RectAreaLight":
          i = {
            color: new Ft(),
            position: new X(),
            halfWidth: new X(),
            halfHeight: new X()
          };
          break;
      }
      return r[e.id] = i, i;
    }
  };
}
function t6() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let i;
      switch (e.type) {
        case "DirectionalLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Le()
          };
          break;
        case "SpotLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Le()
          };
          break;
        case "PointLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Le(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return r[e.id] = i, i;
    }
  };
}
let i6 = 0;
function r6(r, e) {
  return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0);
}
function n6(r) {
  const e = new e6(), i = t6(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let c = 0; c < 9; c++) n.probe.push(new X());
  const s = new X(), a = new ui(), o = new ui();
  function l(c) {
    let h = 0, d = 0, p = 0;
    for (let E = 0; E < 9; E++) n.probe[E].set(0, 0, 0);
    let f = 0, m = 0, v = 0, y = 0, g = 0, _ = 0, x = 0, b = 0, T = 0, S = 0, w = 0;
    c.sort(r6);
    for (let E = 0, A = c.length; E < A; E++) {
      const N = c[E], L = N.color, F = N.intensity, M = N.distance, P = N.shadow && N.shadow.map ? N.shadow.map.texture : null;
      if (N.isAmbientLight)
        h += L.r * F, d += L.g * F, p += L.b * F;
      else if (N.isLightProbe) {
        for (let O = 0; O < 9; O++)
          n.probe[O].addScaledVector(N.sh.coefficients[O], F);
        w++;
      } else if (N.isDirectionalLight) {
        const O = e.get(N);
        if (O.color.copy(N.color).multiplyScalar(N.intensity), N.castShadow) {
          const V = N.shadow, B = i.get(N);
          B.shadowIntensity = V.intensity, B.shadowBias = V.bias, B.shadowNormalBias = V.normalBias, B.shadowRadius = V.radius, B.shadowMapSize = V.mapSize, n.directionalShadow[f] = B, n.directionalShadowMap[f] = P, n.directionalShadowMatrix[f] = N.shadow.matrix, _++;
        }
        n.directional[f] = O, f++;
      } else if (N.isSpotLight) {
        const O = e.get(N);
        O.position.setFromMatrixPosition(N.matrixWorld), O.color.copy(L).multiplyScalar(F), O.distance = M, O.coneCos = Math.cos(N.angle), O.penumbraCos = Math.cos(N.angle * (1 - N.penumbra)), O.decay = N.decay, n.spot[v] = O;
        const V = N.shadow;
        if (N.map && (n.spotLightMap[T] = N.map, T++, V.updateMatrices(N), N.castShadow && S++), n.spotLightMatrix[v] = V.matrix, N.castShadow) {
          const B = i.get(N);
          B.shadowIntensity = V.intensity, B.shadowBias = V.bias, B.shadowNormalBias = V.normalBias, B.shadowRadius = V.radius, B.shadowMapSize = V.mapSize, n.spotShadow[v] = B, n.spotShadowMap[v] = P, b++;
        }
        v++;
      } else if (N.isRectAreaLight) {
        const O = e.get(N);
        O.color.copy(L).multiplyScalar(F), O.halfWidth.set(N.width * 0.5, 0, 0), O.halfHeight.set(0, N.height * 0.5, 0), n.rectArea[y] = O, y++;
      } else if (N.isPointLight) {
        const O = e.get(N);
        if (O.color.copy(N.color).multiplyScalar(N.intensity), O.distance = N.distance, O.decay = N.decay, N.castShadow) {
          const V = N.shadow, B = i.get(N);
          B.shadowIntensity = V.intensity, B.shadowBias = V.bias, B.shadowNormalBias = V.normalBias, B.shadowRadius = V.radius, B.shadowMapSize = V.mapSize, B.shadowCameraNear = V.camera.near, B.shadowCameraFar = V.camera.far, n.pointShadow[m] = B, n.pointShadowMap[m] = P, n.pointShadowMatrix[m] = N.shadow.matrix, x++;
        }
        n.point[m] = O, m++;
      } else if (N.isHemisphereLight) {
        const O = e.get(N);
        O.skyColor.copy(N.color).multiplyScalar(F), O.groundColor.copy(N.groundColor).multiplyScalar(F), n.hemi[g] = O, g++;
      }
    }
    y > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Ge.LTC_FLOAT_1, n.rectAreaLTC2 = Ge.LTC_FLOAT_2) : (n.rectAreaLTC1 = Ge.LTC_HALF_1, n.rectAreaLTC2 = Ge.LTC_HALF_2)), n.ambient[0] = h, n.ambient[1] = d, n.ambient[2] = p;
    const C = n.hash;
    (C.directionalLength !== f || C.pointLength !== m || C.spotLength !== v || C.rectAreaLength !== y || C.hemiLength !== g || C.numDirectionalShadows !== _ || C.numPointShadows !== x || C.numSpotShadows !== b || C.numSpotMaps !== T || C.numLightProbes !== w) && (n.directional.length = f, n.spot.length = v, n.rectArea.length = y, n.point.length = m, n.hemi.length = g, n.directionalShadow.length = _, n.directionalShadowMap.length = _, n.pointShadow.length = x, n.pointShadowMap.length = x, n.spotShadow.length = b, n.spotShadowMap.length = b, n.directionalShadowMatrix.length = _, n.pointShadowMatrix.length = x, n.spotLightMatrix.length = b + T - S, n.spotLightMap.length = T, n.numSpotLightShadowsWithMaps = S, n.numLightProbes = w, C.directionalLength = f, C.pointLength = m, C.spotLength = v, C.rectAreaLength = y, C.hemiLength = g, C.numDirectionalShadows = _, C.numPointShadows = x, C.numSpotShadows = b, C.numSpotMaps = T, C.numLightProbes = w, n.version = i6++);
  }
  function u(c, h) {
    let d = 0, p = 0, f = 0, m = 0, v = 0;
    const y = h.matrixWorldInverse;
    for (let g = 0, _ = c.length; g < _; g++) {
      const x = c[g];
      if (x.isDirectionalLight) {
        const b = n.directional[d];
        b.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(y), d++;
      } else if (x.isSpotLight) {
        const b = n.spot[f];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(y), b.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(y), f++;
      } else if (x.isRectAreaLight) {
        const b = n.rectArea[m];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(y), o.identity(), a.copy(x.matrixWorld), a.premultiply(y), o.extractRotation(a), b.halfWidth.set(x.width * 0.5, 0, 0), b.halfHeight.set(0, x.height * 0.5, 0), b.halfWidth.applyMatrix4(o), b.halfHeight.applyMatrix4(o), m++;
      } else if (x.isPointLight) {
        const b = n.point[p];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(y), p++;
      } else if (x.isHemisphereLight) {
        const b = n.hemi[v];
        b.direction.setFromMatrixPosition(x.matrixWorld), b.direction.transformDirection(y), v++;
      }
    }
  }
  return {
    setup: l,
    setupView: u,
    state: n
  };
}
function pw(r) {
  const e = new n6(r), i = [], n = [];
  function s(h) {
    c.camera = h, i.length = 0, n.length = 0;
  }
  function a(h) {
    i.push(h);
  }
  function o(h) {
    n.push(h);
  }
  function l() {
    e.setup(i);
  }
  function u(h) {
    e.setupView(i, h);
  }
  const c = {
    lightsArray: i,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: s,
    state: c,
    setupLights: l,
    setupLightsView: u,
    pushLight: a,
    pushShadow: o
  };
}
function s6(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function i(s, a = 0) {
    const o = e.get(s);
    let l;
    return o === void 0 ? (l = new pw(r), e.set(s, [l])) : a >= o.length ? (l = new pw(r), o.push(l)) : l = o[a], l;
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: n
  };
}
class a6 extends Ol {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.depthPacking = VF, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class o6 extends Ol {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const l6 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, u6 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function c6(r, e, i) {
  let n = new I_();
  const s = new Le(), a = new Le(), o = new Fi(), l = new a6({ depthPacking: GF }), u = new o6(), c = {}, h = i.maxTextureSize, d = { [yo]: Mr, [Mr]: yo, [ea]: ea }, p = new Ss({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Le() },
      radius: { value: 4 }
    },
    vertexShader: l6,
    fragmentShader: u6
  }), f = p.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new pn();
  m.setAttribute(
    "position",
    new wn(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const v = new Ur(m, p), y = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = DC;
  let g = this.type;
  this.render = function(S, w, C) {
    if (y.enabled === !1 || y.autoUpdate === !1 && y.needsUpdate === !1 || S.length === 0) return;
    const E = r.getRenderTarget(), A = r.getActiveCubeFace(), N = r.getActiveMipmapLevel(), L = r.state;
    L.setBlending(ha), L.buffers.color.setClear(1, 1, 1, 1), L.buffers.depth.setTest(!0), L.setScissorTest(!1);
    const F = g !== qs && this.type === qs, M = g === qs && this.type !== qs;
    for (let P = 0, O = S.length; P < O; P++) {
      const V = S[P], B = V.shadow;
      if (B === void 0) {
        console.warn("THREE.WebGLShadowMap:", V, "has no shadow.");
        continue;
      }
      if (B.autoUpdate === !1 && B.needsUpdate === !1) continue;
      s.copy(B.mapSize);
      const H = B.getFrameExtents();
      if (s.multiply(H), a.copy(B.mapSize), (s.x > h || s.y > h) && (s.x > h && (a.x = Math.floor(h / H.x), s.x = a.x * H.x, B.mapSize.x = a.x), s.y > h && (a.y = Math.floor(h / H.y), s.y = a.y * H.y, B.mapSize.y = a.y)), B.map === null || F === !0 || M === !0) {
        const j = this.type !== qs ? { minFilter: Jn, magFilter: Jn } : {};
        B.map !== null && B.map.dispose(), B.map = new vo(s.x, s.y, j), B.map.texture.name = V.name + ".shadowMap", B.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(B.map), r.clear();
      const U = B.getViewportCount();
      for (let j = 0; j < U; j++) {
        const Q = B.getViewport(j);
        o.set(
          a.x * Q.x,
          a.y * Q.y,
          a.x * Q.z,
          a.y * Q.w
        ), L.viewport(o), B.updateMatrices(V, j), n = B.getFrustum(), b(w, C, B.camera, V, this.type);
      }
      B.isPointLightShadow !== !0 && this.type === qs && _(B, C), B.needsUpdate = !1;
    }
    g = this.type, y.needsUpdate = !1, r.setRenderTarget(E, A, N);
  };
  function _(S, w) {
    const C = e.update(v);
    p.defines.VSM_SAMPLES !== S.blurSamples && (p.defines.VSM_SAMPLES = S.blurSamples, f.defines.VSM_SAMPLES = S.blurSamples, p.needsUpdate = !0, f.needsUpdate = !0), S.mapPass === null && (S.mapPass = new vo(s.x, s.y)), p.uniforms.shadow_pass.value = S.map.texture, p.uniforms.resolution.value = S.mapSize, p.uniforms.radius.value = S.radius, r.setRenderTarget(S.mapPass), r.clear(), r.renderBufferDirect(w, null, C, p, v, null), f.uniforms.shadow_pass.value = S.mapPass.texture, f.uniforms.resolution.value = S.mapSize, f.uniforms.radius.value = S.radius, r.setRenderTarget(S.map), r.clear(), r.renderBufferDirect(w, null, C, f, v, null);
  }
  function x(S, w, C, E) {
    let A = null;
    const N = C.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
    if (N !== void 0)
      A = N;
    else if (A = C.isPointLight === !0 ? u : l, r.localClippingEnabled && w.clipShadows === !0 && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
      const L = A.uuid, F = w.uuid;
      let M = c[L];
      M === void 0 && (M = {}, c[L] = M);
      let P = M[F];
      P === void 0 && (P = A.clone(), M[F] = P, w.addEventListener("dispose", T)), A = P;
    }
    if (A.visible = w.visible, A.wireframe = w.wireframe, E === qs ? A.side = w.shadowSide !== null ? w.shadowSide : w.side : A.side = w.shadowSide !== null ? w.shadowSide : d[w.side], A.alphaMap = w.alphaMap, A.alphaTest = w.alphaTest, A.map = w.map, A.clipShadows = w.clipShadows, A.clippingPlanes = w.clippingPlanes, A.clipIntersection = w.clipIntersection, A.displacementMap = w.displacementMap, A.displacementScale = w.displacementScale, A.displacementBias = w.displacementBias, A.wireframeLinewidth = w.wireframeLinewidth, A.linewidth = w.linewidth, C.isPointLight === !0 && A.isMeshDistanceMaterial === !0) {
      const L = r.properties.get(A);
      L.light = C;
    }
    return A;
  }
  function b(S, w, C, E, A) {
    if (S.visible === !1) return;
    if (S.layers.test(w.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && A === qs) && (!S.frustumCulled || n.intersectsObject(S))) {
      S.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, S.matrixWorld);
      const L = e.update(S), F = S.material;
      if (Array.isArray(F)) {
        const M = L.groups;
        for (let P = 0, O = M.length; P < O; P++) {
          const V = M[P], B = F[V.materialIndex];
          if (B && B.visible) {
            const H = x(S, B, E, A);
            S.onBeforeShadow(r, S, w, C, L, H, V), r.renderBufferDirect(C, null, L, H, S, V), S.onAfterShadow(r, S, w, C, L, H, V);
          }
        }
      } else if (F.visible) {
        const M = x(S, F, E, A);
        S.onBeforeShadow(r, S, w, C, L, M, null), r.renderBufferDirect(C, null, L, M, S, null), S.onAfterShadow(r, S, w, C, L, M, null);
      }
    }
    const N = S.children;
    for (let L = 0, F = N.length; L < F; L++)
      b(N[L], w, C, E, A);
  }
  function T(S) {
    S.target.removeEventListener("dispose", T);
    for (const w in c) {
      const C = c[w], E = S.target.uuid;
      E in C && (C[E].dispose(), delete C[E]);
    }
  }
}
const h6 = {
  [Kv]: Qv,
  [Zv]: tb,
  [Jv]: ib,
  [dc]: eb,
  [Qv]: Kv,
  [tb]: Zv,
  [ib]: Jv,
  [eb]: dc
};
function d6(r, e) {
  function i() {
    let J = !1;
    const Oe = new Fi();
    let de = null;
    const Se = new Fi(0, 0, 0, 0);
    return {
      setMask: function(Ve) {
        de !== Ve && !J && (r.colorMask(Ve, Ve, Ve, Ve), de = Ve);
      },
      setLocked: function(Ve) {
        J = Ve;
      },
      setClear: function(Ve, Ue, Rt, si, _i) {
        _i === !0 && (Ve *= si, Ue *= si, Rt *= si), Oe.set(Ve, Ue, Rt, si), Se.equals(Oe) === !1 && (r.clearColor(Ve, Ue, Rt, si), Se.copy(Oe));
      },
      reset: function() {
        J = !1, de = null, Se.set(-1, 0, 0, 0);
      }
    };
  }
  function n() {
    let J = !1, Oe = !1, de = null, Se = null, Ve = null;
    return {
      setReversed: function(Ue) {
        if (Oe !== Ue) {
          const Rt = e.get("EXT_clip_control");
          Oe ? Rt.clipControlEXT(Rt.LOWER_LEFT_EXT, Rt.ZERO_TO_ONE_EXT) : Rt.clipControlEXT(Rt.LOWER_LEFT_EXT, Rt.NEGATIVE_ONE_TO_ONE_EXT);
          const si = Ve;
          Ve = null, this.setClear(si);
        }
        Oe = Ue;
      },
      getReversed: function() {
        return Oe;
      },
      setTest: function(Ue) {
        Ue ? ue(r.DEPTH_TEST) : ge(r.DEPTH_TEST);
      },
      setMask: function(Ue) {
        de !== Ue && !J && (r.depthMask(Ue), de = Ue);
      },
      setFunc: function(Ue) {
        if (Oe && (Ue = h6[Ue]), Se !== Ue) {
          switch (Ue) {
            case Kv:
              r.depthFunc(r.NEVER);
              break;
            case Qv:
              r.depthFunc(r.ALWAYS);
              break;
            case Zv:
              r.depthFunc(r.LESS);
              break;
            case dc:
              r.depthFunc(r.LEQUAL);
              break;
            case Jv:
              r.depthFunc(r.EQUAL);
              break;
            case eb:
              r.depthFunc(r.GEQUAL);
              break;
            case tb:
              r.depthFunc(r.GREATER);
              break;
            case ib:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          Se = Ue;
        }
      },
      setLocked: function(Ue) {
        J = Ue;
      },
      setClear: function(Ue) {
        Ve !== Ue && (Oe && (Ue = 1 - Ue), r.clearDepth(Ue), Ve = Ue);
      },
      reset: function() {
        J = !1, de = null, Se = null, Ve = null, Oe = !1;
      }
    };
  }
  function s() {
    let J = !1, Oe = null, de = null, Se = null, Ve = null, Ue = null, Rt = null, si = null, _i = null;
    return {
      setTest: function(Bt) {
        J || (Bt ? ue(r.STENCIL_TEST) : ge(r.STENCIL_TEST));
      },
      setMask: function(Bt) {
        Oe !== Bt && !J && (r.stencilMask(Bt), Oe = Bt);
      },
      setFunc: function(Bt, yr, Kr) {
        (de !== Bt || Se !== yr || Ve !== Kr) && (r.stencilFunc(Bt, yr, Kr), de = Bt, Se = yr, Ve = Kr);
      },
      setOp: function(Bt, yr, Kr) {
        (Ue !== Bt || Rt !== yr || si !== Kr) && (r.stencilOp(Bt, yr, Kr), Ue = Bt, Rt = yr, si = Kr);
      },
      setLocked: function(Bt) {
        J = Bt;
      },
      setClear: function(Bt) {
        _i !== Bt && (r.clearStencil(Bt), _i = Bt);
      },
      reset: function() {
        J = !1, Oe = null, de = null, Se = null, Ve = null, Ue = null, Rt = null, si = null, _i = null;
      }
    };
  }
  const a = new i(), o = new n(), l = new s(), u = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
  let h = {}, d = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, v = !1, y = null, g = null, _ = null, x = null, b = null, T = null, S = null, w = new Ft(0, 0, 0), C = 0, E = !1, A = null, N = null, L = null, F = null, M = null;
  const P = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let O = !1, V = 0;
  const B = r.getParameter(r.VERSION);
  B.indexOf("WebGL") !== -1 ? (V = parseFloat(/^WebGL (\d)/.exec(B)[1]), O = V >= 1) : B.indexOf("OpenGL ES") !== -1 && (V = parseFloat(/^OpenGL ES (\d)/.exec(B)[1]), O = V >= 2);
  let H = null, U = {};
  const j = r.getParameter(r.SCISSOR_BOX), Q = r.getParameter(r.VIEWPORT), q = new Fi().fromArray(j), G = new Fi().fromArray(Q);
  function Y(J, Oe, de, Se) {
    const Ve = new Uint8Array(4), Ue = r.createTexture();
    r.bindTexture(J, Ue), r.texParameteri(J, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(J, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let Rt = 0; Rt < de; Rt++)
      J === r.TEXTURE_3D || J === r.TEXTURE_2D_ARRAY ? r.texImage3D(Oe, 0, r.RGBA, 1, 1, Se, 0, r.RGBA, r.UNSIGNED_BYTE, Ve) : r.texImage2D(Oe + Rt, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, Ve);
    return Ue;
  }
  const ae = {};
  ae[r.TEXTURE_2D] = Y(r.TEXTURE_2D, r.TEXTURE_2D, 1), ae[r.TEXTURE_CUBE_MAP] = Y(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ae[r.TEXTURE_2D_ARRAY] = Y(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), ae[r.TEXTURE_3D] = Y(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), a.setClear(0, 0, 0, 1), o.setClear(1), l.setClear(0), ue(r.DEPTH_TEST), o.setFunc(dc), ct(!1), xt(y1), ue(r.CULL_FACE), Z(ha);
  function ue(J) {
    h[J] !== !0 && (r.enable(J), h[J] = !0);
  }
  function ge(J) {
    h[J] !== !1 && (r.disable(J), h[J] = !1);
  }
  function we(J, Oe) {
    return d[J] !== Oe ? (r.bindFramebuffer(J, Oe), d[J] = Oe, J === r.DRAW_FRAMEBUFFER && (d[r.FRAMEBUFFER] = Oe), J === r.FRAMEBUFFER && (d[r.DRAW_FRAMEBUFFER] = Oe), !0) : !1;
  }
  function Ne(J, Oe) {
    let de = f, Se = !1;
    if (J) {
      de = p.get(Oe), de === void 0 && (de = [], p.set(Oe, de));
      const Ve = J.textures;
      if (de.length !== Ve.length || de[0] !== r.COLOR_ATTACHMENT0) {
        for (let Ue = 0, Rt = Ve.length; Ue < Rt; Ue++)
          de[Ue] = r.COLOR_ATTACHMENT0 + Ue;
        de.length = Ve.length, Se = !0;
      }
    } else
      de[0] !== r.BACK && (de[0] = r.BACK, Se = !0);
    Se && r.drawBuffers(de);
  }
  function lt(J) {
    return m !== J ? (r.useProgram(J), m = J, !0) : !1;
  }
  const be = {
    [$o]: r.FUNC_ADD,
    [mF]: r.FUNC_SUBTRACT,
    [gF]: r.FUNC_REVERSE_SUBTRACT
  };
  be[yF] = r.MIN, be[vF] = r.MAX;
  const vt = {
    [bF]: r.ZERO,
    [xF]: r.ONE,
    [_F]: r.SRC_COLOR,
    [Yv]: r.SRC_ALPHA,
    [AF]: r.SRC_ALPHA_SATURATE,
    [EF]: r.DST_COLOR,
    [SF]: r.DST_ALPHA,
    [TF]: r.ONE_MINUS_SRC_COLOR,
    [$v]: r.ONE_MINUS_SRC_ALPHA,
    [MF]: r.ONE_MINUS_DST_COLOR,
    [wF]: r.ONE_MINUS_DST_ALPHA,
    [CF]: r.CONSTANT_COLOR,
    [RF]: r.ONE_MINUS_CONSTANT_COLOR,
    [NF]: r.CONSTANT_ALPHA,
    [PF]: r.ONE_MINUS_CONSTANT_ALPHA
  };
  function Z(J, Oe, de, Se, Ve, Ue, Rt, si, _i, Bt) {
    if (J === ha) {
      v === !0 && (ge(r.BLEND), v = !1);
      return;
    }
    if (v === !1 && (ue(r.BLEND), v = !0), J !== fF) {
      if (J !== y || Bt !== E) {
        if ((g !== $o || b !== $o) && (r.blendEquation(r.FUNC_ADD), g = $o, b = $o), Bt)
          switch (J) {
            case Hu:
              r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case v1:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case b1:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case x1:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", J);
              break;
          }
        else
          switch (J) {
            case Hu:
              r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case v1:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case b1:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case x1:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", J);
              break;
          }
        _ = null, x = null, T = null, S = null, w.set(0, 0, 0), C = 0, y = J, E = Bt;
      }
      return;
    }
    Ve = Ve || Oe, Ue = Ue || de, Rt = Rt || Se, (Oe !== g || Ve !== b) && (r.blendEquationSeparate(be[Oe], be[Ve]), g = Oe, b = Ve), (de !== _ || Se !== x || Ue !== T || Rt !== S) && (r.blendFuncSeparate(vt[de], vt[Se], vt[Ue], vt[Rt]), _ = de, x = Se, T = Ue, S = Rt), (si.equals(w) === !1 || _i !== C) && (r.blendColor(si.r, si.g, si.b, _i), w.copy(si), C = _i), y = J, E = !1;
  }
  function Vt(J, Oe) {
    J.side === ea ? ge(r.CULL_FACE) : ue(r.CULL_FACE);
    let de = J.side === Mr;
    Oe && (de = !de), ct(de), J.blending === Hu && J.transparent === !1 ? Z(ha) : Z(J.blending, J.blendEquation, J.blendSrc, J.blendDst, J.blendEquationAlpha, J.blendSrcAlpha, J.blendDstAlpha, J.blendColor, J.blendAlpha, J.premultipliedAlpha), o.setFunc(J.depthFunc), o.setTest(J.depthTest), o.setMask(J.depthWrite), a.setMask(J.colorWrite);
    const Se = J.stencilWrite;
    l.setTest(Se), Se && (l.setMask(J.stencilWriteMask), l.setFunc(J.stencilFunc, J.stencilRef, J.stencilFuncMask), l.setOp(J.stencilFail, J.stencilZFail, J.stencilZPass)), Dt(J.polygonOffset, J.polygonOffsetFactor, J.polygonOffsetUnits), J.alphaToCoverage === !0 ? ue(r.SAMPLE_ALPHA_TO_COVERAGE) : ge(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ct(J) {
    A !== J && (J ? r.frontFace(r.CW) : r.frontFace(r.CCW), A = J);
  }
  function xt(J) {
    J !== hF ? (ue(r.CULL_FACE), J !== N && (J === y1 ? r.cullFace(r.BACK) : J === dF ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : ge(r.CULL_FACE), N = J;
  }
  function it(J) {
    J !== L && (O && r.lineWidth(J), L = J);
  }
  function Dt(J, Oe, de) {
    J ? (ue(r.POLYGON_OFFSET_FILL), (F !== Oe || M !== de) && (r.polygonOffset(Oe, de), F = Oe, M = de)) : ge(r.POLYGON_OFFSET_FILL);
  }
  function at(J) {
    J ? ue(r.SCISSOR_TEST) : ge(r.SCISSOR_TEST);
  }
  function z(J) {
    J === void 0 && (J = r.TEXTURE0 + P - 1), H !== J && (r.activeTexture(J), H = J);
  }
  function D(J, Oe, de) {
    de === void 0 && (H === null ? de = r.TEXTURE0 + P - 1 : de = H);
    let Se = U[de];
    Se === void 0 && (Se = { type: void 0, texture: void 0 }, U[de] = Se), (Se.type !== J || Se.texture !== Oe) && (H !== de && (r.activeTexture(de), H = de), r.bindTexture(J, Oe || ae[J]), Se.type = J, Se.texture = Oe);
  }
  function le() {
    const J = U[H];
    J !== void 0 && J.type !== void 0 && (r.bindTexture(J.type, null), J.type = void 0, J.texture = void 0);
  }
  function _e() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Ae() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function xe() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Qe() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function ze() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function je() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function St() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Pe() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Ye() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function ut() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Fe(J) {
    q.equals(J) === !1 && (r.scissor(J.x, J.y, J.z, J.w), q.copy(J));
  }
  function Xe(J) {
    G.equals(J) === !1 && (r.viewport(J.x, J.y, J.z, J.w), G.copy(J));
  }
  function Ct(J, Oe) {
    let de = c.get(Oe);
    de === void 0 && (de = /* @__PURE__ */ new WeakMap(), c.set(Oe, de));
    let Se = de.get(J);
    Se === void 0 && (Se = r.getUniformBlockIndex(Oe, J.name), de.set(J, Se));
  }
  function mt(J, Oe) {
    const de = c.get(Oe).get(J);
    u.get(Oe) !== de && (r.uniformBlockBinding(Oe, de, J.__bindingPointIndex), u.set(Oe, de));
  }
  function kt() {
    r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), o.setReversed(!1), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), h = {}, H = null, U = {}, d = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, v = !1, y = null, g = null, _ = null, x = null, b = null, T = null, S = null, w = new Ft(0, 0, 0), C = 0, E = !1, A = null, N = null, L = null, F = null, M = null, q.set(0, 0, r.canvas.width, r.canvas.height), G.set(0, 0, r.canvas.width, r.canvas.height), a.reset(), o.reset(), l.reset();
  }
  return {
    buffers: {
      color: a,
      depth: o,
      stencil: l
    },
    enable: ue,
    disable: ge,
    bindFramebuffer: we,
    drawBuffers: Ne,
    useProgram: lt,
    setBlending: Z,
    setMaterial: Vt,
    setFlipSided: ct,
    setCullFace: xt,
    setLineWidth: it,
    setPolygonOffset: Dt,
    setScissorTest: at,
    activeTexture: z,
    bindTexture: D,
    unbindTexture: le,
    compressedTexImage2D: _e,
    compressedTexImage3D: Ae,
    texImage2D: Ye,
    texImage3D: ut,
    updateUBOMapping: Ct,
    uniformBlockBinding: mt,
    texStorage2D: St,
    texStorage3D: Pe,
    texSubImage2D: xe,
    texSubImage3D: Qe,
    compressedTexSubImage2D: ze,
    compressedTexSubImage3D: je,
    scissor: Fe,
    viewport: Xe,
    reset: kt
  };
}
function fw(r, e, i, n) {
  const s = p6(n);
  switch (i) {
    case BC:
      return r * e;
    case jC:
      return r * e;
    case VC:
      return r * e * 2;
    case GC:
      return r * e / s.components * s.byteLength;
    case A_:
      return r * e / s.components * s.byteLength;
    case HC:
      return r * e * 2 / s.components * s.byteLength;
    case C_:
      return r * e * 2 / s.components * s.byteLength;
    case zC:
      return r * e * 3 / s.components * s.byteLength;
    case Kn:
      return r * e * 4 / s.components * s.byteLength;
    case R_:
      return r * e * 4 / s.components * s.byteLength;
    case Hf:
    case Wf:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case qf:
    case Xf:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case lb:
    case cb:
      return Math.max(r, 16) * Math.max(e, 8) / 4;
    case ob:
    case ub:
      return Math.max(r, 8) * Math.max(e, 8) / 2;
    case hb:
    case db:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case pb:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case fb:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case mb:
      return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case gb:
      return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case yb:
      return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case vb:
      return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case bb:
      return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case xb:
      return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case _b:
      return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Tb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Sb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case wb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Eb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Mb:
      return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Ab:
      return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Yf:
    case Cb:
    case Rb:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
    case WC:
    case Nb:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
    case Pb:
    case Ob:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${i} format.`
  );
}
function p6(r) {
  switch (r) {
    case Ta:
    case LC:
      return { byteLength: 1, components: 1 };
    case cd:
    case UC:
    case Dc:
      return { byteLength: 2, components: 1 };
    case E_:
    case M_:
      return { byteLength: 2, components: 4 };
    case Tl:
    case w_:
    case aa:
      return { byteLength: 4, components: 1 };
    case FC:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${r}.`);
}
function f6(r, e, i, n, s, a, o) {
  const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, u = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), c = new Le(), h = /* @__PURE__ */ new WeakMap();
  let d;
  const p = /* @__PURE__ */ new WeakMap();
  let f = !1;
  try {
    f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function m(z, D) {
    return f ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(z, D)
    ) : dd("canvas");
  }
  function v(z, D, le) {
    let _e = 1;
    const Ae = at(z);
    if ((Ae.width > le || Ae.height > le) && (_e = le / Math.max(Ae.width, Ae.height)), _e < 1)
      if (typeof HTMLImageElement < "u" && z instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && z instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && z instanceof ImageBitmap || typeof VideoFrame < "u" && z instanceof VideoFrame) {
        const xe = Math.floor(_e * Ae.width), Qe = Math.floor(_e * Ae.height);
        d === void 0 && (d = m(xe, Qe));
        const ze = D ? m(xe, Qe) : d;
        return ze.width = xe, ze.height = Qe, ze.getContext("2d").drawImage(z, 0, 0, xe, Qe), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Ae.width + "x" + Ae.height + ") to (" + xe + "x" + Qe + ")."), ze;
      } else
        return "data" in z && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Ae.width + "x" + Ae.height + ")."), z;
    return z;
  }
  function y(z) {
    return z.generateMipmaps;
  }
  function g(z) {
    r.generateMipmap(z);
  }
  function _(z) {
    return z.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : z.isWebGL3DRenderTarget ? r.TEXTURE_3D : z.isWebGLArrayRenderTarget || z.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D;
  }
  function x(z, D, le, _e, Ae = !1) {
    if (z !== null) {
      if (r[z] !== void 0) return r[z];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + z + "'");
    }
    let xe = D;
    if (D === r.RED && (le === r.FLOAT && (xe = r.R32F), le === r.HALF_FLOAT && (xe = r.R16F), le === r.UNSIGNED_BYTE && (xe = r.R8)), D === r.RED_INTEGER && (le === r.UNSIGNED_BYTE && (xe = r.R8UI), le === r.UNSIGNED_SHORT && (xe = r.R16UI), le === r.UNSIGNED_INT && (xe = r.R32UI), le === r.BYTE && (xe = r.R8I), le === r.SHORT && (xe = r.R16I), le === r.INT && (xe = r.R32I)), D === r.RG && (le === r.FLOAT && (xe = r.RG32F), le === r.HALF_FLOAT && (xe = r.RG16F), le === r.UNSIGNED_BYTE && (xe = r.RG8)), D === r.RG_INTEGER && (le === r.UNSIGNED_BYTE && (xe = r.RG8UI), le === r.UNSIGNED_SHORT && (xe = r.RG16UI), le === r.UNSIGNED_INT && (xe = r.RG32UI), le === r.BYTE && (xe = r.RG8I), le === r.SHORT && (xe = r.RG16I), le === r.INT && (xe = r.RG32I)), D === r.RGB_INTEGER && (le === r.UNSIGNED_BYTE && (xe = r.RGB8UI), le === r.UNSIGNED_SHORT && (xe = r.RGB16UI), le === r.UNSIGNED_INT && (xe = r.RGB32UI), le === r.BYTE && (xe = r.RGB8I), le === r.SHORT && (xe = r.RGB16I), le === r.INT && (xe = r.RGB32I)), D === r.RGBA_INTEGER && (le === r.UNSIGNED_BYTE && (xe = r.RGBA8UI), le === r.UNSIGNED_SHORT && (xe = r.RGBA16UI), le === r.UNSIGNED_INT && (xe = r.RGBA32UI), le === r.BYTE && (xe = r.RGBA8I), le === r.SHORT && (xe = r.RGBA16I), le === r.INT && (xe = r.RGBA32I)), D === r.RGB && le === r.UNSIGNED_INT_5_9_9_9_REV && (xe = r.RGB9_E5), D === r.RGBA) {
      const Qe = Ae ? yg : Gt.getTransfer(_e);
      le === r.FLOAT && (xe = r.RGBA32F), le === r.HALF_FLOAT && (xe = r.RGBA16F), le === r.UNSIGNED_BYTE && (xe = Qe === ei ? r.SRGB8_ALPHA8 : r.RGBA8), le === r.UNSIGNED_SHORT_4_4_4_4 && (xe = r.RGBA4), le === r.UNSIGNED_SHORT_5_5_5_1 && (xe = r.RGB5_A1);
    }
    return (xe === r.R16F || xe === r.R32F || xe === r.RG16F || xe === r.RG32F || xe === r.RGBA16F || xe === r.RGBA32F) && e.get("EXT_color_buffer_float"), xe;
  }
  function b(z, D) {
    let le;
    return z ? D === null || D === Tl || D === mc ? le = r.DEPTH24_STENCIL8 : D === aa ? le = r.DEPTH32F_STENCIL8 : D === cd && (le = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : D === null || D === Tl || D === mc ? le = r.DEPTH_COMPONENT24 : D === aa ? le = r.DEPTH_COMPONENT32F : D === cd && (le = r.DEPTH_COMPONENT16), le;
  }
  function T(z, D) {
    return y(z) === !0 || z.isFramebufferTexture && z.minFilter !== Jn && z.minFilter !== gs ? Math.log2(Math.max(D.width, D.height)) + 1 : z.mipmaps !== void 0 && z.mipmaps.length > 0 ? z.mipmaps.length : z.isCompressedTexture && Array.isArray(z.image) ? D.mipmaps.length : 1;
  }
  function S(z) {
    const D = z.target;
    D.removeEventListener("dispose", S), C(D), D.isVideoTexture && h.delete(D);
  }
  function w(z) {
    const D = z.target;
    D.removeEventListener("dispose", w), A(D);
  }
  function C(z) {
    const D = n.get(z);
    if (D.__webglInit === void 0) return;
    const le = z.source, _e = p.get(le);
    if (_e) {
      const Ae = _e[D.__cacheKey];
      Ae.usedTimes--, Ae.usedTimes === 0 && E(z), Object.keys(_e).length === 0 && p.delete(le);
    }
    n.remove(z);
  }
  function E(z) {
    const D = n.get(z);
    r.deleteTexture(D.__webglTexture);
    const le = z.source, _e = p.get(le);
    delete _e[D.__cacheKey], o.memory.textures--;
  }
  function A(z) {
    const D = n.get(z);
    if (z.depthTexture && (z.depthTexture.dispose(), n.remove(z.depthTexture)), z.isWebGLCubeRenderTarget)
      for (let _e = 0; _e < 6; _e++) {
        if (Array.isArray(D.__webglFramebuffer[_e]))
          for (let Ae = 0; Ae < D.__webglFramebuffer[_e].length; Ae++) r.deleteFramebuffer(D.__webglFramebuffer[_e][Ae]);
        else
          r.deleteFramebuffer(D.__webglFramebuffer[_e]);
        D.__webglDepthbuffer && r.deleteRenderbuffer(D.__webglDepthbuffer[_e]);
      }
    else {
      if (Array.isArray(D.__webglFramebuffer))
        for (let _e = 0; _e < D.__webglFramebuffer.length; _e++) r.deleteFramebuffer(D.__webglFramebuffer[_e]);
      else
        r.deleteFramebuffer(D.__webglFramebuffer);
      if (D.__webglDepthbuffer && r.deleteRenderbuffer(D.__webglDepthbuffer), D.__webglMultisampledFramebuffer && r.deleteFramebuffer(D.__webglMultisampledFramebuffer), D.__webglColorRenderbuffer)
        for (let _e = 0; _e < D.__webglColorRenderbuffer.length; _e++)
          D.__webglColorRenderbuffer[_e] && r.deleteRenderbuffer(D.__webglColorRenderbuffer[_e]);
      D.__webglDepthRenderbuffer && r.deleteRenderbuffer(D.__webglDepthRenderbuffer);
    }
    const le = z.textures;
    for (let _e = 0, Ae = le.length; _e < Ae; _e++) {
      const xe = n.get(le[_e]);
      xe.__webglTexture && (r.deleteTexture(xe.__webglTexture), o.memory.textures--), n.remove(le[_e]);
    }
    n.remove(z);
  }
  let N = 0;
  function L() {
    N = 0;
  }
  function F() {
    const z = N;
    return z >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + z + " texture units while this GPU supports only " + s.maxTextures), N += 1, z;
  }
  function M(z) {
    const D = [];
    return D.push(z.wrapS), D.push(z.wrapT), D.push(z.wrapR || 0), D.push(z.magFilter), D.push(z.minFilter), D.push(z.anisotropy), D.push(z.internalFormat), D.push(z.format), D.push(z.type), D.push(z.generateMipmaps), D.push(z.premultiplyAlpha), D.push(z.flipY), D.push(z.unpackAlignment), D.push(z.colorSpace), D.join();
  }
  function P(z, D) {
    const le = n.get(z);
    if (z.isVideoTexture && it(z), z.isRenderTargetTexture === !1 && z.version > 0 && le.__version !== z.version) {
      const _e = z.image;
      if (_e === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (_e.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        G(le, z, D);
        return;
      }
    }
    i.bindTexture(r.TEXTURE_2D, le.__webglTexture, r.TEXTURE0 + D);
  }
  function O(z, D) {
    const le = n.get(z);
    if (z.version > 0 && le.__version !== z.version) {
      G(le, z, D);
      return;
    }
    i.bindTexture(r.TEXTURE_2D_ARRAY, le.__webglTexture, r.TEXTURE0 + D);
  }
  function V(z, D) {
    const le = n.get(z);
    if (z.version > 0 && le.__version !== z.version) {
      G(le, z, D);
      return;
    }
    i.bindTexture(r.TEXTURE_3D, le.__webglTexture, r.TEXTURE0 + D);
  }
  function B(z, D) {
    const le = n.get(z);
    if (z.version > 0 && le.__version !== z.version) {
      Y(le, z, D);
      return;
    }
    i.bindTexture(r.TEXTURE_CUBE_MAP, le.__webglTexture, r.TEXTURE0 + D);
  }
  const H = {
    [sb]: r.REPEAT,
    [nl]: r.CLAMP_TO_EDGE,
    [ab]: r.MIRRORED_REPEAT
  }, U = {
    [Jn]: r.NEAREST,
    [jF]: r.NEAREST_MIPMAP_NEAREST,
    [hp]: r.NEAREST_MIPMAP_LINEAR,
    [gs]: r.LINEAR,
    [yy]: r.LINEAR_MIPMAP_NEAREST,
    [sl]: r.LINEAR_MIPMAP_LINEAR
  }, j = {
    [WF]: r.NEVER,
    [QF]: r.ALWAYS,
    [qF]: r.LESS,
    [XC]: r.LEQUAL,
    [XF]: r.EQUAL,
    [KF]: r.GEQUAL,
    [YF]: r.GREATER,
    [$F]: r.NOTEQUAL
  };
  function Q(z, D) {
    if (D.type === aa && e.has("OES_texture_float_linear") === !1 && (D.magFilter === gs || D.magFilter === yy || D.magFilter === hp || D.magFilter === sl || D.minFilter === gs || D.minFilter === yy || D.minFilter === hp || D.minFilter === sl) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(z, r.TEXTURE_WRAP_S, H[D.wrapS]), r.texParameteri(z, r.TEXTURE_WRAP_T, H[D.wrapT]), (z === r.TEXTURE_3D || z === r.TEXTURE_2D_ARRAY) && r.texParameteri(z, r.TEXTURE_WRAP_R, H[D.wrapR]), r.texParameteri(z, r.TEXTURE_MAG_FILTER, U[D.magFilter]), r.texParameteri(z, r.TEXTURE_MIN_FILTER, U[D.minFilter]), D.compareFunction && (r.texParameteri(z, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(z, r.TEXTURE_COMPARE_FUNC, j[D.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (D.magFilter === Jn || D.minFilter !== hp && D.minFilter !== sl || D.type === aa && e.has("OES_texture_float_linear") === !1) return;
      if (D.anisotropy > 1 || n.get(D).__currentAnisotropy) {
        const le = e.get("EXT_texture_filter_anisotropic");
        r.texParameterf(z, le.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(D.anisotropy, s.getMaxAnisotropy())), n.get(D).__currentAnisotropy = D.anisotropy;
      }
    }
  }
  function q(z, D) {
    let le = !1;
    z.__webglInit === void 0 && (z.__webglInit = !0, D.addEventListener("dispose", S));
    const _e = D.source;
    let Ae = p.get(_e);
    Ae === void 0 && (Ae = {}, p.set(_e, Ae));
    const xe = M(D);
    if (xe !== z.__cacheKey) {
      Ae[xe] === void 0 && (Ae[xe] = {
        texture: r.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, le = !0), Ae[xe].usedTimes++;
      const Qe = Ae[z.__cacheKey];
      Qe !== void 0 && (Ae[z.__cacheKey].usedTimes--, Qe.usedTimes === 0 && E(D)), z.__cacheKey = xe, z.__webglTexture = Ae[xe].texture;
    }
    return le;
  }
  function G(z, D, le) {
    let _e = r.TEXTURE_2D;
    (D.isDataArrayTexture || D.isCompressedArrayTexture) && (_e = r.TEXTURE_2D_ARRAY), D.isData3DTexture && (_e = r.TEXTURE_3D);
    const Ae = q(z, D), xe = D.source;
    i.bindTexture(_e, z.__webglTexture, r.TEXTURE0 + le);
    const Qe = n.get(xe);
    if (xe.version !== Qe.__version || Ae === !0) {
      i.activeTexture(r.TEXTURE0 + le);
      const ze = Gt.getPrimaries(Gt.workingColorSpace), je = D.colorSpace === to ? null : Gt.getPrimaries(D.colorSpace), St = D.colorSpace === to || ze === je ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, D.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, D.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, St);
      let Pe = v(D.image, !1, s.maxTextureSize);
      Pe = Dt(D, Pe);
      const Ye = a.convert(D.format, D.colorSpace), ut = a.convert(D.type);
      let Fe = x(D.internalFormat, Ye, ut, D.colorSpace, D.isVideoTexture);
      Q(_e, D);
      let Xe;
      const Ct = D.mipmaps, mt = D.isVideoTexture !== !0, kt = Qe.__version === void 0 || Ae === !0, J = xe.dataReady, Oe = T(D, Pe);
      if (D.isDepthTexture)
        Fe = b(D.format === gc, D.type), kt && (mt ? i.texStorage2D(r.TEXTURE_2D, 1, Fe, Pe.width, Pe.height) : i.texImage2D(r.TEXTURE_2D, 0, Fe, Pe.width, Pe.height, 0, Ye, ut, null));
      else if (D.isDataTexture)
        if (Ct.length > 0) {
          mt && kt && i.texStorage2D(r.TEXTURE_2D, Oe, Fe, Ct[0].width, Ct[0].height);
          for (let de = 0, Se = Ct.length; de < Se; de++)
            Xe = Ct[de], mt ? J && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, Xe.width, Xe.height, Ye, ut, Xe.data) : i.texImage2D(r.TEXTURE_2D, de, Fe, Xe.width, Xe.height, 0, Ye, ut, Xe.data);
          D.generateMipmaps = !1;
        } else
          mt ? (kt && i.texStorage2D(r.TEXTURE_2D, Oe, Fe, Pe.width, Pe.height), J && i.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Pe.width, Pe.height, Ye, ut, Pe.data)) : i.texImage2D(r.TEXTURE_2D, 0, Fe, Pe.width, Pe.height, 0, Ye, ut, Pe.data);
      else if (D.isCompressedTexture)
        if (D.isCompressedArrayTexture) {
          mt && kt && i.texStorage3D(r.TEXTURE_2D_ARRAY, Oe, Fe, Ct[0].width, Ct[0].height, Pe.depth);
          for (let de = 0, Se = Ct.length; de < Se; de++)
            if (Xe = Ct[de], D.format !== Kn)
              if (Ye !== null)
                if (mt) {
                  if (J)
                    if (D.layerUpdates.size > 0) {
                      const Ve = fw(Xe.width, Xe.height, D.format, D.type);
                      for (const Ue of D.layerUpdates) {
                        const Rt = Xe.data.subarray(
                          Ue * Ve / Xe.data.BYTES_PER_ELEMENT,
                          (Ue + 1) * Ve / Xe.data.BYTES_PER_ELEMENT
                        );
                        i.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, Ue, Xe.width, Xe.height, 1, Ye, Rt);
                      }
                      D.clearLayerUpdates();
                    } else
                      i.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, 0, Xe.width, Xe.height, Pe.depth, Ye, Xe.data);
                } else
                  i.compressedTexImage3D(r.TEXTURE_2D_ARRAY, de, Fe, Xe.width, Xe.height, Pe.depth, 0, Xe.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              mt ? J && i.texSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, 0, Xe.width, Xe.height, Pe.depth, Ye, ut, Xe.data) : i.texImage3D(r.TEXTURE_2D_ARRAY, de, Fe, Xe.width, Xe.height, Pe.depth, 0, Ye, ut, Xe.data);
        } else {
          mt && kt && i.texStorage2D(r.TEXTURE_2D, Oe, Fe, Ct[0].width, Ct[0].height);
          for (let de = 0, Se = Ct.length; de < Se; de++)
            Xe = Ct[de], D.format !== Kn ? Ye !== null ? mt ? J && i.compressedTexSubImage2D(r.TEXTURE_2D, de, 0, 0, Xe.width, Xe.height, Ye, Xe.data) : i.compressedTexImage2D(r.TEXTURE_2D, de, Fe, Xe.width, Xe.height, 0, Xe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : mt ? J && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, Xe.width, Xe.height, Ye, ut, Xe.data) : i.texImage2D(r.TEXTURE_2D, de, Fe, Xe.width, Xe.height, 0, Ye, ut, Xe.data);
        }
      else if (D.isDataArrayTexture)
        if (mt) {
          if (kt && i.texStorage3D(r.TEXTURE_2D_ARRAY, Oe, Fe, Pe.width, Pe.height, Pe.depth), J)
            if (D.layerUpdates.size > 0) {
              const de = fw(Pe.width, Pe.height, D.format, D.type);
              for (const Se of D.layerUpdates) {
                const Ve = Pe.data.subarray(
                  Se * de / Pe.data.BYTES_PER_ELEMENT,
                  (Se + 1) * de / Pe.data.BYTES_PER_ELEMENT
                );
                i.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, Se, Pe.width, Pe.height, 1, Ye, ut, Ve);
              }
              D.clearLayerUpdates();
            } else
              i.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Pe.width, Pe.height, Pe.depth, Ye, ut, Pe.data);
        } else
          i.texImage3D(r.TEXTURE_2D_ARRAY, 0, Fe, Pe.width, Pe.height, Pe.depth, 0, Ye, ut, Pe.data);
      else if (D.isData3DTexture)
        mt ? (kt && i.texStorage3D(r.TEXTURE_3D, Oe, Fe, Pe.width, Pe.height, Pe.depth), J && i.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, Pe.width, Pe.height, Pe.depth, Ye, ut, Pe.data)) : i.texImage3D(r.TEXTURE_3D, 0, Fe, Pe.width, Pe.height, Pe.depth, 0, Ye, ut, Pe.data);
      else if (D.isFramebufferTexture) {
        if (kt)
          if (mt)
            i.texStorage2D(r.TEXTURE_2D, Oe, Fe, Pe.width, Pe.height);
          else {
            let de = Pe.width, Se = Pe.height;
            for (let Ve = 0; Ve < Oe; Ve++)
              i.texImage2D(r.TEXTURE_2D, Ve, Fe, de, Se, 0, Ye, ut, null), de >>= 1, Se >>= 1;
          }
      } else if (Ct.length > 0) {
        if (mt && kt) {
          const de = at(Ct[0]);
          i.texStorage2D(r.TEXTURE_2D, Oe, Fe, de.width, de.height);
        }
        for (let de = 0, Se = Ct.length; de < Se; de++)
          Xe = Ct[de], mt ? J && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, Ye, ut, Xe) : i.texImage2D(r.TEXTURE_2D, de, Fe, Ye, ut, Xe);
        D.generateMipmaps = !1;
      } else if (mt) {
        if (kt) {
          const de = at(Pe);
          i.texStorage2D(r.TEXTURE_2D, Oe, Fe, de.width, de.height);
        }
        J && i.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ye, ut, Pe);
      } else
        i.texImage2D(r.TEXTURE_2D, 0, Fe, Ye, ut, Pe);
      y(D) && g(_e), Qe.__version = xe.version, D.onUpdate && D.onUpdate(D);
    }
    z.__version = D.version;
  }
  function Y(z, D, le) {
    if (D.image.length !== 6) return;
    const _e = q(z, D), Ae = D.source;
    i.bindTexture(r.TEXTURE_CUBE_MAP, z.__webglTexture, r.TEXTURE0 + le);
    const xe = n.get(Ae);
    if (Ae.version !== xe.__version || _e === !0) {
      i.activeTexture(r.TEXTURE0 + le);
      const Qe = Gt.getPrimaries(Gt.workingColorSpace), ze = D.colorSpace === to ? null : Gt.getPrimaries(D.colorSpace), je = D.colorSpace === to || Qe === ze ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, D.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, D.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, je);
      const St = D.isCompressedTexture || D.image[0].isCompressedTexture, Pe = D.image[0] && D.image[0].isDataTexture, Ye = [];
      for (let Se = 0; Se < 6; Se++)
        !St && !Pe ? Ye[Se] = v(D.image[Se], !0, s.maxCubemapSize) : Ye[Se] = Pe ? D.image[Se].image : D.image[Se], Ye[Se] = Dt(D, Ye[Se]);
      const ut = Ye[0], Fe = a.convert(D.format, D.colorSpace), Xe = a.convert(D.type), Ct = x(D.internalFormat, Fe, Xe, D.colorSpace), mt = D.isVideoTexture !== !0, kt = xe.__version === void 0 || _e === !0, J = Ae.dataReady;
      let Oe = T(D, ut);
      Q(r.TEXTURE_CUBE_MAP, D);
      let de;
      if (St) {
        mt && kt && i.texStorage2D(r.TEXTURE_CUBE_MAP, Oe, Ct, ut.width, ut.height);
        for (let Se = 0; Se < 6; Se++) {
          de = Ye[Se].mipmaps;
          for (let Ve = 0; Ve < de.length; Ve++) {
            const Ue = de[Ve];
            D.format !== Kn ? Fe !== null ? mt ? J && i.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, Ve, 0, 0, Ue.width, Ue.height, Fe, Ue.data) : i.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, Ve, Ct, Ue.width, Ue.height, 0, Ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : mt ? J && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, Ve, 0, 0, Ue.width, Ue.height, Fe, Xe, Ue.data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, Ve, Ct, Ue.width, Ue.height, 0, Fe, Xe, Ue.data);
          }
        }
      } else {
        if (de = D.mipmaps, mt && kt) {
          de.length > 0 && Oe++;
          const Se = at(Ye[0]);
          i.texStorage2D(r.TEXTURE_CUBE_MAP, Oe, Ct, Se.width, Se.height);
        }
        for (let Se = 0; Se < 6; Se++)
          if (Pe) {
            mt ? J && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, 0, 0, 0, Ye[Se].width, Ye[Se].height, Fe, Xe, Ye[Se].data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, 0, Ct, Ye[Se].width, Ye[Se].height, 0, Fe, Xe, Ye[Se].data);
            for (let Ve = 0; Ve < de.length; Ve++) {
              const Ue = de[Ve].image[Se].image;
              mt ? J && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, Ve + 1, 0, 0, Ue.width, Ue.height, Fe, Xe, Ue.data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, Ve + 1, Ct, Ue.width, Ue.height, 0, Fe, Xe, Ue.data);
            }
          } else {
            mt ? J && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, 0, 0, 0, Fe, Xe, Ye[Se]) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, 0, Ct, Fe, Xe, Ye[Se]);
            for (let Ve = 0; Ve < de.length; Ve++) {
              const Ue = de[Ve];
              mt ? J && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, Ve + 1, 0, 0, Fe, Xe, Ue.image[Se]) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Se, Ve + 1, Ct, Fe, Xe, Ue.image[Se]);
            }
          }
      }
      y(D) && g(r.TEXTURE_CUBE_MAP), xe.__version = Ae.version, D.onUpdate && D.onUpdate(D);
    }
    z.__version = D.version;
  }
  function ae(z, D, le, _e, Ae, xe) {
    const Qe = a.convert(le.format, le.colorSpace), ze = a.convert(le.type), je = x(le.internalFormat, Qe, ze, le.colorSpace), St = n.get(D), Pe = n.get(le);
    if (Pe.__renderTarget = D, !St.__hasExternalTextures) {
      const Ye = Math.max(1, D.width >> xe), ut = Math.max(1, D.height >> xe);
      Ae === r.TEXTURE_3D || Ae === r.TEXTURE_2D_ARRAY ? i.texImage3D(Ae, xe, je, Ye, ut, D.depth, 0, Qe, ze, null) : i.texImage2D(Ae, xe, je, Ye, ut, 0, Qe, ze, null);
    }
    i.bindFramebuffer(r.FRAMEBUFFER, z), xt(D) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, _e, Ae, Pe.__webglTexture, 0, ct(D)) : (Ae === r.TEXTURE_2D || Ae >= r.TEXTURE_CUBE_MAP_POSITIVE_X && Ae <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, _e, Ae, Pe.__webglTexture, xe), i.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function ue(z, D, le) {
    if (r.bindRenderbuffer(r.RENDERBUFFER, z), D.depthBuffer) {
      const _e = D.depthTexture, Ae = _e && _e.isDepthTexture ? _e.type : null, xe = b(D.stencilBuffer, Ae), Qe = D.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, ze = ct(D);
      xt(D) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ze, xe, D.width, D.height) : le ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ze, xe, D.width, D.height) : r.renderbufferStorage(r.RENDERBUFFER, xe, D.width, D.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, Qe, r.RENDERBUFFER, z);
    } else {
      const _e = D.textures;
      for (let Ae = 0; Ae < _e.length; Ae++) {
        const xe = _e[Ae], Qe = a.convert(xe.format, xe.colorSpace), ze = a.convert(xe.type), je = x(xe.internalFormat, Qe, ze, xe.colorSpace), St = ct(D);
        le && xt(D) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, St, je, D.width, D.height) : xt(D) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, St, je, D.width, D.height) : r.renderbufferStorage(r.RENDERBUFFER, je, D.width, D.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function ge(z, D) {
    if (D && D.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (i.bindFramebuffer(r.FRAMEBUFFER, z), !(D.depthTexture && D.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const le = n.get(D.depthTexture);
    le.__renderTarget = D, (!le.__webglTexture || D.depthTexture.image.width !== D.width || D.depthTexture.image.height !== D.height) && (D.depthTexture.image.width = D.width, D.depthTexture.image.height = D.height, D.depthTexture.needsUpdate = !0), P(D.depthTexture, 0);
    const _e = le.__webglTexture, Ae = ct(D);
    if (D.depthTexture.format === Wu)
      xt(D) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, _e, 0, Ae) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, _e, 0);
    else if (D.depthTexture.format === gc)
      xt(D) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, _e, 0, Ae) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, _e, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function we(z) {
    const D = n.get(z), le = z.isWebGLCubeRenderTarget === !0;
    if (D.__boundDepthTexture !== z.depthTexture) {
      const _e = z.depthTexture;
      if (D.__depthDisposeCallback && D.__depthDisposeCallback(), _e) {
        const Ae = () => {
          delete D.__boundDepthTexture, delete D.__depthDisposeCallback, _e.removeEventListener("dispose", Ae);
        };
        _e.addEventListener("dispose", Ae), D.__depthDisposeCallback = Ae;
      }
      D.__boundDepthTexture = _e;
    }
    if (z.depthTexture && !D.__autoAllocateDepthBuffer) {
      if (le) throw new Error("target.depthTexture not supported in Cube render targets");
      ge(D.__webglFramebuffer, z);
    } else if (le) {
      D.__webglDepthbuffer = [];
      for (let _e = 0; _e < 6; _e++)
        if (i.bindFramebuffer(r.FRAMEBUFFER, D.__webglFramebuffer[_e]), D.__webglDepthbuffer[_e] === void 0)
          D.__webglDepthbuffer[_e] = r.createRenderbuffer(), ue(D.__webglDepthbuffer[_e], z, !1);
        else {
          const Ae = z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, xe = D.__webglDepthbuffer[_e];
          r.bindRenderbuffer(r.RENDERBUFFER, xe), r.framebufferRenderbuffer(r.FRAMEBUFFER, Ae, r.RENDERBUFFER, xe);
        }
    } else if (i.bindFramebuffer(r.FRAMEBUFFER, D.__webglFramebuffer), D.__webglDepthbuffer === void 0)
      D.__webglDepthbuffer = r.createRenderbuffer(), ue(D.__webglDepthbuffer, z, !1);
    else {
      const _e = z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Ae = D.__webglDepthbuffer;
      r.bindRenderbuffer(r.RENDERBUFFER, Ae), r.framebufferRenderbuffer(r.FRAMEBUFFER, _e, r.RENDERBUFFER, Ae);
    }
    i.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function Ne(z, D, le) {
    const _e = n.get(z);
    D !== void 0 && ae(_e.__webglFramebuffer, z, z.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), le !== void 0 && we(z);
  }
  function lt(z) {
    const D = z.texture, le = n.get(z), _e = n.get(D);
    z.addEventListener("dispose", w);
    const Ae = z.textures, xe = z.isWebGLCubeRenderTarget === !0, Qe = Ae.length > 1;
    if (Qe || (_e.__webglTexture === void 0 && (_e.__webglTexture = r.createTexture()), _e.__version = D.version, o.memory.textures++), xe) {
      le.__webglFramebuffer = [];
      for (let ze = 0; ze < 6; ze++)
        if (D.mipmaps && D.mipmaps.length > 0) {
          le.__webglFramebuffer[ze] = [];
          for (let je = 0; je < D.mipmaps.length; je++)
            le.__webglFramebuffer[ze][je] = r.createFramebuffer();
        } else
          le.__webglFramebuffer[ze] = r.createFramebuffer();
    } else {
      if (D.mipmaps && D.mipmaps.length > 0) {
        le.__webglFramebuffer = [];
        for (let ze = 0; ze < D.mipmaps.length; ze++)
          le.__webglFramebuffer[ze] = r.createFramebuffer();
      } else
        le.__webglFramebuffer = r.createFramebuffer();
      if (Qe)
        for (let ze = 0, je = Ae.length; ze < je; ze++) {
          const St = n.get(Ae[ze]);
          St.__webglTexture === void 0 && (St.__webglTexture = r.createTexture(), o.memory.textures++);
        }
      if (z.samples > 0 && xt(z) === !1) {
        le.__webglMultisampledFramebuffer = r.createFramebuffer(), le.__webglColorRenderbuffer = [], i.bindFramebuffer(r.FRAMEBUFFER, le.__webglMultisampledFramebuffer);
        for (let ze = 0; ze < Ae.length; ze++) {
          const je = Ae[ze];
          le.__webglColorRenderbuffer[ze] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, le.__webglColorRenderbuffer[ze]);
          const St = a.convert(je.format, je.colorSpace), Pe = a.convert(je.type), Ye = x(je.internalFormat, St, Pe, je.colorSpace, z.isXRRenderTarget === !0), ut = ct(z);
          r.renderbufferStorageMultisample(r.RENDERBUFFER, ut, Ye, z.width, z.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ze, r.RENDERBUFFER, le.__webglColorRenderbuffer[ze]);
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null), z.depthBuffer && (le.__webglDepthRenderbuffer = r.createRenderbuffer(), ue(le.__webglDepthRenderbuffer, z, !0)), i.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (xe) {
      i.bindTexture(r.TEXTURE_CUBE_MAP, _e.__webglTexture), Q(r.TEXTURE_CUBE_MAP, D);
      for (let ze = 0; ze < 6; ze++)
        if (D.mipmaps && D.mipmaps.length > 0)
          for (let je = 0; je < D.mipmaps.length; je++)
            ae(le.__webglFramebuffer[ze][je], z, D, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ze, je);
        else
          ae(le.__webglFramebuffer[ze], z, D, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ze, 0);
      y(D) && g(r.TEXTURE_CUBE_MAP), i.unbindTexture();
    } else if (Qe) {
      for (let ze = 0, je = Ae.length; ze < je; ze++) {
        const St = Ae[ze], Pe = n.get(St);
        i.bindTexture(r.TEXTURE_2D, Pe.__webglTexture), Q(r.TEXTURE_2D, St), ae(le.__webglFramebuffer, z, St, r.COLOR_ATTACHMENT0 + ze, r.TEXTURE_2D, 0), y(St) && g(r.TEXTURE_2D);
      }
      i.unbindTexture();
    } else {
      let ze = r.TEXTURE_2D;
      if ((z.isWebGL3DRenderTarget || z.isWebGLArrayRenderTarget) && (ze = z.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), i.bindTexture(ze, _e.__webglTexture), Q(ze, D), D.mipmaps && D.mipmaps.length > 0)
        for (let je = 0; je < D.mipmaps.length; je++)
          ae(le.__webglFramebuffer[je], z, D, r.COLOR_ATTACHMENT0, ze, je);
      else
        ae(le.__webglFramebuffer, z, D, r.COLOR_ATTACHMENT0, ze, 0);
      y(D) && g(ze), i.unbindTexture();
    }
    z.depthBuffer && we(z);
  }
  function be(z) {
    const D = z.textures;
    for (let le = 0, _e = D.length; le < _e; le++) {
      const Ae = D[le];
      if (y(Ae)) {
        const xe = _(z), Qe = n.get(Ae).__webglTexture;
        i.bindTexture(xe, Qe), g(xe), i.unbindTexture();
      }
    }
  }
  const vt = [], Z = [];
  function Vt(z) {
    if (z.samples > 0) {
      if (xt(z) === !1) {
        const D = z.textures, le = z.width, _e = z.height;
        let Ae = r.COLOR_BUFFER_BIT;
        const xe = z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Qe = n.get(z), ze = D.length > 1;
        if (ze)
          for (let je = 0; je < D.length; je++)
            i.bindFramebuffer(r.FRAMEBUFFER, Qe.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + je, r.RENDERBUFFER, null), i.bindFramebuffer(r.FRAMEBUFFER, Qe.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + je, r.TEXTURE_2D, null, 0);
        i.bindFramebuffer(r.READ_FRAMEBUFFER, Qe.__webglMultisampledFramebuffer), i.bindFramebuffer(r.DRAW_FRAMEBUFFER, Qe.__webglFramebuffer);
        for (let je = 0; je < D.length; je++) {
          if (z.resolveDepthBuffer && (z.depthBuffer && (Ae |= r.DEPTH_BUFFER_BIT), z.stencilBuffer && z.resolveStencilBuffer && (Ae |= r.STENCIL_BUFFER_BIT)), ze) {
            r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, Qe.__webglColorRenderbuffer[je]);
            const St = n.get(D[je]).__webglTexture;
            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, St, 0);
          }
          r.blitFramebuffer(0, 0, le, _e, 0, 0, le, _e, Ae, r.NEAREST), u === !0 && (vt.length = 0, Z.length = 0, vt.push(r.COLOR_ATTACHMENT0 + je), z.depthBuffer && z.resolveDepthBuffer === !1 && (vt.push(xe), Z.push(xe), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, Z)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, vt));
        }
        if (i.bindFramebuffer(r.READ_FRAMEBUFFER, null), i.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), ze)
          for (let je = 0; je < D.length; je++) {
            i.bindFramebuffer(r.FRAMEBUFFER, Qe.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + je, r.RENDERBUFFER, Qe.__webglColorRenderbuffer[je]);
            const St = n.get(D[je]).__webglTexture;
            i.bindFramebuffer(r.FRAMEBUFFER, Qe.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + je, r.TEXTURE_2D, St, 0);
          }
        i.bindFramebuffer(r.DRAW_FRAMEBUFFER, Qe.__webglMultisampledFramebuffer);
      } else if (z.depthBuffer && z.resolveDepthBuffer === !1 && u) {
        const D = z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
        r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [D]);
      }
    }
  }
  function ct(z) {
    return Math.min(s.maxSamples, z.samples);
  }
  function xt(z) {
    const D = n.get(z);
    return z.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && D.__useRenderToTexture !== !1;
  }
  function it(z) {
    const D = o.render.frame;
    h.get(z) !== D && (h.set(z, D), z.update());
  }
  function Dt(z, D) {
    const le = z.colorSpace, _e = z.format, Ae = z.type;
    return z.isCompressedTexture === !0 || z.isVideoTexture === !0 || le !== kc && le !== to && (Gt.getTransfer(le) === ei ? (_e !== Kn || Ae !== Ta) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", le)), D;
  }
  function at(z) {
    return typeof HTMLImageElement < "u" && z instanceof HTMLImageElement ? (c.width = z.naturalWidth || z.width, c.height = z.naturalHeight || z.height) : typeof VideoFrame < "u" && z instanceof VideoFrame ? (c.width = z.displayWidth, c.height = z.displayHeight) : (c.width = z.width, c.height = z.height), c;
  }
  this.allocateTextureUnit = F, this.resetTextureUnits = L, this.setTexture2D = P, this.setTexture2DArray = O, this.setTexture3D = V, this.setTextureCube = B, this.rebindTextures = Ne, this.setupRenderTarget = lt, this.updateRenderTargetMipmap = be, this.updateMultisampleRenderTarget = Vt, this.setupDepthRenderbuffer = we, this.setupFrameBufferTexture = ae, this.useMultisampledRTT = xt;
}
function m6(r, e) {
  function i(n, s = to) {
    let a;
    const o = Gt.getTransfer(s);
    if (n === Ta) return r.UNSIGNED_BYTE;
    if (n === E_) return r.UNSIGNED_SHORT_4_4_4_4;
    if (n === M_) return r.UNSIGNED_SHORT_5_5_5_1;
    if (n === FC) return r.UNSIGNED_INT_5_9_9_9_REV;
    if (n === LC) return r.BYTE;
    if (n === UC) return r.SHORT;
    if (n === cd) return r.UNSIGNED_SHORT;
    if (n === w_) return r.INT;
    if (n === Tl) return r.UNSIGNED_INT;
    if (n === aa) return r.FLOAT;
    if (n === Dc) return r.HALF_FLOAT;
    if (n === BC) return r.ALPHA;
    if (n === zC) return r.RGB;
    if (n === Kn) return r.RGBA;
    if (n === jC) return r.LUMINANCE;
    if (n === VC) return r.LUMINANCE_ALPHA;
    if (n === Wu) return r.DEPTH_COMPONENT;
    if (n === gc) return r.DEPTH_STENCIL;
    if (n === GC) return r.RED;
    if (n === A_) return r.RED_INTEGER;
    if (n === HC) return r.RG;
    if (n === C_) return r.RG_INTEGER;
    if (n === R_) return r.RGBA_INTEGER;
    if (n === Hf || n === Wf || n === qf || n === Xf)
      if (o === ei)
        if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (n === Hf) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === Wf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === qf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === Xf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (n === Hf) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === Wf) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === qf) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Xf) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === ob || n === lb || n === ub || n === cb)
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (n === ob) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === lb) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === ub) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === cb) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === hb || n === db || n === pb)
      if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (n === hb || n === db) return o === ei ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (n === pb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (n === fb || n === mb || n === gb || n === yb || n === vb || n === bb || n === xb || n === _b || n === Tb || n === Sb || n === wb || n === Eb || n === Mb || n === Ab)
      if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (n === fb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === mb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === gb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === yb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === vb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === bb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === xb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === _b) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === Tb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === Sb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === wb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === Eb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === Mb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === Ab) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === Yf || n === Cb || n === Rb)
      if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
        if (n === Yf) return o === ei ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === Cb) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === Rb) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (n === WC || n === Nb || n === Pb || n === Ob)
      if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
        if (n === Yf) return a.COMPRESSED_RED_RGTC1_EXT;
        if (n === Nb) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === Pb) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === Ob) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === mc ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null;
  }
  return { convert: i };
}
class g6 extends _n {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
let al = class extends Hr {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
};
const y6 = { type: "move" };
class Hy {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new al(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new al(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new X(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new X()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new al(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new X(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new X()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const i = this._hand;
      if (i)
        for (const n of e.hand.values())
          this._getHandJoint(i, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, i, n) {
    let s = null, a = null, o = null;
    const l = this._targetRay, u = this._grip, c = this._hand;
    if (e && i.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const v of e.hand.values()) {
          const y = i.getJointPose(v, n), g = this._getHandJoint(c, v);
          y !== null && (g.matrix.fromArray(y.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, g.jointRadius = y.radius), g.visible = y !== null;
        }
        const h = c.joints["index-finger-tip"], d = c.joints["thumb-tip"], p = h.position.distanceTo(d.position), f = 0.02, m = 5e-3;
        c.inputState.pinching && p > f + m ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && p <= f - m && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        u !== null && e.gripSpace && (a = i.getPose(e.gripSpace, n), a !== null && (u.matrix.fromArray(a.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (u.hasLinearVelocity = !0, u.linearVelocity.copy(a.linearVelocity)) : u.hasLinearVelocity = !1, a.angularVelocity ? (u.hasAngularVelocity = !0, u.angularVelocity.copy(a.angularVelocity)) : u.hasAngularVelocity = !1));
      l !== null && (s = i.getPose(e.targetRaySpace, n), s === null && a !== null && (s = a), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent(y6)));
    }
    return l !== null && (l.visible = s !== null), u !== null && (u.visible = a !== null), c !== null && (c.visible = o !== null), this;
  }
  // private method
  _getHandJoint(e, i) {
    if (e.joints[i.jointName] === void 0) {
      const n = new al();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[i.jointName] = n, e.add(n);
    }
    return e.joints[i.jointName];
  }
}
const v6 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, b6 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class x6 {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, i, n) {
    if (this.texture === null) {
      const s = new Cn(), a = e.properties.get(s);
      a.__webglTexture = i.texture, (i.depthNear != n.depthNear || i.depthFar != n.depthFar) && (this.depthNear = i.depthNear, this.depthFar = i.depthFar), this.texture = s;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const i = e.cameras[0].viewport, n = new Ss({
        vertexShader: v6,
        fragmentShader: b6,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: i.z },
          depthHeight: { value: i.w }
        }
      });
      this.mesh = new Ur(new Gd(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class _6 extends Nl {
  constructor(e, i) {
    super();
    const n = this;
    let s = null, a = 1, o = null, l = "local-floor", u = 1, c = null, h = null, d = null, p = null, f = null, m = null;
    const v = new x6(), y = i.getContextAttributes();
    let g = null, _ = null;
    const x = [], b = [], T = new Le();
    let S = null;
    const w = new _n();
    w.viewport = new Fi();
    const C = new _n();
    C.viewport = new Fi();
    const E = [w, C], A = new g6();
    let N = null, L = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(G) {
      let Y = x[G];
      return Y === void 0 && (Y = new Hy(), x[G] = Y), Y.getTargetRaySpace();
    }, this.getControllerGrip = function(G) {
      let Y = x[G];
      return Y === void 0 && (Y = new Hy(), x[G] = Y), Y.getGripSpace();
    }, this.getHand = function(G) {
      let Y = x[G];
      return Y === void 0 && (Y = new Hy(), x[G] = Y), Y.getHandSpace();
    };
    function F(G) {
      const Y = b.indexOf(G.inputSource);
      if (Y === -1)
        return;
      const ae = x[Y];
      ae !== void 0 && (ae.update(G.inputSource, G.frame, c || o), ae.dispatchEvent({ type: G.type, data: G.inputSource }));
    }
    function M() {
      s.removeEventListener("select", F), s.removeEventListener("selectstart", F), s.removeEventListener("selectend", F), s.removeEventListener("squeeze", F), s.removeEventListener("squeezestart", F), s.removeEventListener("squeezeend", F), s.removeEventListener("end", M), s.removeEventListener("inputsourceschange", P);
      for (let G = 0; G < x.length; G++) {
        const Y = b[G];
        Y !== null && (b[G] = null, x[G].disconnect(Y));
      }
      N = null, L = null, v.reset(), e.setRenderTarget(g), f = null, p = null, d = null, s = null, _ = null, q.stop(), n.isPresenting = !1, e.setPixelRatio(S), e.setSize(T.width, T.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(G) {
      a = G, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(G) {
      l = G, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || o;
    }, this.setReferenceSpace = function(G) {
      c = G;
    }, this.getBaseLayer = function() {
      return p !== null ? p : f;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return s;
    }, this.setSession = async function(G) {
      if (s = G, s !== null) {
        if (g = e.getRenderTarget(), s.addEventListener("select", F), s.addEventListener("selectstart", F), s.addEventListener("selectend", F), s.addEventListener("squeeze", F), s.addEventListener("squeezestart", F), s.addEventListener("squeezeend", F), s.addEventListener("end", M), s.addEventListener("inputsourceschange", P), y.xrCompatible !== !0 && await i.makeXRCompatible(), S = e.getPixelRatio(), e.getSize(T), s.renderState.layers === void 0) {
          const Y = {
            antialias: y.antialias,
            alpha: !0,
            depth: y.depth,
            stencil: y.stencil,
            framebufferScaleFactor: a
          };
          f = new XRWebGLLayer(s, i, Y), s.updateRenderState({ baseLayer: f }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), _ = new vo(
            f.framebufferWidth,
            f.framebufferHeight,
            {
              format: Kn,
              type: Ta,
              colorSpace: e.outputColorSpace,
              stencilBuffer: y.stencil
            }
          );
        } else {
          let Y = null, ae = null, ue = null;
          y.depth && (ue = y.stencil ? i.DEPTH24_STENCIL8 : i.DEPTH_COMPONENT24, Y = y.stencil ? gc : Wu, ae = y.stencil ? mc : Tl);
          const ge = {
            colorFormat: i.RGBA8,
            depthFormat: ue,
            scaleFactor: a
          };
          d = new XRWebGLBinding(s, i), p = d.createProjectionLayer(ge), s.updateRenderState({ layers: [p] }), e.setPixelRatio(1), e.setSize(p.textureWidth, p.textureHeight, !1), _ = new vo(
            p.textureWidth,
            p.textureHeight,
            {
              format: Kn,
              type: Ta,
              depthTexture: new dR(p.textureWidth, p.textureHeight, ae, void 0, void 0, void 0, void 0, void 0, void 0, Y),
              stencilBuffer: y.stencil,
              colorSpace: e.outputColorSpace,
              samples: y.antialias ? 4 : 0,
              resolveDepthBuffer: p.ignoreDepthValues === !1
            }
          );
        }
        _.isXRRenderTarget = !0, this.setFoveation(u), c = null, o = await s.requestReferenceSpace(l), q.setContext(s), q.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (s !== null)
        return s.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return v.getDepthTexture();
    };
    function P(G) {
      for (let Y = 0; Y < G.removed.length; Y++) {
        const ae = G.removed[Y], ue = b.indexOf(ae);
        ue >= 0 && (b[ue] = null, x[ue].disconnect(ae));
      }
      for (let Y = 0; Y < G.added.length; Y++) {
        const ae = G.added[Y];
        let ue = b.indexOf(ae);
        if (ue === -1) {
          for (let we = 0; we < x.length; we++)
            if (we >= b.length) {
              b.push(ae), ue = we;
              break;
            } else if (b[we] === null) {
              b[we] = ae, ue = we;
              break;
            }
          if (ue === -1) break;
        }
        const ge = x[ue];
        ge && ge.connect(ae);
      }
    }
    const O = new X(), V = new X();
    function B(G, Y, ae) {
      O.setFromMatrixPosition(Y.matrixWorld), V.setFromMatrixPosition(ae.matrixWorld);
      const ue = O.distanceTo(V), ge = Y.projectionMatrix.elements, we = ae.projectionMatrix.elements, Ne = ge[14] / (ge[10] - 1), lt = ge[14] / (ge[10] + 1), be = (ge[9] + 1) / ge[5], vt = (ge[9] - 1) / ge[5], Z = (ge[8] - 1) / ge[0], Vt = (we[8] + 1) / we[0], ct = Ne * Z, xt = Ne * Vt, it = ue / (-Z + Vt), Dt = it * -Z;
      if (Y.matrixWorld.decompose(G.position, G.quaternion, G.scale), G.translateX(Dt), G.translateZ(it), G.matrixWorld.compose(G.position, G.quaternion, G.scale), G.matrixWorldInverse.copy(G.matrixWorld).invert(), ge[10] === -1)
        G.projectionMatrix.copy(Y.projectionMatrix), G.projectionMatrixInverse.copy(Y.projectionMatrixInverse);
      else {
        const at = Ne + it, z = lt + it, D = ct - Dt, le = xt + (ue - Dt), _e = be * lt / z * at, Ae = vt * lt / z * at;
        G.projectionMatrix.makePerspective(D, le, _e, Ae, at, z), G.projectionMatrixInverse.copy(G.projectionMatrix).invert();
      }
    }
    function H(G, Y) {
      Y === null ? G.matrixWorld.copy(G.matrix) : G.matrixWorld.multiplyMatrices(Y.matrixWorld, G.matrix), G.matrixWorldInverse.copy(G.matrixWorld).invert();
    }
    this.updateCamera = function(G) {
      if (s === null) return;
      let Y = G.near, ae = G.far;
      v.texture !== null && (v.depthNear > 0 && (Y = v.depthNear), v.depthFar > 0 && (ae = v.depthFar)), A.near = C.near = w.near = Y, A.far = C.far = w.far = ae, (N !== A.near || L !== A.far) && (s.updateRenderState({
        depthNear: A.near,
        depthFar: A.far
      }), N = A.near, L = A.far), w.layers.mask = G.layers.mask | 2, C.layers.mask = G.layers.mask | 4, A.layers.mask = w.layers.mask | C.layers.mask;
      const ue = G.parent, ge = A.cameras;
      H(A, ue);
      for (let we = 0; we < ge.length; we++)
        H(ge[we], ue);
      ge.length === 2 ? B(A, w, C) : A.projectionMatrix.copy(w.projectionMatrix), U(G, A, ue);
    };
    function U(G, Y, ae) {
      ae === null ? G.matrix.copy(Y.matrixWorld) : (G.matrix.copy(ae.matrixWorld), G.matrix.invert(), G.matrix.multiply(Y.matrixWorld)), G.matrix.decompose(G.position, G.quaternion, G.scale), G.updateMatrixWorld(!0), G.projectionMatrix.copy(Y.projectionMatrix), G.projectionMatrixInverse.copy(Y.projectionMatrixInverse), G.isPerspectiveCamera && (G.fov = hd * 2 * Math.atan(1 / G.projectionMatrix.elements[5]), G.zoom = 1);
    }
    this.getCamera = function() {
      return A;
    }, this.getFoveation = function() {
      if (!(p === null && f === null))
        return u;
    }, this.setFoveation = function(G) {
      u = G, p !== null && (p.fixedFoveation = G), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = G);
    }, this.hasDepthSensing = function() {
      return v.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return v.getMesh(A);
    };
    let j = null;
    function Q(G, Y) {
      if (h = Y.getViewerPose(c || o), m = Y, h !== null) {
        const ae = h.views;
        f !== null && (e.setRenderTargetFramebuffer(_, f.framebuffer), e.setRenderTarget(_));
        let ue = !1;
        ae.length !== A.cameras.length && (A.cameras.length = 0, ue = !0);
        for (let we = 0; we < ae.length; we++) {
          const Ne = ae[we];
          let lt = null;
          if (f !== null)
            lt = f.getViewport(Ne);
          else {
            const vt = d.getViewSubImage(p, Ne);
            lt = vt.viewport, we === 0 && (e.setRenderTargetTextures(
              _,
              vt.colorTexture,
              p.ignoreDepthValues ? void 0 : vt.depthStencilTexture
            ), e.setRenderTarget(_));
          }
          let be = E[we];
          be === void 0 && (be = new _n(), be.layers.enable(we), be.viewport = new Fi(), E[we] = be), be.matrix.fromArray(Ne.transform.matrix), be.matrix.decompose(be.position, be.quaternion, be.scale), be.projectionMatrix.fromArray(Ne.projectionMatrix), be.projectionMatrixInverse.copy(be.projectionMatrix).invert(), be.viewport.set(lt.x, lt.y, lt.width, lt.height), we === 0 && (A.matrix.copy(be.matrix), A.matrix.decompose(A.position, A.quaternion, A.scale)), ue === !0 && A.cameras.push(be);
        }
        const ge = s.enabledFeatures;
        if (ge && ge.includes("depth-sensing")) {
          const we = d.getDepthInformation(ae[0]);
          we && we.isValid && we.texture && v.init(e, we, s.renderState);
        }
      }
      for (let ae = 0; ae < x.length; ae++) {
        const ue = b[ae], ge = x[ae];
        ue !== null && ge !== void 0 && ge.update(ue, Y, c || o);
      }
      j && j(G, Y), Y.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: Y }), m = null;
    }
    const q = new hR();
    q.setAnimationLoop(Q), this.setAnimationLoop = function(G) {
      j = G;
    }, this.dispose = function() {
    };
  }
}
const Lo = /* @__PURE__ */ new bo(), T6 = /* @__PURE__ */ new ui();
function S6(r, e) {
  function i(y, g) {
    y.matrixAutoUpdate === !0 && y.updateMatrix(), g.value.copy(y.matrix);
  }
  function n(y, g) {
    g.color.getRGB(y.fogColor.value, oR(r)), g.isFog ? (y.fogNear.value = g.near, y.fogFar.value = g.far) : g.isFogExp2 && (y.fogDensity.value = g.density);
  }
  function s(y, g, _, x, b) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial ? a(y, g) : g.isMeshToonMaterial ? (a(y, g), d(y, g)) : g.isMeshPhongMaterial ? (a(y, g), h(y, g)) : g.isMeshStandardMaterial ? (a(y, g), p(y, g), g.isMeshPhysicalMaterial && f(y, g, b)) : g.isMeshMatcapMaterial ? (a(y, g), m(y, g)) : g.isMeshDepthMaterial ? a(y, g) : g.isMeshDistanceMaterial ? (a(y, g), v(y, g)) : g.isMeshNormalMaterial ? a(y, g) : g.isLineBasicMaterial ? (o(y, g), g.isLineDashedMaterial && l(y, g)) : g.isPointsMaterial ? u(y, g, _, x) : g.isSpriteMaterial ? c(y, g) : g.isShadowMaterial ? (y.color.value.copy(g.color), y.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function a(y, g) {
    y.opacity.value = g.opacity, g.color && y.diffuse.value.copy(g.color), g.emissive && y.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (y.map.value = g.map, i(g.map, y.mapTransform)), g.alphaMap && (y.alphaMap.value = g.alphaMap, i(g.alphaMap, y.alphaMapTransform)), g.bumpMap && (y.bumpMap.value = g.bumpMap, i(g.bumpMap, y.bumpMapTransform), y.bumpScale.value = g.bumpScale, g.side === Mr && (y.bumpScale.value *= -1)), g.normalMap && (y.normalMap.value = g.normalMap, i(g.normalMap, y.normalMapTransform), y.normalScale.value.copy(g.normalScale), g.side === Mr && y.normalScale.value.negate()), g.displacementMap && (y.displacementMap.value = g.displacementMap, i(g.displacementMap, y.displacementMapTransform), y.displacementScale.value = g.displacementScale, y.displacementBias.value = g.displacementBias), g.emissiveMap && (y.emissiveMap.value = g.emissiveMap, i(g.emissiveMap, y.emissiveMapTransform)), g.specularMap && (y.specularMap.value = g.specularMap, i(g.specularMap, y.specularMapTransform)), g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
    const _ = e.get(g), x = _.envMap, b = _.envMapRotation;
    x && (y.envMap.value = x, Lo.copy(b), Lo.x *= -1, Lo.y *= -1, Lo.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === !1 && (Lo.y *= -1, Lo.z *= -1), y.envMapRotation.value.setFromMatrix4(T6.makeRotationFromEuler(Lo)), y.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, y.reflectivity.value = g.reflectivity, y.ior.value = g.ior, y.refractionRatio.value = g.refractionRatio), g.lightMap && (y.lightMap.value = g.lightMap, y.lightMapIntensity.value = g.lightMapIntensity, i(g.lightMap, y.lightMapTransform)), g.aoMap && (y.aoMap.value = g.aoMap, y.aoMapIntensity.value = g.aoMapIntensity, i(g.aoMap, y.aoMapTransform));
  }
  function o(y, g) {
    y.diffuse.value.copy(g.color), y.opacity.value = g.opacity, g.map && (y.map.value = g.map, i(g.map, y.mapTransform));
  }
  function l(y, g) {
    y.dashSize.value = g.dashSize, y.totalSize.value = g.dashSize + g.gapSize, y.scale.value = g.scale;
  }
  function u(y, g, _, x) {
    y.diffuse.value.copy(g.color), y.opacity.value = g.opacity, y.size.value = g.size * _, y.scale.value = x * 0.5, g.map && (y.map.value = g.map, i(g.map, y.uvTransform)), g.alphaMap && (y.alphaMap.value = g.alphaMap, i(g.alphaMap, y.alphaMapTransform)), g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
  }
  function c(y, g) {
    y.diffuse.value.copy(g.color), y.opacity.value = g.opacity, y.rotation.value = g.rotation, g.map && (y.map.value = g.map, i(g.map, y.mapTransform)), g.alphaMap && (y.alphaMap.value = g.alphaMap, i(g.alphaMap, y.alphaMapTransform)), g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
  }
  function h(y, g) {
    y.specular.value.copy(g.specular), y.shininess.value = Math.max(g.shininess, 1e-4);
  }
  function d(y, g) {
    g.gradientMap && (y.gradientMap.value = g.gradientMap);
  }
  function p(y, g) {
    y.metalness.value = g.metalness, g.metalnessMap && (y.metalnessMap.value = g.metalnessMap, i(g.metalnessMap, y.metalnessMapTransform)), y.roughness.value = g.roughness, g.roughnessMap && (y.roughnessMap.value = g.roughnessMap, i(g.roughnessMap, y.roughnessMapTransform)), g.envMap && (y.envMapIntensity.value = g.envMapIntensity);
  }
  function f(y, g, _) {
    y.ior.value = g.ior, g.sheen > 0 && (y.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), y.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (y.sheenColorMap.value = g.sheenColorMap, i(g.sheenColorMap, y.sheenColorMapTransform)), g.sheenRoughnessMap && (y.sheenRoughnessMap.value = g.sheenRoughnessMap, i(g.sheenRoughnessMap, y.sheenRoughnessMapTransform))), g.clearcoat > 0 && (y.clearcoat.value = g.clearcoat, y.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (y.clearcoatMap.value = g.clearcoatMap, i(g.clearcoatMap, y.clearcoatMapTransform)), g.clearcoatRoughnessMap && (y.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap, i(g.clearcoatRoughnessMap, y.clearcoatRoughnessMapTransform)), g.clearcoatNormalMap && (y.clearcoatNormalMap.value = g.clearcoatNormalMap, i(g.clearcoatNormalMap, y.clearcoatNormalMapTransform), y.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === Mr && y.clearcoatNormalScale.value.negate())), g.dispersion > 0 && (y.dispersion.value = g.dispersion), g.iridescence > 0 && (y.iridescence.value = g.iridescence, y.iridescenceIOR.value = g.iridescenceIOR, y.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], y.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (y.iridescenceMap.value = g.iridescenceMap, i(g.iridescenceMap, y.iridescenceMapTransform)), g.iridescenceThicknessMap && (y.iridescenceThicknessMap.value = g.iridescenceThicknessMap, i(g.iridescenceThicknessMap, y.iridescenceThicknessMapTransform))), g.transmission > 0 && (y.transmission.value = g.transmission, y.transmissionSamplerMap.value = _.texture, y.transmissionSamplerSize.value.set(_.width, _.height), g.transmissionMap && (y.transmissionMap.value = g.transmissionMap, i(g.transmissionMap, y.transmissionMapTransform)), y.thickness.value = g.thickness, g.thicknessMap && (y.thicknessMap.value = g.thicknessMap, i(g.thicknessMap, y.thicknessMapTransform)), y.attenuationDistance.value = g.attenuationDistance, y.attenuationColor.value.copy(g.attenuationColor)), g.anisotropy > 0 && (y.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && (y.anisotropyMap.value = g.anisotropyMap, i(g.anisotropyMap, y.anisotropyMapTransform))), y.specularIntensity.value = g.specularIntensity, y.specularColor.value.copy(g.specularColor), g.specularColorMap && (y.specularColorMap.value = g.specularColorMap, i(g.specularColorMap, y.specularColorMapTransform)), g.specularIntensityMap && (y.specularIntensityMap.value = g.specularIntensityMap, i(g.specularIntensityMap, y.specularIntensityMapTransform));
  }
  function m(y, g) {
    g.matcap && (y.matcap.value = g.matcap);
  }
  function v(y, g) {
    const _ = e.get(g).light;
    y.referencePosition.value.setFromMatrixPosition(_.matrixWorld), y.nearDistance.value = _.shadow.camera.near, y.farDistance.value = _.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: s
  };
}
function w6(r, e, i, n) {
  let s = {}, a = {}, o = [];
  const l = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
  function u(_, x) {
    const b = x.program;
    n.uniformBlockBinding(_, b);
  }
  function c(_, x) {
    let b = s[_.id];
    b === void 0 && (m(_), b = h(_), s[_.id] = b, _.addEventListener("dispose", y));
    const T = x.program;
    n.updateUBOMapping(_, T);
    const S = e.render.frame;
    a[_.id] !== S && (p(_), a[_.id] = S);
  }
  function h(_) {
    const x = d();
    _.__bindingPointIndex = x;
    const b = r.createBuffer(), T = _.__size, S = _.usage;
    return r.bindBuffer(r.UNIFORM_BUFFER, b), r.bufferData(r.UNIFORM_BUFFER, T, S), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, x, b), b;
  }
  function d() {
    for (let _ = 0; _ < l; _++)
      if (o.indexOf(_) === -1)
        return o.push(_), _;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function p(_) {
    const x = s[_.id], b = _.uniforms, T = _.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, x);
    for (let S = 0, w = b.length; S < w; S++) {
      const C = Array.isArray(b[S]) ? b[S] : [b[S]];
      for (let E = 0, A = C.length; E < A; E++) {
        const N = C[E];
        if (f(N, S, E, T) === !0) {
          const L = N.__offset, F = Array.isArray(N.value) ? N.value : [N.value];
          let M = 0;
          for (let P = 0; P < F.length; P++) {
            const O = F[P], V = v(O);
            typeof O == "number" || typeof O == "boolean" ? (N.__data[0] = O, r.bufferSubData(r.UNIFORM_BUFFER, L + M, N.__data)) : O.isMatrix3 ? (N.__data[0] = O.elements[0], N.__data[1] = O.elements[1], N.__data[2] = O.elements[2], N.__data[3] = 0, N.__data[4] = O.elements[3], N.__data[5] = O.elements[4], N.__data[6] = O.elements[5], N.__data[7] = 0, N.__data[8] = O.elements[6], N.__data[9] = O.elements[7], N.__data[10] = O.elements[8], N.__data[11] = 0) : (O.toArray(N.__data, M), M += V.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          r.bufferSubData(r.UNIFORM_BUFFER, L, N.__data);
        }
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function f(_, x, b, T) {
    const S = _.value, w = x + "_" + b;
    if (T[w] === void 0)
      return typeof S == "number" || typeof S == "boolean" ? T[w] = S : T[w] = S.clone(), !0;
    {
      const C = T[w];
      if (typeof S == "number" || typeof S == "boolean") {
        if (C !== S)
          return T[w] = S, !0;
      } else if (C.equals(S) === !1)
        return C.copy(S), !0;
    }
    return !1;
  }
  function m(_) {
    const x = _.uniforms;
    let b = 0;
    const T = 16;
    for (let w = 0, C = x.length; w < C; w++) {
      const E = Array.isArray(x[w]) ? x[w] : [x[w]];
      for (let A = 0, N = E.length; A < N; A++) {
        const L = E[A], F = Array.isArray(L.value) ? L.value : [L.value];
        for (let M = 0, P = F.length; M < P; M++) {
          const O = F[M], V = v(O), B = b % T, H = B % V.boundary, U = B + H;
          b += H, U !== 0 && T - U < V.storage && (b += T - U), L.__data = new Float32Array(V.storage / Float32Array.BYTES_PER_ELEMENT), L.__offset = b, b += V.storage;
        }
      }
    }
    const S = b % T;
    return S > 0 && (b += T - S), _.__size = b, _.__cache = {}, this;
  }
  function v(_) {
    const x = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof _ == "number" || typeof _ == "boolean" ? (x.boundary = 4, x.storage = 4) : _.isVector2 ? (x.boundary = 8, x.storage = 8) : _.isVector3 || _.isColor ? (x.boundary = 16, x.storage = 12) : _.isVector4 ? (x.boundary = 16, x.storage = 16) : _.isMatrix3 ? (x.boundary = 48, x.storage = 48) : _.isMatrix4 ? (x.boundary = 64, x.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), x;
  }
  function y(_) {
    const x = _.target;
    x.removeEventListener("dispose", y);
    const b = o.indexOf(x.__bindingPointIndex);
    o.splice(b, 1), r.deleteBuffer(s[x.id]), delete s[x.id], delete a[x.id];
  }
  function g() {
    for (const _ in s)
      r.deleteBuffer(s[_]);
    o = [], s = {}, a = {};
  }
  return {
    bind: u,
    update: c,
    dispose: g
  };
}
class E6 {
  constructor(e = {}) {
    const {
      canvas: i = fB(),
      context: n = null,
      depth: s = !0,
      stencil: a = !1,
      alpha: o = !1,
      antialias: l = !1,
      premultipliedAlpha: u = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: d = !1,
      reverseDepthBuffer: p = !1
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    if (n !== null) {
      if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      f = n.getContextAttributes().alpha;
    } else
      f = o;
    const m = new Uint32Array(4), v = new Int32Array(4);
    let y = null, g = null;
    const _ = [], x = [];
    this.domElement = i, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = ln, this.toneMapping = co, this.toneMappingExposure = 1;
    const b = this;
    let T = !1, S = 0, w = 0, C = null, E = -1, A = null;
    const N = new Fi(), L = new Fi();
    let F = null;
    const M = new Ft(0);
    let P = 0, O = i.width, V = i.height, B = 1, H = null, U = null;
    const j = new Fi(0, 0, O, V), Q = new Fi(0, 0, O, V);
    let q = !1;
    const G = new I_();
    let Y = !1, ae = !1;
    const ue = new ui(), ge = new ui(), we = new X(), Ne = new Fi(), lt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let be = !1;
    function vt() {
      return C === null ? B : 1;
    }
    let Z = n;
    function Vt(k, W) {
      return i.getContext(k, W);
    }
    try {
      const k = {
        alpha: !0,
        depth: s,
        stencil: a,
        antialias: l,
        premultipliedAlpha: u,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: d
      };
      if ("setAttribute" in i && i.setAttribute("data-engine", `three.js r${mg}`), i.addEventListener("webglcontextlost", Se, !1), i.addEventListener("webglcontextrestored", Ve, !1), i.addEventListener("webglcontextcreationerror", Ue, !1), Z === null) {
        const W = "webgl2";
        if (Z = Vt(W, k), Z === null)
          throw Vt(W) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (k) {
      throw console.error("THREE.WebGLRenderer: " + k.message), k;
    }
    let ct, xt, it, Dt, at, z, D, le, _e, Ae, xe, Qe, ze, je, St, Pe, Ye, ut, Fe, Xe, Ct, mt, kt, J;
    function Oe() {
      ct = new N4(Z), ct.init(), mt = new m6(Z, ct), xt = new w4(Z, ct, e, mt), it = new d6(Z, ct), xt.reverseDepthBuffer && p && it.buffers.depth.setReversed(!0), Dt = new I4(Z), at = new Qj(), z = new f6(Z, ct, it, at, xt, mt, Dt), D = new M4(b), le = new R4(b), _e = new zB(Z), kt = new T4(Z, _e), Ae = new P4(Z, _e, Dt, kt), xe = new k4(Z, Ae, _e, Dt), Fe = new D4(Z, xt, z), Pe = new E4(at), Qe = new Kj(b, D, le, ct, xt, kt, Pe), ze = new S6(b, at), je = new Jj(), St = new s6(ct), ut = new _4(b, D, le, it, xe, f, u), Ye = new c6(b, xe, xt), J = new w6(Z, Dt, xt, it), Xe = new S4(Z, ct, Dt), Ct = new O4(Z, ct, Dt), Dt.programs = Qe.programs, b.capabilities = xt, b.extensions = ct, b.properties = at, b.renderLists = je, b.shadowMap = Ye, b.state = it, b.info = Dt;
    }
    Oe();
    const de = new _6(b, Z);
    this.xr = de, this.getContext = function() {
      return Z;
    }, this.getContextAttributes = function() {
      return Z.getContextAttributes();
    }, this.forceContextLoss = function() {
      const k = ct.get("WEBGL_lose_context");
      k && k.loseContext();
    }, this.forceContextRestore = function() {
      const k = ct.get("WEBGL_lose_context");
      k && k.restoreContext();
    }, this.getPixelRatio = function() {
      return B;
    }, this.setPixelRatio = function(k) {
      k !== void 0 && (B = k, this.setSize(O, V, !1));
    }, this.getSize = function(k) {
      return k.set(O, V);
    }, this.setSize = function(k, W, te = !0) {
      if (de.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      O = k, V = W, i.width = Math.floor(k * B), i.height = Math.floor(W * B), te === !0 && (i.style.width = k + "px", i.style.height = W + "px"), this.setViewport(0, 0, k, W);
    }, this.getDrawingBufferSize = function(k) {
      return k.set(O * B, V * B).floor();
    }, this.setDrawingBufferSize = function(k, W, te) {
      O = k, V = W, B = te, i.width = Math.floor(k * te), i.height = Math.floor(W * te), this.setViewport(0, 0, k, W);
    }, this.getCurrentViewport = function(k) {
      return k.copy(N);
    }, this.getViewport = function(k) {
      return k.copy(j);
    }, this.setViewport = function(k, W, te, se) {
      k.isVector4 ? j.set(k.x, k.y, k.z, k.w) : j.set(k, W, te, se), it.viewport(N.copy(j).multiplyScalar(B).round());
    }, this.getScissor = function(k) {
      return k.copy(Q);
    }, this.setScissor = function(k, W, te, se) {
      k.isVector4 ? Q.set(k.x, k.y, k.z, k.w) : Q.set(k, W, te, se), it.scissor(L.copy(Q).multiplyScalar(B).round());
    }, this.getScissorTest = function() {
      return q;
    }, this.setScissorTest = function(k) {
      it.setScissorTest(q = k);
    }, this.setOpaqueSort = function(k) {
      H = k;
    }, this.setTransparentSort = function(k) {
      U = k;
    }, this.getClearColor = function(k) {
      return k.copy(ut.getClearColor());
    }, this.setClearColor = function() {
      ut.setClearColor.apply(ut, arguments);
    }, this.getClearAlpha = function() {
      return ut.getClearAlpha();
    }, this.setClearAlpha = function() {
      ut.setClearAlpha.apply(ut, arguments);
    }, this.clear = function(k = !0, W = !0, te = !0) {
      let se = 0;
      if (k) {
        let K = !1;
        if (C !== null) {
          const Ee = C.texture.format;
          K = Ee === R_ || Ee === C_ || Ee === A_;
        }
        if (K) {
          const Ee = C.texture.type, Re = Ee === Ta || Ee === Tl || Ee === cd || Ee === mc || Ee === E_ || Ee === M_, Ke = ut.getClearColor(), tt = ut.getClearAlpha(), yt = Ke.r, wt = Ke.g, dt = Ke.b;
          Re ? (m[0] = yt, m[1] = wt, m[2] = dt, m[3] = tt, Z.clearBufferuiv(Z.COLOR, 0, m)) : (v[0] = yt, v[1] = wt, v[2] = dt, v[3] = tt, Z.clearBufferiv(Z.COLOR, 0, v));
        } else
          se |= Z.COLOR_BUFFER_BIT;
      }
      W && (se |= Z.DEPTH_BUFFER_BIT), te && (se |= Z.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Z.clear(se);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      i.removeEventListener("webglcontextlost", Se, !1), i.removeEventListener("webglcontextrestored", Ve, !1), i.removeEventListener("webglcontextcreationerror", Ue, !1), je.dispose(), St.dispose(), at.dispose(), D.dispose(), le.dispose(), xe.dispose(), kt.dispose(), J.dispose(), Qe.dispose(), de.dispose(), de.removeEventListener("sessionstart", Na), de.removeEventListener("sessionend", Pa), Rn.stop();
    };
    function Se(k) {
      k.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), T = !0;
    }
    function Ve() {
      console.log("THREE.WebGLRenderer: Context Restored."), T = !1;
      const k = Dt.autoReset, W = Ye.enabled, te = Ye.autoUpdate, se = Ye.needsUpdate, K = Ye.type;
      Oe(), Dt.autoReset = k, Ye.enabled = W, Ye.autoUpdate = te, Ye.needsUpdate = se, Ye.type = K;
    }
    function Ue(k) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", k.statusMessage);
    }
    function Rt(k) {
      const W = k.target;
      W.removeEventListener("dispose", Rt), si(W);
    }
    function si(k) {
      _i(k), at.remove(k);
    }
    function _i(k) {
      const W = at.get(k).programs;
      W !== void 0 && (W.forEach(function(te) {
        Qe.releaseProgram(te);
      }), k.isShaderMaterial && Qe.releaseShaderCache(k));
    }
    this.renderBufferDirect = function(k, W, te, se, K, Ee) {
      W === null && (W = lt);
      const Re = K.isMesh && K.matrixWorld.determinant() < 0, Ke = nt(k, W, te, se, K);
      it.setMaterial(se, Re);
      let tt = te.index, yt = 1;
      if (se.wireframe === !0) {
        if (tt = Ae.getWireframeAttribute(te), tt === void 0) return;
        yt = 2;
      }
      const wt = te.drawRange, dt = te.attributes.position;
      let Ht = wt.start * yt, ci = (wt.start + wt.count) * yt;
      Ee !== null && (Ht = Math.max(Ht, Ee.start * yt), ci = Math.min(ci, (Ee.start + Ee.count) * yt)), tt !== null ? (Ht = Math.max(Ht, 0), ci = Math.min(ci, tt.count)) : dt != null && (Ht = Math.max(Ht, 0), ci = Math.min(ci, dt.count));
      const hi = ci - Ht;
      if (hi < 0 || hi === 1 / 0) return;
      kt.setup(K, se, Ke, te, tt);
      let Ni, di = Xe;
      if (tt !== null && (Ni = _e.get(tt), di = Ct, di.setIndex(Ni)), K.isMesh)
        se.wireframe === !0 ? (it.setLineWidth(se.wireframeLinewidth * vt()), di.setMode(Z.LINES)) : di.setMode(Z.TRIANGLES);
      else if (K.isLine) {
        let ot = se.linewidth;
        ot === void 0 && (ot = 1), it.setLineWidth(ot * vt()), K.isLineSegments ? di.setMode(Z.LINES) : K.isLineLoop ? di.setMode(Z.LINE_LOOP) : di.setMode(Z.LINE_STRIP);
      } else K.isPoints ? di.setMode(Z.POINTS) : K.isSprite && di.setMode(Z.TRIANGLES);
      if (K.isBatchedMesh)
        if (K._multiDrawInstances !== null)
          di.renderMultiDrawInstances(K._multiDrawStarts, K._multiDrawCounts, K._multiDrawCount, K._multiDrawInstances);
        else if (ct.get("WEBGL_multi_draw"))
          di.renderMultiDraw(K._multiDrawStarts, K._multiDrawCounts, K._multiDrawCount);
        else {
          const ot = K._multiDrawStarts, Ro = K._multiDrawCounts, No = K._multiDrawCount, Nn = tt ? _e.get(tt).bytesPerElement : 1, zl = at.get(se).currentProgram.getUniforms();
          for (let Qr = 0; Qr < No; Qr++)
            zl.setValue(Z, "_gl_DrawID", Qr), di.render(ot[Qr] / Nn, Ro[Qr]);
        }
      else if (K.isInstancedMesh)
        di.renderInstances(Ht, hi, K.count);
      else if (te.isInstancedBufferGeometry) {
        const ot = te._maxInstanceCount !== void 0 ? te._maxInstanceCount : 1 / 0, Ro = Math.min(te.instanceCount, ot);
        di.renderInstances(Ht, hi, Ro);
      } else
        di.render(Ht, hi);
    };
    function Bt(k, W, te) {
      k.transparent === !0 && k.side === ea && k.forceSinglePass === !1 ? (k.side = Mr, k.needsUpdate = !0, ce(k, W, te), k.side = yo, k.needsUpdate = !0, ce(k, W, te), k.side = ea) : ce(k, W, te);
    }
    this.compile = function(k, W, te = null) {
      te === null && (te = k), g = St.get(te), g.init(W), x.push(g), te.traverseVisible(function(K) {
        K.isLight && K.layers.test(W.layers) && (g.pushLight(K), K.castShadow && g.pushShadow(K));
      }), k !== te && k.traverseVisible(function(K) {
        K.isLight && K.layers.test(W.layers) && (g.pushLight(K), K.castShadow && g.pushShadow(K));
      }), g.setupLights();
      const se = /* @__PURE__ */ new Set();
      return k.traverse(function(K) {
        if (!(K.isMesh || K.isPoints || K.isLine || K.isSprite))
          return;
        const Ee = K.material;
        if (Ee)
          if (Array.isArray(Ee))
            for (let Re = 0; Re < Ee.length; Re++) {
              const Ke = Ee[Re];
              Bt(Ke, te, K), se.add(Ke);
            }
          else
            Bt(Ee, te, K), se.add(Ee);
      }), x.pop(), g = null, se;
    }, this.compileAsync = function(k, W, te = null) {
      const se = this.compile(k, W, te);
      return new Promise((K) => {
        function Ee() {
          if (se.forEach(function(Re) {
            at.get(Re).currentProgram.isReady() && se.delete(Re);
          }), se.size === 0) {
            K(k);
            return;
          }
          setTimeout(Ee, 10);
        }
        ct.get("KHR_parallel_shader_compile") !== null ? Ee() : setTimeout(Ee, 10);
      });
    };
    let yr = null;
    function Kr(k) {
      yr && yr(k);
    }
    function Na() {
      Rn.stop();
    }
    function Pa() {
      Rn.start();
    }
    const Rn = new hR();
    Rn.setAnimationLoop(Kr), typeof self < "u" && Rn.setContext(self), this.setAnimationLoop = function(k) {
      yr = k, de.setAnimationLoop(k), k === null ? Rn.stop() : Rn.start();
    }, de.addEventListener("sessionstart", Na), de.addEventListener("sessionend", Pa), this.render = function(k, W) {
      if (W !== void 0 && W.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (T === !0) return;
      if (k.matrixWorldAutoUpdate === !0 && k.updateMatrixWorld(), W.parent === null && W.matrixWorldAutoUpdate === !0 && W.updateMatrixWorld(), de.enabled === !0 && de.isPresenting === !0 && (de.cameraAutoUpdate === !0 && de.updateCamera(W), W = de.getCamera()), k.isScene === !0 && k.onBeforeRender(b, k, W, C), g = St.get(k, x.length), g.init(W), x.push(g), ge.multiplyMatrices(W.projectionMatrix, W.matrixWorldInverse), G.setFromProjectionMatrix(ge), ae = this.localClippingEnabled, Y = Pe.init(this.clippingPlanes, ae), y = je.get(k, _.length), y.init(), _.push(y), de.enabled === !0 && de.isPresenting === !0) {
        const Ee = b.xr.getDepthSensingMesh();
        Ee !== null && Co(Ee, W, -1 / 0, b.sortObjects);
      }
      Co(k, W, 0, b.sortObjects), y.finish(), b.sortObjects === !0 && y.sort(H, U), be = de.enabled === !1 || de.isPresenting === !1 || de.hasDepthSensing() === !1, be && ut.addToRenderList(y, k), this.info.render.frame++, Y === !0 && Pe.beginShadows();
      const te = g.state.shadowsArray;
      Ye.render(te, k, W), Y === !0 && Pe.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const se = y.opaque, K = y.transmissive;
      if (g.setupLights(), W.isArrayCamera) {
        const Ee = W.cameras;
        if (K.length > 0)
          for (let Re = 0, Ke = Ee.length; Re < Ke; Re++) {
            const tt = Ee[Re];
            Bl(se, K, k, tt);
          }
        be && ut.render(k);
        for (let Re = 0, Ke = Ee.length; Re < Ke; Re++) {
          const tt = Ee[Re];
          Fl(y, k, tt, tt.viewport);
        }
      } else
        K.length > 0 && Bl(se, K, k, W), be && ut.render(k), Fl(y, k, W);
      C !== null && (z.updateMultisampleRenderTarget(C), z.updateRenderTargetMipmap(C)), k.isScene === !0 && k.onAfterRender(b, k, W), kt.resetDefaultState(), E = -1, A = null, x.pop(), x.length > 0 ? (g = x[x.length - 1], Y === !0 && Pe.setGlobalState(b.clippingPlanes, g.state.camera)) : g = null, _.pop(), _.length > 0 ? y = _[_.length - 1] : y = null;
    };
    function Co(k, W, te, se) {
      if (k.visible === !1) return;
      if (k.layers.test(W.layers)) {
        if (k.isGroup)
          te = k.renderOrder;
        else if (k.isLOD)
          k.autoUpdate === !0 && k.update(W);
        else if (k.isLight)
          g.pushLight(k), k.castShadow && g.pushShadow(k);
        else if (k.isSprite) {
          if (!k.frustumCulled || G.intersectsSprite(k)) {
            se && Ne.setFromMatrixPosition(k.matrixWorld).applyMatrix4(ge);
            const Ee = xe.update(k), Re = k.material;
            Re.visible && y.push(k, Ee, Re, te, Ne.z, null);
          }
        } else if ((k.isMesh || k.isLine || k.isPoints) && (!k.frustumCulled || G.intersectsObject(k))) {
          const Ee = xe.update(k), Re = k.material;
          if (se && (k.boundingSphere !== void 0 ? (k.boundingSphere === null && k.computeBoundingSphere(), Ne.copy(k.boundingSphere.center)) : (Ee.boundingSphere === null && Ee.computeBoundingSphere(), Ne.copy(Ee.boundingSphere.center)), Ne.applyMatrix4(k.matrixWorld).applyMatrix4(ge)), Array.isArray(Re)) {
            const Ke = Ee.groups;
            for (let tt = 0, yt = Ke.length; tt < yt; tt++) {
              const wt = Ke[tt], dt = Re[wt.materialIndex];
              dt && dt.visible && y.push(k, Ee, dt, te, Ne.z, wt);
            }
          } else Re.visible && y.push(k, Ee, Re, te, Ne.z, null);
        }
      }
      const K = k.children;
      for (let Ee = 0, Re = K.length; Ee < Re; Ee++)
        Co(K[Ee], W, te, se);
    }
    function Fl(k, W, te, se) {
      const K = k.opaque, Ee = k.transmissive, Re = k.transparent;
      g.setupLightsView(te), Y === !0 && Pe.setGlobalState(b.clippingPlanes, te), se && it.viewport(N.copy(se)), K.length > 0 && R(K, W, te), Ee.length > 0 && R(Ee, W, te), Re.length > 0 && R(Re, W, te), it.buffers.depth.setTest(!0), it.buffers.depth.setMask(!0), it.buffers.color.setMask(!0), it.setPolygonOffset(!1);
    }
    function Bl(k, W, te, se) {
      if ((te.isScene === !0 ? te.overrideMaterial : null) !== null)
        return;
      g.state.transmissionRenderTarget[se.id] === void 0 && (g.state.transmissionRenderTarget[se.id] = new vo(1, 1, {
        generateMipmaps: !0,
        type: ct.has("EXT_color_buffer_half_float") || ct.has("EXT_color_buffer_float") ? Dc : Ta,
        minFilter: sl,
        samples: 4,
        stencilBuffer: a,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: Gt.workingColorSpace
      }));
      const K = g.state.transmissionRenderTarget[se.id], Ee = se.viewport || N;
      K.setSize(Ee.z, Ee.w);
      const Re = b.getRenderTarget();
      b.setRenderTarget(K), b.getClearColor(M), P = b.getClearAlpha(), P < 1 && b.setClearColor(16777215, 0.5), b.clear(), be && ut.render(te);
      const Ke = b.toneMapping;
      b.toneMapping = co;
      const tt = se.viewport;
      if (se.viewport !== void 0 && (se.viewport = void 0), g.setupLightsView(se), Y === !0 && Pe.setGlobalState(b.clippingPlanes, se), R(k, te, se), z.updateMultisampleRenderTarget(K), z.updateRenderTargetMipmap(K), ct.has("WEBGL_multisampled_render_to_texture") === !1) {
        let yt = !1;
        for (let wt = 0, dt = W.length; wt < dt; wt++) {
          const Ht = W[wt], ci = Ht.object, hi = Ht.geometry, Ni = Ht.material, di = Ht.group;
          if (Ni.side === ea && ci.layers.test(se.layers)) {
            const ot = Ni.side;
            Ni.side = Mr, Ni.needsUpdate = !0, ee(ci, te, se, hi, Ni, di), Ni.side = ot, Ni.needsUpdate = !0, yt = !0;
          }
        }
        yt === !0 && (z.updateMultisampleRenderTarget(K), z.updateRenderTargetMipmap(K));
      }
      b.setRenderTarget(Re), b.setClearColor(M, P), tt !== void 0 && (se.viewport = tt), b.toneMapping = Ke;
    }
    function R(k, W, te) {
      const se = W.isScene === !0 ? W.overrideMaterial : null;
      for (let K = 0, Ee = k.length; K < Ee; K++) {
        const Re = k[K], Ke = Re.object, tt = Re.geometry, yt = se === null ? Re.material : se, wt = Re.group;
        Ke.layers.test(te.layers) && ee(Ke, W, te, tt, yt, wt);
      }
    }
    function ee(k, W, te, se, K, Ee) {
      k.onBeforeRender(b, W, te, se, K, Ee), k.modelViewMatrix.multiplyMatrices(te.matrixWorldInverse, k.matrixWorld), k.normalMatrix.getNormalMatrix(k.modelViewMatrix), K.onBeforeRender(b, W, te, se, k, Ee), K.transparent === !0 && K.side === ea && K.forceSinglePass === !1 ? (K.side = Mr, K.needsUpdate = !0, b.renderBufferDirect(te, W, se, K, k, Ee), K.side = yo, K.needsUpdate = !0, b.renderBufferDirect(te, W, se, K, k, Ee), K.side = ea) : b.renderBufferDirect(te, W, se, K, k, Ee), k.onAfterRender(b, W, te, se, K, Ee);
    }
    function ce(k, W, te) {
      W.isScene !== !0 && (W = lt);
      const se = at.get(k), K = g.state.lights, Ee = g.state.shadowsArray, Re = K.state.version, Ke = Qe.getParameters(k, K.state, Ee, W, te), tt = Qe.getProgramCacheKey(Ke);
      let yt = se.programs;
      se.environment = k.isMeshStandardMaterial ? W.environment : null, se.fog = W.fog, se.envMap = (k.isMeshStandardMaterial ? le : D).get(k.envMap || se.environment), se.envMapRotation = se.environment !== null && k.envMap === null ? W.environmentRotation : k.envMapRotation, yt === void 0 && (k.addEventListener("dispose", Rt), yt = /* @__PURE__ */ new Map(), se.programs = yt);
      let wt = yt.get(tt);
      if (wt !== void 0) {
        if (se.currentProgram === wt && se.lightsStateVersion === Re)
          return Ze(k, Ke), wt;
      } else
        Ke.uniforms = Qe.getUniforms(k), k.onBeforeCompile(Ke, b), wt = Qe.acquireProgram(Ke, tt), yt.set(tt, wt), se.uniforms = Ke.uniforms;
      const dt = se.uniforms;
      return (!k.isShaderMaterial && !k.isRawShaderMaterial || k.clipping === !0) && (dt.clippingPlanes = Pe.uniform), Ze(k, Ke), se.needsLights = We(k), se.lightsStateVersion = Re, se.needsLights && (dt.ambientLightColor.value = K.state.ambient, dt.lightProbe.value = K.state.probe, dt.directionalLights.value = K.state.directional, dt.directionalLightShadows.value = K.state.directionalShadow, dt.spotLights.value = K.state.spot, dt.spotLightShadows.value = K.state.spotShadow, dt.rectAreaLights.value = K.state.rectArea, dt.ltc_1.value = K.state.rectAreaLTC1, dt.ltc_2.value = K.state.rectAreaLTC2, dt.pointLights.value = K.state.point, dt.pointLightShadows.value = K.state.pointShadow, dt.hemisphereLights.value = K.state.hemi, dt.directionalShadowMap.value = K.state.directionalShadowMap, dt.directionalShadowMatrix.value = K.state.directionalShadowMatrix, dt.spotShadowMap.value = K.state.spotShadowMap, dt.spotLightMatrix.value = K.state.spotLightMatrix, dt.spotLightMap.value = K.state.spotLightMap, dt.pointShadowMap.value = K.state.pointShadowMap, dt.pointShadowMatrix.value = K.state.pointShadowMatrix), se.currentProgram = wt, se.uniformsList = null, wt;
    }
    function Ce(k) {
      if (k.uniformsList === null) {
        const W = k.currentProgram.getUniforms();
        k.uniformsList = Qf.seqWithValue(W.seq, k.uniforms);
      }
      return k.uniformsList;
    }
    function Ze(k, W) {
      const te = at.get(k);
      te.outputColorSpace = W.outputColorSpace, te.batching = W.batching, te.batchingColor = W.batchingColor, te.instancing = W.instancing, te.instancingColor = W.instancingColor, te.instancingMorph = W.instancingMorph, te.skinning = W.skinning, te.morphTargets = W.morphTargets, te.morphNormals = W.morphNormals, te.morphColors = W.morphColors, te.morphTargetsCount = W.morphTargetsCount, te.numClippingPlanes = W.numClippingPlanes, te.numIntersection = W.numClipIntersection, te.vertexAlphas = W.vertexAlphas, te.vertexTangents = W.vertexTangents, te.toneMapping = W.toneMapping;
    }
    function nt(k, W, te, se, K) {
      W.isScene !== !0 && (W = lt), z.resetTextureUnits();
      const Ee = W.fog, Re = se.isMeshStandardMaterial ? W.environment : null, Ke = C === null ? b.outputColorSpace : C.isXRRenderTarget === !0 ? C.texture.colorSpace : kc, tt = (se.isMeshStandardMaterial ? le : D).get(se.envMap || Re), yt = se.vertexColors === !0 && !!te.attributes.color && te.attributes.color.itemSize === 4, wt = !!te.attributes.tangent && (!!se.normalMap || se.anisotropy > 0), dt = !!te.morphAttributes.position, Ht = !!te.morphAttributes.normal, ci = !!te.morphAttributes.color;
      let hi = co;
      se.toneMapped && (C === null || C.isXRRenderTarget === !0) && (hi = b.toneMapping);
      const Ni = te.morphAttributes.position || te.morphAttributes.normal || te.morphAttributes.color, di = Ni !== void 0 ? Ni.length : 0, ot = at.get(se), Ro = g.state.lights;
      if (Y === !0 && (ae === !0 || k !== A)) {
        const Or = k === A && se.id === E;
        Pe.setState(se, k, Or);
      }
      let No = !1;
      se.version === ot.__version ? (ot.needsLights && ot.lightsStateVersion !== Ro.state.version || ot.outputColorSpace !== Ke || K.isBatchedMesh && ot.batching === !1 || !K.isBatchedMesh && ot.batching === !0 || K.isBatchedMesh && ot.batchingColor === !0 && K.colorTexture === null || K.isBatchedMesh && ot.batchingColor === !1 && K.colorTexture !== null || K.isInstancedMesh && ot.instancing === !1 || !K.isInstancedMesh && ot.instancing === !0 || K.isSkinnedMesh && ot.skinning === !1 || !K.isSkinnedMesh && ot.skinning === !0 || K.isInstancedMesh && ot.instancingColor === !0 && K.instanceColor === null || K.isInstancedMesh && ot.instancingColor === !1 && K.instanceColor !== null || K.isInstancedMesh && ot.instancingMorph === !0 && K.morphTexture === null || K.isInstancedMesh && ot.instancingMorph === !1 && K.morphTexture !== null || ot.envMap !== tt || se.fog === !0 && ot.fog !== Ee || ot.numClippingPlanes !== void 0 && (ot.numClippingPlanes !== Pe.numPlanes || ot.numIntersection !== Pe.numIntersection) || ot.vertexAlphas !== yt || ot.vertexTangents !== wt || ot.morphTargets !== dt || ot.morphNormals !== Ht || ot.morphColors !== ci || ot.toneMapping !== hi || ot.morphTargetsCount !== di) && (No = !0) : (No = !0, ot.__version = se.version);
      let Nn = ot.currentProgram;
      No === !0 && (Nn = ce(se, W, K));
      let zl = !1, Qr = !1, qc = !1;
      const ai = Nn.getUniforms(), as = ot.uniforms;
      if (it.useProgram(Nn.program) && (zl = !0, Qr = !0, qc = !0), se.id !== E && (E = se.id, Qr = !0), zl || A !== k) {
        it.buffers.depth.getReversed() ? (ue.copy(k.projectionMatrix), gB(ue), yB(ue), ai.setValue(Z, "projectionMatrix", ue)) : ai.setValue(Z, "projectionMatrix", k.projectionMatrix), ai.setValue(Z, "viewMatrix", k.matrixWorldInverse);
        const Or = ai.map.cameraPosition;
        Or !== void 0 && Or.setValue(Z, we.setFromMatrixPosition(k.matrixWorld)), xt.logarithmicDepthBuffer && ai.setValue(
          Z,
          "logDepthBufFC",
          2 / (Math.log(k.far + 1) / Math.LN2)
        ), (se.isMeshPhongMaterial || se.isMeshToonMaterial || se.isMeshLambertMaterial || se.isMeshBasicMaterial || se.isMeshStandardMaterial || se.isShaderMaterial) && ai.setValue(Z, "isOrthographic", k.isOrthographicCamera === !0), A !== k && (A = k, Qr = !0, qc = !0);
      }
      if (K.isSkinnedMesh) {
        ai.setOptional(Z, K, "bindMatrix"), ai.setOptional(Z, K, "bindMatrixInverse");
        const Or = K.skeleton;
        Or && (Or.boneTexture === null && Or.computeBoneTexture(), ai.setValue(Z, "boneTexture", Or.boneTexture, z));
      }
      K.isBatchedMesh && (ai.setOptional(Z, K, "batchingTexture"), ai.setValue(Z, "batchingTexture", K._matricesTexture, z), ai.setOptional(Z, K, "batchingIdTexture"), ai.setValue(Z, "batchingIdTexture", K._indirectTexture, z), ai.setOptional(Z, K, "batchingColorTexture"), K._colorsTexture !== null && ai.setValue(Z, "batchingColorTexture", K._colorsTexture, z));
      const Xc = te.morphAttributes;
      if ((Xc.position !== void 0 || Xc.normal !== void 0 || Xc.color !== void 0) && Fe.update(K, te, Nn), (Qr || ot.receiveShadow !== K.receiveShadow) && (ot.receiveShadow = K.receiveShadow, ai.setValue(Z, "receiveShadow", K.receiveShadow)), se.isMeshGouraudMaterial && se.envMap !== null && (as.envMap.value = tt, as.flipEnvMap.value = tt.isCubeTexture && tt.isRenderTargetTexture === !1 ? -1 : 1), se.isMeshStandardMaterial && se.envMap === null && W.environment !== null && (as.envMapIntensity.value = W.environmentIntensity), Qr && (ai.setValue(Z, "toneMappingExposure", b.toneMappingExposure), ot.needsLights && $e(as, qc), Ee && se.fog === !0 && ze.refreshFogUniforms(as, Ee), ze.refreshMaterialUniforms(as, se, B, V, g.state.transmissionRenderTarget[k.id]), Qf.upload(Z, Ce(ot), as, z)), se.isShaderMaterial && se.uniformsNeedUpdate === !0 && (Qf.upload(Z, Ce(ot), as, z), se.uniformsNeedUpdate = !1), se.isSpriteMaterial && ai.setValue(Z, "center", K.center), ai.setValue(Z, "modelViewMatrix", K.modelViewMatrix), ai.setValue(Z, "normalMatrix", K.normalMatrix), ai.setValue(Z, "modelMatrix", K.matrixWorld), se.isShaderMaterial || se.isRawShaderMaterial) {
        const Or = se.uniformsGroups;
        for (let Yc = 0, Oa = Or.length; Yc < Oa; Yc++) {
          const cS = Or[Yc];
          J.update(cS, Nn), J.bind(cS, Nn);
        }
      }
      return Nn;
    }
    function $e(k, W) {
      k.ambientLightColor.needsUpdate = W, k.lightProbe.needsUpdate = W, k.directionalLights.needsUpdate = W, k.directionalLightShadows.needsUpdate = W, k.pointLights.needsUpdate = W, k.pointLightShadows.needsUpdate = W, k.spotLights.needsUpdate = W, k.spotLightShadows.needsUpdate = W, k.rectAreaLights.needsUpdate = W, k.hemisphereLights.needsUpdate = W;
    }
    function We(k) {
      return k.isMeshLambertMaterial || k.isMeshToonMaterial || k.isMeshPhongMaterial || k.isMeshStandardMaterial || k.isShadowMaterial || k.isShaderMaterial && k.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return S;
    }, this.getActiveMipmapLevel = function() {
      return w;
    }, this.getRenderTarget = function() {
      return C;
    }, this.setRenderTargetTextures = function(k, W, te) {
      at.get(k.texture).__webglTexture = W, at.get(k.depthTexture).__webglTexture = te;
      const se = at.get(k);
      se.__hasExternalTextures = !0, se.__autoAllocateDepthBuffer = te === void 0, se.__autoAllocateDepthBuffer || ct.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), se.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(k, W) {
      const te = at.get(k);
      te.__webglFramebuffer = W, te.__useDefaultFramebuffer = W === void 0;
    }, this.setRenderTarget = function(k, W = 0, te = 0) {
      C = k, S = W, w = te;
      let se = !0, K = null, Ee = !1, Re = !1;
      if (k) {
        const Ke = at.get(k);
        if (Ke.__useDefaultFramebuffer !== void 0)
          it.bindFramebuffer(Z.FRAMEBUFFER, null), se = !1;
        else if (Ke.__webglFramebuffer === void 0)
          z.setupRenderTarget(k);
        else if (Ke.__hasExternalTextures)
          z.rebindTextures(k, at.get(k.texture).__webglTexture, at.get(k.depthTexture).__webglTexture);
        else if (k.depthBuffer) {
          const wt = k.depthTexture;
          if (Ke.__boundDepthTexture !== wt) {
            if (wt !== null && at.has(wt) && (k.width !== wt.image.width || k.height !== wt.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            z.setupDepthRenderbuffer(k);
          }
        }
        const tt = k.texture;
        (tt.isData3DTexture || tt.isDataArrayTexture || tt.isCompressedArrayTexture) && (Re = !0);
        const yt = at.get(k).__webglFramebuffer;
        k.isWebGLCubeRenderTarget ? (Array.isArray(yt[W]) ? K = yt[W][te] : K = yt[W], Ee = !0) : k.samples > 0 && z.useMultisampledRTT(k) === !1 ? K = at.get(k).__webglMultisampledFramebuffer : Array.isArray(yt) ? K = yt[te] : K = yt, N.copy(k.viewport), L.copy(k.scissor), F = k.scissorTest;
      } else
        N.copy(j).multiplyScalar(B).floor(), L.copy(Q).multiplyScalar(B).floor(), F = q;
      if (it.bindFramebuffer(Z.FRAMEBUFFER, K) && se && it.drawBuffers(k, K), it.viewport(N), it.scissor(L), it.setScissorTest(F), Ee) {
        const Ke = at.get(k.texture);
        Z.framebufferTexture2D(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_CUBE_MAP_POSITIVE_X + W, Ke.__webglTexture, te);
      } else if (Re) {
        const Ke = at.get(k.texture), tt = W || 0;
        Z.framebufferTextureLayer(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Ke.__webglTexture, te || 0, tt);
      }
      E = -1;
    }, this.readRenderTargetPixels = function(k, W, te, se, K, Ee, Re) {
      if (!(k && k.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Ke = at.get(k).__webglFramebuffer;
      if (k.isWebGLCubeRenderTarget && Re !== void 0 && (Ke = Ke[Re]), Ke) {
        it.bindFramebuffer(Z.FRAMEBUFFER, Ke);
        try {
          const tt = k.texture, yt = tt.format, wt = tt.type;
          if (!xt.textureFormatReadable(yt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!xt.textureTypeReadable(wt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          W >= 0 && W <= k.width - se && te >= 0 && te <= k.height - K && Z.readPixels(W, te, se, K, mt.convert(yt), mt.convert(wt), Ee);
        } finally {
          const tt = C !== null ? at.get(C).__webglFramebuffer : null;
          it.bindFramebuffer(Z.FRAMEBUFFER, tt);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(k, W, te, se, K, Ee, Re) {
      if (!(k && k.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Ke = at.get(k).__webglFramebuffer;
      if (k.isWebGLCubeRenderTarget && Re !== void 0 && (Ke = Ke[Re]), Ke) {
        const tt = k.texture, yt = tt.format, wt = tt.type;
        if (!xt.textureFormatReadable(yt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!xt.textureTypeReadable(wt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (W >= 0 && W <= k.width - se && te >= 0 && te <= k.height - K) {
          it.bindFramebuffer(Z.FRAMEBUFFER, Ke);
          const dt = Z.createBuffer();
          Z.bindBuffer(Z.PIXEL_PACK_BUFFER, dt), Z.bufferData(Z.PIXEL_PACK_BUFFER, Ee.byteLength, Z.STREAM_READ), Z.readPixels(W, te, se, K, mt.convert(yt), mt.convert(wt), 0);
          const Ht = C !== null ? at.get(C).__webglFramebuffer : null;
          it.bindFramebuffer(Z.FRAMEBUFFER, Ht);
          const ci = Z.fenceSync(Z.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return Z.flush(), await mB(Z, ci, 4), Z.bindBuffer(Z.PIXEL_PACK_BUFFER, dt), Z.getBufferSubData(Z.PIXEL_PACK_BUFFER, 0, Ee), Z.deleteBuffer(dt), Z.deleteSync(ci), Ee;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(k, W = null, te = 0) {
      k.isTexture !== !0 && (Uh("WebGLRenderer: copyFramebufferToTexture function signature has changed."), W = arguments[0] || null, k = arguments[1]);
      const se = Math.pow(2, -te), K = Math.floor(k.image.width * se), Ee = Math.floor(k.image.height * se), Re = W !== null ? W.x : 0, Ke = W !== null ? W.y : 0;
      z.setTexture2D(k, 0), Z.copyTexSubImage2D(Z.TEXTURE_2D, te, 0, 0, Re, Ke, K, Ee), it.unbindTexture();
    }, this.copyTextureToTexture = function(k, W, te = null, se = null, K = 0) {
      k.isTexture !== !0 && (Uh("WebGLRenderer: copyTextureToTexture function signature has changed."), se = arguments[0] || null, k = arguments[1], W = arguments[2], K = arguments[3] || 0, te = null);
      let Ee, Re, Ke, tt, yt, wt, dt, Ht, ci;
      const hi = k.isCompressedTexture ? k.mipmaps[K] : k.image;
      te !== null ? (Ee = te.max.x - te.min.x, Re = te.max.y - te.min.y, Ke = te.isBox3 ? te.max.z - te.min.z : 1, tt = te.min.x, yt = te.min.y, wt = te.isBox3 ? te.min.z : 0) : (Ee = hi.width, Re = hi.height, Ke = hi.depth || 1, tt = 0, yt = 0, wt = 0), se !== null ? (dt = se.x, Ht = se.y, ci = se.z) : (dt = 0, Ht = 0, ci = 0);
      const Ni = mt.convert(W.format), di = mt.convert(W.type);
      let ot;
      W.isData3DTexture ? (z.setTexture3D(W, 0), ot = Z.TEXTURE_3D) : W.isDataArrayTexture || W.isCompressedArrayTexture ? (z.setTexture2DArray(W, 0), ot = Z.TEXTURE_2D_ARRAY) : (z.setTexture2D(W, 0), ot = Z.TEXTURE_2D), Z.pixelStorei(Z.UNPACK_FLIP_Y_WEBGL, W.flipY), Z.pixelStorei(Z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, W.premultiplyAlpha), Z.pixelStorei(Z.UNPACK_ALIGNMENT, W.unpackAlignment);
      const Ro = Z.getParameter(Z.UNPACK_ROW_LENGTH), No = Z.getParameter(Z.UNPACK_IMAGE_HEIGHT), Nn = Z.getParameter(Z.UNPACK_SKIP_PIXELS), zl = Z.getParameter(Z.UNPACK_SKIP_ROWS), Qr = Z.getParameter(Z.UNPACK_SKIP_IMAGES);
      Z.pixelStorei(Z.UNPACK_ROW_LENGTH, hi.width), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, hi.height), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, tt), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, yt), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, wt);
      const qc = k.isDataArrayTexture || k.isData3DTexture, ai = W.isDataArrayTexture || W.isData3DTexture;
      if (k.isRenderTargetTexture || k.isDepthTexture) {
        const as = at.get(k), Xc = at.get(W), Or = at.get(as.__renderTarget), Yc = at.get(Xc.__renderTarget);
        it.bindFramebuffer(Z.READ_FRAMEBUFFER, Or.__webglFramebuffer), it.bindFramebuffer(Z.DRAW_FRAMEBUFFER, Yc.__webglFramebuffer);
        for (let Oa = 0; Oa < Ke; Oa++)
          qc && Z.framebufferTextureLayer(Z.READ_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, at.get(k).__webglTexture, K, wt + Oa), k.isDepthTexture ? (ai && Z.framebufferTextureLayer(Z.DRAW_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, at.get(W).__webglTexture, K, ci + Oa), Z.blitFramebuffer(tt, yt, Ee, Re, dt, Ht, Ee, Re, Z.DEPTH_BUFFER_BIT, Z.NEAREST)) : ai ? Z.copyTexSubImage3D(ot, K, dt, Ht, ci + Oa, tt, yt, Ee, Re) : Z.copyTexSubImage2D(ot, K, dt, Ht, ci + Oa, tt, yt, Ee, Re);
        it.bindFramebuffer(Z.READ_FRAMEBUFFER, null), it.bindFramebuffer(Z.DRAW_FRAMEBUFFER, null);
      } else
        ai ? k.isDataTexture || k.isData3DTexture ? Z.texSubImage3D(ot, K, dt, Ht, ci, Ee, Re, Ke, Ni, di, hi.data) : W.isCompressedArrayTexture ? Z.compressedTexSubImage3D(ot, K, dt, Ht, ci, Ee, Re, Ke, Ni, hi.data) : Z.texSubImage3D(ot, K, dt, Ht, ci, Ee, Re, Ke, Ni, di, hi) : k.isDataTexture ? Z.texSubImage2D(Z.TEXTURE_2D, K, dt, Ht, Ee, Re, Ni, di, hi.data) : k.isCompressedTexture ? Z.compressedTexSubImage2D(Z.TEXTURE_2D, K, dt, Ht, hi.width, hi.height, Ni, hi.data) : Z.texSubImage2D(Z.TEXTURE_2D, K, dt, Ht, Ee, Re, Ni, di, hi);
      Z.pixelStorei(Z.UNPACK_ROW_LENGTH, Ro), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, No), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, Nn), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, zl), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, Qr), K === 0 && W.generateMipmaps && Z.generateMipmap(ot), it.unbindTexture();
    }, this.copyTextureToTexture3D = function(k, W, te = null, se = null, K = 0) {
      return k.isTexture !== !0 && (Uh("WebGLRenderer: copyTextureToTexture3D function signature has changed."), te = arguments[0] || null, se = arguments[1] || null, k = arguments[2], W = arguments[3], K = arguments[4] || 0), Uh('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(k, W, te, se, K);
    }, this.initRenderTarget = function(k) {
      at.get(k).__webglFramebuffer === void 0 && z.setupRenderTarget(k);
    }, this.initTexture = function(k) {
      k.isCubeTexture ? z.setTextureCube(k, 0) : k.isData3DTexture ? z.setTexture3D(k, 0) : k.isDataArrayTexture || k.isCompressedArrayTexture ? z.setTexture2DArray(k, 0) : z.setTexture2D(k, 0), it.unbindTexture();
    }, this.resetState = function() {
      S = 0, w = 0, C = null, it.reset(), kt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return oa;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const i = this.getContext();
    i.drawingBufferColorspace = Gt._getDrawingBufferColorSpace(e), i.unpackColorSpace = Gt._getUnpackColorSpace();
  }
}
let M6 = class extends Hr {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new bo(), this.environmentIntensity = 1, this.environmentRotation = new bo(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(r, e) {
    return super.copy(r, e), r.background !== null && (this.background = r.background.clone()), r.environment !== null && (this.environment = r.environment.clone()), r.fog !== null && (this.fog = r.fog.clone()), this.backgroundBlurriness = r.backgroundBlurriness, this.backgroundIntensity = r.backgroundIntensity, this.backgroundRotation.copy(r.backgroundRotation), this.environmentIntensity = r.environmentIntensity, this.environmentRotation.copy(r.environmentRotation), r.overrideMaterial !== null && (this.overrideMaterial = r.overrideMaterial.clone()), this.matrixAutoUpdate = r.matrixAutoUpdate, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
  }
}, A6 = class {
  constructor(r, e) {
    this.isInterleavedBuffer = !0, this.array = r, this.stride = e, this.count = r !== void 0 ? r.length / e : 0, this.usage = Ib, this.updateRanges = [], this.version = 0, this.uuid = da();
  }
  onUploadCallback() {
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  setUsage(r) {
    return this.usage = r, this;
  }
  addUpdateRange(r, e) {
    this.updateRanges.push({ start: r, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(r) {
    return this.array = new r.array.constructor(r.array), this.count = r.count, this.stride = r.stride, this.usage = r.usage, this;
  }
  copyAt(r, e, i) {
    r *= this.stride, i *= e.stride;
    for (let n = 0, s = this.stride; n < s; n++)
      this.array[r + n] = e.array[i + n];
    return this;
  }
  set(r, e = 0) {
    return this.array.set(r, e), this;
  }
  clone(r) {
    r.arrayBuffers === void 0 && (r.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = da()), r.arrayBuffers[this.array.buffer._uuid] === void 0 && (r.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(r.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(e, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(r) {
    return this.onUploadCallback = r, this;
  }
  toJSON(r) {
    return r.arrayBuffers === void 0 && (r.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = da()), r.arrayBuffers[this.array.buffer._uuid] === void 0 && (r.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
};
const vr = /* @__PURE__ */ new X();
let mw = class yR {
  constructor(e, i, n, s = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = i, this.offset = n, this.normalized = s;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.data.count; i < n; i++)
      vr.fromBufferAttribute(this, i), vr.applyMatrix4(e), this.setXYZ(i, vr.x, vr.y, vr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      vr.fromBufferAttribute(this, i), vr.applyNormalMatrix(e), this.setXYZ(i, vr.x, vr.y, vr.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      vr.fromBufferAttribute(this, i), vr.transformDirection(e), this.setXYZ(i, vr.x, vr.y, vr.z);
    return this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.data.stride + this.offset + i];
    return this.normalized && (n = Xn(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = Jt(n, this.array)), this.data.array[e * this.data.stride + this.offset + i] = n, this;
  }
  setX(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset] = i, this;
  }
  setY(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = i, this;
  }
  setZ(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = i, this;
  }
  setW(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = i, this;
  }
  getX(e) {
    let i = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (i = Xn(i, this.array)), i;
  }
  getY(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (i = Xn(i, this.array)), i;
  }
  getZ(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (i = Xn(i, this.array)), i;
  }
  getW(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (i = Xn(i, this.array)), i;
  }
  setXY(e, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Jt(i, this.array), n = Jt(n, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Jt(i, this.array), n = Jt(n, this.array), s = Jt(s, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Jt(i, this.array), n = Jt(n, this.array), s = Jt(s, this.array), a = Jt(a, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = a, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return new wn(new this.array.constructor(i), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new yR(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: i,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}, C6 = class extends Ol {
  static get type() {
    return "SpriteMaterial";
  }
  constructor(r) {
    super(), this.isSpriteMaterial = !0, this.color = new Ft(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.alphaMap = r.alphaMap, this.rotation = r.rotation, this.sizeAttenuation = r.sizeAttenuation, this.fog = r.fog, this;
  }
}, iu;
const ah = /* @__PURE__ */ new X(), ru = /* @__PURE__ */ new X(), nu = /* @__PURE__ */ new X(), su = /* @__PURE__ */ new Le(), oh = /* @__PURE__ */ new Le(), vR = /* @__PURE__ */ new ui(), Op = /* @__PURE__ */ new X(), lh = /* @__PURE__ */ new X(), Ip = /* @__PURE__ */ new X(), gw = /* @__PURE__ */ new Le(), Wy = /* @__PURE__ */ new Le(), yw = /* @__PURE__ */ new Le();
class R6 extends Hr {
  constructor(e = new C6()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", iu === void 0) {
      iu = new pn();
      const i = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new A6(i, 5);
      iu.setIndex([0, 1, 2, 0, 2, 3]), iu.setAttribute("position", new mw(n, 3, 0, !1)), iu.setAttribute("uv", new mw(n, 2, 3, !1));
    }
    this.geometry = iu, this.material = e, this.center = new Le(0.5, 0.5);
  }
  raycast(e, i) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ru.setFromMatrixScale(this.matrixWorld), vR.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), nu.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && ru.multiplyScalar(-nu.z);
    const n = this.material.rotation;
    let s, a;
    n !== 0 && (a = Math.cos(n), s = Math.sin(n));
    const o = this.center;
    Dp(Op.set(-0.5, -0.5, 0), nu, o, ru, s, a), Dp(lh.set(0.5, -0.5, 0), nu, o, ru, s, a), Dp(Ip.set(0.5, 0.5, 0), nu, o, ru, s, a), gw.set(0, 0), Wy.set(1, 0), yw.set(1, 1);
    let l = e.ray.intersectTriangle(Op, lh, Ip, !1, ah);
    if (l === null && (Dp(lh.set(-0.5, 0.5, 0), nu, o, ru, s, a), Wy.set(0, 1), l = e.ray.intersectTriangle(Op, Ip, lh, !1, ah), l === null))
      return;
    const u = e.ray.origin.distanceTo(ah);
    u < e.near || u > e.far || i.push({
      distance: u,
      point: ah.clone(),
      uv: Ru.getInterpolation(ah, Op, lh, Ip, gw, Wy, yw, new Le()),
      face: null,
      object: this
    });
  }
  copy(e, i) {
    return super.copy(e, i), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Dp(r, e, i, n, s, a) {
  su.subVectors(r, i).addScalar(0.5).multiply(n), s !== void 0 ? (oh.x = a * su.x - s * su.y, oh.y = s * su.x + a * su.y) : oh.copy(su), r.copy(e), r.x += oh.x, r.y += oh.y, r.applyMatrix4(vR);
}
let bR = class extends Ol {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(r) {
    super(), this.isLineBasicMaterial = !0, this.color = new Ft(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.linewidth = r.linewidth, this.linecap = r.linecap, this.linejoin = r.linejoin, this.fog = r.fog, this;
  }
};
const vm = /* @__PURE__ */ new X(), bm = /* @__PURE__ */ new X(), vw = /* @__PURE__ */ new ui(), uh = /* @__PURE__ */ new bg(), kp = /* @__PURE__ */ new vg(), qy = /* @__PURE__ */ new X(), bw = /* @__PURE__ */ new X();
class N6 extends Hr {
  constructor(e = new pn(), i = new bR()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = i, this.updateMorphTargets();
  }
  copy(e, i) {
    return super.copy(e, i), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const i = e.attributes.position, n = [0];
      for (let s = 1, a = i.count; s < a; s++)
        vm.fromBufferAttribute(i, s - 1), bm.fromBufferAttribute(i, s), n[s] = n[s - 1], n[s] += vm.distanceTo(bm);
      e.setAttribute("lineDistance", new Ri(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, i) {
    const n = this.geometry, s = this.matrixWorld, a = e.params.Line.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), kp.copy(n.boundingSphere), kp.applyMatrix4(s), kp.radius += a, e.ray.intersectsSphere(kp) === !1) return;
    vw.copy(s).invert(), uh.copy(e.ray).applyMatrix4(vw);
    const l = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), u = l * l, c = this.isLineSegments ? 2 : 1, h = n.index, d = n.attributes.position;
    if (h !== null) {
      const p = Math.max(0, o.start), f = Math.min(h.count, o.start + o.count);
      for (let m = p, v = f - 1; m < v; m += c) {
        const y = h.getX(m), g = h.getX(m + 1), _ = Lp(this, e, uh, u, y, g);
        _ && i.push(_);
      }
      if (this.isLineLoop) {
        const m = h.getX(f - 1), v = h.getX(p), y = Lp(this, e, uh, u, m, v);
        y && i.push(y);
      }
    } else {
      const p = Math.max(0, o.start), f = Math.min(d.count, o.start + o.count);
      for (let m = p, v = f - 1; m < v; m += c) {
        const y = Lp(this, e, uh, u, m, m + 1);
        y && i.push(y);
      }
      if (this.isLineLoop) {
        const m = Lp(this, e, uh, u, f - 1, p);
        m && i.push(m);
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, i = Object.keys(e);
    if (i.length > 0) {
      const n = e[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
        }
      }
    }
  }
}
function Lp(r, e, i, n, s, a) {
  const o = r.geometry.attributes.position;
  if (vm.fromBufferAttribute(o, s), bm.fromBufferAttribute(o, a), i.distanceSqToSegment(vm, bm, qy, bw) > n) return;
  qy.applyMatrix4(r.matrixWorld);
  const l = e.ray.origin.distanceTo(qy);
  if (!(l < e.near || l > e.far))
    return {
      distance: l,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: bw.clone().applyMatrix4(r.matrixWorld),
      index: s,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: r
    };
}
class Ma {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, i) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, i);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const i = [];
    for (let n = 0; n <= e; n++)
      i.push(this.getPoint(n / e));
    return i;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const i = [];
    for (let n = 0; n <= e; n++)
      i.push(this.getPointAt(n / e));
    return i;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const i = [];
    let n, s = this.getPoint(0), a = 0;
    i.push(0);
    for (let o = 1; o <= e; o++)
      n = this.getPoint(o / e), a += n.distanceTo(s), i.push(a), s = n;
    return this.cacheArcLengths = i, i;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, i) {
    const n = this.getLengths();
    let s = 0;
    const a = n.length;
    let o;
    i ? o = i : o = e * n[a - 1];
    let l = 0, u = a - 1, c;
    for (; l <= u; )
      if (s = Math.floor(l + (u - l) / 2), c = n[s] - o, c < 0)
        l = s + 1;
      else if (c > 0)
        u = s - 1;
      else {
        u = s;
        break;
      }
    if (s = u, n[s] === o)
      return s / (a - 1);
    const h = n[s], d = n[s + 1] - h, p = (o - h) / d;
    return (s + p) / (a - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, i) {
    let n = e - 1e-4, s = e + 1e-4;
    n < 0 && (n = 0), s > 1 && (s = 1);
    const a = this.getPoint(n), o = this.getPoint(s), l = i || (a.isVector2 ? new Le() : new X());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(e, i) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, i);
  }
  computeFrenetFrames(e, i) {
    const n = new X(), s = [], a = [], o = [], l = new X(), u = new ui();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      s[f] = this.getTangentAt(m, new X());
    }
    a[0] = new X(), o[0] = new X();
    let c = Number.MAX_VALUE;
    const h = Math.abs(s[0].x), d = Math.abs(s[0].y), p = Math.abs(s[0].z);
    h <= c && (c = h, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), p <= c && n.set(0, 0, 1), l.crossVectors(s[0], n).normalize(), a[0].crossVectors(s[0], l), o[0].crossVectors(s[0], a[0]);
    for (let f = 1; f <= e; f++) {
      if (a[f] = a[f - 1].clone(), o[f] = o[f - 1].clone(), l.crossVectors(s[f - 1], s[f]), l.length() > Number.EPSILON) {
        l.normalize();
        const m = Math.acos($i(s[f - 1].dot(s[f]), -1, 1));
        a[f].applyMatrix4(u.makeRotationAxis(l, m));
      }
      o[f].crossVectors(s[f], a[f]);
    }
    if (i === !0) {
      let f = Math.acos($i(a[0].dot(a[e]), -1, 1));
      f /= e, s[0].dot(l.crossVectors(a[0], a[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++)
        a[m].applyMatrix4(u.makeRotationAxis(s[m], f * m)), o[m].crossVectors(s[m], a[m]);
    }
    return {
      tangents: s,
      normals: a,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class xR extends Ma {
  constructor(e = 0, i = 0, n = 1, s = 1, a = 0, o = Math.PI * 2, l = !1, u = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = i, this.xRadius = n, this.yRadius = s, this.aStartAngle = a, this.aEndAngle = o, this.aClockwise = l, this.aRotation = u;
  }
  getPoint(e, i = new Le()) {
    const n = i, s = Math.PI * 2;
    let a = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(a) < Number.EPSILON;
    for (; a < 0; ) a += s;
    for (; a > s; ) a -= s;
    a < Number.EPSILON && (o ? a = 0 : a = s), this.aClockwise === !0 && !o && (a === s ? a = -s : a = a - s);
    const l = this.aStartAngle + e * a;
    let u = this.aX + this.xRadius * Math.cos(l), c = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = u - this.aX, f = c - this.aY;
      u = p * h - f * d + this.aX, c = p * d + f * h + this.aY;
    }
    return n.set(u, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class P6 extends xR {
  constructor(e, i, n, s, a, o) {
    super(e, i, n, n, s, a, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function L_() {
  let r = 0, e = 0, i = 0, n = 0;
  function s(a, o, l, u) {
    r = a, e = l, i = -3 * a + 3 * o - 2 * l - u, n = 2 * a - 2 * o + l + u;
  }
  return {
    initCatmullRom: function(a, o, l, u, c) {
      s(o, l, c * (l - a), c * (u - o));
    },
    initNonuniformCatmullRom: function(a, o, l, u, c, h, d) {
      let p = (o - a) / c - (l - a) / (c + h) + (l - o) / h, f = (l - o) / h - (u - o) / (h + d) + (u - l) / d;
      p *= h, f *= h, s(o, l, p, f);
    },
    calc: function(a) {
      const o = a * a, l = o * a;
      return r + e * a + i * o + n * l;
    }
  };
}
const Up = /* @__PURE__ */ new X(), Xy = /* @__PURE__ */ new L_(), Yy = /* @__PURE__ */ new L_(), $y = /* @__PURE__ */ new L_();
class O6 extends Ma {
  constructor(e = [], i = !1, n = "centripetal", s = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = i, this.curveType = n, this.tension = s;
  }
  getPoint(e, i = new X()) {
    const n = i, s = this.points, a = s.length, o = (a - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(o), u = o - l;
    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / a) + 1) * a : u === 0 && l === a - 1 && (l = a - 2, u = 1);
    let c, h;
    this.closed || l > 0 ? c = s[(l - 1) % a] : (Up.subVectors(s[0], s[1]).add(s[0]), c = Up);
    const d = s[l % a], p = s[(l + 1) % a];
    if (this.closed || l + 2 < a ? h = s[(l + 2) % a] : (Up.subVectors(s[a - 1], s[a - 2]).add(s[a - 1]), h = Up), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(c.distanceToSquared(d), f), v = Math.pow(d.distanceToSquared(p), f), y = Math.pow(p.distanceToSquared(h), f);
      v < 1e-4 && (v = 1), m < 1e-4 && (m = v), y < 1e-4 && (y = v), Xy.initNonuniformCatmullRom(c.x, d.x, p.x, h.x, m, v, y), Yy.initNonuniformCatmullRom(c.y, d.y, p.y, h.y, m, v, y), $y.initNonuniformCatmullRom(c.z, d.z, p.z, h.z, m, v, y);
    } else this.curveType === "catmullrom" && (Xy.initCatmullRom(c.x, d.x, p.x, h.x, this.tension), Yy.initCatmullRom(c.y, d.y, p.y, h.y, this.tension), $y.initCatmullRom(c.z, d.z, p.z, h.z, this.tension));
    return n.set(
      Xy.calc(u),
      Yy.calc(u),
      $y.calc(u)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(s.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let i = 0, n = this.points.length; i < n; i++) {
      const s = this.points[i];
      e.points.push(s.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(new X().fromArray(s));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function xw(r, e, i, n, s) {
  const a = (n - e) * 0.5, o = (s - i) * 0.5, l = r * r, u = r * l;
  return (2 * i - 2 * n + a + o) * u + (-3 * i + 3 * n - 2 * a - o) * l + a * r + i;
}
function I6(r, e) {
  const i = 1 - r;
  return i * i * e;
}
function D6(r, e) {
  return 2 * (1 - r) * r * e;
}
function k6(r, e) {
  return r * r * e;
}
function Kh(r, e, i, n) {
  return I6(r, e) + D6(r, i) + k6(r, n);
}
function L6(r, e) {
  const i = 1 - r;
  return i * i * i * e;
}
function U6(r, e) {
  const i = 1 - r;
  return 3 * i * i * r * e;
}
function F6(r, e) {
  return 3 * (1 - r) * r * r * e;
}
function B6(r, e) {
  return r * r * r * e;
}
function Qh(r, e, i, n, s) {
  return L6(r, e) + U6(r, i) + F6(r, n) + B6(r, s);
}
class z6 extends Ma {
  constructor(e = new Le(), i = new Le(), n = new Le(), s = new Le()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = i, this.v2 = n, this.v3 = s;
  }
  getPoint(e, i = new Le()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2, l = this.v3;
    return n.set(
      Qh(e, s.x, a.x, o.x, l.x),
      Qh(e, s.y, a.y, o.y, l.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class _R extends Ma {
  constructor(e = new X(), i = new X(), n = new X(), s = new X()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = i, this.v2 = n, this.v3 = s;
  }
  getPoint(e, i = new X()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2, l = this.v3;
    return n.set(
      Qh(e, s.x, a.x, o.x, l.x),
      Qh(e, s.y, a.y, o.y, l.y),
      Qh(e, s.z, a.z, o.z, l.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class j6 extends Ma {
  constructor(e = new Le(), i = new Le()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = i;
  }
  getPoint(e, i = new Le()) {
    const n = i;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, i) {
    return this.getPoint(e, i);
  }
  getTangent(e, i = new Le()) {
    return i.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, i) {
    return this.getTangent(e, i);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class V6 extends Ma {
  constructor(e = new X(), i = new X()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = i;
  }
  getPoint(e, i = new X()) {
    const n = i;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, i) {
    return this.getPoint(e, i);
  }
  getTangent(e, i = new X()) {
    return i.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, i) {
    return this.getTangent(e, i);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class G6 extends Ma {
  constructor(e = new Le(), i = new Le(), n = new Le()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = i, this.v2 = n;
  }
  getPoint(e, i = new Le()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2;
    return n.set(
      Kh(e, s.x, a.x, o.x),
      Kh(e, s.y, a.y, o.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class U_ extends Ma {
  constructor(e = new X(), i = new X(), n = new X()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = i, this.v2 = n;
  }
  getPoint(e, i = new X()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2;
    return n.set(
      Kh(e, s.x, a.x, o.x),
      Kh(e, s.y, a.y, o.y),
      Kh(e, s.z, a.z, o.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class H6 extends Ma {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, i = new Le()) {
    const n = i, s = this.points, a = (s.length - 1) * e, o = Math.floor(a), l = a - o, u = s[o === 0 ? o : o - 1], c = s[o], h = s[o > s.length - 2 ? s.length - 1 : o + 1], d = s[o > s.length - 3 ? s.length - 1 : o + 2];
    return n.set(
      xw(l, u.x, c.x, h.x, d.x),
      xw(l, u.y, c.y, h.y, d.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let i = 0, n = this.points.length; i < n; i++) {
      const s = this.points[i];
      e.points.push(s.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(new Le().fromArray(s));
    }
    return this;
  }
}
var W6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: P6,
  CatmullRomCurve3: O6,
  CubicBezierCurve: z6,
  CubicBezierCurve3: _R,
  EllipseCurve: xR,
  LineCurve: j6,
  LineCurve3: V6,
  QuadraticBezierCurve: G6,
  QuadraticBezierCurve3: U_,
  SplineCurve: H6
});
class F_ extends pn {
  constructor(e = 1, i = 32, n = 0, s = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: i,
      thetaStart: n,
      thetaLength: s
    }, i = Math.max(3, i);
    const a = [], o = [], l = [], u = [], c = new X(), h = new Le();
    o.push(0, 0, 0), l.push(0, 0, 1), u.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= i; d++, p += 3) {
      const f = n + d / i * s;
      c.x = e * Math.cos(f), c.y = e * Math.sin(f), o.push(c.x, c.y, c.z), l.push(0, 0, 1), h.x = (o[p] / e + 1) / 2, h.y = (o[p + 1] / e + 1) / 2, u.push(h.x, h.y);
    }
    for (let d = 1; d <= i; d++)
      a.push(d, d + 1, 0);
    this.setIndex(a), this.setAttribute("position", new Ri(o, 3)), this.setAttribute("normal", new Ri(l, 3)), this.setAttribute("uv", new Ri(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new F_(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Tg extends pn {
  constructor(e = 1, i = 1, n = 1, s = 32, a = 1, o = !1, l = 0, u = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: i,
      height: n,
      radialSegments: s,
      heightSegments: a,
      openEnded: o,
      thetaStart: l,
      thetaLength: u
    };
    const c = this;
    s = Math.floor(s), a = Math.floor(a);
    const h = [], d = [], p = [], f = [];
    let m = 0;
    const v = [], y = n / 2;
    let g = 0;
    _(), o === !1 && (e > 0 && x(!0), i > 0 && x(!1)), this.setIndex(h), this.setAttribute("position", new Ri(d, 3)), this.setAttribute("normal", new Ri(p, 3)), this.setAttribute("uv", new Ri(f, 2));
    function _() {
      const b = new X(), T = new X();
      let S = 0;
      const w = (i - e) / n;
      for (let C = 0; C <= a; C++) {
        const E = [], A = C / a, N = A * (i - e) + e;
        for (let L = 0; L <= s; L++) {
          const F = L / s, M = F * u + l, P = Math.sin(M), O = Math.cos(M);
          T.x = N * P, T.y = -A * n + y, T.z = N * O, d.push(T.x, T.y, T.z), b.set(P, w, O).normalize(), p.push(b.x, b.y, b.z), f.push(F, 1 - A), E.push(m++);
        }
        v.push(E);
      }
      for (let C = 0; C < s; C++)
        for (let E = 0; E < a; E++) {
          const A = v[E][C], N = v[E + 1][C], L = v[E + 1][C + 1], F = v[E][C + 1];
          (e > 0 || E !== 0) && (h.push(A, N, F), S += 3), (i > 0 || E !== a - 1) && (h.push(N, L, F), S += 3);
        }
      c.addGroup(g, S, 0), g += S;
    }
    function x(b) {
      const T = m, S = new Le(), w = new X();
      let C = 0;
      const E = b === !0 ? e : i, A = b === !0 ? 1 : -1;
      for (let L = 1; L <= s; L++)
        d.push(0, y * A, 0), p.push(0, A, 0), f.push(0.5, 0.5), m++;
      const N = m;
      for (let L = 0; L <= s; L++) {
        const F = L / s * u + l, M = Math.cos(F), P = Math.sin(F);
        w.x = E * P, w.y = y * A, w.z = E * M, d.push(w.x, w.y, w.z), p.push(0, A, 0), S.x = M * 0.5 + 0.5, S.y = P * 0.5 * A + 0.5, f.push(S.x, S.y), m++;
      }
      for (let L = 0; L < s; L++) {
        const F = T + L, M = N + L;
        b === !0 ? h.push(M, M + 1, F) : h.push(M + 1, M, F), C += 3;
      }
      c.addGroup(g, C, b === !0 ? 1 : 2), g += C;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Tg(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class B_ extends Tg {
  constructor(e = 1, i = 1, n = 32, s = 1, a = !1, o = 0, l = Math.PI * 2) {
    super(0, e, i, n, s, a, o, l), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: i,
      radialSegments: n,
      heightSegments: s,
      openEnded: a,
      thetaStart: o,
      thetaLength: l
    };
  }
  static fromJSON(e) {
    return new B_(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
let TR = class SR extends pn {
  constructor(e = 1, i = 32, n = 16, s = 0, a = Math.PI * 2, o = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: i,
      heightSegments: n,
      phiStart: s,
      phiLength: a,
      thetaStart: o,
      thetaLength: l
    }, i = Math.max(3, Math.floor(i)), n = Math.max(2, Math.floor(n));
    const u = Math.min(o + l, Math.PI);
    let c = 0;
    const h = [], d = new X(), p = new X(), f = [], m = [], v = [], y = [];
    for (let g = 0; g <= n; g++) {
      const _ = [], x = g / n;
      let b = 0;
      g === 0 && o === 0 ? b = 0.5 / i : g === n && u === Math.PI && (b = -0.5 / i);
      for (let T = 0; T <= i; T++) {
        const S = T / i;
        d.x = -e * Math.cos(s + S * a) * Math.sin(o + x * l), d.y = e * Math.cos(o + x * l), d.z = e * Math.sin(s + S * a) * Math.sin(o + x * l), m.push(d.x, d.y, d.z), p.copy(d).normalize(), v.push(p.x, p.y, p.z), y.push(S + b, 1 - x), _.push(c++);
      }
      h.push(_);
    }
    for (let g = 0; g < n; g++)
      for (let _ = 0; _ < i; _++) {
        const x = h[g][_ + 1], b = h[g][_], T = h[g + 1][_], S = h[g + 1][_ + 1];
        (g !== 0 || o > 0) && f.push(x, b, S), (g !== n - 1 || u < Math.PI) && f.push(b, T, S);
      }
    this.setIndex(f), this.setAttribute("position", new Ri(m, 3)), this.setAttribute("normal", new Ri(v, 3)), this.setAttribute("uv", new Ri(y, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new SR(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
};
class z_ extends pn {
  constructor(e = new U_(new X(-1, -1, 0), new X(-1, 1, 0), new X(1, 1, 0)), i = 64, n = 1, s = 8, a = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: i,
      radius: n,
      radialSegments: s,
      closed: a
    };
    const o = e.computeFrenetFrames(i, a);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const l = new X(), u = new X(), c = new Le();
    let h = new X();
    const d = [], p = [], f = [], m = [];
    v(), this.setIndex(m), this.setAttribute("position", new Ri(d, 3)), this.setAttribute("normal", new Ri(p, 3)), this.setAttribute("uv", new Ri(f, 2));
    function v() {
      for (let x = 0; x < i; x++)
        y(x);
      y(a === !1 ? i : 0), _(), g();
    }
    function y(x) {
      h = e.getPointAt(x / i, h);
      const b = o.normals[x], T = o.binormals[x];
      for (let S = 0; S <= s; S++) {
        const w = S / s * Math.PI * 2, C = Math.sin(w), E = -Math.cos(w);
        u.x = E * b.x + C * T.x, u.y = E * b.y + C * T.y, u.z = E * b.z + C * T.z, u.normalize(), p.push(u.x, u.y, u.z), l.x = h.x + n * u.x, l.y = h.y + n * u.y, l.z = h.z + n * u.z, d.push(l.x, l.y, l.z);
      }
    }
    function g() {
      for (let x = 1; x <= i; x++)
        for (let b = 1; b <= s; b++) {
          const T = (s + 1) * (x - 1) + (b - 1), S = (s + 1) * x + (b - 1), w = (s + 1) * x + b, C = (s + 1) * (x - 1) + b;
          m.push(T, S, C), m.push(S, w, C);
        }
    }
    function _() {
      for (let x = 0; x <= i; x++)
        for (let b = 0; b <= s; b++)
          c.x = x / i, c.y = b / s, f.push(c.x, c.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new z_(
      new W6[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
let q6 = class extends Ol {
  static get type() {
    return "MeshLambertMaterial";
  }
  constructor(r) {
    super(), this.isMeshLambertMaterial = !0, this.color = new Ft(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ft(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = qC, this.normalScale = new Le(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bo(), this.combine = S_, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.lightMap = r.lightMap, this.lightMapIntensity = r.lightMapIntensity, this.aoMap = r.aoMap, this.aoMapIntensity = r.aoMapIntensity, this.emissive.copy(r.emissive), this.emissiveMap = r.emissiveMap, this.emissiveIntensity = r.emissiveIntensity, this.bumpMap = r.bumpMap, this.bumpScale = r.bumpScale, this.normalMap = r.normalMap, this.normalMapType = r.normalMapType, this.normalScale.copy(r.normalScale), this.displacementMap = r.displacementMap, this.displacementScale = r.displacementScale, this.displacementBias = r.displacementBias, this.specularMap = r.specularMap, this.alphaMap = r.alphaMap, this.envMap = r.envMap, this.envMapRotation.copy(r.envMapRotation), this.combine = r.combine, this.reflectivity = r.reflectivity, this.refractionRatio = r.refractionRatio, this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.wireframeLinecap = r.wireframeLinecap, this.wireframeLinejoin = r.wireframeLinejoin, this.flatShading = r.flatShading, this.fog = r.fog, this;
  }
};
const _w = {
  enabled: !1,
  files: {},
  add: function(r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function(r) {
    if (this.enabled !== !1)
      return this.files[r];
  },
  remove: function(r) {
    delete this.files[r];
  },
  clear: function() {
    this.files = {};
  }
};
class X6 {
  constructor(e, i, n) {
    const s = this;
    let a = !1, o = 0, l = 0, u;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = i, this.onError = n, this.itemStart = function(h) {
      l++, a === !1 && s.onStart !== void 0 && s.onStart(h, o, l), a = !0;
    }, this.itemEnd = function(h) {
      o++, s.onProgress !== void 0 && s.onProgress(h, o, l), o === l && (a = !1, s.onLoad !== void 0 && s.onLoad());
    }, this.itemError = function(h) {
      s.onError !== void 0 && s.onError(h);
    }, this.resolveURL = function(h) {
      return u ? u(h) : h;
    }, this.setURLModifier = function(h) {
      return u = h, this;
    }, this.addHandler = function(h, d) {
      return c.push(h, d), this;
    }, this.removeHandler = function(h) {
      const d = c.indexOf(h);
      return d !== -1 && c.splice(d, 2), this;
    }, this.getHandler = function(h) {
      for (let d = 0, p = c.length; d < p; d += 2) {
        const f = c[d], m = c[d + 1];
        if (f.global && (f.lastIndex = 0), f.test(h))
          return m;
      }
      return null;
    };
  }
}
const Y6 = /* @__PURE__ */ new X6();
class j_ {
  constructor(e) {
    this.manager = e !== void 0 ? e : Y6, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, i) {
    const n = this;
    return new Promise(function(s, a) {
      n.load(e, s, i, a);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
j_.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class $6 extends j_ {
  constructor(e) {
    super(e);
  }
  load(e, i, n, s) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const a = this, o = _w.get(e);
    if (o !== void 0)
      return a.manager.itemStart(e), setTimeout(function() {
        i && i(o), a.manager.itemEnd(e);
      }, 0), o;
    const l = dd("img");
    function u() {
      h(), _w.add(e, this), i && i(this), a.manager.itemEnd(e);
    }
    function c(d) {
      h(), s && s(d), a.manager.itemError(e), a.manager.itemEnd(e);
    }
    function h() {
      l.removeEventListener("load", u, !1), l.removeEventListener("error", c, !1);
    }
    return l.addEventListener("load", u, !1), l.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), a.manager.itemStart(e), l.src = e, l;
  }
}
class K6 extends j_ {
  constructor(e) {
    super(e);
  }
  load(e, i, n, s) {
    const a = new Cn(), o = new $6(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(l) {
      a.image = l, a.needsUpdate = !0, i !== void 0 && i(a);
    }, n, s), a;
  }
}
let wR = class extends Hr {
  constructor(r, e = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Ft(r), this.intensity = e;
  }
  dispose() {
  }
  copy(r, e) {
    return super.copy(r, e), this.color.copy(r.color), this.intensity = r.intensity, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (e.object.target = this.target.uuid), e;
  }
};
const Ky = /* @__PURE__ */ new ui(), Tw = /* @__PURE__ */ new X(), Sw = /* @__PURE__ */ new X();
let Q6 = class {
  constructor(r) {
    this.camera = r, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Le(512, 512), this.map = null, this.mapPass = null, this.matrix = new ui(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new I_(), this._frameExtents = new Le(1, 1), this._viewportCount = 1, this._viewports = [
      new Fi(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(r) {
    const e = this.camera, i = this.matrix;
    Tw.setFromMatrixPosition(r.matrixWorld), e.position.copy(Tw), Sw.setFromMatrixPosition(r.target.matrixWorld), e.lookAt(Sw), e.updateMatrixWorld(), Ky.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ky), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(Ky);
  }
  getViewport(r) {
    return this._viewports[r];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(r) {
    return this.camera = r.camera.clone(), this.intensity = r.intensity, this.bias = r.bias, this.radius = r.radius, this.mapSize.copy(r.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const r = {};
    return this.intensity !== 1 && (r.intensity = this.intensity), this.bias !== 0 && (r.bias = this.bias), this.normalBias !== 0 && (r.normalBias = this.normalBias), this.radius !== 1 && (r.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (r.mapSize = this.mapSize.toArray()), r.camera = this.camera.toJSON(!1).object, delete r.camera.matrix, r;
  }
}, Z6 = class extends Q6 {
  constructor() {
    super(new D_(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}, J6 = class extends wR {
  constructor(r, e) {
    super(r, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Hr.DEFAULT_UP), this.updateMatrix(), this.target = new Hr(), this.shadow = new Z6();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(r) {
    return super.copy(r), this.target = r.target.clone(), this.shadow = r.shadow.clone(), this;
  }
}, eV = class extends wR {
  constructor(r, e) {
    super(r, e), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
};
class ER {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = ww(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const i = ww();
      e = (i - this.oldTime) / 1e3, this.oldTime = i, this.elapsedTime += e;
    }
    return e;
  }
}
function ww() {
  return performance.now();
}
const Ew = /* @__PURE__ */ new ui();
class MR {
  constructor(e, i, n = 0, s = 1 / 0) {
    this.ray = new bg(e, i), this.near = n, this.far = s, this.camera = null, this.layers = new P_(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, i) {
    this.ray.set(e, i);
  }
  setFromCamera(e, i) {
    i.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(i.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(i).sub(this.ray.origin).normalize(), this.camera = i) : i.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (i.near + i.far) / (i.near - i.far)).unproject(i), this.ray.direction.set(0, 0, -1).transformDirection(i.matrixWorld), this.camera = i) : console.error("THREE.Raycaster: Unsupported camera type: " + i.type);
  }
  setFromXRController(e) {
    return Ew.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Ew), this;
  }
  intersectObject(e, i = !0, n = []) {
    return Ub(e, this, n, i), n.sort(Mw), n;
  }
  intersectObjects(e, i = !0, n = []) {
    for (let s = 0, a = e.length; s < a; s++)
      Ub(e[s], this, n, i);
    return n.sort(Mw), n;
  }
}
function Mw(r, e) {
  return r.distance - e.distance;
}
function Ub(r, e, i, n) {
  let s = !0;
  if (r.layers.test(e.layers) && r.raycast(e, i) === !1 && (s = !1), s === !0 && n === !0) {
    const a = r.children;
    for (let o = 0, l = a.length; o < l; o++)
      Ub(a[o], e, i, !0);
  }
}
class Aw {
  constructor(e = 1, i = 0, n = 0) {
    return this.radius = e, this.phi = i, this.theta = n, this;
  }
  set(e, i, n) {
    return this.radius = e, this.phi = i, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, i, n) {
    return this.radius = Math.sqrt(e * e + i * i + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos($i(i / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Sg extends Nl {
  constructor(e, i = null) {
    super(), this.object = e, this.domElement = i, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: mg
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = mg);
function AR(r, e, i) {
  var n, s = 1;
  r == null && (r = 0), e == null && (e = 0), i == null && (i = 0);
  function a() {
    var o, l = n.length, u, c = 0, h = 0, d = 0;
    for (o = 0; o < l; ++o)
      u = n[o], c += u.x || 0, h += u.y || 0, d += u.z || 0;
    for (c = (c / l - r) * s, h = (h / l - e) * s, d = (d / l - i) * s, o = 0; o < l; ++o)
      u = n[o], c && (u.x -= c), h && (u.y -= h), d && (u.z -= d);
  }
  return a.initialize = function(o) {
    n = o;
  }, a.x = function(o) {
    return arguments.length ? (r = +o, a) : r;
  }, a.y = function(o) {
    return arguments.length ? (e = +o, a) : e;
  }, a.z = function(o) {
    return arguments.length ? (i = +o, a) : i;
  }, a.strength = function(o) {
    return arguments.length ? (s = +o, a) : s;
  }, a;
}
function tV(r) {
  const e = +this._x.call(null, r);
  return CR(this.cover(e), e, r);
}
function CR(r, e, i) {
  if (isNaN(e)) return r;
  var n, s = r._root, a = { data: i }, o = r._x0, l = r._x1, u, c, h, d, p;
  if (!s) return r._root = a, r;
  for (; s.length; )
    if ((h = e >= (u = (o + l) / 2)) ? o = u : l = u, n = s, !(s = s[d = +h])) return n[d] = a, r;
  if (c = +r._x.call(null, s.data), e === c) return a.next = s, n ? n[d] = a : r._root = a, r;
  do
    n = n ? n[d] = new Array(2) : r._root = new Array(2), (h = e >= (u = (o + l) / 2)) ? o = u : l = u;
  while ((d = +h) == (p = +(c >= u)));
  return n[p] = s, n[d] = a, r;
}
function iV(r) {
  Array.isArray(r) || (r = Array.from(r));
  const e = r.length, i = new Float64Array(e);
  let n = 1 / 0, s = -1 / 0;
  for (let a = 0, o; a < e; ++a)
    isNaN(o = +this._x.call(null, r[a])) || (i[a] = o, o < n && (n = o), o > s && (s = o));
  if (n > s) return this;
  this.cover(n).cover(s);
  for (let a = 0; a < e; ++a)
    CR(this, i[a], r[a]);
  return this;
}
function rV(r) {
  if (isNaN(r = +r)) return this;
  var e = this._x0, i = this._x1;
  if (isNaN(e))
    i = (e = Math.floor(r)) + 1;
  else {
    for (var n = i - e || 1, s = this._root, a, o; e > r || r >= i; )
      switch (o = +(r < e), a = new Array(2), a[o] = s, s = a, n *= 2, o) {
        case 0:
          i = e + n;
          break;
        case 1:
          e = i - n;
          break;
      }
    this._root && this._root.length && (this._root = s);
  }
  return this._x0 = e, this._x1 = i, this;
}
function nV() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function sV(r) {
  return arguments.length ? this.cover(+r[0][0]).cover(+r[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
}
function fa(r, e, i) {
  this.node = r, this.x0 = e, this.x1 = i;
}
function aV(r, e) {
  var i, n = this._x0, s, a, o = this._x1, l = [], u = this._root, c, h;
  for (u && l.push(new fa(u, n, o)), e == null ? e = 1 / 0 : (n = r - e, o = r + e); c = l.pop(); )
    if (!(!(u = c.node) || (s = c.x0) > o || (a = c.x1) < n))
      if (u.length) {
        var d = (s + a) / 2;
        l.push(
          new fa(u[1], d, a),
          new fa(u[0], s, d)
        ), (h = +(r >= d)) && (c = l[l.length - 1], l[l.length - 1] = l[l.length - 1 - h], l[l.length - 1 - h] = c);
      } else {
        var p = Math.abs(r - +this._x.call(null, u.data));
        p < e && (e = p, n = r - p, o = r + p, i = u.data);
      }
  return i;
}
function oV(r) {
  if (isNaN(u = +this._x.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._x1, u, c, h, d, p;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((h = u >= (c = (o + l) / 2)) ? o = c : l = c, e = i, !(i = i[d = +h])) return this;
    if (!i.length) break;
    e[d + 1 & 1] && (n = e, p = d);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[d] = a : delete e[d], (i = e[0] || e[1]) && i === (e[1] || e[0]) && !i.length && (n ? n[p] = i : this._root = i), this) : (this._root = a, this);
}
function lV(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function uV() {
  return this._root;
}
function cV() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function hV(r) {
  var e = [], i, n = this._root, s, a, o;
  for (n && e.push(new fa(n, this._x0, this._x1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.x1) && n.length) {
      var l = (a + o) / 2;
      (s = n[1]) && e.push(new fa(s, l, o)), (s = n[0]) && e.push(new fa(s, a, l));
    }
  return this;
}
function dV(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new fa(this._root, this._x0, this._x1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.x1, u = (o + l) / 2;
      (a = s[0]) && e.push(new fa(a, o, u)), (a = s[1]) && e.push(new fa(a, u, l));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.x1);
  return this;
}
function pV(r) {
  return r[0];
}
function fV(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function RR(r, e) {
  var i = new V_(e ?? pV, NaN, NaN);
  return r == null ? i : i.addAll(r);
}
function V_(r, e, i) {
  this._x = r, this._x0 = e, this._x1 = i, this._root = void 0;
}
function Cw(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var Xr = RR.prototype = V_.prototype;
Xr.copy = function() {
  var r = new V_(this._x, this._x0, this._x1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = Cw(e), r;
  for (i = [{ source: e, target: r._root = new Array(2) }]; e = i.pop(); )
    for (var s = 0; s < 2; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(2) }) : e.target[s] = Cw(n));
  return r;
};
Xr.add = tV;
Xr.addAll = iV;
Xr.cover = rV;
Xr.data = nV;
Xr.extent = sV;
Xr.find = aV;
Xr.remove = oV;
Xr.removeAll = lV;
Xr.root = uV;
Xr.size = cV;
Xr.visit = hV;
Xr.visitAfter = dV;
Xr.x = fV;
function mV(r) {
  const e = +this._x.call(null, r), i = +this._y.call(null, r);
  return NR(this.cover(e, i), e, i, r);
}
function NR(r, e, i, n) {
  if (isNaN(e) || isNaN(i)) return r;
  var s, a = r._root, o = { data: n }, l = r._x0, u = r._y0, c = r._x1, h = r._y1, d, p, f, m, v, y, g, _;
  if (!a) return r._root = o, r;
  for (; a.length; )
    if ((v = e >= (d = (l + c) / 2)) ? l = d : c = d, (y = i >= (p = (u + h) / 2)) ? u = p : h = p, s = a, !(a = a[g = y << 1 | v])) return s[g] = o, r;
  if (f = +r._x.call(null, a.data), m = +r._y.call(null, a.data), e === f && i === m) return o.next = a, s ? s[g] = o : r._root = o, r;
  do
    s = s ? s[g] = new Array(4) : r._root = new Array(4), (v = e >= (d = (l + c) / 2)) ? l = d : c = d, (y = i >= (p = (u + h) / 2)) ? u = p : h = p;
  while ((g = y << 1 | v) === (_ = (m >= p) << 1 | f >= d));
  return s[_] = a, s[g] = o, r;
}
function gV(r) {
  var e, i, n = r.length, s, a, o = new Array(n), l = new Array(n), u = 1 / 0, c = 1 / 0, h = -1 / 0, d = -1 / 0;
  for (i = 0; i < n; ++i)
    isNaN(s = +this._x.call(null, e = r[i])) || isNaN(a = +this._y.call(null, e)) || (o[i] = s, l[i] = a, s < u && (u = s), s > h && (h = s), a < c && (c = a), a > d && (d = a));
  if (u > h || c > d) return this;
  for (this.cover(u, c).cover(h, d), i = 0; i < n; ++i)
    NR(this, o[i], l[i], r[i]);
  return this;
}
function yV(r, e) {
  if (isNaN(r = +r) || isNaN(e = +e)) return this;
  var i = this._x0, n = this._y0, s = this._x1, a = this._y1;
  if (isNaN(i))
    s = (i = Math.floor(r)) + 1, a = (n = Math.floor(e)) + 1;
  else {
    for (var o = s - i || 1, l = this._root, u, c; i > r || r >= s || n > e || e >= a; )
      switch (c = (e < n) << 1 | r < i, u = new Array(4), u[c] = l, l = u, o *= 2, c) {
        case 0:
          s = i + o, a = n + o;
          break;
        case 1:
          i = s - o, a = n + o;
          break;
        case 2:
          s = i + o, n = a - o;
          break;
        case 3:
          i = s - o, n = a - o;
          break;
      }
    this._root && this._root.length && (this._root = l);
  }
  return this._x0 = i, this._y0 = n, this._x1 = s, this._y1 = a, this;
}
function vV() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function bV(r) {
  return arguments.length ? this.cover(+r[0][0], +r[0][1]).cover(+r[1][0], +r[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function wr(r, e, i, n, s) {
  this.node = r, this.x0 = e, this.y0 = i, this.x1 = n, this.y1 = s;
}
function xV(r, e, i) {
  var n, s = this._x0, a = this._y0, o, l, u, c, h = this._x1, d = this._y1, p = [], f = this._root, m, v;
  for (f && p.push(new wr(f, s, a, h, d)), i == null ? i = 1 / 0 : (s = r - i, a = e - i, h = r + i, d = e + i, i *= i); m = p.pop(); )
    if (!(!(f = m.node) || (o = m.x0) > h || (l = m.y0) > d || (u = m.x1) < s || (c = m.y1) < a))
      if (f.length) {
        var y = (o + u) / 2, g = (l + c) / 2;
        p.push(
          new wr(f[3], y, g, u, c),
          new wr(f[2], o, g, y, c),
          new wr(f[1], y, l, u, g),
          new wr(f[0], o, l, y, g)
        ), (v = (e >= g) << 1 | r >= y) && (m = p[p.length - 1], p[p.length - 1] = p[p.length - 1 - v], p[p.length - 1 - v] = m);
      } else {
        var _ = r - +this._x.call(null, f.data), x = e - +this._y.call(null, f.data), b = _ * _ + x * x;
        if (b < i) {
          var T = Math.sqrt(i = b);
          s = r - T, a = e - T, h = r + T, d = e + T, n = f.data;
        }
      }
  return n;
}
function _V(r) {
  if (isNaN(h = +this._x.call(null, r)) || isNaN(d = +this._y.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._y0, u = this._x1, c = this._y1, h, d, p, f, m, v, y, g;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((m = h >= (p = (o + u) / 2)) ? o = p : u = p, (v = d >= (f = (l + c) / 2)) ? l = f : c = f, e = i, !(i = i[y = v << 1 | m])) return this;
    if (!i.length) break;
    (e[y + 1 & 3] || e[y + 2 & 3] || e[y + 3 & 3]) && (n = e, g = y);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[y] = a : delete e[y], (i = e[0] || e[1] || e[2] || e[3]) && i === (e[3] || e[2] || e[1] || e[0]) && !i.length && (n ? n[g] = i : this._root = i), this) : (this._root = a, this);
}
function TV(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function SV() {
  return this._root;
}
function wV() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function EV(r) {
  var e = [], i, n = this._root, s, a, o, l, u;
  for (n && e.push(new wr(n, this._x0, this._y0, this._x1, this._y1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.y0, l = i.x1, u = i.y1) && n.length) {
      var c = (a + l) / 2, h = (o + u) / 2;
      (s = n[3]) && e.push(new wr(s, c, h, l, u)), (s = n[2]) && e.push(new wr(s, a, h, c, u)), (s = n[1]) && e.push(new wr(s, c, o, l, h)), (s = n[0]) && e.push(new wr(s, a, o, c, h));
    }
  return this;
}
function MV(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new wr(this._root, this._x0, this._y0, this._x1, this._y1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.y0, u = n.x1, c = n.y1, h = (o + u) / 2, d = (l + c) / 2;
      (a = s[0]) && e.push(new wr(a, o, l, h, d)), (a = s[1]) && e.push(new wr(a, h, l, u, d)), (a = s[2]) && e.push(new wr(a, o, d, h, c)), (a = s[3]) && e.push(new wr(a, h, d, u, c));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.y0, n.x1, n.y1);
  return this;
}
function AV(r) {
  return r[0];
}
function CV(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function RV(r) {
  return r[1];
}
function NV(r) {
  return arguments.length ? (this._y = r, this) : this._y;
}
function PR(r, e, i) {
  var n = new G_(e ?? AV, i ?? RV, NaN, NaN, NaN, NaN);
  return r == null ? n : n.addAll(r);
}
function G_(r, e, i, n, s, a) {
  this._x = r, this._y = e, this._x0 = i, this._y0 = n, this._x1 = s, this._y1 = a, this._root = void 0;
}
function Rw(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var Pr = PR.prototype = G_.prototype;
Pr.copy = function() {
  var r = new G_(this._x, this._y, this._x0, this._y0, this._x1, this._y1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = Rw(e), r;
  for (i = [{ source: e, target: r._root = new Array(4) }]; e = i.pop(); )
    for (var s = 0; s < 4; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(4) }) : e.target[s] = Rw(n));
  return r;
};
Pr.add = mV;
Pr.addAll = gV;
Pr.cover = yV;
Pr.data = vV;
Pr.extent = bV;
Pr.find = xV;
Pr.remove = _V;
Pr.removeAll = TV;
Pr.root = SV;
Pr.size = wV;
Pr.visit = EV;
Pr.visitAfter = MV;
Pr.x = CV;
Pr.y = NV;
function PV(r) {
  const e = +this._x.call(null, r), i = +this._y.call(null, r), n = +this._z.call(null, r);
  return OR(this.cover(e, i, n), e, i, n, r);
}
function OR(r, e, i, n, s) {
  if (isNaN(e) || isNaN(i) || isNaN(n)) return r;
  var a, o = r._root, l = { data: s }, u = r._x0, c = r._y0, h = r._z0, d = r._x1, p = r._y1, f = r._z1, m, v, y, g, _, x, b, T, S, w, C;
  if (!o) return r._root = l, r;
  for (; o.length; )
    if ((b = e >= (m = (u + d) / 2)) ? u = m : d = m, (T = i >= (v = (c + p) / 2)) ? c = v : p = v, (S = n >= (y = (h + f) / 2)) ? h = y : f = y, a = o, !(o = o[w = S << 2 | T << 1 | b])) return a[w] = l, r;
  if (g = +r._x.call(null, o.data), _ = +r._y.call(null, o.data), x = +r._z.call(null, o.data), e === g && i === _ && n === x) return l.next = o, a ? a[w] = l : r._root = l, r;
  do
    a = a ? a[w] = new Array(8) : r._root = new Array(8), (b = e >= (m = (u + d) / 2)) ? u = m : d = m, (T = i >= (v = (c + p) / 2)) ? c = v : p = v, (S = n >= (y = (h + f) / 2)) ? h = y : f = y;
  while ((w = S << 2 | T << 1 | b) === (C = (x >= y) << 2 | (_ >= v) << 1 | g >= m));
  return a[C] = o, a[w] = l, r;
}
function OV(r) {
  Array.isArray(r) || (r = Array.from(r));
  const e = r.length, i = new Float64Array(e), n = new Float64Array(e), s = new Float64Array(e);
  let a = 1 / 0, o = 1 / 0, l = 1 / 0, u = -1 / 0, c = -1 / 0, h = -1 / 0;
  for (let d = 0, p, f, m, v; d < e; ++d)
    isNaN(f = +this._x.call(null, p = r[d])) || isNaN(m = +this._y.call(null, p)) || isNaN(v = +this._z.call(null, p)) || (i[d] = f, n[d] = m, s[d] = v, f < a && (a = f), f > u && (u = f), m < o && (o = m), m > c && (c = m), v < l && (l = v), v > h && (h = v));
  if (a > u || o > c || l > h) return this;
  this.cover(a, o, l).cover(u, c, h);
  for (let d = 0; d < e; ++d)
    OR(this, i[d], n[d], s[d], r[d]);
  return this;
}
function IV(r, e, i) {
  if (isNaN(r = +r) || isNaN(e = +e) || isNaN(i = +i)) return this;
  var n = this._x0, s = this._y0, a = this._z0, o = this._x1, l = this._y1, u = this._z1;
  if (isNaN(n))
    o = (n = Math.floor(r)) + 1, l = (s = Math.floor(e)) + 1, u = (a = Math.floor(i)) + 1;
  else {
    for (var c = o - n || 1, h = this._root, d, p; n > r || r >= o || s > e || e >= l || a > i || i >= u; )
      switch (p = (i < a) << 2 | (e < s) << 1 | r < n, d = new Array(8), d[p] = h, h = d, c *= 2, p) {
        case 0:
          o = n + c, l = s + c, u = a + c;
          break;
        case 1:
          n = o - c, l = s + c, u = a + c;
          break;
        case 2:
          o = n + c, s = l - c, u = a + c;
          break;
        case 3:
          n = o - c, s = l - c, u = a + c;
          break;
        case 4:
          o = n + c, l = s + c, a = u - c;
          break;
        case 5:
          n = o - c, l = s + c, a = u - c;
          break;
        case 6:
          o = n + c, s = l - c, a = u - c;
          break;
        case 7:
          n = o - c, s = l - c, a = u - c;
          break;
      }
    this._root && this._root.length && (this._root = h);
  }
  return this._x0 = n, this._y0 = s, this._z0 = a, this._x1 = o, this._y1 = l, this._z1 = u, this;
}
function DV() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function kV(r) {
  return arguments.length ? this.cover(+r[0][0], +r[0][1], +r[0][2]).cover(+r[1][0], +r[1][1], +r[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
}
function ri(r, e, i, n, s, a, o) {
  this.node = r, this.x0 = e, this.y0 = i, this.z0 = n, this.x1 = s, this.y1 = a, this.z1 = o;
}
function LV(r, e, i, n) {
  var s, a = this._x0, o = this._y0, l = this._z0, u, c, h, d, p, f, m = this._x1, v = this._y1, y = this._z1, g = [], _ = this._root, x, b;
  for (_ && g.push(new ri(_, a, o, l, m, v, y)), n == null ? n = 1 / 0 : (a = r - n, o = e - n, l = i - n, m = r + n, v = e + n, y = i + n, n *= n); x = g.pop(); )
    if (!(!(_ = x.node) || (u = x.x0) > m || (c = x.y0) > v || (h = x.z0) > y || (d = x.x1) < a || (p = x.y1) < o || (f = x.z1) < l))
      if (_.length) {
        var T = (u + d) / 2, S = (c + p) / 2, w = (h + f) / 2;
        g.push(
          new ri(_[7], T, S, w, d, p, f),
          new ri(_[6], u, S, w, T, p, f),
          new ri(_[5], T, c, w, d, S, f),
          new ri(_[4], u, c, w, T, S, f),
          new ri(_[3], T, S, h, d, p, w),
          new ri(_[2], u, S, h, T, p, w),
          new ri(_[1], T, c, h, d, S, w),
          new ri(_[0], u, c, h, T, S, w)
        ), (b = (i >= w) << 2 | (e >= S) << 1 | r >= T) && (x = g[g.length - 1], g[g.length - 1] = g[g.length - 1 - b], g[g.length - 1 - b] = x);
      } else {
        var C = r - +this._x.call(null, _.data), E = e - +this._y.call(null, _.data), A = i - +this._z.call(null, _.data), N = C * C + E * E + A * A;
        if (N < n) {
          var L = Math.sqrt(n = N);
          a = r - L, o = e - L, l = i - L, m = r + L, v = e + L, y = i + L, s = _.data;
        }
      }
  return s;
}
const UV = (r, e, i, n, s, a) => Math.sqrt((r - n) ** 2 + (e - s) ** 2 + (i - a) ** 2);
function FV(r, e, i, n) {
  const s = [], a = r - n, o = e - n, l = i - n, u = r + n, c = e + n, h = i + n;
  return this.visit((d, p, f, m, v, y, g) => {
    if (!d.length)
      do {
        const _ = d.data;
        UV(r, e, i, this._x(_), this._y(_), this._z(_)) <= n && s.push(_);
      } while (d = d.next);
    return p > u || f > c || m > h || v < a || y < o || g < l;
  }), s;
}
function BV(r) {
  if (isNaN(p = +this._x.call(null, r)) || isNaN(f = +this._y.call(null, r)) || isNaN(m = +this._z.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._y0, u = this._z0, c = this._x1, h = this._y1, d = this._z1, p, f, m, v, y, g, _, x, b, T, S;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((_ = p >= (v = (o + c) / 2)) ? o = v : c = v, (x = f >= (y = (l + h) / 2)) ? l = y : h = y, (b = m >= (g = (u + d) / 2)) ? u = g : d = g, e = i, !(i = i[T = b << 2 | x << 1 | _])) return this;
    if (!i.length) break;
    (e[T + 1 & 7] || e[T + 2 & 7] || e[T + 3 & 7] || e[T + 4 & 7] || e[T + 5 & 7] || e[T + 6 & 7] || e[T + 7 & 7]) && (n = e, S = T);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[T] = a : delete e[T], (i = e[0] || e[1] || e[2] || e[3] || e[4] || e[5] || e[6] || e[7]) && i === (e[7] || e[6] || e[5] || e[4] || e[3] || e[2] || e[1] || e[0]) && !i.length && (n ? n[S] = i : this._root = i), this) : (this._root = a, this);
}
function zV(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function jV() {
  return this._root;
}
function VV() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function GV(r) {
  var e = [], i, n = this._root, s, a, o, l, u, c, h;
  for (n && e.push(new ri(n, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.y0, l = i.z0, u = i.x1, c = i.y1, h = i.z1) && n.length) {
      var d = (a + u) / 2, p = (o + c) / 2, f = (l + h) / 2;
      (s = n[7]) && e.push(new ri(s, d, p, f, u, c, h)), (s = n[6]) && e.push(new ri(s, a, p, f, d, c, h)), (s = n[5]) && e.push(new ri(s, d, o, f, u, p, h)), (s = n[4]) && e.push(new ri(s, a, o, f, d, p, h)), (s = n[3]) && e.push(new ri(s, d, p, l, u, c, f)), (s = n[2]) && e.push(new ri(s, a, p, l, d, c, f)), (s = n[1]) && e.push(new ri(s, d, o, l, u, p, f)), (s = n[0]) && e.push(new ri(s, a, o, l, d, p, f));
    }
  return this;
}
function HV(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new ri(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.y0, u = n.z0, c = n.x1, h = n.y1, d = n.z1, p = (o + c) / 2, f = (l + h) / 2, m = (u + d) / 2;
      (a = s[0]) && e.push(new ri(a, o, l, u, p, f, m)), (a = s[1]) && e.push(new ri(a, p, l, u, c, f, m)), (a = s[2]) && e.push(new ri(a, o, f, u, p, h, m)), (a = s[3]) && e.push(new ri(a, p, f, u, c, h, m)), (a = s[4]) && e.push(new ri(a, o, l, m, p, f, d)), (a = s[5]) && e.push(new ri(a, p, l, m, c, f, d)), (a = s[6]) && e.push(new ri(a, o, f, m, p, h, d)), (a = s[7]) && e.push(new ri(a, p, f, m, c, h, d));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.y0, n.z0, n.x1, n.y1, n.z1);
  return this;
}
function WV(r) {
  return r[0];
}
function qV(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function XV(r) {
  return r[1];
}
function YV(r) {
  return arguments.length ? (this._y = r, this) : this._y;
}
function $V(r) {
  return r[2];
}
function KV(r) {
  return arguments.length ? (this._z = r, this) : this._z;
}
function IR(r, e, i, n) {
  var s = new H_(e ?? WV, i ?? XV, n ?? $V, NaN, NaN, NaN, NaN, NaN, NaN);
  return r == null ? s : s.addAll(r);
}
function H_(r, e, i, n, s, a, o, l, u) {
  this._x = r, this._y = e, this._z = i, this._x0 = n, this._y0 = s, this._z0 = a, this._x1 = o, this._y1 = l, this._z1 = u, this._root = void 0;
}
function Nw(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var sr = IR.prototype = H_.prototype;
sr.copy = function() {
  var r = new H_(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = Nw(e), r;
  for (i = [{ source: e, target: r._root = new Array(8) }]; e = i.pop(); )
    for (var s = 0; s < 8; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(8) }) : e.target[s] = Nw(n));
  return r;
};
sr.add = PV;
sr.addAll = OV;
sr.cover = IV;
sr.data = DV;
sr.extent = kV;
sr.find = LV;
sr.findAllWithinRadius = FV;
sr.remove = BV;
sr.removeAll = zV;
sr.root = jV;
sr.size = VV;
sr.visit = GV;
sr.visitAfter = HV;
sr.x = qV;
sr.y = YV;
sr.z = KV;
function la(r) {
  return function() {
    return r;
  };
}
function Ks(r) {
  return (r() - 0.5) * 1e-6;
}
function QV(r) {
  return r.index;
}
function Pw(r, e) {
  var i = r.get(e);
  if (!i) throw new Error("node not found: " + e);
  return i;
}
function DR(r) {
  var e = QV, i = p, n, s = la(30), a, o, l, u, c, h, d = 1;
  r == null && (r = []);
  function p(g) {
    return 1 / Math.min(u[g.source.index], u[g.target.index]);
  }
  function f(g) {
    for (var _ = 0, x = r.length; _ < d; ++_)
      for (var b = 0, T, S, w, C = 0, E = 0, A = 0, N, L; b < x; ++b)
        T = r[b], S = T.source, w = T.target, C = w.x + w.vx - S.x - S.vx || Ks(h), l > 1 && (E = w.y + w.vy - S.y - S.vy || Ks(h)), l > 2 && (A = w.z + w.vz - S.z - S.vz || Ks(h)), N = Math.sqrt(C * C + E * E + A * A), N = (N - a[b]) / N * g * n[b], C *= N, E *= N, A *= N, w.vx -= C * (L = c[b]), l > 1 && (w.vy -= E * L), l > 2 && (w.vz -= A * L), S.vx += C * (L = 1 - L), l > 1 && (S.vy += E * L), l > 2 && (S.vz += A * L);
  }
  function m() {
    if (o) {
      var g, _ = o.length, x = r.length, b = new Map(o.map((S, w) => [e(S, w, o), S])), T;
      for (g = 0, u = new Array(_); g < x; ++g)
        T = r[g], T.index = g, typeof T.source != "object" && (T.source = Pw(b, T.source)), typeof T.target != "object" && (T.target = Pw(b, T.target)), u[T.source.index] = (u[T.source.index] || 0) + 1, u[T.target.index] = (u[T.target.index] || 0) + 1;
      for (g = 0, c = new Array(x); g < x; ++g)
        T = r[g], c[g] = u[T.source.index] / (u[T.source.index] + u[T.target.index]);
      n = new Array(x), v(), a = new Array(x), y();
    }
  }
  function v() {
    if (o)
      for (var g = 0, _ = r.length; g < _; ++g)
        n[g] = +i(r[g], g, r);
  }
  function y() {
    if (o)
      for (var g = 0, _ = r.length; g < _; ++g)
        a[g] = +s(r[g], g, r);
  }
  return f.initialize = function(g, ..._) {
    o = g, h = _.find((x) => typeof x == "function") || Math.random, l = _.find((x) => [1, 2, 3].includes(x)) || 2, m();
  }, f.links = function(g) {
    return arguments.length ? (r = g, m(), f) : r;
  }, f.id = function(g) {
    return arguments.length ? (e = g, f) : e;
  }, f.iterations = function(g) {
    return arguments.length ? (d = +g, f) : d;
  }, f.strength = function(g) {
    return arguments.length ? (i = typeof g == "function" ? g : la(+g), v(), f) : i;
  }, f.distance = function(g) {
    return arguments.length ? (s = typeof g == "function" ? g : la(+g), y(), f) : s;
  }, f;
}
var ZV = { value: () => {
} };
function Hd() {
  for (var r = 0, e = arguments.length, i = {}, n; r < e; ++r) {
    if (!(n = arguments[r] + "") || n in i || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    i[n] = [];
  }
  return new Zf(i);
}
function Zf(r) {
  this._ = r;
}
function JV(r, e) {
  return r.trim().split(/^|\s+/).map(function(i) {
    var n = "", s = i.indexOf(".");
    if (s >= 0 && (n = i.slice(s + 1), i = i.slice(0, s)), i && !e.hasOwnProperty(i)) throw new Error("unknown type: " + i);
    return { type: i, name: n };
  });
}
Zf.prototype = Hd.prototype = {
  constructor: Zf,
  on: function(r, e) {
    var i = this._, n = JV(r + "", i), s, a = -1, o = n.length;
    if (arguments.length < 2) {
      for (; ++a < o; ) if ((s = (r = n[a]).type) && (s = eG(i[s], r.name))) return s;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++a < o; )
      if (s = (r = n[a]).type) i[s] = Ow(i[s], r.name, e);
      else if (e == null) for (s in i) i[s] = Ow(i[s], r.name, null);
    return this;
  },
  copy: function() {
    var r = {}, e = this._;
    for (var i in e) r[i] = e[i].slice();
    return new Zf(r);
  },
  call: function(r, e) {
    if ((s = arguments.length - 2) > 0) for (var i = new Array(s), n = 0, s, a; n < s; ++n) i[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    for (a = this._[r], n = 0, s = a.length; n < s; ++n) a[n].value.apply(e, i);
  },
  apply: function(r, e, i) {
    if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    for (var n = this._[r], s = 0, a = n.length; s < a; ++s) n[s].value.apply(e, i);
  }
};
function eG(r, e) {
  for (var i = 0, n = r.length, s; i < n; ++i)
    if ((s = r[i]).name === e)
      return s.value;
}
function Ow(r, e, i) {
  for (var n = 0, s = r.length; n < s; ++n)
    if (r[n].name === e) {
      r[n] = ZV, r = r.slice(0, n).concat(r.slice(n + 1));
      break;
    }
  return i != null && r.push({ name: e, value: i }), r;
}
var vc = 0, Bh = 0, ch = 0, kR = 1e3, xm, zh, _m = 0, Sl = 0, wg = 0, pd = typeof performance == "object" && performance.now ? performance : Date, LR = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(r) {
  setTimeout(r, 17);
};
function W_() {
  return Sl || (LR(tG), Sl = pd.now() + wg);
}
function tG() {
  Sl = 0;
}
function Tm() {
  this._call = this._time = this._next = null;
}
Tm.prototype = q_.prototype = {
  constructor: Tm,
  restart: function(r, e, i) {
    if (typeof r != "function") throw new TypeError("callback is not a function");
    i = (i == null ? W_() : +i) + (e == null ? 0 : +e), !this._next && zh !== this && (zh ? zh._next = this : xm = this, zh = this), this._call = r, this._time = i, Fb();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Fb());
  }
};
function q_(r, e, i) {
  var n = new Tm();
  return n.restart(r, e, i), n;
}
function iG() {
  W_(), ++vc;
  for (var r = xm, e; r; )
    (e = Sl - r._time) >= 0 && r._call.call(void 0, e), r = r._next;
  --vc;
}
function Iw() {
  Sl = (_m = pd.now()) + wg, vc = Bh = 0;
  try {
    iG();
  } finally {
    vc = 0, nG(), Sl = 0;
  }
}
function rG() {
  var r = pd.now(), e = r - _m;
  e > kR && (wg -= e, _m = r);
}
function nG() {
  for (var r, e = xm, i, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), r = e, e = e._next) : (i = e._next, e._next = null, e = r ? r._next = i : xm = i);
  zh = r, Fb(n);
}
function Fb(r) {
  if (!vc) {
    Bh && (Bh = clearTimeout(Bh));
    var e = r - Sl;
    e > 24 ? (r < 1 / 0 && (Bh = setTimeout(Iw, r - pd.now() - wg)), ch && (ch = clearInterval(ch))) : (ch || (_m = pd.now(), ch = setInterval(rG, kR)), vc = 1, LR(Iw));
  }
}
function Dw(r, e, i) {
  var n = new Tm();
  return e = e == null ? 0 : +e, n.restart((s) => {
    n.stop(), r(s + e);
  }, e, i), n;
}
const sG = 1664525, aG = 1013904223, kw = 4294967296;
function oG() {
  let r = 1;
  return () => (r = (sG * r + aG) % kw) / kw;
}
var Lw = 3;
function Qy(r) {
  return r.x;
}
function Uw(r) {
  return r.y;
}
function lG(r) {
  return r.z;
}
var uG = 10, cG = Math.PI * (3 - Math.sqrt(5)), hG = Math.PI * 20 / (9 + Math.sqrt(221));
function UR(r, e) {
  e = e || 2;
  var i = Math.min(Lw, Math.max(1, Math.round(e))), n, s = 1, a = 1e-3, o = 1 - Math.pow(a, 1 / 300), l = 0, u = 0.6, c = /* @__PURE__ */ new Map(), h = q_(f), d = Hd("tick", "end"), p = oG();
  r == null && (r = []);
  function f() {
    m(), d.call("tick", n), s < a && (h.stop(), d.call("end", n));
  }
  function m(g) {
    var _, x = r.length, b;
    g === void 0 && (g = 1);
    for (var T = 0; T < g; ++T)
      for (s += (l - s) * o, c.forEach(function(S) {
        S(s);
      }), _ = 0; _ < x; ++_)
        b = r[_], b.fx == null ? b.x += b.vx *= u : (b.x = b.fx, b.vx = 0), i > 1 && (b.fy == null ? b.y += b.vy *= u : (b.y = b.fy, b.vy = 0)), i > 2 && (b.fz == null ? b.z += b.vz *= u : (b.z = b.fz, b.vz = 0));
    return n;
  }
  function v() {
    for (var g = 0, _ = r.length, x; g < _; ++g) {
      if (x = r[g], x.index = g, x.fx != null && (x.x = x.fx), x.fy != null && (x.y = x.fy), x.fz != null && (x.z = x.fz), isNaN(x.x) || i > 1 && isNaN(x.y) || i > 2 && isNaN(x.z)) {
        var b = uG * (i > 2 ? Math.cbrt(0.5 + g) : i > 1 ? Math.sqrt(0.5 + g) : g), T = g * cG, S = g * hG;
        i === 1 ? x.x = b : i === 2 ? (x.x = b * Math.cos(T), x.y = b * Math.sin(T)) : (x.x = b * Math.sin(T) * Math.cos(S), x.y = b * Math.cos(T), x.z = b * Math.sin(T) * Math.sin(S));
      }
      (isNaN(x.vx) || i > 1 && isNaN(x.vy) || i > 2 && isNaN(x.vz)) && (x.vx = 0, i > 1 && (x.vy = 0), i > 2 && (x.vz = 0));
    }
  }
  function y(g) {
    return g.initialize && g.initialize(r, p, i), g;
  }
  return v(), n = {
    tick: m,
    restart: function() {
      return h.restart(f), n;
    },
    stop: function() {
      return h.stop(), n;
    },
    numDimensions: function(g) {
      return arguments.length ? (i = Math.min(Lw, Math.max(1, Math.round(g))), c.forEach(y), n) : i;
    },
    nodes: function(g) {
      return arguments.length ? (r = g, v(), c.forEach(y), n) : r;
    },
    alpha: function(g) {
      return arguments.length ? (s = +g, n) : s;
    },
    alphaMin: function(g) {
      return arguments.length ? (a = +g, n) : a;
    },
    alphaDecay: function(g) {
      return arguments.length ? (o = +g, n) : +o;
    },
    alphaTarget: function(g) {
      return arguments.length ? (l = +g, n) : l;
    },
    velocityDecay: function(g) {
      return arguments.length ? (u = 1 - g, n) : 1 - u;
    },
    randomSource: function(g) {
      return arguments.length ? (p = g, c.forEach(y), n) : p;
    },
    force: function(g, _) {
      return arguments.length > 1 ? (_ == null ? c.delete(g) : c.set(g, y(_)), n) : c.get(g);
    },
    find: function() {
      var g = Array.prototype.slice.call(arguments), _ = g.shift() || 0, x = (i > 1 ? g.shift() : null) || 0, b = (i > 2 ? g.shift() : null) || 0, T = g.shift() || 1 / 0, S = 0, w = r.length, C, E, A, N, L, F;
      for (T *= T, S = 0; S < w; ++S)
        L = r[S], C = _ - L.x, E = x - (L.y || 0), A = b - (L.z || 0), N = C * C + E * E + A * A, N < T && (F = L, T = N);
      return F;
    },
    on: function(g, _) {
      return arguments.length > 1 ? (d.on(g, _), n) : d.on(g);
    }
  };
}
function FR() {
  var r, e, i, n, s, a = la(-30), o, l = 1, u = 1 / 0, c = 0.81;
  function h(m) {
    var v, y = r.length, g = (e === 1 ? RR(r, Qy) : e === 2 ? PR(r, Qy, Uw) : e === 3 ? IR(r, Qy, Uw, lG) : null).visitAfter(p);
    for (s = m, v = 0; v < y; ++v) i = r[v], g.visit(f);
  }
  function d() {
    if (r) {
      var m, v = r.length, y;
      for (o = new Array(v), m = 0; m < v; ++m) y = r[m], o[y.index] = +a(y, m, r);
    }
  }
  function p(m) {
    var v = 0, y, g, _ = 0, x, b, T, S, w = m.length;
    if (w) {
      for (x = b = T = S = 0; S < w; ++S)
        (y = m[S]) && (g = Math.abs(y.value)) && (v += y.value, _ += g, x += g * (y.x || 0), b += g * (y.y || 0), T += g * (y.z || 0));
      v *= Math.sqrt(4 / w), m.x = x / _, e > 1 && (m.y = b / _), e > 2 && (m.z = T / _);
    } else {
      y = m, y.x = y.data.x, e > 1 && (y.y = y.data.y), e > 2 && (y.z = y.data.z);
      do
        v += o[y.data.index];
      while (y = y.next);
    }
    m.value = v;
  }
  function f(m, v, y, g, _) {
    if (!m.value) return !0;
    var x = [y, g, _][e - 1], b = m.x - i.x, T = e > 1 ? m.y - i.y : 0, S = e > 2 ? m.z - i.z : 0, w = x - v, C = b * b + T * T + S * S;
    if (w * w / c < C)
      return C < u && (b === 0 && (b = Ks(n), C += b * b), e > 1 && T === 0 && (T = Ks(n), C += T * T), e > 2 && S === 0 && (S = Ks(n), C += S * S), C < l && (C = Math.sqrt(l * C)), i.vx += b * m.value * s / C, e > 1 && (i.vy += T * m.value * s / C), e > 2 && (i.vz += S * m.value * s / C)), !0;
    if (!(m.length || C >= u)) {
      (m.data !== i || m.next) && (b === 0 && (b = Ks(n), C += b * b), e > 1 && T === 0 && (T = Ks(n), C += T * T), e > 2 && S === 0 && (S = Ks(n), C += S * S), C < l && (C = Math.sqrt(l * C)));
      do
        m.data !== i && (w = o[m.data.index] * s / C, i.vx += b * w, e > 1 && (i.vy += T * w), e > 2 && (i.vz += S * w));
      while (m = m.next);
    }
  }
  return h.initialize = function(m, ...v) {
    r = m, n = v.find((y) => typeof y == "function") || Math.random, e = v.find((y) => [1, 2, 3].includes(y)) || 2, d();
  }, h.strength = function(m) {
    return arguments.length ? (a = typeof m == "function" ? m : la(+m), d(), h) : a;
  }, h.distanceMin = function(m) {
    return arguments.length ? (l = m * m, h) : Math.sqrt(l);
  }, h.distanceMax = function(m) {
    return arguments.length ? (u = m * m, h) : Math.sqrt(u);
  }, h.theta = function(m) {
    return arguments.length ? (c = m * m, h) : Math.sqrt(c);
  }, h;
}
function BR(r, e, i, n) {
  var s, a, o = la(0.1), l, u;
  typeof r != "function" && (r = la(+r)), e == null && (e = 0), i == null && (i = 0), n == null && (n = 0);
  function c(d) {
    for (var p = 0, f = s.length; p < f; ++p) {
      var m = s[p], v = m.x - e || 1e-6, y = (m.y || 0) - i || 1e-6, g = (m.z || 0) - n || 1e-6, _ = Math.sqrt(v * v + y * y + g * g), x = (u[p] - _) * l[p] * d / _;
      m.vx += v * x, a > 1 && (m.vy += y * x), a > 2 && (m.vz += g * x);
    }
  }
  function h() {
    if (s) {
      var d, p = s.length;
      for (l = new Array(p), u = new Array(p), d = 0; d < p; ++d)
        u[d] = +r(s[d], d, s), l[d] = isNaN(u[d]) ? 0 : +o(s[d], d, s);
    }
  }
  return c.initialize = function(d, ...p) {
    s = d, a = p.find((f) => [1, 2, 3].includes(f)) || 2, h();
  }, c.strength = function(d) {
    return arguments.length ? (o = typeof d == "function" ? d : la(+d), h(), c) : o;
  }, c.radius = function(d) {
    return arguments.length ? (r = typeof d == "function" ? d : la(+d), h(), c) : r;
  }, c.x = function(d) {
    return arguments.length ? (e = +d, c) : e;
  }, c.y = function(d) {
    return arguments.length ? (i = +d, c) : i;
  }, c.z = function(d) {
    return arguments.length ? (n = +d, c) : n;
  }, c;
}
var X_ = function(r) {
  pG(r);
  var e = dG(r);
  return r.on = e.on, r.off = e.off, r.fire = e.fire, r;
};
function dG(r) {
  var e = /* @__PURE__ */ Object.create(null);
  return {
    on: function(i, n, s) {
      if (typeof n != "function")
        throw new Error("callback is expected to be a function");
      var a = e[i];
      return a || (a = e[i] = []), a.push({ callback: n, ctx: s }), r;
    },
    off: function(i, n) {
      var s = typeof i > "u";
      if (s)
        return e = /* @__PURE__ */ Object.create(null), r;
      if (e[i]) {
        var a = typeof n != "function";
        if (a)
          delete e[i];
        else
          for (var o = e[i], l = 0; l < o.length; ++l)
            o[l].callback === n && o.splice(l, 1);
      }
      return r;
    },
    fire: function(i) {
      var n = e[i];
      if (!n)
        return r;
      var s;
      arguments.length > 1 && (s = Array.prototype.splice.call(arguments, 1));
      for (var a = 0; a < n.length; ++a) {
        var o = n[a];
        o.callback.apply(o.ctx, s);
      }
      return r;
    }
  };
}
function pG(r) {
  if (!r)
    throw new Error("Eventify cannot use falsy object as events subject");
  for (var e = ["on", "fire", "off"], i = 0; i < e.length; ++i)
    if (r.hasOwnProperty(e[i]))
      throw new Error("Subject cannot be eventified, since it already has property '" + e[i] + "'");
}
var fG = gG, mG = X_;
function gG(r) {
  if (r = r || {}, "uniqueLinkId" in r && (console.warn(
    "ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\nUse `multigraph` option instead\n",
    `
`,
    `Note: there is also change in default behavior: From now on each graph
is considered to be not a multigraph by default (each edge is unique).`
  ), r.multigraph = r.uniqueLinkId), r.multigraph === void 0 && (r.multigraph = !1), typeof Map != "function")
    throw new Error("ngraph.graph requires `Map` to be defined. Please polyfill it before using ngraph");
  var e = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = {}, s = 0, a = r.multigraph ? b : x, o = [], l = O, u = O, c = O, h = O, d = {
    /**
     * Sometimes duck typing could be slow. Giving clients a hint about data structure
     * via explicit version number here:
     */
    version: 20,
    /**
     * Adds node to the graph. If node with given id already exists in the graph
     * its data is extended with whatever comes in 'data' argument.
     *
     * @param nodeId the node's identifier. A string or number is preferred.
     * @param [data] additional data for the node being added. If node already
     *   exists its data object is augmented with the new one.
     *
     * @return {node} The newly added node or node with given id if it already exists.
     */
    addNode: v,
    /**
     * Adds a link to the graph. The function always create a new
     * link between two nodes. If one of the nodes does not exists
     * a new node is created.
     *
     * @param fromId link start node id;
     * @param toId link end node id;
     * @param [data] additional data to be set on the new link;
     *
     * @return {link} The newly created link
     */
    addLink: _,
    /**
     * Removes link from the graph. If link does not exist does nothing.
     *
     * @param link - object returned by addLink() or getLinks() methods.
     *
     * @returns true if link was removed; false otherwise.
     */
    removeLink: C,
    /**
     * Removes node with given id from the graph. If node does not exist in the graph
     * does nothing.
     *
     * @param nodeId node's identifier passed to addNode() function.
     *
     * @returns true if node was removed; false otherwise.
     */
    removeNode: g,
    /**
     * Gets node with given identifier. If node does not exist undefined value is returned.
     *
     * @param nodeId requested node identifier;
     *
     * @return {node} in with requested identifier or undefined if no such node exists.
     */
    getNode: y,
    /**
     * Gets number of nodes in this graph.
     *
     * @return number of nodes in the graph.
     */
    getNodeCount: T,
    /**
     * Gets total number of links in the graph.
     */
    getLinkCount: S,
    /**
     * Gets total number of links in the graph.
     */
    getEdgeCount: S,
    /**
     * Synonym for `getLinkCount()`
     */
    getLinksCount: S,
    /**
     * Synonym for `getNodeCount()`
     */
    getNodesCount: T,
    /**
     * Gets all links (inbound and outbound) from the node with given id.
     * If node with given id is not found null is returned.
     *
     * @param nodeId requested node identifier.
     *
     * @return Set of links from and to requested node if such node exists;
     *   otherwise null is returned.
     */
    getLinks: w,
    /**
     * Invokes callback on each node of the graph.
     *
     * @param {Function(node)} callback Function to be invoked. The function
     *   is passed one argument: visited node.
     */
    forEachNode: H,
    /**
     * Invokes callback on every linked (adjacent) node to the given one.
     *
     * @param nodeId Identifier of the requested node.
     * @param {Function(node, link)} callback Function to be called on all linked nodes.
     *   The function is passed two parameters: adjacent node and link object itself.
     * @param oriented if true graph treated as oriented.
     */
    forEachLinkedNode: F,
    /**
     * Enumerates all links in the graph
     *
     * @param {Function(link)} callback Function to be called on all links in the graph.
     *   The function is passed one parameter: graph's link object.
     *
     * Link object contains at least the following fields:
     *  fromId - node id where link starts;
     *  toId - node id where link ends,
     *  data - additional data passed to graph.addLink() method.
     */
    forEachLink: L,
    /**
     * Suspend all notifications about graph changes until
     * endUpdate is called.
     */
    beginUpdate: c,
    /**
     * Resumes all notifications about graph changes and fires
     * graph 'changed' event in case there are any pending changes.
     */
    endUpdate: h,
    /**
     * Removes all nodes and links from the graph.
     */
    clear: N,
    /**
     * Detects whether there is a link between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     * NOTE: this function is synonym for getLink()
     *
     * @returns link if there is one. null otherwise.
     */
    hasLink: A,
    /**
     * Detects whether there is a node with given id
     * 
     * Operation complexity is O(1)
     * NOTE: this function is synonym for getNode()
     *
     * @returns node if there is one; Falsy value otherwise.
     */
    hasNode: y,
    /**
     * Gets an edge between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     *
     * @param {string} fromId link start identifier
     * @param {string} toId link end identifier
     *
     * @returns link if there is one; undefined otherwise.
     */
    getLink: A
  };
  return mG(d), p(), d;
  function p() {
    var U = d.on;
    d.on = j;
    function j() {
      return d.beginUpdate = c = V, d.endUpdate = h = B, l = f, u = m, d.on = U, U.apply(d, arguments);
    }
  }
  function f(U, j) {
    o.push({
      link: U,
      changeType: j
    });
  }
  function m(U, j) {
    o.push({
      node: U,
      changeType: j
    });
  }
  function v(U, j) {
    if (U === void 0)
      throw new Error("Invalid node identifier");
    c();
    var Q = y(U);
    return Q ? (Q.data = j, u(Q, "update")) : (Q = new yG(U, j), u(Q, "add")), e.set(U, Q), h(), Q;
  }
  function y(U) {
    return e.get(U);
  }
  function g(U) {
    var j = y(U);
    if (!j)
      return !1;
    c();
    var Q = j.links;
    return Q && (Q.forEach(E), j.links = null), e.delete(U), u(j, "remove"), h(), !0;
  }
  function _(U, j, Q) {
    c();
    var q = y(U) || v(U), G = y(j) || v(j), Y = a(U, j, Q), ae = i.has(Y.id);
    return i.set(Y.id, Y), Fw(q, Y), U !== j && Fw(G, Y), l(Y, ae ? "update" : "add"), h(), Y;
  }
  function x(U, j, Q) {
    var q = Fp(U, j), G = i.get(q);
    return G ? (G.data = Q, G) : new Bw(U, j, Q, q);
  }
  function b(U, j, Q) {
    var q = Fp(U, j), G = n.hasOwnProperty(q);
    if (G || A(U, j)) {
      G || (n[q] = 0);
      var Y = "@" + ++n[q];
      q = Fp(U + Y, j + Y);
    }
    return new Bw(U, j, Q, q);
  }
  function T() {
    return e.size;
  }
  function S() {
    return i.size;
  }
  function w(U) {
    var j = y(U);
    return j ? j.links : null;
  }
  function C(U, j) {
    return j !== void 0 && (U = A(U, j)), E(U);
  }
  function E(U) {
    if (!U || !i.get(U.id)) return !1;
    c(), i.delete(U.id);
    var j = y(U.fromId), Q = y(U.toId);
    return j && j.links.delete(U), Q && Q.links.delete(U), l(U, "remove"), h(), !0;
  }
  function A(U, j) {
    if (!(U === void 0 || j === void 0))
      return i.get(Fp(U, j));
  }
  function N() {
    c(), H(function(U) {
      g(U.id);
    }), h();
  }
  function L(U) {
    if (typeof U == "function")
      for (var j = i.values(), Q = j.next(); !Q.done; ) {
        if (U(Q.value))
          return !0;
        Q = j.next();
      }
  }
  function F(U, j, Q) {
    var q = y(U);
    if (q && q.links && typeof j == "function")
      return Q ? P(q.links, U, j) : M(q.links, U, j);
  }
  function M(U, j, Q) {
    for (var q, G = U.values(), Y = G.next(); !Y.done; ) {
      var ae = Y.value, ue = ae.fromId === j ? ae.toId : ae.fromId;
      if (q = Q(e.get(ue), ae), q)
        return !0;
      Y = G.next();
    }
  }
  function P(U, j, Q) {
    for (var q, G = U.values(), Y = G.next(); !Y.done; ) {
      var ae = Y.value;
      if (ae.fromId === j && (q = Q(e.get(ae.toId), ae), q))
        return !0;
      Y = G.next();
    }
  }
  function O() {
  }
  function V() {
    s += 1;
  }
  function B() {
    s -= 1, s === 0 && o.length > 0 && (d.fire("changed", o), o.length = 0);
  }
  function H(U) {
    if (typeof U != "function")
      throw new Error("Function is expected to iterate over graph nodes. You passed " + U);
    for (var j = e.values(), Q = j.next(); !Q.done; ) {
      if (U(Q.value))
        return !0;
      Q = j.next();
    }
  }
}
function yG(r, e) {
  this.id = r, this.links = null, this.data = e;
}
function Fw(r, e) {
  r.links ? r.links.add(e) : r.links = /* @__PURE__ */ new Set([e]);
}
function Bw(r, e, i, n) {
  this.fromId = r, this.toId = e, this.data = i, this.id = n;
}
function Fp(r, e) {
  return r.toString() + "👉 " + e.toString();
}
const vG = /* @__PURE__ */ f_(fG);
var Y_ = { exports: {} }, Wd = { exports: {} }, zR = function(r) {
  return r === 0 ? "x" : r === 1 ? "y" : r === 2 ? "z" : "c" + (r + 1);
};
const bG = zR;
var Uc = function(r) {
  return e;
  function e(i, n) {
    let s = n && n.indent || 0, a = n && n.join !== void 0 ? n.join : `
`, o = Array(s + 1).join(" "), l = [];
    for (let u = 0; u < r; ++u) {
      let c = bG(u), h = u === 0 ? "" : o;
      l.push(h + i.replace(/{var}/g, c));
    }
    return l.join(a);
  }
};
const jR = Uc;
Wd.exports = xG;
Wd.exports.generateCreateBodyFunctionBody = VR;
Wd.exports.getVectorCode = HR;
Wd.exports.getBodyCode = GR;
function xG(r, e) {
  let i = VR(r, e), { Body: n } = new Function(i)();
  return n;
}
function VR(r, e) {
  return `
${HR(r, e)}
${GR(r)}
return {Body: Body, Vector: Vector};
`;
}
function GR(r) {
  let e = jR(r), i = e("{var}", { join: ", " });
  return `
function Body(${i}) {
  this.isPinned = false;
  this.pos = new Vector(${i});
  this.force = new Vector();
  this.velocity = new Vector();
  this.mass = 1;

  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.reset = function() {
  this.force.reset();
  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.setPosition = function (${i}) {
  ${e("this.pos.{var} = {var} || 0;", { indent: 2 })}
};`;
}
function HR(r, e) {
  let i = jR(r), n = "";
  return e && (n = `${i(`
   var v{var};
Object.defineProperty(this, '{var}', {
  set: function(v) { 
    if (!Number.isFinite(v)) throw new Error('Cannot set non-numbers to {var}');
    v{var} = v; 
  },
  get: function() { return v{var}; }
});`)}`), `function Vector(${i("{var}", { join: ", " })}) {
  ${n}
    if (typeof arguments[0] === 'object') {
      // could be another vector
      let v = arguments[0];
      ${i('if (!Number.isFinite(v.{var})) throw new Error("Expected value is not a finite number at Vector constructor ({var})");', { indent: 4 })}
      ${i("this.{var} = v.{var};", { indent: 4 })}
    } else {
      ${i('this.{var} = typeof {var} === "number" ? {var} : 0;', { indent: 4 })}
    }
  }
  
  Vector.prototype.reset = function () {
    ${i("this.{var} = ", { join: "" })}0;
  };`;
}
var _G = Wd.exports, So = { exports: {} };
const $_ = Uc, Ba = zR;
So.exports = TG;
So.exports.generateQuadTreeFunctionBody = WR;
So.exports.getInsertStackCode = KR;
So.exports.getQuadNodeCode = $R;
So.exports.isSamePosition = qR;
So.exports.getChildBodyCode = YR;
So.exports.setChildBodyCode = XR;
function TG(r) {
  let e = WR(r);
  return new Function(e)();
}
function WR(r) {
  let e = $_(r), i = Math.pow(2, r);
  return `
${KR()}
${$R(r)}
${qR(r)}
${YR(r)}
${XR(r)}

function createQuadTree(options, random) {
  options = options || {};
  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;
  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;

  var gravity = options.gravity;
  var updateQueue = [];
  var insertStack = new InsertStack();
  var theta = options.theta;

  var nodesCache = [];
  var currentInCache = 0;
  var root = newNode();

  return {
    insertBodies: insertBodies,

    /**
     * Gets root node if it is present
     */
    getRoot: function() {
      return root;
    },

    updateBodyForce: update,

    options: function(newOptions) {
      if (newOptions) {
        if (typeof newOptions.gravity === 'number') {
          gravity = newOptions.gravity;
        }
        if (typeof newOptions.theta === 'number') {
          theta = newOptions.theta;
        }

        return this;
      }

      return {
        gravity: gravity,
        theta: theta
      };
    }
  };

  function newNode() {
    // To avoid pressure on GC we reuse nodes.
    var node = nodesCache[currentInCache];
    if (node) {
${a("      node.")}
      node.body = null;
      node.mass = ${e("node.mass_{var} = ", { join: "" })}0;
      ${e("node.min_{var} = node.max_{var} = ", { join: "" })}0;
    } else {
      node = new QuadNode();
      nodesCache[currentInCache] = node;
    }

    ++currentInCache;
    return node;
  }

  function update(sourceBody) {
    var queue = updateQueue;
    var v;
    ${e("var d{var};", { indent: 4 })}
    var r; 
    ${e("var f{var} = 0;", { indent: 4 })}
    var queueLength = 1;
    var shiftIdx = 0;
    var pushIdx = 1;

    queue[0] = root;

    while (queueLength) {
      var node = queue[shiftIdx];
      var body = node.body;

      queueLength -= 1;
      shiftIdx += 1;
      var differentBody = (body !== sourceBody);
      if (body && differentBody) {
        // If the current node is a leaf node (and it is not source body),
        // calculate the force exerted by the current node on body, and add this
        // amount to body's net force.
        ${e("d{var} = body.pos.{var} - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Poor man's protection against zero distance.
          ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
        }

        // This is standard gravitation force calculation but we divide
        // by r^3 to save two operations when normalizing force vector.
        v = gravity * body.mass * sourceBody.mass / (r * r * r);
        ${e("f{var} += v * d{var};", { indent: 8 })}
      } else if (differentBody) {
        // Otherwise, calculate the ratio s / r,  where s is the width of the region
        // represented by the internal node, and r is the distance between the body
        // and the node's center-of-mass
        ${e("d{var} = node.mass_{var} / node.mass - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Sorry about code duplication. I don't want to create many functions
          // right away. Just want to see performance first.
          ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
        }
        // If s / r < θ, treat this internal node as a single body, and calculate the
        // force it exerts on sourceBody, and add this amount to sourceBody's net force.
        if ((node.max_${Ba(0)} - node.min_${Ba(0)}) / r < theta) {
          // in the if statement above we consider node's width only
          // because the region was made into square during tree creation.
          // Thus there is no difference between using width or height.
          v = gravity * node.mass * sourceBody.mass / (r * r * r);
          ${e("f{var} += v * d{var};", { indent: 10 })}
        } else {
          // Otherwise, run the procedure recursively on each of the current node's children.

          // I intentionally unfolded this loop, to save several CPU cycles.
${s()}
        }
      }
    }

    ${e("sourceBody.force.{var} += f{var};", { indent: 4 })}
  }

  function insertBodies(bodies) {
    ${e("var {var}min = Number.MAX_VALUE;", { indent: 4 })}
    ${e("var {var}max = Number.MIN_VALUE;", { indent: 4 })}
    var i = bodies.length;

    // To reduce quad tree depth we are looking for exact bounding box of all particles.
    while (i--) {
      var pos = bodies[i].pos;
      ${e("if (pos.{var} < {var}min) {var}min = pos.{var};", { indent: 6 })}
      ${e("if (pos.{var} > {var}max) {var}max = pos.{var};", { indent: 6 })}
    }

    // Makes the bounds square.
    var maxSideLength = -Infinity;
    ${e("if ({var}max - {var}min > maxSideLength) maxSideLength = {var}max - {var}min ;", { indent: 4 })}

    currentInCache = 0;
    root = newNode();
    ${e("root.min_{var} = {var}min;", { indent: 4 })}
    ${e("root.max_{var} = {var}min + maxSideLength;", { indent: 4 })}

    i = bodies.length - 1;
    if (i >= 0) {
      root.body = bodies[i];
    }
    while (i--) {
      insert(bodies[i], root);
    }
  }

  function insert(newBody) {
    insertStack.reset();
    insertStack.push(root, newBody);

    while (!insertStack.isEmpty()) {
      var stackItem = insertStack.pop();
      var node = stackItem.node;
      var body = stackItem.body;

      if (!node.body) {
        // This is internal node. Update the total mass of the node and center-of-mass.
        ${e("var {var} = body.pos.{var};", { indent: 8 })}
        node.mass += body.mass;
        ${e("node.mass_{var} += body.mass * {var};", { indent: 8 })}

        // Recursively insert the body in the appropriate quadrant.
        // But first find the appropriate quadrant.
        var quadIdx = 0; // Assume we are in the 0's quad.
        ${e("var min_{var} = node.min_{var};", { indent: 8 })}
        ${e("var max_{var} = (min_{var} + node.max_{var}) / 2;", { indent: 8 })}

${n(8)}

        var child = getChild(node, quadIdx);

        if (!child) {
          // The node is internal but this quadrant is not taken. Add
          // subnode to it.
          child = newNode();
          ${e("child.min_{var} = min_{var};", { indent: 10 })}
          ${e("child.max_{var} = max_{var};", { indent: 10 })}
          child.body = body;

          setChild(node, quadIdx, child);
        } else {
          // continue searching in this quadrant.
          insertStack.push(child, body);
        }
      } else {
        // We are trying to add to the leaf node.
        // We have to convert current leaf into internal node
        // and continue adding two nodes.
        var oldBody = node.body;
        node.body = null; // internal nodes do not cary bodies

        if (isSamePosition(oldBody.pos, body.pos)) {
          // Prevent infinite subdivision by bumping one node
          // anywhere in this quadrant
          var retriesCount = 3;
          do {
            var offset = random.nextDouble();
            ${e("var d{var} = (node.max_{var} - node.min_{var}) * offset;", { indent: 12 })}

            ${e("oldBody.pos.{var} = node.min_{var} + d{var};", { indent: 12 })}
            retriesCount -= 1;
            // Make sure we don't bump it out of the box. If we do, next iteration should fix it
          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));

          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {
            // This is very bad, we ran out of precision.
            // if we do not return from the method we'll get into
            // infinite loop here. So we sacrifice correctness of layout, and keep the app running
            // Next layout iteration should get larger bounding box in the first step and fix this
            return;
          }
        }
        // Next iteration should subdivide node further.
        insertStack.push(node, oldBody);
        insertStack.push(node, body);
      }
    }
  }
}
return createQuadTree;

`;
  function n(o) {
    let l = [], u = Array(o + 1).join(" ");
    for (let c = 0; c < r; ++c)
      l.push(u + `if (${Ba(c)} > max_${Ba(c)}) {`), l.push(u + `  quadIdx = quadIdx + ${Math.pow(2, c)};`), l.push(u + `  min_${Ba(c)} = max_${Ba(c)};`), l.push(u + `  max_${Ba(c)} = node.max_${Ba(c)};`), l.push(u + "}");
    return l.join(`
`);
  }
  function s() {
    let o = Array(11).join(" "), l = [];
    for (let u = 0; u < i; ++u)
      l.push(o + `if (node.quad${u}) {`), l.push(o + `  queue[pushIdx] = node.quad${u};`), l.push(o + "  queueLength += 1;"), l.push(o + "  pushIdx += 1;"), l.push(o + "}");
    return l.join(`
`);
  }
  function a(o) {
    let l = [];
    for (let u = 0; u < i; ++u)
      l.push(`${o}quad${u} = null;`);
    return l.join(`
`);
  }
}
function qR(r) {
  let e = $_(r);
  return `
  function isSamePosition(point1, point2) {
    ${e("var d{var} = Math.abs(point1.{var} - point2.{var});", { indent: 2 })}
  
    return ${e("d{var} < 1e-8", { join: " && " })};
  }  
`;
}
function XR(r) {
  var e = Math.pow(2, r);
  return `
function setChild(node, idx, child) {
  ${i()}
}`;
  function i() {
    let n = [];
    for (let s = 0; s < e; ++s) {
      let a = s === 0 ? "  " : "  else ";
      n.push(`${a}if (idx === ${s}) node.quad${s} = child;`);
    }
    return n.join(`
`);
  }
}
function YR(r) {
  return `function getChild(node, idx) {
${e()}
  return null;
}`;
  function e() {
    let i = [], n = Math.pow(2, r);
    for (let s = 0; s < n; ++s)
      i.push(`  if (idx === ${s}) return node.quad${s};`);
    return i.join(`
`);
  }
}
function $R(r) {
  let e = $_(r), i = Math.pow(2, r);
  var n = `
function QuadNode() {
  // body stored inside this node. In quad tree only leaf nodes (by construction)
  // contain bodies:
  this.body = null;

  // Child nodes are stored in quads. Each quad is presented by number:
  // 0 | 1
  // -----
  // 2 | 3
${s("  this.")}

  // Total mass of current node
  this.mass = 0;

  // Center of mass coordinates
  ${e("this.mass_{var} = 0;", { indent: 2 })}

  // bounding box coordinates
  ${e("this.min_{var} = 0;", { indent: 2 })}
  ${e("this.max_{var} = 0;", { indent: 2 })}
}
`;
  return n;
  function s(a) {
    let o = [];
    for (let l = 0; l < i; ++l)
      o.push(`${a}quad${l} = null;`);
    return o.join(`
`);
  }
}
function KR() {
  return `
/**
 * Our implementation of QuadTree is non-recursive to avoid GC hit
 * This data structure represent stack of elements
 * which we are trying to insert into quad tree.
 */
function InsertStack () {
    this.stack = [];
    this.popIdx = 0;
}

InsertStack.prototype = {
    isEmpty: function() {
        return this.popIdx === 0;
    },
    push: function (node, body) {
        var item = this.stack[this.popIdx];
        if (!item) {
            // we are trying to avoid memory pressure: create new element
            // only when absolutely necessary
            this.stack[this.popIdx] = new InsertStackElement(node, body);
        } else {
            item.node = node;
            item.body = body;
        }
        ++this.popIdx;
    },
    pop: function () {
        if (this.popIdx > 0) {
            return this.stack[--this.popIdx];
        }
    },
    reset: function () {
        this.popIdx = 0;
    }
};

function InsertStackElement(node, body) {
    this.node = node; // QuadTree node
    this.body = body; // physical body which needs to be inserted to node
}
`;
}
var SG = So.exports, K_ = { exports: {} };
K_.exports = EG;
K_.exports.generateFunctionBody = QR;
const wG = Uc;
function EG(r) {
  let e = QR(r);
  return new Function("bodies", "settings", "random", e);
}
function QR(r) {
  let e = wG(r);
  return `
  var boundingBox = {
    ${e("min_{var}: 0, max_{var}: 0,", { indent: 4 })}
  };

  return {
    box: boundingBox,

    update: updateBoundingBox,

    reset: resetBoundingBox,

    getBestNewPosition: function (neighbors) {
      var ${e("base_{var} = 0", { join: ", " })};

      if (neighbors.length) {
        for (var i = 0; i < neighbors.length; ++i) {
          let neighborPos = neighbors[i].pos;
          ${e("base_{var} += neighborPos.{var};", { indent: 10 })}
        }

        ${e("base_{var} /= neighbors.length;", { indent: 8 })}
      } else {
        ${e("base_{var} = (boundingBox.min_{var} + boundingBox.max_{var}) / 2;", { indent: 8 })}
      }

      var springLength = settings.springLength;
      return {
        ${e("{var}: base_{var} + (random.nextDouble() - 0.5) * springLength,", { indent: 8 })}
      };
    }
  };

  function updateBoundingBox() {
    var i = bodies.length;
    if (i === 0) return; // No bodies - no borders.

    ${e("var max_{var} = -Infinity;", { indent: 4 })}
    ${e("var min_{var} = Infinity;", { indent: 4 })}

    while(i--) {
      // this is O(n), it could be done faster with quadtree, if we check the root node bounds
      var bodyPos = bodies[i].pos;
      ${e("if (bodyPos.{var} < min_{var}) min_{var} = bodyPos.{var};", { indent: 6 })}
      ${e("if (bodyPos.{var} > max_{var}) max_{var} = bodyPos.{var};", { indent: 6 })}
    }

    ${e("boundingBox.min_{var} = min_{var};", { indent: 4 })}
    ${e("boundingBox.max_{var} = max_{var};", { indent: 4 })}
  }

  function resetBoundingBox() {
    ${e("boundingBox.min_{var} = boundingBox.max_{var} = 0;", { indent: 4 })}
  }
`;
}
var MG = K_.exports, Q_ = { exports: {} };
const AG = Uc;
Q_.exports = CG;
Q_.exports.generateCreateDragForceFunctionBody = ZR;
function CG(r) {
  let e = ZR(r);
  return new Function("options", e);
}
function ZR(r) {
  return `
  if (!Number.isFinite(options.dragCoefficient)) throw new Error('dragCoefficient is not a finite number');

  return {
    update: function(body) {
      ${AG(r)("body.force.{var} -= options.dragCoefficient * body.velocity.{var};", { indent: 6 })}
    }
  };
`;
}
var RG = Q_.exports, Z_ = { exports: {} };
const NG = Uc;
Z_.exports = PG;
Z_.exports.generateCreateSpringForceFunctionBody = JR;
function PG(r) {
  let e = JR(r);
  return new Function("options", "random", e);
}
function JR(r) {
  let e = NG(r);
  return `
  if (!Number.isFinite(options.springCoefficient)) throw new Error('Spring coefficient is not a number');
  if (!Number.isFinite(options.springLength)) throw new Error('Spring length is not a number');

  return {
    /**
     * Updates forces acting on a spring
     */
    update: function (spring) {
      var body1 = spring.from;
      var body2 = spring.to;
      var length = spring.length < 0 ? options.springLength : spring.length;
      ${e("var d{var} = body2.pos.{var} - body1.pos.{var};", { indent: 6 })}
      var r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

      if (r === 0) {
        ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
      }

      var d = r - length;
      var coefficient = ((spring.coefficient > 0) ? spring.coefficient : options.springCoefficient) * d / r;

      ${e("body1.force.{var} += coefficient * d{var}", { indent: 6 })};
      body1.springCount += 1;
      body1.springLength += r;

      ${e("body2.force.{var} -= coefficient * d{var}", { indent: 6 })};
      body2.springCount += 1;
      body2.springLength += r;
    }
  };
`;
}
var OG = Z_.exports, J_ = { exports: {} };
const IG = Uc;
J_.exports = DG;
J_.exports.generateIntegratorFunctionBody = eN;
function DG(r) {
  let e = eN(r);
  return new Function("bodies", "timeStep", "adaptiveTimeStepWeight", e);
}
function eN(r) {
  let e = IG(r);
  return `
  var length = bodies.length;
  if (length === 0) return 0;

  ${e("var d{var} = 0, t{var} = 0;", { indent: 2 })}

  for (var i = 0; i < length; ++i) {
    var body = bodies[i];
    if (body.isPinned) continue;

    if (adaptiveTimeStepWeight && body.springCount) {
      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);
    }

    var coeff = timeStep / body.mass;

    ${e("body.velocity.{var} += coeff * body.force.{var};", { indent: 4 })}
    ${e("var v{var} = body.velocity.{var};", { indent: 4 })}
    var v = Math.sqrt(${e("v{var} * v{var}", { join: " + " })});

    if (v > 1) {
      // We normalize it so that we move within timeStep range. 
      // for the case when v <= 1 - we let velocity to fade out.
      ${e("body.velocity.{var} = v{var} / v;", { indent: 6 })}
    }

    ${e("d{var} = timeStep * body.velocity.{var};", { indent: 4 })}

    ${e("body.pos.{var} += d{var};", { indent: 4 })}

    ${e("t{var} += Math.abs(d{var});", { indent: 4 })}
  }

  return (${e("t{var} * t{var}", { join: " + " })})/length;
`;
}
var kG = J_.exports, Zy, zw;
function LG() {
  if (zw) return Zy;
  zw = 1, Zy = r;
  function r(e, i, n, s) {
    this.from = e, this.to = i, this.length = n, this.coefficient = s;
  }
  return Zy;
}
var Jy, jw;
function UG() {
  if (jw) return Jy;
  jw = 1, Jy = r;
  function r(e, i) {
    var n;
    if (e || (e = {}), i) {
      for (n in i)
        if (i.hasOwnProperty(n)) {
          var s = e.hasOwnProperty(n), a = typeof i[n], o = !s || typeof e[n] !== a;
          o ? e[n] = i[n] : a === "object" && (e[n] = r(e[n], i[n]));
        }
    }
    return e;
  }
  return Jy;
}
var hh = { exports: {} }, Vw;
function FG() {
  if (Vw) return hh.exports;
  Vw = 1, hh.exports = r, hh.exports.random = r, hh.exports.randomIterator = l;
  function r(u) {
    var c = typeof u == "number" ? u : +/* @__PURE__ */ new Date();
    return new e(c);
  }
  function e(u) {
    this.seed = u;
  }
  e.prototype.next = o, e.prototype.nextDouble = a, e.prototype.uniform = a, e.prototype.gaussian = i;
  function i() {
    var u, c, h;
    do
      c = this.nextDouble() * 2 - 1, h = this.nextDouble() * 2 - 1, u = c * c + h * h;
    while (u >= 1 || u === 0);
    return c * Math.sqrt(-2 * Math.log(u) / u);
  }
  e.prototype.levy = n;
  function n() {
    var u = 1.5, c = Math.pow(
      s(1 + u) * Math.sin(Math.PI * u / 2) / (s((1 + u) / 2) * u * Math.pow(2, (u - 1) / 2)),
      1 / u
    );
    return this.gaussian() * c / Math.pow(Math.abs(this.gaussian()), 1 / u);
  }
  function s(u) {
    return Math.sqrt(2 * Math.PI / u) * Math.pow(1 / Math.E * (u + 1 / (12 * u - 1 / (10 * u))), u);
  }
  function a() {
    var u = this.seed;
    return u = u + 2127912214 + (u << 12) & 4294967295, u = (u ^ 3345072700 ^ u >>> 19) & 4294967295, u = u + 374761393 + (u << 5) & 4294967295, u = (u + 3550635116 ^ u << 9) & 4294967295, u = u + 4251993797 + (u << 3) & 4294967295, u = (u ^ 3042594569 ^ u >>> 16) & 4294967295, this.seed = u, (u & 268435455) / 268435456;
  }
  function o(u) {
    return Math.floor(this.nextDouble() * u);
  }
  function l(u, c) {
    var h = c || r();
    if (typeof h.next != "function")
      throw new Error("customRandom does not match expected API: next() function is missing");
    return {
      forEach: p,
      /**
       * Shuffles array randomly, in place.
       */
      shuffle: d
    };
    function d() {
      var f, m, v;
      for (f = u.length - 1; f > 0; --f)
        m = h.next(f + 1), v = u[m], u[m] = u[f], u[f] = v;
      return u;
    }
    function p(f) {
      var m, v, y;
      for (m = u.length - 1; m > 0; --m)
        v = h.next(m + 1), y = u[v], u[v] = u[m], u[m] = y, f(y);
      u.length && f(u[0]);
    }
  }
  return hh.exports;
}
var tN = WG, BG = _G, zG = SG, jG = MG, VG = RG, GG = OG, HG = kG, Gw = {};
function WG(r) {
  var e = LG(), i = UG(), n = X_;
  if (r) {
    if (r.springCoeff !== void 0) throw new Error("springCoeff was renamed to springCoefficient");
    if (r.dragCoeff !== void 0) throw new Error("dragCoeff was renamed to dragCoefficient");
  }
  r = i(r, {
    /**
     * Ideal length for links (springs in physical model).
     */
    springLength: 10,
    /**
     * Hook's law coefficient. 1 - solid spring.
     */
    springCoefficient: 0.8,
    /**
     * Coulomb's law coefficient. It's used to repel nodes thus should be negative
     * if you make it positive nodes start attract each other :).
     */
    gravity: -12,
    /**
     * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).
     * The closer it's to 1 the more nodes algorithm will have to go through.
     * Setting it to one makes Barnes Hut simulation no different from
     * brute-force forces calculation (each node is considered).
     */
    theta: 0.8,
    /**
     * Drag force coefficient. Used to slow down system, thus should be less than 1.
     * The closer it is to 0 the less tight system will be.
     */
    dragCoefficient: 0.9,
    // TODO: Need to rename this to something better. E.g. `dragCoefficient`
    /**
     * Default time step (dt) for forces integration
     */
    timeStep: 0.5,
    /**
     * Adaptive time step uses average spring length to compute actual time step:
     * See: https://twitter.com/anvaka/status/1293067160755957760
     */
    adaptiveTimeStepWeight: 0,
    /**
     * This parameter defines number of dimensions of the space where simulation
     * is performed. 
     */
    dimensions: 2,
    /**
     * In debug mode more checks are performed, this will help you catch errors
     * quickly, however for production build it is recommended to turn off this flag
     * to speed up computation.
     */
    debug: !1
  });
  var s = Gw[r.dimensions];
  if (!s) {
    var a = r.dimensions;
    s = {
      Body: BG(a, r.debug),
      createQuadTree: zG(a),
      createBounds: jG(a),
      createDragForce: VG(a),
      createSpringForce: GG(a),
      integrate: HG(a)
    }, Gw[a] = s;
  }
  var o = s.Body, l = s.createQuadTree, u = s.createBounds, c = s.createDragForce, h = s.createSpringForce, d = s.integrate, p = (P) => new o(P), f = FG().random(42), m = [], v = [], y = l(r, f), g = u(m, r, f), _ = h(r, f), x = c(r), b = 0, T = [], S = /* @__PURE__ */ new Map(), w = 0;
  A("nbody", F), A("spring", M);
  var C = {
    /**
     * Array of bodies, registered with current simulator
     *
     * Note: To add new body, use addBody() method. This property is only
     * exposed for testing/performance purposes.
     */
    bodies: m,
    quadTree: y,
    /**
     * Array of springs, registered with current simulator
     *
     * Note: To add new spring, use addSpring() method. This property is only
     * exposed for testing/performance purposes.
     */
    springs: v,
    /**
     * Returns settings with which current simulator was initialized
     */
    settings: r,
    /**
     * Adds a new force to simulation
     */
    addForce: A,
    /**
     * Removes a force from the simulation.
     */
    removeForce: N,
    /**
     * Returns a map of all registered forces.
     */
    getForces: L,
    /**
     * Performs one step of force simulation.
     *
     * @returns {boolean} true if system is considered stable; False otherwise.
     */
    step: function() {
      for (var P = 0; P < T.length; ++P)
        T[P](w);
      var O = d(m, r.timeStep, r.adaptiveTimeStepWeight);
      return w += 1, O;
    },
    /**
     * Adds body to the system
     *
     * @param {ngraph.physics.primitives.Body} body physical body
     *
     * @returns {ngraph.physics.primitives.Body} added body
     */
    addBody: function(P) {
      if (!P)
        throw new Error("Body is required");
      return m.push(P), P;
    },
    /**
     * Adds body to the system at given position
     *
     * @param {Object} pos position of a body
     *
     * @returns {ngraph.physics.primitives.Body} added body
     */
    addBodyAt: function(P) {
      if (!P)
        throw new Error("Body position is required");
      var O = p(P);
      return m.push(O), O;
    },
    /**
     * Removes body from the system
     *
     * @param {ngraph.physics.primitives.Body} body to remove
     *
     * @returns {Boolean} true if body found and removed. falsy otherwise;
     */
    removeBody: function(P) {
      if (P) {
        var O = m.indexOf(P);
        if (!(O < 0))
          return m.splice(O, 1), m.length === 0 && g.reset(), !0;
      }
    },
    /**
     * Adds a spring to this simulation.
     *
     * @returns {Object} - a handle for a spring. If you want to later remove
     * spring pass it to removeSpring() method.
     */
    addSpring: function(P, O, V, B) {
      if (!P || !O)
        throw new Error("Cannot add null spring to force simulator");
      typeof V != "number" && (V = -1);
      var H = new e(P, O, V, B >= 0 ? B : -1);
      return v.push(H), H;
    },
    /**
     * Returns amount of movement performed on last step() call
     */
    getTotalMovement: function() {
      return b;
    },
    /**
     * Removes spring from the system
     *
     * @param {Object} spring to remove. Spring is an object returned by addSpring
     *
     * @returns {Boolean} true if spring found and removed. falsy otherwise;
     */
    removeSpring: function(P) {
      if (P) {
        var O = v.indexOf(P);
        if (O > -1)
          return v.splice(O, 1), !0;
      }
    },
    getBestNewBodyPosition: function(P) {
      return g.getBestNewPosition(P);
    },
    /**
     * Returns bounding box which covers all bodies
     */
    getBBox: E,
    getBoundingBox: E,
    invalidateBBox: function() {
      console.warn("invalidateBBox() is deprecated, bounds always recomputed on `getBBox()` call");
    },
    // TODO: Move the force specific stuff to force
    gravity: function(P) {
      return P !== void 0 ? (r.gravity = P, y.options({ gravity: P }), this) : r.gravity;
    },
    theta: function(P) {
      return P !== void 0 ? (r.theta = P, y.options({ theta: P }), this) : r.theta;
    },
    /**
     * Returns pseudo-random number generator instance.
     */
    random: f
  };
  return qG(r, C), n(C), C;
  function E() {
    return g.update(), g.box;
  }
  function A(P, O) {
    if (S.has(P)) throw new Error("Force " + P + " is already added");
    S.set(P, O), T.push(O);
  }
  function N(P) {
    var O = T.indexOf(S.get(P));
    O < 0 || (T.splice(O, 1), S.delete(P));
  }
  function L() {
    return S;
  }
  function F() {
    if (m.length !== 0) {
      y.insertBodies(m);
      for (var P = m.length; P--; ) {
        var O = m[P];
        O.isPinned || (O.reset(), y.updateBodyForce(O), x.update(O));
      }
    }
  }
  function M() {
    for (var P = v.length; P--; )
      _.update(v[P]);
  }
}
function qG(r, e) {
  for (var i in r)
    XG(r, e, i);
}
function XG(r, e, i) {
  if (r.hasOwnProperty(i) && typeof e[i] != "function") {
    var n = Number.isFinite(r[i]);
    n ? e[i] = function(s) {
      if (s !== void 0) {
        if (!Number.isFinite(s)) throw new Error("Value of " + i + " should be a valid number.");
        return r[i] = s, e;
      }
      return r[i];
    } : e[i] = function(s) {
      return s !== void 0 ? (r[i] = s, e) : r[i];
    };
  }
}
Y_.exports = $G;
Y_.exports.simulator = tN;
var YG = X_;
function $G(r, e) {
  if (!r)
    throw new Error("Graph structure cannot be undefined");
  var i = e && e.createSimulator || tN, n = i(e);
  if (Array.isArray(e)) throw new Error("Physics settings is expected to be an object");
  var s = r.version > 19 ? F : L;
  e && typeof e.nodeMass == "function" && (s = e.nodeMass);
  var a = /* @__PURE__ */ new Map(), o = {}, l = 0, u = n.settings.springTransform || KG;
  x(), y();
  var c = !1, h = {
    /**
     * Performs one step of iterative layout algorithm
     *
     * @returns {boolean} true if the system should be considered stable; False otherwise.
     * The system is stable if no further call to `step()` can improve the layout.
     */
    step: function() {
      if (l === 0)
        return d(!0), !0;
      var M = n.step();
      h.lastMove = M, h.fire("step");
      var P = M / l, O = P <= 0.01;
      return d(O), O;
    },
    /**
     * For a given `nodeId` returns position
     */
    getNodePosition: function(M) {
      return N(M).pos;
    },
    /**
     * Sets position of a node to a given coordinates
     * @param {string} nodeId node identifier
     * @param {number} x position of a node
     * @param {number} y position of a node
     * @param {number=} z position of node (only if applicable to body)
     */
    setNodePosition: function(M) {
      var P = N(M);
      P.setPosition.apply(P, Array.prototype.slice.call(arguments, 1));
    },
    /**
     * @returns {Object} Link position by link id
     * @returns {Object.from} {x, y} coordinates of link start
     * @returns {Object.to} {x, y} coordinates of link end
     */
    getLinkPosition: function(M) {
      var P = o[M];
      if (P)
        return {
          from: P.from.pos,
          to: P.to.pos
        };
    },
    /**
     * @returns {Object} area required to fit in the graph. Object contains
     * `x1`, `y1` - top left coordinates
     * `x2`, `y2` - bottom right coordinates
     */
    getGraphRect: function() {
      return n.getBBox();
    },
    /**
     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)
     */
    forEachBody: p,
    /*
     * Requests layout algorithm to pin/unpin node to its current position
     * Pinned nodes should not be affected by layout algorithm and always
     * remain at their position
     */
    pinNode: function(M, P) {
      var O = N(M.id);
      O.isPinned = !!P;
    },
    /**
     * Checks whether given graph's node is currently pinned
     */
    isNodePinned: function(M) {
      return N(M.id).isPinned;
    },
    /**
     * Request to release all resources
     */
    dispose: function() {
      r.off("changed", _), h.fire("disposed");
    },
    /**
     * Gets physical body for a given node id. If node is not found undefined
     * value is returned.
     */
    getBody: v,
    /**
     * Gets spring for a given edge.
     *
     * @param {string} linkId link identifer. If two arguments are passed then
     * this argument is treated as formNodeId
     * @param {string=} toId when defined this parameter denotes head of the link
     * and first argument is treated as tail of the link (fromId)
     */
    getSpring: m,
    /**
     * Returns length of cumulative force vector. The closer this to zero - the more stable the system is
     */
    getForceVectorLength: f,
    /**
     * [Read only] Gets current physics simulator
     */
    simulator: n,
    /**
     * Gets the graph that was used for layout
     */
    graph: r,
    /**
     * Gets amount of movement performed during last step operation
     */
    lastMove: 0
  };
  return YG(h), h;
  function d(M) {
    c !== M && (c = M, g(M));
  }
  function p(M) {
    a.forEach(M);
  }
  function f() {
    var M = 0, P = 0;
    return p(function(O) {
      M += Math.abs(O.force.x), P += Math.abs(O.force.y);
    }), Math.sqrt(M * M + P * P);
  }
  function m(M, P) {
    var O;
    if (P === void 0)
      typeof M != "object" ? O = M : O = M.id;
    else {
      var V = r.hasLink(M, P);
      if (!V) return;
      O = V.id;
    }
    return o[O];
  }
  function v(M) {
    return a.get(M);
  }
  function y() {
    r.on("changed", _);
  }
  function g(M) {
    h.fire("stable", M);
  }
  function _(M) {
    for (var P = 0; P < M.length; ++P) {
      var O = M[P];
      O.changeType === "add" ? (O.node && b(O.node.id), O.link && S(O.link)) : O.changeType === "remove" && (O.node && T(O.node), O.link && w(O.link));
    }
    l = r.getNodesCount();
  }
  function x() {
    l = 0, r.forEachNode(function(M) {
      b(M.id), l += 1;
    }), r.forEachLink(S);
  }
  function b(M) {
    var P = a.get(M);
    if (!P) {
      var O = r.getNode(M);
      if (!O)
        throw new Error("initBody() was called with unknown node id");
      var V = O.position;
      if (!V) {
        var B = C(O);
        V = n.getBestNewBodyPosition(B);
      }
      P = n.addBodyAt(V), P.id = M, a.set(M, P), E(M), A(O) && (P.isPinned = !0);
    }
  }
  function T(M) {
    var P = M.id, O = a.get(P);
    O && (a.delete(P), n.removeBody(O));
  }
  function S(M) {
    E(M.fromId), E(M.toId);
    var P = a.get(M.fromId), O = a.get(M.toId), V = n.addSpring(P, O, M.length);
    u(M, V), o[M.id] = V;
  }
  function w(M) {
    var P = o[M.id];
    if (P) {
      var O = r.getNode(M.fromId), V = r.getNode(M.toId);
      O && E(O.id), V && E(V.id), delete o[M.id], n.removeSpring(P);
    }
  }
  function C(M) {
    var P = [];
    if (!M.links)
      return P;
    for (var O = Math.min(M.links.length, 2), V = 0; V < O; ++V) {
      var B = M.links[V], H = B.fromId !== M.id ? a.get(B.fromId) : a.get(B.toId);
      H && H.pos && P.push(H);
    }
    return P;
  }
  function E(M) {
    var P = a.get(M);
    if (P.mass = s(M), Number.isNaN(P.mass))
      throw new Error("Node mass should be a number");
  }
  function A(M) {
    return M && (M.isPinned || M.data && M.data.isPinned);
  }
  function N(M) {
    var P = a.get(M);
    return P || (b(M), P = a.get(M)), P;
  }
  function L(M) {
    var P = r.getLinks(M);
    return P ? 1 + P.length / 3 : 1;
  }
  function F(M) {
    var P = r.getLinks(M);
    return P ? 1 + P.size / 3 : 1;
  }
}
function KG() {
}
var QG = Y_.exports;
const ZG = /* @__PURE__ */ f_(QG);
function Sm(r) {
  var e = typeof r;
  return r != null && (e == "object" || e == "function");
}
var JG = typeof global == "object" && global && global.Object === Object && global, e8 = typeof self == "object" && self && self.Object === Object && self, iN = JG || e8 || Function("return this")(), e0 = function() {
  return iN.Date.now();
}, t8 = /\s/;
function i8(r) {
  for (var e = r.length; e-- && t8.test(r.charAt(e)); )
    ;
  return e;
}
var r8 = /^\s+/;
function n8(r) {
  return r && r.slice(0, i8(r) + 1).replace(r8, "");
}
var wm = iN.Symbol, rN = Object.prototype, s8 = rN.hasOwnProperty, a8 = rN.toString, dh = wm ? wm.toStringTag : void 0;
function o8(r) {
  var e = s8.call(r, dh), i = r[dh];
  try {
    r[dh] = void 0;
    var n = !0;
  } catch {
  }
  var s = a8.call(r);
  return n && (e ? r[dh] = i : delete r[dh]), s;
}
var l8 = Object.prototype, u8 = l8.toString;
function c8(r) {
  return u8.call(r);
}
var h8 = "[object Null]", d8 = "[object Undefined]", Hw = wm ? wm.toStringTag : void 0;
function p8(r) {
  return r == null ? r === void 0 ? d8 : h8 : Hw && Hw in Object(r) ? o8(r) : c8(r);
}
function f8(r) {
  return r != null && typeof r == "object";
}
var m8 = "[object Symbol]";
function g8(r) {
  return typeof r == "symbol" || f8(r) && p8(r) == m8;
}
var Ww = NaN, y8 = /^[-+]0x[0-9a-f]+$/i, v8 = /^0b[01]+$/i, b8 = /^0o[0-7]+$/i, x8 = parseInt;
function qw(r) {
  if (typeof r == "number")
    return r;
  if (g8(r))
    return Ww;
  if (Sm(r)) {
    var e = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = Sm(e) ? e + "" : e;
  }
  if (typeof r != "string")
    return r === 0 ? r : +r;
  r = n8(r);
  var i = v8.test(r);
  return i || b8.test(r) ? x8(r.slice(2), i ? 2 : 8) : y8.test(r) ? Ww : +r;
}
var _8 = "Expected a function", T8 = Math.max, S8 = Math.min;
function nN(r, e, i) {
  var n, s, a, o, l, u, c = 0, h = !1, d = !1, p = !0;
  if (typeof r != "function")
    throw new TypeError(_8);
  e = qw(e) || 0, Sm(i) && (h = !!i.leading, d = "maxWait" in i, a = d ? T8(qw(i.maxWait) || 0, e) : a, p = "trailing" in i ? !!i.trailing : p);
  function f(S) {
    var w = n, C = s;
    return n = s = void 0, c = S, o = r.apply(C, w), o;
  }
  function m(S) {
    return c = S, l = setTimeout(g, e), h ? f(S) : o;
  }
  function v(S) {
    var w = S - u, C = S - c, E = e - w;
    return d ? S8(E, a - C) : E;
  }
  function y(S) {
    var w = S - u, C = S - c;
    return u === void 0 || w >= e || w < 0 || d && C >= a;
  }
  function g() {
    var S = e0();
    if (y(S))
      return _(S);
    l = setTimeout(g, v(S));
  }
  function _(S) {
    return l = void 0, p && n ? f(S) : (n = s = void 0, o);
  }
  function x() {
    l !== void 0 && clearTimeout(l), c = 0, n = u = s = l = void 0;
  }
  function b() {
    return l === void 0 ? o : _(e0());
  }
  function T() {
    var S = e0(), w = y(S);
    if (n = arguments, s = this, u = S, w) {
      if (l === void 0)
        return m(u);
      if (d)
        return clearTimeout(l), l = setTimeout(g, e), f(u);
    }
    return l === void 0 && (l = setTimeout(g, e)), o;
  }
  return T.cancel = x, T.flush = b, T;
}
function Xw(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function w8(r) {
  if (Array.isArray(r)) return r;
}
function E8(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function M8(r, e, i) {
  return Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function A8(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function C8() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function R8(r, e) {
  return w8(r) || A8(r, e) || N8(r, e) || C8();
}
function N8(r, e) {
  if (r) {
    if (typeof r == "string") return Xw(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Xw(r, e) : void 0;
  }
}
var P8 = /* @__PURE__ */ M8(function r(e, i) {
  var n = i.default, s = n === void 0 ? null : n, a = i.triggerUpdate, o = a === void 0 ? !0 : a, l = i.onChange, u = l === void 0 ? function(c, h) {
  } : l;
  E8(this, r), this.name = e, this.defaultVal = s, this.triggerUpdate = o, this.onChange = u;
});
function Il(r) {
  var e = r.stateInit, i = e === void 0 ? function() {
    return {};
  } : e, n = r.props, s = n === void 0 ? {} : n, a = r.methods, o = a === void 0 ? {} : a, l = r.aliases, u = l === void 0 ? {} : l, c = r.init, h = c === void 0 ? function() {
  } : c, d = r.update, p = d === void 0 ? function() {
  } : d, f = Object.keys(s).map(function(m) {
    return new P8(m, s[m]);
  });
  return function m() {
    for (var v = arguments.length, y = new Array(v), g = 0; g < v; g++)
      y[g] = arguments[g];
    var _ = !!(this instanceof m && this.constructor), x = _ ? y.shift() : void 0, b = y[0], T = b === void 0 ? {} : b, S = Object.assign(
      {},
      i instanceof Function ? i(T) : i,
      // Support plain objects for backwards compatibility
      {
        initialised: !1
      }
    ), w = {};
    function C(N) {
      return E(N, T), A(), C;
    }
    var E = function(N, L) {
      h.call(C, N, S, L), S.initialised = !0;
    }, A = nN(function() {
      S.initialised && (p.call(C, S, w), w = {});
    }, 1);
    return f.forEach(function(N) {
      C[N.name] = L(N);
      function L(F) {
        var M = F.name, P = F.triggerUpdate, O = P === void 0 ? !1 : P, V = F.onChange, B = V === void 0 ? function(j, Q) {
        } : V, H = F.defaultVal, U = H === void 0 ? null : H;
        return function(j) {
          var Q = S[M];
          if (!arguments.length)
            return Q;
          var q = j === void 0 ? U : j;
          return S[M] = q, B.call(C, q, S, Q), !w.hasOwnProperty(M) && (w[M] = Q), O && A(), C;
        };
      }
    }), Object.keys(o).forEach(function(N) {
      C[N] = function() {
        for (var L, F = arguments.length, M = new Array(F), P = 0; P < F; P++)
          M[P] = arguments[P];
        return (L = o[N]).call.apply(L, [C, S].concat(M));
      };
    }), Object.entries(u).forEach(function(N) {
      var L = R8(N, 2), F = L[0], M = L[1];
      return C[F] = C[M];
    }), C.resetProps = function() {
      return f.forEach(function(N) {
        C[N.name](N.defaultVal);
      }), C;
    }, C.resetProps(), S._rerender = A, _ && x && C(x), C;
  };
}
var et = function(r) {
  return typeof r == "function" ? r : typeof r == "string" ? function(e) {
    return e[r];
  } : function(e) {
    return r;
  };
};
class Yw extends Map {
  constructor(e, i = D8) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: i } }), e != null) for (const [n, s] of e) this.set(n, s);
  }
  get(e) {
    return super.get($w(this, e));
  }
  has(e) {
    return super.has($w(this, e));
  }
  set(e, i) {
    return super.set(O8(this, e), i);
  }
  delete(e) {
    return super.delete(I8(this, e));
  }
}
function $w({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) ? r.get(n) : i;
}
function O8({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) ? r.get(n) : (r.set(n, i), i);
}
function I8({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) && (i = r.get(n), r.delete(n)), i;
}
function D8(r) {
  return r !== null && typeof r == "object" ? r.valueOf() : r;
}
function Bb(r, e) {
  let i;
  if (e === void 0)
    for (const n of r)
      n != null && (i < n || i === void 0 && n >= n) && (i = n);
  else {
    let n = -1;
    for (let s of r)
      (s = e(s, ++n, r)) != null && (i < s || i === void 0 && s >= s) && (i = s);
  }
  return i;
}
function zb(r, e) {
  let i;
  if (e === void 0)
    for (const n of r)
      n != null && (i > n || i === void 0 && n >= n) && (i = n);
  else {
    let n = -1;
    for (let s of r)
      (s = e(s, ++n, r)) != null && (i > s || i === void 0 && s >= s) && (i = s);
  }
  return i;
}
function k8(r, e) {
  let i = 0;
  for (let n of r)
    (n = +n) && (i += n);
  return i;
}
function jb(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function L8(r) {
  if (Array.isArray(r)) return r;
}
function U8(r) {
  if (Array.isArray(r)) return jb(r);
}
function sN(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function F8(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function B8(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function ur(r, e) {
  return r.get(sN(r, e));
}
function au(r, e, i) {
  F8(r, e), e.set(r, i);
}
function Bp(r, e, i) {
  return r.set(sN(r, e), i), i;
}
function z8(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, $8(n.key), n);
  }
}
function j8(r, e, i) {
  return e && z8(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function V8(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function G8(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function H8() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function W8() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function q8(r, e) {
  return L8(r) || G8(r, e) || aN(r, e) || H8();
}
function X8(r) {
  return U8(r) || V8(r) || aN(r) || W8();
}
function Y8(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function $8(r) {
  var e = Y8(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function aN(r, e) {
  if (r) {
    if (typeof r == "string") return jb(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? jb(r, e) : void 0;
  }
}
var ou = /* @__PURE__ */ new WeakMap(), ph = /* @__PURE__ */ new WeakMap(), lu = /* @__PURE__ */ new WeakMap(), t0 = /* @__PURE__ */ new WeakMap(), i0 = /* @__PURE__ */ new WeakMap(), r0 = /* @__PURE__ */ new WeakMap(), K8 = /* @__PURE__ */ function() {
  function r() {
    B8(this, r), au(this, ou, /* @__PURE__ */ new Map()), au(this, ph, /* @__PURE__ */ new Map()), au(this, lu, function(e) {
      return e;
    }), au(this, t0, function() {
      return {};
    }), au(this, i0, function() {
    }), au(this, r0, function() {
    });
  }
  return j8(r, [{
    key: "getObj",
    value: function(e) {
      return ur(ou, this).get(ur(lu, this).call(this, e));
    }
  }, {
    key: "getData",
    value: function(e) {
      return ur(ph, this).get(e);
    }
  }, {
    key: "entries",
    value: function() {
      return X8(ur(ph, this).entries()).map(function(e) {
        var i = q8(e, 2), n = i[0], s = i[1];
        return [s, n];
      });
    }
  }, {
    key: "id",
    value: function(e) {
      return Bp(lu, this, et(e)), this;
    }
  }, {
    key: "onCreateObj",
    value: function(e) {
      return Bp(t0, this, e), this;
    }
  }, {
    key: "onUpdateObj",
    value: function(e) {
      return Bp(i0, this, e), this;
    }
  }, {
    key: "onRemoveObj",
    value: function(e) {
      return Bp(r0, this, e), this;
    }
  }, {
    key: "digest",
    value: function(e) {
      var i = this;
      e.filter(function(s) {
        return !ur(ou, i).has(ur(lu, i).call(i, s));
      }).forEach(function(s) {
        var a = ur(t0, i).call(i, s);
        ur(ou, i).set(ur(lu, i).call(i, s), a), ur(ph, i).set(a, s);
      });
      var n = new Map(e.map(function(s) {
        return [ur(lu, i).call(i, s), s];
      }));
      return ur(ou, this).forEach(function(s, a) {
        n.has(a) ? ur(i0, i).call(i, s, n.get(a)) : (ur(r0, i).call(i, s, a), ur(ou, i).delete(a), ur(ph, i).delete(s));
      }), this;
    }
  }, {
    key: "clear",
    value: function() {
      return this.digest([]), this;
    }
  }]);
}();
function Q8(r, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(r);
      break;
    default:
      this.range(e).domain(r);
      break;
  }
  return this;
}
const Kw = Symbol("implicit");
function eT() {
  var r = new Yw(), e = [], i = [], n = Kw;
  function s(a) {
    let o = r.get(a);
    if (o === void 0) {
      if (n !== Kw) return n;
      r.set(a, o = e.push(a) - 1);
    }
    return i[o % i.length];
  }
  return s.domain = function(a) {
    if (!arguments.length) return e.slice();
    e = [], r = new Yw();
    for (const o of a)
      r.has(o) || r.set(o, e.push(o) - 1);
    return s;
  }, s.range = function(a) {
    return arguments.length ? (i = Array.from(a), s) : i.slice();
  }, s.unknown = function(a) {
    return arguments.length ? (n = a, s) : n;
  }, s.copy = function() {
    return eT(e, i).unknown(n);
  }, Q8.apply(s, arguments), s;
}
function tT(r, e, i) {
  r.prototype = e.prototype = i, i.constructor = r;
}
function oN(r, e) {
  var i = Object.create(r.prototype);
  for (var n in e) i[n] = e[n];
  return i;
}
function qd() {
}
var fd = 0.7, Em = 1 / fd, Xu = "\\s*([+-]?\\d+)\\s*", md = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", _s = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Z8 = /^#([0-9a-f]{3,8})$/, J8 = new RegExp(`^rgb\\(${Xu},${Xu},${Xu}\\)$`), eH = new RegExp(`^rgb\\(${_s},${_s},${_s}\\)$`), tH = new RegExp(`^rgba\\(${Xu},${Xu},${Xu},${md}\\)$`), iH = new RegExp(`^rgba\\(${_s},${_s},${_s},${md}\\)$`), rH = new RegExp(`^hsl\\(${md},${_s},${_s}\\)$`), nH = new RegExp(`^hsla\\(${md},${_s},${_s},${md}\\)$`), Qw = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
tT(qd, gd, {
  copy(r) {
    return Object.assign(new this.constructor(), this, r);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Zw,
  // Deprecated! Use color.formatHex.
  formatHex: Zw,
  formatHex8: sH,
  formatHsl: aH,
  formatRgb: Jw,
  toString: Jw
});
function Zw() {
  return this.rgb().formatHex();
}
function sH() {
  return this.rgb().formatHex8();
}
function aH() {
  return lN(this).formatHsl();
}
function Jw() {
  return this.rgb().formatRgb();
}
function gd(r) {
  var e, i;
  return r = (r + "").trim().toLowerCase(), (e = Z8.exec(r)) ? (i = e[1].length, e = parseInt(e[1], 16), i === 6 ? eE(e) : i === 3 ? new Fr(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : i === 8 ? zp(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : i === 4 ? zp(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = J8.exec(r)) ? new Fr(e[1], e[2], e[3], 1) : (e = eH.exec(r)) ? new Fr(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = tH.exec(r)) ? zp(e[1], e[2], e[3], e[4]) : (e = iH.exec(r)) ? zp(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = rH.exec(r)) ? rE(e[1], e[2] / 100, e[3] / 100, 1) : (e = nH.exec(r)) ? rE(e[1], e[2] / 100, e[3] / 100, e[4]) : Qw.hasOwnProperty(r) ? eE(Qw[r]) : r === "transparent" ? new Fr(NaN, NaN, NaN, 0) : null;
}
function eE(r) {
  return new Fr(r >> 16 & 255, r >> 8 & 255, r & 255, 1);
}
function zp(r, e, i, n) {
  return n <= 0 && (r = e = i = NaN), new Fr(r, e, i, n);
}
function oH(r) {
  return r instanceof qd || (r = gd(r)), r ? (r = r.rgb(), new Fr(r.r, r.g, r.b, r.opacity)) : new Fr();
}
function Vb(r, e, i, n) {
  return arguments.length === 1 ? oH(r) : new Fr(r, e, i, n ?? 1);
}
function Fr(r, e, i, n) {
  this.r = +r, this.g = +e, this.b = +i, this.opacity = +n;
}
tT(Fr, Vb, oN(qd, {
  brighter(r) {
    return r = r == null ? Em : Math.pow(Em, r), new Fr(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? fd : Math.pow(fd, r), new Fr(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Fr(yl(this.r), yl(this.g), yl(this.b), Mm(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: tE,
  // Deprecated! Use color.formatHex.
  formatHex: tE,
  formatHex8: lH,
  formatRgb: iE,
  toString: iE
}));
function tE() {
  return `#${ol(this.r)}${ol(this.g)}${ol(this.b)}`;
}
function lH() {
  return `#${ol(this.r)}${ol(this.g)}${ol(this.b)}${ol((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function iE() {
  const r = Mm(this.opacity);
  return `${r === 1 ? "rgb(" : "rgba("}${yl(this.r)}, ${yl(this.g)}, ${yl(this.b)}${r === 1 ? ")" : `, ${r})`}`;
}
function Mm(r) {
  return isNaN(r) ? 1 : Math.max(0, Math.min(1, r));
}
function yl(r) {
  return Math.max(0, Math.min(255, Math.round(r) || 0));
}
function ol(r) {
  return r = yl(r), (r < 16 ? "0" : "") + r.toString(16);
}
function rE(r, e, i, n) {
  return n <= 0 ? r = e = i = NaN : i <= 0 || i >= 1 ? r = e = NaN : e <= 0 && (r = NaN), new Yn(r, e, i, n);
}
function lN(r) {
  if (r instanceof Yn) return new Yn(r.h, r.s, r.l, r.opacity);
  if (r instanceof qd || (r = gd(r)), !r) return new Yn();
  if (r instanceof Yn) return r;
  r = r.rgb();
  var e = r.r / 255, i = r.g / 255, n = r.b / 255, s = Math.min(e, i, n), a = Math.max(e, i, n), o = NaN, l = a - s, u = (a + s) / 2;
  return l ? (e === a ? o = (i - n) / l + (i < n) * 6 : i === a ? o = (n - e) / l + 2 : o = (e - i) / l + 4, l /= u < 0.5 ? a + s : 2 - a - s, o *= 60) : l = u > 0 && u < 1 ? 0 : o, new Yn(o, l, u, r.opacity);
}
function uH(r, e, i, n) {
  return arguments.length === 1 ? lN(r) : new Yn(r, e, i, n ?? 1);
}
function Yn(r, e, i, n) {
  this.h = +r, this.s = +e, this.l = +i, this.opacity = +n;
}
tT(Yn, uH, oN(qd, {
  brighter(r) {
    return r = r == null ? Em : Math.pow(Em, r), new Yn(this.h, this.s, this.l * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? fd : Math.pow(fd, r), new Yn(this.h, this.s, this.l * r, this.opacity);
  },
  rgb() {
    var r = this.h % 360 + (this.h < 0) * 360, e = isNaN(r) || isNaN(this.s) ? 0 : this.s, i = this.l, n = i + (i < 0.5 ? i : 1 - i) * e, s = 2 * i - n;
    return new Fr(
      n0(r >= 240 ? r - 240 : r + 120, s, n),
      n0(r, s, n),
      n0(r < 120 ? r + 240 : r - 120, s, n),
      this.opacity
    );
  },
  clamp() {
    return new Yn(nE(this.h), jp(this.s), jp(this.l), Mm(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const r = Mm(this.opacity);
    return `${r === 1 ? "hsl(" : "hsla("}${nE(this.h)}, ${jp(this.s) * 100}%, ${jp(this.l) * 100}%${r === 1 ? ")" : `, ${r})`}`;
  }
}));
function nE(r) {
  return r = (r || 0) % 360, r < 0 ? r + 360 : r;
}
function jp(r) {
  return Math.max(0, Math.min(1, r || 0));
}
function n0(r, e, i) {
  return (r < 60 ? e + (i - e) * r / 60 : r < 180 ? i : r < 240 ? e + (i - e) * (240 - r) / 60 : e) * 255;
}
const uN = (r) => () => r;
function cH(r, e) {
  return function(i) {
    return r + i * e;
  };
}
function hH(r, e, i) {
  return r = Math.pow(r, i), e = Math.pow(e, i) - r, i = 1 / i, function(n) {
    return Math.pow(r + n * e, i);
  };
}
function dH(r) {
  return (r = +r) == 1 ? cN : function(e, i) {
    return i - e ? hH(e, i, r) : uN(isNaN(e) ? i : e);
  };
}
function cN(r, e) {
  var i = e - r;
  return i ? cH(r, i) : uN(isNaN(r) ? e : r);
}
const sE = function r(e) {
  var i = dH(e);
  function n(s, a) {
    var o = i((s = Vb(s)).r, (a = Vb(a)).r), l = i(s.g, a.g), u = i(s.b, a.b), c = cN(s.opacity, a.opacity);
    return function(h) {
      return s.r = o(h), s.g = l(h), s.b = u(h), s.opacity = c(h), s + "";
    };
  }
  return n.gamma = r, n;
}(1);
function Za(r, e) {
  return r = +r, e = +e, function(i) {
    return r * (1 - i) + e * i;
  };
}
var Gb = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, s0 = new RegExp(Gb.source, "g");
function pH(r) {
  return function() {
    return r;
  };
}
function fH(r) {
  return function(e) {
    return r(e) + "";
  };
}
function mH(r, e) {
  var i = Gb.lastIndex = s0.lastIndex = 0, n, s, a, o = -1, l = [], u = [];
  for (r = r + "", e = e + ""; (n = Gb.exec(r)) && (s = s0.exec(e)); )
    (a = s.index) > i && (a = e.slice(i, a), l[o] ? l[o] += a : l[++o] = a), (n = n[0]) === (s = s[0]) ? l[o] ? l[o] += s : l[++o] = s : (l[++o] = null, u.push({ i: o, x: Za(n, s) })), i = s0.lastIndex;
  return i < e.length && (a = e.slice(i), l[o] ? l[o] += a : l[++o] = a), l.length < 2 ? u[0] ? fH(u[0].x) : pH(e) : (e = u.length, function(c) {
    for (var h = 0, d; h < e; ++h) l[(d = u[h]).i] = d.x(c);
    return l.join("");
  });
}
var aE = 180 / Math.PI, hN = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function dN(r, e, i, n, s, a) {
  var o, l, u;
  return (o = Math.sqrt(r * r + e * e)) && (r /= o, e /= o), (u = r * i + e * n) && (i -= r * u, n -= e * u), (l = Math.sqrt(i * i + n * n)) && (i /= l, n /= l, u /= l), r * n < e * i && (r = -r, e = -e, u = -u, o = -o), {
    translateX: s,
    translateY: a,
    rotate: Math.atan2(e, r) * aE,
    skewX: Math.atan(u) * aE,
    scaleX: o,
    scaleY: l
  };
}
var Vp;
function gH(r) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(r + "");
  return e.isIdentity ? hN : dN(e.a, e.b, e.c, e.d, e.e, e.f);
}
function yH(r) {
  return r == null || (Vp || (Vp = document.createElementNS("http://www.w3.org/2000/svg", "g")), Vp.setAttribute("transform", r), !(r = Vp.transform.baseVal.consolidate())) ? hN : (r = r.matrix, dN(r.a, r.b, r.c, r.d, r.e, r.f));
}
function pN(r, e, i, n) {
  function s(c) {
    return c.length ? c.pop() + " " : "";
  }
  function a(c, h, d, p, f, m) {
    if (c !== d || h !== p) {
      var v = f.push("translate(", null, e, null, i);
      m.push({ i: v - 4, x: Za(c, d) }, { i: v - 2, x: Za(h, p) });
    } else (d || p) && f.push("translate(" + d + e + p + i);
  }
  function o(c, h, d, p) {
    c !== h ? (c - h > 180 ? h += 360 : h - c > 180 && (c += 360), p.push({ i: d.push(s(d) + "rotate(", null, n) - 2, x: Za(c, h) })) : h && d.push(s(d) + "rotate(" + h + n);
  }
  function l(c, h, d, p) {
    c !== h ? p.push({ i: d.push(s(d) + "skewX(", null, n) - 2, x: Za(c, h) }) : h && d.push(s(d) + "skewX(" + h + n);
  }
  function u(c, h, d, p, f, m) {
    if (c !== d || h !== p) {
      var v = f.push(s(f) + "scale(", null, ",", null, ")");
      m.push({ i: v - 4, x: Za(c, d) }, { i: v - 2, x: Za(h, p) });
    } else (d !== 1 || p !== 1) && f.push(s(f) + "scale(" + d + "," + p + ")");
  }
  return function(c, h) {
    var d = [], p = [];
    return c = r(c), h = r(h), a(c.translateX, c.translateY, h.translateX, h.translateY, d, p), o(c.rotate, h.rotate, d, p), l(c.skewX, h.skewX, d, p), u(c.scaleX, c.scaleY, h.scaleX, h.scaleY, d, p), c = h = null, function(f) {
      for (var m = -1, v = p.length, y; ++m < v; ) d[(y = p[m]).i] = y.x(f);
      return d.join("");
    };
  };
}
var vH = pN(gH, "px, ", "px)", "deg)"), bH = pN(yH, ", ", ")", ")"), xH = 1e-12;
function oE(r) {
  return ((r = Math.exp(r)) + 1 / r) / 2;
}
function _H(r) {
  return ((r = Math.exp(r)) - 1 / r) / 2;
}
function TH(r) {
  return ((r = Math.exp(2 * r)) - 1) / (r + 1);
}
const SH = function r(e, i, n) {
  function s(a, o) {
    var l = a[0], u = a[1], c = a[2], h = o[0], d = o[1], p = o[2], f = h - l, m = d - u, v = f * f + m * m, y, g;
    if (v < xH)
      g = Math.log(p / c) / e, y = function(w) {
        return [
          l + w * f,
          u + w * m,
          c * Math.exp(e * w * g)
        ];
      };
    else {
      var _ = Math.sqrt(v), x = (p * p - c * c + n * v) / (2 * c * i * _), b = (p * p - c * c - n * v) / (2 * p * i * _), T = Math.log(Math.sqrt(x * x + 1) - x), S = Math.log(Math.sqrt(b * b + 1) - b);
      g = (S - T) / e, y = function(w) {
        var C = w * g, E = oE(T), A = c / (i * _) * (E * TH(e * C + T) - _H(T));
        return [
          l + A * f,
          u + A * m,
          c * E / oE(e * C + T)
        ];
      };
    }
    return y.duration = g * 1e3 * e / Math.SQRT2, y;
  }
  return s.rho = function(a) {
    var o = Math.max(1e-3, +a), l = o * o, u = l * l;
    return r(o, l, u);
  }, s;
}(Math.SQRT2, 2, 4);
function wH(r) {
  for (var e = r.length / 6 | 0, i = new Array(e), n = 0; n < e; ) i[n] = "#" + r.slice(n * 6, ++n * 6);
  return i;
}
const fN = wH("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
function Am(r) {
  "@babel/helpers - typeof";
  return Am = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Am(r);
}
var EH = /^\s+/, MH = /\s+$/;
function rt(r, e) {
  if (r = r || "", e = e || {}, r instanceof rt)
    return r;
  if (!(this instanceof rt))
    return new rt(r, e);
  var i = AH(r);
  this._originalInput = r, this._r = i.r, this._g = i.g, this._b = i.b, this._a = i.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e.format || i.format, this._gradientType = e.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = i.ok;
}
rt.prototype = {
  isDark: function() {
    return this.getBrightness() < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  isValid: function() {
    return this._ok;
  },
  getOriginalInput: function() {
    return this._originalInput;
  },
  getFormat: function() {
    return this._format;
  },
  getAlpha: function() {
    return this._a;
  },
  getBrightness: function() {
    var r = this.toRgb();
    return (r.r * 299 + r.g * 587 + r.b * 114) / 1e3;
  },
  getLuminance: function() {
    var r = this.toRgb(), e, i, n, s, a, o;
    return e = r.r / 255, i = r.g / 255, n = r.b / 255, e <= 0.03928 ? s = e / 12.92 : s = Math.pow((e + 0.055) / 1.055, 2.4), i <= 0.03928 ? a = i / 12.92 : a = Math.pow((i + 0.055) / 1.055, 2.4), n <= 0.03928 ? o = n / 12.92 : o = Math.pow((n + 0.055) / 1.055, 2.4), 0.2126 * s + 0.7152 * a + 0.0722 * o;
  },
  setAlpha: function(r) {
    return this._a = mN(r), this._roundA = Math.round(100 * this._a) / 100, this;
  },
  toHsv: function() {
    var r = uE(this._r, this._g, this._b);
    return {
      h: r.h * 360,
      s: r.s,
      v: r.v,
      a: this._a
    };
  },
  toHsvString: function() {
    var r = uE(this._r, this._g, this._b), e = Math.round(r.h * 360), i = Math.round(r.s * 100), n = Math.round(r.v * 100);
    return this._a == 1 ? "hsv(" + e + ", " + i + "%, " + n + "%)" : "hsva(" + e + ", " + i + "%, " + n + "%, " + this._roundA + ")";
  },
  toHsl: function() {
    var r = lE(this._r, this._g, this._b);
    return {
      h: r.h * 360,
      s: r.s,
      l: r.l,
      a: this._a
    };
  },
  toHslString: function() {
    var r = lE(this._r, this._g, this._b), e = Math.round(r.h * 360), i = Math.round(r.s * 100), n = Math.round(r.l * 100);
    return this._a == 1 ? "hsl(" + e + ", " + i + "%, " + n + "%)" : "hsla(" + e + ", " + i + "%, " + n + "%, " + this._roundA + ")";
  },
  toHex: function(r) {
    return cE(this._r, this._g, this._b, r);
  },
  toHexString: function(r) {
    return "#" + this.toHex(r);
  },
  toHex8: function(r) {
    return PH(this._r, this._g, this._b, this._a, r);
  },
  toHex8String: function(r) {
    return "#" + this.toHex8(r);
  },
  toRgb: function() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function() {
    return {
      r: Math.round(fi(this._r, 255) * 100) + "%",
      g: Math.round(fi(this._g, 255) * 100) + "%",
      b: Math.round(fi(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(fi(this._r, 255) * 100) + "%, " + Math.round(fi(this._g, 255) * 100) + "%, " + Math.round(fi(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(fi(this._r, 255) * 100) + "%, " + Math.round(fi(this._g, 255) * 100) + "%, " + Math.round(fi(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function() {
    return this._a === 0 ? "transparent" : this._a < 1 ? !1 : GH[cE(this._r, this._g, this._b, !0)] || !1;
  },
  toFilter: function(r) {
    var e = "#" + hE(this._r, this._g, this._b, this._a), i = e, n = this._gradientType ? "GradientType = 1, " : "";
    if (r) {
      var s = rt(r);
      i = "#" + hE(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + n + "startColorstr=" + e + ",endColorstr=" + i + ")";
  },
  toString: function(r) {
    var e = !!r;
    r = r || this._format;
    var i = !1, n = this._a < 1 && this._a >= 0, s = !e && n && (r === "hex" || r === "hex6" || r === "hex3" || r === "hex4" || r === "hex8" || r === "name");
    return s ? r === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (r === "rgb" && (i = this.toRgbString()), r === "prgb" && (i = this.toPercentageRgbString()), (r === "hex" || r === "hex6") && (i = this.toHexString()), r === "hex3" && (i = this.toHexString(!0)), r === "hex4" && (i = this.toHex8String(!0)), r === "hex8" && (i = this.toHex8String()), r === "name" && (i = this.toName()), r === "hsl" && (i = this.toHslString()), r === "hsv" && (i = this.toHsvString()), i || this.toHexString());
  },
  clone: function() {
    return rt(this.toString());
  },
  _applyModification: function(r, e) {
    var i = r.apply(null, [this].concat([].slice.call(e)));
    return this._r = i._r, this._g = i._g, this._b = i._b, this.setAlpha(i._a), this;
  },
  lighten: function() {
    return this._applyModification(kH, arguments);
  },
  brighten: function() {
    return this._applyModification(LH, arguments);
  },
  darken: function() {
    return this._applyModification(UH, arguments);
  },
  desaturate: function() {
    return this._applyModification(OH, arguments);
  },
  saturate: function() {
    return this._applyModification(IH, arguments);
  },
  greyscale: function() {
    return this._applyModification(DH, arguments);
  },
  spin: function() {
    return this._applyModification(FH, arguments);
  },
  _applyCombination: function(r, e) {
    return r.apply(null, [this].concat([].slice.call(e)));
  },
  analogous: function() {
    return this._applyCombination(jH, arguments);
  },
  complement: function() {
    return this._applyCombination(BH, arguments);
  },
  monochromatic: function() {
    return this._applyCombination(VH, arguments);
  },
  splitcomplement: function() {
    return this._applyCombination(zH, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function() {
    return this._applyCombination(dE, [3]);
  },
  tetrad: function() {
    return this._applyCombination(dE, [4]);
  }
};
rt.fromRatio = function(r, e) {
  if (Am(r) == "object") {
    var i = {};
    for (var n in r)
      r.hasOwnProperty(n) && (n === "a" ? i[n] = r[n] : i[n] = jh(r[n]));
    r = i;
  }
  return rt(r, e);
};
function AH(r) {
  var e = {
    r: 0,
    g: 0,
    b: 0
  }, i = 1, n = null, s = null, a = null, o = !1, l = !1;
  return typeof r == "string" && (r = XH(r)), Am(r) == "object" && (ks(r.r) && ks(r.g) && ks(r.b) ? (e = CH(r.r, r.g, r.b), o = !0, l = String(r.r).substr(-1) === "%" ? "prgb" : "rgb") : ks(r.h) && ks(r.s) && ks(r.v) ? (n = jh(r.s), s = jh(r.v), e = NH(r.h, n, s), o = !0, l = "hsv") : ks(r.h) && ks(r.s) && ks(r.l) && (n = jh(r.s), a = jh(r.l), e = RH(r.h, n, a), o = !0, l = "hsl"), r.hasOwnProperty("a") && (i = r.a)), i = mN(i), {
    ok: o,
    format: r.format || l,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: i
  };
}
function CH(r, e, i) {
  return {
    r: fi(r, 255) * 255,
    g: fi(e, 255) * 255,
    b: fi(i, 255) * 255
  };
}
function lE(r, e, i) {
  r = fi(r, 255), e = fi(e, 255), i = fi(i, 255);
  var n = Math.max(r, e, i), s = Math.min(r, e, i), a, o, l = (n + s) / 2;
  if (n == s)
    a = o = 0;
  else {
    var u = n - s;
    switch (o = l > 0.5 ? u / (2 - n - s) : u / (n + s), n) {
      case r:
        a = (e - i) / u + (e < i ? 6 : 0);
        break;
      case e:
        a = (i - r) / u + 2;
        break;
      case i:
        a = (r - e) / u + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s: o,
    l
  };
}
function RH(r, e, i) {
  var n, s, a;
  r = fi(r, 360), e = fi(e, 100), i = fi(i, 100);
  function o(c, h, d) {
    return d < 0 && (d += 1), d > 1 && (d -= 1), d < 1 / 6 ? c + (h - c) * 6 * d : d < 1 / 2 ? h : d < 2 / 3 ? c + (h - c) * (2 / 3 - d) * 6 : c;
  }
  if (e === 0)
    n = s = a = i;
  else {
    var l = i < 0.5 ? i * (1 + e) : i + e - i * e, u = 2 * i - l;
    n = o(u, l, r + 1 / 3), s = o(u, l, r), a = o(u, l, r - 1 / 3);
  }
  return {
    r: n * 255,
    g: s * 255,
    b: a * 255
  };
}
function uE(r, e, i) {
  r = fi(r, 255), e = fi(e, 255), i = fi(i, 255);
  var n = Math.max(r, e, i), s = Math.min(r, e, i), a, o, l = n, u = n - s;
  if (o = n === 0 ? 0 : u / n, n == s)
    a = 0;
  else {
    switch (n) {
      case r:
        a = (e - i) / u + (e < i ? 6 : 0);
        break;
      case e:
        a = (i - r) / u + 2;
        break;
      case i:
        a = (r - e) / u + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s: o,
    v: l
  };
}
function NH(r, e, i) {
  r = fi(r, 360) * 6, e = fi(e, 100), i = fi(i, 100);
  var n = Math.floor(r), s = r - n, a = i * (1 - e), o = i * (1 - s * e), l = i * (1 - (1 - s) * e), u = n % 6, c = [i, o, a, a, l, i][u], h = [l, i, i, o, a, a][u], d = [a, a, l, i, i, o][u];
  return {
    r: c * 255,
    g: h * 255,
    b: d * 255
  };
}
function cE(r, e, i, n) {
  var s = [Qn(Math.round(r).toString(16)), Qn(Math.round(e).toString(16)), Qn(Math.round(i).toString(16))];
  return n && s[0].charAt(0) == s[0].charAt(1) && s[1].charAt(0) == s[1].charAt(1) && s[2].charAt(0) == s[2].charAt(1) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) : s.join("");
}
function PH(r, e, i, n, s) {
  var a = [Qn(Math.round(r).toString(16)), Qn(Math.round(e).toString(16)), Qn(Math.round(i).toString(16)), Qn(gN(n))];
  return s && a[0].charAt(0) == a[0].charAt(1) && a[1].charAt(0) == a[1].charAt(1) && a[2].charAt(0) == a[2].charAt(1) && a[3].charAt(0) == a[3].charAt(1) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("");
}
function hE(r, e, i, n) {
  var s = [Qn(gN(n)), Qn(Math.round(r).toString(16)), Qn(Math.round(e).toString(16)), Qn(Math.round(i).toString(16))];
  return s.join("");
}
rt.equals = function(r, e) {
  return !r || !e ? !1 : rt(r).toRgbString() == rt(e).toRgbString();
};
rt.random = function() {
  return rt.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function OH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.s -= e / 100, i.s = Eg(i.s), rt(i);
}
function IH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.s += e / 100, i.s = Eg(i.s), rt(i);
}
function DH(r) {
  return rt(r).desaturate(100);
}
function kH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.l += e / 100, i.l = Eg(i.l), rt(i);
}
function LH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toRgb();
  return i.r = Math.max(0, Math.min(255, i.r - Math.round(255 * -(e / 100)))), i.g = Math.max(0, Math.min(255, i.g - Math.round(255 * -(e / 100)))), i.b = Math.max(0, Math.min(255, i.b - Math.round(255 * -(e / 100)))), rt(i);
}
function UH(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.l -= e / 100, i.l = Eg(i.l), rt(i);
}
function FH(r, e) {
  var i = rt(r).toHsl(), n = (i.h + e) % 360;
  return i.h = n < 0 ? 360 + n : n, rt(i);
}
function BH(r) {
  var e = rt(r).toHsl();
  return e.h = (e.h + 180) % 360, rt(e);
}
function dE(r, e) {
  if (isNaN(e) || e <= 0)
    throw new Error("Argument to polyad must be a positive number");
  for (var i = rt(r).toHsl(), n = [rt(r)], s = 360 / e, a = 1; a < e; a++)
    n.push(rt({
      h: (i.h + a * s) % 360,
      s: i.s,
      l: i.l
    }));
  return n;
}
function zH(r) {
  var e = rt(r).toHsl(), i = e.h;
  return [rt(r), rt({
    h: (i + 72) % 360,
    s: e.s,
    l: e.l
  }), rt({
    h: (i + 216) % 360,
    s: e.s,
    l: e.l
  })];
}
function jH(r, e, i) {
  e = e || 6, i = i || 30;
  var n = rt(r).toHsl(), s = 360 / i, a = [rt(r)];
  for (n.h = (n.h - (s * e >> 1) + 720) % 360; --e; )
    n.h = (n.h + s) % 360, a.push(rt(n));
  return a;
}
function VH(r, e) {
  e = e || 6;
  for (var i = rt(r).toHsv(), n = i.h, s = i.s, a = i.v, o = [], l = 1 / e; e--; )
    o.push(rt({
      h: n,
      s,
      v: a
    })), a = (a + l) % 1;
  return o;
}
rt.mix = function(r, e, i) {
  i = i === 0 ? 0 : i || 50;
  var n = rt(r).toRgb(), s = rt(e).toRgb(), a = i / 100, o = {
    r: (s.r - n.r) * a + n.r,
    g: (s.g - n.g) * a + n.g,
    b: (s.b - n.b) * a + n.b,
    a: (s.a - n.a) * a + n.a
  };
  return rt(o);
};
rt.readability = function(r, e) {
  var i = rt(r), n = rt(e);
  return (Math.max(i.getLuminance(), n.getLuminance()) + 0.05) / (Math.min(i.getLuminance(), n.getLuminance()) + 0.05);
};
rt.isReadable = function(r, e, i) {
  var n = rt.readability(r, e), s, a;
  switch (a = !1, s = YH(i), s.level + s.size) {
    case "AAsmall":
    case "AAAlarge":
      a = n >= 4.5;
      break;
    case "AAlarge":
      a = n >= 3;
      break;
    case "AAAsmall":
      a = n >= 7;
      break;
  }
  return a;
};
rt.mostReadable = function(r, e, i) {
  var n = null, s = 0, a, o, l, u;
  i = i || {}, o = i.includeFallbackColors, l = i.level, u = i.size;
  for (var c = 0; c < e.length; c++)
    a = rt.readability(r, e[c]), a > s && (s = a, n = rt(e[c]));
  return rt.isReadable(r, n, {
    level: l,
    size: u
  }) || !o ? n : (i.includeFallbackColors = !1, rt.mostReadable(r, ["#fff", "#000"], i));
};
var Hb = rt.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
}, GH = rt.hexNames = HH(Hb);
function HH(r) {
  var e = {};
  for (var i in r)
    r.hasOwnProperty(i) && (e[r[i]] = i);
  return e;
}
function mN(r) {
  return r = parseFloat(r), (isNaN(r) || r < 0 || r > 1) && (r = 1), r;
}
function fi(r, e) {
  WH(r) && (r = "100%");
  var i = qH(r);
  return r = Math.min(e, Math.max(0, parseFloat(r))), i && (r = parseInt(r * e, 10) / 100), Math.abs(r - e) < 1e-6 ? 1 : r % e / parseFloat(e);
}
function Eg(r) {
  return Math.min(1, Math.max(0, r));
}
function an(r) {
  return parseInt(r, 16);
}
function WH(r) {
  return typeof r == "string" && r.indexOf(".") != -1 && parseFloat(r) === 1;
}
function qH(r) {
  return typeof r == "string" && r.indexOf("%") != -1;
}
function Qn(r) {
  return r.length == 1 ? "0" + r : "" + r;
}
function jh(r) {
  return r <= 1 && (r = r * 100 + "%"), r;
}
function gN(r) {
  return Math.round(parseFloat(r) * 255).toString(16);
}
function pE(r) {
  return an(r) / 255;
}
var Fn = function() {
  var r = "[-\\+]?\\d+%?", e = "[-\\+]?\\d*\\.\\d+%?", i = "(?:" + e + ")|(?:" + r + ")", n = "[\\s|\\(]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")\\s*\\)?", s = "[\\s|\\(]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(i),
    rgb: new RegExp("rgb" + n),
    rgba: new RegExp("rgba" + s),
    hsl: new RegExp("hsl" + n),
    hsla: new RegExp("hsla" + s),
    hsv: new RegExp("hsv" + n),
    hsva: new RegExp("hsva" + s),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function ks(r) {
  return !!Fn.CSS_UNIT.exec(r);
}
function XH(r) {
  r = r.replace(EH, "").replace(MH, "").toLowerCase();
  var e = !1;
  if (Hb[r])
    r = Hb[r], e = !0;
  else if (r == "transparent")
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  var i;
  return (i = Fn.rgb.exec(r)) ? {
    r: i[1],
    g: i[2],
    b: i[3]
  } : (i = Fn.rgba.exec(r)) ? {
    r: i[1],
    g: i[2],
    b: i[3],
    a: i[4]
  } : (i = Fn.hsl.exec(r)) ? {
    h: i[1],
    s: i[2],
    l: i[3]
  } : (i = Fn.hsla.exec(r)) ? {
    h: i[1],
    s: i[2],
    l: i[3],
    a: i[4]
  } : (i = Fn.hsv.exec(r)) ? {
    h: i[1],
    s: i[2],
    v: i[3]
  } : (i = Fn.hsva.exec(r)) ? {
    h: i[1],
    s: i[2],
    v: i[3],
    a: i[4]
  } : (i = Fn.hex8.exec(r)) ? {
    r: an(i[1]),
    g: an(i[2]),
    b: an(i[3]),
    a: pE(i[4]),
    format: e ? "name" : "hex8"
  } : (i = Fn.hex6.exec(r)) ? {
    r: an(i[1]),
    g: an(i[2]),
    b: an(i[3]),
    format: e ? "name" : "hex"
  } : (i = Fn.hex4.exec(r)) ? {
    r: an(i[1] + "" + i[1]),
    g: an(i[2] + "" + i[2]),
    b: an(i[3] + "" + i[3]),
    a: pE(i[4] + "" + i[4]),
    format: e ? "name" : "hex8"
  } : (i = Fn.hex3.exec(r)) ? {
    r: an(i[1] + "" + i[1]),
    g: an(i[2] + "" + i[2]),
    b: an(i[3] + "" + i[3]),
    format: e ? "name" : "hex"
  } : !1;
}
function YH(r) {
  var e, i;
  return r = r || {
    level: "AA",
    size: "small"
  }, e = (r.level || "AA").toUpperCase(), i = (r.size || "small").toLowerCase(), e !== "AA" && e !== "AAA" && (e = "AA"), i !== "small" && i !== "large" && (i = "small"), {
    level: e,
    size: i
  };
}
function Wb(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function $H(r) {
  if (Array.isArray(r)) return r;
}
function KH(r) {
  if (Array.isArray(r)) return Wb(r);
}
function yN(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function QH(r) {
  if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function vN(r, e, i) {
  return e = bc(e), s9(r, iT() ? Reflect.construct(e, i || [], bc(r).constructor) : e.apply(r, i));
}
function ZH(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function bN(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function a0(r, e) {
  return r.get(yN(r, e));
}
function fE(r, e, i) {
  ZH(r, e), e.set(r, i);
}
function mE(r, e, i) {
  return r.set(yN(r, e), i), i;
}
function xN(r, e, i) {
  if (iT()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return s;
}
function JH(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, SN(n.key), n);
  }
}
function _N(r, e, i) {
  return e && JH(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function Mg(r, e, i) {
  return (e = SN(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function qb() {
  return qb = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(r, e, i) {
    var n = a9(r, e);
    if (n) {
      var s = Object.getOwnPropertyDescriptor(n, e);
      return s.get ? s.get.call(arguments.length < 3 ? r : i) : s.value;
    }
  }, qb.apply(null, arguments);
}
function bc(r) {
  return bc = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, bc(r);
}
function TN(r, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  r.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: r,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(r, "prototype", {
    writable: !1
  }), e && Xb(r, e);
}
function iT() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (iT = function() {
    return !!r;
  })();
}
function e9(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function t9(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function i9() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function r9() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function gE(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function n9(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? gE(Object(i), !0).forEach(function(n) {
      Mg(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : gE(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function s9(r, e) {
  if (e && (typeof e == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return QH(r);
}
function Xb(r, e) {
  return Xb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Xb(r, e);
}
function Zh(r, e) {
  return $H(r) || t9(r, e) || wN(r, e) || i9();
}
function a9(r, e) {
  for (; !{}.hasOwnProperty.call(r, e) && (r = bc(r)) !== null; ) ;
  return r;
}
function o0(r, e, i, n) {
  var s = qb(bc(r.prototype), e, i);
  return typeof s == "function" ? function(a) {
    return s.apply(i, a);
  } : s;
}
function Hn(r) {
  return KH(r) || e9(r) || wN(r) || r9();
}
function o9(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function SN(r) {
  var e = o9(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Yb(r) {
  "@babel/helpers - typeof";
  return Yb = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Yb(r);
}
function wN(r, e) {
  if (r) {
    if (typeof r == "string") return Wb(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Wb(r, e) : void 0;
  }
}
var EN = function(r) {
  r instanceof Array ? r.forEach(EN) : (r.map && r.map.dispose(), r.dispose());
}, MN = function(r) {
  r.geometry && r.geometry.dispose(), r.material && EN(r.material), r.texture && r.texture.dispose(), r.children && r.children.forEach(MN);
}, $b = function(r) {
  for (; r.children.length; ) {
    var e = r.children[0];
    r.remove(e), MN(e);
  }
}, l0 = /* @__PURE__ */ new WeakMap(), Gp = /* @__PURE__ */ new WeakMap(), fh = /* @__PURE__ */ function(r) {
  function e(i) {
    var n, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = s.dataBindAttr, o = a === void 0 ? "__data" : a, l = s.objBindAttr, u = l === void 0 ? "__threeObj" : l;
    return bN(this, e), n = vN(this, e), Mg(n, "scene", void 0), fE(n, l0, void 0), fE(n, Gp, void 0), n.scene = i, mE(l0, n, o), mE(Gp, n, u), n.onRemoveObj(function() {
    }), n;
  }
  return TN(e, r), _N(e, [{
    key: "onCreateObj",
    value: function(i) {
      var n = this;
      return o0(e, "onCreateObj", this)([function(s) {
        var a = i(s);
        return s[a0(Gp, n)] = a, a[a0(l0, n)] = s, n.scene.add(a), a;
      }]), this;
    }
  }, {
    key: "onRemoveObj",
    value: function(i) {
      var n = this;
      return o0(e, "onRemoveObj", this)([function(s, a) {
        var o = o0(e, "getData", n)([s]);
        i(s, a), n.scene.remove(s), $b(s), delete o[a0(Gp, n)];
      }]), this;
    }
  }]);
}(K8), mh = function(r) {
  return isNaN(r) ? parseInt(rt(r).toHex(), 16) : r;
}, u0 = function(r) {
  return isNaN(r) ? rt(r).getAlpha() : 1;
}, l9 = eT(fN);
function yE(r, e, i) {
  !e || typeof i != "string" || r.filter(function(n) {
    return !n[i];
  }).forEach(function(n) {
    n[i] = l9(e(n));
  });
}
function u9(r, e) {
  var i = r.nodes, n = r.links, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = s.nodeFilter, o = a === void 0 ? function() {
    return !0;
  } : a, l = s.onLoopError, u = l === void 0 ? function(f) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(f.join(" -> "), ".");
  } : l, c = {};
  i.forEach(function(f) {
    return c[e(f)] = {
      data: f,
      out: [],
      depth: -1,
      skip: !o(f)
    };
  }), n.forEach(function(f) {
    var m = f.source, v = f.target, y = b(m), g = b(v);
    if (!c.hasOwnProperty(y)) throw "Missing source node with id: ".concat(y);
    if (!c.hasOwnProperty(g)) throw "Missing target node with id: ".concat(g);
    var _ = c[y], x = c[g];
    _.out.push(x);
    function b(T) {
      return Yb(T) === "object" ? e(T) : T;
    }
  });
  var h = [];
  p(Object.values(c));
  var d = Object.assign.apply(Object, [{}].concat(Hn(Object.entries(c).filter(function(f) {
    var m = Zh(f, 2), v = m[1];
    return !v.skip;
  }).map(function(f) {
    var m = Zh(f, 2), v = m[0], y = m[1];
    return Mg({}, v, y.depth);
  }))));
  return d;
  function p(f) {
    for (var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, y = function() {
      var x = f[g];
      if (m.indexOf(x) !== -1) {
        var b = [].concat(Hn(m.slice(m.indexOf(x))), [x]).map(function(T) {
          return e(T.data);
        });
        return h.some(function(T) {
          return T.length === b.length && T.every(function(S, w) {
            return S === b[w];
          });
        }) || (h.push(b), u(b)), 1;
      }
      v > x.depth && (x.depth = v, p(x.out, [].concat(Hn(m), [x]), v + (x.skip ? 0 : 1)));
    }, g = 0, _ = f.length; g < _; g++)
      y();
  }
}
var pt = window.THREE ? window.THREE : {
  Group: al,
  Mesh: Ur,
  MeshLambertMaterial: q6,
  Color: Ft,
  BufferGeometry: pn,
  BufferAttribute: wn,
  Matrix4: ui,
  Vector3: X,
  SphereGeometry: TR,
  CylinderGeometry: Tg,
  TubeGeometry: z_,
  ConeGeometry: B_,
  Line: N6,
  LineBasicMaterial: bR,
  QuadraticBezierCurve3: U_,
  CubicBezierCurve3: _R,
  Box3: Pl
}, vE = {
  graph: vG,
  forcelayout: ZG
}, c9 = 2, c0 = new pt.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute", Hp = new pt.BufferGeometry().applyMatrix4 ? "applyMatrix4" : "applyMatrix", h9 = Il({
  props: {
    jsonUrl: {
      onChange: function(r, e) {
        var i = this;
        r && !e.fetchingJson && (e.fetchingJson = !0, e.onLoading(), fetch(r).then(function(n) {
          return n.json();
        }).then(function(n) {
          e.fetchingJson = !1, e.onFinishLoading(n), i.graphData(n);
        }));
      },
      triggerUpdate: !1
    },
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        e.engineRunning = !1;
      }
    },
    numDimensions: {
      default: 3,
      onChange: function(r, e) {
        var i = e.d3ForceLayout.force("charge");
        i && i.strength(r > 2 ? -60 : -30), r < 3 && n(e.graphData.nodes, "z"), r < 2 && n(e.graphData.nodes, "y");
        function n(s, a) {
          s.forEach(function(o) {
            delete o[a], delete o["v".concat(a)];
          });
        }
      }
    },
    dagMode: {
      onChange: function(r, e) {
        !r && e.forceEngine === "d3" && (e.graphData.nodes || []).forEach(function(i) {
          return i.fx = i.fy = i.fz = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function(r) {
        return !0;
      }
    },
    onDagError: {
      triggerUpdate: !1
    },
    nodeRelSize: {
      default: 4
    },
    // volume per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val"
    },
    nodeResolution: {
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeColor: {
      default: "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      default: 0.75
    },
    nodeVisibility: {
      default: !0
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      default: !1
    },
    nodePositionUpdate: {
      triggerUpdate: !1
    },
    // custom function to call for updating the node's position. Signature: (threeObj, { x, y, z}, node). If the function returns a truthy value, the regular node position update will not run.
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0
    },
    linkColor: {
      default: "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      default: 0.2
    },
    linkWidth: {},
    // Rounded to nearest decimal. For falsy values use dimensionless line with 1px regardless of distance.
    linkResolution: {
      default: 6
    },
    // how many radial segments in each line tube's geometry
    linkCurvature: {
      default: 0,
      triggerUpdate: !1
    },
    // line curvature radius (0: straight, 1: semi-circle)
    linkCurveRotation: {
      default: 0,
      triggerUpdate: !1
    },
    // line curve rotation along the line axis (0: interection with XY plane, PI: upside down)
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      default: !1
    },
    linkPositionUpdate: {
      triggerUpdate: !1
    },
    // custom function to call for updating the link's position. Signature: (threeObj, { start: { x, y, z},  end: { x, y, z }}, link). If the function returns a truthy value, the regular link position update will not run.
    linkDirectionalArrowLength: {
      default: 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      default: 0.5,
      triggerUpdate: !1
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01,
      triggerUpdate: !1
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    forceEngine: {
      default: "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      default: 0
    },
    d3AlphaDecay: {
      default: 0.0228,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.alphaDecay(r);
      }
    },
    d3AlphaTarget: {
      default: 0,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.alphaTarget(r);
      }
    },
    d3VelocityDecay: {
      default: 0.4,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.velocityDecay(r);
      }
    },
    ngraphPhysics: {
      default: {
        // defaults from https://github.com/anvaka/ngraph.physics.simulator/blob/master/index.js
        timeStep: 20,
        gravity: -1.2,
        theta: 0.8,
        springLength: 30,
        springCoefficient: 8e-4,
        dragCoefficient: 0.02
      }
    },
    warmupTicks: {
      default: 0,
      triggerUpdate: !1
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      default: 1 / 0,
      triggerUpdate: !1
    },
    cooldownTime: {
      default: 15e3,
      triggerUpdate: !1
    },
    // ms
    onLoading: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishLoading: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineTick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineStop: {
      default: function() {
      },
      triggerUpdate: !1
    }
  },
  methods: {
    refresh: function(r) {
      return r._flushObjects = !0, r._rerender(), this;
    },
    // Expose d3 forces for external manipulation
    d3Force: function(r, e, i) {
      return i === void 0 ? r.d3ForceLayout.force(e) : (r.d3ForceLayout.force(e, i), this);
    },
    d3ReheatSimulation: function(r) {
      return r.d3ForceLayout.alpha(1), this.resetCountdown(), this;
    },
    // reset cooldown state
    resetCountdown: function(r) {
      return r.cntTicks = 0, r.startTickTime = /* @__PURE__ */ new Date(), r.engineRunning = !0, this;
    },
    tickFrame: function(r) {
      var e = r.forceEngine !== "ngraph";
      return r.engineRunning && i(), n(), s(), this;
      function i() {
        ++r.cntTicks > r.cooldownTicks || /* @__PURE__ */ new Date() - r.startTickTime > r.cooldownTime || e && r.d3AlphaMin > 0 && r.d3ForceLayout.alpha() < r.d3AlphaMin ? (r.engineRunning = !1, r.onEngineStop()) : (r.layout[e ? "tick" : "step"](), r.onEngineTick());
        var a = et(r.nodeThreeObjectExtend);
        r.nodeDataMapper.entries().forEach(function(d) {
          var p = Zh(d, 2), f = p[0], m = p[1];
          if (m) {
            var v = e ? f : r.layout.getNodePosition(f[r.nodeId]), y = a(f);
            (!r.nodePositionUpdate || !r.nodePositionUpdate(y ? m.children[0] : m, {
              x: v.x,
              y: v.y,
              z: v.z
            }, f) || y) && (m.position.x = v.x, m.position.y = v.y || 0, m.position.z = v.z || 0);
          }
        });
        var o = et(r.linkWidth), l = et(r.linkCurvature), u = et(r.linkCurveRotation), c = et(r.linkThreeObjectExtend);
        r.linkDataMapper.entries().forEach(function(d) {
          var p = Zh(d, 2), f = p[0], m = p[1];
          if (m) {
            var v = e ? f : r.layout.getLinkPosition(r.layout.graph.getLink(f.source, f.target).id), y = v[e ? "source" : "from"], g = v[e ? "target" : "to"];
            if (!(!y || !g || !y.hasOwnProperty("x") || !g.hasOwnProperty("x"))) {
              h(f);
              var _ = c(f);
              if (!(r.linkPositionUpdate && r.linkPositionUpdate(
                _ ? m.children[1] : m,
                // pass child custom object if extending the default
                {
                  start: {
                    x: y.x,
                    y: y.y,
                    z: y.z
                  },
                  end: {
                    x: g.x,
                    y: g.y,
                    z: g.z
                  }
                },
                f
              ) && !_)) {
                var x = 30, b = f.__curve, T = m.children.length ? m.children[0] : m;
                if (T.type === "Line") {
                  if (b) {
                    var S = b.getPoints(x);
                    T.geometry.getAttribute("position").array.length !== S.length * 3 && T.geometry[c0]("position", new pt.BufferAttribute(new Float32Array(S.length * 3), 3)), T.geometry.setFromPoints(S);
                  } else {
                    var w = T.geometry.getAttribute("position");
                    (!w || !w.array || w.array.length !== 6) && T.geometry[c0]("position", w = new pt.BufferAttribute(new Float32Array(2 * 3), 3)), w.array[0] = y.x, w.array[1] = y.y || 0, w.array[2] = y.z || 0, w.array[3] = g.x, w.array[4] = g.y || 0, w.array[5] = g.z || 0, w.needsUpdate = !0;
                  }
                  T.geometry.computeBoundingSphere();
                } else if (T.type === "Mesh")
                  if (b) {
                    T.geometry.type.match(/^Tube(Buffer)?Geometry$/) || (T.position.set(0, 0, 0), T.rotation.set(0, 0, 0), T.scale.set(1, 1, 1));
                    var C = Math.ceil(o(f) * 10) / 10, E = C / 2, A = new pt.TubeGeometry(b, x, E, r.linkResolution, !1);
                    T.geometry.dispose(), T.geometry = A;
                  } else {
                    if (!T.geometry.type.match(/^Cylinder(Buffer)?Geometry$/)) {
                      var N = Math.ceil(o(f) * 10) / 10, L = N / 2, F = new pt.CylinderGeometry(L, L, 1, r.linkResolution, 1, !1);
                      F[Hp](new pt.Matrix4().makeTranslation(0, 1 / 2, 0)), F[Hp](new pt.Matrix4().makeRotationX(Math.PI / 2)), T.geometry.dispose(), T.geometry = F;
                    }
                    var M = new pt.Vector3(y.x, y.y || 0, y.z || 0), P = new pt.Vector3(g.x, g.y || 0, g.z || 0), O = M.distanceTo(P);
                    T.position.x = M.x, T.position.y = M.y, T.position.z = M.z, T.scale.z = O, T.parent.localToWorld(P), T.lookAt(P);
                  }
              }
            }
          }
        });
        function h(d) {
          var p = e ? d : r.layout.getLinkPosition(r.layout.graph.getLink(d.source, d.target).id), f = p[e ? "source" : "from"], m = p[e ? "target" : "to"];
          if (!(!f || !m || !f.hasOwnProperty("x") || !m.hasOwnProperty("x"))) {
            var v = l(d);
            if (!v)
              d.__curve = null;
            else {
              var y = new pt.Vector3(f.x, f.y || 0, f.z || 0), g = new pt.Vector3(m.x, m.y || 0, m.z || 0), _ = y.distanceTo(g), x, b = u(d);
              if (_ > 0) {
                var T = m.x - f.x, S = m.y - f.y || 0, w = new pt.Vector3().subVectors(g, y), C = w.clone().multiplyScalar(v).cross(T !== 0 || S !== 0 ? new pt.Vector3(0, 0, 1) : new pt.Vector3(0, 1, 0)).applyAxisAngle(w.normalize(), b).add(new pt.Vector3().addVectors(y, g).divideScalar(2));
                x = new pt.QuadraticBezierCurve3(y, C, g);
              } else {
                var E = v * 70, A = -b, N = A + Math.PI / 2;
                x = new pt.CubicBezierCurve3(y, new pt.Vector3(E * Math.cos(N), E * Math.sin(N), 0).add(y), new pt.Vector3(E * Math.cos(A), E * Math.sin(A), 0).add(y), g);
              }
              d.__curve = x;
            }
          }
        }
      }
      function n() {
        var a = et(r.linkDirectionalArrowRelPos), o = et(r.linkDirectionalArrowLength), l = et(r.nodeVal);
        r.arrowDataMapper.entries().forEach(function(u) {
          var c = Zh(u, 2), h = c[0], d = c[1];
          if (d) {
            var p = e ? h : r.layout.getLinkPosition(r.layout.graph.getLink(h.source, h.target).id), f = p[e ? "source" : "from"], m = p[e ? "target" : "to"];
            if (!(!f || !m || !f.hasOwnProperty("x") || !m.hasOwnProperty("x"))) {
              var v = Math.cbrt(Math.max(0, l(f) || 1)) * r.nodeRelSize, y = Math.cbrt(Math.max(0, l(m) || 1)) * r.nodeRelSize, g = o(h), _ = a(h), x = h.__curve ? function(E) {
                return h.__curve.getPoint(E);
              } : function(E) {
                var A = function(N, L, F, M) {
                  return L[N] + (F[N] - L[N]) * M || 0;
                };
                return {
                  x: A("x", f, m, E),
                  y: A("y", f, m, E),
                  z: A("z", f, m, E)
                };
              }, b = h.__curve ? h.__curve.getLength() : Math.sqrt(["x", "y", "z"].map(function(E) {
                return Math.pow((m[E] || 0) - (f[E] || 0), 2);
              }).reduce(function(E, A) {
                return E + A;
              }, 0)), T = v + g + (b - v - y - g) * _, S = x(T / b), w = x((T - g) / b);
              ["x", "y", "z"].forEach(function(E) {
                return d.position[E] = w[E];
              });
              var C = xN(pt.Vector3, Hn(["x", "y", "z"].map(function(E) {
                return S[E];
              })));
              d.parent.localToWorld(C), d.lookAt(C);
            }
          }
        });
      }
      function s() {
        var a = et(r.linkDirectionalParticleSpeed);
        r.graphData.links.forEach(function(o) {
          var l = r.particlesDataMapper.getObj(o), u = l && l.children, c = o.__singleHopPhotonsObj && o.__singleHopPhotonsObj.children;
          if (!((!c || !c.length) && (!u || !u.length))) {
            var h = e ? o : r.layout.getLinkPosition(r.layout.graph.getLink(o.source, o.target).id), d = h[e ? "source" : "from"], p = h[e ? "target" : "to"];
            if (!(!d || !p || !d.hasOwnProperty("x") || !p.hasOwnProperty("x"))) {
              var f = a(o), m = o.__curve ? function(y) {
                return o.__curve.getPoint(y);
              } : function(y) {
                var g = function(_, x, b, T) {
                  return x[_] + (b[_] - x[_]) * T || 0;
                };
                return {
                  x: g("x", d, p, y),
                  y: g("y", d, p, y),
                  z: g("z", d, p, y)
                };
              }, v = [].concat(Hn(u || []), Hn(c || []));
              v.forEach(function(y, g) {
                var _ = y.parent.__linkThreeObjType === "singleHopPhotons";
                if (y.hasOwnProperty("__progressRatio") || (y.__progressRatio = _ ? 0 : g / u.length), y.__progressRatio += f, y.__progressRatio >= 1)
                  if (!_)
                    y.__progressRatio = y.__progressRatio % 1;
                  else {
                    y.parent.remove(y), $b(y);
                    return;
                  }
                var x = y.__progressRatio, b = m(x);
                ["x", "y", "z"].forEach(function(T) {
                  return y.position[T] = b[T];
                });
              });
            }
          }
        });
      }
    },
    emitParticle: function(r, e) {
      if (e && r.graphData.links.includes(e)) {
        if (!e.__singleHopPhotonsObj) {
          var i = new pt.Group();
          i.__linkThreeObjType = "singleHopPhotons", e.__singleHopPhotonsObj = i, r.graphScene.add(i);
        }
        var n = et(r.linkDirectionalParticleWidth), s = Math.ceil(n(e) * 10) / 10 / 2, a = r.linkDirectionalParticleResolution, o = new pt.SphereGeometry(s, a, a), l = et(r.linkColor), u = et(r.linkDirectionalParticleColor), c = u(e) || l(e) || "#f0f0f0", h = new pt.Color(mh(c)), d = r.linkOpacity * 3, p = new pt.MeshLambertMaterial({
          color: h,
          transparent: !0,
          opacity: d
        });
        e.__singleHopPhotonsObj.add(new pt.Mesh(o, p));
      }
      return this;
    },
    getGraphBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      };
      if (!r.initialised) return null;
      var i = function n(s) {
        var a = [];
        if (s.geometry) {
          s.geometry.computeBoundingBox();
          var o = new pt.Box3();
          o.copy(s.geometry.boundingBox).applyMatrix4(s.matrixWorld), a.push(o);
        }
        return a.concat.apply(a, Hn((s.children || []).filter(
          function(l) {
            return !l.hasOwnProperty("__graphObjType") || l.__graphObjType === "node" && e(l.__data);
          }
          // exclude filtered out nodes
        ).map(n)));
      }(r.graphScene);
      return i.length ? Object.assign.apply(Object, Hn(["x", "y", "z"].map(function(n) {
        return Mg({}, n, [zb(i, function(s) {
          return s.min[n];
        }), Bb(i, function(s) {
          return s.max[n];
        })]);
      }))) : null;
    }
  },
  stateInit: function() {
    return {
      d3ForceLayout: UR().force("link", DR()).force("charge", FR()).force("center", AR()).force("dagRadial", null).stop(),
      engineRunning: !1
    };
  },
  init: function(r, e) {
    e.graphScene = r, e.nodeDataMapper = new fh(r, {
      objBindAttr: "__threeObj"
    }), e.linkDataMapper = new fh(r, {
      objBindAttr: "__lineObj"
    }), e.arrowDataMapper = new fh(r, {
      objBindAttr: "__arrowObj"
    }), e.particlesDataMapper = new fh(r, {
      objBindAttr: "__photonsObj"
    });
  },
  update: function(r, e) {
    var i = function(q) {
      return q.some(function(G) {
        return e.hasOwnProperty(G);
      });
    };
    if (r.engineRunning = !1, typeof r.onUpdate == "function" && r.onUpdate(), r.nodeAutoColorBy !== null && i(["nodeAutoColorBy", "graphData", "nodeColor"]) && yE(r.graphData.nodes, et(r.nodeAutoColorBy), r.nodeColor), r.linkAutoColorBy !== null && i(["linkAutoColorBy", "graphData", "linkColor"]) && yE(r.graphData.links, et(r.linkAutoColorBy), r.linkColor), r._flushObjects || i(["graphData", "nodeThreeObject", "nodeThreeObjectExtend", "nodeVal", "nodeColor", "nodeVisibility", "nodeRelSize", "nodeResolution", "nodeOpacity"])) {
      var n = et(r.nodeThreeObject), s = et(r.nodeThreeObjectExtend), a = et(r.nodeVal), o = et(r.nodeColor), l = et(r.nodeVisibility), u = {}, c = {};
      (r._flushObjects || i([
        // recreate objects if any of these props have changed
        "nodeThreeObject",
        "nodeThreeObjectExtend"
      ])) && r.nodeDataMapper.clear(), r.nodeDataMapper.onCreateObj(function(q) {
        var G = n(q), Y = s(q);
        G && r.nodeThreeObject === G && (G = G.clone());
        var ae;
        return G && !Y ? ae = G : (ae = new pt.Mesh(), ae.__graphDefaultObj = !0, G && Y && ae.add(G)), ae.__graphObjType = "node", ae;
      }).onUpdateObj(function(q, G) {
        if (q.__graphDefaultObj) {
          var Y = a(G) || 1, ae = Math.cbrt(Y) * r.nodeRelSize, ue = r.nodeResolution;
          (!q.geometry.type.match(/^Sphere(Buffer)?Geometry$/) || q.geometry.parameters.radius !== ae || q.geometry.parameters.widthSegments !== ue) && (u.hasOwnProperty(Y) || (u[Y] = new pt.SphereGeometry(ae, ue, ue)), q.geometry.dispose(), q.geometry = u[Y]);
          var ge = o(G), we = new pt.Color(mh(ge || "#ffffaa")), Ne = r.nodeOpacity * u0(ge);
          (q.material.type !== "MeshLambertMaterial" || !q.material.color.equals(we) || q.material.opacity !== Ne) && (c.hasOwnProperty(ge) || (c[ge] = new pt.MeshLambertMaterial({
            color: we,
            transparent: !0,
            opacity: Ne
          })), q.material.dispose(), q.material = c[ge]);
        }
      }).digest(r.graphData.nodes.filter(l));
    }
    if (r._flushObjects || i(["graphData", "linkThreeObject", "linkThreeObjectExtend", "linkMaterial", "linkColor", "linkWidth", "linkVisibility", "linkResolution", "linkOpacity", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution"])) {
      var h = et(r.linkThreeObject), d = et(r.linkThreeObjectExtend), p = et(r.linkMaterial), f = et(r.linkVisibility), m = et(r.linkColor), v = et(r.linkWidth), y = {}, g = {}, _ = {}, x = r.graphData.links.filter(f);
      if ((r._flushObjects || i([
        // recreate objects if any of these props have changed
        "linkThreeObject",
        "linkThreeObjectExtend",
        "linkWidth"
      ])) && r.linkDataMapper.clear(), r.linkDataMapper.onRemoveObj(function(q) {
        var G = q.__data && q.__data.__singleHopPhotonsObj;
        G && (G.parent.remove(G), $b(G), delete q.__data.__singleHopPhotonsObj);
      }).onCreateObj(function(q) {
        var G = h(q), Y = d(q);
        G && r.linkThreeObject === G && (G = G.clone());
        var ae;
        if (!G || Y) {
          var ue = !!v(q);
          if (ue)
            ae = new pt.Mesh();
          else {
            var ge = new pt.BufferGeometry();
            ge[c0]("position", new pt.BufferAttribute(new Float32Array(2 * 3), 3)), ae = new pt.Line(ge);
          }
        }
        var we;
        return G ? Y ? (we = new pt.Group(), we.__graphDefaultObj = !0, we.add(ae), we.add(G)) : we = G : (we = ae, we.__graphDefaultObj = !0), we.renderOrder = 10, we.__graphObjType = "link", we;
      }).onUpdateObj(function(q, G) {
        if (q.__graphDefaultObj) {
          var Y = q.children.length ? q.children[0] : q, ae = Math.ceil(v(G) * 10) / 10, ue = !!ae;
          if (ue) {
            var ge = ae / 2, we = r.linkResolution;
            if (!Y.geometry.type.match(/^Cylinder(Buffer)?Geometry$/) || Y.geometry.parameters.radiusTop !== ge || Y.geometry.parameters.radialSegments !== we) {
              if (!y.hasOwnProperty(ae)) {
                var Ne = new pt.CylinderGeometry(ge, ge, 1, we, 1, !1);
                Ne[Hp](new pt.Matrix4().makeTranslation(0, 1 / 2, 0)), Ne[Hp](new pt.Matrix4().makeRotationX(Math.PI / 2)), y[ae] = Ne;
              }
              Y.geometry.dispose(), Y.geometry = y[ae];
            }
          }
          var lt = p(G);
          if (lt)
            Y.material = lt;
          else {
            var be = m(G), vt = new pt.Color(mh(be || "#f0f0f0")), Z = r.linkOpacity * u0(be), Vt = ue ? "MeshLambertMaterial" : "LineBasicMaterial";
            if (Y.material.type !== Vt || !Y.material.color.equals(vt) || Y.material.opacity !== Z) {
              var ct = ue ? g : _;
              ct.hasOwnProperty(be) || (ct[be] = new pt[Vt]({
                color: vt,
                transparent: Z < 1,
                opacity: Z,
                depthWrite: Z >= 1
                // Prevent transparency issues
              })), Y.material.dispose(), Y.material = ct[be];
            }
          }
        }
      }).digest(x), r.linkDirectionalArrowLength || e.hasOwnProperty("linkDirectionalArrowLength")) {
        var b = et(r.linkDirectionalArrowLength), T = et(r.linkDirectionalArrowColor);
        r.arrowDataMapper.onCreateObj(function() {
          var q = new pt.Mesh(void 0, new pt.MeshLambertMaterial({
            transparent: !0
          }));
          return q.__linkThreeObjType = "arrow", q;
        }).onUpdateObj(function(q, G) {
          var Y = b(G), ae = r.linkDirectionalArrowResolution;
          if (!q.geometry.type.match(/^Cone(Buffer)?Geometry$/) || q.geometry.parameters.height !== Y || q.geometry.parameters.radialSegments !== ae) {
            var ue = new pt.ConeGeometry(Y * 0.25, Y, ae);
            ue.translate(0, Y / 2, 0), ue.rotateX(Math.PI / 2), q.geometry.dispose(), q.geometry = ue;
          }
          var ge = T(G) || m(G) || "#f0f0f0";
          q.material.color = new pt.Color(mh(ge)), q.material.opacity = r.linkOpacity * 3 * u0(ge);
        }).digest(x.filter(b));
      }
      if (r.linkDirectionalParticles || e.hasOwnProperty("linkDirectionalParticles")) {
        var S = et(r.linkDirectionalParticles), w = et(r.linkDirectionalParticleWidth), C = et(r.linkDirectionalParticleColor), E = {}, A = {};
        r.particlesDataMapper.onCreateObj(function() {
          var q = new pt.Group();
          return q.__linkThreeObjType = "photons", q.__photonDataMapper = new fh(q), q;
        }).onUpdateObj(function(q, G) {
          var Y = Math.round(Math.abs(S(G))), ae = !!q.children.length && q.children[0], ue = Math.ceil(w(G) * 10) / 10 / 2, ge = r.linkDirectionalParticleResolution, we;
          ae && ae.geometry.parameters.radius === ue && ae.geometry.parameters.widthSegments === ge ? we = ae.geometry : (A.hasOwnProperty(ue) || (A[ue] = new pt.SphereGeometry(ue, ge, ge)), we = A[ue], ae && ae.geometry.dispose());
          var Ne = C(G) || m(G) || "#f0f0f0", lt = new pt.Color(mh(Ne)), be = r.linkOpacity * 3, vt;
          ae && ae.material.color.equals(lt) && ae.material.opacity === be ? vt = ae.material : (E.hasOwnProperty(Ne) || (E[Ne] = new pt.MeshLambertMaterial({
            color: lt,
            transparent: !0,
            opacity: be
          })), vt = E[Ne], ae && ae.material.dispose()), q.__photonDataMapper.id(function(Z) {
            return Z.idx;
          }).onCreateObj(function() {
            return new pt.Mesh(we, vt);
          }).onUpdateObj(function(Z) {
            Z.geometry = we, Z.material = vt;
          }).digest(Hn(new Array(Y)).map(function(Z, Vt) {
            return {
              idx: Vt
            };
          }));
        }).digest(x.filter(S));
      }
    }
    if (r._flushObjects = !1, i(["graphData", "nodeId", "linkSource", "linkTarget", "numDimensions", "forceEngine", "dagMode", "dagNodeFilter", "dagLevelDistance"])) {
      r.engineRunning = !1, r.graphData.links.forEach(function(q) {
        q.source = q[r.linkSource], q.target = q[r.linkTarget];
      });
      var N = r.forceEngine !== "ngraph", L;
      if (N) {
        (L = r.d3ForceLayout).stop().alpha(1).numDimensions(r.numDimensions).nodes(r.graphData.nodes);
        var F = r.d3ForceLayout.force("link");
        F && F.id(function(q) {
          return q[r.nodeId];
        }).links(r.graphData.links);
        var M = r.dagMode && u9(r.graphData, function(q) {
          return q[r.nodeId];
        }, {
          nodeFilter: r.dagNodeFilter,
          onLoopError: r.onDagError || void 0
        }), P = Math.max.apply(Math, Hn(Object.values(M || []))), O = r.dagLevelDistance || r.graphData.nodes.length / (P || 1) * c9 * (["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? 0.7 : 1);
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(e.dagMode)) {
          var V = ["lr", "rl"].includes(e.dagMode) ? "fx" : ["td", "bu"].includes(e.dagMode) ? "fy" : "fz";
          r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(q) {
            return delete q[V];
          });
        }
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(r.dagMode)) {
          var B = ["rl", "td", "zout"].includes(r.dagMode), H = function(q) {
            return (M[q[r.nodeId]] - P / 2) * O * (B ? -1 : 1);
          }, U = ["lr", "rl"].includes(r.dagMode) ? "fx" : ["td", "bu"].includes(r.dagMode) ? "fy" : "fz";
          r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(q) {
            return q[U] = H(q);
          });
        }
        r.d3ForceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? BR(function(q) {
          var G = M[q[r.nodeId]] || -1;
          return (r.dagMode === "radialin" ? P - G : G) * O;
        }).strength(function(q) {
          return r.dagNodeFilter(q) ? 1 : 0;
        }) : null);
      } else {
        var j = vE.graph();
        r.graphData.nodes.forEach(function(q) {
          j.addNode(q[r.nodeId]);
        }), r.graphData.links.forEach(function(q) {
          j.addLink(q.source, q.target);
        }), L = vE.forcelayout(j, n9({
          dimensions: r.numDimensions
        }, r.ngraphPhysics)), L.graph = j;
      }
      for (var Q = 0; Q < r.warmupTicks && !(N && r.d3AlphaMin > 0 && r.d3ForceLayout.alpha() < r.d3AlphaMin); Q++)
        L[N ? "tick" : "step"]();
      r.layout = L, this.resetCountdown();
    }
    r.engineRunning = !0, r.onFinishUpdate();
  }
});
function d9(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = /* @__PURE__ */ function(s) {
    function a() {
      var o;
      bN(this, a);
      for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
        u[c] = arguments[c];
      return o = vN(this, a, [].concat(u)), o.__kapsuleInstance = xN(r, [].concat(Hn(i ? [o] : []), u)), o;
    }
    return TN(a, s), _N(a);
  }(e);
  return Object.keys(r()).forEach(function(s) {
    return n.prototype[s] = function() {
      var a, o = (a = this.__kapsuleInstance)[s].apply(a, arguments);
      return o === this.__kapsuleInstance ? this : o;
    };
  }), n;
}
var p9 = window.THREE ? window.THREE : {
  Group: al
}, ku = d9(h9, p9.Group, !0);
if (typeof AFRAME > "u")
  throw new Error("Component attempted to register before AFRAME was available.");
var h0 = function(r) {
  return typeof r == "string" ? JSON.parse(r) : r;
}, Bn = function(r) {
  if (typeof r == "function") return r;
  var e = eval;
  try {
    var i = e("(" + r + ")");
    return i;
  } catch {
  }
  return null;
}, Ti = function(r) {
  return isNaN(parseFloat(r)) ? Bn(r) ? Bn(r) : r : parseFloat(r);
};
AFRAME.components.hasOwnProperty("forcegraph") || AFRAME.registerComponent("forcegraph", {
  schema: {
    jsonUrl: {
      type: "string",
      default: ""
    },
    nodes: {
      parse: h0,
      default: []
    },
    links: {
      parse: h0,
      default: []
    },
    numDimensions: {
      type: "number",
      default: 3
    },
    dagMode: {
      type: "string",
      default: ""
    },
    dagLevelDistance: {
      type: "number",
      default: 0
    },
    dagNodeFilter: {
      parse: Bn,
      default: function() {
        return !0;
      }
    },
    onDagError: {
      parse: Bn,
      default: void 0
    },
    nodeRelSize: {
      type: "number",
      default: 4
    },
    // volume per val unit
    nodeId: {
      type: "string",
      default: "id"
    },
    nodeVal: {
      parse: Ti,
      default: "val"
    },
    nodeResolution: {
      type: "number",
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeVisibility: {
      parse: Ti,
      default: !0
    },
    nodeColor: {
      parse: Ti,
      default: "color"
    },
    nodeAutoColorBy: {
      parse: Ti,
      default: ""
    },
    // color nodes with the same field equally
    nodeOpacity: {
      type: "number",
      default: 0.75
    },
    nodeThreeObject: {
      parse: Ti,
      default: null
    },
    nodeThreeObjectExtend: {
      parse: Ti,
      default: !1
    },
    linkSource: {
      type: "string",
      default: "source"
    },
    linkTarget: {
      type: "string",
      default: "target"
    },
    linkVisibility: {
      parse: Ti,
      default: !0
    },
    linkColor: {
      parse: Ti,
      default: "color"
    },
    linkAutoColorBy: {
      parse: Ti,
      default: ""
    },
    // color links with the same field equally
    linkOpacity: {
      type: "number",
      default: 0.2
    },
    linkWidth: {
      parse: Ti,
      default: 0
    },
    linkResolution: {
      type: "number",
      default: 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      parse: Ti,
      default: 0
    },
    linkCurveRotation: {
      parse: Ti,
      default: 0
    },
    linkMaterial: {
      parse: Ti,
      default: null
    },
    linkThreeObject: {
      parse: Ti,
      default: null
    },
    linkThreeObjectExtend: {
      parse: Ti,
      default: !1
    },
    linkPositionUpdate: {
      parse: Bn,
      default: null
    },
    linkDirectionalArrowLength: {
      parse: Ti,
      default: 0
    },
    linkDirectionalArrowColor: {
      parse: Ti,
      default: null
    },
    linkDirectionalArrowRelPos: {
      parse: Ti,
      default: 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      type: "number",
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      parse: Ti,
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      parse: Ti,
      default: 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      parse: Ti,
      default: 0.5
    },
    linkDirectionalParticleColor: {
      parse: Ti,
      default: null
    },
    linkDirectionalParticleResolution: {
      type: "number",
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    onNodeHover: {
      parse: Bn,
      default: function() {
      }
    },
    onLinkHover: {
      parse: Bn,
      default: function() {
      }
    },
    onNodeClick: {
      parse: Bn,
      default: function() {
      }
    },
    onLinkClick: {
      parse: Bn,
      default: function() {
      }
    },
    forceEngine: {
      type: "string",
      default: "d3"
    },
    // 'd3' or 'ngraph'
    d3AlphaMin: {
      type: "number",
      default: 0
    },
    d3AlphaDecay: {
      type: "number",
      default: 0.0228
    },
    d3VelocityDecay: {
      type: "number",
      default: 0.4
    },
    ngraphPhysics: {
      parse: h0,
      default: null
    },
    warmupTicks: {
      type: "int",
      default: 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      type: "int",
      default: 1e18
    },
    // Simulate infinity (int parser doesn't accept Infinity object)
    cooldownTime: {
      type: "int",
      default: 15e3
    },
    // ms
    onEngineTick: {
      parse: Bn,
      default: function() {
      }
    },
    onEngineStop: {
      parse: Bn,
      default: function() {
      }
    }
  },
  // Bind component methods
  getGraphBbox: function(r) {
    return this.forceGraph || (this.forceGraph = new ku()), this.forceGraph.getGraphBbox(r);
  },
  emitParticle: function() {
    this.forceGraph || (this.forceGraph = new ku());
    var r = this.forceGraph, e = r.emitParticle.apply(r, arguments);
    return e === r ? this : e;
  },
  d3Force: function() {
    this.forceGraph || (this.forceGraph = new ku());
    var r = this.forceGraph, e = r.d3Force.apply(r, arguments);
    return e === r ? this : e;
  },
  d3ReheatSimulation: function() {
    return this.forceGraph && this.forceGraph.d3ReheatSimulation(), this;
  },
  refresh: function() {
    return this.forceGraph && this.forceGraph.refresh(), this;
  },
  init: function() {
    var r = this, e = this.state = {};
    e.infoEl = document.createElement("a-text"), e.infoEl.setAttribute("position", "0 -0.1 -1"), e.infoEl.setAttribute("width", 1), e.infoEl.setAttribute("align", "center"), e.infoEl.setAttribute("color", "lavender");
    var i = document.querySelector("a-entity[camera], a-camera");
    i.appendChild(e.infoEl), e.cameraObj = i.object3D.children.filter(function(n) {
      return n.type === "PerspectiveCamera";
    })[0], this.el.sceneEl.addEventListener("camera-set-active", function(n) {
      e.cameraObj = n.detail.cameraEl.components.camera.camera;
    }), this.forceGraph || (this.forceGraph = new ku()), this.forceGraph.onFinishUpdate(function() {
      return r.el.setObject3D("forcegraphGroup", r.forceGraph);
    }).onLoading(function() {
      return e.infoEl.setAttribute("value", "Loading...");
    }).onFinishLoading(function() {
      return e.infoEl.setAttribute("value", "");
    }), this.el.addEventListener("raycaster-intersected", function(n) {
      return e.hoverDetail = n.detail;
    }), this.el.addEventListener("raycaster-intersected-cleared", function(n) {
      return e.hoverDetail = n.detail;
    }), this.el.addEventListener("click", function() {
      return e.hoverObj && r.data["on" + (e.hoverObj.__graphObjType === "node" ? "Node" : "Link") + "Click"](e.hoverObj.__data);
    });
  },
  remove: function() {
    this.state.infoEl.remove(), this.el.removeObject3D("forcegraphGroup");
  },
  update: function(r) {
    var e = this, i = this.data, n = AFRAME.utils.diff(i, r), s = ["jsonUrl", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeVisibility", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "forceEngine", "d3AlphaMin", "d3AphaDecay", "d3VelocityDecay", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"];
    s.filter(function(a) {
      return a in n;
    }).forEach(function(a) {
      e.forceGraph[a](i[a] !== "" ? i[a] : null);
    }), ("nodes" in n || "links" in n) && e.forceGraph.graphData({
      nodes: i.nodes,
      links: i.links
    });
  },
  tick: function(r, e) {
    for (var i = this.state, n = this.data, s = i.hoverDetail ? i.hoverDetail.getIntersection ? i.hoverDetail.getIntersection(this.el) : i.hoverDetail.intersection || void 0 : void 0, a = s ? s.object : void 0; a && !a.hasOwnProperty("__graphObjType"); ) a = a.parent;
    if (a !== i.hoverObj) {
      var o = i.hoverObj ? i.hoverObj.__graphObjType : null, l = i.hoverObj ? i.hoverObj.__data : null, u = a ? a.__graphObjType : null, c = a ? a.__data : null;
      o && o !== u && n["on" + (o === "node" ? "Node" : "Link") + "Hover"](null, l), u && n["on" + (u === "node" ? "Node" : "Link") + "Hover"](c, o === u ? l : null), i.hoverObj = a;
    }
    this.forceGraph.tickFrame();
  }
});
function Kb(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function f9(r) {
  if (Array.isArray(r)) return r;
}
function m9(r) {
  if (Array.isArray(r)) return Kb(r);
}
function Jf(r, e, i) {
  return (e = _9(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function g9(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function y9(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function v9() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function b9() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function bE(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function xE(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? bE(Object(i), !0).forEach(function(n) {
      Jf(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : bE(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function Wp(r, e) {
  return f9(r) || y9(r, e) || AN(r, e) || v9();
}
function qp(r) {
  return m9(r) || g9(r) || AN(r) || b9();
}
function x9(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function _9(r) {
  var e = x9(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function AN(r, e) {
  if (r) {
    if (typeof r == "string") return Kb(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Kb(r, e) : void 0;
  }
}
var T9 = Il({
  props: {
    width: {},
    height: {},
    yOffset: {
      default: 1.5
    },
    // marker size units
    glScale: {
      default: 200
    },
    // gl units per marker width
    jsonUrl: {},
    graphData: {
      default: {
        nodes: [],
        links: []
      }
    },
    numDimensions: {
      default: 3
    },
    dagMode: {},
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function() {
        return !0;
      }
    },
    onDagError: {
      default: void 0
    },
    nodeRelSize: {
      default: 4
    },
    // volume per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val"
    },
    nodeResolution: {
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeVisibility: {
      default: !0
    },
    nodeColor: {
      default: "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      default: 0.75
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      default: !1
    },
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0
    },
    linkColor: {
      default: "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      default: 0.2
    },
    linkWidth: {
      default: 0
    },
    linkResolution: {
      default: 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      default: 0
    },
    linkCurveRotation: {
      default: 0
    },
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      default: !1
    },
    linkPositionUpdate: {},
    linkDirectionalArrowLength: {
      default: 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      default: 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    onNodeHover: {},
    onNodeClick: {},
    onLinkHover: {},
    onLinkClick: {},
    forceEngine: {
      default: "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      default: 0
    },
    d3AlphaDecay: {
      default: 0.0228
    },
    d3VelocityDecay: {
      default: 0.4
    },
    ngraphPhysics: {},
    warmupTicks: {
      default: 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {},
    cooldownTime: {
      default: 15e3
    },
    // ms
    onEngineTick: {},
    onEngineStop: {}
  },
  methods: xE(xE({}, Object.assign.apply(Object, [{}].concat(qp(["getGraphBbox", "emitParticle", "d3Force", "d3ReheatSimulation", "refresh"].map(function(r) {
    return Jf({}, r, function(e) {
      for (var i = e.forcegraph.components.forcegraph, n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
        s[a - 1] = arguments[a];
      var o = i[r].apply(i, s);
      return o === i ? this : o;
    });
  }))))), {}, {
    _destructor: function() {
      this.graphData({
        nodes: [],
        links: []
      });
    }
  }),
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.markerAttrs, s = n === void 0 ? {
      preset: "hiro"
    } : n;
    r.innerHTML = "", e.container = document.createElement("div"), r.appendChild(e.container);
    var a = document.createElement("a-scene");
    a.setAttribute("embedded", ""), a.setAttribute("vr-mode-ui", "enabled: false"), a.setAttribute("arjs", "debugUIEnabled: false;");
    var o = document.createElement("a-marker");
    Object.entries(s).forEach(function(c) {
      var h = Wp(c, 2), d = h[0], p = h[1];
      return o.setAttribute(d, p);
    }), a.appendChild(o);
    var l;
    a.appendChild(l = document.createElement("a-entity")), l.setAttribute(
      "cursor"
      /*, 'rayOrigin: mouse'*/
    ), l.setAttribute("raycaster", "objects: [forcegraph]"), e.forcegraph = document.createElement("a-entity"), e.forcegraph.setAttribute("forcegraph", null), o.appendChild(e.forcegraph);
    var u = document.createElement("a-entity");
    u.setAttribute("camera", ""), a.appendChild(u), e.container.appendChild(a);
  },
  update: function(r, e) {
    e.hasOwnProperty("width") && r.width && (r.container.style.width = "".concat(r.width, "px")), e.hasOwnProperty("height") && r.height && (r.container.style.height = "".concat(r.height, "px")), e.hasOwnProperty("glScale") && r.forcegraph.setAttribute("scale", qp(new Array(3)).map(function() {
      return 1 / r.glScale;
    }).join(" ")), e.hasOwnProperty("yOffset") && r.forcegraph.setAttribute("position", "0 ".concat(r.yOffset, " 0"));
    var i = ["jsonUrl", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeVisibility", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "onNodeHover", "onNodeClick", "onLinkHover", "onLinkClick", "forceEngine", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"], n = Object.assign.apply(Object, [{}].concat(qp(Object.entries(r).filter(function(s) {
      var a = Wp(s, 2), o = a[0], l = a[1];
      return e.hasOwnProperty(o) && i.indexOf(o) !== -1 && l !== void 0 && l !== null;
    }).map(function(s) {
      var a = Wp(s, 2), o = a[0], l = a[1];
      return Jf({}, o, l);
    })), qp(Object.entries(r.graphData).map(function(s) {
      var a = Wp(s, 2), o = a[0], l = a[1];
      return Jf({}, o, l);
    }))));
    r.forcegraph.setAttribute("forcegraph", n);
  }
});
const Yu = new $s(), ta = new Le(), CN = new X(), d0 = new Le(), em = new Le(), Cm = new X(), Qb = new X(), RN = new ui(), NN = new X(), PN = new X();
let Lr = null, ls = null;
const ia = [], ho = {
  NONE: -1,
  PAN: 0,
  ROTATE: 1
};
class S9 extends Sg {
  constructor(e, i, n = null) {
    super(i, n), this.objects = e, this.recursive = !0, this.transformGroup = !1, this.rotateSpeed = 1, this.raycaster = new MR(), this.mouseButtons = { LEFT: tr.PAN, MIDDLE: tr.PAN, RIGHT: tr.ROTATE }, this.touches = { ONE: sa.PAN }, this._onPointerMove = w9.bind(this), this._onPointerDown = E9.bind(this), this._onPointerCancel = M9.bind(this), this._onContextMenu = A9.bind(this), n !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointerup", this._onPointerCancel), this.domElement.addEventListener("pointerleave", this._onPointerCancel), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointerup", this._onPointerCancel), this.domElement.removeEventListener("pointerleave", this._onPointerCancel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "auto", this.domElement.style.cursor = "";
  }
  dispose() {
    this.disconnect();
  }
  _updatePointer(e) {
    const i = this.domElement.getBoundingClientRect();
    ta.x = (e.clientX - i.left) / i.width * 2 - 1, ta.y = -(e.clientY - i.top) / i.height * 2 + 1;
  }
  _updateState(e) {
    let i;
    if (e.pointerType === "touch")
      i = this.touches.ONE;
    else
      switch (e.button) {
        case 0:
          i = this.mouseButtons.LEFT;
          break;
        case 1:
          i = this.mouseButtons.MIDDLE;
          break;
        case 2:
          i = this.mouseButtons.RIGHT;
          break;
        default:
          i = null;
      }
    switch (i) {
      case tr.PAN:
      case sa.PAN:
        this.state = ho.PAN;
        break;
      case tr.ROTATE:
      case sa.ROTATE:
        this.state = ho.ROTATE;
        break;
      default:
        this.state = ho.NONE;
    }
  }
  getRaycaster() {
    return console.warn("THREE.DragControls: getRaycaster() has been deprecated. Use controls.raycaster instead."), this.raycaster;
  }
  setObjects(e) {
    console.warn("THREE.DragControls: setObjects() has been deprecated. Use controls.objects instead."), this.objects = e;
  }
  getObjects() {
    return console.warn("THREE.DragControls: getObjects() has been deprecated. Use controls.objects instead."), this.objects;
  }
  activate() {
    console.warn("THREE.DragControls: activate() has been renamed to connect()."), this.connect();
  }
  deactivate() {
    console.warn("THREE.DragControls: deactivate() has been renamed to disconnect()."), this.disconnect();
  }
  set mode(e) {
    console.warn("THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.");
  }
  get mode() {
    console.warn("THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.");
  }
}
function w9(r) {
  const e = this.object, i = this.domElement, n = this.raycaster;
  if (this.enabled !== !1) {
    if (this._updatePointer(r), n.setFromCamera(ta, e), Lr)
      this.state === ho.PAN ? n.ray.intersectPlane(Yu, Cm) && Lr.position.copy(Cm.sub(CN).applyMatrix4(RN)) : this.state === ho.ROTATE && (d0.subVectors(ta, em).multiplyScalar(this.rotateSpeed), Lr.rotateOnWorldAxis(NN, d0.x), Lr.rotateOnWorldAxis(PN.normalize(), -d0.y)), this.dispatchEvent({ type: "drag", object: Lr }), em.copy(ta);
    else if (r.pointerType === "mouse" || r.pointerType === "pen")
      if (ia.length = 0, n.setFromCamera(ta, e), n.intersectObjects(this.objects, this.recursive, ia), ia.length > 0) {
        const s = ia[0].object;
        Yu.setFromNormalAndCoplanarPoint(e.getWorldDirection(Yu.normal), Qb.setFromMatrixPosition(s.matrixWorld)), ls !== s && ls !== null && (this.dispatchEvent({ type: "hoveroff", object: ls }), i.style.cursor = "auto", ls = null), ls !== s && (this.dispatchEvent({ type: "hoveron", object: s }), i.style.cursor = "pointer", ls = s);
      } else
        ls !== null && (this.dispatchEvent({ type: "hoveroff", object: ls }), i.style.cursor = "auto", ls = null);
    em.copy(ta);
  }
}
function E9(r) {
  const e = this.object, i = this.domElement, n = this.raycaster;
  this.enabled !== !1 && (this._updatePointer(r), this._updateState(r), ia.length = 0, n.setFromCamera(ta, e), n.intersectObjects(this.objects, this.recursive, ia), ia.length > 0 && (this.transformGroup === !0 ? Lr = ON(ia[0].object) : Lr = ia[0].object, Yu.setFromNormalAndCoplanarPoint(e.getWorldDirection(Yu.normal), Qb.setFromMatrixPosition(Lr.matrixWorld)), n.ray.intersectPlane(Yu, Cm) && (this.state === ho.PAN ? (RN.copy(Lr.parent.matrixWorld).invert(), CN.copy(Cm).sub(Qb.setFromMatrixPosition(Lr.matrixWorld))) : this.state === ho.ROTATE && (NN.set(0, 1, 0).applyQuaternion(e.quaternion).normalize(), PN.set(1, 0, 0).applyQuaternion(e.quaternion).normalize())), i.style.cursor = "move", this.dispatchEvent({ type: "dragstart", object: Lr })), em.copy(ta));
}
function M9() {
  this.enabled !== !1 && (Lr && (this.dispatchEvent({ type: "dragend", object: Lr }), Lr = null), this.domElement.style.cursor = ls ? "pointer" : "auto", this.state = ho.NONE);
}
function A9(r) {
  this.enabled !== !1 && r.preventDefault();
}
function ON(r, e = null) {
  return r.isGroup && (e = r), r.parent === null ? e : ON(r.parent, e);
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Ag = "170", C9 = 0, R9 = 1, N9 = 2, P9 = 1, Xp = 3, xc = 0, es = 1, $u = 2, _c = 0, po = 1, Rm = 2, Nm = 3, Pm = 4, IN = 5, io = 100, DN = 101, kN = 102, O9 = 103, I9 = 104, LN = 200, UN = 201, FN = 202, BN = 203, Om = 204, Im = 205, zN = 206, jN = 207, VN = 208, GN = 209, HN = 210, WN = 0, qN = 1, XN = 2, Dm = 3, YN = 4, $N = 5, KN = 6, QN = 7, Cg = 0, D9 = 1, k9 = 2, Ku = 0, L9 = 1, U9 = 2, F9 = 3, B9 = 4, z9 = 6, j9 = 7, rT = 300, wl = 301, Tc = 302, Xd = 303, Yd = 304, Zb = 306, km = 1e3, Lu = 1001, Lm = 1002, mr = 1003, Jb = 1004, Qu = 1005, hn = 1006, ex = 1007, ma = 1008, fo = 1009, Jh = 1010, ed = 1011, Uu = 1012, Tr = 1013, Ji = 1014, cn = 1015, ga = 1016, V9 = 1017, G9 = 1018, $d = 1020, ZN = 35902, H9 = 1021, nT = 1022, Fc = 1023, W9 = 1024, q9 = 1025, vl = 1026, Sc = 1027, sT = 1028, aT = 1029, yd = 1030, oT = 1031, X9 = 1032, lT = 1033, p0 = 33776, tm = 33777, im = 33778, rm = 33779, _E = 35840, TE = 35841, SE = 35842, wE = 35843, EE = 36196, tx = 37492, ix = 37496, rx = 37808, nx = 37809, sx = 37810, ax = 37811, ox = 37812, lx = 37813, ux = 37814, cx = 37815, hx = 37816, dx = 37817, px = 37818, fx = 37819, mx = 37820, gx = 37821, f0 = 36492, Y9 = 36283, ME = 36284, AE = 36285, CE = 36286, xo = 0, $9 = 1, El = "", ht = "srgb", mo = "srgb-linear", JN = "linear", vd = "srgb", K9 = 0, Wo = 7680, Q9 = 7681, Z9 = 7682, J9 = 7683, e7 = 34055, t7 = 34056, i7 = 5386, r7 = 512, n7 = 513, s7 = 514, a7 = 515, o7 = 516, l7 = 517, u7 = 518, yx = 519, eP = 512, uT = 513, tP = 514, iP = 515, rP = 516, nP = 517, sP = 518, aP = 519, Um = 35044, Fu = 35048, Zn = 2e3, Ml = 2001;
class Bc {
  addEventListener(e, i) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(i) === -1 && n[e].push(i);
  }
  hasEventListener(e, i) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(i) !== -1;
  }
  removeEventListener(e, i) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const s = n.indexOf(i);
      s !== -1 && n.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const n = i.slice(0);
      for (let s = 0, a = n.length; s < a; s++)
        n[s].call(this, e);
      e.target = null;
    }
  }
}
const cr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let RE = 1234567;
const td = Math.PI / 180, bd = 180 / Math.PI;
function ya() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (cr[r & 255] + cr[r >> 8 & 255] + cr[r >> 16 & 255] + cr[r >> 24 & 255] + "-" + cr[e & 255] + cr[e >> 8 & 255] + "-" + cr[e >> 16 & 15 | 64] + cr[e >> 24 & 255] + "-" + cr[i & 63 | 128] + cr[i >> 8 & 255] + "-" + cr[i >> 16 & 255] + cr[i >> 24 & 255] + cr[n & 255] + cr[n >> 8 & 255] + cr[n >> 16 & 255] + cr[n >> 24 & 255]).toLowerCase();
}
function er(r, e, i) {
  return Math.max(e, Math.min(i, r));
}
function cT(r, e) {
  return (r % e + e) % e;
}
function c7(r, e, i, n, s) {
  return n + (r - e) * (s - n) / (i - e);
}
function h7(r, e, i) {
  return r !== e ? (i - r) / (e - r) : 0;
}
function id(r, e, i) {
  return (1 - i) * r + i * e;
}
function d7(r, e, i, n) {
  return id(r, e, 1 - Math.exp(-i * n));
}
function p7(r, e = 1) {
  return e - Math.abs(cT(r, e * 2) - e);
}
function f7(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * (3 - 2 * r));
}
function m7(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * r * (r * (r * 6 - 15) + 10));
}
function g7(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function y7(r, e) {
  return r + Math.random() * (e - r);
}
function v7(r) {
  return r * (0.5 - Math.random());
}
function b7(r) {
  r !== void 0 && (RE = r);
  let e = RE += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function x7(r) {
  return r * td;
}
function _7(r) {
  return r * bd;
}
function T7(r) {
  return (r & r - 1) === 0 && r !== 0;
}
function S7(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function w7(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function E7(r, e, i, n, s) {
  const a = Math.cos, o = Math.sin, l = a(i / 2), u = o(i / 2), c = a((e + n) / 2), h = o((e + n) / 2), d = a((e - n) / 2), p = o((e - n) / 2), f = a((n - e) / 2), m = o((n - e) / 2);
  switch (s) {
    case "XYX":
      r.set(l * h, u * d, u * p, l * c);
      break;
    case "YZY":
      r.set(u * p, l * h, u * d, l * c);
      break;
    case "ZXZ":
      r.set(u * d, u * p, l * h, l * c);
      break;
    case "XZX":
      r.set(l * h, u * m, u * f, l * c);
      break;
    case "YXY":
      r.set(u * f, l * h, u * m, l * c);
      break;
    case "ZYZ":
      r.set(u * m, u * f, l * h, l * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function Er(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Et(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const M7 = {
  DEG2RAD: td,
  RAD2DEG: bd,
  generateUUID: ya,
  clamp: er,
  euclideanModulo: cT,
  mapLinear: c7,
  inverseLerp: h7,
  lerp: id,
  damp: d7,
  pingpong: p7,
  smoothstep: f7,
  smootherstep: m7,
  randInt: g7,
  randFloat: y7,
  randFloatSpread: v7,
  seededRandom: b7,
  degToRad: x7,
  radToDeg: _7,
  isPowerOfTwo: T7,
  ceilPowerOfTwo: S7,
  floorPowerOfTwo: w7,
  setQuaternionFromProperEuler: E7,
  normalize: Et,
  denormalize: Er
};
class jt {
  constructor(e = 0, i = 0) {
    jt.prototype.isVector2 = !0, this.x = e, this.y = i;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, i) {
    return this.x = e, this.y = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * i + s[3] * n + s[6], this.y = s[1] * i + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(er(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y;
    return i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this;
  }
  rotateAround(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = this.x - e.x, o = this.y - e.y;
    return this.x = a * n - o * s + e.x, this.y = a * s + o * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Yr {
  constructor(e, i, n, s, a, o, l, u, c) {
    Yr.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c);
  }
  set(e, i, n, s, a, o, l, u, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = l, h[3] = i, h[4] = a, h[5] = u, h[6] = n, h[7] = o, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrix3Column(this, 0), i.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[4],
      i[8],
      i[1],
      i[5],
      i[9],
      i[2],
      i[6],
      i[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[3], u = n[6], c = n[1], h = n[4], d = n[7], p = n[2], f = n[5], m = n[8], v = s[0], y = s[3], g = s[6], _ = s[1], x = s[4], b = s[7], T = s[2], S = s[5], w = s[8];
    return a[0] = o * v + l * _ + u * T, a[3] = o * y + l * x + u * S, a[6] = o * g + l * b + u * w, a[1] = c * v + h * _ + d * T, a[4] = c * y + h * x + d * S, a[7] = c * g + h * b + d * w, a[2] = p * v + f * _ + m * T, a[5] = p * y + f * x + m * S, a[8] = p * g + f * b + m * w, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= e, i[4] *= e, i[7] *= e, i[2] *= e, i[5] *= e, i[8] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8];
    return i * o * h - i * l * c - n * a * h + n * l * u + s * a * c - s * o * u;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = h * o - l * c, p = l * u - h * a, f = c * a - o * u, m = i * d + n * p + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / m;
    return e[0] = d * v, e[1] = (s * c - h * n) * v, e[2] = (l * n - s * o) * v, e[3] = p * v, e[4] = (h * i - s * u) * v, e[5] = (s * a - l * i) * v, e[6] = f * v, e[7] = (n * u - c * i) * v, e[8] = (o * i - n * a) * v, this;
  }
  transpose() {
    let e;
    const i = this.elements;
    return e = i[1], i[1] = i[3], i[3] = e, e = i[2], i[2] = i[6], i[6] = e, e = i[5], i[5] = i[7], i[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const i = this.elements;
    return e[0] = i[0], e[1] = i[3], e[2] = i[6], e[3] = i[1], e[4] = i[4], e[5] = i[7], e[6] = i[2], e[7] = i[5], e[8] = i[8], this;
  }
  setUvTransform(e, i, n, s, a, o, l) {
    const u = Math.cos(a), c = Math.sin(a);
    return this.set(
      n * u,
      n * c,
      -n * (u * o + c * l) + o + e,
      -s * c,
      s * u,
      -s * (-c * o + u * l) + l + i,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, i) {
    return this.premultiply(m0.makeScale(e, i)), this;
  }
  rotate(e) {
    return this.premultiply(m0.makeRotation(-e)), this;
  }
  translate(e, i) {
    return this.premultiply(m0.makeTranslation(e, i)), this;
  }
  // for 2D Transforms
  makeTranslation(e, i) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      i,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      n,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i) {
    return this.set(
      e,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const m0 = /* @__PURE__ */ new Yr();
function A7(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function vx(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function C7() {
  const r = vx("canvas");
  return r.style.display = "block", r;
}
const NE = {};
function R7(r) {
  r in NE || (NE[r] = !0, console.warn(r));
}
const ki = {
  enabled: !0,
  workingColorSpace: mo,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(r, e, i) {
    return this.enabled === !1 || e === i || !e || !i || (this.spaces[e].transfer === vd && (r.r = va(r.r), r.g = va(r.g), r.b = va(r.b)), this.spaces[e].primaries !== this.spaces[i].primaries && (r.applyMatrix3(this.spaces[e].toXYZ), r.applyMatrix3(this.spaces[i].fromXYZ)), this.spaces[i].transfer === vd && (r.r = Zu(r.r), r.g = Zu(r.g), r.b = Zu(r.b))), r;
  },
  fromWorkingColorSpace: function(r, e) {
    return this.convert(r, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(r, e) {
    return this.convert(r, e, this.workingColorSpace);
  },
  getPrimaries: function(r) {
    return this.spaces[r].primaries;
  },
  getTransfer: function(r) {
    return r === El ? JN : this.spaces[r].transfer;
  },
  getLuminanceCoefficients: function(r, e = this.workingColorSpace) {
    return r.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(r) {
    Object.assign(this.spaces, r);
  },
  // Internal APIs
  _getMatrix: function(r, e, i) {
    return r.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(r) {
    return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(r = this.workingColorSpace) {
    return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
  }
};
function va(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Zu(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const PE = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], OE = [0.2126, 0.7152, 0.0722], IE = [0.3127, 0.329], DE = /* @__PURE__ */ new Yr().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), kE = /* @__PURE__ */ new Yr().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
ki.define({
  [mo]: {
    primaries: PE,
    whitePoint: IE,
    transfer: JN,
    toXYZ: DE,
    fromXYZ: kE,
    luminanceCoefficients: OE,
    workingColorSpaceConfig: { unpackColorSpace: ht },
    outputColorSpaceConfig: { drawingBufferColorSpace: ht }
  },
  [ht]: {
    primaries: PE,
    whitePoint: IE,
    transfer: vd,
    toXYZ: DE,
    fromXYZ: kE,
    luminanceCoefficients: OE,
    outputColorSpaceConfig: { drawingBufferColorSpace: ht }
  }
});
let uu;
class N7 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let i;
    if (e instanceof HTMLCanvasElement)
      i = e;
    else {
      uu === void 0 && (uu = vx("canvas")), uu.width = e.width, uu.height = e.height;
      const n = uu.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), i = uu;
    }
    return i.width > 2048 || i.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), i.toDataURL("image/jpeg", 0.6)) : i.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const i = vx("canvas");
      i.width = e.width, i.height = e.height;
      const n = i.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const s = n.getImageData(0, 0, e.width, e.height), a = s.data;
      for (let o = 0; o < a.length; o++)
        a[o] = va(a[o] / 255) * 255;
      return n.putImageData(s, 0, 0), i;
    } else if (e.data) {
      const i = e.data.slice(0);
      for (let n = 0; n < i.length; n++)
        i instanceof Uint8Array || i instanceof Uint8ClampedArray ? i[n] = Math.floor(va(i[n] / 255) * 255) : i[n] = va(i[n]);
      return {
        data: i,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let P7 = 0;
class oP {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: P7++ }), this.uuid = ya(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, s = this.data;
    if (s !== null) {
      let a;
      if (Array.isArray(s)) {
        a = [];
        for (let o = 0, l = s.length; o < l; o++)
          s[o].isDataTexture ? a.push(g0(s[o].image)) : a.push(g0(s[o]));
      } else
        a = g0(s);
      n.url = a;
    }
    return i || (e.images[this.uuid] = n), n;
  }
}
function g0(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? N7.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let O7 = 0;
class Ar extends Bc {
  constructor(e = Ar.DEFAULT_IMAGE, i = Ar.DEFAULT_MAPPING, n = Lu, s = Lu, a = hn, o = ma, l = Fc, u = fo, c = Ar.DEFAULT_ANISOTROPY, h = El) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: O7++ }), this.uuid = ya(), this.name = "", this.source = new oP(e), this.mipmaps = [], this.mapping = i, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = a, this.minFilter = o, this.anisotropy = c, this.format = l, this.internalFormat = null, this.type = u, this.offset = new jt(0, 0), this.repeat = new jt(1, 1), this.center = new jt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Yr(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), i || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== rT) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case km:
          e.x = e.x - Math.floor(e.x);
          break;
        case Lu:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Lm:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case km:
          e.y = e.y - Math.floor(e.y);
          break;
        case Lu:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Lm:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Ar.DEFAULT_IMAGE = null;
Ar.DEFAULT_MAPPING = rT;
Ar.DEFAULT_ANISOTROPY = 1;
class $t {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    $t.prototype.isVector4 = !0, this.x = e, this.y = i, this.z = n, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, i, n, s) {
    return this.x = e, this.y = i, this.z = n, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      case 3:
        this.w = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this.w = e.w + i.w, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this.w += e.w * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this.w = e.w - i.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = this.w, o = e.elements;
    return this.x = o[0] * i + o[4] * n + o[8] * s + o[12] * a, this.y = o[1] * i + o[5] * n + o[9] * s + o[13] * a, this.z = o[2] * i + o[6] * n + o[10] * s + o[14] * a, this.w = o[3] * i + o[7] * n + o[11] * s + o[15] * a, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const i = Math.sqrt(1 - e.w * e.w);
    return i < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / i, this.y = e.y / i, this.z = e.z / i), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let i, n, s, a;
    const o = e.elements, l = o[0], u = o[4], c = o[8], h = o[1], d = o[5], p = o[9], f = o[2], m = o[6], v = o[10];
    if (Math.abs(u - h) < 0.01 && Math.abs(c - f) < 0.01 && Math.abs(p - m) < 0.01) {
      if (Math.abs(u + h) < 0.1 && Math.abs(c + f) < 0.1 && Math.abs(p + m) < 0.1 && Math.abs(l + d + v - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      i = Math.PI;
      const g = (l + 1) / 2, _ = (d + 1) / 2, x = (v + 1) / 2, b = (u + h) / 4, T = (c + f) / 4, S = (p + m) / 4;
      return g > _ && g > x ? g < 0.01 ? (n = 0, s = 0.707106781, a = 0.707106781) : (n = Math.sqrt(g), s = b / n, a = T / n) : _ > x ? _ < 0.01 ? (n = 0.707106781, s = 0, a = 0.707106781) : (s = Math.sqrt(_), n = b / s, a = S / s) : x < 0.01 ? (n = 0.707106781, s = 0.707106781, a = 0) : (a = Math.sqrt(x), n = T / a, s = S / a), this.set(n, s, a, i), this;
    }
    let y = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (h - u) * (h - u));
    return Math.abs(y) < 1e-3 && (y = 1), this.x = (m - p) / y, this.y = (c - f) / y, this.z = (h - u) / y, this.w = Math.acos((l + d + v - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this.w = i[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this.w = Math.max(e.w, Math.min(i.w, this.w)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this.w = Math.max(e, Math.min(i, this.w)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this.w += (e.w - this.w) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this.w = e.w + (i.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this.w = e[i + 3], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e[i + 3] = this.w, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this.w = e.getW(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class zc extends Bc {
  constructor(e = 1, i = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = i, this.depth = 1, this.scissor = new $t(0, 0, e, i), this.scissorTest = !1, this.viewport = new $t(0, 0, e, i);
    const s = { width: e, height: i, depth: 1 };
    n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: hn,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, n);
    const a = new Ar(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
    a.flipY = !1, a.generateMipmaps = n.generateMipmaps, a.internalFormat = n.internalFormat, this.textures = [];
    const o = n.count;
    for (let l = 0; l < o; l++)
      this.textures[l] = a.clone(), this.textures[l].isRenderTargetTexture = !0;
    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, i, n = 1) {
    if (this.width !== e || this.height !== i || this.depth !== n) {
      this.width = e, this.height = i, this.depth = n;
      for (let s = 0, a = this.textures.length; s < a; s++)
        this.textures[s].image.width = e, this.textures[s].image.height = i, this.textures[s].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, i), this.scissor.set(0, 0, e, i);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let n = 0, s = e.textures.length; n < s; n++)
      this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
    const i = Object.assign({}, e.texture.image);
    return this.texture.source = new oP(i), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class I7 extends zc {
  constructor(e = 1, i = 1, n = {}) {
    super(e, i, n), this.isWebGLRenderTarget = !0;
  }
}
class D7 extends Ar {
  constructor(e = null, i = 1, n = 1, s = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: i, height: n, depth: s }, this.magFilter = mr, this.minFilter = mr, this.wrapR = Lu, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Kd {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    this.isQuaternion = !0, this._x = e, this._y = i, this._z = n, this._w = s;
  }
  static slerpFlat(e, i, n, s, a, o, l) {
    let u = n[s + 0], c = n[s + 1], h = n[s + 2], d = n[s + 3];
    const p = a[o + 0], f = a[o + 1], m = a[o + 2], v = a[o + 3];
    if (l === 0) {
      e[i + 0] = u, e[i + 1] = c, e[i + 2] = h, e[i + 3] = d;
      return;
    }
    if (l === 1) {
      e[i + 0] = p, e[i + 1] = f, e[i + 2] = m, e[i + 3] = v;
      return;
    }
    if (d !== v || u !== p || c !== f || h !== m) {
      let y = 1 - l;
      const g = u * p + c * f + h * m + d * v, _ = g >= 0 ? 1 : -1, x = 1 - g * g;
      if (x > Number.EPSILON) {
        const T = Math.sqrt(x), S = Math.atan2(T, g * _);
        y = Math.sin(y * S) / T, l = Math.sin(l * S) / T;
      }
      const b = l * _;
      if (u = u * y + p * b, c = c * y + f * b, h = h * y + m * b, d = d * y + v * b, y === 1 - l) {
        const T = 1 / Math.sqrt(u * u + c * c + h * h + d * d);
        u *= T, c *= T, h *= T, d *= T;
      }
    }
    e[i] = u, e[i + 1] = c, e[i + 2] = h, e[i + 3] = d;
  }
  static multiplyQuaternionsFlat(e, i, n, s, a, o) {
    const l = n[s], u = n[s + 1], c = n[s + 2], h = n[s + 3], d = a[o], p = a[o + 1], f = a[o + 2], m = a[o + 3];
    return e[i] = l * m + h * d + u * f - c * p, e[i + 1] = u * m + h * p + c * d - l * f, e[i + 2] = c * m + h * f + l * p - u * d, e[i + 3] = h * m - l * d - u * p - c * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, i, n, s) {
    return this._x = e, this._y = i, this._z = n, this._w = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, i = !0) {
    const n = e._x, s = e._y, a = e._z, o = e._order, l = Math.cos, u = Math.sin, c = l(n / 2), h = l(s / 2), d = l(a / 2), p = u(n / 2), f = u(s / 2), m = u(a / 2);
    switch (o) {
      case "XYZ":
        this._x = p * h * d + c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "YXZ":
        this._x = p * h * d + c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d + p * f * m;
        break;
      case "ZXY":
        this._x = p * h * d - c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "ZYX":
        this._x = p * h * d - c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d + p * f * m;
        break;
      case "YZX":
        this._x = p * h * d + c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "XZY":
        this._x = p * h * d - c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d + p * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return i === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, i) {
    const n = i / 2, s = Math.sin(n);
    return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const i = e.elements, n = i[0], s = i[4], a = i[8], o = i[1], l = i[5], u = i[9], c = i[2], h = i[6], d = i[10], p = n + l + d;
    if (p > 0) {
      const f = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / f, this._x = (h - u) * f, this._y = (a - c) * f, this._z = (o - s) * f;
    } else if (n > l && n > d) {
      const f = 2 * Math.sqrt(1 + n - l - d);
      this._w = (h - u) / f, this._x = 0.25 * f, this._y = (s + o) / f, this._z = (a + c) / f;
    } else if (l > d) {
      const f = 2 * Math.sqrt(1 + l - n - d);
      this._w = (a - c) / f, this._x = (s + o) / f, this._y = 0.25 * f, this._z = (u + h) / f;
    } else {
      const f = 2 * Math.sqrt(1 + d - n - l);
      this._w = (o - s) / f, this._x = (a + c) / f, this._y = (u + h) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, i) {
    let n = e.dot(i) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * i.z - e.z * i.y, this._y = e.z * i.x - e.x * i.z, this._z = e.x * i.y - e.y * i.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(er(this.dot(e), -1, 1)));
  }
  rotateTowards(e, i) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const s = Math.min(1, i / n);
    return this.slerp(e, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, i) {
    const n = e._x, s = e._y, a = e._z, o = e._w, l = i._x, u = i._y, c = i._z, h = i._w;
    return this._x = n * h + o * l + s * c - a * u, this._y = s * h + o * u + a * l - n * c, this._z = a * h + o * c + n * u - s * l, this._w = o * h - n * l - s * u - a * c, this._onChangeCallback(), this;
  }
  slerp(e, i) {
    if (i === 0) return this;
    if (i === 1) return this.copy(e);
    const n = this._x, s = this._y, a = this._z, o = this._w;
    let l = o * e._w + n * e._x + s * e._y + a * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = o, this._x = n, this._y = s, this._z = a, this;
    const u = 1 - l * l;
    if (u <= Number.EPSILON) {
      const f = 1 - i;
      return this._w = f * o + i * this._w, this._x = f * n + i * this._x, this._y = f * s + i * this._y, this._z = f * a + i * this._z, this.normalize(), this;
    }
    const c = Math.sqrt(u), h = Math.atan2(c, l), d = Math.sin((1 - i) * h) / c, p = Math.sin(i * h) / c;
    return this._w = o * d + this._w * p, this._x = n * d + this._x * p, this._y = s * d + this._y * p, this._z = a * d + this._z * p, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, i, n) {
    return this.copy(e).slerp(i, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), i = 2 * Math.PI * Math.random(), n = Math.random(), s = Math.sqrt(1 - n), a = Math.sqrt(n);
    return this.set(
      s * Math.sin(e),
      s * Math.cos(e),
      a * Math.sin(i),
      a * Math.cos(i)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, i = 0) {
    return this._x = e[i], this._y = e[i + 1], this._z = e[i + 2], this._w = e[i + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._w, e;
  }
  fromBufferAttribute(e, i) {
    return this._x = e.getX(i), this._y = e.getY(i), this._z = e.getZ(i), this._w = e.getW(i), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class oe {
  constructor(e = 0, i = 0, n = 0) {
    oe.prototype.isVector3 = !0, this.x = e, this.y = i, this.z = n;
  }
  set(e, i, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = i, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, i) {
    return this.x = e.x * i.x, this.y = e.y * i.y, this.z = e.z * i.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(LE.setFromEuler(e));
  }
  applyAxisAngle(e, i) {
    return this.applyQuaternion(LE.setFromAxisAngle(e, i));
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[3] * n + a[6] * s, this.y = a[1] * i + a[4] * n + a[7] * s, this.z = a[2] * i + a[5] * n + a[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements, o = 1 / (a[3] * i + a[7] * n + a[11] * s + a[15]);
    return this.x = (a[0] * i + a[4] * n + a[8] * s + a[12]) * o, this.y = (a[1] * i + a[5] * n + a[9] * s + a[13]) * o, this.z = (a[2] * i + a[6] * n + a[10] * s + a[14]) * o, this;
  }
  applyQuaternion(e) {
    const i = this.x, n = this.y, s = this.z, a = e.x, o = e.y, l = e.z, u = e.w, c = 2 * (o * s - l * n), h = 2 * (l * i - a * s), d = 2 * (a * n - o * i);
    return this.x = i + u * c + o * d - l * h, this.y = n + u * h + l * c - a * d, this.z = s + u * d + a * h - o * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[4] * n + a[8] * s, this.y = a[1] * i + a[5] * n + a[9] * s, this.z = a[2] * i + a[6] * n + a[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, i) {
    const n = e.x, s = e.y, a = e.z, o = i.x, l = i.y, u = i.z;
    return this.x = s * u - a * l, this.y = a * o - n * u, this.z = n * l - s * o, this;
  }
  projectOnVector(e) {
    const i = e.lengthSq();
    if (i === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / i;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return y0.copy(this).projectOnVector(e), this.sub(y0);
  }
  reflect(e) {
    return this.sub(y0.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(er(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
    return i * i + n * n + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, i, n) {
    const s = Math.sin(i) * e;
    return this.x = s * Math.sin(n), this.y = Math.cos(i) * e, this.z = s * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, i, n) {
    return this.x = e * Math.sin(i), this.y = n, this.z = e * Math.cos(i), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this;
  }
  setFromMatrixScale(e) {
    const i = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = i, this.y = n, this.z = s, this;
  }
  setFromMatrixColumn(e, i) {
    return this.fromArray(e.elements, i * 4);
  }
  setFromMatrix3Column(e, i) {
    return this.fromArray(e.elements, i * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, i = Math.random() * 2 - 1, n = Math.sqrt(1 - i * i);
    return this.x = n * Math.cos(e), this.y = i, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const y0 = /* @__PURE__ */ new oe(), LE = /* @__PURE__ */ new Kd();
class Qd {
  constructor(e = new oe(1 / 0, 1 / 0, 1 / 0), i = new oe(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = i;
  }
  set(e, i) {
    return this.min.copy(e), this.max.copy(i), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let i = 0, n = e.length; i < n; i += 3)
      this.expandByPoint(kn.fromArray(e, i));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let i = 0, n = e.count; i < n; i++)
      this.expandByPoint(kn.fromBufferAttribute(e, i));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let i = 0, n = e.length; i < n; i++)
      this.expandByPoint(e[i]);
    return this;
  }
  setFromCenterAndSize(e, i) {
    const n = kn.copy(i).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, i = !1) {
    return this.makeEmpty(), this.expandByObject(e, i);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, i = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const a = n.getAttribute("position");
      if (i === !0 && a !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, l = a.count; o < l; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, kn) : kn.fromBufferAttribute(a, o), kn.applyMatrix4(e.matrixWorld), this.expandByPoint(kn);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Yp.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Yp.copy(n.boundingBox)), Yp.applyMatrix4(e.matrixWorld), this.union(Yp);
    }
    const s = e.children;
    for (let a = 0, o = s.length; a < o; a++)
      this.expandByObject(s[a], i);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, i) {
    return i.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, kn), kn.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let i, n;
    return e.normal.x > 0 ? (i = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (i = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (i += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (i += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (i += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (i += e.normal.z * this.max.z, n += e.normal.z * this.min.z), i <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(gh), $p.subVectors(this.max, gh), cu.subVectors(e.a, gh), hu.subVectors(e.b, gh), du.subVectors(e.c, gh), za.subVectors(hu, cu), ja.subVectors(du, hu), Uo.subVectors(cu, du);
    let i = [
      0,
      -za.z,
      za.y,
      0,
      -ja.z,
      ja.y,
      0,
      -Uo.z,
      Uo.y,
      za.z,
      0,
      -za.x,
      ja.z,
      0,
      -ja.x,
      Uo.z,
      0,
      -Uo.x,
      -za.y,
      za.x,
      0,
      -ja.y,
      ja.x,
      0,
      -Uo.y,
      Uo.x,
      0
    ];
    return !v0(i, cu, hu, du, $p) || (i = [1, 0, 0, 0, 1, 0, 0, 0, 1], !v0(i, cu, hu, du, $p)) ? !1 : (Kp.crossVectors(za, ja), i = [Kp.x, Kp.y, Kp.z], v0(i, cu, hu, du, $p));
  }
  clampPoint(e, i) {
    return i.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, kn).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(kn).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Ls[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ls[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ls[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ls[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ls[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ls[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ls[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ls[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ls), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ls = [
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe(),
  /* @__PURE__ */ new oe()
], kn = /* @__PURE__ */ new oe(), Yp = /* @__PURE__ */ new Qd(), cu = /* @__PURE__ */ new oe(), hu = /* @__PURE__ */ new oe(), du = /* @__PURE__ */ new oe(), za = /* @__PURE__ */ new oe(), ja = /* @__PURE__ */ new oe(), Uo = /* @__PURE__ */ new oe(), gh = /* @__PURE__ */ new oe(), $p = /* @__PURE__ */ new oe(), Kp = /* @__PURE__ */ new oe(), Fo = /* @__PURE__ */ new oe();
function v0(r, e, i, n, s) {
  for (let a = 0, o = r.length - 3; a <= o; a += 3) {
    Fo.fromArray(r, a);
    const l = s.x * Math.abs(Fo.x) + s.y * Math.abs(Fo.y) + s.z * Math.abs(Fo.z), u = e.dot(Fo), c = i.dot(Fo), h = n.dot(Fo);
    if (Math.max(-Math.max(u, c, h), Math.min(u, c, h)) > l)
      return !1;
  }
  return !0;
}
const k7 = /* @__PURE__ */ new Qd(), yh = /* @__PURE__ */ new oe(), b0 = /* @__PURE__ */ new oe();
class hT {
  constructor(e = new oe(), i = -1) {
    this.isSphere = !0, this.center = e, this.radius = i;
  }
  set(e, i) {
    return this.center.copy(e), this.radius = i, this;
  }
  setFromPoints(e, i) {
    const n = this.center;
    i !== void 0 ? n.copy(i) : k7.setFromPoints(e).getCenter(n);
    let s = 0;
    for (let a = 0, o = e.length; a < o; a++)
      s = Math.max(s, n.distanceToSquared(e[a]));
    return this.radius = Math.sqrt(s), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const i = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= i * i;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, i) {
    const n = this.center.distanceToSquared(e);
    return i.copy(e), n > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)), i;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    yh.subVectors(e, this.center);
    const i = yh.lengthSq();
    if (i > this.radius * this.radius) {
      const n = Math.sqrt(i), s = (n - this.radius) * 0.5;
      this.center.addScaledVector(yh, s / n), this.radius += s;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (b0.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(yh.copy(e.center).add(b0)), this.expandByPoint(yh.copy(e.center).sub(b0))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Us = /* @__PURE__ */ new oe(), x0 = /* @__PURE__ */ new oe(), Qp = /* @__PURE__ */ new oe(), Va = /* @__PURE__ */ new oe(), _0 = /* @__PURE__ */ new oe(), Zp = /* @__PURE__ */ new oe(), T0 = /* @__PURE__ */ new oe();
class L7 {
  constructor(e = new oe(), i = new oe(0, 0, -1)) {
    this.origin = e, this.direction = i;
  }
  set(e, i) {
    return this.origin.copy(e), this.direction.copy(i), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, i) {
    return i.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Us)), this;
  }
  closestPointToPoint(e, i) {
    i.subVectors(e, this.origin);
    const n = i.dot(this.direction);
    return n < 0 ? i.copy(this.origin) : i.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const i = Us.subVectors(e, this.origin).dot(this.direction);
    return i < 0 ? this.origin.distanceToSquared(e) : (Us.copy(this.origin).addScaledVector(this.direction, i), Us.distanceToSquared(e));
  }
  distanceSqToSegment(e, i, n, s) {
    x0.copy(e).add(i).multiplyScalar(0.5), Qp.copy(i).sub(e).normalize(), Va.copy(this.origin).sub(x0);
    const a = e.distanceTo(i) * 0.5, o = -this.direction.dot(Qp), l = Va.dot(this.direction), u = -Va.dot(Qp), c = Va.lengthSq(), h = Math.abs(1 - o * o);
    let d, p, f, m;
    if (h > 0)
      if (d = o * u - l, p = o * l - u, m = a * h, d >= 0)
        if (p >= -m)
          if (p <= m) {
            const v = 1 / h;
            d *= v, p *= v, f = d * (d + o * p + 2 * l) + p * (o * d + p + 2 * u) + c;
          } else
            p = a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
        else
          p = -a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
      else
        p <= -m ? (d = Math.max(0, -(-o * a + l)), p = d > 0 ? -a : Math.min(Math.max(-a, -u), a), f = -d * d + p * (p + 2 * u) + c) : p <= m ? (d = 0, p = Math.min(Math.max(-a, -u), a), f = p * (p + 2 * u) + c) : (d = Math.max(0, -(o * a + l)), p = d > 0 ? a : Math.min(Math.max(-a, -u), a), f = -d * d + p * (p + 2 * u) + c);
    else
      p = o > 0 ? -a : a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
    return n && n.copy(this.origin).addScaledVector(this.direction, d), s && s.copy(x0).addScaledVector(Qp, p), f;
  }
  intersectSphere(e, i) {
    Us.subVectors(e.center, this.origin);
    const n = Us.dot(this.direction), s = Us.dot(Us) - n * n, a = e.radius * e.radius;
    if (s > a) return null;
    const o = Math.sqrt(a - s), l = n - o, u = n + o;
    return u < 0 ? null : l < 0 ? this.at(u, i) : this.at(l, i);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const i = e.normal.dot(this.direction);
    if (i === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / i;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, i) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, i);
  }
  intersectsPlane(e) {
    const i = e.distanceToPoint(this.origin);
    return i === 0 || e.normal.dot(this.direction) * i < 0;
  }
  intersectBox(e, i) {
    let n, s, a, o, l, u;
    const c = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin;
    return c >= 0 ? (n = (e.min.x - p.x) * c, s = (e.max.x - p.x) * c) : (n = (e.max.x - p.x) * c, s = (e.min.x - p.x) * c), h >= 0 ? (a = (e.min.y - p.y) * h, o = (e.max.y - p.y) * h) : (a = (e.max.y - p.y) * h, o = (e.min.y - p.y) * h), n > o || a > s || ((a > n || isNaN(n)) && (n = a), (o < s || isNaN(s)) && (s = o), d >= 0 ? (l = (e.min.z - p.z) * d, u = (e.max.z - p.z) * d) : (l = (e.max.z - p.z) * d, u = (e.min.z - p.z) * d), n > u || l > s) || ((l > n || n !== n) && (n = l), (u < s || s !== s) && (s = u), s < 0) ? null : this.at(n >= 0 ? n : s, i);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Us) !== null;
  }
  intersectTriangle(e, i, n, s, a) {
    _0.subVectors(i, e), Zp.subVectors(n, e), T0.crossVectors(_0, Zp);
    let o = this.direction.dot(T0), l;
    if (o > 0) {
      if (s) return null;
      l = 1;
    } else if (o < 0)
      l = -1, o = -o;
    else
      return null;
    Va.subVectors(this.origin, e);
    const u = l * this.direction.dot(Zp.crossVectors(Va, Zp));
    if (u < 0)
      return null;
    const c = l * this.direction.dot(_0.cross(Va));
    if (c < 0 || u + c > o)
      return null;
    const h = -l * Va.dot(T0);
    return h < 0 ? null : this.at(h / o, a);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class gi {
  constructor(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y) {
    gi.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y);
  }
  set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, v, y) {
    const g = this.elements;
    return g[0] = e, g[4] = i, g[8] = n, g[12] = s, g[1] = a, g[5] = o, g[9] = l, g[13] = u, g[2] = c, g[6] = h, g[10] = d, g[14] = p, g[3] = f, g[7] = m, g[11] = v, g[15] = y, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new gi().fromArray(this.elements);
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], i[9] = n[9], i[10] = n[10], i[11] = n[11], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15], this;
  }
  copyPosition(e) {
    const i = this.elements, n = e.elements;
    return i[12] = n[12], i[13] = n[13], i[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[3],
      i[6],
      0,
      i[1],
      i[4],
      i[7],
      0,
      i[2],
      i[5],
      i[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrixColumn(this, 0), i.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, i, n) {
    return this.set(
      e.x,
      i.x,
      n.x,
      0,
      e.y,
      i.y,
      n.y,
      0,
      e.z,
      i.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const i = this.elements, n = e.elements, s = 1 / pu.setFromMatrixColumn(e, 0).length(), a = 1 / pu.setFromMatrixColumn(e, 1).length(), o = 1 / pu.setFromMatrixColumn(e, 2).length();
    return i[0] = n[0] * s, i[1] = n[1] * s, i[2] = n[2] * s, i[3] = 0, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[7] = 0, i[8] = n[8] * o, i[9] = n[9] * o, i[10] = n[10] * o, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z, o = Math.cos(n), l = Math.sin(n), u = Math.cos(s), c = Math.sin(s), h = Math.cos(a), d = Math.sin(a);
    if (e.order === "XYZ") {
      const p = o * h, f = o * d, m = l * h, v = l * d;
      i[0] = u * h, i[4] = -u * d, i[8] = c, i[1] = f + m * c, i[5] = p - v * c, i[9] = -l * u, i[2] = v - p * c, i[6] = m + f * c, i[10] = o * u;
    } else if (e.order === "YXZ") {
      const p = u * h, f = u * d, m = c * h, v = c * d;
      i[0] = p + v * l, i[4] = m * l - f, i[8] = o * c, i[1] = o * d, i[5] = o * h, i[9] = -l, i[2] = f * l - m, i[6] = v + p * l, i[10] = o * u;
    } else if (e.order === "ZXY") {
      const p = u * h, f = u * d, m = c * h, v = c * d;
      i[0] = p - v * l, i[4] = -o * d, i[8] = m + f * l, i[1] = f + m * l, i[5] = o * h, i[9] = v - p * l, i[2] = -o * c, i[6] = l, i[10] = o * u;
    } else if (e.order === "ZYX") {
      const p = o * h, f = o * d, m = l * h, v = l * d;
      i[0] = u * h, i[4] = m * c - f, i[8] = p * c + v, i[1] = u * d, i[5] = v * c + p, i[9] = f * c - m, i[2] = -c, i[6] = l * u, i[10] = o * u;
    } else if (e.order === "YZX") {
      const p = o * u, f = o * c, m = l * u, v = l * c;
      i[0] = u * h, i[4] = v - p * d, i[8] = m * d + f, i[1] = d, i[5] = o * h, i[9] = -l * h, i[2] = -c * h, i[6] = f * d + m, i[10] = p - v * d;
    } else if (e.order === "XZY") {
      const p = o * u, f = o * c, m = l * u, v = l * c;
      i[0] = u * h, i[4] = -d, i[8] = c * h, i[1] = p * d + v, i[5] = o * h, i[9] = f * d - m, i[2] = m * d - f, i[6] = l * h, i[10] = v * d + p;
    }
    return i[3] = 0, i[7] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(U7, e, F7);
  }
  lookAt(e, i, n) {
    const s = this.elements;
    return en.subVectors(e, i), en.lengthSq() === 0 && (en.z = 1), en.normalize(), Ga.crossVectors(n, en), Ga.lengthSq() === 0 && (Math.abs(n.z) === 1 ? en.x += 1e-4 : en.z += 1e-4, en.normalize(), Ga.crossVectors(n, en)), Ga.normalize(), Jp.crossVectors(en, Ga), s[0] = Ga.x, s[4] = Jp.x, s[8] = en.x, s[1] = Ga.y, s[5] = Jp.y, s[9] = en.y, s[2] = Ga.z, s[6] = Jp.z, s[10] = en.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[4], u = n[8], c = n[12], h = n[1], d = n[5], p = n[9], f = n[13], m = n[2], v = n[6], y = n[10], g = n[14], _ = n[3], x = n[7], b = n[11], T = n[15], S = s[0], w = s[4], C = s[8], E = s[12], A = s[1], N = s[5], L = s[9], F = s[13], M = s[2], P = s[6], O = s[10], V = s[14], B = s[3], H = s[7], U = s[11], j = s[15];
    return a[0] = o * S + l * A + u * M + c * B, a[4] = o * w + l * N + u * P + c * H, a[8] = o * C + l * L + u * O + c * U, a[12] = o * E + l * F + u * V + c * j, a[1] = h * S + d * A + p * M + f * B, a[5] = h * w + d * N + p * P + f * H, a[9] = h * C + d * L + p * O + f * U, a[13] = h * E + d * F + p * V + f * j, a[2] = m * S + v * A + y * M + g * B, a[6] = m * w + v * N + y * P + g * H, a[10] = m * C + v * L + y * O + g * U, a[14] = m * E + v * F + y * V + g * j, a[3] = _ * S + x * A + b * M + T * B, a[7] = _ * w + x * N + b * P + T * H, a[11] = _ * C + x * L + b * O + T * U, a[15] = _ * E + x * F + b * V + T * j, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[4] *= e, i[8] *= e, i[12] *= e, i[1] *= e, i[5] *= e, i[9] *= e, i[13] *= e, i[2] *= e, i[6] *= e, i[10] *= e, i[14] *= e, i[3] *= e, i[7] *= e, i[11] *= e, i[15] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[4], s = e[8], a = e[12], o = e[1], l = e[5], u = e[9], c = e[13], h = e[2], d = e[6], p = e[10], f = e[14], m = e[3], v = e[7], y = e[11], g = e[15];
    return m * (+a * u * d - s * c * d - a * l * p + n * c * p + s * l * f - n * u * f) + v * (+i * u * f - i * c * p + a * o * p - s * o * f + s * c * h - a * u * h) + y * (+i * c * d - i * l * f - a * o * d + n * o * f + a * l * h - n * c * h) + g * (-s * l * h - i * u * d + i * l * p + s * o * d - n * o * p + n * u * h);
  }
  transpose() {
    const e = this.elements;
    let i;
    return i = e[1], e[1] = e[4], e[4] = i, i = e[2], e[2] = e[8], e[8] = i, i = e[6], e[6] = e[9], e[9] = i, i = e[3], e[3] = e[12], e[12] = i, i = e[7], e[7] = e[13], e[13] = i, i = e[11], e[11] = e[14], e[14] = i, this;
  }
  setPosition(e, i, n) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = i, s[14] = n), this;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = e[9], p = e[10], f = e[11], m = e[12], v = e[13], y = e[14], g = e[15], _ = d * y * c - v * p * c + v * u * f - l * y * f - d * u * g + l * p * g, x = m * p * c - h * y * c - m * u * f + o * y * f + h * u * g - o * p * g, b = h * v * c - m * d * c + m * l * f - o * v * f - h * l * g + o * d * g, T = m * d * u - h * v * u - m * l * p + o * v * p + h * l * y - o * d * y, S = i * _ + n * x + s * b + a * T;
    if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / S;
    return e[0] = _ * w, e[1] = (v * p * a - d * y * a - v * s * f + n * y * f + d * s * g - n * p * g) * w, e[2] = (l * y * a - v * u * a + v * s * c - n * y * c - l * s * g + n * u * g) * w, e[3] = (d * u * a - l * p * a - d * s * c + n * p * c + l * s * f - n * u * f) * w, e[4] = x * w, e[5] = (h * y * a - m * p * a + m * s * f - i * y * f - h * s * g + i * p * g) * w, e[6] = (m * u * a - o * y * a - m * s * c + i * y * c + o * s * g - i * u * g) * w, e[7] = (o * p * a - h * u * a + h * s * c - i * p * c - o * s * f + i * u * f) * w, e[8] = b * w, e[9] = (m * d * a - h * v * a - m * n * f + i * v * f + h * n * g - i * d * g) * w, e[10] = (o * v * a - m * l * a + m * n * c - i * v * c - o * n * g + i * l * g) * w, e[11] = (h * l * a - o * d * a - h * n * c + i * d * c + o * n * f - i * l * f) * w, e[12] = T * w, e[13] = (h * v * s - m * d * s + m * n * p - i * v * p - h * n * y + i * d * y) * w, e[14] = (m * l * s - o * v * s - m * n * u + i * v * u + o * n * y - i * l * y) * w, e[15] = (o * d * s - h * l * s + h * n * u - i * d * u - o * n * p + i * l * p) * w, this;
  }
  scale(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z;
    return i[0] *= n, i[4] *= s, i[8] *= a, i[1] *= n, i[5] *= s, i[9] *= a, i[2] *= n, i[6] *= s, i[10] *= a, i[3] *= n, i[7] *= s, i[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(i, n, s));
  }
  makeTranslation(e, i, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      i,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = 1 - n, o = e.x, l = e.y, u = e.z, c = a * o, h = a * l;
    return this.set(
      c * o + n,
      c * l - s * u,
      c * u + s * l,
      0,
      c * l + s * u,
      h * l + n,
      h * u - s * o,
      0,
      c * u - s * l,
      h * u + s * o,
      a * u * u + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, i, n, s, a, o) {
    return this.set(
      1,
      n,
      a,
      0,
      e,
      1,
      o,
      0,
      i,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, i, n) {
    const s = this.elements, a = i._x, o = i._y, l = i._z, u = i._w, c = a + a, h = o + o, d = l + l, p = a * c, f = a * h, m = a * d, v = o * h, y = o * d, g = l * d, _ = u * c, x = u * h, b = u * d, T = n.x, S = n.y, w = n.z;
    return s[0] = (1 - (v + g)) * T, s[1] = (f + b) * T, s[2] = (m - x) * T, s[3] = 0, s[4] = (f - b) * S, s[5] = (1 - (p + g)) * S, s[6] = (y + _) * S, s[7] = 0, s[8] = (m + x) * w, s[9] = (y - _) * w, s[10] = (1 - (p + v)) * w, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, i, n) {
    const s = this.elements;
    let a = pu.set(s[0], s[1], s[2]).length();
    const o = pu.set(s[4], s[5], s[6]).length(), l = pu.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (a = -a), e.x = s[12], e.y = s[13], e.z = s[14], Ln.copy(this);
    const u = 1 / a, c = 1 / o, h = 1 / l;
    return Ln.elements[0] *= u, Ln.elements[1] *= u, Ln.elements[2] *= u, Ln.elements[4] *= c, Ln.elements[5] *= c, Ln.elements[6] *= c, Ln.elements[8] *= h, Ln.elements[9] *= h, Ln.elements[10] *= h, i.setFromRotationMatrix(Ln), n.x = a, n.y = o, n.z = l, this;
  }
  makePerspective(e, i, n, s, a, o, l = Zn) {
    const u = this.elements, c = 2 * a / (i - e), h = 2 * a / (n - s), d = (i + e) / (i - e), p = (n + s) / (n - s);
    let f, m;
    if (l === Zn)
      f = -(o + a) / (o - a), m = -2 * o * a / (o - a);
    else if (l === Ml)
      f = -o / (o - a), m = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return u[0] = c, u[4] = 0, u[8] = d, u[12] = 0, u[1] = 0, u[5] = h, u[9] = p, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = f, u[14] = m, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this;
  }
  makeOrthographic(e, i, n, s, a, o, l = Zn) {
    const u = this.elements, c = 1 / (i - e), h = 1 / (n - s), d = 1 / (o - a), p = (i + e) * c, f = (n + s) * h;
    let m, v;
    if (l === Zn)
      m = (o + a) * d, v = -2 * d;
    else if (l === Ml)
      m = a * d, v = -1 * d;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return u[0] = 2 * c, u[4] = 0, u[8] = 0, u[12] = -p, u[1] = 0, u[5] = 2 * h, u[9] = 0, u[13] = -f, u[2] = 0, u[6] = 0, u[10] = v, u[14] = -m, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this;
  }
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 16; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e[i + 9] = n[9], e[i + 10] = n[10], e[i + 11] = n[11], e[i + 12] = n[12], e[i + 13] = n[13], e[i + 14] = n[14], e[i + 15] = n[15], e;
  }
}
const pu = /* @__PURE__ */ new oe(), Ln = /* @__PURE__ */ new gi(), U7 = /* @__PURE__ */ new oe(0, 0, 0), F7 = /* @__PURE__ */ new oe(1, 1, 1), Ga = /* @__PURE__ */ new oe(), Jp = /* @__PURE__ */ new oe(), en = /* @__PURE__ */ new oe(), UE = /* @__PURE__ */ new gi(), FE = /* @__PURE__ */ new Kd();
class ts {
  constructor(e = 0, i = 0, n = 0, s = ts.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = i, this._z = n, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, i, n, s = this._order) {
    return this._x = e, this._y = i, this._z = n, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, i = this._order, n = !0) {
    const s = e.elements, a = s[0], o = s[4], l = s[8], u = s[1], c = s[5], h = s[9], d = s[2], p = s[6], f = s[10];
    switch (i) {
      case "XYZ":
        this._y = Math.asin(er(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(p, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-er(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(u, c)) : (this._y = Math.atan2(-d, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(er(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(u, a));
        break;
      case "ZYX":
        this._y = Math.asin(-er(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(u, a)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin(er(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-d, a)) : (this._x = 0, this._y = Math.atan2(l, f));
        break;
      case "XZY":
        this._z = Math.asin(-er(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + i);
    }
    return this._order = i, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, i, n) {
    return UE.makeRotationFromQuaternion(e), this.setFromRotationMatrix(UE, i, n);
  }
  setFromVector3(e, i = this._order) {
    return this.set(e.x, e.y, e.z, i);
  }
  reorder(e) {
    return FE.setFromEuler(this), this.setFromQuaternion(FE, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
ts.DEFAULT_ORDER = "XYZ";
class B7 {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let z7 = 0;
const BE = /* @__PURE__ */ new oe(), fu = /* @__PURE__ */ new Kd(), Fs = /* @__PURE__ */ new gi(), ef = /* @__PURE__ */ new oe(), vh = /* @__PURE__ */ new oe(), j7 = /* @__PURE__ */ new oe(), V7 = /* @__PURE__ */ new Kd(), zE = /* @__PURE__ */ new oe(1, 0, 0), jE = /* @__PURE__ */ new oe(0, 1, 0), VE = /* @__PURE__ */ new oe(0, 0, 1), GE = { type: "added" }, G7 = { type: "removed" }, mu = { type: "childadded", child: null }, S0 = { type: "childremoved", child: null };
class Ki extends Bc {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: z7++ }), this.uuid = ya(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ki.DEFAULT_UP.clone();
    const e = new oe(), i = new ts(), n = new Kd(), s = new oe(1, 1, 1);
    function a() {
      n.setFromEuler(i, !1);
    }
    function o() {
      i.setFromQuaternion(n, void 0, !1);
    }
    i._onChange(a), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      modelViewMatrix: {
        value: new gi()
      },
      normalMatrix: {
        value: new Yr()
      }
    }), this.matrix = new gi(), this.matrixWorld = new gi(), this.matrixAutoUpdate = Ki.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Ki.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new B7(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, i) {
    this.quaternion.setFromAxisAngle(e, i);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, i) {
    return fu.setFromAxisAngle(e, i), this.quaternion.multiply(fu), this;
  }
  rotateOnWorldAxis(e, i) {
    return fu.setFromAxisAngle(e, i), this.quaternion.premultiply(fu), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(zE, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(jE, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(VE, e);
  }
  translateOnAxis(e, i) {
    return BE.copy(e).applyQuaternion(this.quaternion), this.position.add(BE.multiplyScalar(i)), this;
  }
  translateX(e) {
    return this.translateOnAxis(zE, e);
  }
  translateY(e) {
    return this.translateOnAxis(jE, e);
  }
  translateZ(e) {
    return this.translateOnAxis(VE, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Fs.copy(this.matrixWorld).invert());
  }
  lookAt(e, i, n) {
    e.isVector3 ? ef.copy(e) : ef.set(e, i, n);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), vh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Fs.lookAt(vh, ef, this.up) : Fs.lookAt(ef, vh, this.up), this.quaternion.setFromRotationMatrix(Fs), s && (Fs.extractRotation(s.matrixWorld), fu.setFromRotationMatrix(Fs), this.quaternion.premultiply(fu.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.add(arguments[i]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(GE), mu.child = e, this.dispatchEvent(mu), mu.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const i = this.children.indexOf(e);
    return i !== -1 && (e.parent = null, this.children.splice(i, 1), e.dispatchEvent(G7), S0.child = e, this.dispatchEvent(S0), S0.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Fs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Fs.multiply(e.parent.matrixWorld)), e.applyMatrix4(Fs), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(GE), mu.child = e, this.dispatchEvent(mu), mu.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, i) {
    if (this[e] === i) return this;
    for (let n = 0, s = this.children.length; n < s; n++) {
      const a = this.children[n].getObjectByProperty(e, i);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, i, n = []) {
    this[e] === i && n.push(this);
    const s = this.children;
    for (let a = 0, o = s.length; a < o; a++)
      s[a].getObjectsByProperty(e, i, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(vh, e, j7), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(vh, V7, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const i = this.matrixWorld.elements;
    return e.set(i[8], i[9], i[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const i = this.parent;
    i !== null && (e(i), i.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, i) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), i === !0) {
      const s = this.children;
      for (let a = 0, o = s.length; a < o; a++)
        s[a].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string", n = {};
    i && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
      center: s.boundingSphere.center.toArray(),
      radius: s.boundingSphere.radius
    }), this.boundingBox !== null && (s.boundingBox = {
      min: s.boundingBox.min.toArray(),
      max: s.boundingBox.max.toArray()
    }));
    function a(l, u) {
      return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = a(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const u = l.shapes;
        if (Array.isArray(u))
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c];
            a(e.shapes, d);
          }
        else
          a(e.shapes, u);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let u = 0, c = this.material.length; u < c; u++)
          l.push(a(e.materials, this.material[u]));
        s.material = l;
      } else
        s.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let l = 0; l < this.children.length; l++)
        s.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const u = this.animations[l];
        s.animations.push(a(e.animations, u));
      }
    }
    if (i) {
      const l = o(e.geometries), u = o(e.materials), c = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), f = o(e.animations), m = o(e.nodes);
      l.length > 0 && (n.geometries = l), u.length > 0 && (n.materials = u), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), d.length > 0 && (n.shapes = d), p.length > 0 && (n.skeletons = p), f.length > 0 && (n.animations = f), m.length > 0 && (n.nodes = m);
    }
    return n.object = s, n;
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, i = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), i === !0)
      for (let n = 0; n < e.children.length; n++) {
        const s = e.children[n];
        this.add(s.clone());
      }
    return this;
  }
}
Ki.DEFAULT_UP = /* @__PURE__ */ new oe(0, 1, 0);
Ki.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ki.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Un = /* @__PURE__ */ new oe(), Bs = /* @__PURE__ */ new oe(), w0 = /* @__PURE__ */ new oe(), zs = /* @__PURE__ */ new oe(), gu = /* @__PURE__ */ new oe(), yu = /* @__PURE__ */ new oe(), HE = /* @__PURE__ */ new oe(), E0 = /* @__PURE__ */ new oe(), M0 = /* @__PURE__ */ new oe(), A0 = /* @__PURE__ */ new oe(), C0 = /* @__PURE__ */ new $t(), R0 = /* @__PURE__ */ new $t(), N0 = /* @__PURE__ */ new $t();
class $n {
  constructor(e = new oe(), i = new oe(), n = new oe()) {
    this.a = e, this.b = i, this.c = n;
  }
  static getNormal(e, i, n, s) {
    s.subVectors(n, i), Un.subVectors(e, i), s.cross(Un);
    const a = s.lengthSq();
    return a > 0 ? s.multiplyScalar(1 / Math.sqrt(a)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, i, n, s, a) {
    Un.subVectors(s, i), Bs.subVectors(n, i), w0.subVectors(e, i);
    const o = Un.dot(Un), l = Un.dot(Bs), u = Un.dot(w0), c = Bs.dot(Bs), h = Bs.dot(w0), d = o * c - l * l;
    if (d === 0)
      return a.set(0, 0, 0), null;
    const p = 1 / d, f = (c * u - l * h) * p, m = (o * h - l * u) * p;
    return a.set(1 - f - m, m, f);
  }
  static containsPoint(e, i, n, s) {
    return this.getBarycoord(e, i, n, s, zs) === null ? !1 : zs.x >= 0 && zs.y >= 0 && zs.x + zs.y <= 1;
  }
  static getInterpolation(e, i, n, s, a, o, l, u) {
    return this.getBarycoord(e, i, n, s, zs) === null ? (u.x = 0, u.y = 0, "z" in u && (u.z = 0), "w" in u && (u.w = 0), null) : (u.setScalar(0), u.addScaledVector(a, zs.x), u.addScaledVector(o, zs.y), u.addScaledVector(l, zs.z), u);
  }
  static getInterpolatedAttribute(e, i, n, s, a, o) {
    return C0.setScalar(0), R0.setScalar(0), N0.setScalar(0), C0.fromBufferAttribute(e, i), R0.fromBufferAttribute(e, n), N0.fromBufferAttribute(e, s), o.setScalar(0), o.addScaledVector(C0, a.x), o.addScaledVector(R0, a.y), o.addScaledVector(N0, a.z), o;
  }
  static isFrontFacing(e, i, n, s) {
    return Un.subVectors(n, i), Bs.subVectors(e, i), Un.cross(Bs).dot(s) < 0;
  }
  set(e, i, n) {
    return this.a.copy(e), this.b.copy(i), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, i, n, s) {
    return this.a.copy(e[i]), this.b.copy(e[n]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, i, n, s) {
    return this.a.fromBufferAttribute(e, i), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Un.subVectors(this.c, this.b), Bs.subVectors(this.a, this.b), Un.cross(Bs).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return $n.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, i) {
    return $n.getBarycoord(e, this.a, this.b, this.c, i);
  }
  getInterpolation(e, i, n, s, a) {
    return $n.getInterpolation(e, this.a, this.b, this.c, i, n, s, a);
  }
  containsPoint(e) {
    return $n.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return $n.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, i) {
    const n = this.a, s = this.b, a = this.c;
    let o, l;
    gu.subVectors(s, n), yu.subVectors(a, n), E0.subVectors(e, n);
    const u = gu.dot(E0), c = yu.dot(E0);
    if (u <= 0 && c <= 0)
      return i.copy(n);
    M0.subVectors(e, s);
    const h = gu.dot(M0), d = yu.dot(M0);
    if (h >= 0 && d <= h)
      return i.copy(s);
    const p = u * d - h * c;
    if (p <= 0 && u >= 0 && h <= 0)
      return o = u / (u - h), i.copy(n).addScaledVector(gu, o);
    A0.subVectors(e, a);
    const f = gu.dot(A0), m = yu.dot(A0);
    if (m >= 0 && f <= m)
      return i.copy(a);
    const v = f * c - u * m;
    if (v <= 0 && c >= 0 && m <= 0)
      return l = c / (c - m), i.copy(n).addScaledVector(yu, l);
    const y = h * m - f * d;
    if (y <= 0 && d - h >= 0 && f - m >= 0)
      return HE.subVectors(a, s), l = (d - h) / (d - h + (f - m)), i.copy(s).addScaledVector(HE, l);
    const g = 1 / (y + v + p);
    return o = v * g, l = p * g, i.copy(n).addScaledVector(gu, o).addScaledVector(yu, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const lP = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Ha = { h: 0, s: 0, l: 0 }, tf = { h: 0, s: 0, l: 0 };
function P0(r, e, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? r + (e - r) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - i) : r;
}
class Kt {
  constructor(e, i, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, i, n);
  }
  set(e, i, n) {
    if (i === void 0 && n === void 0) {
      const s = e;
      s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
    } else
      this.setRGB(e, i, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, i = ht) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, ki.toWorkingColorSpace(this, i), this;
  }
  setRGB(e, i, n, s = ki.workingColorSpace) {
    return this.r = e, this.g = i, this.b = n, ki.toWorkingColorSpace(this, s), this;
  }
  setHSL(e, i, n, s = ki.workingColorSpace) {
    if (e = cT(e, 1), i = er(i, 0, 1), n = er(n, 0, 1), i === 0)
      this.r = this.g = this.b = n;
    else {
      const a = n <= 0.5 ? n * (1 + i) : n + i - n * i, o = 2 * n - a;
      this.r = P0(o, a, e + 1 / 3), this.g = P0(o, a, e), this.b = P0(o, a, e - 1 / 3);
    }
    return ki.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, i = ht) {
    function n(a) {
      a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let a;
      const o = s[1], l = s[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setRGB(
              Math.min(255, parseInt(a[1], 10)) / 255,
              Math.min(255, parseInt(a[2], 10)) / 255,
              Math.min(255, parseInt(a[3], 10)) / 255,
              i
            );
          if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setRGB(
              Math.min(100, parseInt(a[1], 10)) / 100,
              Math.min(100, parseInt(a[2], 10)) / 100,
              Math.min(100, parseInt(a[3], 10)) / 100,
              i
            );
          break;
        case "hsl":
        case "hsla":
          if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setHSL(
              parseFloat(a[1]) / 360,
              parseFloat(a[2]) / 100,
              parseFloat(a[3]) / 100,
              i
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const a = s[1], o = a.length;
      if (o === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          i
        );
      if (o === 6)
        return this.setHex(parseInt(a, 16), i);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, i);
    return this;
  }
  setColorName(e, i = ht) {
    const n = lP[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, i) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = va(e.r), this.g = va(e.g), this.b = va(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Zu(e.r), this.g = Zu(e.g), this.b = Zu(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = ht) {
    return ki.fromWorkingColorSpace(hr.copy(this), e), Math.round(er(hr.r * 255, 0, 255)) * 65536 + Math.round(er(hr.g * 255, 0, 255)) * 256 + Math.round(er(hr.b * 255, 0, 255));
  }
  getHexString(e = ht) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, i = ki.workingColorSpace) {
    ki.fromWorkingColorSpace(hr.copy(this), i);
    const n = hr.r, s = hr.g, a = hr.b, o = Math.max(n, s, a), l = Math.min(n, s, a);
    let u, c;
    const h = (l + o) / 2;
    if (l === o)
      u = 0, c = 0;
    else {
      const d = o - l;
      switch (c = h <= 0.5 ? d / (o + l) : d / (2 - o - l), o) {
        case n:
          u = (s - a) / d + (s < a ? 6 : 0);
          break;
        case s:
          u = (a - n) / d + 2;
          break;
        case a:
          u = (n - s) / d + 4;
          break;
      }
      u /= 6;
    }
    return e.h = u, e.s = c, e.l = h, e;
  }
  getRGB(e, i = ki.workingColorSpace) {
    return ki.fromWorkingColorSpace(hr.copy(this), i), e.r = hr.r, e.g = hr.g, e.b = hr.b, e;
  }
  getStyle(e = ht) {
    ki.fromWorkingColorSpace(hr.copy(this), e);
    const i = hr.r, n = hr.g, s = hr.b;
    return e !== ht ? `color(${e} ${i.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(i * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
  }
  offsetHSL(e, i, n) {
    return this.getHSL(Ha), this.setHSL(Ha.h + e, Ha.s + i, Ha.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, i) {
    return this.r = e.r + i.r, this.g = e.g + i.g, this.b = e.b + i.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, i) {
    return this.r += (e.r - this.r) * i, this.g += (e.g - this.g) * i, this.b += (e.b - this.b) * i, this;
  }
  lerpColors(e, i, n) {
    return this.r = e.r + (i.r - e.r) * n, this.g = e.g + (i.g - e.g) * n, this.b = e.b + (i.b - e.b) * n, this;
  }
  lerpHSL(e, i) {
    this.getHSL(Ha), e.getHSL(tf);
    const n = id(Ha.h, tf.h, i), s = id(Ha.s, tf.s, i), a = id(Ha.l, tf.l, i);
    return this.setHSL(n, s, a), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const i = this.r, n = this.g, s = this.b, a = e.elements;
    return this.r = a[0] * i + a[3] * n + a[6] * s, this.g = a[1] * i + a[4] * n + a[7] * s, this.b = a[2] * i + a[5] * n + a[8] * s, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, i = 0) {
    return this.r = e[i], this.g = e[i + 1], this.b = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.r, e[i + 1] = this.g, e[i + 2] = this.b, e;
  }
  fromBufferAttribute(e, i) {
    return this.r = e.getX(i), this.g = e.getY(i), this.b = e.getZ(i), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const hr = /* @__PURE__ */ new Kt();
Kt.NAMES = lP;
let H7 = 0;
class Wr extends Bc {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(e) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: H7++ }), this.uuid = ya(), this.name = "", this.blending = po, this.side = xc, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Om, this.blendDst = Im, this.blendEquation = io, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Kt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Dm, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = yx, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Wo, this.stencilZFail = Wo, this.stencilZPass = Wo, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const i in e) {
        const n = e[i];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${i}' has value of undefined.`);
          continue;
        }
        const s = this[i];
        if (s === void 0) {
          console.warn(`THREE.Material: '${i}' is not a property of THREE.${this.type}.`);
          continue;
        }
        s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[i] = n;
      }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    i && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== po && (n.blending = this.blending), this.side !== xc && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Om && (n.blendSrc = this.blendSrc), this.blendDst !== Im && (n.blendDst = this.blendDst), this.blendEquation !== io && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== Dm && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== yx && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Wo && (n.stencilFail = this.stencilFail), this.stencilZFail !== Wo && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Wo && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function s(a) {
      const o = [];
      for (const l in a) {
        const u = a[l];
        delete u.metadata, o.push(u);
      }
      return o;
    }
    if (i) {
      const a = s(e.textures), o = s(e.images);
      a.length > 0 && (n.textures = a), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const i = e.clippingPlanes;
    let n = null;
    if (i !== null) {
      const s = i.length;
      n = new Array(s);
      for (let a = 0; a !== s; ++a)
        n[a] = i[a].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class Rg extends Wr {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Kt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ts(), this.combine = Cg, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const ra = /* @__PURE__ */ W7();
function W7() {
  const r = new ArrayBuffer(4), e = new Float32Array(r), i = new Uint32Array(r), n = new Uint32Array(512), s = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    const c = u - 127;
    c < -27 ? (n[u] = 0, n[u | 256] = 32768, s[u] = 24, s[u | 256] = 24) : c < -14 ? (n[u] = 1024 >> -c - 14, n[u | 256] = 1024 >> -c - 14 | 32768, s[u] = -c - 1, s[u | 256] = -c - 1) : c <= 15 ? (n[u] = c + 15 << 10, n[u | 256] = c + 15 << 10 | 32768, s[u] = 13, s[u | 256] = 13) : c < 128 ? (n[u] = 31744, n[u | 256] = 64512, s[u] = 24, s[u | 256] = 24) : (n[u] = 31744, n[u | 256] = 64512, s[u] = 13, s[u | 256] = 13);
  }
  const a = new Uint32Array(2048), o = new Uint32Array(64), l = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let c = u << 13, h = 0;
    for (; !(c & 8388608); )
      c <<= 1, h -= 8388608;
    c &= -8388609, h += 947912704, a[u] = c | h;
  }
  for (let u = 1024; u < 2048; ++u)
    a[u] = 939524096 + (u - 1024 << 13);
  for (let u = 1; u < 31; ++u)
    o[u] = u << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let u = 33; u < 63; ++u)
    o[u] = 2147483648 + (u - 32 << 23);
  o[63] = 3347054592;
  for (let u = 1; u < 64; ++u)
    u !== 32 && (l[u] = 1024);
  return {
    floatView: e,
    uint32View: i,
    baseTable: n,
    shiftTable: s,
    mantissaTable: a,
    exponentTable: o,
    offsetTable: l
  };
}
function tn(r) {
  Math.abs(r) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), r = er(r, -65504, 65504), ra.floatView[0] = r;
  const e = ra.uint32View[0], i = e >> 23 & 511;
  return ra.baseTable[i] + ((e & 8388607) >> ra.shiftTable[i]);
}
function rf(r) {
  const e = r >> 10;
  return ra.uint32View[0] = ra.mantissaTable[ra.offsetTable[e] + (r & 1023)] + ra.exponentTable[e], ra.floatView[0];
}
const Oi = /* @__PURE__ */ new oe(), nf = /* @__PURE__ */ new jt();
class En {
  constructor(e, i, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = i, this.count = e !== void 0 ? e.length / i : 0, this.normalized = n, this.usage = Um, this.updateRanges = [], this.gpuType = cn, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, i) {
    this.updateRanges.push({ start: e, count: i });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, i, n) {
    e *= this.itemSize, n *= i.itemSize;
    for (let s = 0, a = this.itemSize; s < a; s++)
      this.array[e + s] = i.array[n + s];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let i = 0, n = this.count; i < n; i++)
        nf.fromBufferAttribute(this, i), nf.applyMatrix3(e), this.setXY(i, nf.x, nf.y);
    else if (this.itemSize === 3)
      for (let i = 0, n = this.count; i < n; i++)
        Oi.fromBufferAttribute(this, i), Oi.applyMatrix3(e), this.setXYZ(i, Oi.x, Oi.y, Oi.z);
    return this;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Oi.fromBufferAttribute(this, i), Oi.applyMatrix4(e), this.setXYZ(i, Oi.x, Oi.y, Oi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Oi.fromBufferAttribute(this, i), Oi.applyNormalMatrix(e), this.setXYZ(i, Oi.x, Oi.y, Oi.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Oi.fromBufferAttribute(this, i), Oi.transformDirection(e), this.setXYZ(i, Oi.x, Oi.y, Oi.z);
    return this;
  }
  set(e, i = 0) {
    return this.array.set(e, i), this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.itemSize + i];
    return this.normalized && (n = Er(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = Et(n, this.array)), this.array[e * this.itemSize + i] = n, this;
  }
  getX(e) {
    let i = this.array[e * this.itemSize];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setX(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.array[e * this.itemSize] = i, this;
  }
  getY(e) {
    let i = this.array[e * this.itemSize + 1];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setY(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.array[e * this.itemSize + 1] = i, this;
  }
  getZ(e) {
    let i = this.array[e * this.itemSize + 2];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setZ(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.array[e * this.itemSize + 2] = i, this;
  }
  getW(e) {
    let i = this.array[e * this.itemSize + 3];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setW(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.array[e * this.itemSize + 3] = i, this;
  }
  setXY(e, i, n) {
    return e *= this.itemSize, this.normalized && (i = Et(i, this.array), n = Et(n, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e *= this.itemSize, this.normalized && (i = Et(i, this.array), n = Et(n, this.array), s = Et(s, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e *= this.itemSize, this.normalized && (i = Et(i, this.array), n = Et(n, this.array), s = Et(s, this.array), a = Et(a, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this.array[e + 2] = s, this.array[e + 3] = a, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Um && (e.usage = this.usage), e;
  }
}
class uP extends En {
  constructor(e, i, n) {
    super(new Uint16Array(e), i, n);
  }
}
class cP extends En {
  constructor(e, i, n) {
    super(new Uint32Array(e), i, n);
  }
}
class hP extends En {
  constructor(e, i, n) {
    super(new Uint16Array(e), i, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let i = rf(this.array[e * this.itemSize]);
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setX(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.array[e * this.itemSize] = tn(i), this;
  }
  getY(e) {
    let i = rf(this.array[e * this.itemSize + 1]);
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setY(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.array[e * this.itemSize + 1] = tn(i), this;
  }
  getZ(e) {
    let i = rf(this.array[e * this.itemSize + 2]);
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setZ(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.array[e * this.itemSize + 2] = tn(i), this;
  }
  getW(e) {
    let i = rf(this.array[e * this.itemSize + 3]);
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setW(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.array[e * this.itemSize + 3] = tn(i), this;
  }
  setXY(e, i, n) {
    return e *= this.itemSize, this.normalized && (i = Et(i, this.array), n = Et(n, this.array)), this.array[e + 0] = tn(i), this.array[e + 1] = tn(n), this;
  }
  setXYZ(e, i, n, s) {
    return e *= this.itemSize, this.normalized && (i = Et(i, this.array), n = Et(n, this.array), s = Et(s, this.array)), this.array[e + 0] = tn(i), this.array[e + 1] = tn(n), this.array[e + 2] = tn(s), this;
  }
  setXYZW(e, i, n, s, a) {
    return e *= this.itemSize, this.normalized && (i = Et(i, this.array), n = Et(n, this.array), s = Et(s, this.array), a = Et(a, this.array)), this.array[e + 0] = tn(i), this.array[e + 1] = tn(n), this.array[e + 2] = tn(s), this.array[e + 3] = tn(a), this;
  }
}
class ba extends En {
  constructor(e, i, n) {
    super(new Float32Array(e), i, n);
  }
}
let q7 = 0;
const gn = /* @__PURE__ */ new gi(), O0 = /* @__PURE__ */ new Ki(), vu = /* @__PURE__ */ new oe(), rn = /* @__PURE__ */ new Qd(), bh = /* @__PURE__ */ new Qd(), qi = /* @__PURE__ */ new oe();
class Dl extends Bc {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: q7++ }), this.uuid = ya(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (A7(e) ? cP : uP)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, i) {
    return this.attributes[e] = i, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, i, n = 0) {
    this.groups.push({
      start: e,
      count: i,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, i) {
    this.drawRange.start = e, this.drawRange.count = i;
  }
  applyMatrix4(e) {
    const i = this.attributes.position;
    i !== void 0 && (i.applyMatrix4(e), i.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const a = new Yr().getNormalMatrix(e);
      n.applyNormalMatrix(a), n.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return gn.makeRotationFromQuaternion(e), this.applyMatrix4(gn), this;
  }
  rotateX(e) {
    return gn.makeRotationX(e), this.applyMatrix4(gn), this;
  }
  rotateY(e) {
    return gn.makeRotationY(e), this.applyMatrix4(gn), this;
  }
  rotateZ(e) {
    return gn.makeRotationZ(e), this.applyMatrix4(gn), this;
  }
  translate(e, i, n) {
    return gn.makeTranslation(e, i, n), this.applyMatrix4(gn), this;
  }
  scale(e, i, n) {
    return gn.makeScale(e, i, n), this.applyMatrix4(gn), this;
  }
  lookAt(e) {
    return O0.lookAt(e), O0.updateMatrix(), this.applyMatrix4(O0.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(vu).negate(), this.translate(vu.x, vu.y, vu.z), this;
  }
  setFromPoints(e) {
    const i = this.getAttribute("position");
    if (i === void 0) {
      const n = [];
      for (let s = 0, a = e.length; s < a; s++) {
        const o = e[s];
        n.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new ba(n, 3));
    } else {
      for (let n = 0, s = i.count; n < s; n++) {
        const a = e[n];
        i.setXYZ(n, a.x, a.y, a.z || 0);
      }
      e.length > i.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), i.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Qd());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new oe(-1 / 0, -1 / 0, -1 / 0),
        new oe(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), i)
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n];
          rn.setFromBufferAttribute(a), this.morphTargetsRelative ? (qi.addVectors(this.boundingBox.min, rn.min), this.boundingBox.expandByPoint(qi), qi.addVectors(this.boundingBox.max, rn.max), this.boundingBox.expandByPoint(qi)) : (this.boundingBox.expandByPoint(rn.min), this.boundingBox.expandByPoint(rn.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new hT());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new oe(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (rn.setFromBufferAttribute(e), i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a];
          bh.setFromBufferAttribute(l), this.morphTargetsRelative ? (qi.addVectors(rn.min, bh.min), rn.expandByPoint(qi), qi.addVectors(rn.max, bh.max), rn.expandByPoint(qi)) : (rn.expandByPoint(bh.min), rn.expandByPoint(bh.max));
        }
      rn.getCenter(n);
      let s = 0;
      for (let a = 0, o = e.count; a < o; a++)
        qi.fromBufferAttribute(e, a), s = Math.max(s, n.distanceToSquared(qi));
      if (i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a], u = this.morphTargetsRelative;
          for (let c = 0, h = l.count; c < h; c++)
            qi.fromBufferAttribute(l, c), u && (vu.fromBufferAttribute(e, c), qi.add(vu)), s = Math.max(s, n.distanceToSquared(qi));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, i = this.attributes;
    if (e === null || i.position === void 0 || i.normal === void 0 || i.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = i.position, s = i.normal, a = i.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new En(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"), l = [], u = [];
    for (let C = 0; C < n.count; C++)
      l[C] = new oe(), u[C] = new oe();
    const c = new oe(), h = new oe(), d = new oe(), p = new jt(), f = new jt(), m = new jt(), v = new oe(), y = new oe();
    function g(C, E, A) {
      c.fromBufferAttribute(n, C), h.fromBufferAttribute(n, E), d.fromBufferAttribute(n, A), p.fromBufferAttribute(a, C), f.fromBufferAttribute(a, E), m.fromBufferAttribute(a, A), h.sub(c), d.sub(c), f.sub(p), m.sub(p);
      const N = 1 / (f.x * m.y - m.x * f.y);
      isFinite(N) && (v.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(N), y.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(N), l[C].add(v), l[E].add(v), l[A].add(v), u[C].add(y), u[E].add(y), u[A].add(y));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{
      start: 0,
      count: e.count
    }]);
    for (let C = 0, E = _.length; C < E; ++C) {
      const A = _[C], N = A.start, L = A.count;
      for (let F = N, M = N + L; F < M; F += 3)
        g(
          e.getX(F + 0),
          e.getX(F + 1),
          e.getX(F + 2)
        );
    }
    const x = new oe(), b = new oe(), T = new oe(), S = new oe();
    function w(C) {
      T.fromBufferAttribute(s, C), S.copy(T);
      const E = l[C];
      x.copy(E), x.sub(T.multiplyScalar(T.dot(E))).normalize(), b.crossVectors(S, E);
      const A = b.dot(u[C]) < 0 ? -1 : 1;
      o.setXYZW(C, x.x, x.y, x.z, A);
    }
    for (let C = 0, E = _.length; C < E; ++C) {
      const A = _[C], N = A.start, L = A.count;
      for (let F = N, M = N + L; F < M; F += 3)
        w(e.getX(F + 0)), w(e.getX(F + 1)), w(e.getX(F + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, i = this.getAttribute("position");
    if (i !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new En(new Float32Array(i.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let p = 0, f = n.count; p < f; p++)
          n.setXYZ(p, 0, 0, 0);
      const s = new oe(), a = new oe(), o = new oe(), l = new oe(), u = new oe(), c = new oe(), h = new oe(), d = new oe();
      if (e)
        for (let p = 0, f = e.count; p < f; p += 3) {
          const m = e.getX(p + 0), v = e.getX(p + 1), y = e.getX(p + 2);
          s.fromBufferAttribute(i, m), a.fromBufferAttribute(i, v), o.fromBufferAttribute(i, y), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, v), c.fromBufferAttribute(n, y), l.add(h), u.add(h), c.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(v, u.x, u.y, u.z), n.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let p = 0, f = i.count; p < f; p += 3)
          s.fromBufferAttribute(i, p + 0), a.fromBufferAttribute(i, p + 1), o.fromBufferAttribute(i, p + 2), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), n.setXYZ(p + 0, h.x, h.y, h.z), n.setXYZ(p + 1, h.x, h.y, h.z), n.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let i = 0, n = e.count; i < n; i++)
      qi.fromBufferAttribute(e, i), qi.normalize(), e.setXYZ(i, qi.x, qi.y, qi.z);
  }
  toNonIndexed() {
    function e(l, u) {
      const c = l.array, h = l.itemSize, d = l.normalized, p = new c.constructor(u.length * h);
      let f = 0, m = 0;
      for (let v = 0, y = u.length; v < y; v++) {
        l.isInterleavedBufferAttribute ? f = u[v] * l.data.stride + l.offset : f = u[v] * h;
        for (let g = 0; g < h; g++)
          p[m++] = c[f++];
      }
      return new En(p, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const i = new Dl(), n = this.index.array, s = this.attributes;
    for (const l in s) {
      const u = s[l], c = e(u, n);
      i.setAttribute(l, c);
    }
    const a = this.morphAttributes;
    for (const l in a) {
      const u = [], c = a[l];
      for (let h = 0, d = c.length; h < d; h++) {
        const p = c[h], f = e(p, n);
        u.push(f);
      }
      i.morphAttributes[l] = u;
    }
    i.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const c = o[l];
      i.addGroup(c.start, c.count, c.materialIndex);
    }
    return i;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const u = this.parameters;
      for (const c in u)
        u[c] !== void 0 && (e[c] = u[c]);
      return e;
    }
    e.data = { attributes: {} };
    const i = this.index;
    i !== null && (e.data.index = {
      type: i.array.constructor.name,
      array: Array.prototype.slice.call(i.array)
    });
    const n = this.attributes;
    for (const u in n) {
      const c = n[u];
      e.data.attributes[u] = c.toJSON(e.data);
    }
    const s = {};
    let a = !1;
    for (const u in this.morphAttributes) {
      const c = this.morphAttributes[u], h = [];
      for (let d = 0, p = c.length; d < p; d++) {
        const f = c[d];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (s[u] = h, a = !0);
    }
    a && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const i = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(i));
    const s = e.attributes;
    for (const c in s) {
      const h = s[c];
      this.setAttribute(c, h.clone(i));
    }
    const a = e.morphAttributes;
    for (const c in a) {
      const h = [], d = a[c];
      for (let p = 0, f = d.length; p < f; p++)
        h.push(d[p].clone(i));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = e.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const WE = /* @__PURE__ */ new gi(), Bo = /* @__PURE__ */ new L7(), sf = /* @__PURE__ */ new hT(), qE = /* @__PURE__ */ new oe(), af = /* @__PURE__ */ new oe(), of = /* @__PURE__ */ new oe(), lf = /* @__PURE__ */ new oe(), I0 = /* @__PURE__ */ new oe(), uf = /* @__PURE__ */ new oe(), XE = /* @__PURE__ */ new oe(), cf = /* @__PURE__ */ new oe();
class Al extends Ki {
  constructor(e = new Dl(), i = new Rg()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = i, this.updateMorphTargets();
  }
  copy(e, i) {
    return super.copy(e, i), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, i = Object.keys(e);
    if (i.length > 0) {
      const n = e[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
        }
      }
    }
  }
  getVertexPosition(e, i) {
    const n = this.geometry, s = n.attributes.position, a = n.morphAttributes.position, o = n.morphTargetsRelative;
    i.fromBufferAttribute(s, e);
    const l = this.morphTargetInfluences;
    if (a && l) {
      uf.set(0, 0, 0);
      for (let u = 0, c = a.length; u < c; u++) {
        const h = l[u], d = a[u];
        h !== 0 && (I0.fromBufferAttribute(d, e), o ? uf.addScaledVector(I0, h) : uf.addScaledVector(I0.sub(i), h));
      }
      i.add(uf);
    }
    return i;
  }
  raycast(e, i) {
    const n = this.geometry, s = this.material, a = this.matrixWorld;
    s !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), sf.copy(n.boundingSphere), sf.applyMatrix4(a), Bo.copy(e.ray).recast(e.near), !(sf.containsPoint(Bo.origin) === !1 && (Bo.intersectSphere(sf, qE) === null || Bo.origin.distanceToSquared(qE) > (e.far - e.near) ** 2)) && (WE.copy(a).invert(), Bo.copy(e.ray).applyMatrix4(WE), !(n.boundingBox !== null && Bo.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, i, Bo)));
  }
  _computeIntersections(e, i, n) {
    let s;
    const a = this.geometry, o = this.material, l = a.index, u = a.attributes.position, c = a.attributes.uv, h = a.attributes.uv1, d = a.attributes.normal, p = a.groups, f = a.drawRange;
    if (l !== null)
      if (Array.isArray(o))
        for (let m = 0, v = p.length; m < v; m++) {
          const y = p[m], g = o[y.materialIndex], _ = Math.max(y.start, f.start), x = Math.min(l.count, Math.min(y.start + y.count, f.start + f.count));
          for (let b = _, T = x; b < T; b += 3) {
            const S = l.getX(b), w = l.getX(b + 1), C = l.getX(b + 2);
            s = hf(this, g, e, n, c, h, d, S, w, C), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = y.materialIndex, i.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), v = Math.min(l.count, f.start + f.count);
        for (let y = m, g = v; y < g; y += 3) {
          const _ = l.getX(y), x = l.getX(y + 1), b = l.getX(y + 2);
          s = hf(this, o, e, n, c, h, d, _, x, b), s && (s.faceIndex = Math.floor(y / 3), i.push(s));
        }
      }
    else if (u !== void 0)
      if (Array.isArray(o))
        for (let m = 0, v = p.length; m < v; m++) {
          const y = p[m], g = o[y.materialIndex], _ = Math.max(y.start, f.start), x = Math.min(u.count, Math.min(y.start + y.count, f.start + f.count));
          for (let b = _, T = x; b < T; b += 3) {
            const S = b, w = b + 1, C = b + 2;
            s = hf(this, g, e, n, c, h, d, S, w, C), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = y.materialIndex, i.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), v = Math.min(u.count, f.start + f.count);
        for (let y = m, g = v; y < g; y += 3) {
          const _ = y, x = y + 1, b = y + 2;
          s = hf(this, o, e, n, c, h, d, _, x, b), s && (s.faceIndex = Math.floor(y / 3), i.push(s));
        }
      }
  }
}
function X7(r, e, i, n, s, a, o, l) {
  let u;
  if (e.side === es ? u = n.intersectTriangle(o, a, s, !0, l) : u = n.intersectTriangle(s, a, o, e.side === xc, l), u === null) return null;
  cf.copy(l), cf.applyMatrix4(r.matrixWorld);
  const c = i.ray.origin.distanceTo(cf);
  return c < i.near || c > i.far ? null : {
    distance: c,
    point: cf.clone(),
    object: r
  };
}
function hf(r, e, i, n, s, a, o, l, u, c) {
  r.getVertexPosition(l, af), r.getVertexPosition(u, of), r.getVertexPosition(c, lf);
  const h = X7(r, e, i, n, af, of, lf, XE);
  if (h) {
    const d = new oe();
    $n.getBarycoord(XE, af, of, lf, d), s && (h.uv = $n.getInterpolatedAttribute(s, l, u, c, d, new jt())), a && (h.uv1 = $n.getInterpolatedAttribute(a, l, u, c, d, new jt())), o && (h.normal = $n.getInterpolatedAttribute(o, l, u, c, d, new oe()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const p = {
      a: l,
      b: u,
      c,
      normal: new oe(),
      materialIndex: 0
    };
    $n.getNormal(af, of, lf, p.normal), h.face = p, h.barycoord = d;
  }
  return h;
}
class Zd extends Dl {
  constructor(e = 1, i = 1, n = 1, s = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: i,
      depth: n,
      widthSegments: s,
      heightSegments: a,
      depthSegments: o
    };
    const l = this;
    s = Math.floor(s), a = Math.floor(a), o = Math.floor(o);
    const u = [], c = [], h = [], d = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, n, i, e, o, a, 0), m("z", "y", "x", 1, -1, n, i, -e, o, a, 1), m("x", "z", "y", 1, 1, e, n, i, s, o, 2), m("x", "z", "y", 1, -1, e, n, -i, s, o, 3), m("x", "y", "z", 1, -1, e, i, n, s, a, 4), m("x", "y", "z", -1, -1, e, i, -n, s, a, 5), this.setIndex(u), this.setAttribute("position", new ba(c, 3)), this.setAttribute("normal", new ba(h, 3)), this.setAttribute("uv", new ba(d, 2));
    function m(v, y, g, _, x, b, T, S, w, C, E) {
      const A = b / w, N = T / C, L = b / 2, F = T / 2, M = S / 2, P = w + 1, O = C + 1;
      let V = 0, B = 0;
      const H = new oe();
      for (let U = 0; U < O; U++) {
        const j = U * N - F;
        for (let Q = 0; Q < P; Q++) {
          const q = Q * A - L;
          H[v] = q * _, H[y] = j * x, H[g] = M, c.push(H.x, H.y, H.z), H[v] = 0, H[y] = 0, H[g] = S > 0 ? 1 : -1, h.push(H.x, H.y, H.z), d.push(Q / w), d.push(1 - U / C), V += 1;
        }
      }
      for (let U = 0; U < C; U++)
        for (let j = 0; j < w; j++) {
          const Q = p + j + P * U, q = p + j + P * (U + 1), G = p + (j + 1) + P * (U + 1), Y = p + (j + 1) + P * U;
          u.push(Q, q, Y), u.push(q, G, Y), B += 6;
        }
      l.addGroup(f, B, E), f += B, p += V;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Zd(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function dP(r) {
  const e = {};
  for (const i in r) {
    e[i] = {};
    for (const n in r[i]) {
      const s = r[i][n];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][n] = null) : e[i][n] = s.clone() : Array.isArray(s) ? e[i][n] = s.slice() : e[i][n] = s;
    }
  }
  return e;
}
function Y7(r) {
  const e = [];
  for (let i = 0; i < r.length; i++)
    e.push(r[i].clone());
  return e;
}
var $7 = (
  /* glsl */
  `
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`
), K7 = (
  /* glsl */
  `
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`
);
class Q7 extends Wr {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = $7, this.fragmentShader = K7, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = dP(e.uniforms), this.uniformsGroups = Y7(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    i.glslVersion = this.glslVersion, i.uniforms = {};
    for (const s in this.uniforms) {
      const a = this.uniforms[s].value;
      a && a.isTexture ? i.uniforms[s] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? i.uniforms[s] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? i.uniforms[s] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? i.uniforms[s] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? i.uniforms[s] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? i.uniforms[s] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? i.uniforms[s] = {
        type: "m4",
        value: a.toArray()
      } : i.uniforms[s] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (i.defines = this.defines), i.vertexShader = this.vertexShader, i.fragmentShader = this.fragmentShader, i.lights = this.lights, i.clipping = this.clipping;
    const n = {};
    for (const s in this.extensions)
      this.extensions[s] === !0 && (n[s] = !0);
    return Object.keys(n).length > 0 && (i.extensions = n), i;
  }
}
class pP extends Ki {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new gi(), this.projectionMatrix = new gi(), this.projectionMatrixInverse = new gi(), this.coordinateSystem = Zn;
  }
  copy(e, i) {
    return super.copy(e, i), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, i) {
    super.updateWorldMatrix(e, i), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Wa = /* @__PURE__ */ new oe(), YE = /* @__PURE__ */ new jt(), $E = /* @__PURE__ */ new jt();
class Qs extends pP {
  constructor(e = 50, i = 1, n = 0.1, s = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = s, this.focus = 10, this.aspect = i, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, i) {
    return super.copy(e, i), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const i = 0.5 * this.getFilmHeight() / e;
    this.fov = bd * 2 * Math.atan(i), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(td * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return bd * 2 * Math.atan(
      Math.tan(td * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, i, n) {
    Wa.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Wa.x, Wa.y).multiplyScalar(-e / Wa.z), Wa.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Wa.x, Wa.y).multiplyScalar(-e / Wa.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, i) {
    return this.getViewBounds(e, YE, $E), i.subVectors($E, YE);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, i, n, s, a, o) {
    this.aspect = e / i, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = i, this.view.offsetX = n, this.view.offsetY = s, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let i = e * Math.tan(td * 0.5 * this.fov) / this.zoom, n = 2 * i, s = this.aspect * n, a = -0.5 * s;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = o.fullWidth, c = o.fullHeight;
      a += o.offsetX * s / u, i -= o.offsetY * n / c, s *= o.width / u, n *= o.height / c;
    }
    const l = this.filmOffset;
    l !== 0 && (a += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + s, i, i - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.fov = this.fov, i.object.zoom = this.zoom, i.object.near = this.near, i.object.far = this.far, i.object.focus = this.focus, i.object.aspect = this.aspect, this.view !== null && (i.object.view = Object.assign({}, this.view)), i.object.filmGauge = this.filmGauge, i.object.filmOffset = this.filmOffset, i;
  }
}
const bu = -90, xu = 1;
class fP extends Ki {
  constructor(e, i, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const s = new Qs(bu, xu, e, i);
    s.layers = this.layers, this.add(s);
    const a = new Qs(bu, xu, e, i);
    a.layers = this.layers, this.add(a);
    const o = new Qs(bu, xu, e, i);
    o.layers = this.layers, this.add(o);
    const l = new Qs(bu, xu, e, i);
    l.layers = this.layers, this.add(l);
    const u = new Qs(bu, xu, e, i);
    u.layers = this.layers, this.add(u);
    const c = new Qs(bu, xu, e, i);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, i = this.children.concat(), [n, s, a, o, l, u] = i;
    for (const c of i) this.remove(c);
    if (e === Zn)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), a.up.set(0, 0, -1), a.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), u.up.set(0, 1, 0), u.lookAt(0, 0, -1);
    else if (e === Ml)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), a.up.set(0, 0, 1), a.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), u.up.set(0, -1, 0), u.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const c of i)
      this.add(c), c.updateMatrixWorld();
  }
  update(e, i) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: s } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [a, o, l, u, c, h] = this.children, d = e.getRenderTarget(), p = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = !1;
    const v = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, s), e.render(i, a), e.setRenderTarget(n, 1, s), e.render(i, o), e.setRenderTarget(n, 2, s), e.render(i, l), e.setRenderTarget(n, 3, s), e.render(i, u), e.setRenderTarget(n, 4, s), e.render(i, c), n.texture.generateMipmaps = v, e.setRenderTarget(n, 5, s), e.render(i, h), e.setRenderTarget(d, p, f), e.xr.enabled = m, n.texture.needsPMREMUpdate = !0;
  }
}
class dT extends Ar {
  constructor(e, i, n, s, a, o, l, u, c, h) {
    e = e !== void 0 ? e : [], i = i !== void 0 ? i : wl, super(e, i, n, s, a, o, l, u, c, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Z7 extends I7 {
  constructor(e = 1, i = {}) {
    super(e, e, i), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, s = [n, n, n, n, n, n];
    this.texture = new dT(s, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : hn;
  }
  fromEquirectangularTexture(e, i) {
    this.texture.type = i.type, this.texture.colorSpace = i.colorSpace, this.texture.generateMipmaps = i.generateMipmaps, this.texture.minFilter = i.minFilter, this.texture.magFilter = i.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, s = new Zd(5, 5, 5), a = new Q7({
      name: "CubemapFromEquirect",
      uniforms: dP(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: es,
      blending: _c
    });
    a.uniforms.tEquirect.value = i;
    const o = new Al(s, a), l = i.minFilter;
    return i.minFilter === ma && (i.minFilter = hn), new fP(1, 10, this).update(e, o), i.minFilter = l, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, i, n, s) {
    const a = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(i, n, s);
    e.setRenderTarget(a);
  }
}
class mP extends Ki {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new ts(), this.environmentIntensity = 1, this.environmentRotation = new ts(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, i) {
    return super.copy(e, i), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return this.fog !== null && (i.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (i.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (i.object.backgroundIntensity = this.backgroundIntensity), i.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (i.object.environmentIntensity = this.environmentIntensity), i.object.environmentRotation = this.environmentRotation.toArray(), i;
  }
}
class gP {
  constructor(e, i) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = i, this.count = e !== void 0 ? e.length / i : 0, this.usage = Um, this.updateRanges = [], this.version = 0, this.uuid = ya();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, i) {
    this.updateRanges.push({ start: e, count: i });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, i, n) {
    e *= this.stride, n *= i.stride;
    for (let s = 0, a = this.stride; s < a; s++)
      this.array[e + s] = i.array[n + s];
    return this;
  }
  set(e, i = 0) {
    return this.array.set(e, i), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ya()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const i = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(i, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ya()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const br = /* @__PURE__ */ new oe();
class pT {
  constructor(e, i, n, s = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = i, this.offset = n, this.normalized = s;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.data.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.applyMatrix4(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.applyNormalMatrix(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.transformDirection(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.data.stride + this.offset + i];
    return this.normalized && (n = Er(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = Et(n, this.array)), this.data.array[e * this.data.stride + this.offset + i] = n, this;
  }
  setX(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.data.array[e * this.data.stride + this.offset] = i, this;
  }
  setY(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = i, this;
  }
  setZ(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = i, this;
  }
  setW(e, i) {
    return this.normalized && (i = Et(i, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = i, this;
  }
  getX(e) {
    let i = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  getY(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  getZ(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  getW(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (i = Er(i, this.array)), i;
  }
  setXY(e, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Et(i, this.array), n = Et(n, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Et(i, this.array), n = Et(n, this.array), s = Et(s, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Et(i, this.array), n = Et(n, this.array), s = Et(s, this.array), a = Et(a, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = a, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return new En(new this.array.constructor(i), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new pT(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: i,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class yP extends Wr {
  static get type() {
    return "SpriteMaterial";
  }
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.color = new Kt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
class J7 extends Ar {
  constructor(e = null, i = 1, n = 1, s, a, o, l, u, c = mr, h = mr, d, p) {
    super(null, o, l, u, c, h, s, a, d, p), this.isDataTexture = !0, this.image = { data: e, width: i, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class eW extends En {
  constructor(e, i, n, s = 1) {
    super(e, i, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const D0 = /* @__PURE__ */ new oe(), tW = /* @__PURE__ */ new oe(), iW = /* @__PURE__ */ new Yr();
class Ja {
  constructor(e = new oe(1, 0, 0), i = 0) {
    this.isPlane = !0, this.normal = e, this.constant = i;
  }
  set(e, i) {
    return this.normal.copy(e), this.constant = i, this;
  }
  setComponents(e, i, n, s) {
    return this.normal.set(e, i, n), this.constant = s, this;
  }
  setFromNormalAndCoplanarPoint(e, i) {
    return this.normal.copy(e), this.constant = -i.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, i, n) {
    const s = D0.subVectors(n, i).cross(tW.subVectors(e, i)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, i) {
    return i.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, i) {
    const n = e.delta(D0), s = this.normal.dot(n);
    if (s === 0)
      return this.distanceToPoint(e.start) === 0 ? i.copy(e.start) : null;
    const a = -(e.start.dot(this.normal) + this.constant) / s;
    return a < 0 || a > 1 ? null : i.copy(e.start).addScaledVector(n, a);
  }
  intersectsLine(e) {
    const i = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return i < 0 && n > 0 || n < 0 && i > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, i) {
    const n = i || iW.getNormalMatrix(e), s = this.coplanarPoint(D0).applyMatrix4(e), a = this.normal.applyMatrix3(n).normalize();
    return this.constant = -s.dot(a), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const zo = /* @__PURE__ */ new hT(), df = /* @__PURE__ */ new oe();
class vP {
  constructor(e = new Ja(), i = new Ja(), n = new Ja(), s = new Ja(), a = new Ja(), o = new Ja()) {
    this.planes = [e, i, n, s, a, o];
  }
  set(e, i, n, s, a, o) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(i), l[2].copy(n), l[3].copy(s), l[4].copy(a), l[5].copy(o), this;
  }
  copy(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++)
      i[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, i = Zn) {
    const n = this.planes, s = e.elements, a = s[0], o = s[1], l = s[2], u = s[3], c = s[4], h = s[5], d = s[6], p = s[7], f = s[8], m = s[9], v = s[10], y = s[11], g = s[12], _ = s[13], x = s[14], b = s[15];
    if (n[0].setComponents(u - a, p - c, y - f, b - g).normalize(), n[1].setComponents(u + a, p + c, y + f, b + g).normalize(), n[2].setComponents(u + o, p + h, y + m, b + _).normalize(), n[3].setComponents(u - o, p - h, y - m, b - _).normalize(), n[4].setComponents(u - l, p - d, y - v, b - x).normalize(), i === Zn)
      n[5].setComponents(u + l, p + d, y + v, b + x).normalize();
    else if (i === Ml)
      n[5].setComponents(l, d, v, x).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + i);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), zo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const i = e.geometry;
      i.boundingSphere === null && i.computeBoundingSphere(), zo.copy(i.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(zo);
  }
  intersectsSprite(e) {
    return zo.center.set(0, 0, 0), zo.radius = 0.7071067811865476, zo.applyMatrix4(e.matrixWorld), this.intersectsSphere(zo);
  }
  intersectsSphere(e) {
    const i = this.planes, n = e.center, s = -e.radius;
    for (let a = 0; a < 6; a++)
      if (i[a].distanceToPoint(n) < s)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++) {
      const s = i[n];
      if (df.x = s.normal.x > 0 ? e.max.x : e.min.x, df.y = s.normal.y > 0 ? e.max.y : e.min.y, df.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(df) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++)
      if (i[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class fT extends Wr {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.color = new Kt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
class bP extends Wr {
  static get type() {
    return "PointsMaterial";
  }
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.color = new Kt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
class rW extends Ar {
  constructor(e, i) {
    super({ width: e, height: i }), this.isFramebufferTexture = !0, this.magFilter = mr, this.minFilter = mr, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class jc extends Ar {
  constructor(e, i, n, s, a, o, l, u, c, h = vl) {
    if (h !== vl && h !== Sc)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && h === vl && (n = Ji), n === void 0 && h === Sc && (n = $d), super(null, s, a, o, l, u, h, n, c), this.isDepthTexture = !0, this.image = { width: e, height: i }, this.magFilter = l !== void 0 ? l : mr, this.minFilter = u !== void 0 ? u : mr, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return this.compareFunction !== null && (i.compareFunction = this.compareFunction), i;
  }
}
class mT extends Dl {
  constructor(e = 1, i = 32, n = 16, s = 0, a = Math.PI * 2, o = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: i,
      heightSegments: n,
      phiStart: s,
      phiLength: a,
      thetaStart: o,
      thetaLength: l
    }, i = Math.max(3, Math.floor(i)), n = Math.max(2, Math.floor(n));
    const u = Math.min(o + l, Math.PI);
    let c = 0;
    const h = [], d = new oe(), p = new oe(), f = [], m = [], v = [], y = [];
    for (let g = 0; g <= n; g++) {
      const _ = [], x = g / n;
      let b = 0;
      g === 0 && o === 0 ? b = 0.5 / i : g === n && u === Math.PI && (b = -0.5 / i);
      for (let T = 0; T <= i; T++) {
        const S = T / i;
        d.x = -e * Math.cos(s + S * a) * Math.sin(o + x * l), d.y = e * Math.cos(o + x * l), d.z = e * Math.sin(s + S * a) * Math.sin(o + x * l), m.push(d.x, d.y, d.z), p.copy(d).normalize(), v.push(p.x, p.y, p.z), y.push(S + b, 1 - x), _.push(c++);
      }
      h.push(_);
    }
    for (let g = 0; g < n; g++)
      for (let _ = 0; _ < i; _++) {
        const x = h[g][_ + 1], b = h[g][_], T = h[g + 1][_], S = h[g + 1][_ + 1];
        (g !== 0 || o > 0) && f.push(x, b, S), (g !== n - 1 || u < Math.PI) && f.push(b, T, S);
      }
    this.setIndex(f), this.setAttribute("position", new ba(m, 3)), this.setAttribute("normal", new ba(v, 3)), this.setAttribute("uv", new ba(y, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new mT(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class xP extends Wr {
  static get type() {
    return "ShadowMaterial";
  }
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.color = new Kt(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class gT extends Wr {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.color = new Kt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ts(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class _P extends gT {
  static get type() {
    return "MeshPhysicalMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new jt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return er(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(i) {
        this.ior = (1 + 0.4 * i) / (1 - 0.4 * i);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Kt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Kt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Kt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class TP extends Wr {
  static get type() {
    return "MeshPhongMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.color = new Kt(16777215), this.specular = new Kt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ts(), this.combine = Cg, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class SP extends Wr {
  static get type() {
    return "MeshToonMaterial";
  }
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.color = new Kt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class wP extends Wr {
  static get type() {
    return "MeshNormalMaterial";
  }
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class EP extends Wr {
  static get type() {
    return "MeshLambertMaterial";
  }
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.color = new Kt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ts(), this.combine = Cg, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class MP extends Wr {
  static get type() {
    return "MeshMatcapMaterial";
  }
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.color = new Kt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xo, this.normalScale = new jt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class AP extends fT {
  static get type() {
    return "LineDashedMaterial";
  }
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
class kl extends Ki {
  constructor(e, i = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Kt(e), this.intensity = i;
  }
  dispose() {
  }
  copy(e, i) {
    return super.copy(e, i), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.color = this.color.getHex(), i.object.intensity = this.intensity, this.groundColor !== void 0 && (i.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (i.object.distance = this.distance), this.angle !== void 0 && (i.object.angle = this.angle), this.decay !== void 0 && (i.object.decay = this.decay), this.penumbra !== void 0 && (i.object.penumbra = this.penumbra), this.shadow !== void 0 && (i.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (i.object.target = this.target.uuid), i;
  }
}
class nW extends kl {
  constructor(e, i, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Ki.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Kt(i);
  }
  copy(e, i) {
    return super.copy(e, i), this.groundColor.copy(e.groundColor), this;
  }
}
const k0 = /* @__PURE__ */ new gi(), KE = /* @__PURE__ */ new oe(), QE = /* @__PURE__ */ new oe();
class yT {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new jt(512, 512), this.map = null, this.mapPass = null, this.matrix = new gi(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new vP(), this._frameExtents = new jt(1, 1), this._viewportCount = 1, this._viewports = [
      new $t(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const i = this.camera, n = this.matrix;
    KE.setFromMatrixPosition(e.matrixWorld), i.position.copy(KE), QE.setFromMatrixPosition(e.target.matrixWorld), i.lookAt(QE), i.updateMatrixWorld(), k0.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(k0), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(k0);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class sW extends yT {
  constructor() {
    super(new Qs(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const i = this.camera, n = bd * 2 * e.angle * this.focus, s = this.mapSize.width / this.mapSize.height, a = e.distance || i.far;
    (n !== i.fov || s !== i.aspect || a !== i.far) && (i.fov = n, i.aspect = s, i.far = a, i.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class CP extends kl {
  constructor(e, i, n = 0, s = Math.PI / 3, a = 0, o = 2) {
    super(e, i), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Ki.DEFAULT_UP), this.updateMatrix(), this.target = new Ki(), this.distance = n, this.angle = s, this.penumbra = a, this.decay = o, this.map = null, this.shadow = new sW();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, i) {
    return super.copy(e, i), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const ZE = /* @__PURE__ */ new gi(), xh = /* @__PURE__ */ new oe(), L0 = /* @__PURE__ */ new oe();
class aW extends yT {
  constructor() {
    super(new Qs(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new jt(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new $t(2, 1, 1, 1),
      // negative X
      new $t(0, 1, 1, 1),
      // positive Z
      new $t(3, 1, 1, 1),
      // negative Z
      new $t(1, 1, 1, 1),
      // positive Y
      new $t(3, 0, 1, 1),
      // negative Y
      new $t(1, 0, 1, 1)
    ], this._cubeDirections = [
      new oe(1, 0, 0),
      new oe(-1, 0, 0),
      new oe(0, 0, 1),
      new oe(0, 0, -1),
      new oe(0, 1, 0),
      new oe(0, -1, 0)
    ], this._cubeUps = [
      new oe(0, 1, 0),
      new oe(0, 1, 0),
      new oe(0, 1, 0),
      new oe(0, 1, 0),
      new oe(0, 0, 1),
      new oe(0, 0, -1)
    ];
  }
  updateMatrices(e, i = 0) {
    const n = this.camera, s = this.matrix, a = e.distance || n.far;
    a !== n.far && (n.far = a, n.updateProjectionMatrix()), xh.setFromMatrixPosition(e.matrixWorld), n.position.copy(xh), L0.copy(n.position), L0.add(this._cubeDirections[i]), n.up.copy(this._cubeUps[i]), n.lookAt(L0), n.updateMatrixWorld(), s.makeTranslation(-xh.x, -xh.y, -xh.z), ZE.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ZE);
  }
}
class oW extends kl {
  constructor(e, i, n = 0, s = 2) {
    super(e, i), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = s, this.shadow = new aW();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, i) {
    return super.copy(e, i), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class vT extends pP {
  constructor(e = -1, i = 1, n = 1, s = -1, a = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = i, this.top = n, this.bottom = s, this.near = a, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, i) {
    return super.copy(e, i), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, i, n, s, a, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = i, this.view.offsetX = n, this.view.offsetY = s, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), i = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
    let a = n - e, o = n + e, l = s + i, u = s - i;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      a += c * this.view.offsetX, o = a + c * this.view.width, l -= h * this.view.offsetY, u = l - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(a, o, l, u, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.zoom = this.zoom, i.object.left = this.left, i.object.right = this.right, i.object.top = this.top, i.object.bottom = this.bottom, i.object.near = this.near, i.object.far = this.far, this.view !== null && (i.object.view = Object.assign({}, this.view)), i;
  }
}
class lW extends yT {
  constructor() {
    super(new vT(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class uW extends kl {
  constructor(e, i) {
    super(e, i), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Ki.DEFAULT_UP), this.updateMatrix(), this.target = new Ki(), this.shadow = new lW();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class cW extends kl {
  constructor(e, i) {
    super(e, i), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class hW extends kl {
  constructor(e, i, n = 10, s = 10) {
    super(e, i), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = s;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.width = this.width, i.object.height = this.height, i;
  }
}
class dW {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new oe());
  }
  set(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].copy(e[i]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, i) {
    const n = e.x, s = e.y, a = e.z, o = this.coefficients;
    return i.copy(o[0]).multiplyScalar(0.282095), i.addScaledVector(o[1], 0.488603 * s), i.addScaledVector(o[2], 0.488603 * a), i.addScaledVector(o[3], 0.488603 * n), i.addScaledVector(o[4], 1.092548 * (n * s)), i.addScaledVector(o[5], 1.092548 * (s * a)), i.addScaledVector(o[6], 0.315392 * (3 * a * a - 1)), i.addScaledVector(o[7], 1.092548 * (n * a)), i.addScaledVector(o[8], 0.546274 * (n * n - s * s)), i;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, i) {
    const n = e.x, s = e.y, a = e.z, o = this.coefficients;
    return i.copy(o[0]).multiplyScalar(0.886227), i.addScaledVector(o[1], 2 * 0.511664 * s), i.addScaledVector(o[2], 2 * 0.511664 * a), i.addScaledVector(o[3], 2 * 0.511664 * n), i.addScaledVector(o[4], 2 * 0.429043 * n * s), i.addScaledVector(o[5], 2 * 0.429043 * s * a), i.addScaledVector(o[6], 0.743125 * a * a - 0.247708), i.addScaledVector(o[7], 2 * 0.429043 * n * a), i.addScaledVector(o[8], 0.429043 * (n * n - s * s)), i;
  }
  add(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].add(e.coefficients[i]);
    return this;
  }
  addScaledSH(e, i) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], i);
    return this;
  }
  scale(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].multiplyScalar(e);
    return this;
  }
  lerp(e, i) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], i);
    return this;
  }
  equals(e) {
    for (let i = 0; i < 9; i++)
      if (!this.coefficients[i].equals(e.coefficients[i]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, i = 0) {
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].fromArray(e, i + s * 3);
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].toArray(e, i + s * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, i) {
    const n = e.x, s = e.y, a = e.z;
    i[0] = 0.282095, i[1] = 0.488603 * s, i[2] = 0.488603 * a, i[3] = 0.488603 * n, i[4] = 1.092548 * n * s, i[5] = 1.092548 * s * a, i[6] = 0.315392 * (3 * a * a - 1), i[7] = 1.092548 * n * a, i[8] = 0.546274 * (n * n - s * s);
  }
}
class pW extends kl {
  constructor(e = new dW(), i = 1) {
    super(void 0, i), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.sh = this.sh.toArray(), i;
  }
}
class fW extends gP {
  constructor(e, i, n = 1) {
    super(e, i), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const i = super.clone(e);
    return i.meshPerAttribute = this.meshPerAttribute, i;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.isInstancedInterleavedBuffer = !0, i.meshPerAttribute = this.meshPerAttribute, i;
  }
}
const mW = [
  "alphaMap",
  "alphaTest",
  "anisotropy",
  "anisotropyMap",
  "anisotropyRotation",
  "aoMap",
  "attenuationColor",
  "attenuationDistance",
  "bumpMap",
  "clearcoat",
  "clearcoatMap",
  "clearcoatNormalMap",
  "clearcoatNormalScale",
  "clearcoatRoughness",
  "color",
  "dispersion",
  "displacementMap",
  "emissive",
  "emissiveMap",
  "envMap",
  "gradientMap",
  "ior",
  "iridescence",
  "iridescenceIOR",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "lightMap",
  "map",
  "matcap",
  "metalness",
  "metalnessMap",
  "normalMap",
  "normalScale",
  "opacity",
  "roughness",
  "roughnessMap",
  "sheen",
  "sheenColor",
  "sheenColorMap",
  "sheenRoughnessMap",
  "shininess",
  "specular",
  "specularColor",
  "specularColorMap",
  "specularIntensity",
  "specularIntensityMap",
  "specularMap",
  "thickness",
  "transmission",
  "transmissionMap"
];
class gW {
  constructor(e) {
    this.renderObjects = /* @__PURE__ */ new WeakMap(), this.hasNode = this.containsNode(e), this.hasAnimation = e.object.isSkinnedMesh === !0, this.refreshUniforms = mW, this.renderId = 0;
  }
  firstInitialization(e) {
    return this.renderObjects.has(e) === !1 ? (this.getRenderObjectData(e), !0) : !1;
  }
  getRenderObjectData(e) {
    let i = this.renderObjects.get(e);
    if (i === void 0) {
      const { geometry: n, material: s } = e;
      if (i = {
        material: this.getMaterialData(s),
        geometry: {
          attributes: this.getAttributesData(n.attributes),
          indexVersion: n.index ? n.index.version : null,
          drawRange: { start: n.drawRange.start, count: n.drawRange.count }
        },
        worldMatrix: e.object.matrixWorld.clone()
      }, e.object.center && (i.center = e.object.center.clone()), e.object.morphTargetInfluences && (i.morphTargetInfluences = e.object.morphTargetInfluences.slice()), e.bundle !== null && (i.version = e.bundle.version), i.material.transmission > 0) {
        const { width: a, height: o } = e.context;
        i.bufferWidth = a, i.bufferHeight = o;
      }
      this.renderObjects.set(e, i);
    }
    return i;
  }
  getAttributesData(e) {
    const i = {};
    for (const n in e) {
      const s = e[n];
      i[n] = {
        version: s.version
      };
    }
    return i;
  }
  containsNode(e) {
    const i = e.material;
    for (const n in i)
      if (i[n] && i[n].isNode)
        return !0;
    return e.renderer.nodes.modelViewMatrix !== null || e.renderer.nodes.modelNormalViewMatrix !== null;
  }
  getMaterialData(e) {
    const i = {};
    for (const n of this.refreshUniforms) {
      const s = e[n];
      s != null && (typeof s == "object" && s.clone !== void 0 ? s.isTexture === !0 ? i[n] = { id: s.id, version: s.version } : i[n] = s.clone() : i[n] = s);
    }
    return i;
  }
  equals(e) {
    const { object: i, material: n, geometry: s } = e, a = this.getRenderObjectData(e);
    if (a.worldMatrix.equals(i.matrixWorld) !== !0)
      return a.worldMatrix.copy(i.matrixWorld), !1;
    const o = a.material;
    for (const v in o) {
      const y = o[v], g = n[v];
      if (y.equals !== void 0) {
        if (y.equals(g) === !1)
          return y.copy(g), !1;
      } else if (g.isTexture === !0) {
        if (y.id !== g.id || y.version !== g.version)
          return y.id = g.id, y.version = g.version, !1;
      } else if (y !== g)
        return o[v] = g, !1;
    }
    if (o.transmission > 0) {
      const { width: v, height: y } = e.context;
      if (a.bufferWidth !== v || a.bufferHeight !== y)
        return a.bufferWidth = v, a.bufferHeight = y, !1;
    }
    const l = a.geometry, u = s.attributes, c = l.attributes, h = Object.keys(c), d = Object.keys(u);
    if (h.length !== d.length)
      return a.geometry.attributes = this.getAttributesData(u), !1;
    for (const v of h) {
      const y = c[v], g = u[v];
      if (g === void 0)
        return delete c[v], !1;
      if (y.version !== g.version)
        return y.version = g.version, !1;
    }
    const p = s.index, f = l.indexVersion, m = p ? p.version : null;
    if (f !== m)
      return l.indexVersion = m, !1;
    if (l.drawRange.start !== s.drawRange.start || l.drawRange.count !== s.drawRange.count)
      return l.drawRange.start = s.drawRange.start, l.drawRange.count = s.drawRange.count, !1;
    if (a.morphTargetInfluences) {
      let v = !1;
      for (let y = 0; y < a.morphTargetInfluences.length; y++)
        a.morphTargetInfluences[y] !== i.morphTargetInfluences[y] && (v = !0);
      if (v) return !0;
    }
    return a.center && a.center.equals(i.center) === !1 ? (a.center.copy(i.center), !0) : (e.bundle !== null && (a.version = e.bundle.version), !0);
  }
  needsRefresh(e, i) {
    if (this.hasNode || this.hasAnimation || this.firstInitialization(e))
      return !0;
    const { renderId: n } = i;
    if (this.renderId !== n)
      return this.renderId = n, !0;
    const s = e.object.static === !0, a = e.bundle !== null && e.bundle.static === !0 && this.getRenderObjectData(e).version === e.bundle.version;
    return s || a ? !1 : this.equals(e) !== !0;
  }
}
function xd(r, e = 0) {
  let i = 3735928559 ^ e, n = 1103547991 ^ e;
  if (r instanceof Array)
    for (let s = 0, a; s < r.length; s++)
      a = r[s], i = Math.imul(i ^ a, 2654435761), n = Math.imul(n ^ a, 1597334677);
  else
    for (let s = 0, a; s < r.length; s++)
      a = r.charCodeAt(s), i = Math.imul(i ^ a, 2654435761), n = Math.imul(n ^ a, 1597334677);
  return i = Math.imul(i ^ i >>> 16, 2246822507), i ^= Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507), n ^= Math.imul(i ^ i >>> 13, 3266489909), 4294967296 * (2097151 & n) + (i >>> 0);
}
const yW = (r) => xd(r), RP = (r) => xd(r), Fm = (...r) => xd(r);
function NP(r, e = !1) {
  const i = [];
  r.isNode === !0 && (i.push(r.id), r = r.getSelf());
  for (const { property: n, childNode: s } of Bm(r))
    i.push(i, xd(n.slice(0, -4)), s.getCacheKey(e));
  return xd(i);
}
function* Bm(r, e = !1) {
  for (const i in r) {
    if (i.startsWith("_") === !0) continue;
    const n = r[i];
    if (Array.isArray(n) === !0)
      for (let s = 0; s < n.length; s++) {
        const a = n[s];
        a && (a.isNode === !0 || e && typeof a.toJSON == "function") && (yield { property: i, index: s, childNode: a });
      }
    else if (n && n.isNode === !0)
      yield { property: i, childNode: n };
    else if (typeof n == "object")
      for (const s in n) {
        const a = n[s];
        a && (a.isNode === !0 || e && typeof a.toJSON == "function") && (yield { property: i, index: s, childNode: a });
      }
  }
}
function zm(r) {
  if (r == null) return null;
  const e = typeof r;
  return r.isNode === !0 ? "node" : e === "number" ? "float" : e === "boolean" ? "bool" : e === "string" ? "string" : e === "function" ? "shader" : r.isVector2 === !0 ? "vec2" : r.isVector3 === !0 ? "vec3" : r.isVector4 === !0 ? "vec4" : r.isMatrix3 === !0 ? "mat3" : r.isMatrix4 === !0 ? "mat4" : r.isColor === !0 ? "color" : r instanceof ArrayBuffer ? "ArrayBuffer" : null;
}
function PP(r, ...e) {
  const i = r ? r.slice(-4) : void 0;
  return e.length === 1 && (i === "vec2" ? e = [e[0], e[0]] : i === "vec3" ? e = [e[0], e[0], e[0]] : i === "vec4" && (e = [e[0], e[0], e[0], e[0]])), r === "color" ? new Kt(...e) : i === "vec2" ? new jt(...e) : i === "vec3" ? new oe(...e) : i === "vec4" ? new $t(...e) : i === "mat3" ? new Yr(...e) : i === "mat4" ? new gi(...e) : r === "bool" ? e[0] || !1 : r === "float" || r === "int" || r === "uint" ? e[0] || 0 : r === "string" ? e[0] || "" : r === "ArrayBuffer" ? bW(e[0]) : null;
}
function vW(r) {
  let e = "";
  const i = new Uint8Array(r);
  for (let n = 0; n < i.length; n++)
    e += String.fromCharCode(i[n]);
  return btoa(e);
}
function bW(r) {
  return Uint8Array.from(atob(r), (e) => e.charCodeAt(0)).buffer;
}
const JE = {
  VERTEX: "vertex"
}, Pt = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
}, xW = ["fragment", "vertex"], eM = ["setup", "analyze", "generate"], tM = [...xW, "compute"], Vc = ["x", "y", "z", "w"];
let _W = 0;
class At extends Bc {
  static get type() {
    return "Node";
  }
  constructor(e = null) {
    super(), this.nodeType = e, this.updateType = Pt.NONE, this.updateBeforeType = Pt.NONE, this.updateAfterType = Pt.NONE, this.uuid = M7.generateUUID(), this.version = 0, this._cacheKey = null, this._cacheKeyVersion = 0, this.global = !1, this.isNode = !0, Object.defineProperty(this, "id", { value: _W++ });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get type() {
    return this.constructor.type;
  }
  onUpdate(e, i) {
    return this.updateType = i, this.update = e.bind(this.getSelf()), this;
  }
  onFrameUpdate(e) {
    return this.onUpdate(e, Pt.FRAME);
  }
  onRenderUpdate(e) {
    return this.onUpdate(e, Pt.RENDER);
  }
  onObjectUpdate(e) {
    return this.onUpdate(e, Pt.OBJECT);
  }
  onReference(e) {
    return this.updateReference = e.bind(this.getSelf()), this;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return this.global;
  }
  *getChildren() {
    for (const { childNode: e } of Bm(this))
      yield e;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(e) {
    e(this);
    for (const i of this.getChildren())
      i.traverse(e);
  }
  getCacheKey(e = !1) {
    return e = e || this.version !== this._cacheKeyVersion, (e === !0 || this._cacheKey === null) && (this._cacheKey = NP(this, e), this._cacheKeyVersion = this.version), this._cacheKey;
  }
  getScope() {
    return this;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  getElementType(e) {
    const i = this.getNodeType(e);
    return e.getElementType(i);
  }
  getNodeType(e) {
    const i = e.getNodeProperties(this);
    return i.outputNode ? i.outputNode.getNodeType(e) : this.nodeType;
  }
  getShared(e) {
    const i = this.getHash(e);
    return e.getNodeFromHash(i) || this;
  }
  setup(e) {
    const i = e.getNodeProperties(this);
    let n = 0;
    for (const s of this.getChildren())
      i["node" + n++] = s;
    return null;
  }
  analyze(e) {
    if (e.increaseUsage(this) === 1) {
      const i = e.getNodeProperties(this);
      for (const n of Object.values(i))
        n && n.isNode === !0 && n.build(e);
    }
  }
  generate(e, i) {
    const { outputNode: n } = e.getNodeProperties(this);
    if (n && n.isNode === !0)
      return n.build(e, i);
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  updateAfter() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(e, i = null) {
    const n = this.getShared(e);
    if (this !== n)
      return n.build(e, i);
    e.addNode(this), e.addChain(this);
    let s = null;
    const a = e.getBuildStage();
    if (a === "setup") {
      this.updateReference(e);
      const o = e.getNodeProperties(this);
      if (o.initialized !== !0) {
        e.stack.nodes.length, o.initialized = !0, o.outputNode = this.setup(e), o.outputNode !== null && e.stack.nodes.length;
        for (const l of Object.values(o))
          l && l.isNode === !0 && l.build(e);
      }
    } else if (a === "analyze")
      this.analyze(e);
    else if (a === "generate")
      if (this.generate.length === 1) {
        const o = this.getNodeType(e), l = e.getDataFromNode(this);
        s = l.snippet, s === void 0 ? (s = this.generate(e) || "", l.snippet = s) : l.flowCodes !== void 0 && e.context.nodeBlock !== void 0 && e.addFlowCodeHierarchy(this, e.context.nodeBlock), s = e.format(s, o, i);
      } else
        s = this.generate(e, i) || "";
    return e.removeChain(this), e.addSequentialNode(this), s;
  }
  getSerializeChildren() {
    return Bm(this);
  }
  serialize(e) {
    const i = this.getSerializeChildren(), n = {};
    for (const { property: s, index: a, childNode: o } of i)
      a !== void 0 ? (n[s] === void 0 && (n[s] = Number.isInteger(a) ? [] : {}), n[s][a] = o.toJSON(e.meta).uuid) : n[s] = o.toJSON(e.meta).uuid;
    Object.keys(n).length > 0 && (e.inputNodes = n);
  }
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const i = e.meta.nodes;
      for (const n in e.inputNodes)
        if (Array.isArray(e.inputNodes[n])) {
          const s = [];
          for (const a of e.inputNodes[n])
            s.push(i[a]);
          this[n] = s;
        } else if (typeof e.inputNodes[n] == "object") {
          const s = {};
          for (const a in e.inputNodes[n]) {
            const o = e.inputNodes[n][a];
            s[a] = i[o];
          }
          this[n] = s;
        } else {
          const s = e.inputNodes[n];
          this[n] = i[s];
        }
    }
  }
  toJSON(e) {
    const { uuid: i, type: n } = this, s = e === void 0 || typeof e == "string";
    s && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    let a = e.nodes[i];
    a === void 0 && (a = {
      uuid: i,
      type: n,
      meta: e,
      metadata: {
        version: 4.6,
        type: "Node",
        generator: "Node.toJSON"
      }
    }, s !== !0 && (e.nodes[a.uuid] = a), this.serialize(a), delete a.meta);
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
    if (s) {
      const l = o(e.textures), u = o(e.images), c = o(e.nodes);
      l.length > 0 && (a.textures = l), u.length > 0 && (a.images = u), c.length > 0 && (a.nodes = c);
    }
    return a;
  }
}
class Jd extends At {
  static get type() {
    return "ArrayElementNode";
  }
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(e, i) {
    super(), this.node = e, this.indexNode = i, this.isArrayElementNode = !0;
  }
  getNodeType(e) {
    return this.node.getElementType(e);
  }
  generate(e) {
    const i = this.node.build(e), n = this.indexNode.build(e, "uint");
    return `${i}[ ${n} ]`;
  }
}
class OP extends At {
  static get type() {
    return "ConvertNode";
  }
  constructor(e, i) {
    super(), this.node = e, this.convertTo = i;
  }
  getNodeType(e) {
    const i = this.node.getNodeType(e);
    let n = null;
    for (const s of this.convertTo.split("|"))
      (n === null || e.getTypeLength(i) === e.getTypeLength(s)) && (n = s);
    return n;
  }
  serialize(e) {
    super.serialize(e), e.convertTo = this.convertTo;
  }
  deserialize(e) {
    super.deserialize(e), this.convertTo = e.convertTo;
  }
  generate(e, i) {
    const n = this.node, s = this.getNodeType(e), a = n.build(e, s);
    return e.format(a, s, i);
  }
}
class zi extends At {
  static get type() {
    return "TempNode";
  }
  constructor(e) {
    super(e), this.isTempNode = !0;
  }
  hasDependencies(e) {
    return e.getDataFromNode(this).usageCount > 1;
  }
  build(e, i) {
    if (e.getBuildStage() === "generate") {
      const n = e.getVectorType(this.getNodeType(e, i)), s = e.getDataFromNode(this);
      if (s.propertyName !== void 0)
        return e.format(s.propertyName, n, i);
      if (n !== "void" && i !== "void" && this.hasDependencies(e)) {
        const a = super.build(e, n), o = e.getVarFromNode(this, null, n), l = e.getPropertyName(o);
        return e.addLineFlowCode(`${l} = ${a}`, this), s.snippet = a, s.propertyName = l, e.format(s.propertyName, n, i);
      }
    }
    return super.build(e, i);
  }
}
class TW extends zi {
  static get type() {
    return "JoinNode";
  }
  constructor(e = [], i = null) {
    super(i), this.nodes = e;
  }
  getNodeType(e) {
    return this.nodeType !== null ? e.getVectorType(this.nodeType) : e.getTypeFromLength(this.nodes.reduce((i, n) => i + e.getTypeLength(n.getNodeType(e)), 0));
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.nodes, a = e.getComponentType(n), o = [];
    for (const u of s) {
      let c = u.build(e);
      const h = e.getComponentType(u.getNodeType(e));
      h !== a && (c = e.format(c, h, a)), o.push(c);
    }
    const l = `${e.getType(n)}( ${o.join(", ")} )`;
    return e.format(l, n, i);
  }
}
const SW = Vc.join("");
class iM extends At {
  static get type() {
    return "SplitNode";
  }
  constructor(e, i = "x") {
    super(), this.node = e, this.components = i, this.isSplitNode = !0;
  }
  getVectorLength() {
    let e = this.components.length;
    for (const i of this.components)
      e = Math.max(Vc.indexOf(i) + 1, e);
    return e;
  }
  getComponentType(e) {
    return e.getComponentType(this.node.getNodeType(e));
  }
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length, this.getComponentType(e));
  }
  generate(e, i) {
    const n = this.node, s = e.getTypeLength(n.getNodeType(e));
    let a = null;
    if (s > 1) {
      let o = null;
      this.getVectorLength() >= s && (o = e.getTypeFromLength(this.getVectorLength(), this.getComponentType(e)));
      const l = n.build(e, o);
      this.components.length === s && this.components === SW.slice(0, this.components.length) ? a = e.format(l, o, i) : a = e.format(`${l}.${this.components}`, this.getNodeType(e), i);
    } else
      a = n.build(e, i);
    return a;
  }
  serialize(e) {
    super.serialize(e), e.components = this.components;
  }
  deserialize(e) {
    super.deserialize(e), this.components = e.components;
  }
}
class wW extends zi {
  static get type() {
    return "SetNode";
  }
  constructor(e, i, n) {
    super(), this.sourceNode = e, this.components = i, this.targetNode = n;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { sourceNode: i, components: n, targetNode: s } = this, a = this.getNodeType(e), o = e.getTypeFromLength(n.length, s.getNodeType(e)), l = s.build(e, o), u = i.build(e, a), c = e.getTypeLength(a), h = [];
    for (let d = 0; d < c; d++) {
      const p = Vc[d];
      p === n[0] ? (h.push(l), d += n.length - 1) : h.push(u + "." + p);
    }
    return `${e.getType(a)}( ${h.join(", ")} )`;
  }
}
class EW extends zi {
  static get type() {
    return "FlipNode";
  }
  constructor(e, i) {
    super(), this.sourceNode = e, this.components = i;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { components: i, sourceNode: n } = this, s = this.getNodeType(e), a = n.build(e), o = e.getVarFromNode(this), l = e.getPropertyName(o);
    e.addLineFlowCode(l + " = " + a, this);
    const u = e.getTypeLength(s), c = [];
    let h = 0;
    for (let d = 0; d < u; d++) {
      const p = Vc[d];
      p === i[h] ? (c.push("1.0 - " + (l + "." + p)), h++) : c.push(l + "." + p);
    }
    return `${e.getType(s)}( ${c.join(", ")} )`;
  }
}
class bT extends At {
  static get type() {
    return "InputNode";
  }
  constructor(e, i = null) {
    super(i), this.isInputNode = !0, this.value = e, this.precision = null;
  }
  getNodeType() {
    return this.nodeType === null ? zm(this.value) : this.nodeType;
  }
  getInputType(e) {
    return this.getNodeType(e);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  serialize(e) {
    super.serialize(e), e.value = this.value, this.value && this.value.toArray && (e.value = this.value.toArray()), e.valueType = zm(this.value), e.nodeType = this.nodeType, e.valueType === "ArrayBuffer" && (e.value = vW(e.value)), e.precision = this.precision;
  }
  deserialize(e) {
    super.deserialize(e), this.nodeType = e.nodeType, this.value = Array.isArray(e.value) ? PP(e.valueType, ...e.value) : e.value, this.precision = e.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
class Aa extends bT {
  static get type() {
    return "ConstNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isConstNode = !0;
  }
  generateConst(e) {
    return e.generateConst(this.getNodeType(e), this.value);
  }
  generate(e, i) {
    const n = this.getNodeType(e);
    return e.format(this.generateConst(e), n, i);
  }
}
let wc = null;
const Bu = /* @__PURE__ */ new Map();
function fe(r, e) {
  if (Bu.has(r)) {
    console.warn(`Redefinition of method chaining ${r}`);
    return;
  }
  if (typeof e != "function") throw new Error(`Node element ${r} is not a function`);
  Bu.set(r, e);
}
const IP = (r) => r.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), rM = (r) => IP(r).split("").sort().join(""), DP = {
  setup(r, e) {
    const i = e.shift();
    return r(Og(i), ...e);
  },
  get(r, e, i) {
    if (typeof e == "string" && r[e] === void 0) {
      if (r.isStackNode !== !0 && e === "assign")
        return (...n) => (wc.assign(i, ...n), i);
      if (Bu.has(e)) {
        const n = Bu.get(e);
        return r.isStackNode ? (...s) => i.add(n(...s)) : (...s) => n(i, ...s);
      } else {
        if (e === "self")
          return r;
        if (e.endsWith("Assign") && Bu.has(e.slice(0, e.length - 6))) {
          const n = Bu.get(e.slice(0, e.length - 6));
          return r.isStackNode ? (...s) => i.assign(s[0], n(...s)) : (...s) => i.assign(n(i, ...s));
        } else {
          if (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0)
            return e = IP(e), De(new iM(i, e));
          if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = rM(e.slice(3).toLowerCase()), (n) => De(new wW(r, e, n));
          if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = rM(e.slice(4).toLowerCase()), () => De(new EW(De(r), e));
          if (e === "width" || e === "height" || e === "depth")
            return e === "width" ? e = "x" : e === "height" ? e = "y" : e === "depth" && (e = "z"), De(new iM(r, e));
          if (/^\d+$/.test(e) === !0)
            return De(new Jd(i, new Aa(Number(e), "uint")));
        }
      }
    }
    return Reflect.get(r, e, i);
  },
  set(r, e, i, n) {
    return typeof e == "string" && r[e] === void 0 && (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0 || e === "width" || e === "height" || e === "depth" || /^\d+$/.test(e) === !0) ? (n[e].assign(i), !0) : Reflect.set(r, e, i, n);
  }
}, U0 = /* @__PURE__ */ new WeakMap(), nM = /* @__PURE__ */ new WeakMap(), MW = function(r, e = null) {
  const i = zm(r);
  if (i === "node") {
    let n = U0.get(r);
    return n === void 0 && (n = new Proxy(r, DP), U0.set(r, n), U0.set(n, n)), n;
  } else {
    if (e === null && (i === "float" || i === "boolean") || i && i !== "shader" && i !== "string")
      return De(bx(r, e));
    if (i === "shader")
      return Be(r);
  }
  return r;
}, AW = function(r, e = null) {
  for (const i in r)
    r[i] = De(r[i], e);
  return r;
}, CW = function(r, e = null) {
  const i = r.length;
  for (let n = 0; n < i; n++)
    r[n] = De(r[n], e);
  return r;
}, RW = function(r, e = null, i = null, n = null) {
  const s = (a) => De(n !== null ? Object.assign(a, n) : a);
  return e === null ? (...a) => s(new r(...Ju(a))) : i !== null ? (i = De(i), (...a) => s(new r(e, ...Ju(a), i))) : (...a) => s(new r(e, ...Ju(a)));
}, NW = function(r, ...e) {
  return De(new r(...Ju(e)));
};
class PW extends At {
  constructor(e, i) {
    super(), this.shaderNode = e, this.inputNodes = i;
  }
  getNodeType(e) {
    return this.shaderNode.nodeType || this.getOutputNode(e).getNodeType(e);
  }
  call(e) {
    const { shaderNode: i, inputNodes: n } = this, s = e.getNodeProperties(i);
    if (s.onceOutput) return s.onceOutput;
    let a = null;
    if (i.layout) {
      let o = nM.get(e.constructor);
      o === void 0 && (o = /* @__PURE__ */ new WeakMap(), nM.set(e.constructor, o));
      let l = o.get(i);
      l === void 0 && (l = De(e.buildFunctionNode(i)), o.set(i, l)), e.currentFunctionNode !== null && e.currentFunctionNode.includes.push(l), a = De(l.call(n));
    } else {
      const o = i.jsFunc, l = n !== null ? o(n, e) : o(e);
      a = De(l);
    }
    return i.once && (s.onceOutput = a), a;
  }
  getOutputNode(e) {
    const i = e.getNodeProperties(this);
    return i.outputNode === null && (i.outputNode = this.setupOutput(e)), i.outputNode;
  }
  setup(e) {
    return this.getOutputNode(e);
  }
  setupOutput(e) {
    return e.addStack(), e.stack.outputNode = this.call(e), e.removeStack();
  }
  generate(e, i) {
    return this.getOutputNode(e).build(e, i);
  }
}
class OW extends At {
  constructor(e, i) {
    super(i), this.jsFunc = e, this.layout = null, this.global = !0, this.once = !1;
  }
  setLayout(e) {
    return this.layout = e, this;
  }
  call(e = null) {
    return Og(e), De(new PW(this, e));
  }
  setup() {
    return this.call();
  }
}
const IW = [!1, !0], DW = [0, 1, 2, 3], kW = [-1, -2], kP = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2], xT = /* @__PURE__ */ new Map();
for (const r of IW) xT.set(r, new Aa(r));
const _T = /* @__PURE__ */ new Map();
for (const r of DW) _T.set(r, new Aa(r, "uint"));
const TT = new Map([..._T].map((r) => new Aa(r.value, "int")));
for (const r of kW) TT.set(r, new Aa(r, "int"));
const Ng = new Map([...TT].map((r) => new Aa(r.value)));
for (const r of kP) Ng.set(r, new Aa(r));
for (const r of kP) Ng.set(-r, new Aa(-r));
const Pg = { bool: xT, uint: _T, ints: TT, float: Ng }, sM = new Map([...xT, ...Ng]), bx = (r, e) => sM.has(r) ? sM.get(r) : r.isNode === !0 ? r : new Aa(r, e), LW = (r) => {
  try {
    return r.getNodeType();
  } catch {
    return;
  }
}, ji = function(r, e = null) {
  return (...i) => {
    if ((i.length === 0 || !["bool", "float", "int", "uint"].includes(r) && i.every((s) => typeof s != "object")) && (i = [PP(r, ...i)]), i.length === 1 && e !== null && e.has(i[0]))
      return De(e.get(i[0]));
    if (i.length === 1) {
      const s = bx(i[0], r);
      return LW(s) === r ? De(s) : De(new OP(s, r));
    }
    const n = i.map((s) => bx(s));
    return De(new TW(n, r));
  };
}, aM = (r) => typeof r == "object" && r !== null ? r.value : r, UW = (r) => r != null ? r.nodeType || r.convertTo || (typeof r == "string" ? r : null) : null;
function nm(r, e) {
  return new Proxy(new OW(r, e), DP);
}
const De = (r, e = null) => (
  /* new */
  MW(r, e)
), Og = (r, e = null) => new AW(r, e), Ju = (r, e = null) => new CW(r, e), Me = (...r) => new RW(...r), He = (...r) => new NW(...r), Be = (r, e) => {
  const i = new nm(r, e), n = (...s) => {
    let a;
    return Og(s), s[0] && s[0].isNode ? a = [...s] : a = s[0], i.call(a);
  };
  return n.shaderNode = i, n.setLayout = (s) => (i.setLayout(s), n), n.once = () => (i.once = !0, n), n;
};
fe("toGlobal", (r) => (r.global = !0, r));
const jm = (r) => {
  wc = r;
}, LP = () => wc, rr = (...r) => wc.If(...r);
function FW(r) {
  return wc && wc.add(r), r;
}
fe("append", FW);
const BW = new ji("color"), ve = new ji("float", Pg.float), Mi = new ji("int", Pg.ints), zW = new ji("uint", Pg.uint), jW = new ji("bool", Pg.bool), qe = new ji("vec2"), Zs = new ji("ivec2"), VW = new ji("uvec2"), GW = new ji("bvec2"), ye = new ji("vec3"), HW = new ji("ivec3"), WW = new ji("uvec3"), qW = new ji("bvec3"), _t = new ji("vec4"), XW = new ji("ivec4"), YW = new ji("uvec4"), $W = new ji("bvec4"), ST = new ji("mat2"), Rr = new ji("mat3"), ec = new ji("mat4");
fe("toColor", BW);
fe("toFloat", ve);
fe("toInt", Mi);
fe("toUint", zW);
fe("toBool", jW);
fe("toVec2", qe);
fe("toIVec2", Zs);
fe("toUVec2", VW);
fe("toBVec2", GW);
fe("toVec3", ye);
fe("toIVec3", HW);
fe("toUVec3", WW);
fe("toBVec3", qW);
fe("toVec4", _t);
fe("toIVec4", XW);
fe("toUVec4", YW);
fe("toBVec4", $W);
fe("toMat2", ST);
fe("toMat3", Rr);
fe("toMat4", ec);
const KW = /* @__PURE__ */ Me(Jd), QW = (r, e) => De(new OP(De(r), e));
fe("element", KW);
fe("convert", QW);
class UP extends At {
  static get type() {
    return "UniformGroupNode";
  }
  constructor(e, i = !1, n = 1) {
    super("string"), this.name = e, this.version = 0, this.shared = i, this.order = n, this.isUniformGroup = !0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  serialize(e) {
    super.serialize(e), e.name = this.name, e.version = this.version, e.shared = this.shared;
  }
  deserialize(e) {
    super.deserialize(e), this.name = e.name, this.version = e.version, this.shared = e.shared;
  }
}
const ZW = (r) => new UP(r), FP = (r, e = 0) => new UP(r, !0, e), JW = /* @__PURE__ */ FP("frame"), Ut = /* @__PURE__ */ FP("render"), BP = /* @__PURE__ */ ZW("object");
class ep extends bT {
  static get type() {
    return "UniformNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isUniformNode = !0, this.name = "", this.groupNode = BP;
  }
  label(e) {
    return this.name = e, this;
  }
  setGroup(e) {
    return this.groupNode = e, this;
  }
  getGroup() {
    return this.groupNode;
  }
  getUniformHash(e) {
    return this.getHash(e);
  }
  onUpdate(e, i) {
    const n = this.getSelf();
    return e = e.bind(n), super.onUpdate((s) => {
      const a = e(s, n);
      a !== void 0 && (this.value = a);
    }, i);
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.getUniformHash(e);
    let a = e.getNodeFromHash(s);
    a === void 0 && (e.setHashNode(this, s), a = this);
    const o = a.getInputType(e), l = e.getUniformFromNode(a, o, e.shaderStage, this.name || e.context.label), u = e.getPropertyName(l);
    return e.context.label !== void 0 && delete e.context.label, e.format(u, n, i);
  }
}
const Tt = (r, e) => {
  const i = UW(e || r), n = r && r.isNode === !0 ? r.node && r.node.value || r.value : r;
  return De(new ep(n, i));
};
class Qt extends At {
  static get type() {
    return "PropertyNode";
  }
  constructor(e, i = null, n = !1) {
    super(e), this.name = i, this.varying = n, this.isPropertyNode = !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  isGlobal() {
    return !0;
  }
  generate(e) {
    let i;
    return this.varying === !0 ? (i = e.getVaryingFromNode(this, this.name), i.needsInterpolation = !0) : i = e.getVarFromNode(this, this.name), e.getPropertyName(i);
  }
}
const Pu = (r, e) => De(new Qt(r, e)), Vm = (r, e) => De(new Qt(r, e, !0)), Wt = /* @__PURE__ */ He(Qt, "vec4", "DiffuseColor"), oM = /* @__PURE__ */ He(Qt, "vec3", "EmissiveColor"), na = /* @__PURE__ */ He(Qt, "float", "Roughness"), Gm = /* @__PURE__ */ He(Qt, "float", "Metalness"), xx = /* @__PURE__ */ He(Qt, "float", "Clearcoat"), Hm = /* @__PURE__ */ He(Qt, "float", "ClearcoatRoughness"), zu = /* @__PURE__ */ He(Qt, "vec3", "Sheen"), wT = /* @__PURE__ */ He(Qt, "float", "SheenRoughness"), ET = /* @__PURE__ */ He(Qt, "float", "Iridescence"), zP = /* @__PURE__ */ He(Qt, "float", "IridescenceIOR"), jP = /* @__PURE__ */ He(Qt, "float", "IridescenceThickness"), _x = /* @__PURE__ */ He(Qt, "float", "AlphaT"), qo = /* @__PURE__ */ He(Qt, "float", "Anisotropy"), sm = /* @__PURE__ */ He(Qt, "vec3", "AnisotropyT"), tc = /* @__PURE__ */ He(Qt, "vec3", "AnisotropyB"), on = /* @__PURE__ */ He(Qt, "color", "SpecularColor"), Wm = /* @__PURE__ */ He(Qt, "float", "SpecularF90"), Tx = /* @__PURE__ */ He(Qt, "float", "Shininess"), eq = /* @__PURE__ */ He(Qt, "vec4", "Output"), F0 = /* @__PURE__ */ He(Qt, "float", "dashSize"), lM = /* @__PURE__ */ He(Qt, "float", "gapSize"), am = /* @__PURE__ */ He(Qt, "float", "IOR"), Sx = /* @__PURE__ */ He(Qt, "float", "Transmission"), VP = /* @__PURE__ */ He(Qt, "float", "Thickness"), GP = /* @__PURE__ */ He(Qt, "float", "AttenuationDistance"), HP = /* @__PURE__ */ He(Qt, "color", "AttenuationColor"), WP = /* @__PURE__ */ He(Qt, "float", "Dispersion");
class tq extends zi {
  static get type() {
    return "AssignNode";
  }
  constructor(e, i) {
    super(), this.targetNode = e, this.sourceNode = i;
  }
  hasDependencies() {
    return !1;
  }
  getNodeType(e, i) {
    return i !== "void" ? this.targetNode.getNodeType(e) : "void";
  }
  needsSplitAssign(e) {
    const { targetNode: i } = this;
    if (e.isAvailable("swizzleAssign") === !1 && i.isSplitNode && i.components.length > 1) {
      const n = e.getTypeLength(i.node.getNodeType(e));
      return Vc.join("").slice(0, n) !== i.components;
    }
    return !1;
  }
  generate(e, i) {
    const { targetNode: n, sourceNode: s } = this, a = this.needsSplitAssign(e), o = n.getNodeType(e), l = n.context({ assign: !0 }).build(e), u = s.build(e, o), c = s.getNodeType(e), h = e.getDataFromNode(this);
    let d;
    if (h.initialized === !0)
      i !== "void" && (d = l);
    else if (a) {
      const p = e.getVarFromNode(this, null, o), f = e.getPropertyName(p);
      e.addLineFlowCode(`${f} = ${u}`, this);
      const m = n.node.context({ assign: !0 }).build(e);
      for (let v = 0; v < n.components.length; v++) {
        const y = n.components[v];
        e.addLineFlowCode(`${m}.${y} = ${f}[ ${v} ]`, this);
      }
      i !== "void" && (d = l);
    } else
      d = `${l} = ${u}`, (i === "void" || c === "void") && (e.addLineFlowCode(d, this), i !== "void" && (d = l));
    return h.initialized = !0, e.format(d, o, i);
  }
}
const iq = /* @__PURE__ */ Me(tq);
fe("assign", iq);
class rq extends zi {
  static get type() {
    return "FunctionCallNode";
  }
  constructor(e = null, i = {}) {
    super(), this.functionNode = e, this.parameters = i;
  }
  setParameters(e) {
    return this.parameters = e, this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(e) {
    return this.functionNode.getNodeType(e);
  }
  generate(e) {
    const i = [], n = this.functionNode, s = n.getInputs(e), a = this.parameters, o = (l, u) => {
      const c = u.type, h = c === "pointer";
      let d;
      return h ? d = "&" + l.build(e) : d = l.build(e, c), d;
    };
    if (Array.isArray(a))
      for (let l = 0; l < a.length; l++)
        i.push(o(a[l], s[l]));
    else
      for (const l of s) {
        const u = a[l.name];
        if (u !== void 0)
          i.push(o(u, l));
        else
          throw new Error(`FunctionCallNode: Input '${l.name}' not found in FunctionNode.`);
      }
    return `${n.build(e, "property")}( ${i.join(", ")} )`;
  }
}
const nq = (r, ...e) => (e = e.length > 1 || e[0] && e[0].isNode === !0 ? Ju(e) : Og(e[0]), De(new rq(De(r), e)));
fe("call", nq);
class yi extends zi {
  static get type() {
    return "OperatorNode";
  }
  constructor(e, i, n, ...s) {
    if (super(), s.length > 0) {
      let a = new yi(e, i, n);
      for (let o = 0; o < s.length - 1; o++)
        a = new yi(e, a, s[o]);
      i = a, n = s[s.length - 1];
    }
    this.op = e, this.aNode = i, this.bNode = n;
  }
  getNodeType(e, i) {
    const n = this.op, s = this.aNode, a = this.bNode, o = s.getNodeType(e), l = typeof a < "u" ? a.getNodeType(e) : null;
    if (o === "void" || l === "void")
      return "void";
    if (n === "%")
      return o;
    if (n === "~" || n === "&" || n === "|" || n === "^" || n === ">>" || n === "<<")
      return e.getIntegerType(o);
    if (n === "!" || n === "==" || n === "&&" || n === "||" || n === "^^")
      return "bool";
    if (n === "<" || n === ">" || n === "<=" || n === ">=") {
      const u = i ? e.getTypeLength(i) : Math.max(e.getTypeLength(o), e.getTypeLength(l));
      return u > 1 ? `bvec${u}` : "bool";
    } else
      return o === "float" && e.isMatrix(l) ? l : e.isMatrix(o) && e.isVector(l) ? e.getVectorFromMatrix(o) : e.isVector(o) && e.isMatrix(l) ? e.getVectorFromMatrix(l) : e.getTypeLength(l) > e.getTypeLength(o) ? l : o;
  }
  generate(e, i) {
    const n = this.op, s = this.aNode, a = this.bNode, o = this.getNodeType(e, i);
    let l = null, u = null;
    o !== "void" ? (l = s.getNodeType(e), u = typeof a < "u" ? a.getNodeType(e) : null, n === "<" || n === ">" || n === "<=" || n === ">=" || n === "==" ? e.isVector(l) ? u = l : l !== u && (l = u = "float") : n === ">>" || n === "<<" ? (l = o, u = e.changeComponentType(u, "uint")) : e.isMatrix(l) && e.isVector(u) ? u = e.getVectorFromMatrix(l) : e.isVector(l) && e.isMatrix(u) ? l = e.getVectorFromMatrix(u) : l = u = o) : l = u = o;
    const c = s.build(e, l), h = typeof a < "u" ? a.build(e, u) : null, d = e.getTypeLength(i), p = e.getFunctionOperator(n);
    if (i !== "void")
      return n === "<" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("lessThan", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} < ${h} )`, o, i) : n === "<=" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("lessThanEqual", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} <= ${h} )`, o, i) : n === ">" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("greaterThan", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} > ${h} )`, o, i) : n === ">=" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("greaterThanEqual", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} >= ${h} )`, o, i) : n === "!" || n === "~" ? e.format(`(${n}${c})`, l, i) : p ? e.format(`${p}( ${c}, ${h} )`, o, i) : e.format(`( ${c} ${n} ${h} )`, o, i);
    if (l !== "void")
      return p ? e.format(`${p}( ${c}, ${h} )`, o, i) : e.format(`${c} ${n} ${h}`, o, i);
  }
  serialize(e) {
    super.serialize(e), e.op = this.op;
  }
  deserialize(e) {
    super.deserialize(e), this.op = e.op;
  }
}
const Nr = /* @__PURE__ */ Me(yi, "+"), un = /* @__PURE__ */ Me(yi, "-"), It = /* @__PURE__ */ Me(yi, "*"), _o = /* @__PURE__ */ Me(yi, "/"), qP = /* @__PURE__ */ Me(yi, "%"), sq = /* @__PURE__ */ Me(yi, "=="), aq = /* @__PURE__ */ Me(yi, "!="), oq = /* @__PURE__ */ Me(yi, "<"), lq = /* @__PURE__ */ Me(yi, ">"), uq = /* @__PURE__ */ Me(yi, "<="), cq = /* @__PURE__ */ Me(yi, ">="), hq = /* @__PURE__ */ Me(yi, "&&"), dq = /* @__PURE__ */ Me(yi, "||"), pq = /* @__PURE__ */ Me(yi, "!"), fq = /* @__PURE__ */ Me(yi, "^^"), mq = /* @__PURE__ */ Me(yi, "&"), gq = /* @__PURE__ */ Me(yi, "~"), yq = /* @__PURE__ */ Me(yi, "|"), vq = /* @__PURE__ */ Me(yi, "^"), bq = /* @__PURE__ */ Me(yi, "<<"), xq = /* @__PURE__ */ Me(yi, ">>");
fe("add", Nr);
fe("sub", un);
fe("mul", It);
fe("div", _o);
fe("modInt", qP);
fe("equal", sq);
fe("notEqual", aq);
fe("lessThan", oq);
fe("greaterThan", lq);
fe("lessThanEqual", uq);
fe("greaterThanEqual", cq);
fe("and", hq);
fe("or", dq);
fe("not", pq);
fe("xor", fq);
fe("bitAnd", mq);
fe("bitNot", gq);
fe("bitOr", yq);
fe("bitXor", vq);
fe("shiftLeft", bq);
fe("shiftRight", xq);
const _q = (...r) => (console.warn("TSL.OperatorNode: .remainder() has been renamed to .modInt()."), qP(...r));
fe("remainder", _q);
class ne extends zi {
  static get type() {
    return "MathNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.method = e, this.aNode = i, this.bNode = n, this.cNode = s;
  }
  getInputType(e) {
    const i = this.aNode.getNodeType(e), n = this.bNode ? this.bNode.getNodeType(e) : null, s = this.cNode ? this.cNode.getNodeType(e) : null, a = e.isMatrix(i) ? 0 : e.getTypeLength(i), o = e.isMatrix(n) ? 0 : e.getTypeLength(n), l = e.isMatrix(s) ? 0 : e.getTypeLength(s);
    return a > o && a > l ? i : o > l ? n : l > a ? s : i;
  }
  getNodeType(e) {
    const i = this.method;
    return i === ne.LENGTH || i === ne.DISTANCE || i === ne.DOT ? "float" : i === ne.CROSS ? "vec3" : i === ne.ALL ? "bool" : i === ne.EQUALS ? e.changeComponentType(this.aNode.getNodeType(e), "bool") : i === ne.MOD ? this.aNode.getNodeType(e) : this.getInputType(e);
  }
  generate(e, i) {
    const n = this.method, s = this.getNodeType(e), a = this.getInputType(e), o = this.aNode, l = this.bNode, u = this.cNode, c = e.renderer.isWebGLRenderer === !0;
    if (n === ne.TRANSFORM_DIRECTION) {
      let h = o, d = l;
      e.isMatrix(h.getNodeType(e)) ? d = _t(ye(d), 0) : h = _t(ye(h), 0);
      const p = It(h, d).xyz;
      return Td(p).build(e, i);
    } else {
      if (n === ne.NEGATE)
        return e.format("( - " + o.build(e, a) + " )", s, i);
      if (n === ne.ONE_MINUS)
        return un(1, o).build(e, i);
      if (n === ne.RECIPROCAL)
        return _o(1, o).build(e, i);
      if (n === ne.DIFFERENCE)
        return qn(un(o, l)).build(e, i);
      {
        const h = [];
        return n === ne.CROSS || n === ne.MOD ? h.push(
          o.build(e, s),
          l.build(e, s)
        ) : c && n === ne.STEP ? h.push(
          o.build(e, e.getTypeLength(o.getNodeType(e)) === 1 ? "float" : a),
          l.build(e, a)
        ) : c && (n === ne.MIN || n === ne.MAX) || n === ne.MOD ? h.push(
          o.build(e, a),
          l.build(e, e.getTypeLength(l.getNodeType(e)) === 1 ? "float" : a)
        ) : n === ne.REFRACT ? h.push(
          o.build(e, a),
          l.build(e, a),
          u.build(e, "float")
        ) : n === ne.MIX ? h.push(
          o.build(e, a),
          l.build(e, a),
          u.build(e, e.getTypeLength(u.getNodeType(e)) === 1 ? "float" : a)
        ) : (h.push(o.build(e, a)), l !== null && h.push(l.build(e, a)), u !== null && h.push(u.build(e, a))), e.format(`${e.getMethod(n, s)}( ${h.join(", ")} )`, s, i);
      }
    }
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
ne.ALL = "all";
ne.ANY = "any";
ne.EQUALS = "equals";
ne.RADIANS = "radians";
ne.DEGREES = "degrees";
ne.EXP = "exp";
ne.EXP2 = "exp2";
ne.LOG = "log";
ne.LOG2 = "log2";
ne.SQRT = "sqrt";
ne.INVERSE_SQRT = "inversesqrt";
ne.FLOOR = "floor";
ne.CEIL = "ceil";
ne.NORMALIZE = "normalize";
ne.FRACT = "fract";
ne.SIN = "sin";
ne.COS = "cos";
ne.TAN = "tan";
ne.ASIN = "asin";
ne.ACOS = "acos";
ne.ATAN = "atan";
ne.ABS = "abs";
ne.SIGN = "sign";
ne.LENGTH = "length";
ne.NEGATE = "negate";
ne.ONE_MINUS = "oneMinus";
ne.DFDX = "dFdx";
ne.DFDY = "dFdy";
ne.ROUND = "round";
ne.RECIPROCAL = "reciprocal";
ne.TRUNC = "trunc";
ne.FWIDTH = "fwidth";
ne.BITCAST = "bitcast";
ne.TRANSPOSE = "transpose";
ne.ATAN2 = "atan2";
ne.MIN = "min";
ne.MAX = "max";
ne.MOD = "mod";
ne.STEP = "step";
ne.REFLECT = "reflect";
ne.DISTANCE = "distance";
ne.DIFFERENCE = "difference";
ne.DOT = "dot";
ne.CROSS = "cross";
ne.POW = "pow";
ne.TRANSFORM_DIRECTION = "transformDirection";
ne.MIX = "mix";
ne.CLAMP = "clamp";
ne.REFRACT = "refract";
ne.SMOOTHSTEP = "smoothstep";
ne.FACEFORWARD = "faceforward";
const Tq = /* @__PURE__ */ ve(1e-6), Sq = /* @__PURE__ */ ve(Math.PI), XP = /* @__PURE__ */ Me(ne, ne.ALL), wq = /* @__PURE__ */ Me(ne, ne.ANY), Eq = /* @__PURE__ */ Me(ne, ne.EQUALS), Mq = /* @__PURE__ */ Me(ne, ne.RADIANS), Aq = /* @__PURE__ */ Me(ne, ne.DEGREES), YP = /* @__PURE__ */ Me(ne, ne.EXP), _d = /* @__PURE__ */ Me(ne, ne.EXP2), $P = /* @__PURE__ */ Me(ne, ne.LOG), xa = /* @__PURE__ */ Me(ne, ne.LOG2), MT = /* @__PURE__ */ Me(ne, ne.SQRT), Cq = /* @__PURE__ */ Me(ne, ne.INVERSE_SQRT), bl = /* @__PURE__ */ Me(ne, ne.FLOOR), AT = /* @__PURE__ */ Me(ne, ne.CEIL), Td = /* @__PURE__ */ Me(ne, ne.NORMALIZE), wo = /* @__PURE__ */ Me(ne, ne.FRACT), Wn = /* @__PURE__ */ Me(ne, ne.SIN), eo = /* @__PURE__ */ Me(ne, ne.COS), Rq = /* @__PURE__ */ Me(ne, ne.TAN), Nq = /* @__PURE__ */ Me(ne, ne.ASIN), Pq = /* @__PURE__ */ Me(ne, ne.ACOS), Oq = /* @__PURE__ */ Me(ne, ne.ATAN), qn = /* @__PURE__ */ Me(ne, ne.ABS), KP = /* @__PURE__ */ Me(ne, ne.SIGN), go = /* @__PURE__ */ Me(ne, ne.LENGTH), Iq = /* @__PURE__ */ Me(ne, ne.NEGATE), Dq = /* @__PURE__ */ Me(ne, ne.ONE_MINUS), QP = /* @__PURE__ */ Me(ne, ne.DFDX), ZP = /* @__PURE__ */ Me(ne, ne.DFDY), kq = /* @__PURE__ */ Me(ne, ne.ROUND), Lq = /* @__PURE__ */ Me(ne, ne.RECIPROCAL), Uq = /* @__PURE__ */ Me(ne, ne.TRUNC), Fq = /* @__PURE__ */ Me(ne, ne.FWIDTH);
ne.BITCAST;
const Bq = /* @__PURE__ */ Me(ne, ne.TRANSPOSE), zq = /* @__PURE__ */ Me(ne, ne.ATAN2), Sd = /* @__PURE__ */ Me(ne, ne.MIN), An = /* @__PURE__ */ Me(ne, ne.MAX), JP = /* @__PURE__ */ Me(ne, ne.MOD), e3 = /* @__PURE__ */ Me(ne, ne.STEP), jq = /* @__PURE__ */ Me(ne, ne.REFLECT), Vq = /* @__PURE__ */ Me(ne, ne.DISTANCE), Gq = /* @__PURE__ */ Me(ne, ne.DIFFERENCE), CT = /* @__PURE__ */ Me(ne, ne.DOT), t3 = /* @__PURE__ */ Me(ne, ne.CROSS), Ig = /* @__PURE__ */ Me(ne, ne.POW), i3 = /* @__PURE__ */ Me(ne, ne.POW, 2), Hq = /* @__PURE__ */ Me(ne, ne.POW, 3), Wq = /* @__PURE__ */ Me(ne, ne.POW, 4), qq = /* @__PURE__ */ Me(ne, ne.TRANSFORM_DIRECTION), Xq = (r) => It(KP(r), Ig(qn(r), 1 / 3)), Yq = (r) => CT(r, r), li = /* @__PURE__ */ Me(ne, ne.MIX), Sa = (r, e = 0, i = 1) => De(new ne(ne.CLAMP, De(r), De(e), De(i))), $q = (r) => Sa(r), r3 = /* @__PURE__ */ Me(ne, ne.REFRACT), Cl = /* @__PURE__ */ Me(ne, ne.SMOOTHSTEP), Kq = /* @__PURE__ */ Me(ne, ne.FACEFORWARD), Qq = /* @__PURE__ */ Be(([r]) => {
  const e = 43758.5453, i = CT(r.xy, qe(12.9898, 78.233)), n = JP(i, Sq);
  return wo(Wn(n).mul(e));
}), Zq = (r, e, i) => li(e, i, r), Jq = (r, e, i) => Cl(e, i, r);
fe("all", XP);
fe("any", wq);
fe("equals", Eq);
fe("radians", Mq);
fe("degrees", Aq);
fe("exp", YP);
fe("exp2", _d);
fe("log", $P);
fe("log2", xa);
fe("sqrt", MT);
fe("inverseSqrt", Cq);
fe("floor", bl);
fe("ceil", AT);
fe("normalize", Td);
fe("fract", wo);
fe("sin", Wn);
fe("cos", eo);
fe("tan", Rq);
fe("asin", Nq);
fe("acos", Pq);
fe("atan", Oq);
fe("abs", qn);
fe("sign", KP);
fe("length", go);
fe("lengthSq", Yq);
fe("negate", Iq);
fe("oneMinus", Dq);
fe("dFdx", QP);
fe("dFdy", ZP);
fe("round", kq);
fe("reciprocal", Lq);
fe("trunc", Uq);
fe("fwidth", Fq);
fe("atan2", zq);
fe("min", Sd);
fe("max", An);
fe("mod", JP);
fe("step", e3);
fe("reflect", jq);
fe("distance", Vq);
fe("dot", CT);
fe("cross", t3);
fe("pow", Ig);
fe("pow2", i3);
fe("pow3", Hq);
fe("pow4", Wq);
fe("transformDirection", qq);
fe("mix", Zq);
fe("clamp", Sa);
fe("refract", r3);
fe("smoothstep", Jq);
fe("faceForward", Kq);
fe("difference", Gq);
fe("saturate", $q);
fe("cbrt", Xq);
fe("transpose", Bq);
fe("rand", Qq);
class eX extends At {
  static get type() {
    return "ConditionalNode";
  }
  constructor(e, i, n = null) {
    super(), this.condNode = e, this.ifNode = i, this.elseNode = n;
  }
  getNodeType(e) {
    const i = this.ifNode.getNodeType(e);
    if (this.elseNode !== null) {
      const n = this.elseNode.getNodeType(e);
      if (e.getTypeLength(n) > e.getTypeLength(i))
        return n;
    }
    return i;
  }
  setup(e) {
    const i = this.condNode.cache(), n = this.ifNode.cache(), s = this.elseNode ? this.elseNode.cache() : null, a = e.context.nodeBlock;
    e.getDataFromNode(n).parentNodeBlock = a, s !== null && (e.getDataFromNode(s).parentNodeBlock = a);
    const o = e.getNodeProperties(this);
    o.condNode = i, o.ifNode = n.context({ nodeBlock: n }), o.elseNode = s ? s.context({ nodeBlock: s }) : null;
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = e.getDataFromNode(this);
    if (s.nodeProperty !== void 0)
      return s.nodeProperty;
    const { condNode: a, ifNode: o, elseNode: l } = e.getNodeProperties(this), u = i !== "void", c = u ? Pu(n).build(e) : "";
    s.nodeProperty = c;
    const h = a.build(e, "bool");
    e.addFlowCode(`
${e.tab}if ( ${h} ) {

`).addFlowTab();
    let d = o.build(e, n);
    if (d && (u ? d = c + " = " + d + ";" : d = "return " + d + ";"), e.removeFlowTab().addFlowCode(e.tab + "	" + d + `

` + e.tab + "}"), l !== null) {
      e.addFlowCode(` else {

`).addFlowTab();
      let p = l.build(e, n);
      p && (u ? p = c + " = " + p + ";" : p = "return " + p + ";"), e.removeFlowTab().addFlowCode(e.tab + "	" + p + `

` + e.tab + `}

`);
    } else
      e.addFlowCode(`

`);
    return e.format(c, n, i);
  }
}
const Br = /* @__PURE__ */ Me(eX);
fe("select", Br);
const tX = (...r) => (console.warn("TSL.ConditionalNode: cond() has been renamed to select()."), Br(...r));
fe("cond", tX);
class n3 extends At {
  static get type() {
    return "ContextNode";
  }
  constructor(e, i = {}) {
    super(), this.isContextNode = !0, this.node = e, this.value = i;
  }
  getScope() {
    return this.node.getScope();
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  analyze(e) {
    this.node.build(e);
  }
  setup(e) {
    const i = e.getContext();
    e.setContext({ ...e.context, ...this.value });
    const n = this.node.build(e);
    return e.setContext(i), n;
  }
  generate(e, i) {
    const n = e.getContext();
    e.setContext({ ...e.context, ...this.value });
    const s = this.node.build(e, i);
    return e.setContext(n), s;
  }
}
const RT = /* @__PURE__ */ Me(n3), iX = (r, e) => RT(r, { label: e });
fe("context", RT);
fe("label", iX);
class rX extends At {
  static get type() {
    return "VarNode";
  }
  constructor(e, i = null) {
    super(), this.node = e, this.name = i, this.global = !0, this.isVarNode = !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { node: i, name: n } = this, s = e.getVarFromNode(this, n, e.getVectorType(this.getNodeType(e))), a = e.getPropertyName(s), o = i.build(e, s.type);
    return e.addLineFlowCode(`${a} = ${o}`, this), a;
  }
}
const s3 = /* @__PURE__ */ Me(rX);
fe("toVar", (...r) => s3(...r).append());
const nX = (r) => (console.warn('TSL: "temp" is deprecated. Use ".toVar()" instead.'), s3(r));
fe("temp", nX);
class sX extends At {
  static get type() {
    return "VaryingNode";
  }
  constructor(e, i = null) {
    super(), this.node = e, this.name = i, this.isVaryingNode = !0;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setupVarying(e) {
    const i = e.getNodeProperties(this);
    let n = i.varying;
    if (n === void 0) {
      const s = this.name, a = this.getNodeType(e);
      i.varying = n = e.getVaryingFromNode(this, s, a), i.node = this.node;
    }
    return n.needsInterpolation || (n.needsInterpolation = e.shaderStage === "fragment"), n;
  }
  setup(e) {
    this.setupVarying(e);
  }
  analyze(e) {
    return this.setupVarying(e), this.node.analyze(e);
  }
  generate(e) {
    const i = e.getNodeProperties(this), n = this.setupVarying(e);
    if (i.propertyName === void 0) {
      const s = this.getNodeType(e), a = e.getPropertyName(n, JE.VERTEX);
      e.flowNodeFromShaderStage(JE.VERTEX, this.node, s, a), i.propertyName = a;
    }
    return e.getPropertyName(n);
  }
}
const Ca = /* @__PURE__ */ Me(sX);
fe("varying", Ca);
const aX = /* @__PURE__ */ Be(([r]) => {
  const e = r.mul(0.9478672986).add(0.0521327014).pow(2.4), i = r.mul(0.0773993808), n = r.lessThanEqual(0.04045);
  return li(e, i, n);
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), oX = /* @__PURE__ */ Be(([r]) => {
  const e = r.pow(0.41666).mul(1.055).sub(0.055), i = r.mul(12.92), n = r.lessThanEqual(31308e-7);
  return li(e, i, n);
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), tp = "WorkingColorSpace", NT = "OutputColorSpace";
class Dg extends zi {
  static get type() {
    return "ColorSpaceNode";
  }
  constructor(e, i, n) {
    super("vec4"), this.colorNode = e, this.source = i, this.target = n;
  }
  resolveColorSpace(e, i) {
    return i === tp ? ki.workingColorSpace : i === NT ? e.context.outputColorSpace || e.renderer.outputColorSpace : i;
  }
  setup(e) {
    const { colorNode: i } = this, n = this.resolveColorSpace(e, this.source), s = this.resolveColorSpace(e, this.target);
    let a = i;
    return ki.enabled === !1 || n === s || !n || !s || (ki.getTransfer(n) === vd && (a = _t(aX(a.rgb), a.a)), ki.getPrimaries(n) !== ki.getPrimaries(s) && (a = _t(
      Rr(ki._getMatrix(new Yr(), n, s)).mul(a.rgb),
      a.a
    )), ki.getTransfer(s) === vd && (a = _t(oX(a.rgb), a.a))), a;
  }
}
const lX = (r) => De(new Dg(De(r), tp, NT)), uX = (r) => De(new Dg(De(r), NT, tp)), cX = (r, e) => De(new Dg(De(r), tp, e)), a3 = (r, e) => De(new Dg(De(r), e, tp));
fe("toOutputColorSpace", lX);
fe("toWorkingColorSpace", uX);
fe("workingToColorSpace", cX);
fe("colorSpaceToWorking", a3);
let hX = class extends Jd {
  static get type() {
    return "ReferenceElementNode";
  }
  constructor(r, e) {
    super(r, e), this.referenceNode = r, this.isReferenceElementNode = !0;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(r) {
    const e = super.generate(r), i = this.referenceNode.getNodeType(), n = this.getNodeType();
    return r.format(e, i, n);
  }
};
class o3 extends At {
  static get type() {
    return "ReferenceBaseNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.property = e, this.uniformType = i, this.object = n, this.count = s, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.updateType = Pt.OBJECT;
  }
  setGroup(e) {
    return this.group = e, this;
  }
  element(e) {
    return De(new hX(this, De(e)));
  }
  setNodeType(e) {
    const i = Tt(null, e).getSelf();
    this.group !== null && i.setGroup(this.group), this.node = i;
  }
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  getValueFromReference(e = this.reference) {
    const { properties: i } = this;
    let n = e[i[0]];
    for (let s = 1; s < i.length; s++)
      n = n[i[s]];
    return n;
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setup() {
    return this.updateValue(), this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const dX = (r, e, i) => De(new o3(r, e, i));
class pX extends o3 {
  static get type() {
    return "RendererReferenceNode";
  }
  constructor(e, i, n = null) {
    super(e, i, n), this.renderer = n, this.setGroup(Ut);
  }
  updateReference(e) {
    return this.reference = this.renderer !== null ? this.renderer : e.renderer, this.reference;
  }
}
const fX = (r, e, i) => De(new pX(r, e, i));
class mX extends zi {
  static get type() {
    return "ToneMappingNode";
  }
  constructor(e, i = yX, n = null) {
    super("vec3"), this.toneMapping = e, this.exposureNode = i, this.colorNode = n;
  }
  getCacheKey() {
    return Fm(super.getCacheKey(), this.toneMapping);
  }
  setup(e) {
    const i = this.colorNode || e.context.color, n = this.toneMapping;
    if (n === Ku) return i;
    let s = null;
    const a = e.renderer.library.getToneMappingFunction(n);
    return a !== null ? s = _t(a(i.rgb, this.exposureNode), i.a) : (console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", n), s = i), s;
  }
}
const gX = (r, e, i) => De(new mX(r, De(e), De(i))), yX = /* @__PURE__ */ fX("toneMappingExposure", "float");
fe("toneMapping", (r, e, i) => gX(e, i, r));
class vX extends bT {
  static get type() {
    return "BufferAttributeNode";
  }
  constructor(e, i = null, n = 0, s = 0) {
    super(e, i), this.isBufferNode = !0, this.bufferType = i, this.bufferStride = n, this.bufferOffset = s, this.usage = Um, this.instanced = !1, this.attribute = null, this.global = !0, e && e.isBufferAttribute === !0 && (this.attribute = e, this.usage = e.usage, this.instanced = e.isInstancedBufferAttribute);
  }
  getHash(e) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let i = e.globalCache.getData(this.value);
      return i === void 0 && (i = {
        node: this
      }, e.globalCache.setData(this.value, i)), i.node.uuid;
    }
    return this.uuid;
  }
  getNodeType(e) {
    return this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)), this.bufferType;
  }
  setup(e) {
    if (this.attribute !== null) return;
    const i = this.getNodeType(e), n = this.value, s = e.getTypeLength(i), a = this.bufferStride || s, o = this.bufferOffset, l = n.isInterleavedBuffer === !0 ? n : new gP(n, a), u = new pT(l, s, o);
    l.setUsage(this.usage), this.attribute = u, this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(e) {
    const i = this.getNodeType(e), n = e.getBufferAttributeFromNode(this, i), s = e.getPropertyName(n);
    let a = null;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? (this.name = s, a = s) : a = Ca(this).build(e, i), a;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(e) {
    return this.usage = e, this.attribute && this.attribute.isBufferAttribute === !0 && (this.attribute.usage = e), this;
  }
  setInstanced(e) {
    return this.instanced = e, this;
  }
}
const PT = (r, e, i, n) => De(new vX(r, e, i, n)), bX = (r, e, i, n) => PT(r, e, i, n).setUsage(Fu), uM = (r, e, i, n) => PT(r, e, i, n).setInstanced(!0), cM = (r, e, i, n) => bX(r, e, i, n).setInstanced(!0);
fe("toAttribute", (r) => PT(r.value));
class xX extends At {
  static get type() {
    return "ComputeNode";
  }
  constructor(e, i, n = [64]) {
    super("void"), this.isComputeNode = !0, this.computeNode = e, this.count = i, this.workgroupSize = n, this.dispatchCount = 0, this.version = 1, this.updateBeforeType = Pt.OBJECT, this.onInitFunction = null, this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  updateDispatchCount() {
    const { count: e, workgroupSize: i } = this;
    let n = i[0];
    for (let s = 1; s < i.length; s++)
      n *= i[s];
    this.dispatchCount = Math.ceil(e / n);
  }
  onInit(e) {
    return this.onInitFunction = e, this;
  }
  updateBefore({ renderer: e }) {
    e.compute(this);
  }
  generate(e) {
    const { shaderStage: i } = e;
    if (i === "compute") {
      const n = this.computeNode.build(e, "void");
      n !== "" && e.addLineFlowCode(n, this);
    }
  }
}
const _X = (r, e, i) => De(new xX(De(r), e, i));
fe("compute", _X);
class TX extends At {
  static get type() {
    return "CacheNode";
  }
  constructor(e, i = !0) {
    super(), this.node = e, this.parent = i, this.isCacheNode = !0;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  build(e, ...i) {
    const n = e.getCache(), s = e.getCacheFromNode(this, this.parent);
    e.setCache(s);
    const a = this.node.build(e, ...i);
    return e.setCache(n), a;
  }
}
const om = (r, ...e) => De(new TX(De(r), ...e));
fe("cache", om);
class SX extends At {
  static get type() {
    return "BypassNode";
  }
  constructor(e, i) {
    super(), this.isBypassNode = !0, this.outputNode = e, this.callNode = i;
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const i = this.callNode.build(e, "void");
    return i !== "" && e.addLineFlowCode(i, this), this.outputNode.build(e);
  }
}
const wX = /* @__PURE__ */ Me(SX);
fe("bypass", wX);
class l3 extends At {
  static get type() {
    return "RemapNode";
  }
  constructor(e, i, n, s = ve(0), a = ve(1)) {
    super(), this.node = e, this.inLowNode = i, this.inHighNode = n, this.outLowNode = s, this.outHighNode = a, this.doClamp = !0;
  }
  setup() {
    const { node: e, inLowNode: i, inHighNode: n, outLowNode: s, outHighNode: a, doClamp: o } = this;
    let l = e.sub(i).div(n.sub(i));
    return o === !0 && (l = l.clamp()), l.mul(a.sub(s)).add(s);
  }
}
const EX = /* @__PURE__ */ Me(l3, null, null, { doClamp: !1 }), MX = /* @__PURE__ */ Me(l3);
fe("remap", EX);
fe("remapClamp", MX);
class AX extends At {
  static get type() {
    return "ExpressionNode";
  }
  constructor(e = "", i = "void") {
    super(i), this.snippet = e;
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.snippet;
    if (n === "void")
      e.addLineFlowCode(s, this);
    else
      return e.format(`( ${s} )`, n, i);
  }
}
const wd = /* @__PURE__ */ Me(AX), CX = (r) => (r ? Br(r, wd("discard")) : wd("discard")).append();
fe("discard", CX);
class RX extends zi {
  static get type() {
    return "RenderOutputNode";
  }
  constructor(e, i, n) {
    super("vec4"), this.colorNode = e, this.toneMapping = i, this.outputColorSpace = n, this.isRenderOutput = !0;
  }
  setup({ context: e }) {
    let i = this.colorNode || e.color;
    const n = (this.toneMapping !== null ? this.toneMapping : e.toneMapping) || Ku, s = (this.outputColorSpace !== null ? this.outputColorSpace : e.outputColorSpace) || El;
    return n !== Ku && (i = i.toneMapping(n)), s !== El && s !== ki.workingColorSpace && (i = i.workingToColorSpace(s)), i;
  }
}
const NX = (r, e = null, i = null) => De(new RX(De(r), e, i));
fe("renderOutput", NX);
class PX extends At {
  static get type() {
    return "AttributeNode";
  }
  constructor(e, i = null) {
    super(i), this.global = !0, this._attributeName = e;
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let i = this.nodeType;
    if (i === null) {
      const n = this.getAttributeName(e);
      if (e.hasGeometryAttribute(n)) {
        const s = e.geometry.getAttribute(n);
        i = e.getTypeFromAttribute(s);
      } else
        i = "float";
    }
    return i;
  }
  setAttributeName(e) {
    return this._attributeName = e, this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const i = this.getAttributeName(e), n = this.getNodeType(e);
    if (e.hasGeometryAttribute(i) === !0) {
      const s = e.geometry.getAttribute(i), a = e.getTypeFromAttribute(s), o = e.getAttribute(i, a);
      return e.shaderStage === "vertex" ? e.format(o.name, a, n) : Ca(this).build(e, n);
    } else
      return console.warn(`AttributeNode: Vertex attribute "${i}" not found on geometry.`), e.generateConst(n);
  }
  serialize(e) {
    super.serialize(e), e.global = this.global, e._attributeName = this._attributeName;
  }
  deserialize(e) {
    super.deserialize(e), this.global = e.global, this._attributeName = e._attributeName;
  }
}
const wa = (r, e) => De(new PX(r, e)), kg = (r) => wa("uv" + (r > 0 ? r : ""), "vec2");
class OX extends At {
  static get type() {
    return "TextureSizeNode";
  }
  constructor(e, i = null) {
    super("uvec2"), this.isTextureSizeNode = !0, this.textureNode = e, this.levelNode = i;
  }
  generate(e, i) {
    const n = this.textureNode.build(e, "property"), s = this.levelNode === null ? "0" : this.levelNode.build(e, "int");
    return e.format(`${e.getMethod("textureDimensions")}( ${n}, ${s} )`, this.getNodeType(e), i);
  }
}
const rd = /* @__PURE__ */ Me(OX);
class IX extends ep {
  static get type() {
    return "MaxMipLevelNode";
  }
  constructor(e) {
    super(0), this._textureNode = e, this.updateType = Pt.FRAME;
  }
  get textureNode() {
    return this._textureNode;
  }
  get texture() {
    return this._textureNode.value;
  }
  update() {
    const e = this.texture, i = e.images, n = i && i.length > 0 ? i[0] && i[0].image || i[0] : e.image;
    if (n && n.width !== void 0) {
      const { width: s, height: a } = n;
      this.value = Math.log2(Math.max(s, a));
    }
  }
}
const DX = /* @__PURE__ */ Me(IX);
class ip extends ep {
  static get type() {
    return "TextureNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e), this.isTextureNode = !0, this.uvNode = i, this.levelNode = n, this.biasNode = s, this.compareNode = null, this.depthNode = null, this.gradNode = null, this.sampler = !0, this.updateMatrix = !1, this.updateType = Pt.NONE, this.referenceNode = null, this._value = e, this._matrixUniform = null, this.setUpdateMatrix(i === null);
  }
  set value(e) {
    this.referenceNode ? this.referenceNode.value = e : this._value = e;
  }
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : this.value.type === Ji ? "uvec4" : this.value.type === Tr ? "ivec4" : "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return kg(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(e) {
    return this._matrixUniform === null && (this._matrixUniform = Tt(this.value.matrix)), this._matrixUniform.mul(ye(e, 1)).xy;
  }
  setUpdateMatrix(e) {
    return this.updateMatrix = e, this.updateType = e ? Pt.FRAME : Pt.NONE, this;
  }
  setupUV(e, i) {
    const n = this.value;
    return e.isFlipY() && (n.isRenderTargetTexture === !0 || n.isFramebufferTexture === !0 || n.isDepthTexture === !0) && (this.sampler ? i = i.flipY() : i = i.setY(Mi(rd(this, this.levelNode).y).sub(i.y).sub(1))), i;
  }
  setup(e) {
    const i = e.getNodeProperties(this);
    i.referenceNode = this.referenceNode;
    let n = this.uvNode;
    (n === null || e.context.forceUVContext === !0) && e.context.getUV && (n = e.context.getUV(this)), n || (n = this.getDefaultUV()), this.updateMatrix === !0 && (n = this.getTransformedUV(n)), n = this.setupUV(e, n);
    let s = this.levelNode;
    s === null && e.context.getTextureLevel && (s = e.context.getTextureLevel(this)), i.uvNode = n, i.levelNode = s, i.biasNode = this.biasNode, i.compareNode = this.compareNode, i.gradNode = this.gradNode, i.depthNode = this.depthNode;
  }
  generateUV(e, i) {
    return i.build(e, this.sampler === !0 ? "vec2" : "ivec2");
  }
  generateSnippet(e, i, n, s, a, o, l, u) {
    const c = this.value;
    let h;
    return s ? h = e.generateTextureLevel(c, i, n, s, o) : a ? h = e.generateTextureBias(c, i, n, a, o) : u ? h = e.generateTextureGrad(c, i, n, u, o) : l ? h = e.generateTextureCompare(c, i, n, l, o) : this.sampler === !1 ? h = e.generateTextureLoad(c, i, n, o) : h = e.generateTexture(c, i, n, o), h;
  }
  generate(e, i) {
    const n = e.getNodeProperties(this), s = this.value;
    if (!s || s.isTexture !== !0)
      throw new Error("TextureNode: Need a three.js texture.");
    const a = super.generate(e, "property");
    if (i === "sampler")
      return a + "_sampler";
    if (e.isReference(i))
      return a;
    {
      const o = e.getDataFromNode(this);
      let l = o.propertyName;
      if (l === void 0) {
        const { uvNode: h, levelNode: d, biasNode: p, compareNode: f, depthNode: m, gradNode: v } = n, y = this.generateUV(e, h), g = d ? d.build(e, "float") : null, _ = p ? p.build(e, "float") : null, x = m ? m.build(e, "int") : null, b = f ? f.build(e, "float") : null, T = v ? [v[0].build(e, "vec2"), v[1].build(e, "vec2")] : null, S = e.getVarFromNode(this);
        l = e.getPropertyName(S);
        const w = this.generateSnippet(e, a, y, g, _, x, b, T);
        e.addLineFlowCode(`${l} = ${w}`, this), o.snippet = w, o.propertyName = l;
      }
      let u = l;
      const c = this.getNodeType(e);
      return e.needsToWorkingColorSpace(s) && (u = a3(wd(u, c), s.colorSpace).setup(e).build(e, c)), e.format(u, c, i);
    }
  }
  setSampler(e) {
    return this.sampler = e, this;
  }
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  uv(e) {
    const i = this.clone();
    return i.uvNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  blur(e) {
    const i = this.clone();
    return i.biasNode = De(e).mul(DX(i)), i.referenceNode = this.getSelf(), De(i);
  }
  level(e) {
    const i = this.clone();
    return i.levelNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  size(e) {
    return rd(this, e);
  }
  bias(e) {
    const i = this.clone();
    return i.biasNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  compare(e) {
    const i = this.clone();
    return i.compareNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  grad(e, i) {
    const n = this.clone();
    return n.gradNode = [De(e), De(i)], n.referenceNode = this.getSelf(), De(n);
  }
  depth(e) {
    const i = this.clone();
    return i.depthNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  // --
  serialize(e) {
    super.serialize(e), e.value = this.value.toJSON(e.meta).uuid, e.sampler = this.sampler, e.updateMatrix = this.updateMatrix, e.updateType = this.updateType;
  }
  deserialize(e) {
    super.deserialize(e), this.value = e.meta.textures[e.value], this.sampler = e.sampler, this.updateMatrix = e.updateMatrix, this.updateType = e.updateType;
  }
  update() {
    const e = this.value, i = this._matrixUniform;
    i !== null && (i.value = e.matrix), e.matrixAutoUpdate === !0 && e.updateMatrix();
  }
  clone() {
    const e = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
    return e.sampler = this.sampler, e;
  }
}
const Ci = /* @__PURE__ */ Me(ip), zn = (...r) => Ci(...r).setSampler(!1), Qo = /* @__PURE__ */ Tt("float").label("cameraNear").setGroup(Ut).onRenderUpdate(({ camera: r }) => r.near), Zo = /* @__PURE__ */ Tt("float").label("cameraFar").setGroup(Ut).onRenderUpdate(({ camera: r }) => r.far), qm = /* @__PURE__ */ Tt("mat4").label("cameraProjectionMatrix").setGroup(Ut).onRenderUpdate(({ camera: r }) => r.projectionMatrix), Ra = /* @__PURE__ */ Tt("mat4").label("cameraViewMatrix").setGroup(Ut).onRenderUpdate(({ camera: r }) => r.matrixWorldInverse), kX = /* @__PURE__ */ Tt(new oe()).label("cameraPosition").setGroup(Ut).onRenderUpdate(({ camera: r }, e) => e.value.setFromMatrixPosition(r.matrixWorld));
class wi extends At {
  static get type() {
    return "Object3DNode";
  }
  constructor(e, i = null) {
    super(), this.scope = e, this.object3d = i, this.updateType = Pt.OBJECT, this._uniformNode = new ep(null);
  }
  getNodeType() {
    const e = this.scope;
    if (e === wi.WORLD_MATRIX)
      return "mat4";
    if (e === wi.POSITION || e === wi.VIEW_POSITION || e === wi.DIRECTION || e === wi.SCALE)
      return "vec3";
  }
  update(e) {
    const i = this.object3d, n = this._uniformNode, s = this.scope;
    if (s === wi.WORLD_MATRIX)
      n.value = i.matrixWorld;
    else if (s === wi.POSITION)
      n.value = n.value || new oe(), n.value.setFromMatrixPosition(i.matrixWorld);
    else if (s === wi.SCALE)
      n.value = n.value || new oe(), n.value.setFromMatrixScale(i.matrixWorld);
    else if (s === wi.DIRECTION)
      n.value = n.value || new oe(), i.getWorldDirection(n.value);
    else if (s === wi.VIEW_POSITION) {
      const a = e.camera;
      n.value = n.value || new oe(), n.value.setFromMatrixPosition(i.matrixWorld), n.value.applyMatrix4(a.matrixWorldInverse);
    }
  }
  generate(e) {
    const i = this.scope;
    return i === wi.WORLD_MATRIX ? this._uniformNode.nodeType = "mat4" : (i === wi.POSITION || i === wi.VIEW_POSITION || i === wi.DIRECTION || i === wi.SCALE) && (this._uniformNode.nodeType = "vec3"), this._uniformNode.build(e);
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
wi.WORLD_MATRIX = "worldMatrix";
wi.POSITION = "position";
wi.SCALE = "scale";
wi.VIEW_POSITION = "viewPosition";
wi.DIRECTION = "direction";
class Ec extends wi {
  static get type() {
    return "ModelNode";
  }
  constructor(e) {
    super(e);
  }
  update(e) {
    this.object3d = e.object, super.update(e);
  }
}
Ec.DIRECTION;
const Rl = /* @__PURE__ */ He(Ec, Ec.WORLD_MATRIX);
Ec.POSITION;
Ec.SCALE;
Ec.VIEW_POSITION;
const LX = /* @__PURE__ */ Tt(new Yr()).onObjectUpdate(({ object: r }, e) => e.value.getNormalMatrix(r.matrixWorld)), Lg = /* @__PURE__ */ Ra.mul(Rl).toVar("modelViewMatrix"), u3 = /* @__PURE__ */ wa("position", "vec3"), nr = /* @__PURE__ */ u3.varying("positionLocal"), hM = /* @__PURE__ */ u3.varying("positionPrevious"), wx = /* @__PURE__ */ Rl.mul(nr).xyz.varying("v_positionWorld"), c3 = /* @__PURE__ */ nr.transformDirection(Rl).varying("v_positionWorldDirection").normalize().toVar("positionWorldDirection"), ir = /* @__PURE__ */ Lg.mul(nr).xyz.varying("v_positionView"), vi = /* @__PURE__ */ ir.negate().varying("v_positionViewDirection").normalize().toVar("positionViewDirection");
class UX extends At {
  static get type() {
    return "FrontFacingNode";
  }
  constructor() {
    super("bool"), this.isFrontFacingNode = !0;
  }
  generate(e) {
    const { renderer: i, material: n } = e;
    return i.coordinateSystem === Zn && n.side === es ? "false" : e.getFrontFacing();
  }
}
const FX = /* @__PURE__ */ He(UX), Ug = /* @__PURE__ */ ve(FX).mul(2).sub(1), h3 = /* @__PURE__ */ wa("normal", "vec3"), ws = /* @__PURE__ */ Be((r) => r.geometry.hasAttribute("normal") === !1 ? (console.warn('TSL.NormalNode: Vertex attribute "normal" not found on geometry.'), ye(0, 1, 0)) : h3, "vec3").once()().toVar("normalLocal"), BX = /* @__PURE__ */ ir.dFdx().cross(ir.dFdy()).normalize().toVar("normalFlat"), is = /* @__PURE__ */ Be((r) => {
  let e;
  return r.material.flatShading === !0 ? e = BX : e = Ca(p3(ws), "v_normalView").normalize(), e;
}, "vec3").once()().toVar("normalView"), d3 = /* @__PURE__ */ Ca(is.transformDirection(Ra), "v_normalWorld").normalize().toVar("normalWorld"), Ui = /* @__PURE__ */ Be((r) => r.context.setupNormal(), "vec3").once()().mul(Ug).toVar("transformedNormalView"), OT = /* @__PURE__ */ Ui.transformDirection(Ra).toVar("transformedNormalWorld"), Vh = /* @__PURE__ */ Be((r) => r.context.setupClearcoatNormal(), "vec3").once()().mul(Ug).toVar("transformedClearcoatNormalView"), zX = /* @__PURE__ */ Be(([r, e = Rl]) => {
  const i = Rr(e), n = r.div(ye(i[0].dot(i[0]), i[1].dot(i[1]), i[2].dot(i[2])));
  return i.mul(n).xyz;
}), p3 = /* @__PURE__ */ Be(([r], e) => {
  const i = e.renderer.nodes.modelNormalViewMatrix;
  if (i !== null)
    return i.transformDirection(r);
  const n = LX.mul(r);
  return Ra.transformDirection(n);
}), jX = /* @__PURE__ */ Tt(0).onReference(({ material: r }) => r).onRenderUpdate(({ material: r }) => r.refractionRatio), VX = /* @__PURE__ */ vi.negate().reflect(Ui), GX = /* @__PURE__ */ vi.negate().refract(Ui, jX), HX = /* @__PURE__ */ VX.transformDirection(Ra).toVar("reflectVector"), WX = /* @__PURE__ */ GX.transformDirection(Ra).toVar("reflectVector");
class qX extends ip {
  static get type() {
    return "CubeTextureNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e, i, n, s), this.isCubeTextureNode = !0;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    const e = this.value;
    return e.mapping === wl ? HX : e.mapping === Tc ? WX : (console.error('THREE.CubeTextureNode: Mapping "%s" not supported.', e.mapping), ye(0, 0, 0));
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  setupUV(e, i) {
    const n = this.value;
    return e.renderer.coordinateSystem === Ml || !n.isRenderTargetTexture ? ye(i.x.negate(), i.yz) : i;
  }
  generateUV(e, i) {
    return i.build(e, "vec3");
  }
}
const Ed = /* @__PURE__ */ Me(qX);
class f3 extends ep {
  static get type() {
    return "BufferNode";
  }
  constructor(e, i, n = 0) {
    super(e, i), this.isBufferNode = !0, this.bufferType = i, this.bufferCount = n;
  }
  getElementType(e) {
    return this.getNodeType(e);
  }
  getInputType() {
    return "buffer";
  }
}
const IT = (r, e, i) => De(new f3(r, e, i));
class XX extends Jd {
  static get type() {
    return "UniformArrayElementNode";
  }
  constructor(e, i) {
    super(e, i), this.isArrayBufferElementNode = !0;
  }
  generate(e) {
    const i = super.generate(e), n = this.getNodeType();
    return e.format(i, "vec4", n);
  }
}
class YX extends f3 {
  static get type() {
    return "UniformArrayNode";
  }
  constructor(e, i = null) {
    super(null, "vec4"), this.array = e, this.elementType = i, this._elementType = null, this._elementLength = 0, this.updateType = Pt.RENDER, this.isArrayBufferNode = !0;
  }
  getElementType() {
    return this.elementType || this._elementType;
  }
  getElementLength() {
    return this._elementLength;
  }
  update() {
    const { array: e, value: i } = this, n = this.getElementLength(), s = this.getElementType();
    if (n === 1)
      for (let a = 0; a < e.length; a++) {
        const o = a * 4;
        i[o] = e[a];
      }
    else if (s === "color")
      for (let a = 0; a < e.length; a++) {
        const o = a * 4, l = e[a];
        i[o] = l.r, i[o + 1] = l.g, i[o + 2] = l.b || 0;
      }
    else
      for (let a = 0; a < e.length; a++) {
        const o = a * 4, l = e[a];
        i[o] = l.x, i[o + 1] = l.y, i[o + 2] = l.z || 0, i[o + 3] = l.w || 0;
      }
  }
  setup(e) {
    const i = this.array.length;
    this._elementType = this.elementType === null ? zm(this.array[0]) : this.elementType, this._elementLength = e.getTypeLength(this._elementType);
    let n = Float32Array;
    return this._elementType.charAt(0) === "i" ? n = Int32Array : this._elementType.charAt(0) === "u" && (n = Uint32Array), this.value = new n(i * 4), this.bufferCount = i, this.bufferType = e.changeComponentType("vec4", e.getComponentType(this._elementType)), super.setup(e);
  }
  element(e) {
    return De(new XX(this, De(e)));
  }
}
const Md = (r, e) => De(new YX(r, e));
class $X extends Jd {
  static get type() {
    return "ReferenceElementNode";
  }
  constructor(e, i) {
    super(e, i), this.referenceNode = e, this.isReferenceElementNode = !0;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(e) {
    const i = super.generate(e), n = this.referenceNode.getNodeType(), s = this.getNodeType();
    return e.format(i, n, s);
  }
}
class DT extends At {
  static get type() {
    return "ReferenceNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.property = e, this.uniformType = i, this.object = n, this.count = s, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.name = null, this.updateType = Pt.OBJECT;
  }
  element(e) {
    return De(new $X(this, De(e)));
  }
  setGroup(e) {
    return this.group = e, this;
  }
  label(e) {
    return this.name = e, this;
  }
  setNodeType(e) {
    let i = null;
    this.count !== null ? i = IT(null, e, this.count) : Array.isArray(this.getValueFromReference()) ? i = Md(null, e) : e === "texture" ? i = Ci(null) : e === "cubeTexture" ? i = Ed(null) : i = Tt(null, e), this.group !== null && i.setGroup(this.group), this.name !== null && i.label(this.name), this.node = i.getSelf();
  }
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  getValueFromReference(e = this.reference) {
    const { properties: i } = this;
    let n = e[i[0]];
    for (let s = 1; s < i.length; s++)
      n = n[i[s]];
    return n;
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setup() {
    return this.updateValue(), this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const bi = (r, e, i) => De(new DT(r, e, i)), dM = (r, e, i, n) => De(new DT(r, e, n, i));
class KX extends DT {
  static get type() {
    return "MaterialReferenceNode";
  }
  constructor(e, i, n = null) {
    super(e, i, n), this.material = n, this.isMaterialReferenceNode = !0;
  }
  /*setNodeType( node ) {
  
  		super.setNodeType( node );
  
  		this.node.groupNode = renderGroup;
  
  	}*/
  updateReference(e) {
    return this.reference = this.material !== null ? this.material : e.material, this.reference;
  }
}
const ro = (r, e, i) => De(new KX(r, e, i)), m3 = /* @__PURE__ */ Be((r) => (r.geometry.hasAttribute("tangent") === !1 && r.geometry.computeTangents(), wa("tangent", "vec4")))(), kT = /* @__PURE__ */ m3.xyz.toVar("tangentLocal"), g3 = /* @__PURE__ */ Lg.mul(_t(kT, 0)).xyz.varying("v_tangentView").normalize().toVar("tangentView"), QX = (r) => r.mul(m3.w).xyz, ZX = /* @__PURE__ */ Ca(QX(is.cross(g3)), "v_bitangentView").normalize().toVar("bitangentView"), Gh = /* @__PURE__ */ Rr(g3, ZX, is), JX = /* @__PURE__ */ (() => {
  let r = tc.cross(vi);
  return r = r.cross(tc).normalize(), r = li(r, Ui, qo.mul(na.oneMinus()).oneMinus().pow2().pow2()).normalize(), r;
})(), eY = /* @__PURE__ */ Be((r) => {
  const { eye_pos: e, surf_norm: i, mapN: n, uv: s } = r, a = e.dFdx(), o = e.dFdy(), l = s.dFdx(), u = s.dFdy(), c = i, h = o.cross(c), d = c.cross(a), p = h.mul(l.x).add(d.mul(u.x)), f = h.mul(l.y).add(d.mul(u.y)), m = p.dot(p).max(f.dot(f)), v = Ug.mul(m.inverseSqrt());
  return Nr(p.mul(n.x, v), f.mul(n.y, v), c.mul(n.z)).normalize();
});
class tY extends zi {
  static get type() {
    return "NormalMapNode";
  }
  constructor(e, i = null) {
    super("vec3"), this.node = e, this.scaleNode = i, this.normalMapType = xo;
  }
  setup(e) {
    const { normalMapType: i, scaleNode: n } = this;
    let s = this.node.mul(2).sub(1);
    n !== null && (s = ye(s.xy.mul(n), s.z));
    let a = null;
    return i === $9 ? a = p3(s) : i === xo && (e.hasGeometryAttribute("tangent") === !0 ? a = Gh.mul(s).normalize() : a = eY({
      eye_pos: ir,
      surf_norm: is,
      mapN: s,
      uv: kg()
    })), a;
  }
}
const pM = /* @__PURE__ */ Me(tY), iY = Be(({ textureNode: r, bumpScale: e }) => {
  const i = (s) => r.cache().context({ getUV: (a) => s(a.uvNode || kg()), forceUVContext: !0 }), n = ve(i((s) => s));
  return qe(
    ve(i((s) => s.add(s.dFdx()))).sub(n),
    ve(i((s) => s.add(s.dFdy()))).sub(n)
  ).mul(e);
}), rY = Be((r) => {
  const { surf_pos: e, surf_norm: i, dHdxy: n } = r, s = e.dFdx().normalize(), a = e.dFdy().normalize(), o = i, l = a.cross(o), u = o.cross(s), c = s.dot(l).mul(Ug), h = c.sign().mul(n.x.mul(l).add(n.y.mul(u)));
  return c.abs().mul(i).sub(h).normalize();
});
class nY extends zi {
  static get type() {
    return "BumpMapNode";
  }
  constructor(e, i = null) {
    super("vec3"), this.textureNode = e, this.scaleNode = i;
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1, i = iY({ textureNode: this.textureNode, bumpScale: e });
    return rY({
      surf_pos: ir,
      surf_norm: is,
      dHdxy: i
    });
  }
}
const sY = /* @__PURE__ */ Me(nY), fM = /* @__PURE__ */ new Map();
class pe extends At {
  static get type() {
    return "MaterialNode";
  }
  constructor(e) {
    super(), this.scope = e;
  }
  getCache(e, i) {
    let n = fM.get(e);
    return n === void 0 && (n = ro(e, i), fM.set(e, n)), n;
  }
  getFloat(e) {
    return this.getCache(e, "float");
  }
  getColor(e) {
    return this.getCache(e, "color");
  }
  getTexture(e) {
    return this.getCache(e === "map" ? "map" : e + "Map", "texture");
  }
  setup(e) {
    const i = e.context.material, n = this.scope;
    let s = null;
    if (n === pe.COLOR) {
      const a = i.color !== void 0 ? this.getColor(n) : ye();
      i.map && i.map.isTexture === !0 ? s = a.mul(this.getTexture("map")) : s = a;
    } else if (n === pe.OPACITY) {
      const a = this.getFloat(n);
      i.alphaMap && i.alphaMap.isTexture === !0 ? s = a.mul(this.getTexture("alpha")) : s = a;
    } else if (n === pe.SPECULAR_STRENGTH)
      i.specularMap && i.specularMap.isTexture === !0 ? s = this.getTexture("specular").r : s = ve(1);
    else if (n === pe.SPECULAR_INTENSITY) {
      const a = this.getFloat(n);
      i.specularMap ? s = a.mul(this.getTexture(n).a) : s = a;
    } else if (n === pe.SPECULAR_COLOR) {
      const a = this.getColor(n);
      i.specularColorMap && i.specularColorMap.isTexture === !0 ? s = a.mul(this.getTexture(n).rgb) : s = a;
    } else if (n === pe.ROUGHNESS) {
      const a = this.getFloat(n);
      i.roughnessMap && i.roughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).g) : s = a;
    } else if (n === pe.METALNESS) {
      const a = this.getFloat(n);
      i.metalnessMap && i.metalnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).b) : s = a;
    } else if (n === pe.EMISSIVE) {
      const a = this.getFloat("emissiveIntensity"), o = this.getColor(n).mul(a);
      i.emissiveMap && i.emissiveMap.isTexture === !0 ? s = o.mul(this.getTexture(n)) : s = o;
    } else if (n === pe.NORMAL)
      i.normalMap ? (s = pM(this.getTexture("normal"), this.getCache("normalScale", "vec2")), s.normalMapType = i.normalMapType) : i.bumpMap ? s = sY(this.getTexture("bump").r, this.getFloat("bumpScale")) : s = is;
    else if (n === pe.CLEARCOAT) {
      const a = this.getFloat(n);
      i.clearcoatMap && i.clearcoatMap.isTexture === !0 ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === pe.CLEARCOAT_ROUGHNESS) {
      const a = this.getFloat(n);
      i.clearcoatRoughnessMap && i.clearcoatRoughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === pe.CLEARCOAT_NORMAL)
      i.clearcoatNormalMap ? s = pM(this.getTexture(n), this.getCache(n + "Scale", "vec2")) : s = is;
    else if (n === pe.SHEEN) {
      const a = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      i.sheenColorMap && i.sheenColorMap.isTexture === !0 ? s = a.mul(this.getTexture("sheenColor").rgb) : s = a;
    } else if (n === pe.SHEEN_ROUGHNESS) {
      const a = this.getFloat(n);
      i.sheenRoughnessMap && i.sheenRoughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).a) : s = a, s = s.clamp(0.07, 1);
    } else if (n === pe.ANISOTROPY)
      if (i.anisotropyMap && i.anisotropyMap.isTexture === !0) {
        const a = this.getTexture(n);
        s = ST(_h.x, _h.y, _h.y.negate(), _h.x).mul(a.rg.mul(2).sub(qe(1)).normalize().mul(a.b));
      } else
        s = _h;
    else if (n === pe.IRIDESCENCE_THICKNESS) {
      const a = bi("1", "float", i.iridescenceThicknessRange);
      if (i.iridescenceThicknessMap) {
        const o = bi("0", "float", i.iridescenceThicknessRange);
        s = a.sub(o).mul(this.getTexture(n).g).add(o);
      } else
        s = a;
    } else if (n === pe.TRANSMISSION) {
      const a = this.getFloat(n);
      i.transmissionMap ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === pe.THICKNESS) {
      const a = this.getFloat(n);
      i.thicknessMap ? s = a.mul(this.getTexture(n).g) : s = a;
    } else if (n === pe.IOR)
      s = this.getFloat(n);
    else if (n === pe.LIGHT_MAP)
      s = this.getTexture(n).rgb.mul(this.getFloat("lightMapIntensity"));
    else if (n === pe.AO_MAP)
      s = this.getTexture(n).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
    else {
      const a = this.getNodeType(e);
      s = this.getCache(n, a);
    }
    return s;
  }
}
pe.ALPHA_TEST = "alphaTest";
pe.COLOR = "color";
pe.OPACITY = "opacity";
pe.SHININESS = "shininess";
pe.SPECULAR = "specular";
pe.SPECULAR_STRENGTH = "specularStrength";
pe.SPECULAR_INTENSITY = "specularIntensity";
pe.SPECULAR_COLOR = "specularColor";
pe.REFLECTIVITY = "reflectivity";
pe.ROUGHNESS = "roughness";
pe.METALNESS = "metalness";
pe.NORMAL = "normal";
pe.CLEARCOAT = "clearcoat";
pe.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
pe.CLEARCOAT_NORMAL = "clearcoatNormal";
pe.EMISSIVE = "emissive";
pe.ROTATION = "rotation";
pe.SHEEN = "sheen";
pe.SHEEN_ROUGHNESS = "sheenRoughness";
pe.ANISOTROPY = "anisotropy";
pe.IRIDESCENCE = "iridescence";
pe.IRIDESCENCE_IOR = "iridescenceIOR";
pe.IRIDESCENCE_THICKNESS = "iridescenceThickness";
pe.IOR = "ior";
pe.TRANSMISSION = "transmission";
pe.THICKNESS = "thickness";
pe.ATTENUATION_DISTANCE = "attenuationDistance";
pe.ATTENUATION_COLOR = "attenuationColor";
pe.LINE_SCALE = "scale";
pe.LINE_DASH_SIZE = "dashSize";
pe.LINE_GAP_SIZE = "gapSize";
pe.LINE_WIDTH = "linewidth";
pe.LINE_DASH_OFFSET = "dashOffset";
pe.POINT_WIDTH = "pointWidth";
pe.DISPERSION = "dispersion";
pe.LIGHT_MAP = "light";
pe.AO_MAP = "ao";
const aY = /* @__PURE__ */ He(pe, pe.ALPHA_TEST), oY = /* @__PURE__ */ He(pe, pe.COLOR), lY = /* @__PURE__ */ He(pe, pe.SHININESS), uY = /* @__PURE__ */ He(pe, pe.EMISSIVE), y3 = /* @__PURE__ */ He(pe, pe.OPACITY), cY = /* @__PURE__ */ He(pe, pe.SPECULAR), mM = /* @__PURE__ */ He(pe, pe.SPECULAR_INTENSITY), hY = /* @__PURE__ */ He(pe, pe.SPECULAR_COLOR), lm = /* @__PURE__ */ He(pe, pe.SPECULAR_STRENGTH), B0 = /* @__PURE__ */ He(pe, pe.REFLECTIVITY), dY = /* @__PURE__ */ He(pe, pe.ROUGHNESS), pY = /* @__PURE__ */ He(pe, pe.METALNESS), fY = /* @__PURE__ */ He(pe, pe.NORMAL).context({ getUV: null }), mY = /* @__PURE__ */ He(pe, pe.CLEARCOAT), gY = /* @__PURE__ */ He(pe, pe.CLEARCOAT_ROUGHNESS), yY = /* @__PURE__ */ He(pe, pe.CLEARCOAT_NORMAL).context({ getUV: null }), vY = /* @__PURE__ */ He(pe, pe.ROTATION), bY = /* @__PURE__ */ He(pe, pe.SHEEN), xY = /* @__PURE__ */ He(pe, pe.SHEEN_ROUGHNESS), _Y = /* @__PURE__ */ He(pe, pe.ANISOTROPY), TY = /* @__PURE__ */ He(pe, pe.IRIDESCENCE), SY = /* @__PURE__ */ He(pe, pe.IRIDESCENCE_IOR), wY = /* @__PURE__ */ He(pe, pe.IRIDESCENCE_THICKNESS), EY = /* @__PURE__ */ He(pe, pe.TRANSMISSION), MY = /* @__PURE__ */ He(pe, pe.THICKNESS), AY = /* @__PURE__ */ He(pe, pe.IOR), CY = /* @__PURE__ */ He(pe, pe.ATTENUATION_DISTANCE), RY = /* @__PURE__ */ He(pe, pe.ATTENUATION_COLOR), NY = /* @__PURE__ */ He(pe, pe.LINE_SCALE), PY = /* @__PURE__ */ He(pe, pe.LINE_DASH_SIZE), OY = /* @__PURE__ */ He(pe, pe.LINE_GAP_SIZE);
pe.LINE_WIDTH;
pe.LINE_DASH_OFFSET;
pe.POINT_WIDTH;
const IY = /* @__PURE__ */ He(pe, pe.DISPERSION), v3 = /* @__PURE__ */ He(pe, pe.LIGHT_MAP), DY = /* @__PURE__ */ He(pe, pe.AO_MAP), _h = /* @__PURE__ */ Tt(new jt()).onReference(function(r) {
  return r.material;
}).onRenderUpdate(function({ material: r }) {
  this.value.set(r.anisotropy * Math.cos(r.anisotropyRotation), r.anisotropy * Math.sin(r.anisotropyRotation));
});
class kY extends zi {
  static get type() {
    return "ModelViewProjectionNode";
  }
  constructor(e = null) {
    super("vec4"), this.positionNode = e;
  }
  setup(e) {
    if (e.shaderStage === "fragment")
      return Ca(e.context.mvp);
    const i = this.positionNode || nr, n = e.renderer.nodes.modelViewMatrix || Lg;
    return qm.mul(n).mul(i);
  }
}
const Ex = /* @__PURE__ */ Me(kY);
class Ai extends At {
  static get type() {
    return "IndexNode";
  }
  constructor(e) {
    super("uint"), this.scope = e, this.isInstanceIndexNode = !0;
  }
  generate(e) {
    const i = this.getNodeType(e), n = this.scope;
    let s;
    if (n === Ai.VERTEX)
      s = e.getVertexIndex();
    else if (n === Ai.INSTANCE)
      s = e.getInstanceIndex();
    else if (n === Ai.DRAW)
      s = e.getDrawIndex();
    else if (n === Ai.INVOCATION_LOCAL)
      s = e.getInvocationLocalIndex();
    else if (n === Ai.INVOCATION_SUBGROUP)
      s = e.getInvocationSubgroupIndex();
    else if (n === Ai.SUBGROUP)
      s = e.getSubgroupIndex();
    else
      throw new Error("THREE.IndexNode: Unknown scope: " + n);
    let a;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? a = s : a = Ca(this).build(e, i), a;
  }
}
Ai.VERTEX = "vertex";
Ai.INSTANCE = "instance";
Ai.SUBGROUP = "subgroup";
Ai.INVOCATION_LOCAL = "invocationLocal";
Ai.INVOCATION_SUBGROUP = "invocationSubgroup";
Ai.DRAW = "draw";
const LY = /* @__PURE__ */ He(Ai, Ai.VERTEX), LT = /* @__PURE__ */ He(Ai, Ai.INSTANCE);
Ai.SUBGROUP;
Ai.INVOCATION_SUBGROUP;
Ai.INVOCATION_LOCAL;
const UY = /* @__PURE__ */ He(Ai, Ai.DRAW);
class FY extends At {
  static get type() {
    return "InstanceNode";
  }
  constructor(e) {
    super("void"), this.instanceMesh = e, this.instanceMatrixNode = null, this.instanceColorNode = null, this.updateType = Pt.FRAME, this.buffer = null, this.bufferColor = null;
  }
  setup(e) {
    let i = this.instanceMatrixNode, n = this.instanceColorNode;
    const s = this.instanceMesh;
    if (i === null) {
      const l = s.instanceMatrix;
      if (s.count <= 1e3)
        i = IT(l.array, "mat4", Math.max(s.count, 1)).element(LT);
      else {
        const u = new fW(l.array, 16, 1);
        this.buffer = u;
        const c = l.usage === Fu ? cM : uM, h = [
          // F.Signature -> bufferAttribute( array, type, stride, offset )
          c(u, "vec4", 16, 0),
          c(u, "vec4", 16, 4),
          c(u, "vec4", 16, 8),
          c(u, "vec4", 16, 12)
        ];
        i = ec(...h);
      }
      this.instanceMatrixNode = i;
    }
    const a = s.instanceColor;
    if (a && n === null) {
      const l = new eW(a.array, 3), u = a.usage === Fu ? cM : uM;
      this.bufferColor = l, n = ye(u(l, "vec3", 3, 0)), this.instanceColorNode = n;
    }
    const o = i.mul(nr).xyz;
    if (nr.assign(o), e.hasGeometryAttribute("normal")) {
      const l = zX(ws, i);
      ws.assign(l);
    }
    this.instanceColorNode !== null && Vm("vec3", "vInstanceColor").assign(this.instanceColorNode);
  }
  update() {
    this.instanceMesh.instanceMatrix.usage !== Fu && this.buffer != null && this.instanceMesh.instanceMatrix.version !== this.buffer.version && (this.buffer.version = this.instanceMesh.instanceMatrix.version), this.instanceMesh.instanceColor && this.instanceMesh.instanceColor.usage !== Fu && this.bufferColor != null && this.instanceMesh.instanceColor.version !== this.bufferColor.version && (this.bufferColor.version = this.instanceMesh.instanceColor.version);
  }
}
const BY = /* @__PURE__ */ Me(FY);
class zY extends At {
  static get type() {
    return "BatchNode";
  }
  constructor(e) {
    super("void"), this.batchMesh = e, this.batchingIdNode = null;
  }
  setup(e) {
    this.batchingIdNode === null && (e.getDrawIndex() === null ? this.batchingIdNode = LT : this.batchingIdNode = UY);
    const i = Be(([f]) => {
      const m = rd(zn(this.batchMesh._indirectTexture), 0), v = Mi(f).modInt(Mi(m)), y = Mi(f).div(Mi(m));
      return zn(this.batchMesh._indirectTexture, Zs(v, y)).x;
    }).setLayout({
      name: "getIndirectIndex",
      type: "uint",
      inputs: [
        { name: "id", type: "int" }
      ]
    })(Mi(this.batchingIdNode)), n = this.batchMesh._matricesTexture, s = rd(zn(n), 0), a = ve(i).mul(4).toInt().toVar(), o = a.modInt(s), l = a.div(Mi(s)), u = ec(
      zn(n, Zs(o, l)),
      zn(n, Zs(o.add(1), l)),
      zn(n, Zs(o.add(2), l)),
      zn(n, Zs(o.add(3), l))
    ), c = this.batchMesh._colorsTexture;
    if (c !== null) {
      const f = Be(([m]) => {
        const v = rd(zn(c), 0).x, y = m, g = y.modInt(v), _ = y.div(v);
        return zn(c, Zs(g, _)).rgb;
      }).setLayout({
        name: "getBatchingColor",
        type: "vec3",
        inputs: [
          { name: "id", type: "int" }
        ]
      })(i);
      Vm("vec3", "vBatchColor").assign(f);
    }
    const h = Rr(u);
    nr.assign(u.mul(nr));
    const d = ws.div(ye(h[0].dot(h[0]), h[1].dot(h[1]), h[2].dot(h[2]))), p = h.mul(d).xyz;
    ws.assign(p), e.hasGeometryAttribute("tangent") && kT.mulAssign(h);
  }
}
const jY = /* @__PURE__ */ Me(zY), gM = /* @__PURE__ */ new WeakMap();
class VY extends At {
  static get type() {
    return "SkinningNode";
  }
  constructor(e, i = !1) {
    super("void"), this.skinnedMesh = e, this.useReference = i, this.updateType = Pt.OBJECT, this.skinIndexNode = wa("skinIndex", "uvec4"), this.skinWeightNode = wa("skinWeight", "vec4");
    let n, s, a;
    i ? (n = bi("bindMatrix", "mat4"), s = bi("bindMatrixInverse", "mat4"), a = dM("skeleton.boneMatrices", "mat4", e.skeleton.bones.length)) : (n = Tt(e.bindMatrix, "mat4"), s = Tt(e.bindMatrixInverse, "mat4"), a = IT(e.skeleton.boneMatrices, "mat4", e.skeleton.bones.length)), this.bindMatrixNode = n, this.bindMatrixInverseNode = s, this.boneMatricesNode = a, this.previousBoneMatricesNode = null;
  }
  getSkinnedPosition(e = this.boneMatricesNode, i = nr) {
    const { skinIndexNode: n, skinWeightNode: s, bindMatrixNode: a, bindMatrixInverseNode: o } = this, l = e.element(n.x), u = e.element(n.y), c = e.element(n.z), h = e.element(n.w), d = a.mul(i), p = Nr(
      l.mul(s.x).mul(d),
      u.mul(s.y).mul(d),
      c.mul(s.z).mul(d),
      h.mul(s.w).mul(d)
    );
    return o.mul(p).xyz;
  }
  getSkinnedNormal(e = this.boneMatricesNode, i = ws) {
    const { skinIndexNode: n, skinWeightNode: s, bindMatrixNode: a, bindMatrixInverseNode: o } = this, l = e.element(n.x), u = e.element(n.y), c = e.element(n.z), h = e.element(n.w);
    let d = Nr(
      s.x.mul(l),
      s.y.mul(u),
      s.z.mul(c),
      s.w.mul(h)
    );
    return d = o.mul(d).mul(a), d.transformDirection(i).xyz;
  }
  getPreviousSkinnedPosition(e) {
    const i = e.object;
    return this.previousBoneMatricesNode === null && (i.skeleton.previousBoneMatrices = new Float32Array(i.skeleton.boneMatrices), this.previousBoneMatricesNode = dM("skeleton.previousBoneMatrices", "mat4", i.skeleton.bones.length)), this.getSkinnedPosition(this.previousBoneMatricesNode, hM);
  }
  needsPreviousBoneMatrices(e) {
    const i = e.renderer.getMRT();
    return i && i.has("velocity");
  }
  setup(e) {
    this.needsPreviousBoneMatrices(e) && hM.assign(this.getPreviousSkinnedPosition(e));
    const i = this.getSkinnedPosition();
    if (nr.assign(i), e.hasGeometryAttribute("normal")) {
      const n = this.getSkinnedNormal();
      ws.assign(n), e.hasGeometryAttribute("tangent") && kT.assign(n);
    }
  }
  generate(e, i) {
    if (i !== "void")
      return nr.build(e, i);
  }
  update(e) {
    const i = (this.useReference ? e.object : this.skinnedMesh).skeleton;
    gM.get(i) !== e.frameId && (gM.set(i, e.frameId), this.previousBoneMatricesNode !== null && i.previousBoneMatrices.set(i.boneMatrices), i.update());
  }
}
const GY = (r) => De(new VY(r, !0));
class HY extends At {
  static get type() {
    return "LoopNode";
  }
  constructor(e = []) {
    super(), this.params = e;
  }
  getVarName(e) {
    return String.fromCharCode(105 + e);
  }
  getProperties(e) {
    const i = e.getNodeProperties(this);
    if (i.stackNode !== void 0) return i;
    const n = {};
    for (let a = 0, o = this.params.length - 1; a < o; a++) {
      const l = this.params[a], u = l.isNode !== !0 && l.name || this.getVarName(a), c = l.isNode !== !0 && l.type || "int";
      n[u] = wd(u, c);
    }
    const s = e.addStack();
    return i.returnsNode = this.params[this.params.length - 1](n, s, e), i.stackNode = s, e.removeStack(), i;
  }
  getNodeType(e) {
    const { returnsNode: i } = this.getProperties(e);
    return i ? i.getNodeType(e) : "void";
  }
  setup(e) {
    this.getProperties(e);
  }
  generate(e) {
    const i = this.getProperties(e), n = this.params, s = i.stackNode;
    for (let l = 0, u = n.length - 1; l < u; l++) {
      const c = n[l];
      let h = null, d = null, p = null, f = null, m = null, v = null;
      c.isNode ? (f = "int", p = this.getVarName(l), h = "0", d = c.build(e, f), m = "<") : (f = c.type || "int", p = c.name || this.getVarName(l), h = c.start, d = c.end, m = c.condition, v = c.update, typeof h == "number" ? h = e.generateConst(f, h) : h && h.isNode && (h = h.build(e, f)), typeof d == "number" ? d = e.generateConst(f, d) : d && d.isNode && (d = d.build(e, f)), h !== void 0 && d === void 0 ? (h = h + " - 1", d = "0", m = ">=") : d !== void 0 && h === void 0 && (h = "0", m = "<"), m === void 0 && (Number(h) > Number(d) ? m = ">=" : m = "<"));
      const y = { start: h, end: d }, g = y.start, _ = y.end;
      let x = "", b = "", T = "";
      v || (f === "int" || f === "uint" ? m.includes("<") ? v = "++" : v = "--" : m.includes("<") ? v = "+= 1." : v = "-= 1."), x += e.getVar(f, p) + " = " + g, b += p + " " + m + " " + _, T += p + " " + v;
      const S = `for ( ${x}; ${b}; ${T} )`;
      e.addFlowCode((l === 0 ? `
` : "") + e.tab + S + ` {

`).addFlowTab();
    }
    const a = s.build(e, "void"), o = i.returnsNode ? i.returnsNode.build(e) : "";
    e.removeFlowTab().addFlowCode(`
` + e.tab + a);
    for (let l = 0, u = this.params.length - 1; l < u; l++)
      e.addFlowCode((l === 0 ? "" : e.tab) + `}

`).removeFlowTab();
    return e.addFlowTab(), o;
  }
}
const ys = (...r) => De(new HY(Ju(r, "int"))).append(), WY = () => wd("break").append(), z0 = /* @__PURE__ */ new WeakMap(), nn = /* @__PURE__ */ new $t(), yM = /* @__PURE__ */ Be(({ bufferMap: r, influence: e, stride: i, width: n, depth: s, offset: a }) => {
  const o = Mi(LY).mul(i).add(a), l = o.div(n), u = o.sub(l.mul(n));
  return zn(r, Zs(u, l)).depth(s).mul(e);
});
function qY(r) {
  const e = r.morphAttributes.position !== void 0, i = r.morphAttributes.normal !== void 0, n = r.morphAttributes.color !== void 0, s = r.morphAttributes.position || r.morphAttributes.normal || r.morphAttributes.color, a = s !== void 0 ? s.length : 0;
  let o = z0.get(r);
  if (o === void 0 || o.count !== a) {
    let l = function() {
      y.dispose(), z0.delete(r), r.removeEventListener("dispose", l);
    };
    o !== void 0 && o.texture.dispose();
    const u = r.morphAttributes.position || [], c = r.morphAttributes.normal || [], h = r.morphAttributes.color || [];
    let d = 0;
    e === !0 && (d = 1), i === !0 && (d = 2), n === !0 && (d = 3);
    let p = r.attributes.position.count * d, f = 1;
    const m = 4096;
    p > m && (f = Math.ceil(p / m), p = m);
    const v = new Float32Array(p * f * 4 * a), y = new D7(v, p, f, a);
    y.type = cn, y.needsUpdate = !0;
    const g = d * 4;
    for (let _ = 0; _ < a; _++) {
      const x = u[_], b = c[_], T = h[_], S = p * f * 4 * _;
      for (let w = 0; w < x.count; w++) {
        const C = w * g;
        e === !0 && (nn.fromBufferAttribute(x, w), v[S + C + 0] = nn.x, v[S + C + 1] = nn.y, v[S + C + 2] = nn.z, v[S + C + 3] = 0), i === !0 && (nn.fromBufferAttribute(b, w), v[S + C + 4] = nn.x, v[S + C + 5] = nn.y, v[S + C + 6] = nn.z, v[S + C + 7] = 0), n === !0 && (nn.fromBufferAttribute(T, w), v[S + C + 8] = nn.x, v[S + C + 9] = nn.y, v[S + C + 10] = nn.z, v[S + C + 11] = T.itemSize === 4 ? nn.w : 1);
      }
    }
    o = {
      count: a,
      texture: y,
      stride: d,
      size: new jt(p, f)
    }, z0.set(r, o), r.addEventListener("dispose", l);
  }
  return o;
}
class XY extends At {
  static get type() {
    return "MorphNode";
  }
  constructor(e) {
    super("void"), this.mesh = e, this.morphBaseInfluence = Tt(1), this.updateType = Pt.OBJECT;
  }
  setup(e) {
    const { geometry: i } = e, n = i.morphAttributes.position !== void 0, s = i.hasAttribute("normal") && i.morphAttributes.normal !== void 0, a = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color, o = a !== void 0 ? a.length : 0, { texture: l, stride: u, size: c } = qY(i);
    n === !0 && nr.mulAssign(this.morphBaseInfluence), s === !0 && ws.mulAssign(this.morphBaseInfluence);
    const h = Mi(c.width);
    ys(o, ({ i: d }) => {
      const p = ve(0).toVar();
      this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0 ? p.assign(zn(this.mesh.morphTexture, Zs(Mi(d).add(1), Mi(LT))).r) : p.assign(bi("morphTargetInfluences", "float").element(d).toVar()), n === !0 && nr.addAssign(yM({
        bufferMap: l,
        influence: p,
        stride: u,
        width: h,
        depth: d,
        offset: Mi(0)
      })), s === !0 && ws.addAssign(yM({
        bufferMap: l,
        influence: p,
        stride: u,
        width: h,
        depth: d,
        offset: Mi(1)
      }));
    });
  }
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative ? e.value = 1 : e.value = 1 - this.mesh.morphTargetInfluences.reduce((i, n) => i + n, 0);
  }
}
const YY = /* @__PURE__ */ Me(XY);
class Gc extends At {
  static get type() {
    return "LightingNode";
  }
  constructor() {
    super("vec3"), this.isLightingNode = !0;
  }
  generate() {
    console.warn("Abstract function.");
  }
}
class $Y extends Gc {
  static get type() {
    return "AONode";
  }
  constructor(e = null) {
    super(), this.aoNode = e;
  }
  setup(e) {
    e.context.ambientOcclusion.mulAssign(this.aoNode);
  }
}
class KY extends n3 {
  static get type() {
    return "LightingContextNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e), this.lightingModel = i, this.backdropNode = n, this.backdropAlphaNode = s, this._value = null;
  }
  getContext() {
    const { backdropNode: e, backdropAlphaNode: i } = this, n = ye().toVar("directDiffuse"), s = ye().toVar("directSpecular"), a = ye().toVar("indirectDiffuse"), o = ye().toVar("indirectSpecular"), l = {
      directDiffuse: n,
      directSpecular: s,
      indirectDiffuse: a,
      indirectSpecular: o
    };
    return {
      radiance: ye().toVar("radiance"),
      irradiance: ye().toVar("irradiance"),
      iblIrradiance: ye().toVar("iblIrradiance"),
      ambientOcclusion: ve(1).toVar("ambientOcclusion"),
      reflectedLight: l,
      backdrop: e,
      backdropAlpha: i
    };
  }
  setup(e) {
    return this.value = this._value || (this._value = this.getContext()), this.value.lightingModel = this.lightingModel || e.context.lightingModel, super.setup(e);
  }
}
const QY = /* @__PURE__ */ Me(KY);
class ZY extends Gc {
  static get type() {
    return "IrradianceNode";
  }
  constructor(e) {
    super(), this.node = e;
  }
  setup(e) {
    e.context.irradiance.addAssign(this.node);
  }
}
let Th, Sh;
class Li extends At {
  static get type() {
    return "ScreenNode";
  }
  constructor(e) {
    super(), this.scope = e, this.isViewportNode = !0;
  }
  getNodeType() {
    return this.scope === Li.VIEWPORT ? "vec4" : "vec2";
  }
  getUpdateType() {
    let e = Pt.NONE;
    return (this.scope === Li.SIZE || this.scope === Li.VIEWPORT) && (e = Pt.RENDER), this.updateType = e, e;
  }
  update({ renderer: e }) {
    const i = e.getRenderTarget();
    this.scope === Li.VIEWPORT ? i !== null ? Sh.copy(i.viewport) : (e.getViewport(Sh), Sh.multiplyScalar(e.getPixelRatio())) : i !== null ? (Th.width = i.width, Th.height = i.height) : e.getDrawingBufferSize(Th);
  }
  setup() {
    const e = this.scope;
    let i = null;
    return e === Li.SIZE ? i = Tt(Th || (Th = new jt())) : e === Li.VIEWPORT ? i = Tt(Sh || (Sh = new $t())) : i = qe(UT.div(Mx)), i;
  }
  generate(e) {
    if (this.scope === Li.COORDINATE) {
      let i = e.getFragCoord();
      if (e.isFlipY()) {
        const n = e.getNodeProperties(Mx).outputNode.build(e);
        i = `${e.getType("vec2")}( ${i}.x, ${n}.y - ${i}.y )`;
      }
      return i;
    }
    return super.generate(e);
  }
}
Li.COORDINATE = "coordinate";
Li.VIEWPORT = "viewport";
Li.SIZE = "size";
Li.UV = "uv";
const Ad = /* @__PURE__ */ He(Li, Li.UV), Mx = /* @__PURE__ */ He(Li, Li.SIZE), UT = /* @__PURE__ */ He(Li, Li.COORDINATE), b3 = /* @__PURE__ */ He(Li, Li.VIEWPORT);
b3.zw;
b3.xy;
const wh = /* @__PURE__ */ new jt();
class x3 extends ip {
  static get type() {
    return "ViewportTextureNode";
  }
  constructor(e = Ad, i = null, n = null) {
    n === null && (n = new rW(), n.minFilter = ma), super(n, e, i), this.generateMipmaps = !1, this.isOutputTextureNode = !0, this.updateBeforeType = Pt.FRAME;
  }
  updateBefore(e) {
    const i = e.renderer;
    i.getDrawingBufferSize(wh);
    const n = this.value;
    (n.image.width !== wh.width || n.image.height !== wh.height) && (n.image.width = wh.width, n.image.height = wh.height, n.needsUpdate = !0);
    const s = n.generateMipmaps;
    n.generateMipmaps = this.generateMipmaps, i.copyFramebufferToTexture(n), n.generateMipmaps = s;
  }
  clone() {
    const e = new this.constructor(this.uvNode, this.levelNode, this.value);
    return e.generateMipmaps = this.generateMipmaps, e;
  }
}
const _3 = /* @__PURE__ */ Me(x3, null, null, { generateMipmaps: !0 });
let j0 = null;
class JY extends x3 {
  static get type() {
    return "ViewportDepthTextureNode";
  }
  constructor(e = Ad, i = null) {
    j0 === null && (j0 = new jc()), super(e, i, j0);
  }
}
const e$ = /* @__PURE__ */ Me(JY);
class zr extends At {
  static get type() {
    return "ViewportDepthNode";
  }
  constructor(e, i = null) {
    super("float"), this.scope = e, this.valueNode = i, this.isViewportDepthNode = !0;
  }
  generate(e) {
    const { scope: i } = this;
    return i === zr.DEPTH_BASE ? e.getFragDepth() : super.generate(e);
  }
  setup({ camera: e }) {
    const { scope: i } = this, n = this.valueNode;
    let s = null;
    if (i === zr.DEPTH_BASE)
      n !== null && (s = w3().assign(n));
    else if (i === zr.DEPTH)
      e.isPerspectiveCamera ? s = t$(ir.z, Qo, Zo) : s = nd(ir.z, Qo, Zo);
    else if (i === zr.LINEAR_DEPTH)
      if (n !== null)
        if (e.isPerspectiveCamera) {
          const a = T3(n, Qo, Zo);
          s = nd(a, Qo, Zo);
        } else
          s = n;
      else
        s = nd(ir.z, Qo, Zo);
    return s;
  }
}
zr.DEPTH_BASE = "depthBase";
zr.DEPTH = "depth";
zr.LINEAR_DEPTH = "linearDepth";
const nd = (r, e, i) => r.add(e).div(e.sub(i)), t$ = (r, e, i) => e.add(r).mul(i).div(i.sub(e).mul(r)), T3 = (r, e, i) => e.mul(i).div(i.sub(e).mul(r).sub(i)), S3 = (r, e, i) => {
  e = e.max(1e-6).toVar();
  const n = xa(r.div(e).add(1)), s = xa(i.div(e).add(1));
  return n.div(s);
}, w3 = /* @__PURE__ */ Me(zr, zr.DEPTH_BASE), E3 = /* @__PURE__ */ He(zr, zr.DEPTH);
zr.LINEAR_DEPTH;
e$();
E3.assign = (r) => w3(r);
class To extends At {
  static get type() {
    return "ClippingNode";
  }
  constructor(e = To.DEFAULT) {
    super(), this.scope = e;
  }
  setup(e) {
    super.setup(e);
    const i = e.clippingContext, { localClipIntersection: n, localClippingCount: s, globalClippingCount: a } = i, o = a + s, l = n ? o - s : o;
    return this.scope === To.ALPHA_TO_COVERAGE ? this.setupAlphaToCoverage(i.planes, o, l) : this.setupDefault(i.planes, o, l);
  }
  setupAlphaToCoverage(e, i, n) {
    return Be(() => {
      const s = Md(e), a = Pu("float", "distanceToPlane"), o = Pu("float", "distanceToGradient"), l = Pu("float", "clipOpacity");
      l.assign(1);
      let u;
      if (ys(n, ({ i: c }) => {
        u = s.element(c), a.assign(ir.dot(u.xyz).negate().add(u.w)), o.assign(a.fwidth().div(2)), l.mulAssign(Cl(o.negate(), o, a)), l.equal(0).discard();
      }), n < i) {
        const c = Pu("float", "unionclipOpacity");
        c.assign(1), ys({ start: n, end: i }, ({ i: h }) => {
          u = s.element(h), a.assign(ir.dot(u.xyz).negate().add(u.w)), o.assign(a.fwidth().div(2)), c.mulAssign(Cl(o.negate(), o, a).oneMinus());
        }), l.mulAssign(c.oneMinus());
      }
      Wt.a.mulAssign(l), Wt.a.equal(0).discard();
    })();
  }
  setupDefault(e, i, n) {
    return Be(() => {
      const s = Md(e);
      let a;
      if (ys(n, ({ i: o }) => {
        a = s.element(o), ir.dot(a.xyz).greaterThan(a.w).discard();
      }), n < i) {
        const o = Pu("bool", "clipped");
        o.assign(!0), ys({ start: n, end: i }, ({ i: l }) => {
          a = s.element(l), o.assign(ir.dot(a.xyz).greaterThan(a.w).and(o));
        }), o.discard();
      }
    })();
  }
}
To.ALPHA_TO_COVERAGE = "alphaToCoverage";
To.DEFAULT = "default";
const i$ = () => De(new To()), r$ = () => De(new To(To.ALPHA_TO_COVERAGE)), n$ = 0.05, vM = /* @__PURE__ */ Be(([r]) => wo(It(1e4, Wn(It(17, r.x).add(It(0.1, r.y)))).mul(Nr(0.1, qn(Wn(It(13, r.y).add(r.x))))))), bM = /* @__PURE__ */ Be(([r]) => vM(qe(vM(r.xy), r.z))), s$ = /* @__PURE__ */ Be(([r]) => {
  const e = An(
    go(QP(r.xyz)),
    go(ZP(r.xyz))
  ).toVar("maxDeriv"), i = ve(1).div(ve(n$).mul(e)).toVar("pixScale"), n = qe(
    _d(bl(xa(i))),
    _d(AT(xa(i)))
  ).toVar("pixScales"), s = qe(
    bM(bl(n.x.mul(r.xyz))),
    bM(bl(n.y.mul(r.xyz)))
  ).toVar("alpha"), a = wo(xa(i)).toVar("lerpFactor"), o = Nr(It(a.oneMinus(), s.x), It(a, s.y)).toVar("x"), l = Sd(a, a.oneMinus()).toVar("a"), u = ye(
    o.mul(o).div(It(2, l).mul(un(1, l))),
    o.sub(It(0.5, l)).div(un(1, l)),
    un(1, un(1, o).mul(un(1, o)).div(It(2, l).mul(un(1, l))))
  ).toVar("cases"), c = o.lessThan(l.oneMinus()).select(o.lessThan(l).select(u.x, u.y), u.z);
  return Sa(c, 1e-6, 1);
});
class Bi extends Wr {
  static get type() {
    return "NodeMaterial";
  }
  constructor() {
    super(), this.isNodeMaterial = !0, this.type = this.constructor.type, this.forceSinglePass = !1, this.fog = !0, this.lights = !1, this.lightsNode = null, this.envNode = null, this.aoNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.positionNode = null, this.geometryNode = null, this.depthNode = null, this.shadowNode = null, this.shadowPositionNode = null, this.outputNode = null, this.mrtNode = null, this.fragmentNode = null, this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + NP(this);
  }
  build(e) {
    this.setup(e);
  }
  setupObserver(e) {
    return new gW(e);
  }
  setup(e) {
    e.context.setupNormal = () => this.setupNormal(e), e.addStack(), e.stack.outputNode = this.vertexNode || this.setupPosition(e), this.geometryNode !== null && (e.stack.outputNode = e.stack.outputNode.bypass(this.geometryNode)), e.addFlow("vertex", e.removeStack()), e.addStack();
    let i;
    const n = this.setupClipping(e);
    if (this.depthWrite === !0 && this.setupDepth(e), this.fragmentNode === null) {
      this.setupDiffuseColor(e), this.setupVariants(e);
      const s = this.setupLighting(e);
      n !== null && e.stack.add(n);
      const a = _t(s, Wt.a).max(0);
      if (i = this.setupOutput(e, a), eq.assign(i), this.outputNode !== null && (i = this.outputNode), e.renderer.getRenderTarget() !== null) {
        const o = e.renderer.getMRT(), l = this.mrtNode;
        o !== null ? (i = o, l !== null && (i = o.merge(l))) : l !== null && (i = l);
      }
    } else {
      let s = this.fragmentNode;
      s.isOutputStructNode !== !0 && (s = _t(s)), i = this.setupOutput(e, s);
    }
    e.stack.outputNode = i, e.addFlow("fragment", e.removeStack()), e.monitor = this.setupObserver(e);
  }
  setupClipping(e) {
    if (e.clippingContext === null) return null;
    const { globalClippingCount: i, localClippingCount: n } = e.clippingContext;
    let s = null;
    if (i || n) {
      const a = e.renderer.samples;
      this.alphaToCoverage && a > 1 ? s = r$() : e.stack.add(i$());
    }
    return s;
  }
  setupDepth(e) {
    const { renderer: i, camera: n } = e;
    let s = this.depthNode;
    if (s === null) {
      const a = i.getMRT();
      a && a.has("depth") ? s = a.get("depth") : i.logarithmicDepthBuffer === !0 && (n.isPerspectiveCamera ? s = S3(Ex().w, Qo, Zo) : s = nd(ir.z, Qo, Zo));
    }
    s !== null && E3.assign(s).append();
  }
  setupPosition(e) {
    const { object: i } = e, n = i.geometry;
    if (e.addStack(), (n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color) && YY(i).append(), i.isSkinnedMesh === !0 && GY(i).append(), this.displacementMap) {
      const a = ro("displacementMap", "texture"), o = ro("displacementScale", "float"), l = ro("displacementBias", "float");
      nr.addAssign(ws.normalize().mul(a.x.mul(o).add(l)));
    }
    i.isBatchedMesh && jY(i).append(), i.instanceMatrix && i.instanceMatrix.isInstancedBufferAttribute === !0 && BY(i).append(), this.positionNode !== null && nr.assign(this.positionNode);
    const s = Ex();
    return e.context.vertex = e.removeStack(), e.context.mvp = s, s;
  }
  setupDiffuseColor({ object: e, geometry: i }) {
    let n = this.colorNode ? _t(this.colorNode) : oY;
    this.vertexColors === !0 && i.hasAttribute("color") && (n = _t(n.xyz.mul(wa("color", "vec3")), n.a)), e.instanceColor && (n = Vm("vec3", "vInstanceColor").mul(n)), e.isBatchedMesh && e._colorsTexture && (n = Vm("vec3", "vBatchColor").mul(n)), Wt.assign(n);
    const s = this.opacityNode ? ve(this.opacityNode) : y3;
    if (Wt.a.assign(Wt.a.mul(s)), this.alphaTestNode !== null || this.alphaTest > 0) {
      const a = this.alphaTestNode !== null ? ve(this.alphaTestNode) : aY;
      Wt.a.lessThanEqual(a).discard();
    }
    this.alphaHash === !0 && Wt.a.lessThan(s$(nr)).discard(), this.transparent === !1 && this.blending === po && this.alphaToCoverage === !1 && Wt.a.assign(1);
  }
  setupVariants() {
  }
  setupOutgoingLight() {
    return this.lights === !0 ? ye(0) : Wt.rgb;
  }
  setupNormal() {
    return this.normalNode ? ye(this.normalNode) : fY;
  }
  setupEnvironment() {
    let e = null;
    return this.envNode ? e = this.envNode : this.envMap && (e = this.envMap.isCubeTexture ? ro("envMap", "cubeTexture") : ro("envMap", "texture")), e;
  }
  setupLightMap(e) {
    let i = null;
    return e.material.lightMap && (i = new ZY(v3)), i;
  }
  setupLights(e) {
    const i = [], n = this.setupEnvironment(e);
    n && n.isLightingNode && i.push(n);
    const s = this.setupLightMap(e);
    if (s && s.isLightingNode && i.push(s), this.aoNode !== null || e.material.aoMap) {
      const o = this.aoNode !== null ? this.aoNode : DY;
      i.push(new $Y(o));
    }
    let a = this.lightsNode || e.lightsNode;
    return i.length > 0 && (a = e.renderer.lighting.createNode([...a.getLights(), ...i])), a;
  }
  setupLightingModel() {
  }
  setupLighting(e) {
    const { material: i } = e, { backdropNode: n, backdropAlphaNode: s, emissiveNode: a } = this, o = this.lights === !0 || this.lightsNode !== null ? this.setupLights(e) : null;
    let l = this.setupOutgoingLight(e);
    if (o && o.getScope().hasLights) {
      const u = this.setupLightingModel(e);
      l = QY(o, u, n, s);
    } else n !== null && (l = ye(s !== null ? li(l, n, s) : n));
    return (a && a.isNode === !0 || i.emissive && i.emissive.isColor === !0) && (oM.assign(ye(a || uY)), l = l.add(oM)), l;
  }
  setupOutput(e, i) {
    if (this.fog === !0) {
      const n = e.fogNode;
      n && (i = _t(n.mix(i.rgb, n.colorNode), i.a));
    }
    return i;
  }
  setDefaultValues(e) {
    for (const n in e) {
      const s = e[n];
      this[n] === void 0 && (this[n] = s, s && s.clone && (this[n] = s.clone()));
    }
    const i = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const n in i)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, n) === void 0 && i[n].get !== void 0 && Object.defineProperty(this.constructor.prototype, n, i[n]);
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    i && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    const n = Wr.prototype.toJSON.call(this, e), s = Bm(this);
    n.inputNodes = {};
    for (const { property: o, childNode: l } of s)
      n.inputNodes[o] = l.toJSON(e).uuid;
    function a(o) {
      const l = [];
      for (const u in o) {
        const c = o[u];
        delete c.metadata, l.push(c);
      }
      return l;
    }
    if (i) {
      const o = a(e.textures), l = a(e.images), u = a(e.nodes);
      o.length > 0 && (n.textures = o), l.length > 0 && (n.images = l), u.length > 0 && (n.nodes = u);
    }
    return n;
  }
  copy(e) {
    return this.lightsNode = e.lightsNode, this.envNode = e.envNode, this.colorNode = e.colorNode, this.normalNode = e.normalNode, this.opacityNode = e.opacityNode, this.backdropNode = e.backdropNode, this.backdropAlphaNode = e.backdropAlphaNode, this.alphaTestNode = e.alphaTestNode, this.positionNode = e.positionNode, this.geometryNode = e.geometryNode, this.depthNode = e.depthNode, this.shadowNode = e.shadowNode, this.shadowPositionNode = e.shadowPositionNode, this.outputNode = e.outputNode, this.mrtNode = e.mrtNode, this.fragmentNode = e.fragmentNode, this.vertexNode = e.vertexNode, super.copy(e);
  }
}
const a$ = /* @__PURE__ */ new fT();
class o$ extends Bi {
  static get type() {
    return "LineBasicNodeMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicNodeMaterial = !0, this.lights = !1, this.setDefaultValues(a$), this.setValues(e);
  }
}
const l$ = /* @__PURE__ */ new AP();
class u$ extends Bi {
  static get type() {
    return "LineDashedNodeMaterial";
  }
  constructor(e) {
    super(), this.isLineDashedNodeMaterial = !0, this.lights = !1, this.setDefaultValues(l$), this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setValues(e);
  }
  setupVariants() {
    const e = this.offsetNode, i = this.dashScaleNode ? ve(this.dashScaleNode) : NY, n = this.dashSizeNode ? ve(this.dashSizeNode) : PY, s = this.dashSizeNode ? ve(this.dashGapNode) : OY;
    F0.assign(n), lM.assign(s);
    const a = Ca(wa("lineDistance").mul(i));
    (e ? a.add(e) : a).mod(F0.add(lM)).greaterThan(F0).discard();
  }
}
const c$ = (r) => De(r).mul(0.5).add(0.5), h$ = /* @__PURE__ */ new wP();
class d$ extends Bi {
  static get type() {
    return "MeshNormalNodeMaterial";
  }
  constructor(e) {
    super(), this.lights = !1, this.isMeshNormalNodeMaterial = !0, this.setDefaultValues(h$), this.setValues(e);
  }
  setupDiffuseColor() {
    const e = this.opacityNode ? ve(this.opacityNode) : y3;
    Wt.assign(_t(c$(Ui), e));
  }
}
class p$ extends zi {
  static get type() {
    return "EquirectUVNode";
  }
  constructor(e = c3) {
    super("vec2"), this.dirNode = e;
  }
  setup() {
    const e = this.dirNode, i = e.z.atan2(e.x).mul(1 / (Math.PI * 2)).add(0.5), n = e.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return qe(i, n);
  }
}
const M3 = /* @__PURE__ */ Me(p$);
class A3 extends Z7 {
  constructor(e = 1, i = {}) {
    super(e, i), this.isCubeRenderTarget = !0;
  }
  fromEquirectangularTexture(e, i) {
    const n = i.minFilter, s = i.generateMipmaps;
    i.generateMipmaps = !0, this.texture.type = i.type, this.texture.colorSpace = i.colorSpace, this.texture.generateMipmaps = i.generateMipmaps, this.texture.minFilter = i.minFilter, this.texture.magFilter = i.magFilter;
    const a = new Zd(5, 5, 5), o = M3(c3), l = new Bi();
    l.colorNode = Ci(i, o, 0), l.side = es, l.blending = _c;
    const u = new Al(a, l), c = new mP();
    c.add(u), i.minFilter === ma && (i.minFilter = hn);
    const h = new fP(1, 10, this), d = e.getMRT();
    return e.setMRT(null), h.update(e, c), e.setMRT(d), i.minFilter = n, i.currentGenerateMipmaps = s, u.geometry.dispose(), u.material.dispose(), this;
  }
}
const sd = /* @__PURE__ */ new WeakMap();
class f$ extends zi {
  static get type() {
    return "CubeMapNode";
  }
  constructor(e) {
    super("vec3"), this.envNode = e, this._cubeTexture = null, this._cubeTextureNode = Ed();
    const i = new dT();
    i.isRenderTargetTexture = !0, this._defaultTexture = i, this.updateBeforeType = Pt.RENDER;
  }
  updateBefore(e) {
    const { renderer: i, material: n } = e, s = this.envNode;
    if (s.isTextureNode || s.isMaterialReferenceNode) {
      const a = s.isTextureNode ? s.value : n[s.property];
      if (a && a.isTexture) {
        const o = a.mapping;
        if (o === Xd || o === Yd) {
          if (sd.has(a)) {
            const l = sd.get(a);
            xM(l, a.mapping), this._cubeTexture = l;
          } else {
            const l = a.image;
            if (m$(l)) {
              const u = new A3(l.height);
              u.fromEquirectangularTexture(i, a), xM(u.texture, a.mapping), this._cubeTexture = u.texture, sd.set(a, u.texture), a.addEventListener("dispose", C3);
            } else
              this._cubeTexture = this._defaultTexture;
          }
          this._cubeTextureNode.value = this._cubeTexture;
        } else
          this._cubeTextureNode = this.envNode;
      }
    }
  }
  setup(e) {
    return this.updateBefore(e), this._cubeTextureNode;
  }
}
function m$(r) {
  return r == null ? !1 : r.height > 0;
}
function C3(r) {
  const e = r.target;
  e.removeEventListener("dispose", C3);
  const i = sd.get(e);
  i !== void 0 && (sd.delete(e), i.dispose());
}
function xM(r, e) {
  e === Xd ? r.mapping = wl : e === Yd && (r.mapping = Tc);
}
const R3 = /* @__PURE__ */ Me(f$);
class FT extends Gc {
  static get type() {
    return "BasicEnvironmentNode";
  }
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    e.context.environment = R3(this.envNode);
  }
}
class g$ extends Gc {
  static get type() {
    return "BasicLightMapNode";
  }
  constructor(e = null) {
    super(), this.lightMapNode = e;
  }
  setup(e) {
    const i = ve(1 / Math.PI);
    e.context.irradianceLightMap = this.lightMapNode.mul(i);
  }
}
class Fg {
  start() {
  }
  finish() {
  }
  direct() {
  }
  directRectArea() {
  }
  indirect() {
  }
  ambientOcclusion() {
  }
}
class N3 extends Fg {
  constructor() {
    super();
  }
  indirect(e, i, n) {
    const s = e.ambientOcclusion, a = e.reflectedLight, o = n.context.irradianceLightMap;
    a.indirectDiffuse.assign(_t(0)), o ? a.indirectDiffuse.addAssign(o) : a.indirectDiffuse.addAssign(_t(1, 1, 1, 0)), a.indirectDiffuse.mulAssign(s), a.indirectDiffuse.mulAssign(Wt.rgb);
  }
  finish(e, i, n) {
    const s = n.material, a = e.outgoingLight, o = n.context.environment;
    if (o)
      switch (s.combine) {
        case Cg:
          a.rgb.assign(li(a.rgb, a.rgb.mul(o.rgb), lm.mul(B0)));
          break;
        case D9:
          a.rgb.assign(li(a.rgb, o.rgb, lm.mul(B0)));
          break;
        case k9:
          a.rgb.addAssign(o.rgb.mul(lm.mul(B0)));
          break;
        default:
          console.warn("THREE.BasicLightingModel: Unsupported .combine value:", s.combine);
          break;
      }
  }
}
const y$ = /* @__PURE__ */ new Rg();
class v$ extends Bi {
  static get type() {
    return "MeshBasicNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicNodeMaterial = !0, this.lights = !0, this.setDefaultValues(y$), this.setValues(e);
  }
  setupNormal() {
    return is;
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new FT(i) : null;
  }
  setupLightMap(e) {
    let i = null;
    return e.material.lightMap && (i = new g$(v3)), i;
  }
  setupOutgoingLight() {
    return Wt.rgb;
  }
  setupLightingModel() {
    return new N3();
  }
}
const Cd = /* @__PURE__ */ Be(({ f0: r, f90: e, dotVH: i }) => {
  const n = i.mul(-5.55473).sub(6.98316).mul(i).exp2();
  return r.mul(n.oneMinus()).add(e.mul(n));
}), Mc = /* @__PURE__ */ Be((r) => r.diffuseColor.mul(1 / Math.PI)), b$ = () => ve(0.25), x$ = /* @__PURE__ */ Be(({ dotNH: r }) => Tx.mul(ve(0.5)).add(1).mul(ve(1 / Math.PI)).mul(r.pow(Tx))), _$ = /* @__PURE__ */ Be(({ lightDirection: r }) => {
  const e = r.add(vi).normalize(), i = Ui.dot(e).clamp(), n = vi.dot(e).clamp(), s = Cd({ f0: on, f90: 1, dotVH: n }), a = b$(), o = x$({ dotNH: i });
  return s.mul(a).mul(o);
});
class P3 extends N3 {
  constructor(e = !0) {
    super(), this.specular = e;
  }
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }) {
    const s = Ui.dot(e).clamp().mul(i);
    n.directDiffuse.addAssign(s.mul(Mc({ diffuseColor: Wt.rgb }))), this.specular === !0 && n.directSpecular.addAssign(s.mul(_$({ lightDirection: e })).mul(lm));
  }
  indirect({ ambientOcclusion: e, irradiance: i, reflectedLight: n }) {
    n.indirectDiffuse.addAssign(i.mul(Mc({ diffuseColor: Wt }))), n.indirectDiffuse.mulAssign(e);
  }
}
const T$ = /* @__PURE__ */ new EP();
class S$ extends Bi {
  static get type() {
    return "MeshLambertNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshLambertNodeMaterial = !0, this.lights = !0, this.setDefaultValues(T$), this.setValues(e);
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new FT(i) : null;
  }
  setupLightingModel() {
    return new P3(!1);
  }
}
const w$ = /* @__PURE__ */ new TP();
class E$ extends Bi {
  static get type() {
    return "MeshPhongNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhongNodeMaterial = !0, this.lights = !0, this.shininessNode = null, this.specularNode = null, this.setDefaultValues(w$), this.setValues(e);
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new FT(i) : null;
  }
  setupLightingModel() {
    return new P3();
  }
  setupVariants() {
    const e = (this.shininessNode ? ve(this.shininessNode) : lY).max(1e-4);
    Tx.assign(e);
    const i = this.specularNode || cY;
    on.assign(i);
  }
  copy(e) {
    return this.shininessNode = e.shininessNode, this.specularNode = e.specularNode, super.copy(e);
  }
}
const M$ = /* @__PURE__ */ Be((r) => {
  if (r.geometry.hasAttribute("normal") === !1)
    return ve(0);
  const e = is.dFdx().abs().max(is.dFdy().abs());
  return e.x.max(e.y).max(e.z);
}), O3 = /* @__PURE__ */ Be((r) => {
  const { roughness: e } = r, i = M$();
  let n = e.max(0.0525);
  return n = n.add(i), n = n.min(1), n;
}), A$ = /* @__PURE__ */ Be(({ alpha: r, dotNL: e, dotNV: i }) => {
  const n = r.pow2(), s = e.mul(n.add(n.oneMinus().mul(i.pow2())).sqrt()), a = i.mul(n.add(n.oneMinus().mul(e.pow2())).sqrt());
  return _o(0.5, s.add(a).max(Tq));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
}), C$ = /* @__PURE__ */ Be(({ alphaT: r, alphaB: e, dotTV: i, dotBV: n, dotTL: s, dotBL: a, dotNV: o, dotNL: l }) => {
  const u = l.mul(ye(r.mul(i), e.mul(n), o).length()), c = o.mul(ye(r.mul(s), e.mul(a), l).length());
  return _o(0.5, u.add(c)).saturate();
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
}), R$ = /* @__PURE__ */ Be(({ alpha: r, dotNH: e }) => {
  const i = r.pow2(), n = e.pow2().mul(i.oneMinus()).oneMinus();
  return i.div(n.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), N$ = /* @__PURE__ */ ve(1 / Math.PI), P$ = /* @__PURE__ */ Be(({ alphaT: r, alphaB: e, dotNH: i, dotTH: n, dotBH: s }) => {
  const a = r.mul(e), o = ye(e.mul(n), r.mul(s), a.mul(i)), l = o.dot(o), u = a.div(l);
  return N$.mul(a.mul(u.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
}), _M = /* @__PURE__ */ Be((r) => {
  const { lightDirection: e, f0: i, f90: n, roughness: s, f: a, USE_IRIDESCENCE: o, USE_ANISOTROPY: l } = r, u = r.normalView || Ui, c = s.pow2(), h = e.add(vi).normalize(), d = u.dot(e).clamp(), p = u.dot(vi).clamp(), f = u.dot(h).clamp(), m = vi.dot(h).clamp();
  let v = Cd({ f0: i, f90: n, dotVH: m }), y, g;
  if (aM(o) && (v = ET.mix(v, a)), aM(l)) {
    const _ = sm.dot(e), x = sm.dot(vi), b = sm.dot(h), T = tc.dot(e), S = tc.dot(vi), w = tc.dot(h);
    y = C$({ alphaT: _x, alphaB: c, dotTV: x, dotBV: S, dotTL: _, dotBL: T, dotNV: p, dotNL: d }), g = P$({ alphaT: _x, alphaB: c, dotNH: f, dotTH: b, dotBH: w });
  } else
    y = A$({ alpha: c, dotNL: d, dotNV: p }), g = R$({ alpha: c, dotNH: f });
  return v.mul(y).mul(g);
}), I3 = /* @__PURE__ */ Be(({ roughness: r, dotNV: e }) => {
  const i = _t(-1, -0.0275, -0.572, 0.022), n = _t(1, 0.0425, 1.04, -0.04), s = r.mul(i).add(n), a = s.x.mul(s.x).min(e.mul(-9.28).exp2()).mul(s.x).add(s.y);
  return qe(-1.04, 1.04).mul(a).add(s.zw);
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
}), D3 = /* @__PURE__ */ Be((r) => {
  const { dotNV: e, specularColor: i, specularF90: n, roughness: s } = r, a = I3({ dotNV: e, roughness: s });
  return i.mul(a.x).add(n.mul(a.y));
}), O$ = /* @__PURE__ */ Be(({ f: r, f90: e, dotVH: i }) => {
  const n = i.oneMinus().saturate(), s = n.mul(n), a = n.mul(s, s).clamp(0, 0.9999);
  return r.sub(ye(e).mul(a)).div(a.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
}), I$ = /* @__PURE__ */ Be(({ roughness: r, dotNH: e }) => {
  const i = r.pow2(), n = ve(1).div(i), s = e.pow2().oneMinus().max(78125e-7);
  return ve(2).add(n).mul(s.pow(n.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), D$ = /* @__PURE__ */ Be(({ dotNV: r, dotNL: e }) => ve(1).div(ve(4).mul(e.add(r).sub(e.mul(r))))).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
}), k$ = /* @__PURE__ */ Be(({ lightDirection: r }) => {
  const e = r.add(vi).normalize(), i = Ui.dot(r).clamp(), n = Ui.dot(vi).clamp(), s = Ui.dot(e).clamp(), a = I$({ roughness: wT, dotNH: s }), o = D$({ dotNV: n, dotNL: i });
  return zu.mul(a).mul(o);
}), L$ = /* @__PURE__ */ Be(({ N: r, V: e, roughness: i }) => {
  const n = 78125e-7, s = r.dot(e).saturate(), a = qe(i, s.oneMinus().sqrt());
  return a.assign(a.mul(0.984375).add(n)), a;
}).setLayout({
  name: "LTC_Uv",
  type: "vec2",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "roughness", type: "float" }
  ]
}), U$ = /* @__PURE__ */ Be(({ f: r }) => {
  const e = r.length();
  return An(e.mul(e).add(r.z).div(e.add(1)), 0);
}).setLayout({
  name: "LTC_ClippedSphereFormFactor",
  type: "float",
  inputs: [
    { name: "f", type: "vec3" }
  ]
}), pf = /* @__PURE__ */ Be(({ v1: r, v2: e }) => {
  const i = r.dot(e), n = i.abs().toVar(), s = n.mul(0.0145206).add(0.4965155).mul(n).add(0.8543985).toVar(), a = n.add(4.1616724).mul(n).add(3.417594).toVar(), o = s.div(a), l = i.greaterThan(0).select(o, An(i.mul(i).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(o));
  return r.cross(e).mul(l);
}).setLayout({
  name: "LTC_EdgeVectorFormFactor",
  type: "vec3",
  inputs: [
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" }
  ]
}), TM = /* @__PURE__ */ Be(({ N: r, V: e, P: i, mInv: n, p0: s, p1: a, p2: o, p3: l }) => {
  const u = a.sub(s).toVar(), c = l.sub(s).toVar(), h = u.cross(c), d = ye().toVar();
  return rr(h.dot(i.sub(s)).greaterThanEqual(0), () => {
    const p = e.sub(r.mul(e.dot(r))).normalize(), f = r.cross(p).negate(), m = n.mul(Rr(p, f, r).transpose()).toVar(), v = m.mul(s.sub(i)).normalize().toVar(), y = m.mul(a.sub(i)).normalize().toVar(), g = m.mul(o.sub(i)).normalize().toVar(), _ = m.mul(l.sub(i)).normalize().toVar(), x = ye(0).toVar();
    x.addAssign(pf({ v1: v, v2: y })), x.addAssign(pf({ v1: y, v2: g })), x.addAssign(pf({ v1: g, v2: _ })), x.addAssign(pf({ v1: _, v2: v })), d.assign(ye(U$({ f: x })));
  }), d;
}).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "P", type: "vec3" },
    { name: "mInv", type: "mat3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" }
  ]
}), Bg = 1 / 6, k3 = (r) => It(Bg, It(r, It(r, r.negate().add(3)).sub(3)).add(1)), Ax = (r) => It(Bg, It(r, It(r, It(3, r).sub(6))).add(4)), L3 = (r) => It(Bg, It(r, It(r, It(-3, r).add(3)).add(3)).add(1)), Cx = (r) => It(Bg, Ig(r, 3)), SM = (r) => k3(r).add(Ax(r)), wM = (r) => L3(r).add(Cx(r)), EM = (r) => Nr(-1, Ax(r).div(k3(r).add(Ax(r)))), MM = (r) => Nr(1, Cx(r).div(L3(r).add(Cx(r)))), AM = (r, e, i) => {
  const n = r.uvNode, s = It(n, e.zw).add(0.5), a = bl(s), o = wo(s), l = SM(o.x), u = wM(o.x), c = EM(o.x), h = MM(o.x), d = EM(o.y), p = MM(o.y), f = qe(a.x.add(c), a.y.add(d)).sub(0.5).mul(e.xy), m = qe(a.x.add(h), a.y.add(d)).sub(0.5).mul(e.xy), v = qe(a.x.add(c), a.y.add(p)).sub(0.5).mul(e.xy), y = qe(a.x.add(h), a.y.add(p)).sub(0.5).mul(e.xy), g = SM(o.y).mul(Nr(l.mul(r.uv(f).level(i)), u.mul(r.uv(m).level(i)))), _ = wM(o.y).mul(Nr(l.mul(r.uv(v).level(i)), u.mul(r.uv(y).level(i))));
  return g.add(_);
}, F$ = /* @__PURE__ */ Be(([r, e = ve(3)]) => {
  const i = qe(r.size(Mi(e))), n = qe(r.size(Mi(e.add(1)))), s = _o(1, i), a = _o(1, n), o = AM(r, _t(s, i), bl(e)), l = AM(r, _t(a, n), AT(e));
  return wo(e).mix(o, l);
}), CM = /* @__PURE__ */ Be(([r, e, i, n, s]) => {
  const a = ye(r3(e.negate(), Td(r), _o(1, n))), o = ye(
    go(s[0].xyz),
    go(s[1].xyz),
    go(s[2].xyz)
  );
  return Td(a).mul(i.mul(o));
}).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" }
  ]
}), B$ = /* @__PURE__ */ Be(([r, e]) => r.mul(Sa(e.mul(2).sub(2), 0, 1))).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" }
  ]
}), z$ = /* @__PURE__ */ _3(), j$ = /* @__PURE__ */ _3(), RM = /* @__PURE__ */ Be(([r, e, i], { material: n }) => {
  const s = (n.side == es ? z$ : j$).uv(r), a = xa(Mx.x).mul(B$(e, i));
  return F$(s, a);
}), NM = /* @__PURE__ */ Be(([r, e, i]) => (rr(i.notEqual(0), () => {
  const n = $P(e).negate().div(i);
  return YP(n.negate().mul(r));
}), ye(1))).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" }
  ]
}), V$ = /* @__PURE__ */ Be(([r, e, i, n, s, a, o, l, u, c, h, d, p, f, m]) => {
  let v, y;
  if (m) {
    v = _t().toVar(), y = ye().toVar();
    const T = h.sub(1).mul(m.mul(0.025)), S = ye(h.sub(T), h, h.add(T));
    ys({ start: 0, end: 3 }, ({ i: w }) => {
      const C = S.element(w), E = CM(r, e, d, C, l), A = o.add(E), N = c.mul(u.mul(_t(A, 1))), L = qe(N.xy.div(N.w)).toVar();
      L.addAssign(1), L.divAssign(2), L.assign(qe(L.x, L.y.oneMinus()));
      const F = RM(L, i, C);
      v.element(w).assign(F.element(w)), v.a.addAssign(F.a), y.element(w).assign(n.element(w).mul(NM(go(E), p, f).element(w)));
    }), v.a.divAssign(3);
  } else {
    const T = CM(r, e, d, h, l), S = o.add(T), w = c.mul(u.mul(_t(S, 1))), C = qe(w.xy.div(w.w)).toVar();
    C.addAssign(1), C.divAssign(2), C.assign(qe(C.x, C.y.oneMinus())), v = RM(C, i, h), y = n.mul(NM(go(T), p, f));
  }
  const g = y.rgb.mul(v.rgb), _ = r.dot(e).clamp(), x = ye(D3({
    // n, v, specularColor, specularF90, roughness
    dotNV: _,
    specularColor: s,
    specularF90: a,
    roughness: i
  })), b = y.r.add(y.g, y.b).div(3);
  return _t(x.oneMinus().mul(g), v.a.oneMinus().mul(b).oneMinus());
}), G$ = /* @__PURE__ */ Rr(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
), H$ = (r) => {
  const e = r.sqrt();
  return ye(1).add(e).div(ye(1).sub(e));
}, PM = (r, e) => r.sub(e).div(r.add(e)).pow2(), W$ = (r, e) => {
  const i = r.mul(2 * Math.PI * 1e-9), n = ye(54856e-17, 44201e-17, 52481e-17), s = ye(1681e3, 1795300, 2208400), a = ye(43278e5, 93046e5, 66121e5), o = ve(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(i.mul(2239900).add(e.x).cos()).mul(i.pow2().mul(-45282e5).exp());
  let l = n.mul(a.mul(2 * Math.PI).sqrt()).mul(s.mul(i).add(e).cos()).mul(i.pow2().negate().mul(a).exp());
  return l = ye(l.x.add(o), l.y, l.z).div(10685e-11), G$.mul(l);
}, q$ = /* @__PURE__ */ Be(({ outsideIOR: r, eta2: e, cosTheta1: i, thinFilmThickness: n, baseF0: s }) => {
  const a = li(r, e, Cl(0, 0.03, n)), o = r.div(a).pow2().mul(i.pow2().oneMinus()).oneMinus();
  rr(o.lessThan(0), () => ye(1));
  const l = o.sqrt(), u = PM(a, r), c = Cd({ f0: u, f90: 1, dotVH: i }), h = c.oneMinus(), d = a.lessThan(r).select(Math.PI, 0), p = ve(Math.PI).sub(d), f = H$(s.clamp(0, 0.9999)), m = PM(f, a.toVec3()), v = Cd({ f0: m, f90: 1, dotVH: l }), y = ye(
    f.x.lessThan(a).select(Math.PI, 0),
    f.y.lessThan(a).select(Math.PI, 0),
    f.z.lessThan(a).select(Math.PI, 0)
  ), g = a.mul(n, l, 2), _ = ye(p).add(y), x = c.mul(v).clamp(1e-5, 0.9999), b = x.sqrt(), T = h.pow2().mul(v).div(ye(1).sub(x)), S = c.add(T).toVar(), w = T.sub(h).toVar();
  return ys({ start: 1, end: 2, condition: "<=", name: "m" }, ({ m: C }) => {
    w.mulAssign(b);
    const E = W$(ve(C).mul(g), ve(C).mul(_)).mul(2);
    S.addAssign(w.mul(E));
  }), S.max(ye(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
}), X$ = /* @__PURE__ */ Be(({ normal: r, viewDir: e, roughness: i }) => {
  const n = r.dot(e).saturate(), s = i.pow2(), a = Br(
    i.lessThan(0.25),
    ve(-339.2).mul(s).add(ve(161.4).mul(i)).sub(25.9),
    ve(-8.48).mul(s).add(ve(14.3).mul(i)).sub(9.95)
  ), o = Br(
    i.lessThan(0.25),
    ve(44).mul(s).sub(ve(23.7).mul(i)).add(3.26),
    ve(1.97).mul(s).sub(ve(3.27).mul(i)).add(0.72)
  );
  return Br(i.lessThan(0.25), 0, ve(0.1).mul(i).sub(0.025)).add(a.mul(n).add(o).exp()).mul(1 / Math.PI).saturate();
}), V0 = ye(0.04), G0 = ve(1);
class U3 extends Fg {
  constructor(e = !1, i = !1, n = !1, s = !1, a = !1, o = !1) {
    super(), this.clearcoat = e, this.sheen = i, this.iridescence = n, this.anisotropy = s, this.transmission = a, this.dispersion = o, this.clearcoatRadiance = null, this.clearcoatSpecularDirect = null, this.clearcoatSpecularIndirect = null, this.sheenSpecularDirect = null, this.sheenSpecularIndirect = null, this.iridescenceFresnel = null, this.iridescenceF0 = null;
  }
  start(e) {
    if (this.clearcoat === !0 && (this.clearcoatRadiance = ye().toVar("clearcoatRadiance"), this.clearcoatSpecularDirect = ye().toVar("clearcoatSpecularDirect"), this.clearcoatSpecularIndirect = ye().toVar("clearcoatSpecularIndirect")), this.sheen === !0 && (this.sheenSpecularDirect = ye().toVar("sheenSpecularDirect"), this.sheenSpecularIndirect = ye().toVar("sheenSpecularIndirect")), this.iridescence === !0) {
      const i = Ui.dot(vi).clamp();
      this.iridescenceFresnel = q$({
        outsideIOR: ve(1),
        eta2: zP,
        cosTheta1: i,
        thinFilmThickness: jP,
        baseF0: on
      }), this.iridescenceF0 = O$({ f: this.iridescenceFresnel, f90: 1, dotVH: i });
    }
    if (this.transmission === !0) {
      const i = wx, n = kX.sub(wx).normalize(), s = OT;
      e.backdrop = V$(
        s,
        n,
        na,
        Wt,
        on,
        Wm,
        // specularF90
        i,
        // positionWorld
        Rl,
        // modelMatrix
        Ra,
        // viewMatrix
        qm,
        // projMatrix
        am,
        VP,
        HP,
        GP,
        this.dispersion ? WP : null
      ), e.backdropAlpha = Sx, Wt.a.mulAssign(li(1, e.backdrop.a, Sx));
    }
  }
  // Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(e, i, n) {
    const s = Ui.dot(vi).clamp(), a = I3({ roughness: na, dotNV: s }), o = (this.iridescenceF0 ? ET.mix(on, this.iridescenceF0) : on).mul(a.x).add(n.mul(a.y)), l = a.x.add(a.y).oneMinus(), u = on.add(on.oneMinus().mul(0.047619)), c = o.mul(u).div(l.mul(u).oneMinus());
    e.addAssign(o), i.addAssign(c.mul(l));
  }
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }) {
    const s = Ui.dot(e).clamp().mul(i);
    if (this.sheen === !0 && this.sheenSpecularDirect.addAssign(s.mul(k$({ lightDirection: e }))), this.clearcoat === !0) {
      const a = Vh.dot(e).clamp().mul(i);
      this.clearcoatSpecularDirect.addAssign(a.mul(_M({ lightDirection: e, f0: V0, f90: G0, roughness: Hm, normalView: Vh })));
    }
    n.directDiffuse.addAssign(s.mul(Mc({ diffuseColor: Wt.rgb }))), n.directSpecular.addAssign(s.mul(_M({ lightDirection: e, f0: on, f90: 1, roughness: na, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy })));
  }
  directRectArea({ lightColor: e, lightPosition: i, halfWidth: n, halfHeight: s, reflectedLight: a, ltc_1: o, ltc_2: l }) {
    const u = i.add(n).sub(s), c = i.sub(n).sub(s), h = i.sub(n).add(s), d = i.add(n).add(s), p = Ui, f = vi, m = ir.toVar(), v = L$({ N: p, V: f, roughness: na }), y = o.uv(v).toVar(), g = l.uv(v).toVar(), _ = Rr(
      ye(y.x, 0, y.y),
      ye(0, 1, 0),
      ye(y.z, 0, y.w)
    ).toVar(), x = on.mul(g.x).add(on.oneMinus().mul(g.y)).toVar();
    a.directSpecular.addAssign(e.mul(x).mul(TM({ N: p, V: f, P: m, mInv: _, p0: u, p1: c, p2: h, p3: d }))), a.directDiffuse.addAssign(e.mul(Wt).mul(TM({ N: p, V: f, P: m, mInv: Rr(1, 0, 0, 0, 1, 0, 0, 0, 1), p0: u, p1: c, p2: h, p3: d })));
  }
  indirect(e, i, n) {
    this.indirectDiffuse(e, i, n), this.indirectSpecular(e, i, n), this.ambientOcclusion(e, i, n);
  }
  indirectDiffuse({ irradiance: e, reflectedLight: i }) {
    i.indirectDiffuse.addAssign(e.mul(Mc({ diffuseColor: Wt })));
  }
  indirectSpecular({ radiance: e, iblIrradiance: i, reflectedLight: n }) {
    if (this.sheen === !0 && this.sheenSpecularIndirect.addAssign(i.mul(
      zu,
      X$({
        normal: Ui,
        viewDir: vi,
        roughness: wT
      })
    )), this.clearcoat === !0) {
      const c = Vh.dot(vi).clamp(), h = D3({
        dotNV: c,
        specularColor: V0,
        specularF90: G0,
        roughness: Hm
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(h));
    }
    const s = ye().toVar("singleScattering"), a = ye().toVar("multiScattering"), o = i.mul(1 / Math.PI);
    this.computeMultiscattering(s, a, Wm);
    const l = s.add(a), u = Wt.mul(l.r.max(l.g).max(l.b).oneMinus());
    n.indirectSpecular.addAssign(e.mul(s)), n.indirectSpecular.addAssign(a.mul(o)), n.indirectDiffuse.addAssign(u.mul(o));
  }
  ambientOcclusion({ ambientOcclusion: e, reflectedLight: i }) {
    const n = Ui.dot(vi).clamp().add(e), s = na.mul(-16).oneMinus().negate().exp2(), a = e.sub(n.pow(s).oneMinus()).clamp();
    this.clearcoat === !0 && this.clearcoatSpecularIndirect.mulAssign(e), this.sheen === !0 && this.sheenSpecularIndirect.mulAssign(e), i.indirectDiffuse.mulAssign(e), i.indirectSpecular.mulAssign(a);
  }
  finish(e) {
    const { outgoingLight: i } = e;
    if (this.clearcoat === !0) {
      const n = Vh.dot(vi).clamp(), s = Cd({
        dotVH: n,
        f0: V0,
        f90: G0
      }), a = i.mul(xx.mul(s).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(xx));
      i.assign(a);
    }
    if (this.sheen === !0) {
      const n = zu.r.max(zu.g).max(zu.b).mul(0.157).oneMinus(), s = i.mul(n).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      i.assign(s);
    }
  }
}
const OM = /* @__PURE__ */ ve(1), Rx = /* @__PURE__ */ ve(-2), ff = /* @__PURE__ */ ve(0.8), H0 = /* @__PURE__ */ ve(-1), mf = /* @__PURE__ */ ve(0.4), W0 = /* @__PURE__ */ ve(2), gf = /* @__PURE__ */ ve(0.305), q0 = /* @__PURE__ */ ve(3), IM = /* @__PURE__ */ ve(0.21), Y$ = /* @__PURE__ */ ve(4), DM = /* @__PURE__ */ ve(4), $$ = /* @__PURE__ */ ve(16), K$ = /* @__PURE__ */ Be(([r]) => {
  const e = ye(qn(r)).toVar(), i = ve(-1).toVar();
  return rr(e.x.greaterThan(e.z), () => {
    rr(e.x.greaterThan(e.y), () => {
      i.assign(Br(r.x.greaterThan(0), 0, 3));
    }).Else(() => {
      i.assign(Br(r.y.greaterThan(0), 1, 4));
    });
  }).Else(() => {
    rr(e.z.greaterThan(e.y), () => {
      i.assign(Br(r.z.greaterThan(0), 2, 5));
    }).Else(() => {
      i.assign(Br(r.y.greaterThan(0), 1, 4));
    });
  }), i;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
}), Q$ = /* @__PURE__ */ Be(([r, e]) => {
  const i = qe().toVar();
  return rr(e.equal(0), () => {
    i.assign(qe(r.z, r.y).div(qn(r.x)));
  }).ElseIf(e.equal(1), () => {
    i.assign(qe(r.x.negate(), r.z.negate()).div(qn(r.y)));
  }).ElseIf(e.equal(2), () => {
    i.assign(qe(r.x.negate(), r.y).div(qn(r.z)));
  }).ElseIf(e.equal(3), () => {
    i.assign(qe(r.z.negate(), r.y).div(qn(r.x)));
  }).ElseIf(e.equal(4), () => {
    i.assign(qe(r.x.negate(), r.z).div(qn(r.y)));
  }).Else(() => {
    i.assign(qe(r.x, r.y).div(qn(r.z)));
  }), It(0.5, i.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
}), Z$ = /* @__PURE__ */ Be(([r]) => {
  const e = ve(0).toVar();
  return rr(r.greaterThanEqual(ff), () => {
    e.assign(OM.sub(r).mul(H0.sub(Rx)).div(OM.sub(ff)).add(Rx));
  }).ElseIf(r.greaterThanEqual(mf), () => {
    e.assign(ff.sub(r).mul(W0.sub(H0)).div(ff.sub(mf)).add(H0));
  }).ElseIf(r.greaterThanEqual(gf), () => {
    e.assign(mf.sub(r).mul(q0.sub(W0)).div(mf.sub(gf)).add(W0));
  }).ElseIf(r.greaterThanEqual(IM), () => {
    e.assign(gf.sub(r).mul(Y$.sub(q0)).div(gf.sub(IM)).add(q0));
  }).Else(() => {
    e.assign(ve(-2).mul(xa(It(1.16, r))));
  }), e;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
}), J$ = /* @__PURE__ */ Be(([r, e]) => {
  const i = r.toVar();
  i.assign(It(2, i).sub(1));
  const n = ye(i, 1).toVar();
  return rr(e.equal(0), () => {
    n.assign(n.zyx);
  }).ElseIf(e.equal(1), () => {
    n.assign(n.xzy), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(2), () => {
    n.x.mulAssign(-1);
  }).ElseIf(e.equal(3), () => {
    n.assign(n.zyx), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(4), () => {
    n.assign(n.xzy), n.xy.mulAssign(-1);
  }).ElseIf(e.equal(5), () => {
    n.z.mulAssign(-1);
  }), n;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
}), eK = /* @__PURE__ */ Be(([r, e, i, n, s, a]) => {
  const o = ve(i), l = ye(e), u = Sa(Z$(o), Rx, a), c = wo(u), h = bl(u), d = ye(Nx(r, l, h, n, s, a)).toVar();
  return rr(c.notEqual(0), () => {
    const p = ye(Nx(r, l, h.add(1), n, s, a)).toVar();
    d.assign(li(d, p, c));
  }), d;
}), Nx = /* @__PURE__ */ Be(([r, e, i, n, s, a]) => {
  const o = ve(i).toVar(), l = ye(e), u = ve(K$(l)).toVar(), c = ve(An(DM.sub(o), 0)).toVar();
  o.assign(An(o, DM));
  const h = ve(_d(o)).toVar(), d = qe(Q$(l, u).mul(h.sub(2)).add(1)).toVar();
  return rr(u.greaterThan(2), () => {
    d.y.addAssign(h), u.subAssign(3);
  }), d.x.addAssign(u.mul(h)), d.x.addAssign(c.mul(It(3, $$))), d.y.addAssign(It(4, _d(a).sub(h))), d.x.mulAssign(n), d.y.mulAssign(s), r.uv(d).grad(qe(), qe());
}), X0 = /* @__PURE__ */ Be(({ envMap: r, mipInt: e, outputDirection: i, theta: n, axis: s, CUBEUV_TEXEL_WIDTH: a, CUBEUV_TEXEL_HEIGHT: o, CUBEUV_MAX_MIP: l }) => {
  const u = eo(n), c = i.mul(u).add(s.cross(i).mul(Wn(n))).add(s.mul(s.dot(i).mul(u.oneMinus())));
  return Nx(r, c, e, a, o, l);
}), tK = /* @__PURE__ */ Be(({ n: r, latitudinal: e, poleAxis: i, outputDirection: n, weights: s, samples: a, dTheta: o, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }) => {
  const p = ye(Br(e, i, t3(i, n))).toVar();
  rr(XP(p.equals(ye(0))), () => {
    p.assign(ye(n.z, 0, n.x.negate()));
  }), p.assign(Td(p));
  const f = ye().toVar();
  return f.addAssign(s.element(Mi(0)).mul(X0({ theta: 0, axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }))), ys({ start: Mi(1), end: r }, ({ i: m }) => {
    rr(m.greaterThanEqual(a), () => {
      WY();
    });
    const v = ve(o.mul(ve(m))).toVar();
    f.addAssign(s.element(m).mul(X0({ theta: v.mul(-1), axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }))), f.addAssign(s.element(m).mul(X0({ theta: v, axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d })));
  }), _t(f, 1);
});
let Xm = null;
const kM = /* @__PURE__ */ new WeakMap();
function iK(r) {
  const e = Math.log2(r) - 2, i = 1 / r;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: i, maxMip: e };
}
function rK(r) {
  let e = kM.get(r);
  if ((e !== void 0 ? e.pmremVersion : -1) !== r.pmremVersion) {
    const i = r.image;
    if (r.isCubeTexture)
      if (sK(i))
        e = Xm.fromCubemap(r, e);
      else
        return null;
    else if (aK(i))
      e = Xm.fromEquirectangular(r, e);
    else
      return null;
    e.pmremVersion = r.pmremVersion, kM.set(r, e);
  }
  return e.texture;
}
class nK extends zi {
  static get type() {
    return "PMREMNode";
  }
  constructor(e, i = null, n = null) {
    super("vec3"), this._value = e, this._pmrem = null, this.uvNode = i, this.levelNode = n, this._generator = null;
    const s = new Ar();
    s.isRenderTargetTexture = !0, this._texture = Ci(s), this._width = Tt(0), this._height = Tt(0), this._maxMip = Tt(0), this.updateBeforeType = Pt.RENDER;
  }
  set value(e) {
    this._value = e, this._pmrem = null;
  }
  get value() {
    return this._value;
  }
  updateFromTexture(e) {
    const i = iK(e.image.height);
    this._texture.value = e, this._width.value = i.texelWidth, this._height.value = i.texelHeight, this._maxMip.value = i.maxMip;
  }
  updateBefore() {
    let e = this._pmrem;
    const i = e ? e.pmremVersion : -1, n = this._value;
    i !== n.pmremVersion && (n.isPMREMTexture === !0 ? e = n : e = rK(n), e !== null && (this._pmrem = e, this.updateFromTexture(e)));
  }
  setup(e) {
    Xm === null && (Xm = e.createPMREMGenerator()), this.updateBefore(e);
    let i = this.uvNode;
    i === null && e.context.getUV && (i = e.context.getUV(this));
    const n = this.value;
    e.renderer.coordinateSystem === Zn && n.isPMREMTexture !== !0 && n.isRenderTargetTexture === !0 && (i = ye(i.x.negate(), i.yz));
    let s = this.levelNode;
    return s === null && e.context.getTextureLevel && (s = e.context.getTextureLevel(this)), eK(this._texture, i, s, this._width, this._height, this._maxMip);
  }
}
function sK(r) {
  if (r == null) return !1;
  let e = 0;
  const i = 6;
  for (let n = 0; n < i; n++)
    r[n] !== void 0 && e++;
  return e === i;
}
function aK(r) {
  return r == null ? !1 : r.height > 0;
}
const F3 = /* @__PURE__ */ Me(nK), LM = /* @__PURE__ */ new WeakMap();
class oK extends Gc {
  static get type() {
    return "EnvironmentNode";
  }
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    const { material: i } = e;
    let n = this.envNode;
    if (n.isTextureNode || n.isMaterialReferenceNode) {
      const d = n.isTextureNode ? n.value : i[n.property];
      let p = LM.get(d);
      p === void 0 && (p = F3(d), LM.set(d, p)), n = p;
    }
    const s = i.envMap ? bi("envMapIntensity", "float", e.material) : bi("environmentIntensity", "float", e.scene), a = i.useAnisotropy === !0 || i.anisotropy > 0 ? JX : Ui, o = n.context(UM(na, a)).mul(s), l = n.context(lK(OT)).mul(Math.PI).mul(s), u = om(o), c = om(l);
    e.context.radiance.addAssign(u), e.context.iblIrradiance.addAssign(c);
    const h = e.context.lightingModel.clearcoatRadiance;
    if (h) {
      const d = n.context(UM(Hm, Vh)).mul(s), p = om(d);
      h.addAssign(p);
    }
  }
}
const UM = (r, e) => {
  let i = null;
  return {
    getUV: () => (i === null && (i = vi.negate().reflect(e), i = r.mul(r).mix(i, e).normalize(), i = i.transformDirection(Ra)), i),
    getTextureLevel: () => r
  };
}, lK = (r) => ({
  getUV: () => r,
  getTextureLevel: () => ve(1)
}), uK = /* @__PURE__ */ new gT();
class B3 extends Bi {
  static get type() {
    return "MeshStandardNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardNodeMaterial = !0, this.lights = !0, this.emissiveNode = null, this.metalnessNode = null, this.roughnessNode = null, this.setDefaultValues(uK), this.setValues(e);
  }
  setupEnvironment(e) {
    let i = super.setupEnvironment(e);
    return i === null && e.environmentNode && (i = e.environmentNode), i ? new oK(i) : null;
  }
  setupLightingModel() {
    return new U3();
  }
  setupSpecular() {
    const e = li(ye(0.04), Wt.rgb, Gm);
    on.assign(e), Wm.assign(1);
  }
  setupVariants() {
    const e = this.metalnessNode ? ve(this.metalnessNode) : pY;
    Gm.assign(e);
    let i = this.roughnessNode ? ve(this.roughnessNode) : dY;
    i = O3({ roughness: i }), na.assign(i), this.setupSpecular(), Wt.assign(_t(Wt.rgb.mul(e.oneMinus()), Wt.a));
  }
  copy(e) {
    return this.emissiveNode = e.emissiveNode, this.metalnessNode = e.metalnessNode, this.roughnessNode = e.roughnessNode, super.copy(e);
  }
}
const cK = /* @__PURE__ */ new _P();
class hK extends B3 {
  static get type() {
    return "MeshPhysicalNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhysicalNodeMaterial = !0, this.clearcoatNode = null, this.clearcoatRoughnessNode = null, this.clearcoatNormalNode = null, this.sheenNode = null, this.sheenRoughnessNode = null, this.iridescenceNode = null, this.iridescenceIORNode = null, this.iridescenceThicknessNode = null, this.specularIntensityNode = null, this.specularColorNode = null, this.iorNode = null, this.transmissionNode = null, this.thicknessNode = null, this.attenuationDistanceNode = null, this.attenuationColorNode = null, this.dispersionNode = null, this.anisotropyNode = null, this.setDefaultValues(cK), this.setValues(e);
  }
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  get useDispersion() {
    return this.dispersion > 0 || this.dispersionNode !== null;
  }
  setupSpecular() {
    const e = this.iorNode ? ve(this.iorNode) : AY;
    am.assign(e), on.assign(li(Sd(i3(am.sub(1).div(am.add(1))).mul(hY), ye(1)).mul(mM), Wt.rgb, Gm)), Wm.assign(li(mM, 1, Gm));
  }
  setupLightingModel() {
    return new U3(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
  }
  setupVariants(e) {
    if (super.setupVariants(e), this.useClearcoat) {
      const i = this.clearcoatNode ? ve(this.clearcoatNode) : mY, n = this.clearcoatRoughnessNode ? ve(this.clearcoatRoughnessNode) : gY;
      xx.assign(i), Hm.assign(O3({ roughness: n }));
    }
    if (this.useSheen) {
      const i = this.sheenNode ? ye(this.sheenNode) : bY, n = this.sheenRoughnessNode ? ve(this.sheenRoughnessNode) : xY;
      zu.assign(i), wT.assign(n);
    }
    if (this.useIridescence) {
      const i = this.iridescenceNode ? ve(this.iridescenceNode) : TY, n = this.iridescenceIORNode ? ve(this.iridescenceIORNode) : SY, s = this.iridescenceThicknessNode ? ve(this.iridescenceThicknessNode) : wY;
      ET.assign(i), zP.assign(n), jP.assign(s);
    }
    if (this.useAnisotropy) {
      const i = (this.anisotropyNode ? qe(this.anisotropyNode) : _Y).toVar();
      qo.assign(i.length()), rr(qo.equal(0), () => {
        i.assign(qe(1, 0));
      }).Else(() => {
        i.divAssign(qe(qo)), qo.assign(qo.saturate());
      }), _x.assign(qo.pow2().mix(na.pow2(), 1)), sm.assign(Gh[0].mul(i.x).add(Gh[1].mul(i.y))), tc.assign(Gh[1].mul(i.x).sub(Gh[0].mul(i.y)));
    }
    if (this.useTransmission) {
      const i = this.transmissionNode ? ve(this.transmissionNode) : EY, n = this.thicknessNode ? ve(this.thicknessNode) : MY, s = this.attenuationDistanceNode ? ve(this.attenuationDistanceNode) : CY, a = this.attenuationColorNode ? ye(this.attenuationColorNode) : RY;
      if (Sx.assign(i), VP.assign(n), GP.assign(s), HP.assign(a), this.useDispersion) {
        const o = this.dispersionNode ? ve(this.dispersionNode) : IY;
        WP.assign(o);
      }
    }
  }
  setupClearcoatNormal() {
    return this.clearcoatNormalNode ? ye(this.clearcoatNormalNode) : yY;
  }
  setup(e) {
    e.context.setupClearcoatNormal = () => this.setupClearcoatNormal(e), super.setup(e);
  }
  copy(e) {
    return this.clearcoatNode = e.clearcoatNode, this.clearcoatRoughnessNode = e.clearcoatRoughnessNode, this.clearcoatNormalNode = e.clearcoatNormalNode, this.sheenNode = e.sheenNode, this.sheenRoughnessNode = e.sheenRoughnessNode, this.iridescenceNode = e.iridescenceNode, this.iridescenceIORNode = e.iridescenceIORNode, this.iridescenceThicknessNode = e.iridescenceThicknessNode, this.specularIntensityNode = e.specularIntensityNode, this.specularColorNode = e.specularColorNode, this.transmissionNode = e.transmissionNode, this.thicknessNode = e.thicknessNode, this.attenuationDistanceNode = e.attenuationDistanceNode, this.attenuationColorNode = e.attenuationColorNode, this.dispersionNode = e.dispersionNode, this.anisotropyNode = e.anisotropyNode, super.copy(e);
  }
}
const dK = /* @__PURE__ */ Be(({ normal: r, lightDirection: e, builder: i }) => {
  const n = r.dot(e), s = qe(n.mul(0.5).add(0.5), 0);
  if (i.material.gradientMap) {
    const a = ro("gradientMap", "texture").context({ getUV: () => s });
    return ye(a.r);
  } else {
    const a = s.fwidth().mul(0.5);
    return li(ye(0.7), ye(1), Cl(ve(0.7).sub(a.x), ve(0.7).add(a.x), s.x));
  }
});
class pK extends Fg {
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }, s, a) {
    const o = dK({ normal: h3, lightDirection: e, builder: a }).mul(i);
    n.directDiffuse.addAssign(o.mul(Mc({ diffuseColor: Wt.rgb })));
  }
  indirect({ ambientOcclusion: e, irradiance: i, reflectedLight: n }) {
    n.indirectDiffuse.addAssign(i.mul(Mc({ diffuseColor: Wt }))), n.indirectDiffuse.mulAssign(e);
  }
}
const fK = /* @__PURE__ */ new SP();
class mK extends Bi {
  static get type() {
    return "MeshToonNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshToonNodeMaterial = !0, this.lights = !0, this.setDefaultValues(fK), this.setValues(e);
  }
  setupLightingModel() {
    return new pK();
  }
}
class gK extends zi {
  static get type() {
    return "MatcapUVNode";
  }
  constructor() {
    super("vec2");
  }
  setup() {
    const e = ye(vi.z, 0, vi.x.negate()).normalize(), i = vi.cross(e);
    return qe(e.dot(Ui), i.dot(Ui)).mul(0.495).add(0.5);
  }
}
const yK = /* @__PURE__ */ He(gK), vK = /* @__PURE__ */ new MP();
class bK extends Bi {
  static get type() {
    return "MeshMatcapNodeMaterial";
  }
  constructor(e) {
    super(), this.lights = !1, this.isMeshMatcapNodeMaterial = !0, this.setDefaultValues(vK), this.setValues(e);
  }
  setupVariants(e) {
    const i = yK;
    let n;
    e.material.matcap ? n = ro("matcap", "texture").context({ getUV: () => i }) : n = ye(li(0.2, 0.8, i.y)), Wt.rgb.mulAssign(n.rgb);
  }
}
const xK = /* @__PURE__ */ new bP();
class _K extends Bi {
  static get type() {
    return "PointsNodeMaterial";
  }
  constructor(e) {
    super(), this.isPointsNodeMaterial = !0, this.lights = !1, this.transparent = !0, this.sizeNode = null, this.setDefaultValues(xK), this.setValues(e);
  }
  copy(e) {
    return this.sizeNode = e.sizeNode, super.copy(e);
  }
}
class TK extends zi {
  static get type() {
    return "RotateNode";
  }
  constructor(e, i) {
    super(), this.positionNode = e, this.rotationNode = i;
  }
  getNodeType(e) {
    return this.positionNode.getNodeType(e);
  }
  setup(e) {
    const { rotationNode: i, positionNode: n } = this;
    if (this.getNodeType(e) === "vec2") {
      const s = i.cos(), a = i.sin();
      return ST(
        s,
        a,
        a.negate(),
        s
      ).mul(n);
    } else {
      const s = i, a = ec(_t(1, 0, 0, 0), _t(0, eo(s.x), Wn(s.x).negate(), 0), _t(0, Wn(s.x), eo(s.x), 0), _t(0, 0, 0, 1)), o = ec(_t(eo(s.y), 0, Wn(s.y), 0), _t(0, 1, 0, 0), _t(Wn(s.y).negate(), 0, eo(s.y), 0), _t(0, 0, 0, 1)), l = ec(_t(eo(s.z), Wn(s.z).negate(), 0, 0), _t(Wn(s.z), eo(s.z), 0, 0), _t(0, 0, 1, 0), _t(0, 0, 0, 1));
      return a.mul(o).mul(l).mul(_t(n, 1)).xyz;
    }
  }
}
const SK = /* @__PURE__ */ Me(TK), wK = /* @__PURE__ */ new yP();
class EK extends Bi {
  static get type() {
    return "SpriteNodeMaterial";
  }
  constructor(e) {
    super(), this.isSpriteNodeMaterial = !0, this.lights = !1, this._useSizeAttenuation = !0, this.positionNode = null, this.rotationNode = null, this.scaleNode = null, this.setDefaultValues(wK), this.setValues(e);
  }
  setupPosition({ object: e, camera: i, context: n }) {
    const s = this.sizeAttenuation, { positionNode: a, rotationNode: o, scaleNode: l } = this, u = nr;
    let c = Lg.mul(ye(a || 0)), h = qe(Rl[0].xyz.length(), Rl[1].xyz.length());
    if (l !== null && (h = h.mul(l)), !s)
      if (i.isPerspectiveCamera)
        h = h.mul(c.z.negate());
      else {
        const v = ve(2).div(qm.element(1).element(1));
        h = h.mul(v.mul(2));
      }
    let d = u.xy;
    if (e.center && e.center.isVector2 === !0) {
      const v = dX("center", "vec2");
      d = d.sub(v.sub(0.5));
    }
    d = d.mul(h);
    const p = ve(o || vY), f = SK(d, p);
    c = _t(c.xy.add(f), c.zw);
    const m = qm.mul(c);
    return n.vertex = u, m;
  }
  copy(e) {
    return this.positionNode = e.positionNode, this.rotationNode = e.rotationNode, this.scaleNode = e.scaleNode, super.copy(e);
  }
  get sizeAttenuation() {
    return this._useSizeAttenuation;
  }
  set sizeAttenuation(e) {
    this._useSizeAttenuation !== e && (this._useSizeAttenuation = e, this.needsUpdate = !0);
  }
}
class MK extends Fg {
  constructor() {
    super(), this.shadowNode = ve(1).toVar("shadowMask");
  }
  direct({ shadowMask: e }) {
    this.shadowNode.mulAssign(e);
  }
  finish(e) {
    Wt.a.mulAssign(this.shadowNode.oneMinus()), e.outgoingLight.rgb.assign(Wt.rgb);
  }
}
const AK = /* @__PURE__ */ new xP();
class CK extends Bi {
  static get type() {
    return "ShadowNodeMaterial";
  }
  constructor(e) {
    super(), this.isShadowNodeMaterial = !0, this.lights = !0, this.setDefaultValues(AK), this.setValues(e);
  }
  setupLightingModel() {
    return new MK();
  }
}
Be(({ texture: r, uv: e }) => {
  const i = ye().toVar();
  return rr(e.x.lessThan(1e-4), () => {
    i.assign(ye(1, 0, 0));
  }).ElseIf(e.y.lessThan(1e-4), () => {
    i.assign(ye(0, 1, 0));
  }).ElseIf(e.z.lessThan(1e-4), () => {
    i.assign(ye(0, 0, 1));
  }).ElseIf(e.x.greaterThan(1 - 1e-4), () => {
    i.assign(ye(-1, 0, 0));
  }).ElseIf(e.y.greaterThan(1 - 1e-4), () => {
    i.assign(ye(0, -1, 0));
  }).ElseIf(e.z.greaterThan(1 - 1e-4), () => {
    i.assign(ye(0, 0, -1));
  }).Else(() => {
    const n = r.uv(e.add(ye(-0.01, 0, 0))).r.sub(r.uv(e.add(ye(0.01, 0, 0))).r), s = r.uv(e.add(ye(0, -0.01, 0))).r.sub(r.uv(e.add(ye(0, 0.01, 0))).r), a = r.uv(e.add(ye(0, 0, -0.01))).r.sub(r.uv(e.add(ye(0, 0, 0.01))).r);
    i.assign(ye(n, s, a));
  }), i.normalize();
});
class RK {
  constructor(e, i) {
    this.nodes = e, this.info = i, this.animationLoop = null, this.requestId = null, this._init();
  }
  _init() {
    const e = (i, n) => {
      this.requestId = self.requestAnimationFrame(e), this.info.autoReset === !0 && this.info.reset(), this.nodes.nodeFrame.update(), this.info.frame = this.nodes.nodeFrame.frameId, this.animationLoop !== null && this.animationLoop(i, n);
    };
    e();
  }
  dispose() {
    self.cancelAnimationFrame(this.requestId), this.requestId = null;
  }
  setAnimationLoop(e) {
    this.animationLoop = e;
  }
}
class Es {
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
  }
  get(e) {
    let i = this.weakMap;
    for (let n = 0; n < e.length; n++)
      if (i = i.get(e[n]), i === void 0) return;
    return i.get(e[e.length - 1]);
  }
  set(e, i) {
    let n = this.weakMap;
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      n.has(a) === !1 && n.set(a, /* @__PURE__ */ new WeakMap()), n = n.get(a);
    }
    return n.set(e[e.length - 1], i);
  }
  delete(e) {
    let i = this.weakMap;
    for (let n = 0; n < e.length; n++)
      if (i = i.get(e[n]), i === void 0) return !1;
    return i.delete(e[e.length - 1]);
  }
}
const Y0 = /* @__PURE__ */ new Ja();
class Px {
  constructor() {
    this.version = 0, this.globalClippingCount = 0, this.localClippingCount = 0, this.localClippingEnabled = !1, this.localClipIntersection = !1, this.planes = [], this.parentVersion = 0, this.viewNormalMatrix = new Yr(), this.cacheKey = 0;
  }
  projectPlanes(e, i) {
    const n = e.length, s = this.planes;
    for (let a = 0; a < n; a++) {
      Y0.copy(e[a]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
      const o = s[i + a], l = Y0.normal;
      o.x = -l.x, o.y = -l.y, o.z = -l.z, o.w = Y0.constant;
    }
  }
  updateGlobal(e, i) {
    const n = e.clippingPlanes;
    this.viewMatrix = i.matrixWorldInverse, this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
    let s = !1;
    if (Array.isArray(n) && n.length !== 0) {
      const a = n.length;
      if (a !== this.globalClippingCount) {
        const o = [];
        for (let l = 0; l < a; l++)
          o.push(new $t());
        this.globalClippingCount = a, this.planes = o, s = !0;
      }
      this.projectPlanes(n, 0);
    } else this.globalClippingCount !== 0 && (this.globalClippingCount = 0, this.planes = [], s = !0);
    e.localClippingEnabled !== this.localClippingEnabled && (this.localClippingEnabled = e.localClippingEnabled, s = !0), s && (this.version++, this.cacheKey = Fm(this.globalClippingCount, this.localClippingEnabled === !0 ? 1 : 0));
  }
  update(e, i) {
    let n = !1;
    if (this !== e && e.version !== this.parentVersion && (this.globalClippingCount = i.isShadowNodeMaterial ? 0 : e.globalClippingCount, this.localClippingEnabled = e.localClippingEnabled, this.planes = Array.from(e.planes), this.parentVersion = e.version, this.viewMatrix = e.viewMatrix, this.viewNormalMatrix = e.viewNormalMatrix, n = !0), this.localClippingEnabled) {
      const s = i.clippingPlanes;
      if (Array.isArray(s) && s.length !== 0) {
        const a = s.length, o = this.planes, l = this.globalClippingCount;
        if (n || a !== this.localClippingCount) {
          o.length = l + a;
          for (let u = 0; u < a; u++)
            o[l + u] = new $t();
          this.localClippingCount = a, n = !0;
        }
        this.projectPlanes(s, l);
      } else this.localClippingCount !== 0 && (this.localClippingCount = 0, n = !0);
      this.localClipIntersection !== i.clipIntersection && (this.localClipIntersection = i.clipIntersection, n = !0);
    }
    n && (this.version += e.version, this.cacheKey = Fm(e.cacheKey, this.localClippingCount, this.localClipIntersection === !0 ? 1 : 0));
  }
}
let NK = 0;
function PK(r) {
  const e = Object.keys(r);
  let i = Object.getPrototypeOf(r);
  for (; i; ) {
    const n = Object.getOwnPropertyDescriptors(i);
    for (const s in n)
      if (n[s] !== void 0) {
        const a = n[s];
        a && typeof a.get == "function" && e.push(s);
      }
    i = Object.getPrototypeOf(i);
  }
  return e;
}
class OK {
  constructor(e, i, n, s, a, o, l, u, c) {
    this._nodes = e, this._geometries = i, this.id = NK++, this.renderer = n, this.object = s, this.material = a, this.scene = o, this.camera = l, this.lightsNode = u, this.context = c, this.geometry = s.geometry, this.version = a.version, this.drawRange = null, this.attributes = null, this.pipeline = null, this.vertexBuffers = null, this.drawParams = null, this.bundle = null, this.updateClipping(c.clippingContext), this.clippingContextVersion = this.clippingContext.version, this.initialNodesCacheKey = this.getDynamicCacheKey(), this.initialCacheKey = this.getCacheKey(), this._nodeBuilderState = null, this._bindings = null, this._monitor = null, this.onDispose = null, this.isRenderObject = !0, this.onMaterialDispose = () => {
      this.dispose();
    }, this.material.addEventListener("dispose", this.onMaterialDispose);
  }
  updateClipping(e) {
    const i = this.material;
    let n = this.clippingContext;
    Array.isArray(i.clippingPlanes) ? ((n === e || !n) && (n = new Px(), this.clippingContext = n), n.update(e, i)) : this.clippingContext !== e && (this.clippingContext = e);
  }
  get clippingNeedsUpdate() {
    return this.clippingContext.version === this.clippingContextVersion ? !1 : (this.clippingContextVersion = this.clippingContext.version, !0);
  }
  getNodeBuilderState() {
    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
  }
  getMonitor() {
    return this._monitor || (this._monitor = this.getNodeBuilderState().monitor);
  }
  getBindings() {
    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
  }
  getIndex() {
    return this._geometries.getIndex(this);
  }
  getIndirect() {
    return this._geometries.getIndirect(this);
  }
  getChainArray() {
    return [this.object, this.material, this.context, this.lightsNode];
  }
  getAttributes() {
    if (this.attributes !== null) return this.attributes;
    const e = this.getNodeBuilderState().nodeAttributes, i = this.geometry, n = [], s = /* @__PURE__ */ new Set();
    for (const a of e) {
      const o = a.node && a.node.attribute ? a.node.attribute : i.getAttribute(a.name);
      if (o === void 0) continue;
      n.push(o);
      const l = o.isInterleavedBufferAttribute ? o.data : o;
      s.add(l);
    }
    return this.attributes = n, this.vertexBuffers = Array.from(s.values()), n;
  }
  getVertexBuffers() {
    return this.vertexBuffers === null && this.getAttributes(), this.vertexBuffers;
  }
  getDrawParameters() {
    const { object: e, material: i, geometry: n, group: s, drawRange: a } = this, o = this.drawParams || (this.drawParams = {
      vertexCount: 0,
      firstVertex: 0,
      instanceCount: 0,
      firstInstance: 0
    }), l = this.getIndex(), u = l !== null, c = n.isInstancedBufferGeometry ? n.instanceCount : e.count > 1 ? e.count : 1;
    if (c === 0) return null;
    if (o.instanceCount = c, e.isBatchedMesh === !0) return o;
    let h = 1;
    i.wireframe === !0 && !e.isPoints && !e.isLineSegments && !e.isLine && !e.isLineLoop && (h = 2);
    let d = a.start * h, p = (a.start + a.count) * h;
    s !== null && (d = Math.max(d, s.start * h), p = Math.min(p, (s.start + s.count) * h));
    const f = n.attributes.position;
    let m = 1 / 0;
    u ? m = l.count : f != null && (m = f.count), d = Math.max(d, 0), p = Math.min(p, m);
    const v = p - d;
    return v < 0 || v === 1 / 0 ? null : (o.vertexCount = v, o.firstVertex = d, o);
  }
  getGeometryCacheKey() {
    const { geometry: e } = this;
    let i = "";
    for (const n of Object.keys(e.attributes).sort()) {
      const s = e.attributes[n];
      i += n + ",", s.data && (i += s.data.stride + ","), s.offset && (i += s.offset + ","), s.itemSize && (i += s.itemSize + ","), s.normalized && (i += "n,");
    }
    return e.index && (i += "index,"), i;
  }
  getMaterialCacheKey() {
    const { object: e, material: i } = this;
    let n = i.customProgramCacheKey();
    for (const s of PK(i)) {
      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(s)) continue;
      const a = i[s];
      let o;
      if (a !== null) {
        const l = typeof a;
        l === "number" ? o = a !== 0 ? "1" : "0" : l === "object" ? (o = "{", a.isTexture && (o += a.mapping), o += "}") : o = String(a);
      } else
        o = String(a);
      n += /*property + ':' +*/
      o + ",";
    }
    return n += this.clippingContext.cacheKey + ",", e.geometry && (n += this.getGeometryCacheKey()), e.skeleton && (n += e.skeleton.bones.length + ","), e.morphTargetInfluences && (n += e.morphTargetInfluences.length + ","), e.isBatchedMesh && (n += e._matricesTexture.uuid + ",", e._colorsTexture !== null && (n += e._colorsTexture.uuid + ",")), e.count > 1 && (n += e.uuid + ","), yW(n);
  }
  get needsUpdate() {
    return (
      /*this.object.static !== true &&*/
      this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate
    );
  }
  getDynamicCacheKey() {
    let e = this._nodes.getCacheKey(this.scene, this.lightsNode);
    return this.object.receiveShadow && (e += 1), e;
  }
  getCacheKey() {
    return this.getMaterialCacheKey() + this.getDynamicCacheKey();
  }
  dispose() {
    this.material.removeEventListener("dispose", this.onMaterialDispose), this.onDispose();
  }
}
const _u = [];
class IK {
  constructor(e, i, n, s, a, o) {
    this.renderer = e, this.nodes = i, this.geometries = n, this.pipelines = s, this.bindings = a, this.info = o, this.chainMaps = {};
  }
  get(e, i, n, s, a, o, l) {
    const u = this.getChainMap(l);
    _u[0] = e, _u[1] = i, _u[2] = o, _u[3] = a;
    let c = u.get(_u);
    return c === void 0 ? (c = this.createRenderObject(this.nodes, this.geometries, this.renderer, e, i, n, s, a, o, l), u.set(_u, c)) : (c.updateClipping(o.clippingContext), (c.version !== i.version || c.needsUpdate) && (c.initialCacheKey !== c.getCacheKey() ? (c.dispose(), c = this.get(e, i, n, s, a, o, l)) : c.version = i.version)), c;
  }
  getChainMap(e = "default") {
    return this.chainMaps[e] || (this.chainMaps[e] = new Es());
  }
  dispose() {
    this.chainMaps = {};
  }
  createRenderObject(e, i, n, s, a, o, l, u, c, h) {
    const d = this.getChainMap(h), p = new OK(e, i, n, s, a, o, l, u, c);
    return p.onDispose = () => {
      this.pipelines.delete(p), this.bindings.delete(p), this.nodes.delete(p), d.delete(p.getChainArray());
    }, p;
  }
}
class Eo {
  constructor() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
  get(e) {
    let i = this.data.get(e);
    return i === void 0 && (i = {}, this.data.set(e, i)), i;
  }
  delete(e) {
    let i;
    return this.data.has(e) && (i = this.data.get(e), this.data.delete(e)), i;
  }
  has(e) {
    return this.data.has(e);
  }
  dispose() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
}
const vs = {
  VERTEX: 1,
  INDEX: 2,
  STORAGE: 3,
  INDIRECT: 4
}, no = 16, DK = 211, kK = 212;
class LK extends Eo {
  constructor(e) {
    super(), this.backend = e;
  }
  delete(e) {
    const i = super.delete(e);
    return i !== void 0 && this.backend.destroyAttribute(e), i;
  }
  update(e, i) {
    const n = this.get(e);
    if (n.version === void 0)
      i === vs.VERTEX ? this.backend.createAttribute(e) : i === vs.INDEX ? this.backend.createIndexAttribute(e) : i === vs.STORAGE ? this.backend.createStorageAttribute(e) : i === vs.INDIRECT && this.backend.createIndirectStorageAttribute(e), n.version = this._getBufferAttribute(e).version;
    else {
      const s = this._getBufferAttribute(e);
      (n.version < s.version || s.usage === Fu) && (this.backend.updateAttribute(e), n.version = s.version);
    }
  }
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
function UK(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function z3(r) {
  return r.index !== null ? r.index.version : r.attributes.position.version;
}
function FM(r) {
  const e = [], i = r.index, n = r.attributes.position;
  if (i !== null) {
    const a = i.array;
    for (let o = 0, l = a.length; o < l; o += 3) {
      const u = a[o + 0], c = a[o + 1], h = a[o + 2];
      e.push(u, c, c, h, h, u);
    }
  } else {
    const a = n.array;
    for (let o = 0, l = a.length / 3 - 1; o < l; o += 3) {
      const u = o + 0, c = o + 1, h = o + 2;
      e.push(u, c, c, h, h, u);
    }
  }
  const s = new (UK(e) ? cP : uP)(e, 1);
  return s.version = z3(r), s;
}
class FK extends Eo {
  constructor(e, i) {
    super(), this.attributes = e, this.info = i, this.wireframes = /* @__PURE__ */ new WeakMap(), this.attributeCall = /* @__PURE__ */ new WeakMap();
  }
  has(e) {
    const i = e.geometry;
    return super.has(i) && this.get(i).initialized === !0;
  }
  updateForRender(e) {
    this.has(e) === !1 && this.initGeometry(e), this.updateAttributes(e);
  }
  initGeometry(e) {
    const i = e.geometry, n = this.get(i);
    n.initialized = !0, this.info.memory.geometries++;
    const s = () => {
      this.info.memory.geometries--;
      const a = i.index, o = e.getAttributes();
      a !== null && this.attributes.delete(a);
      for (const u of o)
        this.attributes.delete(u);
      const l = this.wireframes.get(i);
      l !== void 0 && this.attributes.delete(l), i.removeEventListener("dispose", s);
    };
    i.addEventListener("dispose", s);
  }
  updateAttributes(e) {
    const i = e.getAttributes();
    for (const a of i)
      a.isStorageBufferAttribute || a.isStorageInstancedBufferAttribute ? this.updateAttribute(a, vs.STORAGE) : this.updateAttribute(a, vs.VERTEX);
    const n = this.getIndex(e);
    n !== null && this.updateAttribute(n, vs.INDEX);
    const s = e.geometry.indirect;
    s !== null && this.updateAttribute(s, vs.INDIRECT);
  }
  updateAttribute(e, i) {
    const n = this.info.render.calls;
    e.isInterleavedBufferAttribute ? this.attributeCall.get(e) === void 0 ? (this.attributes.update(e, i), this.attributeCall.set(e, n)) : this.attributeCall.get(e.data) !== n && (this.attributes.update(e, i), this.attributeCall.set(e.data, n), this.attributeCall.set(e, n)) : this.attributeCall.get(e) !== n && (this.attributes.update(e, i), this.attributeCall.set(e, n));
  }
  getIndirect(e) {
    return e.geometry.indirect;
  }
  getIndex(e) {
    const { geometry: i, material: n } = e;
    let s = i.index;
    if (n.wireframe === !0) {
      const a = this.wireframes;
      let o = a.get(i);
      o === void 0 ? (o = FM(i), a.set(i, o)) : o.version !== z3(i) && (this.attributes.delete(o), o = FM(i), a.set(i, o)), s = o;
    }
    return s;
  }
}
class BK {
  constructor() {
    this.autoReset = !0, this.frame = 0, this.calls = 0, this.render = {
      calls: 0,
      frameCalls: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
      timestamp: 0,
      previousFrameCalls: 0,
      timestampCalls: 0
    }, this.compute = {
      calls: 0,
      frameCalls: 0,
      timestamp: 0,
      previousFrameCalls: 0,
      timestampCalls: 0
    }, this.memory = {
      geometries: 0,
      textures: 0
    };
  }
  update(e, i, n) {
    this.render.drawCalls++, e.isMesh || e.isSprite ? this.render.triangles += n * (i / 3) : e.isPoints ? this.render.points += n * i : e.isLineSegments ? this.render.lines += n * (i / 2) : e.isLine ? this.render.lines += n * (i - 1) : console.error("THREE.WebGPUInfo: Unknown object type.");
  }
  updateTimestamp(e, i) {
    this[e].timestampCalls === 0 && (this[e].timestamp = 0), this[e].timestamp += i, this[e].timestampCalls++, this[e].timestampCalls >= this[e].previousFrameCalls && (this[e].timestampCalls = 0);
  }
  reset() {
    const e = this.render.frameCalls;
    this.render.previousFrameCalls = e;
    const i = this.compute.frameCalls;
    this.compute.previousFrameCalls = i, this.render.drawCalls = 0, this.render.frameCalls = 0, this.compute.frameCalls = 0, this.render.triangles = 0, this.render.points = 0, this.render.lines = 0;
  }
  dispose() {
    this.reset(), this.calls = 0, this.render.calls = 0, this.compute.calls = 0, this.render.timestamp = 0, this.compute.timestamp = 0, this.memory.geometries = 0, this.memory.textures = 0;
  }
}
class j3 {
  constructor(e) {
    this.cacheKey = e, this.usedTimes = 0;
  }
}
class zK extends j3 {
  constructor(e, i, n) {
    super(e), this.vertexProgram = i, this.fragmentProgram = n;
  }
}
class jK extends j3 {
  constructor(e, i) {
    super(e), this.computeProgram = i, this.isComputePipeline = !0;
  }
}
let VK = 0;
class $0 {
  constructor(e, i, n = null, s = null) {
    this.id = VK++, this.code = e, this.stage = i, this.transforms = n, this.attributes = s, this.usedTimes = 0;
  }
}
class GK extends Eo {
  constructor(e, i) {
    super(), this.backend = e, this.nodes = i, this.bindings = null, this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  getForCompute(e, i) {
    const { backend: n } = this, s = this.get(e);
    if (this._needsComputeUpdate(e)) {
      const a = s.pipeline;
      a && (a.usedTimes--, a.computeProgram.usedTimes--);
      const o = this.nodes.getForCompute(e);
      let l = this.programs.compute.get(o.computeShader);
      l === void 0 && (a && a.computeProgram.usedTimes === 0 && this._releaseProgram(a.computeProgram), l = new $0(o.computeShader, "compute", o.transforms, o.nodeAttributes), this.programs.compute.set(o.computeShader, l), n.createProgram(l));
      const u = this._getComputeCacheKey(e, l);
      let c = this.caches.get(u);
      c === void 0 && (a && a.usedTimes === 0 && this._releasePipeline(a), c = this._getComputePipeline(e, l, u, i)), c.usedTimes++, l.usedTimes++, s.version = e.version, s.pipeline = c;
    }
    return s.pipeline;
  }
  getForRender(e, i = null) {
    const { backend: n } = this, s = this.get(e);
    if (this._needsRenderUpdate(e)) {
      const a = s.pipeline;
      a && (a.usedTimes--, a.vertexProgram.usedTimes--, a.fragmentProgram.usedTimes--);
      const o = e.getNodeBuilderState();
      let l = this.programs.vertex.get(o.vertexShader);
      l === void 0 && (a && a.vertexProgram.usedTimes === 0 && this._releaseProgram(a.vertexProgram), l = new $0(o.vertexShader, "vertex"), this.programs.vertex.set(o.vertexShader, l), n.createProgram(l));
      let u = this.programs.fragment.get(o.fragmentShader);
      u === void 0 && (a && a.fragmentProgram.usedTimes === 0 && this._releaseProgram(a.fragmentProgram), u = new $0(o.fragmentShader, "fragment"), this.programs.fragment.set(o.fragmentShader, u), n.createProgram(u));
      const c = this._getRenderCacheKey(e, l, u);
      let h = this.caches.get(c);
      h === void 0 ? (a && a.usedTimes === 0 && this._releasePipeline(a), h = this._getRenderPipeline(e, l, u, c, i)) : e.pipeline = h, h.usedTimes++, l.usedTimes++, u.usedTimes++, s.pipeline = h;
    }
    return s.pipeline;
  }
  delete(e) {
    const i = this.get(e).pipeline;
    return i && (i.usedTimes--, i.usedTimes === 0 && this._releasePipeline(i), i.isComputePipeline ? (i.computeProgram.usedTimes--, i.computeProgram.usedTimes === 0 && this._releaseProgram(i.computeProgram)) : (i.fragmentProgram.usedTimes--, i.vertexProgram.usedTimes--, i.vertexProgram.usedTimes === 0 && this._releaseProgram(i.vertexProgram), i.fragmentProgram.usedTimes === 0 && this._releaseProgram(i.fragmentProgram))), super.delete(e);
  }
  dispose() {
    super.dispose(), this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  updateForRender(e) {
    this.getForRender(e);
  }
  _getComputePipeline(e, i, n, s) {
    n = n || this._getComputeCacheKey(e, i);
    let a = this.caches.get(n);
    return a === void 0 && (a = new jK(n, i), this.caches.set(n, a), this.backend.createComputePipeline(a, s)), a;
  }
  _getRenderPipeline(e, i, n, s, a) {
    s = s || this._getRenderCacheKey(e, i, n);
    let o = this.caches.get(s);
    return o === void 0 && (o = new zK(s, i, n), this.caches.set(s, o), e.pipeline = o, this.backend.createRenderPipeline(e, a)), o;
  }
  _getComputeCacheKey(e, i) {
    return e.id + "," + i.id;
  }
  _getRenderCacheKey(e, i, n) {
    return i.id + "," + n.id + "," + this.backend.getRenderCacheKey(e);
  }
  _releasePipeline(e) {
    this.caches.delete(e.cacheKey);
  }
  _releaseProgram(e) {
    const i = e.code, n = e.stage;
    this.programs[n].delete(i);
  }
  _needsComputeUpdate(e) {
    const i = this.get(e);
    return i.pipeline === void 0 || i.version !== e.version;
  }
  _needsRenderUpdate(e) {
    return this.get(e).pipeline === void 0 || this.backend.needsRenderUpdate(e);
  }
}
class HK extends Eo {
  constructor(e, i, n, s, a, o) {
    super(), this.backend = e, this.textures = n, this.pipelines = a, this.attributes = s, this.nodes = i, this.info = o, this.pipelines.bindings = this;
  }
  getForRender(e) {
    const i = e.getBindings();
    for (const n of i) {
      const s = this.get(n);
      s.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, i), s.bindGroup = n);
    }
    return i;
  }
  getForCompute(e) {
    const i = this.nodes.getForCompute(e).bindings;
    for (const n of i) {
      const s = this.get(n);
      s.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, i), s.bindGroup = n);
    }
    return i;
  }
  updateForCompute(e) {
    this._updateBindings(this.getForCompute(e));
  }
  updateForRender(e) {
    this._updateBindings(this.getForRender(e));
  }
  _updateBindings(e) {
    for (const i of e)
      this._update(i, e);
  }
  _init(e) {
    for (const i of e.bindings)
      if (i.isSampledTexture)
        this.textures.updateTexture(i.texture);
      else if (i.isStorageBuffer) {
        const n = i.attribute, s = n.isIndirectStorageBufferAttribute ? vs.INDIRECT : vs.STORAGE;
        this.attributes.update(n, s);
      }
  }
  _update(e, i) {
    const { backend: n } = this;
    let s = !1;
    for (const a of e.bindings)
      if (!(a.isNodeUniformsGroup && !this.nodes.updateGroup(a))) {
        if (a.isUniformBuffer)
          a.update() && n.updateBinding(a);
        else if (a.isSampler)
          a.update();
        else if (a.isSampledTexture) {
          a.needsBindingsUpdate(this.textures.get(a.texture).generation) && (s = !0);
          const o = a.update(), l = a.texture;
          o && this.textures.updateTexture(l);
          const u = n.get(l);
          if (n.isWebGPUBackend === !0 && u.texture === void 0 && u.externalTexture === void 0 && (console.error("Bindings._update: binding should be available:", a, o, l, a.textureNode.value, s), this.textures.updateTexture(l), s = !0), l.isStorageTexture === !0) {
            const c = this.get(l);
            a.store === !0 ? c.needsMipmap = !0 : this.textures.needsMipmaps(l) && c.needsMipmap === !0 && (this.backend.generateMipmaps(l), c.needsMipmap = !1);
          }
        }
      }
    s === !0 && this.backend.updateBindings(e, i);
  }
}
function WK(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
}
function BM(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
}
function zM(r) {
  return (r.transmission > 0 || r.transmissionNode) && r.side === $u && r.forceSinglePass === !1;
}
class qK {
  constructor(e, i, n) {
    this.renderItems = [], this.renderItemsIndex = 0, this.opaque = [], this.transparentDoublePass = [], this.transparent = [], this.bundles = [], this.lightsNode = e.getNode(i, n), this.lightsArray = [], this.scene = i, this.camera = n, this.occlusionQueryCount = 0;
  }
  begin() {
    return this.renderItemsIndex = 0, this.opaque.length = 0, this.transparentDoublePass.length = 0, this.transparent.length = 0, this.bundles.length = 0, this.lightsArray.length = 0, this.occlusionQueryCount = 0, this;
  }
  getNextRenderItem(e, i, n, s, a, o) {
    let l = this.renderItems[this.renderItemsIndex];
    return l === void 0 ? (l = {
      id: e.id,
      object: e,
      geometry: i,
      material: n,
      groupOrder: s,
      renderOrder: e.renderOrder,
      z: a,
      group: o
    }, this.renderItems[this.renderItemsIndex] = l) : (l.id = e.id, l.object = e, l.geometry = i, l.material = n, l.groupOrder = s, l.renderOrder = e.renderOrder, l.z = a, l.group = o), this.renderItemsIndex++, l;
  }
  push(e, i, n, s, a, o) {
    const l = this.getNextRenderItem(e, i, n, s, a, o);
    e.occlusionTest === !0 && this.occlusionQueryCount++, n.transparent === !0 || n.transmission > 0 ? (zM(n) && this.transparentDoublePass.push(l), this.transparent.push(l)) : this.opaque.push(l);
  }
  unshift(e, i, n, s, a, o) {
    const l = this.getNextRenderItem(e, i, n, s, a, o);
    n.transparent === !0 || n.transmission > 0 ? (zM(n) && this.transparentDoublePass.unshift(l), this.transparent.unshift(l)) : this.opaque.unshift(l);
  }
  pushBundle(e) {
    this.bundles.push(e);
  }
  pushLight(e) {
    this.lightsArray.push(e);
  }
  sort(e, i) {
    this.opaque.length > 1 && this.opaque.sort(e || WK), this.transparentDoublePass.length > 1 && this.transparentDoublePass.sort(i || BM), this.transparent.length > 1 && this.transparent.sort(i || BM);
  }
  finish() {
    this.lightsNode.setLights(this.lightsArray);
    for (let e = this.renderItemsIndex, i = this.renderItems.length; e < i; e++) {
      const n = this.renderItems[e];
      if (n.id === null) break;
      n.id = null, n.object = null, n.geometry = null, n.material = null, n.groupOrder = null, n.renderOrder = null, n.z = null, n.group = null;
    }
  }
}
class XK {
  constructor(e) {
    this.lighting = e, this.lists = new Es();
  }
  get(e, i) {
    const n = this.lists, s = [e, i];
    let a = n.get(s);
    return a === void 0 && (a = new qK(this.lighting, e, i), n.set(s, a)), a;
  }
  dispose() {
    this.lists = new Es();
  }
}
let YK = 0;
class $K {
  constructor() {
    this.id = YK++, this.color = !0, this.clearColor = !0, this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 }, this.depth = !0, this.clearDepth = !0, this.clearDepthValue = 1, this.stencil = !1, this.clearStencil = !0, this.clearStencilValue = 1, this.viewport = !1, this.viewportValue = new $t(), this.scissor = !1, this.scissorValue = new $t(), this.textures = null, this.depthTexture = null, this.activeCubeFace = 0, this.sampleCount = 1, this.width = 0, this.height = 0, this.isRenderContext = !0;
  }
  getCacheKey() {
    return V3(this);
  }
}
function V3(r) {
  const { textures: e, activeCubeFace: i } = r, n = [i];
  for (const s of e)
    n.push(s.id);
  return RP(n);
}
class KK {
  constructor() {
    this.chainMaps = {};
  }
  get(e, i, n = null) {
    const s = [e, i];
    let a;
    if (n === null)
      a = "default";
    else {
      const u = n.texture.format;
      a = `${n.textures.length}:${u}:${n.samples}:${n.depthBuffer}:${n.stencilBuffer}`;
    }
    const o = this.getChainMap(a);
    let l = o.get(s);
    return l === void 0 && (l = new $K(), o.set(s, l)), n !== null && (l.sampleCount = n.samples === 0 ? 1 : n.samples), l;
  }
  getChainMap(e) {
    return this.chainMaps[e] || (this.chainMaps[e] = new Es());
  }
  dispose() {
    this.chainMaps = {};
  }
}
const QK = /* @__PURE__ */ new oe();
class ZK extends Eo {
  constructor(e, i, n) {
    super(), this.renderer = e, this.backend = i, this.info = n;
  }
  updateRenderTarget(e, i = 0) {
    const n = this.get(e), s = e.samples === 0 ? 1 : e.samples, a = n.depthTextureMips || (n.depthTextureMips = {}), o = e.textures, l = this.getSize(o[0]), u = l.width >> i, c = l.height >> i;
    let h = e.depthTexture || a[i];
    const d = e.depthBuffer === !0 || e.stencilBuffer === !0;
    let p = !1;
    h === void 0 && d && (h = new jc(), h.format = e.stencilBuffer ? Sc : vl, h.type = e.stencilBuffer ? $d : Ji, h.image.width = u, h.image.height = c, a[i] = h), (n.width !== l.width || l.height !== n.height) && (p = !0, h && (h.needsUpdate = !0, h.image.width = u, h.image.height = c)), n.width = l.width, n.height = l.height, n.textures = o, n.depthTexture = h || null, n.depth = e.depthBuffer, n.stencil = e.stencilBuffer, n.renderTarget = e, n.sampleCount !== s && (p = !0, h && (h.needsUpdate = !0), n.sampleCount = s);
    const f = { sampleCount: s };
    for (let m = 0; m < o.length; m++) {
      const v = o[m];
      p && (v.needsUpdate = !0), this.updateTexture(v, f);
    }
    if (h && this.updateTexture(h, f), n.initialized !== !0) {
      n.initialized = !0;
      const m = () => {
        e.removeEventListener("dispose", m);
        for (let v = 0; v < o.length; v++)
          this._destroyTexture(o[v]);
        h && this._destroyTexture(h), this.delete(e);
      };
      e.addEventListener("dispose", m);
    }
  }
  updateTexture(e, i = {}) {
    const n = this.get(e);
    if (n.initialized === !0 && n.version === e.version) return;
    const s = e.isRenderTargetTexture || e.isDepthTexture || e.isFramebufferTexture, a = this.backend;
    if (s && n.initialized === !0 && (a.destroySampler(e), a.destroyTexture(e)), e.isFramebufferTexture) {
      const c = this.renderer.getRenderTarget();
      c ? e.type = c.texture.type : e.type = fo;
    }
    const { width: o, height: l, depth: u } = this.getSize(e);
    if (i.width = o, i.height = l, i.depth = u, i.needsMipmaps = this.needsMipmaps(e), i.levels = i.needsMipmaps ? this.getMipLevels(e, o, l) : 1, s || e.isStorageTexture === !0)
      a.createSampler(e), a.createTexture(e, i), n.generation = e.version;
    else if (n.initialized !== !0 && a.createSampler(e), e.version > 0) {
      const c = e.image;
      if (c === void 0)
        console.warn("THREE.Renderer: Texture marked for update but image is undefined.");
      else if (c.complete === !1)
        console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");
      else {
        if (e.images) {
          const h = [];
          for (const d of e.images)
            h.push(d);
          i.images = h;
        } else
          i.image = c;
        (n.isDefaultTexture === void 0 || n.isDefaultTexture === !0) && (a.createTexture(e, i), n.isDefaultTexture = !1, n.generation = e.version), e.source.dataReady === !0 && a.updateTexture(e, i), i.needsMipmaps && e.mipmaps.length === 0 && a.generateMipmaps(e);
      }
    } else
      a.createDefaultTexture(e), n.isDefaultTexture = !0, n.generation = e.version;
    if (n.initialized !== !0) {
      n.initialized = !0, n.generation = e.version, this.info.memory.textures++;
      const c = () => {
        e.removeEventListener("dispose", c), this._destroyTexture(e), this.info.memory.textures--;
      };
      e.addEventListener("dispose", c);
    }
    n.version = e.version;
  }
  getSize(e, i = QK) {
    let n = e.images ? e.images[0] : e.image;
    return n ? (n.image !== void 0 && (n = n.image), i.width = n.width, i.height = n.height, i.depth = e.isCubeTexture ? 6 : n.depth || 1) : i.width = i.height = i.depth = 1, i;
  }
  getMipLevels(e, i, n) {
    let s;
    return e.isCompressedTexture ? s = e.mipmaps.length : s = Math.floor(Math.log2(Math.max(i, n))) + 1, s;
  }
  needsMipmaps(e) {
    return this.isEnvironmentTexture(e) || e.isCompressedTexture === !0 || e.generateMipmaps;
  }
  isEnvironmentTexture(e) {
    const i = e.mapping;
    return i === Xd || i === Yd || i === wl || i === Tc;
  }
  _destroyTexture(e) {
    this.backend.destroySampler(e), this.backend.destroyTexture(e), this.delete(e);
  }
}
class BT extends Kt {
  constructor(e, i, n, s = 1) {
    super(e, i, n), this.a = s;
  }
  set(e, i, n, s = 1) {
    return this.a = s, super.set(e, i, n);
  }
  copy(e) {
    return e.a !== void 0 && (this.a = e.a), super.copy(e);
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
}
class JK extends Qt {
  static get type() {
    return "ParameterNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isParameterNode = !0;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
class eQ extends At {
  static get type() {
    return "StackNode";
  }
  constructor(e = null) {
    super(), this.nodes = [], this.outputNode = null, this.parent = e, this._currentCond = null, this.isStackNode = !0;
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : "void";
  }
  add(e) {
    return this.nodes.push(e), this;
  }
  If(e, i) {
    const n = new nm(i);
    return this._currentCond = Br(e, n), this.add(this._currentCond);
  }
  ElseIf(e, i) {
    const n = new nm(i), s = Br(e, n);
    return this._currentCond.elseNode = s, this._currentCond = s, this;
  }
  Else(e) {
    return this._currentCond.elseNode = new nm(e), this;
  }
  build(e, ...i) {
    const n = LP();
    jm(this);
    for (const s of this.nodes)
      s.build(e, "void");
    return jm(n), this.outputNode ? this.outputNode.build(e, ...i) : super.build(e, ...i);
  }
  //
  else(...e) {
    return console.warn("TSL.StackNode: .else() has been renamed to .Else()."), this.Else(...e);
  }
  elseif(...e) {
    return console.warn("TSL.StackNode: .elseif() has been renamed to .ElseIf()."), this.ElseIf(...e);
  }
}
const K0 = /* @__PURE__ */ Me(eQ);
new Ja();
new oe();
new oe();
new oe();
new gi();
new oe(0, 0, -1);
new $t();
new oe();
new oe();
new $t();
new jt();
const tQ = new zc();
Ad.flipX();
tQ.depthTexture = new jc(1, 1);
const Q0 = /* @__PURE__ */ new vT(-1, 1, 1, -1, 0, 1);
class iQ extends Dl {
  constructor(e = !1) {
    super();
    const i = e === !1 ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new ba([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new ba(i, 2));
  }
}
const rQ = /* @__PURE__ */ new iQ();
class G3 extends Al {
  constructor(e = null) {
    super(rQ, e), this.camera = Q0, this.isQuadMesh = !0;
  }
  renderAsync(e) {
    return e.renderAsync(this, Q0);
  }
  render(e) {
    e.render(this, Q0);
  }
}
const Eh = /* @__PURE__ */ new ts(), Z0 = /* @__PURE__ */ new gi();
class jr extends At {
  static get type() {
    return "SceneNode";
  }
  constructor(e = jr.BACKGROUND_BLURRINESS, i = null) {
    super(), this.scope = e, this.scene = i;
  }
  setup(e) {
    const i = this.scope, n = this.scene !== null ? this.scene : e.scene;
    let s;
    return i === jr.BACKGROUND_BLURRINESS ? s = bi("backgroundBlurriness", "float", n) : i === jr.BACKGROUND_INTENSITY ? s = bi("backgroundIntensity", "float", n) : i === jr.BACKGROUND_ROTATION ? s = Tt("mat4").label("backgroundRotation").setGroup(Ut).onRenderUpdate(() => {
      const a = n.background;
      return a !== null && a.isTexture && a.mapping !== rT ? (Eh.copy(n.backgroundRotation), Eh.x *= -1, Eh.y *= -1, Eh.z *= -1, Z0.makeRotationFromEuler(Eh)) : Z0.identity(), Z0;
    }) : console.error("THREE.SceneNode: Unknown scope:", i), s;
  }
}
jr.BACKGROUND_BLURRINESS = "backgroundBlurriness";
jr.BACKGROUND_INTENSITY = "backgroundIntensity";
jr.BACKGROUND_ROTATION = "backgroundRotation";
const nQ = /* @__PURE__ */ He(jr, jr.BACKGROUND_BLURRINESS), jM = /* @__PURE__ */ He(jr, jr.BACKGROUND_INTENSITY), sQ = /* @__PURE__ */ He(jr, jr.BACKGROUND_ROTATION), ju = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
}, Qi = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
}, Zi = {
  Store: "store"
}, Ii = {
  Load: "load",
  Clear: "clear"
}, J0 = {
  CCW: "ccw"
}, ev = {
  None: "none",
  Front: "front",
  Back: "back"
}, Ac = {
  Uint16: "uint16",
  Uint32: "uint32"
}, $ = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
}, tv = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
}, Jo = {
  Linear: "linear",
  Nearest: "nearest"
}, bt = {
  Zero: "zero",
  One: "one",
  Src: "src",
  OneMinusSrc: "one-minus-src",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  Dst: "dst",
  OneMinusDstColor: "one-minus-dst",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  Constant: "constant",
  OneMinusConstant: "one-minus-constant"
}, jo = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
}, VM = {
  None: 0,
  All: 15
}, qa = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
}, Ox = {
  Storage: "storage",
  ReadOnlyStorage: "read-only-storage"
}, GM = {
  WriteOnly: "write-only",
  ReadOnly: "read-only"
}, Mh = {
  Float: "float",
  UnfilterableFloat: "unfilterable-float",
  Depth: "depth",
  SInt: "sint",
  UInt: "uint"
}, HM = {
  TwoD: "2d",
  ThreeD: "3d"
}, xn = {
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  ThreeD: "3d"
}, aQ = {
  All: "all"
}, yf = {
  Vertex: "vertex",
  Instance: "instance"
}, Ix = {
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable",
  ClipDistances: "clip-distances",
  DualSourceBlending: "dual-source-blending",
  Subgroups: "subgroups"
}, oQ = /* @__PURE__ */ new jt();
class lQ extends ip {
  static get type() {
    return "PassTextureNode";
  }
  constructor(e, i) {
    super(i), this.passNode = e, this.setUpdateMatrix(!1);
  }
  setup(e) {
    return e.object.isQuadMesh && this.passNode.build(e), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
}
class WM extends lQ {
  static get type() {
    return "PassMultipleTextureNode";
  }
  constructor(e, i, n = !1) {
    super(e, null), this.textureName = i, this.previousTexture = n;
  }
  updateTexture() {
    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
  }
  setup(e) {
    return this.updateTexture(), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.textureName, this.previousTexture);
  }
}
class zg extends zi {
  static get type() {
    return "PassNode";
  }
  constructor(e, i, n, s = {}) {
    super("vec4"), this.scope = e, this.scene = i, this.camera = n, this.options = s, this._pixelRatio = 1, this._width = 1, this._height = 1;
    const a = new jc();
    a.isRenderTargetTexture = !0, a.name = "depth";
    const o = new zc(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: ga, ...s });
    o.texture.name = "output", o.depthTexture = a, this.renderTarget = o, this.updateBeforeType = Pt.FRAME, this._textures = {
      output: o.texture,
      depth: a
    }, this._textureNodes = {}, this._linearDepthNodes = {}, this._viewZNodes = {}, this._previousTextures = {}, this._previousTextureNodes = {}, this._cameraNear = Tt(0), this._cameraFar = Tt(0), this._mrt = null, this.isPassNode = !0;
  }
  setMRT(e) {
    return this._mrt = e, this;
  }
  getMRT() {
    return this._mrt;
  }
  isGlobal() {
    return !0;
  }
  getTexture(e) {
    let i = this._textures[e];
    return i === void 0 && (i = this.renderTarget.texture.clone(), i.isRenderTargetTexture = !0, i.name = e, this._textures[e] = i, this.renderTarget.textures.push(i)), i;
  }
  getPreviousTexture(e) {
    let i = this._previousTextures[e];
    return i === void 0 && (i = this.getTexture(e).clone(), i.isRenderTargetTexture = !0, this._previousTextures[e] = i), i;
  }
  toggleTexture(e) {
    const i = this._previousTextures[e];
    if (i !== void 0) {
      const n = this._textures[e], s = this.renderTarget.textures.indexOf(n);
      this.renderTarget.textures[s] = i, this._textures[e] = i, this._previousTextures[e] = n, this._textureNodes[e].updateTexture(), this._previousTextureNodes[e].updateTexture();
    }
  }
  getTextureNode(e = "output") {
    let i = this._textureNodes[e];
    return i === void 0 && (i = De(new WM(this, e)), i.updateTexture(), this._textureNodes[e] = i), i;
  }
  getPreviousTextureNode(e = "output") {
    let i = this._previousTextureNodes[e];
    return i === void 0 && (this._textureNodes[e] === void 0 && this.getTextureNode(e), i = De(new WM(this, e, !0)), i.updateTexture(), this._previousTextureNodes[e] = i), i;
  }
  getViewZNode(e = "depth") {
    let i = this._viewZNodes[e];
    if (i === void 0) {
      const n = this._cameraNear, s = this._cameraFar;
      this._viewZNodes[e] = i = T3(this.getTextureNode(e), n, s);
    }
    return i;
  }
  getLinearDepthNode(e = "depth") {
    let i = this._linearDepthNodes[e];
    if (i === void 0) {
      const n = this._cameraNear, s = this._cameraFar, a = this.getViewZNode(e);
      this._linearDepthNodes[e] = i = nd(a, n, s);
    }
    return i;
  }
  setup({ renderer: e }) {
    return this.renderTarget.samples = this.options.samples === void 0 ? e.samples : this.options.samples, e.backend.isWebGLBackend === !0 && (this.renderTarget.samples = 0), this.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1, this.scope === zg.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
  }
  updateBefore(e) {
    const { renderer: i } = e, { scene: n, camera: s } = this;
    this._pixelRatio = i.getPixelRatio();
    const a = i.getSize(oQ);
    this.setSize(a.width, a.height);
    const o = i.getRenderTarget(), l = i.getMRT();
    this._cameraNear.value = s.near, this._cameraFar.value = s.far;
    for (const u in this._previousTextures)
      this.toggleTexture(u);
    i.setRenderTarget(this.renderTarget), i.setMRT(this._mrt), i.render(n, s), i.setRenderTarget(o), i.setMRT(l);
  }
  setSize(e, i) {
    this._width = e, this._height = i;
    const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget.setSize(n, s);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget.dispose();
  }
}
zg.COLOR = "color";
zg.DEPTH = "depth";
const uQ = /* @__PURE__ */ Be(([r, e]) => r.mul(e).clamp()).setLayout({
  name: "linearToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), cQ = /* @__PURE__ */ Be(([r, e]) => (r = r.mul(e), r.div(r.add(1)).clamp())).setLayout({
  name: "reinhardToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), hQ = /* @__PURE__ */ Be(([r, e]) => {
  r = r.mul(e), r = r.sub(4e-3).max(0);
  const i = r.mul(r.mul(6.2).add(0.5)), n = r.mul(r.mul(6.2).add(1.7)).add(0.06);
  return i.div(n).pow(2.2);
}).setLayout({
  name: "cineonToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), dQ = /* @__PURE__ */ Be(([r]) => {
  const e = r.mul(r.add(0.0245786)).sub(90537e-9), i = r.mul(r.add(0.432951).mul(0.983729)).add(0.238081);
  return e.div(i);
}), pQ = /* @__PURE__ */ Be(([r, e]) => {
  const i = Rr(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  ), n = Rr(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  return r = r.mul(e).div(0.6), r = i.mul(r), r = dQ(r), r = n.mul(r), r.clamp();
}).setLayout({
  name: "acesFilmicToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), fQ = /* @__PURE__ */ Rr(ye(1.6605, -0.1246, -0.0182), ye(-0.5876, 1.1329, -0.1006), ye(-0.0728, -83e-4, 1.1187)), mQ = /* @__PURE__ */ Rr(ye(0.6274, 0.0691, 0.0164), ye(0.3293, 0.9195, 0.088), ye(0.0433, 0.0113, 0.8956)), gQ = /* @__PURE__ */ Be(([r]) => {
  const e = ye(r).toVar(), i = ye(e.mul(e)).toVar(), n = ye(i.mul(i)).toVar();
  return ve(15.5).mul(n.mul(i)).sub(It(40.14, n.mul(e))).add(It(31.96, n).sub(It(6.868, i.mul(e))).add(It(0.4298, i).add(It(0.1191, e).sub(232e-5))));
}), yQ = /* @__PURE__ */ Be(([r, e]) => {
  const i = ye(r).toVar(), n = Rr(ye(0.856627153315983, 0.137318972929847, 0.11189821299995), ye(0.0951212405381588, 0.761241990602591, 0.0767994186031903), ye(0.0482516061458583, 0.101439036467562, 0.811302368396859)), s = Rr(ye(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), ye(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), ye(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405)), a = ve(-12.47393), o = ve(4.026069);
  return i.mulAssign(e), i.assign(mQ.mul(i)), i.assign(n.mul(i)), i.assign(An(i, 1e-10)), i.assign(xa(i)), i.assign(i.sub(a).div(o.sub(a))), i.assign(Sa(i, 0, 1)), i.assign(gQ(i)), i.assign(s.mul(i)), i.assign(Ig(An(ye(0), i), ye(2.2))), i.assign(fQ.mul(i)), i.assign(Sa(i, 0, 1)), i;
}).setLayout({
  name: "agxToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), vQ = /* @__PURE__ */ Be(([r, e]) => {
  const i = ve(0.76), n = ve(0.15);
  r = r.mul(e);
  const s = Sd(r.r, Sd(r.g, r.b)), a = Br(s.lessThan(0.08), s.sub(It(6.25, s.mul(s))), 0.04);
  r.subAssign(a);
  const o = An(r.r, An(r.g, r.b));
  rr(o.lessThan(i), () => r);
  const l = un(1, i), u = un(1, l.mul(l).div(o.add(l.sub(i))));
  r.mulAssign(u.div(o));
  const c = un(1, _o(1, n.mul(o.sub(u)).add(1)));
  return li(r, ye(u), c);
}).setLayout({
  name: "neutralToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
class pr extends At {
  static get type() {
    return "CodeNode";
  }
  constructor(e = "", i = [], n = "") {
    super("code"), this.isCodeNode = !0, this.code = e, this.language = n, this.includes = i;
  }
  isGlobal() {
    return !0;
  }
  setIncludes(e) {
    return this.includes = e, this;
  }
  getIncludes() {
    return this.includes;
  }
  generate(e) {
    const i = this.getIncludes(e);
    for (const s of i)
      s.build(e);
    const n = e.getCodeFromNode(this, this.getNodeType(e));
    return n.code = this.code, n.code;
  }
  serialize(e) {
    super.serialize(e), e.code = this.code, e.language = this.language;
  }
  deserialize(e) {
    super.deserialize(e), this.code = e.code, this.language = e.language;
  }
}
class bQ extends pr {
  static get type() {
    return "FunctionNode";
  }
  constructor(e = "", i = [], n = "") {
    super(e, i, n);
  }
  getNodeType(e) {
    return this.getNodeFunction(e).type;
  }
  getInputs(e) {
    return this.getNodeFunction(e).inputs;
  }
  getNodeFunction(e) {
    const i = e.getDataFromNode(this);
    let n = i.nodeFunction;
    return n === void 0 && (n = e.parser.parseFunction(this.code), i.nodeFunction = n), n;
  }
  generate(e, i) {
    super.generate(e);
    const n = this.getNodeFunction(e), s = n.name, a = n.type, o = e.getCodeFromNode(this, a);
    s !== "" && (o.name = s);
    const l = e.getPropertyName(o), u = this.getNodeFunction(e).getCode(l);
    return o.code = u + `
`, i === "property" ? l : e.format(`${l}()`, a, i);
  }
}
class H3 extends At {
  static get type() {
    return "FogNode";
  }
  constructor(e, i) {
    super("float"), this.isFogNode = !0, this.colorNode = e, this.factorNode = i;
  }
  getViewZNode(e) {
    let i;
    const n = e.context.getViewZ;
    return n !== void 0 && (i = n(this)), (i || ir.z).negate();
  }
  setup() {
    return this.factorNode;
  }
}
class xQ extends H3 {
  static get type() {
    return "FogRangeNode";
  }
  constructor(e, i, n) {
    super(e), this.isFogRangeNode = !0, this.nearNode = i, this.farNode = n;
  }
  setup(e) {
    const i = this.getViewZNode(e);
    return Cl(this.nearNode, this.farNode, i);
  }
}
const _Q = /* @__PURE__ */ Me(xQ);
class TQ extends H3 {
  static get type() {
    return "FogExp2Node";
  }
  constructor(e, i) {
    super(e), this.isFogExp2Node = !0, this.densityNode = i;
  }
  setup(e) {
    const i = this.getViewZNode(e), n = this.densityNode;
    return n.mul(n, i, i).negate().exp().oneMinus();
  }
}
const SQ = /* @__PURE__ */ Me(TQ);
class wQ extends At {
  constructor(e) {
    super(), this.scope = e;
  }
  generate(e) {
    const { scope: i } = this, { renderer: n } = e;
    n.backend.isWebGLBackend === !0 ? e.addFlowCode(`	// ${i}Barrier 
`) : e.addLineFlowCode(`${i}Barrier()`, this);
  }
}
Me(wQ);
class As extends zi {
  static get type() {
    return "AtomicFunctionNode";
  }
  constructor(e, i, n, s = null) {
    super("uint"), this.method = e, this.pointerNode = i, this.valueNode = n, this.storeNode = s;
  }
  getInputType(e) {
    return this.pointerNode.getNodeType(e);
  }
  getNodeType(e) {
    return this.getInputType(e);
  }
  generate(e) {
    const i = this.method, n = this.getNodeType(e), s = this.getInputType(e), a = this.pointerNode, o = this.valueNode, l = [];
    l.push(`&${a.build(e, s)}`), l.push(o.build(e, s));
    const u = `${e.getMethod(i, n)}( ${l.join(", ")} )`;
    if (this.storeNode !== null) {
      const c = this.storeNode.build(e, s);
      e.addLineFlowCode(`${c} = ${u}`, this);
    } else
      e.addLineFlowCode(u, this);
  }
}
As.ATOMIC_LOAD = "atomicLoad";
As.ATOMIC_STORE = "atomicStore";
As.ATOMIC_ADD = "atomicAdd";
As.ATOMIC_SUB = "atomicSub";
As.ATOMIC_MAX = "atomicMax";
As.ATOMIC_MIN = "atomicMin";
As.ATOMIC_AND = "atomicAnd";
As.ATOMIC_OR = "atomicOr";
As.ATOMIC_XOR = "atomicXor";
Me(As);
let vf;
function zT(r) {
  vf = vf || /* @__PURE__ */ new WeakMap();
  let e = vf.get(r);
  return e === void 0 && vf.set(r, e = {}), e;
}
function W3(r) {
  const e = zT(r);
  return e.position || (e.position = Tt(new oe()).setGroup(Ut).onRenderUpdate((i, n) => n.value.setFromMatrixPosition(r.matrixWorld)));
}
function EQ(r) {
  const e = zT(r);
  return e.targetPosition || (e.targetPosition = Tt(new oe()).setGroup(Ut).onRenderUpdate((i, n) => n.value.setFromMatrixPosition(r.target.matrixWorld)));
}
function jT(r) {
  const e = zT(r);
  return e.viewPosition || (e.viewPosition = Tt(new oe()).setGroup(Ut).onRenderUpdate(({ camera: i }, n) => {
    n.value = n.value || new oe(), n.value.setFromMatrixPosition(r.matrixWorld), n.value.applyMatrix4(i.matrixWorldInverse);
  }));
}
const q3 = (r) => Ra.transformDirection(W3(r).sub(EQ(r))), MQ = (r) => r.sort((e, i) => e.id - i.id), AQ = (r, e) => {
  for (const i of e)
    if (i.isAnalyticLightNode && i.light.id === r)
      return i;
  return null;
}, iv = /* @__PURE__ */ new WeakMap();
class X3 extends At {
  static get type() {
    return "LightsNode";
  }
  constructor() {
    super("vec3"), this.totalDiffuseNode = ye().toVar("totalDiffuse"), this.totalSpecularNode = ye().toVar("totalSpecular"), this.outgoingLightNode = ye().toVar("outgoingLight"), this._lights = [], this._lightNodes = null, this._lightNodesHash = null, this.global = !0;
  }
  getHash(e) {
    if (this._lightNodesHash === null) {
      this._lightNodes === null && this.setupLightsNode(e);
      const i = [];
      for (const n of this._lightNodes)
        i.push(n.getSelf().getHash());
      this._lightNodesHash = "lights-" + i.join(",");
    }
    return this._lightNodesHash;
  }
  analyze(e) {
    const i = e.getDataFromNode(this);
    for (const n of i.nodes)
      n.build(e);
  }
  setupLightsNode(e) {
    const i = [], n = this._lightNodes, s = MQ(this._lights), a = e.renderer.library;
    for (const o of s)
      if (o.isNode)
        i.push(De(o));
      else {
        let l = null;
        if (n !== null && (l = AQ(o.id, n)), l === null) {
          const u = a.getLightNodeClass(o.constructor);
          if (u === null) {
            console.warn(`LightsNode.setupNodeLights: Light node not found for ${o.constructor.name}`);
            continue;
          }
          let c = null;
          iv.has(o) ? c = iv.get(o) : (c = De(new u(o)), iv.set(o, c)), i.push(c);
        }
      }
    this._lightNodes = i;
  }
  setupLights(e, i) {
    for (const n of i)
      n.build(e);
  }
  setup(e) {
    this._lightNodes === null && this.setupLightsNode(e);
    const i = e.context, n = i.lightingModel;
    let s = this.outgoingLightNode;
    if (n) {
      const { _lightNodes: a, totalDiffuseNode: o, totalSpecularNode: l } = this;
      i.outgoingLight = s;
      const u = e.addStack(), c = e.getDataFromNode(this);
      c.nodes = u.nodes, n.start(i, u, e), this.setupLights(e, a), n.indirect(i, u, e);
      const { backdrop: h, backdropAlpha: d } = i, { directDiffuse: p, directSpecular: f, indirectDiffuse: m, indirectSpecular: v } = i.reflectedLight;
      let y = p.add(m);
      h !== null && (d !== null ? y = ye(d.mix(y, h)) : y = ye(h), i.material.transparent = !0), o.assign(y), l.assign(f.add(v)), s.assign(o.add(l)), n.finish(i, u, e), s = s.bypass(e.removeStack());
    }
    return s;
  }
  setLights(e) {
    return this._lights = e, this._lightNodes = null, this._lightNodesHash = null, this;
  }
  getLights() {
    return this._lights;
  }
  get hasLights() {
    return this._lights.length > 0;
  }
}
const CQ = Be(({ depthTexture: r, shadowCoord: e }) => Ci(r, e.xy).compare(e.z)), RQ = Be(({ depthTexture: r, shadowCoord: e, shadow: i }) => {
  const n = (v, y) => Ci(r, v).compare(y), s = bi("mapSize", "vec2", i).setGroup(Ut), a = bi("radius", "float", i).setGroup(Ut), o = qe(1).div(s), l = o.x.negate().mul(a), u = o.y.negate().mul(a), c = o.x.mul(a), h = o.y.mul(a), d = l.div(2), p = u.div(2), f = c.div(2), m = h.div(2);
  return Nr(
    n(e.xy.add(qe(l, u)), e.z),
    n(e.xy.add(qe(0, u)), e.z),
    n(e.xy.add(qe(c, u)), e.z),
    n(e.xy.add(qe(d, p)), e.z),
    n(e.xy.add(qe(0, p)), e.z),
    n(e.xy.add(qe(f, p)), e.z),
    n(e.xy.add(qe(l, 0)), e.z),
    n(e.xy.add(qe(d, 0)), e.z),
    n(e.xy, e.z),
    n(e.xy.add(qe(f, 0)), e.z),
    n(e.xy.add(qe(c, 0)), e.z),
    n(e.xy.add(qe(d, m)), e.z),
    n(e.xy.add(qe(0, m)), e.z),
    n(e.xy.add(qe(f, m)), e.z),
    n(e.xy.add(qe(l, h)), e.z),
    n(e.xy.add(qe(0, h)), e.z),
    n(e.xy.add(qe(c, h)), e.z)
  ).mul(1 / 17);
}), NQ = Be(({ depthTexture: r, shadowCoord: e, shadow: i }) => {
  const n = (h, d) => Ci(r, h).compare(d), s = bi("mapSize", "vec2", i).setGroup(Ut), a = qe(1).div(s), o = a.x, l = a.y, u = e.xy, c = wo(u.mul(s).add(0.5));
  return u.subAssign(c.mul(a)), Nr(
    n(u, e.z),
    n(u.add(qe(o, 0)), e.z),
    n(u.add(qe(0, l)), e.z),
    n(u.add(a), e.z),
    li(
      n(u.add(qe(o.negate(), 0)), e.z),
      n(u.add(qe(o.mul(2), 0)), e.z),
      c.x
    ),
    li(
      n(u.add(qe(o.negate(), l)), e.z),
      n(u.add(qe(o.mul(2), l)), e.z),
      c.x
    ),
    li(
      n(u.add(qe(0, l.negate())), e.z),
      n(u.add(qe(0, l.mul(2))), e.z),
      c.y
    ),
    li(
      n(u.add(qe(o, l.negate())), e.z),
      n(u.add(qe(o, l.mul(2))), e.z),
      c.y
    ),
    li(
      li(
        n(u.add(qe(o.negate(), l.negate())), e.z),
        n(u.add(qe(o.mul(2), l.negate())), e.z),
        c.x
      ),
      li(
        n(u.add(qe(o.negate(), l.mul(2))), e.z),
        n(u.add(qe(o.mul(2), l.mul(2))), e.z),
        c.x
      ),
      c.y
    )
  ).mul(1 / 9);
}), PQ = Be(({ depthTexture: r, shadowCoord: e }) => {
  const i = ve(1).toVar(), n = Ci(r).uv(e.xy).rg, s = e3(e.z, n.x);
  return rr(s.notEqual(ve(1)), () => {
    const a = e.z.sub(n.x), o = An(0, n.y.mul(n.y));
    let l = o.div(o.add(a.mul(a)));
    l = Sa(un(l, 0.3).div(0.95 - 0.3)), i.assign(Sa(An(s, l)));
  }), i;
}), OQ = Be(({ samples: r, radius: e, size: i, shadowPass: n }) => {
  const s = ve(0).toVar(), a = ve(0).toVar(), o = r.lessThanEqual(ve(1)).select(ve(0), ve(2).div(r.sub(1))), l = r.lessThanEqual(ve(1)).select(ve(0), ve(-1));
  ys({ start: Mi(0), end: Mi(r), type: "int", condition: "<" }, ({ i: c }) => {
    const h = l.add(ve(c).mul(o)), d = n.uv(Nr(UT.xy, qe(0, h).mul(e)).div(i)).x;
    s.addAssign(d), a.addAssign(d.mul(d));
  }), s.divAssign(r), a.divAssign(r);
  const u = MT(a.sub(s.mul(s)));
  return qe(s, u);
}), IQ = Be(({ samples: r, radius: e, size: i, shadowPass: n }) => {
  const s = ve(0).toVar(), a = ve(0).toVar(), o = r.lessThanEqual(ve(1)).select(ve(0), ve(2).div(r.sub(1))), l = r.lessThanEqual(ve(1)).select(ve(0), ve(-1));
  ys({ start: Mi(0), end: Mi(r), type: "int", condition: "<" }, ({ i: c }) => {
    const h = l.add(ve(c).mul(o)), d = n.uv(Nr(UT.xy, qe(h, 0).mul(e)).div(i));
    s.addAssign(d.x), a.addAssign(Nr(d.y.mul(d.y), d.x.mul(d.x)));
  }), s.divAssign(r), a.divAssign(r);
  const u = MT(a.sub(s.mul(s)));
  return qe(s, u);
}), DQ = [CQ, RQ, NQ, PQ];
let Tu = null;
const bf = /* @__PURE__ */ new G3();
class kQ extends At {
  static get type() {
    return "ShadowNode";
  }
  constructor(e, i = null) {
    super(), this.light = e, this.shadow = i || e.shadow, this.shadowMap = null, this.vsmShadowMapVertical = null, this.vsmShadowMapHorizontal = null, this.vsmMaterialVertical = null, this.vsmMaterialHorizontal = null, this.updateBeforeType = Pt.RENDER, this._node = null, this.isShadowNode = !0;
  }
  setupShadow(e) {
    const { object: i, renderer: n } = e;
    Tu === null && (Tu = new Bi(), Tu.fragmentNode = _t(0, 0, 0, 1), Tu.isShadowNodeMaterial = !0, Tu.name = "ShadowMaterial");
    const s = this.shadow, a = n.shadowMap.type, o = new jc(s.mapSize.width, s.mapSize.height);
    o.compareFunction = uT;
    const l = e.createRenderTarget(s.mapSize.width, s.mapSize.height);
    if (l.depthTexture = o, s.camera.updateProjectionMatrix(), a === Xp) {
      o.compareFunction = null, this.vsmShadowMapVertical = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: yd, type: ga }), this.vsmShadowMapHorizontal = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: yd, type: ga });
      const _ = Ci(o), x = Ci(this.vsmShadowMapVertical.texture), b = bi("blurSamples", "float", s).setGroup(Ut), T = bi("radius", "float", s).setGroup(Ut), S = bi("mapSize", "vec2", s).setGroup(Ut);
      let w = this.vsmMaterialVertical || (this.vsmMaterialVertical = new Bi());
      w.fragmentNode = OQ({ samples: b, radius: T, size: S, shadowPass: _ }).context(e.getSharedContext()), w.name = "VSMVertical", w = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new Bi()), w.fragmentNode = IQ({ samples: b, radius: T, size: S, shadowPass: x }).context(e.getSharedContext()), w.name = "VSMHorizontal";
    }
    const u = bi("intensity", "float", s).setGroup(Ut), c = bi("bias", "float", s).setGroup(Ut), h = bi("normalBias", "float", s).setGroup(Ut), d = i.material.shadowPositionNode || wx;
    let p = Tt(s.matrix).setGroup(Ut).mul(d.add(OT.mul(h))), f;
    if (s.camera.isOrthographicCamera || n.logarithmicDepthBuffer !== !0)
      p = p.xyz.div(p.w), f = p.z, n.coordinateSystem === Ml && (f = f.mul(2).sub(1));
    else {
      const _ = p.w;
      p = p.xy.div(_);
      const x = Tt("float").onRenderUpdate(() => s.camera.near), b = Tt("float").onRenderUpdate(() => s.camera.far);
      f = S3(_, x, b);
    }
    p = ye(
      p.x,
      p.y.oneMinus(),
      // follow webgpu standards
      f.add(c)
    );
    const m = p.x.greaterThanEqual(0).and(p.x.lessThanEqual(1)).and(p.y.greaterThanEqual(0)).and(p.y.lessThanEqual(1)).and(p.z.lessThanEqual(1)), v = s.filterNode || DQ[n.shadowMap.type] || null;
    if (v === null)
      throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
    const y = Ci(l.texture, p), g = m.select(v({ depthTexture: a === Xp ? this.vsmShadowMapHorizontal.texture : o, shadowCoord: p, shadow: s }), ve(1));
    return this.shadowMap = l, this.shadow.map = l, li(1, g.rgb.mix(y, 1), u.mul(y.a));
  }
  setup(e) {
    if (e.renderer.shadowMap.enabled !== !1)
      return this._node !== null ? this._node : this._node = this.setupShadow(e);
  }
  updateShadow(e) {
    const { shadowMap: i, light: n, shadow: s } = this, { renderer: a, scene: o, camera: l } = e, u = a.shadowMap.type, c = i.depthTexture.version;
    this._depthVersionCached = c;
    const h = o.overrideMaterial;
    o.overrideMaterial = Tu, i.setSize(s.mapSize.width, s.mapSize.height), s.updateMatrices(n), s.camera.layers.mask = l.layers.mask;
    const d = a.getRenderTarget(), p = a.getRenderObjectFunction();
    a.setRenderObjectFunction((f, ...m) => {
      (f.castShadow === !0 || f.receiveShadow && u === Xp) && a.renderObject(f, ...m);
    }), a.setRenderTarget(i), a.render(o, s.camera), a.setRenderObjectFunction(p), n.isPointLight !== !0 && u === Xp && this.vsmPass(a), a.setRenderTarget(d), o.overrideMaterial = h;
  }
  vsmPass(e) {
    const { shadow: i } = this;
    this.vsmShadowMapVertical.setSize(i.mapSize.width, i.mapSize.height), this.vsmShadowMapHorizontal.setSize(i.mapSize.width, i.mapSize.height), e.setRenderTarget(this.vsmShadowMapVertical), bf.material = this.vsmMaterialVertical, bf.render(e), e.setRenderTarget(this.vsmShadowMapHorizontal), bf.material = this.vsmMaterialHorizontal, bf.render(e);
  }
  dispose() {
    this.shadowMap.dispose(), this.shadowMap = null, this.vsmShadowMapVertical !== null && (this.vsmShadowMapVertical.dispose(), this.vsmShadowMapVertical = null, this.vsmMaterialVertical.dispose(), this.vsmMaterialVertical = null), this.vsmShadowMapHorizontal !== null && (this.vsmShadowMapHorizontal.dispose(), this.vsmShadowMapHorizontal = null, this.vsmMaterialHorizontal.dispose(), this.vsmMaterialHorizontal = null), this.updateBeforeType = Pt.NONE;
  }
  updateBefore(e) {
    const { shadow: i } = this;
    (i.needsUpdate || i.autoUpdate) && (this.updateShadow(e), this.shadowMap.depthTexture.version === this._depthVersionCached && (i.needsUpdate = !1));
  }
}
const LQ = (r, e) => De(new kQ(r, e));
class Ll extends Gc {
  static get type() {
    return "AnalyticLightNode";
  }
  constructor(e = null) {
    super(), this.updateType = Pt.FRAME, this.light = e, this.color = new Kt(), this.colorNode = Tt(this.color).setGroup(Ut), this.baseColorNode = null, this.shadowNode = null, this.shadowColorNode = null, this.isAnalyticLightNode = !0;
  }
  getCacheKey() {
    return Fm(super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0);
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(e) {
    const { renderer: i } = e;
    if (i.shadowMap.enabled === !1) return;
    let n = this.shadowColorNode;
    if (n === null) {
      const s = this.light.shadow.shadowNode;
      let a;
      s !== void 0 ? a = De(s) : a = LQ(this.light), this.shadowNode = a, this.shadowColorNode = n = this.colorNode.mul(a), this.baseColorNode = this.colorNode;
    }
    this.colorNode = n;
  }
  setup(e) {
    this.colorNode = this.baseColorNode || this.colorNode, this.light.castShadow ? e.object.receiveShadow && this.setupShadow(e) : this.shadowNode !== null && this.shadowNode.dispose();
  }
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
const Y3 = /* @__PURE__ */ Be((r) => {
  const { lightDistance: e, cutoffDistance: i, decayExponent: n } = r, s = e.pow(n).max(0.01).reciprocal();
  return i.greaterThan(0).select(
    s.mul(e.div(i).pow4().oneMinus().clamp().pow2()),
    s
  );
}), UQ = Be(({ color: r, lightViewPosition: e, cutoffDistance: i, decayExponent: n }, s) => {
  const a = s.context.lightingModel, o = e.sub(ir), l = o.normalize(), u = o.length(), c = Y3({
    lightDistance: u,
    cutoffDistance: i,
    decayExponent: n
  }), h = r.mul(c), d = s.context.reflectedLight;
  a.direct({
    lightDirection: l,
    lightColor: h,
    reflectedLight: d
  }, s.stack, s);
});
class FQ extends Ll {
  static get type() {
    return "PointLightNode";
  }
  constructor(e = null) {
    super(e), this.cutoffDistanceNode = Tt(0).setGroup(Ut), this.decayExponentNode = Tt(0).setGroup(Ut);
  }
  update(e) {
    const { light: i } = this;
    super.update(e), this.cutoffDistanceNode.value = i.distance, this.decayExponentNode.value = i.decay;
  }
  setup() {
    UQ({
      color: this.colorNode,
      lightViewPosition: jT(this.light),
      cutoffDistance: this.cutoffDistanceNode,
      decayExponent: this.decayExponentNode
    }).append();
  }
}
const BQ = /* @__PURE__ */ Be(([r, e]) => {
  const i = r.x, n = r.y, s = r.z;
  let a = e.element(0).mul(0.886227);
  return a = a.add(e.element(1).mul(2 * 0.511664).mul(n)), a = a.add(e.element(2).mul(2 * 0.511664).mul(s)), a = a.add(e.element(3).mul(2 * 0.511664).mul(i)), a = a.add(e.element(4).mul(2 * 0.429043).mul(i).mul(n)), a = a.add(e.element(5).mul(2 * 0.429043).mul(n).mul(s)), a = a.add(e.element(6).mul(s.mul(s).mul(0.743125).sub(0.247708))), a = a.add(e.element(7).mul(2 * 0.429043).mul(i).mul(s)), a = a.add(e.element(8).mul(0.429043).mul(It(i, i).sub(It(n, n)))), a;
}), js = /* @__PURE__ */ new BT();
class zQ extends Eo {
  constructor(e, i) {
    super(), this.renderer = e, this.nodes = i;
  }
  update(e, i, n) {
    const s = this.renderer, a = this.nodes.getBackgroundNode(e) || e.background;
    let o = !1;
    if (a === null)
      s._clearColor.getRGB(js, mo), js.a = s._clearColor.a;
    else if (a.isColor === !0)
      a.getRGB(js, mo), js.a = 1, o = !0;
    else if (a.isNode === !0) {
      const l = this.get(e), u = a;
      js.copy(s._clearColor);
      let c = l.backgroundMesh;
      if (c === void 0) {
        const d = RT(_t(u).mul(jM), {
          // @TODO: Add Texture2D support using node context
          getUV: () => sQ.mul(d3),
          getTextureLevel: () => nQ
        });
        let p = Ex();
        p = p.setZ(p.w);
        const f = new Bi();
        f.name = "Background.material", f.side = es, f.depthTest = !1, f.depthWrite = !1, f.fog = !1, f.lights = !1, f.vertexNode = p, f.colorNode = d, l.backgroundMeshNode = d, l.backgroundMesh = c = new Al(new mT(1, 32, 32), f), c.frustumCulled = !1, c.name = "Background.mesh", c.onBeforeRender = function(m, v, y) {
          this.matrixWorld.copyPosition(y.matrixWorld);
        };
      }
      const h = u.getCacheKey();
      l.backgroundCacheKey !== h && (l.backgroundMeshNode.node = _t(u).mul(jM), l.backgroundMeshNode.needsUpdate = !0, c.material.needsUpdate = !0, l.backgroundCacheKey = h), i.unshift(c, c.geometry, c.material, 0, 0, null);
    } else
      console.error("THREE.Renderer: Unsupported background configuration.", a);
    if (s.autoClear === !0 || o === !0) {
      const l = n.clearColorValue;
      l.r = js.r, l.g = js.g, l.b = js.b, l.a = js.a, (s.backend.isWebGLBackend === !0 || s.alpha === !0) && (l.r *= l.a, l.g *= l.a, l.b *= l.a), n.depthClearValue = s._clearDepth, n.stencilClearValue = s._clearStencil, n.clearColor = s.autoClearColor === !0, n.clearDepth = s.autoClearDepth === !0, n.clearStencil = s.autoClearStencil === !0;
    } else
      n.clearColor = !1, n.clearDepth = !1, n.clearStencil = !1;
  }
}
let jQ = 0;
class Dx {
  constructor(e = "", i = [], n = 0, s = []) {
    this.name = e, this.bindings = i, this.index = n, this.bindingsReference = s, this.id = jQ++;
  }
}
class VQ {
  constructor(e, i, n, s, a, o, l, u, c, h = []) {
    this.vertexShader = e, this.fragmentShader = i, this.computeShader = n, this.transforms = h, this.nodeAttributes = s, this.bindings = a, this.updateNodes = o, this.updateBeforeNodes = l, this.updateAfterNodes = u, this.monitor = c, this.usedTimes = 0;
  }
  createBindings() {
    const e = [];
    for (const i of this.bindings)
      if (i.bindings[0].groupNode.shared !== !0) {
        const n = new Dx(i.name, [], i.index, i);
        e.push(n);
        for (const s of i.bindings)
          n.bindings.push(s.clone());
      } else
        e.push(i);
    return e;
  }
}
class qM {
  constructor(e, i, n = null) {
    this.isNodeAttribute = !0, this.name = e, this.type = i, this.node = n;
  }
}
class GQ {
  constructor(e, i, n) {
    this.isNodeUniform = !0, this.name = e, this.type = i, this.node = n.getSelf();
  }
  get value() {
    return this.node.value;
  }
  set value(e) {
    this.node.value = e;
  }
  get id() {
    return this.node.id;
  }
  get groupNode() {
    return this.node.groupNode;
  }
}
class $3 {
  constructor(e, i) {
    this.isNodeVar = !0, this.name = e, this.type = i;
  }
}
class HQ extends $3 {
  constructor(e, i) {
    super(e, i), this.needsInterpolation = !1, this.isNodeVarying = !0;
  }
}
class WQ {
  constructor(e, i, n = "") {
    this.name = e, this.type = i, this.code = n, Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
}
let qQ = 0;
class rv {
  constructor(e = null) {
    this.id = qQ++, this.nodesData = /* @__PURE__ */ new WeakMap(), this.parent = e;
  }
  getData(e) {
    let i = this.nodesData.get(e);
    return i === void 0 && this.parent !== null && (i = this.parent.getData(e)), i;
  }
  setData(e, i) {
    this.nodesData.set(e, i);
  }
}
class Ul {
  constructor(e, i) {
    this.name = e, this.value = i, this.boundary = 0, this.itemSize = 0, this.offset = 0;
  }
  setValue(e) {
    this.value = e;
  }
  getValue() {
    return this.value;
  }
}
class XQ extends Ul {
  constructor(e, i = 0) {
    super(e, i), this.isNumberUniform = !0, this.boundary = 4, this.itemSize = 1;
  }
}
class YQ extends Ul {
  constructor(e, i = new jt()) {
    super(e, i), this.isVector2Uniform = !0, this.boundary = 8, this.itemSize = 2;
  }
}
class $Q extends Ul {
  constructor(e, i = new oe()) {
    super(e, i), this.isVector3Uniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class KQ extends Ul {
  constructor(e, i = new $t()) {
    super(e, i), this.isVector4Uniform = !0, this.boundary = 16, this.itemSize = 4;
  }
}
class QQ extends Ul {
  constructor(e, i = new Kt()) {
    super(e, i), this.isColorUniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class ZQ extends Ul {
  constructor(e, i = new Yr()) {
    super(e, i), this.isMatrix3Uniform = !0, this.boundary = 48, this.itemSize = 12;
  }
}
class JQ extends Ul {
  constructor(e, i = new gi()) {
    super(e, i), this.isMatrix4Uniform = !0, this.boundary = 64, this.itemSize = 16;
  }
}
class eZ extends XQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class tZ extends YQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class iZ extends $Q {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class rZ extends KQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class nZ extends QQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class sZ extends ZQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class aZ extends JQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
const Vu = 4, XM = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], el = 20, nv = /* @__PURE__ */ new vT(-1, 1, 1, -1, 0, 1), oZ = /* @__PURE__ */ new Qs(90, 1), YM = /* @__PURE__ */ new Kt();
let sv = null, av = 0, ov = 0;
const Xo = (1 + Math.sqrt(5)) / 2, Su = 1 / Xo, $M = [
  /* @__PURE__ */ new oe(-Xo, Su, 0),
  /* @__PURE__ */ new oe(Xo, Su, 0),
  /* @__PURE__ */ new oe(-Su, 0, Xo),
  /* @__PURE__ */ new oe(Su, 0, Xo),
  /* @__PURE__ */ new oe(0, Xo, -Su),
  /* @__PURE__ */ new oe(0, Xo, Su),
  /* @__PURE__ */ new oe(-1, 1, -1),
  /* @__PURE__ */ new oe(1, 1, -1),
  /* @__PURE__ */ new oe(-1, 1, 1),
  /* @__PURE__ */ new oe(1, 1, 1)
], lZ = [
  3,
  1,
  5,
  0,
  4,
  2
], lv = J$(kg(), wa("faceIndex")).normalize(), VT = ye(lv.x, lv.y.negate(), lv.z);
class uZ {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._lodMeshes = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._backgroundBox = null;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, i = 0, n = 0.1, s = 100) {
    sv = this._renderer.getRenderTarget(), av = this._renderer.getActiveCubeFace(), ov = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const a = this._allocateTargets();
    return a.depthBuffer = !0, this._sceneToCubeUV(e, n, s, a), i > 0 && this._blur(a, 0, 0, i), this._applyPMREM(a), this._cleanup(a), a;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, i = null) {
    return this._fromTexture(e, i);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, i = null) {
    return this._fromTexture(e, i);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  async compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = QM(), await this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  async compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = ZM(), await this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose(), this._backgroundBox !== null && (this._backgroundBox.geometry.dispose(), this._backgroundBox.material.dispose());
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(sv, av, ov), e.scissorTest = !1, xf(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, i) {
    e.mapping === wl || e.mapping === Tc ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), sv = this._renderer.getRenderTarget(), av = this._renderer.getActiveCubeFace(), ov = this._renderer.getActiveMipmapLevel();
    const n = i || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), i = 4 * this._cubeSize, n = {
      magFilter: hn,
      minFilter: hn,
      generateMipmaps: !1,
      type: ga,
      format: Fc,
      colorSpace: mo
      //depthBuffer: false
    }, s = KM(e, i, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== i) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = KM(e, i, n);
      const { _lodMax: a } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = cZ(a)), this._blurMaterial = hZ(a, e, i);
    }
    return s;
  }
  async _compileMaterial(e) {
    const i = new Al(this._lodPlanes[0], e);
    await this._renderer.compile(i, nv);
  }
  _sceneToCubeUV(e, i, n, s) {
    const a = oZ;
    a.near = i, a.far = n;
    const o = [-1, 1, -1, -1, -1, -1], l = [1, 1, 1, -1, -1, -1], u = this._renderer, c = u.autoClear;
    u.getClearColor(YM), u.autoClear = !1;
    let h = this._backgroundBox;
    if (h === null) {
      const f = new Rg({
        name: "PMREM.Background",
        side: es,
        depthWrite: !1,
        depthTest: !1
      });
      h = new Al(new Zd(), f);
    }
    let d = !1;
    const p = e.background;
    p ? p.isColor && (h.material.color.copy(p), e.background = null, d = !0) : (h.material.color.copy(YM), d = !0), u.setRenderTarget(s), u.clear(), d && u.render(h, a);
    for (let f = 0; f < 6; f++) {
      const m = f % 3;
      m === 0 ? (a.up.set(0, o[f], 0), a.lookAt(l[f], 0, 0)) : m === 1 ? (a.up.set(0, 0, o[f]), a.lookAt(0, l[f], 0)) : (a.up.set(0, o[f], 0), a.lookAt(0, 0, l[f]));
      const v = this._cubeSize;
      xf(s, m * v, f > 2 ? v : 0, v, v), u.render(e, a);
    }
    u.autoClear = c, e.background = p;
  }
  _textureToCubeUV(e, i) {
    const n = this._renderer, s = e.mapping === wl || e.mapping === Tc;
    s ? this._cubemapMaterial === null && (this._cubemapMaterial = QM(e)) : this._equirectMaterial === null && (this._equirectMaterial = ZM(e));
    const a = s ? this._cubemapMaterial : this._equirectMaterial;
    a.fragmentNode.value = e;
    const o = this._lodMeshes[0];
    o.material = a;
    const l = this._cubeSize;
    xf(i, 0, 0, 3 * l, 2 * l), n.setRenderTarget(i), n.render(o, nv);
  }
  _applyPMREM(e) {
    const i = this._renderer, n = i.autoClear;
    i.autoClear = !1;
    const s = this._lodPlanes.length;
    for (let a = 1; a < s; a++) {
      const o = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1]), l = $M[(s - a - 1) % $M.length];
      this._blur(e, a - 1, a, o, l);
    }
    i.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, i, n, s, a) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      i,
      n,
      s,
      "latitudinal",
      a
    ), this._halfBlur(
      o,
      e,
      n,
      n,
      s,
      "longitudinal",
      a
    );
  }
  _halfBlur(e, i, n, s, a, o, l) {
    const u = this._renderer, c = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const h = 3, d = this._lodMeshes[s];
    d.material = c;
    const p = c.uniforms, f = this._sizeLods[n] - 1, m = isFinite(a) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * el - 1), v = a / m, y = isFinite(a) ? 1 + Math.floor(h * v) : el;
    y > el && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${el}`);
    const g = [];
    let _ = 0;
    for (let w = 0; w < el; ++w) {
      const C = w / v, E = Math.exp(-C * C / 2);
      g.push(E), w === 0 ? _ += E : w < y && (_ += 2 * E);
    }
    for (let w = 0; w < g.length; w++)
      g[w] = g[w] / _;
    e.texture.frame = (e.texture.frame || 0) + 1, p.envMap.value = e.texture, p.samples.value = y, p.weights.array = g, p.latitudinal.value = o === "latitudinal" ? 1 : 0, l && (p.poleAxis.value = l);
    const { _lodMax: x } = this;
    p.dTheta.value = m, p.mipInt.value = x - n;
    const b = this._sizeLods[s], T = 3 * b * (s > x - Vu ? s - x + Vu : 0), S = 4 * (this._cubeSize - b);
    xf(i, T, S, 3 * b, 2 * b), u.setRenderTarget(i), u.render(d, nv);
  }
}
function cZ(r) {
  const e = [], i = [], n = [], s = [];
  let a = r;
  const o = r - Vu + 1 + XM.length;
  for (let l = 0; l < o; l++) {
    const u = Math.pow(2, a);
    i.push(u);
    let c = 1 / u;
    l > r - Vu ? c = XM[l - r + Vu - 1] : l === 0 && (c = 0), n.push(c);
    const h = 1 / (u - 2), d = -h, p = 1 + h, f = [d, d, p, d, p, p, d, d, p, p, d, p], m = 6, v = 6, y = 3, g = 2, _ = 1, x = new Float32Array(y * v * m), b = new Float32Array(g * v * m), T = new Float32Array(_ * v * m);
    for (let w = 0; w < m; w++) {
      const C = w % 3 * 2 / 3 - 1, E = w > 2 ? 0 : -1, A = [
        C,
        E,
        0,
        C + 2 / 3,
        E,
        0,
        C + 2 / 3,
        E + 1,
        0,
        C,
        E,
        0,
        C + 2 / 3,
        E + 1,
        0,
        C,
        E + 1,
        0
      ], N = lZ[w];
      x.set(A, y * v * N), b.set(f, g * v * N);
      const L = [N, N, N, N, N, N];
      T.set(L, _ * v * N);
    }
    const S = new Dl();
    S.setAttribute("position", new En(x, y)), S.setAttribute("uv", new En(b, g)), S.setAttribute("faceIndex", new En(T, _)), e.push(S), s.push(new Al(S, null)), a > Vu && a--;
  }
  return { lodPlanes: e, sizeLods: i, sigmas: n, lodMeshes: s };
}
function KM(r, e, i) {
  const n = new zc(r, e, i);
  return n.texture.mapping = Zb, n.texture.name = "PMREM.cubeUv", n.texture.isPMREMTexture = !0, n.scissorTest = !0, n;
}
function xf(r, e, i, n, s) {
  r.viewport.set(e, i, n, s), r.scissor.set(e, i, n, s);
}
function GT(r) {
  const e = new Bi();
  return e.depthTest = !1, e.depthWrite = !1, e.blending = _c, e.name = `PMREM_${r}`, e;
}
function hZ(r, e, i) {
  const n = Md(new Array(el).fill(0)), s = Tt(new oe(0, 1, 0)), a = Tt(0), o = ve(el), l = Tt(0), u = Tt(1), c = Ci(null), h = Tt(0), d = ve(1 / e), p = ve(1 / i), f = ve(r), m = {
    n: o,
    latitudinal: l,
    weights: n,
    poleAxis: s,
    outputDirection: VT,
    dTheta: a,
    samples: u,
    envMap: c,
    mipInt: h,
    CUBEUV_TEXEL_WIDTH: d,
    CUBEUV_TEXEL_HEIGHT: p,
    CUBEUV_MAX_MIP: f
  }, v = GT("blur");
  return v.uniforms = m, v.fragmentNode = tK({ ...m, latitudinal: l.equal(1) }), v;
}
function QM(r) {
  const e = GT("cubemap");
  return e.fragmentNode = Ed(r, VT), e;
}
function ZM(r) {
  const e = GT("equirect");
  return e.fragmentNode = Ci(r, M3(VT), 0), e;
}
const JM = /* @__PURE__ */ new WeakMap(), dZ = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]), pZ = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]), _f = (r) => /e/g.test(r) ? String(r).replace(/\+/g, "") : (r = Number(r), r + (r % 1 ? "" : ".0"));
class K3 {
  constructor(e, i, n) {
    this.object = e, this.material = e && e.material || null, this.geometry = e && e.geometry || null, this.renderer = i, this.parser = n, this.scene = null, this.camera = null, this.nodes = [], this.sequentialNodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.updateAfterNodes = [], this.hashNodes = {}, this.monitor = null, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.clippingContext = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = { vertex: [], fragment: [], compute: [] }, this.flowCode = { vertex: "", fragment: "", compute: "" }, this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }, this.structs = { vertex: [], fragment: [], compute: [], index: 0 }, this.bindings = { vertex: {}, fragment: {}, compute: {} }, this.bindingsIndexes = {}, this.bindGroups = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.codes = {}, this.vars = {}, this.flow = { code: "" }, this.chaining = [], this.stack = K0(), this.stacks = [], this.tab = "	", this.currentFunctionNode = null, this.context = {
      material: this.material
    }, this.cache = new rv(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null, this.useComparisonMethod = !1;
  }
  getBindGroupsCache() {
    let e = JM.get(this.renderer);
    return e === void 0 && (e = new Es(), JM.set(this.renderer, e)), e;
  }
  createRenderTarget(e, i, n) {
    return new zc(e, i, n);
  }
  createCubeRenderTarget(e, i) {
    return new A3(e, i);
  }
  createPMREMGenerator() {
    return new uZ(this.renderer);
  }
  includes(e) {
    return this.nodes.includes(e);
  }
  _getBindGroup(e, i) {
    const n = this.getBindGroupsCache(), s = [];
    let a = !0;
    for (const l of i)
      s.push(l), a = a && l.groupNode.shared !== !0;
    let o;
    return a ? (o = n.get(s), o === void 0 && (o = new Dx(e, s, this.bindingsIndexes[e].group, s), n.set(s, o))) : o = new Dx(e, s, this.bindingsIndexes[e].group, s), o;
  }
  getBindGroupArray(e, i) {
    const n = this.bindings[i];
    let s = n[e];
    return s === void 0 && (this.bindingsIndexes[e] === void 0 && (this.bindingsIndexes[e] = { binding: 0, group: Object.keys(this.bindingsIndexes).length }), n[e] = s = []), s;
  }
  getBindings() {
    let e = this.bindGroups;
    if (e === null) {
      const i = {}, n = this.bindings;
      for (const s of tM)
        for (const a in n[s]) {
          const o = n[s][a];
          (i[a] || (i[a] = [])).push(...o);
        }
      e = [];
      for (const s in i) {
        const a = i[s], o = this._getBindGroup(s, a);
        e.push(o);
      }
      this.bindGroups = e;
    }
    return e;
  }
  sortBindingGroups() {
    const e = this.getBindings();
    e.sort((i, n) => i.bindings[0].groupNode.order - n.bindings[0].groupNode.order);
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      this.bindingsIndexes[n.name].group = i, n.index = i;
    }
  }
  setHashNode(e, i) {
    this.hashNodes[i] = e;
  }
  addNode(e) {
    this.nodes.includes(e) === !1 && (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
  }
  addSequentialNode(e) {
    this.sequentialNodes.includes(e) === !1 && this.sequentialNodes.push(e);
  }
  buildUpdateNodes() {
    for (const e of this.nodes)
      e.getUpdateType() !== Pt.NONE && this.updateNodes.push(e.getSelf());
    for (const e of this.sequentialNodes) {
      const i = e.getUpdateBeforeType(), n = e.getUpdateAfterType();
      i !== Pt.NONE && this.updateBeforeNodes.push(e.getSelf()), n !== Pt.NONE && this.updateAfterNodes.push(e.getSelf());
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  isFilteredTexture(e) {
    return e.magFilter === hn || e.magFilter === ex || e.magFilter === Qu || e.magFilter === ma || e.minFilter === hn || e.minFilter === ex || e.minFilter === Qu || e.minFilter === ma;
  }
  addChain(e) {
    this.chaining.push(e);
  }
  removeChain(e) {
    if (this.chaining.pop() !== e)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  getMethod(e) {
    return e;
  }
  getNodeFromHash(e) {
    return this.hashNodes[e];
  }
  addFlow(e, i) {
    return this.flowNodes[e].push(i), i;
  }
  setContext(e) {
    this.context = e;
  }
  getContext() {
    return this.context;
  }
  getSharedContext() {
    return { ...this.context }, this.context;
  }
  setCache(e) {
    this.cache = e;
  }
  getCache() {
    return this.cache;
  }
  getCacheFromNode(e, i = !0) {
    const n = this.getDataFromNode(e);
    return n.cache === void 0 && (n.cache = new rv(i ? this.getCache() : null)), n.cache;
  }
  isAvailable() {
    return !1;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getDrawIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return !1;
  }
  increaseUsage(e) {
    const i = this.getDataFromNode(e);
    return i.usageCount = i.usageCount === void 0 ? 1 : i.usageCount + 1, i.usageCount;
  }
  generateTexture() {
    console.warn("Abstract function.");
  }
  generateTextureLod() {
    console.warn("Abstract function.");
  }
  generateConst(e, i = null) {
    if (i === null && (e === "float" || e === "int" || e === "uint" ? i = 0 : e === "bool" ? i = !1 : e === "color" ? i = new Kt() : e === "vec2" ? i = new jt() : e === "vec3" ? i = new oe() : e === "vec4" && (i = new $t())), e === "float") return _f(i);
    if (e === "int") return `${Math.round(i)}`;
    if (e === "uint") return i >= 0 ? `${Math.round(i)}u` : "0u";
    if (e === "bool") return i ? "true" : "false";
    if (e === "color") return `${this.getType("vec3")}( ${_f(i.r)}, ${_f(i.g)}, ${_f(i.b)} )`;
    const n = this.getTypeLength(e), s = this.getComponentType(e), a = (o) => this.generateConst(s, o);
    if (n === 2)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)} )`;
    if (n === 3)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)}, ${a(i.z)} )`;
    if (n === 4)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)}, ${a(i.z)}, ${a(i.w)} )`;
    if (n > 4 && i && (i.isMatrix3 || i.isMatrix4))
      return `${this.getType(e)}( ${i.elements.map(a).join(", ")} )`;
    if (n > 4)
      return `${this.getType(e)}()`;
    throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`);
  }
  getType(e) {
    return e === "color" ? "vec3" : e;
  }
  hasGeometryAttribute(e) {
    return this.geometry && this.geometry.getAttribute(e) !== void 0;
  }
  getAttribute(e, i) {
    const n = this.attributes;
    for (const a of n)
      if (a.name === e)
        return a;
    const s = new qM(e, i);
    return n.push(s), s;
  }
  getPropertyName(e) {
    return e.name;
  }
  isVector(e) {
    return /vec\d/.test(e);
  }
  isMatrix(e) {
    return /mat\d/.test(e);
  }
  isReference(e) {
    return e === "void" || e === "property" || e === "sampler" || e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "depthTexture" || e === "texture3D";
  }
  needsToWorkingColorSpace() {
    return !1;
  }
  getComponentTypeFromTexture(e) {
    const i = e.type;
    if (e.isDataTexture) {
      if (i === Tr) return "int";
      if (i === Ji) return "uint";
    }
    return "float";
  }
  getElementType(e) {
    return e === "mat2" ? "vec2" : e === "mat3" ? "vec3" : e === "mat4" ? "vec4" : this.getComponentType(e);
  }
  getComponentType(e) {
    if (e = this.getVectorType(e), e === "float" || e === "bool" || e === "int" || e === "uint") return e;
    const i = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
    return i === null ? null : i[1] === "b" ? "bool" : i[1] === "i" ? "int" : i[1] === "u" ? "uint" : "float";
  }
  getVectorType(e) {
    return e === "color" ? "vec3" : e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "texture3D" ? "vec4" : e;
  }
  getTypeFromLength(e, i = "float") {
    if (e === 1) return i;
    const n = dZ.get(e);
    return (i === "float" ? "" : i[0]) + n;
  }
  getTypeFromArray(e) {
    return pZ.get(e.constructor);
  }
  getTypeFromAttribute(e) {
    let i = e;
    e.isInterleavedBufferAttribute && (i = e.data);
    const n = i.array, s = e.itemSize, a = e.normalized;
    let o;
    return !(e instanceof hP) && a !== !0 && (o = this.getTypeFromArray(n)), this.getTypeFromLength(s, o);
  }
  getTypeLength(e) {
    const i = this.getVectorType(e), n = /vec([2-4])/.exec(i);
    return n !== null ? Number(n[1]) : i === "float" || i === "bool" || i === "int" || i === "uint" ? 1 : /mat2/.test(e) === !0 ? 4 : /mat3/.test(e) === !0 ? 9 : /mat4/.test(e) === !0 ? 16 : 0;
  }
  getVectorFromMatrix(e) {
    return e.replace("mat", "vec");
  }
  changeComponentType(e, i) {
    return this.getTypeFromLength(this.getTypeLength(e), i);
  }
  getIntegerType(e) {
    const i = this.getComponentType(e);
    return i === "int" || i === "uint" ? e : this.changeComponentType(e, "int");
  }
  addStack() {
    return this.stack = K0(this.stack), this.stacks.push(LP() || this.stack), jm(this.stack), this.stack;
  }
  removeStack() {
    const e = this.stack;
    return this.stack = e.parent, jm(this.stacks.pop()), e;
  }
  getDataFromNode(e, i = this.shaderStage, n = null) {
    n = n === null ? e.isGlobal(this) ? this.globalCache : this.cache : n;
    let s = n.getData(e);
    return s === void 0 && (s = {}, n.setData(e, s)), s[i] === void 0 && (s[i] = {}), s[i];
  }
  getNodeProperties(e, i = "any") {
    const n = this.getDataFromNode(e, i);
    return n.properties || (n.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(e, i) {
    const n = this.getDataFromNode(e);
    let s = n.bufferAttribute;
    if (s === void 0) {
      const a = this.uniforms.index++;
      s = new qM("nodeAttribute" + a, i, e), this.bufferAttributes.push(s), n.bufferAttribute = s;
    }
    return s;
  }
  getStructTypeFromNode(e, i = this.shaderStage) {
    const n = this.getDataFromNode(e, i);
    if (n.structType === void 0) {
      const s = this.structs.index++;
      e.name = `StructType${s}`, this.structs[i].push(e), n.structType = e;
    }
    return e;
  }
  getUniformFromNode(e, i, n = this.shaderStage, s = null) {
    const a = this.getDataFromNode(e, n, this.globalCache);
    let o = a.uniform;
    if (o === void 0) {
      const l = this.uniforms.index++;
      o = new GQ(s || "nodeUniform" + l, i, e), this.uniforms[n].push(o), a.uniform = o;
    }
    return o;
  }
  getVarFromNode(e, i = null, n = e.getNodeType(this), s = this.shaderStage) {
    const a = this.getDataFromNode(e, s);
    let o = a.variable;
    if (o === void 0) {
      const l = this.vars[s] || (this.vars[s] = []);
      i === null && (i = "nodeVar" + l.length), o = new $3(i, n), l.push(o), a.variable = o;
    }
    return o;
  }
  getVaryingFromNode(e, i = null, n = e.getNodeType(this)) {
    const s = this.getDataFromNode(e, "any");
    let a = s.varying;
    if (a === void 0) {
      const o = this.varyings, l = o.length;
      i === null && (i = "nodeVarying" + l), a = new HQ(i, n), o.push(a), s.varying = a;
    }
    return a;
  }
  getCodeFromNode(e, i, n = this.shaderStage) {
    const s = this.getDataFromNode(e);
    let a = s.code;
    if (a === void 0) {
      const o = this.codes[n] || (this.codes[n] = []), l = o.length;
      a = new WQ("nodeCode" + l, i), o.push(a), s.code = a;
    }
    return a;
  }
  addFlowCodeHierarchy(e, i) {
    const { flowCodes: n, flowCodeBlock: s } = this.getDataFromNode(e);
    let a = !0, o = i;
    for (; o; ) {
      if (s.get(o) === !0) {
        a = !1;
        break;
      }
      o = this.getDataFromNode(o).parentNodeBlock;
    }
    if (a)
      for (const l of n)
        this.addLineFlowCode(l);
  }
  addLineFlowCodeBlock(e, i, n) {
    const s = this.getDataFromNode(e), a = s.flowCodes || (s.flowCodes = []), o = s.flowCodeBlock || (s.flowCodeBlock = /* @__PURE__ */ new WeakMap());
    a.push(i), o.set(n, !0);
  }
  addLineFlowCode(e, i = null) {
    return e === "" ? this : (i !== null && this.context.nodeBlock && this.addLineFlowCodeBlock(i, e, this.context.nodeBlock), e = this.tab + e, /;\s*$/.test(e) || (e = e + `;
`), this.flow.code += e, this);
  }
  addFlowCode(e) {
    return this.flow.code += e, this;
  }
  addFlowTab() {
    return this.tab += "	", this;
  }
  removeFlowTab() {
    return this.tab = this.tab.slice(0, -1), this;
  }
  getFlowData(e) {
    return this.flowsData.get(e);
  }
  flowNode(e) {
    const i = e.getNodeType(this), n = this.flowChildNode(e, i);
    return this.flowsData.set(e, n), n;
  }
  buildFunctionNode(e) {
    const i = new bQ(), n = this.currentFunctionNode;
    return this.currentFunctionNode = i, i.code = this.buildFunctionCode(e), this.currentFunctionNode = n, i;
  }
  flowShaderNode(e) {
    const i = e.layout, n = {
      [Symbol.iterator]() {
        let o = 0;
        const l = Object.values(this);
        return {
          next: () => ({
            value: l[o],
            done: o++ >= l.length
          })
        };
      }
    };
    for (const o of i.inputs)
      n[o.name] = new JK(o.type, o.name);
    e.layout = null;
    const s = e.call(n), a = this.flowStagesNode(s, i.type);
    return e.layout = i, a;
  }
  flowStagesNode(e, i = null) {
    const n = this.flow, s = this.vars, a = this.cache, o = this.buildStage, l = this.stack, u = {
      code: ""
    };
    this.flow = u, this.vars = {}, this.cache = new rv(), this.stack = K0();
    for (const c of eM)
      this.setBuildStage(c), u.result = e.build(this, i);
    return u.vars = this.getVars(this.shaderStage), this.flow = n, this.vars = s, this.cache = a, this.stack = l, this.setBuildStage(o), u;
  }
  getFunctionOperator() {
    return null;
  }
  flowChildNode(e, i = null) {
    const n = this.flow, s = {
      code: ""
    };
    return this.flow = s, s.result = e.build(this, i), this.flow = n, s;
  }
  flowNodeFromShaderStage(e, i, n = null, s = null) {
    const a = this.shaderStage;
    this.setShaderStage(e);
    const o = this.flowChildNode(i, n);
    return s !== null && (o.code += `${this.tab + s} = ${o.result};
`), this.flowCode[e] = this.flowCode[e] + o.code, this.setShaderStage(a), o;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(e, i) {
    return `${this.getType(e)} ${i}`;
  }
  getVars(e) {
    let i = "";
    const n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i += `${this.getVar(s.type, s.name)}; `;
    return i;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(e) {
    const i = this.codes[e];
    let n = "";
    if (i !== void 0)
      for (const s of i)
        n += s.code + `
`;
    return n;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(e) {
    this.shaderStage = e;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(e) {
    this.buildStage = e;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    const { object: e, material: i, renderer: n } = this;
    if (i !== null) {
      let s = n.library.fromMaterial(i);
      s === null && (console.error(`NodeMaterial: Material "${i.type}" is not compatible.`), s = new Bi()), s.build(this);
    } else
      this.addFlow("compute", e);
    for (const s of eM) {
      this.setBuildStage(s), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const a of tM) {
        this.setShaderStage(a);
        const o = this.flowNodes[a];
        for (const l of o)
          s === "generate" ? this.flowNode(l) : l.build(this);
      }
    }
    return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
  }
  getNodeUniform(e, i) {
    if (i === "float" || i === "int" || i === "uint") return new eZ(e);
    if (i === "vec2" || i === "ivec2" || i === "uvec2") return new tZ(e);
    if (i === "vec3" || i === "ivec3" || i === "uvec3") return new iZ(e);
    if (i === "vec4" || i === "ivec4" || i === "uvec4") return new rZ(e);
    if (i === "color") return new nZ(e);
    if (i === "mat3") return new sZ(e);
    if (i === "mat4") return new aZ(e);
    throw new Error(`Uniform "${i}" not declared.`);
  }
  createNodeMaterial(e = "NodeMaterial") {
    throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${e}() instead.`);
  }
  format(e, i, n) {
    if (i = this.getVectorType(i), n = this.getVectorType(n), i === n || n === null || this.isReference(n))
      return e;
    const s = this.getTypeLength(i), a = this.getTypeLength(n);
    return s === 16 && a === 9 ? `${this.getType(n)}(${e}[0].xyz, ${e}[1].xyz, ${e}[2].xyz)` : s === 9 && a === 4 ? `${this.getType(n)}(${e}[0].xy, ${e}[1].xy)` : s > 4 || a > 4 || a === 0 ? e : s === a ? `${this.getType(n)}( ${e} )` : s > a ? this.format(`${e}.${"xyz".slice(0, a)}`, this.getTypeFromLength(a, this.getComponentType(i)), n) : a === 4 && s > 1 ? `${this.getType(n)}( ${this.format(e, i, "vec3")}, 1.0 )` : s === 2 ? `${this.getType(n)}( ${this.format(e, i, "vec2")}, 0.0 )` : (s === 1 && a > 1 && i !== this.getComponentType(n) && (e = `${this.getType(this.getComponentType(n))}( ${e} )`), `${this.getType(n)}( ${e} )`);
  }
  getSignature() {
    return `// Three.js r${Ag} - Node System
`;
  }
}
class eA {
  constructor() {
    this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.startTime = null, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.updateAfterMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
  }
  _getMaps(e, i) {
    let n = e.get(i);
    return n === void 0 && (n = {
      renderMap: /* @__PURE__ */ new WeakMap(),
      frameMap: /* @__PURE__ */ new WeakMap()
    }, e.set(i, n)), n;
  }
  updateBeforeNode(e) {
    const i = e.getUpdateBeforeType(), n = e.updateReference(this);
    if (i === Pt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateBeforeMap, n);
      s.get(n) !== this.frameId && e.updateBefore(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Pt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateBeforeMap, n);
      s.get(n) !== this.renderId && e.updateBefore(this) !== !1 && s.set(n, this.renderId);
    } else i === Pt.OBJECT && e.updateBefore(this);
  }
  updateAfterNode(e) {
    const i = e.getUpdateAfterType(), n = e.updateReference(this);
    if (i === Pt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateAfterMap, n);
      s.get(n) !== this.frameId && e.updateAfter(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Pt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateAfterMap, n);
      s.get(n) !== this.renderId && e.updateAfter(this) !== !1 && s.set(n, this.renderId);
    } else i === Pt.OBJECT && e.updateAfter(this);
  }
  updateNode(e) {
    const i = e.getUpdateType(), n = e.updateReference(this);
    if (i === Pt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateMap, n);
      s.get(n) !== this.frameId && e.update(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Pt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateMap, n);
      s.get(n) !== this.renderId && e.update(this) !== !1 && s.set(n, this.renderId);
    } else i === Pt.OBJECT && e.update(this);
  }
  update() {
    this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
  }
}
class HT {
  constructor(e, i, n = null, s = "", a = !1) {
    this.type = e, this.name = i, this.count = n, this.qualifier = s, this.isConst = a;
  }
}
HT.isNodeFunctionInput = !0;
class fZ extends Ll {
  static get type() {
    return "DirectionalLightNode";
  }
  constructor(e = null) {
    super(e);
  }
  setup(e) {
    super.setup(e);
    const i = e.context.lightingModel, n = this.colorNode, s = q3(this.light), a = e.context.reflectedLight;
    i.direct({
      lightDirection: s,
      lightColor: n,
      reflectedLight: a
    }, e.stack, e);
  }
}
const uv = /* @__PURE__ */ new gi(), Tf = /* @__PURE__ */ new gi();
let Ah = null;
class mZ extends Ll {
  static get type() {
    return "RectAreaLightNode";
  }
  constructor(e = null) {
    super(e), this.halfHeight = Tt(new oe()).setGroup(Ut), this.halfWidth = Tt(new oe()).setGroup(Ut), this.updateType = Pt.RENDER;
  }
  update(e) {
    super.update(e);
    const { light: i } = this, n = e.camera.matrixWorldInverse;
    Tf.identity(), uv.copy(i.matrixWorld), uv.premultiply(n), Tf.extractRotation(uv), this.halfWidth.value.set(i.width * 0.5, 0, 0), this.halfHeight.value.set(0, i.height * 0.5, 0), this.halfWidth.value.applyMatrix4(Tf), this.halfHeight.value.applyMatrix4(Tf);
  }
  setup(e) {
    super.setup(e);
    let i, n;
    e.isAvailable("float32Filterable") ? (i = Ci(Ah.LTC_FLOAT_1), n = Ci(Ah.LTC_FLOAT_2)) : (i = Ci(Ah.LTC_HALF_1), n = Ci(Ah.LTC_HALF_2));
    const { colorNode: s, light: a } = this, o = e.context.lightingModel, l = jT(a), u = e.context.reflectedLight;
    o.directRectArea({
      lightColor: s,
      lightPosition: l,
      halfWidth: this.halfWidth,
      halfHeight: this.halfHeight,
      reflectedLight: u,
      ltc_1: i,
      ltc_2: n
    }, e.stack, e);
  }
  static setLTC(e) {
    Ah = e;
  }
}
class Q3 extends Ll {
  static get type() {
    return "SpotLightNode";
  }
  constructor(e = null) {
    super(e), this.coneCosNode = Tt(0).setGroup(Ut), this.penumbraCosNode = Tt(0).setGroup(Ut), this.cutoffDistanceNode = Tt(0).setGroup(Ut), this.decayExponentNode = Tt(0).setGroup(Ut);
  }
  update(e) {
    super.update(e);
    const { light: i } = this;
    this.coneCosNode.value = Math.cos(i.angle), this.penumbraCosNode.value = Math.cos(i.angle * (1 - i.penumbra)), this.cutoffDistanceNode.value = i.distance, this.decayExponentNode.value = i.decay;
  }
  getSpotAttenuation(e) {
    const { coneCosNode: i, penumbraCosNode: n } = this;
    return Cl(i, n, e);
  }
  setup(e) {
    super.setup(e);
    const i = e.context.lightingModel, { colorNode: n, cutoffDistanceNode: s, decayExponentNode: a, light: o } = this, l = jT(o).sub(ir), u = l.normalize(), c = u.dot(q3(o)), h = this.getSpotAttenuation(c), d = l.length(), p = Y3({
      lightDistance: d,
      cutoffDistance: s,
      decayExponent: a
    }), f = n.mul(h).mul(p), m = e.context.reflectedLight;
    i.direct({
      lightDirection: u,
      lightColor: f,
      reflectedLight: m
    }, e.stack, e);
  }
}
class gZ extends Q3 {
  static get type() {
    return "IESSpotLightNode";
  }
  getSpotAttenuation(e) {
    const i = this.light.iesMap;
    let n = null;
    if (i && i.isTexture === !0) {
      const s = e.acos().mul(1 / Math.PI);
      n = Ci(i, qe(s, 0), 0).r;
    } else
      n = super.getSpotAttenuation(e);
    return n;
  }
}
class yZ extends Ll {
  static get type() {
    return "AmbientLightNode";
  }
  constructor(e = null) {
    super(e);
  }
  setup({ context: e }) {
    e.irradiance.addAssign(this.colorNode);
  }
}
class vZ extends Ll {
  static get type() {
    return "HemisphereLightNode";
  }
  constructor(e = null) {
    super(e), this.lightPositionNode = W3(e), this.lightDirectionNode = this.lightPositionNode.normalize(), this.groundColorNode = Tt(new Kt()).setGroup(Ut);
  }
  update(e) {
    const { light: i } = this;
    super.update(e), this.lightPositionNode.object3d = i, this.groundColorNode.value.copy(i.groundColor).multiplyScalar(i.intensity);
  }
  setup(e) {
    const { colorNode: i, groundColorNode: n, lightDirectionNode: s } = this, a = is.dot(s).mul(0.5).add(0.5), o = li(n, i, a);
    e.context.irradiance.addAssign(o);
  }
}
class bZ extends Ll {
  static get type() {
    return "LightProbeNode";
  }
  constructor(e = null) {
    super(e);
    const i = [];
    for (let n = 0; n < 9; n++) i.push(new oe());
    this.lightProbe = Md(i);
  }
  update(e) {
    const { light: i } = this;
    super.update(e);
    for (let n = 0; n < 9; n++)
      this.lightProbe.array[n].copy(i.sh.coefficients[n]).multiplyScalar(i.intensity);
  }
  setup(e) {
    const i = BQ(d3, this.lightProbe);
    e.context.irradiance.addAssign(i);
  }
}
class Z3 {
  parseFunction() {
    console.warn("Abstract function.");
  }
}
class WT {
  constructor(e, i, n = "", s = "") {
    this.type = e, this.inputs = i, this.name = n, this.precision = s;
  }
  getCode() {
    console.warn("Abstract function.");
  }
}
WT.isNodeFunction = !0;
const xZ = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, _Z = /[a-z_0-9]+/ig, tA = "#pragma main", TZ = (r) => {
  r = r.trim();
  const e = r.indexOf(tA), i = e !== -1 ? r.slice(e + tA.length) : r, n = i.match(xZ);
  if (n !== null && n.length === 5) {
    const s = n[4], a = [];
    let o = null;
    for (; (o = _Z.exec(s)) !== null; )
      a.push(o);
    const l = [];
    let u = 0;
    for (; u < a.length; ) {
      const m = a[u][0] === "const";
      m === !0 && u++;
      let v = a[u][0];
      v === "in" || v === "out" || v === "inout" ? u++ : v = "";
      const y = a[u++][0];
      let g = Number.parseInt(a[u][0]);
      Number.isNaN(g) === !1 ? u++ : g = null;
      const _ = a[u++][0];
      l.push(new HT(y, _, g, v, m));
    }
    const c = i.substring(n[0].length), h = n[3] !== void 0 ? n[3] : "", d = n[2], p = n[1] !== void 0 ? n[1] : "", f = e !== -1 ? r.slice(0, e) : "";
    return {
      type: d,
      inputs: l,
      name: h,
      precision: p,
      inputsCode: s,
      blockCode: c,
      headerCode: f
    };
  } else
    throw new Error("FunctionNode: Function is not a GLSL code.");
};
class SZ extends WT {
  constructor(e) {
    const { type: i, inputs: n, name: s, precision: a, inputsCode: o, blockCode: l, headerCode: u } = TZ(e);
    super(i, n, s, a), this.inputsCode = o, this.blockCode = l, this.headerCode = u;
  }
  getCode(e = this.name) {
    let i;
    const n = this.blockCode;
    if (n !== "") {
      const { type: s, inputsCode: a, headerCode: o, precision: l } = this;
      let u = `${s} ${e} ( ${a.trim()} )`;
      l !== "" && (u = `${l} ${u}`), i = o + u + n;
    } else
      i = "";
    return i;
  }
}
class wZ extends Z3 {
  parseFunction(e) {
    return new SZ(e);
  }
}
const iA = /* @__PURE__ */ new WeakMap();
class EZ extends Eo {
  constructor(e, i) {
    super(), this.renderer = e, this.backend = i, this.nodeFrame = new eA(), this.nodeBuilderCache = /* @__PURE__ */ new Map(), this.callHashCache = new Es(), this.groupsData = new Es();
  }
  updateGroup(e) {
    const i = e.groupNode, n = i.name;
    if (n === BP.name) return !0;
    if (n === Ut.name) {
      const o = this.get(e), l = this.nodeFrame.renderId;
      return o.renderId !== l ? (o.renderId = l, !0) : !1;
    }
    if (n === JW.name) {
      const o = this.get(e), l = this.nodeFrame.frameId;
      return o.frameId !== l ? (o.frameId = l, !0) : !1;
    }
    const s = [i, e];
    let a = this.groupsData.get(s);
    return a === void 0 && this.groupsData.set(s, a = {}), a.version !== i.version ? (a.version = i.version, !0) : !1;
  }
  getForRenderCacheKey(e) {
    return e.initialCacheKey;
  }
  getForRender(e) {
    const i = this.get(e);
    let n = i.nodeBuilderState;
    if (n === void 0) {
      const { nodeBuilderCache: s } = this, a = this.getForRenderCacheKey(e);
      if (n = s.get(a), n === void 0) {
        const o = this.backend.createNodeBuilder(e.object, this.renderer);
        o.scene = e.scene, o.material = e.material, o.camera = e.camera, o.context.material = e.material, o.lightsNode = e.lightsNode, o.environmentNode = this.getEnvironmentNode(e.scene), o.fogNode = this.getFogNode(e.scene), o.clippingContext = e.clippingContext, o.build(), n = this._createNodeBuilderState(o), s.set(a, n);
      }
      n.usedTimes++, i.nodeBuilderState = n;
    }
    return n;
  }
  delete(e) {
    if (e.isRenderObject) {
      const i = this.get(e).nodeBuilderState;
      i.usedTimes--, i.usedTimes === 0 && this.nodeBuilderCache.delete(this.getForRenderCacheKey(e));
    }
    return super.delete(e);
  }
  getForCompute(e) {
    const i = this.get(e);
    let n = i.nodeBuilderState;
    if (n === void 0) {
      const s = this.backend.createNodeBuilder(e, this.renderer);
      s.build(), n = this._createNodeBuilderState(s), i.nodeBuilderState = n;
    }
    return n;
  }
  _createNodeBuilderState(e) {
    return new VQ(
      e.vertexShader,
      e.fragmentShader,
      e.computeShader,
      e.getAttributesArray(),
      e.getBindings(),
      e.updateNodes,
      e.updateBeforeNodes,
      e.updateAfterNodes,
      e.monitor,
      e.transforms
    );
  }
  getEnvironmentNode(e) {
    return e.environmentNode || this.get(e).environmentNode || null;
  }
  getBackgroundNode(e) {
    return e.backgroundNode || this.get(e).backgroundNode || null;
  }
  getFogNode(e) {
    return e.fogNode || this.get(e).fogNode || null;
  }
  getCacheKey(e, i) {
    const n = [e, i], s = this.renderer.info.calls;
    let a = this.callHashCache.get(n);
    if (a === void 0 || a.callId !== s) {
      const o = this.getEnvironmentNode(e), l = this.getFogNode(e), u = [];
      i && u.push(i.getCacheKey(!0)), o && u.push(o.getCacheKey()), l && u.push(l.getCacheKey()), u.push(this.renderer.shadowMap.enabled ? 1 : 0), a = {
        callId: s,
        cacheKey: RP(u)
      }, this.callHashCache.set(n, a);
    }
    return a.cacheKey;
  }
  updateScene(e) {
    this.updateEnvironment(e), this.updateFog(e), this.updateBackground(e);
  }
  get isToneMappingState() {
    return !this.renderer.getRenderTarget();
  }
  updateBackground(e) {
    const i = this.get(e), n = e.background;
    if (n) {
      const s = e.backgroundBlurriness === 0 && i.backgroundBlurriness > 0 || e.backgroundBlurriness > 0 && i.backgroundBlurriness === 0;
      if (i.background !== n || s) {
        let a = null;
        if (n.isCubeTexture === !0 || n.mapping === Xd || n.mapping === Yd || n.mapping === Zb)
          if (e.backgroundBlurriness > 0 || n.mapping === Zb)
            a = F3(n);
          else {
            let o;
            n.isCubeTexture === !0 ? o = Ed(n) : o = Ci(n), a = R3(o);
          }
        else n.isTexture === !0 ? a = Ci(n, Ad.flipY()).setUpdateMatrix(!0) : n.isColor !== !0 && console.error("WebGPUNodes: Unsupported background configuration.", n);
        i.backgroundNode = a, i.background = n, i.backgroundBlurriness = e.backgroundBlurriness;
      }
    } else i.backgroundNode && (delete i.backgroundNode, delete i.background);
  }
  updateFog(e) {
    const i = this.get(e), n = e.fog;
    if (n) {
      if (i.fog !== n) {
        let s = null;
        if (n.isFogExp2) {
          const a = bi("color", "color", n).setGroup(Ut), o = bi("density", "float", n).setGroup(Ut);
          s = SQ(a, o);
        } else if (n.isFog) {
          const a = bi("color", "color", n).setGroup(Ut), o = bi("near", "float", n).setGroup(Ut), l = bi("far", "float", n).setGroup(Ut);
          s = _Q(a, o, l);
        } else
          console.error("WebGPUNodes: Unsupported fog configuration.", n);
        i.fogNode = s, i.fog = n;
      }
    } else
      delete i.fogNode, delete i.fog;
  }
  updateEnvironment(e) {
    const i = this.get(e), n = e.environment;
    if (n) {
      if (i.environment !== n) {
        let s = null;
        n.isCubeTexture === !0 ? s = Ed(n) : n.isTexture === !0 ? s = Ci(n) : console.error("Nodes: Unsupported environment configuration.", n), i.environmentNode = s, i.environment = n;
      }
    } else i.environmentNode && (delete i.environmentNode, delete i.environment);
  }
  getNodeFrame(e = this.renderer, i = null, n = null, s = null, a = null) {
    const o = this.nodeFrame;
    return o.renderer = e, o.scene = i, o.object = n, o.camera = s, o.material = a, o;
  }
  getNodeFrameForRender(e) {
    return this.getNodeFrame(e.renderer, e.scene, e.object, e.camera, e.material);
  }
  getOutputCacheKey() {
    const e = this.renderer;
    return e.toneMapping + "," + e.currentColorSpace;
  }
  hasOutputChange(e) {
    return iA.get(e) !== this.getOutputCacheKey();
  }
  getOutputNode(e) {
    const i = this.renderer, n = this.getOutputCacheKey(), s = Ci(e, Ad).renderOutput(i.toneMapping, i.currentColorSpace);
    return iA.set(e, n), s;
  }
  updateBefore(e) {
    const i = e.getNodeBuilderState();
    for (const n of i.updateBeforeNodes)
      this.getNodeFrameForRender(e).updateBeforeNode(n);
  }
  updateAfter(e) {
    const i = e.getNodeBuilderState();
    for (const n of i.updateAfterNodes)
      this.getNodeFrameForRender(e).updateAfterNode(n);
  }
  updateForCompute(e) {
    const i = this.getNodeFrame(), n = this.getForCompute(e);
    for (const s of n.updateNodes)
      i.updateNode(s);
  }
  updateForRender(e) {
    const i = this.getNodeFrameForRender(e), n = e.getNodeBuilderState();
    for (const s of n.updateNodes)
      i.updateNode(s);
  }
  needsRefresh(e) {
    const i = this.getNodeFrameForRender(e);
    return e.getMonitor().needsRefresh(e, i);
  }
  dispose() {
    super.dispose(), this.nodeFrame = new eA(), this.nodeBuilderCache = /* @__PURE__ */ new Map();
  }
}
class MZ {
  constructor(e, i) {
    this.scene = e, this.camera = i;
  }
  clone() {
    return Object.assign(new this.constructor(), this);
  }
}
class AZ {
  constructor() {
    this.lists = new Es();
  }
  get(e, i) {
    const n = this.lists, s = [e, i];
    let a = n.get(s);
    return a === void 0 && (a = new MZ(e, i), n.set(s, a)), a;
  }
  dispose() {
    this.lists = new Es();
  }
}
class J3 {
  constructor() {
    this.lightNodes = /* @__PURE__ */ new WeakMap(), this.materialNodes = /* @__PURE__ */ new Map(), this.toneMappingNodes = /* @__PURE__ */ new Map();
  }
  fromMaterial(e) {
    if (e.isNodeMaterial) return e;
    let i = null;
    const n = this.getMaterialNodeClass(e.type);
    if (n !== null) {
      i = new n();
      for (const s in e)
        i[s] = e[s];
    }
    return i;
  }
  addToneMapping(e, i) {
    this.addType(e, i, this.toneMappingNodes);
  }
  getToneMappingFunction(e) {
    return this.toneMappingNodes.get(e) || null;
  }
  getMaterialNodeClass(e) {
    return this.materialNodes.get(e) || null;
  }
  addMaterial(e, i) {
    this.addType(e, i.type, this.materialNodes);
  }
  getLightNodeClass(e) {
    return this.lightNodes.get(e) || null;
  }
  addLight(e, i) {
    this.addClass(e, i, this.lightNodes);
  }
  addType(e, i, n) {
    if (n.has(i)) {
      console.warn(`Redefinition of node ${i}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof i == "function" || typeof i == "object") throw new Error(`Base class ${i} is not a class.`);
    n.set(i, e);
  }
  addClass(e, i, n) {
    if (n.has(i)) {
      console.warn(`Redefinition of node ${i.name}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof i != "function") throw new Error(`Base class ${i.name} is not a class.`);
    n.set(i, e);
  }
}
const CZ = /* @__PURE__ */ new X3();
class RZ extends Es {
  constructor() {
    super();
  }
  createNode(e = []) {
    return new X3().setLights(e);
  }
  getNode(e, i) {
    if (e.isQuadMesh) return CZ;
    const n = [e, i];
    let s = this.get(n);
    return s === void 0 && (s = this.createNode(), this.set(n, s)), s;
  }
}
const rA = /* @__PURE__ */ new mP(), Sf = /* @__PURE__ */ new jt(), cv = /* @__PURE__ */ new $t(), hv = /* @__PURE__ */ new vP(), wf = /* @__PURE__ */ new gi(), Xa = /* @__PURE__ */ new $t();
class NZ {
  constructor(e, i = {}) {
    this.isRenderer = !0;
    const {
      logarithmicDepthBuffer: n = !1,
      alpha: s = !0,
      depth: a = !0,
      stencil: o = !1,
      antialias: l = !1,
      samples: u = 0,
      getFallback: c = null
    } = i;
    this.domElement = e.getDomElement(), this.backend = e, this.samples = u || l === !0 ? 4 : 0, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.alpha = s, this.logarithmicDepthBuffer = n, this.outputColorSpace = ht, this.toneMapping = Ku, this.toneMappingExposure = 1, this.sortObjects = !0, this.depth = a, this.stencil = o, this.clippingPlanes = [], this.info = new BK(), this.nodes = {
      modelViewMatrix: null,
      modelNormalViewMatrix: null
    }, this.library = new J3(), this.lighting = new RZ(), this._getFallback = c, this._pixelRatio = 1, this._width = this.domElement.width, this._height = this.domElement.height, this._viewport = new $t(0, 0, this._width, this._height), this._scissor = new $t(0, 0, this._width, this._height), this._scissorTest = !1, this._attributes = null, this._geometries = null, this._nodes = null, this._animation = null, this._bindings = null, this._objects = null, this._pipelines = null, this._bundles = null, this._renderLists = null, this._renderContexts = null, this._textures = null, this._background = null, this._quad = new G3(new Bi()), this._quad.material.type = "Renderer_output", this._currentRenderContext = null, this._opaqueSort = null, this._transparentSort = null, this._frameBufferTarget = null;
    const h = this.alpha === !0 ? 0 : 1;
    this._clearColor = new BT(0, 0, 0, h), this._clearDepth = 1, this._clearStencil = 0, this._renderTarget = null, this._activeCubeFace = 0, this._activeMipmapLevel = 0, this._mrt = null, this._renderObjectFunction = null, this._currentRenderObjectFunction = null, this._currentRenderBundle = null, this._handleObjectFunction = this._renderObjectDirect, this._isDeviceLost = !1, this.onDeviceLost = this._onDeviceLost, this._initialized = !1, this._initPromise = null, this._compilationPromises = null, this.transparent = !0, this.opaque = !0, this.shadowMap = {
      enabled: !1,
      type: P9
    }, this.xr = {
      enabled: !1
    }, this.debug = {
      checkShaderErrors: !0,
      onShaderError: null,
      getShaderAsync: async (d, p, f) => {
        await this.compileAsync(d, p);
        const m = this._renderLists.get(d, p), v = this._renderContexts.get(d, p, this._renderTarget), y = d.overrideMaterial || f.material, g = this._objects.get(f, y, d, p, m.lightsNode, v), { fragmentShader: _, vertexShader: x } = g.getNodeBuilderState();
        return { fragmentShader: _, vertexShader: x };
      }
    };
  }
  async init() {
    if (this._initialized)
      throw new Error("Renderer: Backend has already been initialized.");
    return this._initPromise !== null ? this._initPromise : (this._initPromise = new Promise(async (e, i) => {
      let n = this.backend;
      try {
        await n.init(this);
      } catch (s) {
        if (this._getFallback !== null)
          try {
            this.backend = n = this._getFallback(s), await n.init(this);
          } catch (a) {
            i(a);
            return;
          }
        else {
          i(s);
          return;
        }
      }
      this._nodes = new EZ(this, n), this._animation = new RK(this._nodes, this.info), this._attributes = new LK(n), this._background = new zQ(this, this._nodes), this._geometries = new FK(this._attributes, this.info), this._textures = new ZK(this, n, this.info), this._pipelines = new GK(n, this._nodes), this._bindings = new HK(n, this._nodes, this._textures, this._attributes, this._pipelines, this.info), this._objects = new IK(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info), this._renderLists = new XK(this.lighting), this._bundles = new AZ(), this._renderContexts = new KK(), this._initialized = !0, e();
    }), this._initPromise);
  }
  get coordinateSystem() {
    return this.backend.coordinateSystem;
  }
  async compileAsync(e, i, n = null) {
    if (this._isDeviceLost === !0) return;
    this._initialized === !1 && await this.init();
    const s = this._nodes.nodeFrame, a = s.renderId, o = this._currentRenderContext, l = this._currentRenderObjectFunction, u = this._compilationPromises, c = e.isScene === !0 ? e : rA;
    n === null && (n = e);
    const h = this._renderTarget, d = this._renderContexts.get(n, i, h), p = this._activeMipmapLevel, f = [];
    this._currentRenderContext = d, this._currentRenderObjectFunction = this.renderObject, this._handleObjectFunction = this._createObjectPipeline, this._compilationPromises = f, s.renderId++, s.update(), d.depth = this.depth, d.stencil = this.stencil, d.clippingContext || (d.clippingContext = new Px()), d.clippingContext.updateGlobal(this, i), c.onBeforeRender(this, e, i, h);
    const m = this._renderLists.get(e, i);
    if (m.begin(), this._projectObject(e, i, 0, m), n !== e && n.traverseVisible(function(_) {
      _.isLight && _.layers.test(i.layers) && m.pushLight(_);
    }), m.finish(), h !== null) {
      this._textures.updateRenderTarget(h, p);
      const _ = this._textures.get(h);
      d.textures = _.textures, d.depthTexture = _.depthTexture;
    } else
      d.textures = null, d.depthTexture = null;
    this._nodes.updateScene(c), this._background.update(c, m, d);
    const v = m.opaque, y = m.transparent, g = m.lightsNode;
    this.opaque === !0 && v.length > 0 && this._renderObjects(v, i, c, g), this.transparent === !0 && y.length > 0 && this._renderTransparents(y, i, c, g), s.renderId = a, this._currentRenderContext = o, this._currentRenderObjectFunction = l, this._compilationPromises = u, this._handleObjectFunction = this._renderObjectDirect, await Promise.all(f);
  }
  async renderAsync(e, i) {
    this._initialized === !1 && await this.init();
    const n = this._renderScene(e, i);
    await this.backend.resolveTimestampAsync(n, "render");
  }
  async waitForGPU() {
    await this.backend.waitForGPU();
  }
  setMRT(e) {
    return this._mrt = e, this;
  }
  getMRT() {
    return this._mrt;
  }
  _onDeviceLost(e) {
    let i = `THREE.WebGPURenderer: ${e.api} Device Lost:

Message: ${e.message}`;
    e.reason && (i += `
Reason: ${e.reason}`), console.error(i), this._isDeviceLost = !0;
  }
  _renderBundle(e, i, n) {
    const { bundleGroup: s, camera: a, renderList: o } = e, l = this._currentRenderContext, u = this._bundles.get(s, a), c = this.backend.get(u);
    c.renderContexts === void 0 && (c.renderContexts = /* @__PURE__ */ new Set());
    const h = s.version !== c.version, d = c.renderContexts.has(l) === !1 || h;
    if (c.renderContexts.add(l), d) {
      this.backend.beginBundle(l), (c.renderObjects === void 0 || h) && (c.renderObjects = []), this._currentRenderBundle = u;
      const p = o.opaque;
      this.opaque === !0 && p.length > 0 && this._renderObjects(p, a, i, n), this._currentRenderBundle = null, this.backend.finishBundle(l, u), c.version = s.version;
    } else {
      const { renderObjects: p } = c;
      for (let f = 0, m = p.length; f < m; f++) {
        const v = p[f];
        this._nodes.needsRefresh(v) && (this._nodes.updateBefore(v), this._nodes.updateForRender(v), this._bindings.updateForRender(v), this._nodes.updateAfter(v));
      }
    }
    this.backend.addBundle(l, u);
  }
  render(e, i) {
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."), this.renderAsync(e, i);
    this._renderScene(e, i);
  }
  _getFrameBufferTarget() {
    const { currentToneMapping: e, currentColorSpace: i } = this;
    if (e === Ku && i === mo) return null;
    const { width: n, height: s } = this.getDrawingBufferSize(Sf), { depth: a, stencil: o } = this;
    let l = this._frameBufferTarget;
    return l === null && (l = new zc(n, s, {
      depthBuffer: a,
      stencilBuffer: o,
      type: ga,
      // FloatType
      format: Fc,
      colorSpace: mo,
      generateMipmaps: !1,
      minFilter: hn,
      magFilter: hn,
      samples: this.samples
    }), l.isPostProcessingRenderTarget = !0, this._frameBufferTarget = l), l.depthBuffer = a, l.stencilBuffer = o, l.setSize(n, s), l.viewport.copy(this._viewport), l.scissor.copy(this._scissor), l.viewport.multiplyScalar(this._pixelRatio), l.scissor.multiplyScalar(this._pixelRatio), l.scissorTest = this._scissorTest, l;
  }
  _renderScene(e, i, n = !0) {
    if (this._isDeviceLost === !0) return;
    const s = n ? this._getFrameBufferTarget() : null, a = this._nodes.nodeFrame, o = a.renderId, l = this._currentRenderContext, u = this._currentRenderObjectFunction, c = e.isScene === !0 ? e : rA, h = this._renderTarget, d = this._activeCubeFace, p = this._activeMipmapLevel;
    let f;
    s !== null ? (f = s, this.setRenderTarget(f)) : f = h;
    const m = this._renderContexts.get(e, i, f);
    this._currentRenderContext = m, this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject, this.info.calls++, this.info.render.calls++, this.info.render.frameCalls++, a.renderId = this.info.calls;
    const v = this.coordinateSystem;
    i.coordinateSystem !== v && (i.coordinateSystem = v, i.updateProjectionMatrix()), e.matrixWorldAutoUpdate === !0 && e.updateMatrixWorld(), i.parent === null && i.matrixWorldAutoUpdate === !0 && i.updateMatrixWorld();
    let y = this._viewport, g = this._scissor, _ = this._pixelRatio;
    f !== null && (y = f.viewport, g = f.scissor, _ = 1), this.getDrawingBufferSize(Sf), cv.set(0, 0, Sf.width, Sf.height);
    const x = y.minDepth === void 0 ? 0 : y.minDepth, b = y.maxDepth === void 0 ? 1 : y.maxDepth;
    m.viewportValue.copy(y).multiplyScalar(_).floor(), m.viewportValue.width >>= p, m.viewportValue.height >>= p, m.viewportValue.minDepth = x, m.viewportValue.maxDepth = b, m.viewport = m.viewportValue.equals(cv) === !1, m.scissorValue.copy(g).multiplyScalar(_).floor(), m.scissor = this._scissorTest && m.scissorValue.equals(cv) === !1, m.scissorValue.width >>= p, m.scissorValue.height >>= p, m.clippingContext || (m.clippingContext = new Px()), m.clippingContext.updateGlobal(this, i), c.onBeforeRender(this, e, i, f), wf.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), hv.setFromProjectionMatrix(wf, v);
    const T = this._renderLists.get(e, i);
    if (T.begin(), this._projectObject(e, i, 0, T), T.finish(), this.sortObjects === !0 && T.sort(this._opaqueSort, this._transparentSort), f !== null) {
      this._textures.updateRenderTarget(f, p);
      const N = this._textures.get(f);
      m.textures = N.textures, m.depthTexture = N.depthTexture, m.width = N.width, m.height = N.height, m.renderTarget = f, m.depth = f.depthBuffer, m.stencil = f.stencilBuffer;
    } else
      m.textures = null, m.depthTexture = null, m.width = this.domElement.width, m.height = this.domElement.height, m.depth = this.depth, m.stencil = this.stencil;
    m.width >>= p, m.height >>= p, m.activeCubeFace = d, m.activeMipmapLevel = p, m.occlusionQueryCount = T.occlusionQueryCount, this._nodes.updateScene(c), this._background.update(c, T, m), this.backend.beginRender(m);
    const {
      bundles: S,
      lightsNode: w,
      transparentDoublePass: C,
      transparent: E,
      opaque: A
    } = T;
    if (S.length > 0 && this._renderBundles(S, c, w), this.opaque === !0 && A.length > 0 && this._renderObjects(A, i, c, w), this.transparent === !0 && E.length > 0 && this._renderTransparents(E, C, i, c, w), this.backend.finishRender(m), a.renderId = o, this._currentRenderContext = l, this._currentRenderObjectFunction = u, s !== null) {
      this.setRenderTarget(h, d, p);
      const N = this._quad;
      this._nodes.hasOutputChange(f.texture) && (N.material.fragmentNode = this._nodes.getOutputNode(f.texture), N.material.needsUpdate = !0), this._renderScene(N, N.camera, !1);
    }
    return c.onAfterRender(this, e, i, f), m;
  }
  getMaxAnisotropy() {
    return this.backend.getMaxAnisotropy();
  }
  getActiveCubeFace() {
    return this._activeCubeFace;
  }
  getActiveMipmapLevel() {
    return this._activeMipmapLevel;
  }
  async setAnimationLoop(e) {
    this._initialized === !1 && await this.init(), this._animation.setAnimationLoop(e);
  }
  async getArrayBufferAsync(e) {
    return await this.backend.getArrayBufferAsync(e);
  }
  getContext() {
    return this.backend.getContext();
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  getDrawingBufferSize(e) {
    return e.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
  }
  getSize(e) {
    return e.set(this._width, this._height);
  }
  setPixelRatio(e = 1) {
    this._pixelRatio !== e && (this._pixelRatio = e, this.setSize(this._width, this._height, !1));
  }
  setDrawingBufferSize(e, i, n) {
    this._width = e, this._height = i, this._pixelRatio = n, this.domElement.width = Math.floor(e * n), this.domElement.height = Math.floor(i * n), this.setViewport(0, 0, e, i), this._initialized && this.backend.updateSize();
  }
  setSize(e, i, n = !0) {
    this._width = e, this._height = i, this.domElement.width = Math.floor(e * this._pixelRatio), this.domElement.height = Math.floor(i * this._pixelRatio), n === !0 && (this.domElement.style.width = e + "px", this.domElement.style.height = i + "px"), this.setViewport(0, 0, e, i), this._initialized && this.backend.updateSize();
  }
  setOpaqueSort(e) {
    this._opaqueSort = e;
  }
  setTransparentSort(e) {
    this._transparentSort = e;
  }
  getScissor(e) {
    const i = this._scissor;
    return e.x = i.x, e.y = i.y, e.width = i.width, e.height = i.height, e;
  }
  setScissor(e, i, n, s) {
    const a = this._scissor;
    e.isVector4 ? a.copy(e) : a.set(e, i, n, s);
  }
  getScissorTest() {
    return this._scissorTest;
  }
  setScissorTest(e) {
    this._scissorTest = e, this.backend.setScissorTest(e);
  }
  getViewport(e) {
    return e.copy(this._viewport);
  }
  setViewport(e, i, n, s, a = 0, o = 1) {
    const l = this._viewport;
    e.isVector4 ? l.copy(e) : l.set(e, i, n, s), l.minDepth = a, l.maxDepth = o;
  }
  getClearColor(e) {
    return e.copy(this._clearColor);
  }
  setClearColor(e, i = 1) {
    this._clearColor.set(e), this._clearColor.a = i;
  }
  getClearAlpha() {
    return this._clearColor.a;
  }
  setClearAlpha(e) {
    this._clearColor.a = e;
  }
  getClearDepth() {
    return this._clearDepth;
  }
  setClearDepth(e) {
    this._clearDepth = e;
  }
  getClearStencil() {
    return this._clearStencil;
  }
  setClearStencil(e) {
    this._clearStencil = e;
  }
  isOccluded(e) {
    const i = this._currentRenderContext;
    return i && this.backend.isOccluded(i, e);
  }
  clear(e = !0, i = !0, n = !0) {
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."), this.clearAsync(e, i, n);
    const s = this._renderTarget || this._getFrameBufferTarget();
    let a = null;
    if (s !== null && (this._textures.updateRenderTarget(s), a = this._textures.get(s)), this.backend.clear(e, i, n, a), s !== null && this._renderTarget === null) {
      const o = this._quad;
      this._nodes.hasOutputChange(s.texture) && (o.material.fragmentNode = this._nodes.getOutputNode(s.texture), o.material.needsUpdate = !0), this._renderScene(o, o.camera, !1);
    }
  }
  clearColor() {
    return this.clear(!0, !1, !1);
  }
  clearDepth() {
    return this.clear(!1, !0, !1);
  }
  clearStencil() {
    return this.clear(!1, !1, !0);
  }
  async clearAsync(e = !0, i = !0, n = !0) {
    this._initialized === !1 && await this.init(), this.clear(e, i, n);
  }
  clearColorAsync() {
    return this.clearAsync(!0, !1, !1);
  }
  clearDepthAsync() {
    return this.clearAsync(!1, !0, !1);
  }
  clearStencilAsync() {
    return this.clearAsync(!1, !1, !0);
  }
  get currentToneMapping() {
    return this._renderTarget !== null ? Ku : this.toneMapping;
  }
  get currentColorSpace() {
    return this._renderTarget !== null ? mo : this.outputColorSpace;
  }
  dispose() {
    this.info.dispose(), this.backend.dispose(), this._animation.dispose(), this._objects.dispose(), this._pipelines.dispose(), this._nodes.dispose(), this._bindings.dispose(), this._renderLists.dispose(), this._renderContexts.dispose(), this._textures.dispose(), this.setRenderTarget(null), this.setAnimationLoop(null);
  }
  setRenderTarget(e, i = 0, n = 0) {
    this._renderTarget = e, this._activeCubeFace = i, this._activeMipmapLevel = n;
  }
  getRenderTarget() {
    return this._renderTarget;
  }
  setRenderObjectFunction(e) {
    this._renderObjectFunction = e;
  }
  getRenderObjectFunction() {
    return this._renderObjectFunction;
  }
  compute(e) {
    if (this.isDeviceLost === !0) return;
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."), this.computeAsync(e);
    const i = this._nodes.nodeFrame, n = i.renderId;
    this.info.calls++, this.info.compute.calls++, this.info.compute.frameCalls++, i.renderId = this.info.calls;
    const s = this.backend, a = this._pipelines, o = this._bindings, l = this._nodes, u = Array.isArray(e) ? e : [e];
    if (u[0] === void 0 || u[0].isComputeNode !== !0)
      throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
    s.beginCompute(e);
    for (const c of u) {
      if (a.has(c) === !1) {
        const p = () => {
          c.removeEventListener("dispose", p), a.delete(c), o.delete(c), l.delete(c);
        };
        c.addEventListener("dispose", p);
        const f = c.onInitFunction;
        f !== null && f.call(c, { renderer: this });
      }
      l.updateForCompute(c), o.updateForCompute(c);
      const h = o.getForCompute(c), d = a.getForCompute(c, h);
      s.compute(e, c, h, d);
    }
    s.finishCompute(e), i.renderId = n;
  }
  async computeAsync(e) {
    this._initialized === !1 && await this.init(), this.compute(e), await this.backend.resolveTimestampAsync(e, "compute");
  }
  async hasFeatureAsync(e) {
    return this._initialized === !1 && await this.init(), this.backend.hasFeature(e);
  }
  hasFeature(e) {
    return this._initialized === !1 ? (console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."), !1) : this.backend.hasFeature(e);
  }
  copyFramebufferToTexture(e, i = null) {
    if (i !== null)
      if (i.isVector2)
        i = Xa.set(i.x, i.y, e.image.width, e.image.height).floor();
      else if (i.isVector4)
        i = Xa.copy(i).floor();
      else {
        console.error("THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.");
        return;
      }
    else
      i = Xa.set(0, 0, e.image.width, e.image.height);
    let n = this._currentRenderContext, s;
    n !== null ? s = n.renderTarget : (s = this._renderTarget || this._getFrameBufferTarget(), s !== null && (this._textures.updateRenderTarget(s), n = this._textures.get(s))), this._textures.updateTexture(e, { renderTarget: s }), this.backend.copyFramebufferToTexture(e, n, i);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    this._textures.updateTexture(e), this._textures.updateTexture(i), this.backend.copyTextureToTexture(e, i, n, s, a);
  }
  readRenderTargetPixelsAsync(e, i, n, s, a, o = 0, l = 0) {
    return this.backend.copyTextureToBuffer(e.textures[o], i, n, s, a, l);
  }
  _projectObject(e, i, n, s) {
    if (e.visible === !1) return;
    if (e.layers.test(i.layers)) {
      if (e.isGroup)
        n = e.renderOrder;
      else if (e.isLOD)
        e.autoUpdate === !0 && e.update(i);
      else if (e.isLight)
        s.pushLight(e);
      else if (e.isSprite) {
        if (!e.frustumCulled || hv.intersectsSprite(e)) {
          this.sortObjects === !0 && Xa.setFromMatrixPosition(e.matrixWorld).applyMatrix4(wf);
          const { geometry: o, material: l } = e;
          l.visible && s.push(e, o, l, n, Xa.z, null);
        }
      } else if (e.isLineLoop)
        console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
      else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || hv.intersectsObject(e))) {
        const { geometry: o, material: l } = e;
        if (this.sortObjects === !0 && (o.boundingSphere === null && o.computeBoundingSphere(), Xa.copy(o.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(wf)), Array.isArray(l)) {
          const u = o.groups;
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c], p = l[d.materialIndex];
            p && p.visible && s.push(e, o, p, n, Xa.z, d);
          }
        } else l.visible && s.push(e, o, l, n, Xa.z, null);
      }
    }
    if (e.isBundleGroup === !0 && this.backend.beginBundle !== void 0) {
      const o = s;
      s = this._renderLists.get(e, i), s.begin(), o.pushBundle({
        bundleGroup: e,
        camera: i,
        renderList: s
      }), s.finish();
    }
    const a = e.children;
    for (let o = 0, l = a.length; o < l; o++)
      this._projectObject(a[o], i, n, s);
  }
  _renderBundles(e, i, n) {
    for (const s of e)
      this._renderBundle(s, i, n);
  }
  _renderTransparents(e, i, n, s, a) {
    if (i.length > 0) {
      for (const { material: o } of i)
        o.side = es;
      this._renderObjects(i, n, s, a, "backSide");
      for (const { material: o } of i)
        o.side = xc;
      this._renderObjects(e, n, s, a);
      for (const { material: o } of i)
        o.side = $u;
    } else
      this._renderObjects(e, n, s, a);
  }
  _renderObjects(e, i, n, s, a = null) {
    for (let o = 0, l = e.length; o < l; o++) {
      const u = e[o], { object: c, geometry: h, material: d, group: p } = u;
      if (i.isArrayCamera) {
        const f = i.cameras;
        for (let m = 0, v = f.length; m < v; m++) {
          const y = f[m];
          if (c.layers.test(y.layers)) {
            const g = y.viewport, _ = g.minDepth === void 0 ? 0 : g.minDepth, x = g.maxDepth === void 0 ? 1 : g.maxDepth, b = this._currentRenderContext.viewportValue;
            b.copy(g).multiplyScalar(this._pixelRatio).floor(), b.minDepth = _, b.maxDepth = x, this.backend.updateViewport(this._currentRenderContext), this._currentRenderObjectFunction(c, n, y, h, d, p, s, a);
          }
        }
      } else
        this._currentRenderObjectFunction(c, n, i, h, d, p, s, a);
    }
  }
  renderObject(e, i, n, s, a, o, l, u = null) {
    let c, h, d;
    if (e.onBeforeRender(this, i, n, s, a, o), i.overrideMaterial !== null) {
      const p = i.overrideMaterial;
      a.positionNode && a.positionNode.isNode && (c = p.positionNode, p.positionNode = a.positionNode), p.isShadowNodeMaterial && (p.side = a.shadowSide === null ? a.side : a.shadowSide, a.depthNode && a.depthNode.isNode && (d = p.depthNode, p.depthNode = a.depthNode), a.shadowNode && a.shadowNode.isNode && (h = p.fragmentNode, p.fragmentNode = a.shadowNode), this.localClippingEnabled && (a.clipShadows ? (p.clippingPlanes !== a.clippingPlanes && (p.clippingPlanes = a.clippingPlanes, p.needsUpdate = !0), p.clipIntersection !== a.clipIntersection && (p.clipIntersection = a.clipIntersection)) : Array.isArray(p.clippingPlanes) && (p.clippingPlanes = null, p.needsUpdate = !0))), a = p;
    }
    a.transparent === !0 && a.side === $u && a.forceSinglePass === !1 ? (a.side = es, this._handleObjectFunction(e, a, i, n, l, o, "backSide"), a.side = xc, this._handleObjectFunction(e, a, i, n, l, o, u), a.side = $u) : this._handleObjectFunction(e, a, i, n, l, o, u), c !== void 0 && (i.overrideMaterial.positionNode = c), d !== void 0 && (i.overrideMaterial.depthNode = d), h !== void 0 && (i.overrideMaterial.fragmentNode = h), e.onAfterRender(this, i, n, s, a, o);
  }
  _renderObjectDirect(e, i, n, s, a, o, l) {
    const u = this._objects.get(e, i, n, s, a, this._currentRenderContext, l);
    u.drawRange = e.geometry.drawRange, u.group = o;
    const c = this._nodes.needsRefresh(u);
    c && (this._nodes.updateBefore(u), this._geometries.updateForRender(u), this._nodes.updateForRender(u), this._bindings.updateForRender(u)), this._pipelines.updateForRender(u), this._currentRenderBundle !== null && (this.backend.get(this._currentRenderBundle).renderObjects.push(u), u.bundle = this._currentRenderBundle.scene), this.backend.draw(u, this.info), c && this._nodes.updateAfter(u);
  }
  _createObjectPipeline(e, i, n, s, a, o) {
    const l = this._objects.get(e, i, n, s, a, this._currentRenderContext, o);
    this._nodes.updateBefore(l), this._geometries.updateForRender(l), this._nodes.updateForRender(l), this._bindings.updateForRender(l), this._pipelines.getForRender(l, this._compilationPromises), this._nodes.updateAfter(l);
  }
  get compile() {
    return this.compileAsync;
  }
}
class qT {
  constructor(e = "") {
    this.name = e, this.visibility = 0;
  }
  setVisibility(e) {
    this.visibility |= e;
  }
  clone() {
    return Object.assign(new this.constructor(), this);
  }
}
function PZ(r) {
  return r + (no - r % no) % no;
}
class eO extends qT {
  constructor(e, i = null) {
    super(e), this.isBuffer = !0, this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT, this._buffer = i;
  }
  get byteLength() {
    return PZ(this._buffer.byteLength);
  }
  get buffer() {
    return this._buffer;
  }
  update() {
    return !0;
  }
}
class tO extends eO {
  constructor(e, i = null) {
    super(e, i), this.isUniformBuffer = !0;
  }
}
let OZ = 0;
class iO extends tO {
  constructor(e, i) {
    super("UniformBuffer_" + OZ++, e ? e.value : null), this.nodeUniform = e, this.groupNode = i;
  }
  get buffer() {
    return this.nodeUniform.value;
  }
}
class IZ extends tO {
  constructor(e) {
    super(e), this.isUniformsGroup = !0, this._values = null, this.uniforms = [];
  }
  addUniform(e) {
    return this.uniforms.push(e), this;
  }
  removeUniform(e) {
    const i = this.uniforms.indexOf(e);
    return i !== -1 && this.uniforms.splice(i, 1), this;
  }
  get values() {
    return this._values === null && (this._values = Array.from(this.buffer)), this._values;
  }
  get buffer() {
    let e = this._buffer;
    if (e === null) {
      const i = this.byteLength;
      e = new Float32Array(new ArrayBuffer(i)), this._buffer = e;
    }
    return e;
  }
  get byteLength() {
    let e = 0;
    for (let i = 0, n = this.uniforms.length; i < n; i++) {
      const s = this.uniforms[i], { boundary: a, itemSize: o } = s, l = e % no, u = no - l;
      l !== 0 && u - a < 0 ? e += no - l : l % a !== 0 && (e += l % a), s.offset = e / this.bytesPerElement, e += o * this.bytesPerElement;
    }
    return Math.ceil(e / no) * no;
  }
  update() {
    let e = !1;
    for (const i of this.uniforms)
      this.updateByType(i) === !0 && (e = !0);
    return e;
  }
  updateByType(e) {
    if (e.isNumberUniform) return this.updateNumber(e);
    if (e.isVector2Uniform) return this.updateVector2(e);
    if (e.isVector3Uniform) return this.updateVector3(e);
    if (e.isVector4Uniform) return this.updateVector4(e);
    if (e.isColorUniform) return this.updateColor(e);
    if (e.isMatrix3Uniform) return this.updateMatrix3(e);
    if (e.isMatrix4Uniform) return this.updateMatrix4(e);
    console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.", e);
  }
  updateNumber(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a] !== s) {
      const o = this.buffer;
      o[a] = n[a] = s, i = !0;
    }
    return i;
  }
  updateVector2(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, i = !0;
    }
    return i;
  }
  updateVector3(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y || n[a + 2] !== s.z) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, o[a + 2] = n[a + 2] = s.z, i = !0;
    }
    return i;
  }
  updateVector4(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y || n[a + 2] !== s.z || n[a + 4] !== s.w) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, o[a + 2] = n[a + 2] = s.z, o[a + 3] = n[a + 3] = s.w, i = !0;
    }
    return i;
  }
  updateColor(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.r || n[a + 1] !== s.g || n[a + 2] !== s.b) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.r, o[a + 1] = n[a + 1] = s.g, o[a + 2] = n[a + 2] = s.b, i = !0;
    }
    return i;
  }
  updateMatrix3(e) {
    let i = !1;
    const n = this.values, s = e.getValue().elements, a = e.offset;
    if (n[a + 0] !== s[0] || n[a + 1] !== s[1] || n[a + 2] !== s[2] || n[a + 4] !== s[3] || n[a + 5] !== s[4] || n[a + 6] !== s[5] || n[a + 8] !== s[6] || n[a + 9] !== s[7] || n[a + 10] !== s[8]) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s[0], o[a + 1] = n[a + 1] = s[1], o[a + 2] = n[a + 2] = s[2], o[a + 4] = n[a + 4] = s[3], o[a + 5] = n[a + 5] = s[4], o[a + 6] = n[a + 6] = s[5], o[a + 8] = n[a + 8] = s[6], o[a + 9] = n[a + 9] = s[7], o[a + 10] = n[a + 10] = s[8], i = !0;
    }
    return i;
  }
  updateMatrix4(e) {
    let i = !1;
    const n = this.values, s = e.getValue().elements, a = e.offset;
    return kZ(n, s, a) === !1 && (this.buffer.set(s, a), DZ(n, s, a), i = !0), i;
  }
}
function DZ(r, e, i) {
  for (let n = 0, s = e.length; n < s; n++)
    r[i + n] = e[n];
}
function kZ(r, e, i) {
  for (let n = 0, s = e.length; n < s; n++)
    if (r[i + n] !== e[n]) return !1;
  return !0;
}
let LZ = 0;
class rO extends IZ {
  constructor(e, i) {
    super(e), this.id = LZ++, this.groupNode = i, this.isNodeUniformsGroup = !0;
  }
  getNodes() {
    const e = [];
    for (const i of this.uniforms) {
      const n = i.nodeUniform.node;
      if (!n) throw new Error("NodeUniformsGroup: Uniform has no node.");
      e.push(n);
    }
    return e;
  }
}
let UZ = 0;
class FZ extends qT {
  constructor(e, i) {
    super(e), this.id = UZ++, this.texture = i, this.version = i ? i.version : 0, this.store = !1, this.generation = null, this.isSampledTexture = !0;
  }
  needsBindingsUpdate(e) {
    const { texture: i } = this;
    return e !== this.generation ? (this.generation = e, !0) : i.isVideoTexture;
  }
  update() {
    const { texture: e, version: i } = this;
    return i !== e.version ? (this.version = e.version, !0) : !1;
  }
}
class jg extends FZ {
  constructor(e, i, n, s = null) {
    super(e, i ? i.value : null), this.textureNode = i, this.groupNode = n, this.access = s;
  }
  needsBindingsUpdate(e) {
    return this.textureNode.value !== this.texture || super.needsBindingsUpdate(e);
  }
  update() {
    const { textureNode: e } = this;
    return this.texture !== e.value ? (this.texture = e.value, !0) : super.update();
  }
}
class nO extends jg {
  constructor(e, i, n, s) {
    super(e, i, n, s), this.isSampledCubeTexture = !0;
  }
}
class sO extends jg {
  constructor(e, i, n, s) {
    super(e, i, n, s), this.isSampledTexture3D = !0;
  }
}
const BZ = {
  atan2: "atan",
  textureDimensions: "textureSize",
  equals: "equal"
}, zZ = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
}, nA = {
  swizzleAssign: !0,
  storageBuffer: !1
}, sA = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;
class jZ extends K3 {
  constructor(e, i) {
    super(e, i, new wZ()), this.uniformGroups = {}, this.transforms = [], this.extensions = {}, this.useComparisonMethod = !0;
  }
  needsColorSpaceToLinearSRGB(e) {
    return e.isVideoTexture === !0 && e.colorSpace !== El;
  }
  getMethod(e) {
    return BZ[e] || e;
  }
  getOutputStructName() {
    return "";
  }
  buildFunctionCode(e) {
    const i = e.layout, n = this.flowShaderNode(e), s = [];
    for (const a of i.inputs)
      s.push(this.getType(a.type) + " " + a.name);
    return `${this.getType(i.type)} ${i.name}( ${s.join(", ")} ) {

	${n.vars}

${n.code}
	return ${n.result};

}`;
  }
  setupPBO(e) {
    const i = e.value;
    if (i.pbo === void 0) {
      const n = i.array, s = i.count * i.itemSize, { itemSize: a } = i, o = i.array.constructor.name.toLowerCase().includes("int");
      let l = o ? aT : sT;
      a === 2 ? l = o ? oT : yd : a === 3 ? l = o ? X9 : nT : a === 4 && (l = o ? lT : Fc);
      const u = {
        Float32Array: cn,
        Uint8Array: fo,
        Uint16Array: Uu,
        Uint32Array: Ji,
        Int8Array: Jh,
        Int16Array: ed,
        Int32Array: Tr,
        Uint8ClampedArray: fo
      }, c = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(s / a))));
      let h = Math.ceil(s / a / c);
      c * h * a < s && h++;
      const d = c * h * a, p = new n.constructor(d);
      p.set(n, 0), i.array = p;
      const f = new J7(i.array, c, h, l, u[i.array.constructor.name] || cn);
      f.needsUpdate = !0, f.isPBOTexture = !0;
      const m = new ip(f, null, null);
      m.setPrecision("high"), i.pboNode = m, i.pbo = m.value, this.getUniformFromNode(i.pboNode, "texture", this.shaderStage, this.context.label);
    }
  }
  getPropertyName(e, i = this.shaderStage) {
    return e.isNodeUniform && e.node.isTextureNode !== !0 && e.node.isBufferNode !== !0 ? i.charAt(0) + "_" + e.name : super.getPropertyName(e, i);
  }
  generatePBO(e) {
    const { node: i, indexNode: n } = e, s = i.value;
    if (this.renderer.backend.has(s)) {
      const h = this.renderer.backend.get(s);
      h.pbo = s.pbo;
    }
    const a = this.getUniformFromNode(s.pboNode, "texture", this.shaderStage, this.context.label), o = this.getPropertyName(a);
    this.increaseUsage(n);
    const l = n.build(this, "uint"), u = this.getDataFromNode(e);
    let c = u.propertyName;
    if (c === void 0) {
      const h = this.getVarFromNode(e);
      c = this.getPropertyName(h);
      const d = this.getDataFromNode(i);
      let p = d.propertySizeName;
      p === void 0 && (p = c + "Size", this.getVarFromNode(i, p, "uint"), this.addLineFlowCode(`${p} = uint( textureSize( ${o}, 0 ).x )`, e), d.propertySizeName = p);
      const { itemSize: f } = s, m = "." + Vc.join("").slice(0, f), v = `ivec2(${l} % ${p}, ${l} / ${p})`, y = this.generateTextureLoad(null, o, v, null, "0");
      let g = "vec4";
      s.pbo.type === Ji ? g = "uvec4" : s.pbo.type === Tr && (g = "ivec4"), this.addLineFlowCode(`${c} = ${g}(${y})${m}`, e), u.propertyName = c;
    }
    return c;
  }
  generateTextureLoad(e, i, n, s, a = "0") {
    return s ? `texelFetch( ${i}, ivec3( ${n}, ${s} ), ${a} )` : `texelFetch( ${i}, ${n}, ${a} )`;
  }
  generateTexture(e, i, n, s) {
    return e.isDepthTexture ? `texture( ${i}, ${n} ).x` : (s && (n = `vec3( ${n}, ${s} )`), `texture( ${i}, ${n} )`);
  }
  generateTextureLevel(e, i, n, s) {
    return `textureLod( ${i}, ${n}, ${s} )`;
  }
  generateTextureBias(e, i, n, s) {
    return `texture( ${i}, ${n}, ${s} )`;
  }
  generateTextureGrad(e, i, n, s) {
    return `textureGrad( ${i}, ${n}, ${s[0]}, ${s[1]} )`;
  }
  generateTextureCompare(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `texture( ${i}, vec3( ${n}, ${s} ) )`;
    console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${o} shader.`);
  }
  getVars(e) {
    const i = [], n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`${this.getVar(s.type, s.name)};`);
    return i.join(`
	`);
  }
  getUniforms(e) {
    const i = this.uniforms[e], n = [], s = {};
    for (const o of i) {
      let l = null, u = !1;
      if (o.type === "texture") {
        const h = o.node.value;
        let d = "";
        h.isDataTexture === !0 && (h.type === Ji ? d = "u" : h.type === Tr && (d = "i")), h.compareFunction ? l = `sampler2DShadow ${o.name};` : h.isDataArrayTexture === !0 || h.isCompressedArrayTexture === !0 ? l = `${d}sampler2DArray ${o.name};` : l = `${d}sampler2D ${o.name};`;
      } else if (o.type === "cubeTexture")
        l = `samplerCube ${o.name};`;
      else if (o.type === "texture3D")
        l = `sampler3D ${o.name};`;
      else if (o.type === "buffer") {
        const h = o.node, d = this.getType(h.bufferType), p = h.bufferCount, f = p > 0 ? p : "";
        l = `${h.name} {
	${d} ${o.name}[${f}];
};
`;
      } else
        l = `${this.getVectorType(o.type)} ${this.getPropertyName(o, e)};`, u = !0;
      const c = o.node.precision;
      if (c !== null && (l = zZ[c] + " " + l), u) {
        l = "	" + l;
        const h = o.groupNode.name;
        (s[h] || (s[h] = [])).push(l);
      } else
        l = "uniform " + l, n.push(l);
    }
    let a = "";
    for (const o in s) {
      const l = s[o];
      a += this._getGLSLUniformStruct(e + "_" + o, l.join(`
`)) + `
`;
    }
    return a += n.join(`
`), a;
  }
  getTypeFromAttribute(e) {
    let i = super.getTypeFromAttribute(e);
    if (/^[iu]/.test(i) && e.gpuType !== Tr) {
      let n = e;
      e.isInterleavedBufferAttribute && (n = e.data);
      const s = n.array;
      s instanceof Uint32Array || s instanceof Int32Array || (i = i.slice(1));
    }
    return i;
  }
  getAttributes(e) {
    let i = "";
    if (e === "vertex" || e === "compute") {
      const n = this.getAttributesArray();
      let s = 0;
      for (const a of n)
        i += `layout( location = ${s++} ) in ${a.type} ${a.name};
`;
    }
    return i;
  }
  getStructMembers(e) {
    const i = [], n = e.getMemberTypes();
    for (let s = 0; s < n.length; s++) {
      const a = n[s];
      i.push(`layout( location = ${s} ) out ${a} m${s};`);
    }
    return i.join(`
`);
  }
  getStructs(e) {
    const i = [], n = this.structs[e];
    if (n.length === 0)
      return `layout( location = 0 ) out vec4 fragColor;
`;
    for (let s = 0, a = n.length; s < a; s++) {
      const o = n[s];
      let l = `
`;
      l += this.getStructMembers(o), l += `
`, i.push(l);
    }
    return i.join(`

`);
  }
  getVaryings(e) {
    let i = "";
    const n = this.varyings;
    if (e === "vertex" || e === "compute")
      for (const s of n) {
        e === "compute" && (s.needsInterpolation = !0);
        const a = s.type, o = a.includes("int") || a.includes("uv") || a.includes("iv") ? "flat " : "";
        i += `${o}${s.needsInterpolation ? "out" : "/*out*/"} ${a} ${s.name};
`;
      }
    else if (e === "fragment") {
      for (const s of n)
        if (s.needsInterpolation) {
          const a = s.type, o = a.includes("int") || a.includes("uv") || a.includes("iv") ? "flat " : "";
          i += `${o}in ${a} ${s.name};
`;
        }
    }
    return i;
  }
  getVertexIndex() {
    return "uint( gl_VertexID )";
  }
  getInstanceIndex() {
    return "uint( gl_InstanceID )";
  }
  getInvocationLocalIndex() {
    return `uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce((e, i) => e * i, 1)}u`;
  }
  getDrawIndex() {
    return this.renderer.backend.extensions.has("WEBGL_multi_draw") ? "uint( gl_DrawID )" : null;
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord.xy";
  }
  getFragDepth() {
    return "gl_FragDepth";
  }
  enableExtension(e, i, n = this.shaderStage) {
    const s = this.extensions[n] || (this.extensions[n] = /* @__PURE__ */ new Map());
    s.has(e) === !1 && s.set(e, {
      name: e,
      behavior: i
    });
  }
  getExtensions(e) {
    const i = [];
    if (e === "vertex") {
      const s = this.renderer.backend.extensions;
      this.object.isBatchedMesh && s.has("WEBGL_multi_draw") && this.enableExtension("GL_ANGLE_multi_draw", "require", e);
    }
    const n = this.extensions[e];
    if (n !== void 0)
      for (const { name: s, behavior: a } of n.values())
        i.push(`#extension ${s} : ${a}`);
    return i.join(`
`);
  }
  isAvailable(e) {
    let i = nA[e];
    if (i === void 0) {
      if (e === "float32Filterable") {
        const n = this.renderer.backend.extensions;
        n.has("OES_texture_float_linear") ? (n.get("OES_texture_float_linear"), i = !0) : i = !1;
      }
      nA[e] = i;
    }
    return i;
  }
  isFlipY() {
    return !0;
  }
  registerTransform(e, i) {
    this.transforms.push({ varyingName: e, attributeNode: i });
  }
  getTransforms() {
    const e = this.transforms;
    let i = "";
    for (let n = 0; n < e.length; n++) {
      const s = e[n], a = this.getPropertyName(s.attributeNode);
      i += `${s.varyingName} = ${a};
	`;
    }
    return i;
  }
  _getGLSLUniformStruct(e, i) {
    return `
layout( std140 ) uniform ${e} {
${i}
};`;
  }
  _getGLSLVertexCode(e) {
    return `#version 300 es

${this.getSignature()}

// extensions 
${e.extensions}

// precision
${sA}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// attributes
${e.attributes}

// codes
${e.codes}

void main() {

	// vars
	${e.vars}

	// transforms
	${e.transforms}

	// flow
	${e.flow}

	gl_PointSize = 1.0;

}
`;
  }
  _getGLSLFragmentCode(e) {
    return `#version 300 es

${this.getSignature()}

// precision
${sA}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// codes
${e.codes}

${e.structs}

void main() {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const i in e) {
      let n = `// code

`;
      n += this.flowCode[i];
      const s = this.flowNodes[i], a = s[s.length - 1];
      for (const l of s) {
        const u = this.getFlowData(
          l
          /*, shaderStage*/
        ), c = l.name;
        c && (n.length > 0 && (n += `
`), n += `	// flow -> ${c}
	`), n += `${u.code}
	`, l === a && i !== "compute" && (n += `// result
	`, i === "vertex" ? (n += "gl_Position = ", n += `${u.result};`) : i === "fragment" && (l.outputNode.isOutputStructNode || (n += "fragColor = ", n += `${u.result};`)));
      }
      const o = e[i];
      o.extensions = this.getExtensions(i), o.uniforms = this.getUniforms(i), o.attributes = this.getAttributes(i), o.varyings = this.getVaryings(i), o.vars = this.getVars(i), o.structs = this.getStructs(i), o.codes = this.getCodes(i), o.transforms = this.getTransforms(i), o.flow = n;
    }
    this.material !== null ? (this.vertexShader = this._getGLSLVertexCode(e.vertex), this.fragmentShader = this._getGLSLFragmentCode(e.fragment)) : this.computeShader = this._getGLSLVertexCode(e.compute);
  }
  getUniformFromNode(e, i, n, s = null) {
    const a = super.getUniformFromNode(e, i, n, s), o = this.getDataFromNode(e, n, this.globalCache);
    let l = o.uniformGPU;
    if (l === void 0) {
      const u = e.groupNode, c = u.name, h = this.getBindGroupArray(c, n);
      if (i === "texture")
        l = new jg(a.name, a.node, u), h.push(l);
      else if (i === "cubeTexture")
        l = new nO(a.name, a.node, u), h.push(l);
      else if (i === "texture3D")
        l = new sO(a.name, a.node, u), h.push(l);
      else if (i === "buffer") {
        e.name = `NodeBuffer_${e.id}`, a.name = `buffer${e.id}`;
        const d = new iO(e, u);
        d.name = e.name, h.push(d), l = d;
      } else {
        const d = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let p = d[c];
        p === void 0 && (p = new rO(n + "_" + c, u), d[c] = p, h.push(p)), l = this.getNodeUniform(a, i), p.addUniform(l);
      }
      o.uniformGPU = l;
    }
    return a;
  }
}
let dv = null, pv = null, wu = null;
class aO {
  constructor(e = {}) {
    this.parameters = Object.assign({}, e), this.data = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.domElement = null;
  }
  async init(e) {
    this.renderer = e;
  }
  // render context
  begin() {
  }
  finish() {
  }
  // render object
  draw() {
  }
  // program
  createProgram() {
  }
  destroyProgram() {
  }
  // bindings
  createBindings() {
  }
  updateBindings() {
  }
  // pipeline
  createRenderPipeline() {
  }
  createComputePipeline() {
  }
  destroyPipeline() {
  }
  // cache key
  needsRenderUpdate() {
  }
  // return Boolean ( fast test )
  getRenderCacheKey() {
  }
  // return String
  // node builder
  createNodeBuilder() {
  }
  // return NodeBuilder (ADD IT)
  // textures
  createSampler() {
  }
  createDefaultTexture() {
  }
  createTexture() {
  }
  copyTextureToBuffer() {
  }
  // attributes
  createAttribute() {
  }
  createIndexAttribute() {
  }
  updateAttribute() {
  }
  destroyAttribute() {
  }
  // canvas
  getContext() {
  }
  updateSize() {
  }
  // utils
  resolveTimestampAsync() {
  }
  hasFeatureAsync() {
  }
  // return Boolean
  hasFeature() {
  }
  // return Boolean
  getInstanceCount(e) {
    const { object: i, geometry: n } = e;
    return n.isInstancedBufferGeometry ? n.instanceCount : i.count > 1 ? i.count : 1;
  }
  getDrawingBufferSize() {
    return dv = dv || new jt(), this.renderer.getDrawingBufferSize(dv);
  }
  getScissor() {
    return pv = pv || new $t(), this.renderer.getScissor(pv);
  }
  setScissorTest() {
  }
  getClearColor() {
    const e = this.renderer;
    return wu = wu || new BT(), e.getClearColor(wu), wu.getRGB(wu, this.renderer.currentColorSpace), wu;
  }
  getDomElement() {
    let e = this.domElement;
    return e === null && (e = this.parameters.canvas !== void 0 ? this.parameters.canvas : C7(), "setAttribute" in e && e.setAttribute("data-engine", `three.js r${Ag} webgpu`), this.domElement = e), e;
  }
  // resource properties
  set(e, i) {
    this.data.set(e, i);
  }
  get(e) {
    let i = this.data.get(e);
    return i === void 0 && (i = {}, this.data.set(e, i)), i;
  }
  has(e) {
    return this.data.has(e);
  }
  delete(e) {
    this.data.delete(e);
  }
  dispose() {
  }
}
let VZ = 0;
class GZ {
  constructor(e, i) {
    this.buffers = [e.bufferGPU, i], this.type = e.type, this.bufferType = e.bufferType, this.pbo = e.pbo, this.byteLength = e.byteLength, this.bytesPerElement = e.BYTES_PER_ELEMENT, this.version = e.version, this.isInteger = e.isInteger, this.activeBufferIndex = 0, this.baseId = e.id;
  }
  get id() {
    return `${this.baseId}|${this.activeBufferIndex}`;
  }
  get bufferGPU() {
    return this.buffers[this.activeBufferIndex];
  }
  get transformBuffer() {
    return this.buffers[this.activeBufferIndex ^ 1];
  }
  switchBuffers() {
    this.activeBufferIndex ^= 1;
  }
}
class HZ {
  constructor(e) {
    this.backend = e;
  }
  createAttribute(e, i) {
    const n = this.backend, { gl: s } = n, a = e.array, o = e.usage || s.STATIC_DRAW, l = e.isInterleavedBufferAttribute ? e.data : e, u = n.get(l);
    let c = u.bufferGPU;
    c === void 0 && (c = this._createBuffer(s, i, a, o), u.bufferGPU = c, u.bufferType = i, u.version = l.version);
    let h;
    if (a instanceof Float32Array)
      h = s.FLOAT;
    else if (a instanceof Uint16Array)
      e.isFloat16BufferAttribute ? h = s.HALF_FLOAT : h = s.UNSIGNED_SHORT;
    else if (a instanceof Int16Array)
      h = s.SHORT;
    else if (a instanceof Uint32Array)
      h = s.UNSIGNED_INT;
    else if (a instanceof Int32Array)
      h = s.INT;
    else if (a instanceof Int8Array)
      h = s.BYTE;
    else if (a instanceof Uint8Array)
      h = s.UNSIGNED_BYTE;
    else if (a instanceof Uint8ClampedArray)
      h = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + a);
    let d = {
      bufferGPU: c,
      bufferType: i,
      type: h,
      byteLength: a.byteLength,
      bytesPerElement: a.BYTES_PER_ELEMENT,
      version: e.version,
      pbo: e.pbo,
      isInteger: h === s.INT || h === s.UNSIGNED_INT || e.gpuType === Tr,
      id: VZ++
    };
    if (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute) {
      const p = this._createBuffer(s, i, a, o);
      d = new GZ(d, p);
    }
    n.set(e, d);
  }
  updateAttribute(e) {
    const i = this.backend, { gl: n } = i, s = e.array, a = e.isInterleavedBufferAttribute ? e.data : e, o = i.get(a), l = o.bufferType, u = e.isInterleavedBufferAttribute ? e.data.updateRanges : e.updateRanges;
    if (n.bindBuffer(l, o.bufferGPU), u.length === 0)
      n.bufferSubData(l, 0, s);
    else {
      for (let c = 0, h = u.length; c < h; c++) {
        const d = u[c];
        n.bufferSubData(
          l,
          d.start * s.BYTES_PER_ELEMENT,
          s,
          d.start,
          d.count
        );
      }
      a.clearUpdateRanges();
    }
    n.bindBuffer(l, null), o.version = a.version;
  }
  destroyAttribute(e) {
    const i = this.backend, { gl: n } = i;
    e.isInterleavedBufferAttribute && i.delete(e.data);
    const s = i.get(e);
    n.deleteBuffer(s.bufferGPU), i.delete(e);
  }
  async getArrayBufferAsync(e) {
    const i = this.backend, { gl: n } = i, s = e.isInterleavedBufferAttribute ? e.data : e, { bufferGPU: a } = i.get(s), o = e.array, l = o.byteLength;
    n.bindBuffer(n.COPY_READ_BUFFER, a);
    const u = n.createBuffer();
    n.bindBuffer(n.COPY_WRITE_BUFFER, u), n.bufferData(n.COPY_WRITE_BUFFER, l, n.STREAM_READ), n.copyBufferSubData(n.COPY_READ_BUFFER, n.COPY_WRITE_BUFFER, 0, 0, l), await i.utils._clientWaitAsync();
    const c = new e.array.constructor(o.length);
    return n.bindBuffer(n.COPY_WRITE_BUFFER, u), n.getBufferSubData(n.COPY_WRITE_BUFFER, 0, c), n.deleteBuffer(u), n.bindBuffer(n.COPY_READ_BUFFER, null), n.bindBuffer(n.COPY_WRITE_BUFFER, null), c.buffer;
  }
  _createBuffer(e, i, n, s) {
    const a = e.createBuffer();
    return e.bindBuffer(i, a), e.bufferData(i, n, s), e.bindBuffer(i, null), a;
  }
}
let aA = !1, fv, Ch;
class WZ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.enabled = {}, this.currentFlipSided = null, this.currentCullFace = null, this.currentProgram = null, this.currentBlendingEnabled = !1, this.currentBlending = null, this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentPremultipledAlpha = null, this.currentPolygonOffsetFactor = null, this.currentPolygonOffsetUnits = null, this.currentColorMask = null, this.currentDepthFunc = null, this.currentDepthMask = null, this.currentStencilFunc = null, this.currentStencilRef = null, this.currentStencilFuncMask = null, this.currentStencilFail = null, this.currentStencilZFail = null, this.currentStencilZPass = null, this.currentStencilMask = null, this.currentLineWidth = null, this.currentBoundFramebuffers = {}, this.currentDrawbuffers = /* @__PURE__ */ new WeakMap(), this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), this.currentTextureSlot = null, this.currentBoundTextures = {}, this.currentBoundBufferBases = {}, aA === !1 && (this._init(this.gl), aA = !0);
  }
  _init(e) {
    fv = {
      [io]: e.FUNC_ADD,
      [DN]: e.FUNC_SUBTRACT,
      [kN]: e.FUNC_REVERSE_SUBTRACT
    }, Ch = {
      [LN]: e.ZERO,
      [UN]: e.ONE,
      [FN]: e.SRC_COLOR,
      [Om]: e.SRC_ALPHA,
      [HN]: e.SRC_ALPHA_SATURATE,
      [VN]: e.DST_COLOR,
      [zN]: e.DST_ALPHA,
      [BN]: e.ONE_MINUS_SRC_COLOR,
      [Im]: e.ONE_MINUS_SRC_ALPHA,
      [GN]: e.ONE_MINUS_DST_COLOR,
      [jN]: e.ONE_MINUS_DST_ALPHA
    };
  }
  enable(e) {
    const { enabled: i } = this;
    i[e] !== !0 && (this.gl.enable(e), i[e] = !0);
  }
  disable(e) {
    const { enabled: i } = this;
    i[e] !== !1 && (this.gl.disable(e), i[e] = !1);
  }
  setFlipSided(e) {
    if (this.currentFlipSided !== e) {
      const { gl: i } = this;
      e ? i.frontFace(i.CW) : i.frontFace(i.CCW), this.currentFlipSided = e;
    }
  }
  setCullFace(e) {
    const { gl: i } = this;
    e !== C9 ? (this.enable(i.CULL_FACE), e !== this.currentCullFace && (e === R9 ? i.cullFace(i.BACK) : e === N9 ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : this.disable(i.CULL_FACE), this.currentCullFace = e;
  }
  setLineWidth(e) {
    const { currentLineWidth: i, gl: n } = this;
    e !== i && (n.lineWidth(e), this.currentLineWidth = e);
  }
  setBlending(e, i, n, s, a, o, l, u) {
    const { gl: c } = this;
    if (e === _c) {
      this.currentBlendingEnabled === !0 && (this.disable(c.BLEND), this.currentBlendingEnabled = !1);
      return;
    }
    if (this.currentBlendingEnabled === !1 && (this.enable(c.BLEND), this.currentBlendingEnabled = !0), e !== IN) {
      if (e !== this.currentBlending || u !== this.currentPremultipledAlpha) {
        if ((this.currentBlendEquation !== io || this.currentBlendEquationAlpha !== io) && (c.blendEquation(c.FUNC_ADD), this.currentBlendEquation = io, this.currentBlendEquationAlpha = io), u)
          switch (e) {
            case po:
              c.blendFuncSeparate(c.ONE, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA);
              break;
            case Rm:
              c.blendFunc(c.ONE, c.ONE);
              break;
            case Nm:
              c.blendFuncSeparate(c.ZERO, c.ONE_MINUS_SRC_COLOR, c.ZERO, c.ONE);
              break;
            case Pm:
              c.blendFuncSeparate(c.ZERO, c.SRC_COLOR, c.ZERO, c.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
              break;
          }
        else
          switch (e) {
            case po:
              c.blendFuncSeparate(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA);
              break;
            case Rm:
              c.blendFunc(c.SRC_ALPHA, c.ONE);
              break;
            case Nm:
              c.blendFuncSeparate(c.ZERO, c.ONE_MINUS_SRC_COLOR, c.ZERO, c.ONE);
              break;
            case Pm:
              c.blendFunc(c.ZERO, c.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
              break;
          }
        this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentBlending = e, this.currentPremultipledAlpha = u;
      }
      return;
    }
    a = a || i, o = o || n, l = l || s, (i !== this.currentBlendEquation || a !== this.currentBlendEquationAlpha) && (c.blendEquationSeparate(fv[i], fv[a]), this.currentBlendEquation = i, this.currentBlendEquationAlpha = a), (n !== this.currentBlendSrc || s !== this.currentBlendDst || o !== this.currentBlendSrcAlpha || l !== this.currentBlendDstAlpha) && (c.blendFuncSeparate(Ch[n], Ch[s], Ch[o], Ch[l]), this.currentBlendSrc = n, this.currentBlendDst = s, this.currentBlendSrcAlpha = o, this.currentBlendDstAlpha = l), this.currentBlending = e, this.currentPremultipledAlpha = !1;
  }
  setColorMask(e) {
    this.currentColorMask !== e && (this.gl.colorMask(e, e, e, e), this.currentColorMask = e);
  }
  setDepthTest(e) {
    const { gl: i } = this;
    e ? this.enable(i.DEPTH_TEST) : this.disable(i.DEPTH_TEST);
  }
  setDepthMask(e) {
    this.currentDepthMask !== e && (this.gl.depthMask(e), this.currentDepthMask = e);
  }
  setDepthFunc(e) {
    if (this.currentDepthFunc !== e) {
      const { gl: i } = this;
      switch (e) {
        case WN:
          i.depthFunc(i.NEVER);
          break;
        case qN:
          i.depthFunc(i.ALWAYS);
          break;
        case XN:
          i.depthFunc(i.LESS);
          break;
        case Dm:
          i.depthFunc(i.LEQUAL);
          break;
        case YN:
          i.depthFunc(i.EQUAL);
          break;
        case $N:
          i.depthFunc(i.GEQUAL);
          break;
        case KN:
          i.depthFunc(i.GREATER);
          break;
        case QN:
          i.depthFunc(i.NOTEQUAL);
          break;
        default:
          i.depthFunc(i.LEQUAL);
      }
      this.currentDepthFunc = e;
    }
  }
  setStencilTest(e) {
    const { gl: i } = this;
    e ? this.enable(i.STENCIL_TEST) : this.disable(i.STENCIL_TEST);
  }
  setStencilMask(e) {
    this.currentStencilMask !== e && (this.gl.stencilMask(e), this.currentStencilMask = e);
  }
  setStencilFunc(e, i, n) {
    (this.currentStencilFunc !== e || this.currentStencilRef !== i || this.currentStencilFuncMask !== n) && (this.gl.stencilFunc(e, i, n), this.currentStencilFunc = e, this.currentStencilRef = i, this.currentStencilFuncMask = n);
  }
  setStencilOp(e, i, n) {
    (this.currentStencilFail !== e || this.currentStencilZFail !== i || this.currentStencilZPass !== n) && (this.gl.stencilOp(e, i, n), this.currentStencilFail = e, this.currentStencilZFail = i, this.currentStencilZPass = n);
  }
  setMaterial(e, i) {
    const { gl: n } = this;
    e.side === $u ? this.disable(n.CULL_FACE) : this.enable(n.CULL_FACE);
    let s = e.side === es;
    i && (s = !s), this.setFlipSided(s), e.blending === po && e.transparent === !1 ? this.setBlending(_c) : this.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), this.setDepthFunc(e.depthFunc), this.setDepthTest(e.depthTest), this.setDepthMask(e.depthWrite), this.setColorMask(e.colorWrite);
    const a = e.stencilWrite;
    this.setStencilTest(a), a && (this.setStencilMask(e.stencilWriteMask), this.setStencilFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), this.setStencilOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), this.setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), e.alphaToCoverage === !0 && this.backend.renderer.samples > 1 ? this.enable(n.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  setPolygonOffset(e, i, n) {
    const { gl: s } = this;
    e ? (this.enable(s.POLYGON_OFFSET_FILL), (this.currentPolygonOffsetFactor !== i || this.currentPolygonOffsetUnits !== n) && (s.polygonOffset(i, n), this.currentPolygonOffsetFactor = i, this.currentPolygonOffsetUnits = n)) : this.disable(s.POLYGON_OFFSET_FILL);
  }
  useProgram(e) {
    return this.currentProgram !== e ? (this.gl.useProgram(e), this.currentProgram = e, !0) : !1;
  }
  // framebuffer
  bindFramebuffer(e, i) {
    const { gl: n, currentBoundFramebuffers: s } = this;
    return s[e] !== i ? (n.bindFramebuffer(e, i), s[e] = i, e === n.DRAW_FRAMEBUFFER && (s[n.FRAMEBUFFER] = i), e === n.FRAMEBUFFER && (s[n.DRAW_FRAMEBUFFER] = i), !0) : !1;
  }
  drawBuffers(e, i) {
    const { gl: n } = this;
    let s = [], a = !1;
    if (e.textures !== null) {
      s = this.currentDrawbuffers.get(i), s === void 0 && (s = [], this.currentDrawbuffers.set(i, s));
      const o = e.textures;
      if (s.length !== o.length || s[0] !== n.COLOR_ATTACHMENT0) {
        for (let l = 0, u = o.length; l < u; l++)
          s[l] = n.COLOR_ATTACHMENT0 + l;
        s.length = o.length, a = !0;
      }
    } else
      s[0] !== n.BACK && (s[0] = n.BACK, a = !0);
    a && n.drawBuffers(s);
  }
  // texture
  activeTexture(e) {
    const { gl: i, currentTextureSlot: n, maxTextures: s } = this;
    e === void 0 && (e = i.TEXTURE0 + s - 1), n !== e && (i.activeTexture(e), this.currentTextureSlot = e);
  }
  bindTexture(e, i, n) {
    const { gl: s, currentTextureSlot: a, currentBoundTextures: o, maxTextures: l } = this;
    n === void 0 && (a === null ? n = s.TEXTURE0 + l - 1 : n = a);
    let u = o[n];
    u === void 0 && (u = { type: void 0, texture: void 0 }, o[n] = u), (u.type !== e || u.texture !== i) && (a !== n && (s.activeTexture(n), this.currentTextureSlot = n), s.bindTexture(e, i), u.type = e, u.texture = i);
  }
  bindBufferBase(e, i, n) {
    const { gl: s } = this, a = `${e}-${i}`;
    return this.currentBoundBufferBases[a] !== n ? (s.bindBufferBase(e, i, n), this.currentBoundBufferBases[a] = n, !0) : !1;
  }
  unbindTexture() {
    const { gl: e, currentTextureSlot: i, currentBoundTextures: n } = this, s = n[i];
    s !== void 0 && s.type !== void 0 && (e.bindTexture(s.type, null), s.type = void 0, s.texture = void 0);
  }
}
class qZ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.extensions = e.extensions;
  }
  convert(e, i = El) {
    const { gl: n, extensions: s } = this;
    let a;
    if (e === fo) return n.UNSIGNED_BYTE;
    if (e === V9) return n.UNSIGNED_SHORT_4_4_4_4;
    if (e === G9) return n.UNSIGNED_SHORT_5_5_5_1;
    if (e === ZN) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (e === Jh) return n.BYTE;
    if (e === ed) return n.SHORT;
    if (e === Uu) return n.UNSIGNED_SHORT;
    if (e === Tr) return n.INT;
    if (e === Ji) return n.UNSIGNED_INT;
    if (e === cn) return n.FLOAT;
    if (e === ga)
      return n.HALF_FLOAT;
    if (e === H9) return n.ALPHA;
    if (e === nT) return n.RGB;
    if (e === Fc) return n.RGBA;
    if (e === W9) return n.LUMINANCE;
    if (e === q9) return n.LUMINANCE_ALPHA;
    if (e === vl) return n.DEPTH_COMPONENT;
    if (e === Sc) return n.DEPTH_STENCIL;
    if (e === sT) return n.RED;
    if (e === aT) return n.RED_INTEGER;
    if (e === yd) return n.RG;
    if (e === oT) return n.RG_INTEGER;
    if (e === lT) return n.RGBA_INTEGER;
    if (e === p0 || e === tm || e === im || e === rm)
      if (i === ht)
        if (a = s.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (e === p0) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (e === tm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (e === im) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (e === rm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = s.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (e === p0) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (e === tm) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (e === im) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (e === rm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (e === _E || e === TE || e === SE || e === wE)
      if (a = s.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (e === _E) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (e === TE) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (e === SE) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (e === wE) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (e === EE || e === tx || e === ix)
      if (a = s.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (e === EE || e === tx) return i === ht ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (e === ix) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (e === rx || e === nx || e === sx || e === ax || e === ox || e === lx || e === ux || e === cx || e === hx || e === dx || e === px || e === fx || e === mx || e === gx)
      if (a = s.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (e === rx) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (e === nx) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (e === sx) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (e === ax) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (e === ox) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (e === lx) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (e === ux) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (e === cx) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (e === hx) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (e === dx) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (e === px) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (e === fx) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (e === mx) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (e === gx) return i === ht ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (e === f0)
      if (a = s.get("EXT_texture_compression_bptc"), a !== null) {
        if (e === f0) return i === ht ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    if (e === Y9 || e === ME || e === AE || e === CE)
      if (a = s.get("EXT_texture_compression_rgtc"), a !== null) {
        if (e === f0) return a.COMPRESSED_RED_RGTC1_EXT;
        if (e === ME) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (e === AE) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (e === CE) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return e === $d ? n.UNSIGNED_INT_24_8 : n[e] !== void 0 ? n[e] : null;
  }
  _clientWaitAsync() {
    const { gl: e } = this, i = e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE, 0);
    return e.flush(), new Promise((n, s) => {
      function a() {
        const o = e.clientWaitSync(i, e.SYNC_FLUSH_COMMANDS_BIT, 0);
        if (o === e.WAIT_FAILED) {
          e.deleteSync(i), s();
          return;
        }
        if (o === e.TIMEOUT_EXPIRED) {
          requestAnimationFrame(a);
          return;
        }
        e.deleteSync(i), n();
      }
      a();
    });
  }
}
let oA = !1, Ef, mv, lA;
class XZ {
  constructor(e) {
    this.backend = e, this.gl = e.gl, this.extensions = e.extensions, this.defaultTextures = {}, oA === !1 && (this._init(this.gl), oA = !0);
  }
  _init(e) {
    Ef = {
      [km]: e.REPEAT,
      [Lu]: e.CLAMP_TO_EDGE,
      [Lm]: e.MIRRORED_REPEAT
    }, mv = {
      [mr]: e.NEAREST,
      [Jb]: e.NEAREST_MIPMAP_NEAREST,
      [Qu]: e.NEAREST_MIPMAP_LINEAR,
      [hn]: e.LINEAR,
      [ex]: e.LINEAR_MIPMAP_NEAREST,
      [ma]: e.LINEAR_MIPMAP_LINEAR
    }, lA = {
      [eP]: e.NEVER,
      [aP]: e.ALWAYS,
      [uT]: e.LESS,
      [iP]: e.LEQUAL,
      [tP]: e.EQUAL,
      [sP]: e.GEQUAL,
      [rP]: e.GREATER,
      [nP]: e.NOTEQUAL
    };
  }
  filterFallback(e) {
    const { gl: i } = this;
    return e === mr || e === Jb || e === Qu ? i.NEAREST : i.LINEAR;
  }
  getGLTextureType(e) {
    const { gl: i } = this;
    let n;
    return e.isCubeTexture === !0 ? n = i.TEXTURE_CUBE_MAP : e.isDataArrayTexture === !0 || e.isCompressedArrayTexture === !0 ? n = i.TEXTURE_2D_ARRAY : e.isData3DTexture === !0 ? n = i.TEXTURE_3D : n = i.TEXTURE_2D, n;
  }
  getInternalFormat(e, i, n, s, a = !1) {
    const { gl: o, extensions: l } = this;
    if (e !== null) {
      if (o[e] !== void 0) return o[e];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e + "'");
    }
    let u = i;
    return i === o.RED && (n === o.FLOAT && (u = o.R32F), n === o.HALF_FLOAT && (u = o.R16F), n === o.UNSIGNED_BYTE && (u = o.R8), n === o.UNSIGNED_SHORT && (u = o.R16), n === o.UNSIGNED_INT && (u = o.R32UI), n === o.BYTE && (u = o.R8I), n === o.SHORT && (u = o.R16I), n === o.INT && (u = o.R32I)), i === o.RED_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.R8UI), n === o.UNSIGNED_SHORT && (u = o.R16UI), n === o.UNSIGNED_INT && (u = o.R32UI), n === o.BYTE && (u = o.R8I), n === o.SHORT && (u = o.R16I), n === o.INT && (u = o.R32I)), i === o.RG && (n === o.FLOAT && (u = o.RG32F), n === o.HALF_FLOAT && (u = o.RG16F), n === o.UNSIGNED_BYTE && (u = o.RG8), n === o.UNSIGNED_SHORT && (u = o.RG16), n === o.UNSIGNED_INT && (u = o.RG32UI), n === o.BYTE && (u = o.RG8I), n === o.SHORT && (u = o.RG16I), n === o.INT && (u = o.RG32I)), i === o.RG_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RG8UI), n === o.UNSIGNED_SHORT && (u = o.RG16UI), n === o.UNSIGNED_INT && (u = o.RG32UI), n === o.BYTE && (u = o.RG8I), n === o.SHORT && (u = o.RG16I), n === o.INT && (u = o.RG32I)), i === o.RGB && (n === o.FLOAT && (u = o.RGB32F), n === o.HALF_FLOAT && (u = o.RGB16F), n === o.UNSIGNED_BYTE && (u = o.RGB8), n === o.UNSIGNED_SHORT && (u = o.RGB16), n === o.UNSIGNED_INT && (u = o.RGB32UI), n === o.BYTE && (u = o.RGB8I), n === o.SHORT && (u = o.RGB16I), n === o.INT && (u = o.RGB32I), n === o.UNSIGNED_BYTE && (u = s === ht && a === !1 ? o.SRGB8 : o.RGB8), n === o.UNSIGNED_SHORT_5_6_5 && (u = o.RGB565), n === o.UNSIGNED_SHORT_5_5_5_1 && (u = o.RGB5_A1), n === o.UNSIGNED_SHORT_4_4_4_4 && (u = o.RGB4), n === o.UNSIGNED_INT_5_9_9_9_REV && (u = o.RGB9_E5)), i === o.RGB_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RGB8UI), n === o.UNSIGNED_SHORT && (u = o.RGB16UI), n === o.UNSIGNED_INT && (u = o.RGB32UI), n === o.BYTE && (u = o.RGB8I), n === o.SHORT && (u = o.RGB16I), n === o.INT && (u = o.RGB32I)), i === o.RGBA && (n === o.FLOAT && (u = o.RGBA32F), n === o.HALF_FLOAT && (u = o.RGBA16F), n === o.UNSIGNED_BYTE && (u = o.RGBA8), n === o.UNSIGNED_SHORT && (u = o.RGBA16), n === o.UNSIGNED_INT && (u = o.RGBA32UI), n === o.BYTE && (u = o.RGBA8I), n === o.SHORT && (u = o.RGBA16I), n === o.INT && (u = o.RGBA32I), n === o.UNSIGNED_BYTE && (u = s === ht && a === !1 ? o.SRGB8_ALPHA8 : o.RGBA8), n === o.UNSIGNED_SHORT_4_4_4_4 && (u = o.RGBA4), n === o.UNSIGNED_SHORT_5_5_5_1 && (u = o.RGB5_A1)), i === o.RGBA_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RGBA8UI), n === o.UNSIGNED_SHORT && (u = o.RGBA16UI), n === o.UNSIGNED_INT && (u = o.RGBA32UI), n === o.BYTE && (u = o.RGBA8I), n === o.SHORT && (u = o.RGBA16I), n === o.INT && (u = o.RGBA32I)), i === o.DEPTH_COMPONENT && (n === o.UNSIGNED_INT && (u = o.DEPTH24_STENCIL8), n === o.FLOAT && (u = o.DEPTH_COMPONENT32F)), i === o.DEPTH_STENCIL && n === o.UNSIGNED_INT_24_8 && (u = o.DEPTH24_STENCIL8), (u === o.R16F || u === o.R32F || u === o.RG16F || u === o.RG32F || u === o.RGBA16F || u === o.RGBA32F) && l.get("EXT_color_buffer_float"), u;
  }
  setTextureParameters(e, i) {
    const { gl: n, extensions: s, backend: a } = this;
    n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, i.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, i.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE), n.texParameteri(e, n.TEXTURE_WRAP_S, Ef[i.wrapS]), n.texParameteri(e, n.TEXTURE_WRAP_T, Ef[i.wrapT]), (e === n.TEXTURE_3D || e === n.TEXTURE_2D_ARRAY) && n.texParameteri(e, n.TEXTURE_WRAP_R, Ef[i.wrapR]), n.texParameteri(e, n.TEXTURE_MAG_FILTER, mv[i.magFilter]);
    const o = i.mipmaps !== void 0 && i.mipmaps.length > 0, l = i.minFilter === hn && o ? ma : i.minFilter;
    if (n.texParameteri(e, n.TEXTURE_MIN_FILTER, mv[l]), i.compareFunction && (n.texParameteri(e, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(e, n.TEXTURE_COMPARE_FUNC, lA[i.compareFunction])), s.has("EXT_texture_filter_anisotropic") === !0) {
      if (i.magFilter === mr || i.minFilter !== Qu && i.minFilter !== ma || i.type === cn && s.has("OES_texture_float_linear") === !1) return;
      if (i.anisotropy > 1) {
        const u = s.get("EXT_texture_filter_anisotropic");
        n.texParameterf(e, u.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i.anisotropy, a.getMaxAnisotropy()));
      }
    }
  }
  createDefaultTexture(e) {
    const { gl: i, backend: n, defaultTextures: s } = this, a = this.getGLTextureType(e);
    let o = s[a];
    o === void 0 && (o = i.createTexture(), n.state.bindTexture(a, o), i.texParameteri(a, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(a, i.TEXTURE_MAG_FILTER, i.NEAREST), s[a] = o), n.set(e, {
      textureGPU: o,
      glTextureType: a,
      isDefault: !0
    });
  }
  createTexture(e, i) {
    const { gl: n, backend: s } = this, { levels: a, width: o, height: l, depth: u } = i, c = s.utils.convert(e.format, e.colorSpace), h = s.utils.convert(e.type), d = this.getInternalFormat(e.internalFormat, c, h, e.colorSpace, e.isVideoTexture), p = n.createTexture(), f = this.getGLTextureType(e);
    s.state.bindTexture(f, p), this.setTextureParameters(f, e), e.isDataArrayTexture || e.isCompressedArrayTexture ? n.texStorage3D(n.TEXTURE_2D_ARRAY, a, d, o, l, u) : e.isData3DTexture ? n.texStorage3D(n.TEXTURE_3D, a, d, o, l, u) : e.isVideoTexture || n.texStorage2D(f, a, d, o, l), s.set(e, {
      textureGPU: p,
      glTextureType: f,
      glFormat: c,
      glType: h,
      glInternalFormat: d
    });
  }
  copyBufferToTexture(e, i) {
    const { gl: n, backend: s } = this, { textureGPU: a, glTextureType: o, glFormat: l, glType: u } = s.get(i), { width: c, height: h } = i.source.data;
    n.bindBuffer(n.PIXEL_UNPACK_BUFFER, e), s.state.bindTexture(o, a), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), n.texSubImage2D(o, 0, 0, 0, c, h, l, u, 0), n.bindBuffer(n.PIXEL_UNPACK_BUFFER, null), s.state.unbindTexture();
  }
  updateTexture(e, i) {
    const { gl: n } = this, { width: s, height: a } = i, { textureGPU: o, glTextureType: l, glFormat: u, glType: c, glInternalFormat: h } = this.backend.get(e);
    if (e.isRenderTargetTexture || o === void 0)
      return;
    const d = (p) => p.isDataTexture ? p.image.data : p instanceof ImageBitmap || p instanceof OffscreenCanvas || p instanceof HTMLImageElement || p instanceof HTMLCanvasElement ? p : p.data;
    if (this.backend.state.bindTexture(l, o), this.setTextureParameters(l, e), e.isCompressedTexture) {
      const p = e.mipmaps, f = i.image;
      for (let m = 0; m < p.length; m++) {
        const v = p[m];
        e.isCompressedArrayTexture ? e.format !== n.RGBA ? u !== null ? n.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, m, 0, 0, 0, v.width, v.height, f.depth, u, v.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texSubImage3D(n.TEXTURE_2D_ARRAY, m, 0, 0, 0, v.width, v.height, f.depth, u, c, v.data) : u !== null ? n.compressedTexSubImage2D(n.TEXTURE_2D, m, 0, 0, v.width, v.height, u, v.data) : console.warn("Unsupported compressed texture format");
      }
    } else if (e.isCubeTexture) {
      const p = i.images;
      for (let f = 0; f < 6; f++) {
        const m = d(p[f]);
        n.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, 0, 0, s, a, u, c, m);
      }
    } else if (e.isDataArrayTexture) {
      const p = i.image;
      n.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, u, c, p.data);
    } else if (e.isData3DTexture) {
      const p = i.image;
      n.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, u, c, p.data);
    } else if (e.isVideoTexture)
      e.update(), n.texImage2D(l, 0, h, u, c, i.image);
    else {
      const p = d(i.image);
      n.texSubImage2D(l, 0, 0, 0, s, a, u, c, p);
    }
  }
  generateMipmaps(e) {
    const { gl: i, backend: n } = this, { textureGPU: s, glTextureType: a } = n.get(e);
    n.state.bindTexture(a, s), i.generateMipmap(a);
  }
  deallocateRenderBuffers(e) {
    const { gl: i, backend: n } = this;
    if (e) {
      const s = n.get(e);
      if (s.renderBufferStorageSetup = void 0, s.framebuffers) {
        for (const a in s.framebuffers)
          i.deleteFramebuffer(s.framebuffers[a]);
        delete s.framebuffers;
      }
      if (s.depthRenderbuffer && (i.deleteRenderbuffer(s.depthRenderbuffer), delete s.depthRenderbuffer), s.stencilRenderbuffer && (i.deleteRenderbuffer(s.stencilRenderbuffer), delete s.stencilRenderbuffer), s.msaaFrameBuffer && (i.deleteFramebuffer(s.msaaFrameBuffer), delete s.msaaFrameBuffer), s.msaaRenderbuffers) {
        for (let a = 0; a < s.msaaRenderbuffers.length; a++)
          i.deleteRenderbuffer(s.msaaRenderbuffers[a]);
        delete s.msaaRenderbuffers;
      }
    }
  }
  destroyTexture(e) {
    const { gl: i, backend: n } = this, { textureGPU: s, renderTarget: a } = n.get(e);
    this.deallocateRenderBuffers(a), i.deleteTexture(s), n.delete(e);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    const { gl: o, backend: l } = this, { state: u } = this.backend, { textureGPU: c, glTextureType: h, glType: d, glFormat: p } = l.get(i);
    let f, m, v, y, g, _;
    n !== null ? (f = n.max.x - n.min.x, m = n.max.y - n.min.y, v = n.min.x, y = n.min.y) : (f = e.image.width, m = e.image.height, v = 0, y = 0), s !== null ? (g = s.x, _ = s.y) : (g = 0, _ = 0), u.bindTexture(h, c), o.pixelStorei(o.UNPACK_ALIGNMENT, i.unpackAlignment), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, i.flipY), o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), o.pixelStorei(o.UNPACK_ALIGNMENT, i.unpackAlignment);
    const x = o.getParameter(o.UNPACK_ROW_LENGTH), b = o.getParameter(o.UNPACK_IMAGE_HEIGHT), T = o.getParameter(o.UNPACK_SKIP_PIXELS), S = o.getParameter(o.UNPACK_SKIP_ROWS), w = o.getParameter(o.UNPACK_SKIP_IMAGES), C = e.isCompressedTexture ? e.mipmaps[a] : e.image;
    if (o.pixelStorei(o.UNPACK_ROW_LENGTH, C.width), o.pixelStorei(o.UNPACK_IMAGE_HEIGHT, C.height), o.pixelStorei(o.UNPACK_SKIP_PIXELS, v), o.pixelStorei(o.UNPACK_SKIP_ROWS, y), e.isRenderTargetTexture || e.isDepthTexture) {
      const E = l.get(e), A = l.get(i), N = l.get(E.renderTarget), L = l.get(A.renderTarget), F = N.framebuffers[E.cacheKey], M = L.framebuffers[A.cacheKey];
      u.bindFramebuffer(o.READ_FRAMEBUFFER, F), u.bindFramebuffer(o.DRAW_FRAMEBUFFER, M);
      let P = o.COLOR_BUFFER_BIT;
      e.isDepthTexture && (P = o.DEPTH_BUFFER_BIT), o.blitFramebuffer(v, y, f, m, g, _, f, m, P, o.NEAREST), u.bindFramebuffer(o.READ_FRAMEBUFFER, null), u.bindFramebuffer(o.DRAW_FRAMEBUFFER, null);
    } else
      e.isDataTexture ? o.texSubImage2D(o.TEXTURE_2D, a, g, _, f, m, p, d, C.data) : e.isCompressedTexture ? o.compressedTexSubImage2D(o.TEXTURE_2D, a, g, _, C.width, C.height, p, C.data) : o.texSubImage2D(o.TEXTURE_2D, a, g, _, f, m, p, d, C);
    o.pixelStorei(o.UNPACK_ROW_LENGTH, x), o.pixelStorei(o.UNPACK_IMAGE_HEIGHT, b), o.pixelStorei(o.UNPACK_SKIP_PIXELS, T), o.pixelStorei(o.UNPACK_SKIP_ROWS, S), o.pixelStorei(o.UNPACK_SKIP_IMAGES, w), a === 0 && i.generateMipmaps && o.generateMipmap(o.TEXTURE_2D), u.unbindTexture();
  }
  copyFramebufferToTexture(e, i, n) {
    const { gl: s } = this, { state: a } = this.backend, { textureGPU: o } = this.backend.get(e), { x: l, y: u, z: c, w: h } = n, d = e.isDepthTexture === !0 || i.renderTarget && i.renderTarget.samples > 0, p = i.renderTarget ? i.renderTarget.height : this.backend.gerDrawingBufferSize().y;
    if (d) {
      const f = l !== 0 || u !== 0;
      let m, v;
      if (e.isDepthTexture === !0 ? (m = s.DEPTH_BUFFER_BIT, v = s.DEPTH_ATTACHMENT, i.stencil && (m |= s.STENCIL_BUFFER_BIT)) : (m = s.COLOR_BUFFER_BIT, v = s.COLOR_ATTACHMENT0), f) {
        const y = this.backend.get(i.renderTarget), g = y.framebuffers[i.getCacheKey()], _ = y.msaaFrameBuffer;
        a.bindFramebuffer(s.DRAW_FRAMEBUFFER, g), a.bindFramebuffer(s.READ_FRAMEBUFFER, _);
        const x = p - u - h;
        s.blitFramebuffer(l, x, l + c, x + h, l, x, l + c, x + h, m, s.NEAREST), a.bindFramebuffer(s.READ_FRAMEBUFFER, g), a.bindTexture(s.TEXTURE_2D, o), s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, l, x, c, h), a.unbindTexture();
      } else {
        const y = s.createFramebuffer();
        a.bindFramebuffer(s.DRAW_FRAMEBUFFER, y), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, v, s.TEXTURE_2D, o, 0), s.blitFramebuffer(0, 0, c, h, 0, 0, c, h, m, s.NEAREST), s.deleteFramebuffer(y);
      }
    } else
      a.bindTexture(s.TEXTURE_2D, o), s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, l, p - h - u, c, h), a.unbindTexture();
    e.generateMipmaps && this.generateMipmaps(e), this.backend._setFramebuffer(i);
  }
  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  setupRenderBufferStorage(e, i) {
    const { gl: n } = this, s = i.renderTarget, { samples: a, depthTexture: o, depthBuffer: l, stencilBuffer: u, width: c, height: h } = s;
    if (n.bindRenderbuffer(n.RENDERBUFFER, e), l && !u) {
      let d = n.DEPTH_COMPONENT24;
      a > 0 ? (o && o.isDepthTexture && o.type === n.FLOAT && (d = n.DEPTH_COMPONENT32F), n.renderbufferStorageMultisample(n.RENDERBUFFER, a, d, c, h)) : n.renderbufferStorage(n.RENDERBUFFER, d, c, h), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, e);
    } else l && u && (a > 0 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, a, n.DEPTH24_STENCIL8, c, h) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, c, h), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, e));
  }
  async copyTextureToBuffer(e, i, n, s, a, o) {
    const { backend: l, gl: u } = this, { textureGPU: c, glFormat: h, glType: d } = this.backend.get(e), p = u.createFramebuffer();
    u.bindFramebuffer(u.READ_FRAMEBUFFER, p);
    const f = e.isCubeTexture ? u.TEXTURE_CUBE_MAP_POSITIVE_X + o : u.TEXTURE_2D;
    u.framebufferTexture2D(u.READ_FRAMEBUFFER, u.COLOR_ATTACHMENT0, f, c, 0);
    const m = this._getTypedArrayType(d), v = this._getBytesPerTexel(d, h), y = s * a * v, g = u.createBuffer();
    u.bindBuffer(u.PIXEL_PACK_BUFFER, g), u.bufferData(u.PIXEL_PACK_BUFFER, y, u.STREAM_READ), u.readPixels(i, n, s, a, h, d, 0), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), await l.utils._clientWaitAsync();
    const _ = new m(y / m.BYTES_PER_ELEMENT);
    return u.bindBuffer(u.PIXEL_PACK_BUFFER, g), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, _), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), u.deleteFramebuffer(p), _;
  }
  _getTypedArrayType(e) {
    const { gl: i } = this;
    if (e === i.UNSIGNED_BYTE) return Uint8Array;
    if (e === i.UNSIGNED_SHORT_4_4_4_4 || e === i.UNSIGNED_SHORT_5_5_5_1 || e === i.UNSIGNED_SHORT_5_6_5 || e === i.UNSIGNED_SHORT) return Uint16Array;
    if (e === i.UNSIGNED_INT) return Uint32Array;
    if (e === i.HALF_FLOAT) return Uint16Array;
    if (e === i.FLOAT) return Float32Array;
    throw new Error(`Unsupported WebGL type: ${e}`);
  }
  _getBytesPerTexel(e, i) {
    const { gl: n } = this;
    let s = 0;
    if (e === n.UNSIGNED_BYTE && (s = 1), (e === n.UNSIGNED_SHORT_4_4_4_4 || e === n.UNSIGNED_SHORT_5_5_5_1 || e === n.UNSIGNED_SHORT_5_6_5 || e === n.UNSIGNED_SHORT || e === n.HALF_FLOAT) && (s = 2), (e === n.UNSIGNED_INT || e === n.FLOAT) && (s = 4), i === n.RGBA) return s * 4;
    if (i === n.RGB) return s * 3;
    if (i === n.ALPHA) return s;
  }
}
class YZ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.availableExtensions = this.gl.getSupportedExtensions(), this.extensions = {};
  }
  get(e) {
    let i = this.extensions[e];
    return i === void 0 && (i = this.gl.getExtension(e), this.extensions[e] = i), i;
  }
  has(e) {
    return this.availableExtensions.includes(e);
  }
}
class $Z {
  constructor(e) {
    this.backend = e, this.maxAnisotropy = null;
  }
  getMaxAnisotropy() {
    if (this.maxAnisotropy !== null) return this.maxAnisotropy;
    const e = this.backend.gl, i = this.backend.extensions;
    if (i.has("EXT_texture_filter_anisotropic") === !0) {
      const n = i.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      this.maxAnisotropy = 0;
    return this.maxAnisotropy;
  }
}
const uA = {
  WEBGL_multi_draw: "WEBGL_multi_draw",
  WEBGL_compressed_texture_astc: "texture-compression-astc",
  WEBGL_compressed_texture_etc: "texture-compression-etc2",
  WEBGL_compressed_texture_etc1: "texture-compression-etc1",
  WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBKIT_WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBGL_compressed_texture_s3tc: "texture-compression-bc",
  EXT_texture_compression_bptc: "texture-compression-bptc",
  EXT_disjoint_timer_query_webgl2: "timestamp-query"
};
class KZ {
  constructor(e) {
    this.gl = e.gl, this.extensions = e.extensions, this.info = e.renderer.info, this.mode = null, this.index = 0, this.type = null, this.object = null;
  }
  render(e, i) {
    const { gl: n, mode: s, object: a, type: o, info: l, index: u } = this;
    u !== 0 ? n.drawElements(s, i, o, e) : n.drawArrays(s, e, i), l.update(a, i, s, 1);
  }
  renderInstances(e, i, n) {
    const { gl: s, mode: a, type: o, index: l, object: u, info: c } = this;
    n !== 0 && (l !== 0 ? s.drawElementsInstanced(a, i, o, e, n) : s.drawArraysInstanced(a, e, i, n), c.update(u, i, a, n));
  }
  renderMultiDraw(e, i, n) {
    const { extensions: s, mode: a, object: o, info: l } = this;
    if (n === 0) return;
    const u = s.get("WEBGL_multi_draw");
    if (u === null)
      for (let c = 0; c < n; c++)
        this.render(e[c], i[c]);
    else {
      this.index !== 0 ? u.multiDrawElementsWEBGL(a, i, 0, this.type, e, 0, n) : u.multiDrawArraysWEBGL(a, e, 0, i, 0, n);
      let c = 0;
      for (let h = 0; h < n; h++)
        c += i[h];
      l.update(o, c, a, 1);
    }
  }
  renderMultiDrawInstances(e, i, n, s) {
    const { extensions: a, mode: o, object: l, info: u } = this;
    if (n === 0) return;
    const c = a.get("WEBGL_multi_draw");
    if (c === null)
      for (let h = 0; h < n; h++)
        this.renderInstances(e[h], i[h], s[h]);
    else {
      this.index !== 0 ? c.multiDrawElementsInstancedWEBGL(o, i, 0, this.type, e, 0, s, 0, n) : c.multiDrawArraysInstancedWEBGL(o, e, 0, i, 0, s, 0, n);
      let h = 0;
      for (let d = 0; d < n; d++)
        h += i[d] * s[d];
      u.update(l, h, o, 1);
    }
  }
  //
}
class cA extends aO {
  constructor(e = {}) {
    super(e), this.isWebGLBackend = !0;
  }
  init(e) {
    super.init(e);
    const i = this.parameters, n = i.context !== void 0 ? i.context : e.domElement.getContext("webgl2");
    function s(a) {
      a.preventDefault();
      const o = {
        api: "WebGL",
        message: a.statusMessage || "Unknown reason",
        reason: null,
        originalEvent: a
      };
      e.onDeviceLost(o);
    }
    this._onContextLost = s, e.domElement.addEventListener("webglcontextlost", s, !1), this.gl = n, this.extensions = new YZ(this), this.capabilities = new $Z(this), this.attributeUtils = new HZ(this), this.textureUtils = new XZ(this), this.bufferRenderer = new KZ(this), this.state = new WZ(this), this.utils = new qZ(this), this.vaoCache = {}, this.transformFeedbackCache = {}, this.discard = !1, this.trackTimestamp = i.trackTimestamp === !0, this.extensions.get("EXT_color_buffer_float"), this.extensions.get("WEBGL_clip_cull_distance"), this.extensions.get("OES_texture_float_linear"), this.extensions.get("EXT_color_buffer_half_float"), this.extensions.get("WEBGL_multisampled_render_to_texture"), this.extensions.get("WEBGL_render_shared_exponent"), this.extensions.get("WEBGL_multi_draw"), this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2"), this.parallel = this.extensions.get("KHR_parallel_shader_compile"), this._knownBindings = /* @__PURE__ */ new WeakSet(), this._currentContext = null;
  }
  get coordinateSystem() {
    return Zn;
  }
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  async waitForGPU() {
    await this.utils._clientWaitAsync();
  }
  initTimestampQuery(e) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const i = this.get(e);
    if (this.queryRunning) {
      i.queryQueue || (i.queryQueue = []), i.queryQueue.push(e);
      return;
    }
    i.activeQuery && (this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT), i.activeQuery = null), i.activeQuery = this.gl.createQuery(), i.activeQuery !== null && (this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT, i.activeQuery), this.queryRunning = !0);
  }
  // timestamp utils
  prepareTimestampBuffer(e) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const i = this.get(e);
    if (i.activeQuery && (this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT), i.gpuQueries || (i.gpuQueries = []), i.gpuQueries.push({ query: i.activeQuery }), i.activeQuery = null, this.queryRunning = !1, i.queryQueue && i.queryQueue.length > 0)) {
      const n = i.queryQueue.shift();
      this.initTimestampQuery(n);
    }
  }
  async resolveTimestampAsync(e, i = "render") {
    if (!this.disjoint || !this.trackTimestamp) return;
    const n = this.get(e);
    n.gpuQueries || (n.gpuQueries = []);
    for (let s = 0; s < n.gpuQueries.length; s++) {
      const a = n.gpuQueries[s], o = this.gl.getQueryParameter(a.query, this.gl.QUERY_RESULT_AVAILABLE), l = this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);
      if (o && !l) {
        const u = this.gl.getQueryParameter(a.query, this.gl.QUERY_RESULT), c = Number(u) / 1e6;
        this.gl.deleteQuery(a.query), n.gpuQueries.splice(s, 1), s--, this.renderer.info.updateTimestamp(i, c);
      }
    }
  }
  getContext() {
    return this.gl;
  }
  beginRender(e) {
    const { gl: i } = this, n = this.get(e);
    if (this.initTimestampQuery(e), n.previousContext = this._currentContext, this._currentContext = e, this._setFramebuffer(e), this.clear(e.clearColor, e.clearDepth, e.clearStencil, e, !1), e.viewport ? this.updateViewport(e) : i.viewport(0, 0, i.drawingBufferWidth, i.drawingBufferHeight), e.scissor) {
      const { x: a, y: o, width: l, height: u } = e.scissorValue;
      i.scissor(a, e.height - u - o, l, u);
    }
    const s = e.occlusionQueryCount;
    s > 0 && (n.currentOcclusionQueries = n.occlusionQueries, n.currentOcclusionQueryObjects = n.occlusionQueryObjects, n.lastOcclusionObject = null, n.occlusionQueries = new Array(s), n.occlusionQueryObjects = new Array(s), n.occlusionQueryIndex = 0);
  }
  finishRender(e) {
    const { gl: i, state: n } = this, s = this.get(e), a = s.previousContext, o = e.occlusionQueryCount;
    o > 0 && (o > s.occlusionQueryIndex && i.endQuery(i.ANY_SAMPLES_PASSED), this.resolveOccludedAsync(e));
    const l = e.textures;
    if (l !== null)
      for (let u = 0; u < l.length; u++) {
        const c = l[u];
        c.generateMipmaps && this.generateMipmaps(c);
      }
    if (this._currentContext = a, e.textures !== null && e.renderTarget) {
      const u = this.get(e.renderTarget), { samples: c } = e.renderTarget;
      if (c > 0) {
        const h = u.framebuffers[e.getCacheKey()], d = i.COLOR_BUFFER_BIT, p = u.msaaFrameBuffer, f = e.textures;
        n.bindFramebuffer(i.READ_FRAMEBUFFER, p), n.bindFramebuffer(i.DRAW_FRAMEBUFFER, h);
        for (let m = 0; m < f.length; m++)
          if (e.scissor) {
            const { x: v, y, width: g, height: _ } = e.scissorValue, x = e.height - _ - y;
            i.blitFramebuffer(v, x, v + g, x + _, v, x, v + g, x + _, d, i.NEAREST), i.invalidateSubFramebuffer(i.READ_FRAMEBUFFER, u.invalidationArray, v, x, g, _);
          } else
            i.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, d, i.NEAREST), i.invalidateFramebuffer(i.READ_FRAMEBUFFER, u.invalidationArray);
      }
    }
    a !== null && (this._setFramebuffer(a), a.viewport ? this.updateViewport(a) : i.viewport(0, 0, i.drawingBufferWidth, i.drawingBufferHeight)), this.prepareTimestampBuffer(e);
  }
  resolveOccludedAsync(e) {
    const i = this.get(e), { currentOcclusionQueries: n, currentOcclusionQueryObjects: s } = i;
    if (n && s) {
      const a = /* @__PURE__ */ new WeakSet(), { gl: o } = this;
      i.currentOcclusionQueryObjects = null, i.currentOcclusionQueries = null;
      const l = () => {
        let u = 0;
        for (let c = 0; c < n.length; c++) {
          const h = n[c];
          h !== null && o.getQueryParameter(h, o.QUERY_RESULT_AVAILABLE) && (o.getQueryParameter(h, o.QUERY_RESULT) > 0 && a.add(s[c]), n[c] = null, o.deleteQuery(h), u++);
        }
        u < n.length ? requestAnimationFrame(l) : i.occluded = a;
      };
      l();
    }
  }
  isOccluded(e, i) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(i);
  }
  updateViewport(e) {
    const i = this.gl, { x: n, y: s, width: a, height: o } = e.viewportValue;
    i.viewport(n, e.height - o - s, a, o);
  }
  setScissorTest(e) {
    const i = this.gl;
    e ? i.enable(i.SCISSOR_TEST) : i.disable(i.SCISSOR_TEST);
  }
  clear(e, i, n, s = null, a = !0) {
    const { gl: o } = this;
    if (s === null) {
      const u = this.getClearColor();
      u.r *= u.a, u.g *= u.a, u.b *= u.a, s = {
        textures: null,
        clearColorValue: u
      };
    }
    let l = 0;
    if (e && (l |= o.COLOR_BUFFER_BIT), i && (l |= o.DEPTH_BUFFER_BIT), n && (l |= o.STENCIL_BUFFER_BIT), l !== 0) {
      let u;
      if (s.clearColorValue ? u = s.clearColorValue : (u = this.getClearColor(), u.r *= u.a, u.g *= u.a, u.b *= u.a), i && this.state.setDepthMask(!0), s.textures === null)
        o.clearColor(u.r, u.g, u.b, u.a), o.clear(l);
      else {
        if (a && this._setFramebuffer(s), e)
          for (let c = 0; c < s.textures.length; c++)
            o.clearBufferfv(o.COLOR, c, [u.r, u.g, u.b, u.a]);
        i && n ? o.clearBufferfi(o.DEPTH_STENCIL, 0, 1, 0) : i ? o.clearBufferfv(o.DEPTH, 0, [1]) : n && o.clearBufferiv(o.STENCIL, 0, [0]);
      }
    }
  }
  beginCompute(e) {
    const { state: i, gl: n } = this;
    i.bindFramebuffer(n.FRAMEBUFFER, null), this.initTimestampQuery(e);
  }
  compute(e, i, n, s) {
    const { state: a, gl: o } = this;
    this.discard || (o.enable(o.RASTERIZER_DISCARD), this.discard = !0);
    const { programGPU: l, transformBuffers: u, attributes: c } = this.get(s), h = this._getVaoKey(null, c), d = this.vaoCache[h];
    d === void 0 ? this._createVao(null, c) : o.bindVertexArray(d), a.useProgram(l), this._bindUniforms(n);
    const p = this._getTransformFeedback(u);
    o.bindTransformFeedback(o.TRANSFORM_FEEDBACK, p), o.beginTransformFeedback(o.POINTS), c[0].isStorageInstancedBufferAttribute ? o.drawArraysInstanced(o.POINTS, 0, 1, i.count) : o.drawArrays(o.POINTS, 0, i.count), o.endTransformFeedback(), o.bindTransformFeedback(o.TRANSFORM_FEEDBACK, null);
    for (let f = 0; f < u.length; f++) {
      const m = u[f];
      m.pbo && this.textureUtils.copyBufferToTexture(m.transformBuffer, m.pbo), m.switchBuffers();
    }
  }
  finishCompute(e) {
    const i = this.gl;
    this.discard = !1, i.disable(i.RASTERIZER_DISCARD), this.prepareTimestampBuffer(e), this._currentContext && this._setFramebuffer(this._currentContext);
  }
  draw(e) {
    const { object: i, pipeline: n, material: s, context: a } = e, { programGPU: o } = this.get(n), { gl: l, state: u } = this, c = this.get(a), h = e.getDrawParameters();
    if (h === null) return;
    this._bindUniforms(e.getBindings());
    const d = i.isMesh && i.matrixWorld.determinant() < 0;
    u.setMaterial(s, d), u.useProgram(o);
    let p = e.staticVao;
    if (p === void 0) {
      const x = this._getVaoKey(e.getIndex(), e.getAttributes());
      if (p = this.vaoCache[x], p === void 0) {
        let b;
        ({ vaoGPU: p, staticVao: b } = this._createVao(e.getIndex(), e.getAttributes())), b && (e.staticVao = p);
      }
    }
    l.bindVertexArray(p);
    const f = e.getIndex(), m = c.lastOcclusionObject;
    if (m !== i && m !== void 0) {
      if (m !== null && m.occlusionTest === !0 && (l.endQuery(l.ANY_SAMPLES_PASSED), c.occlusionQueryIndex++), i.occlusionTest === !0) {
        const x = l.createQuery();
        l.beginQuery(l.ANY_SAMPLES_PASSED, x), c.occlusionQueries[c.occlusionQueryIndex] = x, c.occlusionQueryObjects[c.occlusionQueryIndex] = i;
      }
      c.lastOcclusionObject = i;
    }
    const v = this.bufferRenderer;
    i.isPoints ? v.mode = l.POINTS : i.isLineSegments ? v.mode = l.LINES : i.isLine ? v.mode = l.LINE_STRIP : i.isLineLoop ? v.mode = l.LINE_LOOP : s.wireframe === !0 ? (u.setLineWidth(s.wireframeLinewidth * this.renderer.getPixelRatio()), v.mode = l.LINES) : v.mode = l.TRIANGLES;
    const { vertexCount: y, instanceCount: g } = h;
    let { firstVertex: _ } = h;
    if (v.object = i, f !== null) {
      _ *= f.array.BYTES_PER_ELEMENT;
      const x = this.get(f);
      v.index = f.count, v.type = x.type;
    } else
      v.index = 0;
    i.isBatchedMesh ? i._multiDrawInstances !== null ? v.renderMultiDrawInstances(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount, i._multiDrawInstances) : this.hasFeature("WEBGL_multi_draw") ? v.renderMultiDraw(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount) : R7("THREE.WebGLRenderer: WEBGL_multi_draw not supported.") : g > 1 ? v.renderInstances(_, y, g) : v.render(_, y), l.bindVertexArray(null);
  }
  needsRenderUpdate() {
    return !1;
  }
  getRenderCacheKey() {
    return "";
  }
  // textures
  createDefaultTexture(e) {
    this.textureUtils.createDefaultTexture(e);
  }
  createTexture(e, i) {
    this.textureUtils.createTexture(e, i);
  }
  updateTexture(e, i) {
    this.textureUtils.updateTexture(e, i);
  }
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  destroyTexture(e) {
    this.textureUtils.destroyTexture(e);
  }
  copyTextureToBuffer(e, i, n, s, a, o) {
    return this.textureUtils.copyTextureToBuffer(e, i, n, s, a, o);
  }
  createSampler() {
  }
  destroySampler() {
  }
  // node builder
  createNodeBuilder(e, i) {
    return new jZ(e, i);
  }
  // program
  createProgram(e) {
    const i = this.gl, { stage: n, code: s } = e, a = n === "fragment" ? i.createShader(i.FRAGMENT_SHADER) : i.createShader(i.VERTEX_SHADER);
    i.shaderSource(a, s), i.compileShader(a), this.set(e, {
      shaderGPU: a
    });
  }
  destroyProgram() {
    console.warn("Abstract class.");
  }
  createRenderPipeline(e, i) {
    const n = this.gl, s = e.pipeline, { fragmentProgram: a, vertexProgram: o } = s, l = n.createProgram(), u = this.get(a).shaderGPU, c = this.get(o).shaderGPU;
    if (n.attachShader(l, u), n.attachShader(l, c), n.linkProgram(l), this.set(s, {
      programGPU: l,
      fragmentShader: u,
      vertexShader: c
    }), i !== null && this.parallel) {
      const h = new Promise((d) => {
        const p = this.parallel, f = () => {
          n.getProgramParameter(l, p.COMPLETION_STATUS_KHR) ? (this._completeCompile(e, s), d()) : requestAnimationFrame(f);
        };
        f();
      });
      i.push(h);
      return;
    }
    this._completeCompile(e, s);
  }
  _handleSource(e, i) {
    const n = e.split(`
`), s = [], a = Math.max(i - 6, 0), o = Math.min(i + 6, n.length);
    for (let l = a; l < o; l++) {
      const u = l + 1;
      s.push(`${u === i ? ">" : " "} ${u}: ${n[l]}`);
    }
    return s.join(`
`);
  }
  _getShaderErrors(e, i, n) {
    const s = e.getShaderParameter(i, e.COMPILE_STATUS), a = e.getShaderInfoLog(i).trim();
    if (s && a === "") return "";
    const o = /ERROR: 0:(\d+)/.exec(a);
    if (o) {
      const l = parseInt(o[1]);
      return n.toUpperCase() + `

` + a + `

` + this._handleSource(e.getShaderSource(i), l);
    } else
      return a;
  }
  _logProgramError(e, i, n) {
    if (this.renderer.debug.checkShaderErrors) {
      const s = this.gl, a = s.getProgramInfoLog(e).trim();
      if (s.getProgramParameter(e, s.LINK_STATUS) === !1)
        if (typeof this.renderer.debug.onShaderError == "function")
          this.renderer.debug.onShaderError(s, e, n, i);
        else {
          const o = this._getShaderErrors(s, n, "vertex"), l = this._getShaderErrors(s, i, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(e, s.VALIDATE_STATUS) + `

Program Info Log: ` + a + `
` + o + `
` + l
          );
        }
      else a !== "" && console.warn("THREE.WebGLProgram: Program Info Log:", a);
    }
  }
  _completeCompile(e, i) {
    const { state: n, gl: s } = this, a = this.get(i), { programGPU: o, fragmentShader: l, vertexShader: u } = a;
    s.getProgramParameter(o, s.LINK_STATUS) === !1 && this._logProgramError(o, l, u), n.useProgram(o);
    const c = e.getBindings();
    this._setupBindings(c, o), this.set(i, {
      programGPU: o
    });
  }
  createComputePipeline(e, i) {
    const { state: n, gl: s } = this, a = {
      stage: "fragment",
      code: `#version 300 es
precision highp float;
void main() {}`
    };
    this.createProgram(a);
    const { computeProgram: o } = e, l = s.createProgram(), u = this.get(a).shaderGPU, c = this.get(o).shaderGPU, h = o.transforms, d = [], p = [];
    for (let y = 0; y < h.length; y++) {
      const g = h[y];
      d.push(g.varyingName), p.push(g.attributeNode);
    }
    s.attachShader(l, u), s.attachShader(l, c), s.transformFeedbackVaryings(
      l,
      d,
      s.SEPARATE_ATTRIBS
    ), s.linkProgram(l), s.getProgramParameter(l, s.LINK_STATUS) === !1 && this._logProgramError(l, u, c), n.useProgram(l), this._setupBindings(i, l);
    const f = o.attributes, m = [], v = [];
    for (let y = 0; y < f.length; y++) {
      const g = f[y].node.attribute;
      m.push(g), this.has(g) || this.attributeUtils.createAttribute(g, s.ARRAY_BUFFER);
    }
    for (let y = 0; y < p.length; y++) {
      const g = p[y].attribute;
      this.has(g) || this.attributeUtils.createAttribute(g, s.ARRAY_BUFFER);
      const _ = this.get(g);
      v.push(_);
    }
    this.set(e, {
      programGPU: l,
      transformBuffers: v,
      attributes: m
    });
  }
  createBindings(e, i) {
    if (this._knownBindings.has(i) === !1) {
      this._knownBindings.add(i);
      let n = 0, s = 0;
      for (const a of i) {
        this.set(a, {
          textures: s,
          uniformBuffers: n
        });
        for (const o of a.bindings)
          o.isUniformBuffer && n++, o.isSampledTexture && s++;
      }
    }
    this.updateBindings(e, i);
  }
  updateBindings(e) {
    const { gl: i } = this, n = this.get(e);
    let s = n.uniformBuffers, a = n.textures;
    for (const o of e.bindings)
      if (o.isUniformsGroup || o.isUniformBuffer) {
        const l = o.buffer, u = i.createBuffer();
        i.bindBuffer(i.UNIFORM_BUFFER, u), i.bufferData(i.UNIFORM_BUFFER, l, i.DYNAMIC_DRAW), this.set(o, {
          index: s++,
          bufferGPU: u
        });
      } else if (o.isSampledTexture) {
        const { textureGPU: l, glTextureType: u } = this.get(o.texture);
        this.set(o, {
          index: a++,
          textureGPU: l,
          glTextureType: u
        });
      }
  }
  updateBinding(e) {
    const i = this.gl;
    if (e.isUniformsGroup || e.isUniformBuffer) {
      const n = this.get(e).bufferGPU, s = e.buffer;
      i.bindBuffer(i.UNIFORM_BUFFER, n), i.bufferData(i.UNIFORM_BUFFER, s, i.DYNAMIC_DRAW);
    }
  }
  // attributes
  createIndexAttribute(e) {
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ELEMENT_ARRAY_BUFFER);
  }
  createAttribute(e) {
    if (this.has(e)) return;
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ARRAY_BUFFER);
  }
  createStorageAttribute(e) {
    if (this.has(e)) return;
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ARRAY_BUFFER);
  }
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  updateSize() {
  }
  hasFeature(e) {
    const i = Object.keys(uA).filter((s) => uA[s] === e), n = this.extensions;
    for (let s = 0; s < i.length; s++)
      if (n.has(i[s])) return !0;
    return !1;
  }
  getMaxAnisotropy() {
    return this.capabilities.getMaxAnisotropy();
  }
  copyTextureToTexture(e, i, n, s, a) {
    this.textureUtils.copyTextureToTexture(e, i, n, s, a);
  }
  copyFramebufferToTexture(e, i, n) {
    this.textureUtils.copyFramebufferToTexture(e, i, n);
  }
  _setFramebuffer(e) {
    const { gl: i, state: n } = this;
    let s = null;
    if (e.textures !== null) {
      const a = e.renderTarget, o = this.get(a), { samples: l, depthBuffer: u, stencilBuffer: c } = a, h = a.isWebGLCubeRenderTarget === !0;
      let d = o.msaaFrameBuffer, p = o.depthRenderbuffer;
      const f = V3(e);
      let m;
      if (h ? (o.cubeFramebuffers || (o.cubeFramebuffers = {}), m = o.cubeFramebuffers[f]) : (o.framebuffers || (o.framebuffers = {}), m = o.framebuffers[f]), m === void 0) {
        m = i.createFramebuffer(), n.bindFramebuffer(i.FRAMEBUFFER, m);
        const v = e.textures;
        if (h) {
          o.cubeFramebuffers[f] = m;
          const { textureGPU: y } = this.get(v[0]), g = this.renderer._activeCubeFace;
          i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + g, y, 0);
        } else {
          o.framebuffers[f] = m;
          for (let y = 0; y < v.length; y++) {
            const g = v[y], _ = this.get(g);
            _.renderTarget = e.renderTarget, _.cacheKey = f;
            const x = i.COLOR_ATTACHMENT0 + y;
            i.framebufferTexture2D(i.FRAMEBUFFER, x, i.TEXTURE_2D, _.textureGPU, 0);
          }
          n.drawBuffers(e, m);
        }
        if (e.depthTexture !== null) {
          const y = this.get(e.depthTexture), g = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
          y.renderTarget = e.renderTarget, y.cacheKey = f, i.framebufferTexture2D(i.FRAMEBUFFER, g, i.TEXTURE_2D, y.textureGPU, 0);
        }
      }
      if (l > 0) {
        if (d === void 0) {
          const v = [];
          d = i.createFramebuffer(), n.bindFramebuffer(i.FRAMEBUFFER, d);
          const y = [], g = e.textures;
          for (let _ = 0; _ < g.length; _++) {
            if (y[_] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, y[_]), v.push(i.COLOR_ATTACHMENT0 + _), u) {
              const T = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
              v.push(T);
            }
            const x = e.textures[_], b = this.get(x);
            i.renderbufferStorageMultisample(i.RENDERBUFFER, l, b.glInternalFormat, e.width, e.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + _, i.RENDERBUFFER, y[_]);
          }
          if (o.msaaFrameBuffer = d, o.msaaRenderbuffers = y, p === void 0) {
            p = i.createRenderbuffer(), this.textureUtils.setupRenderBufferStorage(p, e), o.depthRenderbuffer = p;
            const _ = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
            v.push(_);
          }
          o.invalidationArray = v;
        }
        s = o.msaaFrameBuffer;
      } else
        s = m;
    }
    n.bindFramebuffer(i.FRAMEBUFFER, s);
  }
  _getVaoKey(e, i) {
    let n = [];
    if (e !== null) {
      const s = this.get(e);
      n += ":" + s.id;
    }
    for (let s = 0; s < i.length; s++) {
      const a = this.get(i[s]);
      n += ":" + a.id;
    }
    return n;
  }
  _createVao(e, i) {
    const { gl: n } = this, s = n.createVertexArray();
    let a = "", o = !0;
    if (n.bindVertexArray(s), e !== null) {
      const l = this.get(e);
      n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, l.bufferGPU), a += ":" + l.id;
    }
    for (let l = 0; l < i.length; l++) {
      const u = i[l], c = this.get(u);
      a += ":" + c.id, n.bindBuffer(n.ARRAY_BUFFER, c.bufferGPU), n.enableVertexAttribArray(l), (u.isStorageBufferAttribute || u.isStorageInstancedBufferAttribute) && (o = !1);
      let h, d;
      u.isInterleavedBufferAttribute === !0 ? (h = u.data.stride * c.bytesPerElement, d = u.offset * c.bytesPerElement) : (h = 0, d = 0), c.isInteger ? n.vertexAttribIPointer(l, u.itemSize, c.type, h, d) : n.vertexAttribPointer(l, u.itemSize, c.type, u.normalized, h, d), u.isInstancedBufferAttribute && !u.isInterleavedBufferAttribute ? n.vertexAttribDivisor(l, u.meshPerAttribute) : u.isInterleavedBufferAttribute && u.data.isInstancedInterleavedBuffer && n.vertexAttribDivisor(l, u.data.meshPerAttribute);
    }
    return n.bindBuffer(n.ARRAY_BUFFER, null), this.vaoCache[a] = s, { vaoGPU: s, staticVao: o };
  }
  _getTransformFeedback(e) {
    let i = "";
    for (let a = 0; a < e.length; a++)
      i += ":" + e[a].id;
    let n = this.transformFeedbackCache[i];
    if (n !== void 0)
      return n;
    const { gl: s } = this;
    n = s.createTransformFeedback(), s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, n);
    for (let a = 0; a < e.length; a++) {
      const o = e[a];
      s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER, a, o.transformBuffer);
    }
    return s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, null), this.transformFeedbackCache[i] = n, n;
  }
  _setupBindings(e, i) {
    const n = this.gl;
    for (const s of e)
      for (const a of s.bindings) {
        const o = this.get(a).index;
        if (a.isUniformsGroup || a.isUniformBuffer) {
          const l = n.getUniformBlockIndex(i, a.name);
          n.uniformBlockBinding(i, l, o);
        } else if (a.isSampledTexture) {
          const l = n.getUniformLocation(i, a.name);
          n.uniform1i(l, o);
        }
      }
  }
  _bindUniforms(e) {
    const { gl: i, state: n } = this;
    for (const s of e)
      for (const a of s.bindings) {
        const o = this.get(a), l = o.index;
        a.isUniformsGroup || a.isUniformBuffer ? n.bindBufferBase(i.UNIFORM_BUFFER, l, o.bufferGPU) : a.isSampledTexture && n.bindTexture(o.glTextureType, o.textureGPU, i.TEXTURE0 + l);
      }
  }
  dispose() {
    this.renderer.domElement.removeEventListener("webglcontextlost", this._onContextLost);
  }
}
class QZ extends qT {
  constructor(e, i) {
    super(e), this.texture = i, this.version = i ? i.version : 0, this.isSampler = !0;
  }
}
class ZZ extends QZ {
  constructor(e, i, n) {
    super(e, i ? i.value : null), this.textureNode = i, this.groupNode = n;
  }
  update() {
    this.texture = this.textureNode.value;
  }
}
class JZ extends eO {
  constructor(e, i) {
    super(e, i ? i.array : null), this.attribute = i, this.isStorageBuffer = !0;
  }
}
let eJ = 0;
class tJ extends JZ {
  constructor(e, i) {
    super("StorageBuffer_" + eJ++, e ? e.value : null), this.nodeUniform = e, this.access = e ? e.access : Ox.Storage, this.groupNode = i;
  }
  get buffer() {
    return this.nodeUniform.value;
  }
}
class iJ extends Eo {
  constructor(e) {
    super(), this.device = e;
    const i = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`, n = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`, s = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
    this.mipmapSampler = e.createSampler({ minFilter: Jo.Linear }), this.flipYSampler = e.createSampler({ minFilter: Jo.Nearest }), this.transferPipelines = {}, this.flipYPipelines = {}, this.mipmapVertexShaderModule = e.createShaderModule({
      label: "mipmapVertex",
      code: i
    }), this.mipmapFragmentShaderModule = e.createShaderModule({
      label: "mipmapFragment",
      code: n
    }), this.flipYFragmentShaderModule = e.createShaderModule({
      label: "flipYFragment",
      code: s
    });
  }
  getTransferPipeline(e) {
    let i = this.transferPipelines[e];
    return i === void 0 && (i = this.device.createRenderPipeline({
      label: `mipmap-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.mipmapFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: ju.TriangleStrip,
        stripIndexFormat: Ac.Uint32
      },
      layout: "auto"
    }), this.transferPipelines[e] = i), i;
  }
  getFlipYPipeline(e) {
    let i = this.flipYPipelines[e];
    return i === void 0 && (i = this.device.createRenderPipeline({
      label: `flipY-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.flipYFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: ju.TriangleStrip,
        stripIndexFormat: Ac.Uint32
      },
      layout: "auto"
    }), this.flipYPipelines[e] = i), i;
  }
  flipY(e, i, n = 0) {
    const s = i.format, { width: a, height: o } = i.size, l = this.getTransferPipeline(s), u = this.getFlipYPipeline(s), c = this.device.createTexture({
      size: { width: a, height: o, depthOrArrayLayers: 1 },
      format: s,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    }), h = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: xn.TwoD,
      baseArrayLayer: n
    }), d = c.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: xn.TwoD,
      baseArrayLayer: 0
    }), p = this.device.createCommandEncoder({}), f = (m, v, y) => {
      const g = m.getBindGroupLayout(0), _ = this.device.createBindGroup({
        layout: g,
        entries: [{
          binding: 0,
          resource: this.flipYSampler
        }, {
          binding: 1,
          resource: v
        }]
      }), x = p.beginRenderPass({
        colorAttachments: [{
          view: y,
          loadOp: Ii.Clear,
          storeOp: Zi.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      x.setPipeline(m), x.setBindGroup(0, _), x.draw(4, 1, 0, 0), x.end();
    };
    f(l, h, d), f(u, d, h), this.device.queue.submit([p.finish()]), c.destroy();
  }
  generateMipmaps(e, i, n = 0) {
    const s = this.get(e);
    s.useCount === void 0 && (s.useCount = 0, s.layers = []);
    const a = s.layers[n] || this._mipmapCreateBundles(e, i, n), o = this.device.createCommandEncoder({});
    this._mipmapRunBundles(o, a), this.device.queue.submit([o.finish()]), s.useCount !== 0 && (s.layers[n] = a), s.useCount++;
  }
  _mipmapCreateBundles(e, i, n) {
    const s = this.getTransferPipeline(i.format), a = s.getBindGroupLayout(0);
    let o = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: xn.TwoD,
      baseArrayLayer: n
    });
    const l = [];
    for (let u = 1; u < i.mipLevelCount; u++) {
      const c = this.device.createBindGroup({
        layout: a,
        entries: [{
          binding: 0,
          resource: this.mipmapSampler
        }, {
          binding: 1,
          resource: o
        }]
      }), h = e.createView({
        baseMipLevel: u,
        mipLevelCount: 1,
        dimension: xn.TwoD,
        baseArrayLayer: n
      }), d = {
        colorAttachments: [{
          view: h,
          loadOp: Ii.Clear,
          storeOp: Zi.Store,
          clearValue: [0, 0, 0, 0]
        }]
      }, p = this.device.createRenderBundleEncoder({
        colorFormats: [i.format]
      });
      p.setPipeline(s), p.setBindGroup(0, c), p.draw(4, 1, 0, 0), l.push({
        renderBundles: [p.finish()],
        passDescriptor: d
      }), o = h;
    }
    return l;
  }
  _mipmapRunBundles(e, i) {
    const n = i.length;
    for (let s = 0; s < n; s++) {
      const a = i[s], o = e.beginRenderPass(a.passDescriptor);
      o.executeBundles(a.renderBundles), o.end();
    }
  }
}
const rJ = {
  [eP]: "never",
  [uT]: "less",
  [tP]: "equal",
  [iP]: "less-equal",
  [rP]: "greater",
  [sP]: "greater-equal",
  [aP]: "always",
  [nP]: "not-equal"
}, nJ = [0, 1, 3, 2, 4, 5];
class sJ {
  constructor(e) {
    this.backend = e, this._passUtils = null, this.defaultTexture = {}, this.defaultCubeTexture = {}, this.defaultVideoFrame = null, this.colorBuffer = null, this.depthTexture = new jc(), this.depthTexture.name = "depthBuffer";
  }
  createSampler(e) {
    const i = this.backend, n = i.device, s = i.get(e), a = {
      addressModeU: this._convertAddressMode(e.wrapS),
      addressModeV: this._convertAddressMode(e.wrapT),
      addressModeW: this._convertAddressMode(e.wrapR),
      magFilter: this._convertFilterMode(e.magFilter),
      minFilter: this._convertFilterMode(e.minFilter),
      mipmapFilter: this._convertFilterMode(e.minFilter),
      maxAnisotropy: 1
    };
    a.magFilter === Jo.Linear && a.minFilter === Jo.Linear && a.mipmapFilter === Jo.Linear && (a.maxAnisotropy = e.anisotropy), e.isDepthTexture && e.compareFunction !== null && (a.compare = rJ[e.compareFunction]), s.sampler = n.createSampler(a);
  }
  createDefaultTexture(e) {
    let i;
    const n = kx(e);
    e.isCubeTexture ? i = this._getDefaultCubeTextureGPU(n) : e.isVideoTexture ? this.backend.get(e).externalTexture = this._getDefaultVideoFrame() : i = this._getDefaultTextureGPU(n), this.backend.get(e).texture = i;
  }
  createTexture(e, i = {}) {
    const n = this.backend, s = n.get(e);
    if (s.initialized)
      throw new Error("WebGPUTextureUtils: Texture already initialized.");
    i.needsMipmaps === void 0 && (i.needsMipmaps = !1), i.levels === void 0 && (i.levels = 1), i.depth === void 0 && (i.depth = 1);
    const { width: a, height: o, depth: l, levels: u } = i;
    e.isFramebufferTexture && (i.renderTarget ? i.format = this.backend.utils.getCurrentColorFormat(i.renderTarget) : i.format = this.backend.utils.getPreferredCanvasFormat());
    const c = this._getDimension(e), h = e.internalFormat || i.format || kx(e, n.device);
    s.format = h;
    let d = i.sampleCount !== void 0 ? i.sampleCount : 1;
    d = n.utils.getSampleCount(d);
    const p = e.isRenderTargetTexture && !e.isMultisampleRenderTargetTexture ? 1 : d;
    let f = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
    e.isStorageTexture === !0 && (f |= GPUTextureUsage.STORAGE_BINDING), e.isCompressedTexture !== !0 && e.isCompressedArrayTexture !== !0 && (f |= GPUTextureUsage.RENDER_ATTACHMENT);
    const m = {
      label: e.name,
      size: {
        width: a,
        height: o,
        depthOrArrayLayers: l
      },
      mipLevelCount: u,
      sampleCount: p,
      dimension: c,
      format: h,
      usage: f
    };
    if (e.isVideoTexture) {
      const v = e.source.data, y = new VideoFrame(v);
      m.size.width = y.displayWidth, m.size.height = y.displayHeight, y.close(), s.externalTexture = v;
    } else {
      if (h === void 0)
        return console.warn("WebGPURenderer: Texture format not supported."), this.createDefaultTexture(e);
      s.texture = n.device.createTexture(m);
    }
    if (e.isRenderTargetTexture && d > 1 && !e.isMultisampleRenderTargetTexture) {
      const v = Object.assign({}, m);
      v.label = v.label + "-msaa", v.sampleCount = d, s.msaaTexture = n.device.createTexture(v);
    }
    s.initialized = !0, s.textureDescriptorGPU = m;
  }
  destroyTexture(e) {
    const i = this.backend, n = i.get(e);
    n.texture.destroy(), n.msaaTexture !== void 0 && n.msaaTexture.destroy(), i.delete(e);
  }
  destroySampler(e) {
    const i = this.backend.get(e);
    delete i.sampler;
  }
  generateMipmaps(e) {
    const i = this.backend.get(e);
    if (e.isCubeTexture)
      for (let n = 0; n < 6; n++)
        this._generateMipmaps(i.texture, i.textureDescriptorGPU, n);
    else {
      const n = e.image.depth || 1;
      for (let s = 0; s < n; s++)
        this._generateMipmaps(i.texture, i.textureDescriptorGPU, s);
    }
  }
  getColorBuffer() {
    this.colorBuffer && this.colorBuffer.destroy();
    const e = this.backend, { width: i, height: n } = e.getDrawingBufferSize();
    return this.colorBuffer = e.device.createTexture({
      label: "colorBuffer",
      size: {
        width: i,
        height: n,
        depthOrArrayLayers: 1
      },
      sampleCount: e.utils.getSampleCount(e.renderer.samples),
      format: e.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
    }), this.colorBuffer;
  }
  getDepthBuffer(e = !0, i = !1) {
    const n = this.backend, { width: s, height: a } = n.getDrawingBufferSize(), o = this.depthTexture, l = n.get(o).texture;
    let u, c;
    if (i ? (u = Sc, c = $d) : e && (u = vl, c = Ji), l !== void 0) {
      if (o.image.width === s && o.image.height === a && o.format === u && o.type === c)
        return l;
      this.destroyTexture(o);
    }
    return o.name = "depthBuffer", o.format = u, o.type = c, o.image.width = s, o.image.height = a, this.createTexture(o, { sampleCount: n.utils.getSampleCount(n.renderer.samples), width: s, height: a }), n.get(o).texture;
  }
  updateTexture(e, i) {
    const n = this.backend.get(e), { textureDescriptorGPU: s } = n;
    if (!(e.isRenderTargetTexture || s === void 0)) {
      if (e.isDataTexture)
        this._copyBufferToTexture(i.image, n.texture, s, 0, e.flipY);
      else if (e.isDataArrayTexture || e.isData3DTexture)
        for (let a = 0; a < i.image.depth; a++)
          this._copyBufferToTexture(i.image, n.texture, s, a, e.flipY, a);
      else if (e.isCompressedTexture || e.isCompressedArrayTexture)
        this._copyCompressedBufferToTexture(e.mipmaps, n.texture, s);
      else if (e.isCubeTexture)
        this._copyCubeMapToTexture(i.images, n.texture, s, e.flipY);
      else if (e.isVideoTexture) {
        const a = e.source.data;
        n.externalTexture = a;
      } else
        this._copyImageToTexture(i.image, n.texture, s, 0, e.flipY);
      n.version = e.version, e.onUpdate && e.onUpdate(e);
    }
  }
  async copyTextureToBuffer(e, i, n, s, a, o) {
    const l = this.backend.device, u = this.backend.get(e), c = u.texture, h = u.textureDescriptorGPU.format, d = this._getBytesPerTexel(h);
    let p = s * d;
    p = Math.ceil(p / 256) * 256;
    const f = l.createBuffer(
      {
        size: s * a * d,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }
    ), m = l.createCommandEncoder();
    m.copyTextureToBuffer(
      {
        texture: c,
        origin: { x: i, y: n, z: o }
      },
      {
        buffer: f,
        bytesPerRow: p
      },
      {
        width: s,
        height: a
      }
    );
    const v = this._getTypedArrayType(h);
    l.queue.submit([m.finish()]), await f.mapAsync(GPUMapMode.READ);
    const y = f.getMappedRange();
    return new v(y);
  }
  _isEnvironmentTexture(e) {
    const i = e.mapping;
    return i === Xd || i === Yd || i === wl || i === Tc;
  }
  _getDefaultTextureGPU(e) {
    let i = this.defaultTexture[e];
    if (i === void 0) {
      const n = new Ar();
      n.minFilter = mr, n.magFilter = mr, this.createTexture(n, { width: 1, height: 1, format: e }), this.defaultTexture[e] = i = n;
    }
    return this.backend.get(i).texture;
  }
  _getDefaultCubeTextureGPU(e) {
    let i = this.defaultTexture[e];
    if (i === void 0) {
      const n = new dT();
      n.minFilter = mr, n.magFilter = mr, this.createTexture(n, { width: 1, height: 1, depth: 6 }), this.defaultCubeTexture[e] = i = n;
    }
    return this.backend.get(i).texture;
  }
  _getDefaultVideoFrame() {
    let e = this.defaultVideoFrame;
    if (e === null) {
      const i = {
        timestamp: 0,
        codedWidth: 1,
        codedHeight: 1,
        format: "RGBA"
      };
      this.defaultVideoFrame = e = new VideoFrame(new Uint8Array([0, 0, 0, 255]), i);
    }
    return e;
  }
  _copyCubeMapToTexture(e, i, n, s) {
    for (let a = 0; a < 6; a++) {
      const o = e[a], l = s === !0 ? nJ[a] : a;
      o.isDataTexture ? this._copyBufferToTexture(o.image, i, n, l, s) : this._copyImageToTexture(o, i, n, l, s);
    }
  }
  _copyImageToTexture(e, i, n, s, a) {
    this.backend.device.queue.copyExternalImageToTexture(
      {
        source: e
      },
      {
        texture: i,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: s }
      },
      {
        width: e.width,
        height: e.height,
        depthOrArrayLayers: 1
      }
    ), a === !0 && this._flipY(i, n, s);
  }
  _getPassUtils() {
    let e = this._passUtils;
    return e === null && (this._passUtils = e = new iJ(this.backend.device)), e;
  }
  _generateMipmaps(e, i, n = 0) {
    this._getPassUtils().generateMipmaps(e, i, n);
  }
  _flipY(e, i, n = 0) {
    this._getPassUtils().flipY(e, i, n);
  }
  _copyBufferToTexture(e, i, n, s, a, o = 0) {
    const l = this.backend.device, u = e.data, c = this._getBytesPerTexel(n.format), h = e.width * c;
    l.queue.writeTexture(
      {
        texture: i,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: s }
      },
      u,
      {
        offset: e.width * e.height * c * o,
        bytesPerRow: h
      },
      {
        width: e.width,
        height: e.height,
        depthOrArrayLayers: 1
      }
    ), a === !0 && this._flipY(i, n, s);
  }
  _copyCompressedBufferToTexture(e, i, n) {
    const s = this.backend.device, a = this._getBlockData(n.format), o = n.size.depthOrArrayLayers > 1;
    for (let l = 0; l < e.length; l++) {
      const u = e[l], c = u.width, h = u.height, d = o ? n.size.depthOrArrayLayers : 1, p = Math.ceil(c / a.width) * a.byteLength, f = p * Math.ceil(h / a.height);
      for (let m = 0; m < d; m++)
        s.queue.writeTexture(
          {
            texture: i,
            mipLevel: l,
            origin: { x: 0, y: 0, z: m }
          },
          u.data,
          {
            offset: m * f,
            bytesPerRow: p,
            rowsPerImage: Math.ceil(h / a.height)
          },
          {
            width: Math.ceil(c / a.width) * a.width,
            height: Math.ceil(h / a.height) * a.height,
            depthOrArrayLayers: 1
          }
        );
    }
  }
  _getBlockData(e) {
    if (e === $.BC1RGBAUnorm || e === $.BC1RGBAUnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.BC2RGBAUnorm || e === $.BC2RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC3RGBAUnorm || e === $.BC3RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC4RUnorm || e === $.BC4RSNorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.BC5RGUnorm || e === $.BC5RGSnorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC6HRGBUFloat || e === $.BC6HRGBFloat) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.BC7RGBAUnorm || e === $.BC7RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.ETC2RGB8Unorm || e === $.ETC2RGB8UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.ETC2RGB8A1Unorm || e === $.ETC2RGB8A1UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.ETC2RGBA8Unorm || e === $.ETC2RGBA8UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.EACR11Unorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.EACR11Snorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === $.EACRG11Unorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.EACRG11Snorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.ASTC4x4Unorm || e === $.ASTC4x4UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === $.ASTC5x4Unorm || e === $.ASTC5x4UnormSRGB) return { byteLength: 16, width: 5, height: 4 };
    if (e === $.ASTC5x5Unorm || e === $.ASTC5x5UnormSRGB) return { byteLength: 16, width: 5, height: 5 };
    if (e === $.ASTC6x5Unorm || e === $.ASTC6x5UnormSRGB) return { byteLength: 16, width: 6, height: 5 };
    if (e === $.ASTC6x6Unorm || e === $.ASTC6x6UnormSRGB) return { byteLength: 16, width: 6, height: 6 };
    if (e === $.ASTC8x5Unorm || e === $.ASTC8x5UnormSRGB) return { byteLength: 16, width: 8, height: 5 };
    if (e === $.ASTC8x6Unorm || e === $.ASTC8x6UnormSRGB) return { byteLength: 16, width: 8, height: 6 };
    if (e === $.ASTC8x8Unorm || e === $.ASTC8x8UnormSRGB) return { byteLength: 16, width: 8, height: 8 };
    if (e === $.ASTC10x5Unorm || e === $.ASTC10x5UnormSRGB) return { byteLength: 16, width: 10, height: 5 };
    if (e === $.ASTC10x6Unorm || e === $.ASTC10x6UnormSRGB) return { byteLength: 16, width: 10, height: 6 };
    if (e === $.ASTC10x8Unorm || e === $.ASTC10x8UnormSRGB) return { byteLength: 16, width: 10, height: 8 };
    if (e === $.ASTC10x10Unorm || e === $.ASTC10x10UnormSRGB) return { byteLength: 16, width: 10, height: 10 };
    if (e === $.ASTC12x10Unorm || e === $.ASTC12x10UnormSRGB) return { byteLength: 16, width: 12, height: 10 };
    if (e === $.ASTC12x12Unorm || e === $.ASTC12x12UnormSRGB) return { byteLength: 16, width: 12, height: 12 };
  }
  _convertAddressMode(e) {
    let i = tv.ClampToEdge;
    return e === km ? i = tv.Repeat : e === Lm && (i = tv.MirrorRepeat), i;
  }
  _convertFilterMode(e) {
    let i = Jo.Linear;
    return (e === mr || e === Jb || e === Qu) && (i = Jo.Nearest), i;
  }
  _getBytesPerTexel(e) {
    if (e === $.R8Unorm || e === $.R8Snorm || e === $.R8Uint || e === $.R8Sint) return 1;
    if (e === $.R16Uint || e === $.R16Sint || e === $.R16Float || e === $.RG8Unorm || e === $.RG8Snorm || e === $.RG8Uint || e === $.RG8Sint) return 2;
    if (e === $.R32Uint || e === $.R32Sint || e === $.R32Float || e === $.RG16Uint || e === $.RG16Sint || e === $.RG16Float || e === $.RGBA8Unorm || e === $.RGBA8UnormSRGB || e === $.RGBA8Snorm || e === $.RGBA8Uint || e === $.RGBA8Sint || e === $.BGRA8Unorm || e === $.BGRA8UnormSRGB || // Packed 32-bit formats
    e === $.RGB9E5UFloat || e === $.RGB10A2Unorm || e === $.RG11B10UFloat || e === $.Depth32Float || e === $.Depth24Plus || e === $.Depth24PlusStencil8 || e === $.Depth32FloatStencil8) return 4;
    if (e === $.RG32Uint || e === $.RG32Sint || e === $.RG32Float || e === $.RGBA16Uint || e === $.RGBA16Sint || e === $.RGBA16Float) return 8;
    if (e === $.RGBA32Uint || e === $.RGBA32Sint || e === $.RGBA32Float) return 16;
  }
  _getTypedArrayType(e) {
    if (e === $.R8Uint) return Uint8Array;
    if (e === $.R8Sint) return Int8Array;
    if (e === $.R8Unorm) return Uint8Array;
    if (e === $.R8Snorm) return Int8Array;
    if (e === $.RG8Uint) return Uint8Array;
    if (e === $.RG8Sint) return Int8Array;
    if (e === $.RG8Unorm) return Uint8Array;
    if (e === $.RG8Snorm) return Int8Array;
    if (e === $.RGBA8Uint) return Uint8Array;
    if (e === $.RGBA8Sint) return Int8Array;
    if (e === $.RGBA8Unorm) return Uint8Array;
    if (e === $.RGBA8Snorm) return Int8Array;
    if (e === $.R16Uint) return Uint16Array;
    if (e === $.R16Sint) return Int16Array;
    if (e === $.RG16Uint) return Uint16Array;
    if (e === $.RG16Sint) return Int16Array;
    if (e === $.RGBA16Uint) return Uint16Array;
    if (e === $.RGBA16Sint) return Int16Array;
    if (e === $.R16Float || e === $.RG16Float || e === $.RGBA16Float) return Uint16Array;
    if (e === $.R32Uint) return Uint32Array;
    if (e === $.R32Sint) return Int32Array;
    if (e === $.R32Float) return Float32Array;
    if (e === $.RG32Uint) return Uint32Array;
    if (e === $.RG32Sint) return Int32Array;
    if (e === $.RG32Float) return Float32Array;
    if (e === $.RGBA32Uint) return Uint32Array;
    if (e === $.RGBA32Sint) return Int32Array;
    if (e === $.RGBA32Float) return Float32Array;
    if (e === $.BGRA8Unorm || e === $.BGRA8UnormSRGB) return Uint8Array;
    if (e === $.RGB10A2Unorm || e === $.RGB9E5UFloat || e === $.RG11B10UFloat) return Uint32Array;
    if (e === $.Depth32Float) return Float32Array;
    if (e === $.Depth24Plus || e === $.Depth24PlusStencil8) return Uint32Array;
    if (e === $.Depth32FloatStencil8) return Float32Array;
  }
  _getDimension(e) {
    let i;
    return e.isData3DTexture ? i = HM.ThreeD : i = HM.TwoD, i;
  }
}
function kx(r, e = null) {
  const i = r.format, n = r.type, s = r.colorSpace;
  let a;
  if (r.isCompressedTexture === !0 || r.isCompressedArrayTexture === !0)
    switch (i) {
      case tm:
        a = s === ht ? $.BC1RGBAUnormSRGB : $.BC1RGBAUnorm;
        break;
      case im:
        a = s === ht ? $.BC2RGBAUnormSRGB : $.BC2RGBAUnorm;
        break;
      case rm:
        a = s === ht ? $.BC3RGBAUnormSRGB : $.BC3RGBAUnorm;
        break;
      case tx:
        a = s === ht ? $.ETC2RGB8UnormSRGB : $.ETC2RGB8Unorm;
        break;
      case ix:
        a = s === ht ? $.ETC2RGBA8UnormSRGB : $.ETC2RGBA8Unorm;
        break;
      case rx:
        a = s === ht ? $.ASTC4x4UnormSRGB : $.ASTC4x4Unorm;
        break;
      case nx:
        a = s === ht ? $.ASTC5x4UnormSRGB : $.ASTC5x4Unorm;
        break;
      case sx:
        a = s === ht ? $.ASTC5x5UnormSRGB : $.ASTC5x5Unorm;
        break;
      case ax:
        a = s === ht ? $.ASTC6x5UnormSRGB : $.ASTC6x5Unorm;
        break;
      case ox:
        a = s === ht ? $.ASTC6x6UnormSRGB : $.ASTC6x6Unorm;
        break;
      case lx:
        a = s === ht ? $.ASTC8x5UnormSRGB : $.ASTC8x5Unorm;
        break;
      case ux:
        a = s === ht ? $.ASTC8x6UnormSRGB : $.ASTC8x6Unorm;
        break;
      case cx:
        a = s === ht ? $.ASTC8x8UnormSRGB : $.ASTC8x8Unorm;
        break;
      case hx:
        a = s === ht ? $.ASTC10x5UnormSRGB : $.ASTC10x5Unorm;
        break;
      case dx:
        a = s === ht ? $.ASTC10x6UnormSRGB : $.ASTC10x6Unorm;
        break;
      case px:
        a = s === ht ? $.ASTC10x8UnormSRGB : $.ASTC10x8Unorm;
        break;
      case fx:
        a = s === ht ? $.ASTC10x10UnormSRGB : $.ASTC10x10Unorm;
        break;
      case mx:
        a = s === ht ? $.ASTC12x10UnormSRGB : $.ASTC12x10Unorm;
        break;
      case gx:
        a = s === ht ? $.ASTC12x12UnormSRGB : $.ASTC12x12Unorm;
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", i);
    }
  else
    switch (i) {
      case Fc:
        switch (n) {
          case Jh:
            a = $.RGBA8Snorm;
            break;
          case ed:
            a = $.RGBA16Sint;
            break;
          case Uu:
            a = $.RGBA16Uint;
            break;
          case Ji:
            a = $.RGBA32Uint;
            break;
          case Tr:
            a = $.RGBA32Sint;
            break;
          case fo:
            a = s === ht ? $.RGBA8UnormSRGB : $.RGBA8Unorm;
            break;
          case ga:
            a = $.RGBA16Float;
            break;
          case cn:
            a = $.RGBA32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.", n);
        }
        break;
      case nT:
        switch (n) {
          case ZN:
            a = $.RGB9E5UFloat;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBFormat.", n);
        }
        break;
      case sT:
        switch (n) {
          case Jh:
            a = $.R8Snorm;
            break;
          case ed:
            a = $.R16Sint;
            break;
          case Uu:
            a = $.R16Uint;
            break;
          case Ji:
            a = $.R32Uint;
            break;
          case Tr:
            a = $.R32Sint;
            break;
          case fo:
            a = $.R8Unorm;
            break;
          case ga:
            a = $.R16Float;
            break;
          case cn:
            a = $.R32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedFormat.", n);
        }
        break;
      case yd:
        switch (n) {
          case Jh:
            a = $.RG8Snorm;
            break;
          case ed:
            a = $.RG16Sint;
            break;
          case Uu:
            a = $.RG16Uint;
            break;
          case Ji:
            a = $.RG32Uint;
            break;
          case Tr:
            a = $.RG32Sint;
            break;
          case fo:
            a = $.RG8Unorm;
            break;
          case ga:
            a = $.RG16Float;
            break;
          case cn:
            a = $.RG32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGFormat.", n);
        }
        break;
      case vl:
        switch (n) {
          case Uu:
            a = $.Depth16Unorm;
            break;
          case Ji:
            a = $.Depth24Plus;
            break;
          case cn:
            a = $.Depth32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthFormat.", n);
        }
        break;
      case Sc:
        switch (n) {
          case $d:
            a = $.Depth24PlusStencil8;
            break;
          case cn:
            e && e.features.has(Ix.Depth32FloatStencil8) === !1 && console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'), a = $.Depth32FloatStencil8;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", n);
        }
        break;
      case aT:
        switch (n) {
          case Tr:
            a = $.R32Sint;
            break;
          case Ji:
            a = $.R32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.", n);
        }
        break;
      case oT:
        switch (n) {
          case Tr:
            a = $.RG32Sint;
            break;
          case Ji:
            a = $.RG32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.", n);
        }
        break;
      case lT:
        switch (n) {
          case Tr:
            a = $.RGBA32Sint;
            break;
          case Ji:
            a = $.RGBA32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.", n);
        }
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", i);
    }
  return a;
}
const aJ = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i, oJ = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig, hA = {
  f32: "float",
  i32: "int",
  u32: "uint",
  bool: "bool",
  "vec2<f32>": "vec2",
  "vec2<i32>": "ivec2",
  "vec2<u32>": "uvec2",
  "vec2<bool>": "bvec2",
  vec2f: "vec2",
  vec2i: "ivec2",
  vec2u: "uvec2",
  vec2b: "bvec2",
  "vec3<f32>": "vec3",
  "vec3<i32>": "ivec3",
  "vec3<u32>": "uvec3",
  "vec3<bool>": "bvec3",
  vec3f: "vec3",
  vec3i: "ivec3",
  vec3u: "uvec3",
  vec3b: "bvec3",
  "vec4<f32>": "vec4",
  "vec4<i32>": "ivec4",
  "vec4<u32>": "uvec4",
  "vec4<bool>": "bvec4",
  vec4f: "vec4",
  vec4i: "ivec4",
  vec4u: "uvec4",
  vec4b: "bvec4",
  "mat2x2<f32>": "mat2",
  mat2x2f: "mat2",
  "mat3x3<f32>": "mat3",
  mat3x3f: "mat3",
  "mat4x4<f32>": "mat4",
  mat4x4f: "mat4",
  sampler: "sampler",
  texture_1d: "texture",
  texture_2d: "texture",
  texture_2d_array: "texture",
  texture_multisampled_2d: "cubeTexture",
  texture_depth_2d: "depthTexture",
  texture_3d: "texture3D",
  texture_cube: "cubeTexture",
  texture_cube_array: "cubeTexture",
  texture_storage_1d: "storageTexture",
  texture_storage_2d: "storageTexture",
  texture_storage_2d_array: "storageTexture",
  texture_storage_3d: "storageTexture"
}, lJ = (r) => {
  r = r.trim();
  const e = r.match(aJ);
  if (e !== null && e.length === 4) {
    const i = e[2], n = [];
    let s = null;
    for (; (s = oJ.exec(i)) !== null; )
      n.push({ name: s[1], type: s[2] });
    const a = [];
    for (let c = 0; c < n.length; c++) {
      const { name: h, type: d } = n[c];
      let p = d;
      p.startsWith("ptr") ? p = "pointer" : (p.startsWith("texture") && (p = d.split("<")[0]), p = hA[p]), a.push(new HT(p, h));
    }
    const o = r.substring(e[0].length), l = e[3] || "void", u = e[1] !== void 0 ? e[1] : "";
    return {
      type: hA[l] || l,
      inputs: a,
      name: u,
      inputsCode: i,
      blockCode: o,
      outputType: l
    };
  } else
    throw new Error("FunctionNode: Function is not a WGSL code.");
};
class uJ extends WT {
  constructor(e) {
    const { type: i, inputs: n, name: s, inputsCode: a, blockCode: o, outputType: l } = lJ(e);
    super(i, n, s), this.inputsCode = a, this.blockCode = o, this.outputType = l;
  }
  getCode(e = this.name) {
    const i = this.outputType !== "void" ? "-> " + this.outputType : "";
    return `fn ${e} ( ${this.inputsCode.trim()} ) ${i}` + this.blockCode;
  }
}
class cJ extends Z3 {
  parseFunction(e) {
    return new uJ(e);
  }
}
const Eu = self.GPUShaderStage, Mf = {
  vertex: Eu ? Eu.VERTEX : 1,
  fragment: Eu ? Eu.FRAGMENT : 2,
  compute: Eu ? Eu.COMPUTE : 4
}, dA = {
  instance: !0,
  swizzleAssign: !1,
  storageBuffer: !0
}, hJ = {
  "^^": "tsl_xor"
}, dJ = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat2: "mat2x2<f32>",
  mat3: "mat3x3<f32>",
  mat4: "mat4x4<f32>"
}, Ys = {
  tsl_xor: new pr("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
  mod_float: new pr("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
  mod_vec2: new pr("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
  mod_vec3: new pr("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
  mod_vec4: new pr("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
  equals_bool: new pr("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
  equals_bvec2: new pr("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
  equals_bvec3: new pr("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
  equals_bvec4: new pr("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
  repeatWrapping: new pr(
    /* wgsl */
    `
fn tsl_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {

	let uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );

	return ( ( uvScaled % dimension ) + dimension ) % dimension;

}
`
  ),
  biquadraticTexture: new pr(
    /* wgsl */
    `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, level : i32 ) -> vec4f {

	let iRes = vec2i( textureDimensions( map, level ) );
	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2i( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2i( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2i( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2i( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`
  )
}, Hh = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod_float: "tsl_mod_float",
  mod_vec2: "tsl_mod_vec2",
  mod_vec3: "tsl_mod_vec3",
  mod_vec4: "tsl_mod_vec4",
  equals_bool: "tsl_equals_bool",
  equals_bvec2: "tsl_equals_bvec2",
  equals_bvec3: "tsl_equals_bvec3",
  equals_bvec4: "tsl_equals_bvec4",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>"
};
/Windows/g.test(navigator.userAgent) && (Ys.pow_float = new pr("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"), Ys.pow_vec2 = new pr("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }", [Ys.pow_float]), Ys.pow_vec3 = new pr("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }", [Ys.pow_float]), Ys.pow_vec4 = new pr("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }", [Ys.pow_float]), Hh.pow_float = "tsl_pow_float", Hh.pow_vec2 = "tsl_pow_vec2", Hh.pow_vec3 = "tsl_pow_vec3", Hh.pow_vec4 = "tsl_pow_vec4");
let oO = "";
/Firefox|Deno/g.test(navigator.userAgent) !== !0 && (oO += `diagnostic( off, derivative_uniformity );
`);
class pJ extends K3 {
  constructor(e, i) {
    super(e, i, new cJ()), this.uniformGroups = {}, this.builtins = {}, this.directives = {}, this.scopedArrays = /* @__PURE__ */ new Map();
  }
  needsToWorkingColorSpace(e) {
    return e.isVideoTexture === !0 && e.colorSpace !== El;
  }
  _generateTextureSample(e, i, n, s, a = this.shaderStage) {
    return a === "fragment" ? s ? `textureSample( ${i}, ${i}_sampler, ${n}, ${s} )` : `textureSample( ${i}, ${i}_sampler, ${n} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, i, n) : this.generateTextureLod(e, i, n, "0");
  }
  _generateVideoSample(e, i, n = this.shaderStage) {
    if (n === "fragment")
      return `textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${i}.x, 1.0 - ${i}.y ) )`;
    console.error(`WebGPURenderer: THREE.VideoTexture does not support ${n} shader.`);
  }
  _generateTextureSampleLevel(e, i, n, s, a, o = this.shaderStage) {
    return o === "fragment" && this.isUnfilterable(e) === !1 ? `textureSampleLevel( ${i}, ${i}_sampler, ${n}, ${s} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, i, n, s) : this.generateTextureLod(e, i, n, s);
  }
  generateFilteredTexture(e, i, n, s = "0") {
    return this._include("biquadraticTexture"), `tsl_biquadraticTexture( ${i}, ${n}, i32( ${s} ) )`;
  }
  generateTextureLod(e, i, n, s = "0") {
    this._include("repeatWrapping");
    const a = e.isMultisampleRenderTargetTexture === !0 ? `textureDimensions( ${i} )` : `textureDimensions( ${i}, 0 )`;
    return `textureLoad( ${i}, tsl_repeatWrapping( ${n}, ${a} ), i32( ${s} ) )`;
  }
  generateTextureLoad(e, i, n, s, a = "0u") {
    return s ? `textureLoad( ${i}, ${n}, ${s}, ${a} )` : `textureLoad( ${i}, ${n}, ${a} )`;
  }
  generateTextureStore(e, i, n, s) {
    return `textureStore( ${i}, ${n}, ${s} )`;
  }
  isUnfilterable(e) {
    return this.getComponentTypeFromTexture(e) !== "float" || !this.isAvailable("float32Filterable") && e.isDataTexture === !0 && e.type === cn || e.isMultisampleRenderTargetTexture === !0;
  }
  generateTexture(e, i, n, s, a = this.shaderStage) {
    let o = null;
    return e.isVideoTexture === !0 ? o = this._generateVideoSample(i, n, a) : this.isUnfilterable(e) ? o = this.generateTextureLod(e, i, n, "0", s, a) : o = this._generateTextureSample(e, i, n, s, a), o;
  }
  generateTextureGrad(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleGrad( ${i}, ${i}_sampler, ${n},  ${s[0]}, ${s[1]} )`;
    console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${o} shader.`);
  }
  generateTextureCompare(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleCompare( ${i}, ${i}_sampler, ${n}, ${s} )`;
    console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${o} shader.`);
  }
  generateTextureLevel(e, i, n, s, a, o = this.shaderStage) {
    let l = null;
    return e.isVideoTexture === !0 ? l = this._generateVideoSample(i, n, o) : l = this._generateTextureSampleLevel(e, i, n, s, a, o), l;
  }
  generateTextureBias(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleBias( ${i}, ${i}_sampler, ${n}, ${s} )`;
    console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${o} shader.`);
  }
  getPropertyName(e, i = this.shaderStage) {
    if (e.isNodeVarying === !0 && e.needsInterpolation === !0) {
      if (i === "vertex")
        return `varyings.${e.name}`;
    } else if (e.isNodeUniform === !0) {
      const n = e.name, s = e.type;
      return s === "texture" || s === "cubeTexture" || s === "storageTexture" || s === "texture3D" ? n : s === "buffer" || s === "storageBuffer" || s === "indirectStorageBuffer" ? `NodeBuffer_${e.id}.${n}` : e.groupNode.name + "." + n;
    }
    return super.getPropertyName(e);
  }
  getOutputStructName() {
    return "output";
  }
  _getUniformGroupCount(e) {
    return Object.keys(this.uniforms[e]).length;
  }
  getFunctionOperator(e) {
    const i = hJ[e];
    return i !== void 0 ? (this._include(i), i) : null;
  }
  getStorageAccess(e) {
    if (e.isStorageTextureNode)
      switch (e.access) {
        case GM.ReadOnly:
          return "read";
        case GM.WriteOnly:
          return "write";
        default:
          return "read_write";
      }
    else
      switch (e.access) {
        case Ox.Storage:
          return "read_write";
        case Ox.ReadOnlyStorage:
          return "read";
        default:
          return "write";
      }
  }
  getUniformFromNode(e, i, n, s = null) {
    const a = super.getUniformFromNode(e, i, n, s), o = this.getDataFromNode(e, n, this.globalCache);
    if (o.uniformGPU === void 0) {
      let l;
      const u = e.groupNode, c = u.name, h = this.getBindGroupArray(c, n);
      if (i === "texture" || i === "cubeTexture" || i === "storageTexture" || i === "texture3D") {
        let d = null;
        if (i === "texture" || i === "storageTexture" ? d = new jg(a.name, a.node, u, e.access ? e.access : null) : i === "cubeTexture" ? d = new nO(a.name, a.node, u, e.access ? e.access : null) : i === "texture3D" && (d = new sO(a.name, a.node, u, e.access ? e.access : null)), d.store = e.isStorageTextureNode === !0, d.setVisibility(Mf[n]), n === "fragment" && this.isUnfilterable(e.value) === !1 && d.store === !1) {
          const p = new ZZ(`${a.name}_sampler`, a.node, u);
          p.setVisibility(Mf[n]), h.push(p, d), l = [p, d];
        } else
          h.push(d), l = [d];
      } else if (i === "buffer" || i === "storageBuffer" || i === "indirectStorageBuffer") {
        const d = i === "buffer" ? iO : tJ, p = new d(e, u);
        p.setVisibility(Mf[n]), h.push(p), l = p;
      } else {
        const d = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let p = d[c];
        p === void 0 && (p = new rO(c, u), p.setVisibility(Mf[n]), d[c] = p, h.push(p)), l = this.getNodeUniform(a, i), p.addUniform(l);
      }
      o.uniformGPU = l;
    }
    return a;
  }
  getBuiltin(e, i, n, s = this.shaderStage) {
    const a = this.builtins[s] || (this.builtins[s] = /* @__PURE__ */ new Map());
    return a.has(e) === !1 && a.set(e, {
      name: e,
      property: i,
      type: n
    }), i;
  }
  hasBuiltin(e, i = this.shaderStage) {
    return this.builtins[i] !== void 0 && this.builtins[i].has(e);
  }
  getVertexIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute") : "vertexIndex";
  }
  buildFunctionCode(e) {
    const i = e.layout, n = this.flowShaderNode(e), s = [];
    for (const o of i.inputs)
      s.push(o.name + " : " + this.getType(o.type));
    let a = `fn ${i.name}( ${s.join(", ")} ) -> ${this.getType(i.type)} {
${n.vars}
${n.code}
`;
    return n.result && (a += `	return ${n.result};
`), a += `
}
`, a;
  }
  getInstanceIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute") : "instanceIndex";
  }
  getInvocationLocalIndex() {
    return this.getBuiltin("local_invocation_index", "invocationLocalIndex", "u32", "attribute");
  }
  getSubgroupSize() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
  }
  getInvocationSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_invocation_id", "invocationSubgroupIndex", "u32", "attribute");
  }
  getSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute");
  }
  getDrawIndex() {
    return null;
  }
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
  }
  getFragDepth() {
    return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
  }
  isFlipY() {
    return !1;
  }
  enableDirective(e, i = this.shaderStage) {
    (this.directives[i] || (this.directives[i] = /* @__PURE__ */ new Set())).add(e);
  }
  getDirectives(e) {
    const i = [], n = this.directives[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`enable ${s};`);
    return i.join(`
`);
  }
  enableSubGroups() {
    this.enableDirective("subgroups");
  }
  enableSubgroupsF16() {
    this.enableDirective("subgroups-f16");
  }
  enableClipDistances() {
    this.enableDirective("clip_distances");
  }
  enableShaderF16() {
    this.enableDirective("f16");
  }
  enableDualSourceBlending() {
    this.enableDirective("dual_source_blending");
  }
  getBuiltins(e) {
    const i = [], n = this.builtins[e];
    if (n !== void 0)
      for (const { name: s, property: a, type: o } of n.values())
        i.push(`@builtin( ${s} ) ${a} : ${o}`);
    return i.join(`,
	`);
  }
  getScopedArray(e, i, n, s) {
    return this.scopedArrays.has(e) === !1 && this.scopedArrays.set(e, {
      name: e,
      scope: i,
      bufferType: n,
      bufferCount: s
    }), e;
  }
  getScopedArrays(e) {
    if (e !== "compute")
      return;
    const i = [];
    for (const { name: n, scope: s, bufferType: a, bufferCount: o } of this.scopedArrays.values()) {
      const l = this.getType(a);
      i.push(`var<${s}> ${n}: array< ${l}, ${o} >;`);
    }
    return i.join(`
`);
  }
  getAttributes(e) {
    const i = [];
    if (e === "compute" && (this.getBuiltin("global_invocation_id", "id", "vec3<u32>", "attribute"), this.getBuiltin("workgroup_id", "workgroupId", "vec3<u32>", "attribute"), this.getBuiltin("local_invocation_id", "localId", "vec3<u32>", "attribute"), this.getBuiltin("num_workgroups", "numWorkgroups", "vec3<u32>", "attribute"), this.renderer.hasFeature("subgroups") && (this.enableDirective("subgroups", e), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute"))), e === "vertex" || e === "compute") {
      const n = this.getBuiltins("attribute");
      n && i.push(n);
      const s = this.getAttributesArray();
      for (let a = 0, o = s.length; a < o; a++) {
        const l = s[a], u = l.name, c = this.getType(l.type);
        i.push(`@location( ${a} ) ${u} : ${c}`);
      }
    }
    return i.join(`,
	`);
  }
  getStructMembers(e) {
    const i = [], n = e.getMemberTypes();
    for (let a = 0; a < n.length; a++) {
      const o = n[a];
      i.push(`	@location( ${a} ) m${a} : ${o}<f32>`);
    }
    const s = this.getBuiltins("output");
    return s && i.push("	" + s), i.join(`,
`);
  }
  getStructs(e) {
    const i = [], n = this.structs[e];
    for (let s = 0, a = n.length; s < a; s++) {
      const o = n[s], l = o.name;
      let u = `struct ${l} {
`;
      u += this.getStructMembers(o), u += `
}`, i.push(u), i.push(`
var<private> output : ${l};

`);
    }
    return i.join(`

`);
  }
  getVar(e, i) {
    return `var ${i} : ${this.getType(e)}`;
  }
  getVars(e) {
    const i = [], n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`	${this.getVar(s.type, s.name)};`);
    return `
${i.join(`
`)}
`;
  }
  getVaryings(e) {
    const i = [];
    if (e === "vertex" && this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex"), e === "vertex" || e === "fragment") {
      const a = this.varyings, o = this.vars[e];
      for (let l = 0; l < a.length; l++) {
        const u = a[l];
        if (u.needsInterpolation) {
          let c = `@location( ${l} )`;
          /^(int|uint|ivec|uvec)/.test(u.type) && (c += " @interpolate( flat )"), i.push(`${c} ${u.name} : ${this.getType(u.type)}`);
        } else e === "vertex" && o.includes(u) === !1 && o.push(u);
      }
    }
    const n = this.getBuiltins(e);
    n && i.push(n);
    const s = i.join(`,
	`);
    return e === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + s) : s;
  }
  getUniforms(e) {
    const i = this.uniforms[e], n = [], s = [], a = [], o = {};
    for (const u of i) {
      const c = u.groupNode.name, h = this.bindingsIndexes[c];
      if (u.type === "texture" || u.type === "cubeTexture" || u.type === "storageTexture" || u.type === "texture3D") {
        const d = u.node.value;
        e === "fragment" && this.isUnfilterable(d) === !1 && u.node.isStorageTextureNode !== !0 && (d.isDepthTexture === !0 && d.compareFunction !== null ? n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name}_sampler : sampler_comparison;`) : n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name}_sampler : sampler;`));
        let p, f = "";
        if (d.isMultisampleRenderTargetTexture === !0 && (f = "_multisampled"), d.isCubeTexture === !0)
          p = "texture_cube<f32>";
        else if (d.isDataArrayTexture === !0 || d.isCompressedArrayTexture === !0)
          p = "texture_2d_array<f32>";
        else if (d.isDepthTexture === !0)
          p = `texture_depth${f}_2d`;
        else if (d.isVideoTexture === !0)
          p = "texture_external";
        else if (d.isData3DTexture === !0)
          p = "texture_3d<f32>";
        else if (u.node.isStorageTextureNode === !0) {
          const m = kx(d), v = this.getStorageAccess(u.node);
          p = `texture_storage_2d<${m}, ${v}>`;
        } else {
          const m = this.getComponentTypeFromTexture(d).charAt(0);
          p = `texture${f}_2d<${m}32>`;
        }
        n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name} : ${p};`);
      } else if (u.type === "buffer" || u.type === "storageBuffer" || u.type === "indirectStorageBuffer") {
        const d = u.node, p = this.getType(d.bufferType), f = d.bufferCount, m = f > 0 && u.type === "buffer" ? ", " + f : "", v = d.isAtomic ? `atomic<${p}>` : `${p}`, y = `	${u.name} : array< ${v}${m} >
`, g = d.isStorageBufferNode ? `storage, ${this.getStorageAccess(d)}` : "uniform";
        s.push(this._getWGSLStructBinding("NodeBuffer_" + d.id, y, g, h.binding++, h.group));
      } else {
        const d = this.getType(this.getVectorType(u.type)), p = u.groupNode.name;
        (o[p] || (o[p] = {
          index: h.binding++,
          id: h.group,
          snippets: []
        })).snippets.push(`	${u.name} : ${d}`);
      }
    }
    for (const u in o) {
      const c = o[u];
      a.push(this._getWGSLStructBinding(u, c.snippets.join(`,
`), "uniform", c.index, c.id));
    }
    let l = n.join(`
`);
    return l += s.join(`
`), l += a.join(`
`), l;
  }
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const i in e) {
      const n = e[i];
      n.uniforms = this.getUniforms(i), n.attributes = this.getAttributes(i), n.varyings = this.getVaryings(i), n.structs = this.getStructs(i), n.vars = this.getVars(i), n.codes = this.getCodes(i), n.directives = this.getDirectives(i), n.scopedArrays = this.getScopedArrays(i);
      let s = `// code

`;
      s += this.flowCode[i];
      const a = this.flowNodes[i], o = a[a.length - 1], l = o.outputNode, u = l !== void 0 && l.isOutputStructNode === !0;
      for (const c of a) {
        const h = this.getFlowData(
          c
          /*, shaderStage*/
        ), d = c.name;
        if (d && (s.length > 0 && (s += `
`), s += `	// flow -> ${d}
	`), s += `${h.code}
	`, c === o && i !== "compute") {
          if (s += `// result

	`, i === "vertex")
            s += `varyings.Vertex = ${h.result};`;
          else if (i === "fragment")
            if (u)
              n.returnType = l.nodeType, s += `return ${h.result};`;
            else {
              let p = "	@location(0) color: vec4<f32>";
              const f = this.getBuiltins("output");
              f && (p += `,
	` + f), n.returnType = "OutputStruct", n.structs += this._getWGSLStruct("OutputStruct", p), n.structs += `
var<private> output : OutputStruct;

`, s += `output.color = ${h.result};

	return output;`;
            }
        }
      }
      n.flow = s;
    }
    this.material !== null ? (this.vertexShader = this._getWGSLVertexCode(e.vertex), this.fragmentShader = this._getWGSLFragmentCode(e.fragment)) : this.computeShader = this._getWGSLComputeCode(e.compute, (this.object.workgroupSize || [64]).join(", "));
  }
  getMethod(e, i = null) {
    let n;
    return i !== null && (n = this._getWGSLMethod(e + "_" + i)), n === void 0 && (n = this._getWGSLMethod(e)), n || e;
  }
  getType(e) {
    return dJ[e] || e;
  }
  isAvailable(e) {
    let i = dA[e];
    return i === void 0 && (e === "float32Filterable" && (i = this.renderer.hasFeature("float32-filterable")), dA[e] = i), i;
  }
  _getWGSLMethod(e) {
    return Ys[e] !== void 0 && this._include(e), Hh[e];
  }
  _include(e) {
    const i = Ys[e];
    return i.build(this), this.currentFunctionNode !== null && this.currentFunctionNode.includes.push(i), i;
  }
  _getWGSLVertexCode(e) {
    return `${this.getSignature()}
// directives
${e.directives}

// uniforms
${e.uniforms}

// varyings
${e.varyings}
var<private> varyings : VaryingsStruct;

// codes
${e.codes}

@vertex
fn main( ${e.attributes} ) -> VaryingsStruct {

	// vars
	${e.vars}

	// flow
	${e.flow}

	return varyings;

}
`;
  }
  _getWGSLFragmentCode(e) {
    return `${this.getSignature()}
// global
${oO}

// uniforms
${e.uniforms}

// structs
${e.structs}

// codes
${e.codes}

@fragment
fn main( ${e.varyings} ) -> ${e.returnType} {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  _getWGSLComputeCode(e, i) {
    return `${this.getSignature()}
// directives
${e.directives}

// system
var<private> instanceIndex : u32;

// locals
${e.scopedArrays}

// uniforms
${e.uniforms}

// codes
${e.codes}

@compute @workgroup_size( ${i} )
fn main( ${e.attributes} ) {

	// system
	instanceIndex = id.x + id.y * numWorkgroups.x * u32(${i}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${i});

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  _getWGSLStruct(e, i) {
    return `
struct ${e} {
${i}
};`;
  }
  _getWGSLStructBinding(e, i, n, s = 0, a = 0) {
    const o = e + "Struct";
    return `${this._getWGSLStruct(o, i)}
@binding( ${s} ) @group( ${a} )
var<${n}> ${e} : ${o};`;
  }
}
class fJ {
  constructor(e) {
    this.backend = e;
  }
  getCurrentDepthStencilFormat(e) {
    let i;
    return e.depthTexture !== null ? i = this.getTextureFormatGPU(e.depthTexture) : e.depth && e.stencil ? i = $.Depth24PlusStencil8 : e.depth && (i = $.Depth24Plus), i;
  }
  getTextureFormatGPU(e) {
    return this.backend.get(e).format;
  }
  getCurrentColorFormat(e) {
    let i;
    return e.textures !== null ? i = this.getTextureFormatGPU(e.textures[0]) : i = this.getPreferredCanvasFormat(), i;
  }
  getCurrentColorSpace(e) {
    return e.textures !== null ? e.textures[0].colorSpace : this.backend.renderer.outputColorSpace;
  }
  getPrimitiveTopology(e, i) {
    if (e.isPoints) return ju.PointList;
    if (e.isLineSegments || e.isMesh && i.wireframe === !0) return ju.LineList;
    if (e.isLine) return ju.LineStrip;
    if (e.isMesh) return ju.TriangleList;
  }
  getSampleCount(e) {
    let i = 1;
    return e > 1 && (i = Math.pow(2, Math.floor(Math.log2(e))), i === 2 && (i = 4)), i;
  }
  getSampleCountRenderContext(e) {
    return e.textures !== null ? this.getSampleCount(e.sampleCount) : this.getSampleCount(this.backend.renderer.samples);
  }
  getPreferredCanvasFormat() {
    return navigator.userAgent.includes("Quest") ? $.BGRA8Unorm : navigator.gpu.getPreferredCanvasFormat();
  }
}
const mJ = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]), gJ = /* @__PURE__ */ new Map([
  [hP, ["float16"]]
]), yJ = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Int16Array, "sint32"],
  // patch for INT16
  [Uint32Array, "uint32"],
  [Uint16Array, "uint32"],
  // patch for UINT16
  [Float32Array, "float32"]
]);
class vJ {
  constructor(e) {
    this.backend = e;
  }
  createAttribute(e, i) {
    const n = this._getBufferAttribute(e), s = this.backend, a = s.get(n);
    let o = a.buffer;
    if (o === void 0) {
      const l = s.device;
      let u = n.array;
      if (e.normalized === !1 && (u.constructor === Int16Array || u.constructor === Uint16Array)) {
        const h = new Uint32Array(u.length);
        for (let d = 0; d < u.length; d++)
          h[d] = u[d];
        u = h;
      }
      if (n.array = u, (n.isStorageBufferAttribute || n.isStorageInstancedBufferAttribute) && n.itemSize === 3) {
        u = new u.constructor(n.count * 4);
        for (let h = 0; h < n.count; h++)
          u.set(n.array.subarray(h * 3, h * 3 + 3), h * 4);
        n.itemSize = 4, n.array = u;
      }
      const c = u.byteLength + (4 - u.byteLength % 4) % 4;
      o = l.createBuffer({
        label: n.name,
        size: c,
        usage: i,
        mappedAtCreation: !0
      }), new u.constructor(o.getMappedRange()).set(u), o.unmap(), a.buffer = o;
    }
  }
  updateAttribute(e) {
    const i = this._getBufferAttribute(e), n = this.backend, s = n.device, a = n.get(i).buffer, o = i.array, l = i.updateRanges;
    if (l.length === 0)
      s.queue.writeBuffer(
        a,
        0,
        o,
        0
      );
    else {
      for (let u = 0, c = l.length; u < c; u++) {
        const h = l[u];
        s.queue.writeBuffer(
          a,
          0,
          o,
          h.start * o.BYTES_PER_ELEMENT,
          h.count * o.BYTES_PER_ELEMENT
        );
      }
      i.clearUpdateRanges();
    }
  }
  createShaderVertexBuffers(e) {
    const i = e.getAttributes(), n = /* @__PURE__ */ new Map();
    for (let s = 0; s < i.length; s++) {
      const a = i[s], o = a.array.BYTES_PER_ELEMENT, l = this._getBufferAttribute(a);
      let u = n.get(l);
      if (u === void 0) {
        let d, p;
        a.isInterleavedBufferAttribute === !0 ? (d = a.data.stride * o, p = a.data.isInstancedInterleavedBuffer ? yf.Instance : yf.Vertex) : (d = a.itemSize * o, p = a.isInstancedBufferAttribute ? yf.Instance : yf.Vertex), a.normalized === !1 && (a.array.constructor === Int16Array || a.array.constructor === Uint16Array) && (d = 4), u = {
          arrayStride: d,
          attributes: [],
          stepMode: p
        }, n.set(l, u);
      }
      const c = this._getVertexFormat(a), h = a.isInterleavedBufferAttribute === !0 ? a.offset * o : 0;
      u.attributes.push({
        shaderLocation: s,
        offset: h,
        format: c
      });
    }
    return Array.from(n.values());
  }
  destroyAttribute(e) {
    const i = this.backend;
    i.get(this._getBufferAttribute(e)).buffer.destroy(), i.delete(e);
  }
  async getArrayBufferAsync(e) {
    const i = this.backend, n = i.device, s = i.get(this._getBufferAttribute(e)).buffer, a = s.size, o = n.createBuffer({
      label: e.name,
      size: a,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    }), l = n.createCommandEncoder({});
    l.copyBufferToBuffer(
      s,
      0,
      o,
      0,
      a
    ), o.unmap();
    const u = l.finish();
    return n.queue.submit([u]), await o.mapAsync(GPUMapMode.READ), o.getMappedRange();
  }
  _getVertexFormat(e) {
    const { itemSize: i, normalized: n } = e, s = e.array.constructor, a = e.constructor;
    let o;
    if (i == 1)
      o = yJ.get(s);
    else {
      const l = (gJ.get(a) || mJ.get(s))[n ? 1 : 0];
      if (l) {
        const u = s.BYTES_PER_ELEMENT * i, c = Math.floor((u + 3) / 4) * 4 / s.BYTES_PER_ELEMENT;
        if (c % 1)
          throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
        o = `${l}x${c}`;
      }
    }
    return o || console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet."), o;
  }
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
class bJ {
  constructor(e) {
    this.backend = e, this.bindGroupLayoutCache = /* @__PURE__ */ new WeakMap();
  }
  createBindingsLayout(e) {
    const i = this.backend.device, n = [];
    let s = 0;
    for (const a of e.bindings) {
      const o = {
        binding: s++,
        visibility: a.visibility
      };
      if (a.isUniformBuffer || a.isStorageBuffer) {
        const l = {};
        a.isStorageBuffer && (l.type = a.access), o.buffer = l;
      } else if (a.isSampler) {
        const l = {};
        a.texture.isDepthTexture && a.texture.compareFunction !== null && (l.type = "comparison"), o.sampler = l;
      } else if (a.isSampledTexture && a.texture.isVideoTexture)
        o.externalTexture = {};
      else if (a.isSampledTexture && a.store) {
        const l = this.backend.get(a.texture).texture.format, u = a.access;
        o.storageTexture = { format: l, access: u };
      } else if (a.isSampledTexture) {
        const l = {};
        if (a.texture.isMultisampleRenderTargetTexture === !0 && (l.multisampled = !0), a.texture.isDepthTexture)
          l.sampleType = Mh.Depth;
        else if (a.texture.isDataTexture || a.texture.isDataArrayTexture || a.texture.isData3DTexture) {
          const u = a.texture.type;
          u === Tr ? l.sampleType = Mh.SInt : u === Ji ? l.sampleType = Mh.UInt : u === cn && (this.backend.hasFeature("float32-filterable") ? l.sampleType = Mh.Float : l.sampleType = Mh.UnfilterableFloat);
        }
        a.isSampledCubeTexture ? l.viewDimension = xn.Cube : a.texture.isDataArrayTexture || a.texture.isCompressedArrayTexture ? l.viewDimension = xn.TwoDArray : a.isSampledTexture3D && (l.viewDimension = xn.ThreeD), o.texture = l;
      } else
        console.error(`WebGPUBindingUtils: Unsupported binding "${a}".`);
      n.push(o);
    }
    return i.createBindGroupLayout({ entries: n });
  }
  createBindings(e) {
    const { backend: i, bindGroupLayoutCache: n } = this, s = i.get(e);
    let a = n.get(e.bindingsReference);
    a === void 0 && (a = this.createBindingsLayout(e), n.set(e.bindingsReference, a));
    const o = this.createBindGroup(e, a);
    s.layout = a, s.group = o;
  }
  updateBinding(e) {
    const i = this.backend, n = i.device, s = e.buffer, a = i.get(e).buffer;
    n.queue.writeBuffer(a, 0, s, 0);
  }
  createBindGroup(e, i) {
    const n = this.backend, s = n.device;
    let a = 0;
    const o = [];
    for (const l of e.bindings) {
      if (l.isUniformBuffer) {
        const u = n.get(l);
        if (u.buffer === void 0) {
          const c = l.byteLength, h = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, d = s.createBuffer({
            label: "bindingBuffer_" + l.name,
            size: c,
            usage: h
          });
          u.buffer = d;
        }
        o.push({ binding: a, resource: { buffer: u.buffer } });
      } else if (l.isStorageBuffer) {
        const u = n.get(l);
        if (u.buffer === void 0) {
          const c = l.attribute;
          u.buffer = n.get(c).buffer;
        }
        o.push({ binding: a, resource: { buffer: u.buffer } });
      } else if (l.isSampler) {
        const u = n.get(l.texture);
        o.push({ binding: a, resource: u.sampler });
      } else if (l.isSampledTexture) {
        const u = n.get(l.texture);
        let c;
        if (u.externalTexture !== void 0)
          c = s.importExternalTexture({ source: u.externalTexture });
        else {
          const h = l.store ? 1 : u.texture.mipLevelCount, d = `view-${u.texture.width}-${u.texture.height}-${h}`;
          if (c = u[d], c === void 0) {
            const p = aQ.All;
            let f;
            l.isSampledCubeTexture ? f = xn.Cube : l.isSampledTexture3D ? f = xn.ThreeD : l.texture.isDataArrayTexture || l.texture.isCompressedArrayTexture ? f = xn.TwoDArray : f = xn.TwoD, c = u[d] = u.texture.createView({ aspect: p, dimension: f, mipLevelCount: h });
          }
        }
        o.push({ binding: a, resource: c });
      }
      a++;
    }
    return s.createBindGroup({
      label: "bindGroup_" + e.name,
      layout: i,
      entries: o
    });
  }
}
class xJ {
  constructor(e) {
    this.backend = e;
  }
  _getSampleCount(e) {
    return this.backend.utils.getSampleCountRenderContext(e);
  }
  createRenderPipeline(e, i) {
    const { object: n, material: s, geometry: a, pipeline: o } = e, { vertexProgram: l, fragmentProgram: u } = o, c = this.backend, h = c.device, d = c.utils, p = c.get(o), f = [];
    for (const F of e.getBindings()) {
      const M = c.get(F);
      f.push(M.layout);
    }
    const m = c.attributeUtils.createShaderVertexBuffers(e);
    let v;
    s.transparent === !0 && s.blending !== _c && (v = this._getBlending(s));
    let y = {};
    s.stencilWrite === !0 && (y = {
      compare: this._getStencilCompare(s),
      failOp: this._getStencilOperation(s.stencilFail),
      depthFailOp: this._getStencilOperation(s.stencilZFail),
      passOp: this._getStencilOperation(s.stencilZPass)
    });
    const g = this._getColorWriteMask(s), _ = [];
    if (e.context.textures !== null) {
      const F = e.context.textures;
      for (let M = 0; M < F.length; M++) {
        const P = d.getTextureFormatGPU(F[M]);
        _.push({
          format: P,
          blend: v,
          writeMask: g
        });
      }
    } else {
      const F = d.getCurrentColorFormat(e.context);
      _.push({
        format: F,
        blend: v,
        writeMask: g
      });
    }
    const x = c.get(l).module, b = c.get(u).module, T = this._getPrimitiveState(n, a, s), S = this._getDepthCompare(s), w = d.getCurrentDepthStencilFormat(e.context), C = this._getSampleCount(e.context), E = {
      label: `renderPipeline_${s.name || s.type}_${s.id}`,
      vertex: Object.assign({}, x, { buffers: m }),
      fragment: Object.assign({}, b, { targets: _ }),
      primitive: T,
      multisample: {
        count: C,
        alphaToCoverageEnabled: s.alphaToCoverage && C > 1
      },
      layout: h.createPipelineLayout({
        bindGroupLayouts: f
      })
    }, A = {}, N = e.context.depth, L = e.context.stencil;
    if ((N === !0 || L === !0) && (N === !0 && (A.format = w, A.depthWriteEnabled = s.depthWrite, A.depthCompare = S), L === !0 && (A.stencilFront = y, A.stencilBack = {}, A.stencilReadMask = s.stencilFuncMask, A.stencilWriteMask = s.stencilWriteMask), E.depthStencil = A), i === null)
      p.pipeline = h.createRenderPipeline(E);
    else {
      const F = new Promise((M) => {
        h.createRenderPipelineAsync(E).then((P) => {
          p.pipeline = P, M();
        });
      });
      i.push(F);
    }
  }
  createBundleEncoder(e) {
    const i = this.backend, { utils: n, device: s } = i, a = n.getCurrentDepthStencilFormat(e), o = n.getCurrentColorFormat(e), l = this._getSampleCount(e), u = {
      label: "renderBundleEncoder",
      colorFormats: [o],
      depthStencilFormat: a,
      sampleCount: l
    };
    return s.createRenderBundleEncoder(u);
  }
  createComputePipeline(e, i) {
    const n = this.backend, s = n.device, a = n.get(e.computeProgram).module, o = n.get(e), l = [];
    for (const u of i) {
      const c = n.get(u);
      l.push(c.layout);
    }
    o.pipeline = s.createComputePipeline({
      compute: a,
      layout: s.createPipelineLayout({
        bindGroupLayouts: l
      })
    });
  }
  _getBlending(e) {
    let i, n;
    const s = e.blending, a = e.blendSrc, o = e.blendDst, l = e.blendEquation;
    if (s === IN) {
      const u = e.blendSrcAlpha !== null ? e.blendSrcAlpha : a, c = e.blendDstAlpha !== null ? e.blendDstAlpha : o, h = e.blendEquationAlpha !== null ? e.blendEquationAlpha : l;
      i = {
        srcFactor: this._getBlendFactor(a),
        dstFactor: this._getBlendFactor(o),
        operation: this._getBlendOperation(l)
      }, n = {
        srcFactor: this._getBlendFactor(u),
        dstFactor: this._getBlendFactor(c),
        operation: this._getBlendOperation(h)
      };
    } else {
      const u = e.premultipliedAlpha, c = (h, d, p, f) => {
        i = {
          srcFactor: h,
          dstFactor: d,
          operation: jo.Add
        }, n = {
          srcFactor: p,
          dstFactor: f,
          operation: jo.Add
        };
      };
      if (u)
        switch (s) {
          case po:
            c(bt.One, bt.OneMinusSrcAlpha, bt.One, bt.OneMinusSrcAlpha);
            break;
          case Rm:
            c(bt.One, bt.One, bt.One, bt.One);
            break;
          case Nm:
            c(bt.Zero, bt.OneMinusSrc, bt.Zero, bt.One);
            break;
          case Pm:
            c(bt.Zero, bt.Src, bt.Zero, bt.SrcAlpha);
            break;
        }
      else
        switch (s) {
          case po:
            c(bt.SrcAlpha, bt.OneMinusSrcAlpha, bt.One, bt.OneMinusSrcAlpha);
            break;
          case Rm:
            c(bt.SrcAlpha, bt.One, bt.SrcAlpha, bt.One);
            break;
          case Nm:
            c(bt.Zero, bt.OneMinusSrc, bt.Zero, bt.One);
            break;
          case Pm:
            c(bt.Zero, bt.Src, bt.Zero, bt.Src);
            break;
        }
    }
    if (i !== void 0 && n !== void 0)
      return { color: i, alpha: n };
    console.error("THREE.WebGPURenderer: Invalid blending: ", s);
  }
  _getBlendFactor(e) {
    let i;
    switch (e) {
      case LN:
        i = bt.Zero;
        break;
      case UN:
        i = bt.One;
        break;
      case FN:
        i = bt.Src;
        break;
      case BN:
        i = bt.OneMinusSrc;
        break;
      case Om:
        i = bt.SrcAlpha;
        break;
      case Im:
        i = bt.OneMinusSrcAlpha;
        break;
      case VN:
        i = bt.Dst;
        break;
      case GN:
        i = bt.OneMinusDstColor;
        break;
      case zN:
        i = bt.DstAlpha;
        break;
      case jN:
        i = bt.OneMinusDstAlpha;
        break;
      case HN:
        i = bt.SrcAlphaSaturated;
        break;
      case DK:
        i = bt.Constant;
        break;
      case kK:
        i = bt.OneMinusConstant;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend factor not supported.", e);
    }
    return i;
  }
  _getStencilCompare(e) {
    let i;
    const n = e.stencilFunc;
    switch (n) {
      case r7:
        i = Qi.Never;
        break;
      case yx:
        i = Qi.Always;
        break;
      case n7:
        i = Qi.Less;
        break;
      case a7:
        i = Qi.LessEqual;
        break;
      case s7:
        i = Qi.Equal;
        break;
      case u7:
        i = Qi.GreaterEqual;
        break;
      case o7:
        i = Qi.Greater;
        break;
      case l7:
        i = Qi.NotEqual;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil function.", n);
    }
    return i;
  }
  _getStencilOperation(e) {
    let i;
    switch (e) {
      case Wo:
        i = qa.Keep;
        break;
      case K9:
        i = qa.Zero;
        break;
      case Q9:
        i = qa.Replace;
        break;
      case i7:
        i = qa.Invert;
        break;
      case Z9:
        i = qa.IncrementClamp;
        break;
      case J9:
        i = qa.DecrementClamp;
        break;
      case e7:
        i = qa.IncrementWrap;
        break;
      case t7:
        i = qa.DecrementWrap;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil operation.", i);
    }
    return i;
  }
  _getBlendOperation(e) {
    let i;
    switch (e) {
      case io:
        i = jo.Add;
        break;
      case DN:
        i = jo.Subtract;
        break;
      case kN:
        i = jo.ReverseSubtract;
        break;
      case O9:
        i = jo.Min;
        break;
      case I9:
        i = jo.Max;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.", e);
    }
    return i;
  }
  _getPrimitiveState(e, i, n) {
    const s = {}, a = this.backend.utils;
    switch (s.topology = a.getPrimitiveTopology(e, n), i.index !== null && e.isLine === !0 && e.isLineSegments !== !0 && (s.stripIndexFormat = i.index.array instanceof Uint16Array ? Ac.Uint16 : Ac.Uint32), n.side) {
      case xc:
        s.frontFace = J0.CCW, s.cullMode = ev.Back;
        break;
      case es:
        s.frontFace = J0.CCW, s.cullMode = ev.Front;
        break;
      case $u:
        s.frontFace = J0.CCW, s.cullMode = ev.None;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.", n.side);
        break;
    }
    return s;
  }
  _getColorWriteMask(e) {
    return e.colorWrite === !0 ? VM.All : VM.None;
  }
  _getDepthCompare(e) {
    let i;
    if (e.depthTest === !1)
      i = Qi.Always;
    else {
      const n = e.depthFunc;
      switch (n) {
        case WN:
          i = Qi.Never;
          break;
        case qN:
          i = Qi.Always;
          break;
        case XN:
          i = Qi.Less;
          break;
        case Dm:
          i = Qi.LessEqual;
          break;
        case YN:
          i = Qi.Equal;
          break;
        case $N:
          i = Qi.GreaterEqual;
          break;
        case KN:
          i = Qi.Greater;
          break;
        case QN:
          i = Qi.NotEqual;
          break;
        default:
          console.error("THREE.WebGPUPipelineUtils: Invalid depth function.", n);
      }
    }
    return i;
  }
}
class _J extends aO {
  constructor(e = {}) {
    super(e), this.isWebGPUBackend = !0, this.parameters.alpha = e.alpha === void 0 ? !0 : e.alpha, this.parameters.requiredLimits = e.requiredLimits === void 0 ? {} : e.requiredLimits, this.trackTimestamp = e.trackTimestamp === !0, this.device = null, this.context = null, this.colorBuffer = null, this.defaultRenderPassdescriptor = null, this.utils = new fJ(this), this.attributeUtils = new vJ(this), this.bindingUtils = new bJ(this), this.pipelineUtils = new xJ(this), this.textureUtils = new sJ(this), this.occludedResolveCache = /* @__PURE__ */ new Map();
  }
  async init(e) {
    await super.init(e);
    const i = this.parameters;
    let n;
    if (i.device === void 0) {
      const o = {
        powerPreference: i.powerPreference
      }, l = await navigator.gpu.requestAdapter(o);
      if (l === null)
        throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
      const u = Object.values(Ix), c = [];
      for (const d of u)
        l.features.has(d) && c.push(d);
      const h = {
        requiredFeatures: c,
        requiredLimits: i.requiredLimits
      };
      n = await l.requestDevice(h);
    } else
      n = i.device;
    n.lost.then((o) => {
      const l = {
        api: "WebGPU",
        message: o.message || "Unknown reason",
        reason: o.reason || null,
        originalEvent: o
      };
      e.onDeviceLost(l);
    });
    const s = i.context !== void 0 ? i.context : e.domElement.getContext("webgpu");
    this.device = n, this.context = s;
    const a = i.alpha ? "premultiplied" : "opaque";
    this.trackTimestamp = this.trackTimestamp && this.hasFeature(Ix.TimestampQuery), this.context.configure({
      device: this.device,
      format: this.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
      alphaMode: a
    }), this.updateSize();
  }
  get coordinateSystem() {
    return Ml;
  }
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  getContext() {
    return this.context;
  }
  _getDefaultRenderPassDescriptor() {
    let e = this.defaultRenderPassdescriptor;
    if (e === null) {
      const n = this.renderer;
      e = {
        colorAttachments: [{
          view: null
        }]
      }, (this.renderer.depth === !0 || this.renderer.stencil === !0) && (e.depthStencilAttachment = {
        view: this.textureUtils.getDepthBuffer(n.depth, n.stencil).createView()
      });
      const s = e.colorAttachments[0];
      this.renderer.samples > 0 ? s.view = this.colorBuffer.createView() : s.resolveTarget = void 0, this.defaultRenderPassdescriptor = e;
    }
    const i = e.colorAttachments[0];
    return this.renderer.samples > 0 ? i.resolveTarget = this.context.getCurrentTexture().createView() : i.view = this.context.getCurrentTexture().createView(), e;
  }
  _getRenderPassDescriptor(e) {
    const i = e.renderTarget, n = this.get(i);
    let s = n.descriptors;
    if (s === void 0 || n.width !== i.width || n.height !== i.height || n.activeMipmapLevel !== i.activeMipmapLevel || n.samples !== i.samples) {
      s = {}, n.descriptors = s;
      const l = () => {
        i.removeEventListener("dispose", l), this.delete(i);
      };
      i.addEventListener("dispose", l);
    }
    const a = e.getCacheKey();
    let o = s[a];
    if (o === void 0) {
      const l = e.textures, u = [];
      for (let c = 0; c < l.length; c++) {
        const h = this.get(l[c]), d = h.texture.createView({
          baseMipLevel: e.activeMipmapLevel,
          mipLevelCount: 1,
          baseArrayLayer: e.activeCubeFace,
          dimension: xn.TwoD
        });
        let p, f;
        h.msaaTexture !== void 0 ? (p = h.msaaTexture.createView(), f = d) : (p = d, f = void 0), u.push({
          view: p,
          resolveTarget: f,
          loadOp: Ii.Load,
          storeOp: Zi.Store
        });
      }
      if (o = {
        colorAttachments: u
      }, e.depth) {
        const c = {
          view: this.get(e.depthTexture).texture.createView()
        };
        o.depthStencilAttachment = c;
      }
      s[a] = o, n.width = i.width, n.height = i.height, n.samples = i.samples, n.activeMipmapLevel = i.activeMipmapLevel;
    }
    return o;
  }
  beginRender(e) {
    const i = this.get(e), n = this.device, s = e.occlusionQueryCount;
    let a;
    s > 0 && (i.currentOcclusionQuerySet && i.currentOcclusionQuerySet.destroy(), i.currentOcclusionQueryBuffer && i.currentOcclusionQueryBuffer.destroy(), i.currentOcclusionQuerySet = i.occlusionQuerySet, i.currentOcclusionQueryBuffer = i.occlusionQueryBuffer, i.currentOcclusionQueryObjects = i.occlusionQueryObjects, a = n.createQuerySet({ type: "occlusion", count: s }), i.occlusionQuerySet = a, i.occlusionQueryIndex = 0, i.occlusionQueryObjects = new Array(s), i.lastOcclusionObject = null);
    let o;
    e.textures === null ? o = this._getDefaultRenderPassDescriptor() : o = this._getRenderPassDescriptor(e), this.initTimestampQuery(e, o), o.occlusionQuerySet = a;
    const l = o.depthStencilAttachment;
    if (e.textures !== null) {
      const h = o.colorAttachments;
      for (let d = 0; d < h.length; d++) {
        const p = h[d];
        e.clearColor ? (p.clearValue = d === 0 ? e.clearColorValue : { r: 0, g: 0, b: 0, a: 1 }, p.loadOp = Ii.Clear, p.storeOp = Zi.Store) : (p.loadOp = Ii.Load, p.storeOp = Zi.Store);
      }
    } else {
      const h = o.colorAttachments[0];
      e.clearColor ? (h.clearValue = e.clearColorValue, h.loadOp = Ii.Clear, h.storeOp = Zi.Store) : (h.loadOp = Ii.Load, h.storeOp = Zi.Store);
    }
    e.depth && (e.clearDepth ? (l.depthClearValue = e.clearDepthValue, l.depthLoadOp = Ii.Clear, l.depthStoreOp = Zi.Store) : (l.depthLoadOp = Ii.Load, l.depthStoreOp = Zi.Store)), e.stencil && (e.clearStencil ? (l.stencilClearValue = e.clearStencilValue, l.stencilLoadOp = Ii.Clear, l.stencilStoreOp = Zi.Store) : (l.stencilLoadOp = Ii.Load, l.stencilStoreOp = Zi.Store));
    const u = n.createCommandEncoder({ label: "renderContext_" + e.id }), c = u.beginRenderPass(o);
    if (i.descriptor = o, i.encoder = u, i.currentPass = c, i.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, i.renderBundles = [], e.viewport && this.updateViewport(e), e.scissor) {
      const { x: h, y: d, width: p, height: f } = e.scissorValue;
      c.setScissorRect(h, d, p, f);
    }
  }
  finishRender(e) {
    const i = this.get(e), n = e.occlusionQueryCount;
    if (i.renderBundles.length > 0 && i.currentPass.executeBundles(i.renderBundles), n > i.occlusionQueryIndex && i.currentPass.endOcclusionQuery(), i.currentPass.end(), n > 0) {
      const s = n * 8;
      let a = this.occludedResolveCache.get(s);
      a === void 0 && (a = this.device.createBuffer(
        {
          size: s,
          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
        }
      ), this.occludedResolveCache.set(s, a));
      const o = this.device.createBuffer(
        {
          size: s,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        }
      );
      i.encoder.resolveQuerySet(i.occlusionQuerySet, 0, n, a, 0), i.encoder.copyBufferToBuffer(a, 0, o, 0, s), i.occlusionQueryBuffer = o, this.resolveOccludedAsync(e);
    }
    if (this.prepareTimestampBuffer(e, i.encoder), this.device.queue.submit([i.encoder.finish()]), e.textures !== null) {
      const s = e.textures;
      for (let a = 0; a < s.length; a++) {
        const o = s[a];
        o.generateMipmaps === !0 && this.textureUtils.generateMipmaps(o);
      }
    }
  }
  isOccluded(e, i) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(i);
  }
  async resolveOccludedAsync(e) {
    const i = this.get(e), { currentOcclusionQueryBuffer: n, currentOcclusionQueryObjects: s } = i;
    if (n && s) {
      const a = /* @__PURE__ */ new WeakSet();
      i.currentOcclusionQueryObjects = null, i.currentOcclusionQueryBuffer = null, await n.mapAsync(GPUMapMode.READ);
      const o = n.getMappedRange(), l = new BigUint64Array(o);
      for (let u = 0; u < s.length; u++)
        l[u] !== BigInt(0) && a.add(s[u]);
      n.destroy(), i.occluded = a;
    }
  }
  updateViewport(e) {
    const { currentPass: i } = this.get(e), { x: n, y: s, width: a, height: o, minDepth: l, maxDepth: u } = e.viewportValue;
    i.setViewport(n, s, a, o, l, u);
  }
  clear(e, i, n, s = null) {
    const a = this.device, o = this.renderer;
    let l = [], u, c, h, d;
    if (e) {
      const f = this.getClearColor();
      if (this.renderer.alpha === !0) {
        const m = f.a;
        c = { r: f.r * m, g: f.g * m, b: f.b * m, a: m };
      } else
        c = { r: f.r, g: f.g, b: f.b, a: f.a };
    }
    if (s === null) {
      h = o.depth, d = o.stencil;
      const f = this._getDefaultRenderPassDescriptor();
      if (e) {
        l = f.colorAttachments;
        const m = l[0];
        m.clearValue = c, m.loadOp = Ii.Clear, m.storeOp = Zi.Store;
      }
      (h || d) && (u = f.depthStencilAttachment);
    } else {
      if (h = s.depth, d = s.stencil, e)
        for (const f of s.textures) {
          const m = this.get(f), v = m.texture.createView();
          let y, g;
          m.msaaTexture !== void 0 ? (y = m.msaaTexture.createView(), g = v) : (y = v, g = void 0), l.push({
            view: y,
            resolveTarget: g,
            clearValue: c,
            loadOp: Ii.Clear,
            storeOp: Zi.Store
          });
        }
      (h || d) && (u = {
        view: this.get(s.depthTexture).texture.createView()
      });
    }
    h && (i ? (u.depthLoadOp = Ii.Clear, u.depthClearValue = o.getClearDepth(), u.depthStoreOp = Zi.Store) : (u.depthLoadOp = Ii.Load, u.depthStoreOp = Zi.Store)), d && (n ? (u.stencilLoadOp = Ii.Clear, u.stencilClearValue = o.getClearStencil(), u.stencilStoreOp = Zi.Store) : (u.stencilLoadOp = Ii.Load, u.stencilStoreOp = Zi.Store));
    const p = a.createCommandEncoder({});
    p.beginRenderPass({
      colorAttachments: l,
      depthStencilAttachment: u
    }).end(), a.queue.submit([p.finish()]);
  }
  // compute
  beginCompute(e) {
    const i = this.get(e), n = {};
    this.initTimestampQuery(e, n), i.cmdEncoderGPU = this.device.createCommandEncoder(), i.passEncoderGPU = i.cmdEncoderGPU.beginComputePass(n);
  }
  compute(e, i, n, s) {
    const { passEncoderGPU: a } = this.get(e), o = this.get(s).pipeline;
    a.setPipeline(o);
    for (let h = 0, d = n.length; h < d; h++) {
      const p = n[h], f = this.get(p);
      a.setBindGroup(h, f.group);
    }
    const l = this.device.limits.maxComputeWorkgroupsPerDimension, u = this.get(i);
    u.dispatchSize === void 0 && (u.dispatchSize = { x: 0, y: 1, z: 1 });
    const { dispatchSize: c } = u;
    i.dispatchCount > l ? (c.x = Math.min(i.dispatchCount, l), c.y = Math.ceil(i.dispatchCount / l)) : c.x = i.dispatchCount, a.dispatchWorkgroups(
      c.x,
      c.y,
      c.z
    );
  }
  finishCompute(e) {
    const i = this.get(e);
    i.passEncoderGPU.end(), this.prepareTimestampBuffer(e, i.cmdEncoderGPU), this.device.queue.submit([i.cmdEncoderGPU.finish()]);
  }
  async waitForGPU() {
    await this.device.queue.onSubmittedWorkDone();
  }
  // render object
  draw(e, i) {
    const { object: n, context: s, pipeline: a } = e, o = e.getBindings(), l = this.get(s), u = this.get(a).pipeline, c = l.currentSets, h = l.currentPass, d = e.getDrawParameters();
    if (d === null) return;
    c.pipeline !== u && (h.setPipeline(u), c.pipeline = u);
    const p = c.bindingGroups;
    for (let y = 0, g = o.length; y < g; y++) {
      const _ = o[y], x = this.get(_);
      p[_.index] !== _.id && (h.setBindGroup(_.index, x.group), p[_.index] = _.id);
    }
    const f = e.getIndex(), m = f !== null;
    if (m === !0 && c.index !== f) {
      const y = this.get(f).buffer, g = f.array instanceof Uint16Array ? Ac.Uint16 : Ac.Uint32;
      h.setIndexBuffer(y, g), c.index = f;
    }
    const v = e.getVertexBuffers();
    for (let y = 0, g = v.length; y < g; y++) {
      const _ = v[y];
      if (c.attributes[y] !== _) {
        const x = this.get(_).buffer;
        h.setVertexBuffer(y, x), c.attributes[y] = _;
      }
    }
    if (l.occlusionQuerySet !== void 0) {
      const y = l.lastOcclusionObject;
      y !== n && (y !== null && y.occlusionTest === !0 && (h.endOcclusionQuery(), l.occlusionQueryIndex++), n.occlusionTest === !0 && (h.beginOcclusionQuery(l.occlusionQueryIndex), l.occlusionQueryObjects[l.occlusionQueryIndex] = n), l.lastOcclusionObject = n);
    }
    if (n.isBatchedMesh === !0) {
      const y = n._multiDrawStarts, g = n._multiDrawCounts, _ = n._multiDrawCount, x = n._multiDrawInstances, b = m ? f.array.BYTES_PER_ELEMENT : 1;
      for (let T = 0; T < _; T++) {
        const S = x ? x[T] : 1, w = S > 1 ? 0 : T;
        h.drawIndexed(g[T], S, y[T] / b, 0, w);
      }
    } else if (m === !0) {
      const { vertexCount: y, instanceCount: g, firstVertex: _ } = d, x = e.getIndirect();
      if (x !== null) {
        const b = this.get(x).buffer;
        h.drawIndexedIndirect(b, 0);
      } else
        h.drawIndexed(y, g, _, 0, 0);
      i.update(n, y, g);
    } else {
      const { vertexCount: y, instanceCount: g, firstVertex: _ } = d, x = e.getIndirect();
      if (x !== null) {
        const b = this.get(x).buffer;
        h.drawIndirect(b, 0);
      } else
        h.draw(y, g, _, 0);
      i.update(n, y, g);
    }
  }
  // cache key
  needsRenderUpdate(e) {
    const i = this.get(e), { object: n, material: s } = e, a = this.utils, o = a.getSampleCountRenderContext(e.context), l = a.getCurrentColorSpace(e.context), u = a.getCurrentColorFormat(e.context), c = a.getCurrentDepthStencilFormat(e.context), h = a.getPrimitiveTopology(n, s);
    let d = !1;
    return (i.material !== s || i.materialVersion !== s.version || i.transparent !== s.transparent || i.blending !== s.blending || i.premultipliedAlpha !== s.premultipliedAlpha || i.blendSrc !== s.blendSrc || i.blendDst !== s.blendDst || i.blendEquation !== s.blendEquation || i.blendSrcAlpha !== s.blendSrcAlpha || i.blendDstAlpha !== s.blendDstAlpha || i.blendEquationAlpha !== s.blendEquationAlpha || i.colorWrite !== s.colorWrite || i.depthWrite !== s.depthWrite || i.depthTest !== s.depthTest || i.depthFunc !== s.depthFunc || i.stencilWrite !== s.stencilWrite || i.stencilFunc !== s.stencilFunc || i.stencilFail !== s.stencilFail || i.stencilZFail !== s.stencilZFail || i.stencilZPass !== s.stencilZPass || i.stencilFuncMask !== s.stencilFuncMask || i.stencilWriteMask !== s.stencilWriteMask || i.side !== s.side || i.alphaToCoverage !== s.alphaToCoverage || i.sampleCount !== o || i.colorSpace !== l || i.colorFormat !== u || i.depthStencilFormat !== c || i.primitiveTopology !== h || i.clippingContextCacheKey !== e.clippingContext.cacheKey) && (i.material = s, i.materialVersion = s.version, i.transparent = s.transparent, i.blending = s.blending, i.premultipliedAlpha = s.premultipliedAlpha, i.blendSrc = s.blendSrc, i.blendDst = s.blendDst, i.blendEquation = s.blendEquation, i.blendSrcAlpha = s.blendSrcAlpha, i.blendDstAlpha = s.blendDstAlpha, i.blendEquationAlpha = s.blendEquationAlpha, i.colorWrite = s.colorWrite, i.depthWrite = s.depthWrite, i.depthTest = s.depthTest, i.depthFunc = s.depthFunc, i.stencilWrite = s.stencilWrite, i.stencilFunc = s.stencilFunc, i.stencilFail = s.stencilFail, i.stencilZFail = s.stencilZFail, i.stencilZPass = s.stencilZPass, i.stencilFuncMask = s.stencilFuncMask, i.stencilWriteMask = s.stencilWriteMask, i.side = s.side, i.alphaToCoverage = s.alphaToCoverage, i.sampleCount = o, i.colorSpace = l, i.colorFormat = u, i.depthStencilFormat = c, i.primitiveTopology = h, i.clippingContextCacheKey = e.clippingContext.cacheKey, d = !0), d;
  }
  getRenderCacheKey(e) {
    const { object: i, material: n } = e, s = this.utils, a = e.context;
    return [
      n.transparent,
      n.blending,
      n.premultipliedAlpha,
      n.blendSrc,
      n.blendDst,
      n.blendEquation,
      n.blendSrcAlpha,
      n.blendDstAlpha,
      n.blendEquationAlpha,
      n.colorWrite,
      n.depthWrite,
      n.depthTest,
      n.depthFunc,
      n.stencilWrite,
      n.stencilFunc,
      n.stencilFail,
      n.stencilZFail,
      n.stencilZPass,
      n.stencilFuncMask,
      n.stencilWriteMask,
      n.side,
      s.getSampleCountRenderContext(a),
      s.getCurrentColorSpace(a),
      s.getCurrentColorFormat(a),
      s.getCurrentDepthStencilFormat(a),
      s.getPrimitiveTopology(i, n),
      e.getGeometryCacheKey(),
      e.clippingContext.cacheKey
    ].join();
  }
  // textures
  createSampler(e) {
    this.textureUtils.createSampler(e);
  }
  destroySampler(e) {
    this.textureUtils.destroySampler(e);
  }
  createDefaultTexture(e) {
    this.textureUtils.createDefaultTexture(e);
  }
  createTexture(e, i) {
    this.textureUtils.createTexture(e, i);
  }
  updateTexture(e, i) {
    this.textureUtils.updateTexture(e, i);
  }
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  destroyTexture(e) {
    this.textureUtils.destroyTexture(e);
  }
  copyTextureToBuffer(e, i, n, s, a, o) {
    return this.textureUtils.copyTextureToBuffer(e, i, n, s, a, o);
  }
  initTimestampQuery(e, i) {
    if (!this.trackTimestamp) return;
    const n = this.get(e);
    if (!n.timeStampQuerySet) {
      const s = this.device.createQuerySet({ type: "timestamp", count: 2 });
      Object.assign(i, {
        timestampWrites: {
          querySet: s,
          beginningOfPassWriteIndex: 0,
          // Write timestamp in index 0 when pass begins.
          endOfPassWriteIndex: 1
          // Write timestamp in index 1 when pass ends.
        }
      }), n.timeStampQuerySet = s;
    }
  }
  // timestamp utils
  prepareTimestampBuffer(e, i) {
    if (!this.trackTimestamp) return;
    const n = this.get(e), s = 2 * BigInt64Array.BYTES_PER_ELEMENT;
    n.currentTimestampQueryBuffers === void 0 && (n.currentTimestampQueryBuffers = {
      resolveBuffer: this.device.createBuffer({
        label: "timestamp resolve buffer",
        size: s,
        usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
      }),
      resultBuffer: this.device.createBuffer({
        label: "timestamp result buffer",
        size: s,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }),
      isMappingPending: !1
    });
    const { resolveBuffer: a, resultBuffer: o, isMappingPending: l } = n.currentTimestampQueryBuffers;
    l !== !0 && (i.resolveQuerySet(n.timeStampQuerySet, 0, 2, a, 0), i.copyBufferToBuffer(a, 0, o, 0, s));
  }
  async resolveTimestampAsync(e, i = "render") {
    if (!this.trackTimestamp) return;
    const n = this.get(e);
    if (n.currentTimestampQueryBuffers === void 0) return;
    const { resultBuffer: s, isMappingPending: a } = n.currentTimestampQueryBuffers;
    a !== !0 && (n.currentTimestampQueryBuffers.isMappingPending = !0, s.mapAsync(GPUMapMode.READ).then(() => {
      const o = new BigUint64Array(s.getMappedRange()), l = Number(o[1] - o[0]) / 1e6;
      this.renderer.info.updateTimestamp(i, l), s.unmap(), n.currentTimestampQueryBuffers.isMappingPending = !1;
    }));
  }
  // node builder
  createNodeBuilder(e, i) {
    return new pJ(e, i);
  }
  // program
  createProgram(e) {
    const i = this.get(e);
    i.module = {
      module: this.device.createShaderModule({ code: e.code, label: e.stage }),
      entryPoint: "main"
    };
  }
  destroyProgram(e) {
    this.delete(e);
  }
  // pipelines
  createRenderPipeline(e, i) {
    this.pipelineUtils.createRenderPipeline(e, i);
  }
  createComputePipeline(e, i) {
    this.pipelineUtils.createComputePipeline(e, i);
  }
  beginBundle(e) {
    const i = this.get(e);
    i._currentPass = i.currentPass, i._currentSets = i.currentSets, i.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, i.currentPass = this.pipelineUtils.createBundleEncoder(e);
  }
  finishBundle(e, i) {
    const n = this.get(e), s = n.currentPass.finish();
    this.get(i).bundleGPU = s, n.currentSets = n._currentSets, n.currentPass = n._currentPass;
  }
  addBundle(e, i) {
    this.get(e).renderBundles.push(this.get(i).bundleGPU);
  }
  // bindings
  createBindings(e) {
    this.bindingUtils.createBindings(e);
  }
  updateBindings(e) {
    this.bindingUtils.createBindings(e);
  }
  updateBinding(e) {
    this.bindingUtils.updateBinding(e);
  }
  // attributes
  createIndexAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createIndirectStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  // canvas
  updateSize() {
    this.colorBuffer = this.textureUtils.getColorBuffer(), this.defaultRenderPassdescriptor = null;
  }
  // utils public
  getMaxAnisotropy() {
    return 16;
  }
  hasFeature(e) {
    return this.device.features.has(e);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    let o = 0, l = 0, u = 0, c = 0, h = 0, d = 0, p = e.image.width, f = e.image.height;
    n !== null && (c = n.x, h = n.y, d = n.z || 0, p = n.width, f = n.height), s !== null && (o = s.x, l = s.y, u = s.z || 0);
    const m = this.device.createCommandEncoder({ label: "copyTextureToTexture_" + e.id + "_" + i.id }), v = this.get(e).texture, y = this.get(i).texture;
    m.copyTextureToTexture(
      {
        texture: v,
        mipLevel: a,
        origin: { x: c, y: h, z: d }
      },
      {
        texture: y,
        mipLevel: a,
        origin: { x: o, y: l, z: u }
      },
      [
        p,
        f,
        1
      ]
    ), this.device.queue.submit([m.finish()]);
  }
  copyFramebufferToTexture(e, i, n) {
    const s = this.get(i);
    let a = null;
    i.renderTarget ? e.isDepthTexture ? a = this.get(i.depthTexture).texture : a = this.get(i.textures[0]).texture : e.isDepthTexture ? a = this.textureUtils.getDepthBuffer(i.depth, i.stencil) : a = this.context.getCurrentTexture();
    const o = this.get(e).texture;
    if (a.format !== o.format) {
      console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.", a.format, o.format);
      return;
    }
    let l;
    if (s.currentPass ? (s.currentPass.end(), l = s.encoder) : l = this.device.createCommandEncoder({ label: "copyFramebufferToTexture_" + e.id }), l.copyTextureToTexture(
      {
        texture: a,
        origin: { x: n.x, y: n.y, z: 0 }
      },
      {
        texture: o
      },
      [
        n.z,
        n.w
      ]
    ), e.generateMipmaps && this.textureUtils.generateMipmaps(e), s.currentPass) {
      const { descriptor: u } = s;
      for (let c = 0; c < u.colorAttachments.length; c++)
        u.colorAttachments[c].loadOp = Ii.Load;
      i.depth && (u.depthStencilAttachment.depthLoadOp = Ii.Load), i.stencil && (u.depthStencilAttachment.stencilLoadOp = Ii.Load), s.currentPass = l.beginRenderPass(u), s.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
    } else
      this.device.queue.submit([l.finish()]);
  }
}
class TJ extends CP {
  constructor(e, i, n, s, a, o) {
    super(e, i, n, s, a, o), this.iesMap = null;
  }
  copy(e, i) {
    return super.copy(e, i), this.iesMap = e.iesMap, this;
  }
}
class SJ extends J3 {
  constructor() {
    super(), this.addMaterial(E$, TP), this.addMaterial(B3, gT), this.addMaterial(hK, _P), this.addMaterial(mK, SP), this.addMaterial(v$, Rg), this.addMaterial(S$, EP), this.addMaterial(d$, wP), this.addMaterial(bK, MP), this.addMaterial(o$, fT), this.addMaterial(u$, AP), this.addMaterial(_K, bP), this.addMaterial(EK, yP), this.addMaterial(CK, xP), this.addLight(FQ, oW), this.addLight(fZ, uW), this.addLight(mZ, hW), this.addLight(Q3, CP), this.addLight(yZ, cW), this.addLight(vZ, nW), this.addLight(bZ, pW), this.addLight(gZ, TJ), this.addToneMapping(uQ, L9), this.addToneMapping(cQ, U9), this.addToneMapping(hQ, F9), this.addToneMapping(pQ, B9), this.addToneMapping(yQ, z9), this.addToneMapping(vQ, j9);
  }
}
class wJ extends NZ {
  constructor(e = {}) {
    let i;
    e.forceWebGL ? i = cA : (i = _J, e.getFallback = () => (console.warn("THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend."), new cA(e)));
    const n = new i(e);
    super(n, e), this.library = new SJ(), this.isWebGPURenderer = !0;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Ag
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Ag);
const gv = { type: "change" }, XT = { type: "start" }, YT = { type: "end" }, pA = 1e-6, qt = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 }, Af = new Le(), Ya = new Le(), EJ = new X(), Cf = new X(), yv = new X(), Mu = new Ts(), fA = new X(), Rf = new X(), vv = new X(), Nf = new X();
class MJ extends Sg {
  constructor(e, i = null) {
    super(e, i), this.enabled = !0, this.screen = { left: 0, top: 0, width: 0, height: 0 }, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = 0.3, this.noRotate = !1, this.noZoom = !1, this.noPan = !1, this.staticMoving = !1, this.dynamicDampingFactor = 0.2, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.keys = [
      "KeyA",
      "KeyS",
      "KeyD"
      /*D*/
    ], this.mouseButtons = { LEFT: tr.ROTATE, MIDDLE: tr.DOLLY, RIGHT: tr.PAN }, this.state = qt.NONE, this.keyState = qt.NONE, this.target = new X(), this._lastPosition = new X(), this._lastZoom = 1, this._touchZoomDistanceStart = 0, this._touchZoomDistanceEnd = 0, this._lastAngle = 0, this._eye = new X(), this._movePrev = new Le(), this._moveCurr = new Le(), this._lastAxis = new X(), this._zoomStart = new Le(), this._zoomEnd = new Le(), this._panStart = new Le(), this._panEnd = new Le(), this._pointers = [], this._pointerPositions = {}, this._onPointerMove = CJ.bind(this), this._onPointerDown = AJ.bind(this), this._onPointerUp = RJ.bind(this), this._onPointerCancel = NJ.bind(this), this._onContextMenu = UJ.bind(this), this._onMouseWheel = LJ.bind(this), this._onKeyDown = OJ.bind(this), this._onKeyUp = PJ.bind(this), this._onTouchStart = FJ.bind(this), this._onTouchMove = BJ.bind(this), this._onTouchEnd = zJ.bind(this), this._onMouseDown = IJ.bind(this), this._onMouseMove = DJ.bind(this), this._onMouseUp = kJ.bind(this), this._target0 = this.target.clone(), this._position0 = this.object.position.clone(), this._up0 = this.object.up.clone(), this._zoom0 = this.object.zoom, i !== null && (this.connect(), this.handleResize()), this.update();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown), window.addEventListener("keyup", this._onKeyUp), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  handleResize() {
    const e = this.domElement.getBoundingClientRect(), i = this.domElement.ownerDocument.documentElement;
    this.screen.left = e.left + window.pageXOffset - i.clientLeft, this.screen.top = e.top + window.pageYOffset - i.clientTop, this.screen.width = e.width, this.screen.height = e.height;
  }
  update() {
    this._eye.subVectors(this.object.position, this.target), this.noRotate || this._rotateCamera(), this.noZoom || this._zoomCamera(), this.noPan || this._panCamera(), this.object.position.addVectors(this.target, this._eye), this.object.isPerspectiveCamera ? (this._checkDistances(), this.object.lookAt(this.target), this._lastPosition.distanceToSquared(this.object.position) > pA && (this.dispatchEvent(gv), this._lastPosition.copy(this.object.position))) : this.object.isOrthographicCamera ? (this.object.lookAt(this.target), (this._lastPosition.distanceToSquared(this.object.position) > pA || this._lastZoom !== this.object.zoom) && (this.dispatchEvent(gv), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type.");
  }
  reset() {
    this.state = qt.NONE, this.keyState = qt.NONE, this.target.copy(this._target0), this.object.position.copy(this._position0), this.object.up.copy(this._up0), this.object.zoom = this._zoom0, this.object.updateProjectionMatrix(), this._eye.subVectors(this.object.position, this.target), this.object.lookAt(this.target), this.dispatchEvent(gv), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom;
  }
  _panCamera() {
    if (Ya.copy(this._panEnd).sub(this._panStart), Ya.lengthSq()) {
      if (this.object.isOrthographicCamera) {
        const e = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth, i = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;
        Ya.x *= e, Ya.y *= i;
      }
      Ya.multiplyScalar(this._eye.length() * this.panSpeed), Cf.copy(this._eye).cross(this.object.up).setLength(Ya.x), Cf.add(EJ.copy(this.object.up).setLength(Ya.y)), this.object.position.add(Cf), this.target.add(Cf), this.staticMoving ? this._panStart.copy(this._panEnd) : this._panStart.add(Ya.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
    }
  }
  _rotateCamera() {
    Nf.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
    let e = Nf.length();
    e ? (this._eye.copy(this.object.position).sub(this.target), fA.copy(this._eye).normalize(), Rf.copy(this.object.up).normalize(), vv.crossVectors(Rf, fA).normalize(), Rf.setLength(this._moveCurr.y - this._movePrev.y), vv.setLength(this._moveCurr.x - this._movePrev.x), Nf.copy(Rf.add(vv)), yv.crossVectors(Nf, this._eye).normalize(), e *= this.rotateSpeed, Mu.setFromAxisAngle(yv, e), this._eye.applyQuaternion(Mu), this.object.up.applyQuaternion(Mu), this._lastAxis.copy(yv), this._lastAngle = e) : !this.staticMoving && this._lastAngle && (this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor), this._eye.copy(this.object.position).sub(this.target), Mu.setFromAxisAngle(this._lastAxis, this._lastAngle), this._eye.applyQuaternion(Mu), this.object.up.applyQuaternion(Mu)), this._movePrev.copy(this._moveCurr);
  }
  _zoomCamera() {
    let e;
    this.state === qt.TOUCH_ZOOM_PAN ? (e = this._touchZoomDistanceStart / this._touchZoomDistanceEnd, this._touchZoomDistanceStart = this._touchZoomDistanceEnd, this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = Db.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (e = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed, e !== 1 && e > 0 && (this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = Db.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")), this.staticMoving ? this._zoomStart.copy(this._zoomEnd) : this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor);
  }
  _getMouseOnScreen(e, i) {
    return Af.set(
      (e - this.screen.left) / this.screen.width,
      (i - this.screen.top) / this.screen.height
    ), Af;
  }
  _getMouseOnCircle(e, i) {
    return Af.set(
      (e - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5),
      (this.screen.height + 2 * (this.screen.top - i)) / this.screen.width
      // screen.width intentional
    ), Af;
  }
  _addPointer(e) {
    this._pointers.push(e);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i].pointerId == e.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
  }
  _trackPointer(e) {
    let i = this._pointerPositions[e.pointerId];
    i === void 0 && (i = new Le(), this._pointerPositions[e.pointerId] = i), i.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const i = e.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[i.pointerId];
  }
  _checkDistances() {
    (!this.noZoom || !this.noPan) && (this._eye.lengthSq() > this.maxDistance * this.maxDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance)), this._zoomStart.copy(this._zoomEnd)), this._eye.lengthSq() < this.minDistance * this.minDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance)), this._zoomStart.copy(this._zoomEnd)));
  }
}
function AJ(r) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(r.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), this._addPointer(r), r.pointerType === "touch" ? this._onTouchStart(r) : this._onMouseDown(r));
}
function CJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchMove(r) : this._onMouseMove(r));
}
function RJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchEnd(r) : this._onMouseUp(), this._removePointer(r), this._pointers.length === 0 && (this.domElement.releasePointerCapture(r.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp)));
}
function NJ(r) {
  this._removePointer(r);
}
function PJ() {
  this.enabled !== !1 && (this.keyState = qt.NONE, window.addEventListener("keydown", this._onKeyDown));
}
function OJ(r) {
  this.enabled !== !1 && (window.removeEventListener("keydown", this._onKeyDown), this.keyState === qt.NONE && (r.code === this.keys[qt.ROTATE] && !this.noRotate ? this.keyState = qt.ROTATE : r.code === this.keys[qt.ZOOM] && !this.noZoom ? this.keyState = qt.ZOOM : r.code === this.keys[qt.PAN] && !this.noPan && (this.keyState = qt.PAN)));
}
function IJ(r) {
  let e;
  switch (r.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case tr.DOLLY:
      this.state = qt.ZOOM;
      break;
    case tr.ROTATE:
      this.state = qt.ROTATE;
      break;
    case tr.PAN:
      this.state = qt.PAN;
      break;
    default:
      this.state = qt.NONE;
  }
  const i = this.keyState !== qt.NONE ? this.keyState : this.state;
  i === qt.ROTATE && !this.noRotate ? (this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY)), this._movePrev.copy(this._moveCurr)) : i === qt.ZOOM && !this.noZoom ? (this._zoomStart.copy(this._getMouseOnScreen(r.pageX, r.pageY)), this._zoomEnd.copy(this._zoomStart)) : i === qt.PAN && !this.noPan && (this._panStart.copy(this._getMouseOnScreen(r.pageX, r.pageY)), this._panEnd.copy(this._panStart)), this.dispatchEvent(XT);
}
function DJ(r) {
  const e = this.keyState !== qt.NONE ? this.keyState : this.state;
  e === qt.ROTATE && !this.noRotate ? (this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY))) : e === qt.ZOOM && !this.noZoom ? this._zoomEnd.copy(this._getMouseOnScreen(r.pageX, r.pageY)) : e === qt.PAN && !this.noPan && this._panEnd.copy(this._getMouseOnScreen(r.pageX, r.pageY));
}
function kJ() {
  this.state = qt.NONE, this.dispatchEvent(YT);
}
function LJ(r) {
  if (this.enabled !== !1 && this.noZoom !== !0) {
    switch (r.preventDefault(), r.deltaMode) {
      case 2:
        this._zoomStart.y -= r.deltaY * 0.025;
        break;
      case 1:
        this._zoomStart.y -= r.deltaY * 0.01;
        break;
      default:
        this._zoomStart.y -= r.deltaY * 25e-5;
        break;
    }
    this.dispatchEvent(XT), this.dispatchEvent(YT);
  }
}
function UJ(r) {
  this.enabled !== !1 && r.preventDefault();
}
function FJ(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      this.state = qt.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY)), this._movePrev.copy(this._moveCurr);
      break;
    default:
      this.state = qt.TOUCH_ZOOM_PAN;
      const e = this._pointers[0].pageX - this._pointers[1].pageX, i = this._pointers[0].pageY - this._pointers[1].pageY;
      this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(e * e + i * i);
      const n = (this._pointers[0].pageX + this._pointers[1].pageX) / 2, s = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;
      this._panStart.copy(this._getMouseOnScreen(n, s)), this._panEnd.copy(this._panStart);
      break;
  }
  this.dispatchEvent(XT);
}
function BJ(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY));
      break;
    default:
      const e = this._getSecondPointerPosition(r), i = r.pageX - e.x, n = r.pageY - e.y;
      this._touchZoomDistanceEnd = Math.sqrt(i * i + n * n);
      const s = (r.pageX + e.x) / 2, a = (r.pageY + e.y) / 2;
      this._panEnd.copy(this._getMouseOnScreen(s, a));
      break;
  }
}
function zJ(r) {
  switch (this._pointers.length) {
    case 0:
      this.state = qt.NONE;
      break;
    case 1:
      this.state = qt.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY)), this._movePrev.copy(this._moveCurr);
      break;
    case 2:
      this.state = qt.TOUCH_ZOOM_PAN;
      for (let e = 0; e < this._pointers.length; e++)
        if (this._pointers[e].pointerId !== r.pointerId) {
          const i = this._pointerPositions[this._pointers[e].pointerId];
          this._moveCurr.copy(this._getMouseOnCircle(i.x, i.y)), this._movePrev.copy(this._moveCurr);
          break;
        }
      break;
  }
  this.dispatchEvent(YT);
}
const mA = { type: "change" }, $T = { type: "start" }, lO = { type: "end" }, Pf = new bg(), gA = new $s(), jJ = Math.cos(70 * Db.DEG2RAD), Vi = new X(), Ir = 2 * Math.PI, ti = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
}, bv = 1e-6;
class VJ extends Sg {
  constructor(e, i = null) {
    super(e, i), this.state = ti.NONE, this.enabled = !0, this.target = new X(), this.cursor = new X(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: tr.ROTATE, MIDDLE: tr.DOLLY, RIGHT: tr.PAN }, this.touches = { ONE: sa.ROTATE, TWO: sa.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new X(), this._lastQuaternion = new Ts(), this._lastTargetPosition = new X(), this._quat = new Ts().setFromUnitVectors(e.up, new X(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new Aw(), this._sphericalDelta = new Aw(), this._scale = 1, this._panOffset = new X(), this._rotateStart = new Le(), this._rotateEnd = new Le(), this._rotateDelta = new Le(), this._panStart = new Le(), this._panEnd = new Le(), this._panDelta = new Le(), this._dollyStart = new Le(), this._dollyEnd = new Le(), this._dollyDelta = new Le(), this._dollyDirection = new X(), this._mouse = new Le(), this._performCursorZoom = !1, this._pointers = [], this._pointerPositions = {}, this._controlActive = !1, this._onPointerMove = HJ.bind(this), this._onPointerDown = GJ.bind(this), this._onPointerUp = WJ.bind(this), this._onContextMenu = ZJ.bind(this), this._onMouseWheel = YJ.bind(this), this._onKeyDown = $J.bind(this), this._onTouchStart = KJ.bind(this), this._onTouchMove = QJ.bind(this), this._onMouseDown = qJ.bind(this), this._onMouseMove = XJ.bind(this), this._interceptControlDown = JJ.bind(this), this._interceptControlUp = eee.bind(this), this.domElement !== null && this.connect(), this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, { passive: !0, capture: !0 }), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, { capture: !0 }), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
  }
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
  }
  saveState() {
    this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(mA), this.update(), this.state = ti.NONE;
  }
  update(e = null) {
    const i = this.object.position;
    Vi.copy(i).sub(this.target), Vi.applyQuaternion(this._quat), this._spherical.setFromVector3(Vi), this.autoRotate && this.state === ti.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
    let n = this.minAzimuthAngle, s = this.maxAzimuthAngle;
    isFinite(n) && isFinite(s) && (n < -Math.PI ? n += Ir : n > Math.PI && (n -= Ir), s < -Math.PI ? s += Ir : s > Math.PI && (s -= Ir), n <= s ? this._spherical.theta = Math.max(n, Math.min(s, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (n + s) / 2 ? Math.max(n, this._spherical.theta) : Math.min(s, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
    let a = !1;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const o = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), a = o != this._spherical.radius;
    }
    if (Vi.setFromSpherical(this._spherical), Vi.applyQuaternion(this._quatInverse), i.copy(this.target).add(Vi), this.object.lookAt(this.target), this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
      let o = null;
      if (this.object.isPerspectiveCamera) {
        const l = Vi.length();
        o = this._clampDistance(l * this._scale);
        const u = l - o;
        this.object.position.addScaledVector(this._dollyDirection, u), this.object.updateMatrixWorld(), a = !!u;
      } else if (this.object.isOrthographicCamera) {
        const l = new X(this._mouse.x, this._mouse.y, 0);
        l.unproject(this.object);
        const u = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), a = u !== this.object.zoom;
        const c = new X(this._mouse.x, this._mouse.y, 0);
        c.unproject(this.object), this.object.position.sub(c).add(l), this.object.updateMatrixWorld(), o = Vi.length();
      } else
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = !1;
      o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : (Pf.origin.copy(this.object.position), Pf.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(Pf.direction)) < jJ ? this.object.lookAt(this.target) : (gA.setFromNormalAndCoplanarPoint(this.object.up, this.target), Pf.intersectPlane(gA, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const o = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), o !== this.object.zoom && (this.object.updateProjectionMatrix(), a = !0);
    }
    return this._scale = 1, this._performCursorZoom = !1, a || this._lastPosition.distanceToSquared(this.object.position) > bv || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > bv || this._lastTargetPosition.distanceToSquared(this.target) > bv ? (this.dispatchEvent(mA), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), !0) : !1;
  }
  _getAutoRotationAngle(e) {
    return e !== null ? Ir / 60 * this.autoRotateSpeed * e : Ir / 60 / 60 * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const i = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * i);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, i) {
    Vi.setFromMatrixColumn(i, 0), Vi.multiplyScalar(-e), this._panOffset.add(Vi);
  }
  _panUp(e, i) {
    this.screenSpacePanning === !0 ? Vi.setFromMatrixColumn(i, 1) : (Vi.setFromMatrixColumn(i, 0), Vi.crossVectors(this.object.up, Vi)), Vi.multiplyScalar(e), this._panOffset.add(Vi);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(e, i) {
    const n = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const s = this.object.position;
      Vi.copy(s).sub(this.target);
      let a = Vi.length();
      a *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * a / n.clientHeight, this.object.matrix), this._panUp(2 * i * a / n.clientHeight, this.object.matrix);
    } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / n.clientWidth, this.object.matrix), this._panUp(i * (this.object.top - this.object.bottom) / this.object.zoom / n.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = !1);
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _updateZoomParameters(e, i) {
    if (!this.zoomToCursor)
      return;
    this._performCursorZoom = !0;
    const n = this.domElement.getBoundingClientRect(), s = e - n.left, a = i - n.top, o = n.width, l = n.height;
    this._mouse.x = s / o * 2 - 1, this._mouse.y = -(a / l) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const i = this.domElement;
    this._rotateLeft(Ir * this._rotateDelta.x / i.clientHeight), this._rotateUp(Ir * this._rotateDelta.y / i.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
  }
  _handleKeyDown(e) {
    let i = !1;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(Ir * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, this.keyPanSpeed), i = !0;
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(-Ir * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, -this.keyPanSpeed), i = !0;
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(Ir * this.rotateSpeed / this.domElement.clientHeight) : this._pan(this.keyPanSpeed, 0), i = !0;
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(-Ir * this.rotateSpeed / this.domElement.clientHeight) : this._pan(-this.keyPanSpeed, 0), i = !0;
        break;
    }
    i && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1)
      this._rotateStart.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._rotateStart.set(n, s);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1)
      this._panStart.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._panStart.set(n, s);
    }
  }
  _handleTouchStartDolly(e) {
    const i = this._getSecondPointerPosition(e), n = e.pageX - i.x, s = e.pageY - i.y, a = Math.sqrt(n * n + s * s);
    this._dollyStart.set(0, a);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1)
      this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const n = this._getSecondPointerPosition(e), s = 0.5 * (e.pageX + n.x), a = 0.5 * (e.pageY + n.y);
      this._rotateEnd.set(s, a);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const i = this.domElement;
    this._rotateLeft(Ir * this._rotateDelta.x / i.clientHeight), this._rotateUp(Ir * this._rotateDelta.y / i.clientHeight), this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1)
      this._panEnd.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._panEnd.set(n, s);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const i = this._getSecondPointerPosition(e), n = e.pageX - i.x, s = e.pageY - i.y, a = Math.sqrt(n * n + s * s);
    this._dollyEnd.set(0, a), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
    const o = (e.pageX + i.x) * 0.5, l = (e.pageY + i.y) * 0.5;
    this._updateZoomParameters(o, l);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
  }
  // pointers
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i] == e.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
  }
  _isTrackingPointer(e) {
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i] == e.pointerId) return !0;
    return !1;
  }
  _trackPointer(e) {
    let i = this._pointerPositions[e.pointerId];
    i === void 0 && (i = new Le(), this._pointerPositions[e.pointerId] = i), i.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const i = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[i];
  }
  //
  _customWheelEvent(e) {
    const i = e.deltaMode, n = {
      clientX: e.clientX,
      clientY: e.clientY,
      deltaY: e.deltaY
    };
    switch (i) {
      case 1:
        n.deltaY *= 16;
        break;
      case 2:
        n.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (n.deltaY *= 10), n;
  }
}
function GJ(r) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(r.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(r) && (this._addPointer(r), r.pointerType === "touch" ? this._onTouchStart(r) : this._onMouseDown(r)));
}
function HJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchMove(r) : this._onMouseMove(r));
}
function WJ(r) {
  switch (this._removePointer(r), this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(r.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(lO), this.state = ti.NONE;
      break;
    case 1:
      const e = this._pointers[0], i = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: i.x, pageY: i.y });
      break;
  }
}
function qJ(r) {
  let e;
  switch (r.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case tr.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseDownDolly(r), this.state = ti.DOLLY;
      break;
    case tr.ROTATE:
      if (r.ctrlKey || r.metaKey || r.shiftKey) {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(r), this.state = ti.PAN;
      } else {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(r), this.state = ti.ROTATE;
      }
      break;
    case tr.PAN:
      if (r.ctrlKey || r.metaKey || r.shiftKey) {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(r), this.state = ti.ROTATE;
      } else {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(r), this.state = ti.PAN;
      }
      break;
    default:
      this.state = ti.NONE;
  }
  this.state !== ti.NONE && this.dispatchEvent($T);
}
function XJ(r) {
  switch (this.state) {
    case ti.ROTATE:
      if (this.enableRotate === !1) return;
      this._handleMouseMoveRotate(r);
      break;
    case ti.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseMoveDolly(r);
      break;
    case ti.PAN:
      if (this.enablePan === !1) return;
      this._handleMouseMovePan(r);
      break;
  }
}
function YJ(r) {
  this.enabled === !1 || this.enableZoom === !1 || this.state !== ti.NONE || (r.preventDefault(), this.dispatchEvent($T), this._handleMouseWheel(this._customWheelEvent(r)), this.dispatchEvent(lO));
}
function $J(r) {
  this.enabled === !1 || this.enablePan === !1 || this._handleKeyDown(r);
}
function KJ(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case sa.ROTATE:
          if (this.enableRotate === !1) return;
          this._handleTouchStartRotate(r), this.state = ti.TOUCH_ROTATE;
          break;
        case sa.PAN:
          if (this.enablePan === !1) return;
          this._handleTouchStartPan(r), this.state = ti.TOUCH_PAN;
          break;
        default:
          this.state = ti.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case sa.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1) return;
          this._handleTouchStartDollyPan(r), this.state = ti.TOUCH_DOLLY_PAN;
          break;
        case sa.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1) return;
          this._handleTouchStartDollyRotate(r), this.state = ti.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = ti.NONE;
      }
      break;
    default:
      this.state = ti.NONE;
  }
  this.state !== ti.NONE && this.dispatchEvent($T);
}
function QJ(r) {
  switch (this._trackPointer(r), this.state) {
    case ti.TOUCH_ROTATE:
      if (this.enableRotate === !1) return;
      this._handleTouchMoveRotate(r), this.update();
      break;
    case ti.TOUCH_PAN:
      if (this.enablePan === !1) return;
      this._handleTouchMovePan(r), this.update();
      break;
    case ti.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1) return;
      this._handleTouchMoveDollyPan(r), this.update();
      break;
    case ti.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1) return;
      this._handleTouchMoveDollyRotate(r), this.update();
      break;
    default:
      this.state = ti.NONE;
  }
}
function ZJ(r) {
  this.enabled !== !1 && r.preventDefault();
}
function JJ(r) {
  r.key === "Control" && (this._controlActive = !0, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
function eee(r) {
  r.key === "Control" && (this._controlActive = !1, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
const tee = { type: "change" }, yA = 1e-6, vA = new Ts();
class iee extends Sg {
  constructor(e, i = null) {
    super(e, i), this.movementSpeed = 1, this.rollSpeed = 5e-3, this.dragToLook = !1, this.autoForward = !1, this._moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 }, this._moveVector = new X(0, 0, 0), this._rotationVector = new X(0, 0, 0), this._lastQuaternion = new Ts(), this._lastPosition = new X(), this._status = 0, this._onKeyDown = ree.bind(this), this._onKeyUp = nee.bind(this), this._onPointerMove = aee.bind(this), this._onPointerDown = see.bind(this), this._onPointerUp = oee.bind(this), this._onPointerCancel = lee.bind(this), this._onContextMenu = uee.bind(this), i !== null && this.connect();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown), window.addEventListener("keyup", this._onKeyUp), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("contextmenu", this._onContextMenu);
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("contextmenu", this._onContextMenu);
  }
  dispose() {
    this.disconnect();
  }
  update(e) {
    if (this.enabled === !1) return;
    const i = this.object, n = e * this.movementSpeed, s = e * this.rollSpeed;
    i.translateX(this._moveVector.x * n), i.translateY(this._moveVector.y * n), i.translateZ(this._moveVector.z * n), vA.set(this._rotationVector.x * s, this._rotationVector.y * s, this._rotationVector.z * s, 1).normalize(), i.quaternion.multiply(vA), (this._lastPosition.distanceToSquared(i.position) > yA || 8 * (1 - this._lastQuaternion.dot(i.quaternion)) > yA) && (this.dispatchEvent(tee), this._lastQuaternion.copy(i.quaternion), this._lastPosition.copy(i.position));
  }
  // private
  _updateMovementVector() {
    const e = this._moveState.forward || this.autoForward && !this._moveState.back ? 1 : 0;
    this._moveVector.x = -this._moveState.left + this._moveState.right, this._moveVector.y = -this._moveState.down + this._moveState.up, this._moveVector.z = -e + this._moveState.back;
  }
  _updateRotationVector() {
    this._rotationVector.x = -this._moveState.pitchDown + this._moveState.pitchUp, this._rotationVector.y = -this._moveState.yawRight + this._moveState.yawLeft, this._rotationVector.z = -this._moveState.rollRight + this._moveState.rollLeft;
  }
  _getContainerDimensions() {
    return this.domElement != document ? {
      size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
      offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
    } : {
      size: [window.innerWidth, window.innerHeight],
      offset: [0, 0]
    };
  }
}
function ree(r) {
  if (!(r.altKey || this.enabled === !1)) {
    switch (r.code) {
      case "ShiftLeft":
      case "ShiftRight":
        this.movementSpeedMultiplier = 0.1;
        break;
      case "KeyW":
        this._moveState.forward = 1;
        break;
      case "KeyS":
        this._moveState.back = 1;
        break;
      case "KeyA":
        this._moveState.left = 1;
        break;
      case "KeyD":
        this._moveState.right = 1;
        break;
      case "KeyR":
        this._moveState.up = 1;
        break;
      case "KeyF":
        this._moveState.down = 1;
        break;
      case "ArrowUp":
        this._moveState.pitchUp = 1;
        break;
      case "ArrowDown":
        this._moveState.pitchDown = 1;
        break;
      case "ArrowLeft":
        this._moveState.yawLeft = 1;
        break;
      case "ArrowRight":
        this._moveState.yawRight = 1;
        break;
      case "KeyQ":
        this._moveState.rollLeft = 1;
        break;
      case "KeyE":
        this._moveState.rollRight = 1;
        break;
    }
    this._updateMovementVector(), this._updateRotationVector();
  }
}
function nee(r) {
  if (this.enabled !== !1) {
    switch (r.code) {
      case "ShiftLeft":
      case "ShiftRight":
        this.movementSpeedMultiplier = 1;
        break;
      case "KeyW":
        this._moveState.forward = 0;
        break;
      case "KeyS":
        this._moveState.back = 0;
        break;
      case "KeyA":
        this._moveState.left = 0;
        break;
      case "KeyD":
        this._moveState.right = 0;
        break;
      case "KeyR":
        this._moveState.up = 0;
        break;
      case "KeyF":
        this._moveState.down = 0;
        break;
      case "ArrowUp":
        this._moveState.pitchUp = 0;
        break;
      case "ArrowDown":
        this._moveState.pitchDown = 0;
        break;
      case "ArrowLeft":
        this._moveState.yawLeft = 0;
        break;
      case "ArrowRight":
        this._moveState.yawRight = 0;
        break;
      case "KeyQ":
        this._moveState.rollLeft = 0;
        break;
      case "KeyE":
        this._moveState.rollRight = 0;
        break;
    }
    this._updateMovementVector(), this._updateRotationVector();
  }
}
function see(r) {
  if (this.enabled !== !1)
    if (this.dragToLook)
      this._status++;
    else {
      switch (r.button) {
        case 0:
          this._moveState.forward = 1;
          break;
        case 2:
          this._moveState.back = 1;
          break;
      }
      this._updateMovementVector();
    }
}
function aee(r) {
  if (this.enabled !== !1 && (!this.dragToLook || this._status > 0)) {
    const e = this._getContainerDimensions(), i = e.size[0] / 2, n = e.size[1] / 2;
    this._moveState.yawLeft = -(r.pageX - e.offset[0] - i) / i, this._moveState.pitchDown = (r.pageY - e.offset[1] - n) / n, this._updateRotationVector();
  }
}
function oee(r) {
  if (this.enabled !== !1) {
    if (this.dragToLook)
      this._status--, this._moveState.yawLeft = this._moveState.pitchDown = 0;
    else {
      switch (r.button) {
        case 0:
          this._moveState.forward = 0;
          break;
        case 2:
          this._moveState.back = 0;
          break;
      }
      this._updateMovementVector();
    }
    this._updateRotationVector();
  }
}
function lee() {
  this.enabled !== !1 && (this.dragToLook ? (this._status = 0, this._moveState.yawLeft = this._moveState.pitchDown = 0) : (this._moveState.forward = 0, this._moveState.back = 0, this._updateMovementVector()), this._updateRotationVector());
}
function uee(r) {
  this.enabled !== !1 && r.preventDefault();
}
const cee = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class Vg {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const hee = new D_(-1, 1, 1, -1, 0, 1);
class dee extends pn {
  constructor() {
    super(), this.setAttribute("position", new Ri([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Ri([0, 2, 0, 0, 2, 0], 2));
  }
}
const pee = new dee();
class fee {
  constructor(e) {
    this._mesh = new Ur(pee, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, hee);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class mee extends Vg {
  constructor(e, i) {
    super(), this.textureID = i !== void 0 ? i : "tDiffuse", e instanceof Ss ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = lR.clone(e.uniforms), this.material = new Ss({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new fee(this.material);
  }
  render(e, i, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(i), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class bA extends Vg {
  constructor(e, i) {
    super(), this.scene = e, this.camera = i, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, i, n) {
    const s = e.getContext(), a = e.state;
    a.buffers.color.setMask(!1), a.buffers.depth.setMask(!1), a.buffers.color.setLocked(!0), a.buffers.depth.setLocked(!0);
    let o, l;
    this.inverse ? (o = 0, l = 1) : (o = 1, l = 0), a.buffers.stencil.setTest(!0), a.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), a.buffers.stencil.setFunc(s.ALWAYS, o, 4294967295), a.buffers.stencil.setClear(l), a.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), a.buffers.color.setLocked(!1), a.buffers.depth.setLocked(!1), a.buffers.color.setMask(!0), a.buffers.depth.setMask(!0), a.buffers.stencil.setLocked(!1), a.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), a.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), a.buffers.stencil.setLocked(!0);
  }
}
class gee extends Vg {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class yee {
  constructor(e, i) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), i === void 0) {
      const n = e.getSize(new Le());
      this._width = n.width, this._height = n.height, i = new vo(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: Dc }), i.texture.name = "EffectComposer.rt1";
    } else
      this._width = i.width, this._height = i.height;
    this.renderTarget1 = i, this.renderTarget2 = i.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new mee(cee), this.copyPass.material.blending = ha, this.clock = new ER();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, i) {
    this.passes.splice(i, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const i = this.passes.indexOf(e);
    i !== -1 && this.passes.splice(i, 1);
  }
  isLastEnabledPass(e) {
    for (let i = e + 1; i < this.passes.length; i++)
      if (this.passes[i].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const i = this.renderer.getRenderTarget();
    let n = !1;
    for (let s = 0, a = this.passes.length; s < a; s++) {
      const o = this.passes[s];
      if (o.enabled !== !1) {
        if (o.renderToScreen = this.renderToScreen && this.isLastEnabledPass(s), o.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), o.needsSwap) {
          if (n) {
            const l = this.renderer.getContext(), u = this.renderer.state.buffers.stencil;
            u.setFunc(l.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), u.setFunc(l.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        bA !== void 0 && (o instanceof bA ? n = !0 : o instanceof gee && (n = !1));
      }
    }
    this.renderer.setRenderTarget(i);
  }
  reset(e) {
    if (e === void 0) {
      const i = this.renderer.getSize(new Le());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = i.width, this._height = i.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, i) {
    this._width = e, this._height = i;
    const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, s), this.renderTarget2.setSize(n, s);
    for (let a = 0; a < this.passes.length; a++)
      this.passes[a].setSize(n, s);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class vee extends Vg {
  constructor(e, i, n = null, s = null, a = null) {
    super(), this.scene = e, this.camera = i, this.overrideMaterial = n, this.clearColor = s, this.clearAlpha = a, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Ft();
  }
  render(e, i, n) {
    const s = e.autoClear;
    e.autoClear = !1;
    let a, o;
    this.overrideMaterial !== null && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (a = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(a), this.overrideMaterial !== null && (this.scene.overrideMaterial = o), e.autoClear = s;
  }
}
function qr() {
  return qr = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i) ({}).hasOwnProperty.call(i, n) && (r[n] = i[n]);
    }
    return r;
  }, qr.apply(null, arguments);
}
function bee(r) {
  if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function Rd(r, e) {
  return Rd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Rd(r, e);
}
function xee(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Rd(r, e);
}
function Lx(r) {
  return Lx = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Lx(r);
}
function _ee(r) {
  try {
    return Function.toString.call(r).indexOf("[native code]") !== -1;
  } catch {
    return typeof r == "function";
  }
}
function uO() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (uO = function() {
    return !!r;
  })();
}
function Tee(r, e, i) {
  if (uO()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return i && Rd(s, i.prototype), s;
}
function Ux(r) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Ux = function(i) {
    if (i === null || !_ee(i)) return i;
    if (typeof i != "function") throw new TypeError("Super expression must either be null or a function");
    if (e !== void 0) {
      if (e.has(i)) return e.get(i);
      e.set(i, n);
    }
    function n() {
      return Tee(i, arguments, Lx(this).constructor);
    }
    return n.prototype = Object.create(i.prototype, {
      constructor: {
        value: n,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Rd(n, i);
  }, Ux(r);
}
var See = {
  1: `Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).

`,
  2: `Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).

`,
  3: `Passed an incorrect argument to a color function, please pass a string representation of a color.

`,
  4: `Couldn't generate valid rgb string from %s, it returned %s.

`,
  5: `Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.

`,
  6: `Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).

`,
  7: `Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).

`,
  8: `Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.

`,
  9: `Please provide a number of steps to the modularScale helper.

`,
  10: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
  11: `Invalid value passed as base to modularScale, expected number or em string but got "%s"

`,
  12: `Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.

`,
  13: `Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.

`,
  14: `Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.

`,
  15: `Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.

`,
  16: `You must provide a template to this method.

`,
  17: `You passed an unsupported selector state to this method.

`,
  18: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
  19: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
  20: `expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
  21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  23: `fontFace expects a name of a font-family.

`,
  24: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
  25: `fontFace expects localFonts to be an array.

`,
  26: `fontFace expects fileFormats to be an array.

`,
  27: `radialGradient requries at least 2 color-stops to properly render.

`,
  28: `Please supply a filename to retinaImage() as the first argument.

`,
  29: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
  30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  31: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation

`,
  32: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])
To pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')

`,
  33: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation

`,
  34: `borderRadius expects a radius value as a string or number as the second argument.

`,
  35: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
  36: `Property must be a string value.

`,
  37: `Syntax Error at %s.

`,
  38: `Formula contains a function that needs parentheses at %s.

`,
  39: `Formula is missing closing parenthesis at %s.

`,
  40: `Formula has too many closing parentheses at %s.

`,
  41: `All values in a formula must have the same unit or be unitless.

`,
  42: `Please provide a number of steps to the modularScale helper.

`,
  43: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
  44: `Invalid value passed as base to modularScale, expected number or em/rem string but got %s.

`,
  45: `Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.

`,
  46: `Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.

`,
  47: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
  48: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
  49: `Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
  50: `Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.

`,
  51: `Expects the first argument object to have the properties prop, fromSize, and toSize.

`,
  52: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
  53: `fontFace expects localFonts to be an array.

`,
  54: `fontFace expects fileFormats to be an array.

`,
  55: `fontFace expects a name of a font-family.

`,
  56: `linearGradient requries at least 2 color-stops to properly render.

`,
  57: `radialGradient requries at least 2 color-stops to properly render.

`,
  58: `Please supply a filename to retinaImage() as the first argument.

`,
  59: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
  60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  61: `Property must be a string value.

`,
  62: `borderRadius expects a radius value as a string or number as the second argument.

`,
  63: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
  64: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.

`,
  65: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').

`,
  66: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.

`,
  67: `You must provide a template to this method.

`,
  68: `You passed an unsupported selector state to this method.

`,
  69: `Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.

`,
  70: `Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.

`,
  71: `Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.

`,
  72: `Passed invalid base value %s to %s(), please pass a value like "12px" or 12.

`,
  73: `Please provide a valid CSS variable.

`,
  74: `CSS variable not found and no default was provided.

`,
  75: `important requires a valid style object, got a %s instead.

`,
  76: `fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.

`,
  77: `remToPx expects a value in "rem" but you provided it in "%s".

`,
  78: `base must be set in "px" or "%" but you set it in "%s".
`
};
function wee() {
  for (var r = arguments.length, e = new Array(r), i = 0; i < r; i++)
    e[i] = arguments[i];
  var n = e[0], s = [], a;
  for (a = 1; a < e.length; a += 1)
    s.push(e[a]);
  return s.forEach(function(o) {
    n = n.replace(/%[a-z]/, o);
  }), n;
}
var bs = /* @__PURE__ */ function(r) {
  xee(e, r);
  function e(i) {
    var n;
    if (process.env.NODE_ENV === "production")
      n = r.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + i + " for more information.") || this;
    else {
      for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), o = 1; o < s; o++)
        a[o - 1] = arguments[o];
      n = r.call(this, wee.apply(void 0, [See[i]].concat(a))) || this;
    }
    return bee(n);
  }
  return e;
}(/* @__PURE__ */ Ux(Error));
function xv(r) {
  return Math.round(r * 255);
}
function Eee(r, e, i) {
  return xv(r) + "," + xv(e) + "," + xv(i);
}
function Ym(r, e, i, n) {
  if (n === void 0 && (n = Eee), e === 0)
    return n(i, i, i);
  var s = (r % 360 + 360) % 360 / 60, a = (1 - Math.abs(2 * i - 1)) * e, o = a * (1 - Math.abs(s % 2 - 1)), l = 0, u = 0, c = 0;
  s >= 0 && s < 1 ? (l = a, u = o) : s >= 1 && s < 2 ? (l = o, u = a) : s >= 2 && s < 3 ? (u = a, c = o) : s >= 3 && s < 4 ? (u = o, c = a) : s >= 4 && s < 5 ? (l = o, c = a) : s >= 5 && s < 6 && (l = a, c = o);
  var h = i - a / 2, d = l + h, p = u + h, f = c + h;
  return n(d, p, f);
}
var xA = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function Mee(r) {
  if (typeof r != "string") return r;
  var e = r.toLowerCase();
  return xA[e] ? "#" + xA[e] : r;
}
var Aee = /^#[a-fA-F0-9]{6}$/, Cee = /^#[a-fA-F0-9]{8}$/, Ree = /^#[a-fA-F0-9]{3}$/, Nee = /^#[a-fA-F0-9]{4}$/, _v = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i, Pee = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i, Oee = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, Iee = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function Cc(r) {
  if (typeof r != "string")
    throw new bs(3);
  var e = Mee(r);
  if (e.match(Aee))
    return {
      red: parseInt("" + e[1] + e[2], 16),
      green: parseInt("" + e[3] + e[4], 16),
      blue: parseInt("" + e[5] + e[6], 16)
    };
  if (e.match(Cee)) {
    var i = parseFloat((parseInt("" + e[7] + e[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + e[1] + e[2], 16),
      green: parseInt("" + e[3] + e[4], 16),
      blue: parseInt("" + e[5] + e[6], 16),
      alpha: i
    };
  }
  if (e.match(Ree))
    return {
      red: parseInt("" + e[1] + e[1], 16),
      green: parseInt("" + e[2] + e[2], 16),
      blue: parseInt("" + e[3] + e[3], 16)
    };
  if (e.match(Nee)) {
    var n = parseFloat((parseInt("" + e[4] + e[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + e[1] + e[1], 16),
      green: parseInt("" + e[2] + e[2], 16),
      blue: parseInt("" + e[3] + e[3], 16),
      alpha: n
    };
  }
  var s = _v.exec(e);
  if (s)
    return {
      red: parseInt("" + s[1], 10),
      green: parseInt("" + s[2], 10),
      blue: parseInt("" + s[3], 10)
    };
  var a = Pee.exec(e.substring(0, 50));
  if (a)
    return {
      red: parseInt("" + a[1], 10),
      green: parseInt("" + a[2], 10),
      blue: parseInt("" + a[3], 10),
      alpha: parseFloat("" + a[4]) > 1 ? parseFloat("" + a[4]) / 100 : parseFloat("" + a[4])
    };
  var o = Oee.exec(e);
  if (o) {
    var l = parseInt("" + o[1], 10), u = parseInt("" + o[2], 10) / 100, c = parseInt("" + o[3], 10) / 100, h = "rgb(" + Ym(l, u, c) + ")", d = _v.exec(h);
    if (!d)
      throw new bs(4, e, h);
    return {
      red: parseInt("" + d[1], 10),
      green: parseInt("" + d[2], 10),
      blue: parseInt("" + d[3], 10)
    };
  }
  var p = Iee.exec(e.substring(0, 50));
  if (p) {
    var f = parseInt("" + p[1], 10), m = parseInt("" + p[2], 10) / 100, v = parseInt("" + p[3], 10) / 100, y = "rgb(" + Ym(f, m, v) + ")", g = _v.exec(y);
    if (!g)
      throw new bs(4, e, y);
    return {
      red: parseInt("" + g[1], 10),
      green: parseInt("" + g[2], 10),
      blue: parseInt("" + g[3], 10),
      alpha: parseFloat("" + p[4]) > 1 ? parseFloat("" + p[4]) / 100 : parseFloat("" + p[4])
    };
  }
  throw new bs(5);
}
function Dee(r) {
  var e = r.red / 255, i = r.green / 255, n = r.blue / 255, s = Math.max(e, i, n), a = Math.min(e, i, n), o = (s + a) / 2;
  if (s === a)
    return r.alpha !== void 0 ? {
      hue: 0,
      saturation: 0,
      lightness: o,
      alpha: r.alpha
    } : {
      hue: 0,
      saturation: 0,
      lightness: o
    };
  var l, u = s - a, c = o > 0.5 ? u / (2 - s - a) : u / (s + a);
  switch (s) {
    case e:
      l = (i - n) / u + (i < n ? 6 : 0);
      break;
    case i:
      l = (n - e) / u + 2;
      break;
    default:
      l = (e - i) / u + 4;
      break;
  }
  return l *= 60, r.alpha !== void 0 ? {
    hue: l,
    saturation: c,
    lightness: o,
    alpha: r.alpha
  } : {
    hue: l,
    saturation: c,
    lightness: o
  };
}
function Mo(r) {
  return Dee(Cc(r));
}
var kee = function(r) {
  return r.length === 7 && r[1] === r[2] && r[3] === r[4] && r[5] === r[6] ? "#" + r[1] + r[3] + r[5] : r;
}, Fx = kee;
function Yo(r) {
  var e = r.toString(16);
  return e.length === 1 ? "0" + e : e;
}
function Tv(r) {
  return Yo(Math.round(r * 255));
}
function Lee(r, e, i) {
  return Fx("#" + Tv(r) + Tv(e) + Tv(i));
}
function cO(r, e, i) {
  return Ym(r, e, i, Lee);
}
function Uee(r, e, i) {
  if (typeof r == "object" && e === void 0 && i === void 0)
    return cO(r.hue, r.saturation, r.lightness);
  throw new bs(1);
}
function Fee(r, e, i, n) {
  if (typeof r == "object" && e === void 0 && i === void 0 && n === void 0)
    return r.alpha >= 1 ? cO(r.hue, r.saturation, r.lightness) : "rgba(" + Ym(r.hue, r.saturation, r.lightness) + "," + r.alpha + ")";
  throw new bs(2);
}
function hO(r, e, i) {
  if (typeof r == "number" && typeof e == "number" && typeof i == "number")
    return Fx("#" + Yo(r) + Yo(e) + Yo(i));
  if (typeof r == "object" && e === void 0 && i === void 0)
    return Fx("#" + Yo(r.red) + Yo(r.green) + Yo(r.blue));
  throw new bs(6);
}
function Gg(r, e, i, n) {
  if (typeof r == "object" && e === void 0 && i === void 0 && n === void 0)
    return r.alpha >= 1 ? hO(r.red, r.green, r.blue) : "rgba(" + r.red + "," + r.green + "," + r.blue + "," + r.alpha + ")";
  throw new bs(7);
}
var Bee = function(r) {
  return typeof r.red == "number" && typeof r.green == "number" && typeof r.blue == "number" && (typeof r.alpha != "number" || typeof r.alpha > "u");
}, zee = function(r) {
  return typeof r.red == "number" && typeof r.green == "number" && typeof r.blue == "number" && typeof r.alpha == "number";
}, jee = function(r) {
  return typeof r.hue == "number" && typeof r.saturation == "number" && typeof r.lightness == "number" && (typeof r.alpha != "number" || typeof r.alpha > "u");
}, Vee = function(r) {
  return typeof r.hue == "number" && typeof r.saturation == "number" && typeof r.lightness == "number" && typeof r.alpha == "number";
};
function Ao(r) {
  if (typeof r != "object") throw new bs(8);
  if (zee(r)) return Gg(r);
  if (Bee(r)) return hO(r);
  if (Vee(r)) return Fee(r);
  if (jee(r)) return Uee(r);
  throw new bs(8);
}
function dO(r, e, i) {
  return function() {
    var n = i.concat(Array.prototype.slice.call(arguments));
    return n.length >= e ? r.apply(this, n) : dO(r, e, n);
  };
}
function fn(r) {
  return dO(r, r.length, []);
}
function Gee(r, e) {
  if (e === "transparent") return e;
  var i = Mo(e);
  return Ao(qr({}, i, {
    hue: i.hue + parseFloat(r)
  }));
}
fn(Gee);
function Hc(r, e, i) {
  return Math.max(r, Math.min(e, i));
}
function Hee(r, e) {
  if (e === "transparent") return e;
  var i = Mo(e);
  return Ao(qr({}, i, {
    lightness: Hc(0, 1, i.lightness - parseFloat(r))
  }));
}
fn(Hee);
function Wee(r, e) {
  if (e === "transparent") return e;
  var i = Mo(e);
  return Ao(qr({}, i, {
    saturation: Hc(0, 1, i.saturation - parseFloat(r))
  }));
}
fn(Wee);
function qee(r, e) {
  if (e === "transparent") return e;
  var i = Mo(e);
  return Ao(qr({}, i, {
    lightness: Hc(0, 1, i.lightness + parseFloat(r))
  }));
}
fn(qee);
function Xee(r, e, i) {
  if (e === "transparent") return i;
  if (i === "transparent") return e;
  if (r === 0) return i;
  var n = Cc(e), s = qr({}, n, {
    alpha: typeof n.alpha == "number" ? n.alpha : 1
  }), a = Cc(i), o = qr({}, a, {
    alpha: typeof a.alpha == "number" ? a.alpha : 1
  }), l = s.alpha - o.alpha, u = parseFloat(r) * 2 - 1, c = u * l === -1 ? u : u + l, h = 1 + u * l, d = (c / h + 1) / 2, p = 1 - d, f = {
    red: Math.floor(s.red * d + o.red * p),
    green: Math.floor(s.green * d + o.green * p),
    blue: Math.floor(s.blue * d + o.blue * p),
    alpha: s.alpha * parseFloat(r) + o.alpha * (1 - parseFloat(r))
  };
  return Gg(f);
}
var Yee = fn(Xee), pO = Yee;
function $ee(r, e) {
  if (e === "transparent") return e;
  var i = Cc(e), n = typeof i.alpha == "number" ? i.alpha : 1, s = qr({}, i, {
    alpha: Hc(0, 1, (n * 100 + parseFloat(r) * 100) / 100)
  });
  return Gg(s);
}
var Kee = fn($ee), Qee = Kee;
function Zee(r, e) {
  if (e === "transparent") return e;
  var i = Mo(e);
  return Ao(qr({}, i, {
    saturation: Hc(0, 1, i.saturation + parseFloat(r))
  }));
}
fn(Zee);
function Jee(r, e) {
  return e === "transparent" ? e : Ao(qr({}, Mo(e), {
    hue: parseFloat(r)
  }));
}
fn(Jee);
function ete(r, e) {
  return e === "transparent" ? e : Ao(qr({}, Mo(e), {
    lightness: parseFloat(r)
  }));
}
fn(ete);
function tte(r, e) {
  return e === "transparent" ? e : Ao(qr({}, Mo(e), {
    saturation: parseFloat(r)
  }));
}
fn(tte);
function ite(r, e) {
  return e === "transparent" ? e : pO(parseFloat(r), "rgb(0, 0, 0)", e);
}
fn(ite);
function rte(r, e) {
  return e === "transparent" ? e : pO(parseFloat(r), "rgb(255, 255, 255)", e);
}
fn(rte);
function nte(r, e) {
  if (e === "transparent") return e;
  var i = Cc(e), n = typeof i.alpha == "number" ? i.alpha : 1, s = qr({}, i, {
    alpha: Hc(0, 1, +(n * 100 - parseFloat(r) * 100).toFixed(2) / 100)
  });
  return Gg(s);
}
fn(nte);
var _a = Object.freeze({
  Linear: Object.freeze({
    None: function(r) {
      return r;
    },
    In: function(r) {
      return r;
    },
    Out: function(r) {
      return r;
    },
    InOut: function(r) {
      return r;
    }
  }),
  Quadratic: Object.freeze({
    In: function(r) {
      return r * r;
    },
    Out: function(r) {
      return r * (2 - r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(r) {
      return r * r * r;
    },
    Out: function(r) {
      return --r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(r) {
      return r * r * r * r;
    },
    Out: function(r) {
      return 1 - --r * r * r * r;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(r) {
      return r * r * r * r * r;
    },
    Out: function(r) {
      return --r * r * r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(r) {
      return 1 - Math.sin((1 - r) * Math.PI / 2);
    },
    Out: function(r) {
      return Math.sin(r * Math.PI / 2);
    },
    InOut: function(r) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - r)));
    }
  }),
  Exponential: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : Math.pow(1024, r - 1);
    },
    Out: function(r) {
      return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(r) {
      return 1 - Math.sqrt(1 - r * r);
    },
    Out: function(r) {
      return Math.sqrt(1 - --r * r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : -Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI);
    },
    Out: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : Math.pow(2, -10 * r) * Math.sin((r - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2, r < 1 ? -0.5 * Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In: function(r) {
      var e = 1.70158;
      return r === 1 ? 1 : r * r * ((e + 1) * r - e);
    },
    Out: function(r) {
      var e = 1.70158;
      return r === 0 ? 0 : --r * r * ((e + 1) * r + e) + 1;
    },
    InOut: function(r) {
      var e = 2.5949095;
      return (r *= 2) < 1 ? 0.5 * (r * r * ((e + 1) * r - e)) : 0.5 * ((r -= 2) * r * ((e + 1) * r + e) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(r) {
      return 1 - _a.Bounce.Out(1 - r);
    },
    Out: function(r) {
      return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
    },
    InOut: function(r) {
      return r < 0.5 ? _a.Bounce.In(r * 2) * 0.5 : _a.Bounce.Out(r * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(r) {
    return r === void 0 && (r = 4), r = r < Number.EPSILON ? Number.EPSILON : r, r = r > 1e4 ? 1e4 : r, {
      In: function(e) {
        return Math.pow(e, r);
      },
      Out: function(e) {
        return 1 - Math.pow(1 - e, r);
      },
      InOut: function(e) {
        return e < 0.5 ? Math.pow(e * 2, r) / 2 : (1 - Math.pow(2 - e * 2, r)) / 2 + 0.5;
      }
    };
  }
}), Wh = function() {
  return performance.now();
}, KT = (
  /** @class */
  function() {
    function r() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      this._tweens = {}, this._tweensAddedDuringUpdate = {}, this.add.apply(this, e);
    }
    return r.prototype.getAll = function() {
      var e = this;
      return Object.keys(this._tweens).map(function(i) {
        return e._tweens[i];
      });
    }, r.prototype.removeAll = function() {
      this._tweens = {};
    }, r.prototype.add = function() {
      for (var e, i = [], n = 0; n < arguments.length; n++)
        i[n] = arguments[n];
      for (var s = 0, a = i; s < a.length; s++) {
        var o = a[s];
        (e = o._group) === null || e === void 0 || e.remove(o), o._group = this, this._tweens[o.getId()] = o, this._tweensAddedDuringUpdate[o.getId()] = o;
      }
    }, r.prototype.remove = function() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      for (var n = 0, s = e; n < s.length; n++) {
        var a = s[n];
        a._group = void 0, delete this._tweens[a.getId()], delete this._tweensAddedDuringUpdate[a.getId()];
      }
    }, r.prototype.allStopped = function() {
      return this.getAll().every(function(e) {
        return !e.isPlaying();
      });
    }, r.prototype.update = function(e, i) {
      e === void 0 && (e = Wh()), i === void 0 && (i = !0);
      var n = Object.keys(this._tweens);
      if (n.length !== 0)
        for (; n.length > 0; ) {
          this._tweensAddedDuringUpdate = {};
          for (var s = 0; s < n.length; s++) {
            var a = this._tweens[n[s]], o = !i;
            a && a.update(e, o) === !1 && !i && this.remove(a);
          }
          n = Object.keys(this._tweensAddedDuringUpdate);
        }
    }, r;
  }()
), Bx = {
  Linear: function(r, e) {
    var i = r.length - 1, n = i * e, s = Math.floor(n), a = Bx.Utils.Linear;
    return e < 0 ? a(r[0], r[1], n) : e > 1 ? a(r[i], r[i - 1], i - n) : a(r[s], r[s + 1 > i ? i : s + 1], n - s);
  },
  Utils: {
    Linear: function(r, e, i) {
      return (e - r) * i + r;
    }
  }
}, fO = (
  /** @class */
  function() {
    function r() {
    }
    return r.nextId = function() {
      return r._nextId++;
    }, r._nextId = 0, r;
  }()
), zx = new KT(), $m = (
  /** @class */
  function() {
    function r(e, i) {
      this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = _a.Linear.None, this._interpolationFunction = Bx.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = fO.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1, this._object = e, typeof i == "object" ? (this._group = i, i.add(this)) : i === !0 && (this._group = zx, zx.add(this));
    }
    return r.prototype.getId = function() {
      return this._id;
    }, r.prototype.isPlaying = function() {
      return this._isPlaying;
    }, r.prototype.isPaused = function() {
      return this._isPaused;
    }, r.prototype.getDuration = function() {
      return this._duration;
    }, r.prototype.to = function(e, i) {
      if (i === void 0 && (i = 1e3), this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      return this._valuesEnd = e, this._propertiesAreSetUp = !1, this._duration = i < 0 ? 0 : i, this;
    }, r.prototype.duration = function(e) {
      return e === void 0 && (e = 1e3), this._duration = e < 0 ? 0 : e, this;
    }, r.prototype.dynamic = function(e) {
      return e === void 0 && (e = !1), this._isDynamic = e, this;
    }, r.prototype.start = function(e, i) {
      if (e === void 0 && (e = Wh()), i === void 0 && (i = !1), this._isPlaying)
        return this;
      if (this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var n in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n];
      }
      if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = e, this._startTime += this._delayTime, !this._propertiesAreSetUp || i) {
        if (this._propertiesAreSetUp = !0, !this._isDynamic) {
          var s = {};
          for (var a in this._valuesEnd)
            s[a] = this._valuesEnd[a];
          this._valuesEnd = s;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, i);
      }
      return this;
    }, r.prototype.startFromCurrentValues = function(e) {
      return this.start(e, !0);
    }, r.prototype._setupProperties = function(e, i, n, s, a) {
      for (var o in n) {
        var l = e[o], u = Array.isArray(l), c = u ? "array" : typeof l, h = !u && Array.isArray(n[o]);
        if (!(c === "undefined" || c === "function")) {
          if (h) {
            var d = n[o];
            if (d.length === 0)
              continue;
            for (var p = [l], f = 0, m = d.length; f < m; f += 1) {
              var v = this._handleRelativeValue(l, d[f]);
              if (isNaN(v)) {
                h = !1, console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              p.push(v);
            }
            h && (n[o] = p);
          }
          if ((c === "object" || u) && l && !h) {
            i[o] = u ? [] : {};
            var y = l;
            for (var g in y)
              i[o][g] = y[g];
            s[o] = u ? [] : {};
            var d = n[o];
            if (!this._isDynamic) {
              var _ = {};
              for (var g in d)
                _[g] = d[g];
              n[o] = d = _;
            }
            this._setupProperties(y, i[o], d, s[o], a);
          } else
            (typeof i[o] > "u" || a) && (i[o] = l), u || (i[o] *= 1), h ? s[o] = n[o].slice().reverse() : s[o] = i[o] || 0;
        }
      }
    }, r.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, r.prototype.end = function() {
      return this._goToEnd = !0, this.update(this._startTime + this._duration), this;
    }, r.prototype.pause = function(e) {
      return e === void 0 && (e = Wh()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = e, this);
    }, r.prototype.resume = function(e) {
      return e === void 0 && (e = Wh()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += e - this._pauseStart, this._pauseStart = 0, this);
    }, r.prototype.stopChainedTweens = function() {
      for (var e = 0, i = this._chainedTweens.length; e < i; e++)
        this._chainedTweens[e].stop();
      return this;
    }, r.prototype.group = function(e) {
      return e ? (e.add(this), this) : (console.warn("tween.group() without args has been removed, use group.add(tween) instead."), this);
    }, r.prototype.remove = function() {
      var e;
      return (e = this._group) === null || e === void 0 || e.remove(this), this;
    }, r.prototype.delay = function(e) {
      return e === void 0 && (e = 0), this._delayTime = e, this;
    }, r.prototype.repeat = function(e) {
      return e === void 0 && (e = 0), this._initialRepeat = e, this._repeat = e, this;
    }, r.prototype.repeatDelay = function(e) {
      return this._repeatDelayTime = e, this;
    }, r.prototype.yoyo = function(e) {
      return e === void 0 && (e = !1), this._yoyo = e, this;
    }, r.prototype.easing = function(e) {
      return e === void 0 && (e = _a.Linear.None), this._easingFunction = e, this;
    }, r.prototype.interpolation = function(e) {
      return e === void 0 && (e = Bx.Linear), this._interpolationFunction = e, this;
    }, r.prototype.chain = function() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      return this._chainedTweens = e, this;
    }, r.prototype.onStart = function(e) {
      return this._onStartCallback = e, this;
    }, r.prototype.onEveryStart = function(e) {
      return this._onEveryStartCallback = e, this;
    }, r.prototype.onUpdate = function(e) {
      return this._onUpdateCallback = e, this;
    }, r.prototype.onRepeat = function(e) {
      return this._onRepeatCallback = e, this;
    }, r.prototype.onComplete = function(e) {
      return this._onCompleteCallback = e, this;
    }, r.prototype.onStop = function(e) {
      return this._onStopCallback = e, this;
    }, r.prototype.update = function(e, i) {
      var n = this, s;
      if (e === void 0 && (e = Wh()), i === void 0 && (i = r.autoStartOnUpdate), this._isPaused)
        return !0;
      var a;
      if (!this._goToEnd && !this._isPlaying)
        if (i)
          this.start(e, !0);
        else
          return !1;
      if (this._goToEnd = !1, e < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0);
      var o = e - this._startTime, l = this._duration + ((s = this._repeatDelayTime) !== null && s !== void 0 ? s : this._delayTime), u = this._duration + this._repeat * l, c = function() {
        if (n._duration === 0 || o > u)
          return 1;
        var v = Math.trunc(o / l), y = o - v * l, g = Math.min(y / n._duration, 1);
        return g === 0 && o === n._duration ? 1 : g;
      }, h = c(), d = this._easingFunction(h);
      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, d), this._onUpdateCallback && this._onUpdateCallback(this._object, h), this._duration === 0 || o >= this._duration)
        if (this._repeat > 0) {
          var p = Math.min(Math.trunc((o - this._duration) / l) + 1, this._repeat);
          isFinite(this._repeat) && (this._repeat -= p);
          for (a in this._valuesStartRepeat)
            !this._yoyo && typeof this._valuesEnd[a] == "string" && (this._valuesStartRepeat[a] = // eslint-disable-next-line
            // @ts-ignore FIXME?
            this._valuesStartRepeat[a] + parseFloat(this._valuesEnd[a])), this._yoyo && this._swapEndStartRepeatValues(a), this._valuesStart[a] = this._valuesStartRepeat[a];
          return this._yoyo && (this._reversed = !this._reversed), this._startTime += l * p, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;
        } else {
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var f = 0, m = this._chainedTweens.length; f < m; f++)
            this._chainedTweens[f].start(this._startTime + this._duration, !1);
          return this._isPlaying = !1, !1;
        }
      return !0;
    }, r.prototype._updateProperties = function(e, i, n, s) {
      for (var a in n)
        if (i[a] !== void 0) {
          var o = i[a] || 0, l = n[a], u = Array.isArray(e[a]), c = Array.isArray(l), h = !u && c;
          h ? e[a] = this._interpolationFunction(l, s) : typeof l == "object" && l ? this._updateProperties(e[a], o, l, s) : (l = this._handleRelativeValue(o, l), typeof l == "number" && (e[a] = o + (l - o) * s));
        }
    }, r.prototype._handleRelativeValue = function(e, i) {
      return typeof i != "string" ? i : i.charAt(0) === "+" || i.charAt(0) === "-" ? e + parseFloat(i) : parseFloat(i);
    }, r.prototype._swapEndStartRepeatValues = function(e) {
      var i = this._valuesStartRepeat[e], n = this._valuesEnd[e];
      typeof n == "string" ? this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(n) : this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = i;
    }, r.autoStartOnUpdate = !1, r;
  }()
);
fO.nextId;
var Ms = zx;
Ms.getAll.bind(Ms);
Ms.removeAll.bind(Ms);
Ms.add.bind(Ms);
Ms.remove.bind(Ms);
Ms.update.bind(Ms);
var jx = "http://www.w3.org/1999/xhtml";
const _A = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: jx,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Hg(r) {
  var e = r += "", i = e.indexOf(":");
  return i >= 0 && (e = r.slice(0, i)) !== "xmlns" && (r = r.slice(i + 1)), _A.hasOwnProperty(e) ? { space: _A[e], local: r } : r;
}
function ste(r) {
  return function() {
    var e = this.ownerDocument, i = this.namespaceURI;
    return i === jx && e.documentElement.namespaceURI === jx ? e.createElement(r) : e.createElementNS(i, r);
  };
}
function ate(r) {
  return function() {
    return this.ownerDocument.createElementNS(r.space, r.local);
  };
}
function mO(r) {
  var e = Hg(r);
  return (e.local ? ate : ste)(e);
}
function ote() {
}
function QT(r) {
  return r == null ? ote : function() {
    return this.querySelector(r);
  };
}
function lte(r) {
  typeof r != "function" && (r = QT(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = new Array(o), u, c, h = 0; h < o; ++h)
      (u = a[h]) && (c = r.call(u, u.__data__, h, a)) && ("__data__" in u && (c.__data__ = u.__data__), l[h] = c);
  return new dn(n, this._parents);
}
function ute(r) {
  return r == null ? [] : Array.isArray(r) ? r : Array.from(r);
}
function cte() {
  return [];
}
function gO(r) {
  return r == null ? cte : function() {
    return this.querySelectorAll(r);
  };
}
function hte(r) {
  return function() {
    return ute(r.apply(this, arguments));
  };
}
function dte(r) {
  typeof r == "function" ? r = hte(r) : r = gO(r);
  for (var e = this._groups, i = e.length, n = [], s = [], a = 0; a < i; ++a)
    for (var o = e[a], l = o.length, u, c = 0; c < l; ++c)
      (u = o[c]) && (n.push(r.call(u, u.__data__, c, o)), s.push(u));
  return new dn(n, s);
}
function yO(r) {
  return function() {
    return this.matches(r);
  };
}
function vO(r) {
  return function(e) {
    return e.matches(r);
  };
}
var pte = Array.prototype.find;
function fte(r) {
  return function() {
    return pte.call(this.children, r);
  };
}
function mte() {
  return this.firstElementChild;
}
function gte(r) {
  return this.select(r == null ? mte : fte(typeof r == "function" ? r : vO(r)));
}
var yte = Array.prototype.filter;
function vte() {
  return Array.from(this.children);
}
function bte(r) {
  return function() {
    return yte.call(this.children, r);
  };
}
function xte(r) {
  return this.selectAll(r == null ? vte : bte(typeof r == "function" ? r : vO(r)));
}
function _te(r) {
  typeof r != "function" && (r = yO(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = [], u, c = 0; c < o; ++c)
      (u = a[c]) && r.call(u, u.__data__, c, a) && l.push(u);
  return new dn(n, this._parents);
}
function bO(r) {
  return new Array(r.length);
}
function Tte() {
  return new dn(this._enter || this._groups.map(bO), this._parents);
}
function Km(r, e) {
  this.ownerDocument = r.ownerDocument, this.namespaceURI = r.namespaceURI, this._next = null, this._parent = r, this.__data__ = e;
}
Km.prototype = {
  constructor: Km,
  appendChild: function(r) {
    return this._parent.insertBefore(r, this._next);
  },
  insertBefore: function(r, e) {
    return this._parent.insertBefore(r, e);
  },
  querySelector: function(r) {
    return this._parent.querySelector(r);
  },
  querySelectorAll: function(r) {
    return this._parent.querySelectorAll(r);
  }
};
function Ste(r) {
  return function() {
    return r;
  };
}
function wte(r, e, i, n, s, a) {
  for (var o = 0, l, u = e.length, c = a.length; o < c; ++o)
    (l = e[o]) ? (l.__data__ = a[o], n[o] = l) : i[o] = new Km(r, a[o]);
  for (; o < u; ++o)
    (l = e[o]) && (s[o] = l);
}
function Ete(r, e, i, n, s, a, o) {
  var l, u, c = /* @__PURE__ */ new Map(), h = e.length, d = a.length, p = new Array(h), f;
  for (l = 0; l < h; ++l)
    (u = e[l]) && (p[l] = f = o.call(u, u.__data__, l, e) + "", c.has(f) ? s[l] = u : c.set(f, u));
  for (l = 0; l < d; ++l)
    f = o.call(r, a[l], l, a) + "", (u = c.get(f)) ? (n[l] = u, u.__data__ = a[l], c.delete(f)) : i[l] = new Km(r, a[l]);
  for (l = 0; l < h; ++l)
    (u = e[l]) && c.get(p[l]) === u && (s[l] = u);
}
function Mte(r) {
  return r.__data__;
}
function Ate(r, e) {
  if (!arguments.length) return Array.from(this, Mte);
  var i = e ? Ete : wte, n = this._parents, s = this._groups;
  typeof r != "function" && (r = Ste(r));
  for (var a = s.length, o = new Array(a), l = new Array(a), u = new Array(a), c = 0; c < a; ++c) {
    var h = n[c], d = s[c], p = d.length, f = Cte(r.call(h, h && h.__data__, c, n)), m = f.length, v = l[c] = new Array(m), y = o[c] = new Array(m), g = u[c] = new Array(p);
    i(h, d, v, y, g, f, e);
    for (var _ = 0, x = 0, b, T; _ < m; ++_)
      if (b = v[_]) {
        for (_ >= x && (x = _ + 1); !(T = y[x]) && ++x < m; ) ;
        b._next = T || null;
      }
  }
  return o = new dn(o, n), o._enter = l, o._exit = u, o;
}
function Cte(r) {
  return typeof r == "object" && "length" in r ? r : Array.from(r);
}
function Rte() {
  return new dn(this._exit || this._groups.map(bO), this._parents);
}
function Nte(r, e, i) {
  var n = this.enter(), s = this, a = this.exit();
  return typeof r == "function" ? (n = r(n), n && (n = n.selection())) : n = n.append(r + ""), e != null && (s = e(s), s && (s = s.selection())), i == null ? a.remove() : i(a), n && s ? n.merge(s).order() : s;
}
function Pte(r) {
  for (var e = r.selection ? r.selection() : r, i = this._groups, n = e._groups, s = i.length, a = n.length, o = Math.min(s, a), l = new Array(s), u = 0; u < o; ++u)
    for (var c = i[u], h = n[u], d = c.length, p = l[u] = new Array(d), f, m = 0; m < d; ++m)
      (f = c[m] || h[m]) && (p[m] = f);
  for (; u < s; ++u)
    l[u] = i[u];
  return new dn(l, this._parents);
}
function Ote() {
  for (var r = this._groups, e = -1, i = r.length; ++e < i; )
    for (var n = r[e], s = n.length - 1, a = n[s], o; --s >= 0; )
      (o = n[s]) && (a && o.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(o, a), a = o);
  return this;
}
function Ite(r) {
  r || (r = Dte);
  function e(d, p) {
    return d && p ? r(d.__data__, p.__data__) : !d - !p;
  }
  for (var i = this._groups, n = i.length, s = new Array(n), a = 0; a < n; ++a) {
    for (var o = i[a], l = o.length, u = s[a] = new Array(l), c, h = 0; h < l; ++h)
      (c = o[h]) && (u[h] = c);
    u.sort(e);
  }
  return new dn(s, this._parents).order();
}
function Dte(r, e) {
  return r < e ? -1 : r > e ? 1 : r >= e ? 0 : NaN;
}
function kte() {
  var r = arguments[0];
  return arguments[0] = this, r.apply(null, arguments), this;
}
function Lte() {
  return Array.from(this);
}
function Ute() {
  for (var r = this._groups, e = 0, i = r.length; e < i; ++e)
    for (var n = r[e], s = 0, a = n.length; s < a; ++s) {
      var o = n[s];
      if (o) return o;
    }
  return null;
}
function Fte() {
  let r = 0;
  for (const e of this) ++r;
  return r;
}
function Bte() {
  return !this.node();
}
function zte(r) {
  for (var e = this._groups, i = 0, n = e.length; i < n; ++i)
    for (var s = e[i], a = 0, o = s.length, l; a < o; ++a)
      (l = s[a]) && r.call(l, l.__data__, a, s);
  return this;
}
function jte(r) {
  return function() {
    this.removeAttribute(r);
  };
}
function Vte(r) {
  return function() {
    this.removeAttributeNS(r.space, r.local);
  };
}
function Gte(r, e) {
  return function() {
    this.setAttribute(r, e);
  };
}
function Hte(r, e) {
  return function() {
    this.setAttributeNS(r.space, r.local, e);
  };
}
function Wte(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? this.removeAttribute(r) : this.setAttribute(r, i);
  };
}
function qte(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? this.removeAttributeNS(r.space, r.local) : this.setAttributeNS(r.space, r.local, i);
  };
}
function Xte(r, e) {
  var i = Hg(r);
  if (arguments.length < 2) {
    var n = this.node();
    return i.local ? n.getAttributeNS(i.space, i.local) : n.getAttribute(i);
  }
  return this.each((e == null ? i.local ? Vte : jte : typeof e == "function" ? i.local ? qte : Wte : i.local ? Hte : Gte)(i, e));
}
function xO(r) {
  return r.ownerDocument && r.ownerDocument.defaultView || r.document && r || r.defaultView;
}
function Yte(r) {
  return function() {
    this.style.removeProperty(r);
  };
}
function $te(r, e, i) {
  return function() {
    this.style.setProperty(r, e, i);
  };
}
function Kte(r, e, i) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(r) : this.style.setProperty(r, n, i);
  };
}
function Qte(r, e, i) {
  return arguments.length > 1 ? this.each((e == null ? Yte : typeof e == "function" ? Kte : $te)(r, e, i ?? "")) : Rc(this.node(), r);
}
function Rc(r, e) {
  return r.style.getPropertyValue(e) || xO(r).getComputedStyle(r, null).getPropertyValue(e);
}
function Zte(r) {
  return function() {
    delete this[r];
  };
}
function Jte(r, e) {
  return function() {
    this[r] = e;
  };
}
function eie(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? delete this[r] : this[r] = i;
  };
}
function tie(r, e) {
  return arguments.length > 1 ? this.each((e == null ? Zte : typeof e == "function" ? eie : Jte)(r, e)) : this.node()[r];
}
function _O(r) {
  return r.trim().split(/^|\s+/);
}
function ZT(r) {
  return r.classList || new TO(r);
}
function TO(r) {
  this._node = r, this._names = _O(r.getAttribute("class") || "");
}
TO.prototype = {
  add: function(r) {
    var e = this._names.indexOf(r);
    e < 0 && (this._names.push(r), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(r) {
    var e = this._names.indexOf(r);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(r) {
    return this._names.indexOf(r) >= 0;
  }
};
function SO(r, e) {
  for (var i = ZT(r), n = -1, s = e.length; ++n < s; ) i.add(e[n]);
}
function wO(r, e) {
  for (var i = ZT(r), n = -1, s = e.length; ++n < s; ) i.remove(e[n]);
}
function iie(r) {
  return function() {
    SO(this, r);
  };
}
function rie(r) {
  return function() {
    wO(this, r);
  };
}
function nie(r, e) {
  return function() {
    (e.apply(this, arguments) ? SO : wO)(this, r);
  };
}
function sie(r, e) {
  var i = _O(r + "");
  if (arguments.length < 2) {
    for (var n = ZT(this.node()), s = -1, a = i.length; ++s < a; ) if (!n.contains(i[s])) return !1;
    return !0;
  }
  return this.each((typeof e == "function" ? nie : e ? iie : rie)(i, e));
}
function aie() {
  this.textContent = "";
}
function oie(r) {
  return function() {
    this.textContent = r;
  };
}
function lie(r) {
  return function() {
    var e = r.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function uie(r) {
  return arguments.length ? this.each(r == null ? aie : (typeof r == "function" ? lie : oie)(r)) : this.node().textContent;
}
function cie() {
  this.innerHTML = "";
}
function hie(r) {
  return function() {
    this.innerHTML = r;
  };
}
function die(r) {
  return function() {
    var e = r.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function pie(r) {
  return arguments.length ? this.each(r == null ? cie : (typeof r == "function" ? die : hie)(r)) : this.node().innerHTML;
}
function fie() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function mie() {
  return this.each(fie);
}
function gie() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function yie() {
  return this.each(gie);
}
function vie(r) {
  var e = typeof r == "function" ? r : mO(r);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function bie() {
  return null;
}
function xie(r, e) {
  var i = typeof r == "function" ? r : mO(r), n = e == null ? bie : typeof e == "function" ? e : QT(e);
  return this.select(function() {
    return this.insertBefore(i.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function _ie() {
  var r = this.parentNode;
  r && r.removeChild(this);
}
function Tie() {
  return this.each(_ie);
}
function Sie() {
  var r = this.cloneNode(!1), e = this.parentNode;
  return e ? e.insertBefore(r, this.nextSibling) : r;
}
function wie() {
  var r = this.cloneNode(!0), e = this.parentNode;
  return e ? e.insertBefore(r, this.nextSibling) : r;
}
function Eie(r) {
  return this.select(r ? wie : Sie);
}
function Mie(r) {
  return arguments.length ? this.property("__data__", r) : this.node().__data__;
}
function Aie(r) {
  return function(e) {
    r.call(this, e, this.__data__);
  };
}
function Cie(r) {
  return r.trim().split(/^|\s+/).map(function(e) {
    var i = "", n = e.indexOf(".");
    return n >= 0 && (i = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: i };
  });
}
function Rie(r) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var i = 0, n = -1, s = e.length, a; i < s; ++i)
        a = e[i], (!r.type || a.type === r.type) && a.name === r.name ? this.removeEventListener(a.type, a.listener, a.options) : e[++n] = a;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function Nie(r, e, i) {
  return function() {
    var n = this.__on, s, a = Aie(e);
    if (n) {
      for (var o = 0, l = n.length; o < l; ++o)
        if ((s = n[o]).type === r.type && s.name === r.name) {
          this.removeEventListener(s.type, s.listener, s.options), this.addEventListener(s.type, s.listener = a, s.options = i), s.value = e;
          return;
        }
    }
    this.addEventListener(r.type, a, i), s = { type: r.type, name: r.name, value: e, listener: a, options: i }, n ? n.push(s) : this.__on = [s];
  };
}
function Pie(r, e, i) {
  var n = Cie(r + ""), s, a = n.length, o;
  if (arguments.length < 2) {
    var l = this.node().__on;
    if (l) {
      for (var u = 0, c = l.length, h; u < c; ++u)
        for (s = 0, h = l[u]; s < a; ++s)
          if ((o = n[s]).type === h.type && o.name === h.name)
            return h.value;
    }
    return;
  }
  for (l = e ? Nie : Rie, s = 0; s < a; ++s) this.each(l(n[s], e, i));
  return this;
}
function EO(r, e, i) {
  var n = xO(r), s = n.CustomEvent;
  typeof s == "function" ? s = new s(e, i) : (s = n.document.createEvent("Event"), i ? (s.initEvent(e, i.bubbles, i.cancelable), s.detail = i.detail) : s.initEvent(e, !1, !1)), r.dispatchEvent(s);
}
function Oie(r, e) {
  return function() {
    return EO(this, r, e);
  };
}
function Iie(r, e) {
  return function() {
    return EO(this, r, e.apply(this, arguments));
  };
}
function Die(r, e) {
  return this.each((typeof e == "function" ? Iie : Oie)(r, e));
}
function* kie() {
  for (var r = this._groups, e = 0, i = r.length; e < i; ++e)
    for (var n = r[e], s = 0, a = n.length, o; s < a; ++s)
      (o = n[s]) && (yield o);
}
var MO = [null];
function dn(r, e) {
  this._groups = r, this._parents = e;
}
function rp() {
  return new dn([[document.documentElement]], MO);
}
function Lie() {
  return this;
}
dn.prototype = rp.prototype = {
  constructor: dn,
  select: lte,
  selectAll: dte,
  selectChild: gte,
  selectChildren: xte,
  filter: _te,
  data: Ate,
  enter: Tte,
  exit: Rte,
  join: Nte,
  merge: Pte,
  selection: Lie,
  order: Ote,
  sort: Ite,
  call: kte,
  nodes: Lte,
  node: Ute,
  size: Fte,
  empty: Bte,
  each: zte,
  attr: Xte,
  style: Qte,
  property: tie,
  classed: sie,
  text: uie,
  html: pie,
  raise: mie,
  lower: yie,
  append: vie,
  insert: xie,
  remove: Tie,
  clone: Eie,
  datum: Mie,
  on: Pie,
  dispatch: Die,
  [Symbol.iterator]: kie
};
function Tn(r) {
  return typeof r == "string" ? new dn([[document.querySelector(r)]], [document.documentElement]) : new dn([[r]], MO);
}
function Uie(r) {
  let e;
  for (; e = r.sourceEvent; ) r = e;
  return r;
}
function cs(r, e) {
  if (r = Uie(r), e === void 0 && (e = r.currentTarget), e) {
    var i = e.ownerSVGElement || e;
    if (i.createSVGPoint) {
      var n = i.createSVGPoint();
      return n.x = r.clientX, n.y = r.clientY, n = n.matrixTransform(e.getScreenCTM().inverse()), [n.x, n.y];
    }
    if (e.getBoundingClientRect) {
      var s = e.getBoundingClientRect();
      return [r.clientX - s.left - e.clientLeft, r.clientY - s.top - e.clientTop];
    }
  }
  return [r.pageX, r.pageY];
}
var np, mi, AO, CO, tl, TA, RO, NO, PO, JT, Vx, Gx, Nd = {}, OO = [], Fie = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Wg = Array.isArray;
function xs(r, e) {
  for (var i in e) r[i] = e[i];
  return r;
}
function eS(r) {
  r && r.parentNode && r.parentNode.removeChild(r);
}
function Bie(r, e, i) {
  var n, s, a, o = {};
  for (a in e) a == "key" ? n = e[a] : a == "ref" ? s = e[a] : o[a] = e[a];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? np.call(arguments, 2) : i), typeof r == "function" && r.defaultProps != null) for (a in r.defaultProps) o[a] === void 0 && (o[a] = r.defaultProps[a]);
  return ad(r, o, n, s, null);
}
function ad(r, e, i, n, s) {
  var a = { type: r, props: e, key: i, ref: n, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: s ?? ++AO, __i: -1, __u: 0 };
  return s == null && mi.vnode != null && mi.vnode(a), a;
}
function qg(r) {
  return r.children;
}
function um(r, e) {
  this.props = r, this.context = e;
}
function Nc(r, e) {
  if (e == null) return r.__ ? Nc(r.__, r.__i + 1) : null;
  for (var i; e < r.__k.length; e++) if ((i = r.__k[e]) != null && i.__e != null) return i.__e;
  return typeof r.type == "function" ? Nc(r) : null;
}
function IO(r) {
  var e, i;
  if ((r = r.__) != null && r.__c != null) {
    for (r.__e = r.__c.base = null, e = 0; e < r.__k.length; e++) if ((i = r.__k[e]) != null && i.__e != null) {
      r.__e = r.__c.base = i.__e;
      break;
    }
    return IO(r);
  }
}
function SA(r) {
  (!r.__d && (r.__d = !0) && tl.push(r) && !Qm.__r++ || TA !== mi.debounceRendering) && ((TA = mi.debounceRendering) || RO)(Qm);
}
function Qm() {
  for (var r, e, i, n, s, a, o, l = 1; tl.length; ) tl.length > l && tl.sort(NO), r = tl.shift(), l = tl.length, r.__d && (i = void 0, s = (n = (e = r).__v).__e, a = [], o = [], e.__P && ((i = xs({}, n)).__v = n.__v + 1, mi.vnode && mi.vnode(i), tS(e.__P, i, n, e.__n, e.__P.namespaceURI, 32 & n.__u ? [s] : null, a, s ?? Nc(n), !!(32 & n.__u), o), i.__v = n.__v, i.__.__k[i.__i] = i, LO(a, i, o), i.__e != s && IO(i)));
  Qm.__r = 0;
}
function DO(r, e, i, n, s, a, o, l, u, c, h) {
  var d, p, f, m, v, y, g = n && n.__k || OO, _ = e.length;
  for (u = zie(i, e, g, u, _), d = 0; d < _; d++) (f = i.__k[d]) != null && (p = f.__i === -1 ? Nd : g[f.__i] || Nd, f.__i = d, y = tS(r, f, p, s, a, o, l, u, c, h), m = f.__e, f.ref && p.ref != f.ref && (p.ref && iS(p.ref, null, f), h.push(f.ref, f.__c || m, f)), v == null && m != null && (v = m), 4 & f.__u || p.__k === f.__k ? u = kO(f, u, r) : typeof f.type == "function" && y !== void 0 ? u = y : m && (u = m.nextSibling), f.__u &= -7);
  return i.__e = v, u;
}
function zie(r, e, i, n, s) {
  var a, o, l, u, c, h = i.length, d = h, p = 0;
  for (r.__k = new Array(s), a = 0; a < s; a++) (o = e[a]) != null && typeof o != "boolean" && typeof o != "function" ? (u = a + p, (o = r.__k[a] = typeof o == "string" || typeof o == "number" || typeof o == "bigint" || o.constructor == String ? ad(null, o, null, null, null) : Wg(o) ? ad(qg, { children: o }, null, null, null) : o.constructor === void 0 && o.__b > 0 ? ad(o.type, o.props, o.key, o.ref ? o.ref : null, o.__v) : o).__ = r, o.__b = r.__b + 1, l = null, (c = o.__i = jie(o, i, u, d)) !== -1 && (d--, (l = i[c]) && (l.__u |= 2)), l == null || l.__v === null ? (c == -1 && (s > h ? p-- : s < h && p++), typeof o.type != "function" && (o.__u |= 4)) : c != u && (c == u - 1 ? p-- : c == u + 1 ? p++ : (c > u ? p-- : p++, o.__u |= 4))) : r.__k[a] = null;
  if (d) for (a = 0; a < h; a++) (l = i[a]) != null && !(2 & l.__u) && (l.__e == n && (n = Nc(l)), FO(l, l));
  return n;
}
function kO(r, e, i) {
  var n, s;
  if (typeof r.type == "function") {
    for (n = r.__k, s = 0; n && s < n.length; s++) n[s] && (n[s].__ = r, e = kO(n[s], e, i));
    return e;
  }
  r.__e != e && (e && r.type && !i.contains(e) && (e = Nc(r)), i.insertBefore(r.__e, e || null), e = r.__e);
  do
    e = e && e.nextSibling;
  while (e != null && e.nodeType == 8);
  return e;
}
function jie(r, e, i, n) {
  var s, a, o = r.key, l = r.type, u = e[i];
  if (u === null && r.key == null || u && o == u.key && l === u.type && !(2 & u.__u)) return i;
  if (n > (u != null && !(2 & u.__u) ? 1 : 0)) for (s = i - 1, a = i + 1; s >= 0 || a < e.length; ) {
    if (s >= 0) {
      if ((u = e[s]) && !(2 & u.__u) && o == u.key && l === u.type) return s;
      s--;
    }
    if (a < e.length) {
      if ((u = e[a]) && !(2 & u.__u) && o == u.key && l === u.type) return a;
      a++;
    }
  }
  return -1;
}
function wA(r, e, i) {
  e[0] == "-" ? r.setProperty(e, i ?? "") : r[e] = i == null ? "" : typeof i != "number" || Fie.test(e) ? i : i + "px";
}
function Of(r, e, i, n, s) {
  var a;
  e: if (e == "style") if (typeof i == "string") r.style.cssText = i;
  else {
    if (typeof n == "string" && (r.style.cssText = n = ""), n) for (e in n) i && e in i || wA(r.style, e, "");
    if (i) for (e in i) n && i[e] === n[e] || wA(r.style, e, i[e]);
  }
  else if (e[0] == "o" && e[1] == "n") a = e != (e = e.replace(PO, "$1")), e = e.toLowerCase() in r || e == "onFocusOut" || e == "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), r.l || (r.l = {}), r.l[e + a] = i, i ? n ? i.t = n.t : (i.t = JT, r.addEventListener(e, a ? Gx : Vx, a)) : r.removeEventListener(e, a ? Gx : Vx, a);
  else {
    if (s == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in r) try {
      r[e] = i ?? "";
      break e;
    } catch {
    }
    typeof i == "function" || (i == null || i === !1 && e[4] != "-" ? r.removeAttribute(e) : r.setAttribute(e, e == "popover" && i == 1 ? "" : i));
  }
}
function EA(r) {
  return function(e) {
    if (this.l) {
      var i = this.l[e.type + r];
      if (e.u == null) e.u = JT++;
      else if (e.u < i.t) return;
      return i(mi.event ? mi.event(e) : e);
    }
  };
}
function tS(r, e, i, n, s, a, o, l, u, c) {
  var h, d, p, f, m, v, y, g, _, x, b, T, S, w, C, E, A, N = e.type;
  if (e.constructor !== void 0) return null;
  128 & i.__u && (u = !!(32 & i.__u), a = [l = e.__e = i.__e]), (h = mi.__b) && h(e);
  e: if (typeof N == "function") try {
    if (g = e.props, _ = "prototype" in N && N.prototype.render, x = (h = N.contextType) && n[h.__c], b = h ? x ? x.props.value : h.__ : n, i.__c ? y = (d = e.__c = i.__c).__ = d.__E : (_ ? e.__c = d = new N(g, b) : (e.__c = d = new um(g, b), d.constructor = N, d.render = Gie), x && x.sub(d), d.props = g, d.state || (d.state = {}), d.context = b, d.__n = n, p = d.__d = !0, d.__h = [], d._sb = []), _ && d.__s == null && (d.__s = d.state), _ && N.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = xs({}, d.__s)), xs(d.__s, N.getDerivedStateFromProps(g, d.__s))), f = d.props, m = d.state, d.__v = e, p) _ && N.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(), _ && d.componentDidMount != null && d.__h.push(d.componentDidMount);
    else {
      if (_ && N.getDerivedStateFromProps == null && g !== f && d.componentWillReceiveProps != null && d.componentWillReceiveProps(g, b), !d.__e && (d.shouldComponentUpdate != null && d.shouldComponentUpdate(g, d.__s, b) === !1 || e.__v == i.__v)) {
        for (e.__v != i.__v && (d.props = g, d.state = d.__s, d.__d = !1), e.__e = i.__e, e.__k = i.__k, e.__k.some(function(L) {
          L && (L.__ = e);
        }), T = 0; T < d._sb.length; T++) d.__h.push(d._sb[T]);
        d._sb = [], d.__h.length && o.push(d);
        break e;
      }
      d.componentWillUpdate != null && d.componentWillUpdate(g, d.__s, b), _ && d.componentDidUpdate != null && d.__h.push(function() {
        d.componentDidUpdate(f, m, v);
      });
    }
    if (d.context = b, d.props = g, d.__P = r, d.__e = !1, S = mi.__r, w = 0, _) {
      for (d.state = d.__s, d.__d = !1, S && S(e), h = d.render(d.props, d.state, d.context), C = 0; C < d._sb.length; C++) d.__h.push(d._sb[C]);
      d._sb = [];
    } else do
      d.__d = !1, S && S(e), h = d.render(d.props, d.state, d.context), d.state = d.__s;
    while (d.__d && ++w < 25);
    d.state = d.__s, d.getChildContext != null && (n = xs(xs({}, n), d.getChildContext())), _ && !p && d.getSnapshotBeforeUpdate != null && (v = d.getSnapshotBeforeUpdate(f, m)), E = h, h != null && h.type === qg && h.key == null && (E = UO(h.props.children)), l = DO(r, Wg(E) ? E : [E], e, i, n, s, a, o, l, u, c), d.base = e.__e, e.__u &= -161, d.__h.length && o.push(d), y && (d.__E = d.__ = null);
  } catch (L) {
    if (e.__v = null, u || a != null) if (L.then) {
      for (e.__u |= u ? 160 : 128; l && l.nodeType == 8 && l.nextSibling; ) l = l.nextSibling;
      a[a.indexOf(l)] = null, e.__e = l;
    } else for (A = a.length; A--; ) eS(a[A]);
    else e.__e = i.__e, e.__k = i.__k;
    mi.__e(L, e, i);
  }
  else a == null && e.__v == i.__v ? (e.__k = i.__k, e.__e = i.__e) : l = e.__e = Vie(i.__e, e, i, n, s, a, o, u, c);
  return (h = mi.diffed) && h(e), 128 & e.__u ? void 0 : l;
}
function LO(r, e, i) {
  for (var n = 0; n < i.length; n++) iS(i[n], i[++n], i[++n]);
  mi.__c && mi.__c(e, r), r.some(function(s) {
    try {
      r = s.__h, s.__h = [], r.some(function(a) {
        a.call(s);
      });
    } catch (a) {
      mi.__e(a, s.__v);
    }
  });
}
function UO(r) {
  return typeof r != "object" || r == null ? r : Wg(r) ? r.map(UO) : xs({}, r);
}
function Vie(r, e, i, n, s, a, o, l, u) {
  var c, h, d, p, f, m, v, y = i.props, g = e.props, _ = e.type;
  if (_ == "svg" ? s = "http://www.w3.org/2000/svg" : _ == "math" ? s = "http://www.w3.org/1998/Math/MathML" : s || (s = "http://www.w3.org/1999/xhtml"), a != null) {
    for (c = 0; c < a.length; c++) if ((f = a[c]) && "setAttribute" in f == !!_ && (_ ? f.localName == _ : f.nodeType == 3)) {
      r = f, a[c] = null;
      break;
    }
  }
  if (r == null) {
    if (_ == null) return document.createTextNode(g);
    r = document.createElementNS(s, _, g.is && g), l && (mi.__m && mi.__m(e, a), l = !1), a = null;
  }
  if (_ === null) y === g || l && r.data === g || (r.data = g);
  else {
    if (a = a && np.call(r.childNodes), y = i.props || Nd, !l && a != null) for (y = {}, c = 0; c < r.attributes.length; c++) y[(f = r.attributes[c]).name] = f.value;
    for (c in y) if (f = y[c], c != "children") {
      if (c == "dangerouslySetInnerHTML") d = f;
      else if (!(c in g)) {
        if (c == "value" && "defaultValue" in g || c == "checked" && "defaultChecked" in g) continue;
        Of(r, c, null, f, s);
      }
    }
    for (c in g) f = g[c], c == "children" ? p = f : c == "dangerouslySetInnerHTML" ? h = f : c == "value" ? m = f : c == "checked" ? v = f : l && typeof f != "function" || y[c] === f || Of(r, c, f, y[c], s);
    if (h) l || d && (h.__html === d.__html || h.__html === r.innerHTML) || (r.innerHTML = h.__html), e.__k = [];
    else if (d && (r.innerHTML = ""), DO(e.type === "template" ? r.content : r, Wg(p) ? p : [p], e, i, n, _ == "foreignObject" ? "http://www.w3.org/1999/xhtml" : s, a, o, a ? a[0] : i.__k && Nc(i, 0), l, u), a != null) for (c = a.length; c--; ) eS(a[c]);
    l || (c = "value", _ == "progress" && m == null ? r.removeAttribute("value") : m !== void 0 && (m !== r[c] || _ == "progress" && !m || _ == "option" && m !== y[c]) && Of(r, c, m, y[c], s), c = "checked", v !== void 0 && v !== r[c] && Of(r, c, v, y[c], s));
  }
  return r;
}
function iS(r, e, i) {
  try {
    if (typeof r == "function") {
      var n = typeof r.__u == "function";
      n && r.__u(), n && e == null || (r.__u = r(e));
    } else r.current = e;
  } catch (s) {
    mi.__e(s, i);
  }
}
function FO(r, e, i) {
  var n, s;
  if (mi.unmount && mi.unmount(r), (n = r.ref) && (n.current && n.current !== r.__e || iS(n, null, e)), (n = r.__c) != null) {
    if (n.componentWillUnmount) try {
      n.componentWillUnmount();
    } catch (a) {
      mi.__e(a, e);
    }
    n.base = n.__P = null;
  }
  if (n = r.__k) for (s = 0; s < n.length; s++) n[s] && FO(n[s], e, i || typeof r.type != "function");
  i || eS(r.__e), r.__c = r.__ = r.__e = void 0;
}
function Gie(r, e, i) {
  return this.constructor(r, i);
}
function Hie(r, e, i) {
  var n, s, a, o;
  e == document && (e = document.documentElement), mi.__ && mi.__(r, e), s = (n = !1) ? null : e.__k, a = [], o = [], tS(e, r = e.__k = Bie(qg, null, [r]), s || Nd, Nd, e.namespaceURI, s ? null : e.firstChild ? np.call(e.childNodes) : null, a, s ? s.__e : e.firstChild, n, o), LO(a, r, o);
}
function BO(r, e, i) {
  var n, s, a, o, l = xs({}, r.props);
  for (a in r.type && r.type.defaultProps && (o = r.type.defaultProps), e) a == "key" ? n = e[a] : a == "ref" ? s = e[a] : l[a] = e[a] === void 0 && o !== void 0 ? o[a] : e[a];
  return arguments.length > 2 && (l.children = arguments.length > 3 ? np.call(arguments, 2) : i), ad(r.type, l, n || r.key, s || r.ref, null);
}
np = OO.slice, mi = { __e: function(r, e, i, n) {
  for (var s, a, o; e = e.__; ) if ((s = e.__c) && !s.__) try {
    if ((a = s.constructor) && a.getDerivedStateFromError != null && (s.setState(a.getDerivedStateFromError(r)), o = s.__d), s.componentDidCatch != null && (s.componentDidCatch(r, n || {}), o = s.__d), o) return s.__E = s;
  } catch (l) {
    r = l;
  }
  throw r;
} }, AO = 0, CO = function(r) {
  return r != null && r.constructor == null;
}, um.prototype.setState = function(r, e) {
  var i;
  i = this.__s != null && this.__s !== this.state ? this.__s : this.__s = xs({}, this.state), typeof r == "function" && (r = r(xs({}, i), this.props)), r && xs(i, r), r != null && this.__v && (e && this._sb.push(e), SA(this));
}, um.prototype.forceUpdate = function(r) {
  this.__v && (this.__e = !0, r && this.__h.push(r), SA(this));
}, um.prototype.render = qg, tl = [], RO = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, NO = function(r, e) {
  return r.__v.__b - e.__v.__b;
}, Qm.__r = 0, PO = /(PointerCapture)$|Capture$/i, JT = 0, Vx = EA(!1), Gx = EA(!0);
function MA(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Wie(r) {
  if (Array.isArray(r)) return r;
}
function qie(r, e, i) {
  return (e = Zie(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function Xie(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function Yie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function AA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function $ie(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? AA(Object(i), !0).forEach(function(n) {
      qie(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : AA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function Kie(r, e) {
  return Wie(r) || Xie(r, e) || Jie(r, e) || Yie();
}
function Qie(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Zie(r) {
  var e = Qie(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Zm(r) {
  "@babel/helpers - typeof";
  return Zm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Zm(r);
}
function Jie(r, e) {
  if (r) {
    if (typeof r == "string") return MA(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? MA(r, e) : void 0;
  }
}
var Hx = function(r) {
  if (Zm(r) !== "object") return r;
  var e = BO(r);
  if (e.props) {
    var i;
    e.props = $ie({}, e.props), e != null && (i = e.props) !== null && i !== void 0 && i.children && (e.props.children = Array.isArray(e.props.children) ? e.props.children.map(Hx) : Hx(e.props.children));
  }
  return e;
}, ere = function(r) {
  return CO(BO(r));
}, tre = function(r, e) {
  delete e.__k, Hie(Hx(r), e);
};
function ire(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var rre = `.float-tooltip-kap {
  position: absolute;
  width: max-content; /* prevent shrinking near right edge */
  max-width: max(50%, 150px);
  padding: 3px 5px;
  border-radius: 3px;
  font: 12px sans-serif;
  color: #eee;
  background: rgba(0,0,0,0.6);
  pointer-events: none;
}
`;
ire(rre);
var zO = Il({
  props: {
    content: {
      default: !1
    },
    offsetX: {
      triggerUpdate: !1
    },
    // null or number
    offsetY: {
      triggerUpdate: !1
    }
    // null or number
  },
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.style, s = n === void 0 ? {} : n, a = !!r && Zm(r) === "object" && !!r.node && typeof r.node == "function", o = Tn(a ? r.node() : r);
    o.style("position") === "static" && o.style("position", "relative"), e.tooltipEl = o.append("div").attr("class", "float-tooltip-kap"), Object.entries(s).forEach(function(u) {
      var c = Kie(u, 2), h = c[0], d = c[1];
      return e.tooltipEl.style(h, d);
    }), e.tooltipEl.style("left", "-10000px").style("display", "none");
    var l = "tooltip-".concat(Math.round(Math.random() * 1e12));
    e.mouseInside = !1, o.on("mousemove.".concat(l), function(u) {
      e.mouseInside = !0;
      var c = cs(u), h = o.node(), d = h.offsetWidth, p = h.offsetHeight, f = [e.offsetX === null || e.offsetX === void 0 ? "-".concat(c[0] / d * 100, "%") : typeof e.offsetX == "number" ? "calc(-50% + ".concat(e.offsetX, "px)") : e.offsetX, e.offsetY === null || e.offsetY === void 0 ? p > 130 && p - c[1] < 100 ? "calc(-100% - 6px)" : "21px" : typeof e.offsetY == "number" ? e.offsetY < 0 ? "calc(-100% - ".concat(Math.abs(e.offsetY), "px)") : "".concat(e.offsetY, "px") : e.offsetY];
      e.tooltipEl.style("left", c[0] + "px").style("top", c[1] + "px").style("transform", "translate(".concat(f.join(","), ")")), e.content && e.tooltipEl.style("display", "inline");
    }), o.on("mouseover.".concat(l), function() {
      e.mouseInside = !0, e.content && e.tooltipEl.style("display", "inline");
    }), o.on("mouseout.".concat(l), function() {
      e.mouseInside = !1, e.tooltipEl.style("display", "none");
    });
  },
  update: function(r) {
    r.tooltipEl.style("display", r.content && r.mouseInside ? "inline" : "none"), r.content ? r.content instanceof HTMLElement ? (r.tooltipEl.text(""), r.tooltipEl.append(function() {
      return r.content;
    })) : typeof r.content == "string" ? r.tooltipEl.html(r.content) : ere(r.content) ? (r.tooltipEl.text(""), tre(r.content, r.tooltipEl.node())) : (r.tooltipEl.style("display", "none"), console.warn("Tooltip content is invalid, skipping.", r.content, r.content.toString())) : r.tooltipEl.text("");
  }
});
function nre(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var sre = `.scene-nav-info {
  position: absolute;
  bottom: 5px;
  width: 100%;
  text-align: center;
  color: slategrey;
  opacity: 0.7;
  font-size: 10px;
  font-family: sans-serif;
  pointer-events: none;
  user-select: none;
}

.scene-container canvas:focus {
  outline: none;
}`;
nre(sre);
function Wx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function are(r) {
  if (Array.isArray(r)) return r;
}
function ore(r) {
  if (Array.isArray(r)) return Wx(r);
}
function lre(r, e, i) {
  return (e = mre(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function ure(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function cre(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function hre() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function dre() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function pre(r, e) {
  return are(r) || cre(r, e) || jO(r, e) || hre();
}
function Vo(r) {
  return ore(r) || ure(r) || jO(r) || dre();
}
function fre(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function mre(r) {
  var e = fre(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function jO(r, e) {
  if (r) {
    if (typeof r == "string") return Wx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Wx(r, e) : void 0;
  }
}
var pi = window.THREE ? window.THREE : {
  WebGLRenderer: E6,
  Scene: M6,
  PerspectiveCamera: _n,
  Raycaster: MR,
  SRGBColorSpace: ln,
  TextureLoader: K6,
  Vector2: Le,
  Vector3: X,
  Box3: Pl,
  Color: Ft,
  Mesh: Ur,
  SphereGeometry: TR,
  MeshBasicMaterial: xg,
  BackSide: Mr,
  Clock: ER
}, VO = Il({
  props: {
    width: {
      default: window.innerWidth,
      onChange: function(r, e, i) {
        isNaN(r) && (e.width = i);
      }
    },
    height: {
      default: window.innerHeight,
      onChange: function(r, e, i) {
        isNaN(r) && (e.height = i);
      }
    },
    viewOffset: {
      default: [0, 0]
    },
    backgroundColor: {
      default: "#000011"
    },
    backgroundImageUrl: {},
    onBackgroundImageLoaded: {},
    showNavInfo: {
      default: !0
    },
    skyRadius: {
      default: 5e4
    },
    objects: {
      default: []
    },
    lights: {
      default: []
    },
    enablePointerInteraction: {
      default: !0,
      onChange: function(r, e) {
        e.hoverObj = null, e.tooltip && e.tooltip.content(null);
      },
      triggerUpdate: !1
    },
    lineHoverPrecision: {
      default: 1,
      triggerUpdate: !1
    },
    pointsHoverPrecision: {
      default: 1,
      triggerUpdate: !1
    },
    hoverOrderComparator: {
      triggerUpdate: !1
    },
    // keep existing order by default
    hoverFilter: {
      default: function() {
        return !0;
      },
      triggerUpdate: !1
    },
    // exclude objects from interaction
    tooltipContent: {
      triggerUpdate: !1
    },
    hoverDuringDrag: {
      default: !1,
      triggerUpdate: !1
    },
    clickAfterDrag: {
      default: !1,
      triggerUpdate: !1
    },
    onHover: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onClick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onRightClick: {
      triggerUpdate: !1
    }
  },
  methods: {
    tick: function(r) {
      if (r.initialised) {
        if (r.controls.update && r.controls.update(Math.min(1, r.clock.getDelta())), r.postProcessingComposer ? r.postProcessingComposer.render() : r.renderer.render(r.scene, r.camera), r.extraRenderers.forEach(function(s) {
          return s.render(r.scene, r.camera);
        }), r.enablePointerInteraction) {
          var e = null;
          if (r.hoverDuringDrag || !r.isPointerDragging) {
            var i = this.intersectingObjects(r.pointerPos.x, r.pointerPos.y);
            r.hoverOrderComparator && i.sort(function(s, a) {
              return r.hoverOrderComparator(s.object, a.object);
            });
            var n = i.find(function(s) {
              return r.hoverFilter(s.object);
            }) || null;
            e = n ? n.object : null, r.intersection = n || null;
          }
          e !== r.hoverObj && (r.onHover(e, r.hoverObj, r.intersection), r.tooltip.content(e && et(r.tooltipContent)(e, r.intersection) || null), r.hoverObj = e);
        }
        r.tweenGroup.update();
      }
      return this;
    },
    getPointerPos: function(r) {
      var e = r.pointerPos, i = e.x, n = e.y;
      return {
        x: i,
        y: n
      };
    },
    cameraPosition: function(r, e, i, n) {
      var s = r.camera;
      if (e && r.initialised) {
        var a = e, o = i || {
          x: 0,
          y: 0,
          z: 0
        };
        if (!n)
          c(a), h(o);
        else {
          var l = Object.assign({}, s.position), u = d();
          r.tweenGroup.add(new $m(l).to(a, n).easing(_a.Quadratic.Out).onUpdate(c).start()), r.tweenGroup.add(new $m(u).to(o, n / 3).easing(_a.Quadratic.Out).onUpdate(h).start());
        }
        return this;
      }
      return Object.assign({}, s.position, {
        lookAt: d()
      });
      function c(p) {
        var f = p.x, m = p.y, v = p.z;
        f !== void 0 && (s.position.x = f), m !== void 0 && (s.position.y = m), v !== void 0 && (s.position.z = v);
      }
      function h(p) {
        var f = new pi.Vector3(p.x, p.y, p.z);
        r.controls.target ? r.controls.target = f : s.lookAt(f);
      }
      function d() {
        return Object.assign(new pi.Vector3(0, 0, -1e3).applyQuaternion(s.quaternion).add(s.position));
      }
    },
    zoomToFit: function(r) {
      for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, n = arguments.length, s = new Array(n > 3 ? n - 3 : 0), a = 3; a < n; a++)
        s[a - 3] = arguments[a];
      return this.fitToBbox(this.getBbox.apply(this, s), e, i);
    },
    fitToBbox: function(r, e) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10, s = r.camera;
      if (e) {
        var a = new pi.Vector3(0, 0, 0), o = Math.max.apply(Math, Vo(Object.entries(e).map(function(p) {
          var f = pre(p, 2), m = f[0], v = f[1];
          return Math.max.apply(Math, Vo(v.map(function(y) {
            return Math.abs(a[m] - y);
          })));
        }))) * 2, l = (1 - n * 2 / r.height) * s.fov, u = o / Math.atan(l * Math.PI / 180), c = u / s.aspect, h = Math.max(u, c);
        if (h > 0) {
          var d = a.clone().sub(s.position).normalize().multiplyScalar(-h);
          this.cameraPosition(d, a, i);
        }
      }
      return this;
    },
    getBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      }, i = new pi.Box3(new pi.Vector3(0, 0, 0), new pi.Vector3(0, 0, 0)), n = r.objects.filter(e);
      return n.length ? (n.forEach(function(s) {
        return i.expandByObject(s);
      }), Object.assign.apply(Object, Vo(["x", "y", "z"].map(function(s) {
        return lre({}, s, [i.min[s], i.max[s]]);
      })))) : null;
    },
    getScreenCoords: function(r, e, i, n) {
      var s = new pi.Vector3(e, i, n);
      return s.project(this.camera()), {
        // align relative pos to canvas dimensions
        x: (s.x + 1) * r.width / 2,
        y: -(s.y - 1) * r.height / 2
      };
    },
    getSceneCoords: function(r, e, i) {
      var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s = new pi.Vector2(e / r.width * 2 - 1, -(i / r.height) * 2 + 1), a = new pi.Raycaster();
      return a.setFromCamera(s, r.camera), Object.assign({}, a.ray.at(n, new pi.Vector3()));
    },
    intersectingObjects: function(r, e, i) {
      var n = new pi.Vector2(e / r.width * 2 - 1, -(i / r.height) * 2 + 1), s = new pi.Raycaster();
      return s.params.Line.threshold = r.lineHoverPrecision, s.params.Points.threshold = r.pointsHoverPrecision, s.setFromCamera(n, r.camera), s.intersectObjects(r.objects, !0);
    },
    renderer: function(r) {
      return r.renderer;
    },
    scene: function(r) {
      return r.scene;
    },
    camera: function(r) {
      return r.camera;
    },
    postProcessingComposer: function(r) {
      return r.postProcessingComposer;
    },
    controls: function(r) {
      return r.controls;
    },
    tbControls: function(r) {
      return r.controls;
    }
    // to be deprecated
  },
  stateInit: function() {
    return {
      scene: new pi.Scene(),
      camera: new pi.PerspectiveCamera(),
      clock: new pi.Clock(),
      tweenGroup: new KT()
    };
  },
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.controlType, s = n === void 0 ? "trackball" : n, a = i.useWebGPU, o = a === void 0 ? !1 : a, l = i.rendererConfig, u = l === void 0 ? {} : l, c = i.extraRenderers, h = c === void 0 ? [] : c, d = i.waitForLoadComplete, p = d === void 0 ? !0 : d;
    r.innerHTML = "", r.appendChild(e.container = document.createElement("div")), e.container.className = "scene-container", e.container.style.position = "relative", e.container.appendChild(e.navInfo = document.createElement("div")), e.navInfo.className = "scene-nav-info", e.navInfo.textContent = {
      orbit: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      trackball: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      fly: "WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw"
    }[s] || "", e.navInfo.style.display = e.showNavInfo ? null : "none", e.tooltip = new zO(e.container), e.pointerPos = new pi.Vector2(), e.pointerPos.x = -2, e.pointerPos.y = -2, ["pointermove", "pointerdown"].forEach(function(f) {
      return e.container.addEventListener(f, function(m) {
        if (f === "pointerdown" && (e.isPointerPressed = !0), !e.isPointerDragging && m.type === "pointermove" && (m.pressure > 0 || e.isPointerPressed) && (m.pointerType !== "touch" || m.movementX === void 0 || [m.movementX, m.movementY].some(function(g) {
          return Math.abs(g) > 1;
        })) && (e.isPointerDragging = !0), e.enablePointerInteraction) {
          var v = y(e.container);
          e.pointerPos.x = m.pageX - v.left, e.pointerPos.y = m.pageY - v.top;
        }
        function y(g) {
          var _ = g.getBoundingClientRect(), x = window.pageXOffset || document.documentElement.scrollLeft, b = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: _.top + b,
            left: _.left + x
          };
        }
      }, {
        passive: !0
      });
    }), e.container.addEventListener("pointerup", function(f) {
      e.isPointerPressed = !1, !(e.isPointerDragging && (e.isPointerDragging = !1, !e.clickAfterDrag)) && requestAnimationFrame(function() {
        f.button === 0 && e.onClick(e.hoverObj || null, f, e.intersection), f.button === 2 && e.onRightClick && e.onRightClick(e.hoverObj || null, f, e.intersection);
      });
    }, {
      passive: !0,
      capture: !0
    }), e.container.addEventListener("contextmenu", function(f) {
      e.onRightClick && f.preventDefault();
    }), e.renderer = new (o ? wJ : pi.WebGLRenderer)(Object.assign({
      antialias: !0,
      alpha: !0
    }, u)), e.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio)), e.container.appendChild(e.renderer.domElement), e.extraRenderers = h, e.extraRenderers.forEach(function(f) {
      f.domElement.style.position = "absolute", f.domElement.style.top = "0px", f.domElement.style.pointerEvents = "none", e.container.appendChild(f.domElement);
    }), e.postProcessingComposer = new yee(e.renderer), e.postProcessingComposer.addPass(new vee(e.scene, e.camera)), e.controls = new {
      trackball: MJ,
      orbit: VJ,
      fly: iee
    }[s](e.camera, e.renderer.domElement), s === "fly" && (e.controls.movementSpeed = 300, e.controls.rollSpeed = Math.PI / 6, e.controls.dragToLook = !0), (s === "trackball" || s === "orbit") && (e.controls.minDistance = 0.1, e.controls.maxDistance = e.skyRadius, e.controls.addEventListener("start", function() {
      e.controlsEngaged = !0;
    }), e.controls.addEventListener("change", function() {
      e.controlsEngaged && (e.controlsDragging = !0);
    }), e.controls.addEventListener("end", function() {
      e.controlsEngaged = !1, e.controlsDragging = !1;
    })), [e.renderer, e.postProcessingComposer].concat(Vo(e.extraRenderers)).forEach(function(f) {
      return f.setSize(e.width, e.height);
    }), e.camera.aspect = e.width / e.height, e.camera.updateProjectionMatrix(), e.camera.position.z = 1e3, e.scene.add(e.skysphere = new pi.Mesh()), e.skysphere.visible = !1, e.loadComplete = e.scene.visible = !p, window.scene = e.scene;
  },
  update: function(r, e) {
    if (r.width && r.height && (e.hasOwnProperty("width") || e.hasOwnProperty("height"))) {
      var i, n = r.width, s = r.height;
      r.container.style.width = "".concat(n, "px"), r.container.style.height = "".concat(s, "px"), [r.renderer, r.postProcessingComposer].concat(Vo(r.extraRenderers)).forEach(function(p) {
        return p.setSize(n, s);
      }), r.camera.aspect = n / s;
      var a = r.viewOffset.slice(0, 2);
      a.some(function(p) {
        return p;
      }) && (i = r.camera).setViewOffset.apply(i, [n, s].concat(Vo(a), [n, s])), r.camera.updateProjectionMatrix();
    }
    if (e.hasOwnProperty("viewOffset")) {
      var o, l = r.width, u = r.height, c = r.viewOffset.slice(0, 2);
      c.some(function(p) {
        return p;
      }) ? (o = r.camera).setViewOffset.apply(o, [l, u].concat(Vo(c), [l, u])) : r.camera.clearViewOffset();
    }
    if (e.hasOwnProperty("skyRadius") && r.skyRadius && (r.controls.hasOwnProperty("maxDistance") && e.skyRadius && (r.controls.maxDistance = Math.min(r.controls.maxDistance, r.skyRadius)), r.camera.far = r.skyRadius * 2.5, r.camera.updateProjectionMatrix(), r.skysphere.geometry = new pi.SphereGeometry(r.skyRadius)), e.hasOwnProperty("backgroundColor")) {
      var h = Cc(r.backgroundColor).alpha;
      h === void 0 && (h = 1), r.renderer.setClearColor(new pi.Color(Qee(1, r.backgroundColor)), h);
    }
    e.hasOwnProperty("backgroundImageUrl") && (r.backgroundImageUrl ? new pi.TextureLoader().load(r.backgroundImageUrl, function(p) {
      p.colorSpace = pi.SRGBColorSpace, r.skysphere.material = new pi.MeshBasicMaterial({
        map: p,
        side: pi.BackSide
      }), r.skysphere.visible = !0, r.onBackgroundImageLoaded && setTimeout(r.onBackgroundImageLoaded), !r.loadComplete && d();
    }) : (r.skysphere.visible = !1, r.skysphere.material.map = null, !r.loadComplete && d())), e.hasOwnProperty("showNavInfo") && (r.navInfo.style.display = r.showNavInfo ? null : "none"), e.hasOwnProperty("lights") && ((e.lights || []).forEach(function(p) {
      return r.scene.remove(p);
    }), r.lights.forEach(function(p) {
      return r.scene.add(p);
    })), e.hasOwnProperty("objects") && ((e.objects || []).forEach(function(p) {
      return r.scene.remove(p);
    }), r.objects.forEach(function(p) {
      return r.scene.add(p);
    }));
    function d() {
      r.loadComplete = r.scene.visible = !0;
    }
  }
});
function gre(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var yre = `.graph-info-msg {
  top: 50%;
  width: 100%;
  text-align: center;
  color: lavender;
  opacity: 0.7;
  font-size: 22px;
  position: absolute;
  font-family: Sans-serif;
}

.scene-container .clickable {
  cursor: pointer;
}

.scene-container .grabbable {
  cursor: move;
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

.scene-container .grabbable:active {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
}`;
gre(yre);
function qx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function vre(r) {
  if (Array.isArray(r)) return qx(r);
}
function sp(r, e, i) {
  return (e = Tre(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function bre(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function xre() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function CA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function If(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? CA(Object(i), !0).forEach(function(n) {
      sp(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : CA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function Xg(r) {
  return vre(r) || bre(r) || Sre(r) || xre();
}
function _re(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Tre(r) {
  var e = _re(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Sre(r, e) {
  if (r) {
    if (typeof r == "string") return qx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? qx(r, e) : void 0;
  }
}
function GO(r, e) {
  var i = new e();
  return i._destructor && i._destructor(), {
    linkProp: function(n) {
      return {
        default: i[n](),
        onChange: function(s, a) {
          a[r][n](s);
        },
        triggerUpdate: !1
      };
    },
    linkMethod: function(n) {
      return function(s) {
        for (var a = s[r], o = arguments.length, l = new Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)
          l[u - 1] = arguments[u];
        var c = a[n].apply(a, l);
        return c === a ? this : c;
      };
    }
  };
}
var Sv = window.THREE ? window.THREE : {
  AmbientLight: eV,
  DirectionalLight: J6,
  REVISION: mg
}, wre = 170, HO = GO("forceGraph", ku), Ere = Object.assign.apply(Object, Xg(["jsonUrl", "graphData", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeVisibility", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "forceEngine", "d3AlphaDecay", "d3VelocityDecay", "d3AlphaMin", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(r) {
  return sp({}, r, HO.linkProp(r));
}))), Mre = Object.assign.apply(Object, Xg(["refresh", "getGraphBbox", "d3Force", "d3ReheatSimulation", "emitParticle"].map(function(r) {
  return sp({}, r, HO.linkMethod(r));
}))), cm = GO("renderObjs", VO), Are = Object.assign.apply(Object, Xg(["width", "height", "backgroundColor", "showNavInfo", "enablePointerInteraction"].map(function(r) {
  return sp({}, r, cm.linkProp(r));
}))), Cre = Object.assign.apply(Object, Xg(["lights", "cameraPosition", "postProcessingComposer"].map(function(r) {
  return sp({}, r, cm.linkMethod(r));
})).concat([{
  graph2ScreenCoords: cm.linkMethod("getScreenCoords"),
  screen2GraphCoords: cm.linkMethod("getSceneCoords")
}])), Rre = Il({
  props: If(If({
    nodeLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkHoverPrecision: {
      default: 1,
      onChange: function(r, e) {
        return e.renderObjs.lineHoverPrecision(r);
      },
      triggerUpdate: !1
    },
    enableNavigationControls: {
      default: !0,
      onChange: function(r, e) {
        var i = e.renderObjs.controls();
        i && (i.enabled = r, r && i.domElement && i.domElement.dispatchEvent(new PointerEvent("pointerup")));
      },
      triggerUpdate: !1
    },
    enableNodeDrag: {
      default: !0,
      triggerUpdate: !1
    },
    onNodeDrag: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeDragEnd: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeClick: {
      triggerUpdate: !1
    },
    onNodeRightClick: {
      triggerUpdate: !1
    },
    onNodeHover: {
      triggerUpdate: !1
    },
    onLinkClick: {
      triggerUpdate: !1
    },
    onLinkRightClick: {
      triggerUpdate: !1
    },
    onLinkHover: {
      triggerUpdate: !1
    },
    onBackgroundClick: {
      triggerUpdate: !1
    },
    onBackgroundRightClick: {
      triggerUpdate: !1
    }
  }, Ere), Are),
  methods: If(If({
    zoomToFit: function(r, e, i) {
      for (var n, s = arguments.length, a = new Array(s > 3 ? s - 3 : 0), o = 3; o < s; o++)
        a[o - 3] = arguments[o];
      return r.renderObjs.fitToBbox((n = r.forceGraph).getGraphBbox.apply(n, a), e, i), this;
    },
    pauseAnimation: function(r) {
      return r.animationFrameRequestId !== null && (cancelAnimationFrame(r.animationFrameRequestId), r.animationFrameRequestId = null), this;
    },
    resumeAnimation: function(r) {
      return r.animationFrameRequestId === null && this._animationCycle(), this;
    },
    _animationCycle: function(r) {
      r.enablePointerInteraction && (this.renderer().domElement.style.cursor = null), r.forceGraph.tickFrame(), r.renderObjs.tick(), r.animationFrameRequestId = requestAnimationFrame(this._animationCycle);
    },
    scene: function(r) {
      return r.renderObjs.scene();
    },
    // Expose scene
    camera: function(r) {
      return r.renderObjs.camera();
    },
    // Expose camera
    renderer: function(r) {
      return r.renderObjs.renderer();
    },
    // Expose renderer
    controls: function(r) {
      return r.renderObjs.controls();
    },
    // Expose controls
    tbControls: function(r) {
      return r.renderObjs.tbControls();
    },
    // To be deprecated
    _destructor: function() {
      this.pauseAnimation(), this.graphData({
        nodes: [],
        links: []
      });
    }
  }, Mre), Cre),
  stateInit: function(r) {
    var e = r.controlType, i = r.rendererConfig, n = r.extraRenderers, s = new ku();
    return {
      forceGraph: s,
      renderObjs: VO({
        controlType: e,
        rendererConfig: i,
        extraRenderers: n
      }).objects([s]).lights([new Sv.AmbientLight(13421772, Math.PI), new Sv.DirectionalLight(16777215, 0.6 * Math.PI)])
    };
  },
  init: function(r, e) {
    r.innerHTML = "", r.appendChild(e.container = document.createElement("div")), e.container.style.position = "relative";
    var i = document.createElement("div");
    e.container.appendChild(i), e.renderObjs(i);
    var n = e.renderObjs.camera(), s = e.renderObjs.renderer(), a = e.renderObjs.controls();
    a.enabled = !!e.enableNavigationControls, e.lastSetCameraZ = n.position.z;
    var o;
    e.container.appendChild(o = document.createElement("div")), o.className = "graph-info-msg", o.textContent = "", e.forceGraph.onLoading(function() {
      o.textContent = "Loading...";
    }).onFinishLoading(function() {
      o.textContent = "";
    }).onUpdate(function() {
      e.graphData = e.forceGraph.graphData(), n.position.x === 0 && n.position.y === 0 && n.position.z === e.lastSetCameraZ && e.graphData.nodes.length && (n.lookAt(e.forceGraph.position), e.lastSetCameraZ = n.position.z = Math.cbrt(e.graphData.nodes.length) * wre);
    }).onFinishUpdate(function() {
      if (e._dragControls) {
        var l = e.graphData.nodes.find(function(c) {
          return c.__initialFixedPos && !c.__disposeControlsAfterDrag;
        });
        l ? l.__disposeControlsAfterDrag = !0 : e._dragControls.dispose(), e._dragControls = void 0;
      }
      if (e.enableNodeDrag && e.enablePointerInteraction && e.forceEngine === "d3") {
        var u = e._dragControls = new S9(e.graphData.nodes.map(function(c) {
          return c.__threeObj;
        }).filter(function(c) {
          return c;
        }), n, s.domElement);
        u.addEventListener("dragstart", function(c) {
          var h = Vs(c.object);
          if (h) {
            a.enabled = !1, c.object.__initialPos = c.object.position.clone(), c.object.__prevPos = c.object.position.clone();
            var d = h.__data;
            !d.__initialFixedPos && (d.__initialFixedPos = {
              fx: d.fx,
              fy: d.fy,
              fz: d.fz
            }), !d.__initialPos && (d.__initialPos = {
              x: d.x,
              y: d.y,
              z: d.z
            }), ["x", "y", "z"].forEach(function(p) {
              return d["f".concat(p)] = d[p];
            }), s.domElement.classList.add("grabbable");
          }
        }), u.addEventListener("drag", function(c) {
          var h = Vs(c.object);
          if (h) {
            if (!c.object.hasOwnProperty("__graphObjType")) {
              var d = c.object.__initialPos, p = c.object.__prevPos, f = c.object.position;
              h.position.add(f.clone().sub(p)), p.copy(f), f.copy(d);
            }
            var m = h.__data, v = h.position, y = {
              x: v.x - m.x,
              y: v.y - m.y,
              z: v.z - m.z
            };
            ["x", "y", "z"].forEach(function(g) {
              return m["f".concat(g)] = m[g] = v[g];
            }), e.forceGraph.d3AlphaTarget(0.3).resetCountdown(), m.__dragged = !0, e.onNodeDrag(m, y);
          }
        }), u.addEventListener("dragend", function(c) {
          var h = Vs(c.object);
          if (h) {
            delete c.object.__initialPos, delete c.object.__prevPos;
            var d = h.__data;
            d.__disposeControlsAfterDrag && (u.dispose(), delete d.__disposeControlsAfterDrag);
            var p = d.__initialFixedPos, f = d.__initialPos, m = {
              x: f.x - d.x,
              y: f.y - d.y,
              z: f.z - d.z
            };
            p && (["x", "y", "z"].forEach(function(v) {
              var y = "f".concat(v);
              p[y] === void 0 && delete d[y];
            }), delete d.__initialFixedPos, delete d.__initialPos, d.__dragged && (delete d.__dragged, e.onNodeDragEnd(d, m))), e.forceGraph.d3AlphaTarget(0).resetCountdown(), e.enableNavigationControls && (a.enabled = !0, a.domElement && a.domElement.ownerDocument && a.domElement.ownerDocument.dispatchEvent(
              // simulate mouseup to ensure the controls don't take over after dragend
              new PointerEvent("pointerup", {
                pointerType: "touch"
              })
            )), s.domElement.classList.remove("grabbable");
          }
        });
      }
    }), Sv.REVISION < 155 && (e.renderObjs.renderer().useLegacyLights = !1), e.renderObjs.hoverOrderComparator(function(l, u) {
      var c = Vs(l);
      if (!c) return 1;
      var h = Vs(u);
      if (!h) return -1;
      var d = function(p) {
        return p.__graphObjType === "node";
      };
      return d(h) - d(c);
    }).tooltipContent(function(l) {
      var u = Vs(l);
      return u && et(e["".concat(u.__graphObjType, "Label")])(u.__data) || "";
    }).hoverDuringDrag(!1).onHover(function(l) {
      var u = Vs(l);
      if (u !== e.hoverObj) {
        var c = e.hoverObj ? e.hoverObj.__graphObjType : null, h = e.hoverObj ? e.hoverObj.__data : null, d = u ? u.__graphObjType : null, p = u ? u.__data : null;
        if (c && c !== d) {
          var f = e["on".concat(c === "node" ? "Node" : "Link", "Hover")];
          f && f(null, h);
        }
        if (d) {
          var m = e["on".concat(d === "node" ? "Node" : "Link", "Hover")];
          m && m(p, c === d ? h : null);
        }
        s.domElement.classList[u && e["on".concat(d === "node" ? "Node" : "Link", "Click")] || !u && e.onBackgroundClick ? "add" : "remove"]("clickable"), e.hoverObj = u;
      }
    }).clickAfterDrag(!1).onClick(function(l, u) {
      var c = Vs(l);
      if (c) {
        var h = e["on".concat(c.__graphObjType === "node" ? "Node" : "Link", "Click")];
        h && h(c.__data, u);
      } else
        e.onBackgroundClick && e.onBackgroundClick(u);
    }).onRightClick(function(l, u) {
      var c = Vs(l);
      if (c) {
        var h = e["on".concat(c.__graphObjType === "node" ? "Node" : "Link", "RightClick")];
        h && h(c.__data, u);
      } else
        e.onBackgroundRightClick && e.onBackgroundRightClick(u);
    }), this._animationCycle();
  }
});
function Vs(r) {
  for (var e = r; e && !e.hasOwnProperty("__graphObjType"); )
    e = e.parent;
  return e;
}
const Nre = { passive: !1 }, Pd = { capture: !0, passive: !1 };
function wv(r) {
  r.stopImmediatePropagation();
}
function ic(r) {
  r.preventDefault(), r.stopImmediatePropagation();
}
function WO(r) {
  var e = r.document.documentElement, i = Tn(r).on("dragstart.drag", ic, Pd);
  "onselectstart" in e ? i.on("selectstart.drag", ic, Pd) : (e.__noselect = e.style.MozUserSelect, e.style.MozUserSelect = "none");
}
function qO(r, e) {
  var i = r.document.documentElement, n = Tn(r).on("dragstart.drag", null);
  e && (n.on("click.drag", ic, Pd), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in i ? n.on("selectstart.drag", null) : (i.style.MozUserSelect = i.__noselect, delete i.__noselect);
}
const Df = (r) => () => r;
function Xx(r, {
  sourceEvent: e,
  subject: i,
  target: n,
  identifier: s,
  active: a,
  x: o,
  y: l,
  dx: u,
  dy: c,
  dispatch: h
}) {
  Object.defineProperties(this, {
    type: { value: r, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    subject: { value: i, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    identifier: { value: s, enumerable: !0, configurable: !0 },
    active: { value: a, enumerable: !0, configurable: !0 },
    x: { value: o, enumerable: !0, configurable: !0 },
    y: { value: l, enumerable: !0, configurable: !0 },
    dx: { value: u, enumerable: !0, configurable: !0 },
    dy: { value: c, enumerable: !0, configurable: !0 },
    _: { value: h }
  });
}
Xx.prototype.on = function() {
  var r = this._.on.apply(this._, arguments);
  return r === this._ ? this : r;
};
function Pre(r) {
  return !r.ctrlKey && !r.button;
}
function Ore() {
  return this.parentNode;
}
function Ire(r, e) {
  return e ?? { x: r.x, y: r.y };
}
function Dre() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function kre() {
  var r = Pre, e = Ore, i = Ire, n = Dre, s = {}, a = Hd("start", "drag", "end"), o = 0, l, u, c, h, d = 0;
  function p(b) {
    b.on("mousedown.drag", f).filter(n).on("touchstart.drag", y).on("touchmove.drag", g, Nre).on("touchend.drag touchcancel.drag", _).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function f(b, T) {
    if (!(h || !r.call(this, b, T))) {
      var S = x(this, e.call(this, b, T), b, T, "mouse");
      S && (Tn(b.view).on("mousemove.drag", m, Pd).on("mouseup.drag", v, Pd), WO(b.view), wv(b), c = !1, l = b.clientX, u = b.clientY, S("start", b));
    }
  }
  function m(b) {
    if (ic(b), !c) {
      var T = b.clientX - l, S = b.clientY - u;
      c = T * T + S * S > d;
    }
    s.mouse("drag", b);
  }
  function v(b) {
    Tn(b.view).on("mousemove.drag mouseup.drag", null), qO(b.view, c), ic(b), s.mouse("end", b);
  }
  function y(b, T) {
    if (r.call(this, b, T)) {
      var S = b.changedTouches, w = e.call(this, b, T), C = S.length, E, A;
      for (E = 0; E < C; ++E)
        (A = x(this, w, b, T, S[E].identifier, S[E])) && (wv(b), A("start", b, S[E]));
    }
  }
  function g(b) {
    var T = b.changedTouches, S = T.length, w, C;
    for (w = 0; w < S; ++w)
      (C = s[T[w].identifier]) && (ic(b), C("drag", b, T[w]));
  }
  function _(b) {
    var T = b.changedTouches, S = T.length, w, C;
    for (h && clearTimeout(h), h = setTimeout(function() {
      h = null;
    }, 500), w = 0; w < S; ++w)
      (C = s[T[w].identifier]) && (wv(b), C("end", b, T[w]));
  }
  function x(b, T, S, w, C, E) {
    var A = a.copy(), N = cs(E || S, T), L, F, M;
    if ((M = i.call(b, new Xx("beforestart", {
      sourceEvent: S,
      target: p,
      identifier: C,
      active: o,
      x: N[0],
      y: N[1],
      dx: 0,
      dy: 0,
      dispatch: A
    }), w)) != null)
      return L = M.x - N[0] || 0, F = M.y - N[1] || 0, function P(O, V, B) {
        var H = N, U;
        switch (O) {
          case "start":
            s[C] = P, U = o++;
            break;
          case "end":
            delete s[C], --o;
          case "drag":
            N = cs(B || V, T), U = o;
            break;
        }
        A.call(
          O,
          b,
          new Xx(O, {
            sourceEvent: V,
            subject: M,
            target: p,
            identifier: C,
            active: U,
            x: N[0] + L,
            y: N[1] + F,
            dx: N[0] - H[0],
            dy: N[1] - H[1],
            dispatch: A
          }),
          w
        );
      };
  }
  return p.filter = function(b) {
    return arguments.length ? (r = typeof b == "function" ? b : Df(!!b), p) : r;
  }, p.container = function(b) {
    return arguments.length ? (e = typeof b == "function" ? b : Df(b), p) : e;
  }, p.subject = function(b) {
    return arguments.length ? (i = typeof b == "function" ? b : Df(b), p) : i;
  }, p.touchable = function(b) {
    return arguments.length ? (n = typeof b == "function" ? b : Df(!!b), p) : n;
  }, p.on = function() {
    var b = a.on.apply(a, arguments);
    return b === a ? p : b;
  }, p.clickDistance = function(b) {
    return arguments.length ? (d = (b = +b) * b, p) : Math.sqrt(d);
  }, p;
}
var Lre = Hd("start", "end", "cancel", "interrupt"), Ure = [], XO = 0, RA = 1, Yx = 2, hm = 3, NA = 4, $x = 5, dm = 6;
function Yg(r, e, i, n, s, a) {
  var o = r.__transition;
  if (!o) r.__transition = {};
  else if (i in o) return;
  Fre(r, i, {
    name: e,
    index: n,
    // For context during callback.
    group: s,
    // For context during callback.
    on: Lre,
    tween: Ure,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: XO
  });
}
function rS(r, e) {
  var i = ss(r, e);
  if (i.state > XO) throw new Error("too late; already scheduled");
  return i;
}
function Cs(r, e) {
  var i = ss(r, e);
  if (i.state > hm) throw new Error("too late; already running");
  return i;
}
function ss(r, e) {
  var i = r.__transition;
  if (!i || !(i = i[e])) throw new Error("transition not found");
  return i;
}
function Fre(r, e, i) {
  var n = r.__transition, s;
  n[e] = i, i.timer = q_(a, 0, i.time);
  function a(c) {
    i.state = RA, i.timer.restart(o, i.delay, i.time), i.delay <= c && o(c - i.delay);
  }
  function o(c) {
    var h, d, p, f;
    if (i.state !== RA) return u();
    for (h in n)
      if (f = n[h], f.name === i.name) {
        if (f.state === hm) return Dw(o);
        f.state === NA ? (f.state = dm, f.timer.stop(), f.on.call("interrupt", r, r.__data__, f.index, f.group), delete n[h]) : +h < e && (f.state = dm, f.timer.stop(), f.on.call("cancel", r, r.__data__, f.index, f.group), delete n[h]);
      }
    if (Dw(function() {
      i.state === hm && (i.state = NA, i.timer.restart(l, i.delay, i.time), l(c));
    }), i.state = Yx, i.on.call("start", r, r.__data__, i.index, i.group), i.state === Yx) {
      for (i.state = hm, s = new Array(p = i.tween.length), h = 0, d = -1; h < p; ++h)
        (f = i.tween[h].value.call(r, r.__data__, i.index, i.group)) && (s[++d] = f);
      s.length = d + 1;
    }
  }
  function l(c) {
    for (var h = c < i.duration ? i.ease.call(null, c / i.duration) : (i.timer.restart(u), i.state = $x, 1), d = -1, p = s.length; ++d < p; )
      s[d].call(r, h);
    i.state === $x && (i.on.call("end", r, r.__data__, i.index, i.group), u());
  }
  function u() {
    i.state = dm, i.timer.stop(), delete n[e];
    for (var c in n) return;
    delete r.__transition;
  }
}
function pm(r, e) {
  var i = r.__transition, n, s, a = !0, o;
  if (i) {
    e = e == null ? null : e + "";
    for (o in i) {
      if ((n = i[o]).name !== e) {
        a = !1;
        continue;
      }
      s = n.state > Yx && n.state < $x, n.state = dm, n.timer.stop(), n.on.call(s ? "interrupt" : "cancel", r, r.__data__, n.index, n.group), delete i[o];
    }
    a && delete r.__transition;
  }
}
function Bre(r) {
  return this.each(function() {
    pm(this, r);
  });
}
function zre(r, e) {
  var i, n;
  return function() {
    var s = Cs(this, r), a = s.tween;
    if (a !== i) {
      n = i = a;
      for (var o = 0, l = n.length; o < l; ++o)
        if (n[o].name === e) {
          n = n.slice(), n.splice(o, 1);
          break;
        }
    }
    s.tween = n;
  };
}
function jre(r, e, i) {
  var n, s;
  if (typeof i != "function") throw new Error();
  return function() {
    var a = Cs(this, r), o = a.tween;
    if (o !== n) {
      s = (n = o).slice();
      for (var l = { name: e, value: i }, u = 0, c = s.length; u < c; ++u)
        if (s[u].name === e) {
          s[u] = l;
          break;
        }
      u === c && s.push(l);
    }
    a.tween = s;
  };
}
function Vre(r, e) {
  var i = this._id;
  if (r += "", arguments.length < 2) {
    for (var n = ss(this.node(), i).tween, s = 0, a = n.length, o; s < a; ++s)
      if ((o = n[s]).name === r)
        return o.value;
    return null;
  }
  return this.each((e == null ? zre : jre)(i, r, e));
}
function nS(r, e, i) {
  var n = r._id;
  return r.each(function() {
    var s = Cs(this, n);
    (s.value || (s.value = {}))[e] = i.apply(this, arguments);
  }), function(s) {
    return ss(s, n).value[e];
  };
}
function YO(r, e) {
  var i;
  return (typeof e == "number" ? Za : e instanceof gd ? sE : (i = gd(e)) ? (e = i, sE) : mH)(r, e);
}
function Gre(r) {
  return function() {
    this.removeAttribute(r);
  };
}
function Hre(r) {
  return function() {
    this.removeAttributeNS(r.space, r.local);
  };
}
function Wre(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = this.getAttribute(r);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function qre(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = this.getAttributeNS(r.space, r.local);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function Xre(r, e, i) {
  var n, s, a;
  return function() {
    var o, l = i(this), u;
    return l == null ? void this.removeAttribute(r) : (o = this.getAttribute(r), u = l + "", o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l)));
  };
}
function Yre(r, e, i) {
  var n, s, a;
  return function() {
    var o, l = i(this), u;
    return l == null ? void this.removeAttributeNS(r.space, r.local) : (o = this.getAttributeNS(r.space, r.local), u = l + "", o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l)));
  };
}
function $re(r, e) {
  var i = Hg(r), n = i === "transform" ? bH : YO;
  return this.attrTween(r, typeof e == "function" ? (i.local ? Yre : Xre)(i, n, nS(this, "attr." + r, e)) : e == null ? (i.local ? Hre : Gre)(i) : (i.local ? qre : Wre)(i, n, e));
}
function Kre(r, e) {
  return function(i) {
    this.setAttribute(r, e.call(this, i));
  };
}
function Qre(r, e) {
  return function(i) {
    this.setAttributeNS(r.space, r.local, e.call(this, i));
  };
}
function Zre(r, e) {
  var i, n;
  function s() {
    var a = e.apply(this, arguments);
    return a !== n && (i = (n = a) && Qre(r, a)), i;
  }
  return s._value = e, s;
}
function Jre(r, e) {
  var i, n;
  function s() {
    var a = e.apply(this, arguments);
    return a !== n && (i = (n = a) && Kre(r, a)), i;
  }
  return s._value = e, s;
}
function ene(r, e) {
  var i = "attr." + r;
  if (arguments.length < 2) return (i = this.tween(i)) && i._value;
  if (e == null) return this.tween(i, null);
  if (typeof e != "function") throw new Error();
  var n = Hg(r);
  return this.tween(i, (n.local ? Zre : Jre)(n, e));
}
function tne(r, e) {
  return function() {
    rS(this, r).delay = +e.apply(this, arguments);
  };
}
function ine(r, e) {
  return e = +e, function() {
    rS(this, r).delay = e;
  };
}
function rne(r) {
  var e = this._id;
  return arguments.length ? this.each((typeof r == "function" ? tne : ine)(e, r)) : ss(this.node(), e).delay;
}
function nne(r, e) {
  return function() {
    Cs(this, r).duration = +e.apply(this, arguments);
  };
}
function sne(r, e) {
  return e = +e, function() {
    Cs(this, r).duration = e;
  };
}
function ane(r) {
  var e = this._id;
  return arguments.length ? this.each((typeof r == "function" ? nne : sne)(e, r)) : ss(this.node(), e).duration;
}
function one(r, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    Cs(this, r).ease = e;
  };
}
function lne(r) {
  var e = this._id;
  return arguments.length ? this.each(one(e, r)) : ss(this.node(), e).ease;
}
function une(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    if (typeof i != "function") throw new Error();
    Cs(this, r).ease = i;
  };
}
function cne(r) {
  if (typeof r != "function") throw new Error();
  return this.each(une(this._id, r));
}
function hne(r) {
  typeof r != "function" && (r = yO(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = [], u, c = 0; c < o; ++c)
      (u = a[c]) && r.call(u, u.__data__, c, a) && l.push(u);
  return new Ea(n, this._parents, this._name, this._id);
}
function dne(r) {
  if (r._id !== this._id) throw new Error();
  for (var e = this._groups, i = r._groups, n = e.length, s = i.length, a = Math.min(n, s), o = new Array(n), l = 0; l < a; ++l)
    for (var u = e[l], c = i[l], h = u.length, d = o[l] = new Array(h), p, f = 0; f < h; ++f)
      (p = u[f] || c[f]) && (d[f] = p);
  for (; l < n; ++l)
    o[l] = e[l];
  return new Ea(o, this._parents, this._name, this._id);
}
function pne(r) {
  return (r + "").trim().split(/^|\s+/).every(function(e) {
    var i = e.indexOf(".");
    return i >= 0 && (e = e.slice(0, i)), !e || e === "start";
  });
}
function fne(r, e, i) {
  var n, s, a = pne(e) ? rS : Cs;
  return function() {
    var o = a(this, r), l = o.on;
    l !== n && (s = (n = l).copy()).on(e, i), o.on = s;
  };
}
function mne(r, e) {
  var i = this._id;
  return arguments.length < 2 ? ss(this.node(), i).on.on(r) : this.each(fne(i, r, e));
}
function gne(r) {
  return function() {
    var e = this.parentNode;
    for (var i in this.__transition) if (+i !== r) return;
    e && e.removeChild(this);
  };
}
function yne() {
  return this.on("end.remove", gne(this._id));
}
function vne(r) {
  var e = this._name, i = this._id;
  typeof r != "function" && (r = QT(r));
  for (var n = this._groups, s = n.length, a = new Array(s), o = 0; o < s; ++o)
    for (var l = n[o], u = l.length, c = a[o] = new Array(u), h, d, p = 0; p < u; ++p)
      (h = l[p]) && (d = r.call(h, h.__data__, p, l)) && ("__data__" in h && (d.__data__ = h.__data__), c[p] = d, Yg(c[p], e, i, p, c, ss(h, i)));
  return new Ea(a, this._parents, e, i);
}
function bne(r) {
  var e = this._name, i = this._id;
  typeof r != "function" && (r = gO(r));
  for (var n = this._groups, s = n.length, a = [], o = [], l = 0; l < s; ++l)
    for (var u = n[l], c = u.length, h, d = 0; d < c; ++d)
      if (h = u[d]) {
        for (var p = r.call(h, h.__data__, d, u), f, m = ss(h, i), v = 0, y = p.length; v < y; ++v)
          (f = p[v]) && Yg(f, e, i, v, p, m);
        a.push(p), o.push(h);
      }
  return new Ea(a, o, e, i);
}
var xne = rp.prototype.constructor;
function _ne() {
  return new xne(this._groups, this._parents);
}
function Tne(r, e) {
  var i, n, s;
  return function() {
    var a = Rc(this, r), o = (this.style.removeProperty(r), Rc(this, r));
    return a === o ? null : a === i && o === n ? s : s = e(i = a, n = o);
  };
}
function $O(r) {
  return function() {
    this.style.removeProperty(r);
  };
}
function Sne(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = Rc(this, r);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function wne(r, e, i) {
  var n, s, a;
  return function() {
    var o = Rc(this, r), l = i(this), u = l + "";
    return l == null && (u = l = (this.style.removeProperty(r), Rc(this, r))), o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l));
  };
}
function Ene(r, e) {
  var i, n, s, a = "style." + e, o = "end." + a, l;
  return function() {
    var u = Cs(this, r), c = u.on, h = u.value[a] == null ? l || (l = $O(e)) : void 0;
    (c !== i || s !== h) && (n = (i = c).copy()).on(o, s = h), u.on = n;
  };
}
function Mne(r, e, i) {
  var n = (r += "") == "transform" ? vH : YO;
  return e == null ? this.styleTween(r, Tne(r, n)).on("end.style." + r, $O(r)) : typeof e == "function" ? this.styleTween(r, wne(r, n, nS(this, "style." + r, e))).each(Ene(this._id, r)) : this.styleTween(r, Sne(r, n, e), i).on("end.style." + r, null);
}
function Ane(r, e, i) {
  return function(n) {
    this.style.setProperty(r, e.call(this, n), i);
  };
}
function Cne(r, e, i) {
  var n, s;
  function a() {
    var o = e.apply(this, arguments);
    return o !== s && (n = (s = o) && Ane(r, o, i)), n;
  }
  return a._value = e, a;
}
function Rne(r, e, i) {
  var n = "style." + (r += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  return this.tween(n, Cne(r, e, i ?? ""));
}
function Nne(r) {
  return function() {
    this.textContent = r;
  };
}
function Pne(r) {
  return function() {
    var e = r(this);
    this.textContent = e ?? "";
  };
}
function One(r) {
  return this.tween("text", typeof r == "function" ? Pne(nS(this, "text", r)) : Nne(r == null ? "" : r + ""));
}
function Ine(r) {
  return function(e) {
    this.textContent = r.call(this, e);
  };
}
function Dne(r) {
  var e, i;
  function n() {
    var s = r.apply(this, arguments);
    return s !== i && (e = (i = s) && Ine(s)), e;
  }
  return n._value = r, n;
}
function kne(r) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (r == null) return this.tween(e, null);
  if (typeof r != "function") throw new Error();
  return this.tween(e, Dne(r));
}
function Lne() {
  for (var r = this._name, e = this._id, i = KO(), n = this._groups, s = n.length, a = 0; a < s; ++a)
    for (var o = n[a], l = o.length, u, c = 0; c < l; ++c)
      if (u = o[c]) {
        var h = ss(u, e);
        Yg(u, r, i, c, o, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new Ea(n, this._parents, r, i);
}
function Une() {
  var r, e, i = this, n = i._id, s = i.size();
  return new Promise(function(a, o) {
    var l = { value: o }, u = { value: function() {
      --s === 0 && a();
    } };
    i.each(function() {
      var c = Cs(this, n), h = c.on;
      h !== r && (e = (r = h).copy(), e._.cancel.push(l), e._.interrupt.push(l), e._.end.push(u)), c.on = e;
    }), s === 0 && a();
  });
}
var Fne = 0;
function Ea(r, e, i, n) {
  this._groups = r, this._parents = e, this._name = i, this._id = n;
}
function KO() {
  return ++Fne;
}
var Gs = rp.prototype;
Ea.prototype = {
  constructor: Ea,
  select: vne,
  selectAll: bne,
  selectChild: Gs.selectChild,
  selectChildren: Gs.selectChildren,
  filter: hne,
  merge: dne,
  selection: _ne,
  transition: Lne,
  call: Gs.call,
  nodes: Gs.nodes,
  node: Gs.node,
  size: Gs.size,
  empty: Gs.empty,
  each: Gs.each,
  on: mne,
  attr: $re,
  attrTween: ene,
  style: Mne,
  styleTween: Rne,
  text: One,
  textTween: kne,
  remove: yne,
  tween: Vre,
  delay: rne,
  duration: ane,
  ease: lne,
  easeVarying: cne,
  end: Une,
  [Symbol.iterator]: Gs[Symbol.iterator]
};
function Bne(r) {
  return ((r *= 2) <= 1 ? r * r * r : (r -= 2) * r * r + 2) / 2;
}
var zne = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Bne
};
function jne(r, e) {
  for (var i; !(i = r.__transition) || !(i = i[e]); )
    if (!(r = r.parentNode))
      throw new Error(`transition ${e} not found`);
  return i;
}
function Vne(r) {
  var e, i;
  r instanceof Ea ? (e = r._id, r = r._name) : (e = KO(), (i = zne).time = W_(), r = r == null ? null : r + "");
  for (var n = this._groups, s = n.length, a = 0; a < s; ++a)
    for (var o = n[a], l = o.length, u, c = 0; c < l; ++c)
      (u = o[c]) && Yg(u, r, e, c, o, i || jne(u, e));
  return new Ea(n, this._parents, r, e);
}
rp.prototype.interrupt = Bre;
rp.prototype.transition = Vne;
const kf = (r) => () => r;
function Gne(r, {
  sourceEvent: e,
  target: i,
  transform: n,
  dispatch: s
}) {
  Object.defineProperties(this, {
    type: { value: r, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    target: { value: i, enumerable: !0, configurable: !0 },
    transform: { value: n, enumerable: !0, configurable: !0 },
    _: { value: s }
  });
}
function ua(r, e, i) {
  this.k = r, this.x = e, this.y = i;
}
ua.prototype = {
  constructor: ua,
  scale: function(r) {
    return r === 1 ? this : new ua(this.k * r, this.x, this.y);
  },
  translate: function(r, e) {
    return r === 0 & e === 0 ? this : new ua(this.k, this.x + this.k * r, this.y + this.k * e);
  },
  apply: function(r) {
    return [r[0] * this.k + this.x, r[1] * this.k + this.y];
  },
  applyX: function(r) {
    return r * this.k + this.x;
  },
  applyY: function(r) {
    return r * this.k + this.y;
  },
  invert: function(r) {
    return [(r[0] - this.x) / this.k, (r[1] - this.y) / this.k];
  },
  invertX: function(r) {
    return (r - this.x) / this.k;
  },
  invertY: function(r) {
    return (r - this.y) / this.k;
  },
  rescaleX: function(r) {
    return r.copy().domain(r.range().map(this.invertX, this).map(r.invert, r));
  },
  rescaleY: function(r) {
    return r.copy().domain(r.range().map(this.invertY, this).map(r.invert, r));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var sS = new ua(1, 0, 0);
us.prototype = ua.prototype;
function us(r) {
  for (; !r.__zoom; ) if (!(r = r.parentNode)) return sS;
  return r.__zoom;
}
function Ev(r) {
  r.stopImmediatePropagation();
}
function Rh(r) {
  r.preventDefault(), r.stopImmediatePropagation();
}
function Hne(r) {
  return (!r.ctrlKey || r.type === "wheel") && !r.button;
}
function Wne() {
  var r = this;
  return r instanceof SVGElement ? (r = r.ownerSVGElement || r, r.hasAttribute("viewBox") ? (r = r.viewBox.baseVal, [[r.x, r.y], [r.x + r.width, r.y + r.height]]) : [[0, 0], [r.width.baseVal.value, r.height.baseVal.value]]) : [[0, 0], [r.clientWidth, r.clientHeight]];
}
function PA() {
  return this.__zoom || sS;
}
function qne(r) {
  return -r.deltaY * (r.deltaMode === 1 ? 0.05 : r.deltaMode ? 1 : 2e-3) * (r.ctrlKey ? 10 : 1);
}
function Xne() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Yne(r, e, i) {
  var n = r.invertX(e[0][0]) - i[0][0], s = r.invertX(e[1][0]) - i[1][0], a = r.invertY(e[0][1]) - i[0][1], o = r.invertY(e[1][1]) - i[1][1];
  return r.translate(
    s > n ? (n + s) / 2 : Math.min(0, n) || Math.max(0, s),
    o > a ? (a + o) / 2 : Math.min(0, a) || Math.max(0, o)
  );
}
function $ne() {
  var r = Hne, e = Wne, i = Yne, n = qne, s = Xne, a = [0, 1 / 0], o = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], l = 250, u = SH, c = Hd("start", "zoom", "end"), h, d, p, f = 500, m = 150, v = 0, y = 10;
  function g(M) {
    M.property("__zoom", PA).on("wheel.zoom", C, { passive: !1 }).on("mousedown.zoom", E).on("dblclick.zoom", A).filter(s).on("touchstart.zoom", N).on("touchmove.zoom", L).on("touchend.zoom touchcancel.zoom", F).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  g.transform = function(M, P, O, V) {
    var B = M.selection ? M.selection() : M;
    B.property("__zoom", PA), M !== B ? T(M, P, O, V) : B.interrupt().each(function() {
      S(this, arguments).event(V).start().zoom(null, typeof P == "function" ? P.apply(this, arguments) : P).end();
    });
  }, g.scaleBy = function(M, P, O, V) {
    g.scaleTo(M, function() {
      var B = this.__zoom.k, H = typeof P == "function" ? P.apply(this, arguments) : P;
      return B * H;
    }, O, V);
  }, g.scaleTo = function(M, P, O, V) {
    g.transform(M, function() {
      var B = e.apply(this, arguments), H = this.__zoom, U = O == null ? b(B) : typeof O == "function" ? O.apply(this, arguments) : O, j = H.invert(U), Q = typeof P == "function" ? P.apply(this, arguments) : P;
      return i(x(_(H, Q), U, j), B, o);
    }, O, V);
  }, g.translateBy = function(M, P, O, V) {
    g.transform(M, function() {
      return i(this.__zoom.translate(
        typeof P == "function" ? P.apply(this, arguments) : P,
        typeof O == "function" ? O.apply(this, arguments) : O
      ), e.apply(this, arguments), o);
    }, null, V);
  }, g.translateTo = function(M, P, O, V, B) {
    g.transform(M, function() {
      var H = e.apply(this, arguments), U = this.__zoom, j = V == null ? b(H) : typeof V == "function" ? V.apply(this, arguments) : V;
      return i(sS.translate(j[0], j[1]).scale(U.k).translate(
        typeof P == "function" ? -P.apply(this, arguments) : -P,
        typeof O == "function" ? -O.apply(this, arguments) : -O
      ), H, o);
    }, V, B);
  };
  function _(M, P) {
    return P = Math.max(a[0], Math.min(a[1], P)), P === M.k ? M : new ua(P, M.x, M.y);
  }
  function x(M, P, O) {
    var V = P[0] - O[0] * M.k, B = P[1] - O[1] * M.k;
    return V === M.x && B === M.y ? M : new ua(M.k, V, B);
  }
  function b(M) {
    return [(+M[0][0] + +M[1][0]) / 2, (+M[0][1] + +M[1][1]) / 2];
  }
  function T(M, P, O, V) {
    M.on("start.zoom", function() {
      S(this, arguments).event(V).start();
    }).on("interrupt.zoom end.zoom", function() {
      S(this, arguments).event(V).end();
    }).tween("zoom", function() {
      var B = this, H = arguments, U = S(B, H).event(V), j = e.apply(B, H), Q = O == null ? b(j) : typeof O == "function" ? O.apply(B, H) : O, q = Math.max(j[1][0] - j[0][0], j[1][1] - j[0][1]), G = B.__zoom, Y = typeof P == "function" ? P.apply(B, H) : P, ae = u(G.invert(Q).concat(q / G.k), Y.invert(Q).concat(q / Y.k));
      return function(ue) {
        if (ue === 1) ue = Y;
        else {
          var ge = ae(ue), we = q / ge[2];
          ue = new ua(we, Q[0] - ge[0] * we, Q[1] - ge[1] * we);
        }
        U.zoom(null, ue);
      };
    });
  }
  function S(M, P, O) {
    return !O && M.__zooming || new w(M, P);
  }
  function w(M, P) {
    this.that = M, this.args = P, this.active = 0, this.sourceEvent = null, this.extent = e.apply(M, P), this.taps = 0;
  }
  w.prototype = {
    event: function(M) {
      return M && (this.sourceEvent = M), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(M, P) {
      return this.mouse && M !== "mouse" && (this.mouse[1] = P.invert(this.mouse[0])), this.touch0 && M !== "touch" && (this.touch0[1] = P.invert(this.touch0[0])), this.touch1 && M !== "touch" && (this.touch1[1] = P.invert(this.touch1[0])), this.that.__zoom = P, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(M) {
      var P = Tn(this.that).datum();
      c.call(
        M,
        this.that,
        new Gne(M, {
          sourceEvent: this.sourceEvent,
          target: g,
          transform: this.that.__zoom,
          dispatch: c
        }),
        P
      );
    }
  };
  function C(M, ...P) {
    if (!r.apply(this, arguments)) return;
    var O = S(this, P).event(M), V = this.__zoom, B = Math.max(a[0], Math.min(a[1], V.k * Math.pow(2, n.apply(this, arguments)))), H = cs(M);
    if (O.wheel)
      (O.mouse[0][0] !== H[0] || O.mouse[0][1] !== H[1]) && (O.mouse[1] = V.invert(O.mouse[0] = H)), clearTimeout(O.wheel);
    else {
      if (V.k === B) return;
      O.mouse = [H, V.invert(H)], pm(this), O.start();
    }
    Rh(M), O.wheel = setTimeout(U, m), O.zoom("mouse", i(x(_(V, B), O.mouse[0], O.mouse[1]), O.extent, o));
    function U() {
      O.wheel = null, O.end();
    }
  }
  function E(M, ...P) {
    if (p || !r.apply(this, arguments)) return;
    var O = M.currentTarget, V = S(this, P, !0).event(M), B = Tn(M.view).on("mousemove.zoom", Q, !0).on("mouseup.zoom", q, !0), H = cs(M, O), U = M.clientX, j = M.clientY;
    WO(M.view), Ev(M), V.mouse = [H, this.__zoom.invert(H)], pm(this), V.start();
    function Q(G) {
      if (Rh(G), !V.moved) {
        var Y = G.clientX - U, ae = G.clientY - j;
        V.moved = Y * Y + ae * ae > v;
      }
      V.event(G).zoom("mouse", i(x(V.that.__zoom, V.mouse[0] = cs(G, O), V.mouse[1]), V.extent, o));
    }
    function q(G) {
      B.on("mousemove.zoom mouseup.zoom", null), qO(G.view, V.moved), Rh(G), V.event(G).end();
    }
  }
  function A(M, ...P) {
    if (r.apply(this, arguments)) {
      var O = this.__zoom, V = cs(M.changedTouches ? M.changedTouches[0] : M, this), B = O.invert(V), H = O.k * (M.shiftKey ? 0.5 : 2), U = i(x(_(O, H), V, B), e.apply(this, P), o);
      Rh(M), l > 0 ? Tn(this).transition().duration(l).call(T, U, V, M) : Tn(this).call(g.transform, U, V, M);
    }
  }
  function N(M, ...P) {
    if (r.apply(this, arguments)) {
      var O = M.touches, V = O.length, B = S(this, P, M.changedTouches.length === V).event(M), H, U, j, Q;
      for (Ev(M), U = 0; U < V; ++U)
        j = O[U], Q = cs(j, this), Q = [Q, this.__zoom.invert(Q), j.identifier], B.touch0 ? !B.touch1 && B.touch0[2] !== Q[2] && (B.touch1 = Q, B.taps = 0) : (B.touch0 = Q, H = !0, B.taps = 1 + !!h);
      h && (h = clearTimeout(h)), H && (B.taps < 2 && (d = Q[0], h = setTimeout(function() {
        h = null;
      }, f)), pm(this), B.start());
    }
  }
  function L(M, ...P) {
    if (this.__zooming) {
      var O = S(this, P).event(M), V = M.changedTouches, B = V.length, H, U, j, Q;
      for (Rh(M), H = 0; H < B; ++H)
        U = V[H], j = cs(U, this), O.touch0 && O.touch0[2] === U.identifier ? O.touch0[0] = j : O.touch1 && O.touch1[2] === U.identifier && (O.touch1[0] = j);
      if (U = O.that.__zoom, O.touch1) {
        var q = O.touch0[0], G = O.touch0[1], Y = O.touch1[0], ae = O.touch1[1], ue = (ue = Y[0] - q[0]) * ue + (ue = Y[1] - q[1]) * ue, ge = (ge = ae[0] - G[0]) * ge + (ge = ae[1] - G[1]) * ge;
        U = _(U, Math.sqrt(ue / ge)), j = [(q[0] + Y[0]) / 2, (q[1] + Y[1]) / 2], Q = [(G[0] + ae[0]) / 2, (G[1] + ae[1]) / 2];
      } else if (O.touch0) j = O.touch0[0], Q = O.touch0[1];
      else return;
      O.zoom("touch", i(x(U, j, Q), O.extent, o));
    }
  }
  function F(M, ...P) {
    if (this.__zooming) {
      var O = S(this, P).event(M), V = M.changedTouches, B = V.length, H, U;
      for (Ev(M), p && clearTimeout(p), p = setTimeout(function() {
        p = null;
      }, f), H = 0; H < B; ++H)
        U = V[H], O.touch0 && O.touch0[2] === U.identifier ? delete O.touch0 : O.touch1 && O.touch1[2] === U.identifier && delete O.touch1;
      if (O.touch1 && !O.touch0 && (O.touch0 = O.touch1, delete O.touch1), O.touch0) O.touch0[1] = this.__zoom.invert(O.touch0[0]);
      else if (O.end(), O.taps === 2 && (U = cs(U, this), Math.hypot(d[0] - U[0], d[1] - U[1]) < y)) {
        var j = Tn(this).on("dblclick.zoom");
        j && j.apply(this, arguments);
      }
    }
  }
  return g.wheelDelta = function(M) {
    return arguments.length ? (n = typeof M == "function" ? M : kf(+M), g) : n;
  }, g.filter = function(M) {
    return arguments.length ? (r = typeof M == "function" ? M : kf(!!M), g) : r;
  }, g.touchable = function(M) {
    return arguments.length ? (s = typeof M == "function" ? M : kf(!!M), g) : s;
  }, g.extent = function(M) {
    return arguments.length ? (e = typeof M == "function" ? M : kf([[+M[0][0], +M[0][1]], [+M[1][0], +M[1][1]]]), g) : e;
  }, g.scaleExtent = function(M) {
    return arguments.length ? (a[0] = +M[0], a[1] = +M[1], g) : [a[0], a[1]];
  }, g.translateExtent = function(M) {
    return arguments.length ? (o[0][0] = +M[0][0], o[1][0] = +M[1][0], o[0][1] = +M[0][1], o[1][1] = +M[1][1], g) : [[o[0][0], o[0][1]], [o[1][0], o[1][1]]];
  }, g.constrain = function(M) {
    return arguments.length ? (i = M, g) : i;
  }, g.duration = function(M) {
    return arguments.length ? (l = +M, g) : l;
  }, g.interpolate = function(M) {
    return arguments.length ? (u = M, g) : u;
  }, g.on = function() {
    var M = c.on.apply(c, arguments);
    return M === c ? g : M;
  }, g.clickDistance = function(M) {
    return arguments.length ? (v = (M = +M) * M, g) : Math.sqrt(v);
  }, g.tapDistance = function(M) {
    return arguments.length ? (y = +M, g) : y;
  }, g;
}
var Kne = "Expected a function";
function Qne(r, e, i) {
  var n = !0, s = !0;
  if (typeof r != "function")
    throw new TypeError(Kne);
  return Sm(i) && (n = "leading" in i ? !!i.leading : n, s = "trailing" in i ? !!i.trailing : s), nN(r, e, {
    leading: n,
    maxWait: e,
    trailing: s
  });
}
function Kx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Zne(r) {
  if (Array.isArray(r)) return Kx(r);
}
function QO(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function Jne(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function ese(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function yn(r, e) {
  return r.get(QO(r, e));
}
function OA(r, e, i) {
  Jne(r, e), e.set(r, i);
}
function IA(r, e, i) {
  return r.set(QO(r, e), i), i;
}
function tse(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, ose(n.key), n);
  }
}
function ise(r, e, i) {
  return e && tse(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function rse(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function nse() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function sse(r) {
  return Zne(r) || rse(r) || lse(r) || nse();
}
function ase(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function ose(r) {
  var e = ase(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function lse(r, e) {
  if (r) {
    if (typeof r == "string") return Kx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Kx(r, e) : void 0;
  }
}
var use = 123, cse = function(r) {
  return "#".concat(Math.min(r, Math.pow(2, 24)).toString(16).padStart(6, "0"));
}, ZO = function(r, e, i) {
  return (r << 16) + (e << 8) + i;
}, hse = function(r) {
  var e = rt(r).toRgb(), i = e.r, n = e.g, s = e.b;
  return ZO(i, n, s);
}, DA = function(r, e) {
  return r * use % Math.pow(2, e);
}, Go = /* @__PURE__ */ new WeakMap(), Hs = /* @__PURE__ */ new WeakMap(), dse = /* @__PURE__ */ function() {
  function r() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6;
    ese(this, r), OA(this, Go, void 0), OA(this, Hs, void 0), IA(Hs, this, e), this.reset();
  }
  return ise(r, [{
    key: "reset",
    value: function() {
      IA(Go, this, ["__reserved for background__"]);
    }
  }, {
    key: "register",
    value: function(e) {
      if (yn(Go, this).length >= Math.pow(2, 24 - yn(Hs, this)))
        return null;
      var i = yn(Go, this).length, n = DA(i, yn(Hs, this)), s = cse(i + (n << 24 - yn(Hs, this)));
      return yn(Go, this).push(e), s;
    }
  }, {
    key: "lookup",
    value: function(e) {
      if (!e) return null;
      var i = typeof e == "string" ? hse(e) : ZO.apply(void 0, sse(e));
      if (!i) return null;
      var n = i & Math.pow(2, 24 - yn(Hs, this)) - 1, s = i >> 24 - yn(Hs, this) & Math.pow(2, yn(Hs, this)) - 1;
      return DA(n, yn(Hs, this)) !== s || n >= yn(Go, this).length ? null : yn(Go, this)[n];
    }
    // How many bits to reserve for checksum. Will eat away into the usable size of the registry.
  }]);
}();
const { abs: Nh, cos: Ws, sin: Au, acos: pse, atan2: Ph, sqrt: $a, pow: vn } = Math;
function Oh(r) {
  return r < 0 ? -vn(-r, 1 / 3) : vn(r, 1 / 3);
}
const JO = Math.PI, Lf = 2 * JO, Ka = JO / 2, fse = 1e-6, Mv = Number.MAX_SAFE_INTEGER || 9007199254740991, Av = Number.MIN_SAFE_INTEGER || -9007199254740991, mse = { x: 0, y: 0, z: 0 }, Ie = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(r, e) {
    const i = e(r);
    let n = i.x * i.x + i.y * i.y;
    return typeof i.z < "u" && (n += i.z * i.z), $a(n);
  },
  compute: function(r, e, i) {
    if (r === 0)
      return e[0].t = 0, e[0];
    const n = e.length - 1;
    if (r === 1)
      return e[n].t = 1, e[n];
    const s = 1 - r;
    let a = e;
    if (n === 0)
      return e[0].t = r, e[0];
    if (n === 1) {
      const l = {
        x: s * a[0].x + r * a[1].x,
        y: s * a[0].y + r * a[1].y,
        t: r
      };
      return i && (l.z = s * a[0].z + r * a[1].z), l;
    }
    if (n < 4) {
      let l = s * s, u = r * r, c, h, d, p = 0;
      n === 2 ? (a = [a[0], a[1], a[2], mse], c = l, h = s * r * 2, d = u) : n === 3 && (c = l * s, h = l * r * 3, d = s * u * 3, p = r * u);
      const f = {
        x: c * a[0].x + h * a[1].x + d * a[2].x + p * a[3].x,
        y: c * a[0].y + h * a[1].y + d * a[2].y + p * a[3].y,
        t: r
      };
      return i && (f.z = c * a[0].z + h * a[1].z + d * a[2].z + p * a[3].z), f;
    }
    const o = JSON.parse(JSON.stringify(e));
    for (; o.length > 1; ) {
      for (let l = 0; l < o.length - 1; l++)
        o[l] = {
          x: o[l].x + (o[l + 1].x - o[l].x) * r,
          y: o[l].y + (o[l + 1].y - o[l].y) * r
        }, typeof o[l].z < "u" && (o[l].z = o[l].z + (o[l + 1].z - o[l].z) * r);
      o.splice(o.length - 1, 1);
    }
    return o[0].t = r, o[0];
  },
  computeWithRatios: function(r, e, i, n) {
    const s = 1 - r, a = i, o = e;
    let l = a[0], u = a[1], c = a[2], h = a[3], d;
    if (l *= s, u *= r, o.length === 2)
      return d = l + u, {
        x: (l * o[0].x + u * o[1].x) / d,
        y: (l * o[0].y + u * o[1].y) / d,
        z: n ? (l * o[0].z + u * o[1].z) / d : !1,
        t: r
      };
    if (l *= s, u *= 2 * s, c *= r * r, o.length === 3)
      return d = l + u + c, {
        x: (l * o[0].x + u * o[1].x + c * o[2].x) / d,
        y: (l * o[0].y + u * o[1].y + c * o[2].y) / d,
        z: n ? (l * o[0].z + u * o[1].z + c * o[2].z) / d : !1,
        t: r
      };
    if (l *= s, u *= 1.5 * s, c *= 3 * s, h *= r * r * r, o.length === 4)
      return d = l + u + c + h, {
        x: (l * o[0].x + u * o[1].x + c * o[2].x + h * o[3].x) / d,
        y: (l * o[0].y + u * o[1].y + c * o[2].y + h * o[3].y) / d,
        z: n ? (l * o[0].z + u * o[1].z + c * o[2].z + h * o[3].z) / d : !1,
        t: r
      };
  },
  derive: function(r, e) {
    const i = [];
    for (let n = r, s = n.length, a = s - 1; s > 1; s--, a--) {
      const o = [];
      for (let l = 0, u; l < a; l++)
        u = {
          x: a * (n[l + 1].x - n[l].x),
          y: a * (n[l + 1].y - n[l].y)
        }, e && (u.z = a * (n[l + 1].z - n[l].z)), o.push(u);
      i.push(o), n = o;
    }
    return i;
  },
  between: function(r, e, i) {
    return e <= r && r <= i || Ie.approximately(r, e) || Ie.approximately(r, i);
  },
  approximately: function(r, e, i) {
    return Nh(r - e) <= (i || fse);
  },
  length: function(r) {
    const e = Ie.Tvalues.length;
    let i = 0;
    for (let n = 0, s; n < e; n++)
      s = 0.5 * Ie.Tvalues[n] + 0.5, i += Ie.Cvalues[n] * Ie.arcfn(s, r);
    return 0.5 * i;
  },
  map: function(r, e, i, n, s) {
    const a = i - e, o = s - n, l = r - e, u = l / a;
    return n + o * u;
  },
  lerp: function(r, e, i) {
    const n = {
      x: e.x + r * (i.x - e.x),
      y: e.y + r * (i.y - e.y)
    };
    return e.z !== void 0 && i.z !== void 0 && (n.z = e.z + r * (i.z - e.z)), n;
  },
  pointToString: function(r) {
    let e = r.x + "/" + r.y;
    return typeof r.z < "u" && (e += "/" + r.z), e;
  },
  pointsToString: function(r) {
    return "[" + r.map(Ie.pointToString).join(", ") + "]";
  },
  copy: function(r) {
    return JSON.parse(JSON.stringify(r));
  },
  angle: function(r, e, i) {
    const n = e.x - r.x, s = e.y - r.y, a = i.x - r.x, o = i.y - r.y, l = n * o - s * a, u = n * a + s * o;
    return Ph(l, u);
  },
  // round as string, to avoid rounding errors
  round: function(r, e) {
    const i = "" + r, n = i.indexOf(".");
    return parseFloat(i.substring(0, n + 1 + e));
  },
  dist: function(r, e) {
    const i = r.x - e.x, n = r.y - e.y;
    return $a(i * i + n * n);
  },
  closest: function(r, e) {
    let i = vn(2, 63), n, s;
    return r.forEach(function(a, o) {
      s = Ie.dist(e, a), s < i && (i = s, n = o);
    }), { mdist: i, mpos: n };
  },
  abcratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const i = vn(r, e) + vn(1 - r, e), n = i - 1;
    return Nh(n / i);
  },
  projectionratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const i = vn(1 - r, e), n = vn(r, e) + i;
    return i / n;
  },
  lli8: function(r, e, i, n, s, a, o, l) {
    const u = (r * n - e * i) * (s - o) - (r - i) * (s * l - a * o), c = (r * n - e * i) * (a - l) - (e - n) * (s * l - a * o), h = (r - i) * (a - l) - (e - n) * (s - o);
    return h == 0 ? !1 : { x: u / h, y: c / h };
  },
  lli4: function(r, e, i, n) {
    const s = r.x, a = r.y, o = e.x, l = e.y, u = i.x, c = i.y, h = n.x, d = n.y;
    return Ie.lli8(s, a, o, l, u, c, h, d);
  },
  lli: function(r, e) {
    return Ie.lli4(r, r.c, e, e.c);
  },
  makeline: function(r, e) {
    return new oi(
      r.x,
      r.y,
      (r.x + e.x) / 2,
      (r.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(r) {
    let e = Mv, i = Mv, n = Av, s = Av;
    return r.forEach(function(a) {
      const o = a.bbox();
      e > o.x.min && (e = o.x.min), i > o.y.min && (i = o.y.min), n < o.x.max && (n = o.x.max), s < o.y.max && (s = o.y.max);
    }), {
      x: { min: e, mid: (e + n) / 2, max: n, size: n - e },
      y: { min: i, mid: (i + s) / 2, max: s, size: s - i }
    };
  },
  shapeintersections: function(r, e, i, n, s) {
    if (!Ie.bboxoverlap(e, n)) return [];
    const a = [], o = [r.startcap, r.forward, r.back, r.endcap], l = [i.startcap, i.forward, i.back, i.endcap];
    return o.forEach(function(u) {
      u.virtual || l.forEach(function(c) {
        if (c.virtual) return;
        const h = u.intersects(c, s);
        h.length > 0 && (h.c1 = u, h.c2 = c, h.s1 = r, h.s2 = i, a.push(h));
      });
    }), a;
  },
  makeshape: function(r, e, i) {
    const n = e.points.length, s = r.points.length, a = Ie.makeline(e.points[n - 1], r.points[0]), o = Ie.makeline(r.points[s - 1], e.points[0]), l = {
      startcap: a,
      forward: r,
      back: e,
      endcap: o,
      bbox: Ie.findbbox([a, r, e, o])
    };
    return l.intersections = function(u) {
      return Ie.shapeintersections(
        l,
        l.bbox,
        u,
        u.bbox,
        i
      );
    }, l;
  },
  getminmax: function(r, e, i) {
    if (!i) return { min: 0, max: 0 };
    let n = Mv, s = Av, a, o;
    i.indexOf(0) === -1 && (i = [0].concat(i)), i.indexOf(1) === -1 && i.push(1);
    for (let l = 0, u = i.length; l < u; l++)
      a = i[l], o = r.get(a), o[e] < n && (n = o[e]), o[e] > s && (s = o[e]);
    return { min: n, mid: (n + s) / 2, max: s, size: s - n };
  },
  align: function(r, e) {
    const i = e.p1.x, n = e.p1.y, s = -Ph(e.p2.y - n, e.p2.x - i), a = function(o) {
      return {
        x: (o.x - i) * Ws(s) - (o.y - n) * Au(s),
        y: (o.x - i) * Au(s) + (o.y - n) * Ws(s)
      };
    };
    return r.map(a);
  },
  roots: function(r, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const i = r.length - 1, n = Ie.align(r, e), s = function(w) {
      return 0 <= w && w <= 1;
    };
    if (i === 2) {
      const w = n[0].y, C = n[1].y, E = n[2].y, A = w - 2 * C + E;
      if (A !== 0) {
        const N = -$a(C * C - w * E), L = -w + C, F = -(N + L) / A, M = -(-N + L) / A;
        return [F, M].filter(s);
      } else if (C !== E && A === 0)
        return [(2 * C - E) / (2 * C - 2 * E)].filter(s);
      return [];
    }
    const a = n[0].y, o = n[1].y, l = n[2].y, u = n[3].y;
    let c = -a + 3 * o - 3 * l + u, h = 3 * a - 6 * o + 3 * l, d = -3 * a + 3 * o, p = a;
    if (Ie.approximately(c, 0)) {
      if (Ie.approximately(h, 0))
        return Ie.approximately(d, 0) ? [] : [-p / d].filter(s);
      const w = $a(d * d - 4 * h * p), C = 2 * h;
      return [(w - d) / C, (-d - w) / C].filter(s);
    }
    h /= c, d /= c, p /= c;
    const f = (3 * d - h * h) / 3, m = f / 3, v = (2 * h * h * h - 9 * h * d + 27 * p) / 27, y = v / 2, g = y * y + m * m * m;
    let _, x, b, T, S;
    if (g < 0) {
      const w = -f / 3, C = w * w * w, E = $a(C), A = -v / (2 * E), N = A < -1 ? -1 : A > 1 ? 1 : A, L = pse(N), F = Oh(E), M = 2 * F;
      return b = M * Ws(L / 3) - h / 3, T = M * Ws((L + Lf) / 3) - h / 3, S = M * Ws((L + 2 * Lf) / 3) - h / 3, [b, T, S].filter(s);
    } else {
      if (g === 0)
        return _ = y < 0 ? Oh(-y) : -Oh(y), b = 2 * _ - h / 3, T = -_ - h / 3, [b, T].filter(s);
      {
        const w = $a(g);
        return _ = Oh(-y + w), x = Oh(y + w), [_ - x - h / 3].filter(s);
      }
    }
  },
  droots: function(r) {
    if (r.length === 3) {
      const e = r[0], i = r[1], n = r[2], s = e - 2 * i + n;
      if (s !== 0) {
        const a = -$a(i * i - e * n), o = -e + i, l = -(a + o) / s, u = -(-a + o) / s;
        return [l, u];
      } else if (i !== n && s === 0)
        return [(2 * i - n) / (2 * (i - n))];
      return [];
    }
    if (r.length === 2) {
      const e = r[0], i = r[1];
      return e !== i ? [e / (e - i)] : [];
    }
    return [];
  },
  curvature: function(r, e, i, n, s) {
    let a, o, l, u, c = 0, h = 0;
    const d = Ie.compute(r, e), p = Ie.compute(r, i), f = d.x * d.x + d.y * d.y;
    if (n ? (a = $a(
      vn(d.y * p.z - p.y * d.z, 2) + vn(d.z * p.x - p.z * d.x, 2) + vn(d.x * p.y - p.x * d.y, 2)
    ), o = vn(f + d.z * d.z, 3 / 2)) : (a = d.x * p.y - d.y * p.x, o = vn(f, 3 / 2)), a === 0 || o === 0)
      return { k: 0, r: 0 };
    if (c = a / o, h = o / a, !s) {
      const m = Ie.curvature(r - 1e-3, e, i, n, !0).k, v = Ie.curvature(r + 1e-3, e, i, n, !0).k;
      u = (v - c + (c - m)) / 2, l = (Nh(v - c) + Nh(c - m)) / 2;
    }
    return { k: c, r: h, dk: u, adk: l };
  },
  inflections: function(r) {
    if (r.length < 4) return [];
    const e = Ie.align(r, { p1: r[0], p2: r.slice(-1)[0] }), i = e[2].x * e[1].y, n = e[3].x * e[1].y, s = e[1].x * e[2].y, a = e[3].x * e[2].y, o = 18 * (-3 * i + 2 * n + 3 * s - a), l = 18 * (3 * i - n - 3 * s), u = 18 * (s - i);
    if (Ie.approximately(o, 0)) {
      if (!Ie.approximately(l, 0)) {
        let p = -u / l;
        if (0 <= p && p <= 1) return [p];
      }
      return [];
    }
    const c = 2 * o;
    if (Ie.approximately(c, 0)) return [];
    const h = l * l - 4 * o * u;
    if (h < 0) return [];
    const d = Math.sqrt(h);
    return [(d - l) / c, -(l + d) / c].filter(function(p) {
      return 0 <= p && p <= 1;
    });
  },
  bboxoverlap: function(r, e) {
    const i = ["x", "y"], n = i.length;
    for (let s = 0, a, o, l, u; s < n; s++)
      if (a = i[s], o = r[a].mid, l = e[a].mid, u = (r[a].size + e[a].size) / 2, Nh(o - l) >= u) return !1;
    return !0;
  },
  expandbox: function(r, e) {
    e.x.min < r.x.min && (r.x.min = e.x.min), e.y.min < r.y.min && (r.y.min = e.y.min), e.z && e.z.min < r.z.min && (r.z.min = e.z.min), e.x.max > r.x.max && (r.x.max = e.x.max), e.y.max > r.y.max && (r.y.max = e.y.max), e.z && e.z.max > r.z.max && (r.z.max = e.z.max), r.x.mid = (r.x.min + r.x.max) / 2, r.y.mid = (r.y.min + r.y.max) / 2, r.z && (r.z.mid = (r.z.min + r.z.max) / 2), r.x.size = r.x.max - r.x.min, r.y.size = r.y.max - r.y.min, r.z && (r.z.size = r.z.max - r.z.min);
  },
  pairiteration: function(r, e, i) {
    const n = r.bbox(), s = e.bbox(), a = 1e5, o = i || 0.5;
    if (n.x.size + n.y.size < o && s.x.size + s.y.size < o)
      return [
        (a * (r._t1 + r._t2) / 2 | 0) / a + "/" + (a * (e._t1 + e._t2) / 2 | 0) / a
      ];
    let l = r.split(0.5), u = e.split(0.5), c = [
      { left: l.left, right: u.left },
      { left: l.left, right: u.right },
      { left: l.right, right: u.right },
      { left: l.right, right: u.left }
    ];
    c = c.filter(function(d) {
      return Ie.bboxoverlap(d.left.bbox(), d.right.bbox());
    });
    let h = [];
    return c.length === 0 || (c.forEach(function(d) {
      h = h.concat(
        Ie.pairiteration(d.left, d.right, o)
      );
    }), h = h.filter(function(d, p) {
      return h.indexOf(d) === p;
    })), h;
  },
  getccenter: function(r, e, i) {
    const n = e.x - r.x, s = e.y - r.y, a = i.x - e.x, o = i.y - e.y, l = n * Ws(Ka) - s * Au(Ka), u = n * Au(Ka) + s * Ws(Ka), c = a * Ws(Ka) - o * Au(Ka), h = a * Au(Ka) + o * Ws(Ka), d = (r.x + e.x) / 2, p = (r.y + e.y) / 2, f = (e.x + i.x) / 2, m = (e.y + i.y) / 2, v = d + l, y = p + u, g = f + c, _ = m + h, x = Ie.lli8(d, p, v, y, f, m, g, _), b = Ie.dist(x, r);
    let T = Ph(r.y - x.y, r.x - x.x), S = Ph(e.y - x.y, e.x - x.x), w = Ph(i.y - x.y, i.x - x.x), C;
    return T < w ? ((T > S || S > w) && (T += Lf), T > w && (C = w, w = T, T = C)) : w < S && S < T ? (C = w, w = T, T = C) : w += Lf, x.s = T, x.e = w, x.r = b, x;
  },
  numberSort: function(r, e) {
    return r - e;
  }
};
class od {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return Ie.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, i) {
      return e + i;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var i = e[0].bbox(), n = 1; n < e.length; n++)
      Ie.expandbox(i, e[n].bbox());
    return i;
  }
  offset(e) {
    const i = [];
    return this.curves.forEach(function(n) {
      i.push(...n.offset(e));
    }), new od(i);
  }
}
const { abs: Ih, min: kA, max: LA, cos: gse, sin: yse, acos: vse, sqrt: Dh } = Math, bse = Math.PI;
class oi {
  constructor(e) {
    let i = e && e.forEach ? e : Array.from(arguments).slice(), n = !1;
    if (typeof i[0] == "object") {
      n = i.length;
      const f = [];
      i.forEach(function(m) {
        ["x", "y", "z"].forEach(function(v) {
          typeof m[v] < "u" && f.push(m[v]);
        });
      }), i = f;
    }
    let s = !1;
    const a = i.length;
    if (n) {
      if (n > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        s = !0;
      }
    } else if (a !== 6 && a !== 8 && a !== 9 && a !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const o = this._3d = !s && (a === 9 || a === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let f = 0, m = o ? 3 : 2; f < a; f += m) {
      var u = {
        x: i[f],
        y: i[f + 1]
      };
      o && (u.z = i[f + 2]), l.push(u);
    }
    const c = this.order = l.length - 1, h = this.dims = ["x", "y"];
    o && h.push("z"), this.dimlen = h.length;
    const d = Ie.align(l, { p1: l[0], p2: l[c] }), p = Ie.dist(l[0], l[c]);
    this._linear = d.reduce((f, m) => f + Ih(m.y), 0) < p / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, i, n, s) {
    if (typeof s > "u" && (s = 0.5), s === 0)
      return new oi(i, i, n);
    if (s === 1)
      return new oi(e, i, i);
    const a = oi.getABC(2, e, i, n, s);
    return new oi(e, a.A, n);
  }
  static cubicFromPoints(e, i, n, s, a) {
    typeof s > "u" && (s = 0.5);
    const o = oi.getABC(3, e, i, n, s);
    typeof a > "u" && (a = Ie.dist(i, o.C));
    const l = a * (1 - s) / s, u = Ie.dist(e, n), c = (n.x - e.x) / u, h = (n.y - e.y) / u, d = a * c, p = a * h, f = l * c, m = l * h, v = { x: i.x - d, y: i.y - p }, y = { x: i.x + f, y: i.y + m }, g = o.A, _ = { x: g.x + (v.x - g.x) / (1 - s), y: g.y + (v.y - g.y) / (1 - s) }, x = { x: g.x + (y.x - g.x) / s, y: g.y + (y.y - g.y) / s }, b = { x: e.x + (_.x - e.x) / s, y: e.y + (_.y - e.y) / s }, T = {
      x: n.x + (x.x - n.x) / (1 - s),
      y: n.y + (x.y - n.y) / (1 - s)
    };
    return new oi(e, b, T, n);
  }
  static getUtils() {
    return Ie;
  }
  getUtils() {
    return oi.getUtils();
  }
  static get PolyBezier() {
    return od;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return Ie.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, i = e[0].x, n = e[0].y, s = ["M", i, n, this.order === 2 ? "Q" : "C"];
    for (let a = 1, o = e.length; a < o; a++)
      s.push(e[a].x), s.push(e[a].y);
    return s.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, i) {
      return "" + i + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = Ie.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, i = Ie.angle(e[0], e[this.order], e[1]);
    this.clockwise = i > 0;
  }
  length() {
    return Ie.length(this.derivative.bind(this));
  }
  static getABC(e = 2, i, n, s, a = 0.5) {
    const o = Ie.projectionratio(a, e), l = 1 - o, u = {
      x: o * i.x + l * s.x,
      y: o * i.y + l * s.y
    }, c = Ie.abcratio(a, e);
    return { A: {
      x: n.x + (n.x - u.x) / c,
      y: n.y + (n.y - u.y) / c
    }, B: n, C: u, S: i, E: s };
  }
  getABC(e, i) {
    i = i || this.get(e);
    let n = this.points[0], s = this.points[this.order];
    return oi.getABC(this.order, n, i, s, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let i = 0, n, s; i < e; i++)
      s = i / (e - 1), n = this.compute(s), n.t = s, this._lut.push(n);
    return this._lut;
  }
  on(e, i) {
    i = i || 5;
    const n = this.getLUT(), s = [];
    for (let a = 0, o, l = 0; a < n.length; a++)
      o = n[a], Ie.dist(o, e) < i && (s.push(o), l += a / n.length);
    return s.length ? t /= s.length : !1;
  }
  project(e) {
    const i = this.getLUT(), n = i.length - 1, s = Ie.closest(i, e), a = s.mpos, o = (a - 1) / n, l = (a + 1) / n, u = 0.1 / n;
    let c = s.mdist, h = o, d = h, p;
    c += 1;
    for (let f; h < l + u; h += u)
      p = this.compute(h), f = Ie.dist(e, p), f < c && (c = f, d = h);
    return d = d < 0 ? 0 : d > 1 ? 1 : d, p = this.compute(d), p.t = d, p.d = c, p;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? Ie.computeWithRatios(e, this.points, this.ratios, this._3d) : Ie.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, i = [e[0]], n = e.length;
    for (let s = 1, a, o; s < n; s++)
      a = e[s], o = e[s - 1], i[s] = {
        x: (n - s) / n * a.x + s / n * o.x,
        y: (n - s) / n * a.y + s / n * o.y
      };
    return i[n] = e[n - 1], new oi(i);
  }
  derivative(e) {
    return Ie.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return Ie.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new oi(Ie.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return Ie.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return Ie.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const i = this.derivative(e), n = Dh(i.x * i.x + i.y * i.y);
    return { t: e, x: -i.y / n, y: i.x / n };
  }
  __normal3(e) {
    const i = this.derivative(e), n = this.derivative(e + 0.01), s = Dh(i.x * i.x + i.y * i.y + i.z * i.z), a = Dh(n.x * n.x + n.y * n.y + n.z * n.z);
    i.x /= s, i.y /= s, i.z /= s, n.x /= a, n.y /= a, n.z /= a;
    const o = {
      x: n.y * i.z - n.z * i.y,
      y: n.z * i.x - n.x * i.z,
      z: n.x * i.y - n.y * i.x
    }, l = Dh(o.x * o.x + o.y * o.y + o.z * o.z);
    o.x /= l, o.y /= l, o.z /= l;
    const u = [
      o.x * o.x,
      o.x * o.y - o.z,
      o.x * o.z + o.y,
      o.x * o.y + o.z,
      o.y * o.y,
      o.y * o.z - o.x,
      o.x * o.z - o.y,
      o.y * o.z + o.x,
      o.z * o.z
    ];
    return {
      t: e,
      x: u[0] * i.x + u[1] * i.y + u[2] * i.z,
      y: u[3] * i.x + u[4] * i.y + u[5] * i.z,
      z: u[6] * i.x + u[7] * i.y + u[8] * i.z
    };
  }
  hull(e) {
    let i = this.points, n = [], s = [], a = 0;
    for (s[a++] = i[0], s[a++] = i[1], s[a++] = i[2], this.order === 3 && (s[a++] = i[3]); i.length > 1; ) {
      n = [];
      for (let o = 0, l, u = i.length - 1; o < u; o++)
        l = Ie.lerp(e, i[o], i[o + 1]), s[a++] = l, n.push(l);
      i = n;
    }
    return s;
  }
  split(e, i) {
    if (e === 0 && i)
      return this.split(i).left;
    if (i === 1)
      return this.split(e).right;
    const n = this.hull(e), s = {
      left: this.order === 2 ? new oi([n[0], n[3], n[5]]) : new oi([n[0], n[4], n[7], n[9]]),
      right: this.order === 2 ? new oi([n[5], n[4], n[2]]) : new oi([n[9], n[8], n[6], n[3]]),
      span: n
    };
    return s.left._t1 = Ie.map(0, 0, 1, this._t1, this._t2), s.left._t2 = Ie.map(e, 0, 1, this._t1, this._t2), s.right._t1 = Ie.map(e, 0, 1, this._t1, this._t2), s.right._t2 = Ie.map(1, 0, 1, this._t1, this._t2), i ? (i = Ie.map(i, e, 1, 0, 1), s.right.split(i).left) : s;
  }
  extrema() {
    const e = {};
    let i = [];
    return this.dims.forEach(
      (function(n) {
        let s = function(o) {
          return o[n];
        }, a = this.dpoints[0].map(s);
        e[n] = Ie.droots(a), this.order === 3 && (a = this.dpoints[1].map(s), e[n] = e[n].concat(Ie.droots(a))), e[n] = e[n].filter(function(o) {
          return o >= 0 && o <= 1;
        }), i = i.concat(e[n].sort(Ie.numberSort));
      }).bind(this)
    ), e.values = i.sort(Ie.numberSort).filter(function(n, s) {
      return i.indexOf(n) === s;
    }), e;
  }
  bbox() {
    const e = this.extrema(), i = {};
    return this.dims.forEach(
      (function(n) {
        i[n] = Ie.getminmax(this, n, e[n]);
      }).bind(this)
    ), i;
  }
  overlaps(e) {
    const i = this.bbox(), n = e.bbox();
    return Ie.bboxoverlap(i, n);
  }
  offset(e, i) {
    if (typeof i < "u") {
      const n = this.get(e), s = this.normal(e), a = {
        c: n,
        n: s,
        x: n.x + s.x * i,
        y: n.y + s.y * i
      };
      return this._3d && (a.z = n.z + s.z * i), a;
    }
    if (this._linear) {
      const n = this.normal(0), s = this.points.map(function(a) {
        const o = {
          x: a.x + e * n.x,
          y: a.y + e * n.y
        };
        return a.z && n.z && (o.z = a.z + e * n.z), o;
      });
      return [new oi(s)];
    }
    return this.reduce().map(function(n) {
      return n._linear ? n.offset(e)[0] : n.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const s = Ie.angle(this.points[0], this.points[3], this.points[1]), a = Ie.angle(this.points[0], this.points[3], this.points[2]);
      if (s > 0 && a < 0 || s < 0 && a > 0) return !1;
    }
    const e = this.normal(0), i = this.normal(1);
    let n = e.x * i.x + e.y * i.y;
    return this._3d && (n += e.z * i.z), Ih(vse(n)) < bse / 3;
  }
  reduce() {
    let e, i = 0, n = 0, s = 0.01, a, o = [], l = [], u = this.extrema().values;
    for (u.indexOf(0) === -1 && (u = [0].concat(u)), u.indexOf(1) === -1 && u.push(1), i = u[0], e = 1; e < u.length; e++)
      n = u[e], a = this.split(i, n), a._t1 = i, a._t2 = n, o.push(a), i = n;
    return o.forEach(function(c) {
      for (i = 0, n = 0; n <= 1; )
        for (n = i + s; n <= 1 + s; n += s)
          if (a = c.split(i, n), !a.simple()) {
            if (n -= s, Ih(i - n) < s)
              return [];
            a = c.split(i, n), a._t1 = Ie.map(i, 0, 1, c._t1, c._t2), a._t2 = Ie.map(n, 0, 1, c._t1, c._t2), l.push(a), i = n;
            break;
          }
      i < 1 && (a = c.split(i, 1), a._t1 = Ie.map(i, 0, 1, c._t1, c._t2), a._t2 = c._t2, l.push(a));
    }), l;
  }
  translate(e, i, n) {
    n = typeof n == "number" ? n : i;
    const s = this.order;
    let a = this.points.map((o, l) => (1 - l / s) * i + l / s * n);
    return new oi(
      this.points.map((o, l) => ({
        x: o.x + e.x * a[l],
        y: o.y + e.y * a[l]
      }))
    );
  }
  scale(e) {
    const i = this.order;
    let n = !1;
    if (typeof e == "function" && (n = e), n && i === 2)
      return this.raise().scale(n);
    const s = this.clockwise, a = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        n ? n(0) : e,
        n ? n(1) : e
      );
    const o = n ? n(0) : e, l = n ? n(1) : e, u = [this.offset(0, 10), this.offset(1, 10)], c = [], h = Ie.lli4(u[0], u[0].c, u[1], u[1].c);
    if (!h)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(d) {
      const p = c[d * i] = Ie.copy(a[d * i]);
      p.x += (d ? l : o) * u[d].n.x, p.y += (d ? l : o) * u[d].n.y;
    }), n ? ([0, 1].forEach(function(d) {
      if (!(i === 2 && d)) {
        var p = a[d + 1], f = {
          x: p.x - h.x,
          y: p.y - h.y
        }, m = n ? n((d + 1) / i) : e;
        n && !s && (m = -m);
        var v = Dh(f.x * f.x + f.y * f.y);
        f.x /= v, f.y /= v, c[d + 1] = {
          x: p.x + m * f.x,
          y: p.y + m * f.y
        };
      }
    }), new oi(c)) : ([0, 1].forEach((d) => {
      if (i === 2 && d) return;
      const p = c[d * i], f = this.derivative(d), m = { x: p.x + f.x, y: p.y + f.y };
      c[d + 1] = Ie.lli4(p, m, h, a[d + 1]);
    }), new oi(c));
  }
  outline(e, i, n, s) {
    if (i = i === void 0 ? e : i, this._linear) {
      const T = this.normal(0), S = this.points[0], w = this.points[this.points.length - 1];
      let C, E, A;
      n === void 0 && (n = e, s = i), C = { x: S.x + T.x * e, y: S.y + T.y * e }, A = { x: w.x + T.x * n, y: w.y + T.y * n }, E = { x: (C.x + A.x) / 2, y: (C.y + A.y) / 2 };
      const N = [C, E, A];
      C = { x: S.x - T.x * i, y: S.y - T.y * i }, A = { x: w.x - T.x * s, y: w.y - T.y * s }, E = { x: (C.x + A.x) / 2, y: (C.y + A.y) / 2 };
      const L = [A, E, C], F = Ie.makeline(L[2], N[0]), M = Ie.makeline(N[2], L[0]), P = [F, new oi(N), M, new oi(L)];
      return new od(P);
    }
    const a = this.reduce(), o = a.length, l = [];
    let u = [], c, h = 0, d = this.length();
    const p = typeof n < "u" && typeof s < "u";
    function f(T, S, w, C, E) {
      return function(A) {
        const N = C / w, L = (C + E) / w, F = S - T;
        return Ie.map(A, 0, 1, T + N * F, T + L * F);
      };
    }
    a.forEach(function(T) {
      const S = T.length();
      p ? (l.push(
        T.scale(f(e, n, d, h, S))
      ), u.push(
        T.scale(f(-i, -s, d, h, S))
      )) : (l.push(T.scale(e)), u.push(T.scale(-i))), h += S;
    }), u = u.map(function(T) {
      return c = T.points, c[3] ? T.points = [c[3], c[2], c[1], c[0]] : T.points = [c[2], c[1], c[0]], T;
    }).reverse();
    const m = l[0].points[0], v = l[o - 1].points[l[o - 1].points.length - 1], y = u[o - 1].points[u[o - 1].points.length - 1], g = u[0].points[0], _ = Ie.makeline(y, m), x = Ie.makeline(v, g), b = [_].concat(l).concat([x]).concat(u);
    return new od(b);
  }
  outlineshapes(e, i, n) {
    i = i || e;
    const s = this.outline(e, i).curves, a = [];
    for (let o = 1, l = s.length; o < l / 2; o++) {
      const u = Ie.makeshape(
        s[o],
        s[l - o],
        n
      );
      u.startcap.virtual = o > 1, u.endcap.virtual = o < l / 2 - 1, a.push(u);
    }
    return a;
  }
  intersects(e, i) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof oi && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      i
    )) : this.selfintersects(i);
  }
  lineIntersects(e) {
    const i = kA(e.p1.x, e.p2.x), n = kA(e.p1.y, e.p2.y), s = LA(e.p1.x, e.p2.x), a = LA(e.p1.y, e.p2.y);
    return Ie.roots(this.points, e).filter((o) => {
      var l = this.get(o);
      return Ie.between(l.x, i, s) && Ie.between(l.y, n, a);
    });
  }
  selfintersects(e) {
    const i = this.reduce(), n = i.length - 2, s = [];
    for (let a = 0, o, l, u; a < n; a++)
      l = i.slice(a, a + 1), u = i.slice(a + 2), o = this.curveintersects(l, u, e), s.push(...o);
    return s;
  }
  curveintersects(e, i, n) {
    const s = [];
    e.forEach(function(o) {
      i.forEach(function(l) {
        o.overlaps(l) && s.push({ left: o, right: l });
      });
    });
    let a = [];
    return s.forEach(function(o) {
      const l = Ie.pairiteration(
        o.left,
        o.right,
        n
      );
      l.length > 0 && (a = a.concat(l));
    }), a;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, i, n, s) {
    const a = (s - n) / 4, o = this.get(n + a), l = this.get(s - a), u = Ie.dist(e, i), c = Ie.dist(e, o), h = Ie.dist(e, l);
    return Ih(c - u) + Ih(h - u);
  }
  _iterate(e, i) {
    let n = 0, s = 1, a;
    do {
      a = 0, s = 1;
      let o = this.get(n), l, u, c, h, d = !1, p = !1, f, m = s, v = 1;
      do
        if (p = d, h = c, m = (n + s) / 2, l = this.get(m), u = this.get(s), c = Ie.getccenter(o, l, u), c.interval = {
          start: n,
          end: s
        }, d = this._error(c, o, n, s) <= e, f = p && !d, f || (v = s), d) {
          if (s >= 1) {
            if (c.interval.end = v = 1, h = c, s > 1) {
              let y = {
                x: c.x + c.r * gse(c.e),
                y: c.y + c.r * yse(c.e)
              };
              c.e += Ie.angle({ x: c.x, y: c.y }, y, this.get(1));
            }
            break;
          }
          s = s + (s - n) / 2;
        } else
          s = m;
      while (!f && a++ < 100);
      if (a >= 100)
        break;
      h = h || c, i.push(h), n = v;
    } while (s < 1);
    return i;
  }
}
function Qx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function xse(r) {
  if (Array.isArray(r)) return r;
}
function _se(r) {
  if (Array.isArray(r)) return Qx(r);
}
function Tse(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function Sse(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function wse() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ese() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Mse(r, e) {
  if (r == null) return {};
  var i, n, s = Ase(r, e);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(r);
    for (n = 0; n < a.length; n++) i = a[n], e.includes(i) || {}.propertyIsEnumerable.call(r, i) && (s[i] = r[i]);
  }
  return s;
}
function Ase(r, e) {
  if (r == null) return {};
  var i = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    i[n] = r[n];
  }
  return i;
}
function Cse(r, e) {
  return xse(r) || Sse(r, e) || eI(r, e) || wse();
}
function Rse(r) {
  return _se(r) || Tse(r) || eI(r) || Ese();
}
function Nse(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function Pse(r) {
  var e = Nse(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function eI(r, e) {
  if (r) {
    if (typeof r == "string") return Qx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Qx(r, e) : void 0;
  }
}
var Ose = function() {
  var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = (e instanceof Array ? e.length ? e : [void 0] : [e]).map(function(l) {
    return {
      keyAccessor: l,
      isProp: !(l instanceof Function)
    };
  }), a = r.reduce(function(l, u) {
    var c = l, h = u;
    return s.forEach(function(d, p) {
      var f = d.keyAccessor, m = d.isProp, v;
      if (m) {
        var y = h, g = y[f], _ = Mse(y, [f].map(Pse));
        v = g, h = _;
      } else
        v = f(h, p);
      p + 1 < s.length ? (c.hasOwnProperty(v) || (c[v] = {}), c = c[v]) : i ? (c.hasOwnProperty(v) || (c[v] = []), c[v].push(h)) : c[v] = h;
    }), l;
  }, {});
  i instanceof Function && function l(u) {
    var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    c === s.length ? Object.keys(u).forEach(function(h) {
      return u[h] = i(u[h]);
    }) : Object.values(u).forEach(function(h) {
      return l(h, c + 1);
    });
  }(a);
  var o = a;
  return n && (o = [], function l(u) {
    var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    c.length === s.length ? o.push({
      keys: c,
      vals: u
    }) : Object.entries(u).forEach(function(h) {
      var d = Cse(h, 2), p = d[0], f = d[1];
      return l(f, [].concat(Rse(c), [p]));
    });
  }(a), e instanceof Array && e.length === 0 && o.length === 1 && (o[0].keys = [])), o;
};
function Ise(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var Dse = `.force-graph-container canvas {
  display: block;
  user-select: none;
  outline: none;
  -webkit-tap-highlight-color: transparent;
}

.force-graph-container .clickable {
  cursor: pointer;
}

.force-graph-container .grabbable {
  cursor: move;
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

.force-graph-container .grabbable:active {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
}
`;
Ise(Dse);
function Zx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function kse(r) {
  if (Array.isArray(r)) return r;
}
function Lse(r) {
  if (Array.isArray(r)) return Zx(r);
}
function UA(r, e, i) {
  if (tI()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return s;
}
function Od(r, e, i) {
  return (e = Vse(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function tI() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (tI = function() {
    return !!r;
  })();
}
function Use(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function Fse(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function Bse() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function zse() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function FA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function Cu(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? FA(Object(i), !0).forEach(function(n) {
      Od(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : FA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function ld(r, e) {
  return kse(r) || Fse(r, e) || iI(r, e) || Bse();
}
function Sn(r) {
  return Lse(r) || Use(r) || iI(r) || zse();
}
function jse(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Vse(r) {
  var e = jse(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Jx(r) {
  "@babel/helpers - typeof";
  return Jx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Jx(r);
}
function iI(r, e) {
  if (r) {
    if (typeof r == "string") return Zx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Zx(r, e) : void 0;
  }
}
var Gse = eT(fN);
function BA(r, e, i) {
  !e || typeof i != "string" || r.filter(function(n) {
    return !n[i];
  }).forEach(function(n) {
    n[i] = Gse(e(n));
  });
}
function Hse(r, e) {
  var i = r.nodes, n = r.links, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = s.nodeFilter, o = a === void 0 ? function() {
    return !0;
  } : a, l = s.onLoopError, u = l === void 0 ? function(f) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(f.join(" -> "), ".");
  } : l, c = {};
  i.forEach(function(f) {
    return c[e(f)] = {
      data: f,
      out: [],
      depth: -1,
      skip: !o(f)
    };
  }), n.forEach(function(f) {
    var m = f.source, v = f.target, y = b(m), g = b(v);
    if (!c.hasOwnProperty(y)) throw "Missing source node with id: ".concat(y);
    if (!c.hasOwnProperty(g)) throw "Missing target node with id: ".concat(g);
    var _ = c[y], x = c[g];
    _.out.push(x);
    function b(T) {
      return Jx(T) === "object" ? e(T) : T;
    }
  });
  var h = [];
  p(Object.values(c));
  var d = Object.assign.apply(Object, [{}].concat(Sn(Object.entries(c).filter(function(f) {
    var m = ld(f, 2), v = m[1];
    return !v.skip;
  }).map(function(f) {
    var m = ld(f, 2), v = m[0], y = m[1];
    return Od({}, v, y.depth);
  }))));
  return d;
  function p(f) {
    for (var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, y = function() {
      var x = f[g];
      if (m.indexOf(x) !== -1) {
        var b = [].concat(Sn(m.slice(m.indexOf(x))), [x]).map(function(T) {
          return e(T.data);
        });
        return h.some(function(T) {
          return T.length === b.length && T.every(function(S, w) {
            return S === b[w];
          });
        }) || (h.push(b), u(b)), 1;
      }
      v > x.depth && (x.depth = v, p(x.out, [].concat(Sn(m), [x]), v + (x.skip ? 0 : 1)));
    }, g = 0, _ = f.length; g < _; g++)
      y();
  }
}
var Wse = 2, dr = function(r, e) {
  return e.onNeedsRedraw && e.onNeedsRedraw();
}, zA = function(r, e) {
  if (!e.isShadow) {
    var i = et(e.linkDirectionalParticles);
    e.graphData.links.forEach(function(n) {
      var s = Math.round(Math.abs(i(n)));
      s ? n.__photons = Sn(Array(s)).map(function() {
        return {};
      }) : delete n.__photons;
    });
  }
}, Jm = Il({
  props: {
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        e.engineRunning = !1, zA(r, e);
      }
    },
    dagMode: {
      onChange: function(r, e) {
        !r && (e.graphData.nodes || []).forEach(function(i) {
          return i.fx = i.fy = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function(r) {
        return !0;
      }
    },
    onDagError: {
      triggerUpdate: !1
    },
    nodeRelSize: {
      default: 4,
      triggerUpdate: !1,
      onChange: dr
    },
    // area per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val",
      triggerUpdate: !1,
      onChange: dr
    },
    nodeColor: {
      default: "color",
      triggerUpdate: !1,
      onChange: dr
    },
    nodeAutoColorBy: {},
    nodeCanvasObject: {
      triggerUpdate: !1,
      onChange: dr
    },
    nodeCanvasObjectMode: {
      default: function() {
        return "replace";
      },
      triggerUpdate: !1,
      onChange: dr
    },
    nodeVisibility: {
      default: !0,
      triggerUpdate: !1,
      onChange: dr
    },
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0,
      triggerUpdate: !1,
      onChange: dr
    },
    linkColor: {
      default: "color",
      triggerUpdate: !1,
      onChange: dr
    },
    linkAutoColorBy: {},
    linkLineDash: {
      triggerUpdate: !1,
      onChange: dr
    },
    linkWidth: {
      default: 1,
      triggerUpdate: !1,
      onChange: dr
    },
    linkCurvature: {
      default: 0,
      triggerUpdate: !1,
      onChange: dr
    },
    linkCanvasObject: {
      triggerUpdate: !1,
      onChange: dr
    },
    linkCanvasObjectMode: {
      default: function() {
        return "replace";
      },
      triggerUpdate: !1,
      onChange: dr
    },
    linkDirectionalArrowLength: {
      default: 0,
      triggerUpdate: !1,
      onChange: dr
    },
    linkDirectionalArrowColor: {
      triggerUpdate: !1,
      onChange: dr
    },
    linkDirectionalArrowRelPos: {
      default: 0.5,
      triggerUpdate: !1,
      onChange: dr
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalParticles: {
      default: 0,
      triggerUpdate: !1,
      onChange: zA
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01,
      triggerUpdate: !1
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 4,
      triggerUpdate: !1
    },
    linkDirectionalParticleColor: {
      triggerUpdate: !1
    },
    globalScale: {
      default: 1,
      triggerUpdate: !1
    },
    d3AlphaMin: {
      default: 0,
      triggerUpdate: !1
    },
    d3AlphaDecay: {
      default: 0.0228,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.alphaDecay(r);
      }
    },
    d3AlphaTarget: {
      default: 0,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.alphaTarget(r);
      }
    },
    d3VelocityDecay: {
      default: 0.4,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.velocityDecay(r);
      }
    },
    warmupTicks: {
      default: 0,
      triggerUpdate: !1
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      default: 1 / 0,
      triggerUpdate: !1
    },
    cooldownTime: {
      default: 15e3,
      triggerUpdate: !1
    },
    // ms
    onUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineTick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineStop: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNeedsRedraw: {
      triggerUpdate: !1
    },
    isShadow: {
      default: !1,
      triggerUpdate: !1
    }
  },
  methods: {
    // Expose d3 forces for external manipulation
    d3Force: function(r, e, i) {
      return i === void 0 ? r.forceLayout.force(e) : (r.forceLayout.force(e, i), this);
    },
    d3ReheatSimulation: function(r) {
      return r.forceLayout.alpha(1), this.resetCountdown(), this;
    },
    // reset cooldown state
    resetCountdown: function(r) {
      return r.cntTicks = 0, r.startTickTime = /* @__PURE__ */ new Date(), r.engineRunning = !0, this;
    },
    isEngineRunning: function(r) {
      return !!r.engineRunning;
    },
    tickFrame: function(r) {
      return !r.isShadow && e(), n(), !r.isShadow && s(), !r.isShadow && a(), i(), this;
      function e() {
        r.engineRunning && (++r.cntTicks > r.cooldownTicks || /* @__PURE__ */ new Date() - r.startTickTime > r.cooldownTime || r.d3AlphaMin > 0 && r.forceLayout.alpha() < r.d3AlphaMin ? (r.engineRunning = !1, r.onEngineStop()) : (r.forceLayout.tick(), r.onEngineTick()));
      }
      function i() {
        var o = et(r.nodeVisibility), l = et(r.nodeVal), u = et(r.nodeColor), c = et(r.nodeCanvasObjectMode), h = r.ctx, d = r.isShadow / r.globalScale, p = r.graphData.nodes.filter(o);
        h.save(), p.forEach(function(f) {
          var m = c(f);
          if (r.nodeCanvasObject && (m === "before" || m === "replace") && (r.nodeCanvasObject(f, h, r.globalScale), m === "replace")) {
            h.restore();
            return;
          }
          var v = Math.sqrt(Math.max(0, l(f) || 1)) * r.nodeRelSize + d;
          h.beginPath(), h.arc(f.x, f.y, v, 0, 2 * Math.PI, !1), h.fillStyle = u(f) || "rgba(31, 120, 180, 0.92)", h.fill(), r.nodeCanvasObject && m === "after" && r.nodeCanvasObject(f, r.ctx, r.globalScale);
        }), h.restore();
      }
      function n() {
        var o = et(r.linkVisibility), l = et(r.linkColor), u = et(r.linkWidth), c = et(r.linkLineDash), h = et(r.linkCurvature), d = et(r.linkCanvasObjectMode), p = r.ctx, f = r.isShadow * 2, m = r.graphData.links.filter(o);
        m.forEach(T);
        var v = [], y = [], g = m;
        if (r.linkCanvasObject) {
          var _ = [], x = [];
          m.forEach(function(S) {
            return ({
              before: v,
              after: y,
              replace: _
            }[d(S)] || x).push(S);
          }), g = [].concat(Sn(v), y, x), v = v.concat(_);
        }
        p.save(), v.forEach(function(S) {
          return r.linkCanvasObject(S, p, r.globalScale);
        }), p.restore();
        var b = Ose(g, [l, u, c]);
        p.save(), Object.entries(b).forEach(function(S) {
          var w = ld(S, 2), C = w[0], E = w[1], A = !C || C === "undefined" ? "rgba(0,0,0,0.15)" : C;
          Object.entries(E).forEach(function(N) {
            var L = ld(N, 2), F = L[0], M = L[1], P = (F || 1) / r.globalScale + f;
            Object.entries(M).forEach(function(O) {
              var V = ld(O, 2);
              V[0];
              var B = V[1], H = c(B[0]);
              p.beginPath(), B.forEach(function(U) {
                var j = U.source, Q = U.target;
                if (!(!j || !Q || !j.hasOwnProperty("x") || !Q.hasOwnProperty("x"))) {
                  p.moveTo(j.x, j.y);
                  var q = U.__controlPoints;
                  q ? p[q.length === 2 ? "quadraticCurveTo" : "bezierCurveTo"].apply(p, Sn(q).concat([Q.x, Q.y])) : p.lineTo(Q.x, Q.y);
                }
              }), p.strokeStyle = A, p.lineWidth = P, p.setLineDash(H || []), p.stroke();
            });
          });
        }), p.restore(), p.save(), y.forEach(function(S) {
          return r.linkCanvasObject(S, p, r.globalScale);
        }), p.restore();
        function T(S) {
          var w = h(S);
          if (!w) {
            S.__controlPoints = null;
            return;
          }
          var C = S.source, E = S.target;
          if (!(!C || !E || !C.hasOwnProperty("x") || !E.hasOwnProperty("x"))) {
            var A = Math.sqrt(Math.pow(E.x - C.x, 2) + Math.pow(E.y - C.y, 2));
            if (A > 0) {
              var N = Math.atan2(E.y - C.y, E.x - C.x), L = A * w, F = {
                // control point
                x: (C.x + E.x) / 2 + L * Math.cos(N - Math.PI / 2),
                y: (C.y + E.y) / 2 + L * Math.sin(N - Math.PI / 2)
              };
              S.__controlPoints = [F.x, F.y];
            } else {
              var M = w * 70;
              S.__controlPoints = [E.x, E.y - M, E.x + M, E.y];
            }
          }
        }
      }
      function s() {
        var o = 1.6, l = 0.2, u = et(r.linkDirectionalArrowLength), c = et(r.linkDirectionalArrowRelPos), h = et(r.linkVisibility), d = et(r.linkDirectionalArrowColor || r.linkColor), p = et(r.nodeVal), f = r.ctx;
        f.save(), r.graphData.links.filter(h).forEach(function(m) {
          var v = u(m);
          if (!(!v || v < 0)) {
            var y = m.source, g = m.target;
            if (!(!y || !g || !y.hasOwnProperty("x") || !g.hasOwnProperty("x"))) {
              var _ = Math.sqrt(Math.max(0, p(y) || 1)) * r.nodeRelSize, x = Math.sqrt(Math.max(0, p(g) || 1)) * r.nodeRelSize, b = Math.min(1, Math.max(0, c(m))), T = d(m) || "rgba(0,0,0,0.28)", S = v / o / 2, w = m.__controlPoints && UA(oi, [y.x, y.y].concat(Sn(m.__controlPoints), [g.x, g.y])), C = w ? function(P) {
                return w.get(P);
              } : function(P) {
                return {
                  // straight line: interpolate linearly
                  x: y.x + (g.x - y.x) * P || 0,
                  y: y.y + (g.y - y.y) * P || 0
                };
              }, E = w ? w.length() : Math.sqrt(Math.pow(g.x - y.x, 2) + Math.pow(g.y - y.y, 2)), A = _ + v + (E - _ - x - v) * b, N = C(A / E), L = C((A - v) / E), F = C((A - v * (1 - l)) / E), M = Math.atan2(N.y - L.y, N.x - L.x) - Math.PI / 2;
              f.beginPath(), f.moveTo(N.x, N.y), f.lineTo(L.x + S * Math.cos(M), L.y + S * Math.sin(M)), f.lineTo(F.x, F.y), f.lineTo(L.x - S * Math.cos(M), L.y - S * Math.sin(M)), f.fillStyle = T, f.fill();
            }
          }
        }), f.restore();
      }
      function a() {
        var o = et(r.linkDirectionalParticles), l = et(r.linkDirectionalParticleSpeed), u = et(r.linkDirectionalParticleWidth), c = et(r.linkVisibility), h = et(r.linkDirectionalParticleColor || r.linkColor), d = r.ctx;
        d.save(), r.graphData.links.filter(c).forEach(function(p) {
          var f = o(p);
          if (!(!p.hasOwnProperty("__photons") || !p.__photons.length)) {
            var m = p.source, v = p.target;
            if (!(!m || !v || !m.hasOwnProperty("x") || !v.hasOwnProperty("x"))) {
              var y = l(p), g = p.__photons || [], _ = Math.max(0, u(p) / 2) / Math.sqrt(r.globalScale), x = h(p) || "rgba(0,0,0,0.28)";
              d.fillStyle = x;
              var b = p.__controlPoints ? UA(oi, [m.x, m.y].concat(Sn(p.__controlPoints), [v.x, v.y])) : null, T = 0, S = !1;
              g.forEach(function(w) {
                var C = !!w.__singleHop;
                if (w.hasOwnProperty("__progressRatio") || (w.__progressRatio = C ? 0 : T / f), !C && T++, w.__progressRatio += y, w.__progressRatio >= 1)
                  if (!C)
                    w.__progressRatio = w.__progressRatio % 1;
                  else {
                    S = !0;
                    return;
                  }
                var E = w.__progressRatio, A = b ? b.get(E) : {
                  // straight line: interpolate linearly
                  x: m.x + (v.x - m.x) * E || 0,
                  y: m.y + (v.y - m.y) * E || 0
                };
                d.beginPath(), d.arc(A.x, A.y, _, 0, 2 * Math.PI, !1), d.fill();
              }), S && (p.__photons = p.__photons.filter(function(w) {
                return !w.__singleHop || w.__progressRatio <= 1;
              }));
            }
          }
        }), d.restore();
      }
    },
    emitParticle: function(r, e) {
      return e && (!e.__photons && (e.__photons = []), e.__photons.push({
        __singleHop: !0
      })), this;
    }
  },
  stateInit: function() {
    return {
      forceLayout: UR().force("link", DR()).force("charge", FR()).force("center", AR()).force("dagRadial", null).stop(),
      engineRunning: !1
    };
  },
  init: function(r, e) {
    e.ctx = r;
  },
  update: function(r, e) {
    r.engineRunning = !1, r.onUpdate(), r.nodeAutoColorBy !== null && BA(r.graphData.nodes, et(r.nodeAutoColorBy), r.nodeColor), r.linkAutoColorBy !== null && BA(r.graphData.links, et(r.linkAutoColorBy), r.linkColor), r.graphData.links.forEach(function(d) {
      d.source = d[r.linkSource], d.target = d[r.linkTarget];
    }), r.forceLayout.stop().alpha(1).nodes(r.graphData.nodes);
    var i = r.forceLayout.force("link");
    i && i.id(function(d) {
      return d[r.nodeId];
    }).links(r.graphData.links);
    var n = r.dagMode && Hse(r.graphData, function(d) {
      return d[r.nodeId];
    }, {
      nodeFilter: r.dagNodeFilter,
      onLoopError: r.onDagError || void 0
    }), s = Math.max.apply(Math, Sn(Object.values(n || []))), a = r.dagLevelDistance || r.graphData.nodes.length / (s || 1) * Wse * (["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? 0.7 : 1);
    if (["lr", "rl", "td", "bu"].includes(e.dagMode)) {
      var o = ["lr", "rl"].includes(e.dagMode) ? "fx" : "fy";
      r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(d) {
        return delete d[o];
      });
    }
    if (["lr", "rl", "td", "bu"].includes(r.dagMode)) {
      var l = ["rl", "bu"].includes(r.dagMode), u = function(d) {
        return (n[d[r.nodeId]] - s / 2) * a * (l ? -1 : 1);
      }, c = ["lr", "rl"].includes(r.dagMode) ? "fx" : "fy";
      r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(d) {
        return d[c] = u(d);
      });
    }
    r.forceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? BR(function(d) {
      var p = n[d[r.nodeId]] || -1;
      return (r.dagMode === "radialin" ? s - p : p) * a;
    }).strength(function(d) {
      return r.dagNodeFilter(d) ? 1 : 0;
    }) : null);
    for (var h = 0; h < r.warmupTicks && !(r.d3AlphaMin > 0 && r.forceLayout.alpha() < r.d3AlphaMin); h++)
      r.forceLayout.tick();
    this.resetCountdown(), r.onFinishUpdate();
  }
});
function rI(r, e) {
  var i = r instanceof Array ? r : [r], n = new e();
  return n._destructor && n._destructor(), {
    linkProp: function(s) {
      return {
        default: n[s](),
        onChange: function(a, o) {
          i.forEach(function(l) {
            return o[l][s](a);
          });
        },
        triggerUpdate: !1
      };
    },
    linkMethod: function(s) {
      return function(a) {
        for (var o = arguments.length, l = new Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)
          l[u - 1] = arguments[u];
        var c = [];
        return i.forEach(function(h) {
          var d = a[h], p = d[s].apply(d, l);
          p !== d && c.push(p);
        }), c.length ? c[0] : this;
      };
    }
  };
}
var qse = 800, Xse = 4, Yse = 5, nI = rI("forceGraph", Jm), $se = rI(["forceGraph", "shadowGraph"], Jm), Kse = Object.assign.apply(Object, Sn(["nodeColor", "nodeAutoColorBy", "nodeCanvasObject", "nodeCanvasObjectMode", "linkColor", "linkAutoColorBy", "linkLineDash", "linkWidth", "linkCanvasObject", "linkCanvasObjectMode", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(r) {
  return Od({}, r, nI.linkProp(r));
})).concat(Sn(["nodeRelSize", "nodeId", "nodeVal", "nodeVisibility", "linkSource", "linkTarget", "linkVisibility", "linkCurvature"].map(function(r) {
  return Od({}, r, $se.linkProp(r));
})))), Qse = Object.assign.apply(Object, Sn(["d3Force", "d3ReheatSimulation", "emitParticle"].map(function(r) {
  return Od({}, r, nI.linkMethod(r));
})));
function Cv(r) {
  if (r.canvas) {
    var e = r.canvas.width, i = r.canvas.height;
    e === 300 && i === 150 && (e = i = 0);
    var n = window.devicePixelRatio;
    e /= n, i /= n, [r.canvas, r.shadowCanvas].forEach(function(a) {
      a.style.width = "".concat(r.width, "px"), a.style.height = "".concat(r.height, "px"), a.width = r.width * n, a.height = r.height * n, !e && !i && a.getContext("2d").scale(n, n);
    });
    var s = us(r.canvas).k;
    r.zoom.translateBy(r.zoom.__baseElem, (r.width - e) / 2 / s, (r.height - i) / 2 / s), r.needsRedraw = !0;
  }
}
function sI(r) {
  var e = window.devicePixelRatio;
  r.setTransform(e, 0, 0, e, 0, 0);
}
function jA(r, e, i) {
  r.save(), sI(r), r.clearRect(0, 0, e, i), r.restore();
}
var Zse = Il({
  props: Cu({
    width: {
      default: window.innerWidth,
      onChange: function(r, e) {
        return Cv(e);
      },
      triggerUpdate: !1
    },
    height: {
      default: window.innerHeight,
      onChange: function(r, e) {
        return Cv(e);
      },
      triggerUpdate: !1
    },
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        [r.nodes, r.links].every(function(n) {
          return (n || []).every(function(s) {
            return !s.hasOwnProperty("__indexColor");
          });
        }) && e.colorTracker.reset(), [{
          type: "Node",
          objs: r.nodes
        }, {
          type: "Link",
          objs: r.links
        }].forEach(i), e.forceGraph.graphData(r), e.shadowGraph.graphData(r);
        function i(n) {
          var s = n.type, a = n.objs;
          a.filter(function(o) {
            if (!o.hasOwnProperty("__indexColor")) return !0;
            var l = e.colorTracker.lookup(o.__indexColor);
            return !l || !l.hasOwnProperty("d") || l.d !== o;
          }).forEach(function(o) {
            o.__indexColor = e.colorTracker.register({
              type: s,
              d: o
            });
          });
        }
      },
      triggerUpdate: !1
    },
    backgroundColor: {
      onChange: function(r, e) {
        e.canvas && r && (e.canvas.style.background = r);
      },
      triggerUpdate: !1
    },
    nodeLabel: {
      default: "name",
      triggerUpdate: !1
    },
    nodePointerAreaPaint: {
      onChange: function(r, e) {
        e.shadowGraph.nodeCanvasObject(r ? function(i, n, s) {
          return r(i, i.__indexColor, n, s);
        } : null), e.flushShadowCanvas && e.flushShadowCanvas();
      },
      triggerUpdate: !1
    },
    linkPointerAreaPaint: {
      onChange: function(r, e) {
        e.shadowGraph.linkCanvasObject(r ? function(i, n, s) {
          return r(i, i.__indexColor, n, s);
        } : null), e.flushShadowCanvas && e.flushShadowCanvas();
      },
      triggerUpdate: !1
    },
    linkLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkHoverPrecision: {
      default: 4,
      triggerUpdate: !1
    },
    minZoom: {
      default: 0.01,
      onChange: function(r, e) {
        e.zoom.scaleExtent([r, e.zoom.scaleExtent()[1]]);
      },
      triggerUpdate: !1
    },
    maxZoom: {
      default: 1e3,
      onChange: function(r, e) {
        e.zoom.scaleExtent([e.zoom.scaleExtent()[0], r]);
      },
      triggerUpdate: !1
    },
    enableNodeDrag: {
      default: !0,
      triggerUpdate: !1
    },
    enableZoomInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    enablePanInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    enableZoomPanInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    // to be deprecated
    enablePointerInteraction: {
      default: !0,
      onChange: function(r, e) {
        e.hoverObj = null;
      },
      triggerUpdate: !1
    },
    autoPauseRedraw: {
      default: !0,
      triggerUpdate: !1
    },
    onNodeDrag: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeDragEnd: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeClick: {
      triggerUpdate: !1
    },
    onNodeRightClick: {
      triggerUpdate: !1
    },
    onNodeHover: {
      triggerUpdate: !1
    },
    onLinkClick: {
      triggerUpdate: !1
    },
    onLinkRightClick: {
      triggerUpdate: !1
    },
    onLinkHover: {
      triggerUpdate: !1
    },
    onBackgroundClick: {
      triggerUpdate: !1
    },
    onBackgroundRightClick: {
      triggerUpdate: !1
    },
    onZoom: {
      triggerUpdate: !1
    },
    onZoomEnd: {
      triggerUpdate: !1
    },
    onRenderFramePre: {
      triggerUpdate: !1
    },
    onRenderFramePost: {
      triggerUpdate: !1
    }
  }, Kse),
  aliases: {
    // Prop names supported for backwards compatibility
    stopAnimation: "pauseAnimation"
  },
  methods: Cu({
    graph2ScreenCoords: function(r, e, i) {
      var n = us(r.canvas);
      return {
        x: e * n.k + n.x,
        y: i * n.k + n.y
      };
    },
    screen2GraphCoords: function(r, e, i) {
      var n = us(r.canvas);
      return {
        x: (e - n.x) / n.k,
        y: (i - n.y) / n.k
      };
    },
    centerAt: function(r, e, i, n) {
      if (!r.canvas) return null;
      if (e !== void 0 || i !== void 0) {
        var s = Object.assign({}, e !== void 0 ? {
          x: e
        } : {}, i !== void 0 ? {
          y: i
        } : {});
        return n ? r.tweenGroup.add(new $m(a()).to(s, n).easing(_a.Quadratic.Out).onUpdate(o).start()) : o(s), this;
      }
      return a();
      function a() {
        var l = us(r.canvas);
        return {
          x: (r.width / 2 - l.x) / l.k,
          y: (r.height / 2 - l.y) / l.k
        };
      }
      function o(l) {
        var u = l.x, c = l.y;
        r.zoom.translateTo(r.zoom.__baseElem, u === void 0 ? a().x : u, c === void 0 ? a().y : c), r.needsRedraw = !0;
      }
    },
    zoom: function(r, e, i) {
      if (!r.canvas) return null;
      if (e !== void 0)
        return i ? r.tweenGroup.add(new $m({
          k: n()
        }).to({
          k: e
        }, i).easing(_a.Quadratic.Out).onUpdate(function(a) {
          var o = a.k;
          return s(o);
        }).start()) : s(e), this;
      return n();
      function n() {
        return us(r.canvas).k;
      }
      function s(a) {
        r.zoom.scaleTo(r.zoom.__baseElem, a), r.needsRedraw = !0;
      }
    },
    zoomToFit: function(r) {
      for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, n = arguments.length, s = new Array(n > 3 ? n - 3 : 0), a = 3; a < n; a++)
        s[a - 3] = arguments[a];
      var o = this.getGraphBbox.apply(this, s);
      if (o) {
        var l = {
          x: (o.x[0] + o.x[1]) / 2,
          y: (o.y[0] + o.y[1]) / 2
        }, u = Math.max(1e-12, Math.min(1e12, (r.width - i * 2) / (o.x[1] - o.x[0]), (r.height - i * 2) / (o.y[1] - o.y[0])));
        this.centerAt(l.x, l.y, e), this.zoom(u, e);
      }
      return this;
    },
    getGraphBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      }, i = et(r.nodeVal), n = function(a) {
        return Math.sqrt(Math.max(0, i(a) || 1)) * r.nodeRelSize;
      }, s = r.graphData.nodes.filter(e).map(function(a) {
        return {
          x: a.x,
          y: a.y,
          r: n(a)
        };
      });
      return s.length ? {
        x: [zb(s, function(a) {
          return a.x - a.r;
        }), Bb(s, function(a) {
          return a.x + a.r;
        })],
        y: [zb(s, function(a) {
          return a.y - a.r;
        }), Bb(s, function(a) {
          return a.y + a.r;
        })]
      } : null;
    },
    pauseAnimation: function(r) {
      return r.animationFrameRequestId && (cancelAnimationFrame(r.animationFrameRequestId), r.animationFrameRequestId = null), this;
    },
    resumeAnimation: function(r) {
      return r.animationFrameRequestId || this._animationCycle(), this;
    },
    _destructor: function() {
      this.pauseAnimation(), this.graphData({
        nodes: [],
        links: []
      });
    }
  }, Qse),
  stateInit: function() {
    return {
      lastSetZoom: 1,
      zoom: $ne(),
      forceGraph: new Jm(),
      shadowGraph: new Jm().cooldownTicks(0).nodeColor("__indexColor").linkColor("__indexColor").isShadow(!0),
      colorTracker: new dse(),
      // indexed objects for rgb lookup
      tweenGroup: new KT()
    };
  },
  init: function(r, e) {
    var i = this;
    r.innerHTML = "";
    var n = document.createElement("div");
    n.classList.add("force-graph-container"), n.style.position = "relative", r.appendChild(n), e.canvas = document.createElement("canvas"), e.backgroundColor && (e.canvas.style.background = e.backgroundColor), n.appendChild(e.canvas), e.shadowCanvas = document.createElement("canvas");
    var s = e.canvas.getContext("2d"), a = e.shadowCanvas.getContext("2d", {
      willReadFrequently: !0
    }), o = {
      x: -1e12,
      y: -1e12
    }, l = function() {
      var c = null, h = window.devicePixelRatio, d = o.x > 0 && o.y > 0 ? a.getImageData(o.x * h, o.y * h, 1, 1) : null;
      return d && (c = e.colorTracker.lookup(d.data)), c;
    };
    Tn(e.canvas).call(kre().subject(function() {
      if (!e.enableNodeDrag)
        return null;
      var c = l();
      return c && c.type === "Node" ? c.d : null;
    }).on("start", function(c) {
      var h = c.subject;
      h.__initialDragPos = {
        x: h.x,
        y: h.y,
        fx: h.fx,
        fy: h.fy
      }, c.active || (h.fx = h.x, h.fy = h.y), e.canvas.classList.add("grabbable");
    }).on("drag", function(c) {
      var h = c.subject, d = h.__initialDragPos, p = c, f = us(e.canvas).k, m = {
        x: d.x + (p.x - d.x) / f - h.x,
        y: d.y + (p.y - d.y) / f - h.y
      };
      ["x", "y"].forEach(function(v) {
        return h["f".concat(v)] = h[v] = d[v] + (p[v] - d[v]) / f;
      }), !(!h.__dragged && Yse >= Math.sqrt(k8(["x", "y"].map(function(v) {
        return Math.pow(c[v] - d[v], 2);
      })))) && (e.forceGraph.d3AlphaTarget(0.3).resetCountdown(), e.isPointerDragging = !0, h.__dragged = !0, e.onNodeDrag(h, m));
    }).on("end", function(c) {
      var h = c.subject, d = h.__initialDragPos, p = {
        x: h.x - d.x,
        y: h.y - d.y
      };
      d.fx === void 0 && (h.fx = void 0), d.fy === void 0 && (h.fy = void 0), delete h.__initialDragPos, e.forceGraph.d3AlphaTarget() && e.forceGraph.d3AlphaTarget(0).resetCountdown(), e.canvas.classList.remove("grabbable"), e.isPointerDragging = !1, h.__dragged && (delete h.__dragged, e.onNodeDragEnd(h, p));
    })), e.zoom(e.zoom.__baseElem = Tn(e.canvas)), e.zoom.__baseElem.on("dblclick.zoom", null), e.zoom.filter(function(c) {
      return (
        // disable zoom interaction
        !c.button && e.enableZoomPanInteraction && (c.type !== "wheel" || et(e.enableZoomInteraction)(c)) && (c.type === "wheel" || et(e.enablePanInteraction)(c))
      );
    }).on("zoom", function(c) {
      var h = c.transform;
      [s, a].forEach(function(d) {
        sI(d), d.translate(h.x, h.y), d.scale(h.k, h.k);
      }), e.onZoom && e.onZoom(Cu(Cu({}, h), i.centerAt())), e.needsRedraw = !0;
    }).on("end", function(c) {
      return e.onZoomEnd && e.onZoomEnd(Cu(Cu({}, c.transform), i.centerAt()));
    }), Cv(e), e.forceGraph.onNeedsRedraw(function() {
      return e.needsRedraw = !0;
    }).onFinishUpdate(function() {
      us(e.canvas).k === e.lastSetZoom && e.graphData.nodes.length && (e.zoom.scaleTo(e.zoom.__baseElem, e.lastSetZoom = Xse / Math.cbrt(e.graphData.nodes.length)), e.needsRedraw = !0);
    }), e.tooltip = new zO(n), ["pointermove", "pointerdown"].forEach(function(c) {
      return n.addEventListener(c, function(h) {
        c === "pointerdown" && (e.isPointerPressed = !0, e.pointerDownEvent = h), !e.isPointerDragging && h.type === "pointermove" && e.onBackgroundClick && (h.pressure > 0 || e.isPointerPressed) && (h.pointerType !== "touch" || h.movementX === void 0 || [h.movementX, h.movementY].some(function(f) {
          return Math.abs(f) > 1;
        })) && (e.isPointerDragging = !0);
        var d = p(n);
        o.x = h.pageX - d.left, o.y = h.pageY - d.top;
        function p(f) {
          var m = f.getBoundingClientRect(), v = window.pageXOffset || document.documentElement.scrollLeft, y = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: m.top + y,
            left: m.left + v
          };
        }
      }, {
        passive: !0
      });
    }), n.addEventListener("pointerup", function(c) {
      if (e.isPointerPressed = !1, e.isPointerDragging) {
        e.isPointerDragging = !1;
        return;
      }
      var h = [c, e.pointerDownEvent];
      requestAnimationFrame(function() {
        if (c.button === 0)
          if (e.hoverObj) {
            var d = e["on".concat(e.hoverObj.type, "Click")];
            d && d.apply(void 0, [e.hoverObj.d].concat(h));
          } else
            e.onBackgroundClick && e.onBackgroundClick.apply(e, h);
        if (c.button === 2)
          if (e.hoverObj) {
            var p = e["on".concat(e.hoverObj.type, "RightClick")];
            p && p.apply(void 0, [e.hoverObj.d].concat(h));
          } else
            e.onBackgroundRightClick && e.onBackgroundRightClick.apply(e, h);
      });
    }, {
      passive: !0
    }), n.addEventListener("contextmenu", function(c) {
      return !e.onBackgroundRightClick && !e.onNodeRightClick && !e.onLinkRightClick ? !0 : (c.preventDefault(), !1);
    }), e.forceGraph(s), e.shadowGraph(a);
    var u = Qne(function() {
      jA(a, e.width, e.height), e.shadowGraph.linkWidth(function(h) {
        return et(e.linkWidth)(h) + e.linkHoverPrecision;
      });
      var c = us(e.canvas);
      e.shadowGraph.globalScale(c.k).tickFrame();
    }, qse);
    e.flushShadowCanvas = u.flush, (this._animationCycle = function c() {
      var h = !e.autoPauseRedraw || !!e.needsRedraw || e.forceGraph.isEngineRunning() || e.graphData.links.some(function(_) {
        return _.__photons && _.__photons.length;
      });
      if (e.needsRedraw = !1, e.enablePointerInteraction) {
        var d = e.isPointerDragging ? null : l();
        if (d !== e.hoverObj) {
          var p = e.hoverObj, f = p ? p.type : null, m = d ? d.type : null;
          if (f && f !== m) {
            var v = e["on".concat(f, "Hover")];
            v && v(null, p.d);
          }
          if (m) {
            var y = e["on".concat(m, "Hover")];
            y && y(d.d, f === m ? p.d : null);
          }
          e.tooltip.content(d && et(e["".concat(d.type.toLowerCase(), "Label")])(d.d) || null), e.canvas.classList[d && e["on".concat(m, "Click")] || !d && e.onBackgroundClick ? "add" : "remove"]("clickable"), e.hoverObj = d;
        }
        h && u();
      }
      if (h) {
        jA(s, e.width, e.height);
        var g = us(e.canvas).k;
        e.onRenderFramePre && e.onRenderFramePre(s, g), e.forceGraph.globalScale(g).tickFrame(), e.onRenderFramePost && e.onRenderFramePost(s, g);
      }
      e.tweenGroup.update(), e.animationFrameRequestId = requestAnimationFrame(c);
    })();
  },
  update: function(r) {
  }
}), $g = {
  width: re.number,
  height: re.number,
  graphData: re.shape({
    nodes: re.arrayOf(re.object).isRequired,
    links: re.arrayOf(re.object).isRequired
  }),
  backgroundColor: re.string,
  nodeRelSize: re.number,
  nodeId: re.string,
  nodeLabel: re.oneOfType([re.string, re.func]),
  nodeVal: re.oneOfType([re.number, re.string, re.func]),
  nodeVisibility: re.oneOfType([re.bool, re.string, re.func]),
  nodeColor: re.oneOfType([re.string, re.func]),
  nodeAutoColorBy: re.oneOfType([re.string, re.func]),
  onNodeHover: re.func,
  onNodeClick: re.func,
  linkSource: re.string,
  linkTarget: re.string,
  linkLabel: re.oneOfType([re.string, re.func]),
  linkVisibility: re.oneOfType([re.bool, re.string, re.func]),
  linkColor: re.oneOfType([re.string, re.func]),
  linkAutoColorBy: re.oneOfType([re.string, re.func]),
  linkWidth: re.oneOfType([re.number, re.string, re.func]),
  linkCurvature: re.oneOfType([re.number, re.string, re.func]),
  linkDirectionalArrowLength: re.oneOfType([re.number, re.string, re.func]),
  linkDirectionalArrowColor: re.oneOfType([re.string, re.func]),
  linkDirectionalArrowRelPos: re.oneOfType([re.number, re.string, re.func]),
  linkDirectionalParticles: re.oneOfType([re.number, re.string, re.func]),
  linkDirectionalParticleSpeed: re.oneOfType([re.number, re.string, re.func]),
  linkDirectionalParticleWidth: re.oneOfType([re.number, re.string, re.func]),
  linkDirectionalParticleColor: re.oneOfType([re.string, re.func]),
  onLinkHover: re.func,
  onLinkClick: re.func,
  dagMode: re.oneOf(["td", "bu", "lr", "rl", "zin", "zout", "radialin", "radialout"]),
  dagLevelDistance: re.number,
  dagNodeFilter: re.func,
  onDagError: re.func,
  d3AlphaMin: re.number,
  d3AlphaDecay: re.number,
  d3VelocityDecay: re.number,
  warmupTicks: re.number,
  cooldownTicks: re.number,
  cooldownTime: re.number,
  onEngineTick: re.func,
  onEngineStop: re.func,
  getGraphBbox: re.func
}, aI = {
  zoomToFit: re.func,
  onNodeRightClick: re.func,
  onNodeDrag: re.func,
  onNodeDragEnd: re.func,
  onLinkRightClick: re.func,
  linkHoverPrecision: re.number,
  onBackgroundClick: re.func,
  onBackgroundRightClick: re.func,
  enablePointerInteraction: re.bool,
  enableNodeDrag: re.bool
}, aS = {
  showNavInfo: re.bool,
  nodeOpacity: re.number,
  nodeResolution: re.number,
  nodeThreeObject: re.oneOfType([re.object, re.string, re.func]),
  nodeThreeObjectExtend: re.oneOfType([re.bool, re.string, re.func]),
  linkOpacity: re.number,
  linkResolution: re.number,
  linkCurveRotation: re.oneOfType([re.number, re.string, re.func]),
  linkMaterial: re.oneOfType([re.object, re.string, re.func]),
  linkThreeObject: re.oneOfType([re.object, re.string, re.func]),
  linkThreeObjectExtend: re.oneOfType([re.bool, re.string, re.func]),
  linkPositionUpdate: re.func,
  linkDirectionalArrowResolution: re.number,
  linkDirectionalParticleResolution: re.number,
  forceEngine: re.oneOf(["d3", "ngraph"]),
  ngraphPhysics: re.object,
  numDimensions: re.oneOf([1, 2, 3])
}, Jse = Object.assign({}, $g, aI, {
  linkLineDash: re.oneOfType([re.arrayOf(re.number), re.string, re.func]),
  nodeCanvasObjectMode: re.oneOfType([re.string, re.func]),
  nodeCanvasObject: re.func,
  nodePointerAreaPaint: re.func,
  linkCanvasObjectMode: re.oneOfType([re.string, re.func]),
  linkCanvasObject: re.func,
  linkPointerAreaPaint: re.func,
  autoPauseRedraw: re.bool,
  minZoom: re.number,
  maxZoom: re.number,
  enableZoomInteraction: re.oneOfType([re.bool, re.func]),
  enablePanInteraction: re.oneOfType([re.bool, re.func]),
  onZoom: re.func,
  onZoomEnd: re.func,
  onRenderFramePre: re.func,
  onRenderFramePost: re.func
}), eae = Object.assign({}, $g, aI, aS, {
  enableNavigationControls: re.bool,
  controlType: re.oneOf(["trackball", "orbit", "fly"]),
  rendererConfig: re.object,
  extraRenderers: re.arrayOf(re.shape({
    render: re.func.isRequired
  }))
}), tae = Object.assign({}, $g, aS, {
  nodeDesc: re.oneOfType([re.string, re.func]),
  linkDesc: re.oneOfType([re.string, re.func])
}), iae = Object.assign({}, $g, aS, {
  markerAttrs: re.object,
  yOffset: re.number,
  glScale: re.number
});
const oI = fg(p2, {
  methodNames: [
    // bind methods
    "getGraphBbox",
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "refresh"
  ]
});
oI.displayName = "ForceGraphVR";
oI.propTypes = tae;
const lI = fg(T9, {
  methodNames: [
    // bind methods
    "getGraphBbox",
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "refresh"
  ],
  initPropNames: ["markerAttrs"]
});
lI.displayName = "ForceGraphAR";
lI.propTypes = iae;
const oS = fg(Rre, {
  methodNames: [
    // bind methods
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "stopAnimation",
    "pauseAnimation",
    "resumeAnimation",
    "cameraPosition",
    "zoomToFit",
    "getGraphBbox",
    "screen2GraphCoords",
    "graph2ScreenCoords",
    "postProcessingComposer",
    "lights",
    "scene",
    "camera",
    "renderer",
    "controls",
    "refresh"
  ],
  initPropNames: ["controlType", "rendererConfig", "extraRenderers"]
});
oS.displayName = "ForceGraph3D";
oS.propTypes = eae;
const lS = fg(Zse, {
  methodNames: [
    // bind methods
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "stopAnimation",
    "pauseAnimation",
    "resumeAnimation",
    "centerAt",
    "zoom",
    "zoomToFit",
    "getGraphBbox",
    "screen2GraphCoords",
    "graph2ScreenCoords"
  ]
});
lS.displayName = "ForceGraph2D";
lS.propTypes = Jse;
const rae = {
  position: "absolute",
  pointerEvents: "none",
  background: Ei.PREDICATE,
  color: "#fff",
  border: `2px solid ${Ei.PREDICATE}`,
  borderRadius: 8,
  padding: "6px 14px",
  fontSize: 15,
  fontWeight: "bold",
  zIndex: 1e4,
  boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
  whiteSpace: "nowrap",
  maxWidth: 260,
  overflow: "hidden",
  textOverflow: "ellipsis"
}, nae = 16, VA = 32, sae = ({
  graphData: r,
  onNodeClick: e,
  onEngineStop: i,
  fgRef: n,
  tabs: s,
  activeTab: a,
  onTabChange: o,
  children: l,
  drawerOpen: u,
  drawerContent: c,
  onDrawerClose: h,
  sidebarOpen: d,
  sidebarContent: p,
  onSidebarClose: f,
  selectedTriple: m,
  endpoint: v
}) => {
  const y = gr(), [g, _] = ke(null), [x, b] = ke(null), [T, S] = ke({ x: 0, y: 0 }), [w, C] = ke({ width: 100, height: 100 }), [E, A] = ke(/* @__PURE__ */ new Map());
  ni(() => {
    const P = () => {
      y.current && C({
        width: y.current.clientWidth,
        height: y.current.clientHeight
      });
    };
    return P(), window.addEventListener("resize", P), () => window.removeEventListener("resize", P);
  }, []), ni(() => {
    r.nodes.forEach((P) => {
      if (P.image && !E.has(P.image)) {
        const O = new Image();
        O.crossOrigin = "anonymous", O.src = P.image, O.onload = () => {
          A((V) => new Map(V).set(P.image, O)), n.current && n.current.emit("redraw");
        };
      }
    });
  }, [r.nodes]);
  const N = kr(() => {
    _(null), b(null);
  }, []), L = kr((P) => {
    if (y.current) {
      const O = y.current.getBoundingClientRect();
      S({
        x: P.clientX - O.left,
        y: P.clientY - O.top
      });
    }
  }, []), F = kr(() => {
    _(null), b(null);
  }, []), M = () => {
    if (!y.current) return { left: T.x, top: T.y };
    const P = y.current.getBoundingClientRect(), O = 180, V = 36;
    let B = T.x + nae, H = T.y - VA;
    return B + O > P.width && (B = P.width - O - 8), B < 0 && (B = 8), H < 0 && (H = T.y + VA), H + V > P.height && (H = P.height - V - 8), { left: B, top: H };
  };
  return /* @__PURE__ */ I.jsxs(
    "div",
    {
      ref: y,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      onMouseMove: L,
      children: [
        /* @__PURE__ */ I.jsx(
          lS,
          {
            ref: n,
            graphData: r,
            width: w.width,
            height: w.height,
            nodeCanvasObject: (P, O, V) => {
              const B = 44 / V * Math.pow(V, 0.15);
              if (P.type === "object")
                if (P.image) {
                  if (O.save(), O.beginPath(), O.rect(P.x - B / 2, P.y - B / 2, B, B), O.closePath(), O.strokeStyle = P.color, O.lineWidth = 3 / V, O.stroke(), O.clip(), !P.__img) {
                    const H = new window.Image();
                    H.crossOrigin = "anonymous", H.src = P.image, H.onload = () => {
                      P.__imgLoaded = !0, n && n.current && n.current.emit && n.current.emit("redraw");
                    }, P.__img = H, P.__imgLoaded = !1;
                  }
                  P.__imgLoaded ? O.drawImage(
                    P.__img,
                    P.x - B / 2,
                    P.y - B / 2,
                    B,
                    B
                  ) : (O.fillStyle = P.color || "#888", O.fillRect(P.x - B / 2, P.y - B / 2, B, B)), O.restore();
                } else {
                  O.save(), O.beginPath(), O.rect(P.x - B / 2, P.y - B / 2, B, B), O.closePath(), O.fillStyle = P.color + "CC", O.fill(), O.strokeStyle = P.color, O.lineWidth = 3 / V, O.stroke();
                  const H = (P.label || "?").substring(0, 3), U = 20 / V;
                  O.font = `bold ${U}px Sans-Serif`, O.fillStyle = "#fff", O.textAlign = "center", O.textBaseline = "middle", O.fillText(H, P.x, P.y + B * 0.04), O.restore();
                }
              else if (P.image) {
                if (!P.__img) {
                  const H = new window.Image();
                  H.src = P.image, H.onload = () => {
                    P.__imgLoaded = !0, n && n.current && n.current.emit && n.current.emit("redraw");
                  }, P.__img = H, P.__imgLoaded = !1;
                }
                O.save(), O.beginPath(), O.arc(P.x, P.y, B / 2, 0, 2 * Math.PI, !1), O.closePath(), O.lineWidth = 3 / V, O.strokeStyle = P.color, O.stroke(), O.clip(), P.__imgLoaded ? O.drawImage(
                  P.__img,
                  P.x - B / 2,
                  P.y - B / 2,
                  B,
                  B
                ) : (O.fillStyle = P.color || "#888", O.fill()), O.restore();
              } else {
                O.save(), O.beginPath(), O.arc(P.x, P.y, B / 2, 0, 2 * Math.PI, !1), O.closePath(), O.fillStyle = P.color + "CC", O.fill(), O.strokeStyle = P.color, O.lineWidth = 3 / V, O.stroke();
                const H = (P.label || "?").substring(0, 3), U = 20 / V;
                O.font = `bold ${U}px Sans-Serif`, O.fillStyle = "#fff", O.textAlign = "center", O.textBaseline = "middle", O.fillText(H, P.x, P.y + B * 0.04), O.restore();
              }
            },
            nodePointerAreaPaint: (P, O, V, B) => {
              const H = 44 / B * Math.pow(B, 0.15);
              V.fillStyle = O, P.type === "object" ? (V.beginPath(), V.rect(P.x - H / 2, P.y - H / 2, H, H), V.closePath(), V.fill()) : (V.beginPath(), V.arc(P.x, P.y, H / 2, 0, 2 * Math.PI, !1), V.closePath(), V.fill());
            },
            linkColor: () => "rgba(255, 211, 42, 0.15)",
            linkDirectionalParticles: 1,
            linkDirectionalParticleSpeed: 0.01,
            linkDirectionalParticleColor: () => "rgba(255,255,255,0.5)",
            nodeAutoColorBy: "type",
            onNodeClick: e,
            onEngineStop: i,
            onNodeHover: b,
            onLinkHover: _,
            onBackgroundClick: F,
            onZoom: N
          }
        ),
        g && g.label ? /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              ...rae,
              ...M(),
              pointerEvents: "none"
            },
            children: g.label
          }
        ) : x && x.label ? /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: T.x + 18,
              top: T.y - 10,
              background: "#232326",
              color: "#fff",
              border: "1.5px solid #ffd32a",
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 10001,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: x.label
          }
        ) : null,
        m && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: 80,
              right: 30,
              width: 350,
              zIndex: 9999,
              maxHeight: "80vh",
              background: "#18181b",
              borderRadius: "10px",
              border: "3px solid #ffd32a",
              boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
              overflowY: "auto"
            },
            children: /* @__PURE__ */ I.jsx(
              __,
              {
                triple: m,
                endpoint: v,
                onClose: () => e(null)
              }
            )
          }
        ),
        s && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: 0,
              right: 0,
              bottom: 0,
              zIndex: 2e3,
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              gap: 36,
              padding: "0 0 4px 0",
              height: 54
            },
            children: s.map((P) => /* @__PURE__ */ I.jsxs(
              "div",
              {
                style: {
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "center",
                  cursor: "pointer",
                  minWidth: 120
                },
                onClick: () => o(P.key),
                children: [
                  /* @__PURE__ */ I.jsx(
                    "span",
                    {
                      style: {
                        color: a === P.key ? "#ffd32a" : "#fff",
                        fontWeight: a === P.key ? "bold" : "normal",
                        fontSize: 17,
                        letterSpacing: 0.5,
                        padding: "8px 0 2px 0",
                        transition: "color 0.2s, font-weight 0.2s"
                      },
                      children: P.label
                    }
                  ),
                  /* @__PURE__ */ I.jsx(
                    "div",
                    {
                      style: {
                        height: 3,
                        width: "80%",
                        background: a === P.key ? "#ffd32a" : "transparent",
                        borderRadius: 2,
                        transition: "background 0.2s"
                      }
                    }
                  )
                ]
              },
              P.key || "map"
            ))
          }
        ),
        /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: 0,
              right: 0,
              bottom: 0,
              height: u ? "33.33vh" : 0,
              backgroundColor: "#18181b",
              borderTopLeftRadius: 18,
              borderTopRightRadius: 18,
              transition: "height 0.35s cubic-bezier(0.4, 1.3, 0.5, 1)",
              zIndex: 1300,
              boxShadow: "0 -2px 16px rgba(0, 0, 0, 0.18)",
              border: "2px solid #ffd32a",
              overflow: "hidden"
            },
            children: u && /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
              /* @__PURE__ */ I.jsx(
                "button",
                {
                  style: {
                    background: "none",
                    border: "none",
                    color: "#ffd32a",
                    fontSize: 32,
                    position: "absolute",
                    top: 10,
                    right: 18,
                    cursor: "pointer",
                    zIndex: 1302,
                    transition: "color 0.2s"
                  },
                  onClick: h,
                  children: "×"
                }
              ),
              /* @__PURE__ */ I.jsx(
                "div",
                {
                  style: {
                    padding: "48px 24px 24px 24px",
                    overflowY: "auto",
                    height: "100%",
                    color: "#ffd32a"
                  },
                  children: c
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              bottom: 0,
              width: d ? "16.67vw" : 0,
              minWidth: d ? "250px" : 0,
              backgroundColor: "#18181b",
              borderTopRightRadius: 18,
              borderBottomRightRadius: 18,
              transition: "width 0.35s cubic-bezier(0.4, 1.3, 0.5, 1)",
              zIndex: 1300,
              boxShadow: "2px 0 16px rgba(0, 0, 0, 0.18)",
              border: "2px solid #ffd32a",
              overflow: "hidden"
            },
            children: d && /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
              /* @__PURE__ */ I.jsx(
                "button",
                {
                  style: {
                    background: "none",
                    border: "none",
                    color: "#ffd32a",
                    fontSize: 32,
                    position: "absolute",
                    top: 10,
                    right: 18,
                    cursor: "pointer",
                    zIndex: 1302,
                    transition: "color 0.2s"
                  },
                  onClick: f,
                  children: "×"
                }
              ),
              /* @__PURE__ */ I.jsx(
                "div",
                {
                  style: {
                    padding: "48px 24px 24px 24px",
                    overflowY: "auto",
                    height: "100%",
                    color: "#ffd32a"
                  },
                  children: p
                }
              )
            ] })
          }
        ),
        (u || d) && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              inset: 0,
              backgroundColor: "rgba(0, 0, 0, 0.35)",
              zIndex: 1200,
              pointerEvents: "auto"
            },
            onClick: u ? h : f
          }
        ),
        /* @__PURE__ */ I.jsx("div", { style: { position: "relative", zIndex: 2e3 }, children: l })
      ]
    }
  );
};
var aae = typeof window < "u" && window.THREE ? window.THREE : {
  Sprite: R6
};
aae.Sprite;
const oae = ({
  graphData: r,
  onNodeClick: e,
  onEngineStop: i,
  fgRef: n,
  tabs: s,
  activeTab: a,
  onTabChange: o,
  children: l,
  drawerOpen: u,
  drawerContent: c,
  onDrawerClose: h,
  sidebarOpen: d,
  sidebarContent: p,
  onSidebarClose: f,
  selectedTriple: m,
  endpoint: v
}) => {
  const y = gr(), [g, _] = ke({ width: 100, height: 100 }), [x, b] = ke(null), [T, S] = ke(null), [w, C] = ke({ x: 0, y: 0 }), E = gr(/* @__PURE__ */ new Map());
  ni(() => {
    const N = () => {
      y.current && _({
        width: y.current.clientWidth,
        height: y.current.clientHeight
      });
    };
    return N(), window.addEventListener("resize", N), () => window.removeEventListener("resize", N);
  }, []);
  const A = (N) => {
    if (E.current.has(N.id))
      return E.current.get(N.id);
    const L = 128, F = document.createElement("canvas");
    F.width = F.height = L;
    const M = F.getContext("2d");
    if (M.clearRect(0, 0, L, L), N.image) {
      const V = new window.Image();
      V.crossOrigin = "anonymous", V.src = N.image, V.onload = () => {
        if (M.clearRect(0, 0, L, L), N.type === "object") {
          M.fillStyle = Ou(N.type) + "CC", M.fillRect(0, 0, L, L);
          const B = Math.max(L / V.width, L / V.height), H = V.width * B, U = V.height * B;
          M.drawImage(V, L / 2 - H / 2, L / 2 - U / 2, H, U);
        } else {
          M.save(), M.beginPath(), M.arc(L / 2, L / 2, L / 2, 0, 2 * Math.PI), M.closePath(), M.clip(), M.fillStyle = Ou(N.type) + "CC", M.fillRect(0, 0, L, L);
          const B = Math.max(L / V.width, L / V.height), H = V.width * B, U = V.height * B;
          M.drawImage(V, L / 2 - H / 2, L / 2 - U / 2, H, U), M.restore();
        }
        P.needsUpdate = !0, n.current && n.current.emit("redraw");
      };
    } else {
      N.type === "object" ? (M.fillStyle = Ou(N.type) + "CC", M.fillRect(0, 0, L, L)) : (M.save(), M.beginPath(), M.arc(L / 2, L / 2, L / 2, 0, 2 * Math.PI), M.closePath(), M.clip(), M.fillStyle = Ou(N.type) + "CC", M.fillRect(0, 0, L, L), M.restore());
      const V = (N.label || "?").substring(0, 3);
      M.font = "bold 48px Sans-Serif", M.fillStyle = "#fff", M.textAlign = "center", M.textBaseline = "middle", M.fillText(V, L / 2, L / 2 + 6);
    }
    const P = new Cn(F);
    P.needsUpdate = !0;
    const O = new xg({
      map: P,
      transparent: !0
    });
    return E.current.set(N.id, O), O;
  };
  return /* @__PURE__ */ I.jsxs(
    "div",
    {
      ref: y,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      onMouseMove: (N) => {
        if (y.current) {
          const L = y.current.getBoundingClientRect();
          C({
            x: N.clientX - L.left,
            y: N.clientY - L.top
          });
        }
      },
      children: [
        /* @__PURE__ */ I.jsx(
          oS,
          {
            ref: n,
            graphData: r,
            width: g.width,
            height: g.height,
            controlType: "fly",
            backgroundColor: "rgba(0,0,0,0)",
            nodeLabel: "",
            onNodeClick: e,
            linkColor: () => "rgba(255, 211, 42, 0.15)",
            linkDirectionalParticles: 2,
            linkDirectionalParticleSpeed: 25e-4,
            linkDirectionalParticleColor: () => "rgba(255,255,255,0.5)",
            nodeAutoColorBy: "type",
            nodeThreeObject: (N) => {
              const L = new al(), F = A(N);
              let M;
              return N.type === "object" ? M = new Ur(
                new Gd(16, 16),
                F
              ) : M = new Ur(
                new F_(16 / 2, 48),
                F
              ), L.add(M), L;
            },
            onEngineStop: i,
            onNodeHover: b,
            onLinkHover: S,
            onBackgroundClick: () => {
              S(null), b(null);
            },
            onZoom: () => {
              S(null), b(null);
            }
          }
        ),
        m && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: 80,
              right: 30,
              width: 350,
              zIndex: 9999,
              maxHeight: "80vh",
              background: "#18181b",
              borderRadius: "10px",
              border: "3px solid #ffd32a",
              boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
              overflowY: "auto"
            },
            children: /* @__PURE__ */ I.jsx(
              __,
              {
                triple: m,
                endpoint: v,
                onClose: () => e(null)
              }
            )
          }
        ),
        s && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: 0,
              right: 0,
              bottom: 0,
              zIndex: 2e3,
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              gap: 36,
              padding: "0 0 4px 0",
              height: 54
            },
            children: s.map((N) => /* @__PURE__ */ I.jsxs(
              "div",
              {
                style: {
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "center",
                  cursor: "pointer",
                  minWidth: 120
                },
                onClick: () => o(N.key),
                children: [
                  /* @__PURE__ */ I.jsx(
                    "span",
                    {
                      style: {
                        color: a === N.key ? "#ffd32a" : "#fff",
                        fontWeight: a === N.key ? "bold" : "normal",
                        fontSize: 17,
                        letterSpacing: 0.5,
                        padding: "8px 0 2px 0",
                        transition: "color 0.2s, font-weight 0.2s"
                      },
                      children: N.label
                    }
                  ),
                  /* @__PURE__ */ I.jsx(
                    "div",
                    {
                      style: {
                        height: 3,
                        width: "80%",
                        background: a === N.key ? "#ffd32a" : "transparent",
                        borderRadius: 2,
                        transition: "background 0.2s"
                      }
                    }
                  )
                ]
              },
              N.key || "map"
            ))
          }
        ),
        /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: 0,
              right: 0,
              bottom: 0,
              height: u ? "33.33vh" : 0,
              backgroundColor: "#18181b",
              borderTopLeftRadius: 18,
              borderTopRightRadius: 18,
              transition: "height 0.35s cubic-bezier(0.4, 1.3, 0.5, 1)",
              zIndex: 1300,
              boxShadow: "0 -2px 16px rgba(0, 0, 0, 0.18)",
              border: "2px solid #ffd32a",
              overflow: "hidden"
            },
            children: u && /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
              /* @__PURE__ */ I.jsx(
                "button",
                {
                  style: {
                    background: "none",
                    border: "none",
                    color: "#ffd32a",
                    fontSize: 32,
                    position: "absolute",
                    top: 10,
                    right: 18,
                    cursor: "pointer",
                    zIndex: 1302,
                    transition: "color 0.2s"
                  },
                  onClick: h,
                  children: "×"
                }
              ),
              /* @__PURE__ */ I.jsx(
                "div",
                {
                  style: {
                    padding: "48px 24px 24px 24px",
                    overflowY: "auto",
                    height: "100%",
                    color: "#ffd32a"
                  },
                  children: c
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              bottom: 0,
              width: d ? "16.67vw" : 0,
              minWidth: d ? "250px" : 0,
              backgroundColor: "#18181b",
              borderTopRightRadius: 18,
              borderBottomRightRadius: 18,
              transition: "width 0.35s cubic-bezier(0.4, 1.3, 0.5, 1)",
              zIndex: 1300,
              boxShadow: "2px 0 16px rgba(0, 0, 0, 0.18)",
              border: "2px solid #ffd32a",
              overflow: "hidden"
            },
            children: d && /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
              /* @__PURE__ */ I.jsx(
                "button",
                {
                  style: {
                    background: "none",
                    border: "none",
                    color: "#ffd32a",
                    fontSize: 32,
                    position: "absolute",
                    top: 10,
                    right: 18,
                    cursor: "pointer",
                    zIndex: 1302,
                    transition: "color 0.2s"
                  },
                  onClick: f,
                  children: "×"
                }
              ),
              /* @__PURE__ */ I.jsx(
                "div",
                {
                  style: {
                    padding: "48px 24px 24px 24px",
                    overflowY: "auto",
                    height: "100%",
                    color: "#ffd32a"
                  },
                  children: p
                }
              )
            ] })
          }
        ),
        (u || d) && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              inset: 0,
              backgroundColor: "rgba(0, 0, 0, 0.35)",
              zIndex: 1200,
              pointerEvents: "auto"
            },
            onClick: u ? h : f
          }
        ),
        /* @__PURE__ */ I.jsx("div", { style: { position: "relative", zIndex: 2e3 }, children: l }),
        T && T.label ? /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: w.x + 18,
              top: w.y - 10,
              background: Ei.PREDICATE,
              color: "#fff",
              border: `1.5px solid ${Ei.PREDICATE}`,
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 10001,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: T.label
          }
        ) : x && x.label ? /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: w.x + 18,
              top: w.y - 10,
              background: "#232326",
              color: "#fff",
              border: "1.5px solid #ffd32a",
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 10001,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: x.label
          }
        ) : null
      ]
    }
  );
};
var uI = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, GA = Yt.createContext && /* @__PURE__ */ Yt.createContext(uI), lae = ["attr", "size", "title"];
function uae(r, e) {
  if (r == null) return {};
  var i = cae(r, e), n, s;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(r);
    for (s = 0; s < a.length; s++)
      n = a[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (i[n] = r[n]);
  }
  return i;
}
function cae(r, e) {
  if (r == null) return {};
  var i = {};
  for (var n in r)
    if (Object.prototype.hasOwnProperty.call(r, n)) {
      if (e.indexOf(n) >= 0) continue;
      i[n] = r[n];
    }
  return i;
}
function eg() {
  return eg = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n]);
    }
    return r;
  }, eg.apply(this, arguments);
}
function HA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function tg(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? HA(Object(i), !0).forEach(function(n) {
      hae(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : HA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function hae(r, e, i) {
  return e = dae(e), e in r ? Object.defineProperty(r, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = i, r;
}
function dae(r) {
  var e = pae(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function pae(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function cI(r) {
  return r && r.map((e, i) => /* @__PURE__ */ Yt.createElement(e.tag, tg({
    key: i
  }, e.attr), cI(e.child)));
}
function Kg(r) {
  return (e) => /* @__PURE__ */ Yt.createElement(fae, eg({
    attr: tg({}, r.attr)
  }, e), cI(r.child));
}
function fae(r) {
  var e = (i) => {
    var {
      attr: n,
      size: s,
      title: a
    } = r, o = uae(r, lae), l = s || i.size || "1em", u;
    return i.className && (u = i.className), r.className && (u = (u ? u + " " : "") + r.className), /* @__PURE__ */ Yt.createElement("svg", eg({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, i.attr, n, o, {
      className: u,
      style: tg(tg({
        color: r.color || i.color
      }, i.style), r.style),
      height: l,
      width: l,
      xmlns: "http://www.w3.org/2000/svg"
    }), a && /* @__PURE__ */ Yt.createElement("title", null, a), r.children);
  };
  return GA !== void 0 ? /* @__PURE__ */ Yt.createElement(GA.Consumer, null, (i) => e(i)) : e(uI);
}
function mae(r) {
  return Kg({ attr: { viewBox: "0 0 256 256", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M200,154a29.87,29.87,0,0,0-19.5,7.23L154.88,141.3A29.83,29.83,0,0,0,158,128a30.52,30.52,0,0,0-.22-3.6L174,119a30,30,0,1,0-4-15,30.52,30.52,0,0,0,.22,3.6L154,113a29.91,29.91,0,0,0-32.42-14.31l-8.14-18.3a30,30,0,1,0-11,4.88l8.14,18.3A29.92,29.92,0,0,0,102.06,143L74,168a30.08,30.08,0,1,0,8,9L110,152a29.91,29.91,0,0,0,37.47-1.23l25.62,19.93A30,30,0,1,0,200,154Zm0-68a18,18,0,1,1-18,18A18,18,0,0,1,200,86ZM78,56A18,18,0,1,1,96,74,18,18,0,0,1,78,56ZM56,210a18,18,0,1,1,18-18A18,18,0,0,1,56,210Zm72-64a18,18,0,1,1,18-18A18,18,0,0,1,128,146Zm72,56a18,18,0,1,1,18-18A18,18,0,0,1,200,202Z" }, child: [] }] })(r);
}
function gae(r) {
  return Kg({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z" }, child: [] }] })(r);
}
function yae(r) {
  return Kg({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z" }, child: [] }] })(r);
}
function vae(r) {
  return Kg({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z" }, child: [] }] })(r);
}
const WA = {
  background: "#ffd32a",
  color: "#18181b",
  border: "none",
  borderRadius: 12,
  width: 44,
  height: 44,
  fontSize: 22,
  fontWeight: "bold",
  boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
  cursor: "pointer",
  marginBottom: 0,
  marginTop: 0,
  textTransform: "uppercase",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: 0,
  transition: "background 0.2s, color 0.2s, transform 0.1s"
}, bae = {
  background: "#ffe066",
  color: "#18181b",
  transform: "translateY(-2px) scale(1.03)"
}, xae = ({
  onReset: r,
  onBack: e,
  onForward: i,
  canGoBack: n,
  canGoForward: s,
  onMyView: a
}) => {
  const [o, l] = Yt.useState(""), u = (c) => o === c ? { ...WA, ...bae } : WA;
  return /* @__PURE__ */ I.jsxs(
    "div",
    {
      style: {
        position: "absolute",
        top: "18px",
        left: "18px",
        zIndex: 50,
        display: "flex",
        flexDirection: "row",
        gap: "12px",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ I.jsx(
          "button",
          {
            style: u("profile"),
            onClick: a,
            "aria-label": "Profile",
            onMouseEnter: () => l("profile"),
            onMouseLeave: () => l(""),
            children: /* @__PURE__ */ I.jsx(vae, {})
          }
        ),
        /* @__PURE__ */ I.jsx(
          "button",
          {
            style: { ...u("graph"), width: 54 },
            onClick: r,
            "aria-label": "Return to graph",
            onMouseEnter: () => l("graph"),
            onMouseLeave: () => l(""),
            children: /* @__PURE__ */ I.jsx(mae, { size: 28 })
          }
        ),
        /* @__PURE__ */ I.jsx(
          "button",
          {
            style: { ...u("prev"), opacity: n ? 1 : 0.5 },
            onClick: e,
            disabled: !n,
            "aria-label": "Previous",
            onMouseEnter: () => l("prev"),
            onMouseLeave: () => l(""),
            children: /* @__PURE__ */ I.jsx(gae, {})
          }
        ),
        /* @__PURE__ */ I.jsx(
          "button",
          {
            style: { ...u("next"), opacity: s ? 1 : 0.5 },
            onClick: i,
            disabled: !s,
            "aria-label": "Next",
            onMouseEnter: () => l("next"),
            onMouseLeave: () => l(""),
            children: /* @__PURE__ */ I.jsx(yae, {})
          }
        )
      ]
    }
  );
}, _ae = ({ viewMode: r, onViewModeChange: e }) => /* @__PURE__ */ I.jsxs(
  "div",
  {
    className: "agent-navbar",
    style: {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      background: "#18181b",
      border: "2px solid #ffd32a",
      borderRadius: "10px",
      padding: "6px 16px",
      color: "#ffd32a",
      fontWeight: "bold",
      fontSize: "15px",
      boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
    },
    children: [
      /* @__PURE__ */ I.jsx("label", { htmlFor: "viewMode", style: { color: "#ffd32a", marginRight: 8 }, children: "View Mode:" }),
      /* @__PURE__ */ I.jsxs(
        "select",
        {
          id: "viewMode",
          value: r,
          onChange: (i) => e(i.target.value),
          style: {
            background: "#232326",
            color: "#ffd32a",
            border: "1.5px solid #ffd32a",
            borderRadius: 6,
            padding: "4px 10px",
            fontWeight: "bold",
            fontSize: 15,
            outline: "none",
            cursor: "pointer"
          },
          children: [
            /* @__PURE__ */ I.jsx("option", { value: "2D", children: "2D" }),
            /* @__PURE__ */ I.jsx("option", { value: "3D", children: "3D" }),
            /* @__PURE__ */ I.jsx("option", { value: "VR", children: "VR" })
          ]
        }
      )
    ]
  }
), fm = (r) => {
  const e = [], i = [], n = /* @__PURE__ */ new Map();
  return r.forEach(({ subject: s, predicate: a, object: o }) => {
    if (!n.has(s.id)) {
      const l = {
        id: s.id,
        label: s.label,
        image: s.image,
        isTriple: !1,
        color: Ou("subject"),
        type: "subject"
      };
      n.set(s.id, l), e.push(l);
    }
    if (!n.has(o.id)) {
      const l = {
        id: o.id,
        label: o.label,
        image: o.image,
        isTriple: !1,
        color: Ou("object"),
        type: "object"
      };
      n.set(o.id, l), e.push(l);
    }
    i.push({
      source: s.id,
      target: o.id,
      type: "subject-to-object",
      label: a.label,
      predicateId: a.id
    });
  }), { nodes: e, links: i };
}, Tae = "0x5dc0a2335c12343d8e0f71b62a73fbf70d06fcbaf647f57d82a189873ad90da3", Sae = (r, e = "base") => {
  const [i, n] = ke({ nodes: [], links: [] }), [s, a] = ke(null), [o, l] = ke(!0), [u, c] = ke(null), [h, d] = ke(!1), [p, f] = ke([]), [m, v] = ke(0), y = gr(null), [g, _] = ke(""), [x, b] = ke(""), [T, S] = ke(""), [w, C] = ke(!1), [E, A] = ke(!1), N = kr(async () => {
    d(!0);
    try {
      let B;
      e === "agent" ? B = await kU(Tae, r) : B = await x_(r);
      const H = fm(B);
      n(H), a(H);
    } catch (B) {
      console.error("Error loading graph data:", B);
    } finally {
      d(!1);
    }
  }, [r, e]), L = kr(() => {
    n(s), c(null), _(""), b(""), S(""), A(!1);
  }, [s]), F = kr(
    async (B, H, U) => {
      if (B === null) {
        c(null);
        return;
      }
      if (c(B), H && H.current)
        try {
          const j = {
            x: B.x,
            y: B.y,
            z: B.z || 0
          }, Q = await OU(B.id, r), q = fm(Q), G = q.nodes.find((Y) => Y.id === B.id);
          G && (G.x = j.x, G.y = j.y, U === "3D" && (G.z = j.z), G.fx = j.x, G.fy = j.y, U === "3D" && (G.fz = j.z)), f((Y) => {
            const ae = Y.slice(
              0,
              m + 1
            );
            return ae.push({ graphData: i, selectedTriple: B }), ae;
          }), v((Y) => Y + 1), n(q);
        } catch (j) {
          console.error("Error fetching triples:", j);
        }
    },
    [r, i, m]
  ), M = kr((B, H) => {
    switch (y.current && clearTimeout(y.current), B) {
      case "subject":
        _(H);
        break;
      case "predicate":
        b(H);
        break;
      case "object":
        S(H);
        break;
    }
    y.current = setTimeout(() => {
      A(!0);
    }, 500);
  }, []), P = kr(async () => {
    if (E) {
      if (!g && !x && !T) {
        L();
        return;
      }
      C(!0);
      try {
        const B = await Iu({
          subject: g,
          predicate: x,
          object: T
        }, r);
        if (!B || B.length === 0) {
          n({ nodes: [], links: [] });
          return;
        }
        const H = fm(B);
        n(H), f((U) => {
          const j = U.slice(0, m + 1);
          return j.push({ graphData: H, selectedTriple: null }), j;
        }), v((U) => U + 1);
      } catch (B) {
        console.error("Error searching triples:", B);
      } finally {
        C(!1), A(!1);
      }
    }
  }, [
    g,
    x,
    T,
    r,
    L,
    m,
    E
  ]), O = kr(() => {
    if (m > 0) {
      const { graphData: B, selectedTriple: H } = p[m - 1];
      n(B), c(H), v((U) => U - 1);
    }
  }, [m, p]), V = kr(() => {
    if (m < p.length - 1) {
      const { graphData: B, selectedTriple: H } = p[m + 1];
      n(B), c(H), v((U) => U + 1);
    }
  }, [m, p]);
  return {
    graphData: i,
    initialGraphData: s,
    isInitialLoad: o,
    selectedTriple: u,
    isLoading: h,
    isSearching: w,
    subjectFilter: g,
    predicateFilter: x,
    objectFilter: T,
    shouldSearch: E,
    canGoBack: m > 0,
    canGoForward: m < p.length - 1,
    setSelectedTriple: c,
    setIsInitialLoad: l,
    loadInitialData: N,
    resetGraph: L,
    handleNodeClick: F,
    handleFilterChange: M,
    applyFilters: P,
    goBack: O,
    goForward: V,
    setGraphData: n,
    graphHistory: p,
    setGraphHistory: f,
    currentHistoryIndex: m,
    setCurrentHistoryIndex: v
  };
};
function wae({ open: r, onClose: e, children: i, height: n = 400 }) {
  return ni(() => (r ? document.body.style.overflow = "hidden" : document.body.style.overflow = "", () => {
    document.body.style.overflow = "";
  }), [r]), /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
    /* @__PURE__ */ I.jsx(
      "div",
      {
        className: `drawer-backdrop${r ? " open" : ""}`,
        onClick: e,
        "aria-hidden": !r
      }
    ),
    /* @__PURE__ */ I.jsxs(
      "div",
      {
        className: `drawer-panel${r ? " open" : ""}`,
        style: { height: n },
        role: "dialog",
        "aria-modal": "true",
        children: [
          /* @__PURE__ */ I.jsx(
            "button",
            {
              className: "drawer-close-btn",
              onClick: e,
              "aria-label": "Close",
              children: "×"
            }
          ),
          /* @__PURE__ */ I.jsx("div", { className: "drawer-content", children: i })
        ]
      }
    )
  ] });
}
function Eae({
  open: r,
  onClose: e,
  children: i,
  width: n = 350
}) {
  return ni(() => (r ? document.body.style.overflow = "hidden" : document.body.style.overflow = "", () => {
    document.body.style.overflow = "";
  }), [r]), /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
    /* @__PURE__ */ I.jsx(
      "div",
      {
        className: `drawer-backdrop${r ? " open" : ""}`,
        onClick: e,
        "aria-hidden": !r
      }
    ),
    /* @__PURE__ */ I.jsxs(
      "div",
      {
        className: `sidebar-drawer-panel${r ? " open" : ""}`,
        style: { width: n },
        role: "dialog",
        "aria-modal": "true",
        children: [
          /* @__PURE__ */ I.jsx(
            "button",
            {
              className: "drawer-close-btn",
              onClick: e,
              "aria-label": "Close",
              children: "×"
            }
          ),
          /* @__PURE__ */ I.jsx("div", { className: "drawer-content", children: i })
        ]
      }
    )
  ] });
}
const Mae = ({ claim: r }) => /* @__PURE__ */ I.jsxs(
  "div",
  {
    style: {
      background: "#232326",
      borderRadius: 14,
      padding: "18px 24px",
      marginBottom: 18,
      boxShadow: "0 2px 12px rgba(0,0,0,0.13)",
      display: "flex",
      alignItems: "center",
      gap: 18,
      borderLeft: "6px solid #ffd32a",
      transition: "box-shadow 0.2s, border-color 0.2s",
      position: "relative"
    },
    className: "claim-card",
    children: [
      /* @__PURE__ */ I.jsx("div", { style: { flex: 1 }, children: /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", gap: 10, marginBottom: 8 }, children: [
        /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: 700 }, children: "Subject:" }),
        /* @__PURE__ */ I.jsx("span", { style: { color: "#fff" }, children: r.subject.label }),
        /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: 700, marginLeft: 12 }, children: "Predicate:" }),
        /* @__PURE__ */ I.jsx("span", { style: { color: "#fff" }, children: r.predicate.label }),
        /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: 700, marginLeft: 12 }, children: "Object:" }),
        /* @__PURE__ */ I.jsx("span", { style: { color: "#fff" }, children: r.object.label })
      ] }) }),
      /* @__PURE__ */ I.jsx(
        "button",
        {
          style: {
            background: "#ffd32a",
            color: "#18181b",
            border: "none",
            borderRadius: 8,
            padding: "8px 18px",
            fontWeight: "bold",
            cursor: "pointer",
            transition: "background 0.2s, color 0.2s, transform 0.1s",
            boxShadow: "0 2px 8px rgba(0,0,0,0.10)"
          },
          onMouseEnter: (e) => e.currentTarget.style.background = "#ffe066",
          onMouseLeave: (e) => e.currentTarget.style.background = "#ffd32a",
          onClick: () => alert("Action à définir"),
          children: "Action"
        }
      )
    ]
  }
), sn = ({ label: r, value: e }) => /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", gap: 8, marginBottom: 4 }, children: [
  /* @__PURE__ */ I.jsxs("span", { style: { color: "#ffd32a", fontWeight: 700, minWidth: 90 }, children: [
    r,
    ":"
  ] }),
  /* @__PURE__ */ I.jsx("span", { style: { color: "#fff" }, children: e })
] }), qA = ({ src: r, alt: e }) => r ? /* @__PURE__ */ I.jsx(
  "img",
  {
    src: r,
    alt: e,
    style: {
      width: 48,
      height: 48,
      borderRadius: "50%",
      objectFit: "cover",
      boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
      marginRight: 10
    }
  }
) : null, Aae = ({ position: r }) => {
  var e, i, n, s, a;
  const o = Number(((e = r.term) == null ? void 0 : e.total_market_cap) || 0), l = Number(r.shares || 0), u = Number(((i = r.term) == null ? void 0 : i.current_share_price) || 0), c = r.account, h = r.term, d = h == null ? void 0 : h.triple, p = h == null ? void 0 : h.atom;
  return /* @__PURE__ */ I.jsxs(
    "div",
    {
      style: {
        background: "#232326",
        borderRadius: 14,
        padding: "18px 24px",
        marginBottom: 18,
        boxShadow: "0 2px 12px rgba(0,0,0,0.13)",
        borderLeft: "6px solid #ffd32a",
        position: "relative",
        display: "flex",
        flexDirection: "column",
        gap: 10
      },
      className: "position-card",
      children: [
        /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", marginBottom: 10 }, children: [
          /* @__PURE__ */ I.jsx(qA, { src: c == null ? void 0 : c.image, alt: c == null ? void 0 : c.label }),
          /* @__PURE__ */ I.jsxs("div", { children: [
            /* @__PURE__ */ I.jsx(sn, { label: "Account", value: (c == null ? void 0 : c.label) || (c == null ? void 0 : c.id) }),
            /* @__PURE__ */ I.jsx(sn, { label: "Type", value: c == null ? void 0 : c.type })
          ] })
        ] }),
        /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", marginBottom: 10 }, children: [
          /* @__PURE__ */ I.jsx(qA, { src: p == null ? void 0 : p.image, alt: p == null ? void 0 : p.label }),
          /* @__PURE__ */ I.jsxs("div", { children: [
            /* @__PURE__ */ I.jsx(sn, { label: "Vault", value: h == null ? void 0 : h.term_id }),
            /* @__PURE__ */ I.jsx(sn, { label: "Atom", value: p == null ? void 0 : p.label })
          ] })
        ] }),
        /* @__PURE__ */ I.jsx(sn, { label: "Position ID", value: r.id }),
        /* @__PURE__ */ I.jsx(sn, { label: "Shares", value: l }),
        /* @__PURE__ */ I.jsx(sn, { label: "Vault Shares", value: o }),
        /* @__PURE__ */ I.jsx(sn, { label: "Share Price", value: u }),
        d && /* @__PURE__ */ I.jsxs(
          "div",
          {
            style: {
              marginTop: 10,
              padding: 10,
              background: "#18181b",
              borderRadius: 8
            },
            children: [
              /* @__PURE__ */ I.jsx("div", { style: { color: "#ffd32a", fontWeight: 700, marginBottom: 6 }, children: "Triple" }),
              /* @__PURE__ */ I.jsx(sn, { label: "Block", value: d.block_number }),
              /* @__PURE__ */ I.jsx(sn, { label: "Tx Hash", value: d.transaction_hash }),
              /* @__PURE__ */ I.jsx(sn, { label: "Subject", value: (n = d.subject) == null ? void 0 : n.label }),
              /* @__PURE__ */ I.jsx(sn, { label: "Predicate", value: (s = d.predicate) == null ? void 0 : s.label }),
              /* @__PURE__ */ I.jsx(sn, { label: "Object", value: (a = d.object) == null ? void 0 : a.label })
            ]
          }
        )
      ]
    }
  );
}, Dr = ({ label: r, value: e }) => /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", gap: 8, marginBottom: 4 }, children: [
  /* @__PURE__ */ I.jsxs("span", { style: { color: "#ffd32a", fontWeight: 700, minWidth: 110 }, children: [
    r,
    ":"
  ] }),
  /* @__PURE__ */ I.jsx("span", { style: { color: "#fff" }, children: e })
] }), XA = ({ src: r, alt: e }) => r ? /* @__PURE__ */ I.jsx(
  "img",
  {
    src: r,
    alt: e,
    style: {
      width: 48,
      height: 48,
      borderRadius: "50%",
      objectFit: "cover",
      boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
      marginRight: 10
    }
  }
) : null, Rv = ({ value: r }) => {
  if (!r) return null;
  const { person: e, thing: i, organization: n } = r;
  return /* @__PURE__ */ I.jsxs("div", { style: { marginTop: 6, marginBottom: 6 }, children: [
    e && /* @__PURE__ */ I.jsxs("div", { style: { color: "#ffd32a" }, children: [
      /* @__PURE__ */ I.jsx("b", { children: "Person:" }),
      " ",
      e.name,
      " ",
      /* @__PURE__ */ I.jsx("br", {}),
      /* @__PURE__ */ I.jsx("span", { style: { color: "#fff" }, children: e.description }),
      e.url && /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
        /* @__PURE__ */ I.jsx("br", {}),
        /* @__PURE__ */ I.jsx(
          "a",
          {
            href: e.url,
            target: "_blank",
            rel: "noopener noreferrer",
            style: { color: "#ffd32a" },
            children: e.url
          }
        )
      ] })
    ] }),
    i && /* @__PURE__ */ I.jsxs("div", { style: { color: "#ffd32a" }, children: [
      /* @__PURE__ */ I.jsx("b", { children: "Thing:" }),
      " ",
      i.name,
      " ",
      /* @__PURE__ */ I.jsx("br", {}),
      /* @__PURE__ */ I.jsx("span", { style: { color: "#fff" }, children: i.description }),
      i.url && /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
        /* @__PURE__ */ I.jsx("br", {}),
        /* @__PURE__ */ I.jsx(
          "a",
          {
            href: i.url,
            target: "_blank",
            rel: "noopener noreferrer",
            style: { color: "#ffd32a" },
            children: i.url
          }
        )
      ] })
    ] }),
    n && /* @__PURE__ */ I.jsxs("div", { style: { color: "#ffd32a" }, children: [
      /* @__PURE__ */ I.jsx("b", { children: "Organization:" }),
      " ",
      n.name,
      " ",
      /* @__PURE__ */ I.jsx("br", {}),
      /* @__PURE__ */ I.jsx("span", { style: { color: "#fff" }, children: n.description }),
      n.url && /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
        /* @__PURE__ */ I.jsx("br", {}),
        /* @__PURE__ */ I.jsx(
          "a",
          {
            href: n.url,
            target: "_blank",
            rel: "noopener noreferrer",
            style: { color: "#ffd32a" },
            children: n.url
          }
        )
      ] })
    ] })
  ] });
}, Cae = ({ position: r }) => {
  var e, i, n, s, a, o, l, u;
  const c = Number(((e = r.vault) == null ? void 0 : e.total_shares) || 0), h = Number(r.shares || 0), d = Number(((i = r.vault) == null ? void 0 : i.current_share_price) || 0), p = r.account, f = r.vault, m = f == null ? void 0 : f.triple, v = f == null ? void 0 : f.atom;
  return /* @__PURE__ */ I.jsxs(
    "div",
    {
      style: {
        background: "#232326",
        borderRadius: 14,
        padding: "18px 24px",
        marginBottom: 18,
        boxShadow: "0 2px 12px rgba(0,0,0,0.13)",
        borderLeft: "6px solid #ffd32a",
        position: "relative",
        display: "flex",
        flexDirection: "column",
        gap: 10
      },
      className: "activity-card",
      children: [
        /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", marginBottom: 10 }, children: [
          /* @__PURE__ */ I.jsx(XA, { src: p == null ? void 0 : p.image, alt: p == null ? void 0 : p.label }),
          /* @__PURE__ */ I.jsxs("div", { children: [
            /* @__PURE__ */ I.jsx(Dr, { label: "Account", value: (p == null ? void 0 : p.label) || (p == null ? void 0 : p.id) }),
            /* @__PURE__ */ I.jsx(Dr, { label: "Type", value: p == null ? void 0 : p.type })
          ] })
        ] }),
        /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", marginBottom: 10 }, children: [
          /* @__PURE__ */ I.jsx(XA, { src: v == null ? void 0 : v.image, alt: v == null ? void 0 : v.label }),
          /* @__PURE__ */ I.jsxs("div", { children: [
            /* @__PURE__ */ I.jsx(Dr, { label: "Vault", value: f == null ? void 0 : f.id }),
            /* @__PURE__ */ I.jsx(Dr, { label: "Atom", value: v == null ? void 0 : v.label })
          ] })
        ] }),
        /* @__PURE__ */ I.jsx(Dr, { label: "Position ID", value: r.id }),
        /* @__PURE__ */ I.jsx(Dr, { label: "Shares", value: h }),
        /* @__PURE__ */ I.jsx(Dr, { label: "Vault Shares", value: c }),
        /* @__PURE__ */ I.jsx(Dr, { label: "Share Price", value: d }),
        m && /* @__PURE__ */ I.jsxs(
          "div",
          {
            style: {
              marginTop: 10,
              padding: 10,
              background: "#18181b",
              borderRadius: 8
            },
            children: [
              /* @__PURE__ */ I.jsx("div", { style: { color: "#ffd32a", fontWeight: 700, marginBottom: 6 }, children: "Triple" }),
              /* @__PURE__ */ I.jsx(Dr, { label: "Block", value: m.block_number }),
              /* @__PURE__ */ I.jsx(Dr, { label: "Timestamp", value: m.block_timestamp }),
              /* @__PURE__ */ I.jsx(Dr, { label: "Tx Hash", value: m.transaction_hash }),
              /* @__PURE__ */ I.jsx(Dr, { label: "Subject", value: (n = m.subject) == null ? void 0 : n.label }),
              /* @__PURE__ */ I.jsx(Rv, { value: (s = m.subject) == null ? void 0 : s.value }),
              /* @__PURE__ */ I.jsx(Dr, { label: "Predicate", value: (a = m.predicate) == null ? void 0 : a.label }),
              /* @__PURE__ */ I.jsx(Rv, { value: (o = m.predicate) == null ? void 0 : o.value }),
              /* @__PURE__ */ I.jsx(Dr, { label: "Object", value: (l = m.object) == null ? void 0 : l.label }),
              /* @__PURE__ */ I.jsx(Rv, { value: (u = m.object) == null ? void 0 : u.value })
            ]
          }
        )
      ]
    }
  );
};
let kh = {
  endpoint: null,
  data: null,
  timestamp: null
};
const Rae = 15 * 60 * 1e3, Nae = async (r) => {
  const e = Date.now();
  if (kh.data && kh.endpoint === r && e - kh.timestamp < Rae)
    return kh.data;
  const i = await x_(r);
  return kh = {
    endpoint: r,
    data: i,
    timestamp: e
  }, i;
}, Pae = async (r, e = "base", i = 10) => {
  if (!r || r.length < 1)
    return { subjects: [], predicates: [], objects: [], triples: [] };
  const n = r.toLowerCase().trim();
  if (["is", "of", "in", "at", "by", "to"].includes(n))
    try {
      const s = await Iu({ predicate: n }, e);
      if (s && s.length > 0)
        return {
          subjects: [...new Set(s.map((a) => a.subject.label))].slice(0, i),
          predicates: [n],
          objects: [...new Set(s.map((a) => a.object.label))].slice(0, i),
          triples: s.map((a) => ({
            subject: a.subject.label,
            predicate: a.predicate.label,
            object: a.object.label
          })).slice(0, i)
        };
    } catch {
    }
  try {
    const s = (await Nae(e)).filter((f) => n.length <= 3 ? f.subject && f.subject.label && f.subject.label.toLowerCase().indexOf(n) !== -1 || f.predicate && f.predicate.label && f.predicate.label.toLowerCase().indexOf(n) !== -1 || f.object && f.object.label && f.object.label.toLowerCase().indexOf(n) !== -1 : f.subject && f.subject.label && f.subject.label.toLowerCase().includes(n) || f.predicate && f.predicate.label && f.predicate.label.toLowerCase().includes(n) || f.object && f.object.label && f.object.label.toLowerCase().includes(n));
    if (s.length > 0) {
      const f = (x) => {
        if (!x) return 0;
        const b = x.toLowerCase();
        let T = 100 - Math.min(x.length, 50);
        return b.startsWith(n) && (T += 200), b === n && (T += 300), !/^0x[0-9a-f]{8,}$/i.test(b) && !/[0-9a-f]{30,}/i.test(b) && (T += 150), /^[A-Za-z0-9]+ - [A-Za-z0-9 ]+$/.test(x) && (T += 100), T;
      }, m = [...new Set(
        s.filter((x) => x.subject && x.subject.label && x.subject.label.toLowerCase().indexOf(n) !== -1).map((x) => x.subject.label)
      )].sort((x, b) => f(b) - f(x));
      let v = [...new Set(
        s.filter((x) => x.predicate && x.predicate.label && x.predicate.label.toLowerCase().indexOf(n) !== -1).map((x) => x.predicate.label)
      )].sort((x, b) => x.toLowerCase() === n ? -1 : b.toLowerCase() === n ? 1 : f(b) - f(x));
      const y = [...new Set(
        s.filter((x) => x.object && x.object.label && x.object.label.toLowerCase().indexOf(n) !== -1).map((x) => x.object.label)
      )].sort((x, b) => f(b) - f(x)), g = (x) => {
        if (!x) return 0;
        const b = x.subject ? f(x.subject) : 0, T = x.predicate ? f(x.predicate) : 0, S = x.object ? f(x.object) : 0;
        return Math.max(b, T, S);
      }, _ = s.map((x) => ({
        subject: x.subject.label,
        predicate: x.predicate.label,
        object: x.object.label
      })).sort((x, b) => g(b) - g(x)).slice(0, i);
      return {
        subjects: m.slice(0, i),
        predicates: v.slice(0, i),
        objects: y.slice(0, i),
        triples: _
      };
    }
    const a = await Iu({ subject: r }, e), o = await Iu({ predicate: r }, e), l = await Iu({ object: r }, e);
    let u = [...a || []];
    o && o.length > 0 && (u = [...u, ...o.filter(
      (f) => !u.some((m) => m.id === f.id)
    )]), l && l.length > 0 && (u = [...u, ...l.filter(
      (f) => !u.some((m) => m.id === f.id)
    )]);
    const c = [...new Set(
      u.filter((f) => f.subject && f.subject.label).map((f) => f.subject.label).filter((f) => f.toLowerCase().includes(n))
    )], h = [...new Set(
      u.filter((f) => f.predicate && f.predicate.label).map((f) => f.predicate.label).filter((f) => f.toLowerCase().includes(n))
    )], d = [...new Set(
      u.filter((f) => f.object && f.object.label).map((f) => f.object.label).filter((f) => f.toLowerCase().includes(n))
    )], p = u.map((f) => ({
      subject: f.subject.label,
      predicate: f.predicate.label,
      object: f.object.label
    })).slice(0, i);
    return {
      subjects: c.slice(0, i),
      predicates: h.slice(0, i),
      objects: d.slice(0, i),
      triples: p
    };
  } catch {
    return { subjects: [], predicates: [], objects: [], triples: [] };
  }
}, Oae = ({
  endpoint: r,
  onSearch: e,
  isSearching: i,
  onSearchStart: n
}) => {
  const [s, a] = ke(""), [o, l] = ke({
    subjects: [],
    predicates: [],
    objects: [],
    triples: []
  }), [u, c] = ke({
    subject: "",
    predicate: "",
    object: ""
  }), [h, d] = ke(!1), [p, f] = ke(!1), m = gr(null), v = gr(null);
  ni(() => {
    const F = (M) => {
      v.current && !v.current.contains(M.target) && d(!1);
    };
    return document.addEventListener("mousedown", F), () => {
      document.removeEventListener("mousedown", F);
    };
  }, []), ni(() => (s.length >= 2 ? (clearTimeout(m.current), f(!0), d(!0), m.current = setTimeout(async () => {
    try {
      const F = await Pae(s, r);
      l(F), d(!0), f(!1);
    } catch (F) {
      console.error("Error retrieving suggestions:", F), f(!1);
    }
  }, 300)) : (l({
    subjects: [],
    predicates: [],
    objects: [],
    triples: []
  }), d(!1), f(!1)), () => {
    clearTimeout(m.current);
  }), [s, r]);
  const y = (F, M) => {
    c((P) => ({
      ...P,
      [F]: P[F] === M ? "" : M
    }));
  }, g = async () => {
    typeof n == "function" && n();
    try {
      const F = {
        subject: u.subject || "",
        predicate: u.predicate || "",
        object: u.object || ""
      };
      typeof e == "function" && await e(s, F);
    } catch {
    }
  }, _ = u.subject || u.predicate || u.object, x = o.subjects.length > 0 || o.predicates.length > 0 || o.objects.length > 0 || o.triples && o.triples.length > 0, b = {
    container: {
      width: "100%",
      maxWidth: "550px",
      margin: "0 auto",
      position: "relative",
      zIndex: 1e3
    },
    inputWrapper: {
      display: "flex",
      width: "100%",
      boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
      borderRadius: "12px",
      overflow: "hidden",
      backgroundColor: "rgba(30, 30, 40, 0.6)",
      backdropFilter: "blur(5px)",
      border: "1px solid rgba(255, 255, 255, 0.2)"
    },
    input: {
      flex: 1,
      padding: "10px 15px",
      fontSize: "15px",
      border: "none",
      backgroundColor: "transparent",
      color: "white",
      outline: "none",
      fontWeight: "400",
      height: "40px"
    },
    button: {
      padding: "0 22px",
      border: "none",
      cursor: "pointer",
      fontWeight: "bold",
      fontSize: "15px",
      textTransform: "uppercase"
    },
    activeFilters: {
      display: "flex",
      flexWrap: "wrap",
      alignItems: "center",
      marginTop: "12px",
      padding: "8px 12px",
      backgroundColor: "rgba(30, 30, 40, 0.7)",
      borderRadius: "6px",
      border: "1px solid rgba(255, 255, 255, 0.1)",
      backdropFilter: "blur(5px)"
    },
    filtersLabel: {
      fontWeight: "600",
      marginRight: "12px",
      color: "rgba(255, 255, 255, 0.9)",
      fontSize: "13px"
    },
    filtersChips: {
      display: "flex",
      flexWrap: "wrap",
      gap: "6px",
      flex: 1
    },
    filterChip: {
      display: "flex",
      alignItems: "center",
      padding: "3px 8px",
      borderRadius: "16px",
      fontSize: "12px",
      color: "white",
      boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
    },
    subjectChip: {
      backgroundColor: `${Ei.SUBJECT}cc`
    },
    predicateChip: {
      backgroundColor: `${Ei.PREDICATE}cc`
    },
    objectChip: {
      backgroundColor: `${Ei.OBJECT}cc`
    },
    chipButton: {
      background: "none",
      border: "none",
      color: "white",
      marginLeft: "4px",
      cursor: "pointer",
      fontSize: "14px",
      lineHeight: 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "16px",
      height: "16px",
      borderRadius: "50%",
      transition: "background-color 0.2s ease"
    },
    chipButtonHover: {
      backgroundColor: "rgba(255, 255, 255, 0.2)"
    },
    clearButton: {
      padding: "4px 10px",
      backgroundColor: "rgba(255, 70, 70, 0.8)",
      color: "white",
      border: "none",
      borderRadius: "16px",
      cursor: "pointer",
      fontSize: "12px",
      fontWeight: "500",
      boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)",
      transition: "background-color 0.2s ease",
      marginLeft: "auto"
    },
    clearButtonHover: {
      backgroundColor: "rgba(255, 70, 70, 1)"
    },
    suggestionsContainer: {
      position: "absolute",
      top: "calc(100% + 8px)",
      left: 0,
      right: 0,
      backgroundColor: "rgba(25, 25, 35, 0.9)",
      backdropFilter: "blur(10px)",
      border: "1px solid rgba(255, 255, 255, 0.1)",
      borderRadius: "8px",
      maxHeight: "400px",
      overflowY: "auto",
      zIndex: 1001,
      boxShadow: "0 8px 16px rgba(0, 0, 0, 0.3)",
      color: "white"
    },
    suggestionCategory: {
      padding: "14px",
      borderBottom: "1px solid rgba(255, 255, 255, 0.1)"
    },
    categoryHeader: {
      fontWeight: "600",
      marginBottom: "10px",
      color: "rgba(255, 255, 255, 0.8)",
      fontSize: "14px",
      textTransform: "uppercase",
      letterSpacing: "0.5px"
    },
    suggestionList: {
      display: "flex",
      flexWrap: "wrap",
      gap: "8px"
    },
    suggestionItem: {
      padding: "3px 8px",
      borderRadius: "16px",
      backgroundColor: "rgba(255, 255, 255, 0.15)",
      fontSize: "12px",
      cursor: "pointer",
      transition: "all 0.2s ease",
      color: "rgba(255, 255, 255, 0.9)"
    },
    suggestionItemHover: {
      backgroundColor: "rgba(255, 255, 255, 0.25)"
    },
    selectedSuggestion: {
      backgroundColor: "#4A66E8",
      color: "white"
    },
    loadingContainer: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: "25px"
    },
    loader: {
      width: "30px",
      height: "30px",
      border: "3px solid rgba(255,255,255,0.2)",
      borderRadius: "50%",
      borderTop: "3px solid #ffd32a",
      animation: "spin 1s linear infinite"
    },
    noResults: {
      padding: "25px",
      textAlign: "center",
      fontSize: "14px",
      color: "rgba(255,255,255,0.7)"
    },
    tripleSuggestion: {
      padding: "8px 12px",
      borderRadius: "12px",
      fontSize: "13px",
      cursor: "pointer",
      transition: "all 0.2s ease",
      backgroundColor: "rgba(30, 30, 40, 0.55)",
      backdropFilter: "blur(5px)",
      border: "1px solid rgba(255, 255, 255, 0.15)",
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      gap: "6px",
      alignItems: "center",
      justifyContent: "center"
    },
    tripleSuggestionHover: {
      backgroundColor: "rgba(50, 50, 60, 0.65)"
    },
    tripleSubjectPart: {
      color: Ei.SUBJECT,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Ei.SUBJECT}33`
    },
    triplePredicatePart: {
      color: Ei.PREDICATE,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Ei.PREDICATE}33`
    },
    tripleObjectPart: {
      color: Ei.OBJECT,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Ei.OBJECT}33`
    },
    subjectSuggestion: {
      backgroundColor: Ei.SUBJECT,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    },
    predicateSuggestion: {
      backgroundColor: Ei.PREDICATE,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    },
    objectSuggestion: {
      backgroundColor: Ei.OBJECT,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    }
  }, [T, S] = ke(!1), [w, C] = ke(!1), [E, A] = ke(null), [N, L] = ke(null);
  return /* @__PURE__ */ I.jsxs("div", { style: b.container, children: [
    /* @__PURE__ */ I.jsx("style", { children: `
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        ` }),
    /* @__PURE__ */ I.jsxs("div", { style: b.inputWrapper, children: [
      /* @__PURE__ */ I.jsx(
        "input",
        {
          type: "text",
          value: s,
          onChange: (F) => a(F.target.value),
          placeholder: "Search for triples...",
          style: b.input,
          onFocus: () => {
            s.length >= 2 && d(!0);
          }
        }
      ),
      /* @__PURE__ */ I.jsx(
        "button",
        {
          onClick: g,
          disabled: i,
          style: {
            ...b.button,
            backgroundColor: "#ffd32a",
            color: "#18181b",
            height: "40px",
            borderRadius: "0 12px 12px 0",
            boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
            transition: "background 0.2s, color 0.2s, transform 0.1s"
          },
          onMouseEnter: (F) => F.currentTarget.style.backgroundColor = "#ffe066",
          onMouseLeave: (F) => F.currentTarget.style.backgroundColor = "#ffd32a",
          children: i ? "Searching..." : "Search"
        }
      )
    ] }),
    _ && /* @__PURE__ */ I.jsxs("div", { style: b.activeFilters, children: [
      /* @__PURE__ */ I.jsx("div", { style: b.filtersLabel, children: "Active filters:" }),
      /* @__PURE__ */ I.jsxs("div", { style: b.filtersChips, children: [
        u.subject && /* @__PURE__ */ I.jsxs("div", { style: { ...b.filterChip, ...b.subjectChip }, children: [
          /* @__PURE__ */ I.jsxs("span", { children: [
            "Subject: ",
            u.subject
          ] }),
          /* @__PURE__ */ I.jsx(
            "button",
            {
              onClick: () => y("subject", u.subject),
              style: {
                ...b.chipButton,
                ...E === "subject" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => A("subject"),
              onMouseLeave: () => A(null),
              children: "×"
            }
          )
        ] }),
        u.predicate && /* @__PURE__ */ I.jsxs("div", { style: { ...b.filterChip, ...b.predicateChip }, children: [
          /* @__PURE__ */ I.jsxs("span", { children: [
            "Predicate: ",
            u.predicate
          ] }),
          /* @__PURE__ */ I.jsx(
            "button",
            {
              onClick: () => y("predicate", u.predicate),
              style: {
                ...b.chipButton,
                ...E === "predicate" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => A("predicate"),
              onMouseLeave: () => A(null),
              children: "×"
            }
          )
        ] }),
        u.object && /* @__PURE__ */ I.jsxs("div", { style: { ...b.filterChip, ...b.objectChip }, children: [
          /* @__PURE__ */ I.jsxs("span", { children: [
            "Object: ",
            u.object
          ] }),
          /* @__PURE__ */ I.jsx(
            "button",
            {
              onClick: () => y("object", u.object),
              style: {
                ...b.chipButton,
                ...E === "object" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => A("object"),
              onMouseLeave: () => A(null),
              children: "×"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ I.jsx(
        "button",
        {
          onClick: () => c({ subject: "", predicate: "", object: "" }),
          style: {
            ...b.clearButton,
            ...w ? b.clearButtonHover : {}
          },
          onMouseEnter: () => C(!0),
          onMouseLeave: () => C(!1),
          children: "Clear all filters"
        }
      )
    ] }),
    h && /* @__PURE__ */ I.jsxs("div", { style: b.suggestionsContainer, ref: v, children: [
      p && /* @__PURE__ */ I.jsx("div", { style: b.loadingContainer, children: /* @__PURE__ */ I.jsx("div", { style: b.loader }) }),
      !p && !x && s.length >= 2 && /* @__PURE__ */ I.jsxs("div", { style: b.noResults, children: [
        'Aucune suggestion trouvée pour "',
        s,
        '"'
      ] }),
      !p && o.subjects.length > 0 && /* @__PURE__ */ I.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ I.jsx("div", { style: b.categoryHeader, children: "Suggested Subjects" }),
        /* @__PURE__ */ I.jsx("div", { style: b.suggestionList, children: o.subjects.map((F, M) => /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.subjectSuggestion,
              ...N === `subject-${M}` ? b.suggestionItemHover : {},
              ...u.subject === F ? b.selectedSuggestion : {}
            },
            onClick: () => y("subject", F),
            onMouseEnter: () => L(`subject-${M}`),
            onMouseLeave: () => L(null),
            children: F
          },
          `subject-${M}`
        )) })
      ] }),
      !p && o.predicates.length > 0 && /* @__PURE__ */ I.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ I.jsx("div", { style: b.categoryHeader, children: "Suggested Predicates" }),
        /* @__PURE__ */ I.jsx("div", { style: b.suggestionList, children: o.predicates.map((F, M) => /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.predicateSuggestion,
              ...N === `predicate-${M}` ? b.suggestionItemHover : {},
              ...u.predicate === F ? b.selectedSuggestion : {}
            },
            onClick: () => y("predicate", F),
            onMouseEnter: () => L(`predicate-${M}`),
            onMouseLeave: () => L(null),
            children: F
          },
          `predicate-${M}`
        )) })
      ] }),
      !p && o.objects.length > 0 && /* @__PURE__ */ I.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ I.jsx("div", { style: b.categoryHeader, children: "Suggested Objects" }),
        /* @__PURE__ */ I.jsx("div", { style: b.suggestionList, children: o.objects.map((F, M) => /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.objectSuggestion,
              ...N === `object-${M}` ? b.suggestionItemHover : {},
              ...u.object === F ? b.selectedSuggestion : {}
            },
            onClick: () => y("object", F),
            onMouseEnter: () => L(`object-${M}`),
            onMouseLeave: () => L(null),
            children: F
          },
          `object-${M}`
        )) })
      ] }),
      !p && o.triples && o.triples.length > 0 && /* @__PURE__ */ I.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ I.jsx("div", { style: b.categoryHeader, children: "Suggested Triples" }),
        /* @__PURE__ */ I.jsx("div", { style: b.suggestionList, children: o.triples.map((F, M) => /* @__PURE__ */ I.jsxs(
          "div",
          {
            style: {
              ...b.tripleSuggestion,
              ...N === `triple-${M}` ? b.tripleSuggestionHover : {}
            },
            onClick: () => {
              c({
                subject: F.subject,
                predicate: F.predicate,
                object: F.object
              });
            },
            onMouseEnter: () => L(`triple-${M}`),
            onMouseLeave: () => L(null),
            children: [
              /* @__PURE__ */ I.jsx("span", { style: b.tripleSubjectPart, children: F.subject }),
              /* @__PURE__ */ I.jsx("span", { style: b.triplePredicatePart, children: F.predicate }),
              /* @__PURE__ */ I.jsx("span", { style: b.tripleObjectPart, children: F.object })
            ]
          },
          `triple-${M}`
        )) })
      ] })
    ] })
  ] });
}, YA = ({ user: r }) => /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", marginBottom: 8 }, children: [
  r.image && /* @__PURE__ */ I.jsx(
    "img",
    {
      src: r.image,
      alt: r.label,
      style: {
        width: 36,
        height: 36,
        borderRadius: "50%",
        objectFit: "cover",
        marginRight: 10,
        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
      }
    }
  ),
  /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: 600 }, children: r.label || r.id })
] }), Iae = ({ follows: r, followers: e }) => /* @__PURE__ */ I.jsxs("div", { children: [
  /* @__PURE__ */ I.jsx("h3", { style: { color: "#ffd32a" }, children: "Follows" }),
  r.length === 0 ? /* @__PURE__ */ I.jsx("p", { style: { color: "#fff" }, children: "No follows." }) : r.map((i) => /* @__PURE__ */ I.jsx(YA, { user: i.object }, i.object.id)),
  /* @__PURE__ */ I.jsx("h3", { style: { color: "#ffd32a", marginTop: 18 }, children: "Followers" }),
  e.length === 0 ? /* @__PURE__ */ I.jsx("p", { style: { color: "#fff" }, children: "No followers." }) : e.map((i) => {
    const n = {
      label: i.creator_id
    };
    return console.log("�� FollowersCard - userData.label:", n.label), console.log("�� FollowersCard - userData complet:", n), /* @__PURE__ */ I.jsx(YA, { user: n }, i.creator_id);
  })
] }), Dae = ({ endpoint: r, walletAddress: e, onNodeSelect: i, onLoadingChange: n }) => {
  const s = e.toLowerCase(), a = gr(), o = gr(), [l, u] = Yt.useState("2D"), [c, h] = Yt.useState(!1), [d, p] = Yt.useState(!1), [f, m] = Yt.useState(null), [v, y] = Yt.useState(!1), [g, _] = Yt.useState([]), [x, b] = Yt.useState([]), [T, S] = Yt.useState([]), [w, C] = ke(!1), [E, A] = ke(!1), [N, L] = ke(!1), [F, M] = ke(null), [P, O] = Yt.useState("agent"), [V, B] = Yt.useState({
    follows: [],
    followers: []
  }), {
    graphData: H,
    isInitialLoad: U,
    selectedTriple: j,
    isLoading: Q,
    isSearching: q,
    subjectFilter: G,
    predicateFilter: Y,
    objectFilter: ae,
    shouldSearch: ue,
    canGoBack: ge,
    canGoForward: we,
    setIsInitialLoad: Ne,
    loadInitialData: lt,
    resetGraph: be,
    handleNodeClick: vt,
    handleFilterChange: Z,
    applyFilters: Vt,
    goBack: ct,
    goForward: xt,
    setGraphData: it,
    setGraphHistory: Dt,
    currentHistoryIndex: at,
    setCurrentHistoryIndex: z
  } = Sae(r, P), D = N && F ? F : H, le = E || q;
  ni(() => {
    lt();
  }, [lt, P]), ni(() => {
    ue && (L(!1), Vt());
  }, [ue, Vt]);
  const _e = () => {
    U && a.current && Ne(!1);
  };
  Yt.useEffect(() => {
    c && f === "claims" && DU(s, r).then(_);
  }, [c, f, r, s]), Yt.useEffect(() => {
    c && f === "positions" && Hv(s, r).then(b);
  }, [c, f, r, s]), Yt.useEffect(() => {
    c && f === "activity" && Hv(s, r).then(S);
  }, [c, f, r, s]), Yt.useEffect(() => {
    c && f === "connections" && CC("0x8f9b5dc2e7b8bd12f6762c839830672f1d13c08e72b5f09f194cafc153f2df8a", s, r).then(B);
  }, [c, f, r, s]);
  const Ae = async (Fe, Xe) => {
    try {
      A(!0);
      const Ct = {
        subject: Xe.subject || "",
        predicate: Xe.predicate || "",
        object: Xe.object || ""
      }, mt = await Iu(Ct, r);
      if (mt && mt.length > 0) {
        const kt = fm(mt);
        L(!1), it(kt), Dt((J) => {
          const Oe = J.slice(0, at + 1);
          return Oe.push({
            graphData: kt,
            selectedTriple: null,
            filters: Ct
          }), Oe;
        }), z((J) => J + 1);
      } else
        it({ nodes: [], links: [] });
    } catch {
      it({ nodes: [], links: [] });
    } finally {
      A(!1);
    }
  }, xe = () => {
    A(!0);
  }, Qe = () => {
    L(!1), be();
  }, ze = (Fe, Xe) => {
    L(!1), Z(Fe, Xe);
  }, je = () => {
    N && L(!1);
  }, St = [
    { key: null, label: "Map" },
    { key: "connections", label: "Connections" },
    { key: "positions", label: "Positions" },
    { key: "claims", label: "Claims" },
    { key: "activity", label: "Activity" }
  ], Pe = (Fe) => {
    m(Fe), h(!!Fe);
  }, Ye = () => {
    switch (f) {
      case "claims":
        return /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
          /* @__PURE__ */ I.jsx(
            "h2",
            {
              style: {
                fontSize: "2rem",
                fontWeight: "bold",
                color: "#ffd32a",
                marginBottom: 18
              },
              children: "Claims"
            }
          ),
          g.length === 0 ? /* @__PURE__ */ I.jsx("p", { style: { color: "#fff" }, children: "No claims found." }) : /* @__PURE__ */ I.jsx("div", { children: g.map((Fe) => /* @__PURE__ */ I.jsx(Mae, { claim: Fe }, Fe.term_id)) })
        ] });
      case "positions":
        return /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
          /* @__PURE__ */ I.jsx(
            "h2",
            {
              style: {
                fontSize: "2rem",
                fontWeight: "bold",
                color: "#ffd32a",
                marginBottom: 18
              },
              children: "Positions"
            }
          ),
          x.length === 0 ? /* @__PURE__ */ I.jsx("p", { style: { color: "#fff" }, children: "No positions found." }) : /* @__PURE__ */ I.jsx("div", { children: x.map((Fe) => /* @__PURE__ */ I.jsx(Aae, { position: Fe }, Fe.id)) })
        ] });
      case "activity":
        return /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
          /* @__PURE__ */ I.jsx(
            "h2",
            {
              style: {
                fontSize: "2rem",
                fontWeight: "bold",
                color: "#ffd32a",
                marginBottom: 18
              },
              children: "Activity"
            }
          ),
          T.length === 0 ? /* @__PURE__ */ I.jsx("p", { style: { color: "#fff" }, children: "Aucune activité trouvée." }) : /* @__PURE__ */ I.jsx("div", { children: T.map((Fe) => /* @__PURE__ */ I.jsx(Cae, { position: Fe }, Fe.id)) })
        ] });
      case "connections":
        return /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
          /* @__PURE__ */ I.jsx(
            "h2",
            {
              style: {
                fontSize: "2rem",
                fontWeight: "bold",
                color: "#ffd32a",
                marginBottom: 18
              },
              children: "Connections"
            }
          ),
          /* @__PURE__ */ I.jsx(
            Iae,
            {
              follows: V.follows || [],
              followers: V.followers || []
            }
          )
        ] });
      default:
        return null;
    }
  }, ut = () => /* @__PURE__ */ I.jsxs(
    "div",
    {
      style: {
        display: "none",
        alignItems: "center",
        backgroundColor: "#27272a",
        padding: "8px 12px",
        borderRadius: 8,
        marginLeft: 12,
        boxShadow: "0 2px 8px rgba(0,0,0,0.2)"
      },
      children: [
        /* @__PURE__ */ I.jsx("span", { style: { color: "white", marginRight: 10, fontSize: 14 }, children: "Graph Type:" }),
        /* @__PURE__ */ I.jsxs(
          "select",
          {
            value: P,
            onChange: (Fe) => O(Fe.target.value),
            style: {
              backgroundColor: "#3f3f46",
              color: "white",
              border: "none",
              padding: "4px 8px",
              borderRadius: 4,
              cursor: "pointer"
            },
            children: [
              /* @__PURE__ */ I.jsx("option", { value: "base", children: "Base" }),
              /* @__PURE__ */ I.jsx("option", { value: "agent", children: "Agent" })
            ]
          }
        )
      ]
    }
  );
  return /* @__PURE__ */ I.jsxs(
    "div",
    {
      ref: o,
      className: "graph-visualization-container",
      style: {
        position: "relative",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        width: "100%",
        height: "100vh",
        overflow: "hidden"
      },
      children: [
        (Q || le || w) && /* @__PURE__ */ I.jsx(RC, {}),
        /* @__PURE__ */ I.jsx(
          xae,
          {
            onReset: Qe,
            onBack: () => {
              je(), ct();
            },
            onForward: () => {
              je(), xt();
            },
            canGoBack: ge,
            canGoForward: we,
            onMyView: () => {
              p(!0);
            }
          }
        ),
        /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "80px",
              left: "18px",
              zIndex: 50
            },
            children: /* @__PURE__ */ I.jsx(_ae, { viewMode: l, onViewModeChange: u })
          }
        ),
        /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "10px",
              left: "50%",
              transform: "translateX(-50%)",
              zIndex: 1e3,
              width: "550px",
              maxWidth: "calc(100% - 350px)"
            },
            children: /* @__PURE__ */ I.jsx(
              Oae,
              {
                endpoint: r,
                onSearch: Ae,
                isSearching: le,
                onSearchStart: xe
              }
            )
          }
        ),
        /* @__PURE__ */ I.jsxs(
          "div",
          {
            className: "agent-navbar",
            style: {
              position: "absolute",
              top: "10px",
              right: "10px",
              zIndex: 10,
              display: "flex",
              flexDirection: "row",
              alignItems: "center",
              gap: "16px"
            },
            children: [
              /* @__PURE__ */ I.jsx(ut, {}),
              !v && /* @__PURE__ */ I.jsx(
                "button",
                {
                  style: {
                    background: "#ffd32a",
                    color: "#18181b",
                    border: "none",
                    borderRadius: 12,
                    width: 120,
                    height: 40,
                    fontSize: 15,
                    fontWeight: "bold",
                    boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
                    cursor: "pointer",
                    textTransform: "uppercase",
                    marginLeft: 12,
                    transition: "background 0.2s, color 0.2s, transform 0.1s"
                  },
                  onMouseEnter: (Fe) => Fe.currentTarget.style.background = "#ffe066",
                  onMouseLeave: (Fe) => Fe.currentTarget.style.background = "#ffd32a",
                  onClick: () => y((Fe) => !Fe),
                  children: "Filters"
                }
              ),
              v && /* @__PURE__ */ I.jsx(
                "div",
                {
                  style: {
                    marginLeft: 12,
                    display: "flex",
                    alignItems: "center",
                    gap: 16,
                    position: "relative"
                  },
                  children: /* @__PURE__ */ I.jsx(
                    "div",
                    {
                      style: {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "flex-end",
                        position: "relative"
                      },
                      children: /* @__PURE__ */ I.jsx(
                        UU,
                        {
                          subjectFilter: G,
                          predicateFilter: Y,
                          objectFilter: ae,
                          onFilterChange: ze,
                          onReset: Qe,
                          onClose: () => y(!1)
                        }
                      )
                    }
                  )
                }
              )
            ]
          }
        ),
        l === "2D" && /* @__PURE__ */ I.jsx(
          sae,
          {
            graphData: D,
            onNodeClick: (Fe) => {
              je(), vt(Fe, a, l);
            },
            onEngineStop: _e,
            fgRef: a,
            tabs: St,
            activeTab: f,
            onTabChange: Pe,
            drawerOpen: c,
            drawerContent: Ye(),
            onDrawerClose: () => {
              h(!1), m(null);
            },
            sidebarOpen: d,
            sidebarContent: /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
              /* @__PURE__ */ I.jsx("h2", { children: "My Profile" }),
              /* @__PURE__ */ I.jsx("p", { children: "Name: Base User" }),
              /* @__PURE__ */ I.jsx("p", { children: "Email: user@email.com" }),
              /* @__PURE__ */ I.jsx("p", { children: "Role: Player" }),
              /* @__PURE__ */ I.jsx(
                "button",
                {
                  style: {
                    background: "#ffd32a",
                    color: "#18181b",
                    border: "none",
                    borderRadius: 8,
                    padding: "10px 18px",
                    fontWeight: "bold",
                    marginTop: 20,
                    cursor: "pointer"
                  },
                  onClick: () => p(!1),
                  children: "Close"
                }
              )
            ] }),
            onSidebarClose: () => p(!1),
            selectedTriple: j,
            endpoint: r,
            children: /* @__PURE__ */ I.jsx(GS, {})
          }
        ),
        l === "3D" && /* @__PURE__ */ I.jsx(
          oae,
          {
            graphData: D,
            onNodeClick: (Fe) => {
              je(), vt(Fe, a, l);
            },
            onEngineStop: _e,
            fgRef: a,
            tabs: St,
            activeTab: f,
            onTabChange: Pe,
            drawerOpen: c,
            drawerContent: Ye(),
            onDrawerClose: () => {
              h(!1), m(null);
            },
            sidebarOpen: d,
            sidebarContent: /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
              /* @__PURE__ */ I.jsx("h2", { children: "My Profile" }),
              /* @__PURE__ */ I.jsx("p", { children: "Name: Base User" }),
              /* @__PURE__ */ I.jsx("p", { children: "Email: user@email.com" }),
              /* @__PURE__ */ I.jsx("p", { children: "Role: Player" }),
              /* @__PURE__ */ I.jsx(
                "button",
                {
                  style: {
                    background: "#ffd32a",
                    color: "#18181b",
                    border: "none",
                    borderRadius: 8,
                    padding: "10px 18px",
                    fontWeight: "bold",
                    marginTop: 20,
                    cursor: "pointer"
                  },
                  onClick: () => p(!1),
                  children: "Close"
                }
              )
            ] }),
            onSidebarClose: () => p(!1),
            selectedTriple: j,
            endpoint: r,
            children: /* @__PURE__ */ I.jsx(GS, {})
          }
        ),
        l === "VR" && /* @__PURE__ */ I.jsx(
          LU,
          {
            graphData: D,
            onNodeClick: (Fe) => {
              je(), vt(Fe, a, l);
            },
            onBack: () => {
              je(), ct();
            },
            onForward: () => {
              je(), xt();
            },
            selectedTriple: j,
            endpoint: r
          }
        ),
        /* @__PURE__ */ I.jsxs(Eae, { open: d, onClose: () => p(!1), children: [
          /* @__PURE__ */ I.jsx("h2", { children: "My Profile" }),
          /* @__PURE__ */ I.jsx("p", { children: "Name: Base User" }),
          /* @__PURE__ */ I.jsx("p", { children: "Email: user@email.com" }),
          /* @__PURE__ */ I.jsx("p", { children: "Role: Player" }),
          /* @__PURE__ */ I.jsx(
            "button",
            {
              style: {
                background: "#ffd32a",
                color: "#18181b",
                border: "none",
                borderRadius: 8,
                padding: "10px 18px",
                fontWeight: "bold",
                marginTop: 20,
                cursor: "pointer"
              },
              onClick: () => p(!1),
              children: "Close"
            }
          )
        ] }),
        /* @__PURE__ */ I.jsx(
          wae,
          {
            open: !!c,
            onClose: () => {
              h(!1), m(null);
            },
            children: Ye()
          }
        )
      ]
    }
  );
}, kae = ({ walletAddress: r }) => {
  const [e, i] = ke(null), [n, s] = ke("base"), [a, o] = ke(!1);
  return /* @__PURE__ */ ie.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        height: "100%",
        width: "100%",
        position: "relative",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ ie.jsx(
          "div",
          {
            style: {
              position: "relative",
              flex: 1,
              width: "100%",
              height: "100%",
              overflow: "hidden"
            },
            children: /* @__PURE__ */ ie.jsx(
              Dae,
              {
                endpoint: n,
                onNodeSelect: i,
                onLoadingChange: o,
                walletAddress: r
              }
            )
          }
        ),
        a && /* @__PURE__ */ ie.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              zIndex: 2
            },
            children: /* @__PURE__ */ ie.jsx(RC, {})
          }
        )
      ]
    }
  );
};
var Qg = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(r) {
    return this.listeners.add(r), this.onSubscribe(), () => {
      this.listeners.delete(r), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, Lae = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (r, e) => setTimeout(r, e),
  clearTimeout: (r) => clearTimeout(r),
  setInterval: (r, e) => setInterval(r, e),
  clearInterval: (r) => clearInterval(r)
}, hs, ll, r2, Uae = (r2 = class {
  constructor() {
    // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
    // type at app boot; and if we leave that type, then any new timer provider
    // would need to support ReturnType<typeof setTimeout>, which is infeasible.
    //
    // We settle for type safety for the TimeoutProvider type, and accept that
    // this class is unsafe internally to allow for extension.
    zt(this, hs, Lae);
    zt(this, ll, !1);
  }
  setTimeoutProvider(r) {
    process.env.NODE_ENV !== "production" && me(this, ll) && r !== me(this, hs) && console.error(
      "[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.",
      { previous: me(this, hs), provider: r }
    ), gt(this, hs, r), process.env.NODE_ENV !== "production" && gt(this, ll, !1);
  }
  setTimeout(r, e) {
    return process.env.NODE_ENV !== "production" && gt(this, ll, !0), me(this, hs).setTimeout(r, e);
  }
  clearTimeout(r) {
    me(this, hs).clearTimeout(r);
  }
  setInterval(r, e) {
    return process.env.NODE_ENV !== "production" && gt(this, ll, !0), me(this, hs).setInterval(r, e);
  }
  clearInterval(r) {
    me(this, hs).clearInterval(r);
  }
}, hs = new WeakMap(), ll = new WeakMap(), r2), e_ = new Uae();
function Fae(r) {
  setTimeout(r, 0);
}
var Zg = typeof window > "u" || "Deno" in globalThis;
function jn() {
}
function Bae(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function zae(r) {
  return typeof r == "number" && r >= 0 && r !== 1 / 0;
}
function jae(r, e) {
  return Math.max(r + (e || 0) - Date.now(), 0);
}
function t_(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function Vae(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function $A(r, e) {
  const {
    type: i = "all",
    exact: n,
    fetchStatus: s,
    predicate: a,
    queryKey: o,
    stale: l
  } = r;
  if (o) {
    if (n) {
      if (e.queryHash !== uS(o, e.options))
        return !1;
    } else if (!Dd(e.queryKey, o))
      return !1;
  }
  if (i !== "all") {
    const u = e.isActive();
    if (i === "active" && !u || i === "inactive" && u)
      return !1;
  }
  return !(typeof l == "boolean" && e.isStale() !== l || s && s !== e.state.fetchStatus || a && !a(e));
}
function KA(r, e) {
  const { exact: i, status: n, predicate: s, mutationKey: a } = r;
  if (a) {
    if (!e.options.mutationKey)
      return !1;
    if (i) {
      if (Id(e.options.mutationKey) !== Id(a))
        return !1;
    } else if (!Dd(e.options.mutationKey, a))
      return !1;
  }
  return !(n && e.state.status !== n || s && !s(e));
}
function uS(r, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || Id)(r);
}
function Id(r) {
  return JSON.stringify(
    r,
    (e, i) => r_(i) ? Object.keys(i).sort().reduce((n, s) => (n[s] = i[s], n), {}) : i
  );
}
function Dd(r, e) {
  return r === e ? !0 : typeof r != typeof e ? !1 : r && e && typeof r == "object" && typeof e == "object" ? Object.keys(e).every((i) => Dd(r[i], e[i])) : !1;
}
var Gae = Object.prototype.hasOwnProperty;
function i_(r, e) {
  if (r === e)
    return r;
  const i = QA(r) && QA(e);
  if (!i && !(r_(r) && r_(e))) return e;
  const s = (i ? r : Object.keys(r)).length, a = i ? e : Object.keys(e), o = a.length, l = i ? new Array(o) : {};
  let u = 0;
  for (let c = 0; c < o; c++) {
    const h = i ? c : a[c], d = r[h], p = e[h];
    if (d === p) {
      l[h] = d, (i ? c < s : Gae.call(r, h)) && u++;
      continue;
    }
    if (d === null || p === null || typeof d != "object" || typeof p != "object") {
      l[h] = p;
      continue;
    }
    const f = i_(d, p);
    l[h] = f, f === d && u++;
  }
  return s === o && u === s ? r : l;
}
function QA(r) {
  return Array.isArray(r) && r.length === Object.keys(r).length;
}
function r_(r) {
  if (!ZA(r))
    return !1;
  const e = r.constructor;
  if (e === void 0)
    return !0;
  const i = e.prototype;
  return !(!ZA(i) || !i.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(r) !== Object.prototype);
}
function ZA(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
function Hae(r) {
  return new Promise((e) => {
    e_.setTimeout(e, r);
  });
}
function Wae(r, e, i) {
  if (typeof i.structuralSharing == "function")
    return i.structuralSharing(r, e);
  if (i.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return i_(r, e);
      } catch (n) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${i.queryHash}]: ${n}`
        ), n;
      }
    return i_(r, e);
  }
  return e;
}
function qae(r, e, i = 0) {
  const n = [...r, e];
  return i && n.length > i ? n.slice(1) : n;
}
function Xae(r, e, i = 0) {
  const n = [e, ...r];
  return i && n.length > i ? n.slice(0, -1) : n;
}
var ig = Symbol();
function hI(r, e) {
  return process.env.NODE_ENV !== "production" && r.queryFn === ig && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${r.queryHash}'`
  ), !r.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !r.queryFn || r.queryFn === ig ? () => Promise.reject(new Error(`Missing queryFn: '${r.queryHash}'`)) : r.queryFn;
}
var ul, so, rc, n2, Yae = (n2 = class extends Qg {
  constructor() {
    super();
    zt(this, ul);
    zt(this, so);
    zt(this, rc);
    gt(this, rc, (e) => {
      if (!Zg && window.addEventListener) {
        const i = () => e();
        return window.addEventListener("visibilitychange", i, !1), () => {
          window.removeEventListener("visibilitychange", i);
        };
      }
    });
  }
  onSubscribe() {
    me(this, so) || this.setEventListener(me(this, rc));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = me(this, so)) == null || e.call(this), gt(this, so, void 0));
  }
  setEventListener(e) {
    var i;
    gt(this, rc, e), (i = me(this, so)) == null || i.call(this), gt(this, so, e((n) => {
      typeof n == "boolean" ? this.setFocused(n) : this.onFocus();
    }));
  }
  setFocused(e) {
    me(this, ul) !== e && (gt(this, ul, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((i) => {
      i(e);
    });
  }
  isFocused() {
    var e;
    return typeof me(this, ul) == "boolean" ? me(this, ul) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden";
  }
}, ul = new WeakMap(), so = new WeakMap(), rc = new WeakMap(), n2), dI = new Yae();
function $ae() {
  let r, e;
  const i = new Promise((s, a) => {
    r = s, e = a;
  });
  i.status = "pending", i.catch(() => {
  });
  function n(s) {
    Object.assign(i, s), delete i.resolve, delete i.reject;
  }
  return i.resolve = (s) => {
    n({
      status: "fulfilled",
      value: s
    }), r(s);
  }, i.reject = (s) => {
    n({
      status: "rejected",
      reason: s
    }), e(s);
  }, i;
}
var Kae = Fae;
function Qae() {
  let r = [], e = 0, i = (l) => {
    l();
  }, n = (l) => {
    l();
  }, s = Kae;
  const a = (l) => {
    e ? r.push(l) : s(() => {
      i(l);
    });
  }, o = () => {
    const l = r;
    r = [], l.length && s(() => {
      n(() => {
        l.forEach((u) => {
          i(u);
        });
      });
    });
  };
  return {
    batch: (l) => {
      let u;
      e++;
      try {
        u = l();
      } finally {
        e--, e || o();
      }
      return u;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (l) => (...u) => {
      a(() => {
        l(...u);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (l) => {
      i = l;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (l) => {
      n = l;
    },
    setScheduler: (l) => {
      s = l;
    }
  };
}
var Sr = Qae(), nc, ao, sc, s2, Zae = (s2 = class extends Qg {
  constructor() {
    super();
    zt(this, nc, !0);
    zt(this, ao);
    zt(this, sc);
    gt(this, sc, (e) => {
      if (!Zg && window.addEventListener) {
        const i = () => e(!0), n = () => e(!1);
        return window.addEventListener("online", i, !1), window.addEventListener("offline", n, !1), () => {
          window.removeEventListener("online", i), window.removeEventListener("offline", n);
        };
      }
    });
  }
  onSubscribe() {
    me(this, ao) || this.setEventListener(me(this, sc));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = me(this, ao)) == null || e.call(this), gt(this, ao, void 0));
  }
  setEventListener(e) {
    var i;
    gt(this, sc, e), (i = me(this, ao)) == null || i.call(this), gt(this, ao, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    me(this, nc) !== e && (gt(this, nc, e), this.listeners.forEach((n) => {
      n(e);
    }));
  }
  isOnline() {
    return me(this, nc);
  }
}, nc = new WeakMap(), ao = new WeakMap(), sc = new WeakMap(), s2), rg = new Zae();
function Jae(r) {
  return Math.min(1e3 * 2 ** r, 3e4);
}
function pI(r) {
  return (r ?? "online") === "online" ? rg.isOnline() : !0;
}
var n_ = class extends Error {
  constructor(r) {
    super("CancelledError"), this.revert = r == null ? void 0 : r.revert, this.silent = r == null ? void 0 : r.silent;
  }
};
function fI(r) {
  let e = !1, i = 0, n;
  const s = $ae(), a = () => s.status !== "pending", o = (v) => {
    var y;
    if (!a()) {
      const g = new n_(v);
      p(g), (y = r.onCancel) == null || y.call(r, g);
    }
  }, l = () => {
    e = !0;
  }, u = () => {
    e = !1;
  }, c = () => dI.isFocused() && (r.networkMode === "always" || rg.isOnline()) && r.canRun(), h = () => pI(r.networkMode) && r.canRun(), d = (v) => {
    a() || (n == null || n(), s.resolve(v));
  }, p = (v) => {
    a() || (n == null || n(), s.reject(v));
  }, f = () => new Promise((v) => {
    var y;
    n = (g) => {
      (a() || c()) && v(g);
    }, (y = r.onPause) == null || y.call(r);
  }).then(() => {
    var v;
    n = void 0, a() || (v = r.onContinue) == null || v.call(r);
  }), m = () => {
    if (a())
      return;
    let v;
    const y = i === 0 ? r.initialPromise : void 0;
    try {
      v = y ?? r.fn();
    } catch (g) {
      v = Promise.reject(g);
    }
    Promise.resolve(v).then(d).catch((g) => {
      var S;
      if (a())
        return;
      const _ = r.retry ?? (Zg ? 0 : 3), x = r.retryDelay ?? Jae, b = typeof x == "function" ? x(i, g) : x, T = _ === !0 || typeof _ == "number" && i < _ || typeof _ == "function" && _(i, g);
      if (e || !T) {
        p(g);
        return;
      }
      i++, (S = r.onFail) == null || S.call(r, i, g), Hae(b).then(() => c() ? void 0 : f()).then(() => {
        e ? p(g) : m();
      });
    });
  };
  return {
    promise: s,
    status: () => s.status,
    cancel: o,
    continue: () => (n == null || n(), s),
    cancelRetry: l,
    continueRetry: u,
    canStart: h,
    start: () => (h() ? m() : f().then(m), s)
  };
}
var cl, a2, mI = (a2 = class {
  constructor() {
    zt(this, cl);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), zae(this.gcTime) && gt(this, cl, e_.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(r) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      r ?? (Zg ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    me(this, cl) && (e_.clearTimeout(me(this, cl)), gt(this, cl, void 0));
  }
}, cl = new WeakMap(), a2), hl, ac, bn, dl, Xi, kd, pl, Vn, Xs, o2, eoe = (o2 = class extends mI {
  constructor(e) {
    super();
    zt(this, Vn);
    zt(this, hl);
    zt(this, ac);
    zt(this, bn);
    zt(this, dl);
    zt(this, Xi);
    zt(this, kd);
    zt(this, pl);
    gt(this, pl, !1), gt(this, kd, e.defaultOptions), this.setOptions(e.options), this.observers = [], gt(this, dl, e.client), gt(this, bn, me(this, dl).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, gt(this, hl, JA(this.options)), this.state = e.state ?? me(this, hl), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = me(this, Xi)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    if (this.options = { ...me(this, kd), ...e }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const i = JA(this.options);
      i.data !== void 0 && (this.setData(i.data, {
        updatedAt: i.dataUpdatedAt,
        manual: !0
      }), gt(this, hl, i));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && me(this, bn).remove(this);
  }
  setData(e, i) {
    const n = Wae(this.state.data, e, this.options);
    return ar(this, Vn, Xs).call(this, {
      data: n,
      type: "success",
      dataUpdatedAt: i == null ? void 0 : i.updatedAt,
      manual: i == null ? void 0 : i.manual
    }), n;
  }
  setState(e, i) {
    ar(this, Vn, Xs).call(this, { type: "setState", state: e, setStateOptions: i });
  }
  cancel(e) {
    var n, s;
    const i = (n = me(this, Xi)) == null ? void 0 : n.promise;
    return (s = me(this, Xi)) == null || s.cancel(e), i ? i.then(jn).catch(jn) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(me(this, hl));
  }
  isActive() {
    return this.observers.some(
      (e) => Vae(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === ig || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => t_(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !jae(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var i;
    const e = this.observers.find((n) => n.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (i = me(this, Xi)) == null || i.continue();
  }
  onOnline() {
    var i;
    const e = this.observers.find((n) => n.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (i = me(this, Xi)) == null || i.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), me(this, bn).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((i) => i !== e), this.observers.length || (me(this, Xi) && (me(this, pl) ? me(this, Xi).cancel({ revert: !0 }) : me(this, Xi).cancelRetry()), this.scheduleGc()), me(this, bn).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || ar(this, Vn, Xs).call(this, { type: "invalidate" });
  }
  async fetch(e, i) {
    var u, c, h, d, p, f, m, v, y, g, _, x;
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    ((u = me(this, Xi)) == null ? void 0 : u.status()) !== "rejected") {
      if (this.state.data !== void 0 && (i != null && i.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (me(this, Xi))
        return me(this, Xi).continueRetry(), me(this, Xi).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const b = this.observers.find((T) => T.options.queryFn);
      b && this.setOptions(b.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const n = new AbortController(), s = (b) => {
      Object.defineProperty(b, "signal", {
        enumerable: !0,
        get: () => (gt(this, pl, !0), n.signal)
      });
    }, a = () => {
      const b = hI(this.options, i), S = (() => {
        const w = {
          client: me(this, dl),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(w), w;
      })();
      return gt(this, pl, !1), this.options.persister ? this.options.persister(
        b,
        S,
        this
      ) : b(S);
    }, l = (() => {
      const b = {
        fetchOptions: i,
        options: this.options,
        queryKey: this.queryKey,
        client: me(this, dl),
        state: this.state,
        fetchFn: a
      };
      return s(b), b;
    })();
    (c = this.options.behavior) == null || c.onFetch(l, this), gt(this, ac, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((h = l.fetchOptions) == null ? void 0 : h.meta)) && ar(this, Vn, Xs).call(this, { type: "fetch", meta: (d = l.fetchOptions) == null ? void 0 : d.meta }), gt(this, Xi, fI({
      initialPromise: i == null ? void 0 : i.initialPromise,
      fn: l.fetchFn,
      onCancel: (b) => {
        b instanceof n_ && b.revert && this.setState({
          ...me(this, ac),
          fetchStatus: "idle"
        }), n.abort();
      },
      onFail: (b, T) => {
        ar(this, Vn, Xs).call(this, { type: "failed", failureCount: b, error: T });
      },
      onPause: () => {
        ar(this, Vn, Xs).call(this, { type: "pause" });
      },
      onContinue: () => {
        ar(this, Vn, Xs).call(this, { type: "continue" });
      },
      retry: l.options.retry,
      retryDelay: l.options.retryDelay,
      networkMode: l.options.networkMode,
      canRun: () => !0
    }));
    try {
      const b = await me(this, Xi).start();
      if (b === void 0)
        throw process.env.NODE_ENV !== "production" && console.error(
          `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
        ), new Error(`${this.queryHash} data is undefined`);
      return this.setData(b), (f = (p = me(this, bn).config).onSuccess) == null || f.call(p, b, this), (v = (m = me(this, bn).config).onSettled) == null || v.call(
        m,
        b,
        this.state.error,
        this
      ), b;
    } catch (b) {
      if (b instanceof n_) {
        if (b.silent)
          return me(this, Xi).promise;
        if (b.revert) {
          if (this.state.data === void 0)
            throw b;
          return this.state.data;
        }
      }
      throw ar(this, Vn, Xs).call(this, {
        type: "error",
        error: b
      }), (g = (y = me(this, bn).config).onError) == null || g.call(
        y,
        b,
        this
      ), (x = (_ = me(this, bn).config).onSettled) == null || x.call(
        _,
        this.state.data,
        b,
        this
      ), b;
    } finally {
      this.scheduleGc();
    }
  }
}, hl = new WeakMap(), ac = new WeakMap(), bn = new WeakMap(), dl = new WeakMap(), Xi = new WeakMap(), kd = new WeakMap(), pl = new WeakMap(), Vn = new WeakSet(), Xs = function(e) {
  const i = (n) => {
    switch (e.type) {
      case "failed":
        return {
          ...n,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...n,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...n,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...n,
          ...toe(n.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        const s = {
          ...n,
          data: e.data,
          dataUpdateCount: n.dataUpdateCount + 1,
          dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        return gt(this, ac, e.manual ? s : void 0), s;
      case "error":
        const a = e.error;
        return {
          ...n,
          error: a,
          errorUpdateCount: n.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: n.fetchFailureCount + 1,
          fetchFailureReason: a,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...n,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...n,
          ...e.state
        };
    }
  };
  this.state = i(this.state), Sr.batch(() => {
    this.observers.forEach((n) => {
      n.onQueryUpdate();
    }), me(this, bn).notify({ query: this, type: "updated", action: e });
  });
}, o2);
function toe(r, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: pI(e.networkMode) ? "fetching" : "paused",
    ...r === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function JA(r) {
  const e = typeof r.initialData == "function" ? r.initialData() : r.initialData, i = e !== void 0, n = i ? typeof r.initialDataUpdatedAt == "function" ? r.initialDataUpdatedAt() : r.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: i ? n ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: i ? "success" : "pending",
    fetchStatus: "idle"
  };
}
function e2(r) {
  return {
    onFetch: (e, i) => {
      var h, d, p, f, m;
      const n = e.options, s = (p = (d = (h = e.fetchOptions) == null ? void 0 : h.meta) == null ? void 0 : d.fetchMore) == null ? void 0 : p.direction, a = ((f = e.state.data) == null ? void 0 : f.pages) || [], o = ((m = e.state.data) == null ? void 0 : m.pageParams) || [];
      let l = { pages: [], pageParams: [] }, u = 0;
      const c = async () => {
        let v = !1;
        const y = (x) => {
          Object.defineProperty(x, "signal", {
            enumerable: !0,
            get: () => (e.signal.aborted ? v = !0 : e.signal.addEventListener("abort", () => {
              v = !0;
            }), e.signal)
          });
        }, g = hI(e.options, e.fetchOptions), _ = async (x, b, T) => {
          if (v)
            return Promise.reject();
          if (b == null && x.pages.length)
            return Promise.resolve(x);
          const w = (() => {
            const N = {
              client: e.client,
              queryKey: e.queryKey,
              pageParam: b,
              direction: T ? "backward" : "forward",
              meta: e.options.meta
            };
            return y(N), N;
          })(), C = await g(w), { maxPages: E } = e.options, A = T ? Xae : qae;
          return {
            pages: A(x.pages, C, E),
            pageParams: A(x.pageParams, b, E)
          };
        };
        if (s && a.length) {
          const x = s === "backward", b = x ? ioe : t2, T = {
            pages: a,
            pageParams: o
          }, S = b(n, T);
          l = await _(T, S, x);
        } else {
          const x = r ?? a.length;
          do {
            const b = u === 0 ? o[0] ?? n.initialPageParam : t2(n, l);
            if (u > 0 && b == null)
              break;
            l = await _(l, b), u++;
          } while (u < x);
        }
        return l;
      };
      e.options.persister ? e.fetchFn = () => {
        var v, y;
        return (y = (v = e.options).persister) == null ? void 0 : y.call(
          v,
          c,
          {
            client: e.client,
            queryKey: e.queryKey,
            meta: e.options.meta,
            signal: e.signal
          },
          i
        );
      } : e.fetchFn = c;
    }
  };
}
function t2(r, { pages: e, pageParams: i }) {
  const n = e.length - 1;
  return e.length > 0 ? r.getNextPageParam(
    e[n],
    e,
    i[n],
    i
  ) : void 0;
}
function ioe(r, { pages: e, pageParams: i }) {
  var n;
  return e.length > 0 ? (n = r.getPreviousPageParam) == null ? void 0 : n.call(r, e[0], e, i[0], i) : void 0;
}
var ds, _r, fl, ps, Qa, l2, roe = (l2 = class extends mI {
  constructor(e) {
    super();
    zt(this, ps);
    zt(this, ds);
    zt(this, _r);
    zt(this, fl);
    this.mutationId = e.mutationId, gt(this, _r, e.mutationCache), gt(this, ds, []), this.state = e.state || noe(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    me(this, ds).includes(e) || (me(this, ds).push(e), this.clearGcTimeout(), me(this, _r).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    gt(this, ds, me(this, ds).filter((i) => i !== e)), this.scheduleGc(), me(this, _r).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    me(this, ds).length || (this.state.status === "pending" ? this.scheduleGc() : me(this, _r).remove(this));
  }
  continue() {
    var e;
    return ((e = me(this, fl)) == null ? void 0 : e.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    var a, o, l, u, c, h, d, p, f, m, v, y, g, _, x, b, T, S, w, C;
    const i = () => {
      ar(this, ps, Qa).call(this, { type: "continue" });
    };
    gt(this, fl, fI({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (E, A) => {
        ar(this, ps, Qa).call(this, { type: "failed", failureCount: E, error: A });
      },
      onPause: () => {
        ar(this, ps, Qa).call(this, { type: "pause" });
      },
      onContinue: i,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => me(this, _r).canRun(this)
    }));
    const n = this.state.status === "pending", s = !me(this, fl).canStart();
    try {
      if (n)
        i();
      else {
        ar(this, ps, Qa).call(this, { type: "pending", variables: e, isPaused: s }), await ((o = (a = me(this, _r).config).onMutate) == null ? void 0 : o.call(
          a,
          e,
          this
        ));
        const A = await ((u = (l = this.options).onMutate) == null ? void 0 : u.call(l, e));
        A !== this.state.context && ar(this, ps, Qa).call(this, {
          type: "pending",
          context: A,
          variables: e,
          isPaused: s
        });
      }
      const E = await me(this, fl).start();
      return await ((h = (c = me(this, _r).config).onSuccess) == null ? void 0 : h.call(
        c,
        E,
        e,
        this.state.context,
        this
      )), await ((p = (d = this.options).onSuccess) == null ? void 0 : p.call(d, E, e, this.state.context)), await ((m = (f = me(this, _r).config).onSettled) == null ? void 0 : m.call(
        f,
        E,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((y = (v = this.options).onSettled) == null ? void 0 : y.call(v, E, null, e, this.state.context)), ar(this, ps, Qa).call(this, { type: "success", data: E }), E;
    } catch (E) {
      try {
        throw await ((_ = (g = me(this, _r).config).onError) == null ? void 0 : _.call(
          g,
          E,
          e,
          this.state.context,
          this
        )), await ((b = (x = this.options).onError) == null ? void 0 : b.call(
          x,
          E,
          e,
          this.state.context
        )), await ((S = (T = me(this, _r).config).onSettled) == null ? void 0 : S.call(
          T,
          void 0,
          E,
          this.state.variables,
          this.state.context,
          this
        )), await ((C = (w = this.options).onSettled) == null ? void 0 : C.call(
          w,
          void 0,
          E,
          e,
          this.state.context
        )), E;
      } finally {
        ar(this, ps, Qa).call(this, { type: "error", error: E });
      }
    } finally {
      me(this, _r).runNext(this);
    }
  }
}, ds = new WeakMap(), _r = new WeakMap(), fl = new WeakMap(), ps = new WeakSet(), Qa = function(e) {
  const i = (n) => {
    switch (e.type) {
      case "failed":
        return {
          ...n,
          failureCount: e.failureCount,
          failureReason: e.error
        };
      case "pause":
        return {
          ...n,
          isPaused: !0
        };
      case "continue":
        return {
          ...n,
          isPaused: !1
        };
      case "pending":
        return {
          ...n,
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...n,
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...n,
          data: void 0,
          error: e.error,
          failureCount: n.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = i(this.state), Sr.batch(() => {
    me(this, ds).forEach((n) => {
      n.onMutationUpdate(e);
    }), me(this, _r).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, l2);
function noe() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var Js, Gn, Ld, u2, soe = (u2 = class extends Qg {
  constructor(e = {}) {
    super();
    zt(this, Js);
    zt(this, Gn);
    zt(this, Ld);
    this.config = e, gt(this, Js, /* @__PURE__ */ new Set()), gt(this, Gn, /* @__PURE__ */ new Map()), gt(this, Ld, 0);
  }
  build(e, i, n) {
    const s = new roe({
      mutationCache: this,
      mutationId: ++ap(this, Ld)._,
      options: e.defaultMutationOptions(i),
      state: n
    });
    return this.add(s), s;
  }
  add(e) {
    me(this, Js).add(e);
    const i = Uf(e);
    if (typeof i == "string") {
      const n = me(this, Gn).get(i);
      n ? n.push(e) : me(this, Gn).set(i, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (me(this, Js).delete(e)) {
      const i = Uf(e);
      if (typeof i == "string") {
        const n = me(this, Gn).get(i);
        if (n)
          if (n.length > 1) {
            const s = n.indexOf(e);
            s !== -1 && n.splice(s, 1);
          } else n[0] === e && me(this, Gn).delete(i);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const i = Uf(e);
    if (typeof i == "string") {
      const n = me(this, Gn).get(i), s = n == null ? void 0 : n.find(
        (a) => a.state.status === "pending"
      );
      return !s || s === e;
    } else
      return !0;
  }
  runNext(e) {
    var n;
    const i = Uf(e);
    if (typeof i == "string") {
      const s = (n = me(this, Gn).get(i)) == null ? void 0 : n.find((a) => a !== e && a.state.isPaused);
      return (s == null ? void 0 : s.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    Sr.batch(() => {
      me(this, Js).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), me(this, Js).clear(), me(this, Gn).clear();
    });
  }
  getAll() {
    return Array.from(me(this, Js));
  }
  find(e) {
    const i = { exact: !0, ...e };
    return this.getAll().find(
      (n) => KA(i, n)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((i) => KA(e, i));
  }
  notify(e) {
    Sr.batch(() => {
      this.listeners.forEach((i) => {
        i(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((i) => i.state.isPaused);
    return Sr.batch(
      () => Promise.all(
        e.map((i) => i.continue().catch(jn))
      )
    );
  }
}, Js = new WeakMap(), Gn = new WeakMap(), Ld = new WeakMap(), u2);
function Uf(r) {
  var e;
  return (e = r.options.scope) == null ? void 0 : e.id;
}
var fs, c2, aoe = (c2 = class extends Qg {
  constructor(e = {}) {
    super();
    zt(this, fs);
    this.config = e, gt(this, fs, /* @__PURE__ */ new Map());
  }
  build(e, i, n) {
    const s = i.queryKey, a = i.queryHash ?? uS(s, i);
    let o = this.get(a);
    return o || (o = new eoe({
      client: e,
      queryKey: s,
      queryHash: a,
      options: e.defaultQueryOptions(i),
      state: n,
      defaultOptions: e.getQueryDefaults(s)
    }), this.add(o)), o;
  }
  add(e) {
    me(this, fs).has(e.queryHash) || (me(this, fs).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const i = me(this, fs).get(e.queryHash);
    i && (e.destroy(), i === e && me(this, fs).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    Sr.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return me(this, fs).get(e);
  }
  getAll() {
    return [...me(this, fs).values()];
  }
  find(e) {
    const i = { exact: !0, ...e };
    return this.getAll().find(
      (n) => $A(i, n)
    );
  }
  findAll(e = {}) {
    const i = this.getAll();
    return Object.keys(e).length > 0 ? i.filter((n) => $A(e, n)) : i;
  }
  notify(e) {
    Sr.batch(() => {
      this.listeners.forEach((i) => {
        i(e);
      });
    });
  }
  onFocus() {
    Sr.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    Sr.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, fs = new WeakMap(), c2), Si, oo, lo, oc, lc, uo, uc, cc, h2, ooe = (h2 = class {
  constructor(r = {}) {
    zt(this, Si);
    zt(this, oo);
    zt(this, lo);
    zt(this, oc);
    zt(this, lc);
    zt(this, uo);
    zt(this, uc);
    zt(this, cc);
    gt(this, Si, r.queryCache || new aoe()), gt(this, oo, r.mutationCache || new soe()), gt(this, lo, r.defaultOptions || {}), gt(this, oc, /* @__PURE__ */ new Map()), gt(this, lc, /* @__PURE__ */ new Map()), gt(this, uo, 0);
  }
  mount() {
    ap(this, uo)._++, me(this, uo) === 1 && (gt(this, uc, dI.subscribe(async (r) => {
      r && (await this.resumePausedMutations(), me(this, Si).onFocus());
    })), gt(this, cc, rg.subscribe(async (r) => {
      r && (await this.resumePausedMutations(), me(this, Si).onOnline());
    })));
  }
  unmount() {
    var r, e;
    ap(this, uo)._--, me(this, uo) === 0 && ((r = me(this, uc)) == null || r.call(this), gt(this, uc, void 0), (e = me(this, cc)) == null || e.call(this), gt(this, cc, void 0));
  }
  isFetching(r) {
    return me(this, Si).findAll({ ...r, fetchStatus: "fetching" }).length;
  }
  isMutating(r) {
    return me(this, oo).findAll({ ...r, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(r) {
    var i;
    const e = this.defaultQueryOptions({ queryKey: r });
    return (i = me(this, Si).get(e.queryHash)) == null ? void 0 : i.state.data;
  }
  ensureQueryData(r) {
    const e = this.defaultQueryOptions(r), i = me(this, Si).build(this, e), n = i.state.data;
    return n === void 0 ? this.fetchQuery(r) : (r.revalidateIfStale && i.isStaleByTime(t_(e.staleTime, i)) && this.prefetchQuery(e), Promise.resolve(n));
  }
  getQueriesData(r) {
    return me(this, Si).findAll(r).map(({ queryKey: e, state: i }) => {
      const n = i.data;
      return [e, n];
    });
  }
  setQueryData(r, e, i) {
    const n = this.defaultQueryOptions({ queryKey: r }), s = me(this, Si).get(
      n.queryHash
    ), a = s == null ? void 0 : s.state.data, o = Bae(e, a);
    if (o !== void 0)
      return me(this, Si).build(this, n).setData(o, { ...i, manual: !0 });
  }
  setQueriesData(r, e, i) {
    return Sr.batch(
      () => me(this, Si).findAll(r).map(({ queryKey: n }) => [
        n,
        this.setQueryData(n, e, i)
      ])
    );
  }
  getQueryState(r) {
    var i;
    const e = this.defaultQueryOptions({ queryKey: r });
    return (i = me(this, Si).get(
      e.queryHash
    )) == null ? void 0 : i.state;
  }
  removeQueries(r) {
    const e = me(this, Si);
    Sr.batch(() => {
      e.findAll(r).forEach((i) => {
        e.remove(i);
      });
    });
  }
  resetQueries(r, e) {
    const i = me(this, Si);
    return Sr.batch(() => (i.findAll(r).forEach((n) => {
      n.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...r
      },
      e
    )));
  }
  cancelQueries(r, e = {}) {
    const i = { revert: !0, ...e }, n = Sr.batch(
      () => me(this, Si).findAll(r).map((s) => s.cancel(i))
    );
    return Promise.all(n).then(jn).catch(jn);
  }
  invalidateQueries(r, e = {}) {
    return Sr.batch(() => (me(this, Si).findAll(r).forEach((i) => {
      i.invalidate();
    }), (r == null ? void 0 : r.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...r,
        type: (r == null ? void 0 : r.refetchType) ?? (r == null ? void 0 : r.type) ?? "active"
      },
      e
    )));
  }
  refetchQueries(r, e = {}) {
    const i = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, n = Sr.batch(
      () => me(this, Si).findAll(r).filter((s) => !s.isDisabled() && !s.isStatic()).map((s) => {
        let a = s.fetch(void 0, i);
        return i.throwOnError || (a = a.catch(jn)), s.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(n).then(jn);
  }
  fetchQuery(r) {
    const e = this.defaultQueryOptions(r);
    e.retry === void 0 && (e.retry = !1);
    const i = me(this, Si).build(this, e);
    return i.isStaleByTime(
      t_(e.staleTime, i)
    ) ? i.fetch(e) : Promise.resolve(i.state.data);
  }
  prefetchQuery(r) {
    return this.fetchQuery(r).then(jn).catch(jn);
  }
  fetchInfiniteQuery(r) {
    return r.behavior = e2(r.pages), this.fetchQuery(r);
  }
  prefetchInfiniteQuery(r) {
    return this.fetchInfiniteQuery(r).then(jn).catch(jn);
  }
  ensureInfiniteQueryData(r) {
    return r.behavior = e2(r.pages), this.ensureQueryData(r);
  }
  resumePausedMutations() {
    return rg.isOnline() ? me(this, oo).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return me(this, Si);
  }
  getMutationCache() {
    return me(this, oo);
  }
  getDefaultOptions() {
    return me(this, lo);
  }
  setDefaultOptions(r) {
    gt(this, lo, r);
  }
  setQueryDefaults(r, e) {
    me(this, oc).set(Id(r), {
      queryKey: r,
      defaultOptions: e
    });
  }
  getQueryDefaults(r) {
    const e = [...me(this, oc).values()], i = {};
    return e.forEach((n) => {
      Dd(r, n.queryKey) && Object.assign(i, n.defaultOptions);
    }), i;
  }
  setMutationDefaults(r, e) {
    me(this, lc).set(Id(r), {
      mutationKey: r,
      defaultOptions: e
    });
  }
  getMutationDefaults(r) {
    const e = [...me(this, lc).values()], i = {};
    return e.forEach((n) => {
      Dd(r, n.mutationKey) && Object.assign(i, n.defaultOptions);
    }), i;
  }
  defaultQueryOptions(r) {
    if (r._defaulted)
      return r;
    const e = {
      ...me(this, lo).queries,
      ...this.getQueryDefaults(r.queryKey),
      ...r,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = uS(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === ig && (e.enabled = !1), e;
  }
  defaultMutationOptions(r) {
    return r != null && r._defaulted ? r : {
      ...me(this, lo).mutations,
      ...(r == null ? void 0 : r.mutationKey) && this.getMutationDefaults(r.mutationKey),
      ...r,
      _defaulted: !0
    };
  }
  clear() {
    me(this, Si).clear(), me(this, oo).clear();
  }
}, Si = new WeakMap(), oo = new WeakMap(), lo = new WeakMap(), oc = new WeakMap(), lc = new WeakMap(), uo = new WeakMap(), uc = new WeakMap(), cc = new WeakMap(), h2), loe = d2.createContext(
  void 0
), uoe = ({
  client: r,
  children: e
}) => (d2.useEffect(() => (r.mount(), () => {
  r.unmount();
}), [r]), /* @__PURE__ */ ie.jsx(loe.Provider, { value: r, children: e })), coe = "https://prod.base-sepolia.intuition-api.com/v1/graphql", hoe = "https://prod.base-mainnet-v-1-0.intuition.sh/v1/graphql", doe = hoe, i2 = {
  apiUrl: doe
};
function poe(r) {
  i2 = { ...i2, ...r };
}
var $r = /* @__PURE__ */ ((r) => (r.MAINNET = "mainnet", r.TESTNET = "testnet", r))($r || {});
const Wc = {
  mainnet: "https://testnet.intuition.sh/v1/graphql",
  testnet: coe
  // TODO: change to mainnet
}, foe = async (r, e = ii.IS_PLAYER_GAMES.predicateId.toString(), i = ii.IS_PLAYER_GAMES.objectId.toString(), n = $r.MAINNET) => {
  var l;
  const s = Wc[n], a = {
    where: {
      subject: {
        creator_id: { _eq: r }
      },
      predicate_id: {
        _eq: `0x${ii.IS_PLAYER_GAMES.predicateId.toString(16).padStart(64, "0")}`
      },
      object_id: {
        _eq: `0x${ii.IS_PLAYER_GAMES.objectId.toString(16).padStart(64, "0")}`
      }
    }
  }, o = `
    query GetTriples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject_id
        predicate_id
        object_id
        subject {
          term_id
          label
          type
          creator_id
        }
        predicate {
          term_id
          label
          type
        }
        object {
          term_id
          label
          type
        }
        block_number
        created_at
        transaction_hash
      }
    }
  `;
  try {
    const c = await (await fetch(s, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify({
        query: o,
        // ← Utiliser la requête directe
        variables: a
      })
    })).json();
    if (c.errors)
      throw console.error("la Erreurs GraphQL:", c.errors), new Error(((l = c.errors[0]) == null ? void 0 : l.message) || "Erreur GraphQL inconnue");
    return c.data;
  } catch (u) {
    throw console.error(
      `[fetchTriplesByCreator] Erreur lors de la requête directe vers ${s}:`,
      u
    ), u;
  }
}, gI = (r, e = ii.IS_PLAYER_GAMES.predicateId.toString(), i = ii.IS_PLAYER_GAMES.objectId.toString(), n = $r.MAINNET) => {
  const [s, a] = ke(null), [o, l] = ke(!0), [u, c] = ke(null);
  ni(() => {
    (async () => {
      if (!r) {
        l(!1);
        return;
      }
      try {
        const p = await foe(
          r,
          e,
          i,
          n
        );
        a(p);
      } catch (p) {
        console.error(
          `[${n}] Erreur lors de la récupération des triples:`,
          p
        ), c(p instanceof Error ? p : new Error(String(p)));
      } finally {
        l(!1);
      }
    })();
  }, [r, e, i, n]);
  const h = (s == null ? void 0 : s.triples) || [];
  return {
    loading: o,
    error: u,
    triples: h,
    network: n,
    rawData: s
  };
}, yI = ({
  isOpen: r,
  onConnectWallet: e
}) => r ? /* @__PURE__ */ ie.jsx(
  "div",
  {
    style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "rgba(0, 0, 0, 0.7)",
      backdropFilter: "blur(5px)",
      zIndex: 1e3,
      width: "100%",
      height: "100%"
    },
    children: /* @__PURE__ */ ie.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#1a1a2e",
          padding: "30px",
          borderRadius: "10px",
          textAlign: "center",
          maxWidth: "500px",
          boxShadow: "0 0 15px rgba(108, 92, 231, 0.5)"
        },
        children: [
          /* @__PURE__ */ ie.jsx("h2", { style: { color: "#6c5ce7", marginBottom: "20px" }, children: "Wallet Required" }),
          /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "18px", marginBottom: "25px", color: "#fff" }, children: "Please connect your wallet to access this feature" }),
          /* @__PURE__ */ ie.jsx(
            "button",
            {
              onClick: e,
              style: {
                padding: "12px 24px",
                backgroundColor: "#6c5ce7",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
                fontSize: "16px"
              },
              children: "Connect Wallet"
            }
          )
        ]
      }
    )
  }
) : null, moe = ({
  isOpen: r,
  onCreatePlayer: e,
  onClose: i
}) => r ? /* @__PURE__ */ ie.jsx(
  "div",
  {
    style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "rgba(0, 0, 0, 1)",
      backdropFilter: "blur(1px)",
      zIndex: 1e3,
      width: "100%",
      height: "100%"
    },
    children: /* @__PURE__ */ ie.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#1a1a2e",
          padding: "30px",
          borderRadius: "10px",
          textAlign: "center",
          maxWidth: "500px",
          boxShadow: "0 0 15px rgba(0, 128, 255, 0.7)",
          position: "relative"
        },
        children: [
          i && /* @__PURE__ */ ie.jsx(
            "button",
            {
              onClick: i,
              style: {
                position: "absolute",
                top: "10px",
                right: "10px",
                backgroundColor: "transparent",
                border: "none",
                fontSize: "20px",
                color: "#666",
                cursor: "pointer"
              },
              children: "×"
            }
          ),
          /* @__PURE__ */ ie.jsx("h2", { style: { color: "#FFD32A", marginBottom: "20px" }, children: "Player Required" }),
          /* @__PURE__ */ ie.jsx("p", { style: { fontSize: "18px", marginBottom: "25px", color: "#fff" }, children: "You need to create a player before you can vote on claims" }),
          /* @__PURE__ */ ie.jsx(
            "button",
            {
              onClick: e,
              style: {
                padding: "12px 24px",
                backgroundColor: "#1976d2",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
                fontSize: "16px"
              },
              children: "Create Player"
            }
          )
        ]
      }
    )
  }
) : null, vI = new ooe({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: !1
    }
  }
});
EI({
  queryClient: vI
});
const goe = ({
  children: r
}) => /* @__PURE__ */ ie.jsx(uoe, { client: vI, children: r }), yoe = "https://testnet.intuition.sh/v1/graphql";
function voe() {
  poe({ apiUrl: yoe });
}
const ele = ({
  walletConnected: r = !1,
  walletAddress: e = "",
  wagmiConfig: i,
  walletHooks: n,
  onClose: s,
  onCreatePlayer: a,
  onConnectWallet: o
}) => {
  ni(() => {
    voe();
  }, []);
  const [l, u] = ke($r.MAINNET), [c, h] = ke(!1), [d, p] = ke(!1), f = e || "";
  ni(() => {
    p(!!(e && e !== ""));
  }, [e]);
  const {
    loading: m,
    error: v,
    triples: y
  } = gI(f, ii.IS_PLAYER_GAMES.predicateId.toString(), ii.IS_PLAYER_GAMES.objectId.toString(), l), g = y.length > 0, _ = m, x = v, b = kr(() => {
    a && a(), h(!0);
  }, [a]), T = kr(() => {
    h(!1), s && s();
  }, [s]), S = kr(() => {
    o && o();
  }, [o]);
  return x ? /* @__PURE__ */ ie.jsxs("div", { style: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100%",
    flexDirection: "column",
    gap: "20px"
  }, children: [
    /* @__PURE__ */ ie.jsx("h2", { style: { color: "red", textAlign: "center" }, children: "Erreur lors du chargement des données" }),
    /* @__PURE__ */ ie.jsx("p", { style: { textAlign: "center", color: "#666" }, children: x.message || "Une erreur inattendue s'est produite" }),
    /* @__PURE__ */ ie.jsx(
      "button",
      {
        onClick: () => window.location.reload(),
        style: {
          padding: "10px 20px",
          backgroundColor: "#FFD32A",
          color: "#000",
          border: "none",
          borderRadius: "5px",
          cursor: "pointer"
        },
        children: "Recharger la page"
      }
    )
  ] }) : _ ? /* @__PURE__ */ ie.jsxs("div", { style: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100%",
    flexDirection: "column",
    gap: "20px"
  }, children: [
    /* @__PURE__ */ ie.jsx("div", { style: {
      width: "50px",
      height: "50px",
      border: "4px solid #FFD32A",
      borderTop: "4px solid transparent",
      borderRadius: "50%",
      animation: "spin 1s linear infinite"
    } }),
    /* @__PURE__ */ ie.jsx("p", { style: { textAlign: "center", color: "#666" }, children: "Chargement des données du joueur..." })
  ] }) : /* @__PURE__ */ ie.jsx(goe, { children: /* @__PURE__ */ ie.jsxs("div", { style: { position: "relative", width: "100%", height: "100%" }, children: [
    /* @__PURE__ */ ie.jsx(
      yI,
      {
        isOpen: !d,
        onConnectWallet: S
      }
    ),
    (!d || d && !g) && /* @__PURE__ */ ie.jsx("div", { style: {
      filter: d ? "none" : "blur(3px)",
      opacity: d ? 1 : 0.7,
      position: "relative"
    }, children: /* @__PURE__ */ ie.jsx(
      CI,
      {
        walletConnected: d,
        walletAddress: e,
        wagmiConfig: i,
        walletHooks: n,
        onCreatePlayer: b
      }
    ) }),
    d && g && /* @__PURE__ */ ie.jsx(kae, { walletAddress: e }),
    /* @__PURE__ */ ie.jsx(
      lC,
      {
        isOpen: c,
        onClose: T,
        walletConnected: r,
        walletAddress: e,
        wagmiConfig: i,
        walletHooks: n
      }
    )
  ] }) });
};
var st = /* @__PURE__ */ ((r) => (r.For = "FOR", r.Against = "AGAINST", r.None = "NONE", r))(st || {});
const bI = 10000000000000000n, boe = [
  "0x27191de92fe0308355319ec8f2359e5ce85123bd243bf7ffa6eb8028347b3eab",
  "0x561a2c3e4359c8ed1c468aef27691e8e48b4424344a38c7693b9127b1911efc9",
  "0x6d7e52c5e80bf6c2873a21cb7013ba0655dc0458c77f2c0e7446c49efdbd0033",
  "0x9df847b39391899840d7973d9718d8caef5c5467dde9374a96d1f71727bae7c4"
], xoe = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  network: n = $r.MAINNET
}) => {
  const [s, a] = ke(!1), o = async (u) => {
    var c;
    try {
      const h = Wc[n], d = await fetch(h, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: `
            query Triple($tripleId: String!) {
              triple(term_id: $tripleId) {
                term_id
                counter_term_id
              }
            }
          `,
          variables: { tripleId: String(u) }
        })
      });
      if (!d.ok)
        return null;
      const p = await d.json();
      return p.errors ? (console.error("❌ GraphQL errors:", p.errors), null) : (c = p.data) != null && c.triple ? {
        id: String(u),
        ...p.data.triple
      } : (console.error("❌ No triple data found"), null);
    } catch (h) {
      return console.error("❌ fetchTripleDetails error:", h), null;
    }
  };
  return {
    depositTriple: async (u) => {
      if (!r || !e)
        return {
          success: !1,
          error: "Wallet not connected"
        };
      if (u.length === 0)
        return {
          success: !1,
          error: "No votes provided"
        };
      for (const c of u)
        if (c.units <= 0)
          return {
            success: !1,
            error: "Units must be greater than 0"
          };
      a(!0);
      try {
        const c = [], h = [], d = [], p = [];
        for (const v of u) {
          const y = await o(v.claimId);
          if (!y)
            return a(!1), {
              success: !1,
              error: `Failed to fetch triple details for claim ${v.claimId}`
            };
          let g;
          if (v.direction === st.For) {
            if (!y.term_id)
              return console.error("❌ term_id is undefined for FOR vote"), { success: !1, error: "term_id not found" };
            g = y.term_id;
          } else {
            if (!y.counter_term_id)
              return console.error("❌ counter_term_id is undefined for AGAINST vote"), { success: !1, error: "counter_term_id not found" };
            g = y.counter_term_id;
          }
          if (!g)
            return console.error("❌ targetId is undefined"), { success: !1, error: "targetId not found" };
          const _ = bI * BigInt(v.units);
          c.push(g), h.push(2n), d.push(_), p.push(0n);
        }
        const f = await r.writeContract({
          address: ml,
          abi: qh,
          functionName: "depositBatch",
          args: [
            e,
            // receiver
            c,
            // termIds array
            h,
            // curveIds array
            d,
            // assets array
            p
            // minShares array
          ],
          value: d.reduce((v, y) => v + y, 0n),
          // Total value
          gas: 500000n * BigInt(u.length)
          // Gas based on number of votes
        });
        let m;
        return r.waitForTransactionReceipt ? m = await r.waitForTransactionReceipt({ hash: f }) : f.wait ? m = await f.wait() : await new Promise((v) => setTimeout(v, 5e3)), a(!1), {
          success: !0,
          hash: typeof f == "string" ? f : f.hash
        };
      } catch (c) {
        return a(!1), {
          success: !1,
          error: c instanceof Error ? c.message : String(c)
        };
      }
    },
    isLoading: s
  };
}, _oe = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  network: n = $r.MAINNET,
  onSuccess: s
}) => {
  const [a, o] = ke(!1), [l, u] = ke({
    status: "idle",
    message: ""
  }), { depositTriple: c, isLoading: h } = xoe({
    walletConnected: r,
    walletAddress: e,
    publicClient: i,
    network: n
  });
  return {
    submitVotes: async (p) => {
      var m;
      if (!p.some((v) => v.units > 0))
        return u({
          status: "error",
          message: "Please place at least one vote."
        }), null;
      if (!r || !e)
        return u({
          status: "error",
          message: "Wallet not connected."
        }), null;
      try {
        o(!0), u({
          status: "pending",
          message: "Transaction in progress..."
        });
        const y = p.filter((_) => _.units > 0).map((_) => ({
          claimId: `0x${_.id.toString(16).padStart(64, "0")}`,
          units: _.units,
          direction: _.direction
        })), g = await c(y);
        if (g.success)
          return u({
            status: "success",
            message: `Transaction successful! Hash: ${(m = g.hash) == null ? void 0 : m.substring(0, 10)}...`
          }), s && s(), g;
        {
          let _ = g.error || "An error occurred.";
          return _.includes("user rejected") ? u({
            status: "error",
            message: "Transaction cancelled: User rejected the request."
          }) : u({
            status: "error",
            message: `Error: ${_}`
          }), null;
        }
      } catch (v) {
        return console.error("Error submitting votes:", v), u({
          status: "error",
          message: v instanceof Error ? v.message : "An error occurred."
        }), null;
      } finally {
        o(!1);
      }
    },
    isSubmitting: a,
    isDepositLoading: h,
    transactionStatus: l,
    setTransactionStatus: u
  };
}, Toe = ({
  network: r = $r.MAINNET,
  onError: e
} = {}) => {
  const [i, n] = ke(!1);
  return {
    fetchTripleDetails: async (a) => {
      var o, l, u, c, h, d, p;
      n(!0);
      try {
        const f = Wc[r], m = await fetch(f, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: `
          query Triple($tripleId: String!) {
            triple(term_id: $tripleId) {
              term_id
              subject_id
              predicate_id
              object_id
              subject {
                term_id
                label
              }
              predicate {
                term_id
                label
              }
              object {
                term_id
                label
              }
              term_id
              term {
                total_market_cap
                total_assets
              }
              counter_term_id
              counter_term {
                total_market_cap
                total_assets
              }
            }
          }
        `,
            variables: { tripleId: a.toString() }
            // Convertir en string pour v2
          })
        });
        if (!m.ok)
          throw new Error(`GraphQL request failed with status ${m.status}`);
        const v = await m.json();
        if (v.errors)
          throw new Error(`GraphQL errors: ${JSON.stringify(v.errors)}`);
        if (!((o = v.data) != null && o.triple))
          return e && e(`Triple with ID ${a} not found`), n(!1), null;
        const y = ((c = (u = (l = v.data.triple.term) == null ? void 0 : l.positions_aggregate) == null ? void 0 : u.aggregate) == null ? void 0 : c.count) || 0, g = ((p = (d = (h = v.data.triple.counter_term) == null ? void 0 : h.positions_aggregate) == null ? void 0 : d.aggregate) == null ? void 0 : p.count) || 0;
        return n(!1), {
          id: String(a),
          subject: v.data.triple.subject,
          predicate: v.data.triple.predicate,
          object: v.data.triple.object,
          term_id: v.data.triple.term_id,
          counter_term_id: v.data.triple.counter_term_id,
          term_position_count: y,
          counter_term_position_count: g
        };
      } catch (f) {
        return e && e(`Error fetching details for triple ${a}: ${f instanceof Error ? f.message : String(f)}`), n(!1), null;
      }
    },
    isLoading: i
  };
}, Soe = (r) => {
  const [e, i] = ke(null), [n, s] = ke(!0), [a, o] = ke(null);
  return ni(() => {
    (async () => {
      if (!r) {
        s(!1);
        return;
      }
      try {
        s(!0);
        const h = await (await fetch(Wc[$r.MAINNET], {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            query: `
          query GetTriplesWithPositions($accountId: String!) {
            triples {
              term_id
              counter_term_id
              subject_id
              predicate_id
              object_id
              positions(where: { account_id: { _eq: $accountId } }) {
                account_id
                term_id
                shares
                account {
                  id
                  label
                }
              }
              term {
                id
                total_market_cap
                total_assets
                positions(where: { account_id: { _eq: $accountId } }) {
                  account_id
                  shares
                }
              }
              counter_term {
                id
                total_market_cap
                total_assets
                positions(where: { account_id: { _eq: $accountId } }) {
                  account_id
                  shares
                }
              }
            }
          }
        `,
            variables: { accountId: r }
          })
        })).json();
        if (h.errors)
          throw console.error("GraphQL Errors:", h.errors), new Error(h.errors[0].message);
        const d = {
          triples: h.data.triples,
          positions: h.data.triples.flatMap((p) => {
            var f, m;
            return [
              ...p.positions || [],
              ...((f = p.term) == null ? void 0 : f.positions) || [],
              ...((m = p.counter_term) == null ? void 0 : m.positions) || []
            ];
          })
        };
        i(d), s(!1);
      } catch (u) {
        console.error("Erreur lors de la récupération des triples:", u), o(u), s(!1);
      }
    })();
  }, [r]), { data: e, loading: n, error: a };
}, woe = ({
  network: r = $r.MAINNET,
  walletAddress: e = "",
  onError: i
}) => {
  const [n, s] = ke([]), [a, o] = ke(!0), [l, u] = ke(0), [c, h] = ke({}), { fetchTripleDetails: d } = Toe({
    network: r,
    onError: i
  }), { data: p, loading: f } = Soe(e);
  ni(() => {
    if (p && !f && e) {
      const x = {};
      p.positions && Array.isArray(p.positions) && p.positions.forEach((b) => {
        if (!b.triple_id) return;
        const T = b.triple_id;
        if (b.is_for !== void 0) {
          const S = b.is_for ? st.For : st.Against;
          x[String(T)] = S;
        } else b.term_id && b.counter_term_id;
      }), p.triples && Array.isArray(p.triples) && p.triples.forEach((b) => {
        var E, A;
        if (!b.id)
          return;
        if (b.positions && Array.isArray(b.positions)) {
          const N = b.positions.find(
            (L) => {
              var F, M;
              return ((M = (F = L.account) == null ? void 0 : F.id) == null ? void 0 : M.toLowerCase()) === e.toLowerCase();
            }
          );
          N && (N.is_for !== void 0 ? x[String(b.id)] = N.is_for ? st.For : st.Against : N.term_id && b.term_id === N.term_id ? x[String(b.id)] = st.For : N.term_id && b.counter_term_id === N.term_id && (x[String(b.id)] = st.Against));
        }
        const T = ((E = b.term) == null ? void 0 : E.positions) || [], S = ((A = b.counter_term) == null ? void 0 : A.positions) || [], w = T.find((N) => {
          var L, F;
          return ((F = (L = N.account) == null ? void 0 : L.id) == null ? void 0 : F.toLowerCase()) === e.toLowerCase();
        }), C = S.find((N) => {
          var L, F;
          return ((F = (L = N.account) == null ? void 0 : L.id) == null ? void 0 : F.toLowerCase()) === e.toLowerCase();
        });
        w ? x[String(b.id)] = st.For : C && (x[String(b.id)] = st.Against);
      }), p.position_triples && Array.isArray(p.position_triples) && p.position_triples.forEach((b) => {
        var S, w, C, E;
        if (!b.triple_id && !((S = b.triple) != null && S.id)) return;
        const T = b.triple_id || ((w = b.triple) == null ? void 0 : w.id);
        b.is_for !== void 0 ? x[String(T)] = b.is_for ? st.For : st.Against : b.term_id && ((C = b.triple) == null ? void 0 : C.term_id) === b.term_id ? x[String(T)] = st.For : b.term_id && ((E = b.triple) == null ? void 0 : E.counter_term_id) === b.term_id && (x[String(T)] = st.Against);
      }), h(x), s(
        (b) => b.map((T) => {
          const S = x[String(T.id)] || st.None, w = S !== st.None;
          return {
            ...T,
            userHasPosition: w,
            userPositionDirection: S
          };
        })
      );
    }
  }, [p, f, e]), ni(() => {
    try {
      m();
    } catch (x) {
      console.error("Error in loadTripleDetails:", x);
    }
  }, []), ni(() => {
    const x = n.reduce((b, T) => b + T.units, 0);
    u(x);
  }, [n]);
  const m = async () => {
    o(!0);
    try {
      const x = boe.map(async (S) => {
        var E, A, N;
        const w = await d(S);
        if (!w)
          return {
            id: BigInt(S),
            subject: `Claim ${S}`,
            predicate: "is",
            object: "Unknown",
            units: 0,
            direction: st.None,
            userHasPosition: !1,
            userPositionDirection: st.None
          };
        const C = c[String(S)] || st.None;
        return {
          id: BigInt(w.id),
          subject: ((E = w.subject) == null ? void 0 : E.label) || `Subject ${S}`,
          predicate: ((A = w.predicate) == null ? void 0 : A.label) || "is",
          object: ((N = w.object) == null ? void 0 : N.label) || `Object ${S}`,
          units: 0,
          direction: st.None,
          term_id: w.term_id,
          term_position_count: w.term_position_count || 0,
          counter_term_id: w.counter_term_id,
          counter_term_position_count: w.counter_term_position_count || 0,
          userHasPosition: C !== st.None,
          userPositionDirection: C
        };
      }), b = await Promise.all(x);
      b.every((S) => S.object === "Unknown") && i && i("Error: Failed to fetch triple details. Please check your network connection or try again later."), s(b);
    } catch {
      i && i("Error: Failed to fetch triple details");
    } finally {
      o(!1);
    }
  }, v = (x, b, T) => {
    if (b !== st.None && !_(x, b)) {
      const w = n.find((C) => C.id === x);
      if (w && w.userHasPosition && w.userPositionDirection !== st.None) {
        i && i(`Cannot vote ${b === st.For ? "for" : "against"} this claim as you already have an ${w.userPositionDirection === st.For ? "affirmative" : "opposing"} position on it.`);
        return;
      }
    }
    s(
      (S) => S.map((w) => w.id === x ? w.userHasPosition && w.userPositionDirection !== st.None && b !== st.None && w.userPositionDirection !== b ? w : w.direction !== b && w.direction !== st.None ? { ...w, units: T, direction: b } : T === 0 ? { ...w, units: 0, direction: st.None } : { ...w, units: T, direction: b } : w)
    );
  }, y = () => {
    s(
      (x) => x.map((b) => ({
        ...b,
        units: 0,
        direction: st.None
      }))
    );
  }, g = n.filter((x) => x.units > 0).length, _ = (x, b) => {
    const T = n.find((w) => w.id === x);
    return !T || !T.userHasPosition ? !0 : T.userPositionDirection === st.None || T.userPositionDirection === b;
  };
  return {
    voteItems: n,
    setVoteItems: s,
    isLoading: a || f,
    totalUnits: l,
    numberOfTransactions: g,
    handleChangeUnits: v,
    resetAllVotes: y,
    loadTripleDetails: m,
    isVoteDirectionAllowed: _,
    userPositions: c
  };
}, xI = (r) => (r * 0.01).toFixed(2), Eoe = (r) => (r * 5e-5).toFixed(5), Moe = ({
  numberOfTransactions: r,
  totalUnits: e,
  onResetAll: i
}) => /* @__PURE__ */ ie.jsxs(
  "div",
  {
    style: {
      backgroundColor: "#10172d",
      padding: "10px",
      borderRadius: "8px",
      marginBottom: "25px",
      display: "flex",
      flexDirection: "column",
      border: "1px solid #1e3b70"
    },
    children: [
      /* @__PURE__ */ ie.jsxs("div", { style: { display: "flex", justifyContent: "space-between", marginBottom: "15px" }, children: [
        /* @__PURE__ */ ie.jsxs("div", { children: [
          /* @__PURE__ */ ie.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Unit value:" }),
          /* @__PURE__ */ ie.jsxs("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: [
            xI(e),
            " tTRUST"
          ] })
        ] }),
        /* @__PURE__ */ ie.jsxs("div", { children: [
          /* @__PURE__ */ ie.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Number of transactions:" }),
          /* @__PURE__ */ ie.jsx("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: r })
        ] }),
        /* @__PURE__ */ ie.jsxs("div", { children: [
          /* @__PURE__ */ ie.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Estimated gas cost:" }),
          /* @__PURE__ */ ie.jsxs("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: [
            "~",
            Eoe(r),
            " tTRUST"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ ie.jsxs("div", { style: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center"
      }, children: [
        /* @__PURE__ */ ie.jsxs("div", { style: { fontSize: "1em", fontWeight: "bold" }, children: [
          "Total units selected:",
          /* @__PURE__ */ ie.jsxs("span", { style: { fontSize: "1.6em", marginLeft: "10px", color: "#FFD32A" }, children: [
            e,
            " ",
            e === 1 ? "unit" : "units"
          ] })
        ] }),
        e > 0 && /* @__PURE__ */ ie.jsx(
          "button",
          {
            onClick: i,
            style: {
              backgroundColor: "transparent",
              border: "1px solid #6b7280",
              color: "#FFF",
              padding: "6px 12px",
              borderRadius: "4px",
              cursor: "pointer",
              fontSize: "0.9em"
            },
            children: "Reset all"
          }
        )
      ] })
    ]
  }
), Aoe = ({ onClose: r }) => /* @__PURE__ */ ie.jsxs(
  "div",
  {
    style: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      marginBottom: "25px",
      borderBottom: "1px solid #1e3b70"
    },
    children: [
      /* @__PURE__ */ ie.jsx("h2", { style: { fontSize: "1.3em", color: "#FFD32A", margin: 0, fontWeight: "bold" }, children: "VOTE ON CLAIMS" }),
      r && /* @__PURE__ */ ie.jsx(
        "button",
        {
          onClick: r,
          style: {
            backgroundColor: "transparent",
            border: "none",
            color: "#FFF",
            cursor: "pointer",
            fontSize: "1.5em"
          },
          children: "×"
        }
      )
    ]
  }
), Coe = ({
  walletAddress: r,
  tripleId: e,
  network: i = $r.MAINNET
}) => {
  const [n, s] = ke(!1), [a, o] = ke(null), [l, u] = ke(!0), [c, h] = ke(null), [d, p] = ke(0), [f, m] = ke(0);
  return ni(() => {
    (async () => {
      var y, g, _, x, b, T, S, w, C, E, A, N, L, F, M, P, O, V, B;
      if (!r || !e) {
        u(!1);
        return;
      }
      try {
        u(!0);
        const H = Wc[i], U = await fetch(H, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: `
              query GetTripleUserPosition($tripleId: String!, $walletAddress: String!) {
                # Get the triple with vault information
                triple(term_id: $tripleId) {
                  term_id
                  subject {
                    label
                  }
                  predicate {
                    label
                  }
                  object {
                    label
                  }
                  term_id
                  counter_term_id
                  
                  # Get vault positions (user only)
                  term {
                    id
                    positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                      aggregate {
                        count
                      }
                      nodes {
                        id
                      }
                    }
                  }
                  
                  # Get counter vault positions (user only)
                  counter_term {
                    id
                    positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                      aggregate {
                        count
                      }
                      nodes {
                        id
                      }
                    }
                  }
                }
              }
            `,
            variables: {
              tripleId: String(e),
              walletAddress: r.toLowerCase()
            }
          })
        });
        if (!U.ok)
          throw new Error(`GraphQL request failed with status ${U.status}`);
        const j = await U.json();
        if (j.errors)
          throw console.error("GraphQL errors:", j.errors), new Error(`GraphQL errors: ${JSON.stringify(j.errors)}`);
        const Q = (y = j.data) == null ? void 0 : y.triple;
        if (!Q) {
          s(!1), o(null), u(!1);
          return;
        }
        const q = ((x = (_ = (g = Q.term) == null ? void 0 : g.positions_aggregate) == null ? void 0 : _.aggregate) == null ? void 0 : x.count) > 0 || ((S = (T = (b = Q.term) == null ? void 0 : b.positions_aggregate) == null ? void 0 : T.nodes) == null ? void 0 : S.length) > 0, G = ((E = (C = (w = Q.counter_term) == null ? void 0 : w.positions_aggregate) == null ? void 0 : C.aggregate) == null ? void 0 : E.count) > 0 || ((L = (N = (A = Q.counter_term) == null ? void 0 : A.positions_aggregate) == null ? void 0 : N.nodes) == null ? void 0 : L.length) > 0;
        p(((P = (M = (F = Q.term) == null ? void 0 : F.positions_aggregate) == null ? void 0 : M.aggregate) == null ? void 0 : P.count) || 0), m(((B = (V = (O = Q.counter_term) == null ? void 0 : O.positions_aggregate) == null ? void 0 : V.aggregate) == null ? void 0 : B.count) || 0);
        const Y = q || G;
        s(Y), Y && o(q), u(!1);
      } catch (H) {
        console.error("Error checking triple position:", H), h(H), u(!1);
      }
    })();
  }, [r, e, i]), { hasPosition: n, isFor: a, loading: l, error: c, termPositionCount: d, counterTermPositionCount: f };
}, Roe = ({
  voteItem: r,
  onChangeUnits: e,
  isVoteDirectionAllowed: i = () => !0,
  walletAddress: n = "",
  network: s = $r.MAINNET
}) => {
  const {
    id: a,
    subject: o,
    predicate: l,
    object: u,
    units: c,
    direction: h,
    term_position_count: d = 0,
    counter_term_position_count: p = 0,
    userHasPosition: f = !1,
    userPositionDirection: m = st.None
  } = r, [v, y] = ke(0), [g, _] = ke(!1), [x, b] = ke(!1), {
    hasPosition: T,
    isFor: S,
    loading: w,
    termPositionCount: C,
    counterTermPositionCount: E
  } = Coe({
    walletAddress: n,
    tripleId: `0x${a.toString(16).padStart(64, "0")}`,
    network: s
  }), A = w ? f : T, N = w ? m : S !== null ? S ? st.For : st.Against : st.None, L = 20;
  ni(() => {
    h === st.For ? y(c) : h === st.Against ? y(-c) : y(0);
  }, [c, h]);
  const F = i ? i(a, st.For) : !A || N === st.For, M = i ? i(a, st.Against) : !A || N === st.Against, P = () => {
    if (!F)
      return;
    const Y = Math.min(v + 1, L);
    y(Y), e(a, st.For, Y);
  }, O = () => {
    if (!F || v <= 0)
      return;
    const Y = v - 1;
    y(Y), Y === 0 ? e(a, st.None, 0) : e(a, st.For, Y);
  }, V = () => {
    if (!M)
      return;
    const Y = Math.max(v - 1, -L);
    y(Y), e(a, st.Against, Math.abs(Y));
  }, B = () => {
    if (!M || v >= 0)
      return;
    const Y = v + 1;
    y(Y), Y === 0 ? e(a, st.None, 0) : e(a, st.Against, Math.abs(Y));
  }, H = h === st.For && c > 0, U = h === st.Against && c > 0, j = Number(bI) / 10 ** 18 * c, Q = A && N !== st.None, q = Q && N === st.Against ? "You cannot vote FOR this claim because you already have an AGAINST position" : "", G = Q && N === st.For ? "You cannot vote AGAINST this claim because you already have a FOR position" : "";
  return /* @__PURE__ */ ie.jsxs(
    "div",
    {
      style: {
        padding: "20px",
        marginBottom: "20px",
        borderRadius: "8px",
        backgroundColor: "#0c1228",
        position: "relative",
        border: Q ? N === st.For ? "2px solid #4CAF50" : "2px solid #F44336" : "1px solid #1e3b70",
        boxShadow: "0 4px 10px rgba(0, 0, 0, 0.3)"
      },
      children: [
        c > 0 && /* @__PURE__ */ ie.jsxs("div", { style: {
          position: "absolute",
          top: "5px",
          left: "5px",
          backgroundColor: "#FFD32A",
          color: "#000000",
          padding: "3px 6px",
          fontSize: "10px",
          fontWeight: "bold",
          borderRadius: "4px"
        }, children: [
          j.toFixed(2),
          " tTRUST"
        ] }),
        /* @__PURE__ */ ie.jsxs("div", { style: {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        }, children: [
          /* @__PURE__ */ ie.jsxs("div", { style: { display: "flex", alignItems: "center", position: "relative" }, children: [
            /* @__PURE__ */ ie.jsx("div", { style: { fontSize: "0.9em", color: "#E1E1E1", marginRight: "10px" }, children: "For ▲:" }),
            N === st.For || N === st.None ? /* @__PURE__ */ ie.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
              /* @__PURE__ */ ie.jsx(
                "button",
                {
                  onClick: F && v > 0 ? O : void 0,
                  disabled: !F || v <= 0,
                  style: {
                    width: "30px",
                    height: "30px",
                    backgroundColor: F && v > 0 ? "#1e2030" : "#606060",
                    border: "none",
                    borderRadius: "4px",
                    color: "#ffffff",
                    fontSize: "16px",
                    cursor: F && v > 0 ? "pointer" : "not-allowed",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    opacity: F && v > 0 ? 1 : 0.4,
                    pointerEvents: F && v > 0 ? "auto" : "none",
                    userSelect: "none"
                  },
                  children: "-"
                }
              ),
              /* @__PURE__ */ ie.jsx("span", { style: { margin: "0 10px", color: "#ffffff", fontWeight: "bold" }, children: H ? c : 0 }),
              /* @__PURE__ */ ie.jsxs(
                "div",
                {
                  style: { position: "relative" },
                  onMouseEnter: () => q && _(!0),
                  onMouseLeave: () => q && _(!1),
                  children: [
                    /* @__PURE__ */ ie.jsx(
                      "button",
                      {
                        onClick: F ? P : void 0,
                        disabled: !F,
                        style: {
                          width: "30px",
                          height: "30px",
                          backgroundColor: F ? "#1976d2" : "#606060",
                          border: !F && Q ? "2px solid #F44336" : "none",
                          borderRadius: "4px",
                          color: "#ffffff",
                          fontSize: "16px",
                          cursor: F ? "pointer" : "not-allowed",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          opacity: F ? 1 : 0.4,
                          pointerEvents: F ? "auto" : "none",
                          userSelect: "none"
                        },
                        children: "+"
                      }
                    ),
                    (!F && Q || g && q) && /* @__PURE__ */ ie.jsx("div", { style: {
                      position: "absolute",
                      bottom: "100%",
                      left: "50%",
                      transform: "translateX(-50%)",
                      backgroundColor: "#F44336",
                      color: "white",
                      padding: "5px 10px",
                      borderRadius: "4px",
                      fontSize: "12px",
                      whiteSpace: "nowrap",
                      zIndex: 10,
                      marginBottom: "5px"
                    }, children: q })
                  ]
                }
              )
            ] }) : /* @__PURE__ */ ie.jsx("div", { style: {
              backgroundColor: "#606060",
              borderRadius: "4px",
              color: "#ffffff",
              padding: "5px 10px",
              fontSize: "12px",
              marginLeft: "10px"
            }, children: "You have voted AGAINST ▼" })
          ] }),
          /* @__PURE__ */ ie.jsxs("div", { style: { display: "flex", marginBottom: "20px", gap: "5px", marginTop: "20px" }, children: [
            /* @__PURE__ */ ie.jsx("span", { style: {
              backgroundColor: "#FFB300",
              padding: "4px 8px",
              borderRadius: "4px",
              fontSize: "0.9em",
              color: "#000000",
              fontWeight: "bold"
            }, children: o }),
            "-",
            /* @__PURE__ */ ie.jsx("span", { style: {
              backgroundColor: "#ccd3d3",
              padding: "4px 8px",
              borderRadius: "4px",
              fontSize: "0.9em",
              color: "#000000",
              fontWeight: "bold"
            }, children: l }),
            "-",
            /* @__PURE__ */ ie.jsx("span", { style: {
              backgroundColor: "#43A047",
              padding: "4px 8px",
              borderRadius: "4px",
              fontSize: "0.9em",
              color: "#000000",
              fontWeight: "bold"
            }, children: u })
          ] }),
          /* @__PURE__ */ ie.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
            /* @__PURE__ */ ie.jsx("div", { style: { fontSize: "0.9em", color: "#E1E1E1", marginRight: "10px" }, children: "Against ▼:" }),
            N === st.Against || N === st.None ? /* @__PURE__ */ ie.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
              /* @__PURE__ */ ie.jsx(
                "button",
                {
                  onClick: M && v < 0 ? B : void 0,
                  disabled: !M || v >= 0,
                  style: {
                    width: "30px",
                    height: "30px",
                    backgroundColor: M && v < 0 ? "#1e2030" : "#606060",
                    border: "none",
                    borderRadius: "4px",
                    color: "#ffffff",
                    fontSize: "16px",
                    cursor: M && v < 0 ? "pointer" : "not-allowed",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    opacity: M && v < 0 ? 1 : 0.4,
                    pointerEvents: M && v < 0 ? "auto" : "none",
                    userSelect: "none"
                  },
                  children: "-"
                }
              ),
              /* @__PURE__ */ ie.jsx("span", { style: { margin: "0 10px", color: "#ffffff", fontWeight: "bold" }, children: U ? c : 0 }),
              /* @__PURE__ */ ie.jsxs(
                "div",
                {
                  style: { position: "relative" },
                  onMouseEnter: () => G && b(!0),
                  onMouseLeave: () => G && b(!1),
                  children: [
                    /* @__PURE__ */ ie.jsx(
                      "button",
                      {
                        onClick: M ? V : void 0,
                        disabled: !M,
                        style: {
                          width: "30px",
                          height: "30px",
                          backgroundColor: M ? "#dc3545" : "#606060",
                          border: !M && Q ? "2px solid #4CAF50" : "none",
                          borderRadius: "4px",
                          color: "#ffffff",
                          fontSize: "16px",
                          cursor: M ? "pointer" : "not-allowed",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          opacity: M ? 1 : 0.4,
                          pointerEvents: M ? "auto" : "none",
                          userSelect: "none"
                        },
                        children: "+"
                      }
                    ),
                    (!M && Q || x && G) && /* @__PURE__ */ ie.jsx("div", { style: {
                      position: "absolute",
                      bottom: "100%",
                      left: "50%",
                      transform: "translateX(-50%)",
                      backgroundColor: "#F44336",
                      color: "white",
                      padding: "5px 10px",
                      borderRadius: "4px",
                      fontSize: "12px",
                      whiteSpace: "nowrap",
                      zIndex: 10,
                      marginBottom: "5px"
                    }, children: G })
                  ]
                }
              )
            ] }) : /* @__PURE__ */ ie.jsx("div", { style: {
              backgroundColor: "#606060",
              borderRadius: "4px",
              color: "#ffffff",
              padding: "5px 10px",
              fontSize: "12px",
              marginLeft: "10px"
            }, children: "You have voted FOR ▲" })
          ] })
        ] }),
        /* @__PURE__ */ ie.jsxs("div", { className: "flex flex-row justify-between", children: [
          /* @__PURE__ */ ie.jsxs("div", { style: {
            fontSize: "0.7em",
            color: "#4CAF50",
            marginBottom: "8px",
            backgroundColor: "rgba(76, 175, 80, 0.1)",
            padding: "2px 6px",
            borderRadius: "4px",
            fontWeight: "bold"
          }, children: [
            C,
            " positions"
          ] }),
          /* @__PURE__ */ ie.jsxs("div", { style: {
            fontSize: "0.7em",
            color: "#F44336",
            marginBottom: "8px",
            backgroundColor: "rgba(244, 67, 54, 0.1)",
            padding: "2px 6px",
            borderRadius: "4px",
            fontWeight: "bold"
          }, children: [
            E,
            " positions"
          ] })
        ] })
      ]
    }
  );
}, Noe = ({
  isLoading: r,
  voteItems: e,
  onChangeUnits: i,
  isVoteDirectionAllowed: n,
  walletAddress: s = "",
  network: a = $r.MAINNET
}) => r ? /* @__PURE__ */ ie.jsx("div", { style: { textAlign: "center", padding: "30px", color: "#6b7280", fontSize: "1.1em" }, children: "Loading claims..." }) : /* @__PURE__ */ ie.jsx("div", { style: { marginBottom: "25px" }, children: e.map((o) => /* @__PURE__ */ ie.jsx(
  Roe,
  {
    voteItem: o,
    onChangeUnits: i,
    isVoteDirectionAllowed: n,
    walletAddress: s,
    network: a
  },
  o.id.toString()
)) }), Poe = ({
  onSubmit: r,
  isSubmitting: e,
  isDepositLoading: i,
  totalUnits: n,
  numberOfTransactions: s
}) => /* @__PURE__ */ ie.jsxs("div", { style: { textAlign: "center" }, children: [
  /* @__PURE__ */ ie.jsx("div", { style: { marginBottom: "15px", fontSize: "0.9em", color: "#6b7280" }, children: s > 0 && `You will initiate ${s} transaction${s > 1 ? "s" : ""}` }),
  /* @__PURE__ */ ie.jsx(
    "button",
    {
      onClick: r,
      disabled: e || i || n === 0,
      style: {
        backgroundColor: n > 0 && !e && !i ? "#1976d2" : "#10172d",
        color: "#FFF",
        padding: "12px 30px",
        border: "none",
        borderRadius: "8px",
        fontSize: "1.1em",
        fontWeight: "bold",
        cursor: n > 0 && !e && !i ? "pointer" : "not-allowed",
        width: "100%",
        maxWidth: "350px",
        boxShadow: "0 4px 10px rgba(0, 0, 0, 0.3)",
        transition: "background-color 0.2s ease"
      },
      children: e || i ? "Processing..." : n > 0 ? `Submit votes (${xI(n)} tTRUST)` : "Submit votes"
    }
  )
] }), Ooe = ({
  transactionStatus: r
}) => r.status === "idle" || r.status === "whitelist_error" ? null : /* @__PURE__ */ ie.jsx(
  "div",
  {
    style: {
      marginTop: "25px",
      padding: "20px",
      borderRadius: "8px",
      backgroundColor: r.status === "pending" ? "#10172d" : r.status === "approval_pending" ? "rgba(255, 211, 42, 0.1)" : r.status === "success" ? "rgba(0, 128, 0, 0.1)" : "rgba(255, 0, 0, 0.1)",
      color: r.status === "success" ? "#4CAF50" : r.status === "error" ? "#F44336" : r.status === "approval_pending" ? "#FFD32A" : "#FFF",
      display: "flex",
      flexDirection: "column",
      gap: "10px",
      border: "1px solid #1e3b70"
    },
    children: /* @__PURE__ */ ie.jsx("div", { children: r.message })
  }
), tle = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  onClose: n,
  network: s = $r.MAINNET,
  onConnectWallet: a,
  onCreatePlayer: o,
  wagmiConfig: l,
  walletHooks: u
}) => {
  const [c, h] = ke(!1), [d, p] = ke(!1), [f, m] = ke(!1), {
    loading: v,
    triples: y
  } = gI(
    e || "",
    ii.IS_PLAYER_GAMES.predicateId.toString(),
    ii.IS_PLAYER_GAMES.objectId.toString(),
    s
  ), g = y.length > 0;
  ni(() => {
    m(!!(e && e !== ""));
  }, [e]), ni(() => {
    p(!!(f && !g && !v));
  }, [f, g, v]);
  const {
    voteItems: _,
    isLoading: x,
    totalUnits: b,
    numberOfTransactions: T,
    handleChangeUnits: S,
    resetAllVotes: w,
    isVoteDirectionAllowed: C
  } = woe({
    network: s,
    walletAddress: e,
    onError: (Q) => {
      F({
        status: "error",
        message: Q
      });
    }
  }), {
    submitVotes: E,
    isSubmitting: A,
    isDepositLoading: N,
    transactionStatus: L,
    setTransactionStatus: F
  } = _oe({
    walletConnected: r,
    walletAddress: e,
    publicClient: i,
    network: s,
    onSuccess: w
  }), M = async () => {
    await E(_);
  }, P = () => {
    p(!1), h(!0), o && o();
  }, O = () => {
    h(!1);
  }, V = () => {
    p(!1), n && n();
  }, { isCorrectNetwork: B, currentChainId: H, targetChainId: U, allowedChainIds: j } = aC({
    walletConnected: r,
    publicClient: i
  });
  return f ? f && !g && !v ? /* @__PURE__ */ ie.jsxs(
    "div",
    {
      style: {
        backgroundColor: "#070b1a",
        minHeight: "50vh",
        color: "#fff",
        padding: "15px",
        border: "1px solid #1e3b70",
        borderRadius: "8px",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: [
        /* @__PURE__ */ ie.jsx(
          moe,
          {
            isOpen: !0,
            onCreatePlayer: P,
            onClose: V
          }
        ),
        /* @__PURE__ */ ie.jsx(
          lC,
          {
            isOpen: c,
            onClose: O,
            walletConnected: r,
            walletAddress: e,
            wagmiConfig: l,
            walletHooks: u
          }
        )
      ]
    }
  ) : /* @__PURE__ */ ie.jsxs(
    "div",
    {
      style: {
        backgroundColor: "#070b1a",
        minHeight: "50vh",
        opacity: "0.9",
        color: "#fff",
        padding: "15px",
        border: "1px solid #1e3b70",
        borderRadius: "8px",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: [
        /* @__PURE__ */ ie.jsx(Aoe, { onClose: n }),
        /* @__PURE__ */ ie.jsx(
          Moe,
          {
            numberOfTransactions: T,
            totalUnits: b,
            onResetAll: w
          }
        ),
        /* @__PURE__ */ ie.jsx(
          Noe,
          {
            isLoading: x || v,
            voteItems: _,
            onChangeUnits: S,
            isVoteDirectionAllowed: C,
            walletAddress: e,
            network: s
          }
        ),
        /* @__PURE__ */ ie.jsx(
          Poe,
          {
            onSubmit: M,
            isSubmitting: A,
            isDepositLoading: N,
            totalUnits: b,
            numberOfTransactions: T
          }
        ),
        /* @__PURE__ */ ie.jsx(Ooe, { transactionStatus: L }),
        !B && /* @__PURE__ */ ie.jsx(
          oC,
          {
            allowedChainIds: j,
            currentChainId: H,
            targetChainId: U
          }
        )
      ]
    }
  ) : /* @__PURE__ */ ie.jsx(
    "div",
    {
      style: {
        backgroundColor: "#070b1a",
        minHeight: "50vh",
        opacity: "0.9",
        color: "#fff",
        padding: "15px",
        border: "1px solid #1e3b70",
        borderRadius: "8px",
        maxWidth: "960px",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: /* @__PURE__ */ ie.jsx(
        yI,
        {
          isOpen: !0,
          onConnectWallet: a || (() => {
          })
        }
      )
    }
  );
}, ile = async (r, e, i = $r.MAINNET) => {
  var n, s, a, o, l, u, c, h, d, p, f, m, v;
  if (!r)
    throw new Error("Wallet address is required");
  try {
    const y = Wc[i], g = await fetch(y, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetTripleUserPosition($tripleId: numeric!, $walletAddress: String!) {
            # Get the triple with vault information
            triple(term_id: $tripleId) {
              id
              subject {
                label
              }
              predicate {
                label
              }
              object {
                label
              }
              term_id
              counter_term_id
              
              # Get vault positions
              term {
                id
                positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                  aggregate {
                    count
                  }
                  nodes {
                    id
                  }
                }
              }
              
              # Get counter vault positions
              counter_term {
                id
                positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                  aggregate {
                    count
                  }
                  nodes {
                    id
                  }
                }
              }
            }
          }
        `,
        variables: {
          tripleId: Number(e),
          walletAddress: r.toLowerCase()
        }
      })
    });
    if (!g.ok)
      throw new Error(`GraphQL request failed with status ${g.status}`);
    const _ = await g.json();
    if (_.errors)
      throw console.error("GraphQL errors:", _.errors), new Error(`GraphQL errors: ${JSON.stringify(_.errors)}`);
    const x = (n = _.data) == null ? void 0 : n.triple;
    if (!x)
      return {
        hasPosition: !1,
        isFor: null,
        result: _.data
      };
    const b = ((o = (a = (s = x.term) == null ? void 0 : s.positions_aggregate) == null ? void 0 : a.aggregate) == null ? void 0 : o.count) > 0 || ((c = (u = (l = x.term) == null ? void 0 : l.positions_aggregate) == null ? void 0 : u.nodes) == null ? void 0 : c.length) > 0, T = ((p = (d = (h = x.counter_term) == null ? void 0 : h.positions_aggregate) == null ? void 0 : d.aggregate) == null ? void 0 : p.count) > 0 || ((v = (m = (f = x.counter_term) == null ? void 0 : f.positions_aggregate) == null ? void 0 : m.nodes) == null ? void 0 : v.length) > 0, S = b || T;
    return {
      hasPosition: S,
      isFor: S ? b : null,
      result: _.data
      // Return raw data for debugging
    };
  } catch (y) {
    throw console.error("Error checking triple position:", y), y;
  }
}, rle = {
  /**
   * Initialise la configuration de la bibliothèque Player-map
   * @param config Configuration contenant l'URL de l'API (obligatoire)
   */
  init: (r) => {
    if (!r.apiUrl)
      throw new Error(
        "L'URL de l'API est obligatoire pour initialiser Player-map"
      );
    return rL(r), !0;
  },
  /**
   * Récupère la configuration actuelle
   * @throws Error si la configuration n'a pas été initialisée
   */
  get: cg
}, nle = {
  setAuthToken: zS,
  getAuthToken: d_,
  isAuthenticated: ug,
  clearAuthToken: iL,
  // Fonction d'initialisation pour les applications intégrant la bibliothèque
  initialize: (r) => r ? (zS(r), !0) : !1
};
export {
  tle as ClaimVoting,
  ele as GraphComponent,
  boe as PREDEFINED_CLAIM_IDS,
  rle as PlayerMapConfig,
  kae as PlayerMapGraph,
  CI as PlayerMapHome,
  lC as RegistrationForm,
  bI as UNIT_VALUE,
  st as VoteDirection,
  nle as auth,
  ile as checkTriplePosition,
  iL as clearAuthToken,
  CI as default,
  d_ as getAuthToken,
  ug as isAuthenticated,
  zS as setAuthToken,
  Coe as useCheckSpecificTriplePosition,
  xoe as useDepositTriple,
  Soe as useDisplayTriplesWithPosition
};
