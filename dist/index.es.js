var gT = (r) => {
  throw TypeError(r);
};
var ty = (r, e, i) => e.has(r) || gT("Cannot " + i);
var ge = (r, e, i) => (ty(r, e, "read from private field"), i ? i.call(r) : e.get(r)), zt = (r, e, i) => e.has(r) ? gT("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, i), mt = (r, e, i, n) => (ty(r, e, "write to private field"), n ? n.call(r, i) : e.set(r, i), i), or = (r, e, i) => (ty(r, e, "access private method"), i);
var ap = (r, e, i, n) => ({
  set _(s) {
    mt(r, e, s, i);
  },
  get _() {
    return ge(r, e, n);
  }
});
import * as vA from "react";
import si, { useState as ye, useEffect as Ft, useRef as Gi, forwardRef as PO, useMemo as gm, useCallback as mr, useImperativeHandle as IO, useLayoutEffect as OO, createContext as DO } from "react";
import bA from "3d-force-graph-vr";
var Nv = { exports: {} }, Kc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yT;
function LO() {
  if (yT) return Kc;
  yT = 1;
  var r = si, e = Symbol.for("react.element"), i = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(l, u, c) {
    var h, d = {}, p = null, f = null;
    c !== void 0 && (p = "" + c), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (f = u.ref);
    for (h in u) n.call(u, h) && !a.hasOwnProperty(h) && (d[h] = u[h]);
    if (l && l.defaultProps) for (h in u = l.defaultProps, u) d[h] === void 0 && (d[h] = u[h]);
    return { $$typeof: e, type: l, key: p, ref: f, props: d, _owner: s.current };
  }
  return Kc.Fragment = i, Kc.jsx = o, Kc.jsxs = o, Kc;
}
var Zc = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vT;
function kO() {
  return vT || (vT = 1, process.env.NODE_ENV !== "production" && function() {
    var r = si, e = Symbol.for("react.element"), i = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), m = Symbol.iterator, y = "@@iterator";
    function v(N) {
      if (N === null || typeof N != "object")
        return null;
      var J = m && N[m] || N[y];
      return typeof J == "function" ? J : null;
    }
    var g = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(N) {
      {
        for (var J = arguments.length, ce = new Array(J > 1 ? J - 1 : 0), Ne = 1; Ne < J; Ne++)
          ce[Ne - 1] = arguments[Ne];
        x("error", N, ce);
      }
    }
    function x(N, J, ce) {
      {
        var Ne = g.ReactDebugCurrentFrame, $e = Ne.getStackAddendum();
        $e !== "" && (J += "%s", ce = ce.concat([$e]));
        var at = ce.map(function(qe) {
          return String(qe);
        });
        at.unshift("Warning: " + J), Function.prototype.apply.call(console[N], console, at);
      }
    }
    var b = !1, T = !1, E = !1, M = !1, C = !1, S;
    S = Symbol.for("react.module.reference");
    function w(N) {
      return !!(typeof N == "string" || typeof N == "function" || N === n || N === a || C || N === s || N === c || N === h || M || N === f || b || T || E || typeof N == "object" && N !== null && (N.$$typeof === p || N.$$typeof === d || N.$$typeof === o || N.$$typeof === l || N.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      N.$$typeof === S || N.getModuleId !== void 0));
    }
    function R(N, J, ce) {
      var Ne = N.displayName;
      if (Ne)
        return Ne;
      var $e = J.displayName || J.name || "";
      return $e !== "" ? ce + "(" + $e + ")" : ce;
    }
    function O(N) {
      return N.displayName || "Context";
    }
    function P(N) {
      if (N == null)
        return null;
      if (typeof N.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof N == "function")
        return N.displayName || N.name || null;
      if (typeof N == "string")
        return N;
      switch (N) {
        case n:
          return "Fragment";
        case i:
          return "Portal";
        case a:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof N == "object")
        switch (N.$$typeof) {
          case l:
            var J = N;
            return O(J) + ".Consumer";
          case o:
            var ce = N;
            return O(ce._context) + ".Provider";
          case u:
            return R(N, N.render, "ForwardRef");
          case d:
            var Ne = N.displayName || null;
            return Ne !== null ? Ne : P(N.type) || "Memo";
          case p: {
            var $e = N, at = $e._payload, qe = $e._init;
            try {
              return P(qe(at));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var A = Object.assign, D = 0, L, H, V, X, F, B, W;
    function G() {
    }
    G.__reactDisabledLog = !0;
    function z() {
      {
        if (D === 0) {
          L = console.log, H = console.info, V = console.warn, X = console.error, F = console.group, B = console.groupCollapsed, W = console.groupEnd;
          var N = {
            configurable: !0,
            enumerable: !0,
            value: G,
            writable: !0
          };
          Object.defineProperties(console, {
            info: N,
            log: N,
            warn: N,
            error: N,
            group: N,
            groupCollapsed: N,
            groupEnd: N
          });
        }
        D++;
      }
    }
    function K() {
      {
        if (D--, D === 0) {
          var N = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: A({}, N, {
              value: L
            }),
            info: A({}, N, {
              value: H
            }),
            warn: A({}, N, {
              value: V
            }),
            error: A({}, N, {
              value: X
            }),
            group: A({}, N, {
              value: F
            }),
            groupCollapsed: A({}, N, {
              value: B
            }),
            groupEnd: A({}, N, {
              value: W
            })
          });
        }
        D < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ne = g.ReactCurrentDispatcher, oe;
    function pe(N, J, ce) {
      {
        if (oe === void 0)
          try {
            throw Error();
          } catch ($e) {
            var Ne = $e.stack.trim().match(/\n( *(at )?)/);
            oe = Ne && Ne[1] || "";
          }
        return `
` + oe + N;
      }
    }
    var xe = !1, Re;
    {
      var nt = typeof WeakMap == "function" ? WeakMap : Map;
      Re = new nt();
    }
    function fe(N, J) {
      if (!N || xe)
        return "";
      {
        var ce = Re.get(N);
        if (ce !== void 0)
          return ce;
      }
      var Ne;
      xe = !0;
      var $e = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var at;
      at = ne.current, ne.current = null, z();
      try {
        if (J) {
          var qe = function() {
            throw Error();
          };
          if (Object.defineProperty(qe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(qe, []);
            } catch (Pe) {
              Ne = Pe;
            }
            Reflect.construct(N, [], qe);
          } else {
            try {
              qe.call();
            } catch (Pe) {
              Ne = Pe;
            }
            N.call(qe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Pe) {
            Ne = Pe;
          }
          N();
        }
      } catch (Pe) {
        if (Pe && Ne && typeof Pe.stack == "string") {
          for (var He = Pe.stack.split(`
`), U = Ne.stack.split(`
`), q = He.length - 1, te = U.length - 1; q >= 1 && te >= 0 && He[q] !== U[te]; )
            te--;
          for (; q >= 1 && te >= 0; q--, te--)
            if (He[q] !== U[te]) {
              if (q !== 1 || te !== 1)
                do
                  if (q--, te--, te < 0 || He[q] !== U[te]) {
                    var ae = `
` + He[q].replace(" at new ", " at ");
                    return N.displayName && ae.includes("<anonymous>") && (ae = ae.replace("<anonymous>", N.displayName)), typeof N == "function" && Re.set(N, ae), ae;
                  }
                while (q >= 1 && te >= 0);
              break;
            }
        }
      } finally {
        xe = !1, ne.current = at, K(), Error.prepareStackTrace = $e;
      }
      var $ = N ? N.displayName || N.name : "", Me = $ ? pe($) : "";
      return typeof N == "function" && Re.set(N, Me), Me;
    }
    function gt(N, J, ce) {
      return fe(N, !1);
    }
    function Q(N) {
      var J = N.prototype;
      return !!(J && J.isReactComponent);
    }
    function Gt(N, J, ce) {
      if (N == null)
        return "";
      if (typeof N == "function")
        return fe(N, Q(N));
      if (typeof N == "string")
        return pe(N);
      switch (N) {
        case c:
          return pe("Suspense");
        case h:
          return pe("SuspenseList");
      }
      if (typeof N == "object")
        switch (N.$$typeof) {
          case u:
            return gt(N.render);
          case d:
            return Gt(N.type, J, ce);
          case p: {
            var Ne = N, $e = Ne._payload, at = Ne._init;
            try {
              return Gt(at($e), J, ce);
            } catch {
            }
          }
        }
      return "";
    }
    var Qe = Object.prototype.hasOwnProperty, bt = {}, Be = g.ReactDebugCurrentFrame;
    function At(N) {
      if (N) {
        var J = N._owner, ce = Gt(N.type, N._source, J ? J.type : null);
        Be.setExtraStackFrame(ce);
      } else
        Be.setExtraStackFrame(null);
    }
    function st(N, J, ce, Ne, $e) {
      {
        var at = Function.call.bind(Qe);
        for (var qe in N)
          if (at(N, qe)) {
            var He = void 0;
            try {
              if (typeof N[qe] != "function") {
                var U = Error((Ne || "React class") + ": " + ce + " type `" + qe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof N[qe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw U.name = "Invariant Violation", U;
              }
              He = N[qe](J, qe, Ne, ce, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (q) {
              He = q;
            }
            He && !(He instanceof Error) && (At($e), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ne || "React class", ce, qe, typeof He), At(null)), He instanceof Error && !(He.message in bt) && (bt[He.message] = !0, At($e), _("Failed %s type: %s", ce, He.message), At(null));
          }
      }
    }
    var j = Array.isArray;
    function k(N) {
      return j(N);
    }
    function le(N) {
      {
        var J = typeof Symbol == "function" && Symbol.toStringTag, ce = J && N[Symbol.toStringTag] || N.constructor.name || "Object";
        return ce;
      }
    }
    function we(N) {
      try {
        return Ce(N), !1;
      } catch {
        return !0;
      }
    }
    function Ce(N) {
      return "" + N;
    }
    function Te(N) {
      if (we(N))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", le(N)), Ce(N);
    }
    var et = g.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Xe, Pt;
    function Ie(N) {
      if (Qe.call(N, "ref")) {
        var J = Object.getOwnPropertyDescriptor(N, "ref").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return N.ref !== void 0;
    }
    function Ye(N) {
      if (Qe.call(N, "key")) {
        var J = Object.getOwnPropertyDescriptor(N, "key").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return N.key !== void 0;
    }
    function ut(N, J) {
      typeof N.ref == "string" && et.current;
    }
    function ft(N, J) {
      {
        var ce = function() {
          Xe || (Xe = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(N, "key", {
          get: ce,
          configurable: !0
        });
      }
    }
    function Ke(N, J) {
      {
        var ce = function() {
          Pt || (Pt = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(N, "ref", {
          get: ce,
          configurable: !0
        });
      }
    }
    var Ot = function(N, J, ce, Ne, $e, at, qe) {
      var He = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: N,
        key: J,
        ref: ce,
        props: qe,
        // Record the component responsible for creating this element.
        _owner: at
      };
      return He._store = {}, Object.defineProperty(He._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(He, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ne
      }), Object.defineProperty(He, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: $e
      }), Object.freeze && (Object.freeze(He.props), Object.freeze(He)), He;
    };
    function xt(N, J, ce, Ne, $e) {
      {
        var at, qe = {}, He = null, U = null;
        ce !== void 0 && (Te(ce), He = "" + ce), Ye(J) && (Te(J.key), He = "" + J.key), Ie(J) && (U = J.ref, ut(J, $e));
        for (at in J)
          Qe.call(J, at) && !ze.hasOwnProperty(at) && (qe[at] = J[at]);
        if (N && N.defaultProps) {
          var q = N.defaultProps;
          for (at in q)
            qe[at] === void 0 && (qe[at] = q[at]);
        }
        if (He || U) {
          var te = typeof N == "function" ? N.displayName || N.name || "Unknown" : N;
          He && ft(qe, te), U && Ke(qe, te);
        }
        return Ot(N, He, U, $e, Ne, et.current, qe);
      }
    }
    var jt = g.ReactCurrentOwner, ee = g.ReactDebugCurrentFrame;
    function Le(N) {
      if (N) {
        var J = N._owner, ce = Gt(N.type, N._source, J ? J.type : null);
        ee.setExtraStackFrame(ce);
      } else
        ee.setExtraStackFrame(null);
    }
    var de;
    de = !1;
    function Ee(N) {
      return typeof N == "object" && N !== null && N.$$typeof === e;
    }
    function je() {
      {
        if (jt.current) {
          var N = P(jt.current.type);
          if (N)
            return `

Check the render method of \`` + N + "`.";
        }
        return "";
      }
    }
    function Ue(N) {
      return "";
    }
    var Ct = {};
    function ni(N) {
      {
        var J = je();
        if (!J) {
          var ce = typeof N == "string" ? N : N.displayName || N.name;
          ce && (J = `

Check the top-level render call using <` + ce + ">.");
        }
        return J;
      }
    }
    function xi(N, J) {
      {
        if (!N._store || N._store.validated || N.key != null)
          return;
        N._store.validated = !0;
        var ce = ni(J);
        if (Ct[ce])
          return;
        Ct[ce] = !0;
        var Ne = "";
        N && N._owner && N._owner !== jt.current && (Ne = " It was passed a child from " + P(N._owner.type) + "."), Le(N), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ce, Ne), Le(null);
      }
    }
    function Bt(N, J) {
      {
        if (typeof N != "object")
          return;
        if (k(N))
          for (var ce = 0; ce < N.length; ce++) {
            var Ne = N[ce];
            Ee(Ne) && xi(Ne, J);
          }
        else if (Ee(N))
          N._store && (N._store.validated = !0);
        else if (N) {
          var $e = v(N);
          if (typeof $e == "function" && $e !== N.entries)
            for (var at = $e.call(N), qe; !(qe = at.next()).done; )
              Ee(qe.value) && xi(qe.value, J);
        }
      }
    }
    function vr(N) {
      {
        var J = N.type;
        if (J == null || typeof J == "string")
          return;
        var ce;
        if (typeof J == "function")
          ce = J.propTypes;
        else if (typeof J == "object" && (J.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        J.$$typeof === d))
          ce = J.propTypes;
        else
          return;
        if (ce) {
          var Ne = P(J);
          st(ce, N.props, "prop", Ne, N);
        } else if (J.PropTypes !== void 0 && !de) {
          de = !0;
          var $e = P(J);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", $e || "Unknown");
        }
        typeof J.getDefaultProps == "function" && !J.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Yr(N) {
      {
        for (var J = Object.keys(N.props), ce = 0; ce < J.length; ce++) {
          var Ne = J[ce];
          if (Ne !== "children" && Ne !== "key") {
            Le(N), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ne), Le(null);
            break;
          }
        }
        N.ref !== null && (Le(N), _("Invalid attribute `ref` supplied to `React.Fragment`."), Le(null));
      }
    }
    var Aa = {};
    function Ca(N, J, ce, Ne, $e, at) {
      {
        var qe = w(N);
        if (!qe) {
          var He = "";
          (N === void 0 || typeof N == "object" && N !== null && Object.keys(N).length === 0) && (He += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var U = Ue();
          U ? He += U : He += je();
          var q;
          N === null ? q = "null" : k(N) ? q = "array" : N !== void 0 && N.$$typeof === e ? (q = "<" + (P(N.type) || "Unknown") + " />", He = " Did you accidentally export a JSX literal instead of a component?") : q = typeof N, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", q, He);
        }
        var te = xt(N, J, ce, $e, at);
        if (te == null)
          return te;
        if (qe) {
          var ae = J.children;
          if (ae !== void 0)
            if (Ne)
              if (k(ae)) {
                for (var $ = 0; $ < ae.length; $++)
                  Bt(ae[$], N);
                Object.freeze && Object.freeze(ae);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Bt(ae, N);
        }
        if (Qe.call(J, "key")) {
          var Me = P(N), Pe = Object.keys(J).filter(function(yt) {
            return yt !== "key";
          }), Ze = Pe.length > 0 ? "{key: someKey, " + Pe.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Aa[Me + Ze]) {
            var it = Pe.length > 0 ? "{" + Pe.join(": ..., ") + ": ...}" : "{}";
            _(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ze, Me, it, Me), Aa[Me + Ze] = !0;
          }
        }
        return N === n ? Yr(te) : vr(te), te;
      }
    }
    function Mn(N, J, ce) {
      return Ca(N, J, ce, !0);
    }
    function Eo(N, J, ce) {
      return Ca(N, J, ce, !1);
    }
    var kl = Eo, Ul = Mn;
    Zc.Fragment = n, Zc.jsx = kl, Zc.jsxs = Ul;
  }()), Zc;
}
process.env.NODE_ENV === "production" ? Nv.exports = LO() : Nv.exports = kO();
var I = Nv.exports;
const xA = "data:image/svg+xml,%3csvg%20width='300'%20height='50'%20viewBox='0%200%20500%2084'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20width='500'%20height='84'%20fill='url(%23pattern0_10_2)'/%3e%3cdefs%3e%3cpattern%20id='pattern0_10_2'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_10_2'%20transform='scale(0.002%200.0119048)'/%3e%3c/pattern%3e%3cimage%20id='image0_10_2'%20width='500'%20height='84'%20preserveAspectRatio='none'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABUCAYAAAB0vcXQAAAAAXNSR0IArs4c6QAAIABJREFUeF7tXQeYJFW5vfdWro4zw2wgioCoJEUMwDOsGEAFFR/6RFEREAH1IUpQQaIEFcWEiiAGVIKib0URFFBEfQbQJ+CCgODCssvuhE5VXfm+PjVVQ01vz0x3T/eE3arvQ2S6wr3/Def+6fyULPC1YcOGjKZpewiC8JwgCPZkjD07CIIVlNICISRPCMG/JUJImVJa4ZzXov//YBAED3iet0bTtPtVVX2MUore8AXuUvr5VAKpBFIJpBJYaAkADjpGg64eWuieTn4/RMD5vsrl8m6CILyRc/56wsl/EEoEQkhXbclms8S2beL7/oZ6vf6rTCbzy2q1euuyZcs2RO/seEh7Io+lPS96IoIt9SWLeWgXc9u21PmwNPqVzoylMU5za2VXINrNJyuVyrMppScSQt5KCFk+zTtcQsjDhJDHCSElQgg08rLImOdzDk09RwjJEkKWEUKeTQgZEASBQDN3HIcwxggAvlarBZIk/da27Svuv//+H++///4WpXRhgL0bYaXPpBJIJZBKIJVAKoEOJdBXQOecy4Zh/GcQBO8jhLxcEAROOKEBD2LT+AOc819QSv9IKV2TyWTWUEoB6m1d1Wp1med5z1UUZR/XdV8tCMIrGGMZ3/eJ53kEYC8IwngQBN+2bfvr22yzDb5HU3BvS7zpTakEUgmkEghNp6k2tDQmQl8AnXPODMN4G2PsfELILgBYzAhBFIDkd/i+f4PnebcMDAw81ksxcc4Vy7IO9DzvMELIkZIkDQdBwD3PA4jjoHC14zjnDw0NPbFVA3u6Qns57dJ3TfFttTe52rsrFW1/JJBKvz9yXfi39hzQa7XaqznnFxPC9+WchOZwTdVGOeFXm6Z5RaFQeKhVtzdt2pTLZDLPIYQ8k3P+TELIDoQQJTKzi5xzh1I6TiktE0I2BEHwD8YYAuIeb6VxP/TQQ8qKFSveFATBcYyxgxhjOGTSIAjqlmV9yXXdc1euXFlPtfWFn4RpCxa/BBYvBCzels06qku46bP2Lb1hQSTQM0Avl8uDjLEvEkLeEVloKOd8I6X0vGw2eyUhBIA8abnZuHFjVtO0QxhjLyOEHEgI2ZsQwjoNjvN9v+L7/p2MsdsEQbgtm83e26x912q1vSilnyKEHCpJEszx9+i6/oI77rhDXLVqlTdXyafrcq4STJ9PJZBKIJVAKoG5SqAngF6r1V7LOb8qCILt0CDGWKWhWV+azWY/Rwg3KA21YwKfer1eP6yRavY2SunrCCE6Atmmv0KletqfgyD0xYe+crwn8p0/LEkSDhDf13X98SS4V6vVV8iyfKrrul/MZrO3wDVAKZ14SXqlEkglsMQkkB6ll9iApc3tswTmBOgAaNu2P+e67kmKohDDMACs/2NZ1vHLli2Ddh4C+djYWIEx9n7G2AcppTHo96RrUe755Ls47PwTl885/7nv+58qFAp/BLAzSjlv2gOq1eqwIAhfC4IAloT/26p96z0ZkS3kJYsSKxa4UQvw+QX45BYygdNubI0S6BrQOecF0zSv9X3/YKSMqapq+L5/WqFQuDwGRZDGKIpyKmX0I5TQDCLTAMAza+WdDcNmgB7AcT/lHdDAb23cd46u6yGwxwcNBNHZtn1BEAQfJYSMEkJO0nX9ulRz72wM0rtTCcwsgRSW0xmSSmA+JNAVoI+Pjz+DMXaTJEl7oJGyJP/JcZ0jdF1fi/8GaG7cuPFwxtjndF3fMdmRGTTqrvrb7vtgWuecX+O67smFQqEEUOecC7Ztn8A5/1Kk2duO45xXLBYvxG+UUr+rRs36ULrBzSqi9IYF5UXa8sW/BNbgEmjilj9PllYP2wP0xMSqVqugab0d5C6+73NBEG7UNO2dlFIbWL5hw4Zl+Xz+SsbYoa7rclEUN/tGwiwO8J9RYhGoIvCtEGnOUzT8DgA9/A6ldF2DrObDuq7fEGvrlmW9LgiC6wkhGdd1EST3tUKh8MFegXq6LpfWokhbm0oglUAqgaUogfYAPepZvV7fyfO83wmCAD84kPhyTdM+FAeWIWXN87zvSpIEJrfQvN58wdwOf3u1WiW5XA6sbrgFh4E/U0p/Rwj5P9/3/8UYezSXy21MPj86OpoXBGFIFMXdGWNIcXs+53wVIWT7yIwOtXvGcdA0jZTLZV/TtKtWr1594hFHHAEbfLBx48bnZbPZnzRy1XdCRH6Dhe4Luq6f1itQX4qTI21zswTSo1k6J1IJpBJYvBJoG9BHRka203X9TkrpMwOwtXB+Rjab/UxsYq9Wqx9paLifCdngpglNjwEeLG6O4xiiKK5uAPN1uVzuFkqp1Y2YoGU7jrN7EARv5py/mxCye5w2F78vBnlExeP/4x+krzmO8wdZlo/QNO1JHAg2bNiwcz6f/xVy4aM0u0s1Tft4CurdjEz6TCqBVAKpBFIJzKcE2gJ05Jjruv5by7KeyzkPBEH4VCaT+WQE5uKGDRs+VywWEcHOgyCY7Z3ws3++Xq9/c2hoqNpLVkGAe71eP4Axdirn/I0T7vwwrn3StA8gB7BblkWgrQtUeNxyrNcjfx33VSqV3ZHPTgjZjlJaJ4Scoev6F1NQn2ZapkrrfK7X9FupBFIJpBKYVgKzgS+AkNm2/UPHcd4MwBYE4Yu6rp8cgaRcq9WuURTlCPjLZyGFGSGEfELX9asIIUG/Gdocx3keUtE454fiEIJ+oM2u64bsdbIsh8Cuqiqqta13HOcNxWLxHtyDOAEQ1QRBsFwQhDHP896Yz+fv6k30e6cIGN3f6WPppE8lMC8SSCfmvIg5ZVSfHzEv8a/MCOjQbqvV6oc555dCyaWM3pjP5f8TfQbL2gEHHHBlEAQwc4eacNJ/DV85gNO2bT+fz39t7dq1Z+24445hdPl8yQxtMk3zjZTSLxNCto0APfTtx4CONkeuAJRbfaOu63/CfeVy+SXw6cuyjAPNg47jvHCbbbYxQjnMYx/mS1bpd7ZGCfQKjHv1nq1xDNI+b7kSmP91MSOgR6D2W865SAh5NAiCfQcGBkrQVGu12qWe552squqkZh4DOv4d5Zo/6TjOewuFAljZFqzKWalUGpAk6TJK6btgHYgoZjebR5zzfzuO8woUjYGJ3TTNoxtEON/ww+oy5Ke5XA5+epFSOme62C13Eqc9SyWQSiCVwGYSCNENezFjDKWv4drcidKQnwRlsaEQViilcMM+Rjh/SNW0+yilYdR0erUngWkBnXOeaZQ+vS8IgmegoIkkSQdmMpm/ApgrlcpJmqZ9SZIkblnWlHfAhA2zdr1e/61hGIevXLlydDFotADoer2OeuyXRaLZjHMWB5Eg8P9qGOZLV6xYYYBvXlXVy2VZPooQUmtYG84qFAqXzbc/vdNzHudcN03zlYj+B2Ne5AoJXxMVtMEhbU60t/fdd5+84447vkiW5X0453bDvcFAwYsrNNdQqvi+/0Qmk/lJ94e5mXsev9c0zR0YY6+PDl7hQ4IgiEEQoJDPbyMK4Fn7G7+vUqlgwwE1MZ4X4n61t6R6ehcOy4wxhnKBd6mq+uBs43bOOeewc845JxgdHd1eUZSXc87zeD6ymIXvqtfrvykUCg/P9q5OehLLrlarreCcv5wxNgQPVyKZXhIE4Zeqqj7U5XfDcUX/zjjjjNfatr1rIzDXUlUVQAAXXoYx9ntZlv88e7spmXgk5KLI1uv1VzPGtvN9H9k2s7ohZ39/d3f4vo9GyaIoPqiq6u/aDRSO5Wnb9uGc822xHqPOId5JHR0d/eOKFSvu6R+vRuv+xnOxVqs9jzH2XyhxTSndBwuqVQZU01swNmD7vJtzfhvn/Lv5fP6B7iTb/VOJef0aSukzpnsTCodpmnZjv2UMZlPG2JswT5P7EmLCKKU/bDl50YlarXYeIeTMaHP+YC6X+wo6MzIy8iJFUe4KgkDM5XIUL8KFAUL0OnLTGWM/yuVy72wuyNK9WHv3pGVZr25YGlaDD6dZU58A9AB9+Vk2m30DvooNShTFO0VB3K1m1NbWarV9t9tuu/HFaHpPbqqMse8TQpDSB0CfQNqJcbpC07TjQdtLKUV6XkdX/A0ARaVSuViWZRDzuJxzKcEAGFptMMkrlcopy5Yt+9Zf/vIXab/99tus1n2nh5VkY+ODlWVZB3POb/Y8zxcEgWEOSpLEgiBYyxh7n6qqsBDNalmJi/VUKpVjRFG8EhtjVPEvdst0JKse3Bxbv1AV8ERN074FOUelgFu+Pu5nuVx+ra7rV3qeh0NdXK+Acc7rmqYdSyn9/nRj0k27E7I7kFJ6FWMM2SaYezg4A6iEIAiOymaz17QzFhO4+rR3Lp53aPNuu+22WlXVgz3P83Bwi9JM5Qbz40Wapn3i6TPl9O69GATr9fozOOc3CIKwH+ZPEARCksmyDeDpRlyTzzS5KXFwE13Xva7BXIk9d1M7h+F4LVuWdTeldN84Zgjr0nVdKZvNXvjkk09esMMOO9Tbed+cOjQhfHbDDTeIr3zlK4+UZRnxVnvLskxh6OxEnvF+HGctNep//Mn3/cvy+fwPZ1oDc21/qz2mWq3eyBhDHFkr7pTY6ntoJpO5aWKj7WW499MtMgzjhZyQ/6UTB/1QnpATlGjP8/ZpCejlcnk3Qsh9jYkgG4bxx3w+/xK8EuYSURTv4ZyDKW4SyOPPAfwJId/KZDLvnY+JM+1paRZZ1uv1l4LnHcVhpgF1qwF2H89ms5/H0NRqtYMymcwvy+WyA6DM5/NHt7cp9XJqzf6uhQD0fD5/Qr1edz3Pk0RRTC7YcJIHQfBX0zTfMDw8/GSXmtm0HY8BfXR09OBMJnOz67q+KIoMAZqqquLfay3Let/Q0FBHgF6v148RBAFgOAnos0u/L3fMCdBxKGn0Y3ts8FHrmOd59SAIji0UCn0F9Gw2u3u9XofRBBtPoOu6UKlUjioUCm0C+lR5JgF9r732Wi3L8sGWZXlQLHAw1TRNrlarF+Xz+Y4B3XXdGxob8X6I9/F9fzNA79PeHHYwCeiiKIaAXq/XrzNN84MrV67sCNBN07y7kQocAjrk7vu+m81mpWq1emG5XO47oCcOSdj/z0EJ7BiUY/DpdJUkQD0Ul67riIt6pGFN+ditt95641vf+tY+sXlOtDTeYwDogiC8eYb2Y61uaGjpe1NKEQDelwuATgDolIYAHAM6Dkuu624O6BgU0zRvcl33kIaGDl/x/sVi8S9YUIZhXNXwMx8dmW6nHAaik9f/aJoWdnoxmNlnkqhpmijZ+uvoLDWpwSYmEEhtXpHL5dagVjui83VdPyIIgk2lUumNQ0NDf+gYoPq5M0SUu5A7rArTaegNk9wVmUymJxp6uVy+uFAonGCaZgjoSAlsxdzXcNt8K5vN4hA0o3bZ6QpIAno2m70ZG3IUxMgzeobZjt01oEuidKXjOimgtzkosYY+NjZ2oCRJV80HoNfrdS86WHcN6KCxFgThhmw2u59lWf6E0j+5HXSkUbYpqim3NQO6wATRsq3rqtVqx4BuGMbdqqzs6wV+4HleCOi5XK7vgB7vgxs2bNgTAdBROezJAwusnq0UwHbk1QToRNd1YppmkM1m2fj4+K0o+lUsFh9t513d3BPvMZVK5UZRFGcDdPhwrlqzZs0JrayRU77fJRZ0DOgjIyMHybL8K1mWkVP+ZV3XP4SG1Ov1lwVB8Jtm0pbEBv47TdPgt3UXO5jHgjVNExH7NyTN0skFFgTBXblc7qW4v1qtPldTtb+7novVfqemaS/vpcmym8nW/Eyzhk4pXQU/VNLk3ktAh8kdGjoAHaY9ZA40AXqoYQqCMMI5P1lRlO/10rKRBPRcLnczNmRFUZhlWRwL3rKsmQG9aVHFoNSJhh6fkKcxxU07rLGcZmE2XHIa+qICdEZ5wmrfDKRhTEUM6Llcbj9YFJoBvbmQVKvxwj2Rq64llXUrM3Pze/DfgiAg1kF0HGcaQG+NArHJvVqt3q3r+r6e54WA7nmem8/n+wro8RrctGnTkaqqfqmR1jyYFHRzPzsxuTdbMPDfiqyQag1xc4TDtaYoSo1zflQ+n4cbtedXM6DPss4RswC31iGqqv6i540hBBVNO9PQy+XyzfBP+b5fdhxn52KxOI4JY5omcrTDYizJK+rgJvhudF1/oh+d6Nc7oTFalgUSmk9NgDoVnrZOhl81HMc5aWBg4Nucc81xnNNQtc3zvBHHcd5WLBZv71hL71dnWmjojLFVQRAsJKAD4AP4s13XvbtUKr1uxYoVG3slszkDetNYJAGdMXZlFCSlzDRkmP/YzKHVxUyE7WxaKaB3linSyuTeCw0dPvTY5I4DIUzuSQ29HUDH/YgfSgI7TKDxe2YD9Bj0ouDH0Ideq9U61tA7A/QuVcTEYogP57Va7dOiKJ6M/bTVQaUZL6JgyTWEkH8QQtYhsj0IAsT0aBGh13M8z3suBgJyTI4BfMUIvMZag8yjIDSBc35cLpf7ZkxD3qtttkNADy3TjuMAB59XKBTGetWO+D0dAXqtVtuLMfZ3xhg0g0sbJVEBdmBfOwkVyaZpHMxeh2az2b6cSHotkBZabb5er/+UEPKyViltvu8/cPPNN+8JXw247CmliDTGxF2t6zrS2HpqRp5Lf5sijb8vy/JmgB4EQc9M7m1o6OFJmjEWchRwzq/UNO24bmXWvAX1GtDj9zXiRg4RBOEizvmTQRBI041JvNFgY1EUBUE/iPZHENreyX0vChAE6+CaRnAbXDl4ZxjxhY1phgvZAogIRkzHF9sJ7ksGxS2ED31Raegz8EXEh0q4pxqgcJYois/zPK+GbA2MRzy2Sd9vkkI6jiKnlO4niuKAbdsIxAQNNZixmSiKjzLGUJMCAzzpnmw2IcdjH5mlfUTr+77/C9d1vzw4OFhuJxYp1tDL5fLd2Wx2XjT0eJ4ZhoFg6eNjK+A0h9l4kv8MMVaapv0ySk/bbOonMk1Qs+OVnPNjRVE8yLbt8KDVrCFH6ydWWj6QzWa/1stI81aAPuOCnZgkmB5fVVUVdU56muLcDOhxW1r60E3TvIYQ8o4G3SlC13eDxo2a4fV6HSku2Kg2w0Pf96/O5/PHTJ14cz/9zQXY2n92op22bT/H9/2/hZOSEiE200FIQRDYkiR9Utf1T8OXLsvyhaqqfoBzDiKaV0SpRH3PsW9HoklAD4Lg+6qqropSuSadggsA6CGoR3mmALMPRTXnZ406n20cew3os31vloUc9qdaraJs8I8ScZlh6hmlFBv88aqq/rKXbocWB9SwHYhyTwG9PyRWEZ00DlqeaZq3y5K8yqybcPcInuc5uq7LlmVd8Mgjj5y/5557Ou2A8hznXpixUiqV7s7lcn0H9Hj+joyMnK9p2qlxJgj60AToMZD/oHGw+aSqqv/qpJ+x3EZHR587MDBwvmEYb2SMPR3gMPVAHIP6W3O5HNyoPbm6APTwnB6t+YM0TUNl0p5dk4DOKEu6k1oCumEYb2qkGv13o8jJo3Gkummax4BcZZoWbWyYh56Tz+fH5+43bweyeiaXKS/CBK3X6x9tTMyLmtO8wPduGMZD2Wz2WXhobGxsb0VR/k8URQsap6qqKLM6Z3DqRc+aAV3X9FWu504xufcS0Gu12sXZbLalDz3BwBfB+cQkD4LgT4899tghe+yxx9hspvfZZsRSAXSEeWNNpYDe2yj3uZjc57LemgEdB+darearqhoCOiLuOwH02eb5bG2NNfTx8fG7G77kvgJ6vObK5TJKZn+ZUlqILLqhFSIC9DiN65+NctXHNWKr7pytD7MclsN4B6Sn+r7/1YaWP10+eBjxTik9UNf1P7b7zZnk3yWgx/mW/7Zt+/kgY2u3LbPd15GGHr8s7kRExoJk/l1bfAj86CdmMpmv9/sEOlsne/F7tVpdJgjCXyIylnBe4H8cx4E51ajVascODw9fi9Q9ALksy4cLgvCIqqoguEgBfSIoboIOkPN/c87/jzF2WOKAFGrpCJyrVqtfKxaLJ4CcBhpMt+O3KAA92g3iOZDU0CfCF2iYE+/7/qOc8+Oz2WyqoXexXnrtQ+92zuG5dgDdNM0LHn300XnV0PsN6EnSIkmSfpPL5Z5pmuaUGh6xT9v3/Rsx3/P5fE9SuCKZY+8YFEXxes45ArCbr7A4mCAID3ie99K5fzskIIIlxo+j3BMWiNjq+GtUIEWKHhZ7HByZCB7/gqZpH+mVG6ArQI+lVK1WXyEIwh0RiUpzzvq/VVXdZT4Krcxl8bX7LCbr6aef/i7O+dVRup6Y9Jl5nvebgYGBVyCyfeedd37z4ODgda7rbqpWq+8cGhq6dTZts912zOW+djR0PwiuyPYoba2Fhh5omsYQk+D7/scFQbg38iHBTIb5EyA/3LKsDZZlIdgQi77rw9CiAPRowFoBekSkgUhcBAWmgN7jPPRuNPS5asPNgN7I/rk91tA1VRNcz3VUVZUrlcoFjz/++BYF6HHsi2EYq4MgOLQ5YBCHd/ANVKvVq2zb/vDw8HC118oe1jzGoFwug4sAbI5TLrgYZVlGMN1n1q1bd9Zuu+2G1NOOr3iezKChx5U8f8YYu5wQ8kPf9xHUl7xAqISYjP/Qdf134Q9znICtAD2Oy2iZhx63BgNhmuY3KKXHhO2gU/AcDf1vVVW/3OsB61jyPXwgotX7Kwq5RBGrYaejwIuNkiT9B6grx8bGdmwUpXlUEAQwn10xMDDwobkA0/Rd6Gz02wH0zk3urRm7wBTXAtB9TdMEwzRvzWYyrzVN8zMNLma4MqCFg5kvFCdA3ff9Pzz66KMH77rrrtVzzz2Xgq6006FsBnTbsny5k7S1Tj84w/3x+I+Pjx8uy3LoQ4+icLmu6cyyLeTKphp6D4llugH0Xgx5UkOfAuiKJniB5yiKssUBerzWTNMEvSxcsEhPS2rnoWvP9/0fB0FwTJQd1ZfYIrQFe8Zpp52GNOoDmscUwfFIP6xWq3utWLHivrmM+WyAzjn/RaOg1+vq9fqXfd9/f0TVPAmjEW7+U9O0/XrBSz8zoE/DFIfWRHzg6yml+WZAB6WnoiioXgbO4HmrnjaXgZl4dmaAhAl4l112Oc0PgvMFxkIayERUJWgTP5nNZj+L+vCEkG/m8/k3mqa5JpPJoE78gke79wfQp0o9Sf3aDOiiJPkZXQdn/h26rr8SZWglSfpOwPm+NKKgrdfrXNO0kIfY87yv6Lr+gVlN79MMWysNHcQyjuOEeeiGYax1HKdtprju51domtssKA4aOo7xuVwOZE1LEtDbPVIuNWKZ7sd6qsl9Og29XKlc8MQWpKEntHNUo0Qu9BRNFEDGOX/IcZxXDQ4Oru2noheb30dGRlZkMhn4ymHuDpXOaL8OMw0459fCVYq6HN2O90yAjk+6rvvz0dHRt3iex1esWHE/YwxW68krwkcso4s1TTuzG9N7cg1OZ3KHlm7b9gRTXLVaBWe7Aw7zXC53P/5mGMbr8N8JHt3JUwch5GpN05oi27sV2eJ6zrKsXV3XfUiSJM/3fWzSk2QRKJCh6zpoYxXXdY8SBOEbrus+ZVkWaqmDTW/WAiD97O1CA7okSaHJDZucrusHoa+QDeccaYFIbwxN70jlgaxc133Stu33DQ8P/6wbC8fiAfRwk587oLeLnm1YCtIo9/5Vd5xWQ99CTe4J7fwIzvnXCSEDMS7g0CpJEiyVkm3brykWi7/s5x4Xv/v6668XolRiMFCiPDZovAnop23bRtqhp+u6uH79+uduu+22yHnv6moH0HO53OGUUrtWq72qkcYILvdJ7oqmIMGXtBWsN8M+0Bagl8vl9YSQFZIkfVfXdfiR6fj4+CW6riMPfYogOAh6PP+gXC4Hc8cWd3HOC9VqdbWiKC9DTimYfxKHmg3j4+N7bbvttiOVSmV3RVEesG27ZNv2GcPDwwgODAMoFkoorQDdcZ2+EcvEGnqtVnMFQZDgv8pms+Dsvq1QKLwKIPfYY4+JQ0NDZ+dyuTMqlQoOjTK0c1EUA4EJMEX/Znx8/JDtt98+rPLTicWnHUAPguB9Ufnern317Yxn66C4AO4ans/nQw09DYrrbZQ7uNw9zxMFQeiY+rWdMZ3unukAHSlVMa/8YvGhg/q1VqvNics9jqI3TRNVz6YEo6GgDdL1KKXfrtVqHxoaGqr0UztPjkm85iqVyl2NSn4HxnnqcHXBnw8OB8/zPpfL5T7WTSEqvCTeY0ql0o2SJIXFWaIrdDd4nvdzlNWO31+pVL4my/Jx8J0joLqJRvh+VVVfRCk1u51/MaAna5DEhEahhl4qlXaRZflhfMBxnBOLxeJXoT1VKpU/KoqyXzOge543msvltmlv0HqgcnTb8y6fwySpVCof1DTtc7Ztx9Wcwrdxzsu+778zn8/fZBgGXA5/C4JgIAiCbxQKhRPxLKPUmzgCzX/fJ8aE8VqtugJ56EhbmxHQGXWmo8acaTOLyk5O+tCTgA4N3XXd21RVfdWTTz6pb7vttmalUnmWIAjX6rr+fNM0w4WGVJcoIh7z7rP5fP7UWU3vTY1KAX3zUZqWWGbC29n34iybEct4PmNC/4qzpIAe7kthHnqrKPe5AnpsdYzWMHKqt4sVnCi2yBVFUWpUsNwX5bW73Ha7eixuW7lcfp0kSdcxxrIRgVW4XUf/bNQ07TmU0VKne12ngI72rF+/Xi0UCn8XRTE0vcOCkTwANIrmnJfNZs+dYLTrHCOSgB4HMDQD+ltkWf5hBOgvKBaLqKaWN02zFEUxTomGa5wCflwsFhEY0ZeAh65GtscPjY+PPz+Tydxj23Y4WROvBw3UZzKZzJmVSmXI87zv5XP517qeCx77/+gUkHrc7DCdJi7O0hagz7F8arOGjtN6LpeDyf02XdehoatxnAUWnaqqcOGEpnekl8D0HuVow+fWdpnTyRUSWURQbS3mckeKGPxZ8KHXarW1862hR0FDk8QyqPxWKBRSDb1P1dYWG6BDLwKxzJaiocdZq3WfAAAgAElEQVQHxFKpdFqj+BIqqGmxXxjWSKxlz/MQ9f6efgbCTbdXxvU0fNe/16ibe4rilMI6UNVF3/dflc1mb+tmv51NQ4cPPZ/Phxp6vP9Wq9VXMsZ+LoqikgD08HwA/nnf918MF2037Wmloce005Zl7QNa1zMdxzkf0cf5fD4Hc4BpmjAL/DEqh5oEdG7b9n8PDAx8qW1A7/wQ0k0/e/JMYkCWaar2QN2qF0RRRA8mSBMYJb7n35LJZA4Ga1yj3vAnBgcGT3c9d+0ll1yy89lnnw3zPDTQBQkUXMyA/uijj6rDw8PnqIp6uh/4DrJL4OuC6T2TySCV7XZN0+IKfziZzCrDVhp6CugTvvytwYe+GE3uWyCgxyx0N0uSdHBTthPKSaPOx9sHBwev7ckm3OFL4j2gWq2eBUXLtm05YVUOrYG2bV9aKBQ+3o3ZvRNAjzT6MI6qVCp9nVJ6LPajZJcAvo7j/K1UKh2A+vQddneyOEvS5D4F0CuVyncIIQjwAjvcMwEKhmG8UxTF77TgmQZbz8sHBwfv6rQhS+n+0dHRPOhJKaUHJ/jdQwtHEAQP6rr+bJi5KpXKEblc7hrHcdY7jrMqn88/GJMvLER/FwugW5Z1m6ZpoYYOHvLYNGZZ1rMopZDr81AFDoUwoopJ4EHHYfHTxWLxjHYtHSmgd2Byn7h1/k3ufa6Hnmro/TO5x7EC5557bvChD33oHwMDA7ujkmHCn4hUU8+27T2KxeIjbSt5Pdwc429GDJ6/EUWxmDRz43dFVv53vDT+GuTFd/rp2QCdc/5z1PRIHhZi0/vAwMDfBUHYBQVlEKxnWVaY9YK6Dw1r5lnZbPbCTovJzKqhVyqVOwRBeAWlNEw1igD9U6IofiyuHpUQQuD7/rJcLjfWjgbVqfAWy/2PP/64tnLlys+g0hpjLA4qiwF93U033bQTIiwty3qVLMu/bMQebISpdXBw8HcLGem+WAE9OrmG7oBKpXKoIAiroUVGla3w95Aq0vf9xzzPQw7r7XEa1ExzIgX0RQzomezudauOQxu8KgFiKyo9JpZJNfSJ8e+XDz3ey0ql0n6SJP2PKIqIG8JJHBbL0NzeIE35VRAER+ZyuU0LAehR/8OUYcMwHmOMoYDWZNEj3/c9TdUFs24M5/P50U4xpktAD/e6Uqn0almWf0opVSRRIo47ESQXFfJBsa8XDA4O/r2TNs0K6MijJoQ8mxDyA13Xj8QgVqvVb8qy/O4WgD6WyWSGFmrgOun4lHs7NPvDb7Rx48b/Hh4e/qzjOKEfJllgxLbtA3AiXbdu3fNXrlx5j+M4I6ihPTAwsDpOp+i6rW0+2KpLSwHQYXpfuXLlOYqinO44Tmh6b0rt+KWqqjC9h0EtMx0cU0DvDNA5Dk2eVw+C4NhCofD92P/Y5pSb8bZZ89A1XahUt/wo98Vucg84p6wNd1YElGHWjmmab3Uc56uodS6KYlxNDLEwKPV6SS6XQ5BXx+bjXsy7qJ2hm6lULv1YkZU3xeVs8Zvv+66malLdqu+Ry+VQrrWjqxtAj9oUmt4bwdNX+L5/LA5BoL2O0+oa8QgA9r888cQTB3ZCfz0roBuGsYkQgqj1L2SzWdS0RTDRjyRJelMzoKN0aGRu3gIC4mZG+dHR0bcV8oVrPT/MgQgBHYDJGButVquv32abbRBj8AwU3bAsa9y27Y8ODAx8cyFT1xYzoCcnOUzvhBBEpYamdxD4JOI1YAW6MJfLnTWb6T0F9M4APTW5d7SXT3vzTGlrMaCXKpUL1i0CYpm5RLnHAXGWZaGi2jmSJOkIOPU8D/ugSylFqupxuq5f1RuLbYeaVzRCCdC9RBCEU2RZDmm7gV8TGromVqqVwwYHB8GH0dHVLaDH+93dd9+t7rrrrv+QZXknpNOhTYqiEATLwvQuMvFUJrJL25VfO4BeI4RkGtScF2YymU9EgH6bJEmvaOFD/5Ou6y9echp6R0M4cXO5XH490tOQupYEdLDkua77ZuThm6a5g+/7axljtcYJ7Nx8Pv/ZdkzF0zenuwkdv2+xA3o0ycPD4NjY2KGZTGY1fHAA9JjrPTLz/ct13ffk8/nfznRA6j2gdy//ePNLo9zHDpQk6apsNrt7vZ6a3OezfGqv09ZidjjTNC/mnJ8C8hhkPgGYkPuPgDjP8w7OZrO3dLHFTvtIp6sw3gfK5fJJoih+VhRFFdgVFUoJq+CBMS6Xy13dqc96joAe7nXIwpEkCdzzSO9L9pvDSskY2wfxV+3IcFZAr1arYPmBBnoOTCeRyf1/ZVl+YQtAj9ORtgANfWbxlUqlgwqFwq+QuoaJDA0dqVacc5TCOzKTydxsmub2vu8/EqViXZDP5y/qhvGsnYFs556lBOiIDWlUajq7kdb2McZYyPWOU7VpmsHQ0BCsRLdeeumlh5x9Nm5pbXrvJaB3uok0j0cK6HeIq1at8jbLQ0996PNWD71fgG4YxhcJISdFNb6hXcJ0bGuapjTW6QH5fP4P7exP/bonkY/+TlmWEV2ux9gFl0EE6B/KZrOXd0r8NRdAb7JKXmnb9nslSZqSNYYsKtd1f7dmzZpV++23H7BmxmtWQK9UKsdFdJx/ymazf4s09DslSTqwBaDfqev6y7cGDX18fPzlxWLx10lAR7+DIAC5zLsadYdXxxo6IaTWOPmB5/3zc9PQZxvOmX9fCoDeNMl355zfEATBXgg+hKaOaHdMelhGcrncBYIgnDud6X1isTF/dHSkZR56tVZby+eZKS7V0FMNHXnoi4XLfS4m93jdwQ9MCAFOhFzpAHRJkkJAL5VK+w4MDPx1ITEhBnTTNN8CxjpYnIFdsCYAwMFkZxjGGZlMBqbtkEau3WuugB5bJR988MHstttue68oijslvw0XBkDd9/3/zmazX2plem/F5T5t2loLTSPUjiRJOqgFoP9Z1/UXLeTgtTsQc72vUqm8IZfL/bTZ5B4EwXgQBG/J5XJ3mKa5o+/7/4aF3vf9j0UsewtG/7pUAD1pejcMAzXTEUEbRr1H/smwIlsjffLhRsGHdxQKhT+1Mr33UkOf63xJNfQeaugtzCXx3EYg35577bVakeWD0yj3iVnbxyj3OHocXOknxCACk3sM6JVK5SWFQgEFUhbsigG9Xq+/g3OOw0fI6w6LX6yhV6vVk/P5/JfnW0NP7nVPPfXUa3K5HLjeJ8nKIl8/r9frKLs7q+l9Vg29eRSQR33qqaf+BPVu8VuSi5YQ8kAjP/s5WwGg03K5fGQ+n7+mGdBd1x21bfvg4eHhv4yPj+9ULBYfq9Vq457npUFxEVNccx56q5UezyHOuVatVs/XNf0jjuvAPBmWWVVVNfA8j9m2vRpV7aIUGZTtnSScSfjODs7omZuRJgUiB2j5uq6nTHGieKUgCNs3qgTGjrulmYdO4e+aYEEEoO+1117wRy4AoE+cNNoJitsSmOISPvRPN1yNJwdBEAIRQEiSpNCH7rpu1yxsvToBxPuAYRjHU0o/TynVYgrYIAh81KmvGbXjCoXCN+fTh57sX7zfGYaBAMKjGUMQ/EThr8jXj9vvUFX1NTNZEToGdHy4XC5fpSjK0fHgJRpm6LoOvtwt2ocOs/n+++9/kqIolzUDuiAIm+r1+oGFQuEhy7LCAi2NogRjrut+YHBw8AdbXZR7JnNCzTCmFGdpB9CjuRWmdlSr1eeKongd53zPOL8VmzcmPefcbvC+n60oyiXNpvctD9Dn6sl/uupbkiku4DwI38w5Djt9TVurVCoHUko3C4rTNA31qY8q9LAeeqqh91dDj9Maa7Uaipuc5fs+gDJcl6iwhih3UL5qmgYz94JdCUA/v5E+dzraFbPFxVHu1Vr1LQMDAzd22shemNzjbwI3YXpfsWLFvbqu7xQxZU7+HBGXnaDrOuIAWjJldgXotVrtzAYbxHlg3EHeXOJCStHKbDa7qd0w+04FuBjuh9ZYqVQ+qygKCq6E9IFxHnq9Xn8SBW123nlna3R09DWDg4O31Gq1jZ7nvXVgYOA3cyOWmduGvhAm90wmc4LRJaAnzVEjIyOH5/P5HzHKPNux4bagoIUVRRFVi9ZUKpV3LFu2DL66SZfGlgfoc5/9yeIsjLErZVkONfTIfbYggC4IAlwobQD69PM/aXJfOA19EkDRUMxDL1kPHdXWFnseeifKWBwPVKvV3hEEwZcFQSiiemAjroUKghBn/5wry/JFKB8699nb3RviOV+r1b7PGPuvuOgT3pYA9OcPDAz8rdMvzAbolNKfq6o6hSluum/Esi+Xy4dQSuFmhEtjsjx3hDEmpXRPTdMea/UeAHoQBP8Ltqb49ynUr7VaDb5yfCCXy+WOj5jiQDBzDZLfm/zoMIO+AulEnQpmKd0/NjZWyGazNzDKXu16Lsy8k8LjnD+A6j2gNa3VakcjctI0zXX1ev3FQ0NDT6KfC3XYgSI2UW2t1l61tR4UZ9F1/QTTNEMNHYcfaGK2bU+hfp1p7ONJjspsy5cvP58xdoplWa7neWGKDMBAURSQHd2Yz+ffkjS9p4C+uWRnAnQcNoMg6LuGLoriVZqmTaatRWOI1KEJDT3gImUdByctApP71gXoMUkWrC6SJN2gKMpKwzBiQA8ZNBljq+v1+nvBwtbJYaGXeJBwDSD1C/TSkyCJ+rq6pot1qw6GU3CudHT1EtCTCsy6deu+OTg4+J7IfTOlTZzzW3Vdf10rf/+sgF6pVD4my/KF9Xqdj4yMFHfbbbfK6OjoSzRN+wOS35vD7B3HOb1YLH5moQZvsudzU2ZbDmrcp2q1Oqyp2n1+4G+DVLW4OEs0IDfpun4oKtI1ZHa27/unMMYey2QyO8cTq60ZM5f2T/NsJxp6wLnM5gjotm1fLAriCXWr3jWgRzINTe+2bT8XXO9BEOzpum4Y9Q5mKpj4CCF1zvmZuq5/Lja9twJ0aPQLXW2NEDKl2hrqodfr9UcZY8erqvrLfqY2JgGdUnqlqqrbQz3HPAZblWEYnq7rx+bz+W93NF+bJnXzFEzUg18lSdKViqI807Ks8LsYW1mSBcu2jspms9d00//pNHTXdcN66GFkebl8UbFY/ERMAtWvg/VmPnRFXVUzauC4ndTQt4Qo96if9KmnntIYY38dHh7eDTiBAYVsAZyU0hHDMF40MDDw2EJgQgyI9Xp9B0opyrcORntKyASG+aer+t9LldJLUau9rb05cVO8x1QqlRtFUZxSDz3q7+Ya+ix7e2x632677e4jhOyYULbDpkd4c0zDLI+8+Smm9xjQ4wDFSOkJFe+w2trY2NjrFEX5Gf5gmuaBy5cv/z3nXK9UKuMSVPSo0ljcR9/3f4KC7gsxeJ0ORrf3G4YB7uI/gzYwGZFICHE555fpun5auVwelCTpakVRDjNN8w+5XO6A2ZjNum1Pu891AuhxZGy7747vSwSz5QHojLETkNoHDR0WLqSIOI7Ttobe/F6kfTHGftQAbxyuoQGEZVajCXw/TGqKotwXaephFGu5XJ4MiltUgE4JcR2XLwSg12q1VwVBAEDfKQZ0RCdnMhlqWdaJmUzmq3MB9OZ5E4M0uPobmtzXBSasdFwniOdLNC5H6rqOOJOQqrOtuRdtjosa0FV1Va2WAHRNlyvVygWPd8QU1/0Jv19R7hifhx56SNltt91szvntKEAVB5tFYO4ITJAN0zikUCj8oq3x7OVNE8GSoQvO9/2TbNv+LKVUTVRbC8szW5Z1eaFQOKUbt0BXgD5LHxOm99cSQn4mJmu+RkYgQojR2Af3aja9zwroIyMj2ymK8kRUJP3EXC6HhQ4T512SJO0fCicx13zfH8lmsytQhaxfJ+Bejnmn78JmU6/XTxZF8TPwv0SbT/gaznm5QfX67kwm8z+GYayklP5JUZRtDdO4Jp/Lv7uX3Nidtjtpztnc5I4YgImDHtI6MpkMXCthWcTZvzN1o+k3oOMwaRjGBaIofrhRnjZ5oApPro3KTjcUi8W3YlzQ9qhU6OIEdJwA3XkH9HCDq1QqL+WcX5nRM8/yA9/H4QjzGeZHyujHBEG4uJcH0PhwALO6JEmXB0GA4NmQ0Rc+V/AMeJ73Nl3XcVhrH9CjCbqkAH3e6qFPRt2Ha7nXxDLRfhGmrm3cuPF8SZJO0zQNWSjhWmSMxfXGr6xWqx9etmxZbb4VvXjPrVQqqLT2stjcjnmH9iEUp16vHz4wMPDj2fe6KVAX75fxempfQ2/jQ7GcKpXKtymlR8WKc1Jb55zflMlkDkvibLlcfmGjCuj/xm7gzTR0fBt87r7vb0MI+XY+nw/t+q7rfsbzvI80t822bZiWXl8oFLqj++v+INqGmOZ+C+e8UK/X/0dgwssDHkDDgDk4Lkiw3jTN5wwODpYNw3g+pfQe3/dLnPPT8/n8FQsZ4T4zoBOYArsE9KkybQZ0SukJjuOEGjqARBIlwfXcjjX0qP2TUe/gepckaU/45eGrwyYCDukgCIxGyszHdV3/YlyeddFq6AsI6JifnucB0PeNAT0IAheBOJzzr+i6/gHM7dkK4LS7ouIDYr1eP7MRRHo+rAJRVS4uyzLjnCO188hsNvuLbsiXthRAb739zW1T7KeGHgf5btq0ab9MJvNTxhiUuRjQQ6u27/uB67rPLRQK4I3oLgOqCxHEpao3bdq0r6Iot6uqWoAVKtpL0EZY9mxd13eklHZcaS16T18APd6vCSGFWq12LyFke/wtAeihuwCV7AqFwg/iddgWoJdKJQQ8/CfnfKOu68vx8FNPPfVqTdNuFQQhtumH70SUIyHkqlwud1zXg9fuLrEA99m2/Rzf9/+B012sBcbNoJT+TlXV/0AUfBAE76OUXua67nrUiEca20LLYyFM7r0E9OShZHx8/HBoc0EQYIWGXO+R6ZiJongvY+ytSBnEM7Va7WBRFG+Oa3V25UPvYkNJTs8kscwC+9DDQxFoiV3XBaC/1g+gHHsiNHRFUUTTNG8qFovHUEo3zi0rY/KQmIz6/gal9FhYV5C3jDFBhLtt22sEQXhPI9inJUnQbEt9SwH02frZze/9BHS0JxGz8kfLsl6U8POGFrIgCGAtu1jTNFRds7rpQzfPJNw8P5Jl+fCwbKrvT5RpjCOEOf8WAne7bVc/TO4J5WqypLQkST9GzFDMcBdjre/7Y6g3v3z58qfwtxjQYx86ItynRLnjpvHx8aNVVUWlMOI4zguKxeI9mCRI0eKcDzULm1JaMgxjx2222QaUpy3z5boZoIV+BhN3l112Oa0xiMhnjDXDuFmYqOc16A4vgv9cFMVv6rr+xtHR0Xu32WabvbvxR84RQzYT15YE6DC927Z9QWMOTzG9J6qyXavr+tt7BuhznHyLCNAnNaRSqXRlNpM9xg/8MGsAByJBEJC6tk6SJKz5ngToxZveyMjIszOZzNWEkJcgngIHMdd1QzO/WTdvFkXx/bqur+3mELFVAXqHG0O/AT2e2yMjIydkMplPE0KyCVDHksRYwwoDLf6vSRftHJfVtI/HcwhZWqIoIgi1EGdkRQxxobmdc/5iHCK7bUc/AT2pwNTr9e8EQfBOaOVJLd11XZrP528477zz/uucc84J2gL0arW6TBTF9RBSo/73mcVi8VNYQJZlXYHayc3CQJCS4zgfKRQKly20VtrtQLV6DnJolI0Fnz3MSriSRPo4Ib1Y07R/m6a5neM4DzHGRFSW0jTthG78gt20faa1viUAejTJJ03vjLEbGGPPjQEiAejVRs4vTO9fRiCWLMur56ShdzMYiWcWC6BH8gv9nqVS6YxsJnsRNHTf98WoSpYnorKGbX8in89f2It5Gx9mK5XKsZIkgSZUiTd813WdTCYjG4ZxaT6f/2hyE+tE5FsVoHcimD5SvyY1SRzObrjhBn7ooYf+nRCC9Zi03MbKz69d1z0in8+PdIILHZ5fwmYBaO+//35h1113vYcQskccrBeB+UT+Lue3GYbx5uHhYewVXV39BvR4PTz22GOF7bff/l7HcULTe3xBYQbXO2PsCFEUf1gqlfZjjIFqN0ylbqmh44d6vf5nnLAIIX/XdX0f/K1arb6SMXZb0+CFdn7XdR/J5XK7bynBcRi4SqXyflmWsSHFpAlJ2f5S07TXQIvfYYcd3pbP57/DOR91HOe9qqqujnM2u5o1PXpoSwH05KZvmuZbGWOonR6WWY3SCMOod0rpfVbdeqkkSy8QRfFXSxLQu9nNZpkvidS1gxtpa1dyzreDdg4qXUEQfEVWBLNu/r4RDHusoihr5hL7EfsxEc9g2zZS0t6SWD/cdd2QVKZer7+rUCh8t9sDRAro0w96vzX0aD2GgYzIkGi4HC+Blt5gcMT5GmyOuCXcMymln1EU5ewGY1t98xb3ZrLHc2j9+vXXDgwMvC2Oao//jXZG7tKX6rp+11y21/kA9Lh9hmEcQghBzfYw5im2OAC0HccZFUVxD8/zdmgL0E3TRGT35z3Pw2YJQSB9DXzYf2WM7Z04McT/F/edrOv6lzo5jc1FuP18tlarLaeU/rmRuxufkELtXNM0UiqVEIh1Qjab/W6lUhmilF6fzWZfOT4+/uDg4OCzu92ket2fLRHQN2zYkCkWixdJkvRBFyHjnMeFDeJAxUtN0/xJoVD4rWGavhTloWeyWWbUamsR64AAzn6P0SLT0EMLR6lUGtAA6IQcHsUihJkBYPmCT73BAnmOoigomdx1QaFYOx8bGztBUZQvwmqVUADCNEbbtv/i+/4x2Wz2791+a94AvQ3MQVvaY4p74vw999xj3sqnjo2P313I5/fFHo7Dm+d57lyqrTXvT3FEuWEYd+m6HlbjdJynE2UApDBz+76PaPjLYCXqwx4XztVyufxlRVHej3FIpKmFOBiZ/7+naRrinMy5tGG+AD2e36Zp4tD7jtg63ETs9r0gCLDGfh+Dfssod3T40UcfLW6zzTbrwNfLGEO0+9GR2f3oIAiuagHo+NOm9evX7/bMZz6zspR96diUIrrbTzb7zmGm9DwvBG50eGx8bK+B4sDfDcMwfN//fKFQOCsJFm3sB3OZXzM+uyUB+oRWEDBKGQhn9ooIZ8DQNxn1Hk36hx3HuUfTtNc3MjMy0Bq6Coqb06iAmSoINRjk0S9kUFzcjRhoLcuCO+jyUJWi4RkV/xPn9YPd67iGRe7H3Rx4EsQ+LwTNbCaT2RtZMPFmg1QqSqncCKQ9W9O08yIg7IpJcd4AvY150D6gP37+nnvuOW+A3o+0taQ4Yr+14zgvNE1ztaqqKxIusLC0ahwk1zhQnJfNZkEJ27MguWi+cZRzdRznPcjfnqBKmaysNpEnScg4IWS/6ehT2xjiyVvmC9CjPtBSqVQQRfE+xth2SS090ebzG8kzIE8KTe7TAjp+rFQq3yGEHKUoirFhw4Yddtppp3FEdNdqtX9F6QrhoCUubBJX4iTUfy29f1BZrVb3IIQgchq87VPI60VRBFXmqaqqfgXaoizLZw0MDJxeq9UQcwAa3H920/d+9GZLA/R4kuOwWK1W3yYIwrURIUkY9R4v5KhgRPgvzE9oKNlsdsGqrS0SQJ+MdscaJYSAxCLpSgqB13Gch3VdP0aSpDs7SSeLXUylUmlnWZavliUZaZ7wesQpkuH7KaVrGkyK75Fluavo9sQBpSX166Jgimsmlpm3PPQJ6cyHyT0xDuHBtVKpfLxxuD5LlmU1tshEgA5Tcch7EATBTz3PO3FoaOiJTkC0+d54X1u/fv0zMpnMtzzPezksp7Ish7XZE1fMG3KYqqowXc/5mk9AjxtbqVQOEwQBhWTCqPemKz6Mh3+eDdAPlGX5rojeL6RRhDBN0zyGEPINvKAJ0DGZfNu23zQ4OIg6r0vuAm87AqoopS+L4gEmedvRGUmS/vmpT33qOYgwtCxrV8dx7ofWkc1mb6WUvrab6PZ+CWlLBnQcpvL5PE78H0R6N4Ym4TObKEHIWIjyKaBPzLBEtayjKKXfEARBSWpUmO9RkYcNlUrlw8PDw9e2E4Eeb3Ku677M87zLVVXdA77ySqXCsNFGBZ1Csz6l9COg623nvVPWRdOJN9XQp9815hPQowNECOqGYXybMfau+GAdAzrWJaxkWJOc8zFVVc99/PHHrwDjXKd7H+bNr3/9a3nPPfc8qVGs6ZOKouTjXPNcLkdQsSy6QqroRq2C0zOZzOfaZiKcpUHtAzpzYvKuTvuYvD+e55VK5buCIISm9xagPvnIjICOu0ql0q9lWX657/s1y7KeNTw8DE1Usizr7iAI9trsuBAEGLwnZVneT9f1DUvJ9A5aw+XLl58jCMIZcRR104HFqFarxy9fvvx7GzduzEqSdGGxWPygZVkjoigeIUnSrzveqOYy2rNPvlCLma/iLKB+7XUeeqsuJlJU9hIE4XpCCNwfoQYYRbVO1hRuR0Pvk3VkUZnco012wsY+YeH4vKIoJyMXHcFLsZwTAA9T5Q8aVqqzVFX9VyurUzwOqHXQMKWeQSmFjzKZwoTqVkRRlPDA1eB0QEnck6LCHaHFoNvpv7QAXZMrlWqH1K/dSmZ+NfTEvArHs16v39SwvrwOwBqnW8U1vjEXMPfAFOi67kOCIFzNGPuOruvrZuptPNaWZe3SKIb1X5xz1DnfYZq9Afjjy7Ii+L73JdBy98HMD+bFnjLFzdZ/RL0PDQ3d1ziIh6b36a5ZAX18fPxliqL8BoQylNIvyLL8YbwMpUJ1Xb8lIpaZtLvjhZIoEddz/zIyMvKy7bff3poJ1PuxmXa7FEZHR5EKcL0oikm/3+TrfN+/JZfLHRz1fw/4NmRZhqZ+88DAwBsWmuq1ud/NGrqqqqsw2WOfZrQYO6R+nfqV+BsoTjMF0EVBomRuTHEzTvKAU8ooN03zbZTSayPzMQAdh5jNAD2TyTDDMBY8KA6aSi6Xm7fiLC3mRLjx4pAniuIVhBAUFpoE9URAURxk6HPOUWbyds75w0EQlKHJc7Bb0nwAABCXSURBVM5znPNnSJIESlnkmYem1lD40RUdrnwBYbmE/M3zvPciL7nbQLhWmgvWXLJ8ampynwrouWwOzIBhUBxqUWSzWcQHXVguly/YYYcdUOCoOya3pokVxRGwc889lx9//PHXDwwMvEUUROBAeCfmAgAdU6F5jhFC/kEIgQsG1dE2MMYQuIZEjFwEYLtSSl/aYC7dOXatTU6zKTRnIbWyr2u6UK1VL4VFuRu+9lnANcEUJ7054XGOwlLaL5+62XdmAcNKpfJGzvmNyVKpze8A/ka07bBW7DPFIR4NBMjsb/I8DyH0lmVZzxseHn4QA1gul78uSdJxyTS2BKAjze3Hy5YtO7xXk6ZboG7nuVKp9BpBEG5GEFUS8BL70yZBEHC4eQDaeaFQ+IrjOO+SJGnj2NjYIdtuuy3Id+akdbTTzk7uSQI65/z7jYPZvAA6omkppSh36ouCKDiuc1sjXeRVMTVrJ32Y7t7EQSJbr9dhev9AVCwnrCkcmtwngnLCnaERhLWoAN2yrEcppX2vtjaNFhNuSrC4BUEAJje4l8KDXiy32NKRLD0Zb8RJk19TZagpLjgcHJD/6/v+Y/Cba5r2m16AebQvbeZDt23bcxxn4autLSIf+nwBeuIQF84tWIBEUTwpWcyqOZ2sk33g6X14etTDdxs0w4JhGB8dHBz8Qq/M7E0Hyb5Rv85ykAjne7VaRY33t89kdoeLC7+3BHR8BNy4siz/WZIkZtv2XcViEaT3OJHkGlG8IBZ4RrIxSF1AgIKu6wisu64RKHZkrziiO5kE7d6LwhWCINzCGINPEcmUk49GEwk5lGdEfOEoVPP6XC63GnW/GyQn12ua9s62o4Ln0STRDOiyLK9ClFK/NHTXdS/mnJ8wH4AeHzajMqt7+b4/aXrHom4GdFVVmWma/dHQW4zpdGlrvu9zWAts254fQJ9mvsWHz3q9vhMh5GuEEFieQr9jrElNKNZP57+2A+gA+Oi+cJ4pinJ/rVZ7b6FQmFMQXAtLw6IEdMuybsfBOa62hsh+FDCpVDqtttbu7rX5fUkfeiaT2Re0p9DQwd0PDb1cLl9YrVZ7qqE/vWE+XfHM87y3eJ6HGgvbxvMoeUCM/9Z8KGzV8+ZYraZ7Yj19bePw+J5cLndH99Kb+cn2fejtFLrqrJXYz6vV6iD4NhprNiY72+wlWLdYw67rbq6hx6fher2O0pinVatVrmnaKdls9jL8BjCklN4RBAHL6BnquE54So9P+AhYkCTpJw3CirdBg1psPnWYMQRBuA4aZcQmNEVAUYWo67LZbEgrCk5smIdEUVzped6/gyB4SSaTCXl1p+vbPGJ4c9snfejQ0AHoiDiNS41Gbb5C07QOqq1NnT/NJncAOni7EWcB0pJ+aegJjSA+uU5GvUf9S1qbUH+b1a16fwC9xbpsBeiRL5Hrug4GxvkB9Bn2jMTYabZtgyXuZByEkN4PP6eiKOHGkNQGmjWD5s0Y2oFpmr6macg3v85xnFOGh4dBGd1T61XSh/6sZz1rNVxh0NAjAhEkQ6MK2EWaps1rPXTP9W4nhKyyncl0vbA2e6lUumDdunXzmraGOCfG2PwCejTf4pREQkjRtu1PEUKOBZd/xE4Y3oWIdIDPxBxqsp3PgnUJgEccBv65zDCM8+bCAtcOvC4koMftq1arSIW9IU5VizA6/BlyiU3u0wJ69AC4tP8qy/KzKpVKzXXdFwwPD4cpWtVq9RhZlr8hSRJ3HGdqHtvT2u6fG7z+/wnu5nYE1+97MDD1ev0E3/e/BOBJaq3Jb7uu+7exsbH9d955Zwum9lwu93XG2JEonep53knZbPZ7vTIj9rrPzRq6JEmoXzwF0JHD2Qh07Amg12q1UEMXRXHeAR1jgzxXQRA+0KJufYD627ZtLzigY+dSZIW5nrvggJ44FMUpbQcSQj7ted4BiJkBqEeRyZNTcxZABwsc5PwAKg42tMPV0YM9P9P2B9C7a2YyDx2A7npueHBmjOFQ4xQKBbnhCrjgoYcemhbQu/ty6x0j1tA3btx4d6FQ2BeABw0dGKqqqmQYRs996NPtXYmAtmc1SpEj2PjtnuepOCjOrJnPDPCR8mRTSr/FOb+oJa70UqhPH1QWxOTeLF+Y3iHLxBqeBPQY4D3Pa62hxw+Zpnmg7/u/1VSN2o695sknn3zJbrvtVonqpV8ERiBVVaeMRBNrz8YgCN6Nkon98au3N4KIymWMXS4Iwn/Cv5o86TQJ7hFN0w6ilP4boF2tVt8ty/JVoB31PO+HKAbStqm912idfN/0ZtVQe0Uqnqqqx4ADPaopjsUdHrwcx7mzUChc00nOcfLT8Tg+/vjj2rJly94siuJrXdc1okNOIDIx53jO3bquf74XKX2tuhprf+VyeVfG2IdEUZzkDo/XoSAIsud5T/m+f00ul7u/1xpj8/DG70fZUsYYGKzCtB1ciqLIqMrHGPueoij/6Hdb2p168Vi6rnug67of9DwPZvhCssJiC0CP1zvcUncJgvDFhx9++NZ+E6jEbUX++2GHHXZSvV5/kaqq1Qi4EOQ3wDm/Pp/P/6Rfh4qEXOF/xFpD2dBTXNeFVlxF4ZswSEvX85s2bbp+zZo1P1+1atVEPc8+XvFaLpVKn9A0bXfOuRmVrsUhIxsEwY26rv+sH8xtswF7pVJBWW7sE9g794+CKTuRhkEIATPatbZj/2hwYBBBmvN2JTI73i+K4vOjfTQs6BbRT9+rKMpX++G/T3YSckRZ4hC7OD7OJzb0hIbemH/nbRYU17x5VyqVcxog+Mkw+E2SVqPCGO7BJDrggAOu9n3/nTPZT+BDlGX5GhRzyWazI52a4NuD7NbjC57p00477U0wzzRKvu4giii+M8E93LxRcc6fCILgtblcDhGYKFP3WkrpL2BSbORa/qvBjLTvwMAASP6xkreYCnPztjLm40MdTJYObp2Pli/oN5KHtEKhgOIP+zcyCZAauDwIgoGocVWUVxYE4Z9Icbdt5/eDgwPl/hzUF1Qc6cf7JIE77rhDffGLX7xfI3Ib1SkRyQ53ZoEQko+yVqAYlBhjj3POH6GU/p+qaXcz2nv/dJ+6uOCvnRHQ0bqoAhvK070JKWtBEFyYyWTOjH4TTNNEgM2xEcht9r6EqWUUJwxN05A6M2NqWy+kAk2pkSP7Wc75K+P0mmSIf1ydB9+CJsc5P7RQKMBNgPrazwuC4E5CSE4QhDFK6WG6rv9usWhWvZBP+o5UAqkEUgm0JYH09NuWmBbDTbMCegTcecuyfh8EwR4wWTfyWM8Ea1cM6rVa7XMwfTbnpUa/N/dzQ6PW9aeDIPguyuz1UggAXMuykKp1KmMMVJeT7oA4cC8iO5gMzmgQ4T/kuu5h+Xz+gUgz3xU5uBGRQVUURXBdX7cYqqn1Ulbpu1IJTCeBdP9O50YqgaUpgbYAHV0rlUq7MMZ+SwhZGUUZop7yxRFogx72+IYfC7mAYMufQjbRLJrI3G03yrWCLvZ7vu/fMTAwUOpYhDR0VFLX9fYG4UgQBEcIggC/KmeMTelbHCUZR/GiDb7v/8nzvEOXL1++CRaG9evX75HJZH5GCEFqj9Uo1XlusVhE4FfX1ag67lP6wAwS6DHU9Ph16dDNXQKLYUgWQxvmLsn0DVujBNoGdAinUqkg4OI38K0xxhDxc04ul4OjPrzK5fJLGqVWbxQEATlz4bubguTC+2L/deI3BI78JQiCuxhjawgha1zXBaF/eWhoqBK9R/7nP/+ZX7Zs2XaCIIBBCCQZCLI4UBAEBL1NUCBF/vHpCDDANW2apjc2Nvb1crl8yh577BGm1o2MjLxoYGDgZ4ZhIIgDZQC/ksvlTl4yYJ7uQlvj+k373BcJpIupL2JNX9p3CXQE6GhNtVpFCUsk8i8HXsuy/JMHH3zwqH322QfRiPh9mSAIl9m2/XYEoTVrytNo69N2NCa7iG+Ahp0Mq49z8JooBiff10xQ4Pv+esuy3jc8PHxTHNBTLpdfLEnS7b7v65qqOa7nXqJp2ieXDJj3fZosxQ8stk15sbVnKY5p2uZUAqkEZpJAx4CeAHUA4jOhEbuue3cmk3mTruuTZfJc1z2oXq9/DSbwuQxBi+puHb0u8Ty07m+WSqUzV6xYEfru42j1Rm72tg061z8ODQ0NBUHwcZDopGDekZh7cHMKeD0QYvqKVAKpBLZiCXQF6JBXqVQaUBTle5ZlHZLJZBApPo5SiZqmXZ1gpNINwziRUvrRSKPfTNSzUPzNOjStTPrJhwDalNJbkDOfzWbvbZVmg7+Zpvk83/dfkM/nr0yj2WcV+ww3pMA8F+kttWfT0V5qI7ZE25tOtLYGrmtAx9tBHFKtVi+WZfkU0EY2ctZRC/mnpmm+H/SPcQsaUe0A9hMopScTQpB7OHFxQujU2LW2Gp28KU6Liw8GCYB3KaPX8YB/Lqr4FLnYuWqa5qt93/9DFGWfTpWOpb40HkgHdmmM05bSynS+bSkjuXT7MSdAj7sdcc1eHgTBchRp4ZyPNwpeXfLII498ee+99zZj0zbM2IZhHEQIOZpSCoIaNVl+cVoxTrNSwBMMAIcfHQQwEQ/7Pb7v/wBlUXVdB0HBZLlAwzBe6Ps+ige8WJblr2madmJqWl+6kzdteSqBVAKpBFIJPC2BngA6XgcTvCRJn6WUvtdxnDAYznXdjYqiXJzJZC4H62iSYY1znjFNE1XcXtWgkMQ/e0zHrz7TgPm+/ySi40VRvLPBSX1roVB4qNmsDqKYBuif4/s+6suGbHGSJD1Uq9X2HR4eRi3elP1tK1wVqUa1dAe9p2PX05ctXZmmLV/6EugZoMeisCzr9ZzzS0BCI0kSMQyDaJoGJrarbdu+slgsPtJKbA3CfcUwjN0ZY8+JCtsPUErBz1yMABfpa14QBBsZY/8mhPyLc/6viKR/syUZuQMOkSQJhUhQ2x0XtHWHc/7VtWvXnrX77rvXUhrXpT+J0x6kEtgaJJCeO5b4KM/DAPYc0CHyiC72yIZJ/BxCyC4om4cLVc4YY0h5Q/nSW3tdiQ2ad71eh1n9aM75mwVBWI5CEw2CGGpZliOK4reDILi4WCziMDBpiu94mszDwHTcpj49sBV1tU8STF+bSiCVQFsSSDebtsQ00019AfT4gyjrZ1nW213XfR/n/ACUW03UzUU6+T8opTejjq8kSfdls9kH2q1ag/esXbu26HlesMsuu4QVeFABLJ/Pf1UUxXfj7yihGQRBSVEUpKt9ddmyZQ/PCcjnLO70BakEUgmkEkglsPVIYH5PKX0F9OSgVavVPRhjJzRA/K2EkOHI/h0WaMcF9rhGDrjDGHuYUrqRcz5KCEFBl1KjIIxMKdUJIVIjqG2wkU++oyiKuzqOgzq7nxwcHAQ9a/iier3+X5RS1I69pUGCc10QBNcvX758MjBv65lIaU9TCaQSSCWwdUpgfmG0lYwXpgXzBugJrZ0ahrE3pfQNCIjzff+lbOIKA96RhjbbFfGwE9Ri55xfq2nakXG0esN/r61bt25o++23B8nNwkh1tg6kv6cSSCWQSiCVwFYlgafBqH+wNO+A3jyCyFE3TXMPx3H2lCRpz6gO8yDnHJr4UKPgC4LjUCcXjviaKIp1z/PWIijOdd1/EULuKRaLv5rRlN4/+W1VEzLtbCqBVAKpBFIJLF4J/D/xclRhztyp5QAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", _A = "data:image/svg+xml,%3csvg%20width='45'%20height='44'%20viewBox='0%200%2045%2044'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M22.0836%2026.4C24.5136%2026.4%2026.4836%2024.4301%2026.4836%2022C26.4836%2019.57%2024.5136%2017.6%2022.0836%2017.6C19.6535%2017.6%2017.6836%2019.57%2017.6836%2022C17.6836%2024.4301%2019.6535%2026.4%2022.0836%2026.4Z'%20fill='black'/%3e%3cpath%20d='M22.0844%2028.6C31.8046%2028.6%2039.6844%2025.6451%2039.6844%2022C39.6844%2018.3549%2031.8046%2015.4%2022.0844%2015.4C12.3642%2015.4%204.48438%2018.3549%204.48438%2022C4.48438%2025.6451%2012.3642%2028.6%2022.0844%2028.6Z'%20stroke='black'%20stroke-width='0.72'/%3e%3cpath%20d='M16.3685%2025.3C21.2286%2033.7179%2027.7275%2039.0645%2030.8842%2037.242C34.041%2035.4195%2032.6601%2027.1179%2027.8%2018.7C22.9399%2010.282%2016.441%204.93539%2013.2842%206.75793C10.1275%208.58047%2011.5084%2016.882%2016.3685%2025.3Z'%20stroke='black'%20stroke-width='0.72'/%3e%3cpath%20d='M16.3681%2018.7C11.508%2027.1179%2010.1271%2035.4195%2013.2838%2037.242C16.4406%2039.0646%2022.9395%2033.7179%2027.7996%2025.3C32.6597%2016.882%2034.0406%208.58048%2030.8838%206.75794C27.7271%204.9354%2021.2282%2010.282%2016.3681%2018.7Z'%20stroke='black'%20stroke-width='0.72'/%3e%3cpath%20d='M39.6844%2024.2C40.8994%2024.2%2041.8844%2023.215%2041.8844%2022C41.8844%2020.785%2040.8994%2019.8%2039.6844%2019.8C38.4693%2019.8%2037.4844%2020.785%2037.4844%2022C37.4844%2023.215%2038.4693%2024.2%2039.6844%2024.2Z'%20fill='black'/%3e%3cpath%20d='M13.284%2029.92C14.499%2029.92%2015.484%2028.935%2015.484%2027.72C15.484%2026.505%2014.499%2025.52%2013.284%2025.52C12.069%2025.52%2011.084%2026.505%2011.084%2027.72C11.084%2028.935%2012.069%2029.92%2013.284%2029.92Z'%20fill='black'/%3e%3cpath%20d='M13.284%2018.48C14.499%2018.48%2015.484%2017.495%2015.484%2016.28C15.484%2015.065%2014.499%2014.08%2013.284%2014.08C12.069%2014.08%2011.084%2015.065%2011.084%2016.28C11.084%2017.495%2012.069%2018.48%2013.284%2018.48Z'%20fill='black'/%3e%3c/svg%3e", UO = ({
  walletConnected: r,
  walletAddress: e,
  wagmiConfig: i,
  walletHooks: n,
  onClose: s,
  isOpen: a,
  onCreatePlayer: o
}) => {
  r && (e || r.account && r.account.address);
  const l = () => {
    o && o();
  };
  return /* @__PURE__ */ I.jsxs("div", { className: "relative flex flex-col w-full items-center py-6", children: [
    /* @__PURE__ */ I.jsx(
      "div",
      {
        style: {
          position: "absolute",
          top: "0",
          left: "0",
          width: "100%",
          height: "20px",
          backgroundColor: "#FFD32A",
          borderTopLeftRadius: "20px",
          borderTopRightRadius: "20px"
        }
      }
    ),
    /* @__PURE__ */ I.jsx(
      "div",
      {
        style: {
          position: "absolute",
          bottom: "0",
          left: "0",
          width: "100%",
          height: "20px",
          backgroundColor: "#FFD32A",
          borderBottomLeftRadius: "20px",
          borderBottomRightRadius: "20px"
        }
      }
    ),
    /* @__PURE__ */ I.jsx(
      "img",
      {
        src: xA,
        alt: "Intuition Logo",
        style: { width: "350px", marginTop: "20px" }
      }
    ),
    /* @__PURE__ */ I.jsx(
      "h2",
      {
        style: {
          fontSize: "1.0em",
          margin: "0 0 20px 0",
          color: "#FFD32A",
          fontWeight: "bold"
        },
        children: "BOSS FIGHTERS COMMUNITY PLAYER MAP"
      }
    ),
    /* @__PURE__ */ I.jsxs("div", { className: "flex flex-col gap-2 w-5/6 mx-auto text-base", children: [
      /* @__PURE__ */ I.jsx("p", { children: "At first, there was nothing. And then, suddenly, the whole community appeared !" }),
      /* @__PURE__ */ I.jsx("p", { children: "Everything of which the Boss Fighters community would one day be composed, would be born in an instant." }),
      /* @__PURE__ */ I.jsx("p", { children: "A single species of condensed matter, exploding in a vast universe." }),
      /* @__PURE__ */ I.jsx("p", { children: "Although energy would neither be created nor destroyed, the interaction between these newly-created atoms would continue to create something beautiful..." }),
      /* @__PURE__ */ I.jsx("p", { children: "What had been separate would become whole again. And what would be created in the process would be even more beautiful than what came before..." }),
      /* @__PURE__ */ I.jsx("p", { children: "Our story begins with the atom. The cornerstone of our ecosystem." }),
      /* @__PURE__ */ I.jsx("p", { children: 'And our "atoms" start with you !' })
    ] }),
    /* @__PURE__ */ I.jsxs("div", { className: "flex flex-col gap-2 w-5/6 mx-auto text-base text-left border-2 border-yellow-400 rounded-xl p-4 my-6", children: [
      /* @__PURE__ */ I.jsxs("p", { children: [
        /* @__PURE__ */ I.jsx("span", { style: { color: "#FFD32A" }, children: "Claims" }),
        " in Intuition, also referred to as ",
        /* @__PURE__ */ I.jsx("span", { style: { color: "#FFD32A" }, children: '"Triples"' }),
        " structured in Semantic Triple format :"
      ] }),
      /* @__PURE__ */ I.jsxs("p", { children: [
        "[",
        /* @__PURE__ */ I.jsx("span", { style: { color: "#FFD32A" }, children: "Subject" }),
        "] ⇒ [",
        /* @__PURE__ */ I.jsx("span", { style: { color: "#FFD32A" }, children: "Predicate" }),
        "] ⇒ [",
        /* @__PURE__ */ I.jsx("span", { style: { color: "#FFD32A" }, children: "Object" }),
        "] (For example, a triple could be : [SciFi] [is] [strong Boss])"
      ] }),
      /* @__PURE__ */ I.jsx("p", { children: "This keeps our attestations tidy !" })
    ] }),
    /* @__PURE__ */ I.jsxs("div", { className: "flex flex-col items-center gap-2 w-5/6 mx-auto text-base", children: [
      /* @__PURE__ */ I.jsxs("p", { children: [
        "You need to connect your ",
        /* @__PURE__ */ I.jsx("span", { style: { color: "#FFD32A" }, children: "wallet (ETH - Base network)" }),
        " and pay ",
        /* @__PURE__ */ I.jsx("span", { style: { color: "#FFD32A" }, children: "0.0001 ETH (less than $0.40)" }),
        " to create your player !"
      ] }),
      /* @__PURE__ */ I.jsxs(
        "button",
        {
          className: "max-w-xs justify-center whitespace-nowrap rounded-md text-sm focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 bg-primary text-background shadow hover:bg-primary/90 font-bold uppercase h-12 px-4 py-2 flex items-center transition-transform duration-200 hover:scale-105 mt-4 mb-8",
          onClick: l,
          children: [
            /* @__PURE__ */ I.jsx("img", { src: _A, alt: "Atom", style: { width: "44px", marginRight: "10px" } }),
            "CREATE YOUR PLAYER"
          ]
        }
      )
    ] })
  ] });
};
function FO(r, e) {
  const i = r.exec(e);
  return i == null ? void 0 : i.groups;
}
const bT = /^tuple(?<array>(\[(\d*)\])*)$/;
function Pv(r) {
  let e = r.type;
  if (bT.test(r.type) && "components" in r) {
    e = "(";
    const i = r.components.length;
    for (let s = 0; s < i; s++) {
      const a = r.components[s];
      e += Pv(a), s < i - 1 && (e += ", ");
    }
    const n = FO(bT, r.type);
    return e += `)${(n == null ? void 0 : n.array) ?? ""}`, Pv({
      ...r,
      type: e
    });
  }
  return "indexed" in r && r.indexed && (e = `${e} indexed`), r.name ? `${e} ${r.name}` : e;
}
function Qc(r) {
  let e = "";
  const i = r.length;
  for (let n = 0; n < i; n++) {
    const s = r[n];
    e += Pv(s), n !== i - 1 && (e += ", ");
  }
  return e;
}
function BO(r) {
  var e;
  return r.type === "function" ? `function ${r.name}(${Qc(r.inputs)})${r.stateMutability && r.stateMutability !== "nonpayable" ? ` ${r.stateMutability}` : ""}${(e = r.outputs) != null && e.length ? ` returns (${Qc(r.outputs)})` : ""}` : r.type === "event" ? `event ${r.name}(${Qc(r.inputs)})` : r.type === "error" ? `error ${r.name}(${Qc(r.inputs)})` : r.type === "constructor" ? `constructor(${Qc(r.inputs)})${r.stateMutability === "payable" ? " payable" : ""}` : r.type === "fallback" ? `fallback() external${r.stateMutability === "payable" ? " payable" : ""}` : "receive() external payable";
}
function s_(r, { strict: e = !0 } = {}) {
  return !r || typeof r != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(r) : r.startsWith("0x");
}
function xT(r) {
  return s_(r, { strict: !1 }) ? Math.ceil((r.length - 2) / 2) : r.length;
}
const TA = "2.38.0";
let $c = {
  getDocsUrl: ({ docsBaseUrl: r, docsPath: e = "", docsSlug: i }) => e ? `${r ?? "https://viem.sh"}${e}${i ? `#${i}` : ""}` : void 0,
  version: `viem@${TA}`
};
class wn extends Error {
  constructor(e, i = {}) {
    var l;
    const n = (() => {
      var u;
      return i.cause instanceof wn ? i.cause.details : (u = i.cause) != null && u.message ? i.cause.message : i.details;
    })(), s = i.cause instanceof wn && i.cause.docsPath || i.docsPath, a = (l = $c.getDocsUrl) == null ? void 0 : l.call($c, { ...i, docsPath: s }), o = [
      e || "An error occurred.",
      "",
      ...i.metaMessages ? [...i.metaMessages, ""] : [],
      ...a ? [`Docs: ${a}`] : [],
      ...n ? [`Details: ${n}`] : [],
      ...$c.version ? [`Version: ${$c.version}`] : []
    ].join(`
`);
    super(o, i.cause ? { cause: i.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = n, this.docsPath = s, this.metaMessages = i.metaMessages, this.name = i.name ?? this.name, this.shortMessage = e, this.version = TA;
  }
  walk(e) {
    return wA(this, e);
  }
}
function wA(r, e) {
  return e != null && e(r) ? r : r && typeof r == "object" && "cause" in r && r.cause !== void 0 ? wA(r.cause, e) : e ? null : r;
}
class zO extends wn {
  constructor({ expectedLength: e, givenLength: i }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${i}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class jO extends wn {
  constructor({ expectedSize: e, givenSize: i }) {
    super(`Expected bytes${e}, got bytes${i}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class VO extends wn {
  constructor(e) {
    super(`Type "${e}" is not supported for packed encoding.`, {
      name: "UnsupportedPackedAbiType"
    });
  }
}
class SA extends wn {
  constructor({ size: e, targetSize: i, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${i}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
function oa(r, { dir: e, size: i = 32 } = {}) {
  return typeof r == "string" ? GO(r, { dir: e, size: i }) : HO(r, { dir: e, size: i });
}
function GO(r, { dir: e, size: i = 32 } = {}) {
  if (i === null)
    return r;
  const n = r.replace("0x", "");
  if (n.length > i * 2)
    throw new SA({
      size: Math.ceil(n.length / 2),
      targetSize: i,
      type: "hex"
    });
  return `0x${n[e === "right" ? "padEnd" : "padStart"](i * 2, "0")}`;
}
function HO(r, { dir: e, size: i = 32 } = {}) {
  if (i === null)
    return r;
  if (r.length > i)
    throw new SA({
      size: r.length,
      targetSize: i,
      type: "bytes"
    });
  const n = new Uint8Array(i);
  for (let s = 0; s < i; s++) {
    const a = e === "right";
    n[a ? s : i - s - 1] = r[a ? s : r.length - s - 1];
  }
  return n;
}
class WO extends wn {
  constructor({ max: e, min: i, signed: n, size: s, value: a }) {
    super(`Number "${a}" is not in safe ${s ? `${s * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${i} to ${e})` : `(above ${i})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class qO extends wn {
  constructor({ givenSize: e, maxSize: i }) {
    super(`Size cannot exceed ${i} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function Ud(r, { size: e }) {
  if (xT(r) > e)
    throw new qO({
      givenSize: xT(r),
      maxSize: e
    });
}
const XO = /* @__PURE__ */ Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function EA(r, e = {}) {
  return typeof r == "number" || typeof r == "bigint" ? a_(r, e) : typeof r == "string" ? CA(r, e) : typeof r == "boolean" ? MA(r, e) : AA(r, e);
}
function MA(r, e = {}) {
  const i = `0x${Number(r)}`;
  return typeof e.size == "number" ? (Ud(i, { size: e.size }), oa(i, { size: e.size })) : i;
}
function AA(r, e = {}) {
  let i = "";
  for (let s = 0; s < r.length; s++)
    i += XO[r[s]];
  const n = `0x${i}`;
  return typeof e.size == "number" ? (Ud(n, { size: e.size }), oa(n, { dir: "right", size: e.size })) : n;
}
function a_(r, e = {}) {
  const { signed: i, size: n } = e, s = BigInt(r);
  let a;
  n ? i ? a = (1n << BigInt(n) * 8n - 1n) - 1n : a = 2n ** (BigInt(n) * 8n) - 1n : typeof r == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof a == "bigint" && i ? -a - 1n : 0;
  if (a && s > a || s < o) {
    const u = typeof r == "bigint" ? "n" : "";
    throw new WO({
      max: a ? `${a}${u}` : void 0,
      min: `${o}${u}`,
      signed: i,
      size: n,
      value: `${r}${u}`
    });
  }
  const l = `0x${(i && s < 0 ? (1n << BigInt(n * 8)) + BigInt(s) : s).toString(16)}`;
  return n ? oa(l, { size: n }) : l;
}
const YO = /* @__PURE__ */ new TextEncoder();
function CA(r, e = {}) {
  const i = YO.encode(r);
  return AA(i, e);
}
const KO = /* @__PURE__ */ new TextEncoder();
function RA(r, e = {}) {
  return typeof r == "number" || typeof r == "bigint" ? QO(r, e) : typeof r == "boolean" ? ZO(r, e) : s_(r) ? NA(r, e) : PA(r, e);
}
function ZO(r, e = {}) {
  const i = new Uint8Array(1);
  return i[0] = Number(r), typeof e.size == "number" ? (Ud(i, { size: e.size }), oa(i, { size: e.size })) : i;
}
const Ms = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function _T(r) {
  if (r >= Ms.zero && r <= Ms.nine)
    return r - Ms.zero;
  if (r >= Ms.A && r <= Ms.F)
    return r - (Ms.A - 10);
  if (r >= Ms.a && r <= Ms.f)
    return r - (Ms.a - 10);
}
function NA(r, e = {}) {
  let i = r;
  e.size && (Ud(i, { size: e.size }), i = oa(i, { dir: "right", size: e.size }));
  let n = i.slice(2);
  n.length % 2 && (n = `0${n}`);
  const s = n.length / 2, a = new Uint8Array(s);
  for (let o = 0, l = 0; o < s; o++) {
    const u = _T(n.charCodeAt(l++)), c = _T(n.charCodeAt(l++));
    if (u === void 0 || c === void 0)
      throw new wn(`Invalid byte sequence ("${n[l - 2]}${n[l - 1]}" in "${n}").`);
    a[o] = u * 16 + c;
  }
  return a;
}
function QO(r, e) {
  const i = a_(r, e);
  return NA(i);
}
function PA(r, e = {}) {
  const i = KO.encode(r);
  return typeof e.size == "number" ? (Ud(i, { size: e.size }), oa(i, { dir: "right", size: e.size })) : i;
}
const op = /* @__PURE__ */ BigInt(2 ** 32 - 1), TT = /* @__PURE__ */ BigInt(32);
function $O(r, e = !1) {
  return e ? { h: Number(r & op), l: Number(r >> TT & op) } : { h: Number(r >> TT & op) | 0, l: Number(r & op) | 0 };
}
function JO(r, e = !1) {
  const i = r.length;
  let n = new Uint32Array(i), s = new Uint32Array(i);
  for (let a = 0; a < i; a++) {
    const { h: o, l } = $O(r[a], e);
    [n[a], s[a]] = [o, l];
  }
  return [n, s];
}
const eD = (r, e, i) => r << i | e >>> 32 - i, tD = (r, e, i) => e << i | r >>> 32 - i, iD = (r, e, i) => e << i - 32 | r >>> 64 - i, rD = (r, e, i) => r << i - 32 | e >>> 64 - i;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function nD(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function wT(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error("positive integer expected, got " + r);
}
function ym(r, ...e) {
  if (!nD(r))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function ST(r, e = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function sD(r, e) {
  ym(r);
  const i = e.outputLen;
  if (r.length < i)
    throw new Error("digestInto() expects output buffer of length at least " + i);
}
function aD(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function IA(...r) {
  for (let e = 0; e < r.length; e++)
    r[e].fill(0);
}
const oD = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function lD(r) {
  return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255;
}
function uD(r) {
  for (let e = 0; e < r.length; e++)
    r[e] = lD(r[e]);
  return r;
}
const ET = oD ? (r) => r : uD;
function cD(r) {
  if (typeof r != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function OA(r) {
  return typeof r == "string" && (r = cD(r)), ym(r), r;
}
class hD {
}
function dD(r) {
  const e = (n) => r().update(OA(n)).digest(), i = r();
  return e.outputLen = i.outputLen, e.blockLen = i.blockLen, e.create = () => r(), e;
}
const pD = BigInt(0), Jc = BigInt(1), fD = BigInt(2), mD = BigInt(7), gD = BigInt(256), yD = BigInt(113), DA = [], LA = [], kA = [];
for (let r = 0, e = Jc, i = 1, n = 0; r < 24; r++) {
  [i, n] = [n, (2 * i + 3 * n) % 5], DA.push(2 * (5 * n + i)), LA.push((r + 1) * (r + 2) / 2 % 64);
  let s = pD;
  for (let a = 0; a < 7; a++)
    e = (e << Jc ^ (e >> mD) * yD) % gD, e & fD && (s ^= Jc << (Jc << /* @__PURE__ */ BigInt(a)) - Jc);
  kA.push(s);
}
const UA = JO(kA, !0), vD = UA[0], bD = UA[1], MT = (r, e, i) => i > 32 ? iD(r, e, i) : eD(r, e, i), AT = (r, e, i) => i > 32 ? rD(r, e, i) : tD(r, e, i);
function xD(r, e = 24) {
  const i = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      i[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const l = (o + 8) % 10, u = (o + 2) % 10, c = i[u], h = i[u + 1], d = MT(c, h, 1) ^ i[l], p = AT(c, h, 1) ^ i[l + 1];
      for (let f = 0; f < 50; f += 10)
        r[o + f] ^= d, r[o + f + 1] ^= p;
    }
    let s = r[2], a = r[3];
    for (let o = 0; o < 24; o++) {
      const l = LA[o], u = MT(s, a, l), c = AT(s, a, l), h = DA[o];
      s = r[h], a = r[h + 1], r[h] = u, r[h + 1] = c;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let l = 0; l < 10; l++)
        i[l] = r[o + l];
      for (let l = 0; l < 10; l++)
        r[o + l] ^= ~i[(l + 2) % 10] & i[(l + 4) % 10];
    }
    r[0] ^= vD[n], r[1] ^= bD[n];
  }
  IA(i);
}
class o_ extends hD {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, i, n, s = !1, a = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = i, this.outputLen = n, this.enableXOF = s, this.rounds = a, wT(n), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = aD(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    ET(this.state32), xD(this.state32, this.rounds), ET(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    ST(this), e = OA(e), ym(e);
    const { blockLen: i, state: n } = this, s = e.length;
    for (let a = 0; a < s; ) {
      const o = Math.min(i - this.pos, s - a);
      for (let l = 0; l < o; l++)
        n[this.pos++] ^= e[a++];
      this.pos === i && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: i, pos: n, blockLen: s } = this;
    e[n] ^= i, i & 128 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    ST(this, !1), ym(e), this.finish();
    const i = this.state, { blockLen: n } = this;
    for (let s = 0, a = e.length; s < a; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, a - s);
      e.set(i.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return wT(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (sD(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, IA(this.state);
  }
  _cloneInto(e) {
    const { blockLen: i, suffix: n, outputLen: s, rounds: a, enableXOF: o } = this;
    return e || (e = new o_(i, n, s, o, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = n, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const _D = (r, e, i) => dD(() => new o_(e, r, i)), TD = _D(1, 136, 256 / 8);
function l_(r, e) {
  const i = e || "hex", n = TD(s_(r, { strict: !1 }) ? RA(r) : r);
  return i === "bytes" ? n : EA(n);
}
const wD = (r) => l_(RA(r));
function SD(r) {
  return wD(r);
}
function ED(r) {
  let e = !0, i = "", n = 0, s = "", a = !1;
  for (let o = 0; o < r.length; o++) {
    const l = r[o];
    if (["(", ")", ","].includes(l) && (e = !0), l === "(" && n++, l === ")" && n--, !!e) {
      if (n === 0) {
        if (l === " " && ["event", "function", ""].includes(s))
          s = "";
        else if (s += l, l === ")") {
          a = !0;
          break;
        }
        continue;
      }
      if (l === " ") {
        r[o - 1] !== "," && i !== "," && i !== ",(" && (i = "", e = !1);
        continue;
      }
      s += l, i += l;
    }
  }
  if (!a)
    throw new wn("Unable to normalize signature.");
  return s;
}
const MD = (r) => {
  const e = typeof r == "string" ? r : BO(r);
  return ED(e);
};
function AD(r) {
  return SD(MD(r));
}
const CD = AD;
class RD extends wn {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class FA extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const i = super.get(e);
    return super.has(e) && i !== void 0 && (this.delete(e), super.set(e, i)), i;
  }
  set(e, i) {
    if (super.set(e, i), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
const iy = /* @__PURE__ */ new FA(8192);
function ND(r, e) {
  if (iy.has(`${r}.${e}`))
    return iy.get(`${r}.${e}`);
  const i = r.substring(2).toLowerCase(), n = l_(PA(i), "bytes"), s = i.split("");
  for (let o = 0; o < 40; o += 2)
    n[o >> 1] >> 4 >= 8 && s[o] && (s[o] = s[o].toUpperCase()), (n[o >> 1] & 15) >= 8 && s[o + 1] && (s[o + 1] = s[o + 1].toUpperCase());
  const a = `0x${s.join("")}`;
  return iy.set(`${r}.${e}`, a), a;
}
const PD = /^0x[a-fA-F0-9]{40}$/, ry = /* @__PURE__ */ new FA(8192);
function ID(r, e) {
  const { strict: i = !0 } = {}, n = `${r}.${i}`;
  if (ry.has(n))
    return ry.get(n);
  const s = PD.test(r) ? r.toLowerCase() === r ? !0 : i ? ND(r) === r : !0 : !1;
  return ry.set(n, s), s;
}
function BA(r) {
  return `0x${r.reduce((e, i) => e + i.replace("0x", ""), "")}`;
}
const OD = /^(.*)\[([0-9]*)\]$/, DD = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, LD = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function kD(r, e) {
  if (r.length !== e.length)
    throw new zO({
      expectedLength: r.length,
      givenLength: e.length
    });
  const i = [];
  for (let n = 0; n < r.length; n++) {
    const s = r[n], a = e[n];
    i.push(zA(s, a));
  }
  return BA(i);
}
function zA(r, e, i = !1) {
  if (r === "address") {
    const o = e;
    if (!ID(o))
      throw new RD({ address: o });
    return oa(o.toLowerCase(), {
      size: i ? 32 : null
    });
  }
  if (r === "string")
    return CA(e);
  if (r === "bytes")
    return e;
  if (r === "bool")
    return oa(MA(e), { size: i ? 32 : 1 });
  const n = r.match(LD);
  if (n) {
    const [o, l, u = "256"] = n, c = Number.parseInt(u, 10) / 8;
    return a_(e, {
      size: i ? 32 : c,
      signed: l === "int"
    });
  }
  const s = r.match(DD);
  if (s) {
    const [o, l] = s;
    if (Number.parseInt(l, 10) !== (e.length - 2) / 2)
      throw new jO({
        expectedSize: Number.parseInt(l, 10),
        givenSize: (e.length - 2) / 2
      });
    return oa(e, { dir: "right", size: i ? 32 : null });
  }
  const a = r.match(OD);
  if (a && Array.isArray(e)) {
    const [o, l] = a, u = [];
    for (let c = 0; c < e.length; c++)
      u.push(zA(l, e[c], !0));
    return u.length === 0 ? "0x" : BA(u);
  }
  throw new VO(r);
}
const pl = "0xB92EA1B47E4ABD0a520E9138BB59dBd1bC6C475B", UD = 13579, CT = BigInt("10000000000000000"), RT = BigInt("10000000000000000"), ju = [
  {
    type: "function",
    name: "BURN_ADDRESS",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "CONTROLLER_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "COUNTER_SALT",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "DEFAULT_ADMIN_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "MAX_BATCH_SIZE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "MIGRATOR_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "ONE_SHARE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "_maxRedeem",
    inputs: [
      {
        name: "sender",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "accumulatedAtomWalletDepositFees",
    inputs: [
      {
        name: "atomWallet",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "accumulatedFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "accumulatedProtocolFees",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "accumulatedFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "approve",
    inputs: [
      {
        name: "sender",
        type: "address",
        internalType: "address"
      },
      {
        name: "approvalType",
        type: "uint8",
        internalType: "enum IMultiVault.ApprovalTypes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "atom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "atomConfig",
    inputs: [],
    outputs: [
      {
        name: "atomCreationProtocolFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomWalletDepositFee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "atomDepositFractionAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "batchSetAtomData",
    inputs: [
      {
        name: "creators",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "atomDataArray",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetTripleData",
    inputs: [
      {
        name: "creators",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "tripleAtomIds",
        type: "bytes32[3][]",
        internalType: "bytes32[3][]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetUserBalances",
    inputs: [
      {
        name: "params",
        type: "tuple",
        internalType: "struct MultiVaultMigrationMode.BatchSetUserBalancesParams",
        components: [
          {
            name: "termIds",
            type: "bytes32[]",
            internalType: "bytes32[]"
          },
          {
            name: "bondingCurveId",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "user",
            type: "address",
            internalType: "address"
          },
          {
            name: "userBalances",
            type: "uint256[]",
            internalType: "uint256[]"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "batchSetVaultTotals",
    inputs: [
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "bondingCurveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "vaultTotals",
        type: "tuple[]",
        internalType: "struct MultiVaultMigrationMode.VaultTotals[]",
        components: [
          {
            name: "totalAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalShares",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "bondingCurveConfig",
    inputs: [],
    outputs: [
      {
        name: "registry",
        type: "address",
        internalType: "address"
      },
      {
        name: "defaultCurveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "calculateAtomId",
    inputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "id",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "calculateCounterTripleId",
    inputs: [
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "calculateTripleId",
    inputs: [
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "claimAtomWalletDepositFees",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "computeAtomWalletAddr",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "convertToAssets",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "bondingCurveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "convertToShares",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "createAtoms",
    inputs: [
      {
        name: "data",
        type: "bytes[]",
        internalType: "bytes[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "createTriples",
    inputs: [
      {
        name: "subjectIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "predicateIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "objectIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "currentEpoch",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "currentSharePrice",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "deposit",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minShares",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "depositBatch",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "curveIds",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "assets",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "minShares",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "entryFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "exitFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "generalConfig",
    inputs: [],
    outputs: [
      {
        name: "admin",
        type: "address",
        internalType: "address"
      },
      {
        name: "protocolMultisig",
        type: "address",
        internalType: "address"
      },
      {
        name: "feeDenominator",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "trustBonding",
        type: "address",
        internalType: "address"
      },
      {
        name: "minDeposit",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minShare",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomDataMaxLength",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "decimalPrecision",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomCreationCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAtomWarden",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getBondingCurveConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getCounterIdFromTripleId",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "getDefaultCurveId",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getGeneralConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleAdmin",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getShares",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTotalUtilizationForEpoch",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTriple",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleCost",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTripleIdFromCounterId",
    inputs: [
      {
        name: "counterId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserUtilizationForEpoch",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVault",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultFees",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultType",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint8",
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getWalletConfig",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "hasRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      {
        name: "_generalConfig",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_atomConfig",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_tripleConfig",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_walletConfig",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      },
      {
        name: "_vaultFees",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "_bondingCurveConfig",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "isAtom",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isCounterTriple",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTermCreated",
    inputs: [
      {
        name: "id",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTriple",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "lastActiveEpoch",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "pause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "paused",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "personalUtilization",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "utilizationAmount",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewAtomCreate",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFixedFees",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewDeposit",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewRedeem",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "previewTripleCreate",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFixedFees",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "protocolFeeAmount",
    inputs: [
      {
        name: "assets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "redeem",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "minAssets",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "redeemBatch",
    inputs: [
      {
        name: "receiver",
        type: "address",
        internalType: "address"
      },
      {
        name: "termIds",
        type: "bytes32[]",
        internalType: "bytes32[]"
      },
      {
        name: "curveIds",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "shares",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "minAssets",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    outputs: [
      {
        name: "received",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "renounceRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "callerConfirmation",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setAtomConfig",
    inputs: [
      {
        name: "_atomConfig",
        type: "tuple",
        internalType: "struct AtomConfig",
        components: [
          {
            name: "atomCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomWalletDepositFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setBondingCurveConfig",
    inputs: [
      {
        name: "_bondingCurveConfig",
        type: "tuple",
        internalType: "struct BondingCurveConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "address"
          },
          {
            name: "defaultCurveId",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setGeneralConfig",
    inputs: [
      {
        name: "_generalConfig",
        type: "tuple",
        internalType: "struct GeneralConfig",
        components: [
          {
            name: "admin",
            type: "address",
            internalType: "address"
          },
          {
            name: "protocolMultisig",
            type: "address",
            internalType: "address"
          },
          {
            name: "feeDenominator",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "trustBonding",
            type: "address",
            internalType: "address"
          },
          {
            name: "minDeposit",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "minShare",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDataMaxLength",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "decimalPrecision",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setTermCount",
    inputs: [
      {
        name: "_termCount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setTripleConfig",
    inputs: [
      {
        name: "_tripleConfig",
        type: "tuple",
        internalType: "struct TripleConfig",
        components: [
          {
            name: "tripleCreationProtocolFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAtomDepositsOnTripleCreation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "atomDepositFractionForTriple",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setVaultFees",
    inputs: [
      {
        name: "_vaultFees",
        type: "tuple",
        internalType: "struct VaultFees",
        components: [
          {
            name: "entryFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exitFee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "protocolFee",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setWalletConfig",
    inputs: [
      {
        name: "_walletConfig",
        type: "tuple",
        internalType: "struct WalletConfig",
        components: [
          {
            name: "permit2",
            type: "address",
            internalType: "contract IPermit2"
          },
          {
            name: "entryPoint",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWarden",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletBeacon",
            type: "address",
            internalType: "address"
          },
          {
            name: "atomWalletFactory",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [
      {
        name: "interfaceId",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "totalTermsCreated",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "totalUtilization",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "utilizationAmount",
        type: "int256",
        internalType: "int256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "triple",
    inputs: [
      {
        name: "tripleId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "tripleConfig",
    inputs: [],
    outputs: [
      {
        name: "tripleCreationProtocolFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "totalAtomDepositsOnTripleCreation",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "atomDepositFractionForTriple",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "unpause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "vaultFees",
    inputs: [],
    outputs: [
      {
        name: "entryFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "exitFee",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "protocolFee",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "walletConfig",
    inputs: [],
    outputs: [
      {
        name: "permit2",
        type: "address",
        internalType: "contract IPermit2"
      },
      {
        name: "entryPoint",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWarden",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWalletBeacon",
        type: "address",
        internalType: "address"
      },
      {
        name: "atomWalletFactory",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "ApprovalTypeUpdated",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "approvalType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.ApprovalTypes"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomCreated",
    inputs: [
      {
        name: "creator",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "atomData",
        type: "bytes",
        indexed: !1,
        internalType: "bytes"
      },
      {
        name: "atomWallet",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomDepositFractionDeposited",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomWalletDepositFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "AtomWalletDepositFeesClaimed",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "atomWalletOwner",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "feesClaimed",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ConfigSynced",
    inputs: [
      {
        name: "caller",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Deposited",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assetsAfterFees",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "EntryFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ExitFeeCollected",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Initialized",
    inputs: [
      {
        name: "version",
        type: "uint64",
        indexed: !1,
        internalType: "uint64"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Paused",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "PersonalUtilizationAdded",
    inputs: [
      {
        name: "user",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueAdded",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "personalUtilization",
        type: "int256",
        indexed: !1,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "PersonalUtilizationRemoved",
    inputs: [
      {
        name: "user",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueRemoved",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "personalUtilization",
        type: "int256",
        indexed: !1,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ProtocolFeeAccrued",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "ProtocolFeeTransferred",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "destination",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Redeemed",
    inputs: [
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "receiver",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "assets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "fees",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleAdminChanged",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "previousAdminRole",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "newAdminRole",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleGranted",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "RoleRevoked",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "SharePriceChanged",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "sharePrice",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalAssets",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "totalShares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "vaultType",
        type: "uint8",
        indexed: !1,
        internalType: "enum IMultiVault.VaultType"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "SharesPullApproval",
    inputs: [
      {
        name: "accountFrom",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "accountTo",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "status",
        type: "bool",
        indexed: !1,
        internalType: "bool"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TermCountSet",
    inputs: [
      {
        name: "termCount",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TokensRecovered",
    inputs: [
      {
        name: "token",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "recipient",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TotalUtilizationAdded",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueAdded",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "totalUtilization",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TotalUtilizationRemoved",
    inputs: [
      {
        name: "epoch",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "valueRemoved",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      },
      {
        name: "totalUtilization",
        type: "int256",
        indexed: !0,
        internalType: "int256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "TripleCreated",
    inputs: [
      {
        name: "creator",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "subjectId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        indexed: !1,
        internalType: "bytes32"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "Unpaused",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: !1,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WalletMigrated",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "oldWallet",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "newWallet",
        type: "address",
        indexed: !1,
        internalType: "address"
      },
      {
        name: "sharesMigrated",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WrappedERC20Registered",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !0,
        internalType: "uint256"
      },
      {
        name: "wrappedERC20",
        type: "address",
        indexed: !0,
        internalType: "address"
      }
    ],
    anonymous: !1
  },
  {
    type: "event",
    name: "WrapperTransfer",
    inputs: [
      {
        name: "from",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "to",
        type: "address",
        indexed: !0,
        internalType: "address"
      },
      {
        name: "termId",
        type: "bytes32",
        indexed: !0,
        internalType: "bytes32"
      },
      {
        name: "curveId",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      },
      {
        name: "shares",
        type: "uint256",
        indexed: !1,
        internalType: "uint256"
      }
    ],
    anonymous: !1
  },
  {
    type: "error",
    name: "AccessControlBadConfirmation",
    inputs: []
  },
  {
    type: "error",
    name: "AccessControlUnauthorizedAccount",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      },
      {
        name: "neededRole",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "AtomDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "EnforcedPause",
    inputs: []
  },
  {
    type: "error",
    name: "ExpectedPause",
    inputs: []
  },
  {
    type: "error",
    name: "FailedCall",
    inputs: []
  },
  {
    type: "error",
    name: "InsufficientBalance",
    inputs: [
      {
        name: "balance",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "needed",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "InvalidInitialization",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ActionExceedsMaxAssets",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ArraysNotSameLength",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_AtomDataTooLong",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_AtomDoesNotExist",
    inputs: [
      {
        name: "atomId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_AtomExists",
    inputs: [
      {
        name: "atomData",
        type: "bytes",
        internalType: "bytes"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_BurnFromZeroAddress",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_BurnInsufficientBalance",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_CannotApproveOrRevokeSelf",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_DepositBelowMinimumDeposit",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_DepositOrRedeemZeroShares",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_EmptyArray",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientAssets",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientBalance",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InsufficientRemainingSharesInVault",
    inputs: [
      {
        name: "remainingShares",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_InsufficientSharesInVault",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InvalidArrayLength",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_InvalidBondingCurveId",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_NoAtomDataProvided",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_OnlyAssociatedAtomWallet",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_RedeemerNotApproved",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_SenderNotApproved",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_SlippageExceeded",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_TermDoesNotExist",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_TripleExists",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "subjectId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "predicateId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "objectId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "MultiVault_ZeroAddress",
    inputs: []
  },
  {
    type: "error",
    name: "MultiVault_ZeroValue",
    inputs: []
  },
  {
    type: "error",
    name: "NotInitializing",
    inputs: []
  },
  {
    type: "error",
    name: "ReentrancyGuardReentrantCall",
    inputs: []
  },
  {
    type: "error",
    name: "TermDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "TripleDoesNotExist",
    inputs: [
      {
        name: "termId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  }
];
function jA(r, e) {
  return function() {
    return r.apply(e, arguments);
  };
}
const { toString: FD } = Object.prototype, { getPrototypeOf: u_ } = Object, { iterator: lg, toStringTag: VA } = Symbol, ug = /* @__PURE__ */ ((r) => (e) => {
  const i = FD.call(e);
  return r[i] || (r[i] = i.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), es = (r) => (r = r.toLowerCase(), (e) => ug(e) === r), cg = (r) => (e) => typeof e === r, { isArray: Pc } = Array, cc = cg("undefined");
function Fd(r) {
  return r !== null && !cc(r) && r.constructor !== null && !cc(r.constructor) && jr(r.constructor.isBuffer) && r.constructor.isBuffer(r);
}
const GA = es("ArrayBuffer");
function BD(r) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(r) : e = r && r.buffer && GA(r.buffer), e;
}
const zD = cg("string"), jr = cg("function"), HA = cg("number"), Bd = (r) => r !== null && typeof r == "object", jD = (r) => r === !0 || r === !1, Ff = (r) => {
  if (ug(r) !== "object")
    return !1;
  const e = u_(r);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(VA in r) && !(lg in r);
}, VD = (r) => {
  if (!Bd(r) || Fd(r))
    return !1;
  try {
    return Object.keys(r).length === 0 && Object.getPrototypeOf(r) === Object.prototype;
  } catch {
    return !1;
  }
}, GD = es("Date"), HD = es("File"), WD = es("Blob"), qD = es("FileList"), XD = (r) => Bd(r) && jr(r.pipe), YD = (r) => {
  let e;
  return r && (typeof FormData == "function" && r instanceof FormData || jr(r.append) && ((e = ug(r)) === "formdata" || // detect form-data instance
  e === "object" && jr(r.toString) && r.toString() === "[object FormData]"));
}, KD = es("URLSearchParams"), [ZD, QD, $D, JD] = ["ReadableStream", "Request", "Response", "Headers"].map(es), eL = (r) => r.trim ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function zd(r, e, { allOwnKeys: i = !1 } = {}) {
  if (r === null || typeof r > "u")
    return;
  let n, s;
  if (typeof r != "object" && (r = [r]), Pc(r))
    for (n = 0, s = r.length; n < s; n++)
      e.call(null, r[n], n, r);
  else {
    if (Fd(r))
      return;
    const a = i ? Object.getOwnPropertyNames(r) : Object.keys(r), o = a.length;
    let l;
    for (n = 0; n < o; n++)
      l = a[n], e.call(null, r[l], l, r);
  }
}
function WA(r, e) {
  if (Fd(r))
    return null;
  e = e.toLowerCase();
  const i = Object.keys(r);
  let n = i.length, s;
  for (; n-- > 0; )
    if (s = i[n], e === s.toLowerCase())
      return s;
  return null;
}
const el = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, qA = (r) => !cc(r) && r !== el;
function Iv() {
  const { caseless: r, skipUndefined: e } = qA(this) && this || {}, i = {}, n = (s, a) => {
    const o = r && WA(i, a) || a;
    Ff(i[o]) && Ff(s) ? i[o] = Iv(i[o], s) : Ff(s) ? i[o] = Iv({}, s) : Pc(s) ? i[o] = s.slice() : (!e || !cc(s)) && (i[o] = s);
  };
  for (let s = 0, a = arguments.length; s < a; s++)
    arguments[s] && zd(arguments[s], n);
  return i;
}
const tL = (r, e, i, { allOwnKeys: n } = {}) => (zd(e, (s, a) => {
  i && jr(s) ? r[a] = jA(s, i) : r[a] = s;
}, { allOwnKeys: n }), r), iL = (r) => (r.charCodeAt(0) === 65279 && (r = r.slice(1)), r), rL = (r, e, i, n) => {
  r.prototype = Object.create(e.prototype, n), r.prototype.constructor = r, Object.defineProperty(r, "super", {
    value: e.prototype
  }), i && Object.assign(r.prototype, i);
}, nL = (r, e, i, n) => {
  let s, a, o;
  const l = {};
  if (e = e || {}, r == null) return e;
  do {
    for (s = Object.getOwnPropertyNames(r), a = s.length; a-- > 0; )
      o = s[a], (!n || n(o, r, e)) && !l[o] && (e[o] = r[o], l[o] = !0);
    r = i !== !1 && u_(r);
  } while (r && (!i || i(r, e)) && r !== Object.prototype);
  return e;
}, sL = (r, e, i) => {
  r = String(r), (i === void 0 || i > r.length) && (i = r.length), i -= e.length;
  const n = r.indexOf(e, i);
  return n !== -1 && n === i;
}, aL = (r) => {
  if (!r) return null;
  if (Pc(r)) return r;
  let e = r.length;
  if (!HA(e)) return null;
  const i = new Array(e);
  for (; e-- > 0; )
    i[e] = r[e];
  return i;
}, oL = /* @__PURE__ */ ((r) => (e) => r && e instanceof r)(typeof Uint8Array < "u" && u_(Uint8Array)), lL = (r, e) => {
  const n = (r && r[lg]).call(r);
  let s;
  for (; (s = n.next()) && !s.done; ) {
    const a = s.value;
    e.call(r, a[0], a[1]);
  }
}, uL = (r, e) => {
  let i;
  const n = [];
  for (; (i = r.exec(e)) !== null; )
    n.push(i);
  return n;
}, cL = es("HTMLFormElement"), hL = (r) => r.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(i, n, s) {
    return n.toUpperCase() + s;
  }
), NT = (({ hasOwnProperty: r }) => (e, i) => r.call(e, i))(Object.prototype), dL = es("RegExp"), XA = (r, e) => {
  const i = Object.getOwnPropertyDescriptors(r), n = {};
  zd(i, (s, a) => {
    let o;
    (o = e(s, a, r)) !== !1 && (n[a] = o || s);
  }), Object.defineProperties(r, n);
}, pL = (r) => {
  XA(r, (e, i) => {
    if (jr(r) && ["arguments", "caller", "callee"].indexOf(i) !== -1)
      return !1;
    const n = r[i];
    if (jr(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + i + "'");
      });
    }
  });
}, fL = (r, e) => {
  const i = {}, n = (s) => {
    s.forEach((a) => {
      i[a] = !0;
    });
  };
  return Pc(r) ? n(r) : n(String(r).split(e)), i;
}, mL = () => {
}, gL = (r, e) => r != null && Number.isFinite(r = +r) ? r : e;
function yL(r) {
  return !!(r && jr(r.append) && r[VA] === "FormData" && r[lg]);
}
const vL = (r) => {
  const e = new Array(10), i = (n, s) => {
    if (Bd(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (Fd(n))
        return n;
      if (!("toJSON" in n)) {
        e[s] = n;
        const a = Pc(n) ? [] : {};
        return zd(n, (o, l) => {
          const u = i(o, s + 1);
          !cc(u) && (a[l] = u);
        }), e[s] = void 0, a;
      }
    }
    return n;
  };
  return i(r, 0);
}, bL = es("AsyncFunction"), xL = (r) => r && (Bd(r) || jr(r)) && jr(r.then) && jr(r.catch), YA = ((r, e) => r ? setImmediate : e ? ((i, n) => (el.addEventListener("message", ({ source: s, data: a }) => {
  s === el && a === i && n.length && n.shift()();
}, !1), (s) => {
  n.push(s), el.postMessage(i, "*");
}))(`axios@${Math.random()}`, []) : (i) => setTimeout(i))(
  typeof setImmediate == "function",
  jr(el.postMessage)
), _L = typeof queueMicrotask < "u" ? queueMicrotask.bind(el) : typeof process < "u" && process.nextTick || YA, TL = (r) => r != null && jr(r[lg]), he = {
  isArray: Pc,
  isArrayBuffer: GA,
  isBuffer: Fd,
  isFormData: YD,
  isArrayBufferView: BD,
  isString: zD,
  isNumber: HA,
  isBoolean: jD,
  isObject: Bd,
  isPlainObject: Ff,
  isEmptyObject: VD,
  isReadableStream: ZD,
  isRequest: QD,
  isResponse: $D,
  isHeaders: JD,
  isUndefined: cc,
  isDate: GD,
  isFile: HD,
  isBlob: WD,
  isRegExp: dL,
  isFunction: jr,
  isStream: XD,
  isURLSearchParams: KD,
  isTypedArray: oL,
  isFileList: qD,
  forEach: zd,
  merge: Iv,
  extend: tL,
  trim: eL,
  stripBOM: iL,
  inherits: rL,
  toFlatObject: nL,
  kindOf: ug,
  kindOfTest: es,
  endsWith: sL,
  toArray: aL,
  forEachEntry: lL,
  matchAll: uL,
  isHTMLForm: cL,
  hasOwnProperty: NT,
  hasOwnProp: NT,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: XA,
  freezeMethods: pL,
  toObjectSet: fL,
  toCamelCase: hL,
  noop: mL,
  toFiniteNumber: gL,
  findKey: WA,
  global: el,
  isContextDefined: qA,
  isSpecCompliantForm: yL,
  toJSONObject: vL,
  isAsyncFn: bL,
  isThenable: xL,
  setImmediate: YA,
  asap: _L,
  isIterable: TL
};
function Et(r, e, i, n, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = r, this.name = "AxiosError", e && (this.code = e), i && (this.config = i), n && (this.request = n), s && (this.response = s, this.status = s.status ? s.status : null);
}
he.inherits(Et, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: he.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const KA = Et.prototype, ZA = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((r) => {
  ZA[r] = { value: r };
});
Object.defineProperties(Et, ZA);
Object.defineProperty(KA, "isAxiosError", { value: !0 });
Et.from = (r, e, i, n, s, a) => {
  const o = Object.create(KA);
  he.toFlatObject(r, o, function(h) {
    return h !== Error.prototype;
  }, (c) => c !== "isAxiosError");
  const l = r && r.message ? r.message : "Error", u = e == null && r ? r.code : e;
  return Et.call(o, l, u, i, n, s), r && o.cause == null && Object.defineProperty(o, "cause", { value: r, configurable: !0 }), o.name = r && r.name || "Error", a && Object.assign(o, a), o;
};
const wL = null;
function Ov(r) {
  return he.isPlainObject(r) || he.isArray(r);
}
function QA(r) {
  return he.endsWith(r, "[]") ? r.slice(0, -2) : r;
}
function PT(r, e, i) {
  return r ? r.concat(e).map(function(s, a) {
    return s = QA(s), !i && a ? "[" + s + "]" : s;
  }).join(i ? "." : "") : e;
}
function SL(r) {
  return he.isArray(r) && !r.some(Ov);
}
const EL = he.toFlatObject(he, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function hg(r, e, i) {
  if (!he.isObject(r))
    throw new TypeError("target must be an object");
  e = e || new FormData(), i = he.toFlatObject(i, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(y, v) {
    return !he.isUndefined(v[y]);
  });
  const n = i.metaTokens, s = i.visitor || h, a = i.dots, o = i.indexes, u = (i.Blob || typeof Blob < "u" && Blob) && he.isSpecCompliantForm(e);
  if (!he.isFunction(s))
    throw new TypeError("visitor must be a function");
  function c(m) {
    if (m === null) return "";
    if (he.isDate(m))
      return m.toISOString();
    if (he.isBoolean(m))
      return m.toString();
    if (!u && he.isBlob(m))
      throw new Et("Blob is not supported. Use a Buffer instead.");
    return he.isArrayBuffer(m) || he.isTypedArray(m) ? u && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m;
  }
  function h(m, y, v) {
    let g = m;
    if (m && !v && typeof m == "object") {
      if (he.endsWith(y, "{}"))
        y = n ? y : y.slice(0, -2), m = JSON.stringify(m);
      else if (he.isArray(m) && SL(m) || (he.isFileList(m) || he.endsWith(y, "[]")) && (g = he.toArray(m)))
        return y = QA(y), g.forEach(function(x, b) {
          !(he.isUndefined(x) || x === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? PT([y], b, a) : o === null ? y : y + "[]",
            c(x)
          );
        }), !1;
    }
    return Ov(m) ? !0 : (e.append(PT(v, y, a), c(m)), !1);
  }
  const d = [], p = Object.assign(EL, {
    defaultVisitor: h,
    convertValue: c,
    isVisitable: Ov
  });
  function f(m, y) {
    if (!he.isUndefined(m)) {
      if (d.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      d.push(m), he.forEach(m, function(g, _) {
        (!(he.isUndefined(g) || g === null) && s.call(
          e,
          g,
          he.isString(_) ? _.trim() : _,
          y,
          p
        )) === !0 && f(g, y ? y.concat(_) : [_]);
      }), d.pop();
    }
  }
  if (!he.isObject(r))
    throw new TypeError("data must be an object");
  return f(r), e;
}
function IT(r) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(r).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function c_(r, e) {
  this._pairs = [], r && hg(r, this, e);
}
const $A = c_.prototype;
$A.append = function(e, i) {
  this._pairs.push([e, i]);
};
$A.toString = function(e) {
  const i = e ? function(n) {
    return e.call(this, n, IT);
  } : IT;
  return this._pairs.map(function(s) {
    return i(s[0]) + "=" + i(s[1]);
  }, "").join("&");
};
function ML(r) {
  return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function JA(r, e, i) {
  if (!e)
    return r;
  const n = i && i.encode || ML;
  he.isFunction(i) && (i = {
    serialize: i
  });
  const s = i && i.serialize;
  let a;
  if (s ? a = s(e, i) : a = he.isURLSearchParams(e) ? e.toString() : new c_(e, i).toString(n), a) {
    const o = r.indexOf("#");
    o !== -1 && (r = r.slice(0, o)), r += (r.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return r;
}
class OT {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, i, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: i,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    he.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const eC = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, AL = typeof URLSearchParams < "u" ? URLSearchParams : c_, CL = typeof FormData < "u" ? FormData : null, RL = typeof Blob < "u" ? Blob : null, NL = {
  isBrowser: !0,
  classes: {
    URLSearchParams: AL,
    FormData: CL,
    Blob: RL
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, h_ = typeof window < "u" && typeof document < "u", Dv = typeof navigator == "object" && navigator || void 0, PL = h_ && (!Dv || ["ReactNative", "NativeScript", "NS"].indexOf(Dv.product) < 0), IL = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", OL = h_ && window.location.href || "http://localhost", DL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: h_,
  hasStandardBrowserEnv: PL,
  hasStandardBrowserWebWorkerEnv: IL,
  navigator: Dv,
  origin: OL
}, Symbol.toStringTag, { value: "Module" })), gr = {
  ...DL,
  ...NL
};
function LL(r, e) {
  return hg(r, new gr.classes.URLSearchParams(), {
    visitor: function(i, n, s, a) {
      return gr.isNode && he.isBuffer(i) ? (this.append(n, i.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    },
    ...e
  });
}
function kL(r) {
  return he.matchAll(/\w+|\[(\w*)]/g, r).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function UL(r) {
  const e = {}, i = Object.keys(r);
  let n;
  const s = i.length;
  let a;
  for (n = 0; n < s; n++)
    a = i[n], e[a] = r[a];
  return e;
}
function tC(r) {
  function e(i, n, s, a) {
    let o = i[a++];
    if (o === "__proto__") return !0;
    const l = Number.isFinite(+o), u = a >= i.length;
    return o = !o && he.isArray(s) ? s.length : o, u ? (he.hasOwnProp(s, o) ? s[o] = [s[o], n] : s[o] = n, !l) : ((!s[o] || !he.isObject(s[o])) && (s[o] = []), e(i, n, s[o], a) && he.isArray(s[o]) && (s[o] = UL(s[o])), !l);
  }
  if (he.isFormData(r) && he.isFunction(r.entries)) {
    const i = {};
    return he.forEachEntry(r, (n, s) => {
      e(kL(n), s, i, 0);
    }), i;
  }
  return null;
}
function FL(r, e, i) {
  if (he.isString(r))
    try {
      return (e || JSON.parse)(r), he.trim(r);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (i || JSON.stringify)(r);
}
const jd = {
  transitional: eC,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, i) {
    const n = i.getContentType() || "", s = n.indexOf("application/json") > -1, a = he.isObject(e);
    if (a && he.isHTMLForm(e) && (e = new FormData(e)), he.isFormData(e))
      return s ? JSON.stringify(tC(e)) : e;
    if (he.isArrayBuffer(e) || he.isBuffer(e) || he.isStream(e) || he.isFile(e) || he.isBlob(e) || he.isReadableStream(e))
      return e;
    if (he.isArrayBufferView(e))
      return e.buffer;
    if (he.isURLSearchParams(e))
      return i.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let l;
    if (a) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return LL(e, this.formSerializer).toString();
      if ((l = he.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const u = this.env && this.env.FormData;
        return hg(
          l ? { "files[]": e } : e,
          u && new u(),
          this.formSerializer
        );
      }
    }
    return a || s ? (i.setContentType("application/json", !1), FL(e)) : e;
  }],
  transformResponse: [function(e) {
    const i = this.transitional || jd.transitional, n = i && i.forcedJSONParsing, s = this.responseType === "json";
    if (he.isResponse(e) || he.isReadableStream(e))
      return e;
    if (e && he.isString(e) && (n && !this.responseType || s)) {
      const o = !(i && i.silentJSONParsing) && s;
      try {
        return JSON.parse(e, this.parseReviver);
      } catch (l) {
        if (o)
          throw l.name === "SyntaxError" ? Et.from(l, Et.ERR_BAD_RESPONSE, this, null, this.response) : l;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: gr.classes.FormData,
    Blob: gr.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
he.forEach(["delete", "get", "head", "post", "put", "patch"], (r) => {
  jd.headers[r] = {};
});
const BL = he.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), zL = (r) => {
  const e = {};
  let i, n, s;
  return r && r.split(`
`).forEach(function(o) {
    s = o.indexOf(":"), i = o.substring(0, s).trim().toLowerCase(), n = o.substring(s + 1).trim(), !(!i || e[i] && BL[i]) && (i === "set-cookie" ? e[i] ? e[i].push(n) : e[i] = [n] : e[i] = e[i] ? e[i] + ", " + n : n);
  }), e;
}, DT = Symbol("internals");
function eh(r) {
  return r && String(r).trim().toLowerCase();
}
function Bf(r) {
  return r === !1 || r == null ? r : he.isArray(r) ? r.map(Bf) : String(r);
}
function jL(r) {
  const e = /* @__PURE__ */ Object.create(null), i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = i.exec(r); )
    e[n[1]] = n[2];
  return e;
}
const VL = (r) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function ny(r, e, i, n, s) {
  if (he.isFunction(n))
    return n.call(this, e, i);
  if (s && (e = i), !!he.isString(e)) {
    if (he.isString(n))
      return e.indexOf(n) !== -1;
    if (he.isRegExp(n))
      return n.test(e);
  }
}
function GL(r) {
  return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, i, n) => i.toUpperCase() + n);
}
function HL(r, e) {
  const i = he.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(r, n + i, {
      value: function(s, a, o) {
        return this[n].call(this, e, s, a, o);
      },
      configurable: !0
    });
  });
}
let Vr = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, i, n) {
    const s = this;
    function a(l, u, c) {
      const h = eh(u);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const d = he.findKey(s, h);
      (!d || s[d] === void 0 || c === !0 || c === void 0 && s[d] !== !1) && (s[d || u] = Bf(l));
    }
    const o = (l, u) => he.forEach(l, (c, h) => a(c, h, u));
    if (he.isPlainObject(e) || e instanceof this.constructor)
      o(e, i);
    else if (he.isString(e) && (e = e.trim()) && !VL(e))
      o(zL(e), i);
    else if (he.isObject(e) && he.isIterable(e)) {
      let l = {}, u, c;
      for (const h of e) {
        if (!he.isArray(h))
          throw TypeError("Object iterator must return a key-value pair");
        l[c = h[0]] = (u = l[c]) ? he.isArray(u) ? [...u, h[1]] : [u, h[1]] : h[1];
      }
      o(l, i);
    } else
      e != null && a(i, e, n);
    return this;
  }
  get(e, i) {
    if (e = eh(e), e) {
      const n = he.findKey(this, e);
      if (n) {
        const s = this[n];
        if (!i)
          return s;
        if (i === !0)
          return jL(s);
        if (he.isFunction(i))
          return i.call(this, s, n);
        if (he.isRegExp(i))
          return i.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, i) {
    if (e = eh(e), e) {
      const n = he.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!i || ny(this, this[n], n, i)));
    }
    return !1;
  }
  delete(e, i) {
    const n = this;
    let s = !1;
    function a(o) {
      if (o = eh(o), o) {
        const l = he.findKey(n, o);
        l && (!i || ny(n, n[l], l, i)) && (delete n[l], s = !0);
      }
    }
    return he.isArray(e) ? e.forEach(a) : a(e), s;
  }
  clear(e) {
    const i = Object.keys(this);
    let n = i.length, s = !1;
    for (; n--; ) {
      const a = i[n];
      (!e || ny(this, this[a], a, e, !0)) && (delete this[a], s = !0);
    }
    return s;
  }
  normalize(e) {
    const i = this, n = {};
    return he.forEach(this, (s, a) => {
      const o = he.findKey(n, a);
      if (o) {
        i[o] = Bf(s), delete i[a];
        return;
      }
      const l = e ? GL(a) : String(a).trim();
      l !== a && delete i[a], i[l] = Bf(s), n[l] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const i = /* @__PURE__ */ Object.create(null);
    return he.forEach(this, (n, s) => {
      n != null && n !== !1 && (i[s] = e && he.isArray(n) ? n.join(", ") : n);
    }), i;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, i]) => e + ": " + i).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...i) {
    const n = new this(e);
    return i.forEach((s) => n.set(s)), n;
  }
  static accessor(e) {
    const n = (this[DT] = this[DT] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function a(o) {
      const l = eh(o);
      n[l] || (HL(s, o), n[l] = !0);
    }
    return he.isArray(e) ? e.forEach(a) : a(e), this;
  }
};
Vr.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
he.reduceDescriptors(Vr.prototype, ({ value: r }, e) => {
  let i = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => r,
    set(n) {
      this[i] = n;
    }
  };
});
he.freezeMethods(Vr);
function sy(r, e) {
  const i = this || jd, n = e || i, s = Vr.from(n.headers);
  let a = n.data;
  return he.forEach(r, function(l) {
    a = l.call(i, a, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), a;
}
function iC(r) {
  return !!(r && r.__CANCEL__);
}
function Ic(r, e, i) {
  Et.call(this, r ?? "canceled", Et.ERR_CANCELED, e, i), this.name = "CanceledError";
}
he.inherits(Ic, Et, {
  __CANCEL__: !0
});
function rC(r, e, i) {
  const n = i.config.validateStatus;
  !i.status || !n || n(i.status) ? r(i) : e(new Et(
    "Request failed with status code " + i.status,
    [Et.ERR_BAD_REQUEST, Et.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4],
    i.config,
    i.request,
    i
  ));
}
function WL(r) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(r);
  return e && e[1] || "";
}
function qL(r, e) {
  r = r || 10;
  const i = new Array(r), n = new Array(r);
  let s = 0, a = 0, o;
  return e = e !== void 0 ? e : 1e3, function(u) {
    const c = Date.now(), h = n[a];
    o || (o = c), i[s] = u, n[s] = c;
    let d = a, p = 0;
    for (; d !== s; )
      p += i[d++], d = d % r;
    if (s = (s + 1) % r, s === a && (a = (a + 1) % r), c - o < e)
      return;
    const f = h && c - h;
    return f ? Math.round(p * 1e3 / f) : void 0;
  };
}
function XL(r, e) {
  let i = 0, n = 1e3 / e, s, a;
  const o = (c, h = Date.now()) => {
    i = h, s = null, a && (clearTimeout(a), a = null), r(...c);
  };
  return [(...c) => {
    const h = Date.now(), d = h - i;
    d >= n ? o(c, h) : (s = c, a || (a = setTimeout(() => {
      a = null, o(s);
    }, n - d)));
  }, () => s && o(s)];
}
const vm = (r, e, i = 3) => {
  let n = 0;
  const s = qL(50, 250);
  return XL((a) => {
    const o = a.loaded, l = a.lengthComputable ? a.total : void 0, u = o - n, c = s(u), h = o <= l;
    n = o;
    const d = {
      loaded: o,
      total: l,
      progress: l ? o / l : void 0,
      bytes: u,
      rate: c || void 0,
      estimated: c && l && h ? (l - o) / c : void 0,
      event: a,
      lengthComputable: l != null,
      [e ? "download" : "upload"]: !0
    };
    r(d);
  }, i);
}, LT = (r, e) => {
  const i = r != null;
  return [(n) => e[0]({
    lengthComputable: i,
    total: r,
    loaded: n
  }), e[1]];
}, kT = (r) => (...e) => he.asap(() => r(...e)), YL = gr.hasStandardBrowserEnv ? /* @__PURE__ */ ((r, e) => (i) => (i = new URL(i, gr.origin), r.protocol === i.protocol && r.host === i.host && (e || r.port === i.port)))(
  new URL(gr.origin),
  gr.navigator && /(msie|trident)/i.test(gr.navigator.userAgent)
) : () => !0, KL = gr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(r, e, i, n, s, a) {
      const o = [r + "=" + encodeURIComponent(e)];
      he.isNumber(i) && o.push("expires=" + new Date(i).toGMTString()), he.isString(n) && o.push("path=" + n), he.isString(s) && o.push("domain=" + s), a === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(r) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(r) {
      this.write(r, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function ZL(r) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(r);
}
function QL(r, e) {
  return e ? r.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : r;
}
function nC(r, e, i) {
  let n = !ZL(e);
  return r && (n || i == !1) ? QL(r, e) : e;
}
const UT = (r) => r instanceof Vr ? { ...r } : r;
function vl(r, e) {
  e = e || {};
  const i = {};
  function n(c, h, d, p) {
    return he.isPlainObject(c) && he.isPlainObject(h) ? he.merge.call({ caseless: p }, c, h) : he.isPlainObject(h) ? he.merge({}, h) : he.isArray(h) ? h.slice() : h;
  }
  function s(c, h, d, p) {
    if (he.isUndefined(h)) {
      if (!he.isUndefined(c))
        return n(void 0, c, d, p);
    } else return n(c, h, d, p);
  }
  function a(c, h) {
    if (!he.isUndefined(h))
      return n(void 0, h);
  }
  function o(c, h) {
    if (he.isUndefined(h)) {
      if (!he.isUndefined(c))
        return n(void 0, c);
    } else return n(void 0, h);
  }
  function l(c, h, d) {
    if (d in e)
      return n(c, h);
    if (d in r)
      return n(void 0, c);
  }
  const u = {
    url: a,
    method: a,
    data: a,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: l,
    headers: (c, h, d) => s(UT(c), UT(h), d, !0)
  };
  return he.forEach(Object.keys({ ...r, ...e }), function(h) {
    const d = u[h] || s, p = d(r[h], e[h], h);
    he.isUndefined(p) && d !== l || (i[h] = p);
  }), i;
}
const sC = (r) => {
  const e = vl({}, r);
  let { data: i, withXSRFToken: n, xsrfHeaderName: s, xsrfCookieName: a, headers: o, auth: l } = e;
  if (e.headers = o = Vr.from(o), e.url = JA(nC(e.baseURL, e.url, e.allowAbsoluteUrls), r.params, r.paramsSerializer), l && o.set(
    "Authorization",
    "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))
  ), he.isFormData(i)) {
    if (gr.hasStandardBrowserEnv || gr.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if (he.isFunction(i.getHeaders)) {
      const u = i.getHeaders(), c = ["content-type", "content-length"];
      Object.entries(u).forEach(([h, d]) => {
        c.includes(h.toLowerCase()) && o.set(h, d);
      });
    }
  }
  if (gr.hasStandardBrowserEnv && (n && he.isFunction(n) && (n = n(e)), n || n !== !1 && YL(e.url))) {
    const u = s && a && KL.read(a);
    u && o.set(s, u);
  }
  return e;
}, $L = typeof XMLHttpRequest < "u", JL = $L && function(r) {
  return new Promise(function(i, n) {
    const s = sC(r);
    let a = s.data;
    const o = Vr.from(s.headers).normalize();
    let { responseType: l, onUploadProgress: u, onDownloadProgress: c } = s, h, d, p, f, m;
    function y() {
      f && f(), m && m(), s.cancelToken && s.cancelToken.unsubscribe(h), s.signal && s.signal.removeEventListener("abort", h);
    }
    let v = new XMLHttpRequest();
    v.open(s.method.toUpperCase(), s.url, !0), v.timeout = s.timeout;
    function g() {
      if (!v)
        return;
      const x = Vr.from(
        "getAllResponseHeaders" in v && v.getAllResponseHeaders()
      ), T = {
        data: !l || l === "text" || l === "json" ? v.responseText : v.response,
        status: v.status,
        statusText: v.statusText,
        headers: x,
        config: r,
        request: v
      };
      rC(function(M) {
        i(M), y();
      }, function(M) {
        n(M), y();
      }, T), v = null;
    }
    "onloadend" in v ? v.onloadend = g : v.onreadystatechange = function() {
      !v || v.readyState !== 4 || v.status === 0 && !(v.responseURL && v.responseURL.indexOf("file:") === 0) || setTimeout(g);
    }, v.onabort = function() {
      v && (n(new Et("Request aborted", Et.ECONNABORTED, r, v)), v = null);
    }, v.onerror = function(b) {
      const T = b && b.message ? b.message : "Network Error", E = new Et(T, Et.ERR_NETWORK, r, v);
      E.event = b || null, n(E), v = null;
    }, v.ontimeout = function() {
      let b = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
      const T = s.transitional || eC;
      s.timeoutErrorMessage && (b = s.timeoutErrorMessage), n(new Et(
        b,
        T.clarifyTimeoutError ? Et.ETIMEDOUT : Et.ECONNABORTED,
        r,
        v
      )), v = null;
    }, a === void 0 && o.setContentType(null), "setRequestHeader" in v && he.forEach(o.toJSON(), function(b, T) {
      v.setRequestHeader(T, b);
    }), he.isUndefined(s.withCredentials) || (v.withCredentials = !!s.withCredentials), l && l !== "json" && (v.responseType = s.responseType), c && ([p, m] = vm(c, !0), v.addEventListener("progress", p)), u && v.upload && ([d, f] = vm(u), v.upload.addEventListener("progress", d), v.upload.addEventListener("loadend", f)), (s.cancelToken || s.signal) && (h = (x) => {
      v && (n(!x || x.type ? new Ic(null, r, v) : x), v.abort(), v = null);
    }, s.cancelToken && s.cancelToken.subscribe(h), s.signal && (s.signal.aborted ? h() : s.signal.addEventListener("abort", h)));
    const _ = WL(s.url);
    if (_ && gr.protocols.indexOf(_) === -1) {
      n(new Et("Unsupported protocol " + _ + ":", Et.ERR_BAD_REQUEST, r));
      return;
    }
    v.send(a || null);
  });
}, ek = (r, e) => {
  const { length: i } = r = r ? r.filter(Boolean) : [];
  if (e || i) {
    let n = new AbortController(), s;
    const a = function(c) {
      if (!s) {
        s = !0, l();
        const h = c instanceof Error ? c : this.reason;
        n.abort(h instanceof Et ? h : new Ic(h instanceof Error ? h.message : h));
      }
    };
    let o = e && setTimeout(() => {
      o = null, a(new Et(`timeout ${e} of ms exceeded`, Et.ETIMEDOUT));
    }, e);
    const l = () => {
      r && (o && clearTimeout(o), o = null, r.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(a) : c.removeEventListener("abort", a);
      }), r = null);
    };
    r.forEach((c) => c.addEventListener("abort", a));
    const { signal: u } = n;
    return u.unsubscribe = () => he.asap(l), u;
  }
}, tk = function* (r, e) {
  let i = r.byteLength;
  if (i < e) {
    yield r;
    return;
  }
  let n = 0, s;
  for (; n < i; )
    s = n + e, yield r.slice(n, s), n = s;
}, ik = async function* (r, e) {
  for await (const i of rk(r))
    yield* tk(i, e);
}, rk = async function* (r) {
  if (r[Symbol.asyncIterator]) {
    yield* r;
    return;
  }
  const e = r.getReader();
  try {
    for (; ; ) {
      const { done: i, value: n } = await e.read();
      if (i)
        break;
      yield n;
    }
  } finally {
    await e.cancel();
  }
}, FT = (r, e, i, n) => {
  const s = ik(r, e);
  let a = 0, o, l = (u) => {
    o || (o = !0, n && n(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: c, value: h } = await s.next();
        if (c) {
          l(), u.close();
          return;
        }
        let d = h.byteLength;
        if (i) {
          let p = a += d;
          i(p);
        }
        u.enqueue(new Uint8Array(h));
      } catch (c) {
        throw l(c), c;
      }
    },
    cancel(u) {
      return l(u), s.return();
    }
  }, {
    highWaterMark: 2
  });
}, BT = 64 * 1024, { isFunction: lp } = he, nk = (({ Request: r, Response: e }) => ({
  Request: r,
  Response: e
}))(he.global), {
  ReadableStream: zT,
  TextEncoder: jT
} = he.global, VT = (r, ...e) => {
  try {
    return !!r(...e);
  } catch {
    return !1;
  }
}, sk = (r) => {
  r = he.merge.call({
    skipUndefined: !0
  }, nk, r);
  const { fetch: e, Request: i, Response: n } = r, s = e ? lp(e) : typeof fetch == "function", a = lp(i), o = lp(n);
  if (!s)
    return !1;
  const l = s && lp(zT), u = s && (typeof jT == "function" ? /* @__PURE__ */ ((m) => (y) => m.encode(y))(new jT()) : async (m) => new Uint8Array(await new i(m).arrayBuffer())), c = a && l && VT(() => {
    let m = !1;
    const y = new i(gr.origin, {
      body: new zT(),
      method: "POST",
      get duplex() {
        return m = !0, "half";
      }
    }).headers.has("Content-Type");
    return m && !y;
  }), h = o && l && VT(() => he.isReadableStream(new n("").body)), d = {
    stream: h && ((m) => m.body)
  };
  s && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((m) => {
    !d[m] && (d[m] = (y, v) => {
      let g = y && y[m];
      if (g)
        return g.call(y);
      throw new Et(`Response type '${m}' is not supported`, Et.ERR_NOT_SUPPORT, v);
    });
  });
  const p = async (m) => {
    if (m == null)
      return 0;
    if (he.isBlob(m))
      return m.size;
    if (he.isSpecCompliantForm(m))
      return (await new i(gr.origin, {
        method: "POST",
        body: m
      }).arrayBuffer()).byteLength;
    if (he.isArrayBufferView(m) || he.isArrayBuffer(m))
      return m.byteLength;
    if (he.isURLSearchParams(m) && (m = m + ""), he.isString(m))
      return (await u(m)).byteLength;
  }, f = async (m, y) => {
    const v = he.toFiniteNumber(m.getContentLength());
    return v ?? p(y);
  };
  return async (m) => {
    let {
      url: y,
      method: v,
      data: g,
      signal: _,
      cancelToken: x,
      timeout: b,
      onDownloadProgress: T,
      onUploadProgress: E,
      responseType: M,
      headers: C,
      withCredentials: S = "same-origin",
      fetchOptions: w
    } = sC(m), R = e || fetch;
    M = M ? (M + "").toLowerCase() : "text";
    let O = ek([_, x && x.toAbortSignal()], b), P = null;
    const A = O && O.unsubscribe && (() => {
      O.unsubscribe();
    });
    let D;
    try {
      if (E && c && v !== "get" && v !== "head" && (D = await f(C, g)) !== 0) {
        let B = new i(y, {
          method: "POST",
          body: g,
          duplex: "half"
        }), W;
        if (he.isFormData(g) && (W = B.headers.get("content-type")) && C.setContentType(W), B.body) {
          const [G, z] = LT(
            D,
            vm(kT(E))
          );
          g = FT(B.body, BT, G, z);
        }
      }
      he.isString(S) || (S = S ? "include" : "omit");
      const L = a && "credentials" in i.prototype, H = {
        ...w,
        signal: O,
        method: v.toUpperCase(),
        headers: C.normalize().toJSON(),
        body: g,
        duplex: "half",
        credentials: L ? S : void 0
      };
      P = a && new i(y, H);
      let V = await (a ? R(P, w) : R(y, H));
      const X = h && (M === "stream" || M === "response");
      if (h && (T || X && A)) {
        const B = {};
        ["status", "statusText", "headers"].forEach((K) => {
          B[K] = V[K];
        });
        const W = he.toFiniteNumber(V.headers.get("content-length")), [G, z] = T && LT(
          W,
          vm(kT(T), !0)
        ) || [];
        V = new n(
          FT(V.body, BT, G, () => {
            z && z(), A && A();
          }),
          B
        );
      }
      M = M || "text";
      let F = await d[he.findKey(d, M) || "text"](V, m);
      return !X && A && A(), await new Promise((B, W) => {
        rC(B, W, {
          data: F,
          headers: Vr.from(V.headers),
          status: V.status,
          statusText: V.statusText,
          config: m,
          request: P
        });
      });
    } catch (L) {
      throw A && A(), L && L.name === "TypeError" && /Load failed|fetch/i.test(L.message) ? Object.assign(
        new Et("Network Error", Et.ERR_NETWORK, m, P),
        {
          cause: L.cause || L
        }
      ) : Et.from(L, L && L.code, m, P);
    }
  };
}, ak = /* @__PURE__ */ new Map(), aC = (r) => {
  let e = r ? r.env : {};
  const { fetch: i, Request: n, Response: s } = e, a = [
    n,
    s,
    i
  ];
  let o = a.length, l = o, u, c, h = ak;
  for (; l--; )
    u = a[l], c = h.get(u), c === void 0 && h.set(u, c = l ? /* @__PURE__ */ new Map() : sk(e)), h = c;
  return c;
};
aC();
const Lv = {
  http: wL,
  xhr: JL,
  fetch: {
    get: aC
  }
};
he.forEach(Lv, (r, e) => {
  if (r) {
    try {
      Object.defineProperty(r, "name", { value: e });
    } catch {
    }
    Object.defineProperty(r, "adapterName", { value: e });
  }
});
const GT = (r) => `- ${r}`, ok = (r) => he.isFunction(r) || r === null || r === !1, oC = {
  getAdapter: (r, e) => {
    r = he.isArray(r) ? r : [r];
    const { length: i } = r;
    let n, s;
    const a = {};
    for (let o = 0; o < i; o++) {
      n = r[o];
      let l;
      if (s = n, !ok(n) && (s = Lv[(l = String(n)).toLowerCase()], s === void 0))
        throw new Et(`Unknown adapter '${l}'`);
      if (s && (he.isFunction(s) || (s = s.get(e))))
        break;
      a[l || "#" + o] = s;
    }
    if (!s) {
      const o = Object.entries(a).map(
        ([u, c]) => `adapter ${u} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let l = i ? o.length > 1 ? `since :
` + o.map(GT).join(`
`) : " " + GT(o[0]) : "as no adapter specified";
      throw new Et(
        "There is no suitable adapter to dispatch the request " + l,
        "ERR_NOT_SUPPORT"
      );
    }
    return s;
  },
  adapters: Lv
};
function ay(r) {
  if (r.cancelToken && r.cancelToken.throwIfRequested(), r.signal && r.signal.aborted)
    throw new Ic(null, r);
}
function HT(r) {
  return ay(r), r.headers = Vr.from(r.headers), r.data = sy.call(
    r,
    r.transformRequest
  ), ["post", "put", "patch"].indexOf(r.method) !== -1 && r.headers.setContentType("application/x-www-form-urlencoded", !1), oC.getAdapter(r.adapter || jd.adapter, r)(r).then(function(n) {
    return ay(r), n.data = sy.call(
      r,
      r.transformResponse,
      n
    ), n.headers = Vr.from(n.headers), n;
  }, function(n) {
    return iC(n) || (ay(r), n && n.response && (n.response.data = sy.call(
      r,
      r.transformResponse,
      n.response
    ), n.response.headers = Vr.from(n.response.headers))), Promise.reject(n);
  });
}
const lC = "1.12.2", dg = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((r, e) => {
  dg[r] = function(n) {
    return typeof n === r || "a" + (e < 1 ? "n " : " ") + r;
  };
});
const WT = {};
dg.transitional = function(e, i, n) {
  function s(a, o) {
    return "[Axios v" + lC + "] Transitional option '" + a + "'" + o + (n ? ". " + n : "");
  }
  return (a, o, l) => {
    if (e === !1)
      throw new Et(
        s(o, " has been removed" + (i ? " in " + i : "")),
        Et.ERR_DEPRECATED
      );
    return i && !WT[o] && (WT[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + i + " and will be removed in the near future"
      )
    )), e ? e(a, o, l) : !0;
  };
};
dg.spelling = function(e) {
  return (i, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function lk(r, e, i) {
  if (typeof r != "object")
    throw new Et("options must be an object", Et.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(r);
  let s = n.length;
  for (; s-- > 0; ) {
    const a = n[s], o = e[a];
    if (o) {
      const l = r[a], u = l === void 0 || o(l, a, r);
      if (u !== !0)
        throw new Et("option " + a + " must be " + u, Et.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (i !== !0)
      throw new Et("Unknown option " + a, Et.ERR_BAD_OPTION);
  }
}
const zf = {
  assertOptions: lk,
  validators: dg
}, rs = zf.validators;
let fl = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new OT(),
      response: new OT()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, i) {
    try {
      return await this._request(e, i);
    } catch (n) {
      if (n instanceof Error) {
        let s = {};
        Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error();
        const a = s.stack ? s.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? a && !String(n.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + a) : n.stack = a;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, i) {
    typeof e == "string" ? (i = i || {}, i.url = e) : i = e || {}, i = vl(this.defaults, i);
    const { transitional: n, paramsSerializer: s, headers: a } = i;
    n !== void 0 && zf.assertOptions(n, {
      silentJSONParsing: rs.transitional(rs.boolean),
      forcedJSONParsing: rs.transitional(rs.boolean),
      clarifyTimeoutError: rs.transitional(rs.boolean)
    }, !1), s != null && (he.isFunction(s) ? i.paramsSerializer = {
      serialize: s
    } : zf.assertOptions(s, {
      encode: rs.function,
      serialize: rs.function
    }, !0)), i.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? i.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : i.allowAbsoluteUrls = !0), zf.assertOptions(i, {
      baseUrl: rs.spelling("baseURL"),
      withXsrfToken: rs.spelling("withXSRFToken")
    }, !0), i.method = (i.method || this.defaults.method || "get").toLowerCase();
    let o = a && he.merge(
      a.common,
      a[i.method]
    );
    a && he.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (m) => {
        delete a[m];
      }
    ), i.headers = Vr.concat(o, a);
    const l = [];
    let u = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(i) === !1 || (u = u && y.synchronous, l.unshift(y.fulfilled, y.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(y) {
      c.push(y.fulfilled, y.rejected);
    });
    let h, d = 0, p;
    if (!u) {
      const m = [HT.bind(this), void 0];
      for (m.unshift(...l), m.push(...c), p = m.length, h = Promise.resolve(i); d < p; )
        h = h.then(m[d++], m[d++]);
      return h;
    }
    p = l.length;
    let f = i;
    for (; d < p; ) {
      const m = l[d++], y = l[d++];
      try {
        f = m(f);
      } catch (v) {
        y.call(this, v);
        break;
      }
    }
    try {
      h = HT.call(this, f);
    } catch (m) {
      return Promise.reject(m);
    }
    for (d = 0, p = c.length; d < p; )
      h = h.then(c[d++], c[d++]);
    return h;
  }
  getUri(e) {
    e = vl(this.defaults, e);
    const i = nC(e.baseURL, e.url, e.allowAbsoluteUrls);
    return JA(i, e.params, e.paramsSerializer);
  }
};
he.forEach(["delete", "get", "head", "options"], function(e) {
  fl.prototype[e] = function(i, n) {
    return this.request(vl(n || {}, {
      method: e,
      url: i,
      data: (n || {}).data
    }));
  };
});
he.forEach(["post", "put", "patch"], function(e) {
  function i(n) {
    return function(a, o, l) {
      return this.request(vl(l || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: o
      }));
    };
  }
  fl.prototype[e] = i(), fl.prototype[e + "Form"] = i(!0);
});
let uk = class uC {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let i;
    this.promise = new Promise(function(a) {
      i = a;
    });
    const n = this;
    this.promise.then((s) => {
      if (!n._listeners) return;
      let a = n._listeners.length;
      for (; a-- > 0; )
        n._listeners[a](s);
      n._listeners = null;
    }), this.promise.then = (s) => {
      let a;
      const o = new Promise((l) => {
        n.subscribe(l), a = l;
      }).then(s);
      return o.cancel = function() {
        n.unsubscribe(a);
      }, o;
    }, e(function(a, o, l) {
      n.reason || (n.reason = new Ic(a, o, l), i(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const i = this._listeners.indexOf(e);
    i !== -1 && this._listeners.splice(i, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), i = (n) => {
      e.abort(n);
    };
    return this.subscribe(i), e.signal.unsubscribe = () => this.unsubscribe(i), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new uC(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
function ck(r) {
  return function(i) {
    return r.apply(null, i);
  };
}
function hk(r) {
  return he.isObject(r) && r.isAxiosError === !0;
}
const kv = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(kv).forEach(([r, e]) => {
  kv[e] = r;
});
function cC(r) {
  const e = new fl(r), i = jA(fl.prototype.request, e);
  return he.extend(i, fl.prototype, e, { allOwnKeys: !0 }), he.extend(i, e, null, { allOwnKeys: !0 }), i.create = function(s) {
    return cC(vl(r, s));
  }, i;
}
const Ri = cC(jd);
Ri.Axios = fl;
Ri.CanceledError = Ic;
Ri.CancelToken = uk;
Ri.isCancel = iC;
Ri.VERSION = lC;
Ri.toFormData = hg;
Ri.AxiosError = Et;
Ri.Cancel = Ri.CanceledError;
Ri.all = function(e) {
  return Promise.all(e);
};
Ri.spread = ck;
Ri.isAxiosError = hk;
Ri.mergeConfig = vl;
Ri.AxiosHeaders = Vr;
Ri.formToJSON = (r) => tC(he.isHTMLForm(r) ? new FormData(r) : r);
Ri.getAdapter = oC.getAdapter;
Ri.HttpStatusCode = kv;
Ri.default = Ri;
const {
  Axios: vle,
  AxiosError: ble,
  CanceledError: xle,
  isCancel: _le,
  CancelToken: Tle,
  VERSION: wle,
  all: Sle,
  Cancel: Ele,
  isAxiosError: Mle,
  spread: Ale,
  toFormData: Cle,
  AxiosHeaders: Rle,
  HttpStatusCode: Nle,
  formToJSON: Ple,
  getAdapter: Ile,
  mergeConfig: Ole
} = Ri;
let hC = null;
const Dle = (r) => {
  hC = r;
}, d_ = () => hC, dC = async (r) => {
  var e;
  try {
    const i = d_();
    if (!((e = i == null ? void 0 : i.PINATA_CONFIG) != null && e.JWT_KEY))
      throw new Error("Configuration Pinata manquante. Appelez setPinataConstants() avec PINATA_CONFIG");
    const n = i.PINATA_CONFIG.JWT_KEY, s = new FormData();
    return s.append("file", r), `ipfs://${(await Ri.post(
      "https://api.pinata.cloud/pinning/pinFileToIPFS",
      s,
      {
        headers: {
          "Content-Type": "multipart/form-data",
          Authorization: `Bearer ${n}`
        }
      }
    )).data.IpfsHash}`;
  } catch (i) {
    throw console.error("Erreur lors du téléversement vers Pinata:", i), new Error("Échec du téléversement de l'image vers IPFS");
  }
}, p_ = (r) => r ? r.startsWith("ipfs://") : !1, pC = async (r) => {
  var e;
  if (!p_(r)) return r;
  try {
    const i = d_();
    if (!((e = i == null ? void 0 : i.PINATA_CONFIG) != null && e.IPFS_GATEWAY))
      throw new Error("Configuration Pinata manquante. Appelez setPinataConstants() avec PINATA_CONFIG");
    const n = i.PINATA_CONFIG.IPFS_GATEWAY, s = r.replace("ipfs://", "");
    return `https://${n}/ipfs/${s}`;
  } catch (i) {
    throw console.error("Erreur lors de la conversion IPFS vers HTTP:", i), i;
  }
}, dk = ({ src: r }) => {
  const [e, i] = si.useState(r), [n, s] = si.useState(!0);
  return si.useEffect(() => {
    (async () => {
      s(!0);
      try {
        const o = pk(r) ? fk(r) : r;
        i(o);
      } catch (o) {
        console.error("Error loading image:", o);
      } finally {
        s(!1);
      }
    })();
  }, [r]), n ? /* @__PURE__ */ I.jsx("div", { children: "Loading image..." }) : /* @__PURE__ */ I.jsx(
    "img",
    {
      src: e,
      alt: "Preview",
      style: {
        maxWidth: "100%",
        maxHeight: "150px",
        borderRadius: "5px"
      }
    }
  );
}, pk = (r) => r.startsWith("ipfs://"), fk = (r) => r.replace("ipfs://", "https://gateway.pinata.cloud/ipfs/"), mk = ({
  step: r,
  isCreatingAtom: e,
  isCreatingTriples: i,
  creationSuccess: n,
  atomId: s,
  tripleCreated: a,
  walletAddress: o,
  hasExistingAtom: l,
  formData: u,
  handleInputChange: c,
  handleSelectChange: h,
  handleFileUpload: d,
  handleSubmit: p,
  isLoading: f,
  isUploading: m,
  fileInputRef: y,
  constants: v
}) => {
  const { OFFICIAL_GUILDS: g } = v;
  return /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
    /* @__PURE__ */ I.jsxs("div", { style: { marginBottom: "20px" }, children: [
      /* @__PURE__ */ I.jsxs(
        "div",
        {
          style: {
            display: "flex",
            justifyContent: "space-between",
            marginBottom: "10px"
          },
          children: [
            /* @__PURE__ */ I.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
              /* @__PURE__ */ I.jsx(
                "div",
                {
                  style: {
                    width: "30px",
                    height: "30px",
                    borderRadius: "15px",
                    backgroundColor: e || r > 1 ? "#FFD32A" : "#2e2e40",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    margin: "0 auto",
                    color: e || r > 1 ? "#000" : "#fff"
                  },
                  children: r > 1 ? "✓" : "1"
                }
              ),
              /* @__PURE__ */ I.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Atom Creation" })
            ] }),
            /* @__PURE__ */ I.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
              /* @__PURE__ */ I.jsx(
                "div",
                {
                  style: {
                    width: "30px",
                    height: "30px",
                    borderRadius: "15px",
                    backgroundColor: i || r > 2 ? "#FFD32A" : "#2e2e40",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    margin: "0 auto",
                    color: i || r > 2 ? "#000" : "#fff"
                  },
                  children: r > 2 ? "✓" : "2"
                }
              ),
              /* @__PURE__ */ I.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Triples Creation" })
            ] }),
            /* @__PURE__ */ I.jsxs("div", { style: { textAlign: "center", flex: 1 }, children: [
              /* @__PURE__ */ I.jsx(
                "div",
                {
                  style: {
                    width: "30px",
                    height: "30px",
                    borderRadius: "15px",
                    backgroundColor: r === 3 ? "#4CAF50" : "#2e2e40",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    margin: "0 auto",
                    color: r === 3 ? "#000" : "#fff"
                  },
                  children: r === 3 ? "✓" : "3"
                }
              ),
              /* @__PURE__ */ I.jsx("p", { style: { fontSize: "0.8em", marginTop: "5px" }, children: "Success" })
            ] })
          ]
        }
      ),
      /* @__PURE__ */ I.jsx(
        "div",
        {
          style: {
            height: "4px",
            backgroundColor: "#2e2e40",
            position: "relative",
            marginBottom: "20px"
          },
          children: /* @__PURE__ */ I.jsx(
            "div",
            {
              style: {
                position: "absolute",
                left: 0,
                top: 0,
                height: "100%",
                width: `${(r - 1) * 50}%`,
                backgroundColor: "#FFD32A",
                transition: "width 0.3s ease"
              }
            }
          )
        }
      )
    ] }),
    n ? /* @__PURE__ */ I.jsxs("div", { style: { textAlign: "center", color: "#4CAF50" }, children: [
      /* @__PURE__ */ I.jsx("h3", { style: { color: "#4CAF50", marginBottom: "10px" }, children: "Success!" }),
      /* @__PURE__ */ I.jsx("p", { children: "Your player has been created successfully." }),
      /* @__PURE__ */ I.jsxs("p", { children: [
        "Atom ID: ",
        s
      ] }),
      /* @__PURE__ */ I.jsxs("p", { children: [
        "Triples created: ",
        a ? "Yes" : "No"
      ] }),
      /* @__PURE__ */ I.jsx("p", { children: "This window will close automatically..." })
    ] }) : o ? l ? /* @__PURE__ */ I.jsx("p", { style: { textAlign: "center", color: "#ff4444" }, children: "You already have an atom associated with this wallet" }) : /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
      /* @__PURE__ */ I.jsxs("div", { style: { marginBottom: "15px" }, children: [
        /* @__PURE__ */ I.jsx(
          "label",
          {
            style: {
              display: "block",
              marginBottom: "5px",
              fontSize: "0.9em",
              textAlign: "left"
            },
            children: "Username"
          }
        ),
        /* @__PURE__ */ I.jsx(
          "input",
          {
            type: "text",
            name: "pseudo",
            value: u.pseudo,
            onChange: c,
            placeholder: "Enter your username",
            style: {
              width: "100%",
              padding: "8px",
              backgroundColor: "#1e1e30",
              border: "1px solid #333",
              color: "#fff",
              borderRadius: "4px"
            }
          }
        )
      ] }),
      /* @__PURE__ */ I.jsxs("div", { style: { marginBottom: "15px" }, children: [
        /* @__PURE__ */ I.jsx(
          "label",
          {
            style: {
              display: "block",
              marginBottom: "5px",
              fontSize: "0.9em",
              textAlign: "left"
            },
            children: "Player UID (optional)"
          }
        ),
        /* @__PURE__ */ I.jsx(
          "input",
          {
            type: "text",
            name: "userId",
            value: u.userId,
            onChange: c,
            placeholder: "Enter your Player UID",
            style: {
              width: "100%",
              padding: "8px",
              backgroundColor: "#1e1e30",
              border: "1px solid #333",
              color: "#fff",
              borderRadius: "4px"
            }
          }
        )
      ] }),
      /* @__PURE__ */ I.jsxs("div", { style: { marginBottom: "15px" }, children: [
        /* @__PURE__ */ I.jsx(
          "label",
          {
            style: {
              display: "block",
              marginBottom: "5px",
              fontSize: "0.9em",
              textAlign: "left"
            },
            children: "Guild (Optional)"
          }
        ),
        /* @__PURE__ */ I.jsxs(
          "select",
          {
            name: "guildId",
            value: u.guildId || "",
            onChange: h,
            style: {
              width: "100%",
              padding: "8px",
              backgroundColor: "#1e1e30",
              border: "1px solid #333",
              color: "#fff",
              borderRadius: "4px"
            },
            children: [
              /* @__PURE__ */ I.jsx("option", { value: "", children: "Select a guild" }),
              g.map((_) => /* @__PURE__ */ I.jsx("option", { value: _.id.toString(), children: _.name }, _.id.toString()))
            ]
          }
        )
      ] }),
      /* @__PURE__ */ I.jsxs("div", { style: { marginBottom: "15px" }, children: [
        /* @__PURE__ */ I.jsx(
          "label",
          {
            style: {
              display: "block",
              marginBottom: "5px",
              fontSize: "0.9em",
              textAlign: "left"
            },
            children: "Player profile picture (optional)"
          }
        ),
        /* @__PURE__ */ I.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "column",
              gap: "10px"
            },
            children: [
              /* @__PURE__ */ I.jsxs("div", { children: [
                /* @__PURE__ */ I.jsx(
                  "button",
                  {
                    onClick: () => {
                      var _;
                      return (_ = y.current) == null ? void 0 : _.click();
                    },
                    style: {
                      padding: "8px 15px",
                      backgroundColor: "#2e2e40",
                      color: "#fff",
                      border: "1px solid #333",
                      borderRadius: "4px",
                      cursor: "pointer",
                      marginRight: "10px"
                    },
                    disabled: m,
                    children: m ? "Upload in progress..." : "Choose an image"
                  }
                ),
                /* @__PURE__ */ I.jsx(
                  "input",
                  {
                    ref: y,
                    type: "file",
                    accept: "image/*",
                    onChange: d,
                    style: { display: "none" }
                  }
                )
              ] }),
              /* @__PURE__ */ I.jsx(
                "p",
                {
                  style: { fontSize: "0.8em", color: "#aaa", marginTop: "0px" },
                  children: "This image will be used as your player's profile picture."
                }
              ),
              u.image && /* @__PURE__ */ I.jsxs("div", { style: { marginTop: "10px" }, children: [
                /* @__PURE__ */ I.jsx(
                  "p",
                  {
                    style: {
                      fontSize: "0.8em",
                      color: "#aaa",
                      marginBottom: "5px"
                    },
                    children: "Image preview:"
                  }
                ),
                /* @__PURE__ */ I.jsx(dk, { src: u.image })
              ] })
            ]
          }
        )
      ] }),
      /* @__PURE__ */ I.jsx("div", { style: { textAlign: "center" }, children: /* @__PURE__ */ I.jsx(
        "button",
        {
          onClick: p,
          disabled: f || m,
          style: {
            padding: "8px 20px",
            backgroundColor: "#FFD32A",
            color: "#000",
            border: "none",
            borderRadius: "5px",
            cursor: "pointer",
            fontWeight: "bold",
            opacity: f || m ? 0.7 : 1
          },
          children: f ? e ? "Creating atom..." : i ? "Creating triples..." : "Creating in progress..." : "VALIDATE"
        }
      ) })
    ] }) : /* @__PURE__ */ I.jsx("div", { children: /* @__PURE__ */ I.jsx("p", { style: { textAlign: "center", color: "#ff4444" }, children: "Please connect your wallet first" }) })
  ] });
}, gk = async (r) => {
  var e, i;
  try {
    const n = d_();
    if (!((e = n == null ? void 0 : n.PINATA_CONFIG) != null && e.JWT_KEY) || !((i = n == null ? void 0 : n.PINATA_CONFIG) != null && i.IPFS_GATEWAY))
      throw new Error("Configuration Pinata manquante. Appelez setPinataConstants() avec PINATA_CONFIG");
    const s = new Blob([JSON.stringify(r)], { type: "application/json" }), a = new File([s], "data.json", { type: "application/json" }), l = (await dC(a)).replace("ipfs://", ""), u = n.PINATA_CONFIG.IPFS_GATEWAY;
    return {
      ipfsHash: `ipfs://${l}`,
      // ← AJOUTER LE PRÉFIXE ipfs://
      httpUrl: `https://${u}/ipfs/${l}`
    };
  } catch (n) {
    throw console.error("Erreur lors du hachage de données vers IPFS:", n), n;
  }
}, yk = ({ walletConnected: r, walletAddress: e, publicClient: i }) => ({
  createAtom: async (s) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const a = {
        "@context": "https://schema.org/",
        "@type": "Thing",
        ...s
      };
      a.image && p_(a.image) && (a.image = await pC(a.image));
      const o = JSON.stringify(a), l = EA(o), { ipfsHash: u } = await gk(a), c = l_(kD(["bytes"], [l])), h = BigInt(c), d = await r.writeContract({
        address: pl,
        abi: ju,
        functionName: "createAtoms",
        args: [
          [l],
          [CT]
        ],
        value: CT
      });
      return {
        atomId: h,
        ipfsHash: u
      };
    } catch (a) {
      throw console.error("Error creating atom:", a), a;
    }
  }
}), vk = ({ walletConnected: r, walletAddress: e, publicClient: i, constants: n }) => {
  const { PLAYER_TRIPLE_TYPES: s } = n, a = async (u, c, h) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const d = i || r;
      return !d || typeof d.readContract != "function" ? (console.warn("No valid read client available to check if triple exists"), !1) : await d.readContract({
        address: pl,
        abi: ju,
        functionName: "isTriple",
        args: [u, c, h]
      });
    } catch (d) {
      if (console.error("Error checking if triple exists:", d), i && i !== r && typeof i.readContract == "function")
        try {
          return await i.readContract({
            address: pl,
            abi: ju,
            functionName: "isTriple",
            args: [u, c, h]
          });
        } catch (p) {
          console.error("Second attempt failed when checking if triple exists:", p);
        }
      return !1;
    }
  }, o = async (u) => {
    if (!r || !e)
      throw new Error("Wallet not connected");
    try {
      const c = u.map((y) => `0x${y.subjectId.toString(16).padStart(64, "0")}`), h = u.map((y) => `0x${y.predicateId.toString(16).padStart(64, "0")}`), d = u.map((y) => `0x${y.objectId.toString(16).padStart(64, "0")}`), p = u.map(() => RT), f = await r.writeContract({
        address: pl,
        abi: ju,
        functionName: "createTriples",
        // Changé de "batchCreateTriple" à "createTriples"
        args: [c, h, d, p],
        // Ajouté le paramètre assets
        value: RT * BigInt(u.length),
        // Valeur pour chaque triple
        gas: 5000000n
      });
      let m;
      return r.waitForTransactionReceipt ? m = await r.waitForTransactionReceipt({ hash: f }) : f.wait ? m = await f.wait() : await new Promise((y) => setTimeout(y, 3e3)), {
        hash: typeof f == "string" ? f : f.hash,
        receipt: m
      };
    } catch (c) {
      throw console.error("Error batch creating triples:", c), c;
    }
  };
  return {
    checkTripleExists: a,
    batchCreateTriple: o,
    createPlayerTriples: async (u) => {
      const c = Object.entries(s).filter(([h, d]) => "objectId" in d && d.objectId !== null).map(([h, d]) => ({
        subjectId: u,
        predicateId: BigInt(d.predicateId),
        objectId: BigInt(d.objectId)
      }));
      return o(c);
    }
  };
}, bk = (r, e, i, n) => {
  const { PLAYER_TRIPLE_TYPES: s } = i, { createAtom: a } = yk({ walletConnected: r, walletAddress: e, publicClient: n }), { batchCreateTriple: o } = vk({ walletConnected: r, walletAddress: e, publicClient: n, constants: i });
  return {
    createPlayer: async (u) => {
      try {
        const c = await a({
          name: u.pseudo,
          description: u.userId,
          image: u.image
        }), h = c.atomId;
        await new Promise((d) => setTimeout(d, 2e3));
        try {
          const d = Object.entries(s).filter(([f, m]) => "objectId" in m && m.objectId !== null).map(([f, m]) => ({
            subjectId: h,
            predicateId: BigInt(m.predicateId),
            objectId: BigInt(m.objectId)
          }));
          u.guildId && d.push({
            subjectId: h,
            predicateId: BigInt(s.PLAYER_GUILD.predicateId),
            objectId: u.guildId
          });
          const p = await o(d);
          return {
            atomId: h,
            ipfsHash: c.ipfsHash,
            tripleCreated: !0,
            transactionHash: p.hash
          };
        } catch (d) {
          return console.error("Erreur lors de la création des triples:", d), {
            atomId: h,
            ipfsHash: c.ipfsHash,
            tripleCreated: !1,
            transactionHash: void 0
          };
        }
      } catch (c) {
        throw console.error("Erreur lors de la création du joueur:", c), c;
      }
    }
  };
}, fC = ({ walletConnected: r, publicClient: e }) => {
  const [i, n] = ye(null), s = [13579], a = Number(UD);
  return Ft(() => {
    (async () => {
      if (!(!r || !e))
        try {
          const l = await e.getChainId();
          n(Number(l));
        } catch (l) {
          console.error("Error checking network:", l), n(null);
        }
    })();
  }, [r, e]), {
    isCorrectNetwork: i !== null && s.includes(i),
    currentChainId: i,
    targetChainId: a,
    allowedChainIds: s
  };
}, mC = ({
  currentChainId: r,
  targetChainId: e,
  allowedChainIds: i = [13579]
}) => {
  const n = (s) => {
    switch (s) {
      case 13579:
        return "Intuition Testnet";
      default:
        return `Chain ID: ${s}`;
    }
  };
  return /* @__PURE__ */ I.jsxs("div", { style: {
    padding: "15px",
    backgroundColor: "#2e2e40",
    borderRadius: "8px",
    margin: "10px 0",
    textAlign: "center"
  }, children: [
    /* @__PURE__ */ I.jsx("p", { style: { color: "#ff4444", marginBottom: "10px" }, children: "You are not on the correct network" }),
    /* @__PURE__ */ I.jsxs("p", { style: { color: "#aaa", fontSize: "0.9em", marginBottom: "10px" }, children: [
      "Current network: ",
      r ? n(r) : "Not connected",
      /* @__PURE__ */ I.jsx("br", {}),
      "Required network: ",
      n(13579)
    ] }),
    /* @__PURE__ */ I.jsx("p", { style: { color: "#fff", fontSize: "0.9em" }, children: "Please switch to Intuition Testnet (13579) in your wallet to continue" })
  ] });
}, gC = ({
  isOpen: r,
  onClose: e,
  walletConnected: i,
  walletAddress: n,
  wagmiConfig: s,
  walletHooks: a,
  constants: o
}) => {
  const [l, u] = ye({
    pseudo: "",
    userId: "",
    image: "",
    guildId: ""
  }), [c, h] = ye(!1), [d, p] = ye(!1), [f, m] = ye(!1), [y, v] = ye(null), g = s == null ? void 0 : s.publicClient, [_, x] = ye(!1), b = Gi(null), [T, E] = ye(1), [M, C] = ye(!1), [S, w] = ye(!1), [R, O] = ye(!1), { createPlayer: P } = bk(
    i,
    n || "",
    o,
    // Passer les constantes personnalisées !
    g
  ), { isCorrectNetwork: A, currentChainId: D, targetChainId: L } = fC({
    walletConnected: i,
    publicClient: s == null ? void 0 : s.publicClient
  });
  Ft(() => {
    (async () => {
      if (!(!n || !g))
        try {
          const W = CD("AtomCreated(address,address,bytes,uint256)"), K = (await (await fetch("https://testnet.rpc.intuition.systems", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              jsonrpc: "2.0",
              method: "eth_getLogs",
              params: [{
                address: pl,
                topics: [
                  W,
                  n
                ],
                fromBlock: "0x0",
                toBlock: "latest"
              }],
              id: 1
            })
          })).json()).result || [];
          h(K.length > 0);
        } catch (W) {
          console.error("Error checking atom ownership:", W), h(!1);
        }
    })();
  }, [n, g]);
  const H = (B) => {
    const { name: W, value: G } = B.target;
    u((z) => ({
      ...z,
      [W]: G
    }));
  }, V = (B) => {
    const { name: W, value: G } = B.target;
    u((z) => ({
      ...z,
      [W]: G
    }));
  }, X = async (B) => {
    if (!B.target.files || B.target.files.length === 0)
      return;
    const W = B.target.files[0];
    try {
      x(!0);
      const G = await dC(W);
      u((z) => ({
        ...z,
        image: G
      })), x(!1);
    } catch (G) {
      console.error("Error uploading image:", G), alert("Error uploading image. Please try again."), x(!1);
    }
  }, F = async () => {
    if (!n || !i) {
      alert("Please connect your wallet first");
      return;
    }
    if (c) {
      alert("You already have an atom!");
      return;
    }
    if (!l.pseudo) {
      alert("Please fill in all fields");
      return;
    }
    try {
      p(!0), C(!0), E(1);
      const B = await P({
        pseudo: l.pseudo,
        userId: l.userId,
        image: l.image || void 0,
        guildId: l.guildId ? BigInt(l.guildId) : void 0
      });
      v(B.atomId.toString()), C(!1), E(2), w(!0), await new Promise((W) => setTimeout(W, 1500)), w(!1), O(B.tripleCreated), E(3), m(!0), p(!1), setTimeout(() => {
        e(), window.location.reload();
      }, 3e3);
    } catch (B) {
      console.error("Error creating player:", B), alert("Error creating player. Please try again."), p(!1), C(!1), w(!1);
    }
  };
  return r ? /* @__PURE__ */ I.jsx(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(0, 0, 0, 0.7)",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        zIndex: 1e3
      },
      children: /* @__PURE__ */ I.jsxs(
        "div",
        {
          style: {
            backgroundColor: "#101020",
            color: "#fff",
            padding: "30px",
            borderRadius: "10px",
            maxWidth: "760px",
            width: "90%",
            position: "relative",
            border: "1px solid #FFD32A"
          },
          children: [
            /* @__PURE__ */ I.jsx(
              "div",
              {
                style: {
                  position: "absolute",
                  top: "40px",
                  right: "10px",
                  fontSize: "10px",
                  color: "#666",
                  textAlign: "left",
                  backgroundColor: "rgba(0,0,0,0.3)",
                  padding: "5px",
                  borderRadius: "3px",
                  maxWidth: "200px",
                  overflow: "hidden"
                },
                children: /* @__PURE__ */ I.jsxs("div", { children: [
                  "Wallet:",
                  " ",
                  n ? n.slice(0, 6) + "..." + n.slice(-4) : "Not connected"
                ] })
              }
            ),
            /* @__PURE__ */ I.jsx(
              "button",
              {
                onClick: e,
                style: {
                  position: "absolute",
                  top: "10px",
                  right: "10px",
                  backgroundColor: "transparent",
                  border: "none",
                  fontSize: "20px",
                  color: "#666",
                  cursor: "pointer"
                },
                children: "×"
              }
            ),
            /* @__PURE__ */ I.jsx(
              "img",
              {
                src: xA,
                alt: "Intuition Logo",
                style: { width: "100px", marginBottom: "10px" }
              }
            ),
            /* @__PURE__ */ I.jsx(
              "h2",
              {
                style: {
                  fontSize: "1.5em",
                  margin: "0 0 20px 0",
                  textAlign: "center"
                },
                children: "Create Your Player"
              }
            ),
            A ? /* @__PURE__ */ I.jsx(
              mk,
              {
                step: T,
                isCreatingAtom: M,
                isCreatingTriples: S,
                creationSuccess: f,
                atomId: y,
                tripleCreated: R,
                walletAddress: n,
                hasExistingAtom: c,
                formData: l,
                handleInputChange: H,
                handleSelectChange: V,
                handleFileUpload: X,
                handleSubmit: F,
                isLoading: d,
                isUploading: _,
                fileInputRef: b,
                constants: o
              }
            ) : /* @__PURE__ */ I.jsx(
              mC,
              {
                currentChainId: D,
                targetChainId: L
              }
            )
          ]
        }
      )
    }
  ) : null;
};
var xk = Object.defineProperty, _k = (r, e, i) => e in r ? xk(r, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : r[e] = i, qh = (r, e, i) => _k(r, typeof e != "symbol" ? e + "" : e, i);
function f_(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Uv = { exports: {} }, th = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qT;
function Tk() {
  if (qT) return th;
  qT = 1;
  var r = si, e = Symbol.for("react.element"), i = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(l, u, c) {
    var h, d = {}, p = null, f = null;
    c !== void 0 && (p = "" + c), u.key !== void 0 && (p = "" + u.key), u.ref !== void 0 && (f = u.ref);
    for (h in u) n.call(u, h) && !a.hasOwnProperty(h) && (d[h] = u[h]);
    if (l && l.defaultProps) for (h in u = l.defaultProps, u) d[h] === void 0 && (d[h] = u[h]);
    return { $$typeof: e, type: l, key: p, ref: f, props: d, _owner: s.current };
  }
  return th.Fragment = i, th.jsx = o, th.jsxs = o, th;
}
var up = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XT;
function wk() {
  return XT || (XT = 1, process.env.NODE_ENV !== "production" && function() {
    var r = si, e = Symbol.for("react.element"), i = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), m = Symbol.iterator, y = "@@iterator";
    function v(N) {
      if (N === null || typeof N != "object")
        return null;
      var J = m && N[m] || N[y];
      return typeof J == "function" ? J : null;
    }
    var g = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(N) {
      {
        for (var J = arguments.length, ce = new Array(J > 1 ? J - 1 : 0), Ne = 1; Ne < J; Ne++)
          ce[Ne - 1] = arguments[Ne];
        x("error", N, ce);
      }
    }
    function x(N, J, ce) {
      {
        var Ne = g.ReactDebugCurrentFrame, $e = Ne.getStackAddendum();
        $e !== "" && (J += "%s", ce = ce.concat([$e]));
        var at = ce.map(function(qe) {
          return String(qe);
        });
        at.unshift("Warning: " + J), Function.prototype.apply.call(console[N], console, at);
      }
    }
    var b = !1, T = !1, E = !1, M = !1, C = !1, S;
    S = Symbol.for("react.module.reference");
    function w(N) {
      return !!(typeof N == "string" || typeof N == "function" || N === n || N === a || C || N === s || N === c || N === h || M || N === f || b || T || E || typeof N == "object" && N !== null && (N.$$typeof === p || N.$$typeof === d || N.$$typeof === o || N.$$typeof === l || N.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      N.$$typeof === S || N.getModuleId !== void 0));
    }
    function R(N, J, ce) {
      var Ne = N.displayName;
      if (Ne)
        return Ne;
      var $e = J.displayName || J.name || "";
      return $e !== "" ? ce + "(" + $e + ")" : ce;
    }
    function O(N) {
      return N.displayName || "Context";
    }
    function P(N) {
      if (N == null)
        return null;
      if (typeof N.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof N == "function")
        return N.displayName || N.name || null;
      if (typeof N == "string")
        return N;
      switch (N) {
        case n:
          return "Fragment";
        case i:
          return "Portal";
        case a:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof N == "object")
        switch (N.$$typeof) {
          case l:
            var J = N;
            return O(J) + ".Consumer";
          case o:
            var ce = N;
            return O(ce._context) + ".Provider";
          case u:
            return R(N, N.render, "ForwardRef");
          case d:
            var Ne = N.displayName || null;
            return Ne !== null ? Ne : P(N.type) || "Memo";
          case p: {
            var $e = N, at = $e._payload, qe = $e._init;
            try {
              return P(qe(at));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var A = Object.assign, D = 0, L, H, V, X, F, B, W;
    function G() {
    }
    G.__reactDisabledLog = !0;
    function z() {
      {
        if (D === 0) {
          L = console.log, H = console.info, V = console.warn, X = console.error, F = console.group, B = console.groupCollapsed, W = console.groupEnd;
          var N = {
            configurable: !0,
            enumerable: !0,
            value: G,
            writable: !0
          };
          Object.defineProperties(console, {
            info: N,
            log: N,
            warn: N,
            error: N,
            group: N,
            groupCollapsed: N,
            groupEnd: N
          });
        }
        D++;
      }
    }
    function K() {
      {
        if (D--, D === 0) {
          var N = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: A({}, N, {
              value: L
            }),
            info: A({}, N, {
              value: H
            }),
            warn: A({}, N, {
              value: V
            }),
            error: A({}, N, {
              value: X
            }),
            group: A({}, N, {
              value: F
            }),
            groupCollapsed: A({}, N, {
              value: B
            }),
            groupEnd: A({}, N, {
              value: W
            })
          });
        }
        D < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ne = g.ReactCurrentDispatcher, oe;
    function pe(N, J, ce) {
      {
        if (oe === void 0)
          try {
            throw Error();
          } catch ($e) {
            var Ne = $e.stack.trim().match(/\n( *(at )?)/);
            oe = Ne && Ne[1] || "";
          }
        return `
` + oe + N;
      }
    }
    var xe = !1, Re;
    {
      var nt = typeof WeakMap == "function" ? WeakMap : Map;
      Re = new nt();
    }
    function fe(N, J) {
      if (!N || xe)
        return "";
      {
        var ce = Re.get(N);
        if (ce !== void 0)
          return ce;
      }
      var Ne;
      xe = !0;
      var $e = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var at;
      at = ne.current, ne.current = null, z();
      try {
        if (J) {
          var qe = function() {
            throw Error();
          };
          if (Object.defineProperty(qe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(qe, []);
            } catch (Pe) {
              Ne = Pe;
            }
            Reflect.construct(N, [], qe);
          } else {
            try {
              qe.call();
            } catch (Pe) {
              Ne = Pe;
            }
            N.call(qe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Pe) {
            Ne = Pe;
          }
          N();
        }
      } catch (Pe) {
        if (Pe && Ne && typeof Pe.stack == "string") {
          for (var He = Pe.stack.split(`
`), U = Ne.stack.split(`
`), q = He.length - 1, te = U.length - 1; q >= 1 && te >= 0 && He[q] !== U[te]; )
            te--;
          for (; q >= 1 && te >= 0; q--, te--)
            if (He[q] !== U[te]) {
              if (q !== 1 || te !== 1)
                do
                  if (q--, te--, te < 0 || He[q] !== U[te]) {
                    var ae = `
` + He[q].replace(" at new ", " at ");
                    return N.displayName && ae.includes("<anonymous>") && (ae = ae.replace("<anonymous>", N.displayName)), typeof N == "function" && Re.set(N, ae), ae;
                  }
                while (q >= 1 && te >= 0);
              break;
            }
        }
      } finally {
        xe = !1, ne.current = at, K(), Error.prepareStackTrace = $e;
      }
      var $ = N ? N.displayName || N.name : "", Me = $ ? pe($) : "";
      return typeof N == "function" && Re.set(N, Me), Me;
    }
    function gt(N, J, ce) {
      return fe(N, !1);
    }
    function Q(N) {
      var J = N.prototype;
      return !!(J && J.isReactComponent);
    }
    function Gt(N, J, ce) {
      if (N == null)
        return "";
      if (typeof N == "function")
        return fe(N, Q(N));
      if (typeof N == "string")
        return pe(N);
      switch (N) {
        case c:
          return pe("Suspense");
        case h:
          return pe("SuspenseList");
      }
      if (typeof N == "object")
        switch (N.$$typeof) {
          case u:
            return gt(N.render);
          case d:
            return Gt(N.type, J, ce);
          case p: {
            var Ne = N, $e = Ne._payload, at = Ne._init;
            try {
              return Gt(at($e), J, ce);
            } catch {
            }
          }
        }
      return "";
    }
    var Qe = Object.prototype.hasOwnProperty, bt = {}, Be = g.ReactDebugCurrentFrame;
    function At(N) {
      if (N) {
        var J = N._owner, ce = Gt(N.type, N._source, J ? J.type : null);
        Be.setExtraStackFrame(ce);
      } else
        Be.setExtraStackFrame(null);
    }
    function st(N, J, ce, Ne, $e) {
      {
        var at = Function.call.bind(Qe);
        for (var qe in N)
          if (at(N, qe)) {
            var He = void 0;
            try {
              if (typeof N[qe] != "function") {
                var U = Error((Ne || "React class") + ": " + ce + " type `" + qe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof N[qe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw U.name = "Invariant Violation", U;
              }
              He = N[qe](J, qe, Ne, ce, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (q) {
              He = q;
            }
            He && !(He instanceof Error) && (At($e), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ne || "React class", ce, qe, typeof He), At(null)), He instanceof Error && !(He.message in bt) && (bt[He.message] = !0, At($e), _("Failed %s type: %s", ce, He.message), At(null));
          }
      }
    }
    var j = Array.isArray;
    function k(N) {
      return j(N);
    }
    function le(N) {
      {
        var J = typeof Symbol == "function" && Symbol.toStringTag, ce = J && N[Symbol.toStringTag] || N.constructor.name || "Object";
        return ce;
      }
    }
    function we(N) {
      try {
        return Ce(N), !1;
      } catch {
        return !0;
      }
    }
    function Ce(N) {
      return "" + N;
    }
    function Te(N) {
      if (we(N))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", le(N)), Ce(N);
    }
    var et = g.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Xe, Pt;
    function Ie(N) {
      if (Qe.call(N, "ref")) {
        var J = Object.getOwnPropertyDescriptor(N, "ref").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return N.ref !== void 0;
    }
    function Ye(N) {
      if (Qe.call(N, "key")) {
        var J = Object.getOwnPropertyDescriptor(N, "key").get;
        if (J && J.isReactWarning)
          return !1;
      }
      return N.key !== void 0;
    }
    function ut(N, J) {
      typeof N.ref == "string" && et.current;
    }
    function ft(N, J) {
      {
        var ce = function() {
          Xe || (Xe = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(N, "key", {
          get: ce,
          configurable: !0
        });
      }
    }
    function Ke(N, J) {
      {
        var ce = function() {
          Pt || (Pt = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", J));
        };
        ce.isReactWarning = !0, Object.defineProperty(N, "ref", {
          get: ce,
          configurable: !0
        });
      }
    }
    var Ot = function(N, J, ce, Ne, $e, at, qe) {
      var He = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: N,
        key: J,
        ref: ce,
        props: qe,
        // Record the component responsible for creating this element.
        _owner: at
      };
      return He._store = {}, Object.defineProperty(He._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(He, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ne
      }), Object.defineProperty(He, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: $e
      }), Object.freeze && (Object.freeze(He.props), Object.freeze(He)), He;
    };
    function xt(N, J, ce, Ne, $e) {
      {
        var at, qe = {}, He = null, U = null;
        ce !== void 0 && (Te(ce), He = "" + ce), Ye(J) && (Te(J.key), He = "" + J.key), Ie(J) && (U = J.ref, ut(J));
        for (at in J)
          Qe.call(J, at) && !ze.hasOwnProperty(at) && (qe[at] = J[at]);
        if (N && N.defaultProps) {
          var q = N.defaultProps;
          for (at in q)
            qe[at] === void 0 && (qe[at] = q[at]);
        }
        if (He || U) {
          var te = typeof N == "function" ? N.displayName || N.name || "Unknown" : N;
          He && ft(qe, te), U && Ke(qe, te);
        }
        return Ot(N, He, U, $e, Ne, et.current, qe);
      }
    }
    var jt = g.ReactCurrentOwner, ee = g.ReactDebugCurrentFrame;
    function Le(N) {
      if (N) {
        var J = N._owner, ce = Gt(N.type, N._source, J ? J.type : null);
        ee.setExtraStackFrame(ce);
      } else
        ee.setExtraStackFrame(null);
    }
    var de;
    de = !1;
    function Ee(N) {
      return typeof N == "object" && N !== null && N.$$typeof === e;
    }
    function je() {
      {
        if (jt.current) {
          var N = P(jt.current.type);
          if (N)
            return `

Check the render method of \`` + N + "`.";
        }
        return "";
      }
    }
    function Ue(N) {
      return "";
    }
    var Ct = {};
    function ni(N) {
      {
        var J = je();
        if (!J) {
          var ce = typeof N == "string" ? N : N.displayName || N.name;
          ce && (J = `

Check the top-level render call using <` + ce + ">.");
        }
        return J;
      }
    }
    function xi(N, J) {
      {
        if (!N._store || N._store.validated || N.key != null)
          return;
        N._store.validated = !0;
        var ce = ni(J);
        if (Ct[ce])
          return;
        Ct[ce] = !0;
        var Ne = "";
        N && N._owner && N._owner !== jt.current && (Ne = " It was passed a child from " + P(N._owner.type) + "."), Le(N), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ce, Ne), Le(null);
      }
    }
    function Bt(N, J) {
      {
        if (typeof N != "object")
          return;
        if (k(N))
          for (var ce = 0; ce < N.length; ce++) {
            var Ne = N[ce];
            Ee(Ne) && xi(Ne, J);
          }
        else if (Ee(N))
          N._store && (N._store.validated = !0);
        else if (N) {
          var $e = v(N);
          if (typeof $e == "function" && $e !== N.entries)
            for (var at = $e.call(N), qe; !(qe = at.next()).done; )
              Ee(qe.value) && xi(qe.value, J);
        }
      }
    }
    function vr(N) {
      {
        var J = N.type;
        if (J == null || typeof J == "string")
          return;
        var ce;
        if (typeof J == "function")
          ce = J.propTypes;
        else if (typeof J == "object" && (J.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        J.$$typeof === d))
          ce = J.propTypes;
        else
          return;
        if (ce) {
          var Ne = P(J);
          st(ce, N.props, "prop", Ne, N);
        } else if (J.PropTypes !== void 0 && !de) {
          de = !0;
          var $e = P(J);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", $e || "Unknown");
        }
        typeof J.getDefaultProps == "function" && !J.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Yr(N) {
      {
        for (var J = Object.keys(N.props), ce = 0; ce < J.length; ce++) {
          var Ne = J[ce];
          if (Ne !== "children" && Ne !== "key") {
            Le(N), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ne), Le(null);
            break;
          }
        }
        N.ref !== null && (Le(N), _("Invalid attribute `ref` supplied to `React.Fragment`."), Le(null));
      }
    }
    var Aa = {};
    function Ca(N, J, ce, Ne, $e, at) {
      {
        var qe = w(N);
        if (!qe) {
          var He = "";
          (N === void 0 || typeof N == "object" && N !== null && Object.keys(N).length === 0) && (He += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var U = Ue();
          U ? He += U : He += je();
          var q;
          N === null ? q = "null" : k(N) ? q = "array" : N !== void 0 && N.$$typeof === e ? (q = "<" + (P(N.type) || "Unknown") + " />", He = " Did you accidentally export a JSX literal instead of a component?") : q = typeof N, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", q, He);
        }
        var te = xt(N, J, ce, $e, at);
        if (te == null)
          return te;
        if (qe) {
          var ae = J.children;
          if (ae !== void 0)
            if (Ne)
              if (k(ae)) {
                for (var $ = 0; $ < ae.length; $++)
                  Bt(ae[$], N);
                Object.freeze && Object.freeze(ae);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Bt(ae, N);
        }
        if (Qe.call(J, "key")) {
          var Me = P(N), Pe = Object.keys(J).filter(function(yt) {
            return yt !== "key";
          }), Ze = Pe.length > 0 ? "{key: someKey, " + Pe.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Aa[Me + Ze]) {
            var it = Pe.length > 0 ? "{" + Pe.join(": ..., ") + ": ...}" : "{}";
            _(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ze, Me, it, Me), Aa[Me + Ze] = !0;
          }
        }
        return N === n ? Yr(te) : vr(te), te;
      }
    }
    function Mn(N, J, ce) {
      return Ca(N, J, ce, !0);
    }
    function Eo(N, J, ce) {
      return Ca(N, J, ce, !1);
    }
    var kl = Eo, Ul = Mn;
    up.Fragment = n, up.jsx = kl, up.jsxs = Ul;
  }()), up;
}
process.env.NODE_ENV === "production" ? Uv.exports = Tk() : Uv.exports = wk();
var se = Uv.exports;
const Si = {
  SUBJECT: "#FFB300",
  // Jaune/orangé accessible
  PREDICATE: "#1976D2",
  // Bleu profond accessible
  OBJECT: "#43A047"
  // Vert foncé accessible
}, Nu = (r) => {
  switch (r) {
    case "subject":
      return Si.SUBJECT;
    case "predicate":
      return Si.PREDICATE;
    case "object":
      return Si.OBJECT;
    default:
      return "#444";
  }
}, YT = () => /* @__PURE__ */ se.jsxs(
  "div",
  {
    style: {
      position: "absolute",
      bottom: 5,
      right: 5,
      zIndex: 1e3
    },
    children: [
      /* @__PURE__ */ se.jsx(
        "h4",
        {
          style: {
            margin: "0 0 12px 0",
            fontSize: "18px",
            color: "#ffd32a",
            fontWeight: "bold",
            letterSpacing: "0.5px"
          },
          children: "Graph Legend"
        }
      ),
      /* @__PURE__ */ se.jsxs(
        "ul",
        {
          style: {
            listStyle: "none",
            margin: 0,
            display: "flex",
            flexDirection: "column",
            gap: "12px",
            background: "rgba(255, 255, 255, 0.05)",
            borderRadius: "10px",
            border: "2px solid rgba(255, 255, 255, 0.1)",
            padding: "16px 24px",
            boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)"
          },
          children: [
            /* @__PURE__ */ se.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ se.jsx(
                    "span",
                    {
                      style: {
                        width: "20px",
                        height: "20px",
                        backgroundColor: Si.SUBJECT,
                        borderRadius: "50%",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ se.jsx("span", { style: { fontSize: "15px" }, children: "Subject" })
                ]
              }
            ),
            /* @__PURE__ */ se.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ se.jsx(
                    "span",
                    {
                      style: {
                        width: "20px",
                        height: "20px",
                        backgroundColor: Si.OBJECT,
                        borderRadius: "4px",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ se.jsx("span", { style: { fontSize: "15px" }, children: "Object" })
                ]
              }
            ),
            /* @__PURE__ */ se.jsxs(
              "li",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "12px",
                  color: "#fff"
                },
                children: [
                  /* @__PURE__ */ se.jsx(
                    "span",
                    {
                      style: {
                        width: "20px",
                        height: "8px",
                        backgroundColor: Si.PREDICATE,
                        borderRadius: "4px",
                        display: "inline-block",
                        boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
                      }
                    }
                  ),
                  /* @__PURE__ */ se.jsx("span", { style: { fontSize: "15px" }, children: "Predicate" })
                ]
              }
            )
          ]
        }
      )
    ]
  }
);
class Vu extends Error {
  constructor(e, i) {
    const n = `${Vu.extractMessage(e)}: ${JSON.stringify({
      response: e,
      request: i
    })}`;
    super(n), qh(this, "response"), qh(this, "request"), Object.setPrototypeOf(this, Vu.prototype), this.response = e, this.request = i, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, Vu);
  }
  static extractMessage(e) {
    var i, n;
    return ((n = (i = e.errors) == null ? void 0 : i[0]) == null ? void 0 : n.message) ?? `GraphQL Error (Code: ${String(e.status)})`;
  }
}
const KT = (r) => r.toUpperCase(), oy = (r) => typeof r == "function" ? r() : r, yC = (r, e) => r.map((i, n) => [i, e[n]]), Bl = (r) => {
  let e = {};
  return r instanceof Headers ? e = Sk(r) : Array.isArray(r) ? r.forEach(([i, n]) => {
    i && n !== void 0 && (e[i] = n);
  }) : r && (e = r), e;
}, Sk = (r) => {
  const e = {};
  return r.forEach((i, n) => {
    e[n] = i;
  }), e;
}, Ek = (r) => {
  try {
    const e = r();
    return Mk(e) ? e.catch((i) => ZT(i)) : e;
  } catch (e) {
    return ZT(e);
  }
}, ZT = (r) => r instanceof Error ? r : new Error(String(r)), Mk = (r) => typeof r == "object" && r !== null && "then" in r && typeof r.then == "function" && "catch" in r && typeof r.catch == "function" && "finally" in r && typeof r.finally == "function", m_ = (r) => {
  throw new Error(`Unhandled case: ${String(r)}`);
}, jf = (r) => typeof r == "object" && r !== null && !Array.isArray(r), Ak = (r, e) => r.documents ? r : {
  documents: r,
  requestHeaders: e,
  signal: void 0
}, Ck = (r, e, i) => r.query ? r : {
  query: r,
  variables: e,
  requestHeaders: i,
  signal: void 0
};
function Vf(r, e) {
  throw new Error(e);
}
function Rk(r) {
  return typeof r == "object" && r !== null;
}
function Nk(r, e) {
  throw new Error(
    "Unexpected invariant triggered."
  );
}
const Pk = /\r\n|[\n\r]/g;
function Fv(r, e) {
  let i = 0, n = 1;
  for (const s of r.body.matchAll(Pk)) {
    if (typeof s.index == "number" || Nk(), s.index >= e)
      break;
    i = s.index + s[0].length, n += 1;
  }
  return {
    line: n,
    column: e + 1 - i
  };
}
function Ik(r) {
  return vC(
    r.source,
    Fv(r.source, r.start)
  );
}
function vC(r, e) {
  const i = r.locationOffset.column - 1, n = "".padStart(i) + r.body, s = e.line - 1, a = r.locationOffset.line - 1, o = e.line + a, l = e.line === 1 ? i : 0, u = e.column + l, c = `${r.name}:${o}:${u}
`, h = n.split(/\r\n|[\n\r]/g), d = h[s];
  if (d.length > 120) {
    const p = Math.floor(u / 80), f = u % 80, m = [];
    for (let y = 0; y < d.length; y += 80)
      m.push(d.slice(y, y + 80));
    return c + QT([
      [`${o} |`, m[0]],
      ...m.slice(1, p + 1).map((y) => ["|", y]),
      ["|", "^".padStart(f)],
      ["|", m[p + 1]]
    ]);
  }
  return c + QT([
    // Lines specified like this: ["prefix", "string"],
    [`${o - 1} |`, h[s - 1]],
    [`${o} |`, d],
    ["|", "^".padStart(u)],
    [`${o + 1} |`, h[s + 1]]
  ]);
}
function QT(r) {
  const e = r.filter(([n, s]) => s !== void 0), i = Math.max(...e.map(([n]) => n.length));
  return e.map(([n, s]) => n.padStart(i) + (s ? " " + s : "")).join(`
`);
}
function Ok(r) {
  const e = r[0];
  return e == null || "kind" in e || "length" in e ? {
    nodes: e,
    source: r[1],
    positions: r[2],
    path: r[3],
    originalError: r[4],
    extensions: r[5]
  } : e;
}
class g_ extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(e, ...i) {
    var n, s, a;
    const { nodes: o, source: l, positions: u, path: c, originalError: h, extensions: d } = Ok(i);
    super(e), this.name = "GraphQLError", this.path = c ?? void 0, this.originalError = h ?? void 0, this.nodes = $T(
      Array.isArray(o) ? o : o ? [o] : void 0
    );
    const p = $T(
      (n = this.nodes) === null || n === void 0 ? void 0 : n.map((m) => m.loc).filter((m) => m != null)
    );
    this.source = l ?? (p == null || (s = p[0]) === null || s === void 0 ? void 0 : s.source), this.positions = u ?? (p == null ? void 0 : p.map((m) => m.start)), this.locations = u && l ? u.map((m) => Fv(l, m)) : p == null ? void 0 : p.map((m) => Fv(m.source, m.start));
    const f = Rk(
      h == null ? void 0 : h.extensions
    ) ? h == null ? void 0 : h.extensions : void 0;
    this.extensions = (a = d ?? f) !== null && a !== void 0 ? a : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), h != null && h.stack ? Object.defineProperty(this, "stack", {
      value: h.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, g_) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let e = this.message;
    if (this.nodes)
      for (const i of this.nodes)
        i.loc && (e += `

` + Ik(i.loc));
    else if (this.source && this.locations)
      for (const i of this.locations)
        e += `

` + vC(this.source, i);
    return e;
  }
  toJSON() {
    const e = {
      message: this.message
    };
    return this.locations != null && (e.locations = this.locations), this.path != null && (e.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (e.extensions = this.extensions), e;
  }
}
function $T(r) {
  return r === void 0 || r.length === 0 ? void 0 : r;
}
function Ki(r, e, i) {
  return new g_(`Syntax Error: ${i}`, {
    source: r,
    positions: [e]
  });
}
class Dk {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(e, i, n) {
    this.start = e.start, this.end = i.end, this.startToken = e, this.endToken = i, this.source = n;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class bC {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(e, i, n, s, a, o) {
    this.kind = e, this.start = i, this.end = n, this.line = s, this.column = a, this.value = o, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const xC = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, Lk = new Set(Object.keys(xC));
function JT(r) {
  const e = r == null ? void 0 : r.kind;
  return typeof e == "string" && Lk.has(e);
}
var tl;
(function(r) {
  r.QUERY = "query", r.MUTATION = "mutation", r.SUBSCRIPTION = "subscription";
})(tl || (tl = {}));
var Bv;
(function(r) {
  r.QUERY = "QUERY", r.MUTATION = "MUTATION", r.SUBSCRIPTION = "SUBSCRIPTION", r.FIELD = "FIELD", r.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", r.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", r.INLINE_FRAGMENT = "INLINE_FRAGMENT", r.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", r.SCHEMA = "SCHEMA", r.SCALAR = "SCALAR", r.OBJECT = "OBJECT", r.FIELD_DEFINITION = "FIELD_DEFINITION", r.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", r.INTERFACE = "INTERFACE", r.UNION = "UNION", r.ENUM = "ENUM", r.ENUM_VALUE = "ENUM_VALUE", r.INPUT_OBJECT = "INPUT_OBJECT", r.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(Bv || (Bv = {}));
var pt;
(function(r) {
  r.NAME = "Name", r.DOCUMENT = "Document", r.OPERATION_DEFINITION = "OperationDefinition", r.VARIABLE_DEFINITION = "VariableDefinition", r.SELECTION_SET = "SelectionSet", r.FIELD = "Field", r.ARGUMENT = "Argument", r.FRAGMENT_SPREAD = "FragmentSpread", r.INLINE_FRAGMENT = "InlineFragment", r.FRAGMENT_DEFINITION = "FragmentDefinition", r.VARIABLE = "Variable", r.INT = "IntValue", r.FLOAT = "FloatValue", r.STRING = "StringValue", r.BOOLEAN = "BooleanValue", r.NULL = "NullValue", r.ENUM = "EnumValue", r.LIST = "ListValue", r.OBJECT = "ObjectValue", r.OBJECT_FIELD = "ObjectField", r.DIRECTIVE = "Directive", r.NAMED_TYPE = "NamedType", r.LIST_TYPE = "ListType", r.NON_NULL_TYPE = "NonNullType", r.SCHEMA_DEFINITION = "SchemaDefinition", r.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", r.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", r.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", r.FIELD_DEFINITION = "FieldDefinition", r.INPUT_VALUE_DEFINITION = "InputValueDefinition", r.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", r.UNION_TYPE_DEFINITION = "UnionTypeDefinition", r.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", r.ENUM_VALUE_DEFINITION = "EnumValueDefinition", r.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", r.DIRECTIVE_DEFINITION = "DirectiveDefinition", r.SCHEMA_EXTENSION = "SchemaExtension", r.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", r.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", r.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", r.UNION_TYPE_EXTENSION = "UnionTypeExtension", r.ENUM_TYPE_EXTENSION = "EnumTypeExtension", r.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(pt || (pt = {}));
function zv(r) {
  return r === 9 || r === 32;
}
function ld(r) {
  return r >= 48 && r <= 57;
}
function _C(r) {
  return r >= 97 && r <= 122 || // A-Z
  r >= 65 && r <= 90;
}
function TC(r) {
  return _C(r) || r === 95;
}
function kk(r) {
  return _C(r) || ld(r) || r === 95;
}
function Uk(r) {
  var e;
  let i = Number.MAX_SAFE_INTEGER, n = null, s = -1;
  for (let o = 0; o < r.length; ++o) {
    var a;
    const l = r[o], u = Fk(l);
    u !== l.length && (n = (a = n) !== null && a !== void 0 ? a : o, s = o, o !== 0 && u < i && (i = u));
  }
  return r.map((o, l) => l === 0 ? o : o.slice(i)).slice(
    (e = n) !== null && e !== void 0 ? e : 0,
    s + 1
  );
}
function Fk(r) {
  let e = 0;
  for (; e < r.length && zv(r.charCodeAt(e)); )
    ++e;
  return e;
}
function Bk(r, e) {
  const i = r.replace(/"""/g, '\\"""'), n = i.split(/\r\n|[\n\r]/g), s = n.length === 1, a = n.length > 1 && n.slice(1).every((f) => f.length === 0 || zv(f.charCodeAt(0))), o = i.endsWith('\\"""'), l = r.endsWith('"') && !o, u = r.endsWith("\\"), c = l || u, h = (
    // add leading and trailing new lines only if it improves readability
    !s || r.length > 70 || c || a || o
  );
  let d = "";
  const p = s && zv(r.charCodeAt(0));
  return (h && !p || a) && (d += `
`), d += i, (h || c) && (d += `
`), '"""' + d + '"""';
}
var Se;
(function(r) {
  r.SOF = "<SOF>", r.EOF = "<EOF>", r.BANG = "!", r.DOLLAR = "$", r.AMP = "&", r.PAREN_L = "(", r.PAREN_R = ")", r.SPREAD = "...", r.COLON = ":", r.EQUALS = "=", r.AT = "@", r.BRACKET_L = "[", r.BRACKET_R = "]", r.BRACE_L = "{", r.PIPE = "|", r.BRACE_R = "}", r.NAME = "Name", r.INT = "Int", r.FLOAT = "Float", r.STRING = "String", r.BLOCK_STRING = "BlockString", r.COMMENT = "Comment";
})(Se || (Se = {}));
class zk {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(e) {
    const i = new bC(Se.SOF, 0, 0, 0, 0);
    this.source = e, this.lastToken = i, this.token = i, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let e = this.token;
    if (e.kind !== Se.EOF)
      do
        if (e.next)
          e = e.next;
        else {
          const i = Vk(this, e.end);
          e.next = i, i.prev = e, e = i;
        }
      while (e.kind === Se.COMMENT);
    return e;
  }
}
function jk(r) {
  return r === Se.BANG || r === Se.DOLLAR || r === Se.AMP || r === Se.PAREN_L || r === Se.PAREN_R || r === Se.SPREAD || r === Se.COLON || r === Se.EQUALS || r === Se.AT || r === Se.BRACKET_L || r === Se.BRACKET_R || r === Se.BRACE_L || r === Se.PIPE || r === Se.BRACE_R;
}
function Oc(r) {
  return r >= 0 && r <= 55295 || r >= 57344 && r <= 1114111;
}
function pg(r, e) {
  return wC(r.charCodeAt(e)) && SC(r.charCodeAt(e + 1));
}
function wC(r) {
  return r >= 55296 && r <= 56319;
}
function SC(r) {
  return r >= 56320 && r <= 57343;
}
function bl(r, e) {
  const i = r.source.body.codePointAt(e);
  if (i === void 0)
    return Se.EOF;
  if (i >= 32 && i <= 126) {
    const n = String.fromCodePoint(i);
    return n === '"' ? `'"'` : `"${n}"`;
  }
  return "U+" + i.toString(16).toUpperCase().padStart(4, "0");
}
function Di(r, e, i, n, s) {
  const a = r.line, o = 1 + i - r.lineStart;
  return new bC(e, i, n, a, o, s);
}
function Vk(r, e) {
  const i = r.source.body, n = i.length;
  let s = e;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    switch (a) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++s;
        continue;
      case 10:
        ++s, ++r.line, r.lineStart = s;
        continue;
      case 13:
        i.charCodeAt(s + 1) === 10 ? s += 2 : ++s, ++r.line, r.lineStart = s;
        continue;
      case 35:
        return Gk(r, s);
      case 33:
        return Di(r, Se.BANG, s, s + 1);
      case 36:
        return Di(r, Se.DOLLAR, s, s + 1);
      case 38:
        return Di(r, Se.AMP, s, s + 1);
      case 40:
        return Di(r, Se.PAREN_L, s, s + 1);
      case 41:
        return Di(r, Se.PAREN_R, s, s + 1);
      case 46:
        if (i.charCodeAt(s + 1) === 46 && i.charCodeAt(s + 2) === 46)
          return Di(r, Se.SPREAD, s, s + 3);
        break;
      case 58:
        return Di(r, Se.COLON, s, s + 1);
      case 61:
        return Di(r, Se.EQUALS, s, s + 1);
      case 64:
        return Di(r, Se.AT, s, s + 1);
      case 91:
        return Di(r, Se.BRACKET_L, s, s + 1);
      case 93:
        return Di(r, Se.BRACKET_R, s, s + 1);
      case 123:
        return Di(r, Se.BRACE_L, s, s + 1);
      case 124:
        return Di(r, Se.PIPE, s, s + 1);
      case 125:
        return Di(r, Se.BRACE_R, s, s + 1);
      case 34:
        return i.charCodeAt(s + 1) === 34 && i.charCodeAt(s + 2) === 34 ? Kk(r, s) : Wk(r, s);
    }
    if (ld(a) || a === 45)
      return Hk(r, s, a);
    if (TC(a))
      return Zk(r, s);
    throw Ki(
      r.source,
      s,
      a === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Oc(a) || pg(i, s) ? `Unexpected character: ${bl(r, s)}.` : `Invalid character: ${bl(r, s)}.`
    );
  }
  return Di(r, Se.EOF, n, n);
}
function Gk(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    if (a === 10 || a === 13)
      break;
    if (Oc(a))
      ++s;
    else if (pg(i, s))
      s += 2;
    else
      break;
  }
  return Di(
    r,
    Se.COMMENT,
    e,
    s,
    i.slice(e + 1, s)
  );
}
function Hk(r, e, i) {
  const n = r.source.body;
  let s = e, a = i, o = !1;
  if (a === 45 && (a = n.charCodeAt(++s)), a === 48) {
    if (a = n.charCodeAt(++s), ld(a))
      throw Ki(
        r.source,
        s,
        `Invalid number, unexpected digit after 0: ${bl(
          r,
          s
        )}.`
      );
  } else
    s = ly(r, s, a), a = n.charCodeAt(s);
  if (a === 46 && (o = !0, a = n.charCodeAt(++s), s = ly(r, s, a), a = n.charCodeAt(s)), (a === 69 || a === 101) && (o = !0, a = n.charCodeAt(++s), (a === 43 || a === 45) && (a = n.charCodeAt(++s)), s = ly(r, s, a), a = n.charCodeAt(s)), a === 46 || TC(a))
    throw Ki(
      r.source,
      s,
      `Invalid number, expected digit but got: ${bl(
        r,
        s
      )}.`
    );
  return Di(
    r,
    o ? Se.FLOAT : Se.INT,
    e,
    s,
    n.slice(e, s)
  );
}
function ly(r, e, i) {
  if (!ld(i))
    throw Ki(
      r.source,
      e,
      `Invalid number, expected digit but got: ${bl(
        r,
        e
      )}.`
    );
  const n = r.source.body;
  let s = e + 1;
  for (; ld(n.charCodeAt(s)); )
    ++s;
  return s;
}
function Wk(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1, a = s, o = "";
  for (; s < n; ) {
    const l = i.charCodeAt(s);
    if (l === 34)
      return o += i.slice(a, s), Di(r, Se.STRING, e, s + 1, o);
    if (l === 92) {
      o += i.slice(a, s);
      const u = i.charCodeAt(s + 1) === 117 ? i.charCodeAt(s + 2) === 123 ? qk(r, s) : Xk(r, s) : Yk(r, s);
      o += u.value, s += u.size, a = s;
      continue;
    }
    if (l === 10 || l === 13)
      break;
    if (Oc(l))
      ++s;
    else if (pg(i, s))
      s += 2;
    else
      throw Ki(
        r.source,
        s,
        `Invalid character within String: ${bl(
          r,
          s
        )}.`
      );
  }
  throw Ki(r.source, s, "Unterminated string.");
}
function qk(r, e) {
  const i = r.source.body;
  let n = 0, s = 3;
  for (; s < 12; ) {
    const a = i.charCodeAt(e + s++);
    if (a === 125) {
      if (s < 5 || !Oc(n))
        break;
      return {
        value: String.fromCodePoint(n),
        size: s
      };
    }
    if (n = n << 4 | kh(a), n < 0)
      break;
  }
  throw Ki(
    r.source,
    e,
    `Invalid Unicode escape sequence: "${i.slice(
      e,
      e + s
    )}".`
  );
}
function Xk(r, e) {
  const i = r.source.body, n = ew(i, e + 2);
  if (Oc(n))
    return {
      value: String.fromCodePoint(n),
      size: 6
    };
  if (wC(n) && i.charCodeAt(e + 6) === 92 && i.charCodeAt(e + 7) === 117) {
    const s = ew(i, e + 8);
    if (SC(s))
      return {
        value: String.fromCodePoint(n, s),
        size: 12
      };
  }
  throw Ki(
    r.source,
    e,
    `Invalid Unicode escape sequence: "${i.slice(e, e + 6)}".`
  );
}
function ew(r, e) {
  return kh(r.charCodeAt(e)) << 12 | kh(r.charCodeAt(e + 1)) << 8 | kh(r.charCodeAt(e + 2)) << 4 | kh(r.charCodeAt(e + 3));
}
function kh(r) {
  return r >= 48 && r <= 57 ? r - 48 : r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : -1;
}
function Yk(r, e) {
  const i = r.source.body;
  switch (i.charCodeAt(e + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw Ki(
    r.source,
    e,
    `Invalid character escape sequence: "${i.slice(
      e,
      e + 2
    )}".`
  );
}
function Kk(r, e) {
  const i = r.source.body, n = i.length;
  let s = r.lineStart, a = e + 3, o = a, l = "";
  const u = [];
  for (; a < n; ) {
    const c = i.charCodeAt(a);
    if (c === 34 && i.charCodeAt(a + 1) === 34 && i.charCodeAt(a + 2) === 34) {
      l += i.slice(o, a), u.push(l);
      const h = Di(
        r,
        Se.BLOCK_STRING,
        e,
        a + 3,
        // Return a string of the lines joined with U+000A.
        Uk(u).join(`
`)
      );
      return r.line += u.length - 1, r.lineStart = s, h;
    }
    if (c === 92 && i.charCodeAt(a + 1) === 34 && i.charCodeAt(a + 2) === 34 && i.charCodeAt(a + 3) === 34) {
      l += i.slice(o, a), o = a + 1, a += 4;
      continue;
    }
    if (c === 10 || c === 13) {
      l += i.slice(o, a), u.push(l), c === 13 && i.charCodeAt(a + 1) === 10 ? a += 2 : ++a, l = "", o = a, s = a;
      continue;
    }
    if (Oc(c))
      ++a;
    else if (pg(i, a))
      a += 2;
    else
      throw Ki(
        r.source,
        a,
        `Invalid character within String: ${bl(
          r,
          a
        )}.`
      );
  }
  throw Ki(r.source, a, "Unterminated string.");
}
function Zk(r, e) {
  const i = r.source.body, n = i.length;
  let s = e + 1;
  for (; s < n; ) {
    const a = i.charCodeAt(s);
    if (kk(a))
      ++s;
    else
      break;
  }
  return Di(
    r,
    Se.NAME,
    e,
    s,
    i.slice(e, s)
  );
}
const Qk = 10, EC = 2;
function y_(r) {
  return fg(r, []);
}
function fg(r, e) {
  switch (typeof r) {
    case "string":
      return JSON.stringify(r);
    case "function":
      return r.name ? `[function ${r.name}]` : "[function]";
    case "object":
      return $k(r, e);
    default:
      return String(r);
  }
}
function $k(r, e) {
  if (r === null)
    return "null";
  if (e.includes(r))
    return "[Circular]";
  const i = [...e, r];
  if (Jk(r)) {
    const n = r.toJSON();
    if (n !== r)
      return typeof n == "string" ? n : fg(n, i);
  } else if (Array.isArray(r))
    return t5(r, i);
  return e5(r, i);
}
function Jk(r) {
  return typeof r.toJSON == "function";
}
function e5(r, e) {
  const i = Object.entries(r);
  return i.length === 0 ? "{}" : e.length > EC ? "[" + i5(r) + "]" : "{ " + i.map(
    ([n, s]) => n + ": " + fg(s, e)
  ).join(", ") + " }";
}
function t5(r, e) {
  if (r.length === 0)
    return "[]";
  if (e.length > EC)
    return "[Array]";
  const i = Math.min(Qk, r.length), n = r.length - i, s = [];
  for (let a = 0; a < i; ++a)
    s.push(fg(r[a], e));
  return n === 1 ? s.push("... 1 more item") : n > 1 && s.push(`... ${n} more items`), "[" + s.join(", ") + "]";
}
function i5(r) {
  const e = Object.prototype.toString.call(r).replace(/^\[object /, "").replace(/]$/, "");
  if (e === "Object" && typeof r.constructor == "function") {
    const i = r.constructor.name;
    if (typeof i == "string" && i !== "")
      return i;
  }
  return e;
}
const r5 = globalThis.process && // eslint-disable-next-line no-undef
process.env.NODE_ENV === "production", n5 = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  r5 ? function(r, e) {
    return r instanceof e;
  } : function(r, e) {
    if (r instanceof e)
      return !0;
    if (typeof r == "object" && r !== null) {
      var i;
      const n = e.prototype[Symbol.toStringTag], s = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in r ? r[Symbol.toStringTag] : (i = r.constructor) === null || i === void 0 ? void 0 : i.name
      );
      if (n === s) {
        const a = y_(r);
        throw new Error(`Cannot use ${n} "${a}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
let MC = class {
  constructor(r, e = "GraphQL request", i = {
    line: 1,
    column: 1
  }) {
    typeof r == "string" || Vf(!1, `Body must be a string. Received: ${y_(r)}.`), this.body = r, this.name = e, this.locationOffset = i, this.locationOffset.line > 0 || Vf(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || Vf(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function s5(r) {
  return n5(r, MC);
}
function a5(r, e) {
  const i = new o5(r, e), n = i.parseDocument();
  return Object.defineProperty(n, "tokenCount", {
    enumerable: !1,
    value: i.tokenCount
  }), n;
}
class o5 {
  constructor(e, i = {}) {
    const n = s5(e) ? e : new MC(e);
    this._lexer = new zk(n), this._options = i, this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const e = this.expectToken(Se.NAME);
    return this.node(e, {
      kind: pt.NAME,
      value: e.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: pt.DOCUMENT,
      definitions: this.many(
        Se.SOF,
        this.parseDefinition,
        Se.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(Se.BRACE_L))
      return this.parseOperationDefinition();
    const e = this.peekDescription(), i = e ? this._lexer.lookahead() : this._lexer.token;
    if (i.kind === Se.NAME) {
      switch (i.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (e)
        throw Ki(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (i.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(i);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const e = this._lexer.token;
    if (this.peek(Se.BRACE_L))
      return this.node(e, {
        kind: pt.OPERATION_DEFINITION,
        operation: tl.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const i = this.parseOperationType();
    let n;
    return this.peek(Se.NAME) && (n = this.parseName()), this.node(e, {
      kind: pt.OPERATION_DEFINITION,
      operation: i,
      name: n,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const e = this.expectToken(Se.NAME);
    switch (e.value) {
      case "query":
        return tl.QUERY;
      case "mutation":
        return tl.MUTATION;
      case "subscription":
        return tl.SUBSCRIPTION;
    }
    throw this.unexpected(e);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      Se.PAREN_L,
      this.parseVariableDefinition,
      Se.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: pt.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(Se.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(Se.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const e = this._lexer.token;
    return this.expectToken(Se.DOLLAR), this.node(e, {
      kind: pt.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: pt.SELECTION_SET,
      selections: this.many(
        Se.BRACE_L,
        this.parseSelection,
        Se.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(Se.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const e = this._lexer.token, i = this.parseName();
    let n, s;
    return this.expectOptionalToken(Se.COLON) ? (n = i, s = this.parseName()) : s = i, this.node(e, {
      kind: pt.FIELD,
      alias: n,
      name: s,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(Se.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(e) {
    const i = e ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(Se.PAREN_L, i, Se.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(e = !1) {
    const i = this._lexer.token, n = this.parseName();
    return this.expectToken(Se.COLON), this.node(i, {
      kind: pt.ARGUMENT,
      name: n,
      value: this.parseValueLiteral(e)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const e = this._lexer.token;
    this.expectToken(Se.SPREAD);
    const i = this.expectOptionalKeyword("on");
    return !i && this.peek(Se.NAME) ? this.node(e, {
      kind: pt.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(e, {
      kind: pt.INLINE_FRAGMENT,
      typeCondition: i ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const e = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(e, {
      kind: pt.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(e, {
      kind: pt.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(e) {
    const i = this._lexer.token;
    switch (i.kind) {
      case Se.BRACKET_L:
        return this.parseList(e);
      case Se.BRACE_L:
        return this.parseObject(e);
      case Se.INT:
        return this.advanceLexer(), this.node(i, {
          kind: pt.INT,
          value: i.value
        });
      case Se.FLOAT:
        return this.advanceLexer(), this.node(i, {
          kind: pt.FLOAT,
          value: i.value
        });
      case Se.STRING:
      case Se.BLOCK_STRING:
        return this.parseStringLiteral();
      case Se.NAME:
        switch (this.advanceLexer(), i.value) {
          case "true":
            return this.node(i, {
              kind: pt.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(i, {
              kind: pt.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(i, {
              kind: pt.NULL
            });
          default:
            return this.node(i, {
              kind: pt.ENUM,
              value: i.value
            });
        }
      case Se.DOLLAR:
        if (e)
          if (this.expectToken(Se.DOLLAR), this._lexer.token.kind === Se.NAME) {
            const n = this._lexer.token.value;
            throw Ki(
              this._lexer.source,
              i.start,
              `Unexpected variable "$${n}" in constant value.`
            );
          } else
            throw this.unexpected(i);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const e = this._lexer.token;
    return this.advanceLexer(), this.node(e, {
      kind: pt.STRING,
      value: e.value,
      block: e.kind === Se.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(e) {
    const i = () => this.parseValueLiteral(e);
    return this.node(this._lexer.token, {
      kind: pt.LIST,
      values: this.any(Se.BRACKET_L, i, Se.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(e) {
    const i = () => this.parseObjectField(e);
    return this.node(this._lexer.token, {
      kind: pt.OBJECT,
      fields: this.any(Se.BRACE_L, i, Se.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(e) {
    const i = this._lexer.token, n = this.parseName();
    return this.expectToken(Se.COLON), this.node(i, {
      kind: pt.OBJECT_FIELD,
      name: n,
      value: this.parseValueLiteral(e)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(e) {
    const i = [];
    for (; this.peek(Se.AT); )
      i.push(this.parseDirective(e));
    return i;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(e) {
    const i = this._lexer.token;
    return this.expectToken(Se.AT), this.node(i, {
      kind: pt.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(e)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const e = this._lexer.token;
    let i;
    if (this.expectOptionalToken(Se.BRACKET_L)) {
      const n = this.parseTypeReference();
      this.expectToken(Se.BRACKET_R), i = this.node(e, {
        kind: pt.LIST_TYPE,
        type: n
      });
    } else
      i = this.parseNamedType();
    return this.expectOptionalToken(Se.BANG) ? this.node(e, {
      kind: pt.NON_NULL_TYPE,
      type: i
    }) : i;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: pt.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(Se.STRING) || this.peek(Se.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("schema");
    const n = this.parseConstDirectives(), s = this.many(
      Se.BRACE_L,
      this.parseOperationTypeDefinition,
      Se.BRACE_R
    );
    return this.node(e, {
      kind: pt.SCHEMA_DEFINITION,
      description: i,
      directives: n,
      operationTypes: s
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const e = this._lexer.token, i = this.parseOperationType();
    this.expectToken(Se.COLON);
    const n = this.parseNamedType();
    return this.node(e, {
      kind: pt.OPERATION_TYPE_DEFINITION,
      operation: i,
      type: n
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("scalar");
    const n = this.parseName(), s = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.SCALAR_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("type");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(e, {
      kind: pt.OBJECT_TYPE_DEFINITION,
      description: i,
      name: n,
      interfaces: s,
      directives: a,
      fields: o
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(Se.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      Se.BRACE_L,
      this.parseFieldDefinition,
      Se.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseName(), s = this.parseArgumentDefs();
    this.expectToken(Se.COLON);
    const a = this.parseTypeReference(), o = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.FIELD_DEFINITION,
      description: i,
      name: n,
      arguments: s,
      type: a,
      directives: o
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      Se.PAREN_L,
      this.parseInputValueDef,
      Se.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseName();
    this.expectToken(Se.COLON);
    const s = this.parseTypeReference();
    let a;
    this.expectOptionalToken(Se.EQUALS) && (a = this.parseConstValueLiteral());
    const o = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.INPUT_VALUE_DEFINITION,
      description: i,
      name: n,
      type: s,
      defaultValue: a,
      directives: o
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("interface");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(e, {
      kind: pt.INTERFACE_TYPE_DEFINITION,
      description: i,
      name: n,
      interfaces: s,
      directives: a,
      fields: o
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("union");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseUnionMemberTypes();
    return this.node(e, {
      kind: pt.UNION_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      types: a
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(Se.EQUALS) ? this.delimitedMany(Se.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("enum");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseEnumValuesDefinition();
    return this.node(e, {
      kind: pt.ENUM_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      values: a
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      Se.BRACE_L,
      this.parseEnumValueDefinition,
      Se.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const e = this._lexer.token, i = this.parseDescription(), n = this.parseEnumValueName(), s = this.parseConstDirectives();
    return this.node(e, {
      kind: pt.ENUM_VALUE_DEFINITION,
      description: i,
      name: n,
      directives: s
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw Ki(
        this._lexer.source,
        this._lexer.token.start,
        `${cp(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("input");
    const n = this.parseName(), s = this.parseConstDirectives(), a = this.parseInputFieldsDefinition();
    return this.node(e, {
      kind: pt.INPUT_OBJECT_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      fields: a
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      Se.BRACE_L,
      this.parseInputValueDef,
      Se.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const e = this._lexer.lookahead();
    if (e.kind === Se.NAME)
      switch (e.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(e);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const i = this.parseConstDirectives(), n = this.optionalMany(
      Se.BRACE_L,
      this.parseOperationTypeDefinition,
      Se.BRACE_R
    );
    if (i.length === 0 && n.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.SCHEMA_EXTENSION,
      directives: i,
      operationTypes: n
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const i = this.parseName(), n = this.parseConstDirectives();
    if (n.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.SCALAR_TYPE_EXTENSION,
      name: i,
      directives: n
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const i = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.OBJECT_TYPE_EXTENSION,
      name: i,
      interfaces: n,
      directives: s,
      fields: a
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const i = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.INTERFACE_TYPE_EXTENSION,
      name: i,
      interfaces: n,
      directives: s,
      fields: a
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseUnionMemberTypes();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.UNION_TYPE_EXTENSION,
      name: i,
      directives: n,
      types: s
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseEnumValuesDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.ENUM_TYPE_EXTENSION,
      name: i,
      directives: n,
      values: s
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseInputFieldsDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: pt.INPUT_OBJECT_TYPE_EXTENSION,
      name: i,
      directives: n,
      fields: s
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const e = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(Se.AT);
    const n = this.parseName(), s = this.parseArgumentDefs(), a = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const o = this.parseDirectiveLocations();
    return this.node(e, {
      kind: pt.DIRECTIVE_DEFINITION,
      description: i,
      name: n,
      arguments: s,
      repeatable: a,
      locations: o
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(Se.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const e = this._lexer.token, i = this.parseName();
    if (Object.prototype.hasOwnProperty.call(Bv, i.value))
      return i;
    throw this.unexpected(e);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(e, i) {
    return this._options.noLocation !== !0 && (i.loc = new Dk(
      e,
      this._lexer.lastToken,
      this._lexer.source
    )), i;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(e) {
    return this._lexer.token.kind === e;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(e) {
    const i = this._lexer.token;
    if (i.kind === e)
      return this.advanceLexer(), i;
    throw Ki(
      this._lexer.source,
      i.start,
      `Expected ${AC(e)}, found ${cp(i)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(e) {
    return this._lexer.token.kind === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(e) {
    const i = this._lexer.token;
    if (i.kind === Se.NAME && i.value === e)
      this.advanceLexer();
    else
      throw Ki(
        this._lexer.source,
        i.start,
        `Expected "${e}", found ${cp(i)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(e) {
    const i = this._lexer.token;
    return i.kind === Se.NAME && i.value === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(e) {
    const i = e ?? this._lexer.token;
    return Ki(
      this._lexer.source,
      i.start,
      `Unexpected ${cp(i)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(e, i, n) {
    this.expectToken(e);
    const s = [];
    for (; !this.expectOptionalToken(n); )
      s.push(i.call(this));
    return s;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(e, i, n) {
    if (this.expectOptionalToken(e)) {
      const s = [];
      do
        s.push(i.call(this));
      while (!this.expectOptionalToken(n));
      return s;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(e, i, n) {
    this.expectToken(e);
    const s = [];
    do
      s.push(i.call(this));
    while (!this.expectOptionalToken(n));
    return s;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(e, i) {
    this.expectOptionalToken(e);
    const n = [];
    do
      n.push(i.call(this));
    while (this.expectOptionalToken(e));
    return n;
  }
  advanceLexer() {
    const { maxTokens: e } = this._options, i = this._lexer.advance();
    if (i.kind !== Se.EOF && (++this._tokenCounter, e !== void 0 && this._tokenCounter > e))
      throw Ki(
        this._lexer.source,
        i.start,
        `Document contains more that ${e} tokens. Parsing aborted.`
      );
  }
}
function cp(r) {
  const e = r.value;
  return AC(r.kind) + (e != null ? ` "${e}"` : "");
}
function AC(r) {
  return jk(r) ? `"${r}"` : r;
}
function l5(r) {
  return `"${r.replace(u5, c5)}"`;
}
const u5 = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function c5(r) {
  return h5[r.charCodeAt(0)];
}
const h5 = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], d5 = Object.freeze({});
function p5(r, e, i = xC) {
  const n = /* @__PURE__ */ new Map();
  for (const g of Object.values(pt))
    n.set(g, f5(e, g));
  let s, a = Array.isArray(r), o = [r], l = -1, u = [], c = r, h, d;
  const p = [], f = [];
  do {
    l++;
    const g = l === o.length, _ = g && u.length !== 0;
    if (g) {
      if (h = f.length === 0 ? void 0 : p[p.length - 1], c = d, d = f.pop(), _)
        if (a) {
          c = c.slice();
          let b = 0;
          for (const [T, E] of u) {
            const M = T - b;
            E === null ? (c.splice(M, 1), b++) : c[M] = E;
          }
        } else {
          c = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(c)
          );
          for (const [b, T] of u)
            c[b] = T;
        }
      l = s.index, o = s.keys, u = s.edits, a = s.inArray, s = s.prev;
    } else if (d) {
      if (h = a ? l : o[l], c = d[h], c == null)
        continue;
      p.push(h);
    }
    let x;
    if (!Array.isArray(c)) {
      var m, y;
      JT(c) || Vf(!1, `Invalid AST Node: ${y_(c)}.`);
      const b = g ? (m = n.get(c.kind)) === null || m === void 0 ? void 0 : m.leave : (y = n.get(c.kind)) === null || y === void 0 ? void 0 : y.enter;
      if (x = b == null ? void 0 : b.call(e, c, h, d, p, f), x === d5)
        break;
      if (x === !1) {
        if (!g) {
          p.pop();
          continue;
        }
      } else if (x !== void 0 && (u.push([h, x]), !g))
        if (JT(x))
          c = x;
        else {
          p.pop();
          continue;
        }
    }
    if (x === void 0 && _ && u.push([h, c]), g)
      p.pop();
    else {
      var v;
      s = {
        inArray: a,
        index: l,
        keys: o,
        edits: u,
        prev: s
      }, a = Array.isArray(c), o = a ? c : (v = i[c.kind]) !== null && v !== void 0 ? v : [], l = -1, u = [], d && f.push(d), d = c;
    }
  } while (s !== void 0);
  return u.length !== 0 ? u[u.length - 1][1] : r;
}
function f5(r, e) {
  const i = r[e];
  return typeof i == "object" ? i : typeof i == "function" ? {
    enter: i,
    leave: void 0
  } : {
    enter: r.enter,
    leave: r.leave
  };
}
function m5(r) {
  return p5(r, y5);
}
const g5 = 80, y5 = {
  Name: {
    leave: (r) => r.value
  },
  Variable: {
    leave: (r) => "$" + r.name
  },
  // Document
  Document: {
    leave: (r) => Je(r.definitions, `

`)
  },
  OperationDefinition: {
    leave(r) {
      const e = Lt("(", Je(r.variableDefinitions, ", "), ")"), i = Je(
        [
          r.operation,
          Je([r.name, e]),
          Je(r.directives, " ")
        ],
        " "
      );
      return (i === "query" ? "" : i + " ") + r.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: r, type: e, defaultValue: i, directives: n }) => r + ": " + e + Lt(" = ", i) + Lt(" ", Je(n, " "))
  },
  SelectionSet: {
    leave: ({ selections: r }) => Cn(r)
  },
  Field: {
    leave({ alias: r, name: e, arguments: i, directives: n, selectionSet: s }) {
      const a = Lt("", r, ": ") + e;
      let o = a + Lt("(", Je(i, ", "), ")");
      return o.length > g5 && (o = a + Lt(`(
`, Gf(Je(i, `
`)), `
)`)), Je([o, Je(n, " "), s], " ");
    }
  },
  Argument: {
    leave: ({ name: r, value: e }) => r + ": " + e
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: r, directives: e }) => "..." + r + Lt(" ", Je(e, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: r, directives: e, selectionSet: i }) => Je(
      [
        "...",
        Lt("on ", r),
        Je(e, " "),
        i
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: r, typeCondition: e, variableDefinitions: i, directives: n, selectionSet: s }) => (
      // or removed in the future.
      `fragment ${r}${Lt("(", Je(i, ", "), ")")} on ${e} ${Lt("", Je(n, " "), " ")}` + s
    )
  },
  // Value
  IntValue: {
    leave: ({ value: r }) => r
  },
  FloatValue: {
    leave: ({ value: r }) => r
  },
  StringValue: {
    leave: ({ value: r, block: e }) => e ? Bk(r) : l5(r)
  },
  BooleanValue: {
    leave: ({ value: r }) => r ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: r }) => r
  },
  ListValue: {
    leave: ({ values: r }) => "[" + Je(r, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: r }) => "{" + Je(r, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: r, value: e }) => r + ": " + e
  },
  // Directive
  Directive: {
    leave: ({ name: r, arguments: e }) => "@" + r + Lt("(", Je(e, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: r }) => r
  },
  ListType: {
    leave: ({ type: r }) => "[" + r + "]"
  },
  NonNullType: {
    leave: ({ type: r }) => r + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: r, directives: e, operationTypes: i }) => Lt("", r, `
`) + Je(["schema", Je(e, " "), Cn(i)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: r, type: e }) => r + ": " + e
  },
  ScalarTypeDefinition: {
    leave: ({ description: r, name: e, directives: i }) => Lt("", r, `
`) + Je(["scalar", e, Je(i, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: r, name: e, interfaces: i, directives: n, fields: s }) => Lt("", r, `
`) + Je(
      [
        "type",
        e,
        Lt("implements ", Je(i, " & ")),
        Je(n, " "),
        Cn(s)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: r, name: e, arguments: i, type: n, directives: s }) => Lt("", r, `
`) + e + (tw(i) ? Lt(`(
`, Gf(Je(i, `
`)), `
)`) : Lt("(", Je(i, ", "), ")")) + ": " + n + Lt(" ", Je(s, " "))
  },
  InputValueDefinition: {
    leave: ({ description: r, name: e, type: i, defaultValue: n, directives: s }) => Lt("", r, `
`) + Je(
      [e + ": " + i, Lt("= ", n), Je(s, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: r, name: e, interfaces: i, directives: n, fields: s }) => Lt("", r, `
`) + Je(
      [
        "interface",
        e,
        Lt("implements ", Je(i, " & ")),
        Je(n, " "),
        Cn(s)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, types: n }) => Lt("", r, `
`) + Je(
      ["union", e, Je(i, " "), Lt("= ", Je(n, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, values: n }) => Lt("", r, `
`) + Je(["enum", e, Je(i, " "), Cn(n)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: r, name: e, directives: i }) => Lt("", r, `
`) + Je([e, Je(i, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: r, name: e, directives: i, fields: n }) => Lt("", r, `
`) + Je(["input", e, Je(i, " "), Cn(n)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: r, name: e, arguments: i, repeatable: n, locations: s }) => Lt("", r, `
`) + "directive @" + e + (tw(i) ? Lt(`(
`, Gf(Je(i, `
`)), `
)`) : Lt("(", Je(i, ", "), ")")) + (n ? " repeatable" : "") + " on " + Je(s, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: r, operationTypes: e }) => Je(
      ["extend schema", Je(r, " "), Cn(e)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: r, directives: e }) => Je(["extend scalar", r, Je(e, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: r, interfaces: e, directives: i, fields: n }) => Je(
      [
        "extend type",
        r,
        Lt("implements ", Je(e, " & ")),
        Je(i, " "),
        Cn(n)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: r, interfaces: e, directives: i, fields: n }) => Je(
      [
        "extend interface",
        r,
        Lt("implements ", Je(e, " & ")),
        Je(i, " "),
        Cn(n)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: r, directives: e, types: i }) => Je(
      [
        "extend union",
        r,
        Je(e, " "),
        Lt("= ", Je(i, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: r, directives: e, values: i }) => Je(["extend enum", r, Je(e, " "), Cn(i)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: r, directives: e, fields: i }) => Je(["extend input", r, Je(e, " "), Cn(i)], " ")
  }
};
function Je(r, e = "") {
  var i;
  return (i = r == null ? void 0 : r.filter((n) => n).join(e)) !== null && i !== void 0 ? i : "";
}
function Cn(r) {
  return Lt(`{
`, Gf(Je(r, `
`)), `
}`);
}
function Lt(r, e, i = "") {
  return e != null && e !== "" ? r + e + i : "";
}
function Gf(r) {
  return Lt("  ", r.replace(/\n/g, `
  `));
}
function tw(r) {
  var e;
  return (e = r == null ? void 0 : r.some((i) => i.includes(`
`))) !== null && e !== void 0 ? e : !1;
}
const iw = "Accept", jv = "Content-Type", Vv = "application/json", CC = "application/graphql-response+json", rw = (r) => r.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), v5 = (r) => {
  const e = r.toLowerCase();
  return e.includes(CC) || e.includes(Vv);
}, nw = (r) => {
  try {
    if (Array.isArray(r))
      return {
        _tag: "Batch",
        executionResults: r.map(sw)
      };
    if (jf(r))
      return {
        _tag: "Single",
        executionResult: sw(r)
      };
    throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(r)}`);
  } catch (e) {
    return e;
  }
}, sw = (r) => {
  if (typeof r != "object" || r === null)
    throw new Error("Invalid execution result: result is not object");
  let e, i, n;
  if ("errors" in r) {
    if (!jf(r.errors) && !Array.isArray(r.errors))
      throw new Error("Invalid execution result: errors is not plain object OR array");
    e = r.errors;
  }
  if ("data" in r) {
    if (!jf(r.data) && r.data !== null)
      throw new Error("Invalid execution result: data is not plain object");
    i = r.data;
  }
  if ("extensions" in r) {
    if (!jf(r.extensions))
      throw new Error("Invalid execution result: extensions is not plain object");
    n = r.extensions;
  }
  return {
    data: i,
    errors: e,
    extensions: n
  };
}, b5 = (r) => r._tag === "Batch" ? r.executionResults.some(aw) : aw(r.executionResult), aw = (r) => Array.isArray(r.errors) ? r.errors.length > 0 : !!r.errors, RC = (r) => typeof r == "object" && r !== null && "kind" in r && r.kind === pt.OPERATION_DEFINITION, x5 = (r) => {
  var e;
  let i;
  const n = r.definitions.filter(RC);
  return n.length === 1 && (i = (e = n[0].name) == null ? void 0 : e.value), i;
}, _5 = (r) => {
  let e = !1;
  const i = r.definitions.filter(RC);
  return i.length === 1 && (e = i[0].operation === tl.MUTATION), e;
}, uy = (r, e) => {
  const i = typeof r == "string" ? r : m5(r);
  let n = !1, s;
  if (e)
    return { expression: i, isMutation: n, operationName: s };
  const a = Ek(() => typeof r == "string" ? a5(r) : r);
  return a instanceof Error ? { expression: i, isMutation: n, operationName: s } : (s = x5(a), n = _5(a), { expression: i, operationName: s, isMutation: n });
}, v_ = JSON, cy = async (r) => {
  const e = {
    ...r,
    method: r.request._tag === "Single" ? r.request.document.isMutation ? "POST" : KT(r.method ?? "post") : r.request.hasMutations ? "POST" : KT(r.method ?? "post"),
    fetchOptions: {
      ...r.fetchOptions,
      errorPolicy: r.fetchOptions.errorPolicy ?? "none"
    }
  }, i = await w5(e.method)(e);
  if (!i.ok)
    return new Vu({ status: i.status, headers: i.headers }, {
      query: r.request._tag === "Single" ? r.request.document.expression : r.request.query,
      variables: r.request.variables
    });
  const n = await T5(i, r.fetchOptions.jsonSerializer ?? v_);
  if (n instanceof Error)
    throw n;
  const s = {
    status: i.status,
    headers: i.headers
  };
  if (b5(n) && e.fetchOptions.errorPolicy === "none") {
    const a = n._tag === "Batch" ? { ...n.executionResults, ...s } : {
      ...n.executionResult,
      ...s
    };
    return new Vu(a, {
      query: r.request._tag === "Single" ? r.request.document.expression : r.request.query,
      variables: r.request.variables
    });
  }
  switch (n._tag) {
    case "Single":
      return {
        ...s,
        ...ow(e)(n.executionResult)
      };
    case "Batch":
      return {
        ...s,
        data: n.executionResults.map(ow(e))
      };
    default:
      m_(n);
  }
}, ow = (r) => (e) => ({
  extensions: e.extensions,
  data: e.data,
  errors: r.fetchOptions.errorPolicy === "all" ? e.errors : void 0
}), T5 = async (r, e) => {
  const i = r.headers.get(jv), n = await r.text();
  return i && v5(i) ? nw(e.parse(n)) : nw(n);
}, w5 = (r) => async (e) => {
  const i = new Headers(e.headers);
  let n = null, s;
  i.has(iw) || i.set(iw, [CC, Vv].join(", ")), r === "POST" ? (s = (e.fetchOptions.jsonSerializer ?? v_).stringify(S5(e)), typeof s == "string" && !i.has(jv) && i.set(jv, Vv)) : n = E5(e);
  const a = { method: r, headers: i, body: s, ...e.fetchOptions };
  let o = new URL(e.url), l = a;
  if (e.middleware) {
    const u = await Promise.resolve(e.middleware({
      ...a,
      url: e.url,
      operationName: e.request._tag === "Single" ? e.request.document.operationName : void 0,
      variables: e.request.variables
    })), { url: c, ...h } = u;
    o = new URL(c), l = h;
  }
  return n && n.forEach((u, c) => {
    o.searchParams.append(c, u);
  }), await (e.fetch ?? fetch)(o, l);
}, S5 = (r) => {
  switch (r.request._tag) {
    case "Single":
      return {
        query: r.request.document.expression,
        variables: r.request.variables,
        operationName: r.request.document.operationName
      };
    case "Batch":
      return yC(r.request.query, r.request.variables ?? []).map(([e, i]) => ({
        query: e,
        variables: i
      }));
    default:
      throw m_(r.request);
  }
}, E5 = (r) => {
  var e;
  const i = r.fetchOptions.jsonSerializer ?? v_, n = new URLSearchParams();
  switch (r.request._tag) {
    case "Single":
      return n.append("query", rw(r.request.document.expression)), r.request.variables && n.append("variables", i.stringify(r.request.variables)), r.request.document.operationName && n.append("operationName", r.request.document.operationName), n;
    case "Batch": {
      const s = ((e = r.request.variables) == null ? void 0 : e.map((l) => i.stringify(l))) ?? [], a = r.request.query.map(rw), o = yC(a, s).map(([l, u]) => ({
        query: l,
        variables: u
      }));
      return n.append("query", i.stringify(o)), n;
    }
    default:
      throw m_(r.request);
  }
};
class NC {
  constructor(e, i = {}) {
    qh(this, "url"), qh(this, "requestConfig"), qh(this, "rawRequest", async (...n) => {
      const [s, a, o] = n, l = Ck(s, a, o), { headers: u, fetch: c = globalThis.fetch, method: h = "POST", requestMiddleware: d, responseMiddleware: p, excludeOperationName: f, ...m } = this.requestConfig, { url: y } = this;
      l.signal !== void 0 && (m.signal = l.signal);
      const v = uy(l.query, f), g = await cy({
        url: y,
        request: {
          _tag: "Single",
          document: v,
          variables: l.variables
        },
        headers: {
          ...Bl(oy(u)),
          ...Bl(l.requestHeaders)
        },
        fetch: c,
        method: h,
        fetchOptions: m,
        middleware: d
      });
      if (p && await p(g, {
        operationName: v.operationName,
        variables: a,
        url: this.url
      }), g instanceof Error)
        throw g;
      return g;
    }), this.url = e, this.requestConfig = i;
  }
  async request(e, ...i) {
    const [n, s] = i, a = M5(e, n, s), { headers: o, fetch: l = globalThis.fetch, method: u = "POST", requestMiddleware: c, responseMiddleware: h, excludeOperationName: d, ...p } = this.requestConfig, { url: f } = this;
    a.signal !== void 0 && (p.signal = a.signal);
    const m = uy(a.document, d), y = await cy({
      url: f,
      request: {
        _tag: "Single",
        document: m,
        variables: a.variables
      },
      headers: {
        ...Bl(oy(o)),
        ...Bl(a.requestHeaders)
      },
      fetch: l,
      method: u,
      fetchOptions: p,
      middleware: c
    });
    if (h && await h(y, {
      operationName: m.operationName,
      variables: a.variables,
      url: this.url
    }), y instanceof Error)
      throw y;
    return y.data;
  }
  async batchRequests(e, i) {
    const n = Ak(e, i), { headers: s, excludeOperationName: a, ...o } = this.requestConfig;
    n.signal !== void 0 && (o.signal = n.signal);
    const l = n.documents.map(({ document: p }) => uy(p, a)), u = l.map(({ expression: p }) => p), c = l.some(({ isMutation: p }) => p), h = n.documents.map(({ variables: p }) => p), d = await cy({
      url: this.url,
      request: {
        _tag: "Batch",
        operationName: void 0,
        query: u,
        hasMutations: c,
        variables: h
      },
      headers: {
        ...Bl(oy(s)),
        ...Bl(n.requestHeaders)
      },
      fetch: this.requestConfig.fetch ?? globalThis.fetch,
      method: this.requestConfig.method || "POST",
      fetchOptions: o,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware && await this.requestConfig.responseMiddleware(d, {
      operationName: void 0,
      variables: h,
      url: this.url
    }), d instanceof Error)
      throw d;
    return d.data;
  }
  setHeaders(e) {
    return this.requestConfig.headers = e, this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(e, i) {
    const { headers: n } = this.requestConfig;
    return n ? n[e] = i : this.requestConfig.headers = { [e]: i }, this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(e) {
    return this.url = e, this;
  }
}
const M5 = (r, e, i) => r.document ? r : {
  document: r,
  variables: e,
  requestHeaders: i,
  signal: void 0
}, vs = (r, ...e) => r.reduce((i, n, s) => `${i}${n}${s in e ? String(e[s]) : ""}`, ""), PC = {
  base: {
    url: " https://prod.base.intuition-api.com/v1/graphql",
    displayName: "Base Mainnet"
  }
}, Vd = (r) => new NC(PC[r].url), A5 = async (r, e = "baseSepolia") => {
  const i = Vd(e);
  let n;
  n = vs`
    query GetAtom($atomId: numeric!) {
      atom(id: $atomId) {
        id
        image
        label
        emoji
        type
        creator_id
        vault {
          total_shares
        }
      }
    }
  `;
  const s = { atomId: r };
  try {
    return (await i.request(n, s)).atom;
  } catch (a) {
    throw console.error("Error fetching atom details:", a), a;
  }
}, C5 = async (r = "baseSepolia") => {
  const e = Vd(r);
  let i, n;
  return i = vs`
    query {
      triples(limit: 1000) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, n = await e.request(i), {
    items: n.triples
  }.items;
}, R5 = async (r, e = "baseSepolia") => {
  const i = Vd(e);
  let n, s, a;
  return n = vs`
    query Triples($where: triples_bool_exp) {
      triples(where: $where) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, a = {
    where: {
      _or: [
        {
          predicate_id: {
            _eq: r
          }
        },
        {
          subject_id: {
            _eq: r
          }
        },
        {
          object_id: {
            _eq: r
          }
        }
      ]
    }
  }, s = await i.request(n, a), s.triples;
}, N5 = async (r, e = "baseSepolia") => {
  const i = Vd(e), n = vs`
    query SearchTriples($where: triples_bool_exp) {
      triples(where: $where) {
        id
        subject {
          label
          id
          creator_id
          type
          image
        }
        predicate {
          label
          id
          creator_id
          type
        }
        object {
          label
          id
          creator_id
          type
          image
        }
      }
    }
  `, s = {
    _and: []
  };
  r.subject && s._and.push({
    subject: {
      label: {
        _ilike: `%${r.subject}%`
      }
    }
  }), r.predicate && s._and.push({
    predicate: {
      label: {
        _ilike: `%${r.predicate}%`
      }
    }
  }), r.object && s._and.push({
    object: {
      label: {
        _ilike: `%${r.object}%`
      }
    }
  });
  const a = {
    where: s._and.length > 0 ? s : {}
  };
  try {
    return (await i.request(n, a)).triples;
  } catch (o) {
    throw console.error("Error executing search query:", o), o;
  }
}, P5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ENDPOINTS: PC,
  createClient: Vd,
  fetchAtomDetails: A5,
  fetchTriples: C5,
  fetchTriplesForNode: R5,
  searchTriples: N5
}, Symbol.toStringTag, { value: "Module" })), IC = {
  baseSepolia: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Intuition Testnet"
  },
  base: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Intuition Testnet"
  }
}, Dc = (r) => new NC(IC[r].url), b_ = (r) => ({
  id: r.term_id,
  subject: {
    id: r.subject.term_id,
    label: r.subject.label,
    type: r.subject.type,
    image: r.subject.image
  },
  predicate: {
    id: r.predicate.term_id,
    label: r.predicate.label,
    type: r.predicate.type
  },
  object: {
    id: r.object.term_id,
    label: r.object.label,
    type: r.object.type,
    image: r.object.image
  }
}), I5 = async (r, e = "base") => {
  const i = Dc(e);
  let n;
  n = vs`
    query GetAtom($atomId: String!) {
      atoms(where: { term_id: { _eq: $atomId } }) {
        term_id
        image
        label
        emoji
        type
        creator_id
        term {
          total_market_cap
        }
      }
    }
  `;
  const s = { atomId: r };
  try {
    return (await i.request(n, s)).atoms[0];
  } catch (a) {
    throw console.error("Error fetching atom details:", a), a;
  }
}, OC = async (r = "base") => {
  const e = Dc(r);
  let i, n;
  return i = vs`
    query {
      triples(limit: 1000) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, n = await e.request(i), {
    items: n.triples
  }.items;
}, O5 = async (r, e = "base") => {
  const i = Dc(e);
  let n, s, a;
  return n = vs`
    query Triples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, a = {
    where: {
      _or: [
        {
          predicate_id: {
            _eq: r
          }
        },
        {
          subject_id: {
            _eq: r
          }
        },
        {
          object_id: {
            _eq: r
          }
        }
      ]
    }
  }, s = await i.request(n, a), s.triples.map(b_);
}, D5 = async (r, e = "base") => {
  const i = Dc(e), n = vs`
    query SearchTriples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject {
          label
          term_id
          creator_id
          type
          image
        }
        predicate {
          label
          term_id
          creator_id
          type
        }
        object {
          label
          term_id
          creator_id
          type
          image
        }
      }
    }
  `, s = {
    _and: []
  };
  r.subject && s._and.push({
    subject: {
      label: {
        _ilike: `%${r.subject}%`
      }
    }
  }), r.predicate && s._and.push({
    predicate: {
      label: {
        _ilike: `%${r.predicate}%`
      }
    }
  }), r.object && s._and.push({
    object: {
      label: {
        _ilike: `%${r.object}%`
      }
    }
  });
  const a = {
    where: s._and.length > 0 ? s : {}
  };
  try {
    return (await i.request(n, a)).triples.map(b_);
  } catch (o) {
    throw console.error("Error executing search query:", o), o;
  }
}, DC = async (r, e = "base", i = 1e3) => {
  const n = Dc(e), s = vs`
    query Triples_for_Agent($objectId: String!, $batchSize: Int!) {
      triples(limit: $batchSize, where: { object_id: { _eq: $objectId } }) {
        term_id
        subject {
          term_id
          label
          type
          image
        }
        predicate {
          term_id
          label
          type
          image
        }
        object {
          term_id
          label
          type
          image
        }
      }
    }
  `, a = vs`
    query Relations_for_Subject($subjectId: String!) {
      triples(where: { subject_id: { _eq: $subjectId } }) {
        term_id
        subject {
          term_id
          label
          type
          image
        }
        predicate {
          term_id
          label
          type
          image
        }
        object {
          term_id
          label
          type
          image
        }
      }
    }
  `, o = {
    batchSize: i,
    objectId: String(r)
  };
  try {
    const l = (await n.request(s, o)).triples, u = [...new Set(l.map((h) => h.subject.term_id))].map(
      (h) => n.request(a, { subjectId: h })
    ), c = (await Promise.all(u)).flatMap((h) => h.triples);
    return [...l, ...c].map(b_);
  } catch (l) {
    return console.error("Error fetching agent-specific triples:", l), OC(e).then((u) => u.filter(
      (c) => c.subject.term_id === r || c.object.term_id === r || c.predicate.term_id === r
    )).catch((u) => {
      throw console.error("Fallback fetch also failed:", u), l;
    });
  }
}, lw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ENDPOINTS: IC,
  createClient: Dc,
  fetchAtomDetails: I5,
  fetchTriples: OC,
  fetchTriplesForAgent: DC,
  fetchTriplesForNode: O5,
  searchTriples: D5
}, Symbol.toStringTag, { value: "Module" })), hy = {
  railsMockApi: {
    url: "https://api-i7n.thp-lab.org/api/v1/graph",
    displayName: "[OffChain] Playground API",
    module: P5
    // Default to Base module for railsMockApi
  },
  baseSepolia: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Base Testnet",
    module: lw
  },
  base: {
    url: "https://testnet.intuition.sh/v1/graphql",
    displayName: "Base Mainnet",
    module: lw
  }
}, mg = (r) => {
  if (!hy[r] || !hy[r].module)
    throw new Error(`No module defined for endpoint '${r}'.`);
  return hy[r].module;
}, x_ = async (r = "base") => {
  const e = mg(r);
  try {
    return e.fetchTriples(r);
  } catch (i) {
    throw console.error(`Error fetching triples for endpoint ${r}:`, i), i;
  }
}, L5 = async (r, e = "base") => {
  const i = mg(e);
  try {
    return i.fetchTriplesForNode(r, e);
  } catch (n) {
    throw console.error(
      `Error fetching triples for node ${r} with endpoint ${e}:`,
      n
    ), n;
  }
}, k5 = async (r, e = "base") => {
  const i = mg(e);
  try {
    return i.fetchAtomDetails(r, e);
  } catch (n) {
    throw console.error(
      `Error fetching atom details for ${r} with endpoint ${e}:`,
      n
    ), n;
  }
}, Pu = async (r, e = "base") => {
  const i = mg(e);
  try {
    return i.searchTriples(r, e);
  } catch (n) {
    throw console.error(`Error searching triples with endpoint ${e}:`, n), n;
  }
}, U5 = async (r, e = "baseSepolia", i = 1e3) => DC(r, e, i), __ = ({ triple: r, endpoint: e, onClose: i }) => {
  var n;
  const [s, a] = ye(null), [o, l] = ye(null), [u, c] = ye(!1), [h, d] = ye(null);
  Ft(() => {
    r && (c(!0), d(null), l(null), (async () => {
      try {
        const y = (await x_(e)).filter(
          (v) => {
            var g, _, x;
            return v.id === r.id || ((g = v.subject) == null ? void 0 : g.id) === r.id || ((_ = v.predicate) == null ? void 0 : _.id) === r.id || ((x = v.object) == null ? void 0 : x.id) === r.id;
          }
        );
        if (a(y), r.id) {
          const v = await k5(
            r.id,
            e
          );
          l(v);
        }
      } catch (y) {
        console.error("Error fetching sidebar data:", y), d("Failed to fetch data");
      } finally {
        c(!1);
      }
    })());
  }, [r, e]);
  const p = (y) => `${(y / 1e18).toFixed(4)} ETH`;
  if (!r)
    return null;
  const f = (y, v = 4, g = 4) => !y || y.length <= v + g ? y : `${y.slice(0, v)}...${y.slice(-g)}`, m = async (y) => {
    try {
      await navigator.clipboard.writeText(y);
    } catch (v) {
      console.error("Error copying ID:", v);
    }
  };
  return /* @__PURE__ */ se.jsxs(
    "div",
    {
      style: {
        background: "#18181b",
        borderRadius: "10px",
        border: "2px solid #ffd32a",
        padding: "24px",
        boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
        color: "#fff",
        maxWidth: "400px",
        width: "100%"
      },
      children: [
        /* @__PURE__ */ se.jsxs(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              marginBottom: "24px"
            },
            children: [
              /* @__PURE__ */ se.jsx(
                "h2",
                {
                  style: {
                    margin: 0,
                    fontSize: "24px",
                    color: "#ffd32a",
                    fontWeight: "bold",
                    letterSpacing: "0.5px"
                  },
                  children: r.label || "No Label"
                }
              ),
              /* @__PURE__ */ se.jsx(
                "button",
                {
                  onClick: i,
                  style: {
                    background: "none",
                    border: "none",
                    color: "#ffd32a",
                    fontSize: "24px",
                    cursor: "pointer",
                    padding: "4px",
                    lineHeight: 1
                  },
                  children: "×"
                }
              )
            ]
          }
        ),
        o && o.image && /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "center",
              margin: "24px 0"
            },
            children: /* @__PURE__ */ se.jsx(
              "img",
              {
                src: o.image,
                alt: o.label || "Node image",
                style: {
                  width: "120px",
                  height: "120px",
                  borderRadius: "50%",
                  objectFit: "cover",
                  border: "3px solid #ffd32a",
                  boxShadow: "0 4px 12px rgba(0,0,0,0.2)"
                }
              }
            )
          }
        ),
        u && /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              textAlign: "center",
              padding: "20px",
              color: "#ffd32a"
            },
            children: "Loading..."
          }
        ),
        h && /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              color: "#ff4444",
              padding: "12px",
              background: "rgba(255,68,68,0.1)",
              borderRadius: "8px",
              marginBottom: "16px"
            },
            children: h
          }
        ),
        o && /* @__PURE__ */ se.jsxs(
          "div",
          {
            style: {
              background: "#232326",
              borderRadius: "8px",
              padding: "16px",
              marginBottom: "24px"
            },
            children: [
              /* @__PURE__ */ se.jsx(
                "h4",
                {
                  style: {
                    color: "#ffd32a",
                    margin: "0 0 16px 0",
                    fontSize: "18px",
                    fontWeight: "bold"
                  },
                  children: "Atom Info"
                }
              ),
              /* @__PURE__ */ se.jsxs(
                "div",
                {
                  style: {
                    display: "grid",
                    gap: "12px"
                  },
                  children: [
                    /* @__PURE__ */ se.jsxs("div", { children: [
                      /* @__PURE__ */ se.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "ID:" }),
                      " ",
                      /* @__PURE__ */ se.jsx(
                        "span",
                        {
                          style: {
                            cursor: "pointer",
                            textDecoration: "underline",
                            color: "#ffd32a"
                          },
                          onClick: () => m(o.term_id),
                          title: `Cliquer pour copier: ${o.term_id}`,
                          children: f(o.term_id)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ se.jsxs("div", { children: [
                      /* @__PURE__ */ se.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Label:" }),
                      " ",
                      o.label
                    ] }),
                    /* @__PURE__ */ se.jsxs("div", { children: [
                      /* @__PURE__ */ se.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Type:" }),
                      " ",
                      o.type
                    ] }),
                    /* @__PURE__ */ se.jsxs("div", { children: [
                      /* @__PURE__ */ se.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Creator:" }),
                      " ",
                      /* @__PURE__ */ se.jsx(
                        "span",
                        {
                          style: {
                            cursor: "pointer",
                            textDecoration: "underline",
                            color: "#ffd32a"
                          },
                          onClick: () => m(o.creator_id),
                          title: `Cliquer pour copier: ${o.creator_id}`,
                          children: f(o.creator_id)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ se.jsxs("div", { children: [
                      /* @__PURE__ */ se.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Vault Shares:" }),
                      " ",
                      p(((n = o.vault) == null ? void 0 : n.total_shares) || 0)
                    ] })
                  ]
                }
              )
            ]
          }
        ),
        s && s.length > 0 && /* @__PURE__ */ se.jsxs(
          "div",
          {
            style: {
              background: "#232326",
              borderRadius: "8px",
              padding: "16px"
            },
            children: [
              /* @__PURE__ */ se.jsx(
                "h4",
                {
                  style: {
                    color: "#ffd32a",
                    margin: "0 0 16px 0",
                    fontSize: "18px",
                    fontWeight: "bold"
                  },
                  children: "Related Data"
                }
              ),
              /* @__PURE__ */ se.jsx(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: "12px"
                  },
                  children: s.map((y) => {
                    var v, g, _;
                    return /* @__PURE__ */ se.jsxs(
                      "div",
                      {
                        style: {
                          padding: "12px",
                          background: "#18181b",
                          borderRadius: "6px",
                          border: "1px solid #ffd32a33"
                        },
                        children: [
                          /* @__PURE__ */ se.jsxs("div", { children: [
                            /* @__PURE__ */ se.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Subject:" }),
                            " ",
                            (v = y.subject) == null ? void 0 : v.label
                          ] }),
                          /* @__PURE__ */ se.jsxs("div", { children: [
                            /* @__PURE__ */ se.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Predicate:" }),
                            " ",
                            (g = y.predicate) == null ? void 0 : g.label
                          ] }),
                          /* @__PURE__ */ se.jsxs("div", { children: [
                            /* @__PURE__ */ se.jsx("span", { style: { color: "#ffd32a", fontWeight: "bold" }, children: "Object:" }),
                            " ",
                            (_ = y.object) == null ? void 0 : _.label
                          ] })
                        ]
                      },
                      y.id
                    );
                  })
                }
              )
            ]
          }
        ),
        !u && !(s != null && s.length) && /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              textAlign: "center",
              padding: "20px",
              color: "#888",
              background: "#232326",
              borderRadius: "8px"
            },
            children: "No additional related data found."
          }
        )
      ]
    }
  );
}, F5 = ({ graphData: r, onNodeClick: e, onBack: i, onForward: n, selectedTriple: s, endpoint: a, disableNodeDetailsSidebar: o = !1 }) => {
  const l = Gi(), u = Gi(), [c, h] = ye({ width: 100, height: 100 });
  return Ft(() => {
    const d = () => {
      l.current && h({
        width: l.current.clientWidth,
        height: l.current.clientHeight
      });
    };
    return d(), window.addEventListener("resize", d), () => window.removeEventListener("resize", d);
  }, []), Ft(() => {
    if (u.current && c.width > 0 && c.height > 0) {
      const d = bA()(u.current);
      d.width(c.width).height(c.height).graphData(r).nodeLabel((p) => p.label || p.id).nodeAutoColorBy("group"), e && d.onNodeClick((p) => {
        e(p);
      });
    }
  }, [r, e, c]), /* @__PURE__ */ se.jsxs(
    "div",
    {
      ref: l,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ se.jsx(
          "div",
          {
            ref: u,
            style: { width: "100%", height: "100%" }
          }
        ),
        /* @__PURE__ */ se.jsxs("div", { style: { position: "absolute", bottom: 20, left: 20, zIndex: 100 }, children: [
          /* @__PURE__ */ se.jsx(
            "button",
            {
              onClick: i,
              style: {
                background: "#ffd32a",
                color: "#18181b",
                border: "none",
                borderRadius: 8,
                padding: "10px 20px",
                marginRight: 10,
                cursor: "pointer",
                fontWeight: "bold"
              },
              children: "Back"
            }
          ),
          /* @__PURE__ */ se.jsx(
            "button",
            {
              onClick: n,
              style: {
                background: "#ffd32a",
                color: "#18181b",
                border: "none",
                borderRadius: 8,
                padding: "10px 20px",
                cursor: "pointer",
                fontWeight: "bold"
              },
              children: "Forward"
            }
          )
        ] }),
        s && !o && /* @__PURE__ */ se.jsx("div", { style: {
          position: "absolute",
          top: 80,
          right: 30,
          width: 350,
          zIndex: 9999,
          maxHeight: "80vh",
          background: "#18181b",
          borderRadius: "10px",
          border: "3px solid #ffd32a",
          boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
          overflowY: "auto"
        }, children: /* @__PURE__ */ se.jsx(
          __,
          {
            triple: s,
            endpoint: a,
            onClose: () => e(null)
          }
        ) })
      ]
    }
  );
}, LC = () => {
  const [r, e] = ye([]), i = 200;
  Ft(() => {
    let s;
    const a = () => {
      const o = Date.now() / 1e3, l = [];
      for (let u = 0; u < 3; u++) {
        const c = o * 0.8 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 150 + 200,
          y: Math.sin(c) * 150 + 200,
          color: "#00fff2"
        });
      }
      for (let u = 0; u < 3; u++) {
        const c = -o * 1.2 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 100 + 200,
          y: Math.sin(c) * 100 + 200,
          color: "#ff00ff"
        });
      }
      for (let u = 0; u < 3; u++) {
        const c = o * 1.5 + u * 2 * Math.PI / 3;
        l.push({
          x: Math.cos(c) * 50 + 200,
          y: Math.sin(c) * 50 + 200,
          color: "#ffff00"
        });
      }
      e(l), s = requestAnimationFrame(a);
    };
    return a(), () => cancelAnimationFrame(s);
  }, []);
  const n = r.flatMap(
    (s, a) => r.slice(a + 1).map((o, l) => {
      const u = o.x - s.x, c = o.y - s.y, h = Math.sqrt(u * u + c * c);
      if (h < i) {
        const d = 1 - h / i;
        return {
          x1: s.x,
          y1: s.y,
          x2: o.x,
          y2: o.y,
          opacity: d * 0.8,
          // Slightly reduce max opacity for subtler effect
          gradient: `link-gradient-${a}-${l}`,
          color1: s.color,
          color2: o.color
        };
      }
      return null;
    }).filter(Boolean)
  );
  return /* @__PURE__ */ se.jsxs("div", { style: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    alignItems: "center",
    background: "rgba(0, 0, 0, 0.9)",
    zIndex: 1e3,
    overflow: "hidden"
  }, children: [
    /* @__PURE__ */ se.jsxs("div", { style: {
      position: "relative",
      width: "400px",
      height: "400px",
      display: "flex",
      flexDirection: "column",
      alignItems: "center"
    }, children: [
      /* @__PURE__ */ se.jsxs("svg", { width: "400", height: "400", children: [
        /* @__PURE__ */ se.jsx("defs", { children: n.map((s) => /* @__PURE__ */ se.jsxs(
          "linearGradient",
          {
            id: s.gradient,
            x1: "0%",
            y1: "0%",
            x2: "100%",
            y2: "0%",
            children: [
              /* @__PURE__ */ se.jsx("stop", { offset: "0%", stopColor: s.color1, stopOpacity: s.opacity }),
              /* @__PURE__ */ se.jsx("stop", { offset: "100%", stopColor: s.color2, stopOpacity: s.opacity })
            ]
          },
          s.gradient
        )) }),
        n.map((s, a) => /* @__PURE__ */ se.jsx(
          "line",
          {
            x1: s.x1,
            y1: s.y1,
            x2: s.x2,
            y2: s.y2,
            stroke: `url(#${s.gradient})`,
            strokeWidth: "3",
            style: {
              filter: "brightness(1.5) blur(1px)"
            }
          },
          a
        ))
      ] }),
      /* @__PURE__ */ se.jsx("div", { style: {
        color: "#00fff2",
        fontSize: "40px",
        fontFamily: "sans-serif",
        letterSpacing: "-2px",
        textShadow: `
            0 0 5px #00fff2,
            0 0 10px #00fff2,
            0 0 20px #00fff2,
            0 0 40px #00fff2
          `,
        animation: "textPulse 1.5s ease-in-out infinite",
        whiteSpace: "nowrap",
        marginTop: "20px"
      }, children: "Connecting I7n Dots..." })
    ] }),
    /* @__PURE__ */ se.jsx("style", { children: `
          @keyframes textPulse {
            0% { 
              opacity: 0.5;
              transform: scale(0.98) translateY(0);
            }
            50% { 
              opacity: 1;
              transform: scale(1.02) translateY(-5px);
            }
            100% { 
              opacity: 0.5;
              transform: scale(0.98) translateY(0);
            }
          }
        ` })
  ] });
}, B5 = ({
  subjectFilter: r,
  predicateFilter: e,
  objectFilter: i,
  onFilterChange: n,
  onReset: s,
  onClose: a
}) => /* @__PURE__ */ se.jsxs(
  "div",
  {
    style: {
      display: "flex",
      flexDirection: "column",
      background: "rgba(255, 255, 255, 0.05)",
      padding: "16px 24px",
      borderRadius: "10px",
      border: "1px solid rgba(255, 255, 255, 0.1)",
      boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
      position: "relative"
    },
    children: [
      /* @__PURE__ */ se.jsx(
        "button",
        {
          onClick: a,
          style: {
            position: "absolute",
            top: 4,
            right: 6,
            background: "none",
            border: "none",
            color: "#ffd32a",
            fontSize: 20,
            cursor: "pointer",
            padding: 0,
            lineHeight: 1,
            width: 24,
            height: 24,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            zIndex: 2
          },
          "aria-label": "Close filters",
          children: "×"
        }
      ),
      /* @__PURE__ */ se.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: [
        /* @__PURE__ */ se.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ se.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Subject"
            }
          ),
          /* @__PURE__ */ se.jsx(
            "input",
            {
              type: "text",
              value: r,
              onChange: (o) => n("subject", o.target.value),
              placeholder: "Filter by subject...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ se.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ se.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Predicate"
            }
          ),
          /* @__PURE__ */ se.jsx(
            "input",
            {
              type: "text",
              value: e,
              onChange: (o) => n("predicate", o.target.value),
              placeholder: "Filter by predicate...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ se.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
          /* @__PURE__ */ se.jsx(
            "label",
            {
              style: { color: "#ffd32a", fontSize: "14px", fontWeight: "bold" },
              children: "Object"
            }
          ),
          /* @__PURE__ */ se.jsx(
            "input",
            {
              type: "text",
              value: i,
              onChange: (o) => n("object", o.target.value),
              placeholder: "Filter by object...",
              style: {
                padding: "8px 12px",
                borderRadius: "8px",
                border: "1px solid #ffd32a",
                fontSize: "14px",
                width: "200px",
                background: "#232326",
                color: "#fff",
                transition: "border-color 0.2s"
              }
            }
          )
        ] }),
        /* @__PURE__ */ se.jsx(
          "button",
          {
            style: {
              background: "#ffd32a",
              color: "#18181b",
              border: "none",
              borderRadius: "8px",
              padding: "8px 24px",
              fontSize: "14px",
              fontWeight: "bold",
              cursor: "pointer",
              textTransform: "uppercase",
              transition: "background 0.2s, transform 0.1s",
              alignSelf: "flex-start",
              marginTop: "8px",
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)"
            },
            onMouseEnter: (o) => {
              o.currentTarget.style.background = "#ffe066", o.currentTarget.style.transform = "translateY(-1px)";
            },
            onMouseLeave: (o) => {
              o.currentTarget.style.background = "#ffd32a", o.currentTarget.style.transform = "translateY(0)";
            },
            onClick: s,
            children: "Reset"
          }
        )
      ] })
    ]
  }
);
function z5(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e === 0) {
        if (Object(i) !== i) return;
        u = !1;
      } else for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function j5(r, e, i) {
  return e = K5(e), e in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function uw(r, e) {
  return H5(r) || z5(r, e) || kC(r, e) || X5();
}
function V5(r) {
  return G5(r) || W5(r) || kC(r) || q5();
}
function G5(r) {
  if (Array.isArray(r)) return Gv(r);
}
function H5(r) {
  if (Array.isArray(r)) return r;
}
function W5(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function kC(r, e) {
  if (r) {
    if (typeof r == "string") return Gv(r, e);
    var i = Object.prototype.toString.call(r).slice(8, -1);
    if (i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set") return Array.from(r);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return Gv(r, e);
  }
}
function Gv(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = new Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function q5() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function X5() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Y5(r, e) {
  if (typeof r != "object" || r === null) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function K5(r) {
  var e = Y5(r, "string");
  return typeof e == "symbol" ? e : String(e);
}
var Z5 = function(r, e) {
  var i = new Set(e);
  return Object.assign.apply(Object, [{}].concat(V5(Object.entries(r).filter(function(n) {
    var s = uw(n, 1), a = s[0];
    return !i.has(a);
  }).map(function(n) {
    var s = uw(n, 2), a = s[0], o = s[1];
    return j5({}, a, o);
  }))));
};
function Hv(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Q5(r) {
  if (Array.isArray(r)) return r;
}
function $5(r) {
  if (Array.isArray(r)) return Hv(r);
}
function J5(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function eU(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function tU() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function iU() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function rU(r, e) {
  return Q5(r) || eU(r, e) || UC(r, e) || tU();
}
function cw(r) {
  return $5(r) || J5(r) || UC(r) || iU();
}
function UC(r, e) {
  if (r) {
    if (typeof r == "string") return Hv(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Hv(r, e) : void 0;
  }
}
function gg(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = e.wrapperElementType, n = i === void 0 ? "div" : i, s = e.nodeMapper, a = s === void 0 ? function(h) {
    return h;
  } : s, o = e.methodNames, l = o === void 0 ? [] : o, u = e.initPropNames, c = u === void 0 ? [] : u;
  return /* @__PURE__ */ PO(function(h, d) {
    var p = Gi(), f = gm(function() {
      var v = Object.fromEntries(c.filter(function(g) {
        return h.hasOwnProperty(g);
      }).map(function(g) {
        return [g, h[g]];
      }));
      return r(v);
    }, []);
    hw(function() {
      f(a(p.current));
    }, OO), hw(function() {
      return f._destructor instanceof Function ? f._destructor : void 0;
    });
    var m = mr(
      function(v) {
        for (var g = arguments.length, _ = new Array(g > 1 ? g - 1 : 0), x = 1; x < g; x++)
          _[x - 1] = arguments[x];
        return f[v] instanceof Function ? f[v].apply(f, _) : void 0;
      },
      [f]
    ), y = Gi({});
    return Object.keys(Z5(h, [].concat(cw(l), cw(c)))).filter(function(v) {
      return y.current[v] !== h[v];
    }).forEach(function(v) {
      return m(v, h[v]);
    }), y.current = h, IO(d, function() {
      return Object.fromEntries(l.map(function(v) {
        return [v, function() {
          for (var g = arguments.length, _ = new Array(g), x = 0; x < g; x++)
            _[x] = arguments[x];
          return m.apply(void 0, [v].concat(_));
        }];
      }));
    }, [m]), /* @__PURE__ */ si.createElement(n, {
      ref: p
    });
  });
}
function hw(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ft, i = Gi(), n = Gi(!1), s = Gi(!1), a = ye(0), o = rU(a, 2);
  o[0];
  var l = o[1];
  n.current && (s.current = !0), e(function() {
    return n.current || (i.current = r(), n.current = !0), l(function(u) {
      return u + 1;
    }), function() {
      s.current && i.current && i.current();
    };
  }, []);
}
var Wv = { exports: {} }, dy = { exports: {} }, Yt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dw;
function nU() {
  if (dw) return Yt;
  dw = 1;
  var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, i = r ? Symbol.for("react.portal") : 60106, n = r ? Symbol.for("react.fragment") : 60107, s = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, o = r ? Symbol.for("react.provider") : 60109, l = r ? Symbol.for("react.context") : 60110, u = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, h = r ? Symbol.for("react.forward_ref") : 60112, d = r ? Symbol.for("react.suspense") : 60113, p = r ? Symbol.for("react.suspense_list") : 60120, f = r ? Symbol.for("react.memo") : 60115, m = r ? Symbol.for("react.lazy") : 60116, y = r ? Symbol.for("react.block") : 60121, v = r ? Symbol.for("react.fundamental") : 60117, g = r ? Symbol.for("react.responder") : 60118, _ = r ? Symbol.for("react.scope") : 60119;
  function x(T) {
    if (typeof T == "object" && T !== null) {
      var E = T.$$typeof;
      switch (E) {
        case e:
          switch (T = T.type, T) {
            case u:
            case c:
            case n:
            case a:
            case s:
            case d:
              return T;
            default:
              switch (T = T && T.$$typeof, T) {
                case l:
                case h:
                case m:
                case f:
                case o:
                  return T;
                default:
                  return E;
              }
          }
        case i:
          return E;
      }
    }
  }
  function b(T) {
    return x(T) === c;
  }
  return Yt.AsyncMode = u, Yt.ConcurrentMode = c, Yt.ContextConsumer = l, Yt.ContextProvider = o, Yt.Element = e, Yt.ForwardRef = h, Yt.Fragment = n, Yt.Lazy = m, Yt.Memo = f, Yt.Portal = i, Yt.Profiler = a, Yt.StrictMode = s, Yt.Suspense = d, Yt.isAsyncMode = function(T) {
    return b(T) || x(T) === u;
  }, Yt.isConcurrentMode = b, Yt.isContextConsumer = function(T) {
    return x(T) === l;
  }, Yt.isContextProvider = function(T) {
    return x(T) === o;
  }, Yt.isElement = function(T) {
    return typeof T == "object" && T !== null && T.$$typeof === e;
  }, Yt.isForwardRef = function(T) {
    return x(T) === h;
  }, Yt.isFragment = function(T) {
    return x(T) === n;
  }, Yt.isLazy = function(T) {
    return x(T) === m;
  }, Yt.isMemo = function(T) {
    return x(T) === f;
  }, Yt.isPortal = function(T) {
    return x(T) === i;
  }, Yt.isProfiler = function(T) {
    return x(T) === a;
  }, Yt.isStrictMode = function(T) {
    return x(T) === s;
  }, Yt.isSuspense = function(T) {
    return x(T) === d;
  }, Yt.isValidElementType = function(T) {
    return typeof T == "string" || typeof T == "function" || T === n || T === c || T === a || T === s || T === d || T === p || typeof T == "object" && T !== null && (T.$$typeof === m || T.$$typeof === f || T.$$typeof === o || T.$$typeof === l || T.$$typeof === h || T.$$typeof === v || T.$$typeof === g || T.$$typeof === _ || T.$$typeof === y);
  }, Yt.typeOf = x, Yt;
}
var $t = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pw;
function sU() {
  return pw || (pw = 1, process.env.NODE_ENV !== "production" && function() {
    var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, i = r ? Symbol.for("react.portal") : 60106, n = r ? Symbol.for("react.fragment") : 60107, s = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, o = r ? Symbol.for("react.provider") : 60109, l = r ? Symbol.for("react.context") : 60110, u = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, h = r ? Symbol.for("react.forward_ref") : 60112, d = r ? Symbol.for("react.suspense") : 60113, p = r ? Symbol.for("react.suspense_list") : 60120, f = r ? Symbol.for("react.memo") : 60115, m = r ? Symbol.for("react.lazy") : 60116, y = r ? Symbol.for("react.block") : 60121, v = r ? Symbol.for("react.fundamental") : 60117, g = r ? Symbol.for("react.responder") : 60118, _ = r ? Symbol.for("react.scope") : 60119;
    function x(fe) {
      return typeof fe == "string" || typeof fe == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      fe === n || fe === c || fe === a || fe === s || fe === d || fe === p || typeof fe == "object" && fe !== null && (fe.$$typeof === m || fe.$$typeof === f || fe.$$typeof === o || fe.$$typeof === l || fe.$$typeof === h || fe.$$typeof === v || fe.$$typeof === g || fe.$$typeof === _ || fe.$$typeof === y);
    }
    function b(fe) {
      if (typeof fe == "object" && fe !== null) {
        var gt = fe.$$typeof;
        switch (gt) {
          case e:
            var Q = fe.type;
            switch (Q) {
              case u:
              case c:
              case n:
              case a:
              case s:
              case d:
                return Q;
              default:
                var Gt = Q && Q.$$typeof;
                switch (Gt) {
                  case l:
                  case h:
                  case m:
                  case f:
                  case o:
                    return Gt;
                  default:
                    return gt;
                }
            }
          case i:
            return gt;
        }
      }
    }
    var T = u, E = c, M = l, C = o, S = e, w = h, R = n, O = m, P = f, A = i, D = a, L = s, H = d, V = !1;
    function X(fe) {
      return V || (V = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), F(fe) || b(fe) === u;
    }
    function F(fe) {
      return b(fe) === c;
    }
    function B(fe) {
      return b(fe) === l;
    }
    function W(fe) {
      return b(fe) === o;
    }
    function G(fe) {
      return typeof fe == "object" && fe !== null && fe.$$typeof === e;
    }
    function z(fe) {
      return b(fe) === h;
    }
    function K(fe) {
      return b(fe) === n;
    }
    function ne(fe) {
      return b(fe) === m;
    }
    function oe(fe) {
      return b(fe) === f;
    }
    function pe(fe) {
      return b(fe) === i;
    }
    function xe(fe) {
      return b(fe) === a;
    }
    function Re(fe) {
      return b(fe) === s;
    }
    function nt(fe) {
      return b(fe) === d;
    }
    $t.AsyncMode = T, $t.ConcurrentMode = E, $t.ContextConsumer = M, $t.ContextProvider = C, $t.Element = S, $t.ForwardRef = w, $t.Fragment = R, $t.Lazy = O, $t.Memo = P, $t.Portal = A, $t.Profiler = D, $t.StrictMode = L, $t.Suspense = H, $t.isAsyncMode = X, $t.isConcurrentMode = F, $t.isContextConsumer = B, $t.isContextProvider = W, $t.isElement = G, $t.isForwardRef = z, $t.isFragment = K, $t.isLazy = ne, $t.isMemo = oe, $t.isPortal = pe, $t.isProfiler = xe, $t.isStrictMode = Re, $t.isSuspense = nt, $t.isValidElementType = x, $t.typeOf = b;
  }()), $t;
}
var fw;
function FC() {
  return fw || (fw = 1, process.env.NODE_ENV === "production" ? dy.exports = nU() : dy.exports = sU()), dy.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var py, mw;
function aU() {
  if (mw) return py;
  mw = 1;
  var r = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, i = Object.prototype.propertyIsEnumerable;
  function n(a) {
    if (a == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(a);
  }
  function s() {
    try {
      if (!Object.assign)
        return !1;
      var a = new String("abc");
      if (a[5] = "de", Object.getOwnPropertyNames(a)[0] === "5")
        return !1;
      for (var o = {}, l = 0; l < 10; l++)
        o["_" + String.fromCharCode(l)] = l;
      var u = Object.getOwnPropertyNames(o).map(function(h) {
        return o[h];
      });
      if (u.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(h) {
        c[h] = h;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return py = s() ? Object.assign : function(a, o) {
    for (var l, u = n(a), c, h = 1; h < arguments.length; h++) {
      l = Object(arguments[h]);
      for (var d in l)
        e.call(l, d) && (u[d] = l[d]);
      if (r) {
        c = r(l);
        for (var p = 0; p < c.length; p++)
          i.call(l, c[p]) && (u[c[p]] = l[c[p]]);
      }
    }
    return u;
  }, py;
}
var fy, gw;
function T_() {
  if (gw) return fy;
  gw = 1;
  var r = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return fy = r, fy;
}
var yw, vw;
function BC() {
  return vw || (vw = 1, yw = Function.call.bind(Object.prototype.hasOwnProperty)), yw;
}
var my, bw;
function oU() {
  if (bw) return my;
  bw = 1;
  var r = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = T_(), i = {}, n = BC();
    r = function(a) {
      var o = "Warning: " + a;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function s(a, o, l, u, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var h in a)
        if (n(a, h)) {
          var d;
          try {
            if (typeof a[h] != "function") {
              var p = Error(
                (u || "React class") + ": " + l + " type `" + h + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[h] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = a[h](o, h, u, l, null, e);
          } catch (m) {
            d = m;
          }
          if (d && !(d instanceof Error) && r(
            (u || "React class") + ": type specification of " + l + " `" + h + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in i)) {
            i[d.message] = !0;
            var f = c ? c() : "";
            r(
              "Failed " + l + " type: " + d.message + (f ?? "")
            );
          }
        }
    }
  }
  return s.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (i = {});
  }, my = s, my;
}
var gy, xw;
function lU() {
  if (xw) return gy;
  xw = 1;
  var r = FC(), e = aU(), i = T_(), n = BC(), s = oU(), a = function() {
  };
  process.env.NODE_ENV !== "production" && (a = function(l) {
    var u = "Warning: " + l;
    typeof console < "u" && console.error(u);
    try {
      throw new Error(u);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return gy = function(l, u) {
    var c = typeof Symbol == "function" && Symbol.iterator, h = "@@iterator";
    function d(F) {
      var B = F && (c && F[c] || F[h]);
      if (typeof B == "function")
        return B;
    }
    var p = "<<anonymous>>", f = {
      array: g("array"),
      bigint: g("bigint"),
      bool: g("boolean"),
      func: g("function"),
      number: g("number"),
      object: g("object"),
      string: g("string"),
      symbol: g("symbol"),
      any: _(),
      arrayOf: x,
      element: b(),
      elementType: T(),
      instanceOf: E,
      node: w(),
      objectOf: C,
      oneOf: M,
      oneOfType: S,
      shape: O,
      exact: P
    };
    function m(F, B) {
      return F === B ? F !== 0 || 1 / F === 1 / B : F !== F && B !== B;
    }
    function y(F, B) {
      this.message = F, this.data = B && typeof B == "object" ? B : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function v(F) {
      if (process.env.NODE_ENV !== "production")
        var B = {}, W = 0;
      function G(K, ne, oe, pe, xe, Re, nt) {
        if (pe = pe || p, Re = Re || oe, nt !== i) {
          if (u) {
            var fe = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw fe.name = "Invariant Violation", fe;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var gt = pe + ":" + oe;
            !B[gt] && // Avoid spamming the console because they are often not actionable except for lib authors
            W < 3 && (a(
              "You are manually calling a React.PropTypes validation function for the `" + Re + "` prop on `" + pe + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), B[gt] = !0, W++);
          }
        }
        return ne[oe] == null ? K ? ne[oe] === null ? new y("The " + xe + " `" + Re + "` is marked as required " + ("in `" + pe + "`, but its value is `null`.")) : new y("The " + xe + " `" + Re + "` is marked as required in " + ("`" + pe + "`, but its value is `undefined`.")) : null : F(ne, oe, pe, xe, Re);
      }
      var z = G.bind(null, !1);
      return z.isRequired = G.bind(null, !0), z;
    }
    function g(F) {
      function B(W, G, z, K, ne, oe) {
        var pe = W[G], xe = L(pe);
        if (xe !== F) {
          var Re = H(pe);
          return new y(
            "Invalid " + K + " `" + ne + "` of type " + ("`" + Re + "` supplied to `" + z + "`, expected ") + ("`" + F + "`."),
            { expectedType: F }
          );
        }
        return null;
      }
      return v(B);
    }
    function _() {
      return v(o);
    }
    function x(F) {
      function B(W, G, z, K, ne) {
        if (typeof F != "function")
          return new y("Property `" + ne + "` of component `" + z + "` has invalid PropType notation inside arrayOf.");
        var oe = W[G];
        if (!Array.isArray(oe)) {
          var pe = L(oe);
          return new y("Invalid " + K + " `" + ne + "` of type " + ("`" + pe + "` supplied to `" + z + "`, expected an array."));
        }
        for (var xe = 0; xe < oe.length; xe++) {
          var Re = F(oe, xe, z, K, ne + "[" + xe + "]", i);
          if (Re instanceof Error)
            return Re;
        }
        return null;
      }
      return v(B);
    }
    function b() {
      function F(B, W, G, z, K) {
        var ne = B[W];
        if (!l(ne)) {
          var oe = L(ne);
          return new y("Invalid " + z + " `" + K + "` of type " + ("`" + oe + "` supplied to `" + G + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(F);
    }
    function T() {
      function F(B, W, G, z, K) {
        var ne = B[W];
        if (!r.isValidElementType(ne)) {
          var oe = L(ne);
          return new y("Invalid " + z + " `" + K + "` of type " + ("`" + oe + "` supplied to `" + G + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(F);
    }
    function E(F) {
      function B(W, G, z, K, ne) {
        if (!(W[G] instanceof F)) {
          var oe = F.name || p, pe = X(W[G]);
          return new y("Invalid " + K + " `" + ne + "` of type " + ("`" + pe + "` supplied to `" + z + "`, expected ") + ("instance of `" + oe + "`."));
        }
        return null;
      }
      return v(B);
    }
    function M(F) {
      if (!Array.isArray(F))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? a(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : a("Invalid argument supplied to oneOf, expected an array.")), o;
      function B(W, G, z, K, ne) {
        for (var oe = W[G], pe = 0; pe < F.length; pe++)
          if (m(oe, F[pe]))
            return null;
        var xe = JSON.stringify(F, function(Re, nt) {
          var fe = H(nt);
          return fe === "symbol" ? String(nt) : nt;
        });
        return new y("Invalid " + K + " `" + ne + "` of value `" + String(oe) + "` " + ("supplied to `" + z + "`, expected one of " + xe + "."));
      }
      return v(B);
    }
    function C(F) {
      function B(W, G, z, K, ne) {
        if (typeof F != "function")
          return new y("Property `" + ne + "` of component `" + z + "` has invalid PropType notation inside objectOf.");
        var oe = W[G], pe = L(oe);
        if (pe !== "object")
          return new y("Invalid " + K + " `" + ne + "` of type " + ("`" + pe + "` supplied to `" + z + "`, expected an object."));
        for (var xe in oe)
          if (n(oe, xe)) {
            var Re = F(oe, xe, z, K, ne + "." + xe, i);
            if (Re instanceof Error)
              return Re;
          }
        return null;
      }
      return v(B);
    }
    function S(F) {
      if (!Array.isArray(F))
        return process.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var B = 0; B < F.length; B++) {
        var W = F[B];
        if (typeof W != "function")
          return a(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + V(W) + " at index " + B + "."
          ), o;
      }
      function G(z, K, ne, oe, pe) {
        for (var xe = [], Re = 0; Re < F.length; Re++) {
          var nt = F[Re], fe = nt(z, K, ne, oe, pe, i);
          if (fe == null)
            return null;
          fe.data && n(fe.data, "expectedType") && xe.push(fe.data.expectedType);
        }
        var gt = xe.length > 0 ? ", expected one of type [" + xe.join(", ") + "]" : "";
        return new y("Invalid " + oe + " `" + pe + "` supplied to " + ("`" + ne + "`" + gt + "."));
      }
      return v(G);
    }
    function w() {
      function F(B, W, G, z, K) {
        return A(B[W]) ? null : new y("Invalid " + z + " `" + K + "` supplied to " + ("`" + G + "`, expected a ReactNode."));
      }
      return v(F);
    }
    function R(F, B, W, G, z) {
      return new y(
        (F || "React class") + ": " + B + " type `" + W + "." + G + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + z + "`."
      );
    }
    function O(F) {
      function B(W, G, z, K, ne) {
        var oe = W[G], pe = L(oe);
        if (pe !== "object")
          return new y("Invalid " + K + " `" + ne + "` of type `" + pe + "` " + ("supplied to `" + z + "`, expected `object`."));
        for (var xe in F) {
          var Re = F[xe];
          if (typeof Re != "function")
            return R(z, K, ne, xe, H(Re));
          var nt = Re(oe, xe, z, K, ne + "." + xe, i);
          if (nt)
            return nt;
        }
        return null;
      }
      return v(B);
    }
    function P(F) {
      function B(W, G, z, K, ne) {
        var oe = W[G], pe = L(oe);
        if (pe !== "object")
          return new y("Invalid " + K + " `" + ne + "` of type `" + pe + "` " + ("supplied to `" + z + "`, expected `object`."));
        var xe = e({}, W[G], F);
        for (var Re in xe) {
          var nt = F[Re];
          if (n(F, Re) && typeof nt != "function")
            return R(z, K, ne, Re, H(nt));
          if (!nt)
            return new y(
              "Invalid " + K + " `" + ne + "` key `" + Re + "` supplied to `" + z + "`.\nBad object: " + JSON.stringify(W[G], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(F), null, "  ")
            );
          var fe = nt(oe, Re, z, K, ne + "." + Re, i);
          if (fe)
            return fe;
        }
        return null;
      }
      return v(B);
    }
    function A(F) {
      switch (typeof F) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !F;
        case "object":
          if (Array.isArray(F))
            return F.every(A);
          if (F === null || l(F))
            return !0;
          var B = d(F);
          if (B) {
            var W = B.call(F), G;
            if (B !== F.entries) {
              for (; !(G = W.next()).done; )
                if (!A(G.value))
                  return !1;
            } else
              for (; !(G = W.next()).done; ) {
                var z = G.value;
                if (z && !A(z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function D(F, B) {
      return F === "symbol" ? !0 : B ? B["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && B instanceof Symbol : !1;
    }
    function L(F) {
      var B = typeof F;
      return Array.isArray(F) ? "array" : F instanceof RegExp ? "object" : D(B, F) ? "symbol" : B;
    }
    function H(F) {
      if (typeof F > "u" || F === null)
        return "" + F;
      var B = L(F);
      if (B === "object") {
        if (F instanceof Date)
          return "date";
        if (F instanceof RegExp)
          return "regexp";
      }
      return B;
    }
    function V(F) {
      var B = H(F);
      switch (B) {
        case "array":
        case "object":
          return "an " + B;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + B;
        default:
          return B;
      }
    }
    function X(F) {
      return !F.constructor || !F.constructor.name ? p : F.constructor.name;
    }
    return f.checkPropTypes = s, f.resetWarningCache = s.resetWarningCache, f.PropTypes = f, f;
  }, gy;
}
var yy, _w;
function uU() {
  if (_w) return yy;
  _w = 1;
  var r = T_();
  function e() {
  }
  function i() {
  }
  return i.resetWarningCache = e, yy = function() {
    function n(o, l, u, c, h, d) {
      if (d !== r) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    n.isRequired = n;
    function s() {
      return n;
    }
    var a = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: s,
      element: n,
      elementType: n,
      instanceOf: s,
      node: n,
      objectOf: s,
      oneOf: s,
      oneOfType: s,
      shape: s,
      exact: s,
      checkPropTypes: i,
      resetWarningCache: e
    };
    return a.PropTypes = a, a;
  }, yy;
}
if (process.env.NODE_ENV !== "production") {
  var cU = FC(), hU = !0;
  Wv.exports = lU()(cU.isElement, hU);
} else
  Wv.exports = uU()();
var dU = Wv.exports;
const ie = /* @__PURE__ */ f_(dU);
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const yg = "170", ir = { ROTATE: 0, DOLLY: 1, PAN: 2 }, ia = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, pU = 0, Tw = 1, fU = 2, zC = 1, mU = 2, Gs = 3, fo = 0, Ar = 1, Qs = 2, la = 0, Gu = 1, ww = 2, Sw = 3, Ew = 4, gU = 5, Xo = 100, yU = 101, vU = 102, bU = 103, xU = 104, _U = 200, TU = 201, wU = 202, SU = 203, qv = 204, Xv = 205, EU = 206, MU = 207, AU = 208, CU = 209, RU = 210, NU = 211, PU = 212, IU = 213, OU = 214, Yv = 0, Kv = 1, Zv = 2, hc = 3, Qv = 4, $v = 5, Jv = 6, eb = 7, w_ = 0, DU = 1, LU = 2, oo = 0, kU = 1, UU = 2, FU = 3, BU = 4, zU = 5, jU = 6, VU = 7, jC = 300, dc = 301, pc = 302, tb = 303, ib = 304, vg = 306, rb = 1e3, il = 1001, nb = 1002, Zn = 1003, GU = 1004, hp = 1005, ds = 1006, vy = 1007, rl = 1008, ba = 1009, VC = 1010, GC = 1011, ud = 1012, S_ = 1013, xl = 1014, ra = 1015, Lc = 1016, E_ = 1017, M_ = 1018, fc = 1020, HC = 35902, WC = 1021, qC = 1022, Xn = 1023, XC = 1024, YC = 1025, Hu = 1026, mc = 1027, KC = 1028, A_ = 1029, ZC = 1030, C_ = 1031, R_ = 1033, Hf = 33776, Wf = 33777, qf = 33778, Xf = 33779, sb = 35840, ab = 35841, ob = 35842, lb = 35843, ub = 36196, cb = 37492, hb = 37496, db = 37808, pb = 37809, fb = 37810, mb = 37811, gb = 37812, yb = 37813, vb = 37814, bb = 37815, xb = 37816, _b = 37817, Tb = 37818, wb = 37819, Sb = 37820, Eb = 37821, Yf = 36492, Mb = 36494, Ab = 36495, QC = 36283, Cb = 36284, Rb = 36285, Nb = 36286, HU = 3200, WU = 3201, $C = 0, qU = 1, $a = "", sn = "srgb", kc = "srgb-linear", bg = "linear", ei = "srgb", zl = 7680, Mw = 519, XU = 512, YU = 513, KU = 514, JC = 515, ZU = 516, QU = 517, $U = 518, JU = 519, Pb = 35044, Aw = "300 es", na = 2e3, bm = 2001;
let Cl = class {
  addEventListener(r, e) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[r] === void 0 && (i[r] = []), i[r].indexOf(e) === -1 && i[r].push(e);
  }
  hasEventListener(r, e) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[r] !== void 0 && i[r].indexOf(e) !== -1;
  }
  removeEventListener(r, e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[r];
    if (i !== void 0) {
      const n = i.indexOf(e);
      n !== -1 && i.splice(n, 1);
    }
  }
  dispatchEvent(r) {
    if (this._listeners === void 0) return;
    const e = this._listeners[r.type];
    if (e !== void 0) {
      r.target = this;
      const i = e.slice(0);
      for (let n = 0, s = i.length; n < s; n++)
        i[n].call(this, r);
      r.target = null;
    }
  }
};
const lr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Cw = 1234567;
const Xh = Math.PI / 180, cd = 180 / Math.PI;
function ua() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (lr[r & 255] + lr[r >> 8 & 255] + lr[r >> 16 & 255] + lr[r >> 24 & 255] + "-" + lr[e & 255] + lr[e >> 8 & 255] + "-" + lr[e >> 16 & 15 | 64] + lr[e >> 24 & 255] + "-" + lr[i & 63 | 128] + lr[i >> 8 & 255] + "-" + lr[i >> 16 & 255] + lr[i >> 24 & 255] + lr[n & 255] + lr[n >> 8 & 255] + lr[n >> 16 & 255] + lr[n >> 24 & 255]).toLowerCase();
}
function Zi(r, e, i) {
  return Math.max(e, Math.min(i, r));
}
function N_(r, e) {
  return (r % e + e) % e;
}
function eF(r, e, i, n, s) {
  return n + (r - e) * (s - n) / (i - e);
}
function tF(r, e, i) {
  return r !== e ? (i - r) / (e - r) : 0;
}
function Yh(r, e, i) {
  return (1 - i) * r + i * e;
}
function iF(r, e, i, n) {
  return Yh(r, e, 1 - Math.exp(-i * n));
}
function rF(r, e = 1) {
  return e - Math.abs(N_(r, e * 2) - e);
}
function nF(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * (3 - 2 * r));
}
function sF(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * r * (r * (r * 6 - 15) + 10));
}
function aF(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function oF(r, e) {
  return r + Math.random() * (e - r);
}
function lF(r) {
  return r * (0.5 - Math.random());
}
function uF(r) {
  r !== void 0 && (Cw = r);
  let e = Cw += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function cF(r) {
  return r * Xh;
}
function hF(r) {
  return r * cd;
}
function dF(r) {
  return (r & r - 1) === 0 && r !== 0;
}
function pF(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function fF(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function mF(r, e, i, n, s) {
  const a = Math.cos, o = Math.sin, l = a(i / 2), u = o(i / 2), c = a((e + n) / 2), h = o((e + n) / 2), d = a((e - n) / 2), p = o((e - n) / 2), f = a((n - e) / 2), m = o((n - e) / 2);
  switch (s) {
    case "XYX":
      r.set(l * h, u * d, u * p, l * c);
      break;
    case "YZY":
      r.set(u * p, l * h, u * d, l * c);
      break;
    case "ZXZ":
      r.set(u * d, u * p, l * h, l * c);
      break;
    case "XZX":
      r.set(l * h, u * m, u * f, l * c);
      break;
    case "YXY":
      r.set(u * f, l * h, u * m, l * c);
      break;
    case "ZYZ":
      r.set(u * m, u * f, l * h, l * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function Hn(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Jt(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Ib = {
  DEG2RAD: Xh,
  RAD2DEG: cd,
  generateUUID: ua,
  clamp: Zi,
  euclideanModulo: N_,
  mapLinear: eF,
  inverseLerp: tF,
  lerp: Yh,
  damp: iF,
  pingpong: rF,
  smoothstep: nF,
  smootherstep: sF,
  randInt: aF,
  randFloat: oF,
  randFloatSpread: lF,
  seededRandom: uF,
  degToRad: cF,
  radToDeg: hF,
  isPowerOfTwo: dF,
  ceilPowerOfTwo: pF,
  floorPowerOfTwo: fF,
  setQuaternionFromProperEuler: mF,
  normalize: Jt,
  denormalize: Hn
};
let ke = class eR {
  constructor(e = 0, i = 0) {
    eR.prototype.isVector2 = !0, this.x = e, this.y = i;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, i) {
    return this.x = e, this.y = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * i + s[3] * n + s[6], this.y = s[1] * i + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(Zi(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y;
    return i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this;
  }
  rotateAround(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = this.x - e.x, o = this.y - e.y;
    return this.x = a * n - o * s + e.x, this.y = a * s + o * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}, It = class tR {
  constructor(e, i, n, s, a, o, l, u, c) {
    tR.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c);
  }
  set(e, i, n, s, a, o, l, u, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = l, h[3] = i, h[4] = a, h[5] = u, h[6] = n, h[7] = o, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrix3Column(this, 0), i.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[4],
      i[8],
      i[1],
      i[5],
      i[9],
      i[2],
      i[6],
      i[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[3], u = n[6], c = n[1], h = n[4], d = n[7], p = n[2], f = n[5], m = n[8], y = s[0], v = s[3], g = s[6], _ = s[1], x = s[4], b = s[7], T = s[2], E = s[5], M = s[8];
    return a[0] = o * y + l * _ + u * T, a[3] = o * v + l * x + u * E, a[6] = o * g + l * b + u * M, a[1] = c * y + h * _ + d * T, a[4] = c * v + h * x + d * E, a[7] = c * g + h * b + d * M, a[2] = p * y + f * _ + m * T, a[5] = p * v + f * x + m * E, a[8] = p * g + f * b + m * M, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= e, i[4] *= e, i[7] *= e, i[2] *= e, i[5] *= e, i[8] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8];
    return i * o * h - i * l * c - n * a * h + n * l * u + s * a * c - s * o * u;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = h * o - l * c, p = l * u - h * a, f = c * a - o * u, m = i * d + n * p + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const y = 1 / m;
    return e[0] = d * y, e[1] = (s * c - h * n) * y, e[2] = (l * n - s * o) * y, e[3] = p * y, e[4] = (h * i - s * u) * y, e[5] = (s * a - l * i) * y, e[6] = f * y, e[7] = (n * u - c * i) * y, e[8] = (o * i - n * a) * y, this;
  }
  transpose() {
    let e;
    const i = this.elements;
    return e = i[1], i[1] = i[3], i[3] = e, e = i[2], i[2] = i[6], i[6] = e, e = i[5], i[5] = i[7], i[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const i = this.elements;
    return e[0] = i[0], e[1] = i[3], e[2] = i[6], e[3] = i[1], e[4] = i[4], e[5] = i[7], e[6] = i[2], e[7] = i[5], e[8] = i[8], this;
  }
  setUvTransform(e, i, n, s, a, o, l) {
    const u = Math.cos(a), c = Math.sin(a);
    return this.set(
      n * u,
      n * c,
      -n * (u * o + c * l) + o + e,
      -s * c,
      s * u,
      -s * (-c * o + u * l) + l + i,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, i) {
    return this.premultiply(by.makeScale(e, i)), this;
  }
  rotate(e) {
    return this.premultiply(by.makeRotation(-e)), this;
  }
  translate(e, i) {
    return this.premultiply(by.makeTranslation(e, i)), this;
  }
  // for 2D Transforms
  makeTranslation(e, i) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      i,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      n,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i) {
    return this.set(
      e,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
const by = /* @__PURE__ */ new It();
function iR(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function hd(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function gF() {
  const r = hd("canvas");
  return r.style.display = "block", r;
}
const Rw = {};
function Uh(r) {
  r in Rw || (Rw[r] = !0, console.warn(r));
}
function yF(r, e, i) {
  return new Promise(function(n, s) {
    function a() {
      switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case r.WAIT_FAILED:
          s();
          break;
        case r.TIMEOUT_EXPIRED:
          setTimeout(a, i);
          break;
        default:
          n();
      }
    }
    setTimeout(a, i);
  });
}
function vF(r) {
  const e = r.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function bF(r) {
  const e = r.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const Ht = {
  enabled: !0,
  workingColorSpace: kc,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(r, e, i) {
    return this.enabled === !1 || e === i || !e || !i || (this.spaces[e].transfer === ei && (r.r = ca(r.r), r.g = ca(r.g), r.b = ca(r.b)), this.spaces[e].primaries !== this.spaces[i].primaries && (r.applyMatrix3(this.spaces[e].toXYZ), r.applyMatrix3(this.spaces[i].fromXYZ)), this.spaces[i].transfer === ei && (r.r = Wu(r.r), r.g = Wu(r.g), r.b = Wu(r.b))), r;
  },
  fromWorkingColorSpace: function(r, e) {
    return this.convert(r, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(r, e) {
    return this.convert(r, e, this.workingColorSpace);
  },
  getPrimaries: function(r) {
    return this.spaces[r].primaries;
  },
  getTransfer: function(r) {
    return r === $a ? bg : this.spaces[r].transfer;
  },
  getLuminanceCoefficients: function(r, e = this.workingColorSpace) {
    return r.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(r) {
    Object.assign(this.spaces, r);
  },
  // Internal APIs
  _getMatrix: function(r, e, i) {
    return r.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(r) {
    return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(r = this.workingColorSpace) {
    return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
  }
};
function ca(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Wu(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const Nw = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], Pw = [0.2126, 0.7152, 0.0722], Iw = [0.3127, 0.329], Ow = /* @__PURE__ */ new It().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), Dw = /* @__PURE__ */ new It().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
Ht.define({
  [kc]: {
    primaries: Nw,
    whitePoint: Iw,
    transfer: bg,
    toXYZ: Ow,
    fromXYZ: Dw,
    luminanceCoefficients: Pw,
    workingColorSpaceConfig: { unpackColorSpace: sn },
    outputColorSpaceConfig: { drawingBufferColorSpace: sn }
  },
  [sn]: {
    primaries: Nw,
    whitePoint: Iw,
    transfer: ei,
    toXYZ: Ow,
    fromXYZ: Dw,
    luminanceCoefficients: Pw,
    outputColorSpaceConfig: { drawingBufferColorSpace: sn }
  }
});
let jl, xF = class {
  static getDataURL(r) {
    if (/^data:/i.test(r.src) || typeof HTMLCanvasElement > "u")
      return r.src;
    let e;
    if (r instanceof HTMLCanvasElement)
      e = r;
    else {
      jl === void 0 && (jl = hd("canvas")), jl.width = r.width, jl.height = r.height;
      const i = jl.getContext("2d");
      r instanceof ImageData ? i.putImageData(r, 0, 0) : i.drawImage(r, 0, 0, r.width, r.height), e = jl;
    }
    return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", r), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
  }
  static sRGBToLinear(r) {
    if (typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap) {
      const e = hd("canvas");
      e.width = r.width, e.height = r.height;
      const i = e.getContext("2d");
      i.drawImage(r, 0, 0, r.width, r.height);
      const n = i.getImageData(0, 0, r.width, r.height), s = n.data;
      for (let a = 0; a < s.length; a++)
        s[a] = ca(s[a] / 255) * 255;
      return i.putImageData(n, 0, 0), e;
    } else if (r.data) {
      const e = r.data.slice(0);
      for (let i = 0; i < e.length; i++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[i] = Math.floor(ca(e[i] / 255) * 255) : e[i] = ca(e[i]);
      return {
        data: e,
        width: r.width,
        height: r.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), r;
  }
}, _F = 0, rR = class {
  constructor(r = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: _F++ }), this.uuid = ua(), this.data = r, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  toJSON(r) {
    const e = r === void 0 || typeof r == "string";
    if (!e && r.images[this.uuid] !== void 0)
      return r.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, n = this.data;
    if (n !== null) {
      let s;
      if (Array.isArray(n)) {
        s = [];
        for (let a = 0, o = n.length; a < o; a++)
          n[a].isDataTexture ? s.push(xy(n[a].image)) : s.push(xy(n[a]));
      } else
        s = xy(n);
      i.url = s;
    }
    return e || (r.images[this.uuid] = i), i;
  }
};
function xy(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? xF.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let TF = 0, En = class Kf extends Cl {
  constructor(e = Kf.DEFAULT_IMAGE, i = Kf.DEFAULT_MAPPING, n = il, s = il, a = ds, o = rl, l = Xn, u = ba, c = Kf.DEFAULT_ANISOTROPY, h = $a) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: TF++ }), this.uuid = ua(), this.name = "", this.source = new rR(e), this.mipmaps = [], this.mapping = i, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = a, this.minFilter = o, this.anisotropy = c, this.format = l, this.internalFormat = null, this.type = u, this.offset = new ke(0, 0), this.repeat = new ke(1, 1), this.center = new ke(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new It(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), i || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== jC) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case rb:
          e.x = e.x - Math.floor(e.x);
          break;
        case il:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case nb:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case rb:
          e.y = e.y - Math.floor(e.y);
          break;
        case il:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case nb:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
};
En.DEFAULT_IMAGE = null;
En.DEFAULT_MAPPING = jC;
En.DEFAULT_ANISOTROPY = 1;
let Fi = class nR {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    nR.prototype.isVector4 = !0, this.x = e, this.y = i, this.z = n, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, i, n, s) {
    return this.x = e, this.y = i, this.z = n, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      case 3:
        this.w = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this.w = e.w + i.w, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this.w += e.w * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this.w = e.w - i.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = this.w, o = e.elements;
    return this.x = o[0] * i + o[4] * n + o[8] * s + o[12] * a, this.y = o[1] * i + o[5] * n + o[9] * s + o[13] * a, this.z = o[2] * i + o[6] * n + o[10] * s + o[14] * a, this.w = o[3] * i + o[7] * n + o[11] * s + o[15] * a, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const i = Math.sqrt(1 - e.w * e.w);
    return i < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / i, this.y = e.y / i, this.z = e.z / i), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let i, n, s, a;
    const o = e.elements, l = o[0], u = o[4], c = o[8], h = o[1], d = o[5], p = o[9], f = o[2], m = o[6], y = o[10];
    if (Math.abs(u - h) < 0.01 && Math.abs(c - f) < 0.01 && Math.abs(p - m) < 0.01) {
      if (Math.abs(u + h) < 0.1 && Math.abs(c + f) < 0.1 && Math.abs(p + m) < 0.1 && Math.abs(l + d + y - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      i = Math.PI;
      const g = (l + 1) / 2, _ = (d + 1) / 2, x = (y + 1) / 2, b = (u + h) / 4, T = (c + f) / 4, E = (p + m) / 4;
      return g > _ && g > x ? g < 0.01 ? (n = 0, s = 0.707106781, a = 0.707106781) : (n = Math.sqrt(g), s = b / n, a = T / n) : _ > x ? _ < 0.01 ? (n = 0.707106781, s = 0, a = 0.707106781) : (s = Math.sqrt(_), n = b / s, a = E / s) : x < 0.01 ? (n = 0.707106781, s = 0.707106781, a = 0) : (a = Math.sqrt(x), n = T / a, s = E / a), this.set(n, s, a, i), this;
    }
    let v = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (h - u) * (h - u));
    return Math.abs(v) < 1e-3 && (v = 1), this.x = (m - p) / v, this.y = (c - f) / v, this.z = (h - u) / v, this.w = Math.acos((l + d + y - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this.w = i[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this.w = Math.max(e.w, Math.min(i.w, this.w)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this.w = Math.max(e, Math.min(i, this.w)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this.w += (e.w - this.w) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this.w = e.w + (i.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this.w = e[i + 3], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e[i + 3] = this.w, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this.w = e.getW(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}, wF = class extends Cl {
  constructor(r = 1, e = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = r, this.height = e, this.depth = 1, this.scissor = new Fi(0, 0, r, e), this.scissorTest = !1, this.viewport = new Fi(0, 0, r, e);
    const n = { width: r, height: e, depth: 1 };
    i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: ds,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, i);
    const s = new En(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    s.flipY = !1, s.generateMipmaps = i.generateMipmaps, s.internalFormat = i.internalFormat, this.textures = [];
    const a = i.count;
    for (let o = 0; o < a; o++)
      this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = !0;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(r) {
    this.textures[0] = r;
  }
  setSize(r, e, i = 1) {
    if (this.width !== r || this.height !== e || this.depth !== i) {
      this.width = r, this.height = e, this.depth = i;
      for (let n = 0, s = this.textures.length; n < s; n++)
        this.textures[n].image.width = r, this.textures[n].image.height = e, this.textures[n].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, r, e), this.scissor.set(0, 0, r, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    this.width = r.width, this.height = r.height, this.depth = r.depth, this.scissor.copy(r.scissor), this.scissorTest = r.scissorTest, this.viewport.copy(r.viewport), this.textures.length = 0;
    for (let i = 0, n = r.textures.length; i < n; i++)
      this.textures[i] = r.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
    const e = Object.assign({}, r.texture.image);
    return this.texture.source = new rR(e), this.depthBuffer = r.depthBuffer, this.stencilBuffer = r.stencilBuffer, this.resolveDepthBuffer = r.resolveDepthBuffer, this.resolveStencilBuffer = r.resolveStencilBuffer, r.depthTexture !== null && (this.depthTexture = r.depthTexture.clone()), this.samples = r.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}, mo = class extends wF {
  constructor(r = 1, e = 1, i = {}) {
    super(r, e, i), this.isWebGLRenderTarget = !0;
  }
}, sR = class extends En {
  constructor(r = null, e = 1, i = 1, n = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: r, width: e, height: i, depth: n }, this.magFilter = Zn, this.minFilter = Zn, this.wrapR = il, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(r) {
    this.layerUpdates.add(r);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
};
class SF extends En {
  constructor(e = null, i = 1, n = 1, s = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: i, height: n, depth: s }, this.magFilter = Zn, this.minFilter = Zn, this.wrapR = il, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
let bs = class {
  constructor(r = 0, e = 0, i = 0, n = 1) {
    this.isQuaternion = !0, this._x = r, this._y = e, this._z = i, this._w = n;
  }
  static slerpFlat(r, e, i, n, s, a, o) {
    let l = i[n + 0], u = i[n + 1], c = i[n + 2], h = i[n + 3];
    const d = s[a + 0], p = s[a + 1], f = s[a + 2], m = s[a + 3];
    if (o === 0) {
      r[e + 0] = l, r[e + 1] = u, r[e + 2] = c, r[e + 3] = h;
      return;
    }
    if (o === 1) {
      r[e + 0] = d, r[e + 1] = p, r[e + 2] = f, r[e + 3] = m;
      return;
    }
    if (h !== m || l !== d || u !== p || c !== f) {
      let y = 1 - o;
      const v = l * d + u * p + c * f + h * m, g = v >= 0 ? 1 : -1, _ = 1 - v * v;
      if (_ > Number.EPSILON) {
        const b = Math.sqrt(_), T = Math.atan2(b, v * g);
        y = Math.sin(y * T) / b, o = Math.sin(o * T) / b;
      }
      const x = o * g;
      if (l = l * y + d * x, u = u * y + p * x, c = c * y + f * x, h = h * y + m * x, y === 1 - o) {
        const b = 1 / Math.sqrt(l * l + u * u + c * c + h * h);
        l *= b, u *= b, c *= b, h *= b;
      }
    }
    r[e] = l, r[e + 1] = u, r[e + 2] = c, r[e + 3] = h;
  }
  static multiplyQuaternionsFlat(r, e, i, n, s, a) {
    const o = i[n], l = i[n + 1], u = i[n + 2], c = i[n + 3], h = s[a], d = s[a + 1], p = s[a + 2], f = s[a + 3];
    return r[e] = o * f + c * h + l * p - u * d, r[e + 1] = l * f + c * d + u * h - o * p, r[e + 2] = u * f + c * p + o * d - l * h, r[e + 3] = c * f - o * h - l * d - u * p, r;
  }
  get x() {
    return this._x;
  }
  set x(r) {
    this._x = r, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(r) {
    this._y = r, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(r) {
    this._z = r, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(r) {
    this._w = r, this._onChangeCallback();
  }
  set(r, e, i, n) {
    return this._x = r, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(r) {
    return this._x = r.x, this._y = r.y, this._z = r.z, this._w = r.w, this._onChangeCallback(), this;
  }
  setFromEuler(r, e = !0) {
    const i = r._x, n = r._y, s = r._z, a = r._order, o = Math.cos, l = Math.sin, u = o(i / 2), c = o(n / 2), h = o(s / 2), d = l(i / 2), p = l(n / 2), f = l(s / 2);
    switch (a) {
      case "XYZ":
        this._x = d * c * h + u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "YXZ":
        this._x = d * c * h + u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h + d * p * f;
        break;
      case "ZXY":
        this._x = d * c * h - u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "ZYX":
        this._x = d * c * h - u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h + d * p * f;
        break;
      case "YZX":
        this._x = d * c * h + u * p * f, this._y = u * p * h + d * c * f, this._z = u * c * f - d * p * h, this._w = u * c * h - d * p * f;
        break;
      case "XZY":
        this._x = d * c * h - u * p * f, this._y = u * p * h - d * c * f, this._z = u * c * f + d * p * h, this._w = u * c * h + d * p * f;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(r, e) {
    const i = e / 2, n = Math.sin(i);
    return this._x = r.x * n, this._y = r.y * n, this._z = r.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(r) {
    const e = r.elements, i = e[0], n = e[4], s = e[8], a = e[1], o = e[5], l = e[9], u = e[2], c = e[6], h = e[10], d = i + o + h;
    if (d > 0) {
      const p = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / p, this._x = (c - l) * p, this._y = (s - u) * p, this._z = (a - n) * p;
    } else if (i > o && i > h) {
      const p = 2 * Math.sqrt(1 + i - o - h);
      this._w = (c - l) / p, this._x = 0.25 * p, this._y = (n + a) / p, this._z = (s + u) / p;
    } else if (o > h) {
      const p = 2 * Math.sqrt(1 + o - i - h);
      this._w = (s - u) / p, this._x = (n + a) / p, this._y = 0.25 * p, this._z = (l + c) / p;
    } else {
      const p = 2 * Math.sqrt(1 + h - i - o);
      this._w = (a - n) / p, this._x = (s + u) / p, this._y = (l + c) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(r, e) {
    let i = r.dot(e) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(r.x) > Math.abs(r.z) ? (this._x = -r.y, this._y = r.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -r.z, this._z = r.y, this._w = i)) : (this._x = r.y * e.z - r.z * e.y, this._y = r.z * e.x - r.x * e.z, this._z = r.x * e.y - r.y * e.x, this._w = i), this.normalize();
  }
  angleTo(r) {
    return 2 * Math.acos(Math.abs(Zi(this.dot(r), -1, 1)));
  }
  rotateTowards(r, e) {
    const i = this.angleTo(r);
    if (i === 0) return this;
    const n = Math.min(1, e / i);
    return this.slerp(r, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(r) {
    return this._x * r._x + this._y * r._y + this._z * r._z + this._w * r._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let r = this.length();
    return r === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (r = 1 / r, this._x = this._x * r, this._y = this._y * r, this._z = this._z * r, this._w = this._w * r), this._onChangeCallback(), this;
  }
  multiply(r) {
    return this.multiplyQuaternions(this, r);
  }
  premultiply(r) {
    return this.multiplyQuaternions(r, this);
  }
  multiplyQuaternions(r, e) {
    const i = r._x, n = r._y, s = r._z, a = r._w, o = e._x, l = e._y, u = e._z, c = e._w;
    return this._x = i * c + a * o + n * u - s * l, this._y = n * c + a * l + s * o - i * u, this._z = s * c + a * u + i * l - n * o, this._w = a * c - i * o - n * l - s * u, this._onChangeCallback(), this;
  }
  slerp(r, e) {
    if (e === 0) return this;
    if (e === 1) return this.copy(r);
    const i = this._x, n = this._y, s = this._z, a = this._w;
    let o = a * r._w + i * r._x + n * r._y + s * r._z;
    if (o < 0 ? (this._w = -r._w, this._x = -r._x, this._y = -r._y, this._z = -r._z, o = -o) : this.copy(r), o >= 1)
      return this._w = a, this._x = i, this._y = n, this._z = s, this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const p = 1 - e;
      return this._w = p * a + e * this._w, this._x = p * i + e * this._x, this._y = p * n + e * this._y, this._z = p * s + e * this._z, this.normalize(), this;
    }
    const u = Math.sqrt(l), c = Math.atan2(u, o), h = Math.sin((1 - e) * c) / u, d = Math.sin(e * c) / u;
    return this._w = a * h + this._w * d, this._x = i * h + this._x * d, this._y = n * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(r, e, i) {
    return this.copy(r).slerp(e, i);
  }
  random() {
    const r = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), s = Math.sqrt(i);
    return this.set(
      n * Math.sin(r),
      n * Math.cos(r),
      s * Math.sin(e),
      s * Math.cos(e)
    );
  }
  equals(r) {
    return r._x === this._x && r._y === this._y && r._z === this._z && r._w === this._w;
  }
  fromArray(r, e = 0) {
    return this._x = r[e], this._y = r[e + 1], this._z = r[e + 2], this._w = r[e + 3], this._onChangeCallback(), this;
  }
  toArray(r = [], e = 0) {
    return r[e] = this._x, r[e + 1] = this._y, r[e + 2] = this._z, r[e + 3] = this._w, r;
  }
  fromBufferAttribute(r, e) {
    return this._x = r.getX(e), this._y = r.getY(e), this._z = r.getZ(e), this._w = r.getW(e), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(r) {
    return this._onChangeCallback = r, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}, Y = class aR {
  constructor(e = 0, i = 0, n = 0) {
    aR.prototype.isVector3 = !0, this.x = e, this.y = i, this.z = n;
  }
  set(e, i, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = i, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, i) {
    return this.x = e.x * i.x, this.y = e.y * i.y, this.z = e.z * i.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Lw.setFromEuler(e));
  }
  applyAxisAngle(e, i) {
    return this.applyQuaternion(Lw.setFromAxisAngle(e, i));
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[3] * n + a[6] * s, this.y = a[1] * i + a[4] * n + a[7] * s, this.z = a[2] * i + a[5] * n + a[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements, o = 1 / (a[3] * i + a[7] * n + a[11] * s + a[15]);
    return this.x = (a[0] * i + a[4] * n + a[8] * s + a[12]) * o, this.y = (a[1] * i + a[5] * n + a[9] * s + a[13]) * o, this.z = (a[2] * i + a[6] * n + a[10] * s + a[14]) * o, this;
  }
  applyQuaternion(e) {
    const i = this.x, n = this.y, s = this.z, a = e.x, o = e.y, l = e.z, u = e.w, c = 2 * (o * s - l * n), h = 2 * (l * i - a * s), d = 2 * (a * n - o * i);
    return this.x = i + u * c + o * d - l * h, this.y = n + u * h + l * c - a * d, this.z = s + u * d + a * h - o * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[4] * n + a[8] * s, this.y = a[1] * i + a[5] * n + a[9] * s, this.z = a[2] * i + a[6] * n + a[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, i) {
    const n = e.x, s = e.y, a = e.z, o = i.x, l = i.y, u = i.z;
    return this.x = s * u - a * l, this.y = a * o - n * u, this.z = n * l - s * o, this;
  }
  projectOnVector(e) {
    const i = e.lengthSq();
    if (i === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / i;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return _y.copy(this).projectOnVector(e), this.sub(_y);
  }
  reflect(e) {
    return this.sub(_y.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(Zi(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
    return i * i + n * n + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, i, n) {
    const s = Math.sin(i) * e;
    return this.x = s * Math.sin(n), this.y = Math.cos(i) * e, this.z = s * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, i, n) {
    return this.x = e * Math.sin(i), this.y = n, this.z = e * Math.cos(i), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this;
  }
  setFromMatrixScale(e) {
    const i = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = i, this.y = n, this.z = s, this;
  }
  setFromMatrixColumn(e, i) {
    return this.fromArray(e.elements, i * 4);
  }
  setFromMatrix3Column(e, i) {
    return this.fromArray(e.elements, i * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, i = Math.random() * 2 - 1, n = Math.sqrt(1 - i * i);
    return this.x = n * Math.cos(e), this.y = i, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
};
const _y = /* @__PURE__ */ new Y(), Lw = /* @__PURE__ */ new bs();
let Rl = class {
  constructor(r = new Y(1 / 0, 1 / 0, 1 / 0), e = new Y(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = r, this.max = e;
  }
  set(r, e) {
    return this.min.copy(r), this.max.copy(e), this;
  }
  setFromArray(r) {
    this.makeEmpty();
    for (let e = 0, i = r.length; e < i; e += 3)
      this.expandByPoint(Rn.fromArray(r, e));
    return this;
  }
  setFromBufferAttribute(r) {
    this.makeEmpty();
    for (let e = 0, i = r.count; e < i; e++)
      this.expandByPoint(Rn.fromBufferAttribute(r, e));
    return this;
  }
  setFromPoints(r) {
    this.makeEmpty();
    for (let e = 0, i = r.length; e < i; e++)
      this.expandByPoint(r[e]);
    return this;
  }
  setFromCenterAndSize(r, e) {
    const i = Rn.copy(e).multiplyScalar(0.5);
    return this.min.copy(r).sub(i), this.max.copy(r).add(i), this;
  }
  setFromObject(r, e = !1) {
    return this.makeEmpty(), this.expandByObject(r, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    return this.min.copy(r.min), this.max.copy(r.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(r) {
    return this.isEmpty() ? r.set(0, 0, 0) : r.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(r) {
    return this.isEmpty() ? r.set(0, 0, 0) : r.subVectors(this.max, this.min);
  }
  expandByPoint(r) {
    return this.min.min(r), this.max.max(r), this;
  }
  expandByVector(r) {
    return this.min.sub(r), this.max.add(r), this;
  }
  expandByScalar(r) {
    return this.min.addScalar(-r), this.max.addScalar(r), this;
  }
  expandByObject(r, e = !1) {
    r.updateWorldMatrix(!1, !1);
    const i = r.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (e === !0 && s !== void 0 && r.isInstancedMesh !== !0)
        for (let a = 0, o = s.count; a < o; a++)
          r.isMesh === !0 ? r.getVertexPosition(a, Rn) : Rn.fromBufferAttribute(s, a), Rn.applyMatrix4(r.matrixWorld), this.expandByPoint(Rn);
      else
        r.boundingBox !== void 0 ? (r.boundingBox === null && r.computeBoundingBox(), dp.copy(r.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), dp.copy(i.boundingBox)), dp.applyMatrix4(r.matrixWorld), this.union(dp);
    }
    const n = r.children;
    for (let s = 0, a = n.length; s < a; s++)
      this.expandByObject(n[s], e);
    return this;
  }
  containsPoint(r) {
    return r.x >= this.min.x && r.x <= this.max.x && r.y >= this.min.y && r.y <= this.max.y && r.z >= this.min.z && r.z <= this.max.z;
  }
  containsBox(r) {
    return this.min.x <= r.min.x && r.max.x <= this.max.x && this.min.y <= r.min.y && r.max.y <= this.max.y && this.min.z <= r.min.z && r.max.z <= this.max.z;
  }
  getParameter(r, e) {
    return e.set(
      (r.x - this.min.x) / (this.max.x - this.min.x),
      (r.y - this.min.y) / (this.max.y - this.min.y),
      (r.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(r) {
    return r.max.x >= this.min.x && r.min.x <= this.max.x && r.max.y >= this.min.y && r.min.y <= this.max.y && r.max.z >= this.min.z && r.min.z <= this.max.z;
  }
  intersectsSphere(r) {
    return this.clampPoint(r.center, Rn), Rn.distanceToSquared(r.center) <= r.radius * r.radius;
  }
  intersectsPlane(r) {
    let e, i;
    return r.normal.x > 0 ? (e = r.normal.x * this.min.x, i = r.normal.x * this.max.x) : (e = r.normal.x * this.max.x, i = r.normal.x * this.min.x), r.normal.y > 0 ? (e += r.normal.y * this.min.y, i += r.normal.y * this.max.y) : (e += r.normal.y * this.max.y, i += r.normal.y * this.min.y), r.normal.z > 0 ? (e += r.normal.z * this.min.z, i += r.normal.z * this.max.z) : (e += r.normal.z * this.max.z, i += r.normal.z * this.min.z), e <= -r.constant && i >= -r.constant;
  }
  intersectsTriangle(r) {
    if (this.isEmpty())
      return !1;
    this.getCenter(ih), pp.subVectors(this.max, ih), Vl.subVectors(r.a, ih), Gl.subVectors(r.b, ih), Hl.subVectors(r.c, ih), Na.subVectors(Gl, Vl), Pa.subVectors(Hl, Gl), Co.subVectors(Vl, Hl);
    let e = [
      0,
      -Na.z,
      Na.y,
      0,
      -Pa.z,
      Pa.y,
      0,
      -Co.z,
      Co.y,
      Na.z,
      0,
      -Na.x,
      Pa.z,
      0,
      -Pa.x,
      Co.z,
      0,
      -Co.x,
      -Na.y,
      Na.x,
      0,
      -Pa.y,
      Pa.x,
      0,
      -Co.y,
      Co.x,
      0
    ];
    return !Ty(e, Vl, Gl, Hl, pp) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Ty(e, Vl, Gl, Hl, pp)) ? !1 : (fp.crossVectors(Na, Pa), e = [fp.x, fp.y, fp.z], Ty(e, Vl, Gl, Hl, pp));
  }
  clampPoint(r, e) {
    return e.copy(r).clamp(this.min, this.max);
  }
  distanceToPoint(r) {
    return this.clampPoint(r, Rn).distanceTo(r);
  }
  getBoundingSphere(r) {
    return this.isEmpty() ? r.makeEmpty() : (this.getCenter(r.center), r.radius = this.getSize(Rn).length() * 0.5), r;
  }
  intersect(r) {
    return this.min.max(r.min), this.max.min(r.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(r) {
    return this.min.min(r.min), this.max.max(r.max), this;
  }
  applyMatrix4(r) {
    return this.isEmpty() ? this : (As[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(r), As[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(r), As[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(r), As[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(r), As[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(r), As[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(r), As[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(r), As[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(r), this.setFromPoints(As), this);
  }
  translate(r) {
    return this.min.add(r), this.max.add(r), this;
  }
  equals(r) {
    return r.min.equals(this.min) && r.max.equals(this.max);
  }
};
const As = [
  /* @__PURE__ */ new Y(),
  /* @__PURE__ */ new Y(),
  /* @__PURE__ */ new Y(),
  /* @__PURE__ */ new Y(),
  /* @__PURE__ */ new Y(),
  /* @__PURE__ */ new Y(),
  /* @__PURE__ */ new Y(),
  /* @__PURE__ */ new Y()
], Rn = /* @__PURE__ */ new Y(), dp = /* @__PURE__ */ new Rl(), Vl = /* @__PURE__ */ new Y(), Gl = /* @__PURE__ */ new Y(), Hl = /* @__PURE__ */ new Y(), Na = /* @__PURE__ */ new Y(), Pa = /* @__PURE__ */ new Y(), Co = /* @__PURE__ */ new Y(), ih = /* @__PURE__ */ new Y(), pp = /* @__PURE__ */ new Y(), fp = /* @__PURE__ */ new Y(), Ro = /* @__PURE__ */ new Y();
function Ty(r, e, i, n, s) {
  for (let a = 0, o = r.length - 3; a <= o; a += 3) {
    Ro.fromArray(r, a);
    const l = s.x * Math.abs(Ro.x) + s.y * Math.abs(Ro.y) + s.z * Math.abs(Ro.z), u = e.dot(Ro), c = i.dot(Ro), h = n.dot(Ro);
    if (Math.max(-Math.max(u, c, h), Math.min(u, c, h)) > l)
      return !1;
  }
  return !0;
}
const EF = /* @__PURE__ */ new Rl(), rh = /* @__PURE__ */ new Y(), wy = /* @__PURE__ */ new Y();
let xg = class {
  constructor(r = new Y(), e = -1) {
    this.isSphere = !0, this.center = r, this.radius = e;
  }
  set(r, e) {
    return this.center.copy(r), this.radius = e, this;
  }
  setFromPoints(r, e) {
    const i = this.center;
    e !== void 0 ? i.copy(e) : EF.setFromPoints(r).getCenter(i);
    let n = 0;
    for (let s = 0, a = r.length; s < a; s++)
      n = Math.max(n, i.distanceToSquared(r[s]));
    return this.radius = Math.sqrt(n), this;
  }
  copy(r) {
    return this.center.copy(r.center), this.radius = r.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(r) {
    return r.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(r) {
    return r.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(r) {
    const e = this.radius + r.radius;
    return r.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(r) {
    return r.intersectsSphere(this);
  }
  intersectsPlane(r) {
    return Math.abs(r.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(r, e) {
    const i = this.center.distanceToSquared(r);
    return e.copy(r), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  }
  getBoundingBox(r) {
    return this.isEmpty() ? (r.makeEmpty(), r) : (r.set(this.center, this.center), r.expandByScalar(this.radius), r);
  }
  applyMatrix4(r) {
    return this.center.applyMatrix4(r), this.radius = this.radius * r.getMaxScaleOnAxis(), this;
  }
  translate(r) {
    return this.center.add(r), this;
  }
  expandByPoint(r) {
    if (this.isEmpty())
      return this.center.copy(r), this.radius = 0, this;
    rh.subVectors(r, this.center);
    const e = rh.lengthSq();
    if (e > this.radius * this.radius) {
      const i = Math.sqrt(e), n = (i - this.radius) * 0.5;
      this.center.addScaledVector(rh, n / i), this.radius += n;
    }
    return this;
  }
  union(r) {
    return r.isEmpty() ? this : this.isEmpty() ? (this.copy(r), this) : (this.center.equals(r.center) === !0 ? this.radius = Math.max(this.radius, r.radius) : (wy.subVectors(r.center, this.center).setLength(r.radius), this.expandByPoint(rh.copy(r.center).add(wy)), this.expandByPoint(rh.copy(r.center).sub(wy))), this);
  }
  equals(r) {
    return r.center.equals(this.center) && r.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const Cs = /* @__PURE__ */ new Y(), Sy = /* @__PURE__ */ new Y(), mp = /* @__PURE__ */ new Y(), Ia = /* @__PURE__ */ new Y(), Ey = /* @__PURE__ */ new Y(), gp = /* @__PURE__ */ new Y(), My = /* @__PURE__ */ new Y();
let _g = class {
  constructor(r = new Y(), e = new Y(0, 0, -1)) {
    this.origin = r, this.direction = e;
  }
  set(r, e) {
    return this.origin.copy(r), this.direction.copy(e), this;
  }
  copy(r) {
    return this.origin.copy(r.origin), this.direction.copy(r.direction), this;
  }
  at(r, e) {
    return e.copy(this.origin).addScaledVector(this.direction, r);
  }
  lookAt(r) {
    return this.direction.copy(r).sub(this.origin).normalize(), this;
  }
  recast(r) {
    return this.origin.copy(this.at(r, Cs)), this;
  }
  closestPointToPoint(r, e) {
    e.subVectors(r, this.origin);
    const i = e.dot(this.direction);
    return i < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(r) {
    return Math.sqrt(this.distanceSqToPoint(r));
  }
  distanceSqToPoint(r) {
    const e = Cs.subVectors(r, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(r) : (Cs.copy(this.origin).addScaledVector(this.direction, e), Cs.distanceToSquared(r));
  }
  distanceSqToSegment(r, e, i, n) {
    Sy.copy(r).add(e).multiplyScalar(0.5), mp.copy(e).sub(r).normalize(), Ia.copy(this.origin).sub(Sy);
    const s = r.distanceTo(e) * 0.5, a = -this.direction.dot(mp), o = Ia.dot(this.direction), l = -Ia.dot(mp), u = Ia.lengthSq(), c = Math.abs(1 - a * a);
    let h, d, p, f;
    if (c > 0)
      if (h = a * l - o, d = a * o - l, f = s * c, h >= 0)
        if (d >= -f)
          if (d <= f) {
            const m = 1 / c;
            h *= m, d *= m, p = h * (h + a * d + 2 * o) + d * (a * h + d + 2 * l) + u;
          } else
            d = s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
        else
          d = -s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
      else
        d <= -f ? (h = Math.max(0, -(-a * s + o)), d = h > 0 ? -s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + u) : d <= f ? (h = 0, d = Math.min(Math.max(-s, -l), s), p = d * (d + 2 * l) + u) : (h = Math.max(0, -(a * s + o)), d = h > 0 ? s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + u);
    else
      d = a > 0 ? -s : s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + u;
    return i && i.copy(this.origin).addScaledVector(this.direction, h), n && n.copy(Sy).addScaledVector(mp, d), p;
  }
  intersectSphere(r, e) {
    Cs.subVectors(r.center, this.origin);
    const i = Cs.dot(this.direction), n = Cs.dot(Cs) - i * i, s = r.radius * r.radius;
    if (n > s) return null;
    const a = Math.sqrt(s - n), o = i - a, l = i + a;
    return l < 0 ? null : o < 0 ? this.at(l, e) : this.at(o, e);
  }
  intersectsSphere(r) {
    return this.distanceSqToPoint(r.center) <= r.radius * r.radius;
  }
  distanceToPlane(r) {
    const e = r.normal.dot(this.direction);
    if (e === 0)
      return r.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(r.normal) + r.constant) / e;
    return i >= 0 ? i : null;
  }
  intersectPlane(r, e) {
    const i = this.distanceToPlane(r);
    return i === null ? null : this.at(i, e);
  }
  intersectsPlane(r) {
    const e = r.distanceToPoint(this.origin);
    return e === 0 || r.normal.dot(this.direction) * e < 0;
  }
  intersectBox(r, e) {
    let i, n, s, a, o, l;
    const u = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin;
    return u >= 0 ? (i = (r.min.x - d.x) * u, n = (r.max.x - d.x) * u) : (i = (r.max.x - d.x) * u, n = (r.min.x - d.x) * u), c >= 0 ? (s = (r.min.y - d.y) * c, a = (r.max.y - d.y) * c) : (s = (r.max.y - d.y) * c, a = (r.min.y - d.y) * c), i > a || s > n || ((s > i || isNaN(i)) && (i = s), (a < n || isNaN(n)) && (n = a), h >= 0 ? (o = (r.min.z - d.z) * h, l = (r.max.z - d.z) * h) : (o = (r.max.z - d.z) * h, l = (r.min.z - d.z) * h), i > l || o > n) || ((o > i || i !== i) && (i = o), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(i >= 0 ? i : n, e);
  }
  intersectsBox(r) {
    return this.intersectBox(r, Cs) !== null;
  }
  intersectTriangle(r, e, i, n, s) {
    Ey.subVectors(e, r), gp.subVectors(i, r), My.crossVectors(Ey, gp);
    let a = this.direction.dot(My), o;
    if (a > 0) {
      if (n) return null;
      o = 1;
    } else if (a < 0)
      o = -1, a = -a;
    else
      return null;
    Ia.subVectors(this.origin, r);
    const l = o * this.direction.dot(gp.crossVectors(Ia, gp));
    if (l < 0)
      return null;
    const u = o * this.direction.dot(Ey.cross(Ia));
    if (u < 0 || l + u > a)
      return null;
    const c = -o * Ia.dot(My);
    return c < 0 ? null : this.at(c / a, s);
  }
  applyMatrix4(r) {
    return this.origin.applyMatrix4(r), this.direction.transformDirection(r), this;
  }
  equals(r) {
    return r.origin.equals(this.origin) && r.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}, ui = class Ob {
  constructor(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v) {
    Ob.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v);
  }
  set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v) {
    const g = this.elements;
    return g[0] = e, g[4] = i, g[8] = n, g[12] = s, g[1] = a, g[5] = o, g[9] = l, g[13] = u, g[2] = c, g[6] = h, g[10] = d, g[14] = p, g[3] = f, g[7] = m, g[11] = y, g[15] = v, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Ob().fromArray(this.elements);
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], i[9] = n[9], i[10] = n[10], i[11] = n[11], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15], this;
  }
  copyPosition(e) {
    const i = this.elements, n = e.elements;
    return i[12] = n[12], i[13] = n[13], i[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[3],
      i[6],
      0,
      i[1],
      i[4],
      i[7],
      0,
      i[2],
      i[5],
      i[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrixColumn(this, 0), i.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, i, n) {
    return this.set(
      e.x,
      i.x,
      n.x,
      0,
      e.y,
      i.y,
      n.y,
      0,
      e.z,
      i.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const i = this.elements, n = e.elements, s = 1 / Wl.setFromMatrixColumn(e, 0).length(), a = 1 / Wl.setFromMatrixColumn(e, 1).length(), o = 1 / Wl.setFromMatrixColumn(e, 2).length();
    return i[0] = n[0] * s, i[1] = n[1] * s, i[2] = n[2] * s, i[3] = 0, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[7] = 0, i[8] = n[8] * o, i[9] = n[9] * o, i[10] = n[10] * o, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z, o = Math.cos(n), l = Math.sin(n), u = Math.cos(s), c = Math.sin(s), h = Math.cos(a), d = Math.sin(a);
    if (e.order === "XYZ") {
      const p = o * h, f = o * d, m = l * h, y = l * d;
      i[0] = u * h, i[4] = -u * d, i[8] = c, i[1] = f + m * c, i[5] = p - y * c, i[9] = -l * u, i[2] = y - p * c, i[6] = m + f * c, i[10] = o * u;
    } else if (e.order === "YXZ") {
      const p = u * h, f = u * d, m = c * h, y = c * d;
      i[0] = p + y * l, i[4] = m * l - f, i[8] = o * c, i[1] = o * d, i[5] = o * h, i[9] = -l, i[2] = f * l - m, i[6] = y + p * l, i[10] = o * u;
    } else if (e.order === "ZXY") {
      const p = u * h, f = u * d, m = c * h, y = c * d;
      i[0] = p - y * l, i[4] = -o * d, i[8] = m + f * l, i[1] = f + m * l, i[5] = o * h, i[9] = y - p * l, i[2] = -o * c, i[6] = l, i[10] = o * u;
    } else if (e.order === "ZYX") {
      const p = o * h, f = o * d, m = l * h, y = l * d;
      i[0] = u * h, i[4] = m * c - f, i[8] = p * c + y, i[1] = u * d, i[5] = y * c + p, i[9] = f * c - m, i[2] = -c, i[6] = l * u, i[10] = o * u;
    } else if (e.order === "YZX") {
      const p = o * u, f = o * c, m = l * u, y = l * c;
      i[0] = u * h, i[4] = y - p * d, i[8] = m * d + f, i[1] = d, i[5] = o * h, i[9] = -l * h, i[2] = -c * h, i[6] = f * d + m, i[10] = p - y * d;
    } else if (e.order === "XZY") {
      const p = o * u, f = o * c, m = l * u, y = l * c;
      i[0] = u * h, i[4] = -d, i[8] = c * h, i[1] = p * d + y, i[5] = o * h, i[9] = f * d - m, i[2] = m * d - f, i[6] = l * h, i[10] = y * d + p;
    }
    return i[3] = 0, i[7] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(MF, e, AF);
  }
  lookAt(e, i, n) {
    const s = this.elements;
    return Zr.subVectors(e, i), Zr.lengthSq() === 0 && (Zr.z = 1), Zr.normalize(), Oa.crossVectors(n, Zr), Oa.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Zr.x += 1e-4 : Zr.z += 1e-4, Zr.normalize(), Oa.crossVectors(n, Zr)), Oa.normalize(), yp.crossVectors(Zr, Oa), s[0] = Oa.x, s[4] = yp.x, s[8] = Zr.x, s[1] = Oa.y, s[5] = yp.y, s[9] = Zr.y, s[2] = Oa.z, s[6] = yp.z, s[10] = Zr.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[4], u = n[8], c = n[12], h = n[1], d = n[5], p = n[9], f = n[13], m = n[2], y = n[6], v = n[10], g = n[14], _ = n[3], x = n[7], b = n[11], T = n[15], E = s[0], M = s[4], C = s[8], S = s[12], w = s[1], R = s[5], O = s[9], P = s[13], A = s[2], D = s[6], L = s[10], H = s[14], V = s[3], X = s[7], F = s[11], B = s[15];
    return a[0] = o * E + l * w + u * A + c * V, a[4] = o * M + l * R + u * D + c * X, a[8] = o * C + l * O + u * L + c * F, a[12] = o * S + l * P + u * H + c * B, a[1] = h * E + d * w + p * A + f * V, a[5] = h * M + d * R + p * D + f * X, a[9] = h * C + d * O + p * L + f * F, a[13] = h * S + d * P + p * H + f * B, a[2] = m * E + y * w + v * A + g * V, a[6] = m * M + y * R + v * D + g * X, a[10] = m * C + y * O + v * L + g * F, a[14] = m * S + y * P + v * H + g * B, a[3] = _ * E + x * w + b * A + T * V, a[7] = _ * M + x * R + b * D + T * X, a[11] = _ * C + x * O + b * L + T * F, a[15] = _ * S + x * P + b * H + T * B, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[4] *= e, i[8] *= e, i[12] *= e, i[1] *= e, i[5] *= e, i[9] *= e, i[13] *= e, i[2] *= e, i[6] *= e, i[10] *= e, i[14] *= e, i[3] *= e, i[7] *= e, i[11] *= e, i[15] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[4], s = e[8], a = e[12], o = e[1], l = e[5], u = e[9], c = e[13], h = e[2], d = e[6], p = e[10], f = e[14], m = e[3], y = e[7], v = e[11], g = e[15];
    return m * (+a * u * d - s * c * d - a * l * p + n * c * p + s * l * f - n * u * f) + y * (+i * u * f - i * c * p + a * o * p - s * o * f + s * c * h - a * u * h) + v * (+i * c * d - i * l * f - a * o * d + n * o * f + a * l * h - n * c * h) + g * (-s * l * h - i * u * d + i * l * p + s * o * d - n * o * p + n * u * h);
  }
  transpose() {
    const e = this.elements;
    let i;
    return i = e[1], e[1] = e[4], e[4] = i, i = e[2], e[2] = e[8], e[8] = i, i = e[6], e[6] = e[9], e[9] = i, i = e[3], e[3] = e[12], e[12] = i, i = e[7], e[7] = e[13], e[13] = i, i = e[11], e[11] = e[14], e[14] = i, this;
  }
  setPosition(e, i, n) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = i, s[14] = n), this;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = e[9], p = e[10], f = e[11], m = e[12], y = e[13], v = e[14], g = e[15], _ = d * v * c - y * p * c + y * u * f - l * v * f - d * u * g + l * p * g, x = m * p * c - h * v * c - m * u * f + o * v * f + h * u * g - o * p * g, b = h * y * c - m * d * c + m * l * f - o * y * f - h * l * g + o * d * g, T = m * d * u - h * y * u - m * l * p + o * y * p + h * l * v - o * d * v, E = i * _ + n * x + s * b + a * T;
    if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const M = 1 / E;
    return e[0] = _ * M, e[1] = (y * p * a - d * v * a - y * s * f + n * v * f + d * s * g - n * p * g) * M, e[2] = (l * v * a - y * u * a + y * s * c - n * v * c - l * s * g + n * u * g) * M, e[3] = (d * u * a - l * p * a - d * s * c + n * p * c + l * s * f - n * u * f) * M, e[4] = x * M, e[5] = (h * v * a - m * p * a + m * s * f - i * v * f - h * s * g + i * p * g) * M, e[6] = (m * u * a - o * v * a - m * s * c + i * v * c + o * s * g - i * u * g) * M, e[7] = (o * p * a - h * u * a + h * s * c - i * p * c - o * s * f + i * u * f) * M, e[8] = b * M, e[9] = (m * d * a - h * y * a - m * n * f + i * y * f + h * n * g - i * d * g) * M, e[10] = (o * y * a - m * l * a + m * n * c - i * y * c - o * n * g + i * l * g) * M, e[11] = (h * l * a - o * d * a - h * n * c + i * d * c + o * n * f - i * l * f) * M, e[12] = T * M, e[13] = (h * y * s - m * d * s + m * n * p - i * y * p - h * n * v + i * d * v) * M, e[14] = (m * l * s - o * y * s - m * n * u + i * y * u + o * n * v - i * l * v) * M, e[15] = (o * d * s - h * l * s + h * n * u - i * d * u - o * n * p + i * l * p) * M, this;
  }
  scale(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z;
    return i[0] *= n, i[4] *= s, i[8] *= a, i[1] *= n, i[5] *= s, i[9] *= a, i[2] *= n, i[6] *= s, i[10] *= a, i[3] *= n, i[7] *= s, i[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(i, n, s));
  }
  makeTranslation(e, i, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      i,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = 1 - n, o = e.x, l = e.y, u = e.z, c = a * o, h = a * l;
    return this.set(
      c * o + n,
      c * l - s * u,
      c * u + s * l,
      0,
      c * l + s * u,
      h * l + n,
      h * u - s * o,
      0,
      c * u - s * l,
      h * u + s * o,
      a * u * u + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, i, n, s, a, o) {
    return this.set(
      1,
      n,
      a,
      0,
      e,
      1,
      o,
      0,
      i,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, i, n) {
    const s = this.elements, a = i._x, o = i._y, l = i._z, u = i._w, c = a + a, h = o + o, d = l + l, p = a * c, f = a * h, m = a * d, y = o * h, v = o * d, g = l * d, _ = u * c, x = u * h, b = u * d, T = n.x, E = n.y, M = n.z;
    return s[0] = (1 - (y + g)) * T, s[1] = (f + b) * T, s[2] = (m - x) * T, s[3] = 0, s[4] = (f - b) * E, s[5] = (1 - (p + g)) * E, s[6] = (v + _) * E, s[7] = 0, s[8] = (m + x) * M, s[9] = (v - _) * M, s[10] = (1 - (p + y)) * M, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, i, n) {
    const s = this.elements;
    let a = Wl.set(s[0], s[1], s[2]).length();
    const o = Wl.set(s[4], s[5], s[6]).length(), l = Wl.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (a = -a), e.x = s[12], e.y = s[13], e.z = s[14], Nn.copy(this);
    const u = 1 / a, c = 1 / o, h = 1 / l;
    return Nn.elements[0] *= u, Nn.elements[1] *= u, Nn.elements[2] *= u, Nn.elements[4] *= c, Nn.elements[5] *= c, Nn.elements[6] *= c, Nn.elements[8] *= h, Nn.elements[9] *= h, Nn.elements[10] *= h, i.setFromRotationMatrix(Nn), n.x = a, n.y = o, n.z = l, this;
  }
  makePerspective(e, i, n, s, a, o, l = na) {
    const u = this.elements, c = 2 * a / (i - e), h = 2 * a / (n - s), d = (i + e) / (i - e), p = (n + s) / (n - s);
    let f, m;
    if (l === na)
      f = -(o + a) / (o - a), m = -2 * o * a / (o - a);
    else if (l === bm)
      f = -o / (o - a), m = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return u[0] = c, u[4] = 0, u[8] = d, u[12] = 0, u[1] = 0, u[5] = h, u[9] = p, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = f, u[14] = m, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this;
  }
  makeOrthographic(e, i, n, s, a, o, l = na) {
    const u = this.elements, c = 1 / (i - e), h = 1 / (n - s), d = 1 / (o - a), p = (i + e) * c, f = (n + s) * h;
    let m, y;
    if (l === na)
      m = (o + a) * d, y = -2 * d;
    else if (l === bm)
      m = a * d, y = -1 * d;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return u[0] = 2 * c, u[4] = 0, u[8] = 0, u[12] = -p, u[1] = 0, u[5] = 2 * h, u[9] = 0, u[13] = -f, u[2] = 0, u[6] = 0, u[10] = y, u[14] = -m, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this;
  }
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 16; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e[i + 9] = n[9], e[i + 10] = n[10], e[i + 11] = n[11], e[i + 12] = n[12], e[i + 13] = n[13], e[i + 14] = n[14], e[i + 15] = n[15], e;
  }
};
const Wl = /* @__PURE__ */ new Y(), Nn = /* @__PURE__ */ new ui(), MF = /* @__PURE__ */ new Y(0, 0, 0), AF = /* @__PURE__ */ new Y(1, 1, 1), Oa = /* @__PURE__ */ new Y(), yp = /* @__PURE__ */ new Y(), Zr = /* @__PURE__ */ new Y(), kw = /* @__PURE__ */ new ui(), Uw = /* @__PURE__ */ new bs();
let go = class oR {
  constructor(e = 0, i = 0, n = 0, s = oR.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = i, this._z = n, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, i, n, s = this._order) {
    return this._x = e, this._y = i, this._z = n, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, i = this._order, n = !0) {
    const s = e.elements, a = s[0], o = s[4], l = s[8], u = s[1], c = s[5], h = s[9], d = s[2], p = s[6], f = s[10];
    switch (i) {
      case "XYZ":
        this._y = Math.asin(Zi(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(p, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Zi(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(u, c)) : (this._y = Math.atan2(-d, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Zi(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(u, a));
        break;
      case "ZYX":
        this._y = Math.asin(-Zi(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(u, a)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin(Zi(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-d, a)) : (this._x = 0, this._y = Math.atan2(l, f));
        break;
      case "XZY":
        this._z = Math.asin(-Zi(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + i);
    }
    return this._order = i, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, i, n) {
    return kw.makeRotationFromQuaternion(e), this.setFromRotationMatrix(kw, i, n);
  }
  setFromVector3(e, i = this._order) {
    return this.set(e.x, e.y, e.z, i);
  }
  reorder(e) {
    return Uw.setFromEuler(this), this.setFromQuaternion(Uw, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
};
go.DEFAULT_ORDER = "XYZ";
let P_ = class {
  constructor() {
    this.mask = 1;
  }
  set(r) {
    this.mask = (1 << r | 0) >>> 0;
  }
  enable(r) {
    this.mask |= 1 << r | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(r) {
    this.mask ^= 1 << r | 0;
  }
  disable(r) {
    this.mask &= ~(1 << r | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(r) {
    return (this.mask & r.mask) !== 0;
  }
  isEnabled(r) {
    return (this.mask & (1 << r | 0)) !== 0;
  }
}, CF = 0;
const Fw = /* @__PURE__ */ new Y(), ql = /* @__PURE__ */ new bs(), Rs = /* @__PURE__ */ new ui(), vp = /* @__PURE__ */ new Y(), nh = /* @__PURE__ */ new Y(), RF = /* @__PURE__ */ new Y(), NF = /* @__PURE__ */ new bs(), Bw = /* @__PURE__ */ new Y(1, 0, 0), zw = /* @__PURE__ */ new Y(0, 1, 0), jw = /* @__PURE__ */ new Y(0, 0, 1), Vw = { type: "added" }, PF = { type: "removed" }, Xl = { type: "childadded", child: null }, Ay = { type: "childremoved", child: null };
let Gr = class Zf extends Cl {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: CF++ }), this.uuid = ua(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Zf.DEFAULT_UP.clone();
    const e = new Y(), i = new go(), n = new bs(), s = new Y(1, 1, 1);
    function a() {
      n.setFromEuler(i, !1);
    }
    function o() {
      i.setFromQuaternion(n, void 0, !1);
    }
    i._onChange(a), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      modelViewMatrix: {
        value: new ui()
      },
      normalMatrix: {
        value: new It()
      }
    }), this.matrix = new ui(), this.matrixWorld = new ui(), this.matrixAutoUpdate = Zf.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Zf.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new P_(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, i) {
    this.quaternion.setFromAxisAngle(e, i);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, i) {
    return ql.setFromAxisAngle(e, i), this.quaternion.multiply(ql), this;
  }
  rotateOnWorldAxis(e, i) {
    return ql.setFromAxisAngle(e, i), this.quaternion.premultiply(ql), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Bw, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(zw, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(jw, e);
  }
  translateOnAxis(e, i) {
    return Fw.copy(e).applyQuaternion(this.quaternion), this.position.add(Fw.multiplyScalar(i)), this;
  }
  translateX(e) {
    return this.translateOnAxis(Bw, e);
  }
  translateY(e) {
    return this.translateOnAxis(zw, e);
  }
  translateZ(e) {
    return this.translateOnAxis(jw, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Rs.copy(this.matrixWorld).invert());
  }
  lookAt(e, i, n) {
    e.isVector3 ? vp.copy(e) : vp.set(e, i, n);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), nh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Rs.lookAt(nh, vp, this.up) : Rs.lookAt(vp, nh, this.up), this.quaternion.setFromRotationMatrix(Rs), s && (Rs.extractRotation(s.matrixWorld), ql.setFromRotationMatrix(Rs), this.quaternion.premultiply(ql.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.add(arguments[i]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Vw), Xl.child = e, this.dispatchEvent(Xl), Xl.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const i = this.children.indexOf(e);
    return i !== -1 && (e.parent = null, this.children.splice(i, 1), e.dispatchEvent(PF), Ay.child = e, this.dispatchEvent(Ay), Ay.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Rs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Rs.multiply(e.parent.matrixWorld)), e.applyMatrix4(Rs), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Vw), Xl.child = e, this.dispatchEvent(Xl), Xl.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, i) {
    if (this[e] === i) return this;
    for (let n = 0, s = this.children.length; n < s; n++) {
      const a = this.children[n].getObjectByProperty(e, i);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, i, n = []) {
    this[e] === i && n.push(this);
    const s = this.children;
    for (let a = 0, o = s.length; a < o; a++)
      s[a].getObjectsByProperty(e, i, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nh, e, RF), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nh, NF, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const i = this.matrixWorld.elements;
    return e.set(i[8], i[9], i[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const i = this.parent;
    i !== null && (e(i), i.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, i) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), i === !0) {
      const s = this.children;
      for (let a = 0, o = s.length; a < o; a++)
        s[a].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string", n = {};
    i && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
      center: s.boundingSphere.center.toArray(),
      radius: s.boundingSphere.radius
    }), this.boundingBox !== null && (s.boundingBox = {
      min: s.boundingBox.min.toArray(),
      max: s.boundingBox.max.toArray()
    }));
    function a(l, u) {
      return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = a(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const u = l.shapes;
        if (Array.isArray(u))
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c];
            a(e.shapes, d);
          }
        else
          a(e.shapes, u);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let u = 0, c = this.material.length; u < c; u++)
          l.push(a(e.materials, this.material[u]));
        s.material = l;
      } else
        s.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let l = 0; l < this.children.length; l++)
        s.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const u = this.animations[l];
        s.animations.push(a(e.animations, u));
      }
    }
    if (i) {
      const l = o(e.geometries), u = o(e.materials), c = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), f = o(e.animations), m = o(e.nodes);
      l.length > 0 && (n.geometries = l), u.length > 0 && (n.materials = u), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), d.length > 0 && (n.shapes = d), p.length > 0 && (n.skeletons = p), f.length > 0 && (n.animations = f), m.length > 0 && (n.nodes = m);
    }
    return n.object = s, n;
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, i = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), i === !0)
      for (let n = 0; n < e.children.length; n++) {
        const s = e.children[n];
        this.add(s.clone());
      }
    return this;
  }
};
Gr.DEFAULT_UP = /* @__PURE__ */ new Y(0, 1, 0);
Gr.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Gr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Pn = /* @__PURE__ */ new Y(), Ns = /* @__PURE__ */ new Y(), Cy = /* @__PURE__ */ new Y(), Ps = /* @__PURE__ */ new Y(), Yl = /* @__PURE__ */ new Y(), Kl = /* @__PURE__ */ new Y(), Gw = /* @__PURE__ */ new Y(), Ry = /* @__PURE__ */ new Y(), Ny = /* @__PURE__ */ new Y(), Py = /* @__PURE__ */ new Y(), Iy = /* @__PURE__ */ new Fi(), Oy = /* @__PURE__ */ new Fi(), Dy = /* @__PURE__ */ new Fi();
let Au = class Cu {
  constructor(e = new Y(), i = new Y(), n = new Y()) {
    this.a = e, this.b = i, this.c = n;
  }
  static getNormal(e, i, n, s) {
    s.subVectors(n, i), Pn.subVectors(e, i), s.cross(Pn);
    const a = s.lengthSq();
    return a > 0 ? s.multiplyScalar(1 / Math.sqrt(a)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, i, n, s, a) {
    Pn.subVectors(s, i), Ns.subVectors(n, i), Cy.subVectors(e, i);
    const o = Pn.dot(Pn), l = Pn.dot(Ns), u = Pn.dot(Cy), c = Ns.dot(Ns), h = Ns.dot(Cy), d = o * c - l * l;
    if (d === 0)
      return a.set(0, 0, 0), null;
    const p = 1 / d, f = (c * u - l * h) * p, m = (o * h - l * u) * p;
    return a.set(1 - f - m, m, f);
  }
  static containsPoint(e, i, n, s) {
    return this.getBarycoord(e, i, n, s, Ps) === null ? !1 : Ps.x >= 0 && Ps.y >= 0 && Ps.x + Ps.y <= 1;
  }
  static getInterpolation(e, i, n, s, a, o, l, u) {
    return this.getBarycoord(e, i, n, s, Ps) === null ? (u.x = 0, u.y = 0, "z" in u && (u.z = 0), "w" in u && (u.w = 0), null) : (u.setScalar(0), u.addScaledVector(a, Ps.x), u.addScaledVector(o, Ps.y), u.addScaledVector(l, Ps.z), u);
  }
  static getInterpolatedAttribute(e, i, n, s, a, o) {
    return Iy.setScalar(0), Oy.setScalar(0), Dy.setScalar(0), Iy.fromBufferAttribute(e, i), Oy.fromBufferAttribute(e, n), Dy.fromBufferAttribute(e, s), o.setScalar(0), o.addScaledVector(Iy, a.x), o.addScaledVector(Oy, a.y), o.addScaledVector(Dy, a.z), o;
  }
  static isFrontFacing(e, i, n, s) {
    return Pn.subVectors(n, i), Ns.subVectors(e, i), Pn.cross(Ns).dot(s) < 0;
  }
  set(e, i, n) {
    return this.a.copy(e), this.b.copy(i), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, i, n, s) {
    return this.a.copy(e[i]), this.b.copy(e[n]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, i, n, s) {
    return this.a.fromBufferAttribute(e, i), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Pn.subVectors(this.c, this.b), Ns.subVectors(this.a, this.b), Pn.cross(Ns).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Cu.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, i) {
    return Cu.getBarycoord(e, this.a, this.b, this.c, i);
  }
  getInterpolation(e, i, n, s, a) {
    return Cu.getInterpolation(e, this.a, this.b, this.c, i, n, s, a);
  }
  containsPoint(e) {
    return Cu.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Cu.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, i) {
    const n = this.a, s = this.b, a = this.c;
    let o, l;
    Yl.subVectors(s, n), Kl.subVectors(a, n), Ry.subVectors(e, n);
    const u = Yl.dot(Ry), c = Kl.dot(Ry);
    if (u <= 0 && c <= 0)
      return i.copy(n);
    Ny.subVectors(e, s);
    const h = Yl.dot(Ny), d = Kl.dot(Ny);
    if (h >= 0 && d <= h)
      return i.copy(s);
    const p = u * d - h * c;
    if (p <= 0 && u >= 0 && h <= 0)
      return o = u / (u - h), i.copy(n).addScaledVector(Yl, o);
    Py.subVectors(e, a);
    const f = Yl.dot(Py), m = Kl.dot(Py);
    if (m >= 0 && f <= m)
      return i.copy(a);
    const y = f * c - u * m;
    if (y <= 0 && c >= 0 && m <= 0)
      return l = c / (c - m), i.copy(n).addScaledVector(Kl, l);
    const v = h * m - f * d;
    if (v <= 0 && d - h >= 0 && f - m >= 0)
      return Gw.subVectors(a, s), l = (d - h) / (d - h + (f - m)), i.copy(s).addScaledVector(Gw, l);
    const g = 1 / (v + y + p);
    return o = y * g, l = p * g, i.copy(n).addScaledVector(Yl, o).addScaledVector(Kl, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
};
const lR = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Da = { h: 0, s: 0, l: 0 }, bp = { h: 0, s: 0, l: 0 };
function Ly(r, e, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? r + (e - r) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - i) : r;
}
let Ut = class {
  constructor(r, e, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(r, e, i);
  }
  set(r, e, i) {
    if (e === void 0 && i === void 0) {
      const n = r;
      n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
    } else
      this.setRGB(r, e, i);
    return this;
  }
  setScalar(r) {
    return this.r = r, this.g = r, this.b = r, this;
  }
  setHex(r, e = sn) {
    return r = Math.floor(r), this.r = (r >> 16 & 255) / 255, this.g = (r >> 8 & 255) / 255, this.b = (r & 255) / 255, Ht.toWorkingColorSpace(this, e), this;
  }
  setRGB(r, e, i, n = Ht.workingColorSpace) {
    return this.r = r, this.g = e, this.b = i, Ht.toWorkingColorSpace(this, n), this;
  }
  setHSL(r, e, i, n = Ht.workingColorSpace) {
    if (r = N_(r, 1), e = Zi(e, 0, 1), i = Zi(i, 0, 1), e === 0)
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + e) : i + e - i * e, a = 2 * i - s;
      this.r = Ly(a, s, r + 1 / 3), this.g = Ly(a, s, r), this.b = Ly(a, s, r - 1 / 3);
    }
    return Ht.toWorkingColorSpace(this, n), this;
  }
  setStyle(r, e = sn) {
    function i(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + r + " will be ignored.");
    }
    let n;
    if (n = /^(\w+)\(([^\)]*)\)/.exec(r)) {
      let s;
      const a = n[1], o = n[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setRGB(
              Math.min(255, parseInt(s[1], 10)) / 255,
              Math.min(255, parseInt(s[2], 10)) / 255,
              Math.min(255, parseInt(s[3], 10)) / 255,
              e
            );
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setRGB(
              Math.min(100, parseInt(s[1], 10)) / 100,
              Math.min(100, parseInt(s[2], 10)) / 100,
              Math.min(100, parseInt(s[3], 10)) / 100,
              e
            );
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setHSL(
              parseFloat(s[1]) / 360,
              parseFloat(s[2]) / 100,
              parseFloat(s[3]) / 100,
              e
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + r);
      }
    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(r)) {
      const s = n[1], a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          e
        );
      if (a === 6)
        return this.setHex(parseInt(s, 16), e);
      console.warn("THREE.Color: Invalid hex color " + r);
    } else if (r && r.length > 0)
      return this.setColorName(r, e);
    return this;
  }
  setColorName(r, e = sn) {
    const i = lR[r.toLowerCase()];
    return i !== void 0 ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + r), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(r) {
    return this.r = r.r, this.g = r.g, this.b = r.b, this;
  }
  copySRGBToLinear(r) {
    return this.r = ca(r.r), this.g = ca(r.g), this.b = ca(r.b), this;
  }
  copyLinearToSRGB(r) {
    return this.r = Wu(r.r), this.g = Wu(r.g), this.b = Wu(r.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(r = sn) {
    return Ht.fromWorkingColorSpace(ur.copy(this), r), Math.round(Zi(ur.r * 255, 0, 255)) * 65536 + Math.round(Zi(ur.g * 255, 0, 255)) * 256 + Math.round(Zi(ur.b * 255, 0, 255));
  }
  getHexString(r = sn) {
    return ("000000" + this.getHex(r).toString(16)).slice(-6);
  }
  getHSL(r, e = Ht.workingColorSpace) {
    Ht.fromWorkingColorSpace(ur.copy(this), e);
    const i = ur.r, n = ur.g, s = ur.b, a = Math.max(i, n, s), o = Math.min(i, n, s);
    let l, u;
    const c = (o + a) / 2;
    if (o === a)
      l = 0, u = 0;
    else {
      const h = a - o;
      switch (u = c <= 0.5 ? h / (a + o) : h / (2 - a - o), a) {
        case i:
          l = (n - s) / h + (n < s ? 6 : 0);
          break;
        case n:
          l = (s - i) / h + 2;
          break;
        case s:
          l = (i - n) / h + 4;
          break;
      }
      l /= 6;
    }
    return r.h = l, r.s = u, r.l = c, r;
  }
  getRGB(r, e = Ht.workingColorSpace) {
    return Ht.fromWorkingColorSpace(ur.copy(this), e), r.r = ur.r, r.g = ur.g, r.b = ur.b, r;
  }
  getStyle(r = sn) {
    Ht.fromWorkingColorSpace(ur.copy(this), r);
    const e = ur.r, i = ur.g, n = ur.b;
    return r !== sn ? `color(${r} ${e.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`;
  }
  offsetHSL(r, e, i) {
    return this.getHSL(Da), this.setHSL(Da.h + r, Da.s + e, Da.l + i);
  }
  add(r) {
    return this.r += r.r, this.g += r.g, this.b += r.b, this;
  }
  addColors(r, e) {
    return this.r = r.r + e.r, this.g = r.g + e.g, this.b = r.b + e.b, this;
  }
  addScalar(r) {
    return this.r += r, this.g += r, this.b += r, this;
  }
  sub(r) {
    return this.r = Math.max(0, this.r - r.r), this.g = Math.max(0, this.g - r.g), this.b = Math.max(0, this.b - r.b), this;
  }
  multiply(r) {
    return this.r *= r.r, this.g *= r.g, this.b *= r.b, this;
  }
  multiplyScalar(r) {
    return this.r *= r, this.g *= r, this.b *= r, this;
  }
  lerp(r, e) {
    return this.r += (r.r - this.r) * e, this.g += (r.g - this.g) * e, this.b += (r.b - this.b) * e, this;
  }
  lerpColors(r, e, i) {
    return this.r = r.r + (e.r - r.r) * i, this.g = r.g + (e.g - r.g) * i, this.b = r.b + (e.b - r.b) * i, this;
  }
  lerpHSL(r, e) {
    this.getHSL(Da), r.getHSL(bp);
    const i = Yh(Da.h, bp.h, e), n = Yh(Da.s, bp.s, e), s = Yh(Da.l, bp.l, e);
    return this.setHSL(i, n, s), this;
  }
  setFromVector3(r) {
    return this.r = r.x, this.g = r.y, this.b = r.z, this;
  }
  applyMatrix3(r) {
    const e = this.r, i = this.g, n = this.b, s = r.elements;
    return this.r = s[0] * e + s[3] * i + s[6] * n, this.g = s[1] * e + s[4] * i + s[7] * n, this.b = s[2] * e + s[5] * i + s[8] * n, this;
  }
  equals(r) {
    return r.r === this.r && r.g === this.g && r.b === this.b;
  }
  fromArray(r, e = 0) {
    return this.r = r[e], this.g = r[e + 1], this.b = r[e + 2], this;
  }
  toArray(r = [], e = 0) {
    return r[e] = this.r, r[e + 1] = this.g, r[e + 2] = this.b, r;
  }
  fromBufferAttribute(r, e) {
    return this.r = r.getX(e), this.g = r.getY(e), this.b = r.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const ur = /* @__PURE__ */ new Ut();
Ut.NAMES = lR;
let IF = 0, Nl = class extends Cl {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(r) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: IF++ }), this.uuid = ua(), this.name = "", this.blending = Gu, this.side = fo, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = qv, this.blendDst = Xv, this.blendEquation = Xo, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ut(0, 0, 0), this.blendAlpha = 0, this.depthFunc = hc, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Mw, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = zl, this.stencilZFail = zl, this.stencilZPass = zl, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(r) {
    this._alphaTest > 0 != r > 0 && this.version++, this._alphaTest = r;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(r) {
    if (r !== void 0)
      for (const e in r) {
        const i = r[e];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
          continue;
        }
        const n = this[e];
        if (n === void 0) {
          console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
          continue;
        }
        n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i;
      }
  }
  toJSON(r) {
    const e = r === void 0 || typeof r == "string";
    e && (r = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(r).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(r).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(r).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(r).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(r).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(r).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(r).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(r).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(r).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(r).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(r).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(r).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(r).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(r).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(r).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(r).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(r).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(r).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(r).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(r).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(r).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(r).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(r).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(r).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Gu && (i.blending = this.blending), this.side !== fo && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== qv && (i.blendSrc = this.blendSrc), this.blendDst !== Xv && (i.blendDst = this.blendDst), this.blendEquation !== Xo && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== hc && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Mw && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== zl && (i.stencilFail = this.stencilFail), this.stencilZFail !== zl && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== zl && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function n(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (e) {
      const s = n(r.textures), a = n(r.images);
      s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    this.name = r.name, this.blending = r.blending, this.side = r.side, this.vertexColors = r.vertexColors, this.opacity = r.opacity, this.transparent = r.transparent, this.blendSrc = r.blendSrc, this.blendDst = r.blendDst, this.blendEquation = r.blendEquation, this.blendSrcAlpha = r.blendSrcAlpha, this.blendDstAlpha = r.blendDstAlpha, this.blendEquationAlpha = r.blendEquationAlpha, this.blendColor.copy(r.blendColor), this.blendAlpha = r.blendAlpha, this.depthFunc = r.depthFunc, this.depthTest = r.depthTest, this.depthWrite = r.depthWrite, this.stencilWriteMask = r.stencilWriteMask, this.stencilFunc = r.stencilFunc, this.stencilRef = r.stencilRef, this.stencilFuncMask = r.stencilFuncMask, this.stencilFail = r.stencilFail, this.stencilZFail = r.stencilZFail, this.stencilZPass = r.stencilZPass, this.stencilWrite = r.stencilWrite;
    const e = r.clippingPlanes;
    let i = null;
    if (e !== null) {
      const n = e.length;
      i = new Array(n);
      for (let s = 0; s !== n; ++s)
        i[s] = e[s].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = r.clipIntersection, this.clipShadows = r.clipShadows, this.shadowSide = r.shadowSide, this.colorWrite = r.colorWrite, this.precision = r.precision, this.polygonOffset = r.polygonOffset, this.polygonOffsetFactor = r.polygonOffsetFactor, this.polygonOffsetUnits = r.polygonOffsetUnits, this.dithering = r.dithering, this.alphaTest = r.alphaTest, this.alphaHash = r.alphaHash, this.alphaToCoverage = r.alphaToCoverage, this.premultipliedAlpha = r.premultipliedAlpha, this.forceSinglePass = r.forceSinglePass, this.visible = r.visible, this.toneMapped = r.toneMapped, this.userData = JSON.parse(JSON.stringify(r.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}, Tg = class extends Nl {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(r) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Ut(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new go(), this.combine = w_, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.lightMap = r.lightMap, this.lightMapIntensity = r.lightMapIntensity, this.aoMap = r.aoMap, this.aoMapIntensity = r.aoMapIntensity, this.specularMap = r.specularMap, this.alphaMap = r.alphaMap, this.envMap = r.envMap, this.envMapRotation.copy(r.envMapRotation), this.combine = r.combine, this.reflectivity = r.reflectivity, this.refractionRatio = r.refractionRatio, this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.wireframeLinecap = r.wireframeLinecap, this.wireframeLinejoin = r.wireframeLinejoin, this.fog = r.fog, this;
  }
};
const Pi = /* @__PURE__ */ new Y(), xp = /* @__PURE__ */ new ke();
let _n = class {
  constructor(r, e, i = !1) {
    if (Array.isArray(r))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = r, this.itemSize = e, this.count = r !== void 0 ? r.length / e : 0, this.normalized = i, this.usage = Pb, this.updateRanges = [], this.gpuType = ra, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  setUsage(r) {
    return this.usage = r, this;
  }
  addUpdateRange(r, e) {
    this.updateRanges.push({ start: r, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(r) {
    return this.name = r.name, this.array = new r.array.constructor(r.array), this.itemSize = r.itemSize, this.count = r.count, this.normalized = r.normalized, this.usage = r.usage, this.gpuType = r.gpuType, this;
  }
  copyAt(r, e, i) {
    r *= this.itemSize, i *= e.itemSize;
    for (let n = 0, s = this.itemSize; n < s; n++)
      this.array[r + n] = e.array[i + n];
    return this;
  }
  copyArray(r) {
    return this.array.set(r), this;
  }
  applyMatrix3(r) {
    if (this.itemSize === 2)
      for (let e = 0, i = this.count; e < i; e++)
        xp.fromBufferAttribute(this, e), xp.applyMatrix3(r), this.setXY(e, xp.x, xp.y);
    else if (this.itemSize === 3)
      for (let e = 0, i = this.count; e < i; e++)
        Pi.fromBufferAttribute(this, e), Pi.applyMatrix3(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  applyMatrix4(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.applyMatrix4(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  applyNormalMatrix(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.applyNormalMatrix(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  transformDirection(r) {
    for (let e = 0, i = this.count; e < i; e++)
      Pi.fromBufferAttribute(this, e), Pi.transformDirection(r), this.setXYZ(e, Pi.x, Pi.y, Pi.z);
    return this;
  }
  set(r, e = 0) {
    return this.array.set(r, e), this;
  }
  getComponent(r, e) {
    let i = this.array[r * this.itemSize + e];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  setComponent(r, e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.array[r * this.itemSize + e] = i, this;
  }
  getX(r) {
    let e = this.array[r * this.itemSize];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setX(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize] = e, this;
  }
  getY(r) {
    let e = this.array[r * this.itemSize + 1];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setY(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize + 1] = e, this;
  }
  getZ(r) {
    let e = this.array[r * this.itemSize + 2];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setZ(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize + 2] = e, this;
  }
  getW(r) {
    let e = this.array[r * this.itemSize + 3];
    return this.normalized && (e = Hn(e, this.array)), e;
  }
  setW(r, e) {
    return this.normalized && (e = Jt(e, this.array)), this.array[r * this.itemSize + 3] = e, this;
  }
  setXY(r, e, i) {
    return r *= this.itemSize, this.normalized && (e = Jt(e, this.array), i = Jt(i, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this;
  }
  setXYZ(r, e, i, n) {
    return r *= this.itemSize, this.normalized && (e = Jt(e, this.array), i = Jt(i, this.array), n = Jt(n, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this.array[r + 2] = n, this;
  }
  setXYZW(r, e, i, n, s) {
    return r *= this.itemSize, this.normalized && (e = Jt(e, this.array), i = Jt(i, this.array), n = Jt(n, this.array), s = Jt(s, this.array)), this.array[r + 0] = e, this.array[r + 1] = i, this.array[r + 2] = n, this.array[r + 3] = s, this;
  }
  onUpload(r) {
    return this.onUploadCallback = r, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const r = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (r.name = this.name), this.usage !== Pb && (r.usage = this.usage), r;
  }
}, uR = class extends _n {
  constructor(r, e, i) {
    super(new Uint16Array(r), e, i);
  }
}, cR = class extends _n {
  constructor(r, e, i) {
    super(new Uint32Array(r), e, i);
  }
}, Ci = class extends _n {
  constructor(r, e, i) {
    super(new Float32Array(r), e, i);
  }
}, OF = 0;
const dn = /* @__PURE__ */ new ui(), ky = /* @__PURE__ */ new Gr(), Zl = /* @__PURE__ */ new Y(), Qr = /* @__PURE__ */ new Rl(), sh = /* @__PURE__ */ new Rl(), qi = /* @__PURE__ */ new Y();
let cn = class hR extends Cl {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: OF++ }), this.uuid = ua(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (iR(e) ? cR : uR)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, i) {
    return this.attributes[e] = i, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, i, n = 0) {
    this.groups.push({
      start: e,
      count: i,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, i) {
    this.drawRange.start = e, this.drawRange.count = i;
  }
  applyMatrix4(e) {
    const i = this.attributes.position;
    i !== void 0 && (i.applyMatrix4(e), i.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const a = new It().getNormalMatrix(e);
      n.applyNormalMatrix(a), n.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return dn.makeRotationFromQuaternion(e), this.applyMatrix4(dn), this;
  }
  rotateX(e) {
    return dn.makeRotationX(e), this.applyMatrix4(dn), this;
  }
  rotateY(e) {
    return dn.makeRotationY(e), this.applyMatrix4(dn), this;
  }
  rotateZ(e) {
    return dn.makeRotationZ(e), this.applyMatrix4(dn), this;
  }
  translate(e, i, n) {
    return dn.makeTranslation(e, i, n), this.applyMatrix4(dn), this;
  }
  scale(e, i, n) {
    return dn.makeScale(e, i, n), this.applyMatrix4(dn), this;
  }
  lookAt(e) {
    return ky.lookAt(e), ky.updateMatrix(), this.applyMatrix4(ky.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Zl).negate(), this.translate(Zl.x, Zl.y, Zl.z), this;
  }
  setFromPoints(e) {
    const i = this.getAttribute("position");
    if (i === void 0) {
      const n = [];
      for (let s = 0, a = e.length; s < a; s++) {
        const o = e[s];
        n.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new Ci(n, 3));
    } else {
      for (let n = 0, s = i.count; n < s; n++) {
        const a = e[n];
        i.setXYZ(n, a.x, a.y, a.z || 0);
      }
      e.length > i.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), i.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Rl());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new Y(-1 / 0, -1 / 0, -1 / 0),
        new Y(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), i)
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n];
          Qr.setFromBufferAttribute(a), this.morphTargetsRelative ? (qi.addVectors(this.boundingBox.min, Qr.min), this.boundingBox.expandByPoint(qi), qi.addVectors(this.boundingBox.max, Qr.max), this.boundingBox.expandByPoint(qi)) : (this.boundingBox.expandByPoint(Qr.min), this.boundingBox.expandByPoint(Qr.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new xg());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new Y(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (Qr.setFromBufferAttribute(e), i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a];
          sh.setFromBufferAttribute(l), this.morphTargetsRelative ? (qi.addVectors(Qr.min, sh.min), Qr.expandByPoint(qi), qi.addVectors(Qr.max, sh.max), Qr.expandByPoint(qi)) : (Qr.expandByPoint(sh.min), Qr.expandByPoint(sh.max));
        }
      Qr.getCenter(n);
      let s = 0;
      for (let a = 0, o = e.count; a < o; a++)
        qi.fromBufferAttribute(e, a), s = Math.max(s, n.distanceToSquared(qi));
      if (i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a], u = this.morphTargetsRelative;
          for (let c = 0, h = l.count; c < h; c++)
            qi.fromBufferAttribute(l, c), u && (Zl.fromBufferAttribute(e, c), qi.add(Zl)), s = Math.max(s, n.distanceToSquared(qi));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, i = this.attributes;
    if (e === null || i.position === void 0 || i.normal === void 0 || i.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = i.position, s = i.normal, a = i.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new _n(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"), l = [], u = [];
    for (let C = 0; C < n.count; C++)
      l[C] = new Y(), u[C] = new Y();
    const c = new Y(), h = new Y(), d = new Y(), p = new ke(), f = new ke(), m = new ke(), y = new Y(), v = new Y();
    function g(C, S, w) {
      c.fromBufferAttribute(n, C), h.fromBufferAttribute(n, S), d.fromBufferAttribute(n, w), p.fromBufferAttribute(a, C), f.fromBufferAttribute(a, S), m.fromBufferAttribute(a, w), h.sub(c), d.sub(c), f.sub(p), m.sub(p);
      const R = 1 / (f.x * m.y - m.x * f.y);
      isFinite(R) && (y.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(R), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(R), l[C].add(y), l[S].add(y), l[w].add(y), u[C].add(v), u[S].add(v), u[w].add(v));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{
      start: 0,
      count: e.count
    }]);
    for (let C = 0, S = _.length; C < S; ++C) {
      const w = _[C], R = w.start, O = w.count;
      for (let P = R, A = R + O; P < A; P += 3)
        g(
          e.getX(P + 0),
          e.getX(P + 1),
          e.getX(P + 2)
        );
    }
    const x = new Y(), b = new Y(), T = new Y(), E = new Y();
    function M(C) {
      T.fromBufferAttribute(s, C), E.copy(T);
      const S = l[C];
      x.copy(S), x.sub(T.multiplyScalar(T.dot(S))).normalize(), b.crossVectors(E, S);
      const w = b.dot(u[C]) < 0 ? -1 : 1;
      o.setXYZW(C, x.x, x.y, x.z, w);
    }
    for (let C = 0, S = _.length; C < S; ++C) {
      const w = _[C], R = w.start, O = w.count;
      for (let P = R, A = R + O; P < A; P += 3)
        M(e.getX(P + 0)), M(e.getX(P + 1)), M(e.getX(P + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, i = this.getAttribute("position");
    if (i !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new _n(new Float32Array(i.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let p = 0, f = n.count; p < f; p++)
          n.setXYZ(p, 0, 0, 0);
      const s = new Y(), a = new Y(), o = new Y(), l = new Y(), u = new Y(), c = new Y(), h = new Y(), d = new Y();
      if (e)
        for (let p = 0, f = e.count; p < f; p += 3) {
          const m = e.getX(p + 0), y = e.getX(p + 1), v = e.getX(p + 2);
          s.fromBufferAttribute(i, m), a.fromBufferAttribute(i, y), o.fromBufferAttribute(i, v), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, y), c.fromBufferAttribute(n, v), l.add(h), u.add(h), c.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(y, u.x, u.y, u.z), n.setXYZ(v, c.x, c.y, c.z);
        }
      else
        for (let p = 0, f = i.count; p < f; p += 3)
          s.fromBufferAttribute(i, p + 0), a.fromBufferAttribute(i, p + 1), o.fromBufferAttribute(i, p + 2), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), n.setXYZ(p + 0, h.x, h.y, h.z), n.setXYZ(p + 1, h.x, h.y, h.z), n.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let i = 0, n = e.count; i < n; i++)
      qi.fromBufferAttribute(e, i), qi.normalize(), e.setXYZ(i, qi.x, qi.y, qi.z);
  }
  toNonIndexed() {
    function e(l, u) {
      const c = l.array, h = l.itemSize, d = l.normalized, p = new c.constructor(u.length * h);
      let f = 0, m = 0;
      for (let y = 0, v = u.length; y < v; y++) {
        l.isInterleavedBufferAttribute ? f = u[y] * l.data.stride + l.offset : f = u[y] * h;
        for (let g = 0; g < h; g++)
          p[m++] = c[f++];
      }
      return new _n(p, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const i = new hR(), n = this.index.array, s = this.attributes;
    for (const l in s) {
      const u = s[l], c = e(u, n);
      i.setAttribute(l, c);
    }
    const a = this.morphAttributes;
    for (const l in a) {
      const u = [], c = a[l];
      for (let h = 0, d = c.length; h < d; h++) {
        const p = c[h], f = e(p, n);
        u.push(f);
      }
      i.morphAttributes[l] = u;
    }
    i.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const c = o[l];
      i.addGroup(c.start, c.count, c.materialIndex);
    }
    return i;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const u = this.parameters;
      for (const c in u)
        u[c] !== void 0 && (e[c] = u[c]);
      return e;
    }
    e.data = { attributes: {} };
    const i = this.index;
    i !== null && (e.data.index = {
      type: i.array.constructor.name,
      array: Array.prototype.slice.call(i.array)
    });
    const n = this.attributes;
    for (const u in n) {
      const c = n[u];
      e.data.attributes[u] = c.toJSON(e.data);
    }
    const s = {};
    let a = !1;
    for (const u in this.morphAttributes) {
      const c = this.morphAttributes[u], h = [];
      for (let d = 0, p = c.length; d < p; d++) {
        const f = c[d];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (s[u] = h, a = !0);
    }
    a && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const i = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(i));
    const s = e.attributes;
    for (const c in s) {
      const h = s[c];
      this.setAttribute(c, h.clone(i));
    }
    const a = e.morphAttributes;
    for (const c in a) {
      const h = [], d = a[c];
      for (let p = 0, f = d.length; p < f; p++)
        h.push(d[p].clone(i));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = e.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
const Hw = /* @__PURE__ */ new ui(), No = /* @__PURE__ */ new _g(), _p = /* @__PURE__ */ new xg(), Ww = /* @__PURE__ */ new Y(), Tp = /* @__PURE__ */ new Y(), wp = /* @__PURE__ */ new Y(), Sp = /* @__PURE__ */ new Y(), Uy = /* @__PURE__ */ new Y(), Ep = /* @__PURE__ */ new Y(), qw = /* @__PURE__ */ new Y(), Mp = /* @__PURE__ */ new Y();
let kr = class extends Gr {
  constructor(r = new cn(), e = new Tg()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = r, this.material = e, this.updateMorphTargets();
  }
  copy(r, e) {
    return super.copy(r, e), r.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = r.morphTargetInfluences.slice()), r.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, r.morphTargetDictionary)), this.material = Array.isArray(r.material) ? r.material.slice() : r.material, this.geometry = r.geometry, this;
  }
  updateMorphTargets() {
    const r = this.geometry.morphAttributes, e = Object.keys(r);
    if (e.length > 0) {
      const i = r[e[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n].name || String(n);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = n;
        }
      }
    }
  }
  getVertexPosition(r, e) {
    const i = this.geometry, n = i.attributes.position, s = i.morphAttributes.position, a = i.morphTargetsRelative;
    e.fromBufferAttribute(n, r);
    const o = this.morphTargetInfluences;
    if (s && o) {
      Ep.set(0, 0, 0);
      for (let l = 0, u = s.length; l < u; l++) {
        const c = o[l], h = s[l];
        c !== 0 && (Uy.fromBufferAttribute(h, r), a ? Ep.addScaledVector(Uy, c) : Ep.addScaledVector(Uy.sub(e), c));
      }
      e.add(Ep);
    }
    return e;
  }
  raycast(r, e) {
    const i = this.geometry, n = this.material, s = this.matrixWorld;
    n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), _p.copy(i.boundingSphere), _p.applyMatrix4(s), No.copy(r.ray).recast(r.near), !(_p.containsPoint(No.origin) === !1 && (No.intersectSphere(_p, Ww) === null || No.origin.distanceToSquared(Ww) > (r.far - r.near) ** 2)) && (Hw.copy(s).invert(), No.copy(r.ray).applyMatrix4(Hw), !(i.boundingBox !== null && No.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(r, e, No)));
  }
  _computeIntersections(r, e, i) {
    let n;
    const s = this.geometry, a = this.material, o = s.index, l = s.attributes.position, u = s.attributes.uv, c = s.attributes.uv1, h = s.attributes.normal, d = s.groups, p = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let f = 0, m = d.length; f < m; f++) {
          const y = d[f], v = a[y.materialIndex], g = Math.max(y.start, p.start), _ = Math.min(o.count, Math.min(y.start + y.count, p.start + p.count));
          for (let x = g, b = _; x < b; x += 3) {
            const T = o.getX(x), E = o.getX(x + 1), M = o.getX(x + 2);
            n = Ap(this, v, r, i, u, c, h, T, E, M), n && (n.faceIndex = Math.floor(x / 3), n.face.materialIndex = y.materialIndex, e.push(n));
          }
        }
      else {
        const f = Math.max(0, p.start), m = Math.min(o.count, p.start + p.count);
        for (let y = f, v = m; y < v; y += 3) {
          const g = o.getX(y), _ = o.getX(y + 1), x = o.getX(y + 2);
          n = Ap(this, a, r, i, u, c, h, g, _, x), n && (n.faceIndex = Math.floor(y / 3), e.push(n));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let f = 0, m = d.length; f < m; f++) {
          const y = d[f], v = a[y.materialIndex], g = Math.max(y.start, p.start), _ = Math.min(l.count, Math.min(y.start + y.count, p.start + p.count));
          for (let x = g, b = _; x < b; x += 3) {
            const T = x, E = x + 1, M = x + 2;
            n = Ap(this, v, r, i, u, c, h, T, E, M), n && (n.faceIndex = Math.floor(x / 3), n.face.materialIndex = y.materialIndex, e.push(n));
          }
        }
      else {
        const f = Math.max(0, p.start), m = Math.min(l.count, p.start + p.count);
        for (let y = f, v = m; y < v; y += 3) {
          const g = y, _ = y + 1, x = y + 2;
          n = Ap(this, a, r, i, u, c, h, g, _, x), n && (n.faceIndex = Math.floor(y / 3), e.push(n));
        }
      }
  }
};
function DF(r, e, i, n, s, a, o, l) {
  let u;
  if (e.side === Ar ? u = n.intersectTriangle(o, a, s, !0, l) : u = n.intersectTriangle(s, a, o, e.side === fo, l), u === null) return null;
  Mp.copy(l), Mp.applyMatrix4(r.matrixWorld);
  const c = i.ray.origin.distanceTo(Mp);
  return c < i.near || c > i.far ? null : {
    distance: c,
    point: Mp.clone(),
    object: r
  };
}
function Ap(r, e, i, n, s, a, o, l, u, c) {
  r.getVertexPosition(l, Tp), r.getVertexPosition(u, wp), r.getVertexPosition(c, Sp);
  const h = DF(r, e, i, n, Tp, wp, Sp, qw);
  if (h) {
    const d = new Y();
    Au.getBarycoord(qw, Tp, wp, Sp, d), s && (h.uv = Au.getInterpolatedAttribute(s, l, u, c, d, new ke())), a && (h.uv1 = Au.getInterpolatedAttribute(a, l, u, c, d, new ke())), o && (h.normal = Au.getInterpolatedAttribute(o, l, u, c, d, new Y()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const p = {
      a: l,
      b: u,
      c,
      normal: new Y(),
      materialIndex: 0
    };
    Au.getNormal(Tp, wp, Sp, p.normal), h.face = p, h.barycoord = d;
  }
  return h;
}
let I_ = class dR extends cn {
  constructor(e = 1, i = 1, n = 1, s = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: i,
      depth: n,
      widthSegments: s,
      heightSegments: a,
      depthSegments: o
    };
    const l = this;
    s = Math.floor(s), a = Math.floor(a), o = Math.floor(o);
    const u = [], c = [], h = [], d = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, n, i, e, o, a, 0), m("z", "y", "x", 1, -1, n, i, -e, o, a, 1), m("x", "z", "y", 1, 1, e, n, i, s, o, 2), m("x", "z", "y", 1, -1, e, n, -i, s, o, 3), m("x", "y", "z", 1, -1, e, i, n, s, a, 4), m("x", "y", "z", -1, -1, e, i, -n, s, a, 5), this.setIndex(u), this.setAttribute("position", new Ci(c, 3)), this.setAttribute("normal", new Ci(h, 3)), this.setAttribute("uv", new Ci(d, 2));
    function m(y, v, g, _, x, b, T, E, M, C, S) {
      const w = b / M, R = T / C, O = b / 2, P = T / 2, A = E / 2, D = M + 1, L = C + 1;
      let H = 0, V = 0;
      const X = new Y();
      for (let F = 0; F < L; F++) {
        const B = F * R - P;
        for (let W = 0; W < D; W++) {
          const G = W * w - O;
          X[y] = G * _, X[v] = B * x, X[g] = A, c.push(X.x, X.y, X.z), X[y] = 0, X[v] = 0, X[g] = E > 0 ? 1 : -1, h.push(X.x, X.y, X.z), d.push(W / M), d.push(1 - F / C), H += 1;
        }
      }
      for (let F = 0; F < C; F++)
        for (let B = 0; B < M; B++) {
          const W = p + B + D * F, G = p + B + D * (F + 1), z = p + (B + 1) + D * (F + 1), K = p + (B + 1) + D * F;
          u.push(W, G, K), u.push(G, z, K), V += 6;
        }
      l.addGroup(f, V, S), f += V, p += H;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new dR(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
};
function gc(r) {
  const e = {};
  for (const i in r) {
    e[i] = {};
    for (const n in r[i]) {
      const s = r[i][n];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][n] = null) : e[i][n] = s.clone() : Array.isArray(s) ? e[i][n] = s.slice() : e[i][n] = s;
    }
  }
  return e;
}
function _r(r) {
  const e = {};
  for (let i = 0; i < r.length; i++) {
    const n = gc(r[i]);
    for (const s in n)
      e[s] = n[s];
  }
  return e;
}
function LF(r) {
  const e = [];
  for (let i = 0; i < r.length; i++)
    e.push(r[i].clone());
  return e;
}
function pR(r) {
  const e = r.getRenderTarget();
  return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Ht.workingColorSpace;
}
const fR = { clone: gc, merge: _r };
var kF = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, UF = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
let xs = class extends Nl {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(r) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = kF, this.fragmentShader = UF, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, r !== void 0 && this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.fragmentShader = r.fragmentShader, this.vertexShader = r.vertexShader, this.uniforms = gc(r.uniforms), this.uniformsGroups = LF(r.uniformsGroups), this.defines = Object.assign({}, r.defines), this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.fog = r.fog, this.lights = r.lights, this.clipping = r.clipping, this.extensions = Object.assign({}, r.extensions), this.glslVersion = r.glslVersion, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    e.glslVersion = this.glslVersion, e.uniforms = {};
    for (const n in this.uniforms) {
      const s = this.uniforms[n].value;
      s && s.isTexture ? e.uniforms[n] = {
        type: "t",
        value: s.toJSON(r).uuid
      } : s && s.isColor ? e.uniforms[n] = {
        type: "c",
        value: s.getHex()
      } : s && s.isVector2 ? e.uniforms[n] = {
        type: "v2",
        value: s.toArray()
      } : s && s.isVector3 ? e.uniforms[n] = {
        type: "v3",
        value: s.toArray()
      } : s && s.isVector4 ? e.uniforms[n] = {
        type: "v4",
        value: s.toArray()
      } : s && s.isMatrix3 ? e.uniforms[n] = {
        type: "m3",
        value: s.toArray()
      } : s && s.isMatrix4 ? e.uniforms[n] = {
        type: "m4",
        value: s.toArray()
      } : e.uniforms[n] = {
        value: s
      };
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
    const i = {};
    for (const n in this.extensions)
      this.extensions[n] === !0 && (i[n] = !0);
    return Object.keys(i).length > 0 && (e.extensions = i), e;
  }
}, mR = class extends Gr {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ui(), this.projectionMatrix = new ui(), this.projectionMatrixInverse = new ui(), this.coordinateSystem = na;
  }
  copy(r, e) {
    return super.copy(r, e), this.matrixWorldInverse.copy(r.matrixWorldInverse), this.projectionMatrix.copy(r.projectionMatrix), this.projectionMatrixInverse.copy(r.projectionMatrixInverse), this.coordinateSystem = r.coordinateSystem, this;
  }
  getWorldDirection(r) {
    return super.getWorldDirection(r).negate();
  }
  updateMatrixWorld(r) {
    super.updateMatrixWorld(r), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(r, e) {
    super.updateWorldMatrix(r, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const La = /* @__PURE__ */ new Y(), Xw = /* @__PURE__ */ new ke(), Yw = /* @__PURE__ */ new ke();
let vn = class extends mR {
  constructor(r = 50, e = 1, i = 0.1, n = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = r, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(r, e) {
    return super.copy(r, e), this.fov = r.fov, this.zoom = r.zoom, this.near = r.near, this.far = r.far, this.focus = r.focus, this.aspect = r.aspect, this.view = r.view === null ? null : Object.assign({}, r.view), this.filmGauge = r.filmGauge, this.filmOffset = r.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(r) {
    const e = 0.5 * this.getFilmHeight() / r;
    this.fov = cd * 2 * Math.atan(e), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const r = Math.tan(Xh * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / r;
  }
  getEffectiveFOV() {
    return cd * 2 * Math.atan(
      Math.tan(Xh * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(r, e, i) {
    La.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), e.set(La.x, La.y).multiplyScalar(-r / La.z), La.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(La.x, La.y).multiplyScalar(-r / La.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(r, e) {
    return this.getViewBounds(r, Xw, Yw), e.subVectors(Yw, Xw);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(r, e, i, n, s, a) {
    this.aspect = r / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = r, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const r = this.near;
    let e = r * Math.tan(Xh * 0.5 * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, s = -0.5 * n;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth, u = a.fullHeight;
      s += a.offsetX * n / l, e -= a.offsetY * i / u, n *= a.width / l, i *= a.height / u;
    }
    const o = this.filmOffset;
    o !== 0 && (s += r * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + n, e, e - i, r, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
};
const Ql = -90, $l = 1;
let FF = class extends Gr {
  constructor(r, e, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const n = new vn(Ql, $l, r, e);
    n.layers = this.layers, this.add(n);
    const s = new vn(Ql, $l, r, e);
    s.layers = this.layers, this.add(s);
    const a = new vn(Ql, $l, r, e);
    a.layers = this.layers, this.add(a);
    const o = new vn(Ql, $l, r, e);
    o.layers = this.layers, this.add(o);
    const l = new vn(Ql, $l, r, e);
    l.layers = this.layers, this.add(l);
    const u = new vn(Ql, $l, r, e);
    u.layers = this.layers, this.add(u);
  }
  updateCoordinateSystem() {
    const r = this.coordinateSystem, e = this.children.concat(), [i, n, s, a, o, l] = e;
    for (const u of e) this.remove(u);
    if (r === na)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (r === bm)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + r);
    for (const u of e)
      this.add(u), u.updateMatrixWorld();
  }
  update(r, e) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: n } = this;
    this.coordinateSystem !== r.coordinateSystem && (this.coordinateSystem = r.coordinateSystem, this.updateCoordinateSystem());
    const [s, a, o, l, u, c] = this.children, h = r.getRenderTarget(), d = r.getActiveCubeFace(), p = r.getActiveMipmapLevel(), f = r.xr.enabled;
    r.xr.enabled = !1;
    const m = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, r.setRenderTarget(i, 0, n), r.render(e, s), r.setRenderTarget(i, 1, n), r.render(e, a), r.setRenderTarget(i, 2, n), r.render(e, o), r.setRenderTarget(i, 3, n), r.render(e, l), r.setRenderTarget(i, 4, n), r.render(e, u), i.texture.generateMipmaps = m, r.setRenderTarget(i, 5, n), r.render(e, c), r.setRenderTarget(h, d, p), r.xr.enabled = f, i.texture.needsPMREMUpdate = !0;
  }
}, gR = class extends En {
  constructor(r, e, i, n, s, a, o, l, u, c) {
    r = r !== void 0 ? r : [], e = e !== void 0 ? e : dc, super(r, e, i, n, s, a, o, l, u, c), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(r) {
    this.image = r;
  }
}, BF = class extends mo {
  constructor(r = 1, e = {}) {
    super(r, r, e), this.isWebGLCubeRenderTarget = !0;
    const i = { width: r, height: r, depth: 1 }, n = [i, i, i, i, i, i];
    this.texture = new gR(n, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : ds;
  }
  fromEquirectangularTexture(r, e) {
    this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, n = new I_(5, 5, 5), s = new xs({
      name: "CubemapFromEquirect",
      uniforms: gc(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: Ar,
      blending: la
    });
    s.uniforms.tEquirect.value = e;
    const a = new kr(n, s), o = e.minFilter;
    return e.minFilter === rl && (e.minFilter = ds), new FF(1, 10, this).update(r, a), e.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(r, e, i, n) {
    const s = r.getRenderTarget();
    for (let a = 0; a < 6; a++)
      r.setRenderTarget(this, a), r.clear(e, i, n);
    r.setRenderTarget(s);
  }
};
const Fy = /* @__PURE__ */ new Y(), zF = /* @__PURE__ */ new Y(), jF = /* @__PURE__ */ new It();
let qs = class {
  constructor(r = new Y(1, 0, 0), e = 0) {
    this.isPlane = !0, this.normal = r, this.constant = e;
  }
  set(r, e) {
    return this.normal.copy(r), this.constant = e, this;
  }
  setComponents(r, e, i, n) {
    return this.normal.set(r, e, i), this.constant = n, this;
  }
  setFromNormalAndCoplanarPoint(r, e) {
    return this.normal.copy(r), this.constant = -e.dot(this.normal), this;
  }
  setFromCoplanarPoints(r, e, i) {
    const n = Fy.subVectors(i, e).cross(zF.subVectors(r, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, r), this;
  }
  copy(r) {
    return this.normal.copy(r.normal), this.constant = r.constant, this;
  }
  normalize() {
    const r = 1 / this.normal.length();
    return this.normal.multiplyScalar(r), this.constant *= r, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(r) {
    return this.normal.dot(r) + this.constant;
  }
  distanceToSphere(r) {
    return this.distanceToPoint(r.center) - r.radius;
  }
  projectPoint(r, e) {
    return e.copy(r).addScaledVector(this.normal, -this.distanceToPoint(r));
  }
  intersectLine(r, e) {
    const i = r.delta(Fy), n = this.normal.dot(i);
    if (n === 0)
      return this.distanceToPoint(r.start) === 0 ? e.copy(r.start) : null;
    const s = -(r.start.dot(this.normal) + this.constant) / n;
    return s < 0 || s > 1 ? null : e.copy(r.start).addScaledVector(i, s);
  }
  intersectsLine(r) {
    const e = this.distanceToPoint(r.start), i = this.distanceToPoint(r.end);
    return e < 0 && i > 0 || i < 0 && e > 0;
  }
  intersectsBox(r) {
    return r.intersectsPlane(this);
  }
  intersectsSphere(r) {
    return r.intersectsPlane(this);
  }
  coplanarPoint(r) {
    return r.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(r, e) {
    const i = e || jF.getNormalMatrix(r), n = this.coplanarPoint(Fy).applyMatrix4(r), s = this.normal.applyMatrix3(i).normalize();
    return this.constant = -n.dot(s), this;
  }
  translate(r) {
    return this.constant -= r.dot(this.normal), this;
  }
  equals(r) {
    return r.normal.equals(this.normal) && r.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
const Po = /* @__PURE__ */ new xg(), Cp = /* @__PURE__ */ new Y();
let O_ = class {
  constructor(r = new qs(), e = new qs(), i = new qs(), n = new qs(), s = new qs(), a = new qs()) {
    this.planes = [r, e, i, n, s, a];
  }
  set(r, e, i, n, s, a) {
    const o = this.planes;
    return o[0].copy(r), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(s), o[5].copy(a), this;
  }
  copy(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++)
      e[i].copy(r.planes[i]);
    return this;
  }
  setFromProjectionMatrix(r, e = na) {
    const i = this.planes, n = r.elements, s = n[0], a = n[1], o = n[2], l = n[3], u = n[4], c = n[5], h = n[6], d = n[7], p = n[8], f = n[9], m = n[10], y = n[11], v = n[12], g = n[13], _ = n[14], x = n[15];
    if (i[0].setComponents(l - s, d - u, y - p, x - v).normalize(), i[1].setComponents(l + s, d + u, y + p, x + v).normalize(), i[2].setComponents(l + a, d + c, y + f, x + g).normalize(), i[3].setComponents(l - a, d - c, y - f, x - g).normalize(), i[4].setComponents(l - o, d - h, y - m, x - _).normalize(), e === na)
      i[5].setComponents(l + o, d + h, y + m, x + _).normalize();
    else if (e === bm)
      i[5].setComponents(o, h, m, _).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
    return this;
  }
  intersectsObject(r) {
    if (r.boundingSphere !== void 0)
      r.boundingSphere === null && r.computeBoundingSphere(), Po.copy(r.boundingSphere).applyMatrix4(r.matrixWorld);
    else {
      const e = r.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(), Po.copy(e.boundingSphere).applyMatrix4(r.matrixWorld);
    }
    return this.intersectsSphere(Po);
  }
  intersectsSprite(r) {
    return Po.center.set(0, 0, 0), Po.radius = 0.7071067811865476, Po.applyMatrix4(r.matrixWorld), this.intersectsSphere(Po);
  }
  intersectsSphere(r) {
    const e = this.planes, i = r.center, n = -r.radius;
    for (let s = 0; s < 6; s++)
      if (e[s].distanceToPoint(i) < n)
        return !1;
    return !0;
  }
  intersectsBox(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = e[i];
      if (Cp.x = n.normal.x > 0 ? r.max.x : r.min.x, Cp.y = n.normal.y > 0 ? r.max.y : r.min.y, Cp.z = n.normal.z > 0 ? r.max.z : r.min.z, n.distanceToPoint(Cp) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(r) {
    const e = this.planes;
    for (let i = 0; i < 6; i++)
      if (e[i].distanceToPoint(r) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function yR() {
  let r = null, e = !1, i = null, n = null;
  function s(a, o) {
    i(a, o), n = r.requestAnimationFrame(s);
  }
  return {
    start: function() {
      e !== !0 && i !== null && (n = r.requestAnimationFrame(s), e = !0);
    },
    stop: function() {
      r.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(a) {
      i = a;
    },
    setContext: function(a) {
      r = a;
    }
  };
}
function VF(r) {
  const e = /* @__PURE__ */ new WeakMap();
  function i(l, u) {
    const c = l.array, h = l.usage, d = c.byteLength, p = r.createBuffer();
    r.bindBuffer(u, p), r.bufferData(u, c, h), l.onUploadCallback();
    let f;
    if (c instanceof Float32Array)
      f = r.FLOAT;
    else if (c instanceof Uint16Array)
      l.isFloat16BufferAttribute ? f = r.HALF_FLOAT : f = r.UNSIGNED_SHORT;
    else if (c instanceof Int16Array)
      f = r.SHORT;
    else if (c instanceof Uint32Array)
      f = r.UNSIGNED_INT;
    else if (c instanceof Int32Array)
      f = r.INT;
    else if (c instanceof Int8Array)
      f = r.BYTE;
    else if (c instanceof Uint8Array)
      f = r.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray)
      f = r.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
    return {
      buffer: p,
      type: f,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: l.version,
      size: d
    };
  }
  function n(l, u, c) {
    const h = u.array, d = u.updateRanges;
    if (r.bindBuffer(c, l), d.length === 0)
      r.bufferSubData(c, 0, h);
    else {
      d.sort((f, m) => f.start - m.start);
      let p = 0;
      for (let f = 1; f < d.length; f++) {
        const m = d[p], y = d[f];
        y.start <= m.start + m.count + 1 ? m.count = Math.max(
          m.count,
          y.start + y.count - m.start
        ) : (++p, d[p] = y);
      }
      d.length = p + 1;
      for (let f = 0, m = d.length; f < m; f++) {
        const y = d[f];
        r.bufferSubData(
          c,
          y.start * h.BYTES_PER_ELEMENT,
          h,
          y.start,
          y.count
        );
      }
      u.clearUpdateRanges();
    }
    u.onUploadCallback();
  }
  function s(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function a(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const u = e.get(l);
    u && (r.deleteBuffer(u.buffer), e.delete(l));
  }
  function o(l, u) {
    if (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute) {
      const h = e.get(l);
      (!h || h.version < l.version) && e.set(l, {
        buffer: l.buffer,
        type: l.type,
        bytesPerElement: l.elementSize,
        version: l.version
      });
      return;
    }
    const c = e.get(l);
    if (c === void 0)
      e.set(l, i(l, u));
    else if (c.version < l.version) {
      if (c.size !== l.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n(c.buffer, l, u), c.version = l.version;
    }
  }
  return {
    get: s,
    remove: a,
    update: o
  };
}
class Gd extends cn {
  constructor(e = 1, i = 1, n = 1, s = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: i,
      widthSegments: n,
      heightSegments: s
    };
    const a = e / 2, o = i / 2, l = Math.floor(n), u = Math.floor(s), c = l + 1, h = u + 1, d = e / l, p = i / u, f = [], m = [], y = [], v = [];
    for (let g = 0; g < h; g++) {
      const _ = g * p - o;
      for (let x = 0; x < c; x++) {
        const b = x * d - a;
        m.push(b, -_, 0), y.push(0, 0, 1), v.push(x / l), v.push(1 - g / u);
      }
    }
    for (let g = 0; g < u; g++)
      for (let _ = 0; _ < l; _++) {
        const x = _ + c * g, b = _ + c * (g + 1), T = _ + 1 + c * (g + 1), E = _ + 1 + c * g;
        f.push(x, b, E), f.push(b, T, E);
      }
    this.setIndex(f), this.setAttribute("position", new Ci(m, 3)), this.setAttribute("normal", new Ci(y, 3)), this.setAttribute("uv", new Ci(v, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Gd(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var GF = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, HF = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, WF = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, qF = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, XF = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, YF = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, KF = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, ZF = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, QF = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, $F = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, JF = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, eB = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, tB = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, iB = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, rB = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, nB = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, sB = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, aB = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, oB = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, lB = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, uB = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, cB = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, hB = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, dB = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, pB = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, fB = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, mB = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, gB = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, yB = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, vB = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, bB = "gl_FragColor = linearToOutputTexel( gl_FragColor );", xB = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, _B = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, TB = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, wB = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, SB = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, EB = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, MB = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, AB = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, CB = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, RB = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, NB = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, PB = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, IB = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, OB = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, DB = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, LB = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, kB = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, UB = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, FB = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, BB = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, zB = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, jB = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, VB = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, GB = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, HB = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, WB = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, qB = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, XB = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, YB = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, KB = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, ZB = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, QB = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, $B = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, JB = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, e4 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, t4 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, i4 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, r4 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, n4 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, s4 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, a4 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, o4 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, l4 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, u4 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, c4 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, h4 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, d4 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, p4 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, f4 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, m4 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, g4 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, y4 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, v4 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, b4 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, x4 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, _4 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, T4 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, w4 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, S4 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, E4 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, M4 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, A4 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, C4 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, R4 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, N4 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, P4 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, I4 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, O4 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, D4 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, L4 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, k4 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, U4 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, F4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, B4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, z4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, j4 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const V4 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, G4 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, H4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, W4 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, q4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, X4 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Y4 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, K4 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, Z4 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Q4 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, $4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, J4 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ez = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, tz = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, iz = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, rz = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, nz = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, sz = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, az = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, oz = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, lz = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, uz = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, cz = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, hz = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, dz = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, pz = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, fz = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, mz = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, gz = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, yz = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, vz = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, bz = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, xz = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, _z = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Rt = {
  alphahash_fragment: GF,
  alphahash_pars_fragment: HF,
  alphamap_fragment: WF,
  alphamap_pars_fragment: qF,
  alphatest_fragment: XF,
  alphatest_pars_fragment: YF,
  aomap_fragment: KF,
  aomap_pars_fragment: ZF,
  batching_pars_vertex: QF,
  batching_vertex: $F,
  begin_vertex: JF,
  beginnormal_vertex: eB,
  bsdfs: tB,
  iridescence_fragment: iB,
  bumpmap_pars_fragment: rB,
  clipping_planes_fragment: nB,
  clipping_planes_pars_fragment: sB,
  clipping_planes_pars_vertex: aB,
  clipping_planes_vertex: oB,
  color_fragment: lB,
  color_pars_fragment: uB,
  color_pars_vertex: cB,
  color_vertex: hB,
  common: dB,
  cube_uv_reflection_fragment: pB,
  defaultnormal_vertex: fB,
  displacementmap_pars_vertex: mB,
  displacementmap_vertex: gB,
  emissivemap_fragment: yB,
  emissivemap_pars_fragment: vB,
  colorspace_fragment: bB,
  colorspace_pars_fragment: xB,
  envmap_fragment: _B,
  envmap_common_pars_fragment: TB,
  envmap_pars_fragment: wB,
  envmap_pars_vertex: SB,
  envmap_physical_pars_fragment: LB,
  envmap_vertex: EB,
  fog_vertex: MB,
  fog_pars_vertex: AB,
  fog_fragment: CB,
  fog_pars_fragment: RB,
  gradientmap_pars_fragment: NB,
  lightmap_pars_fragment: PB,
  lights_lambert_fragment: IB,
  lights_lambert_pars_fragment: OB,
  lights_pars_begin: DB,
  lights_toon_fragment: kB,
  lights_toon_pars_fragment: UB,
  lights_phong_fragment: FB,
  lights_phong_pars_fragment: BB,
  lights_physical_fragment: zB,
  lights_physical_pars_fragment: jB,
  lights_fragment_begin: VB,
  lights_fragment_maps: GB,
  lights_fragment_end: HB,
  logdepthbuf_fragment: WB,
  logdepthbuf_pars_fragment: qB,
  logdepthbuf_pars_vertex: XB,
  logdepthbuf_vertex: YB,
  map_fragment: KB,
  map_pars_fragment: ZB,
  map_particle_fragment: QB,
  map_particle_pars_fragment: $B,
  metalnessmap_fragment: JB,
  metalnessmap_pars_fragment: e4,
  morphinstance_vertex: t4,
  morphcolor_vertex: i4,
  morphnormal_vertex: r4,
  morphtarget_pars_vertex: n4,
  morphtarget_vertex: s4,
  normal_fragment_begin: a4,
  normal_fragment_maps: o4,
  normal_pars_fragment: l4,
  normal_pars_vertex: u4,
  normal_vertex: c4,
  normalmap_pars_fragment: h4,
  clearcoat_normal_fragment_begin: d4,
  clearcoat_normal_fragment_maps: p4,
  clearcoat_pars_fragment: f4,
  iridescence_pars_fragment: m4,
  opaque_fragment: g4,
  packing: y4,
  premultiplied_alpha_fragment: v4,
  project_vertex: b4,
  dithering_fragment: x4,
  dithering_pars_fragment: _4,
  roughnessmap_fragment: T4,
  roughnessmap_pars_fragment: w4,
  shadowmap_pars_fragment: S4,
  shadowmap_pars_vertex: E4,
  shadowmap_vertex: M4,
  shadowmask_pars_fragment: A4,
  skinbase_vertex: C4,
  skinning_pars_vertex: R4,
  skinning_vertex: N4,
  skinnormal_vertex: P4,
  specularmap_fragment: I4,
  specularmap_pars_fragment: O4,
  tonemapping_fragment: D4,
  tonemapping_pars_fragment: L4,
  transmission_fragment: k4,
  transmission_pars_fragment: U4,
  uv_pars_fragment: F4,
  uv_pars_vertex: B4,
  uv_vertex: z4,
  worldpos_vertex: j4,
  background_vert: V4,
  background_frag: G4,
  backgroundCube_vert: H4,
  backgroundCube_frag: W4,
  cube_vert: q4,
  cube_frag: X4,
  depth_vert: Y4,
  depth_frag: K4,
  distanceRGBA_vert: Z4,
  distanceRGBA_frag: Q4,
  equirect_vert: $4,
  equirect_frag: J4,
  linedashed_vert: ez,
  linedashed_frag: tz,
  meshbasic_vert: iz,
  meshbasic_frag: rz,
  meshlambert_vert: nz,
  meshlambert_frag: sz,
  meshmatcap_vert: az,
  meshmatcap_frag: oz,
  meshnormal_vert: lz,
  meshnormal_frag: uz,
  meshphong_vert: cz,
  meshphong_frag: hz,
  meshphysical_vert: dz,
  meshphysical_frag: pz,
  meshtoon_vert: fz,
  meshtoon_frag: mz,
  points_vert: gz,
  points_frag: yz,
  shadow_vert: vz,
  shadow_frag: bz,
  sprite_vert: xz,
  sprite_frag: _z
}, Ve = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Ut(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new It() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new It() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new It() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new It() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new It() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new It() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new It() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new It() },
    normalScale: { value: /* @__PURE__ */ new ke(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new It() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new It() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new It() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new It() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Ut(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Ut(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new It() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new It() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Ut(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new ke(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new It() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new It() },
    alphaTest: { value: 0 }
  }
}, hs = {
  basic: {
    uniforms: /* @__PURE__ */ _r([
      Ve.common,
      Ve.specularmap,
      Ve.envmap,
      Ve.aomap,
      Ve.lightmap,
      Ve.fog
    ]),
    vertexShader: Rt.meshbasic_vert,
    fragmentShader: Rt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ _r([
      Ve.common,
      Ve.specularmap,
      Ve.envmap,
      Ve.aomap,
      Ve.lightmap,
      Ve.emissivemap,
      Ve.bumpmap,
      Ve.normalmap,
      Ve.displacementmap,
      Ve.fog,
      Ve.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ut(0) }
      }
    ]),
    vertexShader: Rt.meshlambert_vert,
    fragmentShader: Rt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ _r([
      Ve.common,
      Ve.specularmap,
      Ve.envmap,
      Ve.aomap,
      Ve.lightmap,
      Ve.emissivemap,
      Ve.bumpmap,
      Ve.normalmap,
      Ve.displacementmap,
      Ve.fog,
      Ve.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ut(0) },
        specular: { value: /* @__PURE__ */ new Ut(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Rt.meshphong_vert,
    fragmentShader: Rt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ _r([
      Ve.common,
      Ve.envmap,
      Ve.aomap,
      Ve.lightmap,
      Ve.emissivemap,
      Ve.bumpmap,
      Ve.normalmap,
      Ve.displacementmap,
      Ve.roughnessmap,
      Ve.metalnessmap,
      Ve.fog,
      Ve.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ut(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Rt.meshphysical_vert,
    fragmentShader: Rt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ _r([
      Ve.common,
      Ve.aomap,
      Ve.lightmap,
      Ve.emissivemap,
      Ve.bumpmap,
      Ve.normalmap,
      Ve.displacementmap,
      Ve.gradientmap,
      Ve.fog,
      Ve.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ut(0) }
      }
    ]),
    vertexShader: Rt.meshtoon_vert,
    fragmentShader: Rt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ _r([
      Ve.common,
      Ve.bumpmap,
      Ve.normalmap,
      Ve.displacementmap,
      Ve.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Rt.meshmatcap_vert,
    fragmentShader: Rt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ _r([
      Ve.points,
      Ve.fog
    ]),
    vertexShader: Rt.points_vert,
    fragmentShader: Rt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ _r([
      Ve.common,
      Ve.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Rt.linedashed_vert,
    fragmentShader: Rt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ _r([
      Ve.common,
      Ve.displacementmap
    ]),
    vertexShader: Rt.depth_vert,
    fragmentShader: Rt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ _r([
      Ve.common,
      Ve.bumpmap,
      Ve.normalmap,
      Ve.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Rt.meshnormal_vert,
    fragmentShader: Rt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ _r([
      Ve.sprite,
      Ve.fog
    ]),
    vertexShader: Rt.sprite_vert,
    fragmentShader: Rt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new It() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Rt.background_vert,
    fragmentShader: Rt.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new It() }
    },
    vertexShader: Rt.backgroundCube_vert,
    fragmentShader: Rt.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Rt.cube_vert,
    fragmentShader: Rt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Rt.equirect_vert,
    fragmentShader: Rt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ _r([
      Ve.common,
      Ve.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Y() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Rt.distanceRGBA_vert,
    fragmentShader: Rt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ _r([
      Ve.lights,
      Ve.fog,
      {
        color: { value: /* @__PURE__ */ new Ut(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Rt.shadow_vert,
    fragmentShader: Rt.shadow_frag
  }
};
hs.physical = {
  uniforms: /* @__PURE__ */ _r([
    hs.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new It() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new It() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new ke(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new It() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new It() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new It() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Ut(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new It() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new It() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new It() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new ke() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new It() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Ut(0) },
      specularColor: { value: /* @__PURE__ */ new Ut(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new It() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new It() },
      anisotropyVector: { value: /* @__PURE__ */ new ke() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new It() }
    }
  ]),
  vertexShader: Rt.meshphysical_vert,
  fragmentShader: Rt.meshphysical_frag
};
const Rp = { r: 0, b: 0, g: 0 }, Io = /* @__PURE__ */ new go(), Tz = /* @__PURE__ */ new ui();
function wz(r, e, i, n, s, a, o) {
  const l = new Ut(0);
  let u = a === !0 ? 0 : 1, c, h, d = null, p = 0, f = null;
  function m(_) {
    let x = _.isScene === !0 ? _.background : null;
    return x && x.isTexture && (x = (_.backgroundBlurriness > 0 ? i : e).get(x)), x;
  }
  function y(_) {
    let x = !1;
    const b = m(_);
    b === null ? g(l, u) : b && b.isColor && (g(b, 1), x = !0);
    const T = r.xr.getEnvironmentBlendMode();
    T === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : T === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (r.autoClear || x) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil));
  }
  function v(_, x) {
    const b = m(x);
    b && (b.isCubeTexture || b.mapping === vg) ? (h === void 0 && (h = new kr(
      new I_(1, 1, 1),
      new xs({
        name: "BackgroundCubeMaterial",
        uniforms: gc(hs.backgroundCube.uniforms),
        vertexShader: hs.backgroundCube.vertexShader,
        fragmentShader: hs.backgroundCube.fragmentShader,
        side: Ar,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(T, E, M) {
      this.matrixWorld.copyPosition(M.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), s.update(h)), Io.copy(x.backgroundRotation), Io.x *= -1, Io.y *= -1, Io.z *= -1, b.isCubeTexture && b.isRenderTargetTexture === !1 && (Io.y *= -1, Io.z *= -1), h.material.uniforms.envMap.value = b, h.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = x.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(Tz.makeRotationFromEuler(Io)), h.material.toneMapped = Ht.getTransfer(b.colorSpace) !== ei, (d !== b || p !== b.version || f !== r.toneMapping) && (h.material.needsUpdate = !0, d = b, p = b.version, f = r.toneMapping), h.layers.enableAll(), _.unshift(h, h.geometry, h.material, 0, 0, null)) : b && b.isTexture && (c === void 0 && (c = new kr(
      new Gd(2, 2),
      new xs({
        name: "BackgroundMaterial",
        uniforms: gc(hs.background.uniforms),
        vertexShader: hs.background.vertexShader,
        fragmentShader: hs.background.fragmentShader,
        side: fo,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), s.update(c)), c.material.uniforms.t2D.value = b, c.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, c.material.toneMapped = Ht.getTransfer(b.colorSpace) !== ei, b.matrixAutoUpdate === !0 && b.updateMatrix(), c.material.uniforms.uvTransform.value.copy(b.matrix), (d !== b || p !== b.version || f !== r.toneMapping) && (c.material.needsUpdate = !0, d = b, p = b.version, f = r.toneMapping), c.layers.enableAll(), _.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function g(_, x) {
    _.getRGB(Rp, pR(r)), n.buffers.color.setClear(Rp.r, Rp.g, Rp.b, x, o);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(_, x = 1) {
      l.set(_), u = x, g(l, u);
    },
    getClearAlpha: function() {
      return u;
    },
    setClearAlpha: function(_) {
      u = _, g(l, u);
    },
    render: y,
    addToRenderList: v
  };
}
function Sz(r, e) {
  const i = r.getParameter(r.MAX_VERTEX_ATTRIBS), n = {}, s = p(null);
  let a = s, o = !1;
  function l(w, R, O, P, A) {
    let D = !1;
    const L = d(P, O, R);
    a !== L && (a = L, c(a.object)), D = f(w, P, O, A), D && m(w, P, O, A), A !== null && e.update(A, r.ELEMENT_ARRAY_BUFFER), (D || o) && (o = !1, b(w, R, O, P), A !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(A).buffer));
  }
  function u() {
    return r.createVertexArray();
  }
  function c(w) {
    return r.bindVertexArray(w);
  }
  function h(w) {
    return r.deleteVertexArray(w);
  }
  function d(w, R, O) {
    const P = O.wireframe === !0;
    let A = n[w.id];
    A === void 0 && (A = {}, n[w.id] = A);
    let D = A[R.id];
    D === void 0 && (D = {}, A[R.id] = D);
    let L = D[P];
    return L === void 0 && (L = p(u()), D[P] = L), L;
  }
  function p(w) {
    const R = [], O = [], P = [];
    for (let A = 0; A < i; A++)
      R[A] = 0, O[A] = 0, P[A] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: R,
      enabledAttributes: O,
      attributeDivisors: P,
      object: w,
      attributes: {},
      index: null
    };
  }
  function f(w, R, O, P) {
    const A = a.attributes, D = R.attributes;
    let L = 0;
    const H = O.getAttributes();
    for (const V in H)
      if (H[V].location >= 0) {
        const X = A[V];
        let F = D[V];
        if (F === void 0 && (V === "instanceMatrix" && w.instanceMatrix && (F = w.instanceMatrix), V === "instanceColor" && w.instanceColor && (F = w.instanceColor)), X === void 0 || X.attribute !== F || F && X.data !== F.data) return !0;
        L++;
      }
    return a.attributesNum !== L || a.index !== P;
  }
  function m(w, R, O, P) {
    const A = {}, D = R.attributes;
    let L = 0;
    const H = O.getAttributes();
    for (const V in H)
      if (H[V].location >= 0) {
        let X = D[V];
        X === void 0 && (V === "instanceMatrix" && w.instanceMatrix && (X = w.instanceMatrix), V === "instanceColor" && w.instanceColor && (X = w.instanceColor));
        const F = {};
        F.attribute = X, X && X.data && (F.data = X.data), A[V] = F, L++;
      }
    a.attributes = A, a.attributesNum = L, a.index = P;
  }
  function y() {
    const w = a.newAttributes;
    for (let R = 0, O = w.length; R < O; R++)
      w[R] = 0;
  }
  function v(w) {
    g(w, 0);
  }
  function g(w, R) {
    const O = a.newAttributes, P = a.enabledAttributes, A = a.attributeDivisors;
    O[w] = 1, P[w] === 0 && (r.enableVertexAttribArray(w), P[w] = 1), A[w] !== R && (r.vertexAttribDivisor(w, R), A[w] = R);
  }
  function _() {
    const w = a.newAttributes, R = a.enabledAttributes;
    for (let O = 0, P = R.length; O < P; O++)
      R[O] !== w[O] && (r.disableVertexAttribArray(O), R[O] = 0);
  }
  function x(w, R, O, P, A, D, L) {
    L === !0 ? r.vertexAttribIPointer(w, R, O, A, D) : r.vertexAttribPointer(w, R, O, P, A, D);
  }
  function b(w, R, O, P) {
    y();
    const A = P.attributes, D = O.getAttributes(), L = R.defaultAttributeValues;
    for (const H in D) {
      const V = D[H];
      if (V.location >= 0) {
        let X = A[H];
        if (X === void 0 && (H === "instanceMatrix" && w.instanceMatrix && (X = w.instanceMatrix), H === "instanceColor" && w.instanceColor && (X = w.instanceColor)), X !== void 0) {
          const F = X.normalized, B = X.itemSize, W = e.get(X);
          if (W === void 0) continue;
          const G = W.buffer, z = W.type, K = W.bytesPerElement, ne = z === r.INT || z === r.UNSIGNED_INT || X.gpuType === S_;
          if (X.isInterleavedBufferAttribute) {
            const oe = X.data, pe = oe.stride, xe = X.offset;
            if (oe.isInstancedInterleavedBuffer) {
              for (let Re = 0; Re < V.locationSize; Re++)
                g(V.location + Re, oe.meshPerAttribute);
              w.isInstancedMesh !== !0 && P._maxInstanceCount === void 0 && (P._maxInstanceCount = oe.meshPerAttribute * oe.count);
            } else
              for (let Re = 0; Re < V.locationSize; Re++)
                v(V.location + Re);
            r.bindBuffer(r.ARRAY_BUFFER, G);
            for (let Re = 0; Re < V.locationSize; Re++)
              x(
                V.location + Re,
                B / V.locationSize,
                z,
                F,
                pe * K,
                (xe + B / V.locationSize * Re) * K,
                ne
              );
          } else {
            if (X.isInstancedBufferAttribute) {
              for (let oe = 0; oe < V.locationSize; oe++)
                g(V.location + oe, X.meshPerAttribute);
              w.isInstancedMesh !== !0 && P._maxInstanceCount === void 0 && (P._maxInstanceCount = X.meshPerAttribute * X.count);
            } else
              for (let oe = 0; oe < V.locationSize; oe++)
                v(V.location + oe);
            r.bindBuffer(r.ARRAY_BUFFER, G);
            for (let oe = 0; oe < V.locationSize; oe++)
              x(
                V.location + oe,
                B / V.locationSize,
                z,
                F,
                B * K,
                B / V.locationSize * oe * K,
                ne
              );
          }
        } else if (L !== void 0) {
          const F = L[H];
          if (F !== void 0)
            switch (F.length) {
              case 2:
                r.vertexAttrib2fv(V.location, F);
                break;
              case 3:
                r.vertexAttrib3fv(V.location, F);
                break;
              case 4:
                r.vertexAttrib4fv(V.location, F);
                break;
              default:
                r.vertexAttrib1fv(V.location, F);
            }
        }
      }
    }
    _();
  }
  function T() {
    C();
    for (const w in n) {
      const R = n[w];
      for (const O in R) {
        const P = R[O];
        for (const A in P)
          h(P[A].object), delete P[A];
        delete R[O];
      }
      delete n[w];
    }
  }
  function E(w) {
    if (n[w.id] === void 0) return;
    const R = n[w.id];
    for (const O in R) {
      const P = R[O];
      for (const A in P)
        h(P[A].object), delete P[A];
      delete R[O];
    }
    delete n[w.id];
  }
  function M(w) {
    for (const R in n) {
      const O = n[R];
      if (O[w.id] === void 0) continue;
      const P = O[w.id];
      for (const A in P)
        h(P[A].object), delete P[A];
      delete O[w.id];
    }
  }
  function C() {
    S(), o = !0, a !== s && (a = s, c(a.object));
  }
  function S() {
    s.geometry = null, s.program = null, s.wireframe = !1;
  }
  return {
    setup: l,
    reset: C,
    resetDefaultState: S,
    dispose: T,
    releaseStatesOfGeometry: E,
    releaseStatesOfProgram: M,
    initAttributes: y,
    enableAttribute: v,
    disableUnusedAttributes: _
  };
}
function Ez(r, e, i) {
  let n;
  function s(c) {
    n = c;
  }
  function a(c, h) {
    r.drawArrays(n, c, h), i.update(h, n, 1);
  }
  function o(c, h, d) {
    d !== 0 && (r.drawArraysInstanced(n, c, h, d), i.update(h, n, d));
  }
  function l(c, h, d) {
    if (d === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, h, 0, d);
    let p = 0;
    for (let f = 0; f < d; f++)
      p += h[f];
    i.update(p, n, 1);
  }
  function u(c, h, d, p) {
    if (d === 0) return;
    const f = e.get("WEBGL_multi_draw");
    if (f === null)
      for (let m = 0; m < c.length; m++)
        o(c[m], h[m], p[m]);
    else {
      f.multiDrawArraysInstancedWEBGL(n, c, 0, h, 0, p, 0, d);
      let m = 0;
      for (let y = 0; y < d; y++)
        m += h[y] * p[y];
      i.update(m, n, 1);
    }
  }
  this.setMode = s, this.render = a, this.renderInstances = o, this.renderMultiDraw = l, this.renderMultiDrawInstances = u;
}
function Mz(r, e, i, n) {
  let s;
  function a() {
    if (s !== void 0) return s;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const M = e.get("EXT_texture_filter_anisotropic");
      s = r.getParameter(M.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      s = 0;
    return s;
  }
  function o(M) {
    return !(M !== Xn && n.convert(M) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function l(M) {
    const C = M === Lc && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(M !== ba && n.convert(M) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    M !== ra && !C);
  }
  function u(M) {
    if (M === "highp") {
      if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
        return "highp";
      M = "mediump";
    }
    return M === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let c = i.precision !== void 0 ? i.precision : "highp";
  const h = u(c);
  h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
  const d = i.logarithmicDepthBuffer === !0, p = i.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), f = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), m = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), y = r.getParameter(r.MAX_TEXTURE_SIZE), v = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), g = r.getParameter(r.MAX_VERTEX_ATTRIBS), _ = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), x = r.getParameter(r.MAX_VARYING_VECTORS), b = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), T = m > 0, E = r.getParameter(r.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: a,
    getMaxPrecision: u,
    textureFormatReadable: o,
    textureTypeReadable: l,
    precision: c,
    logarithmicDepthBuffer: d,
    reverseDepthBuffer: p,
    maxTextures: f,
    maxVertexTextures: m,
    maxTextureSize: y,
    maxCubemapSize: v,
    maxAttributes: g,
    maxVertexUniforms: _,
    maxVaryings: x,
    maxFragmentUniforms: b,
    vertexTextures: T,
    maxSamples: E
  };
}
function Az(r) {
  const e = this;
  let i = null, n = 0, s = !1, a = !1;
  const o = new qs(), l = new It(), u = { value: null, needsUpdate: !1 };
  this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, p) {
    const f = d.length !== 0 || p || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || s;
    return s = p, n = d.length, f;
  }, this.beginShadows = function() {
    a = !0, h(null);
  }, this.endShadows = function() {
    a = !1;
  }, this.setGlobalState = function(d, p) {
    i = h(d, p, 0);
  }, this.setState = function(d, p, f) {
    const m = d.clippingPlanes, y = d.clipIntersection, v = d.clipShadows, g = r.get(d);
    if (!s || m === null || m.length === 0 || a && !v)
      a ? h(null) : c();
    else {
      const _ = a ? 0 : n, x = _ * 4;
      let b = g.clippingState || null;
      u.value = b, b = h(m, p, x, f);
      for (let T = 0; T !== x; ++T)
        b[T] = i[T];
      g.clippingState = b, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += _;
    }
  };
  function c() {
    u.value !== i && (u.value = i, u.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function h(d, p, f, m) {
    const y = d !== null ? d.length : 0;
    let v = null;
    if (y !== 0) {
      if (v = u.value, m !== !0 || v === null) {
        const g = f + y * 4, _ = p.matrixWorldInverse;
        l.getNormalMatrix(_), (v === null || v.length < g) && (v = new Float32Array(g));
        for (let x = 0, b = f; x !== y; ++x, b += 4)
          o.copy(d[x]).applyMatrix4(_, l), o.normal.toArray(v, b), v[b + 3] = o.constant;
      }
      u.value = v, u.needsUpdate = !0;
    }
    return e.numPlanes = y, e.numIntersection = 0, v;
  }
}
function Cz(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function i(o, l) {
    return l === tb ? o.mapping = dc : l === ib && (o.mapping = pc), o;
  }
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping;
      if (l === tb || l === ib)
        if (e.has(o)) {
          const u = e.get(o).texture;
          return i(u, o.mapping);
        } else {
          const u = o.image;
          if (u && u.height > 0) {
            const c = new BF(u.height);
            return c.fromEquirectangularTexture(r, o), e.set(o, c), o.addEventListener("dispose", s), i(c.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function s(o) {
    const l = o.target;
    l.removeEventListener("dispose", s);
    const u = e.get(l);
    u !== void 0 && (e.delete(l), u.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: a
  };
}
let D_ = class extends mR {
  constructor(r = -1, e = 1, i = 1, n = -1, s = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = r, this.right = e, this.top = i, this.bottom = n, this.near = s, this.far = a, this.updateProjectionMatrix();
  }
  copy(r, e) {
    return super.copy(r, e), this.left = r.left, this.right = r.right, this.top = r.top, this.bottom = r.bottom, this.near = r.near, this.far = r.far, this.zoom = r.zoom, this.view = r.view === null ? null : Object.assign({}, r.view), this;
  }
  setViewOffset(r, e, i, n, s, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = r, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const r = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
    let s = i - r, a = i + r, o = n + e, l = n - e;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += u * this.view.offsetX, a = s + u * this.view.width, o -= c * this.view.offsetY, l = o - c * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
};
const Iu = 4, Kw = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Yo = 20, By = /* @__PURE__ */ new D_(), Zw = /* @__PURE__ */ new Ut();
let zy = null, jy = 0, Vy = 0, Gy = !1;
const jo = (1 + Math.sqrt(5)) / 2, Jl = 1 / jo, Qw = [
  /* @__PURE__ */ new Y(-jo, Jl, 0),
  /* @__PURE__ */ new Y(jo, Jl, 0),
  /* @__PURE__ */ new Y(-Jl, 0, jo),
  /* @__PURE__ */ new Y(Jl, 0, jo),
  /* @__PURE__ */ new Y(0, jo, -Jl),
  /* @__PURE__ */ new Y(0, jo, Jl),
  /* @__PURE__ */ new Y(-1, 1, -1),
  /* @__PURE__ */ new Y(1, 1, -1),
  /* @__PURE__ */ new Y(-1, 1, 1),
  /* @__PURE__ */ new Y(1, 1, 1)
];
let $w = class {
  constructor(r) {
    this._renderer = r, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(r, e = 0, i = 0.1, n = 100) {
    zy = this._renderer.getRenderTarget(), jy = this._renderer.getActiveCubeFace(), Vy = this._renderer.getActiveMipmapLevel(), Gy = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(r, i, n, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(r, e = null) {
    return this._fromTexture(r, e);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(r, e = null) {
    return this._fromTexture(r, e);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = tS(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = eS(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(r) {
    this._lodMax = Math.floor(Math.log2(r)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let r = 0; r < this._lodPlanes.length; r++)
      this._lodPlanes[r].dispose();
  }
  _cleanup(r) {
    this._renderer.setRenderTarget(zy, jy, Vy), this._renderer.xr.enabled = Gy, r.scissorTest = !1, Np(r, 0, 0, r.width, r.height);
  }
  _fromTexture(r, e) {
    r.mapping === dc || r.mapping === pc ? this._setSize(r.image.length === 0 ? 16 : r.image[0].width || r.image[0].image.width) : this._setSize(r.image.width / 4), zy = this._renderer.getRenderTarget(), jy = this._renderer.getActiveCubeFace(), Vy = this._renderer.getActiveMipmapLevel(), Gy = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const i = e || this._allocateTargets();
    return this._textureToCubeUV(r, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const r = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, i = {
      magFilter: ds,
      minFilter: ds,
      generateMipmaps: !1,
      type: Lc,
      format: Xn,
      colorSpace: kc,
      depthBuffer: !1
    }, n = Jw(r, e, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== r || this._pingPongRenderTarget.height !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Jw(r, e, i);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Rz(s)), this._blurMaterial = Nz(s, r, e);
    }
    return n;
  }
  _compileMaterial(r) {
    const e = new kr(this._lodPlanes[0], r);
    this._renderer.compile(e, By);
  }
  _sceneToCubeUV(r, e, i, n) {
    const s = new vn(90, 1, e, i), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], l = this._renderer, u = l.autoClear, c = l.toneMapping;
    l.getClearColor(Zw), l.toneMapping = oo, l.autoClear = !1;
    const h = new Tg({
      name: "PMREM.Background",
      side: Ar,
      depthWrite: !1,
      depthTest: !1
    }), d = new kr(new I_(), h);
    let p = !1;
    const f = r.background;
    f ? f.isColor && (h.color.copy(f), r.background = null, p = !0) : (h.color.copy(Zw), p = !0);
    for (let m = 0; m < 6; m++) {
      const y = m % 3;
      y === 0 ? (s.up.set(0, a[m], 0), s.lookAt(o[m], 0, 0)) : y === 1 ? (s.up.set(0, 0, a[m]), s.lookAt(0, o[m], 0)) : (s.up.set(0, a[m], 0), s.lookAt(0, 0, o[m]));
      const v = this._cubeSize;
      Np(n, y * v, m > 2 ? v : 0, v, v), l.setRenderTarget(n), p && l.render(d, s), l.render(r, s);
    }
    d.geometry.dispose(), d.material.dispose(), l.toneMapping = c, l.autoClear = u, r.background = f;
  }
  _textureToCubeUV(r, e) {
    const i = this._renderer, n = r.mapping === dc || r.mapping === pc;
    n ? (this._cubemapMaterial === null && (this._cubemapMaterial = tS()), this._cubemapMaterial.uniforms.flipEnvMap.value = r.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = eS());
    const s = n ? this._cubemapMaterial : this._equirectMaterial, a = new kr(this._lodPlanes[0], s), o = s.uniforms;
    o.envMap.value = r;
    const l = this._cubeSize;
    Np(e, 0, 0, 3 * l, 2 * l), i.setRenderTarget(e), i.render(a, By);
  }
  _applyPMREM(r) {
    const e = this._renderer, i = e.autoClear;
    e.autoClear = !1;
    const n = this._lodPlanes.length;
    for (let s = 1; s < n; s++) {
      const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]), o = Qw[(n - s - 1) % Qw.length];
      this._blur(r, s - 1, s, a, o);
    }
    e.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(r, e, i, n, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      r,
      a,
      e,
      i,
      n,
      "latitudinal",
      s
    ), this._halfBlur(
      a,
      r,
      i,
      i,
      n,
      "longitudinal",
      s
    );
  }
  _halfBlur(r, e, i, n, s, a, o) {
    const l = this._renderer, u = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const c = 3, h = new kr(this._lodPlanes[n], u), d = u.uniforms, p = this._sizeLods[i] - 1, f = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * Yo - 1), m = s / f, y = isFinite(s) ? 1 + Math.floor(c * m) : Yo;
    y > Yo && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${Yo}`);
    const v = [];
    let g = 0;
    for (let E = 0; E < Yo; ++E) {
      const M = E / m, C = Math.exp(-M * M / 2);
      v.push(C), E === 0 ? g += C : E < y && (g += 2 * C);
    }
    for (let E = 0; E < v.length; E++)
      v[E] = v[E] / g;
    d.envMap.value = r.texture, d.samples.value = y, d.weights.value = v, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
    const { _lodMax: _ } = this;
    d.dTheta.value = f, d.mipInt.value = _ - i;
    const x = this._sizeLods[n], b = 3 * x * (n > _ - Iu ? n - _ + Iu : 0), T = 4 * (this._cubeSize - x);
    Np(e, b, T, 3 * x, 2 * x), l.setRenderTarget(e), l.render(h, By);
  }
};
function Rz(r) {
  const e = [], i = [], n = [];
  let s = r;
  const a = r - Iu + 1 + Kw.length;
  for (let o = 0; o < a; o++) {
    const l = Math.pow(2, s);
    i.push(l);
    let u = 1 / l;
    o > r - Iu ? u = Kw[o - r + Iu - 1] : o === 0 && (u = 0), n.push(u);
    const c = 1 / (l - 2), h = -c, d = 1 + c, p = [h, h, d, h, d, d, h, h, d, d, h, d], f = 6, m = 6, y = 3, v = 2, g = 1, _ = new Float32Array(y * m * f), x = new Float32Array(v * m * f), b = new Float32Array(g * m * f);
    for (let E = 0; E < f; E++) {
      const M = E % 3 * 2 / 3 - 1, C = E > 2 ? 0 : -1, S = [
        M,
        C,
        0,
        M + 2 / 3,
        C,
        0,
        M + 2 / 3,
        C + 1,
        0,
        M,
        C,
        0,
        M + 2 / 3,
        C + 1,
        0,
        M,
        C + 1,
        0
      ];
      _.set(S, y * m * E), x.set(p, v * m * E);
      const w = [E, E, E, E, E, E];
      b.set(w, g * m * E);
    }
    const T = new cn();
    T.setAttribute("position", new _n(_, y)), T.setAttribute("uv", new _n(x, v)), T.setAttribute("faceIndex", new _n(b, g)), e.push(T), s > Iu && s--;
  }
  return { lodPlanes: e, sizeLods: i, sigmas: n };
}
function Jw(r, e, i) {
  const n = new mo(r, e, i);
  return n.texture.mapping = vg, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function Np(r, e, i, n, s) {
  r.viewport.set(e, i, n, s), r.scissor.set(e, i, n, s);
}
function Nz(r, e, i) {
  const n = new Float32Array(Yo), s = new Y(0, 1, 0);
  return new xs({
    name: "SphericalGaussianBlur",
    defines: {
      n: Yo,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / i,
      CUBEUV_MAX_MIP: `${r}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: s }
    },
    vertexShader: L_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: la,
    depthTest: !1,
    depthWrite: !1
  });
}
function eS() {
  return new xs({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: L_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: la,
    depthTest: !1,
    depthWrite: !1
  });
}
function tS() {
  return new xs({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: L_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: la,
    depthTest: !1,
    depthWrite: !1
  });
}
function L_() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function Pz(r) {
  let e = /* @__PURE__ */ new WeakMap(), i = null;
  function n(l) {
    if (l && l.isTexture) {
      const u = l.mapping, c = u === tb || u === ib, h = u === dc || u === pc;
      if (c || h) {
        let d = e.get(l);
        const p = d !== void 0 ? d.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== p)
          return i === null && (i = new $w(r)), d = c ? i.fromEquirectangular(l, d) : i.fromCubemap(l, d), d.texture.pmremVersion = l.pmremVersion, e.set(l, d), d.texture;
        if (d !== void 0)
          return d.texture;
        {
          const f = l.image;
          return c && f && f.height > 0 || h && f && s(f) ? (i === null && (i = new $w(r)), d = c ? i.fromEquirectangular(l) : i.fromCubemap(l), d.texture.pmremVersion = l.pmremVersion, e.set(l, d), l.addEventListener("dispose", a), d.texture) : null;
        }
      }
    }
    return l;
  }
  function s(l) {
    let u = 0;
    const c = 6;
    for (let h = 0; h < c; h++)
      l[h] !== void 0 && u++;
    return u === c;
  }
  function a(l) {
    const u = l.target;
    u.removeEventListener("dispose", a);
    const c = e.get(u);
    c !== void 0 && (e.delete(u), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), i !== null && (i.dispose(), i = null);
  }
  return {
    get: n,
    dispose: o
  };
}
function Iz(r) {
  const e = {};
  function i(n) {
    if (e[n] !== void 0)
      return e[n];
    let s;
    switch (n) {
      case "WEBGL_depth_texture":
        s = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        s = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        s = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        s = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        s = r.getExtension(n);
    }
    return e[n] = s, s;
  }
  return {
    has: function(n) {
      return i(n) !== null;
    },
    init: function() {
      i("EXT_color_buffer_float"), i("WEBGL_clip_cull_distance"), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float"), i("WEBGL_multisampled_render_to_texture"), i("WEBGL_render_shared_exponent");
    },
    get: function(n) {
      const s = i(n);
      return s === null && Uh("THREE.WebGLRenderer: " + n + " extension not supported."), s;
    }
  };
}
function Oz(r, e, i, n) {
  const s = {}, a = /* @__PURE__ */ new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const m in p.attributes)
      e.remove(p.attributes[m]);
    for (const m in p.morphAttributes) {
      const y = p.morphAttributes[m];
      for (let v = 0, g = y.length; v < g; v++)
        e.remove(y[v]);
    }
    p.removeEventListener("dispose", o), delete s[p.id];
    const f = a.get(p);
    f && (e.remove(f), a.delete(p)), n.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, i.memory.geometries--;
  }
  function l(d, p) {
    return s[p.id] === !0 || (p.addEventListener("dispose", o), s[p.id] = !0, i.memory.geometries++), p;
  }
  function u(d) {
    const p = d.attributes;
    for (const m in p)
      e.update(p[m], r.ARRAY_BUFFER);
    const f = d.morphAttributes;
    for (const m in f) {
      const y = f[m];
      for (let v = 0, g = y.length; v < g; v++)
        e.update(y[v], r.ARRAY_BUFFER);
    }
  }
  function c(d) {
    const p = [], f = d.index, m = d.attributes.position;
    let y = 0;
    if (f !== null) {
      const _ = f.array;
      y = f.version;
      for (let x = 0, b = _.length; x < b; x += 3) {
        const T = _[x + 0], E = _[x + 1], M = _[x + 2];
        p.push(T, E, E, M, M, T);
      }
    } else if (m !== void 0) {
      const _ = m.array;
      y = m.version;
      for (let x = 0, b = _.length / 3 - 1; x < b; x += 3) {
        const T = x + 0, E = x + 1, M = x + 2;
        p.push(T, E, E, M, M, T);
      }
    } else
      return;
    const v = new (iR(p) ? cR : uR)(p, 1);
    v.version = y;
    const g = a.get(d);
    g && e.remove(g), a.set(d, v);
  }
  function h(d) {
    const p = a.get(d);
    if (p) {
      const f = d.index;
      f !== null && p.version < f.version && c(d);
    } else
      c(d);
    return a.get(d);
  }
  return {
    get: l,
    update: u,
    getWireframeAttribute: h
  };
}
function Dz(r, e, i) {
  let n;
  function s(p) {
    n = p;
  }
  let a, o;
  function l(p) {
    a = p.type, o = p.bytesPerElement;
  }
  function u(p, f) {
    r.drawElements(n, f, a, p * o), i.update(f, n, 1);
  }
  function c(p, f, m) {
    m !== 0 && (r.drawElementsInstanced(n, f, a, p * o, m), i.update(f, n, m));
  }
  function h(p, f, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, f, 0, a, p, 0, m);
    let y = 0;
    for (let v = 0; v < m; v++)
      y += f[v];
    i.update(y, n, 1);
  }
  function d(p, f, m, y) {
    if (m === 0) return;
    const v = e.get("WEBGL_multi_draw");
    if (v === null)
      for (let g = 0; g < p.length; g++)
        c(p[g] / o, f[g], y[g]);
    else {
      v.multiDrawElementsInstancedWEBGL(n, f, 0, a, p, 0, y, 0, m);
      let g = 0;
      for (let _ = 0; _ < m; _++)
        g += f[_] * y[_];
      i.update(g, n, 1);
    }
  }
  this.setMode = s, this.setIndex = l, this.render = u, this.renderInstances = c, this.renderMultiDraw = h, this.renderMultiDrawInstances = d;
}
function Lz(r) {
  const e = {
    geometries: 0,
    textures: 0
  }, i = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(a, o, l) {
    switch (i.calls++, o) {
      case r.TRIANGLES:
        i.triangles += l * (a / 3);
        break;
      case r.LINES:
        i.lines += l * (a / 2);
        break;
      case r.LINE_STRIP:
        i.lines += l * (a - 1);
        break;
      case r.LINE_LOOP:
        i.lines += l * a;
        break;
      case r.POINTS:
        i.points += l * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function s() {
    i.calls = 0, i.triangles = 0, i.points = 0, i.lines = 0;
  }
  return {
    memory: e,
    render: i,
    programs: null,
    autoReset: !0,
    reset: s,
    update: n
  };
}
function kz(r, e, i) {
  const n = /* @__PURE__ */ new WeakMap(), s = new Fi();
  function a(o, l, u) {
    const c = o.morphTargetInfluences, h = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color, d = h !== void 0 ? h.length : 0;
    let p = n.get(l);
    if (p === void 0 || p.count !== d) {
      let f = function() {
        C.dispose(), n.delete(l), l.removeEventListener("dispose", f);
      };
      p !== void 0 && p.texture.dispose();
      const m = l.morphAttributes.position !== void 0, y = l.morphAttributes.normal !== void 0, v = l.morphAttributes.color !== void 0, g = l.morphAttributes.position || [], _ = l.morphAttributes.normal || [], x = l.morphAttributes.color || [];
      let b = 0;
      m === !0 && (b = 1), y === !0 && (b = 2), v === !0 && (b = 3);
      let T = l.attributes.position.count * b, E = 1;
      T > e.maxTextureSize && (E = Math.ceil(T / e.maxTextureSize), T = e.maxTextureSize);
      const M = new Float32Array(T * E * 4 * d), C = new sR(M, T, E, d);
      C.type = ra, C.needsUpdate = !0;
      const S = b * 4;
      for (let w = 0; w < d; w++) {
        const R = g[w], O = _[w], P = x[w], A = T * E * 4 * w;
        for (let D = 0; D < R.count; D++) {
          const L = D * S;
          m === !0 && (s.fromBufferAttribute(R, D), M[A + L + 0] = s.x, M[A + L + 1] = s.y, M[A + L + 2] = s.z, M[A + L + 3] = 0), y === !0 && (s.fromBufferAttribute(O, D), M[A + L + 4] = s.x, M[A + L + 5] = s.y, M[A + L + 6] = s.z, M[A + L + 7] = 0), v === !0 && (s.fromBufferAttribute(P, D), M[A + L + 8] = s.x, M[A + L + 9] = s.y, M[A + L + 10] = s.z, M[A + L + 11] = P.itemSize === 4 ? s.w : 1);
        }
      }
      p = {
        count: d,
        texture: C,
        size: new ke(T, E)
      }, n.set(l, p), l.addEventListener("dispose", f);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      u.getUniforms().setValue(r, "morphTexture", o.morphTexture, i);
    else {
      let f = 0;
      for (let y = 0; y < c.length; y++)
        f += c[y];
      const m = l.morphTargetsRelative ? 1 : 1 - f;
      u.getUniforms().setValue(r, "morphTargetBaseInfluence", m), u.getUniforms().setValue(r, "morphTargetInfluences", c);
    }
    u.getUniforms().setValue(r, "morphTargetsTexture", p.texture, i), u.getUniforms().setValue(r, "morphTargetsTextureSize", p.size);
  }
  return {
    update: a
  };
}
function Uz(r, e, i, n) {
  let s = /* @__PURE__ */ new WeakMap();
  function a(u) {
    const c = n.render.frame, h = u.geometry, d = e.get(u, h);
    if (s.get(d) !== c && (e.update(d), s.set(d, c)), u.isInstancedMesh && (u.hasEventListener("dispose", l) === !1 && u.addEventListener("dispose", l), s.get(u) !== c && (i.update(u.instanceMatrix, r.ARRAY_BUFFER), u.instanceColor !== null && i.update(u.instanceColor, r.ARRAY_BUFFER), s.set(u, c))), u.isSkinnedMesh) {
      const p = u.skeleton;
      s.get(p) !== c && (p.update(), s.set(p, c));
    }
    return d;
  }
  function o() {
    s = /* @__PURE__ */ new WeakMap();
  }
  function l(u) {
    const c = u.target;
    c.removeEventListener("dispose", l), i.remove(c.instanceMatrix), c.instanceColor !== null && i.remove(c.instanceColor);
  }
  return {
    update: a,
    dispose: o
  };
}
let vR = class extends En {
  constructor(r, e, i, n, s, a, o, l, u, c = Hu) {
    if (c !== Hu && c !== mc)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && c === Hu && (i = xl), i === void 0 && c === mc && (i = fc), super(null, n, s, a, o, l, c, i, u), this.isDepthTexture = !0, this.image = { width: r, height: e }, this.magFilter = o !== void 0 ? o : Zn, this.minFilter = l !== void 0 ? l : Zn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(r) {
    return super.copy(r), this.compareFunction = r.compareFunction, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
  }
};
const bR = /* @__PURE__ */ new En(), iS = /* @__PURE__ */ new vR(1, 1), xR = /* @__PURE__ */ new sR(), _R = /* @__PURE__ */ new SF(), TR = /* @__PURE__ */ new gR(), rS = [], nS = [], sS = new Float32Array(16), aS = new Float32Array(9), oS = new Float32Array(4);
function Uc(r, e, i) {
  const n = r[0];
  if (n <= 0 || n > 0) return r;
  const s = e * i;
  let a = rS[s];
  if (a === void 0 && (a = new Float32Array(s), rS[s] = a), e !== 0) {
    n.toArray(a, 0);
    for (let o = 1, l = 0; o !== e; ++o)
      l += i, r[o].toArray(a, l);
  }
  return a;
}
function Hi(r, e) {
  if (r.length !== e.length) return !1;
  for (let i = 0, n = r.length; i < n; i++)
    if (r[i] !== e[i]) return !1;
  return !0;
}
function Wi(r, e) {
  for (let i = 0, n = e.length; i < n; i++)
    r[i] = e[i];
}
function wg(r, e) {
  let i = nS[e];
  i === void 0 && (i = new Int32Array(e), nS[e] = i);
  for (let n = 0; n !== e; ++n)
    i[n] = r.allocateTextureUnit();
  return i;
}
function Fz(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1f(this.addr, e), i[0] = e);
}
function Bz(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Hi(i, e)) return;
    r.uniform2fv(this.addr, e), Wi(i, e);
  }
}
function zz(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else if (e.r !== void 0)
    (i[0] !== e.r || i[1] !== e.g || i[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
  else {
    if (Hi(i, e)) return;
    r.uniform3fv(this.addr, e), Wi(i, e);
  }
}
function jz(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Hi(i, e)) return;
    r.uniform4fv(this.addr, e), Wi(i, e);
  }
}
function Vz(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Hi(i, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), Wi(i, e);
  } else {
    if (Hi(i, n)) return;
    oS.set(n), r.uniformMatrix2fv(this.addr, !1, oS), Wi(i, n);
  }
}
function Gz(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Hi(i, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), Wi(i, e);
  } else {
    if (Hi(i, n)) return;
    aS.set(n), r.uniformMatrix3fv(this.addr, !1, aS), Wi(i, n);
  }
}
function Hz(r, e) {
  const i = this.cache, n = e.elements;
  if (n === void 0) {
    if (Hi(i, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), Wi(i, e);
  } else {
    if (Hi(i, n)) return;
    sS.set(n), r.uniformMatrix4fv(this.addr, !1, sS), Wi(i, n);
  }
}
function Wz(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1i(this.addr, e), i[0] = e);
}
function qz(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Hi(i, e)) return;
    r.uniform2iv(this.addr, e), Wi(i, e);
  }
}
function Xz(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else {
    if (Hi(i, e)) return;
    r.uniform3iv(this.addr, e), Wi(i, e);
  }
}
function Yz(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Hi(i, e)) return;
    r.uniform4iv(this.addr, e), Wi(i, e);
  }
}
function Kz(r, e) {
  const i = this.cache;
  i[0] !== e && (r.uniform1ui(this.addr, e), i[0] = e);
}
function Zz(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
  else {
    if (Hi(i, e)) return;
    r.uniform2uiv(this.addr, e), Wi(i, e);
  }
}
function Qz(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
  else {
    if (Hi(i, e)) return;
    r.uniform3uiv(this.addr, e), Wi(i, e);
  }
}
function $z(r, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
  else {
    if (Hi(i, e)) return;
    r.uniform4uiv(this.addr, e), Wi(i, e);
  }
}
function Jz(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s);
  let a;
  this.type === r.SAMPLER_2D_SHADOW ? (iS.compareFunction = JC, a = iS) : a = bR, i.setTexture2D(e || a, s);
}
function e6(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTexture3D(e || _R, s);
}
function t6(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTextureCube(e || TR, s);
}
function i6(r, e, i) {
  const n = this.cache, s = i.allocateTextureUnit();
  n[0] !== s && (r.uniform1i(this.addr, s), n[0] = s), i.setTexture2DArray(e || xR, s);
}
function r6(r) {
  switch (r) {
    case 5126:
      return Fz;
    case 35664:
      return Bz;
    case 35665:
      return zz;
    case 35666:
      return jz;
    case 35674:
      return Vz;
    case 35675:
      return Gz;
    case 35676:
      return Hz;
    case 5124:
    case 35670:
      return Wz;
    case 35667:
    case 35671:
      return qz;
    case 35668:
    case 35672:
      return Xz;
    case 35669:
    case 35673:
      return Yz;
    case 5125:
      return Kz;
    case 36294:
      return Zz;
    case 36295:
      return Qz;
    case 36296:
      return $z;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Jz;
    case 35679:
    case 36299:
    case 36307:
      return e6;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return t6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return i6;
  }
}
function n6(r, e) {
  r.uniform1fv(this.addr, e);
}
function s6(r, e) {
  const i = Uc(e, this.size, 2);
  r.uniform2fv(this.addr, i);
}
function a6(r, e) {
  const i = Uc(e, this.size, 3);
  r.uniform3fv(this.addr, i);
}
function o6(r, e) {
  const i = Uc(e, this.size, 4);
  r.uniform4fv(this.addr, i);
}
function l6(r, e) {
  const i = Uc(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, i);
}
function u6(r, e) {
  const i = Uc(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, i);
}
function c6(r, e) {
  const i = Uc(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, i);
}
function h6(r, e) {
  r.uniform1iv(this.addr, e);
}
function d6(r, e) {
  r.uniform2iv(this.addr, e);
}
function p6(r, e) {
  r.uniform3iv(this.addr, e);
}
function f6(r, e) {
  r.uniform4iv(this.addr, e);
}
function m6(r, e) {
  r.uniform1uiv(this.addr, e);
}
function g6(r, e) {
  r.uniform2uiv(this.addr, e);
}
function y6(r, e) {
  r.uniform3uiv(this.addr, e);
}
function v6(r, e) {
  r.uniform4uiv(this.addr, e);
}
function b6(r, e, i) {
  const n = this.cache, s = e.length, a = wg(i, s);
  Hi(n, a) || (r.uniform1iv(this.addr, a), Wi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture2D(e[o] || bR, a[o]);
}
function x6(r, e, i) {
  const n = this.cache, s = e.length, a = wg(i, s);
  Hi(n, a) || (r.uniform1iv(this.addr, a), Wi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture3D(e[o] || _R, a[o]);
}
function _6(r, e, i) {
  const n = this.cache, s = e.length, a = wg(i, s);
  Hi(n, a) || (r.uniform1iv(this.addr, a), Wi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTextureCube(e[o] || TR, a[o]);
}
function T6(r, e, i) {
  const n = this.cache, s = e.length, a = wg(i, s);
  Hi(n, a) || (r.uniform1iv(this.addr, a), Wi(n, a));
  for (let o = 0; o !== s; ++o)
    i.setTexture2DArray(e[o] || xR, a[o]);
}
function w6(r) {
  switch (r) {
    case 5126:
      return n6;
    case 35664:
      return s6;
    case 35665:
      return a6;
    case 35666:
      return o6;
    case 35674:
      return l6;
    case 35675:
      return u6;
    case 35676:
      return c6;
    case 5124:
    case 35670:
      return h6;
    case 35667:
    case 35671:
      return d6;
    case 35668:
    case 35672:
      return p6;
    case 35669:
    case 35673:
      return f6;
    case 5125:
      return m6;
    case 36294:
      return g6;
    case 36295:
      return y6;
    case 36296:
      return v6;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return b6;
    case 35679:
    case 36299:
    case 36307:
      return x6;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return _6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return T6;
  }
}
class S6 {
  constructor(e, i, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = i.type, this.setValue = r6(i.type);
  }
}
class E6 {
  constructor(e, i, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = i.type, this.size = i.size, this.setValue = w6(i.type);
  }
}
class M6 {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, i, n) {
    const s = this.seq;
    for (let a = 0, o = s.length; a !== o; ++a) {
      const l = s[a];
      l.setValue(e, i[l.id], n);
    }
  }
}
const Hy = /(\w+)(\])?(\[|\.)?/g;
function lS(r, e) {
  r.seq.push(e), r.map[e.id] = e;
}
function A6(r, e, i) {
  const n = r.name, s = n.length;
  for (Hy.lastIndex = 0; ; ) {
    const a = Hy.exec(n), o = Hy.lastIndex;
    let l = a[1];
    const u = a[2] === "]", c = a[3];
    if (u && (l = l | 0), c === void 0 || c === "[" && o + 2 === s) {
      lS(i, c === void 0 ? new S6(l, r, e) : new E6(l, r, e));
      break;
    } else {
      let h = i.map[l];
      h === void 0 && (h = new M6(l), lS(i, h)), i = h;
    }
  }
}
class Qf {
  constructor(e, i) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(i, e.ACTIVE_UNIFORMS);
    for (let s = 0; s < n; ++s) {
      const a = e.getActiveUniform(i, s), o = e.getUniformLocation(i, a.name);
      A6(a, o, this);
    }
  }
  setValue(e, i, n, s) {
    const a = this.map[i];
    a !== void 0 && a.setValue(e, n, s);
  }
  setOptional(e, i, n) {
    const s = i[n];
    s !== void 0 && this.setValue(e, n, s);
  }
  static upload(e, i, n, s) {
    for (let a = 0, o = i.length; a !== o; ++a) {
      const l = i[a], u = n[l.id];
      u.needsUpdate !== !1 && l.setValue(e, u.value, s);
    }
  }
  static seqWithValue(e, i) {
    const n = [];
    for (let s = 0, a = e.length; s !== a; ++s) {
      const o = e[s];
      o.id in i && n.push(o);
    }
    return n;
  }
}
function uS(r, e, i) {
  const n = r.createShader(e);
  return r.shaderSource(n, i), r.compileShader(n), n;
}
const C6 = 37297;
let R6 = 0;
function N6(r, e) {
  const i = r.split(`
`), n = [], s = Math.max(e - 6, 0), a = Math.min(e + 6, i.length);
  for (let o = s; o < a; o++) {
    const l = o + 1;
    n.push(`${l === e ? ">" : " "} ${l}: ${i[o]}`);
  }
  return n.join(`
`);
}
const cS = /* @__PURE__ */ new It();
function P6(r) {
  Ht._getMatrix(cS, Ht.workingColorSpace, r);
  const e = `mat3( ${cS.elements.map((i) => i.toFixed(4))} )`;
  switch (Ht.getTransfer(r)) {
    case bg:
      return [e, "LinearTransferOETF"];
    case ei:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", r), [e, "LinearTransferOETF"];
  }
}
function hS(r, e, i) {
  const n = r.getShaderParameter(e, r.COMPILE_STATUS), s = r.getShaderInfoLog(e).trim();
  if (n && s === "") return "";
  const a = /ERROR: 0:(\d+)/.exec(s);
  if (a) {
    const o = parseInt(a[1]);
    return i.toUpperCase() + `

` + s + `

` + N6(r.getShaderSource(e), o);
  } else
    return s;
}
function I6(r, e) {
  const i = P6(e);
  return [
    `vec4 ${r}( vec4 value ) {`,
    `	return ${i[1]}( vec4( value.rgb * ${i[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function O6(r, e) {
  let i;
  switch (e) {
    case kU:
      i = "Linear";
      break;
    case UU:
      i = "Reinhard";
      break;
    case FU:
      i = "Cineon";
      break;
    case BU:
      i = "ACESFilmic";
      break;
    case jU:
      i = "AgX";
      break;
    case VU:
      i = "Neutral";
      break;
    case zU:
      i = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), i = "Linear";
  }
  return "vec3 " + r + "( vec3 color ) { return " + i + "ToneMapping( color ); }";
}
const Pp = /* @__PURE__ */ new Y();
function D6() {
  Ht.getLuminanceCoefficients(Pp);
  const r = Pp.x.toFixed(4), e = Pp.y.toFixed(4), i = Pp.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r}, ${e}, ${i} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function L6(r) {
  return [
    r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(Fh).join(`
`);
}
function k6(r) {
  const e = [];
  for (const i in r) {
    const n = r[i];
    n !== !1 && e.push("#define " + i + " " + n);
  }
  return e.join(`
`);
}
function U6(r, e) {
  const i = {}, n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
  for (let s = 0; s < n; s++) {
    const a = r.getActiveAttrib(e, s), o = a.name;
    let l = 1;
    a.type === r.FLOAT_MAT2 && (l = 2), a.type === r.FLOAT_MAT3 && (l = 3), a.type === r.FLOAT_MAT4 && (l = 4), i[o] = {
      type: a.type,
      location: r.getAttribLocation(e, o),
      locationSize: l
    };
  }
  return i;
}
function Fh(r) {
  return r !== "";
}
function dS(r, e) {
  const i = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function pS(r, e) {
  return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const F6 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Db(r) {
  return r.replace(F6, z6);
}
const B6 = /* @__PURE__ */ new Map();
function z6(r, e) {
  let i = Rt[e];
  if (i === void 0) {
    const n = B6.get(e);
    if (n !== void 0)
      i = Rt[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return Db(i);
}
const j6 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function fS(r) {
  return r.replace(j6, V6);
}
function V6(r, e, i, n) {
  let s = "";
  for (let a = parseInt(e); a < parseInt(i); a++)
    s += n.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
  return s;
}
function mS(r) {
  let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
  return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function G6(r) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return r.shadowMapType === zC ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === mU ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === Gs && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function H6(r) {
  let e = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case dc:
      case pc:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case vg:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function W6(r) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case pc:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function q6(r) {
  let e = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case w_:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case DU:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case LU:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function X6(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const i = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 7 * 16)), texelHeight: n, maxMip: i };
}
function Y6(r, e, i, n) {
  const s = r.getContext(), a = i.defines;
  let o = i.vertexShader, l = i.fragmentShader;
  const u = G6(i), c = H6(i), h = W6(i), d = q6(i), p = X6(i), f = L6(i), m = k6(a), y = s.createProgram();
  let v, g, _ = i.glslVersion ? "#version " + i.glslVersion + `
` : "";
  i.isRawShaderMaterial ? (v = [
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m
  ].filter(Fh).join(`
`), v.length > 0 && (v += `
`), g = [
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m
  ].filter(Fh).join(`
`), g.length > 0 && (g += `
`)) : (v = [
    mS(i),
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m,
    i.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    i.batching ? "#define USE_BATCHING" : "",
    i.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    i.instancing ? "#define USE_INSTANCING" : "",
    i.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    i.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    i.useFog && i.fog ? "#define USE_FOG" : "",
    i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
    i.map ? "#define USE_MAP" : "",
    i.envMap ? "#define USE_ENVMAP" : "",
    i.envMap ? "#define " + h : "",
    i.lightMap ? "#define USE_LIGHTMAP" : "",
    i.aoMap ? "#define USE_AOMAP" : "",
    i.bumpMap ? "#define USE_BUMPMAP" : "",
    i.normalMap ? "#define USE_NORMALMAP" : "",
    i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    i.anisotropy ? "#define USE_ANISOTROPY" : "",
    i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    i.specularMap ? "#define USE_SPECULARMAP" : "",
    i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    i.metalnessMap ? "#define USE_METALNESSMAP" : "",
    i.alphaMap ? "#define USE_ALPHAMAP" : "",
    i.alphaHash ? "#define USE_ALPHAHASH" : "",
    i.transmission ? "#define USE_TRANSMISSION" : "",
    i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    i.mapUv ? "#define MAP_UV " + i.mapUv : "",
    i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "",
    i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "",
    i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "",
    i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "",
    i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "",
    i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "",
    i.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv : "",
    i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "",
    i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "",
    i.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv : "",
    i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "",
    i.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv : "",
    i.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv : "",
    i.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv : "",
    i.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i.iridescenceThicknessMapUv : "",
    i.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv : "",
    i.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv : "",
    i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "",
    i.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv : "",
    i.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv : "",
    i.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv : "",
    i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "",
    //
    i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "",
    i.vertexColors ? "#define USE_COLOR" : "",
    i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    i.vertexUv1s ? "#define USE_UV1" : "",
    i.vertexUv2s ? "#define USE_UV2" : "",
    i.vertexUv3s ? "#define USE_UV3" : "",
    i.pointsUvs ? "#define USE_POINTS_UV" : "",
    i.flatShading ? "#define FLAT_SHADED" : "",
    i.skinning ? "#define USE_SKINNING" : "",
    i.morphTargets ? "#define USE_MORPHTARGETS" : "",
    i.morphNormals && i.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    i.morphColors ? "#define USE_MORPHCOLORS" : "",
    i.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "",
    i.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "",
    i.doubleSided ? "#define DOUBLE_SIDED" : "",
    i.flipSided ? "#define FLIP_SIDED" : "",
    i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    i.shadowMapEnabled ? "#define " + u : "",
    i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Fh).join(`
`), g = [
    mS(i),
    "#define SHADER_TYPE " + i.shaderType,
    "#define SHADER_NAME " + i.shaderName,
    m,
    i.useFog && i.fog ? "#define USE_FOG" : "",
    i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
    i.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    i.map ? "#define USE_MAP" : "",
    i.matcap ? "#define USE_MATCAP" : "",
    i.envMap ? "#define USE_ENVMAP" : "",
    i.envMap ? "#define " + c : "",
    i.envMap ? "#define " + h : "",
    i.envMap ? "#define " + d : "",
    p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
    p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
    p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
    i.lightMap ? "#define USE_LIGHTMAP" : "",
    i.aoMap ? "#define USE_AOMAP" : "",
    i.bumpMap ? "#define USE_BUMPMAP" : "",
    i.normalMap ? "#define USE_NORMALMAP" : "",
    i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    i.anisotropy ? "#define USE_ANISOTROPY" : "",
    i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    i.clearcoat ? "#define USE_CLEARCOAT" : "",
    i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    i.dispersion ? "#define USE_DISPERSION" : "",
    i.iridescence ? "#define USE_IRIDESCENCE" : "",
    i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    i.specularMap ? "#define USE_SPECULARMAP" : "",
    i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    i.metalnessMap ? "#define USE_METALNESSMAP" : "",
    i.alphaMap ? "#define USE_ALPHAMAP" : "",
    i.alphaTest ? "#define USE_ALPHATEST" : "",
    i.alphaHash ? "#define USE_ALPHAHASH" : "",
    i.sheen ? "#define USE_SHEEN" : "",
    i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    i.transmission ? "#define USE_TRANSMISSION" : "",
    i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "",
    i.vertexColors || i.instancingColor || i.batchingColor ? "#define USE_COLOR" : "",
    i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    i.vertexUv1s ? "#define USE_UV1" : "",
    i.vertexUv2s ? "#define USE_UV2" : "",
    i.vertexUv3s ? "#define USE_UV3" : "",
    i.pointsUvs ? "#define USE_POINTS_UV" : "",
    i.gradientMap ? "#define USE_GRADIENTMAP" : "",
    i.flatShading ? "#define FLAT_SHADED" : "",
    i.doubleSided ? "#define DOUBLE_SIDED" : "",
    i.flipSided ? "#define FLIP_SIDED" : "",
    i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    i.shadowMapEnabled ? "#define " + u : "",
    i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    i.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    i.toneMapping !== oo ? "#define TONE_MAPPING" : "",
    i.toneMapping !== oo ? Rt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    i.toneMapping !== oo ? O6("toneMapping", i.toneMapping) : "",
    i.dithering ? "#define DITHERING" : "",
    i.opaque ? "#define OPAQUE" : "",
    Rt.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    I6("linearToOutputTexel", i.outputColorSpace),
    D6(),
    i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
    `
`
  ].filter(Fh).join(`
`)), o = Db(o), o = dS(o, i), o = pS(o, i), l = Db(l), l = dS(l, i), l = pS(l, i), o = fS(o), l = fS(l), i.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, v = [
    f,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + v, g = [
    "#define varying in",
    i.glslVersion === Aw ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    i.glslVersion === Aw ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + g);
  const x = _ + v + o, b = _ + g + l, T = uS(s, s.VERTEX_SHADER, x), E = uS(s, s.FRAGMENT_SHADER, b);
  s.attachShader(y, T), s.attachShader(y, E), i.index0AttributeName !== void 0 ? s.bindAttribLocation(y, 0, i.index0AttributeName) : i.morphTargets === !0 && s.bindAttribLocation(y, 0, "position"), s.linkProgram(y);
  function M(R) {
    if (r.debug.checkShaderErrors) {
      const O = s.getProgramInfoLog(y).trim(), P = s.getShaderInfoLog(T).trim(), A = s.getShaderInfoLog(E).trim();
      let D = !0, L = !0;
      if (s.getProgramParameter(y, s.LINK_STATUS) === !1)
        if (D = !1, typeof r.debug.onShaderError == "function")
          r.debug.onShaderError(s, y, T, E);
        else {
          const H = hS(s, T, "vertex"), V = hS(s, E, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(y, s.VALIDATE_STATUS) + `

Material Name: ` + R.name + `
Material Type: ` + R.type + `

Program Info Log: ` + O + `
` + H + `
` + V
          );
        }
      else O !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", O) : (P === "" || A === "") && (L = !1);
      L && (R.diagnostics = {
        runnable: D,
        programLog: O,
        vertexShader: {
          log: P,
          prefix: v
        },
        fragmentShader: {
          log: A,
          prefix: g
        }
      });
    }
    s.deleteShader(T), s.deleteShader(E), C = new Qf(s, y), S = U6(s, y);
  }
  let C;
  this.getUniforms = function() {
    return C === void 0 && M(this), C;
  };
  let S;
  this.getAttributes = function() {
    return S === void 0 && M(this), S;
  };
  let w = i.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return w === !1 && (w = s.getProgramParameter(y, C6)), w;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), s.deleteProgram(y), this.program = void 0;
  }, this.type = i.shaderType, this.name = i.shaderName, this.id = R6++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = T, this.fragmentShader = E, this;
}
let K6 = 0;
class Z6 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const i = e.vertexShader, n = e.fragmentShader, s = this._getShaderStage(i), a = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e);
    return o.has(s) === !1 && (o.add(s), s.usedTimes++), o.has(a) === !1 && (o.add(a), a.usedTimes++), this;
  }
  remove(e) {
    const i = this.materialCache.get(e);
    for (const n of i)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const i = this.materialCache;
    let n = i.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), i.set(e, n)), n;
  }
  _getShaderStage(e) {
    const i = this.shaderCache;
    let n = i.get(e);
    return n === void 0 && (n = new Q6(e), i.set(e, n)), n;
  }
}
class Q6 {
  constructor(e) {
    this.id = K6++, this.code = e, this.usedTimes = 0;
  }
}
function $6(r, e, i, n, s, a, o) {
  const l = new P_(), u = new Z6(), c = /* @__PURE__ */ new Set(), h = [], d = s.logarithmicDepthBuffer, p = s.vertexTextures;
  let f = s.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function y(S) {
    return c.add(S), S === 0 ? "uv" : `uv${S}`;
  }
  function v(S, w, R, O, P) {
    const A = O.fog, D = P.geometry, L = S.isMeshStandardMaterial ? O.environment : null, H = (S.isMeshStandardMaterial ? i : e).get(S.envMap || L), V = H && H.mapping === vg ? H.image.height : null, X = m[S.type];
    S.precision !== null && (f = s.getMaxPrecision(S.precision), f !== S.precision && console.warn("THREE.WebGLProgram.getParameters:", S.precision, "not supported, using", f, "instead."));
    const F = D.morphAttributes.position || D.morphAttributes.normal || D.morphAttributes.color, B = F !== void 0 ? F.length : 0;
    let W = 0;
    D.morphAttributes.position !== void 0 && (W = 1), D.morphAttributes.normal !== void 0 && (W = 2), D.morphAttributes.color !== void 0 && (W = 3);
    let G, z, K, ne;
    if (X) {
      const Bt = hs[X];
      G = Bt.vertexShader, z = Bt.fragmentShader;
    } else
      G = S.vertexShader, z = S.fragmentShader, u.update(S), K = u.getVertexShaderID(S), ne = u.getFragmentShaderID(S);
    const oe = r.getRenderTarget(), pe = r.state.buffers.depth.getReversed(), xe = P.isInstancedMesh === !0, Re = P.isBatchedMesh === !0, nt = !!S.map, fe = !!S.matcap, gt = !!H, Q = !!S.aoMap, Gt = !!S.lightMap, Qe = !!S.bumpMap, bt = !!S.normalMap, Be = !!S.displacementMap, At = !!S.emissiveMap, st = !!S.metalnessMap, j = !!S.roughnessMap, k = S.anisotropy > 0, le = S.clearcoat > 0, we = S.dispersion > 0, Ce = S.iridescence > 0, Te = S.sheen > 0, et = S.transmission > 0, ze = k && !!S.anisotropyMap, Xe = le && !!S.clearcoatMap, Pt = le && !!S.clearcoatNormalMap, Ie = le && !!S.clearcoatRoughnessMap, Ye = Ce && !!S.iridescenceMap, ut = Ce && !!S.iridescenceThicknessMap, ft = Te && !!S.sheenColorMap, Ke = Te && !!S.sheenRoughnessMap, Ot = !!S.specularMap, xt = !!S.specularColorMap, jt = !!S.specularIntensityMap, ee = et && !!S.transmissionMap, Le = et && !!S.thicknessMap, de = !!S.gradientMap, Ee = !!S.alphaMap, je = S.alphaTest > 0, Ue = !!S.alphaHash, Ct = !!S.extensions;
    let ni = oo;
    S.toneMapped && (oe === null || oe.isXRRenderTarget === !0) && (ni = r.toneMapping);
    const xi = {
      shaderID: X,
      shaderType: S.type,
      shaderName: S.name,
      vertexShader: G,
      fragmentShader: z,
      defines: S.defines,
      customVertexShaderID: K,
      customFragmentShaderID: ne,
      isRawShaderMaterial: S.isRawShaderMaterial === !0,
      glslVersion: S.glslVersion,
      precision: f,
      batching: Re,
      batchingColor: Re && P._colorsTexture !== null,
      instancing: xe,
      instancingColor: xe && P.instanceColor !== null,
      instancingMorph: xe && P.morphTexture !== null,
      supportsVertexTextures: p,
      outputColorSpace: oe === null ? r.outputColorSpace : oe.isXRRenderTarget === !0 ? oe.texture.colorSpace : kc,
      alphaToCoverage: !!S.alphaToCoverage,
      map: nt,
      matcap: fe,
      envMap: gt,
      envMapMode: gt && H.mapping,
      envMapCubeUVHeight: V,
      aoMap: Q,
      lightMap: Gt,
      bumpMap: Qe,
      normalMap: bt,
      displacementMap: p && Be,
      emissiveMap: At,
      normalMapObjectSpace: bt && S.normalMapType === qU,
      normalMapTangentSpace: bt && S.normalMapType === $C,
      metalnessMap: st,
      roughnessMap: j,
      anisotropy: k,
      anisotropyMap: ze,
      clearcoat: le,
      clearcoatMap: Xe,
      clearcoatNormalMap: Pt,
      clearcoatRoughnessMap: Ie,
      dispersion: we,
      iridescence: Ce,
      iridescenceMap: Ye,
      iridescenceThicknessMap: ut,
      sheen: Te,
      sheenColorMap: ft,
      sheenRoughnessMap: Ke,
      specularMap: Ot,
      specularColorMap: xt,
      specularIntensityMap: jt,
      transmission: et,
      transmissionMap: ee,
      thicknessMap: Le,
      gradientMap: de,
      opaque: S.transparent === !1 && S.blending === Gu && S.alphaToCoverage === !1,
      alphaMap: Ee,
      alphaTest: je,
      alphaHash: Ue,
      combine: S.combine,
      //
      mapUv: nt && y(S.map.channel),
      aoMapUv: Q && y(S.aoMap.channel),
      lightMapUv: Gt && y(S.lightMap.channel),
      bumpMapUv: Qe && y(S.bumpMap.channel),
      normalMapUv: bt && y(S.normalMap.channel),
      displacementMapUv: Be && y(S.displacementMap.channel),
      emissiveMapUv: At && y(S.emissiveMap.channel),
      metalnessMapUv: st && y(S.metalnessMap.channel),
      roughnessMapUv: j && y(S.roughnessMap.channel),
      anisotropyMapUv: ze && y(S.anisotropyMap.channel),
      clearcoatMapUv: Xe && y(S.clearcoatMap.channel),
      clearcoatNormalMapUv: Pt && y(S.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ie && y(S.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Ye && y(S.iridescenceMap.channel),
      iridescenceThicknessMapUv: ut && y(S.iridescenceThicknessMap.channel),
      sheenColorMapUv: ft && y(S.sheenColorMap.channel),
      sheenRoughnessMapUv: Ke && y(S.sheenRoughnessMap.channel),
      specularMapUv: Ot && y(S.specularMap.channel),
      specularColorMapUv: xt && y(S.specularColorMap.channel),
      specularIntensityMapUv: jt && y(S.specularIntensityMap.channel),
      transmissionMapUv: ee && y(S.transmissionMap.channel),
      thicknessMapUv: Le && y(S.thicknessMap.channel),
      alphaMapUv: Ee && y(S.alphaMap.channel),
      //
      vertexTangents: !!D.attributes.tangent && (bt || k),
      vertexColors: S.vertexColors,
      vertexAlphas: S.vertexColors === !0 && !!D.attributes.color && D.attributes.color.itemSize === 4,
      pointsUvs: P.isPoints === !0 && !!D.attributes.uv && (nt || Ee),
      fog: !!A,
      useFog: S.fog === !0,
      fogExp2: !!A && A.isFogExp2,
      flatShading: S.flatShading === !0,
      sizeAttenuation: S.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      reverseDepthBuffer: pe,
      skinning: P.isSkinnedMesh === !0,
      morphTargets: D.morphAttributes.position !== void 0,
      morphNormals: D.morphAttributes.normal !== void 0,
      morphColors: D.morphAttributes.color !== void 0,
      morphTargetsCount: B,
      morphTextureStride: W,
      numDirLights: w.directional.length,
      numPointLights: w.point.length,
      numSpotLights: w.spot.length,
      numSpotLightMaps: w.spotLightMap.length,
      numRectAreaLights: w.rectArea.length,
      numHemiLights: w.hemi.length,
      numDirLightShadows: w.directionalShadowMap.length,
      numPointLightShadows: w.pointShadowMap.length,
      numSpotLightShadows: w.spotShadowMap.length,
      numSpotLightShadowsWithMaps: w.numSpotLightShadowsWithMaps,
      numLightProbes: w.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: S.dithering,
      shadowMapEnabled: r.shadowMap.enabled && R.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: ni,
      decodeVideoTexture: nt && S.map.isVideoTexture === !0 && Ht.getTransfer(S.map.colorSpace) === ei,
      decodeVideoTextureEmissive: At && S.emissiveMap.isVideoTexture === !0 && Ht.getTransfer(S.emissiveMap.colorSpace) === ei,
      premultipliedAlpha: S.premultipliedAlpha,
      doubleSided: S.side === Qs,
      flipSided: S.side === Ar,
      useDepthPacking: S.depthPacking >= 0,
      depthPacking: S.depthPacking || 0,
      index0AttributeName: S.index0AttributeName,
      extensionClipCullDistance: Ct && S.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (Ct && S.extensions.multiDraw === !0 || Re) && n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: S.customProgramCacheKey()
    };
    return xi.vertexUv1s = c.has(1), xi.vertexUv2s = c.has(2), xi.vertexUv3s = c.has(3), c.clear(), xi;
  }
  function g(S) {
    const w = [];
    if (S.shaderID ? w.push(S.shaderID) : (w.push(S.customVertexShaderID), w.push(S.customFragmentShaderID)), S.defines !== void 0)
      for (const R in S.defines)
        w.push(R), w.push(S.defines[R]);
    return S.isRawShaderMaterial === !1 && (_(w, S), x(w, S), w.push(r.outputColorSpace)), w.push(S.customProgramCacheKey), w.join();
  }
  function _(S, w) {
    S.push(w.precision), S.push(w.outputColorSpace), S.push(w.envMapMode), S.push(w.envMapCubeUVHeight), S.push(w.mapUv), S.push(w.alphaMapUv), S.push(w.lightMapUv), S.push(w.aoMapUv), S.push(w.bumpMapUv), S.push(w.normalMapUv), S.push(w.displacementMapUv), S.push(w.emissiveMapUv), S.push(w.metalnessMapUv), S.push(w.roughnessMapUv), S.push(w.anisotropyMapUv), S.push(w.clearcoatMapUv), S.push(w.clearcoatNormalMapUv), S.push(w.clearcoatRoughnessMapUv), S.push(w.iridescenceMapUv), S.push(w.iridescenceThicknessMapUv), S.push(w.sheenColorMapUv), S.push(w.sheenRoughnessMapUv), S.push(w.specularMapUv), S.push(w.specularColorMapUv), S.push(w.specularIntensityMapUv), S.push(w.transmissionMapUv), S.push(w.thicknessMapUv), S.push(w.combine), S.push(w.fogExp2), S.push(w.sizeAttenuation), S.push(w.morphTargetsCount), S.push(w.morphAttributeCount), S.push(w.numDirLights), S.push(w.numPointLights), S.push(w.numSpotLights), S.push(w.numSpotLightMaps), S.push(w.numHemiLights), S.push(w.numRectAreaLights), S.push(w.numDirLightShadows), S.push(w.numPointLightShadows), S.push(w.numSpotLightShadows), S.push(w.numSpotLightShadowsWithMaps), S.push(w.numLightProbes), S.push(w.shadowMapType), S.push(w.toneMapping), S.push(w.numClippingPlanes), S.push(w.numClipIntersection), S.push(w.depthPacking);
  }
  function x(S, w) {
    l.disableAll(), w.supportsVertexTextures && l.enable(0), w.instancing && l.enable(1), w.instancingColor && l.enable(2), w.instancingMorph && l.enable(3), w.matcap && l.enable(4), w.envMap && l.enable(5), w.normalMapObjectSpace && l.enable(6), w.normalMapTangentSpace && l.enable(7), w.clearcoat && l.enable(8), w.iridescence && l.enable(9), w.alphaTest && l.enable(10), w.vertexColors && l.enable(11), w.vertexAlphas && l.enable(12), w.vertexUv1s && l.enable(13), w.vertexUv2s && l.enable(14), w.vertexUv3s && l.enable(15), w.vertexTangents && l.enable(16), w.anisotropy && l.enable(17), w.alphaHash && l.enable(18), w.batching && l.enable(19), w.dispersion && l.enable(20), w.batchingColor && l.enable(21), S.push(l.mask), l.disableAll(), w.fog && l.enable(0), w.useFog && l.enable(1), w.flatShading && l.enable(2), w.logarithmicDepthBuffer && l.enable(3), w.reverseDepthBuffer && l.enable(4), w.skinning && l.enable(5), w.morphTargets && l.enable(6), w.morphNormals && l.enable(7), w.morphColors && l.enable(8), w.premultipliedAlpha && l.enable(9), w.shadowMapEnabled && l.enable(10), w.doubleSided && l.enable(11), w.flipSided && l.enable(12), w.useDepthPacking && l.enable(13), w.dithering && l.enable(14), w.transmission && l.enable(15), w.sheen && l.enable(16), w.opaque && l.enable(17), w.pointsUvs && l.enable(18), w.decodeVideoTexture && l.enable(19), w.decodeVideoTextureEmissive && l.enable(20), w.alphaToCoverage && l.enable(21), S.push(l.mask);
  }
  function b(S) {
    const w = m[S.type];
    let R;
    if (w) {
      const O = hs[w];
      R = fR.clone(O.uniforms);
    } else
      R = S.uniforms;
    return R;
  }
  function T(S, w) {
    let R;
    for (let O = 0, P = h.length; O < P; O++) {
      const A = h[O];
      if (A.cacheKey === w) {
        R = A, ++R.usedTimes;
        break;
      }
    }
    return R === void 0 && (R = new Y6(r, w, S, a), h.push(R)), R;
  }
  function E(S) {
    if (--S.usedTimes === 0) {
      const w = h.indexOf(S);
      h[w] = h[h.length - 1], h.pop(), S.destroy();
    }
  }
  function M(S) {
    u.remove(S);
  }
  function C() {
    u.dispose();
  }
  return {
    getParameters: v,
    getProgramCacheKey: g,
    getUniforms: b,
    acquireProgram: T,
    releaseProgram: E,
    releaseShaderCache: M,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: h,
    dispose: C
  };
}
function J6() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(o) {
    return r.has(o);
  }
  function i(o) {
    let l = r.get(o);
    return l === void 0 && (l = {}, r.set(o, l)), l;
  }
  function n(o) {
    r.delete(o);
  }
  function s(o, l, u) {
    r.get(o)[l] = u;
  }
  function a() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: i,
    remove: n,
    update: s,
    dispose: a
  };
}
function ej(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
}
function gS(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
}
function yS() {
  const r = [];
  let e = 0;
  const i = [], n = [], s = [];
  function a() {
    e = 0, i.length = 0, n.length = 0, s.length = 0;
  }
  function o(d, p, f, m, y, v) {
    let g = r[e];
    return g === void 0 ? (g = {
      id: d.id,
      object: d,
      geometry: p,
      material: f,
      groupOrder: m,
      renderOrder: d.renderOrder,
      z: y,
      group: v
    }, r[e] = g) : (g.id = d.id, g.object = d, g.geometry = p, g.material = f, g.groupOrder = m, g.renderOrder = d.renderOrder, g.z = y, g.group = v), e++, g;
  }
  function l(d, p, f, m, y, v) {
    const g = o(d, p, f, m, y, v);
    f.transmission > 0 ? n.push(g) : f.transparent === !0 ? s.push(g) : i.push(g);
  }
  function u(d, p, f, m, y, v) {
    const g = o(d, p, f, m, y, v);
    f.transmission > 0 ? n.unshift(g) : f.transparent === !0 ? s.unshift(g) : i.unshift(g);
  }
  function c(d, p) {
    i.length > 1 && i.sort(d || ej), n.length > 1 && n.sort(p || gS), s.length > 1 && s.sort(p || gS);
  }
  function h() {
    for (let d = e, p = r.length; d < p; d++) {
      const f = r[d];
      if (f.id === null) break;
      f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
    }
  }
  return {
    opaque: i,
    transmissive: n,
    transparent: s,
    init: a,
    push: l,
    unshift: u,
    finish: h,
    sort: c
  };
}
function tj() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(n, s) {
    const a = r.get(n);
    let o;
    return a === void 0 ? (o = new yS(), r.set(n, [o])) : s >= a.length ? (o = new yS(), a.push(o)) : o = a[s], o;
  }
  function i() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: i
  };
}
function ij() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let i;
      switch (e.type) {
        case "DirectionalLight":
          i = {
            direction: new Y(),
            color: new Ut()
          };
          break;
        case "SpotLight":
          i = {
            position: new Y(),
            direction: new Y(),
            color: new Ut(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          i = {
            position: new Y(),
            color: new Ut(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          i = {
            direction: new Y(),
            skyColor: new Ut(),
            groundColor: new Ut()
          };
          break;
        case "RectAreaLight":
          i = {
            color: new Ut(),
            position: new Y(),
            halfWidth: new Y(),
            halfHeight: new Y()
          };
          break;
      }
      return r[e.id] = i, i;
    }
  };
}
function rj() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let i;
      switch (e.type) {
        case "DirectionalLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke()
          };
          break;
        case "SpotLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke()
          };
          break;
        case "PointLight":
          i = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return r[e.id] = i, i;
    }
  };
}
let nj = 0;
function sj(r, e) {
  return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0);
}
function aj(r) {
  const e = new ij(), i = rj(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let c = 0; c < 9; c++) n.probe.push(new Y());
  const s = new Y(), a = new ui(), o = new ui();
  function l(c) {
    let h = 0, d = 0, p = 0;
    for (let S = 0; S < 9; S++) n.probe[S].set(0, 0, 0);
    let f = 0, m = 0, y = 0, v = 0, g = 0, _ = 0, x = 0, b = 0, T = 0, E = 0, M = 0;
    c.sort(sj);
    for (let S = 0, w = c.length; S < w; S++) {
      const R = c[S], O = R.color, P = R.intensity, A = R.distance, D = R.shadow && R.shadow.map ? R.shadow.map.texture : null;
      if (R.isAmbientLight)
        h += O.r * P, d += O.g * P, p += O.b * P;
      else if (R.isLightProbe) {
        for (let L = 0; L < 9; L++)
          n.probe[L].addScaledVector(R.sh.coefficients[L], P);
        M++;
      } else if (R.isDirectionalLight) {
        const L = e.get(R);
        if (L.color.copy(R.color).multiplyScalar(R.intensity), R.castShadow) {
          const H = R.shadow, V = i.get(R);
          V.shadowIntensity = H.intensity, V.shadowBias = H.bias, V.shadowNormalBias = H.normalBias, V.shadowRadius = H.radius, V.shadowMapSize = H.mapSize, n.directionalShadow[f] = V, n.directionalShadowMap[f] = D, n.directionalShadowMatrix[f] = R.shadow.matrix, _++;
        }
        n.directional[f] = L, f++;
      } else if (R.isSpotLight) {
        const L = e.get(R);
        L.position.setFromMatrixPosition(R.matrixWorld), L.color.copy(O).multiplyScalar(P), L.distance = A, L.coneCos = Math.cos(R.angle), L.penumbraCos = Math.cos(R.angle * (1 - R.penumbra)), L.decay = R.decay, n.spot[y] = L;
        const H = R.shadow;
        if (R.map && (n.spotLightMap[T] = R.map, T++, H.updateMatrices(R), R.castShadow && E++), n.spotLightMatrix[y] = H.matrix, R.castShadow) {
          const V = i.get(R);
          V.shadowIntensity = H.intensity, V.shadowBias = H.bias, V.shadowNormalBias = H.normalBias, V.shadowRadius = H.radius, V.shadowMapSize = H.mapSize, n.spotShadow[y] = V, n.spotShadowMap[y] = D, b++;
        }
        y++;
      } else if (R.isRectAreaLight) {
        const L = e.get(R);
        L.color.copy(O).multiplyScalar(P), L.halfWidth.set(R.width * 0.5, 0, 0), L.halfHeight.set(0, R.height * 0.5, 0), n.rectArea[v] = L, v++;
      } else if (R.isPointLight) {
        const L = e.get(R);
        if (L.color.copy(R.color).multiplyScalar(R.intensity), L.distance = R.distance, L.decay = R.decay, R.castShadow) {
          const H = R.shadow, V = i.get(R);
          V.shadowIntensity = H.intensity, V.shadowBias = H.bias, V.shadowNormalBias = H.normalBias, V.shadowRadius = H.radius, V.shadowMapSize = H.mapSize, V.shadowCameraNear = H.camera.near, V.shadowCameraFar = H.camera.far, n.pointShadow[m] = V, n.pointShadowMap[m] = D, n.pointShadowMatrix[m] = R.shadow.matrix, x++;
        }
        n.point[m] = L, m++;
      } else if (R.isHemisphereLight) {
        const L = e.get(R);
        L.skyColor.copy(R.color).multiplyScalar(P), L.groundColor.copy(R.groundColor).multiplyScalar(P), n.hemi[g] = L, g++;
      }
    }
    v > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Ve.LTC_FLOAT_1, n.rectAreaLTC2 = Ve.LTC_FLOAT_2) : (n.rectAreaLTC1 = Ve.LTC_HALF_1, n.rectAreaLTC2 = Ve.LTC_HALF_2)), n.ambient[0] = h, n.ambient[1] = d, n.ambient[2] = p;
    const C = n.hash;
    (C.directionalLength !== f || C.pointLength !== m || C.spotLength !== y || C.rectAreaLength !== v || C.hemiLength !== g || C.numDirectionalShadows !== _ || C.numPointShadows !== x || C.numSpotShadows !== b || C.numSpotMaps !== T || C.numLightProbes !== M) && (n.directional.length = f, n.spot.length = y, n.rectArea.length = v, n.point.length = m, n.hemi.length = g, n.directionalShadow.length = _, n.directionalShadowMap.length = _, n.pointShadow.length = x, n.pointShadowMap.length = x, n.spotShadow.length = b, n.spotShadowMap.length = b, n.directionalShadowMatrix.length = _, n.pointShadowMatrix.length = x, n.spotLightMatrix.length = b + T - E, n.spotLightMap.length = T, n.numSpotLightShadowsWithMaps = E, n.numLightProbes = M, C.directionalLength = f, C.pointLength = m, C.spotLength = y, C.rectAreaLength = v, C.hemiLength = g, C.numDirectionalShadows = _, C.numPointShadows = x, C.numSpotShadows = b, C.numSpotMaps = T, C.numLightProbes = M, n.version = nj++);
  }
  function u(c, h) {
    let d = 0, p = 0, f = 0, m = 0, y = 0;
    const v = h.matrixWorldInverse;
    for (let g = 0, _ = c.length; g < _; g++) {
      const x = c[g];
      if (x.isDirectionalLight) {
        const b = n.directional[d];
        b.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(v), d++;
      } else if (x.isSpotLight) {
        const b = n.spot[f];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(v), b.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(v), f++;
      } else if (x.isRectAreaLight) {
        const b = n.rectArea[m];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(v), o.identity(), a.copy(x.matrixWorld), a.premultiply(v), o.extractRotation(a), b.halfWidth.set(x.width * 0.5, 0, 0), b.halfHeight.set(0, x.height * 0.5, 0), b.halfWidth.applyMatrix4(o), b.halfHeight.applyMatrix4(o), m++;
      } else if (x.isPointLight) {
        const b = n.point[p];
        b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(v), p++;
      } else if (x.isHemisphereLight) {
        const b = n.hemi[y];
        b.direction.setFromMatrixPosition(x.matrixWorld), b.direction.transformDirection(v), y++;
      }
    }
  }
  return {
    setup: l,
    setupView: u,
    state: n
  };
}
function vS(r) {
  const e = new aj(r), i = [], n = [];
  function s(h) {
    c.camera = h, i.length = 0, n.length = 0;
  }
  function a(h) {
    i.push(h);
  }
  function o(h) {
    n.push(h);
  }
  function l() {
    e.setup(i);
  }
  function u(h) {
    e.setupView(i, h);
  }
  const c = {
    lightsArray: i,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: s,
    state: c,
    setupLights: l,
    setupLightsView: u,
    pushLight: a,
    pushShadow: o
  };
}
function oj(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function i(s, a = 0) {
    const o = e.get(s);
    let l;
    return o === void 0 ? (l = new vS(r), e.set(s, [l])) : a >= o.length ? (l = new vS(r), o.push(l)) : l = o[a], l;
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: n
  };
}
class lj extends Nl {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.depthPacking = HU, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class uj extends Nl {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const cj = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, hj = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function dj(r, e, i) {
  let n = new O_();
  const s = new ke(), a = new ke(), o = new Fi(), l = new lj({ depthPacking: WU }), u = new uj(), c = {}, h = i.maxTextureSize, d = { [fo]: Ar, [Ar]: fo, [Qs]: Qs }, p = new xs({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new ke() },
      radius: { value: 4 }
    },
    vertexShader: cj,
    fragmentShader: hj
  }), f = p.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new cn();
  m.setAttribute(
    "position",
    new _n(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const y = new kr(m, p), v = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = zC;
  let g = this.type;
  this.render = function(E, M, C) {
    if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || E.length === 0) return;
    const S = r.getRenderTarget(), w = r.getActiveCubeFace(), R = r.getActiveMipmapLevel(), O = r.state;
    O.setBlending(la), O.buffers.color.setClear(1, 1, 1, 1), O.buffers.depth.setTest(!0), O.setScissorTest(!1);
    const P = g !== Gs && this.type === Gs, A = g === Gs && this.type !== Gs;
    for (let D = 0, L = E.length; D < L; D++) {
      const H = E[D], V = H.shadow;
      if (V === void 0) {
        console.warn("THREE.WebGLShadowMap:", H, "has no shadow.");
        continue;
      }
      if (V.autoUpdate === !1 && V.needsUpdate === !1) continue;
      s.copy(V.mapSize);
      const X = V.getFrameExtents();
      if (s.multiply(X), a.copy(V.mapSize), (s.x > h || s.y > h) && (s.x > h && (a.x = Math.floor(h / X.x), s.x = a.x * X.x, V.mapSize.x = a.x), s.y > h && (a.y = Math.floor(h / X.y), s.y = a.y * X.y, V.mapSize.y = a.y)), V.map === null || P === !0 || A === !0) {
        const B = this.type !== Gs ? { minFilter: Zn, magFilter: Zn } : {};
        V.map !== null && V.map.dispose(), V.map = new mo(s.x, s.y, B), V.map.texture.name = H.name + ".shadowMap", V.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(V.map), r.clear();
      const F = V.getViewportCount();
      for (let B = 0; B < F; B++) {
        const W = V.getViewport(B);
        o.set(
          a.x * W.x,
          a.y * W.y,
          a.x * W.z,
          a.y * W.w
        ), O.viewport(o), V.updateMatrices(H, B), n = V.getFrustum(), b(M, C, V.camera, H, this.type);
      }
      V.isPointLightShadow !== !0 && this.type === Gs && _(V, C), V.needsUpdate = !1;
    }
    g = this.type, v.needsUpdate = !1, r.setRenderTarget(S, w, R);
  };
  function _(E, M) {
    const C = e.update(y);
    p.defines.VSM_SAMPLES !== E.blurSamples && (p.defines.VSM_SAMPLES = E.blurSamples, f.defines.VSM_SAMPLES = E.blurSamples, p.needsUpdate = !0, f.needsUpdate = !0), E.mapPass === null && (E.mapPass = new mo(s.x, s.y)), p.uniforms.shadow_pass.value = E.map.texture, p.uniforms.resolution.value = E.mapSize, p.uniforms.radius.value = E.radius, r.setRenderTarget(E.mapPass), r.clear(), r.renderBufferDirect(M, null, C, p, y, null), f.uniforms.shadow_pass.value = E.mapPass.texture, f.uniforms.resolution.value = E.mapSize, f.uniforms.radius.value = E.radius, r.setRenderTarget(E.map), r.clear(), r.renderBufferDirect(M, null, C, f, y, null);
  }
  function x(E, M, C, S) {
    let w = null;
    const R = C.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
    if (R !== void 0)
      w = R;
    else if (w = C.isPointLight === !0 ? u : l, r.localClippingEnabled && M.clipShadows === !0 && Array.isArray(M.clippingPlanes) && M.clippingPlanes.length !== 0 || M.displacementMap && M.displacementScale !== 0 || M.alphaMap && M.alphaTest > 0 || M.map && M.alphaTest > 0) {
      const O = w.uuid, P = M.uuid;
      let A = c[O];
      A === void 0 && (A = {}, c[O] = A);
      let D = A[P];
      D === void 0 && (D = w.clone(), A[P] = D, M.addEventListener("dispose", T)), w = D;
    }
    if (w.visible = M.visible, w.wireframe = M.wireframe, S === Gs ? w.side = M.shadowSide !== null ? M.shadowSide : M.side : w.side = M.shadowSide !== null ? M.shadowSide : d[M.side], w.alphaMap = M.alphaMap, w.alphaTest = M.alphaTest, w.map = M.map, w.clipShadows = M.clipShadows, w.clippingPlanes = M.clippingPlanes, w.clipIntersection = M.clipIntersection, w.displacementMap = M.displacementMap, w.displacementScale = M.displacementScale, w.displacementBias = M.displacementBias, w.wireframeLinewidth = M.wireframeLinewidth, w.linewidth = M.linewidth, C.isPointLight === !0 && w.isMeshDistanceMaterial === !0) {
      const O = r.properties.get(w);
      O.light = C;
    }
    return w;
  }
  function b(E, M, C, S, w) {
    if (E.visible === !1) return;
    if (E.layers.test(M.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && w === Gs) && (!E.frustumCulled || n.intersectsObject(E))) {
      E.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, E.matrixWorld);
      const O = e.update(E), P = E.material;
      if (Array.isArray(P)) {
        const A = O.groups;
        for (let D = 0, L = A.length; D < L; D++) {
          const H = A[D], V = P[H.materialIndex];
          if (V && V.visible) {
            const X = x(E, V, S, w);
            E.onBeforeShadow(r, E, M, C, O, X, H), r.renderBufferDirect(C, null, O, X, E, H), E.onAfterShadow(r, E, M, C, O, X, H);
          }
        }
      } else if (P.visible) {
        const A = x(E, P, S, w);
        E.onBeforeShadow(r, E, M, C, O, A, null), r.renderBufferDirect(C, null, O, A, E, null), E.onAfterShadow(r, E, M, C, O, A, null);
      }
    }
    const R = E.children;
    for (let O = 0, P = R.length; O < P; O++)
      b(R[O], M, C, S, w);
  }
  function T(E) {
    E.target.removeEventListener("dispose", T);
    for (const M in c) {
      const C = c[M], S = E.target.uuid;
      S in C && (C[S].dispose(), delete C[S]);
    }
  }
}
const pj = {
  [Yv]: Kv,
  [Zv]: Jv,
  [Qv]: eb,
  [hc]: $v,
  [Kv]: Yv,
  [Jv]: Zv,
  [eb]: Qv,
  [$v]: hc
};
function fj(r, e) {
  function i() {
    let ee = !1;
    const Le = new Fi();
    let de = null;
    const Ee = new Fi(0, 0, 0, 0);
    return {
      setMask: function(je) {
        de !== je && !ee && (r.colorMask(je, je, je, je), de = je);
      },
      setLocked: function(je) {
        ee = je;
      },
      setClear: function(je, Ue, Ct, ni, xi) {
        xi === !0 && (je *= ni, Ue *= ni, Ct *= ni), Le.set(je, Ue, Ct, ni), Ee.equals(Le) === !1 && (r.clearColor(je, Ue, Ct, ni), Ee.copy(Le));
      },
      reset: function() {
        ee = !1, de = null, Ee.set(-1, 0, 0, 0);
      }
    };
  }
  function n() {
    let ee = !1, Le = !1, de = null, Ee = null, je = null;
    return {
      setReversed: function(Ue) {
        if (Le !== Ue) {
          const Ct = e.get("EXT_clip_control");
          Le ? Ct.clipControlEXT(Ct.LOWER_LEFT_EXT, Ct.ZERO_TO_ONE_EXT) : Ct.clipControlEXT(Ct.LOWER_LEFT_EXT, Ct.NEGATIVE_ONE_TO_ONE_EXT);
          const ni = je;
          je = null, this.setClear(ni);
        }
        Le = Ue;
      },
      getReversed: function() {
        return Le;
      },
      setTest: function(Ue) {
        Ue ? oe(r.DEPTH_TEST) : pe(r.DEPTH_TEST);
      },
      setMask: function(Ue) {
        de !== Ue && !ee && (r.depthMask(Ue), de = Ue);
      },
      setFunc: function(Ue) {
        if (Le && (Ue = pj[Ue]), Ee !== Ue) {
          switch (Ue) {
            case Yv:
              r.depthFunc(r.NEVER);
              break;
            case Kv:
              r.depthFunc(r.ALWAYS);
              break;
            case Zv:
              r.depthFunc(r.LESS);
              break;
            case hc:
              r.depthFunc(r.LEQUAL);
              break;
            case Qv:
              r.depthFunc(r.EQUAL);
              break;
            case $v:
              r.depthFunc(r.GEQUAL);
              break;
            case Jv:
              r.depthFunc(r.GREATER);
              break;
            case eb:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          Ee = Ue;
        }
      },
      setLocked: function(Ue) {
        ee = Ue;
      },
      setClear: function(Ue) {
        je !== Ue && (Le && (Ue = 1 - Ue), r.clearDepth(Ue), je = Ue);
      },
      reset: function() {
        ee = !1, de = null, Ee = null, je = null, Le = !1;
      }
    };
  }
  function s() {
    let ee = !1, Le = null, de = null, Ee = null, je = null, Ue = null, Ct = null, ni = null, xi = null;
    return {
      setTest: function(Bt) {
        ee || (Bt ? oe(r.STENCIL_TEST) : pe(r.STENCIL_TEST));
      },
      setMask: function(Bt) {
        Le !== Bt && !ee && (r.stencilMask(Bt), Le = Bt);
      },
      setFunc: function(Bt, vr, Yr) {
        (de !== Bt || Ee !== vr || je !== Yr) && (r.stencilFunc(Bt, vr, Yr), de = Bt, Ee = vr, je = Yr);
      },
      setOp: function(Bt, vr, Yr) {
        (Ue !== Bt || Ct !== vr || ni !== Yr) && (r.stencilOp(Bt, vr, Yr), Ue = Bt, Ct = vr, ni = Yr);
      },
      setLocked: function(Bt) {
        ee = Bt;
      },
      setClear: function(Bt) {
        xi !== Bt && (r.clearStencil(Bt), xi = Bt);
      },
      reset: function() {
        ee = !1, Le = null, de = null, Ee = null, je = null, Ue = null, Ct = null, ni = null, xi = null;
      }
    };
  }
  const a = new i(), o = new n(), l = new s(), u = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
  let h = {}, d = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, y = !1, v = null, g = null, _ = null, x = null, b = null, T = null, E = null, M = new Ut(0, 0, 0), C = 0, S = !1, w = null, R = null, O = null, P = null, A = null;
  const D = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let L = !1, H = 0;
  const V = r.getParameter(r.VERSION);
  V.indexOf("WebGL") !== -1 ? (H = parseFloat(/^WebGL (\d)/.exec(V)[1]), L = H >= 1) : V.indexOf("OpenGL ES") !== -1 && (H = parseFloat(/^OpenGL ES (\d)/.exec(V)[1]), L = H >= 2);
  let X = null, F = {};
  const B = r.getParameter(r.SCISSOR_BOX), W = r.getParameter(r.VIEWPORT), G = new Fi().fromArray(B), z = new Fi().fromArray(W);
  function K(ee, Le, de, Ee) {
    const je = new Uint8Array(4), Ue = r.createTexture();
    r.bindTexture(ee, Ue), r.texParameteri(ee, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(ee, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let Ct = 0; Ct < de; Ct++)
      ee === r.TEXTURE_3D || ee === r.TEXTURE_2D_ARRAY ? r.texImage3D(Le, 0, r.RGBA, 1, 1, Ee, 0, r.RGBA, r.UNSIGNED_BYTE, je) : r.texImage2D(Le + Ct, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, je);
    return Ue;
  }
  const ne = {};
  ne[r.TEXTURE_2D] = K(r.TEXTURE_2D, r.TEXTURE_2D, 1), ne[r.TEXTURE_CUBE_MAP] = K(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ne[r.TEXTURE_2D_ARRAY] = K(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), ne[r.TEXTURE_3D] = K(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), a.setClear(0, 0, 0, 1), o.setClear(1), l.setClear(0), oe(r.DEPTH_TEST), o.setFunc(hc), Qe(!1), bt(Tw), oe(r.CULL_FACE), Q(la);
  function oe(ee) {
    h[ee] !== !0 && (r.enable(ee), h[ee] = !0);
  }
  function pe(ee) {
    h[ee] !== !1 && (r.disable(ee), h[ee] = !1);
  }
  function xe(ee, Le) {
    return d[ee] !== Le ? (r.bindFramebuffer(ee, Le), d[ee] = Le, ee === r.DRAW_FRAMEBUFFER && (d[r.FRAMEBUFFER] = Le), ee === r.FRAMEBUFFER && (d[r.DRAW_FRAMEBUFFER] = Le), !0) : !1;
  }
  function Re(ee, Le) {
    let de = f, Ee = !1;
    if (ee) {
      de = p.get(Le), de === void 0 && (de = [], p.set(Le, de));
      const je = ee.textures;
      if (de.length !== je.length || de[0] !== r.COLOR_ATTACHMENT0) {
        for (let Ue = 0, Ct = je.length; Ue < Ct; Ue++)
          de[Ue] = r.COLOR_ATTACHMENT0 + Ue;
        de.length = je.length, Ee = !0;
      }
    } else
      de[0] !== r.BACK && (de[0] = r.BACK, Ee = !0);
    Ee && r.drawBuffers(de);
  }
  function nt(ee) {
    return m !== ee ? (r.useProgram(ee), m = ee, !0) : !1;
  }
  const fe = {
    [Xo]: r.FUNC_ADD,
    [yU]: r.FUNC_SUBTRACT,
    [vU]: r.FUNC_REVERSE_SUBTRACT
  };
  fe[bU] = r.MIN, fe[xU] = r.MAX;
  const gt = {
    [_U]: r.ZERO,
    [TU]: r.ONE,
    [wU]: r.SRC_COLOR,
    [qv]: r.SRC_ALPHA,
    [RU]: r.SRC_ALPHA_SATURATE,
    [AU]: r.DST_COLOR,
    [EU]: r.DST_ALPHA,
    [SU]: r.ONE_MINUS_SRC_COLOR,
    [Xv]: r.ONE_MINUS_SRC_ALPHA,
    [CU]: r.ONE_MINUS_DST_COLOR,
    [MU]: r.ONE_MINUS_DST_ALPHA,
    [NU]: r.CONSTANT_COLOR,
    [PU]: r.ONE_MINUS_CONSTANT_COLOR,
    [IU]: r.CONSTANT_ALPHA,
    [OU]: r.ONE_MINUS_CONSTANT_ALPHA
  };
  function Q(ee, Le, de, Ee, je, Ue, Ct, ni, xi, Bt) {
    if (ee === la) {
      y === !0 && (pe(r.BLEND), y = !1);
      return;
    }
    if (y === !1 && (oe(r.BLEND), y = !0), ee !== gU) {
      if (ee !== v || Bt !== S) {
        if ((g !== Xo || b !== Xo) && (r.blendEquation(r.FUNC_ADD), g = Xo, b = Xo), Bt)
          switch (ee) {
            case Gu:
              r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case ww:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case Sw:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Ew:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ee);
              break;
          }
        else
          switch (ee) {
            case Gu:
              r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case ww:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case Sw:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Ew:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ee);
              break;
          }
        _ = null, x = null, T = null, E = null, M.set(0, 0, 0), C = 0, v = ee, S = Bt;
      }
      return;
    }
    je = je || Le, Ue = Ue || de, Ct = Ct || Ee, (Le !== g || je !== b) && (r.blendEquationSeparate(fe[Le], fe[je]), g = Le, b = je), (de !== _ || Ee !== x || Ue !== T || Ct !== E) && (r.blendFuncSeparate(gt[de], gt[Ee], gt[Ue], gt[Ct]), _ = de, x = Ee, T = Ue, E = Ct), (ni.equals(M) === !1 || xi !== C) && (r.blendColor(ni.r, ni.g, ni.b, xi), M.copy(ni), C = xi), v = ee, S = !1;
  }
  function Gt(ee, Le) {
    ee.side === Qs ? pe(r.CULL_FACE) : oe(r.CULL_FACE);
    let de = ee.side === Ar;
    Le && (de = !de), Qe(de), ee.blending === Gu && ee.transparent === !1 ? Q(la) : Q(ee.blending, ee.blendEquation, ee.blendSrc, ee.blendDst, ee.blendEquationAlpha, ee.blendSrcAlpha, ee.blendDstAlpha, ee.blendColor, ee.blendAlpha, ee.premultipliedAlpha), o.setFunc(ee.depthFunc), o.setTest(ee.depthTest), o.setMask(ee.depthWrite), a.setMask(ee.colorWrite);
    const Ee = ee.stencilWrite;
    l.setTest(Ee), Ee && (l.setMask(ee.stencilWriteMask), l.setFunc(ee.stencilFunc, ee.stencilRef, ee.stencilFuncMask), l.setOp(ee.stencilFail, ee.stencilZFail, ee.stencilZPass)), At(ee.polygonOffset, ee.polygonOffsetFactor, ee.polygonOffsetUnits), ee.alphaToCoverage === !0 ? oe(r.SAMPLE_ALPHA_TO_COVERAGE) : pe(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Qe(ee) {
    w !== ee && (ee ? r.frontFace(r.CW) : r.frontFace(r.CCW), w = ee);
  }
  function bt(ee) {
    ee !== pU ? (oe(r.CULL_FACE), ee !== R && (ee === Tw ? r.cullFace(r.BACK) : ee === fU ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : pe(r.CULL_FACE), R = ee;
  }
  function Be(ee) {
    ee !== O && (L && r.lineWidth(ee), O = ee);
  }
  function At(ee, Le, de) {
    ee ? (oe(r.POLYGON_OFFSET_FILL), (P !== Le || A !== de) && (r.polygonOffset(Le, de), P = Le, A = de)) : pe(r.POLYGON_OFFSET_FILL);
  }
  function st(ee) {
    ee ? oe(r.SCISSOR_TEST) : pe(r.SCISSOR_TEST);
  }
  function j(ee) {
    ee === void 0 && (ee = r.TEXTURE0 + D - 1), X !== ee && (r.activeTexture(ee), X = ee);
  }
  function k(ee, Le, de) {
    de === void 0 && (X === null ? de = r.TEXTURE0 + D - 1 : de = X);
    let Ee = F[de];
    Ee === void 0 && (Ee = { type: void 0, texture: void 0 }, F[de] = Ee), (Ee.type !== ee || Ee.texture !== Le) && (X !== de && (r.activeTexture(de), X = de), r.bindTexture(ee, Le || ne[ee]), Ee.type = ee, Ee.texture = Le);
  }
  function le() {
    const ee = F[X];
    ee !== void 0 && ee.type !== void 0 && (r.bindTexture(ee.type, null), ee.type = void 0, ee.texture = void 0);
  }
  function we() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Ce() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Te() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function et() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function ze() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Xe() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Pt() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Ie() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function Ye() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function ut() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (ee) {
      console.error("THREE.WebGLState:", ee);
    }
  }
  function ft(ee) {
    G.equals(ee) === !1 && (r.scissor(ee.x, ee.y, ee.z, ee.w), G.copy(ee));
  }
  function Ke(ee) {
    z.equals(ee) === !1 && (r.viewport(ee.x, ee.y, ee.z, ee.w), z.copy(ee));
  }
  function Ot(ee, Le) {
    let de = c.get(Le);
    de === void 0 && (de = /* @__PURE__ */ new WeakMap(), c.set(Le, de));
    let Ee = de.get(ee);
    Ee === void 0 && (Ee = r.getUniformBlockIndex(Le, ee.name), de.set(ee, Ee));
  }
  function xt(ee, Le) {
    const de = c.get(Le).get(ee);
    u.get(Le) !== de && (r.uniformBlockBinding(Le, de, ee.__bindingPointIndex), u.set(Le, de));
  }
  function jt() {
    r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), o.setReversed(!1), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), h = {}, X = null, F = {}, d = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, y = !1, v = null, g = null, _ = null, x = null, b = null, T = null, E = null, M = new Ut(0, 0, 0), C = 0, S = !1, w = null, R = null, O = null, P = null, A = null, G.set(0, 0, r.canvas.width, r.canvas.height), z.set(0, 0, r.canvas.width, r.canvas.height), a.reset(), o.reset(), l.reset();
  }
  return {
    buffers: {
      color: a,
      depth: o,
      stencil: l
    },
    enable: oe,
    disable: pe,
    bindFramebuffer: xe,
    drawBuffers: Re,
    useProgram: nt,
    setBlending: Q,
    setMaterial: Gt,
    setFlipSided: Qe,
    setCullFace: bt,
    setLineWidth: Be,
    setPolygonOffset: At,
    setScissorTest: st,
    activeTexture: j,
    bindTexture: k,
    unbindTexture: le,
    compressedTexImage2D: we,
    compressedTexImage3D: Ce,
    texImage2D: Ye,
    texImage3D: ut,
    updateUBOMapping: Ot,
    uniformBlockBinding: xt,
    texStorage2D: Pt,
    texStorage3D: Ie,
    texSubImage2D: Te,
    texSubImage3D: et,
    compressedTexSubImage2D: ze,
    compressedTexSubImage3D: Xe,
    scissor: ft,
    viewport: Ke,
    reset: jt
  };
}
function bS(r, e, i, n) {
  const s = mj(n);
  switch (i) {
    case WC:
      return r * e;
    case XC:
      return r * e;
    case YC:
      return r * e * 2;
    case KC:
      return r * e / s.components * s.byteLength;
    case A_:
      return r * e / s.components * s.byteLength;
    case ZC:
      return r * e * 2 / s.components * s.byteLength;
    case C_:
      return r * e * 2 / s.components * s.byteLength;
    case qC:
      return r * e * 3 / s.components * s.byteLength;
    case Xn:
      return r * e * 4 / s.components * s.byteLength;
    case R_:
      return r * e * 4 / s.components * s.byteLength;
    case Hf:
    case Wf:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case qf:
    case Xf:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case ab:
    case lb:
      return Math.max(r, 16) * Math.max(e, 8) / 4;
    case sb:
    case ob:
      return Math.max(r, 8) * Math.max(e, 8) / 2;
    case ub:
    case cb:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case hb:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case db:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case pb:
      return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case fb:
      return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case mb:
      return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case gb:
      return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case yb:
      return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case vb:
      return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case bb:
      return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case xb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case _b:
      return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Tb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case wb:
      return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Sb:
      return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Eb:
      return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Yf:
    case Mb:
    case Ab:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
    case QC:
    case Cb:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
    case Rb:
    case Nb:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${i} format.`
  );
}
function mj(r) {
  switch (r) {
    case ba:
    case VC:
      return { byteLength: 1, components: 1 };
    case ud:
    case GC:
    case Lc:
      return { byteLength: 2, components: 1 };
    case E_:
    case M_:
      return { byteLength: 2, components: 4 };
    case xl:
    case S_:
    case ra:
      return { byteLength: 4, components: 1 };
    case HC:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${r}.`);
}
function gj(r, e, i, n, s, a, o) {
  const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, u = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), c = new ke(), h = /* @__PURE__ */ new WeakMap();
  let d;
  const p = /* @__PURE__ */ new WeakMap();
  let f = !1;
  try {
    f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function m(j, k) {
    return f ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(j, k)
    ) : hd("canvas");
  }
  function y(j, k, le) {
    let we = 1;
    const Ce = st(j);
    if ((Ce.width > le || Ce.height > le) && (we = le / Math.max(Ce.width, Ce.height)), we < 1)
      if (typeof HTMLImageElement < "u" && j instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && j instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && j instanceof ImageBitmap || typeof VideoFrame < "u" && j instanceof VideoFrame) {
        const Te = Math.floor(we * Ce.width), et = Math.floor(we * Ce.height);
        d === void 0 && (d = m(Te, et));
        const ze = k ? m(Te, et) : d;
        return ze.width = Te, ze.height = et, ze.getContext("2d").drawImage(j, 0, 0, Te, et), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Ce.width + "x" + Ce.height + ") to (" + Te + "x" + et + ")."), ze;
      } else
        return "data" in j && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Ce.width + "x" + Ce.height + ")."), j;
    return j;
  }
  function v(j) {
    return j.generateMipmaps;
  }
  function g(j) {
    r.generateMipmap(j);
  }
  function _(j) {
    return j.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : j.isWebGL3DRenderTarget ? r.TEXTURE_3D : j.isWebGLArrayRenderTarget || j.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D;
  }
  function x(j, k, le, we, Ce = !1) {
    if (j !== null) {
      if (r[j] !== void 0) return r[j];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + j + "'");
    }
    let Te = k;
    if (k === r.RED && (le === r.FLOAT && (Te = r.R32F), le === r.HALF_FLOAT && (Te = r.R16F), le === r.UNSIGNED_BYTE && (Te = r.R8)), k === r.RED_INTEGER && (le === r.UNSIGNED_BYTE && (Te = r.R8UI), le === r.UNSIGNED_SHORT && (Te = r.R16UI), le === r.UNSIGNED_INT && (Te = r.R32UI), le === r.BYTE && (Te = r.R8I), le === r.SHORT && (Te = r.R16I), le === r.INT && (Te = r.R32I)), k === r.RG && (le === r.FLOAT && (Te = r.RG32F), le === r.HALF_FLOAT && (Te = r.RG16F), le === r.UNSIGNED_BYTE && (Te = r.RG8)), k === r.RG_INTEGER && (le === r.UNSIGNED_BYTE && (Te = r.RG8UI), le === r.UNSIGNED_SHORT && (Te = r.RG16UI), le === r.UNSIGNED_INT && (Te = r.RG32UI), le === r.BYTE && (Te = r.RG8I), le === r.SHORT && (Te = r.RG16I), le === r.INT && (Te = r.RG32I)), k === r.RGB_INTEGER && (le === r.UNSIGNED_BYTE && (Te = r.RGB8UI), le === r.UNSIGNED_SHORT && (Te = r.RGB16UI), le === r.UNSIGNED_INT && (Te = r.RGB32UI), le === r.BYTE && (Te = r.RGB8I), le === r.SHORT && (Te = r.RGB16I), le === r.INT && (Te = r.RGB32I)), k === r.RGBA_INTEGER && (le === r.UNSIGNED_BYTE && (Te = r.RGBA8UI), le === r.UNSIGNED_SHORT && (Te = r.RGBA16UI), le === r.UNSIGNED_INT && (Te = r.RGBA32UI), le === r.BYTE && (Te = r.RGBA8I), le === r.SHORT && (Te = r.RGBA16I), le === r.INT && (Te = r.RGBA32I)), k === r.RGB && le === r.UNSIGNED_INT_5_9_9_9_REV && (Te = r.RGB9_E5), k === r.RGBA) {
      const et = Ce ? bg : Ht.getTransfer(we);
      le === r.FLOAT && (Te = r.RGBA32F), le === r.HALF_FLOAT && (Te = r.RGBA16F), le === r.UNSIGNED_BYTE && (Te = et === ei ? r.SRGB8_ALPHA8 : r.RGBA8), le === r.UNSIGNED_SHORT_4_4_4_4 && (Te = r.RGBA4), le === r.UNSIGNED_SHORT_5_5_5_1 && (Te = r.RGB5_A1);
    }
    return (Te === r.R16F || Te === r.R32F || Te === r.RG16F || Te === r.RG32F || Te === r.RGBA16F || Te === r.RGBA32F) && e.get("EXT_color_buffer_float"), Te;
  }
  function b(j, k) {
    let le;
    return j ? k === null || k === xl || k === fc ? le = r.DEPTH24_STENCIL8 : k === ra ? le = r.DEPTH32F_STENCIL8 : k === ud && (le = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : k === null || k === xl || k === fc ? le = r.DEPTH_COMPONENT24 : k === ra ? le = r.DEPTH_COMPONENT32F : k === ud && (le = r.DEPTH_COMPONENT16), le;
  }
  function T(j, k) {
    return v(j) === !0 || j.isFramebufferTexture && j.minFilter !== Zn && j.minFilter !== ds ? Math.log2(Math.max(k.width, k.height)) + 1 : j.mipmaps !== void 0 && j.mipmaps.length > 0 ? j.mipmaps.length : j.isCompressedTexture && Array.isArray(j.image) ? k.mipmaps.length : 1;
  }
  function E(j) {
    const k = j.target;
    k.removeEventListener("dispose", E), C(k), k.isVideoTexture && h.delete(k);
  }
  function M(j) {
    const k = j.target;
    k.removeEventListener("dispose", M), w(k);
  }
  function C(j) {
    const k = n.get(j);
    if (k.__webglInit === void 0) return;
    const le = j.source, we = p.get(le);
    if (we) {
      const Ce = we[k.__cacheKey];
      Ce.usedTimes--, Ce.usedTimes === 0 && S(j), Object.keys(we).length === 0 && p.delete(le);
    }
    n.remove(j);
  }
  function S(j) {
    const k = n.get(j);
    r.deleteTexture(k.__webglTexture);
    const le = j.source, we = p.get(le);
    delete we[k.__cacheKey], o.memory.textures--;
  }
  function w(j) {
    const k = n.get(j);
    if (j.depthTexture && (j.depthTexture.dispose(), n.remove(j.depthTexture)), j.isWebGLCubeRenderTarget)
      for (let we = 0; we < 6; we++) {
        if (Array.isArray(k.__webglFramebuffer[we]))
          for (let Ce = 0; Ce < k.__webglFramebuffer[we].length; Ce++) r.deleteFramebuffer(k.__webglFramebuffer[we][Ce]);
        else
          r.deleteFramebuffer(k.__webglFramebuffer[we]);
        k.__webglDepthbuffer && r.deleteRenderbuffer(k.__webglDepthbuffer[we]);
      }
    else {
      if (Array.isArray(k.__webglFramebuffer))
        for (let we = 0; we < k.__webglFramebuffer.length; we++) r.deleteFramebuffer(k.__webglFramebuffer[we]);
      else
        r.deleteFramebuffer(k.__webglFramebuffer);
      if (k.__webglDepthbuffer && r.deleteRenderbuffer(k.__webglDepthbuffer), k.__webglMultisampledFramebuffer && r.deleteFramebuffer(k.__webglMultisampledFramebuffer), k.__webglColorRenderbuffer)
        for (let we = 0; we < k.__webglColorRenderbuffer.length; we++)
          k.__webglColorRenderbuffer[we] && r.deleteRenderbuffer(k.__webglColorRenderbuffer[we]);
      k.__webglDepthRenderbuffer && r.deleteRenderbuffer(k.__webglDepthRenderbuffer);
    }
    const le = j.textures;
    for (let we = 0, Ce = le.length; we < Ce; we++) {
      const Te = n.get(le[we]);
      Te.__webglTexture && (r.deleteTexture(Te.__webglTexture), o.memory.textures--), n.remove(le[we]);
    }
    n.remove(j);
  }
  let R = 0;
  function O() {
    R = 0;
  }
  function P() {
    const j = R;
    return j >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + j + " texture units while this GPU supports only " + s.maxTextures), R += 1, j;
  }
  function A(j) {
    const k = [];
    return k.push(j.wrapS), k.push(j.wrapT), k.push(j.wrapR || 0), k.push(j.magFilter), k.push(j.minFilter), k.push(j.anisotropy), k.push(j.internalFormat), k.push(j.format), k.push(j.type), k.push(j.generateMipmaps), k.push(j.premultiplyAlpha), k.push(j.flipY), k.push(j.unpackAlignment), k.push(j.colorSpace), k.join();
  }
  function D(j, k) {
    const le = n.get(j);
    if (j.isVideoTexture && Be(j), j.isRenderTargetTexture === !1 && j.version > 0 && le.__version !== j.version) {
      const we = j.image;
      if (we === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (we.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        z(le, j, k);
        return;
      }
    }
    i.bindTexture(r.TEXTURE_2D, le.__webglTexture, r.TEXTURE0 + k);
  }
  function L(j, k) {
    const le = n.get(j);
    if (j.version > 0 && le.__version !== j.version) {
      z(le, j, k);
      return;
    }
    i.bindTexture(r.TEXTURE_2D_ARRAY, le.__webglTexture, r.TEXTURE0 + k);
  }
  function H(j, k) {
    const le = n.get(j);
    if (j.version > 0 && le.__version !== j.version) {
      z(le, j, k);
      return;
    }
    i.bindTexture(r.TEXTURE_3D, le.__webglTexture, r.TEXTURE0 + k);
  }
  function V(j, k) {
    const le = n.get(j);
    if (j.version > 0 && le.__version !== j.version) {
      K(le, j, k);
      return;
    }
    i.bindTexture(r.TEXTURE_CUBE_MAP, le.__webglTexture, r.TEXTURE0 + k);
  }
  const X = {
    [rb]: r.REPEAT,
    [il]: r.CLAMP_TO_EDGE,
    [nb]: r.MIRRORED_REPEAT
  }, F = {
    [Zn]: r.NEAREST,
    [GU]: r.NEAREST_MIPMAP_NEAREST,
    [hp]: r.NEAREST_MIPMAP_LINEAR,
    [ds]: r.LINEAR,
    [vy]: r.LINEAR_MIPMAP_NEAREST,
    [rl]: r.LINEAR_MIPMAP_LINEAR
  }, B = {
    [XU]: r.NEVER,
    [JU]: r.ALWAYS,
    [YU]: r.LESS,
    [JC]: r.LEQUAL,
    [KU]: r.EQUAL,
    [$U]: r.GEQUAL,
    [ZU]: r.GREATER,
    [QU]: r.NOTEQUAL
  };
  function W(j, k) {
    if (k.type === ra && e.has("OES_texture_float_linear") === !1 && (k.magFilter === ds || k.magFilter === vy || k.magFilter === hp || k.magFilter === rl || k.minFilter === ds || k.minFilter === vy || k.minFilter === hp || k.minFilter === rl) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(j, r.TEXTURE_WRAP_S, X[k.wrapS]), r.texParameteri(j, r.TEXTURE_WRAP_T, X[k.wrapT]), (j === r.TEXTURE_3D || j === r.TEXTURE_2D_ARRAY) && r.texParameteri(j, r.TEXTURE_WRAP_R, X[k.wrapR]), r.texParameteri(j, r.TEXTURE_MAG_FILTER, F[k.magFilter]), r.texParameteri(j, r.TEXTURE_MIN_FILTER, F[k.minFilter]), k.compareFunction && (r.texParameteri(j, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(j, r.TEXTURE_COMPARE_FUNC, B[k.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (k.magFilter === Zn || k.minFilter !== hp && k.minFilter !== rl || k.type === ra && e.has("OES_texture_float_linear") === !1) return;
      if (k.anisotropy > 1 || n.get(k).__currentAnisotropy) {
        const le = e.get("EXT_texture_filter_anisotropic");
        r.texParameterf(j, le.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(k.anisotropy, s.getMaxAnisotropy())), n.get(k).__currentAnisotropy = k.anisotropy;
      }
    }
  }
  function G(j, k) {
    let le = !1;
    j.__webglInit === void 0 && (j.__webglInit = !0, k.addEventListener("dispose", E));
    const we = k.source;
    let Ce = p.get(we);
    Ce === void 0 && (Ce = {}, p.set(we, Ce));
    const Te = A(k);
    if (Te !== j.__cacheKey) {
      Ce[Te] === void 0 && (Ce[Te] = {
        texture: r.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, le = !0), Ce[Te].usedTimes++;
      const et = Ce[j.__cacheKey];
      et !== void 0 && (Ce[j.__cacheKey].usedTimes--, et.usedTimes === 0 && S(k)), j.__cacheKey = Te, j.__webglTexture = Ce[Te].texture;
    }
    return le;
  }
  function z(j, k, le) {
    let we = r.TEXTURE_2D;
    (k.isDataArrayTexture || k.isCompressedArrayTexture) && (we = r.TEXTURE_2D_ARRAY), k.isData3DTexture && (we = r.TEXTURE_3D);
    const Ce = G(j, k), Te = k.source;
    i.bindTexture(we, j.__webglTexture, r.TEXTURE0 + le);
    const et = n.get(Te);
    if (Te.version !== et.__version || Ce === !0) {
      i.activeTexture(r.TEXTURE0 + le);
      const ze = Ht.getPrimaries(Ht.workingColorSpace), Xe = k.colorSpace === $a ? null : Ht.getPrimaries(k.colorSpace), Pt = k.colorSpace === $a || ze === Xe ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, k.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, k.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Pt);
      let Ie = y(k.image, !1, s.maxTextureSize);
      Ie = At(k, Ie);
      const Ye = a.convert(k.format, k.colorSpace), ut = a.convert(k.type);
      let ft = x(k.internalFormat, Ye, ut, k.colorSpace, k.isVideoTexture);
      W(we, k);
      let Ke;
      const Ot = k.mipmaps, xt = k.isVideoTexture !== !0, jt = et.__version === void 0 || Ce === !0, ee = Te.dataReady, Le = T(k, Ie);
      if (k.isDepthTexture)
        ft = b(k.format === mc, k.type), jt && (xt ? i.texStorage2D(r.TEXTURE_2D, 1, ft, Ie.width, Ie.height) : i.texImage2D(r.TEXTURE_2D, 0, ft, Ie.width, Ie.height, 0, Ye, ut, null));
      else if (k.isDataTexture)
        if (Ot.length > 0) {
          xt && jt && i.texStorage2D(r.TEXTURE_2D, Le, ft, Ot[0].width, Ot[0].height);
          for (let de = 0, Ee = Ot.length; de < Ee; de++)
            Ke = Ot[de], xt ? ee && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, Ke.width, Ke.height, Ye, ut, Ke.data) : i.texImage2D(r.TEXTURE_2D, de, ft, Ke.width, Ke.height, 0, Ye, ut, Ke.data);
          k.generateMipmaps = !1;
        } else
          xt ? (jt && i.texStorage2D(r.TEXTURE_2D, Le, ft, Ie.width, Ie.height), ee && i.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ie.width, Ie.height, Ye, ut, Ie.data)) : i.texImage2D(r.TEXTURE_2D, 0, ft, Ie.width, Ie.height, 0, Ye, ut, Ie.data);
      else if (k.isCompressedTexture)
        if (k.isCompressedArrayTexture) {
          xt && jt && i.texStorage3D(r.TEXTURE_2D_ARRAY, Le, ft, Ot[0].width, Ot[0].height, Ie.depth);
          for (let de = 0, Ee = Ot.length; de < Ee; de++)
            if (Ke = Ot[de], k.format !== Xn)
              if (Ye !== null)
                if (xt) {
                  if (ee)
                    if (k.layerUpdates.size > 0) {
                      const je = bS(Ke.width, Ke.height, k.format, k.type);
                      for (const Ue of k.layerUpdates) {
                        const Ct = Ke.data.subarray(
                          Ue * je / Ke.data.BYTES_PER_ELEMENT,
                          (Ue + 1) * je / Ke.data.BYTES_PER_ELEMENT
                        );
                        i.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, Ue, Ke.width, Ke.height, 1, Ye, Ct);
                      }
                      k.clearLayerUpdates();
                    } else
                      i.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, 0, Ke.width, Ke.height, Ie.depth, Ye, Ke.data);
                } else
                  i.compressedTexImage3D(r.TEXTURE_2D_ARRAY, de, ft, Ke.width, Ke.height, Ie.depth, 0, Ke.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              xt ? ee && i.texSubImage3D(r.TEXTURE_2D_ARRAY, de, 0, 0, 0, Ke.width, Ke.height, Ie.depth, Ye, ut, Ke.data) : i.texImage3D(r.TEXTURE_2D_ARRAY, de, ft, Ke.width, Ke.height, Ie.depth, 0, Ye, ut, Ke.data);
        } else {
          xt && jt && i.texStorage2D(r.TEXTURE_2D, Le, ft, Ot[0].width, Ot[0].height);
          for (let de = 0, Ee = Ot.length; de < Ee; de++)
            Ke = Ot[de], k.format !== Xn ? Ye !== null ? xt ? ee && i.compressedTexSubImage2D(r.TEXTURE_2D, de, 0, 0, Ke.width, Ke.height, Ye, Ke.data) : i.compressedTexImage2D(r.TEXTURE_2D, de, ft, Ke.width, Ke.height, 0, Ke.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : xt ? ee && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, Ke.width, Ke.height, Ye, ut, Ke.data) : i.texImage2D(r.TEXTURE_2D, de, ft, Ke.width, Ke.height, 0, Ye, ut, Ke.data);
        }
      else if (k.isDataArrayTexture)
        if (xt) {
          if (jt && i.texStorage3D(r.TEXTURE_2D_ARRAY, Le, ft, Ie.width, Ie.height, Ie.depth), ee)
            if (k.layerUpdates.size > 0) {
              const de = bS(Ie.width, Ie.height, k.format, k.type);
              for (const Ee of k.layerUpdates) {
                const je = Ie.data.subarray(
                  Ee * de / Ie.data.BYTES_PER_ELEMENT,
                  (Ee + 1) * de / Ie.data.BYTES_PER_ELEMENT
                );
                i.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, Ee, Ie.width, Ie.height, 1, Ye, ut, je);
              }
              k.clearLayerUpdates();
            } else
              i.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Ie.width, Ie.height, Ie.depth, Ye, ut, Ie.data);
        } else
          i.texImage3D(r.TEXTURE_2D_ARRAY, 0, ft, Ie.width, Ie.height, Ie.depth, 0, Ye, ut, Ie.data);
      else if (k.isData3DTexture)
        xt ? (jt && i.texStorage3D(r.TEXTURE_3D, Le, ft, Ie.width, Ie.height, Ie.depth), ee && i.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, Ie.width, Ie.height, Ie.depth, Ye, ut, Ie.data)) : i.texImage3D(r.TEXTURE_3D, 0, ft, Ie.width, Ie.height, Ie.depth, 0, Ye, ut, Ie.data);
      else if (k.isFramebufferTexture) {
        if (jt)
          if (xt)
            i.texStorage2D(r.TEXTURE_2D, Le, ft, Ie.width, Ie.height);
          else {
            let de = Ie.width, Ee = Ie.height;
            for (let je = 0; je < Le; je++)
              i.texImage2D(r.TEXTURE_2D, je, ft, de, Ee, 0, Ye, ut, null), de >>= 1, Ee >>= 1;
          }
      } else if (Ot.length > 0) {
        if (xt && jt) {
          const de = st(Ot[0]);
          i.texStorage2D(r.TEXTURE_2D, Le, ft, de.width, de.height);
        }
        for (let de = 0, Ee = Ot.length; de < Ee; de++)
          Ke = Ot[de], xt ? ee && i.texSubImage2D(r.TEXTURE_2D, de, 0, 0, Ye, ut, Ke) : i.texImage2D(r.TEXTURE_2D, de, ft, Ye, ut, Ke);
        k.generateMipmaps = !1;
      } else if (xt) {
        if (jt) {
          const de = st(Ie);
          i.texStorage2D(r.TEXTURE_2D, Le, ft, de.width, de.height);
        }
        ee && i.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ye, ut, Ie);
      } else
        i.texImage2D(r.TEXTURE_2D, 0, ft, Ye, ut, Ie);
      v(k) && g(we), et.__version = Te.version, k.onUpdate && k.onUpdate(k);
    }
    j.__version = k.version;
  }
  function K(j, k, le) {
    if (k.image.length !== 6) return;
    const we = G(j, k), Ce = k.source;
    i.bindTexture(r.TEXTURE_CUBE_MAP, j.__webglTexture, r.TEXTURE0 + le);
    const Te = n.get(Ce);
    if (Ce.version !== Te.__version || we === !0) {
      i.activeTexture(r.TEXTURE0 + le);
      const et = Ht.getPrimaries(Ht.workingColorSpace), ze = k.colorSpace === $a ? null : Ht.getPrimaries(k.colorSpace), Xe = k.colorSpace === $a || et === ze ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, k.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, k.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Xe);
      const Pt = k.isCompressedTexture || k.image[0].isCompressedTexture, Ie = k.image[0] && k.image[0].isDataTexture, Ye = [];
      for (let Ee = 0; Ee < 6; Ee++)
        !Pt && !Ie ? Ye[Ee] = y(k.image[Ee], !0, s.maxCubemapSize) : Ye[Ee] = Ie ? k.image[Ee].image : k.image[Ee], Ye[Ee] = At(k, Ye[Ee]);
      const ut = Ye[0], ft = a.convert(k.format, k.colorSpace), Ke = a.convert(k.type), Ot = x(k.internalFormat, ft, Ke, k.colorSpace), xt = k.isVideoTexture !== !0, jt = Te.__version === void 0 || we === !0, ee = Ce.dataReady;
      let Le = T(k, ut);
      W(r.TEXTURE_CUBE_MAP, k);
      let de;
      if (Pt) {
        xt && jt && i.texStorage2D(r.TEXTURE_CUBE_MAP, Le, Ot, ut.width, ut.height);
        for (let Ee = 0; Ee < 6; Ee++) {
          de = Ye[Ee].mipmaps;
          for (let je = 0; je < de.length; je++) {
            const Ue = de[je];
            k.format !== Xn ? ft !== null ? xt ? ee && i.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, je, 0, 0, Ue.width, Ue.height, ft, Ue.data) : i.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, je, Ot, Ue.width, Ue.height, 0, Ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : xt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, je, 0, 0, Ue.width, Ue.height, ft, Ke, Ue.data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, je, Ot, Ue.width, Ue.height, 0, ft, Ke, Ue.data);
          }
        }
      } else {
        if (de = k.mipmaps, xt && jt) {
          de.length > 0 && Le++;
          const Ee = st(Ye[0]);
          i.texStorage2D(r.TEXTURE_CUBE_MAP, Le, Ot, Ee.width, Ee.height);
        }
        for (let Ee = 0; Ee < 6; Ee++)
          if (Ie) {
            xt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, 0, 0, Ye[Ee].width, Ye[Ee].height, ft, Ke, Ye[Ee].data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, Ot, Ye[Ee].width, Ye[Ee].height, 0, ft, Ke, Ye[Ee].data);
            for (let je = 0; je < de.length; je++) {
              const Ue = de[je].image[Ee].image;
              xt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, je + 1, 0, 0, Ue.width, Ue.height, ft, Ke, Ue.data) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, je + 1, Ot, Ue.width, Ue.height, 0, ft, Ke, Ue.data);
            }
          } else {
            xt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, 0, 0, ft, Ke, Ye[Ee]) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, Ot, ft, Ke, Ye[Ee]);
            for (let je = 0; je < de.length; je++) {
              const Ue = de[je];
              xt ? ee && i.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, je + 1, 0, 0, ft, Ke, Ue.image[Ee]) : i.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, je + 1, Ot, ft, Ke, Ue.image[Ee]);
            }
          }
      }
      v(k) && g(r.TEXTURE_CUBE_MAP), Te.__version = Ce.version, k.onUpdate && k.onUpdate(k);
    }
    j.__version = k.version;
  }
  function ne(j, k, le, we, Ce, Te) {
    const et = a.convert(le.format, le.colorSpace), ze = a.convert(le.type), Xe = x(le.internalFormat, et, ze, le.colorSpace), Pt = n.get(k), Ie = n.get(le);
    if (Ie.__renderTarget = k, !Pt.__hasExternalTextures) {
      const Ye = Math.max(1, k.width >> Te), ut = Math.max(1, k.height >> Te);
      Ce === r.TEXTURE_3D || Ce === r.TEXTURE_2D_ARRAY ? i.texImage3D(Ce, Te, Xe, Ye, ut, k.depth, 0, et, ze, null) : i.texImage2D(Ce, Te, Xe, Ye, ut, 0, et, ze, null);
    }
    i.bindFramebuffer(r.FRAMEBUFFER, j), bt(k) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, we, Ce, Ie.__webglTexture, 0, Qe(k)) : (Ce === r.TEXTURE_2D || Ce >= r.TEXTURE_CUBE_MAP_POSITIVE_X && Ce <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, we, Ce, Ie.__webglTexture, Te), i.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function oe(j, k, le) {
    if (r.bindRenderbuffer(r.RENDERBUFFER, j), k.depthBuffer) {
      const we = k.depthTexture, Ce = we && we.isDepthTexture ? we.type : null, Te = b(k.stencilBuffer, Ce), et = k.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, ze = Qe(k);
      bt(k) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ze, Te, k.width, k.height) : le ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ze, Te, k.width, k.height) : r.renderbufferStorage(r.RENDERBUFFER, Te, k.width, k.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, et, r.RENDERBUFFER, j);
    } else {
      const we = k.textures;
      for (let Ce = 0; Ce < we.length; Ce++) {
        const Te = we[Ce], et = a.convert(Te.format, Te.colorSpace), ze = a.convert(Te.type), Xe = x(Te.internalFormat, et, ze, Te.colorSpace), Pt = Qe(k);
        le && bt(k) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, Pt, Xe, k.width, k.height) : bt(k) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, Pt, Xe, k.width, k.height) : r.renderbufferStorage(r.RENDERBUFFER, Xe, k.width, k.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function pe(j, k) {
    if (k && k.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (i.bindFramebuffer(r.FRAMEBUFFER, j), !(k.depthTexture && k.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const le = n.get(k.depthTexture);
    le.__renderTarget = k, (!le.__webglTexture || k.depthTexture.image.width !== k.width || k.depthTexture.image.height !== k.height) && (k.depthTexture.image.width = k.width, k.depthTexture.image.height = k.height, k.depthTexture.needsUpdate = !0), D(k.depthTexture, 0);
    const we = le.__webglTexture, Ce = Qe(k);
    if (k.depthTexture.format === Hu)
      bt(k) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, we, 0, Ce) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, we, 0);
    else if (k.depthTexture.format === mc)
      bt(k) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, we, 0, Ce) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, we, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function xe(j) {
    const k = n.get(j), le = j.isWebGLCubeRenderTarget === !0;
    if (k.__boundDepthTexture !== j.depthTexture) {
      const we = j.depthTexture;
      if (k.__depthDisposeCallback && k.__depthDisposeCallback(), we) {
        const Ce = () => {
          delete k.__boundDepthTexture, delete k.__depthDisposeCallback, we.removeEventListener("dispose", Ce);
        };
        we.addEventListener("dispose", Ce), k.__depthDisposeCallback = Ce;
      }
      k.__boundDepthTexture = we;
    }
    if (j.depthTexture && !k.__autoAllocateDepthBuffer) {
      if (le) throw new Error("target.depthTexture not supported in Cube render targets");
      pe(k.__webglFramebuffer, j);
    } else if (le) {
      k.__webglDepthbuffer = [];
      for (let we = 0; we < 6; we++)
        if (i.bindFramebuffer(r.FRAMEBUFFER, k.__webglFramebuffer[we]), k.__webglDepthbuffer[we] === void 0)
          k.__webglDepthbuffer[we] = r.createRenderbuffer(), oe(k.__webglDepthbuffer[we], j, !1);
        else {
          const Ce = j.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Te = k.__webglDepthbuffer[we];
          r.bindRenderbuffer(r.RENDERBUFFER, Te), r.framebufferRenderbuffer(r.FRAMEBUFFER, Ce, r.RENDERBUFFER, Te);
        }
    } else if (i.bindFramebuffer(r.FRAMEBUFFER, k.__webglFramebuffer), k.__webglDepthbuffer === void 0)
      k.__webglDepthbuffer = r.createRenderbuffer(), oe(k.__webglDepthbuffer, j, !1);
    else {
      const we = j.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Ce = k.__webglDepthbuffer;
      r.bindRenderbuffer(r.RENDERBUFFER, Ce), r.framebufferRenderbuffer(r.FRAMEBUFFER, we, r.RENDERBUFFER, Ce);
    }
    i.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function Re(j, k, le) {
    const we = n.get(j);
    k !== void 0 && ne(we.__webglFramebuffer, j, j.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), le !== void 0 && xe(j);
  }
  function nt(j) {
    const k = j.texture, le = n.get(j), we = n.get(k);
    j.addEventListener("dispose", M);
    const Ce = j.textures, Te = j.isWebGLCubeRenderTarget === !0, et = Ce.length > 1;
    if (et || (we.__webglTexture === void 0 && (we.__webglTexture = r.createTexture()), we.__version = k.version, o.memory.textures++), Te) {
      le.__webglFramebuffer = [];
      for (let ze = 0; ze < 6; ze++)
        if (k.mipmaps && k.mipmaps.length > 0) {
          le.__webglFramebuffer[ze] = [];
          for (let Xe = 0; Xe < k.mipmaps.length; Xe++)
            le.__webglFramebuffer[ze][Xe] = r.createFramebuffer();
        } else
          le.__webglFramebuffer[ze] = r.createFramebuffer();
    } else {
      if (k.mipmaps && k.mipmaps.length > 0) {
        le.__webglFramebuffer = [];
        for (let ze = 0; ze < k.mipmaps.length; ze++)
          le.__webglFramebuffer[ze] = r.createFramebuffer();
      } else
        le.__webglFramebuffer = r.createFramebuffer();
      if (et)
        for (let ze = 0, Xe = Ce.length; ze < Xe; ze++) {
          const Pt = n.get(Ce[ze]);
          Pt.__webglTexture === void 0 && (Pt.__webglTexture = r.createTexture(), o.memory.textures++);
        }
      if (j.samples > 0 && bt(j) === !1) {
        le.__webglMultisampledFramebuffer = r.createFramebuffer(), le.__webglColorRenderbuffer = [], i.bindFramebuffer(r.FRAMEBUFFER, le.__webglMultisampledFramebuffer);
        for (let ze = 0; ze < Ce.length; ze++) {
          const Xe = Ce[ze];
          le.__webglColorRenderbuffer[ze] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, le.__webglColorRenderbuffer[ze]);
          const Pt = a.convert(Xe.format, Xe.colorSpace), Ie = a.convert(Xe.type), Ye = x(Xe.internalFormat, Pt, Ie, Xe.colorSpace, j.isXRRenderTarget === !0), ut = Qe(j);
          r.renderbufferStorageMultisample(r.RENDERBUFFER, ut, Ye, j.width, j.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ze, r.RENDERBUFFER, le.__webglColorRenderbuffer[ze]);
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null), j.depthBuffer && (le.__webglDepthRenderbuffer = r.createRenderbuffer(), oe(le.__webglDepthRenderbuffer, j, !0)), i.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (Te) {
      i.bindTexture(r.TEXTURE_CUBE_MAP, we.__webglTexture), W(r.TEXTURE_CUBE_MAP, k);
      for (let ze = 0; ze < 6; ze++)
        if (k.mipmaps && k.mipmaps.length > 0)
          for (let Xe = 0; Xe < k.mipmaps.length; Xe++)
            ne(le.__webglFramebuffer[ze][Xe], j, k, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ze, Xe);
        else
          ne(le.__webglFramebuffer[ze], j, k, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ze, 0);
      v(k) && g(r.TEXTURE_CUBE_MAP), i.unbindTexture();
    } else if (et) {
      for (let ze = 0, Xe = Ce.length; ze < Xe; ze++) {
        const Pt = Ce[ze], Ie = n.get(Pt);
        i.bindTexture(r.TEXTURE_2D, Ie.__webglTexture), W(r.TEXTURE_2D, Pt), ne(le.__webglFramebuffer, j, Pt, r.COLOR_ATTACHMENT0 + ze, r.TEXTURE_2D, 0), v(Pt) && g(r.TEXTURE_2D);
      }
      i.unbindTexture();
    } else {
      let ze = r.TEXTURE_2D;
      if ((j.isWebGL3DRenderTarget || j.isWebGLArrayRenderTarget) && (ze = j.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), i.bindTexture(ze, we.__webglTexture), W(ze, k), k.mipmaps && k.mipmaps.length > 0)
        for (let Xe = 0; Xe < k.mipmaps.length; Xe++)
          ne(le.__webglFramebuffer[Xe], j, k, r.COLOR_ATTACHMENT0, ze, Xe);
      else
        ne(le.__webglFramebuffer, j, k, r.COLOR_ATTACHMENT0, ze, 0);
      v(k) && g(ze), i.unbindTexture();
    }
    j.depthBuffer && xe(j);
  }
  function fe(j) {
    const k = j.textures;
    for (let le = 0, we = k.length; le < we; le++) {
      const Ce = k[le];
      if (v(Ce)) {
        const Te = _(j), et = n.get(Ce).__webglTexture;
        i.bindTexture(Te, et), g(Te), i.unbindTexture();
      }
    }
  }
  const gt = [], Q = [];
  function Gt(j) {
    if (j.samples > 0) {
      if (bt(j) === !1) {
        const k = j.textures, le = j.width, we = j.height;
        let Ce = r.COLOR_BUFFER_BIT;
        const Te = j.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, et = n.get(j), ze = k.length > 1;
        if (ze)
          for (let Xe = 0; Xe < k.length; Xe++)
            i.bindFramebuffer(r.FRAMEBUFFER, et.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Xe, r.RENDERBUFFER, null), i.bindFramebuffer(r.FRAMEBUFFER, et.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Xe, r.TEXTURE_2D, null, 0);
        i.bindFramebuffer(r.READ_FRAMEBUFFER, et.__webglMultisampledFramebuffer), i.bindFramebuffer(r.DRAW_FRAMEBUFFER, et.__webglFramebuffer);
        for (let Xe = 0; Xe < k.length; Xe++) {
          if (j.resolveDepthBuffer && (j.depthBuffer && (Ce |= r.DEPTH_BUFFER_BIT), j.stencilBuffer && j.resolveStencilBuffer && (Ce |= r.STENCIL_BUFFER_BIT)), ze) {
            r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, et.__webglColorRenderbuffer[Xe]);
            const Pt = n.get(k[Xe]).__webglTexture;
            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, Pt, 0);
          }
          r.blitFramebuffer(0, 0, le, we, 0, 0, le, we, Ce, r.NEAREST), u === !0 && (gt.length = 0, Q.length = 0, gt.push(r.COLOR_ATTACHMENT0 + Xe), j.depthBuffer && j.resolveDepthBuffer === !1 && (gt.push(Te), Q.push(Te), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, Q)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, gt));
        }
        if (i.bindFramebuffer(r.READ_FRAMEBUFFER, null), i.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), ze)
          for (let Xe = 0; Xe < k.length; Xe++) {
            i.bindFramebuffer(r.FRAMEBUFFER, et.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Xe, r.RENDERBUFFER, et.__webglColorRenderbuffer[Xe]);
            const Pt = n.get(k[Xe]).__webglTexture;
            i.bindFramebuffer(r.FRAMEBUFFER, et.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Xe, r.TEXTURE_2D, Pt, 0);
          }
        i.bindFramebuffer(r.DRAW_FRAMEBUFFER, et.__webglMultisampledFramebuffer);
      } else if (j.depthBuffer && j.resolveDepthBuffer === !1 && u) {
        const k = j.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
        r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [k]);
      }
    }
  }
  function Qe(j) {
    return Math.min(s.maxSamples, j.samples);
  }
  function bt(j) {
    const k = n.get(j);
    return j.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && k.__useRenderToTexture !== !1;
  }
  function Be(j) {
    const k = o.render.frame;
    h.get(j) !== k && (h.set(j, k), j.update());
  }
  function At(j, k) {
    const le = j.colorSpace, we = j.format, Ce = j.type;
    return j.isCompressedTexture === !0 || j.isVideoTexture === !0 || le !== kc && le !== $a && (Ht.getTransfer(le) === ei ? (we !== Xn || Ce !== ba) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", le)), k;
  }
  function st(j) {
    return typeof HTMLImageElement < "u" && j instanceof HTMLImageElement ? (c.width = j.naturalWidth || j.width, c.height = j.naturalHeight || j.height) : typeof VideoFrame < "u" && j instanceof VideoFrame ? (c.width = j.displayWidth, c.height = j.displayHeight) : (c.width = j.width, c.height = j.height), c;
  }
  this.allocateTextureUnit = P, this.resetTextureUnits = O, this.setTexture2D = D, this.setTexture2DArray = L, this.setTexture3D = H, this.setTextureCube = V, this.rebindTextures = Re, this.setupRenderTarget = nt, this.updateRenderTargetMipmap = fe, this.updateMultisampleRenderTarget = Gt, this.setupDepthRenderbuffer = xe, this.setupFrameBufferTexture = ne, this.useMultisampledRTT = bt;
}
function yj(r, e) {
  function i(n, s = $a) {
    let a;
    const o = Ht.getTransfer(s);
    if (n === ba) return r.UNSIGNED_BYTE;
    if (n === E_) return r.UNSIGNED_SHORT_4_4_4_4;
    if (n === M_) return r.UNSIGNED_SHORT_5_5_5_1;
    if (n === HC) return r.UNSIGNED_INT_5_9_9_9_REV;
    if (n === VC) return r.BYTE;
    if (n === GC) return r.SHORT;
    if (n === ud) return r.UNSIGNED_SHORT;
    if (n === S_) return r.INT;
    if (n === xl) return r.UNSIGNED_INT;
    if (n === ra) return r.FLOAT;
    if (n === Lc) return r.HALF_FLOAT;
    if (n === WC) return r.ALPHA;
    if (n === qC) return r.RGB;
    if (n === Xn) return r.RGBA;
    if (n === XC) return r.LUMINANCE;
    if (n === YC) return r.LUMINANCE_ALPHA;
    if (n === Hu) return r.DEPTH_COMPONENT;
    if (n === mc) return r.DEPTH_STENCIL;
    if (n === KC) return r.RED;
    if (n === A_) return r.RED_INTEGER;
    if (n === ZC) return r.RG;
    if (n === C_) return r.RG_INTEGER;
    if (n === R_) return r.RGBA_INTEGER;
    if (n === Hf || n === Wf || n === qf || n === Xf)
      if (o === ei)
        if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (n === Hf) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === Wf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === qf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === Xf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (n === Hf) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === Wf) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === qf) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Xf) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === sb || n === ab || n === ob || n === lb)
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (n === sb) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === ab) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === ob) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === lb) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === ub || n === cb || n === hb)
      if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (n === ub || n === cb) return o === ei ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (n === hb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (n === db || n === pb || n === fb || n === mb || n === gb || n === yb || n === vb || n === bb || n === xb || n === _b || n === Tb || n === wb || n === Sb || n === Eb)
      if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (n === db) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === pb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === fb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === mb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === gb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === yb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === vb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === bb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === xb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === _b) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === Tb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === wb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === Sb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === Eb) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === Yf || n === Mb || n === Ab)
      if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
        if (n === Yf) return o === ei ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === Mb) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === Ab) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (n === QC || n === Cb || n === Rb || n === Nb)
      if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
        if (n === Yf) return a.COMPRESSED_RED_RGTC1_EXT;
        if (n === Cb) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === Rb) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === Nb) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === fc ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null;
  }
  return { convert: i };
}
class vj extends vn {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
let nl = class extends Gr {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
};
const bj = { type: "move" };
class Wy {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new nl(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new nl(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Y(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Y()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new nl(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Y(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Y()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const i = this._hand;
      if (i)
        for (const n of e.hand.values())
          this._getHandJoint(i, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, i, n) {
    let s = null, a = null, o = null;
    const l = this._targetRay, u = this._grip, c = this._hand;
    if (e && i.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const y of e.hand.values()) {
          const v = i.getJointPose(y, n), g = this._getHandJoint(c, y);
          v !== null && (g.matrix.fromArray(v.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, g.jointRadius = v.radius), g.visible = v !== null;
        }
        const h = c.joints["index-finger-tip"], d = c.joints["thumb-tip"], p = h.position.distanceTo(d.position), f = 0.02, m = 5e-3;
        c.inputState.pinching && p > f + m ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && p <= f - m && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        u !== null && e.gripSpace && (a = i.getPose(e.gripSpace, n), a !== null && (u.matrix.fromArray(a.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (u.hasLinearVelocity = !0, u.linearVelocity.copy(a.linearVelocity)) : u.hasLinearVelocity = !1, a.angularVelocity ? (u.hasAngularVelocity = !0, u.angularVelocity.copy(a.angularVelocity)) : u.hasAngularVelocity = !1));
      l !== null && (s = i.getPose(e.targetRaySpace, n), s === null && a !== null && (s = a), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent(bj)));
    }
    return l !== null && (l.visible = s !== null), u !== null && (u.visible = a !== null), c !== null && (c.visible = o !== null), this;
  }
  // private method
  _getHandJoint(e, i) {
    if (e.joints[i.jointName] === void 0) {
      const n = new nl();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[i.jointName] = n, e.add(n);
    }
    return e.joints[i.jointName];
  }
}
const xj = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, _j = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class Tj {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, i, n) {
    if (this.texture === null) {
      const s = new En(), a = e.properties.get(s);
      a.__webglTexture = i.texture, (i.depthNear != n.depthNear || i.depthFar != n.depthFar) && (this.depthNear = i.depthNear, this.depthFar = i.depthFar), this.texture = s;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const i = e.cameras[0].viewport, n = new xs({
        vertexShader: xj,
        fragmentShader: _j,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: i.z },
          depthHeight: { value: i.w }
        }
      });
      this.mesh = new kr(new Gd(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class wj extends Cl {
  constructor(e, i) {
    super();
    const n = this;
    let s = null, a = 1, o = null, l = "local-floor", u = 1, c = null, h = null, d = null, p = null, f = null, m = null;
    const y = new Tj(), v = i.getContextAttributes();
    let g = null, _ = null;
    const x = [], b = [], T = new ke();
    let E = null;
    const M = new vn();
    M.viewport = new Fi();
    const C = new vn();
    C.viewport = new Fi();
    const S = [M, C], w = new vj();
    let R = null, O = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(z) {
      let K = x[z];
      return K === void 0 && (K = new Wy(), x[z] = K), K.getTargetRaySpace();
    }, this.getControllerGrip = function(z) {
      let K = x[z];
      return K === void 0 && (K = new Wy(), x[z] = K), K.getGripSpace();
    }, this.getHand = function(z) {
      let K = x[z];
      return K === void 0 && (K = new Wy(), x[z] = K), K.getHandSpace();
    };
    function P(z) {
      const K = b.indexOf(z.inputSource);
      if (K === -1)
        return;
      const ne = x[K];
      ne !== void 0 && (ne.update(z.inputSource, z.frame, c || o), ne.dispatchEvent({ type: z.type, data: z.inputSource }));
    }
    function A() {
      s.removeEventListener("select", P), s.removeEventListener("selectstart", P), s.removeEventListener("selectend", P), s.removeEventListener("squeeze", P), s.removeEventListener("squeezestart", P), s.removeEventListener("squeezeend", P), s.removeEventListener("end", A), s.removeEventListener("inputsourceschange", D);
      for (let z = 0; z < x.length; z++) {
        const K = b[z];
        K !== null && (b[z] = null, x[z].disconnect(K));
      }
      R = null, O = null, y.reset(), e.setRenderTarget(g), f = null, p = null, d = null, s = null, _ = null, G.stop(), n.isPresenting = !1, e.setPixelRatio(E), e.setSize(T.width, T.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(z) {
      a = z, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(z) {
      l = z, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || o;
    }, this.setReferenceSpace = function(z) {
      c = z;
    }, this.getBaseLayer = function() {
      return p !== null ? p : f;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return s;
    }, this.setSession = async function(z) {
      if (s = z, s !== null) {
        if (g = e.getRenderTarget(), s.addEventListener("select", P), s.addEventListener("selectstart", P), s.addEventListener("selectend", P), s.addEventListener("squeeze", P), s.addEventListener("squeezestart", P), s.addEventListener("squeezeend", P), s.addEventListener("end", A), s.addEventListener("inputsourceschange", D), v.xrCompatible !== !0 && await i.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(T), s.renderState.layers === void 0) {
          const K = {
            antialias: v.antialias,
            alpha: !0,
            depth: v.depth,
            stencil: v.stencil,
            framebufferScaleFactor: a
          };
          f = new XRWebGLLayer(s, i, K), s.updateRenderState({ baseLayer: f }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), _ = new mo(
            f.framebufferWidth,
            f.framebufferHeight,
            {
              format: Xn,
              type: ba,
              colorSpace: e.outputColorSpace,
              stencilBuffer: v.stencil
            }
          );
        } else {
          let K = null, ne = null, oe = null;
          v.depth && (oe = v.stencil ? i.DEPTH24_STENCIL8 : i.DEPTH_COMPONENT24, K = v.stencil ? mc : Hu, ne = v.stencil ? fc : xl);
          const pe = {
            colorFormat: i.RGBA8,
            depthFormat: oe,
            scaleFactor: a
          };
          d = new XRWebGLBinding(s, i), p = d.createProjectionLayer(pe), s.updateRenderState({ layers: [p] }), e.setPixelRatio(1), e.setSize(p.textureWidth, p.textureHeight, !1), _ = new mo(
            p.textureWidth,
            p.textureHeight,
            {
              format: Xn,
              type: ba,
              depthTexture: new vR(p.textureWidth, p.textureHeight, ne, void 0, void 0, void 0, void 0, void 0, void 0, K),
              stencilBuffer: v.stencil,
              colorSpace: e.outputColorSpace,
              samples: v.antialias ? 4 : 0,
              resolveDepthBuffer: p.ignoreDepthValues === !1
            }
          );
        }
        _.isXRRenderTarget = !0, this.setFoveation(u), c = null, o = await s.requestReferenceSpace(l), G.setContext(s), G.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (s !== null)
        return s.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return y.getDepthTexture();
    };
    function D(z) {
      for (let K = 0; K < z.removed.length; K++) {
        const ne = z.removed[K], oe = b.indexOf(ne);
        oe >= 0 && (b[oe] = null, x[oe].disconnect(ne));
      }
      for (let K = 0; K < z.added.length; K++) {
        const ne = z.added[K];
        let oe = b.indexOf(ne);
        if (oe === -1) {
          for (let xe = 0; xe < x.length; xe++)
            if (xe >= b.length) {
              b.push(ne), oe = xe;
              break;
            } else if (b[xe] === null) {
              b[xe] = ne, oe = xe;
              break;
            }
          if (oe === -1) break;
        }
        const pe = x[oe];
        pe && pe.connect(ne);
      }
    }
    const L = new Y(), H = new Y();
    function V(z, K, ne) {
      L.setFromMatrixPosition(K.matrixWorld), H.setFromMatrixPosition(ne.matrixWorld);
      const oe = L.distanceTo(H), pe = K.projectionMatrix.elements, xe = ne.projectionMatrix.elements, Re = pe[14] / (pe[10] - 1), nt = pe[14] / (pe[10] + 1), fe = (pe[9] + 1) / pe[5], gt = (pe[9] - 1) / pe[5], Q = (pe[8] - 1) / pe[0], Gt = (xe[8] + 1) / xe[0], Qe = Re * Q, bt = Re * Gt, Be = oe / (-Q + Gt), At = Be * -Q;
      if (K.matrixWorld.decompose(z.position, z.quaternion, z.scale), z.translateX(At), z.translateZ(Be), z.matrixWorld.compose(z.position, z.quaternion, z.scale), z.matrixWorldInverse.copy(z.matrixWorld).invert(), pe[10] === -1)
        z.projectionMatrix.copy(K.projectionMatrix), z.projectionMatrixInverse.copy(K.projectionMatrixInverse);
      else {
        const st = Re + Be, j = nt + Be, k = Qe - At, le = bt + (oe - At), we = fe * nt / j * st, Ce = gt * nt / j * st;
        z.projectionMatrix.makePerspective(k, le, we, Ce, st, j), z.projectionMatrixInverse.copy(z.projectionMatrix).invert();
      }
    }
    function X(z, K) {
      K === null ? z.matrixWorld.copy(z.matrix) : z.matrixWorld.multiplyMatrices(K.matrixWorld, z.matrix), z.matrixWorldInverse.copy(z.matrixWorld).invert();
    }
    this.updateCamera = function(z) {
      if (s === null) return;
      let K = z.near, ne = z.far;
      y.texture !== null && (y.depthNear > 0 && (K = y.depthNear), y.depthFar > 0 && (ne = y.depthFar)), w.near = C.near = M.near = K, w.far = C.far = M.far = ne, (R !== w.near || O !== w.far) && (s.updateRenderState({
        depthNear: w.near,
        depthFar: w.far
      }), R = w.near, O = w.far), M.layers.mask = z.layers.mask | 2, C.layers.mask = z.layers.mask | 4, w.layers.mask = M.layers.mask | C.layers.mask;
      const oe = z.parent, pe = w.cameras;
      X(w, oe);
      for (let xe = 0; xe < pe.length; xe++)
        X(pe[xe], oe);
      pe.length === 2 ? V(w, M, C) : w.projectionMatrix.copy(M.projectionMatrix), F(z, w, oe);
    };
    function F(z, K, ne) {
      ne === null ? z.matrix.copy(K.matrixWorld) : (z.matrix.copy(ne.matrixWorld), z.matrix.invert(), z.matrix.multiply(K.matrixWorld)), z.matrix.decompose(z.position, z.quaternion, z.scale), z.updateMatrixWorld(!0), z.projectionMatrix.copy(K.projectionMatrix), z.projectionMatrixInverse.copy(K.projectionMatrixInverse), z.isPerspectiveCamera && (z.fov = cd * 2 * Math.atan(1 / z.projectionMatrix.elements[5]), z.zoom = 1);
    }
    this.getCamera = function() {
      return w;
    }, this.getFoveation = function() {
      if (!(p === null && f === null))
        return u;
    }, this.setFoveation = function(z) {
      u = z, p !== null && (p.fixedFoveation = z), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = z);
    }, this.hasDepthSensing = function() {
      return y.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return y.getMesh(w);
    };
    let B = null;
    function W(z, K) {
      if (h = K.getViewerPose(c || o), m = K, h !== null) {
        const ne = h.views;
        f !== null && (e.setRenderTargetFramebuffer(_, f.framebuffer), e.setRenderTarget(_));
        let oe = !1;
        ne.length !== w.cameras.length && (w.cameras.length = 0, oe = !0);
        for (let xe = 0; xe < ne.length; xe++) {
          const Re = ne[xe];
          let nt = null;
          if (f !== null)
            nt = f.getViewport(Re);
          else {
            const gt = d.getViewSubImage(p, Re);
            nt = gt.viewport, xe === 0 && (e.setRenderTargetTextures(
              _,
              gt.colorTexture,
              p.ignoreDepthValues ? void 0 : gt.depthStencilTexture
            ), e.setRenderTarget(_));
          }
          let fe = S[xe];
          fe === void 0 && (fe = new vn(), fe.layers.enable(xe), fe.viewport = new Fi(), S[xe] = fe), fe.matrix.fromArray(Re.transform.matrix), fe.matrix.decompose(fe.position, fe.quaternion, fe.scale), fe.projectionMatrix.fromArray(Re.projectionMatrix), fe.projectionMatrixInverse.copy(fe.projectionMatrix).invert(), fe.viewport.set(nt.x, nt.y, nt.width, nt.height), xe === 0 && (w.matrix.copy(fe.matrix), w.matrix.decompose(w.position, w.quaternion, w.scale)), oe === !0 && w.cameras.push(fe);
        }
        const pe = s.enabledFeatures;
        if (pe && pe.includes("depth-sensing")) {
          const xe = d.getDepthInformation(ne[0]);
          xe && xe.isValid && xe.texture && y.init(e, xe, s.renderState);
        }
      }
      for (let ne = 0; ne < x.length; ne++) {
        const oe = b[ne], pe = x[ne];
        oe !== null && pe !== void 0 && pe.update(oe, K, c || o);
      }
      B && B(z, K), K.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: K }), m = null;
    }
    const G = new yR();
    G.setAnimationLoop(W), this.setAnimationLoop = function(z) {
      B = z;
    }, this.dispose = function() {
    };
  }
}
const Oo = /* @__PURE__ */ new go(), Sj = /* @__PURE__ */ new ui();
function Ej(r, e) {
  function i(v, g) {
    v.matrixAutoUpdate === !0 && v.updateMatrix(), g.value.copy(v.matrix);
  }
  function n(v, g) {
    g.color.getRGB(v.fogColor.value, pR(r)), g.isFog ? (v.fogNear.value = g.near, v.fogFar.value = g.far) : g.isFogExp2 && (v.fogDensity.value = g.density);
  }
  function s(v, g, _, x, b) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial ? a(v, g) : g.isMeshToonMaterial ? (a(v, g), d(v, g)) : g.isMeshPhongMaterial ? (a(v, g), h(v, g)) : g.isMeshStandardMaterial ? (a(v, g), p(v, g), g.isMeshPhysicalMaterial && f(v, g, b)) : g.isMeshMatcapMaterial ? (a(v, g), m(v, g)) : g.isMeshDepthMaterial ? a(v, g) : g.isMeshDistanceMaterial ? (a(v, g), y(v, g)) : g.isMeshNormalMaterial ? a(v, g) : g.isLineBasicMaterial ? (o(v, g), g.isLineDashedMaterial && l(v, g)) : g.isPointsMaterial ? u(v, g, _, x) : g.isSpriteMaterial ? c(v, g) : g.isShadowMaterial ? (v.color.value.copy(g.color), v.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function a(v, g) {
    v.opacity.value = g.opacity, g.color && v.diffuse.value.copy(g.color), g.emissive && v.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (v.map.value = g.map, i(g.map, v.mapTransform)), g.alphaMap && (v.alphaMap.value = g.alphaMap, i(g.alphaMap, v.alphaMapTransform)), g.bumpMap && (v.bumpMap.value = g.bumpMap, i(g.bumpMap, v.bumpMapTransform), v.bumpScale.value = g.bumpScale, g.side === Ar && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, i(g.normalMap, v.normalMapTransform), v.normalScale.value.copy(g.normalScale), g.side === Ar && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, i(g.displacementMap, v.displacementMapTransform), v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias), g.emissiveMap && (v.emissiveMap.value = g.emissiveMap, i(g.emissiveMap, v.emissiveMapTransform)), g.specularMap && (v.specularMap.value = g.specularMap, i(g.specularMap, v.specularMapTransform)), g.alphaTest > 0 && (v.alphaTest.value = g.alphaTest);
    const _ = e.get(g), x = _.envMap, b = _.envMapRotation;
    x && (v.envMap.value = x, Oo.copy(b), Oo.x *= -1, Oo.y *= -1, Oo.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === !1 && (Oo.y *= -1, Oo.z *= -1), v.envMapRotation.value.setFromMatrix4(Sj.makeRotationFromEuler(Oo)), v.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, v.reflectivity.value = g.reflectivity, v.ior.value = g.ior, v.refractionRatio.value = g.refractionRatio), g.lightMap && (v.lightMap.value = g.lightMap, v.lightMapIntensity.value = g.lightMapIntensity, i(g.lightMap, v.lightMapTransform)), g.aoMap && (v.aoMap.value = g.aoMap, v.aoMapIntensity.value = g.aoMapIntensity, i(g.aoMap, v.aoMapTransform));
  }
  function o(v, g) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, g.map && (v.map.value = g.map, i(g.map, v.mapTransform));
  }
  function l(v, g) {
    v.dashSize.value = g.dashSize, v.totalSize.value = g.dashSize + g.gapSize, v.scale.value = g.scale;
  }
  function u(v, g, _, x) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, v.size.value = g.size * _, v.scale.value = x * 0.5, g.map && (v.map.value = g.map, i(g.map, v.uvTransform)), g.alphaMap && (v.alphaMap.value = g.alphaMap, i(g.alphaMap, v.alphaMapTransform)), g.alphaTest > 0 && (v.alphaTest.value = g.alphaTest);
  }
  function c(v, g) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, v.rotation.value = g.rotation, g.map && (v.map.value = g.map, i(g.map, v.mapTransform)), g.alphaMap && (v.alphaMap.value = g.alphaMap, i(g.alphaMap, v.alphaMapTransform)), g.alphaTest > 0 && (v.alphaTest.value = g.alphaTest);
  }
  function h(v, g) {
    v.specular.value.copy(g.specular), v.shininess.value = Math.max(g.shininess, 1e-4);
  }
  function d(v, g) {
    g.gradientMap && (v.gradientMap.value = g.gradientMap);
  }
  function p(v, g) {
    v.metalness.value = g.metalness, g.metalnessMap && (v.metalnessMap.value = g.metalnessMap, i(g.metalnessMap, v.metalnessMapTransform)), v.roughness.value = g.roughness, g.roughnessMap && (v.roughnessMap.value = g.roughnessMap, i(g.roughnessMap, v.roughnessMapTransform)), g.envMap && (v.envMapIntensity.value = g.envMapIntensity);
  }
  function f(v, g, _) {
    v.ior.value = g.ior, g.sheen > 0 && (v.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), v.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (v.sheenColorMap.value = g.sheenColorMap, i(g.sheenColorMap, v.sheenColorMapTransform)), g.sheenRoughnessMap && (v.sheenRoughnessMap.value = g.sheenRoughnessMap, i(g.sheenRoughnessMap, v.sheenRoughnessMapTransform))), g.clearcoat > 0 && (v.clearcoat.value = g.clearcoat, v.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (v.clearcoatMap.value = g.clearcoatMap, i(g.clearcoatMap, v.clearcoatMapTransform)), g.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap, i(g.clearcoatRoughnessMap, v.clearcoatRoughnessMapTransform)), g.clearcoatNormalMap && (v.clearcoatNormalMap.value = g.clearcoatNormalMap, i(g.clearcoatNormalMap, v.clearcoatNormalMapTransform), v.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === Ar && v.clearcoatNormalScale.value.negate())), g.dispersion > 0 && (v.dispersion.value = g.dispersion), g.iridescence > 0 && (v.iridescence.value = g.iridescence, v.iridescenceIOR.value = g.iridescenceIOR, v.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], v.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (v.iridescenceMap.value = g.iridescenceMap, i(g.iridescenceMap, v.iridescenceMapTransform)), g.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = g.iridescenceThicknessMap, i(g.iridescenceThicknessMap, v.iridescenceThicknessMapTransform))), g.transmission > 0 && (v.transmission.value = g.transmission, v.transmissionSamplerMap.value = _.texture, v.transmissionSamplerSize.value.set(_.width, _.height), g.transmissionMap && (v.transmissionMap.value = g.transmissionMap, i(g.transmissionMap, v.transmissionMapTransform)), v.thickness.value = g.thickness, g.thicknessMap && (v.thicknessMap.value = g.thicknessMap, i(g.thicknessMap, v.thicknessMapTransform)), v.attenuationDistance.value = g.attenuationDistance, v.attenuationColor.value.copy(g.attenuationColor)), g.anisotropy > 0 && (v.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && (v.anisotropyMap.value = g.anisotropyMap, i(g.anisotropyMap, v.anisotropyMapTransform))), v.specularIntensity.value = g.specularIntensity, v.specularColor.value.copy(g.specularColor), g.specularColorMap && (v.specularColorMap.value = g.specularColorMap, i(g.specularColorMap, v.specularColorMapTransform)), g.specularIntensityMap && (v.specularIntensityMap.value = g.specularIntensityMap, i(g.specularIntensityMap, v.specularIntensityMapTransform));
  }
  function m(v, g) {
    g.matcap && (v.matcap.value = g.matcap);
  }
  function y(v, g) {
    const _ = e.get(g).light;
    v.referencePosition.value.setFromMatrixPosition(_.matrixWorld), v.nearDistance.value = _.shadow.camera.near, v.farDistance.value = _.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: s
  };
}
function Mj(r, e, i, n) {
  let s = {}, a = {}, o = [];
  const l = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
  function u(_, x) {
    const b = x.program;
    n.uniformBlockBinding(_, b);
  }
  function c(_, x) {
    let b = s[_.id];
    b === void 0 && (m(_), b = h(_), s[_.id] = b, _.addEventListener("dispose", v));
    const T = x.program;
    n.updateUBOMapping(_, T);
    const E = e.render.frame;
    a[_.id] !== E && (p(_), a[_.id] = E);
  }
  function h(_) {
    const x = d();
    _.__bindingPointIndex = x;
    const b = r.createBuffer(), T = _.__size, E = _.usage;
    return r.bindBuffer(r.UNIFORM_BUFFER, b), r.bufferData(r.UNIFORM_BUFFER, T, E), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, x, b), b;
  }
  function d() {
    for (let _ = 0; _ < l; _++)
      if (o.indexOf(_) === -1)
        return o.push(_), _;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function p(_) {
    const x = s[_.id], b = _.uniforms, T = _.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, x);
    for (let E = 0, M = b.length; E < M; E++) {
      const C = Array.isArray(b[E]) ? b[E] : [b[E]];
      for (let S = 0, w = C.length; S < w; S++) {
        const R = C[S];
        if (f(R, E, S, T) === !0) {
          const O = R.__offset, P = Array.isArray(R.value) ? R.value : [R.value];
          let A = 0;
          for (let D = 0; D < P.length; D++) {
            const L = P[D], H = y(L);
            typeof L == "number" || typeof L == "boolean" ? (R.__data[0] = L, r.bufferSubData(r.UNIFORM_BUFFER, O + A, R.__data)) : L.isMatrix3 ? (R.__data[0] = L.elements[0], R.__data[1] = L.elements[1], R.__data[2] = L.elements[2], R.__data[3] = 0, R.__data[4] = L.elements[3], R.__data[5] = L.elements[4], R.__data[6] = L.elements[5], R.__data[7] = 0, R.__data[8] = L.elements[6], R.__data[9] = L.elements[7], R.__data[10] = L.elements[8], R.__data[11] = 0) : (L.toArray(R.__data, A), A += H.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          r.bufferSubData(r.UNIFORM_BUFFER, O, R.__data);
        }
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function f(_, x, b, T) {
    const E = _.value, M = x + "_" + b;
    if (T[M] === void 0)
      return typeof E == "number" || typeof E == "boolean" ? T[M] = E : T[M] = E.clone(), !0;
    {
      const C = T[M];
      if (typeof E == "number" || typeof E == "boolean") {
        if (C !== E)
          return T[M] = E, !0;
      } else if (C.equals(E) === !1)
        return C.copy(E), !0;
    }
    return !1;
  }
  function m(_) {
    const x = _.uniforms;
    let b = 0;
    const T = 16;
    for (let M = 0, C = x.length; M < C; M++) {
      const S = Array.isArray(x[M]) ? x[M] : [x[M]];
      for (let w = 0, R = S.length; w < R; w++) {
        const O = S[w], P = Array.isArray(O.value) ? O.value : [O.value];
        for (let A = 0, D = P.length; A < D; A++) {
          const L = P[A], H = y(L), V = b % T, X = V % H.boundary, F = V + X;
          b += X, F !== 0 && T - F < H.storage && (b += T - F), O.__data = new Float32Array(H.storage / Float32Array.BYTES_PER_ELEMENT), O.__offset = b, b += H.storage;
        }
      }
    }
    const E = b % T;
    return E > 0 && (b += T - E), _.__size = b, _.__cache = {}, this;
  }
  function y(_) {
    const x = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof _ == "number" || typeof _ == "boolean" ? (x.boundary = 4, x.storage = 4) : _.isVector2 ? (x.boundary = 8, x.storage = 8) : _.isVector3 || _.isColor ? (x.boundary = 16, x.storage = 12) : _.isVector4 ? (x.boundary = 16, x.storage = 16) : _.isMatrix3 ? (x.boundary = 48, x.storage = 48) : _.isMatrix4 ? (x.boundary = 64, x.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), x;
  }
  function v(_) {
    const x = _.target;
    x.removeEventListener("dispose", v);
    const b = o.indexOf(x.__bindingPointIndex);
    o.splice(b, 1), r.deleteBuffer(s[x.id]), delete s[x.id], delete a[x.id];
  }
  function g() {
    for (const _ in s)
      r.deleteBuffer(s[_]);
    o = [], s = {}, a = {};
  }
  return {
    bind: u,
    update: c,
    dispose: g
  };
}
class Aj {
  constructor(e = {}) {
    const {
      canvas: i = gF(),
      context: n = null,
      depth: s = !0,
      stencil: a = !1,
      alpha: o = !1,
      antialias: l = !1,
      premultipliedAlpha: u = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: d = !1,
      reverseDepthBuffer: p = !1
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    if (n !== null) {
      if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      f = n.getContextAttributes().alpha;
    } else
      f = o;
    const m = new Uint32Array(4), y = new Int32Array(4);
    let v = null, g = null;
    const _ = [], x = [];
    this.domElement = i, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = sn, this.toneMapping = oo, this.toneMappingExposure = 1;
    const b = this;
    let T = !1, E = 0, M = 0, C = null, S = -1, w = null;
    const R = new Fi(), O = new Fi();
    let P = null;
    const A = new Ut(0);
    let D = 0, L = i.width, H = i.height, V = 1, X = null, F = null;
    const B = new Fi(0, 0, L, H), W = new Fi(0, 0, L, H);
    let G = !1;
    const z = new O_();
    let K = !1, ne = !1;
    const oe = new ui(), pe = new ui(), xe = new Y(), Re = new Fi(), nt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let fe = !1;
    function gt() {
      return C === null ? V : 1;
    }
    let Q = n;
    function Gt(U, q) {
      return i.getContext(U, q);
    }
    try {
      const U = {
        alpha: !0,
        depth: s,
        stencil: a,
        antialias: l,
        premultipliedAlpha: u,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: d
      };
      if ("setAttribute" in i && i.setAttribute("data-engine", `three.js r${yg}`), i.addEventListener("webglcontextlost", Ee, !1), i.addEventListener("webglcontextrestored", je, !1), i.addEventListener("webglcontextcreationerror", Ue, !1), Q === null) {
        const q = "webgl2";
        if (Q = Gt(q, U), Q === null)
          throw Gt(q) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (U) {
      throw console.error("THREE.WebGLRenderer: " + U.message), U;
    }
    let Qe, bt, Be, At, st, j, k, le, we, Ce, Te, et, ze, Xe, Pt, Ie, Ye, ut, ft, Ke, Ot, xt, jt, ee;
    function Le() {
      Qe = new Iz(Q), Qe.init(), xt = new yj(Q, Qe), bt = new Mz(Q, Qe, e, xt), Be = new fj(Q, Qe), bt.reverseDepthBuffer && p && Be.buffers.depth.setReversed(!0), At = new Lz(Q), st = new J6(), j = new gj(Q, Qe, Be, st, bt, xt, At), k = new Cz(b), le = new Pz(b), we = new VF(Q), jt = new Sz(Q, we), Ce = new Oz(Q, we, At, jt), Te = new Uz(Q, Ce, we, At), ft = new kz(Q, bt, j), Ie = new Az(st), et = new $6(b, k, le, Qe, bt, jt, Ie), ze = new Ej(b, st), Xe = new tj(), Pt = new oj(Qe), ut = new wz(b, k, le, Be, Te, f, u), Ye = new dj(b, Te, bt), ee = new Mj(Q, At, bt, Be), Ke = new Ez(Q, Qe, At), Ot = new Dz(Q, Qe, At), At.programs = et.programs, b.capabilities = bt, b.extensions = Qe, b.properties = st, b.renderLists = Xe, b.shadowMap = Ye, b.state = Be, b.info = At;
    }
    Le();
    const de = new wj(b, Q);
    this.xr = de, this.getContext = function() {
      return Q;
    }, this.getContextAttributes = function() {
      return Q.getContextAttributes();
    }, this.forceContextLoss = function() {
      const U = Qe.get("WEBGL_lose_context");
      U && U.loseContext();
    }, this.forceContextRestore = function() {
      const U = Qe.get("WEBGL_lose_context");
      U && U.restoreContext();
    }, this.getPixelRatio = function() {
      return V;
    }, this.setPixelRatio = function(U) {
      U !== void 0 && (V = U, this.setSize(L, H, !1));
    }, this.getSize = function(U) {
      return U.set(L, H);
    }, this.setSize = function(U, q, te = !0) {
      if (de.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      L = U, H = q, i.width = Math.floor(U * V), i.height = Math.floor(q * V), te === !0 && (i.style.width = U + "px", i.style.height = q + "px"), this.setViewport(0, 0, U, q);
    }, this.getDrawingBufferSize = function(U) {
      return U.set(L * V, H * V).floor();
    }, this.setDrawingBufferSize = function(U, q, te) {
      L = U, H = q, V = te, i.width = Math.floor(U * te), i.height = Math.floor(q * te), this.setViewport(0, 0, U, q);
    }, this.getCurrentViewport = function(U) {
      return U.copy(R);
    }, this.getViewport = function(U) {
      return U.copy(B);
    }, this.setViewport = function(U, q, te, ae) {
      U.isVector4 ? B.set(U.x, U.y, U.z, U.w) : B.set(U, q, te, ae), Be.viewport(R.copy(B).multiplyScalar(V).round());
    }, this.getScissor = function(U) {
      return U.copy(W);
    }, this.setScissor = function(U, q, te, ae) {
      U.isVector4 ? W.set(U.x, U.y, U.z, U.w) : W.set(U, q, te, ae), Be.scissor(O.copy(W).multiplyScalar(V).round());
    }, this.getScissorTest = function() {
      return G;
    }, this.setScissorTest = function(U) {
      Be.setScissorTest(G = U);
    }, this.setOpaqueSort = function(U) {
      X = U;
    }, this.setTransparentSort = function(U) {
      F = U;
    }, this.getClearColor = function(U) {
      return U.copy(ut.getClearColor());
    }, this.setClearColor = function() {
      ut.setClearColor.apply(ut, arguments);
    }, this.getClearAlpha = function() {
      return ut.getClearAlpha();
    }, this.setClearAlpha = function() {
      ut.setClearAlpha.apply(ut, arguments);
    }, this.clear = function(U = !0, q = !0, te = !0) {
      let ae = 0;
      if (U) {
        let $ = !1;
        if (C !== null) {
          const Me = C.texture.format;
          $ = Me === R_ || Me === C_ || Me === A_;
        }
        if ($) {
          const Me = C.texture.type, Pe = Me === ba || Me === xl || Me === ud || Me === fc || Me === E_ || Me === M_, Ze = ut.getClearColor(), it = ut.getClearAlpha(), yt = Ze.r, wt = Ze.g, ht = Ze.b;
          Pe ? (m[0] = yt, m[1] = wt, m[2] = ht, m[3] = it, Q.clearBufferuiv(Q.COLOR, 0, m)) : (y[0] = yt, y[1] = wt, y[2] = ht, y[3] = it, Q.clearBufferiv(Q.COLOR, 0, y));
        } else
          ae |= Q.COLOR_BUFFER_BIT;
      }
      q && (ae |= Q.DEPTH_BUFFER_BIT), te && (ae |= Q.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Q.clear(ae);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      i.removeEventListener("webglcontextlost", Ee, !1), i.removeEventListener("webglcontextrestored", je, !1), i.removeEventListener("webglcontextcreationerror", Ue, !1), Xe.dispose(), Pt.dispose(), st.dispose(), k.dispose(), le.dispose(), Te.dispose(), jt.dispose(), ee.dispose(), et.dispose(), de.dispose(), de.removeEventListener("sessionstart", Aa), de.removeEventListener("sessionend", Ca), Mn.stop();
    };
    function Ee(U) {
      U.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), T = !0;
    }
    function je() {
      console.log("THREE.WebGLRenderer: Context Restored."), T = !1;
      const U = At.autoReset, q = Ye.enabled, te = Ye.autoUpdate, ae = Ye.needsUpdate, $ = Ye.type;
      Le(), At.autoReset = U, Ye.enabled = q, Ye.autoUpdate = te, Ye.needsUpdate = ae, Ye.type = $;
    }
    function Ue(U) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", U.statusMessage);
    }
    function Ct(U) {
      const q = U.target;
      q.removeEventListener("dispose", Ct), ni(q);
    }
    function ni(U) {
      xi(U), st.remove(U);
    }
    function xi(U) {
      const q = st.get(U).programs;
      q !== void 0 && (q.forEach(function(te) {
        et.releaseProgram(te);
      }), U.isShaderMaterial && et.releaseShaderCache(U));
    }
    this.renderBufferDirect = function(U, q, te, ae, $, Me) {
      q === null && (q = nt);
      const Pe = $.isMesh && $.matrixWorld.determinant() < 0, Ze = at(U, q, te, ae, $);
      Be.setMaterial(ae, Pe);
      let it = te.index, yt = 1;
      if (ae.wireframe === !0) {
        if (it = Ce.getWireframeAttribute(te), it === void 0) return;
        yt = 2;
      }
      const wt = te.drawRange, ht = te.attributes.position;
      let Wt = wt.start * yt, ci = (wt.start + wt.count) * yt;
      Me !== null && (Wt = Math.max(Wt, Me.start * yt), ci = Math.min(ci, (Me.start + Me.count) * yt)), it !== null ? (Wt = Math.max(Wt, 0), ci = Math.min(ci, it.count)) : ht != null && (Wt = Math.max(Wt, 0), ci = Math.min(ci, ht.count));
      const hi = ci - Wt;
      if (hi < 0 || hi === 1 / 0) return;
      jt.setup($, ae, Ze, te, it);
      let Ni, di = Ke;
      if (it !== null && (Ni = we.get(it), di = Ot, di.setIndex(Ni)), $.isMesh)
        ae.wireframe === !0 ? (Be.setLineWidth(ae.wireframeLinewidth * gt()), di.setMode(Q.LINES)) : di.setMode(Q.TRIANGLES);
      else if ($.isLine) {
        let ot = ae.linewidth;
        ot === void 0 && (ot = 1), Be.setLineWidth(ot * gt()), $.isLineSegments ? di.setMode(Q.LINES) : $.isLineLoop ? di.setMode(Q.LINE_LOOP) : di.setMode(Q.LINE_STRIP);
      } else $.isPoints ? di.setMode(Q.POINTS) : $.isSprite && di.setMode(Q.TRIANGLES);
      if ($.isBatchedMesh)
        if ($._multiDrawInstances !== null)
          di.renderMultiDrawInstances($._multiDrawStarts, $._multiDrawCounts, $._multiDrawCount, $._multiDrawInstances);
        else if (Qe.get("WEBGL_multi_draw"))
          di.renderMultiDraw($._multiDrawStarts, $._multiDrawCounts, $._multiDrawCount);
        else {
          const ot = $._multiDrawStarts, Mo = $._multiDrawCounts, Ao = $._multiDrawCount, An = it ? we.get(it).bytesPerElement : 1, Fl = st.get(ae).currentProgram.getUniforms();
          for (let Kr = 0; Kr < Ao; Kr++)
            Fl.setValue(Q, "_gl_DrawID", Kr), di.render(ot[Kr] / An, Mo[Kr]);
        }
      else if ($.isInstancedMesh)
        di.renderInstances(Wt, hi, $.count);
      else if (te.isInstancedBufferGeometry) {
        const ot = te._maxInstanceCount !== void 0 ? te._maxInstanceCount : 1 / 0, Mo = Math.min(te.instanceCount, ot);
        di.renderInstances(Wt, hi, Mo);
      } else
        di.render(Wt, hi);
    };
    function Bt(U, q, te) {
      U.transparent === !0 && U.side === Qs && U.forceSinglePass === !1 ? (U.side = Ar, U.needsUpdate = !0, ce(U, q, te), U.side = fo, U.needsUpdate = !0, ce(U, q, te), U.side = Qs) : ce(U, q, te);
    }
    this.compile = function(U, q, te = null) {
      te === null && (te = U), g = Pt.get(te), g.init(q), x.push(g), te.traverseVisible(function($) {
        $.isLight && $.layers.test(q.layers) && (g.pushLight($), $.castShadow && g.pushShadow($));
      }), U !== te && U.traverseVisible(function($) {
        $.isLight && $.layers.test(q.layers) && (g.pushLight($), $.castShadow && g.pushShadow($));
      }), g.setupLights();
      const ae = /* @__PURE__ */ new Set();
      return U.traverse(function($) {
        if (!($.isMesh || $.isPoints || $.isLine || $.isSprite))
          return;
        const Me = $.material;
        if (Me)
          if (Array.isArray(Me))
            for (let Pe = 0; Pe < Me.length; Pe++) {
              const Ze = Me[Pe];
              Bt(Ze, te, $), ae.add(Ze);
            }
          else
            Bt(Me, te, $), ae.add(Me);
      }), x.pop(), g = null, ae;
    }, this.compileAsync = function(U, q, te = null) {
      const ae = this.compile(U, q, te);
      return new Promise(($) => {
        function Me() {
          if (ae.forEach(function(Pe) {
            st.get(Pe).currentProgram.isReady() && ae.delete(Pe);
          }), ae.size === 0) {
            $(U);
            return;
          }
          setTimeout(Me, 10);
        }
        Qe.get("KHR_parallel_shader_compile") !== null ? Me() : setTimeout(Me, 10);
      });
    };
    let vr = null;
    function Yr(U) {
      vr && vr(U);
    }
    function Aa() {
      Mn.stop();
    }
    function Ca() {
      Mn.start();
    }
    const Mn = new yR();
    Mn.setAnimationLoop(Yr), typeof self < "u" && Mn.setContext(self), this.setAnimationLoop = function(U) {
      vr = U, de.setAnimationLoop(U), U === null ? Mn.stop() : Mn.start();
    }, de.addEventListener("sessionstart", Aa), de.addEventListener("sessionend", Ca), this.render = function(U, q) {
      if (q !== void 0 && q.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (T === !0) return;
      if (U.matrixWorldAutoUpdate === !0 && U.updateMatrixWorld(), q.parent === null && q.matrixWorldAutoUpdate === !0 && q.updateMatrixWorld(), de.enabled === !0 && de.isPresenting === !0 && (de.cameraAutoUpdate === !0 && de.updateCamera(q), q = de.getCamera()), U.isScene === !0 && U.onBeforeRender(b, U, q, C), g = Pt.get(U, x.length), g.init(q), x.push(g), pe.multiplyMatrices(q.projectionMatrix, q.matrixWorldInverse), z.setFromProjectionMatrix(pe), ne = this.localClippingEnabled, K = Ie.init(this.clippingPlanes, ne), v = Xe.get(U, _.length), v.init(), _.push(v), de.enabled === !0 && de.isPresenting === !0) {
        const Me = b.xr.getDepthSensingMesh();
        Me !== null && Eo(Me, q, -1 / 0, b.sortObjects);
      }
      Eo(U, q, 0, b.sortObjects), v.finish(), b.sortObjects === !0 && v.sort(X, F), fe = de.enabled === !1 || de.isPresenting === !1 || de.hasDepthSensing() === !1, fe && ut.addToRenderList(v, U), this.info.render.frame++, K === !0 && Ie.beginShadows();
      const te = g.state.shadowsArray;
      Ye.render(te, U, q), K === !0 && Ie.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const ae = v.opaque, $ = v.transmissive;
      if (g.setupLights(), q.isArrayCamera) {
        const Me = q.cameras;
        if ($.length > 0)
          for (let Pe = 0, Ze = Me.length; Pe < Ze; Pe++) {
            const it = Me[Pe];
            Ul(ae, $, U, it);
          }
        fe && ut.render(U);
        for (let Pe = 0, Ze = Me.length; Pe < Ze; Pe++) {
          const it = Me[Pe];
          kl(v, U, it, it.viewport);
        }
      } else
        $.length > 0 && Ul(ae, $, U, q), fe && ut.render(U), kl(v, U, q);
      C !== null && (j.updateMultisampleRenderTarget(C), j.updateRenderTargetMipmap(C)), U.isScene === !0 && U.onAfterRender(b, U, q), jt.resetDefaultState(), S = -1, w = null, x.pop(), x.length > 0 ? (g = x[x.length - 1], K === !0 && Ie.setGlobalState(b.clippingPlanes, g.state.camera)) : g = null, _.pop(), _.length > 0 ? v = _[_.length - 1] : v = null;
    };
    function Eo(U, q, te, ae) {
      if (U.visible === !1) return;
      if (U.layers.test(q.layers)) {
        if (U.isGroup)
          te = U.renderOrder;
        else if (U.isLOD)
          U.autoUpdate === !0 && U.update(q);
        else if (U.isLight)
          g.pushLight(U), U.castShadow && g.pushShadow(U);
        else if (U.isSprite) {
          if (!U.frustumCulled || z.intersectsSprite(U)) {
            ae && Re.setFromMatrixPosition(U.matrixWorld).applyMatrix4(pe);
            const Me = Te.update(U), Pe = U.material;
            Pe.visible && v.push(U, Me, Pe, te, Re.z, null);
          }
        } else if ((U.isMesh || U.isLine || U.isPoints) && (!U.frustumCulled || z.intersectsObject(U))) {
          const Me = Te.update(U), Pe = U.material;
          if (ae && (U.boundingSphere !== void 0 ? (U.boundingSphere === null && U.computeBoundingSphere(), Re.copy(U.boundingSphere.center)) : (Me.boundingSphere === null && Me.computeBoundingSphere(), Re.copy(Me.boundingSphere.center)), Re.applyMatrix4(U.matrixWorld).applyMatrix4(pe)), Array.isArray(Pe)) {
            const Ze = Me.groups;
            for (let it = 0, yt = Ze.length; it < yt; it++) {
              const wt = Ze[it], ht = Pe[wt.materialIndex];
              ht && ht.visible && v.push(U, Me, ht, te, Re.z, wt);
            }
          } else Pe.visible && v.push(U, Me, Pe, te, Re.z, null);
        }
      }
      const $ = U.children;
      for (let Me = 0, Pe = $.length; Me < Pe; Me++)
        Eo($[Me], q, te, ae);
    }
    function kl(U, q, te, ae) {
      const $ = U.opaque, Me = U.transmissive, Pe = U.transparent;
      g.setupLightsView(te), K === !0 && Ie.setGlobalState(b.clippingPlanes, te), ae && Be.viewport(R.copy(ae)), $.length > 0 && N($, q, te), Me.length > 0 && N(Me, q, te), Pe.length > 0 && N(Pe, q, te), Be.buffers.depth.setTest(!0), Be.buffers.depth.setMask(!0), Be.buffers.color.setMask(!0), Be.setPolygonOffset(!1);
    }
    function Ul(U, q, te, ae) {
      if ((te.isScene === !0 ? te.overrideMaterial : null) !== null)
        return;
      g.state.transmissionRenderTarget[ae.id] === void 0 && (g.state.transmissionRenderTarget[ae.id] = new mo(1, 1, {
        generateMipmaps: !0,
        type: Qe.has("EXT_color_buffer_half_float") || Qe.has("EXT_color_buffer_float") ? Lc : ba,
        minFilter: rl,
        samples: 4,
        stencilBuffer: a,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: Ht.workingColorSpace
      }));
      const $ = g.state.transmissionRenderTarget[ae.id], Me = ae.viewport || R;
      $.setSize(Me.z, Me.w);
      const Pe = b.getRenderTarget();
      b.setRenderTarget($), b.getClearColor(A), D = b.getClearAlpha(), D < 1 && b.setClearColor(16777215, 0.5), b.clear(), fe && ut.render(te);
      const Ze = b.toneMapping;
      b.toneMapping = oo;
      const it = ae.viewport;
      if (ae.viewport !== void 0 && (ae.viewport = void 0), g.setupLightsView(ae), K === !0 && Ie.setGlobalState(b.clippingPlanes, ae), N(U, te, ae), j.updateMultisampleRenderTarget($), j.updateRenderTargetMipmap($), Qe.has("WEBGL_multisampled_render_to_texture") === !1) {
        let yt = !1;
        for (let wt = 0, ht = q.length; wt < ht; wt++) {
          const Wt = q[wt], ci = Wt.object, hi = Wt.geometry, Ni = Wt.material, di = Wt.group;
          if (Ni.side === Qs && ci.layers.test(ae.layers)) {
            const ot = Ni.side;
            Ni.side = Ar, Ni.needsUpdate = !0, J(ci, te, ae, hi, Ni, di), Ni.side = ot, Ni.needsUpdate = !0, yt = !0;
          }
        }
        yt === !0 && (j.updateMultisampleRenderTarget($), j.updateRenderTargetMipmap($));
      }
      b.setRenderTarget(Pe), b.setClearColor(A, D), it !== void 0 && (ae.viewport = it), b.toneMapping = Ze;
    }
    function N(U, q, te) {
      const ae = q.isScene === !0 ? q.overrideMaterial : null;
      for (let $ = 0, Me = U.length; $ < Me; $++) {
        const Pe = U[$], Ze = Pe.object, it = Pe.geometry, yt = ae === null ? Pe.material : ae, wt = Pe.group;
        Ze.layers.test(te.layers) && J(Ze, q, te, it, yt, wt);
      }
    }
    function J(U, q, te, ae, $, Me) {
      U.onBeforeRender(b, q, te, ae, $, Me), U.modelViewMatrix.multiplyMatrices(te.matrixWorldInverse, U.matrixWorld), U.normalMatrix.getNormalMatrix(U.modelViewMatrix), $.onBeforeRender(b, q, te, ae, U, Me), $.transparent === !0 && $.side === Qs && $.forceSinglePass === !1 ? ($.side = Ar, $.needsUpdate = !0, b.renderBufferDirect(te, q, ae, $, U, Me), $.side = fo, $.needsUpdate = !0, b.renderBufferDirect(te, q, ae, $, U, Me), $.side = Qs) : b.renderBufferDirect(te, q, ae, $, U, Me), U.onAfterRender(b, q, te, ae, $, Me);
    }
    function ce(U, q, te) {
      q.isScene !== !0 && (q = nt);
      const ae = st.get(U), $ = g.state.lights, Me = g.state.shadowsArray, Pe = $.state.version, Ze = et.getParameters(U, $.state, Me, q, te), it = et.getProgramCacheKey(Ze);
      let yt = ae.programs;
      ae.environment = U.isMeshStandardMaterial ? q.environment : null, ae.fog = q.fog, ae.envMap = (U.isMeshStandardMaterial ? le : k).get(U.envMap || ae.environment), ae.envMapRotation = ae.environment !== null && U.envMap === null ? q.environmentRotation : U.envMapRotation, yt === void 0 && (U.addEventListener("dispose", Ct), yt = /* @__PURE__ */ new Map(), ae.programs = yt);
      let wt = yt.get(it);
      if (wt !== void 0) {
        if (ae.currentProgram === wt && ae.lightsStateVersion === Pe)
          return $e(U, Ze), wt;
      } else
        Ze.uniforms = et.getUniforms(U), U.onBeforeCompile(Ze, b), wt = et.acquireProgram(Ze, it), yt.set(it, wt), ae.uniforms = Ze.uniforms;
      const ht = ae.uniforms;
      return (!U.isShaderMaterial && !U.isRawShaderMaterial || U.clipping === !0) && (ht.clippingPlanes = Ie.uniform), $e(U, Ze), ae.needsLights = He(U), ae.lightsStateVersion = Pe, ae.needsLights && (ht.ambientLightColor.value = $.state.ambient, ht.lightProbe.value = $.state.probe, ht.directionalLights.value = $.state.directional, ht.directionalLightShadows.value = $.state.directionalShadow, ht.spotLights.value = $.state.spot, ht.spotLightShadows.value = $.state.spotShadow, ht.rectAreaLights.value = $.state.rectArea, ht.ltc_1.value = $.state.rectAreaLTC1, ht.ltc_2.value = $.state.rectAreaLTC2, ht.pointLights.value = $.state.point, ht.pointLightShadows.value = $.state.pointShadow, ht.hemisphereLights.value = $.state.hemi, ht.directionalShadowMap.value = $.state.directionalShadowMap, ht.directionalShadowMatrix.value = $.state.directionalShadowMatrix, ht.spotShadowMap.value = $.state.spotShadowMap, ht.spotLightMatrix.value = $.state.spotLightMatrix, ht.spotLightMap.value = $.state.spotLightMap, ht.pointShadowMap.value = $.state.pointShadowMap, ht.pointShadowMatrix.value = $.state.pointShadowMatrix), ae.currentProgram = wt, ae.uniformsList = null, wt;
    }
    function Ne(U) {
      if (U.uniformsList === null) {
        const q = U.currentProgram.getUniforms();
        U.uniformsList = Qf.seqWithValue(q.seq, U.uniforms);
      }
      return U.uniformsList;
    }
    function $e(U, q) {
      const te = st.get(U);
      te.outputColorSpace = q.outputColorSpace, te.batching = q.batching, te.batchingColor = q.batchingColor, te.instancing = q.instancing, te.instancingColor = q.instancingColor, te.instancingMorph = q.instancingMorph, te.skinning = q.skinning, te.morphTargets = q.morphTargets, te.morphNormals = q.morphNormals, te.morphColors = q.morphColors, te.morphTargetsCount = q.morphTargetsCount, te.numClippingPlanes = q.numClippingPlanes, te.numIntersection = q.numClipIntersection, te.vertexAlphas = q.vertexAlphas, te.vertexTangents = q.vertexTangents, te.toneMapping = q.toneMapping;
    }
    function at(U, q, te, ae, $) {
      q.isScene !== !0 && (q = nt), j.resetTextureUnits();
      const Me = q.fog, Pe = ae.isMeshStandardMaterial ? q.environment : null, Ze = C === null ? b.outputColorSpace : C.isXRRenderTarget === !0 ? C.texture.colorSpace : kc, it = (ae.isMeshStandardMaterial ? le : k).get(ae.envMap || Pe), yt = ae.vertexColors === !0 && !!te.attributes.color && te.attributes.color.itemSize === 4, wt = !!te.attributes.tangent && (!!ae.normalMap || ae.anisotropy > 0), ht = !!te.morphAttributes.position, Wt = !!te.morphAttributes.normal, ci = !!te.morphAttributes.color;
      let hi = oo;
      ae.toneMapped && (C === null || C.isXRRenderTarget === !0) && (hi = b.toneMapping);
      const Ni = te.morphAttributes.position || te.morphAttributes.normal || te.morphAttributes.color, di = Ni !== void 0 ? Ni.length : 0, ot = st.get(ae), Mo = g.state.lights;
      if (K === !0 && (ne === !0 || U !== w)) {
        const Or = U === w && ae.id === S;
        Ie.setState(ae, U, Or);
      }
      let Ao = !1;
      ae.version === ot.__version ? (ot.needsLights && ot.lightsStateVersion !== Mo.state.version || ot.outputColorSpace !== Ze || $.isBatchedMesh && ot.batching === !1 || !$.isBatchedMesh && ot.batching === !0 || $.isBatchedMesh && ot.batchingColor === !0 && $.colorTexture === null || $.isBatchedMesh && ot.batchingColor === !1 && $.colorTexture !== null || $.isInstancedMesh && ot.instancing === !1 || !$.isInstancedMesh && ot.instancing === !0 || $.isSkinnedMesh && ot.skinning === !1 || !$.isSkinnedMesh && ot.skinning === !0 || $.isInstancedMesh && ot.instancingColor === !0 && $.instanceColor === null || $.isInstancedMesh && ot.instancingColor === !1 && $.instanceColor !== null || $.isInstancedMesh && ot.instancingMorph === !0 && $.morphTexture === null || $.isInstancedMesh && ot.instancingMorph === !1 && $.morphTexture !== null || ot.envMap !== it || ae.fog === !0 && ot.fog !== Me || ot.numClippingPlanes !== void 0 && (ot.numClippingPlanes !== Ie.numPlanes || ot.numIntersection !== Ie.numIntersection) || ot.vertexAlphas !== yt || ot.vertexTangents !== wt || ot.morphTargets !== ht || ot.morphNormals !== Wt || ot.morphColors !== ci || ot.toneMapping !== hi || ot.morphTargetsCount !== di) && (Ao = !0) : (Ao = !0, ot.__version = ae.version);
      let An = ot.currentProgram;
      Ao === !0 && (An = ce(ae, q, $));
      let Fl = !1, Kr = !1, qc = !1;
      const ai = An.getUniforms(), is = ot.uniforms;
      if (Be.useProgram(An.program) && (Fl = !0, Kr = !0, qc = !0), ae.id !== S && (S = ae.id, Kr = !0), Fl || w !== U) {
        Be.buffers.depth.getReversed() ? (oe.copy(U.projectionMatrix), vF(oe), bF(oe), ai.setValue(Q, "projectionMatrix", oe)) : ai.setValue(Q, "projectionMatrix", U.projectionMatrix), ai.setValue(Q, "viewMatrix", U.matrixWorldInverse);
        const Or = ai.map.cameraPosition;
        Or !== void 0 && Or.setValue(Q, xe.setFromMatrixPosition(U.matrixWorld)), bt.logarithmicDepthBuffer && ai.setValue(
          Q,
          "logDepthBufFC",
          2 / (Math.log(U.far + 1) / Math.LN2)
        ), (ae.isMeshPhongMaterial || ae.isMeshToonMaterial || ae.isMeshLambertMaterial || ae.isMeshBasicMaterial || ae.isMeshStandardMaterial || ae.isShaderMaterial) && ai.setValue(Q, "isOrthographic", U.isOrthographicCamera === !0), w !== U && (w = U, Kr = !0, qc = !0);
      }
      if ($.isSkinnedMesh) {
        ai.setOptional(Q, $, "bindMatrix"), ai.setOptional(Q, $, "bindMatrixInverse");
        const Or = $.skeleton;
        Or && (Or.boneTexture === null && Or.computeBoneTexture(), ai.setValue(Q, "boneTexture", Or.boneTexture, j));
      }
      $.isBatchedMesh && (ai.setOptional(Q, $, "batchingTexture"), ai.setValue(Q, "batchingTexture", $._matricesTexture, j), ai.setOptional(Q, $, "batchingIdTexture"), ai.setValue(Q, "batchingIdTexture", $._indirectTexture, j), ai.setOptional(Q, $, "batchingColorTexture"), $._colorsTexture !== null && ai.setValue(Q, "batchingColorTexture", $._colorsTexture, j));
      const Xc = te.morphAttributes;
      if ((Xc.position !== void 0 || Xc.normal !== void 0 || Xc.color !== void 0) && ft.update($, te, An), (Kr || ot.receiveShadow !== $.receiveShadow) && (ot.receiveShadow = $.receiveShadow, ai.setValue(Q, "receiveShadow", $.receiveShadow)), ae.isMeshGouraudMaterial && ae.envMap !== null && (is.envMap.value = it, is.flipEnvMap.value = it.isCubeTexture && it.isRenderTargetTexture === !1 ? -1 : 1), ae.isMeshStandardMaterial && ae.envMap === null && q.environment !== null && (is.envMapIntensity.value = q.environmentIntensity), Kr && (ai.setValue(Q, "toneMappingExposure", b.toneMappingExposure), ot.needsLights && qe(is, qc), Me && ae.fog === !0 && ze.refreshFogUniforms(is, Me), ze.refreshMaterialUniforms(is, ae, V, H, g.state.transmissionRenderTarget[U.id]), Qf.upload(Q, Ne(ot), is, j)), ae.isShaderMaterial && ae.uniformsNeedUpdate === !0 && (Qf.upload(Q, Ne(ot), is, j), ae.uniformsNeedUpdate = !1), ae.isSpriteMaterial && ai.setValue(Q, "center", $.center), ai.setValue(Q, "modelViewMatrix", $.modelViewMatrix), ai.setValue(Q, "normalMatrix", $.normalMatrix), ai.setValue(Q, "modelMatrix", $.matrixWorld), ae.isShaderMaterial || ae.isRawShaderMaterial) {
        const Or = ae.uniformsGroups;
        for (let Yc = 0, Ra = Or.length; Yc < Ra; Yc++) {
          const mT = Or[Yc];
          ee.update(mT, An), ee.bind(mT, An);
        }
      }
      return An;
    }
    function qe(U, q) {
      U.ambientLightColor.needsUpdate = q, U.lightProbe.needsUpdate = q, U.directionalLights.needsUpdate = q, U.directionalLightShadows.needsUpdate = q, U.pointLights.needsUpdate = q, U.pointLightShadows.needsUpdate = q, U.spotLights.needsUpdate = q, U.spotLightShadows.needsUpdate = q, U.rectAreaLights.needsUpdate = q, U.hemisphereLights.needsUpdate = q;
    }
    function He(U) {
      return U.isMeshLambertMaterial || U.isMeshToonMaterial || U.isMeshPhongMaterial || U.isMeshStandardMaterial || U.isShadowMaterial || U.isShaderMaterial && U.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return E;
    }, this.getActiveMipmapLevel = function() {
      return M;
    }, this.getRenderTarget = function() {
      return C;
    }, this.setRenderTargetTextures = function(U, q, te) {
      st.get(U.texture).__webglTexture = q, st.get(U.depthTexture).__webglTexture = te;
      const ae = st.get(U);
      ae.__hasExternalTextures = !0, ae.__autoAllocateDepthBuffer = te === void 0, ae.__autoAllocateDepthBuffer || Qe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ae.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(U, q) {
      const te = st.get(U);
      te.__webglFramebuffer = q, te.__useDefaultFramebuffer = q === void 0;
    }, this.setRenderTarget = function(U, q = 0, te = 0) {
      C = U, E = q, M = te;
      let ae = !0, $ = null, Me = !1, Pe = !1;
      if (U) {
        const Ze = st.get(U);
        if (Ze.__useDefaultFramebuffer !== void 0)
          Be.bindFramebuffer(Q.FRAMEBUFFER, null), ae = !1;
        else if (Ze.__webglFramebuffer === void 0)
          j.setupRenderTarget(U);
        else if (Ze.__hasExternalTextures)
          j.rebindTextures(U, st.get(U.texture).__webglTexture, st.get(U.depthTexture).__webglTexture);
        else if (U.depthBuffer) {
          const wt = U.depthTexture;
          if (Ze.__boundDepthTexture !== wt) {
            if (wt !== null && st.has(wt) && (U.width !== wt.image.width || U.height !== wt.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            j.setupDepthRenderbuffer(U);
          }
        }
        const it = U.texture;
        (it.isData3DTexture || it.isDataArrayTexture || it.isCompressedArrayTexture) && (Pe = !0);
        const yt = st.get(U).__webglFramebuffer;
        U.isWebGLCubeRenderTarget ? (Array.isArray(yt[q]) ? $ = yt[q][te] : $ = yt[q], Me = !0) : U.samples > 0 && j.useMultisampledRTT(U) === !1 ? $ = st.get(U).__webglMultisampledFramebuffer : Array.isArray(yt) ? $ = yt[te] : $ = yt, R.copy(U.viewport), O.copy(U.scissor), P = U.scissorTest;
      } else
        R.copy(B).multiplyScalar(V).floor(), O.copy(W).multiplyScalar(V).floor(), P = G;
      if (Be.bindFramebuffer(Q.FRAMEBUFFER, $) && ae && Be.drawBuffers(U, $), Be.viewport(R), Be.scissor(O), Be.setScissorTest(P), Me) {
        const Ze = st.get(U.texture);
        Q.framebufferTexture2D(Q.FRAMEBUFFER, Q.COLOR_ATTACHMENT0, Q.TEXTURE_CUBE_MAP_POSITIVE_X + q, Ze.__webglTexture, te);
      } else if (Pe) {
        const Ze = st.get(U.texture), it = q || 0;
        Q.framebufferTextureLayer(Q.FRAMEBUFFER, Q.COLOR_ATTACHMENT0, Ze.__webglTexture, te || 0, it);
      }
      S = -1;
    }, this.readRenderTargetPixels = function(U, q, te, ae, $, Me, Pe) {
      if (!(U && U.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Ze = st.get(U).__webglFramebuffer;
      if (U.isWebGLCubeRenderTarget && Pe !== void 0 && (Ze = Ze[Pe]), Ze) {
        Be.bindFramebuffer(Q.FRAMEBUFFER, Ze);
        try {
          const it = U.texture, yt = it.format, wt = it.type;
          if (!bt.textureFormatReadable(yt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!bt.textureTypeReadable(wt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          q >= 0 && q <= U.width - ae && te >= 0 && te <= U.height - $ && Q.readPixels(q, te, ae, $, xt.convert(yt), xt.convert(wt), Me);
        } finally {
          const it = C !== null ? st.get(C).__webglFramebuffer : null;
          Be.bindFramebuffer(Q.FRAMEBUFFER, it);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(U, q, te, ae, $, Me, Pe) {
      if (!(U && U.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Ze = st.get(U).__webglFramebuffer;
      if (U.isWebGLCubeRenderTarget && Pe !== void 0 && (Ze = Ze[Pe]), Ze) {
        const it = U.texture, yt = it.format, wt = it.type;
        if (!bt.textureFormatReadable(yt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!bt.textureTypeReadable(wt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (q >= 0 && q <= U.width - ae && te >= 0 && te <= U.height - $) {
          Be.bindFramebuffer(Q.FRAMEBUFFER, Ze);
          const ht = Q.createBuffer();
          Q.bindBuffer(Q.PIXEL_PACK_BUFFER, ht), Q.bufferData(Q.PIXEL_PACK_BUFFER, Me.byteLength, Q.STREAM_READ), Q.readPixels(q, te, ae, $, xt.convert(yt), xt.convert(wt), 0);
          const Wt = C !== null ? st.get(C).__webglFramebuffer : null;
          Be.bindFramebuffer(Q.FRAMEBUFFER, Wt);
          const ci = Q.fenceSync(Q.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return Q.flush(), await yF(Q, ci, 4), Q.bindBuffer(Q.PIXEL_PACK_BUFFER, ht), Q.getBufferSubData(Q.PIXEL_PACK_BUFFER, 0, Me), Q.deleteBuffer(ht), Q.deleteSync(ci), Me;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(U, q = null, te = 0) {
      U.isTexture !== !0 && (Uh("WebGLRenderer: copyFramebufferToTexture function signature has changed."), q = arguments[0] || null, U = arguments[1]);
      const ae = Math.pow(2, -te), $ = Math.floor(U.image.width * ae), Me = Math.floor(U.image.height * ae), Pe = q !== null ? q.x : 0, Ze = q !== null ? q.y : 0;
      j.setTexture2D(U, 0), Q.copyTexSubImage2D(Q.TEXTURE_2D, te, 0, 0, Pe, Ze, $, Me), Be.unbindTexture();
    }, this.copyTextureToTexture = function(U, q, te = null, ae = null, $ = 0) {
      U.isTexture !== !0 && (Uh("WebGLRenderer: copyTextureToTexture function signature has changed."), ae = arguments[0] || null, U = arguments[1], q = arguments[2], $ = arguments[3] || 0, te = null);
      let Me, Pe, Ze, it, yt, wt, ht, Wt, ci;
      const hi = U.isCompressedTexture ? U.mipmaps[$] : U.image;
      te !== null ? (Me = te.max.x - te.min.x, Pe = te.max.y - te.min.y, Ze = te.isBox3 ? te.max.z - te.min.z : 1, it = te.min.x, yt = te.min.y, wt = te.isBox3 ? te.min.z : 0) : (Me = hi.width, Pe = hi.height, Ze = hi.depth || 1, it = 0, yt = 0, wt = 0), ae !== null ? (ht = ae.x, Wt = ae.y, ci = ae.z) : (ht = 0, Wt = 0, ci = 0);
      const Ni = xt.convert(q.format), di = xt.convert(q.type);
      let ot;
      q.isData3DTexture ? (j.setTexture3D(q, 0), ot = Q.TEXTURE_3D) : q.isDataArrayTexture || q.isCompressedArrayTexture ? (j.setTexture2DArray(q, 0), ot = Q.TEXTURE_2D_ARRAY) : (j.setTexture2D(q, 0), ot = Q.TEXTURE_2D), Q.pixelStorei(Q.UNPACK_FLIP_Y_WEBGL, q.flipY), Q.pixelStorei(Q.UNPACK_PREMULTIPLY_ALPHA_WEBGL, q.premultiplyAlpha), Q.pixelStorei(Q.UNPACK_ALIGNMENT, q.unpackAlignment);
      const Mo = Q.getParameter(Q.UNPACK_ROW_LENGTH), Ao = Q.getParameter(Q.UNPACK_IMAGE_HEIGHT), An = Q.getParameter(Q.UNPACK_SKIP_PIXELS), Fl = Q.getParameter(Q.UNPACK_SKIP_ROWS), Kr = Q.getParameter(Q.UNPACK_SKIP_IMAGES);
      Q.pixelStorei(Q.UNPACK_ROW_LENGTH, hi.width), Q.pixelStorei(Q.UNPACK_IMAGE_HEIGHT, hi.height), Q.pixelStorei(Q.UNPACK_SKIP_PIXELS, it), Q.pixelStorei(Q.UNPACK_SKIP_ROWS, yt), Q.pixelStorei(Q.UNPACK_SKIP_IMAGES, wt);
      const qc = U.isDataArrayTexture || U.isData3DTexture, ai = q.isDataArrayTexture || q.isData3DTexture;
      if (U.isRenderTargetTexture || U.isDepthTexture) {
        const is = st.get(U), Xc = st.get(q), Or = st.get(is.__renderTarget), Yc = st.get(Xc.__renderTarget);
        Be.bindFramebuffer(Q.READ_FRAMEBUFFER, Or.__webglFramebuffer), Be.bindFramebuffer(Q.DRAW_FRAMEBUFFER, Yc.__webglFramebuffer);
        for (let Ra = 0; Ra < Ze; Ra++)
          qc && Q.framebufferTextureLayer(Q.READ_FRAMEBUFFER, Q.COLOR_ATTACHMENT0, st.get(U).__webglTexture, $, wt + Ra), U.isDepthTexture ? (ai && Q.framebufferTextureLayer(Q.DRAW_FRAMEBUFFER, Q.COLOR_ATTACHMENT0, st.get(q).__webglTexture, $, ci + Ra), Q.blitFramebuffer(it, yt, Me, Pe, ht, Wt, Me, Pe, Q.DEPTH_BUFFER_BIT, Q.NEAREST)) : ai ? Q.copyTexSubImage3D(ot, $, ht, Wt, ci + Ra, it, yt, Me, Pe) : Q.copyTexSubImage2D(ot, $, ht, Wt, ci + Ra, it, yt, Me, Pe);
        Be.bindFramebuffer(Q.READ_FRAMEBUFFER, null), Be.bindFramebuffer(Q.DRAW_FRAMEBUFFER, null);
      } else
        ai ? U.isDataTexture || U.isData3DTexture ? Q.texSubImage3D(ot, $, ht, Wt, ci, Me, Pe, Ze, Ni, di, hi.data) : q.isCompressedArrayTexture ? Q.compressedTexSubImage3D(ot, $, ht, Wt, ci, Me, Pe, Ze, Ni, hi.data) : Q.texSubImage3D(ot, $, ht, Wt, ci, Me, Pe, Ze, Ni, di, hi) : U.isDataTexture ? Q.texSubImage2D(Q.TEXTURE_2D, $, ht, Wt, Me, Pe, Ni, di, hi.data) : U.isCompressedTexture ? Q.compressedTexSubImage2D(Q.TEXTURE_2D, $, ht, Wt, hi.width, hi.height, Ni, hi.data) : Q.texSubImage2D(Q.TEXTURE_2D, $, ht, Wt, Me, Pe, Ni, di, hi);
      Q.pixelStorei(Q.UNPACK_ROW_LENGTH, Mo), Q.pixelStorei(Q.UNPACK_IMAGE_HEIGHT, Ao), Q.pixelStorei(Q.UNPACK_SKIP_PIXELS, An), Q.pixelStorei(Q.UNPACK_SKIP_ROWS, Fl), Q.pixelStorei(Q.UNPACK_SKIP_IMAGES, Kr), $ === 0 && q.generateMipmaps && Q.generateMipmap(ot), Be.unbindTexture();
    }, this.copyTextureToTexture3D = function(U, q, te = null, ae = null, $ = 0) {
      return U.isTexture !== !0 && (Uh("WebGLRenderer: copyTextureToTexture3D function signature has changed."), te = arguments[0] || null, ae = arguments[1] || null, U = arguments[2], q = arguments[3], $ = arguments[4] || 0), Uh('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(U, q, te, ae, $);
    }, this.initRenderTarget = function(U) {
      st.get(U).__webglFramebuffer === void 0 && j.setupRenderTarget(U);
    }, this.initTexture = function(U) {
      U.isCubeTexture ? j.setTextureCube(U, 0) : U.isData3DTexture ? j.setTexture3D(U, 0) : U.isDataArrayTexture || U.isCompressedArrayTexture ? j.setTexture2DArray(U, 0) : j.setTexture2D(U, 0), Be.unbindTexture();
    }, this.resetState = function() {
      E = 0, M = 0, C = null, Be.reset(), jt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return na;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const i = this.getContext();
    i.drawingBufferColorspace = Ht._getDrawingBufferColorSpace(e), i.unpackColorSpace = Ht._getUnpackColorSpace();
  }
}
let Cj = class extends Gr {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new go(), this.environmentIntensity = 1, this.environmentRotation = new go(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(r, e) {
    return super.copy(r, e), r.background !== null && (this.background = r.background.clone()), r.environment !== null && (this.environment = r.environment.clone()), r.fog !== null && (this.fog = r.fog.clone()), this.backgroundBlurriness = r.backgroundBlurriness, this.backgroundIntensity = r.backgroundIntensity, this.backgroundRotation.copy(r.backgroundRotation), this.environmentIntensity = r.environmentIntensity, this.environmentRotation.copy(r.environmentRotation), r.overrideMaterial !== null && (this.overrideMaterial = r.overrideMaterial.clone()), this.matrixAutoUpdate = r.matrixAutoUpdate, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
  }
}, Rj = class {
  constructor(r, e) {
    this.isInterleavedBuffer = !0, this.array = r, this.stride = e, this.count = r !== void 0 ? r.length / e : 0, this.usage = Pb, this.updateRanges = [], this.version = 0, this.uuid = ua();
  }
  onUploadCallback() {
  }
  set needsUpdate(r) {
    r === !0 && this.version++;
  }
  setUsage(r) {
    return this.usage = r, this;
  }
  addUpdateRange(r, e) {
    this.updateRanges.push({ start: r, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(r) {
    return this.array = new r.array.constructor(r.array), this.count = r.count, this.stride = r.stride, this.usage = r.usage, this;
  }
  copyAt(r, e, i) {
    r *= this.stride, i *= e.stride;
    for (let n = 0, s = this.stride; n < s; n++)
      this.array[r + n] = e.array[i + n];
    return this;
  }
  set(r, e = 0) {
    return this.array.set(r, e), this;
  }
  clone(r) {
    r.arrayBuffers === void 0 && (r.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ua()), r.arrayBuffers[this.array.buffer._uuid] === void 0 && (r.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(r.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(e, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(r) {
    return this.onUploadCallback = r, this;
  }
  toJSON(r) {
    return r.arrayBuffers === void 0 && (r.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ua()), r.arrayBuffers[this.array.buffer._uuid] === void 0 && (r.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
};
const br = /* @__PURE__ */ new Y();
let xS = class wR {
  constructor(e, i, n, s = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = i, this.offset = n, this.normalized = s;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.data.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.applyMatrix4(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.applyNormalMatrix(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      br.fromBufferAttribute(this, i), br.transformDirection(e), this.setXYZ(i, br.x, br.y, br.z);
    return this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.data.stride + this.offset + i];
    return this.normalized && (n = Hn(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = Jt(n, this.array)), this.data.array[e * this.data.stride + this.offset + i] = n, this;
  }
  setX(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset] = i, this;
  }
  setY(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = i, this;
  }
  setZ(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = i, this;
  }
  setW(e, i) {
    return this.normalized && (i = Jt(i, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = i, this;
  }
  getX(e) {
    let i = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  getY(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  getZ(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  getW(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (i = Hn(i, this.array)), i;
  }
  setXY(e, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Jt(i, this.array), n = Jt(n, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Jt(i, this.array), n = Jt(n, this.array), s = Jt(s, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = Jt(i, this.array), n = Jt(n, this.array), s = Jt(s, this.array), a = Jt(a, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = a, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return new _n(new this.array.constructor(i), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new wR(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: i,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}, Nj = class extends Nl {
  static get type() {
    return "SpriteMaterial";
  }
  constructor(r) {
    super(), this.isSpriteMaterial = !0, this.color = new Ut(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.alphaMap = r.alphaMap, this.rotation = r.rotation, this.sizeAttenuation = r.sizeAttenuation, this.fog = r.fog, this;
  }
}, eu;
const ah = /* @__PURE__ */ new Y(), tu = /* @__PURE__ */ new Y(), iu = /* @__PURE__ */ new Y(), ru = /* @__PURE__ */ new ke(), oh = /* @__PURE__ */ new ke(), SR = /* @__PURE__ */ new ui(), Ip = /* @__PURE__ */ new Y(), lh = /* @__PURE__ */ new Y(), Op = /* @__PURE__ */ new Y(), _S = /* @__PURE__ */ new ke(), qy = /* @__PURE__ */ new ke(), TS = /* @__PURE__ */ new ke();
class Pj extends Gr {
  constructor(e = new Nj()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", eu === void 0) {
      eu = new cn();
      const i = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new Rj(i, 5);
      eu.setIndex([0, 1, 2, 0, 2, 3]), eu.setAttribute("position", new xS(n, 3, 0, !1)), eu.setAttribute("uv", new xS(n, 2, 3, !1));
    }
    this.geometry = eu, this.material = e, this.center = new ke(0.5, 0.5);
  }
  raycast(e, i) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), tu.setFromMatrixScale(this.matrixWorld), SR.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), iu.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && tu.multiplyScalar(-iu.z);
    const n = this.material.rotation;
    let s, a;
    n !== 0 && (a = Math.cos(n), s = Math.sin(n));
    const o = this.center;
    Dp(Ip.set(-0.5, -0.5, 0), iu, o, tu, s, a), Dp(lh.set(0.5, -0.5, 0), iu, o, tu, s, a), Dp(Op.set(0.5, 0.5, 0), iu, o, tu, s, a), _S.set(0, 0), qy.set(1, 0), TS.set(1, 1);
    let l = e.ray.intersectTriangle(Ip, lh, Op, !1, ah);
    if (l === null && (Dp(lh.set(-0.5, 0.5, 0), iu, o, tu, s, a), qy.set(0, 1), l = e.ray.intersectTriangle(Ip, Op, lh, !1, ah), l === null))
      return;
    const u = e.ray.origin.distanceTo(ah);
    u < e.near || u > e.far || i.push({
      distance: u,
      point: ah.clone(),
      uv: Au.getInterpolation(ah, Ip, lh, Op, _S, qy, TS, new ke()),
      face: null,
      object: this
    });
  }
  copy(e, i) {
    return super.copy(e, i), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Dp(r, e, i, n, s, a) {
  ru.subVectors(r, i).addScalar(0.5).multiply(n), s !== void 0 ? (oh.x = a * ru.x - s * ru.y, oh.y = s * ru.x + a * ru.y) : oh.copy(ru), r.copy(e), r.x += oh.x, r.y += oh.y, r.applyMatrix4(SR);
}
let ER = class extends Nl {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(r) {
    super(), this.isLineBasicMaterial = !0, this.color = new Ut(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.linewidth = r.linewidth, this.linecap = r.linecap, this.linejoin = r.linejoin, this.fog = r.fog, this;
  }
};
const xm = /* @__PURE__ */ new Y(), _m = /* @__PURE__ */ new Y(), wS = /* @__PURE__ */ new ui(), uh = /* @__PURE__ */ new _g(), Lp = /* @__PURE__ */ new xg(), Xy = /* @__PURE__ */ new Y(), SS = /* @__PURE__ */ new Y();
class Ij extends Gr {
  constructor(e = new cn(), i = new ER()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = i, this.updateMorphTargets();
  }
  copy(e, i) {
    return super.copy(e, i), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const i = e.attributes.position, n = [0];
      for (let s = 1, a = i.count; s < a; s++)
        xm.fromBufferAttribute(i, s - 1), _m.fromBufferAttribute(i, s), n[s] = n[s - 1], n[s] += xm.distanceTo(_m);
      e.setAttribute("lineDistance", new Ci(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, i) {
    const n = this.geometry, s = this.matrixWorld, a = e.params.Line.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Lp.copy(n.boundingSphere), Lp.applyMatrix4(s), Lp.radius += a, e.ray.intersectsSphere(Lp) === !1) return;
    wS.copy(s).invert(), uh.copy(e.ray).applyMatrix4(wS);
    const l = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), u = l * l, c = this.isLineSegments ? 2 : 1, h = n.index, d = n.attributes.position;
    if (h !== null) {
      const p = Math.max(0, o.start), f = Math.min(h.count, o.start + o.count);
      for (let m = p, y = f - 1; m < y; m += c) {
        const v = h.getX(m), g = h.getX(m + 1), _ = kp(this, e, uh, u, v, g);
        _ && i.push(_);
      }
      if (this.isLineLoop) {
        const m = h.getX(f - 1), y = h.getX(p), v = kp(this, e, uh, u, m, y);
        v && i.push(v);
      }
    } else {
      const p = Math.max(0, o.start), f = Math.min(d.count, o.start + o.count);
      for (let m = p, y = f - 1; m < y; m += c) {
        const v = kp(this, e, uh, u, m, m + 1);
        v && i.push(v);
      }
      if (this.isLineLoop) {
        const m = kp(this, e, uh, u, f - 1, p);
        m && i.push(m);
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, i = Object.keys(e);
    if (i.length > 0) {
      const n = e[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
        }
      }
    }
  }
}
function kp(r, e, i, n, s, a) {
  const o = r.geometry.attributes.position;
  if (xm.fromBufferAttribute(o, s), _m.fromBufferAttribute(o, a), i.distanceSqToSegment(xm, _m, Xy, SS) > n) return;
  Xy.applyMatrix4(r.matrixWorld);
  const l = e.ray.origin.distanceTo(Xy);
  if (!(l < e.near || l > e.far))
    return {
      distance: l,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: SS.clone().applyMatrix4(r.matrixWorld),
      index: s,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: r
    };
}
class wa {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, i) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, i);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const i = [];
    for (let n = 0; n <= e; n++)
      i.push(this.getPoint(n / e));
    return i;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const i = [];
    for (let n = 0; n <= e; n++)
      i.push(this.getPointAt(n / e));
    return i;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const i = [];
    let n, s = this.getPoint(0), a = 0;
    i.push(0);
    for (let o = 1; o <= e; o++)
      n = this.getPoint(o / e), a += n.distanceTo(s), i.push(a), s = n;
    return this.cacheArcLengths = i, i;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, i) {
    const n = this.getLengths();
    let s = 0;
    const a = n.length;
    let o;
    i ? o = i : o = e * n[a - 1];
    let l = 0, u = a - 1, c;
    for (; l <= u; )
      if (s = Math.floor(l + (u - l) / 2), c = n[s] - o, c < 0)
        l = s + 1;
      else if (c > 0)
        u = s - 1;
      else {
        u = s;
        break;
      }
    if (s = u, n[s] === o)
      return s / (a - 1);
    const h = n[s], d = n[s + 1] - h, p = (o - h) / d;
    return (s + p) / (a - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, i) {
    let n = e - 1e-4, s = e + 1e-4;
    n < 0 && (n = 0), s > 1 && (s = 1);
    const a = this.getPoint(n), o = this.getPoint(s), l = i || (a.isVector2 ? new ke() : new Y());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(e, i) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, i);
  }
  computeFrenetFrames(e, i) {
    const n = new Y(), s = [], a = [], o = [], l = new Y(), u = new ui();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      s[f] = this.getTangentAt(m, new Y());
    }
    a[0] = new Y(), o[0] = new Y();
    let c = Number.MAX_VALUE;
    const h = Math.abs(s[0].x), d = Math.abs(s[0].y), p = Math.abs(s[0].z);
    h <= c && (c = h, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), p <= c && n.set(0, 0, 1), l.crossVectors(s[0], n).normalize(), a[0].crossVectors(s[0], l), o[0].crossVectors(s[0], a[0]);
    for (let f = 1; f <= e; f++) {
      if (a[f] = a[f - 1].clone(), o[f] = o[f - 1].clone(), l.crossVectors(s[f - 1], s[f]), l.length() > Number.EPSILON) {
        l.normalize();
        const m = Math.acos(Zi(s[f - 1].dot(s[f]), -1, 1));
        a[f].applyMatrix4(u.makeRotationAxis(l, m));
      }
      o[f].crossVectors(s[f], a[f]);
    }
    if (i === !0) {
      let f = Math.acos(Zi(a[0].dot(a[e]), -1, 1));
      f /= e, s[0].dot(l.crossVectors(a[0], a[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++)
        a[m].applyMatrix4(u.makeRotationAxis(s[m], f * m)), o[m].crossVectors(s[m], a[m]);
    }
    return {
      tangents: s,
      normals: a,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class MR extends wa {
  constructor(e = 0, i = 0, n = 1, s = 1, a = 0, o = Math.PI * 2, l = !1, u = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = i, this.xRadius = n, this.yRadius = s, this.aStartAngle = a, this.aEndAngle = o, this.aClockwise = l, this.aRotation = u;
  }
  getPoint(e, i = new ke()) {
    const n = i, s = Math.PI * 2;
    let a = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(a) < Number.EPSILON;
    for (; a < 0; ) a += s;
    for (; a > s; ) a -= s;
    a < Number.EPSILON && (o ? a = 0 : a = s), this.aClockwise === !0 && !o && (a === s ? a = -s : a = a - s);
    const l = this.aStartAngle + e * a;
    let u = this.aX + this.xRadius * Math.cos(l), c = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = u - this.aX, f = c - this.aY;
      u = p * h - f * d + this.aX, c = p * d + f * h + this.aY;
    }
    return n.set(u, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class Oj extends MR {
  constructor(e, i, n, s, a, o) {
    super(e, i, n, n, s, a, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function k_() {
  let r = 0, e = 0, i = 0, n = 0;
  function s(a, o, l, u) {
    r = a, e = l, i = -3 * a + 3 * o - 2 * l - u, n = 2 * a - 2 * o + l + u;
  }
  return {
    initCatmullRom: function(a, o, l, u, c) {
      s(o, l, c * (l - a), c * (u - o));
    },
    initNonuniformCatmullRom: function(a, o, l, u, c, h, d) {
      let p = (o - a) / c - (l - a) / (c + h) + (l - o) / h, f = (l - o) / h - (u - o) / (h + d) + (u - l) / d;
      p *= h, f *= h, s(o, l, p, f);
    },
    calc: function(a) {
      const o = a * a, l = o * a;
      return r + e * a + i * o + n * l;
    }
  };
}
const Up = /* @__PURE__ */ new Y(), Yy = /* @__PURE__ */ new k_(), Ky = /* @__PURE__ */ new k_(), Zy = /* @__PURE__ */ new k_();
class Dj extends wa {
  constructor(e = [], i = !1, n = "centripetal", s = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = i, this.curveType = n, this.tension = s;
  }
  getPoint(e, i = new Y()) {
    const n = i, s = this.points, a = s.length, o = (a - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(o), u = o - l;
    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / a) + 1) * a : u === 0 && l === a - 1 && (l = a - 2, u = 1);
    let c, h;
    this.closed || l > 0 ? c = s[(l - 1) % a] : (Up.subVectors(s[0], s[1]).add(s[0]), c = Up);
    const d = s[l % a], p = s[(l + 1) % a];
    if (this.closed || l + 2 < a ? h = s[(l + 2) % a] : (Up.subVectors(s[a - 1], s[a - 2]).add(s[a - 1]), h = Up), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(c.distanceToSquared(d), f), y = Math.pow(d.distanceToSquared(p), f), v = Math.pow(p.distanceToSquared(h), f);
      y < 1e-4 && (y = 1), m < 1e-4 && (m = y), v < 1e-4 && (v = y), Yy.initNonuniformCatmullRom(c.x, d.x, p.x, h.x, m, y, v), Ky.initNonuniformCatmullRom(c.y, d.y, p.y, h.y, m, y, v), Zy.initNonuniformCatmullRom(c.z, d.z, p.z, h.z, m, y, v);
    } else this.curveType === "catmullrom" && (Yy.initCatmullRom(c.x, d.x, p.x, h.x, this.tension), Ky.initCatmullRom(c.y, d.y, p.y, h.y, this.tension), Zy.initCatmullRom(c.z, d.z, p.z, h.z, this.tension));
    return n.set(
      Yy.calc(u),
      Ky.calc(u),
      Zy.calc(u)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(s.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let i = 0, n = this.points.length; i < n; i++) {
      const s = this.points[i];
      e.points.push(s.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(new Y().fromArray(s));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function ES(r, e, i, n, s) {
  const a = (n - e) * 0.5, o = (s - i) * 0.5, l = r * r, u = r * l;
  return (2 * i - 2 * n + a + o) * u + (-3 * i + 3 * n - 2 * a - o) * l + a * r + i;
}
function Lj(r, e) {
  const i = 1 - r;
  return i * i * e;
}
function kj(r, e) {
  return 2 * (1 - r) * r * e;
}
function Uj(r, e) {
  return r * r * e;
}
function Kh(r, e, i, n) {
  return Lj(r, e) + kj(r, i) + Uj(r, n);
}
function Fj(r, e) {
  const i = 1 - r;
  return i * i * i * e;
}
function Bj(r, e) {
  const i = 1 - r;
  return 3 * i * i * r * e;
}
function zj(r, e) {
  return 3 * (1 - r) * r * r * e;
}
function jj(r, e) {
  return r * r * r * e;
}
function Zh(r, e, i, n, s) {
  return Fj(r, e) + Bj(r, i) + zj(r, n) + jj(r, s);
}
class Vj extends wa {
  constructor(e = new ke(), i = new ke(), n = new ke(), s = new ke()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = i, this.v2 = n, this.v3 = s;
  }
  getPoint(e, i = new ke()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2, l = this.v3;
    return n.set(
      Zh(e, s.x, a.x, o.x, l.x),
      Zh(e, s.y, a.y, o.y, l.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class AR extends wa {
  constructor(e = new Y(), i = new Y(), n = new Y(), s = new Y()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = i, this.v2 = n, this.v3 = s;
  }
  getPoint(e, i = new Y()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2, l = this.v3;
    return n.set(
      Zh(e, s.x, a.x, o.x, l.x),
      Zh(e, s.y, a.y, o.y, l.y),
      Zh(e, s.z, a.z, o.z, l.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Gj extends wa {
  constructor(e = new ke(), i = new ke()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = i;
  }
  getPoint(e, i = new ke()) {
    const n = i;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, i) {
    return this.getPoint(e, i);
  }
  getTangent(e, i = new ke()) {
    return i.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, i) {
    return this.getTangent(e, i);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Hj extends wa {
  constructor(e = new Y(), i = new Y()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = i;
  }
  getPoint(e, i = new Y()) {
    const n = i;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, i) {
    return this.getPoint(e, i);
  }
  getTangent(e, i = new Y()) {
    return i.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, i) {
    return this.getTangent(e, i);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Wj extends wa {
  constructor(e = new ke(), i = new ke(), n = new ke()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = i, this.v2 = n;
  }
  getPoint(e, i = new ke()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2;
    return n.set(
      Kh(e, s.x, a.x, o.x),
      Kh(e, s.y, a.y, o.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class U_ extends wa {
  constructor(e = new Y(), i = new Y(), n = new Y()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = i, this.v2 = n;
  }
  getPoint(e, i = new Y()) {
    const n = i, s = this.v0, a = this.v1, o = this.v2;
    return n.set(
      Kh(e, s.x, a.x, o.x),
      Kh(e, s.y, a.y, o.y),
      Kh(e, s.z, a.z, o.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class qj extends wa {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, i = new ke()) {
    const n = i, s = this.points, a = (s.length - 1) * e, o = Math.floor(a), l = a - o, u = s[o === 0 ? o : o - 1], c = s[o], h = s[o > s.length - 2 ? s.length - 1 : o + 1], d = s[o > s.length - 3 ? s.length - 1 : o + 2];
    return n.set(
      ES(l, u.x, c.x, h.x, d.x),
      ES(l, u.y, c.y, h.y, d.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let i = 0, n = this.points.length; i < n; i++) {
      const s = this.points[i];
      e.points.push(s.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let i = 0, n = e.points.length; i < n; i++) {
      const s = e.points[i];
      this.points.push(new ke().fromArray(s));
    }
    return this;
  }
}
var Xj = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: Oj,
  CatmullRomCurve3: Dj,
  CubicBezierCurve: Vj,
  CubicBezierCurve3: AR,
  EllipseCurve: MR,
  LineCurve: Gj,
  LineCurve3: Hj,
  QuadraticBezierCurve: Wj,
  QuadraticBezierCurve3: U_,
  SplineCurve: qj
});
class F_ extends cn {
  constructor(e = 1, i = 32, n = 0, s = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: i,
      thetaStart: n,
      thetaLength: s
    }, i = Math.max(3, i);
    const a = [], o = [], l = [], u = [], c = new Y(), h = new ke();
    o.push(0, 0, 0), l.push(0, 0, 1), u.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= i; d++, p += 3) {
      const f = n + d / i * s;
      c.x = e * Math.cos(f), c.y = e * Math.sin(f), o.push(c.x, c.y, c.z), l.push(0, 0, 1), h.x = (o[p] / e + 1) / 2, h.y = (o[p + 1] / e + 1) / 2, u.push(h.x, h.y);
    }
    for (let d = 1; d <= i; d++)
      a.push(d, d + 1, 0);
    this.setIndex(a), this.setAttribute("position", new Ci(o, 3)), this.setAttribute("normal", new Ci(l, 3)), this.setAttribute("uv", new Ci(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new F_(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Sg extends cn {
  constructor(e = 1, i = 1, n = 1, s = 32, a = 1, o = !1, l = 0, u = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: i,
      height: n,
      radialSegments: s,
      heightSegments: a,
      openEnded: o,
      thetaStart: l,
      thetaLength: u
    };
    const c = this;
    s = Math.floor(s), a = Math.floor(a);
    const h = [], d = [], p = [], f = [];
    let m = 0;
    const y = [], v = n / 2;
    let g = 0;
    _(), o === !1 && (e > 0 && x(!0), i > 0 && x(!1)), this.setIndex(h), this.setAttribute("position", new Ci(d, 3)), this.setAttribute("normal", new Ci(p, 3)), this.setAttribute("uv", new Ci(f, 2));
    function _() {
      const b = new Y(), T = new Y();
      let E = 0;
      const M = (i - e) / n;
      for (let C = 0; C <= a; C++) {
        const S = [], w = C / a, R = w * (i - e) + e;
        for (let O = 0; O <= s; O++) {
          const P = O / s, A = P * u + l, D = Math.sin(A), L = Math.cos(A);
          T.x = R * D, T.y = -w * n + v, T.z = R * L, d.push(T.x, T.y, T.z), b.set(D, M, L).normalize(), p.push(b.x, b.y, b.z), f.push(P, 1 - w), S.push(m++);
        }
        y.push(S);
      }
      for (let C = 0; C < s; C++)
        for (let S = 0; S < a; S++) {
          const w = y[S][C], R = y[S + 1][C], O = y[S + 1][C + 1], P = y[S][C + 1];
          (e > 0 || S !== 0) && (h.push(w, R, P), E += 3), (i > 0 || S !== a - 1) && (h.push(R, O, P), E += 3);
        }
      c.addGroup(g, E, 0), g += E;
    }
    function x(b) {
      const T = m, E = new ke(), M = new Y();
      let C = 0;
      const S = b === !0 ? e : i, w = b === !0 ? 1 : -1;
      for (let O = 1; O <= s; O++)
        d.push(0, v * w, 0), p.push(0, w, 0), f.push(0.5, 0.5), m++;
      const R = m;
      for (let O = 0; O <= s; O++) {
        const P = O / s * u + l, A = Math.cos(P), D = Math.sin(P);
        M.x = S * D, M.y = v * w, M.z = S * A, d.push(M.x, M.y, M.z), p.push(0, w, 0), E.x = A * 0.5 + 0.5, E.y = D * 0.5 * w + 0.5, f.push(E.x, E.y), m++;
      }
      for (let O = 0; O < s; O++) {
        const P = T + O, A = R + O;
        b === !0 ? h.push(A, A + 1, P) : h.push(A + 1, A, P), C += 3;
      }
      c.addGroup(g, C, b === !0 ? 1 : 2), g += C;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Sg(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class B_ extends Sg {
  constructor(e = 1, i = 1, n = 32, s = 1, a = !1, o = 0, l = Math.PI * 2) {
    super(0, e, i, n, s, a, o, l), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: i,
      radialSegments: n,
      heightSegments: s,
      openEnded: a,
      thetaStart: o,
      thetaLength: l
    };
  }
  static fromJSON(e) {
    return new B_(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
let CR = class RR extends cn {
  constructor(e = 1, i = 32, n = 16, s = 0, a = Math.PI * 2, o = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: i,
      heightSegments: n,
      phiStart: s,
      phiLength: a,
      thetaStart: o,
      thetaLength: l
    }, i = Math.max(3, Math.floor(i)), n = Math.max(2, Math.floor(n));
    const u = Math.min(o + l, Math.PI);
    let c = 0;
    const h = [], d = new Y(), p = new Y(), f = [], m = [], y = [], v = [];
    for (let g = 0; g <= n; g++) {
      const _ = [], x = g / n;
      let b = 0;
      g === 0 && o === 0 ? b = 0.5 / i : g === n && u === Math.PI && (b = -0.5 / i);
      for (let T = 0; T <= i; T++) {
        const E = T / i;
        d.x = -e * Math.cos(s + E * a) * Math.sin(o + x * l), d.y = e * Math.cos(o + x * l), d.z = e * Math.sin(s + E * a) * Math.sin(o + x * l), m.push(d.x, d.y, d.z), p.copy(d).normalize(), y.push(p.x, p.y, p.z), v.push(E + b, 1 - x), _.push(c++);
      }
      h.push(_);
    }
    for (let g = 0; g < n; g++)
      for (let _ = 0; _ < i; _++) {
        const x = h[g][_ + 1], b = h[g][_], T = h[g + 1][_], E = h[g + 1][_ + 1];
        (g !== 0 || o > 0) && f.push(x, b, E), (g !== n - 1 || u < Math.PI) && f.push(b, T, E);
      }
    this.setIndex(f), this.setAttribute("position", new Ci(m, 3)), this.setAttribute("normal", new Ci(y, 3)), this.setAttribute("uv", new Ci(v, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new RR(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
};
class z_ extends cn {
  constructor(e = new U_(new Y(-1, -1, 0), new Y(-1, 1, 0), new Y(1, 1, 0)), i = 64, n = 1, s = 8, a = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: i,
      radius: n,
      radialSegments: s,
      closed: a
    };
    const o = e.computeFrenetFrames(i, a);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const l = new Y(), u = new Y(), c = new ke();
    let h = new Y();
    const d = [], p = [], f = [], m = [];
    y(), this.setIndex(m), this.setAttribute("position", new Ci(d, 3)), this.setAttribute("normal", new Ci(p, 3)), this.setAttribute("uv", new Ci(f, 2));
    function y() {
      for (let x = 0; x < i; x++)
        v(x);
      v(a === !1 ? i : 0), _(), g();
    }
    function v(x) {
      h = e.getPointAt(x / i, h);
      const b = o.normals[x], T = o.binormals[x];
      for (let E = 0; E <= s; E++) {
        const M = E / s * Math.PI * 2, C = Math.sin(M), S = -Math.cos(M);
        u.x = S * b.x + C * T.x, u.y = S * b.y + C * T.y, u.z = S * b.z + C * T.z, u.normalize(), p.push(u.x, u.y, u.z), l.x = h.x + n * u.x, l.y = h.y + n * u.y, l.z = h.z + n * u.z, d.push(l.x, l.y, l.z);
      }
    }
    function g() {
      for (let x = 1; x <= i; x++)
        for (let b = 1; b <= s; b++) {
          const T = (s + 1) * (x - 1) + (b - 1), E = (s + 1) * x + (b - 1), M = (s + 1) * x + b, C = (s + 1) * (x - 1) + b;
          m.push(T, E, C), m.push(E, M, C);
        }
    }
    function _() {
      for (let x = 0; x <= i; x++)
        for (let b = 0; b <= s; b++)
          c.x = x / i, c.y = b / s, f.push(c.x, c.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new z_(
      new Xj[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
let Yj = class extends Nl {
  static get type() {
    return "MeshLambertMaterial";
  }
  constructor(r) {
    super(), this.isMeshLambertMaterial = !0, this.color = new Ut(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ut(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = $C, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new go(), this.combine = w_, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(r);
  }
  copy(r) {
    return super.copy(r), this.color.copy(r.color), this.map = r.map, this.lightMap = r.lightMap, this.lightMapIntensity = r.lightMapIntensity, this.aoMap = r.aoMap, this.aoMapIntensity = r.aoMapIntensity, this.emissive.copy(r.emissive), this.emissiveMap = r.emissiveMap, this.emissiveIntensity = r.emissiveIntensity, this.bumpMap = r.bumpMap, this.bumpScale = r.bumpScale, this.normalMap = r.normalMap, this.normalMapType = r.normalMapType, this.normalScale.copy(r.normalScale), this.displacementMap = r.displacementMap, this.displacementScale = r.displacementScale, this.displacementBias = r.displacementBias, this.specularMap = r.specularMap, this.alphaMap = r.alphaMap, this.envMap = r.envMap, this.envMapRotation.copy(r.envMapRotation), this.combine = r.combine, this.reflectivity = r.reflectivity, this.refractionRatio = r.refractionRatio, this.wireframe = r.wireframe, this.wireframeLinewidth = r.wireframeLinewidth, this.wireframeLinecap = r.wireframeLinecap, this.wireframeLinejoin = r.wireframeLinejoin, this.flatShading = r.flatShading, this.fog = r.fog, this;
  }
};
const MS = {
  enabled: !1,
  files: {},
  add: function(r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function(r) {
    if (this.enabled !== !1)
      return this.files[r];
  },
  remove: function(r) {
    delete this.files[r];
  },
  clear: function() {
    this.files = {};
  }
};
class Kj {
  constructor(e, i, n) {
    const s = this;
    let a = !1, o = 0, l = 0, u;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = i, this.onError = n, this.itemStart = function(h) {
      l++, a === !1 && s.onStart !== void 0 && s.onStart(h, o, l), a = !0;
    }, this.itemEnd = function(h) {
      o++, s.onProgress !== void 0 && s.onProgress(h, o, l), o === l && (a = !1, s.onLoad !== void 0 && s.onLoad());
    }, this.itemError = function(h) {
      s.onError !== void 0 && s.onError(h);
    }, this.resolveURL = function(h) {
      return u ? u(h) : h;
    }, this.setURLModifier = function(h) {
      return u = h, this;
    }, this.addHandler = function(h, d) {
      return c.push(h, d), this;
    }, this.removeHandler = function(h) {
      const d = c.indexOf(h);
      return d !== -1 && c.splice(d, 2), this;
    }, this.getHandler = function(h) {
      for (let d = 0, p = c.length; d < p; d += 2) {
        const f = c[d], m = c[d + 1];
        if (f.global && (f.lastIndex = 0), f.test(h))
          return m;
      }
      return null;
    };
  }
}
const Zj = /* @__PURE__ */ new Kj();
class j_ {
  constructor(e) {
    this.manager = e !== void 0 ? e : Zj, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, i) {
    const n = this;
    return new Promise(function(s, a) {
      n.load(e, s, i, a);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
j_.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class Qj extends j_ {
  constructor(e) {
    super(e);
  }
  load(e, i, n, s) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const a = this, o = MS.get(e);
    if (o !== void 0)
      return a.manager.itemStart(e), setTimeout(function() {
        i && i(o), a.manager.itemEnd(e);
      }, 0), o;
    const l = hd("img");
    function u() {
      h(), MS.add(e, this), i && i(this), a.manager.itemEnd(e);
    }
    function c(d) {
      h(), s && s(d), a.manager.itemError(e), a.manager.itemEnd(e);
    }
    function h() {
      l.removeEventListener("load", u, !1), l.removeEventListener("error", c, !1);
    }
    return l.addEventListener("load", u, !1), l.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), a.manager.itemStart(e), l.src = e, l;
  }
}
class $j extends j_ {
  constructor(e) {
    super(e);
  }
  load(e, i, n, s) {
    const a = new En(), o = new Qj(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(l) {
      a.image = l, a.needsUpdate = !0, i !== void 0 && i(a);
    }, n, s), a;
  }
}
let NR = class extends Gr {
  constructor(r, e = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Ut(r), this.intensity = e;
  }
  dispose() {
  }
  copy(r, e) {
    return super.copy(r, e), this.color.copy(r.color), this.intensity = r.intensity, this;
  }
  toJSON(r) {
    const e = super.toJSON(r);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (e.object.target = this.target.uuid), e;
  }
};
const Qy = /* @__PURE__ */ new ui(), AS = /* @__PURE__ */ new Y(), CS = /* @__PURE__ */ new Y();
let Jj = class {
  constructor(r) {
    this.camera = r, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ke(512, 512), this.map = null, this.mapPass = null, this.matrix = new ui(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new O_(), this._frameExtents = new ke(1, 1), this._viewportCount = 1, this._viewports = [
      new Fi(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(r) {
    const e = this.camera, i = this.matrix;
    AS.setFromMatrixPosition(r.matrixWorld), e.position.copy(AS), CS.setFromMatrixPosition(r.target.matrixWorld), e.lookAt(CS), e.updateMatrixWorld(), Qy.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Qy), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(Qy);
  }
  getViewport(r) {
    return this._viewports[r];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(r) {
    return this.camera = r.camera.clone(), this.intensity = r.intensity, this.bias = r.bias, this.radius = r.radius, this.mapSize.copy(r.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const r = {};
    return this.intensity !== 1 && (r.intensity = this.intensity), this.bias !== 0 && (r.bias = this.bias), this.normalBias !== 0 && (r.normalBias = this.normalBias), this.radius !== 1 && (r.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (r.mapSize = this.mapSize.toArray()), r.camera = this.camera.toJSON(!1).object, delete r.camera.matrix, r;
  }
}, e8 = class extends Jj {
  constructor() {
    super(new D_(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}, t8 = class extends NR {
  constructor(r, e) {
    super(r, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Gr.DEFAULT_UP), this.updateMatrix(), this.target = new Gr(), this.shadow = new e8();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(r) {
    return super.copy(r), this.target = r.target.clone(), this.shadow = r.shadow.clone(), this;
  }
}, i8 = class extends NR {
  constructor(r, e) {
    super(r, e), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
};
class PR {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = RS(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const i = RS();
      e = (i - this.oldTime) / 1e3, this.oldTime = i, this.elapsedTime += e;
    }
    return e;
  }
}
function RS() {
  return performance.now();
}
const NS = /* @__PURE__ */ new ui();
class IR {
  constructor(e, i, n = 0, s = 1 / 0) {
    this.ray = new _g(e, i), this.near = n, this.far = s, this.camera = null, this.layers = new P_(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, i) {
    this.ray.set(e, i);
  }
  setFromCamera(e, i) {
    i.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(i.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(i).sub(this.ray.origin).normalize(), this.camera = i) : i.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (i.near + i.far) / (i.near - i.far)).unproject(i), this.ray.direction.set(0, 0, -1).transformDirection(i.matrixWorld), this.camera = i) : console.error("THREE.Raycaster: Unsupported camera type: " + i.type);
  }
  setFromXRController(e) {
    return NS.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(NS), this;
  }
  intersectObject(e, i = !0, n = []) {
    return Lb(e, this, n, i), n.sort(PS), n;
  }
  intersectObjects(e, i = !0, n = []) {
    for (let s = 0, a = e.length; s < a; s++)
      Lb(e[s], this, n, i);
    return n.sort(PS), n;
  }
}
function PS(r, e) {
  return r.distance - e.distance;
}
function Lb(r, e, i, n) {
  let s = !0;
  if (r.layers.test(e.layers) && r.raycast(e, i) === !1 && (s = !1), s === !0 && n === !0) {
    const a = r.children;
    for (let o = 0, l = a.length; o < l; o++)
      Lb(a[o], e, i, !0);
  }
}
class IS {
  constructor(e = 1, i = 0, n = 0) {
    return this.radius = e, this.phi = i, this.theta = n, this;
  }
  set(e, i, n) {
    return this.radius = e, this.phi = i, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, i, n) {
    return this.radius = Math.sqrt(e * e + i * i + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Zi(i / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Eg extends Cl {
  constructor(e, i = null) {
    super(), this.object = e, this.domElement = i, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: yg
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = yg);
function OR(r, e, i) {
  var n, s = 1;
  r == null && (r = 0), e == null && (e = 0), i == null && (i = 0);
  function a() {
    var o, l = n.length, u, c = 0, h = 0, d = 0;
    for (o = 0; o < l; ++o)
      u = n[o], c += u.x || 0, h += u.y || 0, d += u.z || 0;
    for (c = (c / l - r) * s, h = (h / l - e) * s, d = (d / l - i) * s, o = 0; o < l; ++o)
      u = n[o], c && (u.x -= c), h && (u.y -= h), d && (u.z -= d);
  }
  return a.initialize = function(o) {
    n = o;
  }, a.x = function(o) {
    return arguments.length ? (r = +o, a) : r;
  }, a.y = function(o) {
    return arguments.length ? (e = +o, a) : e;
  }, a.z = function(o) {
    return arguments.length ? (i = +o, a) : i;
  }, a.strength = function(o) {
    return arguments.length ? (s = +o, a) : s;
  }, a;
}
function r8(r) {
  const e = +this._x.call(null, r);
  return DR(this.cover(e), e, r);
}
function DR(r, e, i) {
  if (isNaN(e)) return r;
  var n, s = r._root, a = { data: i }, o = r._x0, l = r._x1, u, c, h, d, p;
  if (!s) return r._root = a, r;
  for (; s.length; )
    if ((h = e >= (u = (o + l) / 2)) ? o = u : l = u, n = s, !(s = s[d = +h])) return n[d] = a, r;
  if (c = +r._x.call(null, s.data), e === c) return a.next = s, n ? n[d] = a : r._root = a, r;
  do
    n = n ? n[d] = new Array(2) : r._root = new Array(2), (h = e >= (u = (o + l) / 2)) ? o = u : l = u;
  while ((d = +h) == (p = +(c >= u)));
  return n[p] = s, n[d] = a, r;
}
function n8(r) {
  Array.isArray(r) || (r = Array.from(r));
  const e = r.length, i = new Float64Array(e);
  let n = 1 / 0, s = -1 / 0;
  for (let a = 0, o; a < e; ++a)
    isNaN(o = +this._x.call(null, r[a])) || (i[a] = o, o < n && (n = o), o > s && (s = o));
  if (n > s) return this;
  this.cover(n).cover(s);
  for (let a = 0; a < e; ++a)
    DR(this, i[a], r[a]);
  return this;
}
function s8(r) {
  if (isNaN(r = +r)) return this;
  var e = this._x0, i = this._x1;
  if (isNaN(e))
    i = (e = Math.floor(r)) + 1;
  else {
    for (var n = i - e || 1, s = this._root, a, o; e > r || r >= i; )
      switch (o = +(r < e), a = new Array(2), a[o] = s, s = a, n *= 2, o) {
        case 0:
          i = e + n;
          break;
        case 1:
          e = i - n;
          break;
      }
    this._root && this._root.length && (this._root = s);
  }
  return this._x0 = e, this._x1 = i, this;
}
function a8() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function o8(r) {
  return arguments.length ? this.cover(+r[0][0]).cover(+r[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
}
function ha(r, e, i) {
  this.node = r, this.x0 = e, this.x1 = i;
}
function l8(r, e) {
  var i, n = this._x0, s, a, o = this._x1, l = [], u = this._root, c, h;
  for (u && l.push(new ha(u, n, o)), e == null ? e = 1 / 0 : (n = r - e, o = r + e); c = l.pop(); )
    if (!(!(u = c.node) || (s = c.x0) > o || (a = c.x1) < n))
      if (u.length) {
        var d = (s + a) / 2;
        l.push(
          new ha(u[1], d, a),
          new ha(u[0], s, d)
        ), (h = +(r >= d)) && (c = l[l.length - 1], l[l.length - 1] = l[l.length - 1 - h], l[l.length - 1 - h] = c);
      } else {
        var p = Math.abs(r - +this._x.call(null, u.data));
        p < e && (e = p, n = r - p, o = r + p, i = u.data);
      }
  return i;
}
function u8(r) {
  if (isNaN(u = +this._x.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._x1, u, c, h, d, p;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((h = u >= (c = (o + l) / 2)) ? o = c : l = c, e = i, !(i = i[d = +h])) return this;
    if (!i.length) break;
    e[d + 1 & 1] && (n = e, p = d);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[d] = a : delete e[d], (i = e[0] || e[1]) && i === (e[1] || e[0]) && !i.length && (n ? n[p] = i : this._root = i), this) : (this._root = a, this);
}
function c8(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function h8() {
  return this._root;
}
function d8() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function p8(r) {
  var e = [], i, n = this._root, s, a, o;
  for (n && e.push(new ha(n, this._x0, this._x1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.x1) && n.length) {
      var l = (a + o) / 2;
      (s = n[1]) && e.push(new ha(s, l, o)), (s = n[0]) && e.push(new ha(s, a, l));
    }
  return this;
}
function f8(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new ha(this._root, this._x0, this._x1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.x1, u = (o + l) / 2;
      (a = s[0]) && e.push(new ha(a, o, u)), (a = s[1]) && e.push(new ha(a, u, l));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.x1);
  return this;
}
function m8(r) {
  return r[0];
}
function g8(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function LR(r, e) {
  var i = new V_(e ?? m8, NaN, NaN);
  return r == null ? i : i.addAll(r);
}
function V_(r, e, i) {
  this._x = r, this._x0 = e, this._x1 = i, this._root = void 0;
}
function OS(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var qr = LR.prototype = V_.prototype;
qr.copy = function() {
  var r = new V_(this._x, this._x0, this._x1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = OS(e), r;
  for (i = [{ source: e, target: r._root = new Array(2) }]; e = i.pop(); )
    for (var s = 0; s < 2; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(2) }) : e.target[s] = OS(n));
  return r;
};
qr.add = r8;
qr.addAll = n8;
qr.cover = s8;
qr.data = a8;
qr.extent = o8;
qr.find = l8;
qr.remove = u8;
qr.removeAll = c8;
qr.root = h8;
qr.size = d8;
qr.visit = p8;
qr.visitAfter = f8;
qr.x = g8;
function y8(r) {
  const e = +this._x.call(null, r), i = +this._y.call(null, r);
  return kR(this.cover(e, i), e, i, r);
}
function kR(r, e, i, n) {
  if (isNaN(e) || isNaN(i)) return r;
  var s, a = r._root, o = { data: n }, l = r._x0, u = r._y0, c = r._x1, h = r._y1, d, p, f, m, y, v, g, _;
  if (!a) return r._root = o, r;
  for (; a.length; )
    if ((y = e >= (d = (l + c) / 2)) ? l = d : c = d, (v = i >= (p = (u + h) / 2)) ? u = p : h = p, s = a, !(a = a[g = v << 1 | y])) return s[g] = o, r;
  if (f = +r._x.call(null, a.data), m = +r._y.call(null, a.data), e === f && i === m) return o.next = a, s ? s[g] = o : r._root = o, r;
  do
    s = s ? s[g] = new Array(4) : r._root = new Array(4), (y = e >= (d = (l + c) / 2)) ? l = d : c = d, (v = i >= (p = (u + h) / 2)) ? u = p : h = p;
  while ((g = v << 1 | y) === (_ = (m >= p) << 1 | f >= d));
  return s[_] = a, s[g] = o, r;
}
function v8(r) {
  var e, i, n = r.length, s, a, o = new Array(n), l = new Array(n), u = 1 / 0, c = 1 / 0, h = -1 / 0, d = -1 / 0;
  for (i = 0; i < n; ++i)
    isNaN(s = +this._x.call(null, e = r[i])) || isNaN(a = +this._y.call(null, e)) || (o[i] = s, l[i] = a, s < u && (u = s), s > h && (h = s), a < c && (c = a), a > d && (d = a));
  if (u > h || c > d) return this;
  for (this.cover(u, c).cover(h, d), i = 0; i < n; ++i)
    kR(this, o[i], l[i], r[i]);
  return this;
}
function b8(r, e) {
  if (isNaN(r = +r) || isNaN(e = +e)) return this;
  var i = this._x0, n = this._y0, s = this._x1, a = this._y1;
  if (isNaN(i))
    s = (i = Math.floor(r)) + 1, a = (n = Math.floor(e)) + 1;
  else {
    for (var o = s - i || 1, l = this._root, u, c; i > r || r >= s || n > e || e >= a; )
      switch (c = (e < n) << 1 | r < i, u = new Array(4), u[c] = l, l = u, o *= 2, c) {
        case 0:
          s = i + o, a = n + o;
          break;
        case 1:
          i = s - o, a = n + o;
          break;
        case 2:
          s = i + o, n = a - o;
          break;
        case 3:
          i = s - o, n = a - o;
          break;
      }
    this._root && this._root.length && (this._root = l);
  }
  return this._x0 = i, this._y0 = n, this._x1 = s, this._y1 = a, this;
}
function x8() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function _8(r) {
  return arguments.length ? this.cover(+r[0][0], +r[0][1]).cover(+r[1][0], +r[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function Er(r, e, i, n, s) {
  this.node = r, this.x0 = e, this.y0 = i, this.x1 = n, this.y1 = s;
}
function T8(r, e, i) {
  var n, s = this._x0, a = this._y0, o, l, u, c, h = this._x1, d = this._y1, p = [], f = this._root, m, y;
  for (f && p.push(new Er(f, s, a, h, d)), i == null ? i = 1 / 0 : (s = r - i, a = e - i, h = r + i, d = e + i, i *= i); m = p.pop(); )
    if (!(!(f = m.node) || (o = m.x0) > h || (l = m.y0) > d || (u = m.x1) < s || (c = m.y1) < a))
      if (f.length) {
        var v = (o + u) / 2, g = (l + c) / 2;
        p.push(
          new Er(f[3], v, g, u, c),
          new Er(f[2], o, g, v, c),
          new Er(f[1], v, l, u, g),
          new Er(f[0], o, l, v, g)
        ), (y = (e >= g) << 1 | r >= v) && (m = p[p.length - 1], p[p.length - 1] = p[p.length - 1 - y], p[p.length - 1 - y] = m);
      } else {
        var _ = r - +this._x.call(null, f.data), x = e - +this._y.call(null, f.data), b = _ * _ + x * x;
        if (b < i) {
          var T = Math.sqrt(i = b);
          s = r - T, a = e - T, h = r + T, d = e + T, n = f.data;
        }
      }
  return n;
}
function w8(r) {
  if (isNaN(h = +this._x.call(null, r)) || isNaN(d = +this._y.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._y0, u = this._x1, c = this._y1, h, d, p, f, m, y, v, g;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((m = h >= (p = (o + u) / 2)) ? o = p : u = p, (y = d >= (f = (l + c) / 2)) ? l = f : c = f, e = i, !(i = i[v = y << 1 | m])) return this;
    if (!i.length) break;
    (e[v + 1 & 3] || e[v + 2 & 3] || e[v + 3 & 3]) && (n = e, g = v);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[v] = a : delete e[v], (i = e[0] || e[1] || e[2] || e[3]) && i === (e[3] || e[2] || e[1] || e[0]) && !i.length && (n ? n[g] = i : this._root = i), this) : (this._root = a, this);
}
function S8(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function E8() {
  return this._root;
}
function M8() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function A8(r) {
  var e = [], i, n = this._root, s, a, o, l, u;
  for (n && e.push(new Er(n, this._x0, this._y0, this._x1, this._y1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.y0, l = i.x1, u = i.y1) && n.length) {
      var c = (a + l) / 2, h = (o + u) / 2;
      (s = n[3]) && e.push(new Er(s, c, h, l, u)), (s = n[2]) && e.push(new Er(s, a, h, c, u)), (s = n[1]) && e.push(new Er(s, c, o, l, h)), (s = n[0]) && e.push(new Er(s, a, o, c, h));
    }
  return this;
}
function C8(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new Er(this._root, this._x0, this._y0, this._x1, this._y1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.y0, u = n.x1, c = n.y1, h = (o + u) / 2, d = (l + c) / 2;
      (a = s[0]) && e.push(new Er(a, o, l, h, d)), (a = s[1]) && e.push(new Er(a, h, l, u, d)), (a = s[2]) && e.push(new Er(a, o, d, h, c)), (a = s[3]) && e.push(new Er(a, h, d, u, c));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.y0, n.x1, n.y1);
  return this;
}
function R8(r) {
  return r[0];
}
function N8(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function P8(r) {
  return r[1];
}
function I8(r) {
  return arguments.length ? (this._y = r, this) : this._y;
}
function UR(r, e, i) {
  var n = new G_(e ?? R8, i ?? P8, NaN, NaN, NaN, NaN);
  return r == null ? n : n.addAll(r);
}
function G_(r, e, i, n, s, a) {
  this._x = r, this._y = e, this._x0 = i, this._y0 = n, this._x1 = s, this._y1 = a, this._root = void 0;
}
function DS(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var Ir = UR.prototype = G_.prototype;
Ir.copy = function() {
  var r = new G_(this._x, this._y, this._x0, this._y0, this._x1, this._y1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = DS(e), r;
  for (i = [{ source: e, target: r._root = new Array(4) }]; e = i.pop(); )
    for (var s = 0; s < 4; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(4) }) : e.target[s] = DS(n));
  return r;
};
Ir.add = y8;
Ir.addAll = v8;
Ir.cover = b8;
Ir.data = x8;
Ir.extent = _8;
Ir.find = T8;
Ir.remove = w8;
Ir.removeAll = S8;
Ir.root = E8;
Ir.size = M8;
Ir.visit = A8;
Ir.visitAfter = C8;
Ir.x = N8;
Ir.y = I8;
function O8(r) {
  const e = +this._x.call(null, r), i = +this._y.call(null, r), n = +this._z.call(null, r);
  return FR(this.cover(e, i, n), e, i, n, r);
}
function FR(r, e, i, n, s) {
  if (isNaN(e) || isNaN(i) || isNaN(n)) return r;
  var a, o = r._root, l = { data: s }, u = r._x0, c = r._y0, h = r._z0, d = r._x1, p = r._y1, f = r._z1, m, y, v, g, _, x, b, T, E, M, C;
  if (!o) return r._root = l, r;
  for (; o.length; )
    if ((b = e >= (m = (u + d) / 2)) ? u = m : d = m, (T = i >= (y = (c + p) / 2)) ? c = y : p = y, (E = n >= (v = (h + f) / 2)) ? h = v : f = v, a = o, !(o = o[M = E << 2 | T << 1 | b])) return a[M] = l, r;
  if (g = +r._x.call(null, o.data), _ = +r._y.call(null, o.data), x = +r._z.call(null, o.data), e === g && i === _ && n === x) return l.next = o, a ? a[M] = l : r._root = l, r;
  do
    a = a ? a[M] = new Array(8) : r._root = new Array(8), (b = e >= (m = (u + d) / 2)) ? u = m : d = m, (T = i >= (y = (c + p) / 2)) ? c = y : p = y, (E = n >= (v = (h + f) / 2)) ? h = v : f = v;
  while ((M = E << 2 | T << 1 | b) === (C = (x >= v) << 2 | (_ >= y) << 1 | g >= m));
  return a[C] = o, a[M] = l, r;
}
function D8(r) {
  Array.isArray(r) || (r = Array.from(r));
  const e = r.length, i = new Float64Array(e), n = new Float64Array(e), s = new Float64Array(e);
  let a = 1 / 0, o = 1 / 0, l = 1 / 0, u = -1 / 0, c = -1 / 0, h = -1 / 0;
  for (let d = 0, p, f, m, y; d < e; ++d)
    isNaN(f = +this._x.call(null, p = r[d])) || isNaN(m = +this._y.call(null, p)) || isNaN(y = +this._z.call(null, p)) || (i[d] = f, n[d] = m, s[d] = y, f < a && (a = f), f > u && (u = f), m < o && (o = m), m > c && (c = m), y < l && (l = y), y > h && (h = y));
  if (a > u || o > c || l > h) return this;
  this.cover(a, o, l).cover(u, c, h);
  for (let d = 0; d < e; ++d)
    FR(this, i[d], n[d], s[d], r[d]);
  return this;
}
function L8(r, e, i) {
  if (isNaN(r = +r) || isNaN(e = +e) || isNaN(i = +i)) return this;
  var n = this._x0, s = this._y0, a = this._z0, o = this._x1, l = this._y1, u = this._z1;
  if (isNaN(n))
    o = (n = Math.floor(r)) + 1, l = (s = Math.floor(e)) + 1, u = (a = Math.floor(i)) + 1;
  else {
    for (var c = o - n || 1, h = this._root, d, p; n > r || r >= o || s > e || e >= l || a > i || i >= u; )
      switch (p = (i < a) << 2 | (e < s) << 1 | r < n, d = new Array(8), d[p] = h, h = d, c *= 2, p) {
        case 0:
          o = n + c, l = s + c, u = a + c;
          break;
        case 1:
          n = o - c, l = s + c, u = a + c;
          break;
        case 2:
          o = n + c, s = l - c, u = a + c;
          break;
        case 3:
          n = o - c, s = l - c, u = a + c;
          break;
        case 4:
          o = n + c, l = s + c, a = u - c;
          break;
        case 5:
          n = o - c, l = s + c, a = u - c;
          break;
        case 6:
          o = n + c, s = l - c, a = u - c;
          break;
        case 7:
          n = o - c, s = l - c, a = u - c;
          break;
      }
    this._root && this._root.length && (this._root = h);
  }
  return this._x0 = n, this._y0 = s, this._z0 = a, this._x1 = o, this._y1 = l, this._z1 = u, this;
}
function k8() {
  var r = [];
  return this.visit(function(e) {
    if (!e.length) do
      r.push(e.data);
    while (e = e.next);
  }), r;
}
function U8(r) {
  return arguments.length ? this.cover(+r[0][0], +r[0][1], +r[0][2]).cover(+r[1][0], +r[1][1], +r[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
}
function ii(r, e, i, n, s, a, o) {
  this.node = r, this.x0 = e, this.y0 = i, this.z0 = n, this.x1 = s, this.y1 = a, this.z1 = o;
}
function F8(r, e, i, n) {
  var s, a = this._x0, o = this._y0, l = this._z0, u, c, h, d, p, f, m = this._x1, y = this._y1, v = this._z1, g = [], _ = this._root, x, b;
  for (_ && g.push(new ii(_, a, o, l, m, y, v)), n == null ? n = 1 / 0 : (a = r - n, o = e - n, l = i - n, m = r + n, y = e + n, v = i + n, n *= n); x = g.pop(); )
    if (!(!(_ = x.node) || (u = x.x0) > m || (c = x.y0) > y || (h = x.z0) > v || (d = x.x1) < a || (p = x.y1) < o || (f = x.z1) < l))
      if (_.length) {
        var T = (u + d) / 2, E = (c + p) / 2, M = (h + f) / 2;
        g.push(
          new ii(_[7], T, E, M, d, p, f),
          new ii(_[6], u, E, M, T, p, f),
          new ii(_[5], T, c, M, d, E, f),
          new ii(_[4], u, c, M, T, E, f),
          new ii(_[3], T, E, h, d, p, M),
          new ii(_[2], u, E, h, T, p, M),
          new ii(_[1], T, c, h, d, E, M),
          new ii(_[0], u, c, h, T, E, M)
        ), (b = (i >= M) << 2 | (e >= E) << 1 | r >= T) && (x = g[g.length - 1], g[g.length - 1] = g[g.length - 1 - b], g[g.length - 1 - b] = x);
      } else {
        var C = r - +this._x.call(null, _.data), S = e - +this._y.call(null, _.data), w = i - +this._z.call(null, _.data), R = C * C + S * S + w * w;
        if (R < n) {
          var O = Math.sqrt(n = R);
          a = r - O, o = e - O, l = i - O, m = r + O, y = e + O, v = i + O, s = _.data;
        }
      }
  return s;
}
const B8 = (r, e, i, n, s, a) => Math.sqrt((r - n) ** 2 + (e - s) ** 2 + (i - a) ** 2);
function z8(r, e, i, n) {
  const s = [], a = r - n, o = e - n, l = i - n, u = r + n, c = e + n, h = i + n;
  return this.visit((d, p, f, m, y, v, g) => {
    if (!d.length)
      do {
        const _ = d.data;
        B8(r, e, i, this._x(_), this._y(_), this._z(_)) <= n && s.push(_);
      } while (d = d.next);
    return p > u || f > c || m > h || y < a || v < o || g < l;
  }), s;
}
function j8(r) {
  if (isNaN(p = +this._x.call(null, r)) || isNaN(f = +this._y.call(null, r)) || isNaN(m = +this._z.call(null, r))) return this;
  var e, i = this._root, n, s, a, o = this._x0, l = this._y0, u = this._z0, c = this._x1, h = this._y1, d = this._z1, p, f, m, y, v, g, _, x, b, T, E;
  if (!i) return this;
  if (i.length) for (; ; ) {
    if ((_ = p >= (y = (o + c) / 2)) ? o = y : c = y, (x = f >= (v = (l + h) / 2)) ? l = v : h = v, (b = m >= (g = (u + d) / 2)) ? u = g : d = g, e = i, !(i = i[T = b << 2 | x << 1 | _])) return this;
    if (!i.length) break;
    (e[T + 1 & 7] || e[T + 2 & 7] || e[T + 3 & 7] || e[T + 4 & 7] || e[T + 5 & 7] || e[T + 6 & 7] || e[T + 7 & 7]) && (n = e, E = T);
  }
  for (; i.data !== r; ) if (s = i, !(i = i.next)) return this;
  return (a = i.next) && delete i.next, s ? (a ? s.next = a : delete s.next, this) : e ? (a ? e[T] = a : delete e[T], (i = e[0] || e[1] || e[2] || e[3] || e[4] || e[5] || e[6] || e[7]) && i === (e[7] || e[6] || e[5] || e[4] || e[3] || e[2] || e[1] || e[0]) && !i.length && (n ? n[E] = i : this._root = i), this) : (this._root = a, this);
}
function V8(r) {
  for (var e = 0, i = r.length; e < i; ++e) this.remove(r[e]);
  return this;
}
function G8() {
  return this._root;
}
function H8() {
  var r = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++r;
    while (e = e.next);
  }), r;
}
function W8(r) {
  var e = [], i, n = this._root, s, a, o, l, u, c, h;
  for (n && e.push(new ii(n, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); i = e.pop(); )
    if (!r(n = i.node, a = i.x0, o = i.y0, l = i.z0, u = i.x1, c = i.y1, h = i.z1) && n.length) {
      var d = (a + u) / 2, p = (o + c) / 2, f = (l + h) / 2;
      (s = n[7]) && e.push(new ii(s, d, p, f, u, c, h)), (s = n[6]) && e.push(new ii(s, a, p, f, d, c, h)), (s = n[5]) && e.push(new ii(s, d, o, f, u, p, h)), (s = n[4]) && e.push(new ii(s, a, o, f, d, p, h)), (s = n[3]) && e.push(new ii(s, d, p, l, u, c, f)), (s = n[2]) && e.push(new ii(s, a, p, l, d, c, f)), (s = n[1]) && e.push(new ii(s, d, o, l, u, p, f)), (s = n[0]) && e.push(new ii(s, a, o, l, d, p, f));
    }
  return this;
}
function q8(r) {
  var e = [], i = [], n;
  for (this._root && e.push(new ii(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); n = e.pop(); ) {
    var s = n.node;
    if (s.length) {
      var a, o = n.x0, l = n.y0, u = n.z0, c = n.x1, h = n.y1, d = n.z1, p = (o + c) / 2, f = (l + h) / 2, m = (u + d) / 2;
      (a = s[0]) && e.push(new ii(a, o, l, u, p, f, m)), (a = s[1]) && e.push(new ii(a, p, l, u, c, f, m)), (a = s[2]) && e.push(new ii(a, o, f, u, p, h, m)), (a = s[3]) && e.push(new ii(a, p, f, u, c, h, m)), (a = s[4]) && e.push(new ii(a, o, l, m, p, f, d)), (a = s[5]) && e.push(new ii(a, p, l, m, c, f, d)), (a = s[6]) && e.push(new ii(a, o, f, m, p, h, d)), (a = s[7]) && e.push(new ii(a, p, f, m, c, h, d));
    }
    i.push(n);
  }
  for (; n = i.pop(); )
    r(n.node, n.x0, n.y0, n.z0, n.x1, n.y1, n.z1);
  return this;
}
function X8(r) {
  return r[0];
}
function Y8(r) {
  return arguments.length ? (this._x = r, this) : this._x;
}
function K8(r) {
  return r[1];
}
function Z8(r) {
  return arguments.length ? (this._y = r, this) : this._y;
}
function Q8(r) {
  return r[2];
}
function $8(r) {
  return arguments.length ? (this._z = r, this) : this._z;
}
function BR(r, e, i, n) {
  var s = new H_(e ?? X8, i ?? K8, n ?? Q8, NaN, NaN, NaN, NaN, NaN, NaN);
  return r == null ? s : s.addAll(r);
}
function H_(r, e, i, n, s, a, o, l, u) {
  this._x = r, this._y = e, this._z = i, this._x0 = n, this._y0 = s, this._z0 = a, this._x1 = o, this._y1 = l, this._z1 = u, this._root = void 0;
}
function LS(r) {
  for (var e = { data: r.data }, i = e; r = r.next; ) i = i.next = { data: r.data };
  return e;
}
var ar = BR.prototype = H_.prototype;
ar.copy = function() {
  var r = new H_(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), e = this._root, i, n;
  if (!e) return r;
  if (!e.length) return r._root = LS(e), r;
  for (i = [{ source: e, target: r._root = new Array(8) }]; e = i.pop(); )
    for (var s = 0; s < 8; ++s)
      (n = e.source[s]) && (n.length ? i.push({ source: n, target: e.target[s] = new Array(8) }) : e.target[s] = LS(n));
  return r;
};
ar.add = O8;
ar.addAll = D8;
ar.cover = L8;
ar.data = k8;
ar.extent = U8;
ar.find = F8;
ar.findAllWithinRadius = z8;
ar.remove = j8;
ar.removeAll = V8;
ar.root = G8;
ar.size = H8;
ar.visit = W8;
ar.visitAfter = q8;
ar.x = Y8;
ar.y = Z8;
ar.z = $8;
function sa(r) {
  return function() {
    return r;
  };
}
function Xs(r) {
  return (r() - 0.5) * 1e-6;
}
function J8(r) {
  return r.index;
}
function kS(r, e) {
  var i = r.get(e);
  if (!i) throw new Error("node not found: " + e);
  return i;
}
function zR(r) {
  var e = J8, i = p, n, s = sa(30), a, o, l, u, c, h, d = 1;
  r == null && (r = []);
  function p(g) {
    return 1 / Math.min(u[g.source.index], u[g.target.index]);
  }
  function f(g) {
    for (var _ = 0, x = r.length; _ < d; ++_)
      for (var b = 0, T, E, M, C = 0, S = 0, w = 0, R, O; b < x; ++b)
        T = r[b], E = T.source, M = T.target, C = M.x + M.vx - E.x - E.vx || Xs(h), l > 1 && (S = M.y + M.vy - E.y - E.vy || Xs(h)), l > 2 && (w = M.z + M.vz - E.z - E.vz || Xs(h)), R = Math.sqrt(C * C + S * S + w * w), R = (R - a[b]) / R * g * n[b], C *= R, S *= R, w *= R, M.vx -= C * (O = c[b]), l > 1 && (M.vy -= S * O), l > 2 && (M.vz -= w * O), E.vx += C * (O = 1 - O), l > 1 && (E.vy += S * O), l > 2 && (E.vz += w * O);
  }
  function m() {
    if (o) {
      var g, _ = o.length, x = r.length, b = new Map(o.map((E, M) => [e(E, M, o), E])), T;
      for (g = 0, u = new Array(_); g < x; ++g)
        T = r[g], T.index = g, typeof T.source != "object" && (T.source = kS(b, T.source)), typeof T.target != "object" && (T.target = kS(b, T.target)), u[T.source.index] = (u[T.source.index] || 0) + 1, u[T.target.index] = (u[T.target.index] || 0) + 1;
      for (g = 0, c = new Array(x); g < x; ++g)
        T = r[g], c[g] = u[T.source.index] / (u[T.source.index] + u[T.target.index]);
      n = new Array(x), y(), a = new Array(x), v();
    }
  }
  function y() {
    if (o)
      for (var g = 0, _ = r.length; g < _; ++g)
        n[g] = +i(r[g], g, r);
  }
  function v() {
    if (o)
      for (var g = 0, _ = r.length; g < _; ++g)
        a[g] = +s(r[g], g, r);
  }
  return f.initialize = function(g, ..._) {
    o = g, h = _.find((x) => typeof x == "function") || Math.random, l = _.find((x) => [1, 2, 3].includes(x)) || 2, m();
  }, f.links = function(g) {
    return arguments.length ? (r = g, m(), f) : r;
  }, f.id = function(g) {
    return arguments.length ? (e = g, f) : e;
  }, f.iterations = function(g) {
    return arguments.length ? (d = +g, f) : d;
  }, f.strength = function(g) {
    return arguments.length ? (i = typeof g == "function" ? g : sa(+g), y(), f) : i;
  }, f.distance = function(g) {
    return arguments.length ? (s = typeof g == "function" ? g : sa(+g), v(), f) : s;
  }, f;
}
var eV = { value: () => {
} };
function Hd() {
  for (var r = 0, e = arguments.length, i = {}, n; r < e; ++r) {
    if (!(n = arguments[r] + "") || n in i || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    i[n] = [];
  }
  return new $f(i);
}
function $f(r) {
  this._ = r;
}
function tV(r, e) {
  return r.trim().split(/^|\s+/).map(function(i) {
    var n = "", s = i.indexOf(".");
    if (s >= 0 && (n = i.slice(s + 1), i = i.slice(0, s)), i && !e.hasOwnProperty(i)) throw new Error("unknown type: " + i);
    return { type: i, name: n };
  });
}
$f.prototype = Hd.prototype = {
  constructor: $f,
  on: function(r, e) {
    var i = this._, n = tV(r + "", i), s, a = -1, o = n.length;
    if (arguments.length < 2) {
      for (; ++a < o; ) if ((s = (r = n[a]).type) && (s = iV(i[s], r.name))) return s;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++a < o; )
      if (s = (r = n[a]).type) i[s] = US(i[s], r.name, e);
      else if (e == null) for (s in i) i[s] = US(i[s], r.name, null);
    return this;
  },
  copy: function() {
    var r = {}, e = this._;
    for (var i in e) r[i] = e[i].slice();
    return new $f(r);
  },
  call: function(r, e) {
    if ((s = arguments.length - 2) > 0) for (var i = new Array(s), n = 0, s, a; n < s; ++n) i[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    for (a = this._[r], n = 0, s = a.length; n < s; ++n) a[n].value.apply(e, i);
  },
  apply: function(r, e, i) {
    if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    for (var n = this._[r], s = 0, a = n.length; s < a; ++s) n[s].value.apply(e, i);
  }
};
function iV(r, e) {
  for (var i = 0, n = r.length, s; i < n; ++i)
    if ((s = r[i]).name === e)
      return s.value;
}
function US(r, e, i) {
  for (var n = 0, s = r.length; n < s; ++n)
    if (r[n].name === e) {
      r[n] = eV, r = r.slice(0, n).concat(r.slice(n + 1));
      break;
    }
  return i != null && r.push({ name: e, value: i }), r;
}
var yc = 0, Bh = 0, ch = 0, jR = 1e3, Tm, zh, wm = 0, _l = 0, Mg = 0, dd = typeof performance == "object" && performance.now ? performance : Date, VR = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(r) {
  setTimeout(r, 17);
};
function W_() {
  return _l || (VR(rV), _l = dd.now() + Mg);
}
function rV() {
  _l = 0;
}
function Sm() {
  this._call = this._time = this._next = null;
}
Sm.prototype = q_.prototype = {
  constructor: Sm,
  restart: function(r, e, i) {
    if (typeof r != "function") throw new TypeError("callback is not a function");
    i = (i == null ? W_() : +i) + (e == null ? 0 : +e), !this._next && zh !== this && (zh ? zh._next = this : Tm = this, zh = this), this._call = r, this._time = i, kb();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, kb());
  }
};
function q_(r, e, i) {
  var n = new Sm();
  return n.restart(r, e, i), n;
}
function nV() {
  W_(), ++yc;
  for (var r = Tm, e; r; )
    (e = _l - r._time) >= 0 && r._call.call(void 0, e), r = r._next;
  --yc;
}
function FS() {
  _l = (wm = dd.now()) + Mg, yc = Bh = 0;
  try {
    nV();
  } finally {
    yc = 0, aV(), _l = 0;
  }
}
function sV() {
  var r = dd.now(), e = r - wm;
  e > jR && (Mg -= e, wm = r);
}
function aV() {
  for (var r, e = Tm, i, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), r = e, e = e._next) : (i = e._next, e._next = null, e = r ? r._next = i : Tm = i);
  zh = r, kb(n);
}
function kb(r) {
  if (!yc) {
    Bh && (Bh = clearTimeout(Bh));
    var e = r - _l;
    e > 24 ? (r < 1 / 0 && (Bh = setTimeout(FS, r - dd.now() - Mg)), ch && (ch = clearInterval(ch))) : (ch || (wm = dd.now(), ch = setInterval(sV, jR)), yc = 1, VR(FS));
  }
}
function BS(r, e, i) {
  var n = new Sm();
  return e = e == null ? 0 : +e, n.restart((s) => {
    n.stop(), r(s + e);
  }, e, i), n;
}
const oV = 1664525, lV = 1013904223, zS = 4294967296;
function uV() {
  let r = 1;
  return () => (r = (oV * r + lV) % zS) / zS;
}
var jS = 3;
function $y(r) {
  return r.x;
}
function VS(r) {
  return r.y;
}
function cV(r) {
  return r.z;
}
var hV = 10, dV = Math.PI * (3 - Math.sqrt(5)), pV = Math.PI * 20 / (9 + Math.sqrt(221));
function GR(r, e) {
  e = e || 2;
  var i = Math.min(jS, Math.max(1, Math.round(e))), n, s = 1, a = 1e-3, o = 1 - Math.pow(a, 1 / 300), l = 0, u = 0.6, c = /* @__PURE__ */ new Map(), h = q_(f), d = Hd("tick", "end"), p = uV();
  r == null && (r = []);
  function f() {
    m(), d.call("tick", n), s < a && (h.stop(), d.call("end", n));
  }
  function m(g) {
    var _, x = r.length, b;
    g === void 0 && (g = 1);
    for (var T = 0; T < g; ++T)
      for (s += (l - s) * o, c.forEach(function(E) {
        E(s);
      }), _ = 0; _ < x; ++_)
        b = r[_], b.fx == null ? b.x += b.vx *= u : (b.x = b.fx, b.vx = 0), i > 1 && (b.fy == null ? b.y += b.vy *= u : (b.y = b.fy, b.vy = 0)), i > 2 && (b.fz == null ? b.z += b.vz *= u : (b.z = b.fz, b.vz = 0));
    return n;
  }
  function y() {
    for (var g = 0, _ = r.length, x; g < _; ++g) {
      if (x = r[g], x.index = g, x.fx != null && (x.x = x.fx), x.fy != null && (x.y = x.fy), x.fz != null && (x.z = x.fz), isNaN(x.x) || i > 1 && isNaN(x.y) || i > 2 && isNaN(x.z)) {
        var b = hV * (i > 2 ? Math.cbrt(0.5 + g) : i > 1 ? Math.sqrt(0.5 + g) : g), T = g * dV, E = g * pV;
        i === 1 ? x.x = b : i === 2 ? (x.x = b * Math.cos(T), x.y = b * Math.sin(T)) : (x.x = b * Math.sin(T) * Math.cos(E), x.y = b * Math.cos(T), x.z = b * Math.sin(T) * Math.sin(E));
      }
      (isNaN(x.vx) || i > 1 && isNaN(x.vy) || i > 2 && isNaN(x.vz)) && (x.vx = 0, i > 1 && (x.vy = 0), i > 2 && (x.vz = 0));
    }
  }
  function v(g) {
    return g.initialize && g.initialize(r, p, i), g;
  }
  return y(), n = {
    tick: m,
    restart: function() {
      return h.restart(f), n;
    },
    stop: function() {
      return h.stop(), n;
    },
    numDimensions: function(g) {
      return arguments.length ? (i = Math.min(jS, Math.max(1, Math.round(g))), c.forEach(v), n) : i;
    },
    nodes: function(g) {
      return arguments.length ? (r = g, y(), c.forEach(v), n) : r;
    },
    alpha: function(g) {
      return arguments.length ? (s = +g, n) : s;
    },
    alphaMin: function(g) {
      return arguments.length ? (a = +g, n) : a;
    },
    alphaDecay: function(g) {
      return arguments.length ? (o = +g, n) : +o;
    },
    alphaTarget: function(g) {
      return arguments.length ? (l = +g, n) : l;
    },
    velocityDecay: function(g) {
      return arguments.length ? (u = 1 - g, n) : 1 - u;
    },
    randomSource: function(g) {
      return arguments.length ? (p = g, c.forEach(v), n) : p;
    },
    force: function(g, _) {
      return arguments.length > 1 ? (_ == null ? c.delete(g) : c.set(g, v(_)), n) : c.get(g);
    },
    find: function() {
      var g = Array.prototype.slice.call(arguments), _ = g.shift() || 0, x = (i > 1 ? g.shift() : null) || 0, b = (i > 2 ? g.shift() : null) || 0, T = g.shift() || 1 / 0, E = 0, M = r.length, C, S, w, R, O, P;
      for (T *= T, E = 0; E < M; ++E)
        O = r[E], C = _ - O.x, S = x - (O.y || 0), w = b - (O.z || 0), R = C * C + S * S + w * w, R < T && (P = O, T = R);
      return P;
    },
    on: function(g, _) {
      return arguments.length > 1 ? (d.on(g, _), n) : d.on(g);
    }
  };
}
function HR() {
  var r, e, i, n, s, a = sa(-30), o, l = 1, u = 1 / 0, c = 0.81;
  function h(m) {
    var y, v = r.length, g = (e === 1 ? LR(r, $y) : e === 2 ? UR(r, $y, VS) : e === 3 ? BR(r, $y, VS, cV) : null).visitAfter(p);
    for (s = m, y = 0; y < v; ++y) i = r[y], g.visit(f);
  }
  function d() {
    if (r) {
      var m, y = r.length, v;
      for (o = new Array(y), m = 0; m < y; ++m) v = r[m], o[v.index] = +a(v, m, r);
    }
  }
  function p(m) {
    var y = 0, v, g, _ = 0, x, b, T, E, M = m.length;
    if (M) {
      for (x = b = T = E = 0; E < M; ++E)
        (v = m[E]) && (g = Math.abs(v.value)) && (y += v.value, _ += g, x += g * (v.x || 0), b += g * (v.y || 0), T += g * (v.z || 0));
      y *= Math.sqrt(4 / M), m.x = x / _, e > 1 && (m.y = b / _), e > 2 && (m.z = T / _);
    } else {
      v = m, v.x = v.data.x, e > 1 && (v.y = v.data.y), e > 2 && (v.z = v.data.z);
      do
        y += o[v.data.index];
      while (v = v.next);
    }
    m.value = y;
  }
  function f(m, y, v, g, _) {
    if (!m.value) return !0;
    var x = [v, g, _][e - 1], b = m.x - i.x, T = e > 1 ? m.y - i.y : 0, E = e > 2 ? m.z - i.z : 0, M = x - y, C = b * b + T * T + E * E;
    if (M * M / c < C)
      return C < u && (b === 0 && (b = Xs(n), C += b * b), e > 1 && T === 0 && (T = Xs(n), C += T * T), e > 2 && E === 0 && (E = Xs(n), C += E * E), C < l && (C = Math.sqrt(l * C)), i.vx += b * m.value * s / C, e > 1 && (i.vy += T * m.value * s / C), e > 2 && (i.vz += E * m.value * s / C)), !0;
    if (!(m.length || C >= u)) {
      (m.data !== i || m.next) && (b === 0 && (b = Xs(n), C += b * b), e > 1 && T === 0 && (T = Xs(n), C += T * T), e > 2 && E === 0 && (E = Xs(n), C += E * E), C < l && (C = Math.sqrt(l * C)));
      do
        m.data !== i && (M = o[m.data.index] * s / C, i.vx += b * M, e > 1 && (i.vy += T * M), e > 2 && (i.vz += E * M));
      while (m = m.next);
    }
  }
  return h.initialize = function(m, ...y) {
    r = m, n = y.find((v) => typeof v == "function") || Math.random, e = y.find((v) => [1, 2, 3].includes(v)) || 2, d();
  }, h.strength = function(m) {
    return arguments.length ? (a = typeof m == "function" ? m : sa(+m), d(), h) : a;
  }, h.distanceMin = function(m) {
    return arguments.length ? (l = m * m, h) : Math.sqrt(l);
  }, h.distanceMax = function(m) {
    return arguments.length ? (u = m * m, h) : Math.sqrt(u);
  }, h.theta = function(m) {
    return arguments.length ? (c = m * m, h) : Math.sqrt(c);
  }, h;
}
function WR(r, e, i, n) {
  var s, a, o = sa(0.1), l, u;
  typeof r != "function" && (r = sa(+r)), e == null && (e = 0), i == null && (i = 0), n == null && (n = 0);
  function c(d) {
    for (var p = 0, f = s.length; p < f; ++p) {
      var m = s[p], y = m.x - e || 1e-6, v = (m.y || 0) - i || 1e-6, g = (m.z || 0) - n || 1e-6, _ = Math.sqrt(y * y + v * v + g * g), x = (u[p] - _) * l[p] * d / _;
      m.vx += y * x, a > 1 && (m.vy += v * x), a > 2 && (m.vz += g * x);
    }
  }
  function h() {
    if (s) {
      var d, p = s.length;
      for (l = new Array(p), u = new Array(p), d = 0; d < p; ++d)
        u[d] = +r(s[d], d, s), l[d] = isNaN(u[d]) ? 0 : +o(s[d], d, s);
    }
  }
  return c.initialize = function(d, ...p) {
    s = d, a = p.find((f) => [1, 2, 3].includes(f)) || 2, h();
  }, c.strength = function(d) {
    return arguments.length ? (o = typeof d == "function" ? d : sa(+d), h(), c) : o;
  }, c.radius = function(d) {
    return arguments.length ? (r = typeof d == "function" ? d : sa(+d), h(), c) : r;
  }, c.x = function(d) {
    return arguments.length ? (e = +d, c) : e;
  }, c.y = function(d) {
    return arguments.length ? (i = +d, c) : i;
  }, c.z = function(d) {
    return arguments.length ? (n = +d, c) : n;
  }, c;
}
var X_ = function(r) {
  mV(r);
  var e = fV(r);
  return r.on = e.on, r.off = e.off, r.fire = e.fire, r;
};
function fV(r) {
  var e = /* @__PURE__ */ Object.create(null);
  return {
    on: function(i, n, s) {
      if (typeof n != "function")
        throw new Error("callback is expected to be a function");
      var a = e[i];
      return a || (a = e[i] = []), a.push({ callback: n, ctx: s }), r;
    },
    off: function(i, n) {
      var s = typeof i > "u";
      if (s)
        return e = /* @__PURE__ */ Object.create(null), r;
      if (e[i]) {
        var a = typeof n != "function";
        if (a)
          delete e[i];
        else
          for (var o = e[i], l = 0; l < o.length; ++l)
            o[l].callback === n && o.splice(l, 1);
      }
      return r;
    },
    fire: function(i) {
      var n = e[i];
      if (!n)
        return r;
      var s;
      arguments.length > 1 && (s = Array.prototype.splice.call(arguments, 1));
      for (var a = 0; a < n.length; ++a) {
        var o = n[a];
        o.callback.apply(o.ctx, s);
      }
      return r;
    }
  };
}
function mV(r) {
  if (!r)
    throw new Error("Eventify cannot use falsy object as events subject");
  for (var e = ["on", "fire", "off"], i = 0; i < e.length; ++i)
    if (r.hasOwnProperty(e[i]))
      throw new Error("Subject cannot be eventified, since it already has property '" + e[i] + "'");
}
var gV = vV, yV = X_;
function vV(r) {
  if (r = r || {}, "uniqueLinkId" in r && (console.warn(
    "ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\nUse `multigraph` option instead\n",
    `
`,
    `Note: there is also change in default behavior: From now on each graph
is considered to be not a multigraph by default (each edge is unique).`
  ), r.multigraph = r.uniqueLinkId), r.multigraph === void 0 && (r.multigraph = !1), typeof Map != "function")
    throw new Error("ngraph.graph requires `Map` to be defined. Please polyfill it before using ngraph");
  var e = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = {}, s = 0, a = r.multigraph ? b : x, o = [], l = L, u = L, c = L, h = L, d = {
    /**
     * Sometimes duck typing could be slow. Giving clients a hint about data structure
     * via explicit version number here:
     */
    version: 20,
    /**
     * Adds node to the graph. If node with given id already exists in the graph
     * its data is extended with whatever comes in 'data' argument.
     *
     * @param nodeId the node's identifier. A string or number is preferred.
     * @param [data] additional data for the node being added. If node already
     *   exists its data object is augmented with the new one.
     *
     * @return {node} The newly added node or node with given id if it already exists.
     */
    addNode: y,
    /**
     * Adds a link to the graph. The function always create a new
     * link between two nodes. If one of the nodes does not exists
     * a new node is created.
     *
     * @param fromId link start node id;
     * @param toId link end node id;
     * @param [data] additional data to be set on the new link;
     *
     * @return {link} The newly created link
     */
    addLink: _,
    /**
     * Removes link from the graph. If link does not exist does nothing.
     *
     * @param link - object returned by addLink() or getLinks() methods.
     *
     * @returns true if link was removed; false otherwise.
     */
    removeLink: C,
    /**
     * Removes node with given id from the graph. If node does not exist in the graph
     * does nothing.
     *
     * @param nodeId node's identifier passed to addNode() function.
     *
     * @returns true if node was removed; false otherwise.
     */
    removeNode: g,
    /**
     * Gets node with given identifier. If node does not exist undefined value is returned.
     *
     * @param nodeId requested node identifier;
     *
     * @return {node} in with requested identifier or undefined if no such node exists.
     */
    getNode: v,
    /**
     * Gets number of nodes in this graph.
     *
     * @return number of nodes in the graph.
     */
    getNodeCount: T,
    /**
     * Gets total number of links in the graph.
     */
    getLinkCount: E,
    /**
     * Gets total number of links in the graph.
     */
    getEdgeCount: E,
    /**
     * Synonym for `getLinkCount()`
     */
    getLinksCount: E,
    /**
     * Synonym for `getNodeCount()`
     */
    getNodesCount: T,
    /**
     * Gets all links (inbound and outbound) from the node with given id.
     * If node with given id is not found null is returned.
     *
     * @param nodeId requested node identifier.
     *
     * @return Set of links from and to requested node if such node exists;
     *   otherwise null is returned.
     */
    getLinks: M,
    /**
     * Invokes callback on each node of the graph.
     *
     * @param {Function(node)} callback Function to be invoked. The function
     *   is passed one argument: visited node.
     */
    forEachNode: X,
    /**
     * Invokes callback on every linked (adjacent) node to the given one.
     *
     * @param nodeId Identifier of the requested node.
     * @param {Function(node, link)} callback Function to be called on all linked nodes.
     *   The function is passed two parameters: adjacent node and link object itself.
     * @param oriented if true graph treated as oriented.
     */
    forEachLinkedNode: P,
    /**
     * Enumerates all links in the graph
     *
     * @param {Function(link)} callback Function to be called on all links in the graph.
     *   The function is passed one parameter: graph's link object.
     *
     * Link object contains at least the following fields:
     *  fromId - node id where link starts;
     *  toId - node id where link ends,
     *  data - additional data passed to graph.addLink() method.
     */
    forEachLink: O,
    /**
     * Suspend all notifications about graph changes until
     * endUpdate is called.
     */
    beginUpdate: c,
    /**
     * Resumes all notifications about graph changes and fires
     * graph 'changed' event in case there are any pending changes.
     */
    endUpdate: h,
    /**
     * Removes all nodes and links from the graph.
     */
    clear: R,
    /**
     * Detects whether there is a link between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     * NOTE: this function is synonym for getLink()
     *
     * @returns link if there is one. null otherwise.
     */
    hasLink: w,
    /**
     * Detects whether there is a node with given id
     * 
     * Operation complexity is O(1)
     * NOTE: this function is synonym for getNode()
     *
     * @returns node if there is one; Falsy value otherwise.
     */
    hasNode: v,
    /**
     * Gets an edge between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     *
     * @param {string} fromId link start identifier
     * @param {string} toId link end identifier
     *
     * @returns link if there is one; undefined otherwise.
     */
    getLink: w
  };
  return yV(d), p(), d;
  function p() {
    var F = d.on;
    d.on = B;
    function B() {
      return d.beginUpdate = c = H, d.endUpdate = h = V, l = f, u = m, d.on = F, F.apply(d, arguments);
    }
  }
  function f(F, B) {
    o.push({
      link: F,
      changeType: B
    });
  }
  function m(F, B) {
    o.push({
      node: F,
      changeType: B
    });
  }
  function y(F, B) {
    if (F === void 0)
      throw new Error("Invalid node identifier");
    c();
    var W = v(F);
    return W ? (W.data = B, u(W, "update")) : (W = new bV(F, B), u(W, "add")), e.set(F, W), h(), W;
  }
  function v(F) {
    return e.get(F);
  }
  function g(F) {
    var B = v(F);
    if (!B)
      return !1;
    c();
    var W = B.links;
    return W && (W.forEach(S), B.links = null), e.delete(F), u(B, "remove"), h(), !0;
  }
  function _(F, B, W) {
    c();
    var G = v(F) || y(F), z = v(B) || y(B), K = a(F, B, W), ne = i.has(K.id);
    return i.set(K.id, K), GS(G, K), F !== B && GS(z, K), l(K, ne ? "update" : "add"), h(), K;
  }
  function x(F, B, W) {
    var G = Fp(F, B), z = i.get(G);
    return z ? (z.data = W, z) : new HS(F, B, W, G);
  }
  function b(F, B, W) {
    var G = Fp(F, B), z = n.hasOwnProperty(G);
    if (z || w(F, B)) {
      z || (n[G] = 0);
      var K = "@" + ++n[G];
      G = Fp(F + K, B + K);
    }
    return new HS(F, B, W, G);
  }
  function T() {
    return e.size;
  }
  function E() {
    return i.size;
  }
  function M(F) {
    var B = v(F);
    return B ? B.links : null;
  }
  function C(F, B) {
    return B !== void 0 && (F = w(F, B)), S(F);
  }
  function S(F) {
    if (!F || !i.get(F.id)) return !1;
    c(), i.delete(F.id);
    var B = v(F.fromId), W = v(F.toId);
    return B && B.links.delete(F), W && W.links.delete(F), l(F, "remove"), h(), !0;
  }
  function w(F, B) {
    if (!(F === void 0 || B === void 0))
      return i.get(Fp(F, B));
  }
  function R() {
    c(), X(function(F) {
      g(F.id);
    }), h();
  }
  function O(F) {
    if (typeof F == "function")
      for (var B = i.values(), W = B.next(); !W.done; ) {
        if (F(W.value))
          return !0;
        W = B.next();
      }
  }
  function P(F, B, W) {
    var G = v(F);
    if (G && G.links && typeof B == "function")
      return W ? D(G.links, F, B) : A(G.links, F, B);
  }
  function A(F, B, W) {
    for (var G, z = F.values(), K = z.next(); !K.done; ) {
      var ne = K.value, oe = ne.fromId === B ? ne.toId : ne.fromId;
      if (G = W(e.get(oe), ne), G)
        return !0;
      K = z.next();
    }
  }
  function D(F, B, W) {
    for (var G, z = F.values(), K = z.next(); !K.done; ) {
      var ne = K.value;
      if (ne.fromId === B && (G = W(e.get(ne.toId), ne), G))
        return !0;
      K = z.next();
    }
  }
  function L() {
  }
  function H() {
    s += 1;
  }
  function V() {
    s -= 1, s === 0 && o.length > 0 && (d.fire("changed", o), o.length = 0);
  }
  function X(F) {
    if (typeof F != "function")
      throw new Error("Function is expected to iterate over graph nodes. You passed " + F);
    for (var B = e.values(), W = B.next(); !W.done; ) {
      if (F(W.value))
        return !0;
      W = B.next();
    }
  }
}
function bV(r, e) {
  this.id = r, this.links = null, this.data = e;
}
function GS(r, e) {
  r.links ? r.links.add(e) : r.links = /* @__PURE__ */ new Set([e]);
}
function HS(r, e, i, n) {
  this.fromId = r, this.toId = e, this.data = i, this.id = n;
}
function Fp(r, e) {
  return r.toString() + "👉 " + e.toString();
}
const xV = /* @__PURE__ */ f_(gV);
var Y_ = { exports: {} }, Wd = { exports: {} }, qR = function(r) {
  return r === 0 ? "x" : r === 1 ? "y" : r === 2 ? "z" : "c" + (r + 1);
};
const _V = qR;
var Fc = function(r) {
  return e;
  function e(i, n) {
    let s = n && n.indent || 0, a = n && n.join !== void 0 ? n.join : `
`, o = Array(s + 1).join(" "), l = [];
    for (let u = 0; u < r; ++u) {
      let c = _V(u), h = u === 0 ? "" : o;
      l.push(h + i.replace(/{var}/g, c));
    }
    return l.join(a);
  }
};
const XR = Fc;
Wd.exports = TV;
Wd.exports.generateCreateBodyFunctionBody = YR;
Wd.exports.getVectorCode = ZR;
Wd.exports.getBodyCode = KR;
function TV(r, e) {
  let i = YR(r, e), { Body: n } = new Function(i)();
  return n;
}
function YR(r, e) {
  return `
${ZR(r, e)}
${KR(r)}
return {Body: Body, Vector: Vector};
`;
}
function KR(r) {
  let e = XR(r), i = e("{var}", { join: ", " });
  return `
function Body(${i}) {
  this.isPinned = false;
  this.pos = new Vector(${i});
  this.force = new Vector();
  this.velocity = new Vector();
  this.mass = 1;

  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.reset = function() {
  this.force.reset();
  this.springCount = 0;
  this.springLength = 0;
}

Body.prototype.setPosition = function (${i}) {
  ${e("this.pos.{var} = {var} || 0;", { indent: 2 })}
};`;
}
function ZR(r, e) {
  let i = XR(r), n = "";
  return e && (n = `${i(`
   var v{var};
Object.defineProperty(this, '{var}', {
  set: function(v) { 
    if (!Number.isFinite(v)) throw new Error('Cannot set non-numbers to {var}');
    v{var} = v; 
  },
  get: function() { return v{var}; }
});`)}`), `function Vector(${i("{var}", { join: ", " })}) {
  ${n}
    if (typeof arguments[0] === 'object') {
      // could be another vector
      let v = arguments[0];
      ${i('if (!Number.isFinite(v.{var})) throw new Error("Expected value is not a finite number at Vector constructor ({var})");', { indent: 4 })}
      ${i("this.{var} = v.{var};", { indent: 4 })}
    } else {
      ${i('this.{var} = typeof {var} === "number" ? {var} : 0;', { indent: 4 })}
    }
  }
  
  Vector.prototype.reset = function () {
    ${i("this.{var} = ", { join: "" })}0;
  };`;
}
var wV = Wd.exports, xo = { exports: {} };
const K_ = Fc, ka = qR;
xo.exports = SV;
xo.exports.generateQuadTreeFunctionBody = QR;
xo.exports.getInsertStackCode = iN;
xo.exports.getQuadNodeCode = tN;
xo.exports.isSamePosition = $R;
xo.exports.getChildBodyCode = eN;
xo.exports.setChildBodyCode = JR;
function SV(r) {
  let e = QR(r);
  return new Function(e)();
}
function QR(r) {
  let e = K_(r), i = Math.pow(2, r);
  return `
${iN()}
${tN(r)}
${$R(r)}
${eN(r)}
${JR(r)}

function createQuadTree(options, random) {
  options = options || {};
  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;
  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;

  var gravity = options.gravity;
  var updateQueue = [];
  var insertStack = new InsertStack();
  var theta = options.theta;

  var nodesCache = [];
  var currentInCache = 0;
  var root = newNode();

  return {
    insertBodies: insertBodies,

    /**
     * Gets root node if it is present
     */
    getRoot: function() {
      return root;
    },

    updateBodyForce: update,

    options: function(newOptions) {
      if (newOptions) {
        if (typeof newOptions.gravity === 'number') {
          gravity = newOptions.gravity;
        }
        if (typeof newOptions.theta === 'number') {
          theta = newOptions.theta;
        }

        return this;
      }

      return {
        gravity: gravity,
        theta: theta
      };
    }
  };

  function newNode() {
    // To avoid pressure on GC we reuse nodes.
    var node = nodesCache[currentInCache];
    if (node) {
${a("      node.")}
      node.body = null;
      node.mass = ${e("node.mass_{var} = ", { join: "" })}0;
      ${e("node.min_{var} = node.max_{var} = ", { join: "" })}0;
    } else {
      node = new QuadNode();
      nodesCache[currentInCache] = node;
    }

    ++currentInCache;
    return node;
  }

  function update(sourceBody) {
    var queue = updateQueue;
    var v;
    ${e("var d{var};", { indent: 4 })}
    var r; 
    ${e("var f{var} = 0;", { indent: 4 })}
    var queueLength = 1;
    var shiftIdx = 0;
    var pushIdx = 1;

    queue[0] = root;

    while (queueLength) {
      var node = queue[shiftIdx];
      var body = node.body;

      queueLength -= 1;
      shiftIdx += 1;
      var differentBody = (body !== sourceBody);
      if (body && differentBody) {
        // If the current node is a leaf node (and it is not source body),
        // calculate the force exerted by the current node on body, and add this
        // amount to body's net force.
        ${e("d{var} = body.pos.{var} - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Poor man's protection against zero distance.
          ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
        }

        // This is standard gravitation force calculation but we divide
        // by r^3 to save two operations when normalizing force vector.
        v = gravity * body.mass * sourceBody.mass / (r * r * r);
        ${e("f{var} += v * d{var};", { indent: 8 })}
      } else if (differentBody) {
        // Otherwise, calculate the ratio s / r,  where s is the width of the region
        // represented by the internal node, and r is the distance between the body
        // and the node's center-of-mass
        ${e("d{var} = node.mass_{var} / node.mass - sourceBody.pos.{var};", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

        if (r === 0) {
          // Sorry about code duplication. I don't want to create many functions
          // right away. Just want to see performance first.
          ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 10 })}
          r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
        }
        // If s / r < θ, treat this internal node as a single body, and calculate the
        // force it exerts on sourceBody, and add this amount to sourceBody's net force.
        if ((node.max_${ka(0)} - node.min_${ka(0)}) / r < theta) {
          // in the if statement above we consider node's width only
          // because the region was made into square during tree creation.
          // Thus there is no difference between using width or height.
          v = gravity * node.mass * sourceBody.mass / (r * r * r);
          ${e("f{var} += v * d{var};", { indent: 10 })}
        } else {
          // Otherwise, run the procedure recursively on each of the current node's children.

          // I intentionally unfolded this loop, to save several CPU cycles.
${s()}
        }
      }
    }

    ${e("sourceBody.force.{var} += f{var};", { indent: 4 })}
  }

  function insertBodies(bodies) {
    ${e("var {var}min = Number.MAX_VALUE;", { indent: 4 })}
    ${e("var {var}max = Number.MIN_VALUE;", { indent: 4 })}
    var i = bodies.length;

    // To reduce quad tree depth we are looking for exact bounding box of all particles.
    while (i--) {
      var pos = bodies[i].pos;
      ${e("if (pos.{var} < {var}min) {var}min = pos.{var};", { indent: 6 })}
      ${e("if (pos.{var} > {var}max) {var}max = pos.{var};", { indent: 6 })}
    }

    // Makes the bounds square.
    var maxSideLength = -Infinity;
    ${e("if ({var}max - {var}min > maxSideLength) maxSideLength = {var}max - {var}min ;", { indent: 4 })}

    currentInCache = 0;
    root = newNode();
    ${e("root.min_{var} = {var}min;", { indent: 4 })}
    ${e("root.max_{var} = {var}min + maxSideLength;", { indent: 4 })}

    i = bodies.length - 1;
    if (i >= 0) {
      root.body = bodies[i];
    }
    while (i--) {
      insert(bodies[i], root);
    }
  }

  function insert(newBody) {
    insertStack.reset();
    insertStack.push(root, newBody);

    while (!insertStack.isEmpty()) {
      var stackItem = insertStack.pop();
      var node = stackItem.node;
      var body = stackItem.body;

      if (!node.body) {
        // This is internal node. Update the total mass of the node and center-of-mass.
        ${e("var {var} = body.pos.{var};", { indent: 8 })}
        node.mass += body.mass;
        ${e("node.mass_{var} += body.mass * {var};", { indent: 8 })}

        // Recursively insert the body in the appropriate quadrant.
        // But first find the appropriate quadrant.
        var quadIdx = 0; // Assume we are in the 0's quad.
        ${e("var min_{var} = node.min_{var};", { indent: 8 })}
        ${e("var max_{var} = (min_{var} + node.max_{var}) / 2;", { indent: 8 })}

${n(8)}

        var child = getChild(node, quadIdx);

        if (!child) {
          // The node is internal but this quadrant is not taken. Add
          // subnode to it.
          child = newNode();
          ${e("child.min_{var} = min_{var};", { indent: 10 })}
          ${e("child.max_{var} = max_{var};", { indent: 10 })}
          child.body = body;

          setChild(node, quadIdx, child);
        } else {
          // continue searching in this quadrant.
          insertStack.push(child, body);
        }
      } else {
        // We are trying to add to the leaf node.
        // We have to convert current leaf into internal node
        // and continue adding two nodes.
        var oldBody = node.body;
        node.body = null; // internal nodes do not cary bodies

        if (isSamePosition(oldBody.pos, body.pos)) {
          // Prevent infinite subdivision by bumping one node
          // anywhere in this quadrant
          var retriesCount = 3;
          do {
            var offset = random.nextDouble();
            ${e("var d{var} = (node.max_{var} - node.min_{var}) * offset;", { indent: 12 })}

            ${e("oldBody.pos.{var} = node.min_{var} + d{var};", { indent: 12 })}
            retriesCount -= 1;
            // Make sure we don't bump it out of the box. If we do, next iteration should fix it
          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));

          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {
            // This is very bad, we ran out of precision.
            // if we do not return from the method we'll get into
            // infinite loop here. So we sacrifice correctness of layout, and keep the app running
            // Next layout iteration should get larger bounding box in the first step and fix this
            return;
          }
        }
        // Next iteration should subdivide node further.
        insertStack.push(node, oldBody);
        insertStack.push(node, body);
      }
    }
  }
}
return createQuadTree;

`;
  function n(o) {
    let l = [], u = Array(o + 1).join(" ");
    for (let c = 0; c < r; ++c)
      l.push(u + `if (${ka(c)} > max_${ka(c)}) {`), l.push(u + `  quadIdx = quadIdx + ${Math.pow(2, c)};`), l.push(u + `  min_${ka(c)} = max_${ka(c)};`), l.push(u + `  max_${ka(c)} = node.max_${ka(c)};`), l.push(u + "}");
    return l.join(`
`);
  }
  function s() {
    let o = Array(11).join(" "), l = [];
    for (let u = 0; u < i; ++u)
      l.push(o + `if (node.quad${u}) {`), l.push(o + `  queue[pushIdx] = node.quad${u};`), l.push(o + "  queueLength += 1;"), l.push(o + "  pushIdx += 1;"), l.push(o + "}");
    return l.join(`
`);
  }
  function a(o) {
    let l = [];
    for (let u = 0; u < i; ++u)
      l.push(`${o}quad${u} = null;`);
    return l.join(`
`);
  }
}
function $R(r) {
  let e = K_(r);
  return `
  function isSamePosition(point1, point2) {
    ${e("var d{var} = Math.abs(point1.{var} - point2.{var});", { indent: 2 })}
  
    return ${e("d{var} < 1e-8", { join: " && " })};
  }  
`;
}
function JR(r) {
  var e = Math.pow(2, r);
  return `
function setChild(node, idx, child) {
  ${i()}
}`;
  function i() {
    let n = [];
    for (let s = 0; s < e; ++s) {
      let a = s === 0 ? "  " : "  else ";
      n.push(`${a}if (idx === ${s}) node.quad${s} = child;`);
    }
    return n.join(`
`);
  }
}
function eN(r) {
  return `function getChild(node, idx) {
${e()}
  return null;
}`;
  function e() {
    let i = [], n = Math.pow(2, r);
    for (let s = 0; s < n; ++s)
      i.push(`  if (idx === ${s}) return node.quad${s};`);
    return i.join(`
`);
  }
}
function tN(r) {
  let e = K_(r), i = Math.pow(2, r);
  var n = `
function QuadNode() {
  // body stored inside this node. In quad tree only leaf nodes (by construction)
  // contain bodies:
  this.body = null;

  // Child nodes are stored in quads. Each quad is presented by number:
  // 0 | 1
  // -----
  // 2 | 3
${s("  this.")}

  // Total mass of current node
  this.mass = 0;

  // Center of mass coordinates
  ${e("this.mass_{var} = 0;", { indent: 2 })}

  // bounding box coordinates
  ${e("this.min_{var} = 0;", { indent: 2 })}
  ${e("this.max_{var} = 0;", { indent: 2 })}
}
`;
  return n;
  function s(a) {
    let o = [];
    for (let l = 0; l < i; ++l)
      o.push(`${a}quad${l} = null;`);
    return o.join(`
`);
  }
}
function iN() {
  return `
/**
 * Our implementation of QuadTree is non-recursive to avoid GC hit
 * This data structure represent stack of elements
 * which we are trying to insert into quad tree.
 */
function InsertStack () {
    this.stack = [];
    this.popIdx = 0;
}

InsertStack.prototype = {
    isEmpty: function() {
        return this.popIdx === 0;
    },
    push: function (node, body) {
        var item = this.stack[this.popIdx];
        if (!item) {
            // we are trying to avoid memory pressure: create new element
            // only when absolutely necessary
            this.stack[this.popIdx] = new InsertStackElement(node, body);
        } else {
            item.node = node;
            item.body = body;
        }
        ++this.popIdx;
    },
    pop: function () {
        if (this.popIdx > 0) {
            return this.stack[--this.popIdx];
        }
    },
    reset: function () {
        this.popIdx = 0;
    }
};

function InsertStackElement(node, body) {
    this.node = node; // QuadTree node
    this.body = body; // physical body which needs to be inserted to node
}
`;
}
var EV = xo.exports, Z_ = { exports: {} };
Z_.exports = AV;
Z_.exports.generateFunctionBody = rN;
const MV = Fc;
function AV(r) {
  let e = rN(r);
  return new Function("bodies", "settings", "random", e);
}
function rN(r) {
  let e = MV(r);
  return `
  var boundingBox = {
    ${e("min_{var}: 0, max_{var}: 0,", { indent: 4 })}
  };

  return {
    box: boundingBox,

    update: updateBoundingBox,

    reset: resetBoundingBox,

    getBestNewPosition: function (neighbors) {
      var ${e("base_{var} = 0", { join: ", " })};

      if (neighbors.length) {
        for (var i = 0; i < neighbors.length; ++i) {
          let neighborPos = neighbors[i].pos;
          ${e("base_{var} += neighborPos.{var};", { indent: 10 })}
        }

        ${e("base_{var} /= neighbors.length;", { indent: 8 })}
      } else {
        ${e("base_{var} = (boundingBox.min_{var} + boundingBox.max_{var}) / 2;", { indent: 8 })}
      }

      var springLength = settings.springLength;
      return {
        ${e("{var}: base_{var} + (random.nextDouble() - 0.5) * springLength,", { indent: 8 })}
      };
    }
  };

  function updateBoundingBox() {
    var i = bodies.length;
    if (i === 0) return; // No bodies - no borders.

    ${e("var max_{var} = -Infinity;", { indent: 4 })}
    ${e("var min_{var} = Infinity;", { indent: 4 })}

    while(i--) {
      // this is O(n), it could be done faster with quadtree, if we check the root node bounds
      var bodyPos = bodies[i].pos;
      ${e("if (bodyPos.{var} < min_{var}) min_{var} = bodyPos.{var};", { indent: 6 })}
      ${e("if (bodyPos.{var} > max_{var}) max_{var} = bodyPos.{var};", { indent: 6 })}
    }

    ${e("boundingBox.min_{var} = min_{var};", { indent: 4 })}
    ${e("boundingBox.max_{var} = max_{var};", { indent: 4 })}
  }

  function resetBoundingBox() {
    ${e("boundingBox.min_{var} = boundingBox.max_{var} = 0;", { indent: 4 })}
  }
`;
}
var CV = Z_.exports, Q_ = { exports: {} };
const RV = Fc;
Q_.exports = NV;
Q_.exports.generateCreateDragForceFunctionBody = nN;
function NV(r) {
  let e = nN(r);
  return new Function("options", e);
}
function nN(r) {
  return `
  if (!Number.isFinite(options.dragCoefficient)) throw new Error('dragCoefficient is not a finite number');

  return {
    update: function(body) {
      ${RV(r)("body.force.{var} -= options.dragCoefficient * body.velocity.{var};", { indent: 6 })}
    }
  };
`;
}
var PV = Q_.exports, $_ = { exports: {} };
const IV = Fc;
$_.exports = OV;
$_.exports.generateCreateSpringForceFunctionBody = sN;
function OV(r) {
  let e = sN(r);
  return new Function("options", "random", e);
}
function sN(r) {
  let e = IV(r);
  return `
  if (!Number.isFinite(options.springCoefficient)) throw new Error('Spring coefficient is not a number');
  if (!Number.isFinite(options.springLength)) throw new Error('Spring length is not a number');

  return {
    /**
     * Updates forces acting on a spring
     */
    update: function (spring) {
      var body1 = spring.from;
      var body2 = spring.to;
      var length = spring.length < 0 ? options.springLength : spring.length;
      ${e("var d{var} = body2.pos.{var} - body1.pos.{var};", { indent: 6 })}
      var r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});

      if (r === 0) {
        ${e("d{var} = (random.nextDouble() - 0.5) / 50;", { indent: 8 })}
        r = Math.sqrt(${e("d{var} * d{var}", { join: " + " })});
      }

      var d = r - length;
      var coefficient = ((spring.coefficient > 0) ? spring.coefficient : options.springCoefficient) * d / r;

      ${e("body1.force.{var} += coefficient * d{var}", { indent: 6 })};
      body1.springCount += 1;
      body1.springLength += r;

      ${e("body2.force.{var} -= coefficient * d{var}", { indent: 6 })};
      body2.springCount += 1;
      body2.springLength += r;
    }
  };
`;
}
var DV = $_.exports, J_ = { exports: {} };
const LV = Fc;
J_.exports = kV;
J_.exports.generateIntegratorFunctionBody = aN;
function kV(r) {
  let e = aN(r);
  return new Function("bodies", "timeStep", "adaptiveTimeStepWeight", e);
}
function aN(r) {
  let e = LV(r);
  return `
  var length = bodies.length;
  if (length === 0) return 0;

  ${e("var d{var} = 0, t{var} = 0;", { indent: 2 })}

  for (var i = 0; i < length; ++i) {
    var body = bodies[i];
    if (body.isPinned) continue;

    if (adaptiveTimeStepWeight && body.springCount) {
      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);
    }

    var coeff = timeStep / body.mass;

    ${e("body.velocity.{var} += coeff * body.force.{var};", { indent: 4 })}
    ${e("var v{var} = body.velocity.{var};", { indent: 4 })}
    var v = Math.sqrt(${e("v{var} * v{var}", { join: " + " })});

    if (v > 1) {
      // We normalize it so that we move within timeStep range. 
      // for the case when v <= 1 - we let velocity to fade out.
      ${e("body.velocity.{var} = v{var} / v;", { indent: 6 })}
    }

    ${e("d{var} = timeStep * body.velocity.{var};", { indent: 4 })}

    ${e("body.pos.{var} += d{var};", { indent: 4 })}

    ${e("t{var} += Math.abs(d{var});", { indent: 4 })}
  }

  return (${e("t{var} * t{var}", { join: " + " })})/length;
`;
}
var UV = J_.exports, Jy, WS;
function FV() {
  if (WS) return Jy;
  WS = 1, Jy = r;
  function r(e, i, n, s) {
    this.from = e, this.to = i, this.length = n, this.coefficient = s;
  }
  return Jy;
}
var e0, qS;
function BV() {
  if (qS) return e0;
  qS = 1, e0 = r;
  function r(e, i) {
    var n;
    if (e || (e = {}), i) {
      for (n in i)
        if (i.hasOwnProperty(n)) {
          var s = e.hasOwnProperty(n), a = typeof i[n], o = !s || typeof e[n] !== a;
          o ? e[n] = i[n] : a === "object" && (e[n] = r(e[n], i[n]));
        }
    }
    return e;
  }
  return e0;
}
var hh = { exports: {} }, XS;
function zV() {
  if (XS) return hh.exports;
  XS = 1, hh.exports = r, hh.exports.random = r, hh.exports.randomIterator = l;
  function r(u) {
    var c = typeof u == "number" ? u : +/* @__PURE__ */ new Date();
    return new e(c);
  }
  function e(u) {
    this.seed = u;
  }
  e.prototype.next = o, e.prototype.nextDouble = a, e.prototype.uniform = a, e.prototype.gaussian = i;
  function i() {
    var u, c, h;
    do
      c = this.nextDouble() * 2 - 1, h = this.nextDouble() * 2 - 1, u = c * c + h * h;
    while (u >= 1 || u === 0);
    return c * Math.sqrt(-2 * Math.log(u) / u);
  }
  e.prototype.levy = n;
  function n() {
    var u = 1.5, c = Math.pow(
      s(1 + u) * Math.sin(Math.PI * u / 2) / (s((1 + u) / 2) * u * Math.pow(2, (u - 1) / 2)),
      1 / u
    );
    return this.gaussian() * c / Math.pow(Math.abs(this.gaussian()), 1 / u);
  }
  function s(u) {
    return Math.sqrt(2 * Math.PI / u) * Math.pow(1 / Math.E * (u + 1 / (12 * u - 1 / (10 * u))), u);
  }
  function a() {
    var u = this.seed;
    return u = u + 2127912214 + (u << 12) & 4294967295, u = (u ^ 3345072700 ^ u >>> 19) & 4294967295, u = u + 374761393 + (u << 5) & 4294967295, u = (u + 3550635116 ^ u << 9) & 4294967295, u = u + 4251993797 + (u << 3) & 4294967295, u = (u ^ 3042594569 ^ u >>> 16) & 4294967295, this.seed = u, (u & 268435455) / 268435456;
  }
  function o(u) {
    return Math.floor(this.nextDouble() * u);
  }
  function l(u, c) {
    var h = c || r();
    if (typeof h.next != "function")
      throw new Error("customRandom does not match expected API: next() function is missing");
    return {
      forEach: p,
      /**
       * Shuffles array randomly, in place.
       */
      shuffle: d
    };
    function d() {
      var f, m, y;
      for (f = u.length - 1; f > 0; --f)
        m = h.next(f + 1), y = u[m], u[m] = u[f], u[f] = y;
      return u;
    }
    function p(f) {
      var m, y, v;
      for (m = u.length - 1; m > 0; --m)
        y = h.next(m + 1), v = u[y], u[y] = u[m], u[m] = v, f(v);
      u.length && f(u[0]);
    }
  }
  return hh.exports;
}
var oN = XV, jV = wV, VV = EV, GV = CV, HV = PV, WV = DV, qV = UV, YS = {};
function XV(r) {
  var e = FV(), i = BV(), n = X_;
  if (r) {
    if (r.springCoeff !== void 0) throw new Error("springCoeff was renamed to springCoefficient");
    if (r.dragCoeff !== void 0) throw new Error("dragCoeff was renamed to dragCoefficient");
  }
  r = i(r, {
    /**
     * Ideal length for links (springs in physical model).
     */
    springLength: 10,
    /**
     * Hook's law coefficient. 1 - solid spring.
     */
    springCoefficient: 0.8,
    /**
     * Coulomb's law coefficient. It's used to repel nodes thus should be negative
     * if you make it positive nodes start attract each other :).
     */
    gravity: -12,
    /**
     * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).
     * The closer it's to 1 the more nodes algorithm will have to go through.
     * Setting it to one makes Barnes Hut simulation no different from
     * brute-force forces calculation (each node is considered).
     */
    theta: 0.8,
    /**
     * Drag force coefficient. Used to slow down system, thus should be less than 1.
     * The closer it is to 0 the less tight system will be.
     */
    dragCoefficient: 0.9,
    // TODO: Need to rename this to something better. E.g. `dragCoefficient`
    /**
     * Default time step (dt) for forces integration
     */
    timeStep: 0.5,
    /**
     * Adaptive time step uses average spring length to compute actual time step:
     * See: https://twitter.com/anvaka/status/1293067160755957760
     */
    adaptiveTimeStepWeight: 0,
    /**
     * This parameter defines number of dimensions of the space where simulation
     * is performed. 
     */
    dimensions: 2,
    /**
     * In debug mode more checks are performed, this will help you catch errors
     * quickly, however for production build it is recommended to turn off this flag
     * to speed up computation.
     */
    debug: !1
  });
  var s = YS[r.dimensions];
  if (!s) {
    var a = r.dimensions;
    s = {
      Body: jV(a, r.debug),
      createQuadTree: VV(a),
      createBounds: GV(a),
      createDragForce: HV(a),
      createSpringForce: WV(a),
      integrate: qV(a)
    }, YS[a] = s;
  }
  var o = s.Body, l = s.createQuadTree, u = s.createBounds, c = s.createDragForce, h = s.createSpringForce, d = s.integrate, p = (D) => new o(D), f = zV().random(42), m = [], y = [], v = l(r, f), g = u(m, r, f), _ = h(r, f), x = c(r), b = 0, T = [], E = /* @__PURE__ */ new Map(), M = 0;
  w("nbody", P), w("spring", A);
  var C = {
    /**
     * Array of bodies, registered with current simulator
     *
     * Note: To add new body, use addBody() method. This property is only
     * exposed for testing/performance purposes.
     */
    bodies: m,
    quadTree: v,
    /**
     * Array of springs, registered with current simulator
     *
     * Note: To add new spring, use addSpring() method. This property is only
     * exposed for testing/performance purposes.
     */
    springs: y,
    /**
     * Returns settings with which current simulator was initialized
     */
    settings: r,
    /**
     * Adds a new force to simulation
     */
    addForce: w,
    /**
     * Removes a force from the simulation.
     */
    removeForce: R,
    /**
     * Returns a map of all registered forces.
     */
    getForces: O,
    /**
     * Performs one step of force simulation.
     *
     * @returns {boolean} true if system is considered stable; False otherwise.
     */
    step: function() {
      for (var D = 0; D < T.length; ++D)
        T[D](M);
      var L = d(m, r.timeStep, r.adaptiveTimeStepWeight);
      return M += 1, L;
    },
    /**
     * Adds body to the system
     *
     * @param {ngraph.physics.primitives.Body} body physical body
     *
     * @returns {ngraph.physics.primitives.Body} added body
     */
    addBody: function(D) {
      if (!D)
        throw new Error("Body is required");
      return m.push(D), D;
    },
    /**
     * Adds body to the system at given position
     *
     * @param {Object} pos position of a body
     *
     * @returns {ngraph.physics.primitives.Body} added body
     */
    addBodyAt: function(D) {
      if (!D)
        throw new Error("Body position is required");
      var L = p(D);
      return m.push(L), L;
    },
    /**
     * Removes body from the system
     *
     * @param {ngraph.physics.primitives.Body} body to remove
     *
     * @returns {Boolean} true if body found and removed. falsy otherwise;
     */
    removeBody: function(D) {
      if (D) {
        var L = m.indexOf(D);
        if (!(L < 0))
          return m.splice(L, 1), m.length === 0 && g.reset(), !0;
      }
    },
    /**
     * Adds a spring to this simulation.
     *
     * @returns {Object} - a handle for a spring. If you want to later remove
     * spring pass it to removeSpring() method.
     */
    addSpring: function(D, L, H, V) {
      if (!D || !L)
        throw new Error("Cannot add null spring to force simulator");
      typeof H != "number" && (H = -1);
      var X = new e(D, L, H, V >= 0 ? V : -1);
      return y.push(X), X;
    },
    /**
     * Returns amount of movement performed on last step() call
     */
    getTotalMovement: function() {
      return b;
    },
    /**
     * Removes spring from the system
     *
     * @param {Object} spring to remove. Spring is an object returned by addSpring
     *
     * @returns {Boolean} true if spring found and removed. falsy otherwise;
     */
    removeSpring: function(D) {
      if (D) {
        var L = y.indexOf(D);
        if (L > -1)
          return y.splice(L, 1), !0;
      }
    },
    getBestNewBodyPosition: function(D) {
      return g.getBestNewPosition(D);
    },
    /**
     * Returns bounding box which covers all bodies
     */
    getBBox: S,
    getBoundingBox: S,
    invalidateBBox: function() {
      console.warn("invalidateBBox() is deprecated, bounds always recomputed on `getBBox()` call");
    },
    // TODO: Move the force specific stuff to force
    gravity: function(D) {
      return D !== void 0 ? (r.gravity = D, v.options({ gravity: D }), this) : r.gravity;
    },
    theta: function(D) {
      return D !== void 0 ? (r.theta = D, v.options({ theta: D }), this) : r.theta;
    },
    /**
     * Returns pseudo-random number generator instance.
     */
    random: f
  };
  return YV(r, C), n(C), C;
  function S() {
    return g.update(), g.box;
  }
  function w(D, L) {
    if (E.has(D)) throw new Error("Force " + D + " is already added");
    E.set(D, L), T.push(L);
  }
  function R(D) {
    var L = T.indexOf(E.get(D));
    L < 0 || (T.splice(L, 1), E.delete(D));
  }
  function O() {
    return E;
  }
  function P() {
    if (m.length !== 0) {
      v.insertBodies(m);
      for (var D = m.length; D--; ) {
        var L = m[D];
        L.isPinned || (L.reset(), v.updateBodyForce(L), x.update(L));
      }
    }
  }
  function A() {
    for (var D = y.length; D--; )
      _.update(y[D]);
  }
}
function YV(r, e) {
  for (var i in r)
    KV(r, e, i);
}
function KV(r, e, i) {
  if (r.hasOwnProperty(i) && typeof e[i] != "function") {
    var n = Number.isFinite(r[i]);
    n ? e[i] = function(s) {
      if (s !== void 0) {
        if (!Number.isFinite(s)) throw new Error("Value of " + i + " should be a valid number.");
        return r[i] = s, e;
      }
      return r[i];
    } : e[i] = function(s) {
      return s !== void 0 ? (r[i] = s, e) : r[i];
    };
  }
}
Y_.exports = QV;
Y_.exports.simulator = oN;
var ZV = X_;
function QV(r, e) {
  if (!r)
    throw new Error("Graph structure cannot be undefined");
  var i = e && e.createSimulator || oN, n = i(e);
  if (Array.isArray(e)) throw new Error("Physics settings is expected to be an object");
  var s = r.version > 19 ? P : O;
  e && typeof e.nodeMass == "function" && (s = e.nodeMass);
  var a = /* @__PURE__ */ new Map(), o = {}, l = 0, u = n.settings.springTransform || $V;
  x(), v();
  var c = !1, h = {
    /**
     * Performs one step of iterative layout algorithm
     *
     * @returns {boolean} true if the system should be considered stable; False otherwise.
     * The system is stable if no further call to `step()` can improve the layout.
     */
    step: function() {
      if (l === 0)
        return d(!0), !0;
      var A = n.step();
      h.lastMove = A, h.fire("step");
      var D = A / l, L = D <= 0.01;
      return d(L), L;
    },
    /**
     * For a given `nodeId` returns position
     */
    getNodePosition: function(A) {
      return R(A).pos;
    },
    /**
     * Sets position of a node to a given coordinates
     * @param {string} nodeId node identifier
     * @param {number} x position of a node
     * @param {number} y position of a node
     * @param {number=} z position of node (only if applicable to body)
     */
    setNodePosition: function(A) {
      var D = R(A);
      D.setPosition.apply(D, Array.prototype.slice.call(arguments, 1));
    },
    /**
     * @returns {Object} Link position by link id
     * @returns {Object.from} {x, y} coordinates of link start
     * @returns {Object.to} {x, y} coordinates of link end
     */
    getLinkPosition: function(A) {
      var D = o[A];
      if (D)
        return {
          from: D.from.pos,
          to: D.to.pos
        };
    },
    /**
     * @returns {Object} area required to fit in the graph. Object contains
     * `x1`, `y1` - top left coordinates
     * `x2`, `y2` - bottom right coordinates
     */
    getGraphRect: function() {
      return n.getBBox();
    },
    /**
     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)
     */
    forEachBody: p,
    /*
     * Requests layout algorithm to pin/unpin node to its current position
     * Pinned nodes should not be affected by layout algorithm and always
     * remain at their position
     */
    pinNode: function(A, D) {
      var L = R(A.id);
      L.isPinned = !!D;
    },
    /**
     * Checks whether given graph's node is currently pinned
     */
    isNodePinned: function(A) {
      return R(A.id).isPinned;
    },
    /**
     * Request to release all resources
     */
    dispose: function() {
      r.off("changed", _), h.fire("disposed");
    },
    /**
     * Gets physical body for a given node id. If node is not found undefined
     * value is returned.
     */
    getBody: y,
    /**
     * Gets spring for a given edge.
     *
     * @param {string} linkId link identifer. If two arguments are passed then
     * this argument is treated as formNodeId
     * @param {string=} toId when defined this parameter denotes head of the link
     * and first argument is treated as tail of the link (fromId)
     */
    getSpring: m,
    /**
     * Returns length of cumulative force vector. The closer this to zero - the more stable the system is
     */
    getForceVectorLength: f,
    /**
     * [Read only] Gets current physics simulator
     */
    simulator: n,
    /**
     * Gets the graph that was used for layout
     */
    graph: r,
    /**
     * Gets amount of movement performed during last step operation
     */
    lastMove: 0
  };
  return ZV(h), h;
  function d(A) {
    c !== A && (c = A, g(A));
  }
  function p(A) {
    a.forEach(A);
  }
  function f() {
    var A = 0, D = 0;
    return p(function(L) {
      A += Math.abs(L.force.x), D += Math.abs(L.force.y);
    }), Math.sqrt(A * A + D * D);
  }
  function m(A, D) {
    var L;
    if (D === void 0)
      typeof A != "object" ? L = A : L = A.id;
    else {
      var H = r.hasLink(A, D);
      if (!H) return;
      L = H.id;
    }
    return o[L];
  }
  function y(A) {
    return a.get(A);
  }
  function v() {
    r.on("changed", _);
  }
  function g(A) {
    h.fire("stable", A);
  }
  function _(A) {
    for (var D = 0; D < A.length; ++D) {
      var L = A[D];
      L.changeType === "add" ? (L.node && b(L.node.id), L.link && E(L.link)) : L.changeType === "remove" && (L.node && T(L.node), L.link && M(L.link));
    }
    l = r.getNodesCount();
  }
  function x() {
    l = 0, r.forEachNode(function(A) {
      b(A.id), l += 1;
    }), r.forEachLink(E);
  }
  function b(A) {
    var D = a.get(A);
    if (!D) {
      var L = r.getNode(A);
      if (!L)
        throw new Error("initBody() was called with unknown node id");
      var H = L.position;
      if (!H) {
        var V = C(L);
        H = n.getBestNewBodyPosition(V);
      }
      D = n.addBodyAt(H), D.id = A, a.set(A, D), S(A), w(L) && (D.isPinned = !0);
    }
  }
  function T(A) {
    var D = A.id, L = a.get(D);
    L && (a.delete(D), n.removeBody(L));
  }
  function E(A) {
    S(A.fromId), S(A.toId);
    var D = a.get(A.fromId), L = a.get(A.toId), H = n.addSpring(D, L, A.length);
    u(A, H), o[A.id] = H;
  }
  function M(A) {
    var D = o[A.id];
    if (D) {
      var L = r.getNode(A.fromId), H = r.getNode(A.toId);
      L && S(L.id), H && S(H.id), delete o[A.id], n.removeSpring(D);
    }
  }
  function C(A) {
    var D = [];
    if (!A.links)
      return D;
    for (var L = Math.min(A.links.length, 2), H = 0; H < L; ++H) {
      var V = A.links[H], X = V.fromId !== A.id ? a.get(V.fromId) : a.get(V.toId);
      X && X.pos && D.push(X);
    }
    return D;
  }
  function S(A) {
    var D = a.get(A);
    if (D.mass = s(A), Number.isNaN(D.mass))
      throw new Error("Node mass should be a number");
  }
  function w(A) {
    return A && (A.isPinned || A.data && A.data.isPinned);
  }
  function R(A) {
    var D = a.get(A);
    return D || (b(A), D = a.get(A)), D;
  }
  function O(A) {
    var D = r.getLinks(A);
    return D ? 1 + D.length / 3 : 1;
  }
  function P(A) {
    var D = r.getLinks(A);
    return D ? 1 + D.size / 3 : 1;
  }
}
function $V() {
}
var JV = Y_.exports;
const eG = /* @__PURE__ */ f_(JV);
function Em(r) {
  var e = typeof r;
  return r != null && (e == "object" || e == "function");
}
var tG = typeof global == "object" && global && global.Object === Object && global, iG = typeof self == "object" && self && self.Object === Object && self, lN = tG || iG || Function("return this")(), t0 = function() {
  return lN.Date.now();
}, rG = /\s/;
function nG(r) {
  for (var e = r.length; e-- && rG.test(r.charAt(e)); )
    ;
  return e;
}
var sG = /^\s+/;
function aG(r) {
  return r && r.slice(0, nG(r) + 1).replace(sG, "");
}
var Mm = lN.Symbol, uN = Object.prototype, oG = uN.hasOwnProperty, lG = uN.toString, dh = Mm ? Mm.toStringTag : void 0;
function uG(r) {
  var e = oG.call(r, dh), i = r[dh];
  try {
    r[dh] = void 0;
    var n = !0;
  } catch {
  }
  var s = lG.call(r);
  return n && (e ? r[dh] = i : delete r[dh]), s;
}
var cG = Object.prototype, hG = cG.toString;
function dG(r) {
  return hG.call(r);
}
var pG = "[object Null]", fG = "[object Undefined]", KS = Mm ? Mm.toStringTag : void 0;
function mG(r) {
  return r == null ? r === void 0 ? fG : pG : KS && KS in Object(r) ? uG(r) : dG(r);
}
function gG(r) {
  return r != null && typeof r == "object";
}
var yG = "[object Symbol]";
function vG(r) {
  return typeof r == "symbol" || gG(r) && mG(r) == yG;
}
var ZS = NaN, bG = /^[-+]0x[0-9a-f]+$/i, xG = /^0b[01]+$/i, _G = /^0o[0-7]+$/i, TG = parseInt;
function QS(r) {
  if (typeof r == "number")
    return r;
  if (vG(r))
    return ZS;
  if (Em(r)) {
    var e = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = Em(e) ? e + "" : e;
  }
  if (typeof r != "string")
    return r === 0 ? r : +r;
  r = aG(r);
  var i = xG.test(r);
  return i || _G.test(r) ? TG(r.slice(2), i ? 2 : 8) : bG.test(r) ? ZS : +r;
}
var wG = "Expected a function", SG = Math.max, EG = Math.min;
function cN(r, e, i) {
  var n, s, a, o, l, u, c = 0, h = !1, d = !1, p = !0;
  if (typeof r != "function")
    throw new TypeError(wG);
  e = QS(e) || 0, Em(i) && (h = !!i.leading, d = "maxWait" in i, a = d ? SG(QS(i.maxWait) || 0, e) : a, p = "trailing" in i ? !!i.trailing : p);
  function f(E) {
    var M = n, C = s;
    return n = s = void 0, c = E, o = r.apply(C, M), o;
  }
  function m(E) {
    return c = E, l = setTimeout(g, e), h ? f(E) : o;
  }
  function y(E) {
    var M = E - u, C = E - c, S = e - M;
    return d ? EG(S, a - C) : S;
  }
  function v(E) {
    var M = E - u, C = E - c;
    return u === void 0 || M >= e || M < 0 || d && C >= a;
  }
  function g() {
    var E = t0();
    if (v(E))
      return _(E);
    l = setTimeout(g, y(E));
  }
  function _(E) {
    return l = void 0, p && n ? f(E) : (n = s = void 0, o);
  }
  function x() {
    l !== void 0 && clearTimeout(l), c = 0, n = u = s = l = void 0;
  }
  function b() {
    return l === void 0 ? o : _(t0());
  }
  function T() {
    var E = t0(), M = v(E);
    if (n = arguments, s = this, u = E, M) {
      if (l === void 0)
        return m(u);
      if (d)
        return clearTimeout(l), l = setTimeout(g, e), f(u);
    }
    return l === void 0 && (l = setTimeout(g, e)), o;
  }
  return T.cancel = x, T.flush = b, T;
}
function $S(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function MG(r) {
  if (Array.isArray(r)) return r;
}
function AG(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function CG(r, e, i) {
  return Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function RG(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function NG() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function PG(r, e) {
  return MG(r) || RG(r, e) || IG(r, e) || NG();
}
function IG(r, e) {
  if (r) {
    if (typeof r == "string") return $S(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? $S(r, e) : void 0;
  }
}
var OG = /* @__PURE__ */ CG(function r(e, i) {
  var n = i.default, s = n === void 0 ? null : n, a = i.triggerUpdate, o = a === void 0 ? !0 : a, l = i.onChange, u = l === void 0 ? function(c, h) {
  } : l;
  AG(this, r), this.name = e, this.defaultVal = s, this.triggerUpdate = o, this.onChange = u;
});
function Pl(r) {
  var e = r.stateInit, i = e === void 0 ? function() {
    return {};
  } : e, n = r.props, s = n === void 0 ? {} : n, a = r.methods, o = a === void 0 ? {} : a, l = r.aliases, u = l === void 0 ? {} : l, c = r.init, h = c === void 0 ? function() {
  } : c, d = r.update, p = d === void 0 ? function() {
  } : d, f = Object.keys(s).map(function(m) {
    return new OG(m, s[m]);
  });
  return function m() {
    for (var y = arguments.length, v = new Array(y), g = 0; g < y; g++)
      v[g] = arguments[g];
    var _ = !!(this instanceof m && this.constructor), x = _ ? v.shift() : void 0, b = v[0], T = b === void 0 ? {} : b, E = Object.assign(
      {},
      i instanceof Function ? i(T) : i,
      // Support plain objects for backwards compatibility
      {
        initialised: !1
      }
    ), M = {};
    function C(R) {
      return S(R, T), w(), C;
    }
    var S = function(R, O) {
      h.call(C, R, E, O), E.initialised = !0;
    }, w = cN(function() {
      E.initialised && (p.call(C, E, M), M = {});
    }, 1);
    return f.forEach(function(R) {
      C[R.name] = O(R);
      function O(P) {
        var A = P.name, D = P.triggerUpdate, L = D === void 0 ? !1 : D, H = P.onChange, V = H === void 0 ? function(B, W) {
        } : H, X = P.defaultVal, F = X === void 0 ? null : X;
        return function(B) {
          var W = E[A];
          if (!arguments.length)
            return W;
          var G = B === void 0 ? F : B;
          return E[A] = G, V.call(C, G, E, W), !M.hasOwnProperty(A) && (M[A] = W), L && w(), C;
        };
      }
    }), Object.keys(o).forEach(function(R) {
      C[R] = function() {
        for (var O, P = arguments.length, A = new Array(P), D = 0; D < P; D++)
          A[D] = arguments[D];
        return (O = o[R]).call.apply(O, [C, E].concat(A));
      };
    }), Object.entries(u).forEach(function(R) {
      var O = PG(R, 2), P = O[0], A = O[1];
      return C[P] = C[A];
    }), C.resetProps = function() {
      return f.forEach(function(R) {
        C[R.name](R.defaultVal);
      }), C;
    }, C.resetProps(), E._rerender = w, _ && x && C(x), C;
  };
}
var tt = function(r) {
  return typeof r == "function" ? r : typeof r == "string" ? function(e) {
    return e[r];
  } : function(e) {
    return r;
  };
};
class JS extends Map {
  constructor(e, i = kG) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: i } }), e != null) for (const [n, s] of e) this.set(n, s);
  }
  get(e) {
    return super.get(eE(this, e));
  }
  has(e) {
    return super.has(eE(this, e));
  }
  set(e, i) {
    return super.set(DG(this, e), i);
  }
  delete(e) {
    return super.delete(LG(this, e));
  }
}
function eE({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) ? r.get(n) : i;
}
function DG({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) ? r.get(n) : (r.set(n, i), i);
}
function LG({ _intern: r, _key: e }, i) {
  const n = e(i);
  return r.has(n) && (i = r.get(n), r.delete(n)), i;
}
function kG(r) {
  return r !== null && typeof r == "object" ? r.valueOf() : r;
}
function Ub(r, e) {
  let i;
  if (e === void 0)
    for (const n of r)
      n != null && (i < n || i === void 0 && n >= n) && (i = n);
  else {
    let n = -1;
    for (let s of r)
      (s = e(s, ++n, r)) != null && (i < s || i === void 0 && s >= s) && (i = s);
  }
  return i;
}
function Fb(r, e) {
  let i;
  if (e === void 0)
    for (const n of r)
      n != null && (i > n || i === void 0 && n >= n) && (i = n);
  else {
    let n = -1;
    for (let s of r)
      (s = e(s, ++n, r)) != null && (i > s || i === void 0 && s >= s) && (i = s);
  }
  return i;
}
function UG(r, e) {
  let i = 0;
  for (let n of r)
    (n = +n) && (i += n);
  return i;
}
function Bb(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function FG(r) {
  if (Array.isArray(r)) return r;
}
function BG(r) {
  if (Array.isArray(r)) return Bb(r);
}
function hN(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function zG(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function jG(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function cr(r, e) {
  return r.get(hN(r, e));
}
function nu(r, e, i) {
  zG(r, e), e.set(r, i);
}
function Bp(r, e, i) {
  return r.set(hN(r, e), i), i;
}
function VG(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, QG(n.key), n);
  }
}
function GG(r, e, i) {
  return e && VG(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function HG(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function WG(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function qG() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function XG() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function YG(r, e) {
  return FG(r) || WG(r, e) || dN(r, e) || qG();
}
function KG(r) {
  return BG(r) || HG(r) || dN(r) || XG();
}
function ZG(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function QG(r) {
  var e = ZG(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function dN(r, e) {
  if (r) {
    if (typeof r == "string") return Bb(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Bb(r, e) : void 0;
  }
}
var su = /* @__PURE__ */ new WeakMap(), ph = /* @__PURE__ */ new WeakMap(), au = /* @__PURE__ */ new WeakMap(), i0 = /* @__PURE__ */ new WeakMap(), r0 = /* @__PURE__ */ new WeakMap(), n0 = /* @__PURE__ */ new WeakMap(), $G = /* @__PURE__ */ function() {
  function r() {
    jG(this, r), nu(this, su, /* @__PURE__ */ new Map()), nu(this, ph, /* @__PURE__ */ new Map()), nu(this, au, function(e) {
      return e;
    }), nu(this, i0, function() {
      return {};
    }), nu(this, r0, function() {
    }), nu(this, n0, function() {
    });
  }
  return GG(r, [{
    key: "getObj",
    value: function(e) {
      return cr(su, this).get(cr(au, this).call(this, e));
    }
  }, {
    key: "getData",
    value: function(e) {
      return cr(ph, this).get(e);
    }
  }, {
    key: "entries",
    value: function() {
      return KG(cr(ph, this).entries()).map(function(e) {
        var i = YG(e, 2), n = i[0], s = i[1];
        return [s, n];
      });
    }
  }, {
    key: "id",
    value: function(e) {
      return Bp(au, this, tt(e)), this;
    }
  }, {
    key: "onCreateObj",
    value: function(e) {
      return Bp(i0, this, e), this;
    }
  }, {
    key: "onUpdateObj",
    value: function(e) {
      return Bp(r0, this, e), this;
    }
  }, {
    key: "onRemoveObj",
    value: function(e) {
      return Bp(n0, this, e), this;
    }
  }, {
    key: "digest",
    value: function(e) {
      var i = this;
      e.filter(function(s) {
        return !cr(su, i).has(cr(au, i).call(i, s));
      }).forEach(function(s) {
        var a = cr(i0, i).call(i, s);
        cr(su, i).set(cr(au, i).call(i, s), a), cr(ph, i).set(a, s);
      });
      var n = new Map(e.map(function(s) {
        return [cr(au, i).call(i, s), s];
      }));
      return cr(su, this).forEach(function(s, a) {
        n.has(a) ? cr(r0, i).call(i, s, n.get(a)) : (cr(n0, i).call(i, s, a), cr(su, i).delete(a), cr(ph, i).delete(s));
      }), this;
    }
  }, {
    key: "clear",
    value: function() {
      return this.digest([]), this;
    }
  }]);
}();
function JG(r, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(r);
      break;
    default:
      this.range(e).domain(r);
      break;
  }
  return this;
}
const tE = Symbol("implicit");
function e1() {
  var r = new JS(), e = [], i = [], n = tE;
  function s(a) {
    let o = r.get(a);
    if (o === void 0) {
      if (n !== tE) return n;
      r.set(a, o = e.push(a) - 1);
    }
    return i[o % i.length];
  }
  return s.domain = function(a) {
    if (!arguments.length) return e.slice();
    e = [], r = new JS();
    for (const o of a)
      r.has(o) || r.set(o, e.push(o) - 1);
    return s;
  }, s.range = function(a) {
    return arguments.length ? (i = Array.from(a), s) : i.slice();
  }, s.unknown = function(a) {
    return arguments.length ? (n = a, s) : n;
  }, s.copy = function() {
    return e1(e, i).unknown(n);
  }, JG.apply(s, arguments), s;
}
function t1(r, e, i) {
  r.prototype = e.prototype = i, i.constructor = r;
}
function pN(r, e) {
  var i = Object.create(r.prototype);
  for (var n in e) i[n] = e[n];
  return i;
}
function qd() {
}
var pd = 0.7, Am = 1 / pd, qu = "\\s*([+-]?\\d+)\\s*", fd = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", ys = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", e9 = /^#([0-9a-f]{3,8})$/, t9 = new RegExp(`^rgb\\(${qu},${qu},${qu}\\)$`), i9 = new RegExp(`^rgb\\(${ys},${ys},${ys}\\)$`), r9 = new RegExp(`^rgba\\(${qu},${qu},${qu},${fd}\\)$`), n9 = new RegExp(`^rgba\\(${ys},${ys},${ys},${fd}\\)$`), s9 = new RegExp(`^hsl\\(${fd},${ys},${ys}\\)$`), a9 = new RegExp(`^hsla\\(${fd},${ys},${ys},${fd}\\)$`), iE = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
t1(qd, md, {
  copy(r) {
    return Object.assign(new this.constructor(), this, r);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: rE,
  // Deprecated! Use color.formatHex.
  formatHex: rE,
  formatHex8: o9,
  formatHsl: l9,
  formatRgb: nE,
  toString: nE
});
function rE() {
  return this.rgb().formatHex();
}
function o9() {
  return this.rgb().formatHex8();
}
function l9() {
  return fN(this).formatHsl();
}
function nE() {
  return this.rgb().formatRgb();
}
function md(r) {
  var e, i;
  return r = (r + "").trim().toLowerCase(), (e = e9.exec(r)) ? (i = e[1].length, e = parseInt(e[1], 16), i === 6 ? sE(e) : i === 3 ? new Ur(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : i === 8 ? zp(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : i === 4 ? zp(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = t9.exec(r)) ? new Ur(e[1], e[2], e[3], 1) : (e = i9.exec(r)) ? new Ur(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = r9.exec(r)) ? zp(e[1], e[2], e[3], e[4]) : (e = n9.exec(r)) ? zp(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = s9.exec(r)) ? lE(e[1], e[2] / 100, e[3] / 100, 1) : (e = a9.exec(r)) ? lE(e[1], e[2] / 100, e[3] / 100, e[4]) : iE.hasOwnProperty(r) ? sE(iE[r]) : r === "transparent" ? new Ur(NaN, NaN, NaN, 0) : null;
}
function sE(r) {
  return new Ur(r >> 16 & 255, r >> 8 & 255, r & 255, 1);
}
function zp(r, e, i, n) {
  return n <= 0 && (r = e = i = NaN), new Ur(r, e, i, n);
}
function u9(r) {
  return r instanceof qd || (r = md(r)), r ? (r = r.rgb(), new Ur(r.r, r.g, r.b, r.opacity)) : new Ur();
}
function zb(r, e, i, n) {
  return arguments.length === 1 ? u9(r) : new Ur(r, e, i, n ?? 1);
}
function Ur(r, e, i, n) {
  this.r = +r, this.g = +e, this.b = +i, this.opacity = +n;
}
t1(Ur, zb, pN(qd, {
  brighter(r) {
    return r = r == null ? Am : Math.pow(Am, r), new Ur(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? pd : Math.pow(pd, r), new Ur(this.r * r, this.g * r, this.b * r, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Ur(ml(this.r), ml(this.g), ml(this.b), Cm(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: aE,
  // Deprecated! Use color.formatHex.
  formatHex: aE,
  formatHex8: c9,
  formatRgb: oE,
  toString: oE
}));
function aE() {
  return `#${sl(this.r)}${sl(this.g)}${sl(this.b)}`;
}
function c9() {
  return `#${sl(this.r)}${sl(this.g)}${sl(this.b)}${sl((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function oE() {
  const r = Cm(this.opacity);
  return `${r === 1 ? "rgb(" : "rgba("}${ml(this.r)}, ${ml(this.g)}, ${ml(this.b)}${r === 1 ? ")" : `, ${r})`}`;
}
function Cm(r) {
  return isNaN(r) ? 1 : Math.max(0, Math.min(1, r));
}
function ml(r) {
  return Math.max(0, Math.min(255, Math.round(r) || 0));
}
function sl(r) {
  return r = ml(r), (r < 16 ? "0" : "") + r.toString(16);
}
function lE(r, e, i, n) {
  return n <= 0 ? r = e = i = NaN : i <= 0 || i >= 1 ? r = e = NaN : e <= 0 && (r = NaN), new Wn(r, e, i, n);
}
function fN(r) {
  if (r instanceof Wn) return new Wn(r.h, r.s, r.l, r.opacity);
  if (r instanceof qd || (r = md(r)), !r) return new Wn();
  if (r instanceof Wn) return r;
  r = r.rgb();
  var e = r.r / 255, i = r.g / 255, n = r.b / 255, s = Math.min(e, i, n), a = Math.max(e, i, n), o = NaN, l = a - s, u = (a + s) / 2;
  return l ? (e === a ? o = (i - n) / l + (i < n) * 6 : i === a ? o = (n - e) / l + 2 : o = (e - i) / l + 4, l /= u < 0.5 ? a + s : 2 - a - s, o *= 60) : l = u > 0 && u < 1 ? 0 : o, new Wn(o, l, u, r.opacity);
}
function h9(r, e, i, n) {
  return arguments.length === 1 ? fN(r) : new Wn(r, e, i, n ?? 1);
}
function Wn(r, e, i, n) {
  this.h = +r, this.s = +e, this.l = +i, this.opacity = +n;
}
t1(Wn, h9, pN(qd, {
  brighter(r) {
    return r = r == null ? Am : Math.pow(Am, r), new Wn(this.h, this.s, this.l * r, this.opacity);
  },
  darker(r) {
    return r = r == null ? pd : Math.pow(pd, r), new Wn(this.h, this.s, this.l * r, this.opacity);
  },
  rgb() {
    var r = this.h % 360 + (this.h < 0) * 360, e = isNaN(r) || isNaN(this.s) ? 0 : this.s, i = this.l, n = i + (i < 0.5 ? i : 1 - i) * e, s = 2 * i - n;
    return new Ur(
      s0(r >= 240 ? r - 240 : r + 120, s, n),
      s0(r, s, n),
      s0(r < 120 ? r + 240 : r - 120, s, n),
      this.opacity
    );
  },
  clamp() {
    return new Wn(uE(this.h), jp(this.s), jp(this.l), Cm(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const r = Cm(this.opacity);
    return `${r === 1 ? "hsl(" : "hsla("}${uE(this.h)}, ${jp(this.s) * 100}%, ${jp(this.l) * 100}%${r === 1 ? ")" : `, ${r})`}`;
  }
}));
function uE(r) {
  return r = (r || 0) % 360, r < 0 ? r + 360 : r;
}
function jp(r) {
  return Math.max(0, Math.min(1, r || 0));
}
function s0(r, e, i) {
  return (r < 60 ? e + (i - e) * r / 60 : r < 180 ? i : r < 240 ? e + (i - e) * (240 - r) / 60 : e) * 255;
}
const mN = (r) => () => r;
function d9(r, e) {
  return function(i) {
    return r + i * e;
  };
}
function p9(r, e, i) {
  return r = Math.pow(r, i), e = Math.pow(e, i) - r, i = 1 / i, function(n) {
    return Math.pow(r + n * e, i);
  };
}
function f9(r) {
  return (r = +r) == 1 ? gN : function(e, i) {
    return i - e ? p9(e, i, r) : mN(isNaN(e) ? i : e);
  };
}
function gN(r, e) {
  var i = e - r;
  return i ? d9(r, i) : mN(isNaN(r) ? e : r);
}
const cE = function r(e) {
  var i = f9(e);
  function n(s, a) {
    var o = i((s = zb(s)).r, (a = zb(a)).r), l = i(s.g, a.g), u = i(s.b, a.b), c = gN(s.opacity, a.opacity);
    return function(h) {
      return s.r = o(h), s.g = l(h), s.b = u(h), s.opacity = c(h), s + "";
    };
  }
  return n.gamma = r, n;
}(1);
function Ka(r, e) {
  return r = +r, e = +e, function(i) {
    return r * (1 - i) + e * i;
  };
}
var jb = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, a0 = new RegExp(jb.source, "g");
function m9(r) {
  return function() {
    return r;
  };
}
function g9(r) {
  return function(e) {
    return r(e) + "";
  };
}
function y9(r, e) {
  var i = jb.lastIndex = a0.lastIndex = 0, n, s, a, o = -1, l = [], u = [];
  for (r = r + "", e = e + ""; (n = jb.exec(r)) && (s = a0.exec(e)); )
    (a = s.index) > i && (a = e.slice(i, a), l[o] ? l[o] += a : l[++o] = a), (n = n[0]) === (s = s[0]) ? l[o] ? l[o] += s : l[++o] = s : (l[++o] = null, u.push({ i: o, x: Ka(n, s) })), i = a0.lastIndex;
  return i < e.length && (a = e.slice(i), l[o] ? l[o] += a : l[++o] = a), l.length < 2 ? u[0] ? g9(u[0].x) : m9(e) : (e = u.length, function(c) {
    for (var h = 0, d; h < e; ++h) l[(d = u[h]).i] = d.x(c);
    return l.join("");
  });
}
var hE = 180 / Math.PI, yN = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function vN(r, e, i, n, s, a) {
  var o, l, u;
  return (o = Math.sqrt(r * r + e * e)) && (r /= o, e /= o), (u = r * i + e * n) && (i -= r * u, n -= e * u), (l = Math.sqrt(i * i + n * n)) && (i /= l, n /= l, u /= l), r * n < e * i && (r = -r, e = -e, u = -u, o = -o), {
    translateX: s,
    translateY: a,
    rotate: Math.atan2(e, r) * hE,
    skewX: Math.atan(u) * hE,
    scaleX: o,
    scaleY: l
  };
}
var Vp;
function v9(r) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(r + "");
  return e.isIdentity ? yN : vN(e.a, e.b, e.c, e.d, e.e, e.f);
}
function b9(r) {
  return r == null || (Vp || (Vp = document.createElementNS("http://www.w3.org/2000/svg", "g")), Vp.setAttribute("transform", r), !(r = Vp.transform.baseVal.consolidate())) ? yN : (r = r.matrix, vN(r.a, r.b, r.c, r.d, r.e, r.f));
}
function bN(r, e, i, n) {
  function s(c) {
    return c.length ? c.pop() + " " : "";
  }
  function a(c, h, d, p, f, m) {
    if (c !== d || h !== p) {
      var y = f.push("translate(", null, e, null, i);
      m.push({ i: y - 4, x: Ka(c, d) }, { i: y - 2, x: Ka(h, p) });
    } else (d || p) && f.push("translate(" + d + e + p + i);
  }
  function o(c, h, d, p) {
    c !== h ? (c - h > 180 ? h += 360 : h - c > 180 && (c += 360), p.push({ i: d.push(s(d) + "rotate(", null, n) - 2, x: Ka(c, h) })) : h && d.push(s(d) + "rotate(" + h + n);
  }
  function l(c, h, d, p) {
    c !== h ? p.push({ i: d.push(s(d) + "skewX(", null, n) - 2, x: Ka(c, h) }) : h && d.push(s(d) + "skewX(" + h + n);
  }
  function u(c, h, d, p, f, m) {
    if (c !== d || h !== p) {
      var y = f.push(s(f) + "scale(", null, ",", null, ")");
      m.push({ i: y - 4, x: Ka(c, d) }, { i: y - 2, x: Ka(h, p) });
    } else (d !== 1 || p !== 1) && f.push(s(f) + "scale(" + d + "," + p + ")");
  }
  return function(c, h) {
    var d = [], p = [];
    return c = r(c), h = r(h), a(c.translateX, c.translateY, h.translateX, h.translateY, d, p), o(c.rotate, h.rotate, d, p), l(c.skewX, h.skewX, d, p), u(c.scaleX, c.scaleY, h.scaleX, h.scaleY, d, p), c = h = null, function(f) {
      for (var m = -1, y = p.length, v; ++m < y; ) d[(v = p[m]).i] = v.x(f);
      return d.join("");
    };
  };
}
var x9 = bN(v9, "px, ", "px)", "deg)"), _9 = bN(b9, ", ", ")", ")"), T9 = 1e-12;
function dE(r) {
  return ((r = Math.exp(r)) + 1 / r) / 2;
}
function w9(r) {
  return ((r = Math.exp(r)) - 1 / r) / 2;
}
function S9(r) {
  return ((r = Math.exp(2 * r)) - 1) / (r + 1);
}
const E9 = function r(e, i, n) {
  function s(a, o) {
    var l = a[0], u = a[1], c = a[2], h = o[0], d = o[1], p = o[2], f = h - l, m = d - u, y = f * f + m * m, v, g;
    if (y < T9)
      g = Math.log(p / c) / e, v = function(M) {
        return [
          l + M * f,
          u + M * m,
          c * Math.exp(e * M * g)
        ];
      };
    else {
      var _ = Math.sqrt(y), x = (p * p - c * c + n * y) / (2 * c * i * _), b = (p * p - c * c - n * y) / (2 * p * i * _), T = Math.log(Math.sqrt(x * x + 1) - x), E = Math.log(Math.sqrt(b * b + 1) - b);
      g = (E - T) / e, v = function(M) {
        var C = M * g, S = dE(T), w = c / (i * _) * (S * S9(e * C + T) - w9(T));
        return [
          l + w * f,
          u + w * m,
          c * S / dE(e * C + T)
        ];
      };
    }
    return v.duration = g * 1e3 * e / Math.SQRT2, v;
  }
  return s.rho = function(a) {
    var o = Math.max(1e-3, +a), l = o * o, u = l * l;
    return r(o, l, u);
  }, s;
}(Math.SQRT2, 2, 4);
function M9(r) {
  for (var e = r.length / 6 | 0, i = new Array(e), n = 0; n < e; ) i[n] = "#" + r.slice(n * 6, ++n * 6);
  return i;
}
const xN = M9("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
function Rm(r) {
  "@babel/helpers - typeof";
  return Rm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Rm(r);
}
var A9 = /^\s+/, C9 = /\s+$/;
function rt(r, e) {
  if (r = r || "", e = e || {}, r instanceof rt)
    return r;
  if (!(this instanceof rt))
    return new rt(r, e);
  var i = R9(r);
  this._originalInput = r, this._r = i.r, this._g = i.g, this._b = i.b, this._a = i.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e.format || i.format, this._gradientType = e.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = i.ok;
}
rt.prototype = {
  isDark: function() {
    return this.getBrightness() < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  isValid: function() {
    return this._ok;
  },
  getOriginalInput: function() {
    return this._originalInput;
  },
  getFormat: function() {
    return this._format;
  },
  getAlpha: function() {
    return this._a;
  },
  getBrightness: function() {
    var r = this.toRgb();
    return (r.r * 299 + r.g * 587 + r.b * 114) / 1e3;
  },
  getLuminance: function() {
    var r = this.toRgb(), e, i, n, s, a, o;
    return e = r.r / 255, i = r.g / 255, n = r.b / 255, e <= 0.03928 ? s = e / 12.92 : s = Math.pow((e + 0.055) / 1.055, 2.4), i <= 0.03928 ? a = i / 12.92 : a = Math.pow((i + 0.055) / 1.055, 2.4), n <= 0.03928 ? o = n / 12.92 : o = Math.pow((n + 0.055) / 1.055, 2.4), 0.2126 * s + 0.7152 * a + 0.0722 * o;
  },
  setAlpha: function(r) {
    return this._a = _N(r), this._roundA = Math.round(100 * this._a) / 100, this;
  },
  toHsv: function() {
    var r = fE(this._r, this._g, this._b);
    return {
      h: r.h * 360,
      s: r.s,
      v: r.v,
      a: this._a
    };
  },
  toHsvString: function() {
    var r = fE(this._r, this._g, this._b), e = Math.round(r.h * 360), i = Math.round(r.s * 100), n = Math.round(r.v * 100);
    return this._a == 1 ? "hsv(" + e + ", " + i + "%, " + n + "%)" : "hsva(" + e + ", " + i + "%, " + n + "%, " + this._roundA + ")";
  },
  toHsl: function() {
    var r = pE(this._r, this._g, this._b);
    return {
      h: r.h * 360,
      s: r.s,
      l: r.l,
      a: this._a
    };
  },
  toHslString: function() {
    var r = pE(this._r, this._g, this._b), e = Math.round(r.h * 360), i = Math.round(r.s * 100), n = Math.round(r.l * 100);
    return this._a == 1 ? "hsl(" + e + ", " + i + "%, " + n + "%)" : "hsla(" + e + ", " + i + "%, " + n + "%, " + this._roundA + ")";
  },
  toHex: function(r) {
    return mE(this._r, this._g, this._b, r);
  },
  toHexString: function(r) {
    return "#" + this.toHex(r);
  },
  toHex8: function(r) {
    return O9(this._r, this._g, this._b, this._a, r);
  },
  toHex8String: function(r) {
    return "#" + this.toHex8(r);
  },
  toRgb: function() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function() {
    return {
      r: Math.round(fi(this._r, 255) * 100) + "%",
      g: Math.round(fi(this._g, 255) * 100) + "%",
      b: Math.round(fi(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(fi(this._r, 255) * 100) + "%, " + Math.round(fi(this._g, 255) * 100) + "%, " + Math.round(fi(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(fi(this._r, 255) * 100) + "%, " + Math.round(fi(this._g, 255) * 100) + "%, " + Math.round(fi(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function() {
    return this._a === 0 ? "transparent" : this._a < 1 ? !1 : W9[mE(this._r, this._g, this._b, !0)] || !1;
  },
  toFilter: function(r) {
    var e = "#" + gE(this._r, this._g, this._b, this._a), i = e, n = this._gradientType ? "GradientType = 1, " : "";
    if (r) {
      var s = rt(r);
      i = "#" + gE(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + n + "startColorstr=" + e + ",endColorstr=" + i + ")";
  },
  toString: function(r) {
    var e = !!r;
    r = r || this._format;
    var i = !1, n = this._a < 1 && this._a >= 0, s = !e && n && (r === "hex" || r === "hex6" || r === "hex3" || r === "hex4" || r === "hex8" || r === "name");
    return s ? r === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (r === "rgb" && (i = this.toRgbString()), r === "prgb" && (i = this.toPercentageRgbString()), (r === "hex" || r === "hex6") && (i = this.toHexString()), r === "hex3" && (i = this.toHexString(!0)), r === "hex4" && (i = this.toHex8String(!0)), r === "hex8" && (i = this.toHex8String()), r === "name" && (i = this.toName()), r === "hsl" && (i = this.toHslString()), r === "hsv" && (i = this.toHsvString()), i || this.toHexString());
  },
  clone: function() {
    return rt(this.toString());
  },
  _applyModification: function(r, e) {
    var i = r.apply(null, [this].concat([].slice.call(e)));
    return this._r = i._r, this._g = i._g, this._b = i._b, this.setAlpha(i._a), this;
  },
  lighten: function() {
    return this._applyModification(U9, arguments);
  },
  brighten: function() {
    return this._applyModification(F9, arguments);
  },
  darken: function() {
    return this._applyModification(B9, arguments);
  },
  desaturate: function() {
    return this._applyModification(D9, arguments);
  },
  saturate: function() {
    return this._applyModification(L9, arguments);
  },
  greyscale: function() {
    return this._applyModification(k9, arguments);
  },
  spin: function() {
    return this._applyModification(z9, arguments);
  },
  _applyCombination: function(r, e) {
    return r.apply(null, [this].concat([].slice.call(e)));
  },
  analogous: function() {
    return this._applyCombination(G9, arguments);
  },
  complement: function() {
    return this._applyCombination(j9, arguments);
  },
  monochromatic: function() {
    return this._applyCombination(H9, arguments);
  },
  splitcomplement: function() {
    return this._applyCombination(V9, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function() {
    return this._applyCombination(yE, [3]);
  },
  tetrad: function() {
    return this._applyCombination(yE, [4]);
  }
};
rt.fromRatio = function(r, e) {
  if (Rm(r) == "object") {
    var i = {};
    for (var n in r)
      r.hasOwnProperty(n) && (n === "a" ? i[n] = r[n] : i[n] = jh(r[n]));
    r = i;
  }
  return rt(r, e);
};
function R9(r) {
  var e = {
    r: 0,
    g: 0,
    b: 0
  }, i = 1, n = null, s = null, a = null, o = !1, l = !1;
  return typeof r == "string" && (r = K9(r)), Rm(r) == "object" && (Is(r.r) && Is(r.g) && Is(r.b) ? (e = N9(r.r, r.g, r.b), o = !0, l = String(r.r).substr(-1) === "%" ? "prgb" : "rgb") : Is(r.h) && Is(r.s) && Is(r.v) ? (n = jh(r.s), s = jh(r.v), e = I9(r.h, n, s), o = !0, l = "hsv") : Is(r.h) && Is(r.s) && Is(r.l) && (n = jh(r.s), a = jh(r.l), e = P9(r.h, n, a), o = !0, l = "hsl"), r.hasOwnProperty("a") && (i = r.a)), i = _N(i), {
    ok: o,
    format: r.format || l,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: i
  };
}
function N9(r, e, i) {
  return {
    r: fi(r, 255) * 255,
    g: fi(e, 255) * 255,
    b: fi(i, 255) * 255
  };
}
function pE(r, e, i) {
  r = fi(r, 255), e = fi(e, 255), i = fi(i, 255);
  var n = Math.max(r, e, i), s = Math.min(r, e, i), a, o, l = (n + s) / 2;
  if (n == s)
    a = o = 0;
  else {
    var u = n - s;
    switch (o = l > 0.5 ? u / (2 - n - s) : u / (n + s), n) {
      case r:
        a = (e - i) / u + (e < i ? 6 : 0);
        break;
      case e:
        a = (i - r) / u + 2;
        break;
      case i:
        a = (r - e) / u + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s: o,
    l
  };
}
function P9(r, e, i) {
  var n, s, a;
  r = fi(r, 360), e = fi(e, 100), i = fi(i, 100);
  function o(c, h, d) {
    return d < 0 && (d += 1), d > 1 && (d -= 1), d < 1 / 6 ? c + (h - c) * 6 * d : d < 1 / 2 ? h : d < 2 / 3 ? c + (h - c) * (2 / 3 - d) * 6 : c;
  }
  if (e === 0)
    n = s = a = i;
  else {
    var l = i < 0.5 ? i * (1 + e) : i + e - i * e, u = 2 * i - l;
    n = o(u, l, r + 1 / 3), s = o(u, l, r), a = o(u, l, r - 1 / 3);
  }
  return {
    r: n * 255,
    g: s * 255,
    b: a * 255
  };
}
function fE(r, e, i) {
  r = fi(r, 255), e = fi(e, 255), i = fi(i, 255);
  var n = Math.max(r, e, i), s = Math.min(r, e, i), a, o, l = n, u = n - s;
  if (o = n === 0 ? 0 : u / n, n == s)
    a = 0;
  else {
    switch (n) {
      case r:
        a = (e - i) / u + (e < i ? 6 : 0);
        break;
      case e:
        a = (i - r) / u + 2;
        break;
      case i:
        a = (r - e) / u + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s: o,
    v: l
  };
}
function I9(r, e, i) {
  r = fi(r, 360) * 6, e = fi(e, 100), i = fi(i, 100);
  var n = Math.floor(r), s = r - n, a = i * (1 - e), o = i * (1 - s * e), l = i * (1 - (1 - s) * e), u = n % 6, c = [i, o, a, a, l, i][u], h = [l, i, i, o, a, a][u], d = [a, a, l, i, i, o][u];
  return {
    r: c * 255,
    g: h * 255,
    b: d * 255
  };
}
function mE(r, e, i, n) {
  var s = [Yn(Math.round(r).toString(16)), Yn(Math.round(e).toString(16)), Yn(Math.round(i).toString(16))];
  return n && s[0].charAt(0) == s[0].charAt(1) && s[1].charAt(0) == s[1].charAt(1) && s[2].charAt(0) == s[2].charAt(1) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) : s.join("");
}
function O9(r, e, i, n, s) {
  var a = [Yn(Math.round(r).toString(16)), Yn(Math.round(e).toString(16)), Yn(Math.round(i).toString(16)), Yn(TN(n))];
  return s && a[0].charAt(0) == a[0].charAt(1) && a[1].charAt(0) == a[1].charAt(1) && a[2].charAt(0) == a[2].charAt(1) && a[3].charAt(0) == a[3].charAt(1) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("");
}
function gE(r, e, i, n) {
  var s = [Yn(TN(n)), Yn(Math.round(r).toString(16)), Yn(Math.round(e).toString(16)), Yn(Math.round(i).toString(16))];
  return s.join("");
}
rt.equals = function(r, e) {
  return !r || !e ? !1 : rt(r).toRgbString() == rt(e).toRgbString();
};
rt.random = function() {
  return rt.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function D9(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.s -= e / 100, i.s = Ag(i.s), rt(i);
}
function L9(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.s += e / 100, i.s = Ag(i.s), rt(i);
}
function k9(r) {
  return rt(r).desaturate(100);
}
function U9(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.l += e / 100, i.l = Ag(i.l), rt(i);
}
function F9(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toRgb();
  return i.r = Math.max(0, Math.min(255, i.r - Math.round(255 * -(e / 100)))), i.g = Math.max(0, Math.min(255, i.g - Math.round(255 * -(e / 100)))), i.b = Math.max(0, Math.min(255, i.b - Math.round(255 * -(e / 100)))), rt(i);
}
function B9(r, e) {
  e = e === 0 ? 0 : e || 10;
  var i = rt(r).toHsl();
  return i.l -= e / 100, i.l = Ag(i.l), rt(i);
}
function z9(r, e) {
  var i = rt(r).toHsl(), n = (i.h + e) % 360;
  return i.h = n < 0 ? 360 + n : n, rt(i);
}
function j9(r) {
  var e = rt(r).toHsl();
  return e.h = (e.h + 180) % 360, rt(e);
}
function yE(r, e) {
  if (isNaN(e) || e <= 0)
    throw new Error("Argument to polyad must be a positive number");
  for (var i = rt(r).toHsl(), n = [rt(r)], s = 360 / e, a = 1; a < e; a++)
    n.push(rt({
      h: (i.h + a * s) % 360,
      s: i.s,
      l: i.l
    }));
  return n;
}
function V9(r) {
  var e = rt(r).toHsl(), i = e.h;
  return [rt(r), rt({
    h: (i + 72) % 360,
    s: e.s,
    l: e.l
  }), rt({
    h: (i + 216) % 360,
    s: e.s,
    l: e.l
  })];
}
function G9(r, e, i) {
  e = e || 6, i = i || 30;
  var n = rt(r).toHsl(), s = 360 / i, a = [rt(r)];
  for (n.h = (n.h - (s * e >> 1) + 720) % 360; --e; )
    n.h = (n.h + s) % 360, a.push(rt(n));
  return a;
}
function H9(r, e) {
  e = e || 6;
  for (var i = rt(r).toHsv(), n = i.h, s = i.s, a = i.v, o = [], l = 1 / e; e--; )
    o.push(rt({
      h: n,
      s,
      v: a
    })), a = (a + l) % 1;
  return o;
}
rt.mix = function(r, e, i) {
  i = i === 0 ? 0 : i || 50;
  var n = rt(r).toRgb(), s = rt(e).toRgb(), a = i / 100, o = {
    r: (s.r - n.r) * a + n.r,
    g: (s.g - n.g) * a + n.g,
    b: (s.b - n.b) * a + n.b,
    a: (s.a - n.a) * a + n.a
  };
  return rt(o);
};
rt.readability = function(r, e) {
  var i = rt(r), n = rt(e);
  return (Math.max(i.getLuminance(), n.getLuminance()) + 0.05) / (Math.min(i.getLuminance(), n.getLuminance()) + 0.05);
};
rt.isReadable = function(r, e, i) {
  var n = rt.readability(r, e), s, a;
  switch (a = !1, s = Z9(i), s.level + s.size) {
    case "AAsmall":
    case "AAAlarge":
      a = n >= 4.5;
      break;
    case "AAlarge":
      a = n >= 3;
      break;
    case "AAAsmall":
      a = n >= 7;
      break;
  }
  return a;
};
rt.mostReadable = function(r, e, i) {
  var n = null, s = 0, a, o, l, u;
  i = i || {}, o = i.includeFallbackColors, l = i.level, u = i.size;
  for (var c = 0; c < e.length; c++)
    a = rt.readability(r, e[c]), a > s && (s = a, n = rt(e[c]));
  return rt.isReadable(r, n, {
    level: l,
    size: u
  }) || !o ? n : (i.includeFallbackColors = !1, rt.mostReadable(r, ["#fff", "#000"], i));
};
var Vb = rt.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
}, W9 = rt.hexNames = q9(Vb);
function q9(r) {
  var e = {};
  for (var i in r)
    r.hasOwnProperty(i) && (e[r[i]] = i);
  return e;
}
function _N(r) {
  return r = parseFloat(r), (isNaN(r) || r < 0 || r > 1) && (r = 1), r;
}
function fi(r, e) {
  X9(r) && (r = "100%");
  var i = Y9(r);
  return r = Math.min(e, Math.max(0, parseFloat(r))), i && (r = parseInt(r * e, 10) / 100), Math.abs(r - e) < 1e-6 ? 1 : r % e / parseFloat(e);
}
function Ag(r) {
  return Math.min(1, Math.max(0, r));
}
function rn(r) {
  return parseInt(r, 16);
}
function X9(r) {
  return typeof r == "string" && r.indexOf(".") != -1 && parseFloat(r) === 1;
}
function Y9(r) {
  return typeof r == "string" && r.indexOf("%") != -1;
}
function Yn(r) {
  return r.length == 1 ? "0" + r : "" + r;
}
function jh(r) {
  return r <= 1 && (r = r * 100 + "%"), r;
}
function TN(r) {
  return Math.round(parseFloat(r) * 255).toString(16);
}
function vE(r) {
  return rn(r) / 255;
}
var Ln = function() {
  var r = "[-\\+]?\\d+%?", e = "[-\\+]?\\d*\\.\\d+%?", i = "(?:" + e + ")|(?:" + r + ")", n = "[\\s|\\(]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")\\s*\\)?", s = "[\\s|\\(]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(i),
    rgb: new RegExp("rgb" + n),
    rgba: new RegExp("rgba" + s),
    hsl: new RegExp("hsl" + n),
    hsla: new RegExp("hsla" + s),
    hsv: new RegExp("hsv" + n),
    hsva: new RegExp("hsva" + s),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function Is(r) {
  return !!Ln.CSS_UNIT.exec(r);
}
function K9(r) {
  r = r.replace(A9, "").replace(C9, "").toLowerCase();
  var e = !1;
  if (Vb[r])
    r = Vb[r], e = !0;
  else if (r == "transparent")
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  var i;
  return (i = Ln.rgb.exec(r)) ? {
    r: i[1],
    g: i[2],
    b: i[3]
  } : (i = Ln.rgba.exec(r)) ? {
    r: i[1],
    g: i[2],
    b: i[3],
    a: i[4]
  } : (i = Ln.hsl.exec(r)) ? {
    h: i[1],
    s: i[2],
    l: i[3]
  } : (i = Ln.hsla.exec(r)) ? {
    h: i[1],
    s: i[2],
    l: i[3],
    a: i[4]
  } : (i = Ln.hsv.exec(r)) ? {
    h: i[1],
    s: i[2],
    v: i[3]
  } : (i = Ln.hsva.exec(r)) ? {
    h: i[1],
    s: i[2],
    v: i[3],
    a: i[4]
  } : (i = Ln.hex8.exec(r)) ? {
    r: rn(i[1]),
    g: rn(i[2]),
    b: rn(i[3]),
    a: vE(i[4]),
    format: e ? "name" : "hex8"
  } : (i = Ln.hex6.exec(r)) ? {
    r: rn(i[1]),
    g: rn(i[2]),
    b: rn(i[3]),
    format: e ? "name" : "hex"
  } : (i = Ln.hex4.exec(r)) ? {
    r: rn(i[1] + "" + i[1]),
    g: rn(i[2] + "" + i[2]),
    b: rn(i[3] + "" + i[3]),
    a: vE(i[4] + "" + i[4]),
    format: e ? "name" : "hex8"
  } : (i = Ln.hex3.exec(r)) ? {
    r: rn(i[1] + "" + i[1]),
    g: rn(i[2] + "" + i[2]),
    b: rn(i[3] + "" + i[3]),
    format: e ? "name" : "hex"
  } : !1;
}
function Z9(r) {
  var e, i;
  return r = r || {
    level: "AA",
    size: "small"
  }, e = (r.level || "AA").toUpperCase(), i = (r.size || "small").toLowerCase(), e !== "AA" && e !== "AAA" && (e = "AA"), i !== "small" && i !== "large" && (i = "small"), {
    level: e,
    size: i
  };
}
function Gb(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Q9(r) {
  if (Array.isArray(r)) return r;
}
function $9(r) {
  if (Array.isArray(r)) return Gb(r);
}
function wN(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function J9(r) {
  if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function SN(r, e, i) {
  return e = vc(e), oH(r, i1() ? Reflect.construct(e, i || [], vc(r).constructor) : e.apply(r, i));
}
function eH(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function EN(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function o0(r, e) {
  return r.get(wN(r, e));
}
function bE(r, e, i) {
  eH(r, e), e.set(r, i);
}
function xE(r, e, i) {
  return r.set(wN(r, e), i), i;
}
function MN(r, e, i) {
  if (i1()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return s;
}
function tH(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, RN(n.key), n);
  }
}
function AN(r, e, i) {
  return e && tH(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function Cg(r, e, i) {
  return (e = RN(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function Hb() {
  return Hb = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(r, e, i) {
    var n = lH(r, e);
    if (n) {
      var s = Object.getOwnPropertyDescriptor(n, e);
      return s.get ? s.get.call(arguments.length < 3 ? r : i) : s.value;
    }
  }, Hb.apply(null, arguments);
}
function vc(r) {
  return vc = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, vc(r);
}
function CN(r, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  r.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: r,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(r, "prototype", {
    writable: !1
  }), e && Wb(r, e);
}
function i1() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (i1 = function() {
    return !!r;
  })();
}
function iH(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function rH(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function nH() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function sH() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _E(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function aH(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? _E(Object(i), !0).forEach(function(n) {
      Cg(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : _E(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function oH(r, e) {
  if (e && (typeof e == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return J9(r);
}
function Wb(r, e) {
  return Wb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Wb(r, e);
}
function Qh(r, e) {
  return Q9(r) || rH(r, e) || NN(r, e) || nH();
}
function lH(r, e) {
  for (; !{}.hasOwnProperty.call(r, e) && (r = vc(r)) !== null; ) ;
  return r;
}
function l0(r, e, i, n) {
  var s = Hb(vc(r.prototype), e, i);
  return typeof s == "function" ? function(a) {
    return s.apply(i, a);
  } : s;
}
function jn(r) {
  return $9(r) || iH(r) || NN(r) || sH();
}
function uH(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function RN(r) {
  var e = uH(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function qb(r) {
  "@babel/helpers - typeof";
  return qb = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, qb(r);
}
function NN(r, e) {
  if (r) {
    if (typeof r == "string") return Gb(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Gb(r, e) : void 0;
  }
}
var PN = function(r) {
  r instanceof Array ? r.forEach(PN) : (r.map && r.map.dispose(), r.dispose());
}, IN = function(r) {
  r.geometry && r.geometry.dispose(), r.material && PN(r.material), r.texture && r.texture.dispose(), r.children && r.children.forEach(IN);
}, Xb = function(r) {
  for (; r.children.length; ) {
    var e = r.children[0];
    r.remove(e), IN(e);
  }
}, u0 = /* @__PURE__ */ new WeakMap(), Gp = /* @__PURE__ */ new WeakMap(), fh = /* @__PURE__ */ function(r) {
  function e(i) {
    var n, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = s.dataBindAttr, o = a === void 0 ? "__data" : a, l = s.objBindAttr, u = l === void 0 ? "__threeObj" : l;
    return EN(this, e), n = SN(this, e), Cg(n, "scene", void 0), bE(n, u0, void 0), bE(n, Gp, void 0), n.scene = i, xE(u0, n, o), xE(Gp, n, u), n.onRemoveObj(function() {
    }), n;
  }
  return CN(e, r), AN(e, [{
    key: "onCreateObj",
    value: function(i) {
      var n = this;
      return l0(e, "onCreateObj", this)([function(s) {
        var a = i(s);
        return s[o0(Gp, n)] = a, a[o0(u0, n)] = s, n.scene.add(a), a;
      }]), this;
    }
  }, {
    key: "onRemoveObj",
    value: function(i) {
      var n = this;
      return l0(e, "onRemoveObj", this)([function(s, a) {
        var o = l0(e, "getData", n)([s]);
        i(s, a), n.scene.remove(s), Xb(s), delete o[o0(Gp, n)];
      }]), this;
    }
  }]);
}($G), mh = function(r) {
  return isNaN(r) ? parseInt(rt(r).toHex(), 16) : r;
}, c0 = function(r) {
  return isNaN(r) ? rt(r).getAlpha() : 1;
}, cH = e1(xN);
function TE(r, e, i) {
  !e || typeof i != "string" || r.filter(function(n) {
    return !n[i];
  }).forEach(function(n) {
    n[i] = cH(e(n));
  });
}
function hH(r, e) {
  var i = r.nodes, n = r.links, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = s.nodeFilter, o = a === void 0 ? function() {
    return !0;
  } : a, l = s.onLoopError, u = l === void 0 ? function(f) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(f.join(" -> "), ".");
  } : l, c = {};
  i.forEach(function(f) {
    return c[e(f)] = {
      data: f,
      out: [],
      depth: -1,
      skip: !o(f)
    };
  }), n.forEach(function(f) {
    var m = f.source, y = f.target, v = b(m), g = b(y);
    if (!c.hasOwnProperty(v)) throw "Missing source node with id: ".concat(v);
    if (!c.hasOwnProperty(g)) throw "Missing target node with id: ".concat(g);
    var _ = c[v], x = c[g];
    _.out.push(x);
    function b(T) {
      return qb(T) === "object" ? e(T) : T;
    }
  });
  var h = [];
  p(Object.values(c));
  var d = Object.assign.apply(Object, [{}].concat(jn(Object.entries(c).filter(function(f) {
    var m = Qh(f, 2), y = m[1];
    return !y.skip;
  }).map(function(f) {
    var m = Qh(f, 2), y = m[0], v = m[1];
    return Cg({}, y, v.depth);
  }))));
  return d;
  function p(f) {
    for (var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, v = function() {
      var x = f[g];
      if (m.indexOf(x) !== -1) {
        var b = [].concat(jn(m.slice(m.indexOf(x))), [x]).map(function(T) {
          return e(T.data);
        });
        return h.some(function(T) {
          return T.length === b.length && T.every(function(E, M) {
            return E === b[M];
          });
        }) || (h.push(b), u(b)), 1;
      }
      y > x.depth && (x.depth = y, p(x.out, [].concat(jn(m), [x]), y + (x.skip ? 0 : 1)));
    }, g = 0, _ = f.length; g < _; g++)
      v();
  }
}
var dt = window.THREE ? window.THREE : {
  Group: nl,
  Mesh: kr,
  MeshLambertMaterial: Yj,
  Color: Ut,
  BufferGeometry: cn,
  BufferAttribute: _n,
  Matrix4: ui,
  Vector3: Y,
  SphereGeometry: CR,
  CylinderGeometry: Sg,
  TubeGeometry: z_,
  ConeGeometry: B_,
  Line: Ij,
  LineBasicMaterial: ER,
  QuadraticBezierCurve3: U_,
  CubicBezierCurve3: AR,
  Box3: Rl
}, wE = {
  graph: xV,
  forcelayout: eG
}, dH = 2, h0 = new dt.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute", Hp = new dt.BufferGeometry().applyMatrix4 ? "applyMatrix4" : "applyMatrix", pH = Pl({
  props: {
    jsonUrl: {
      onChange: function(r, e) {
        var i = this;
        r && !e.fetchingJson && (e.fetchingJson = !0, e.onLoading(), fetch(r).then(function(n) {
          return n.json();
        }).then(function(n) {
          e.fetchingJson = !1, e.onFinishLoading(n), i.graphData(n);
        }));
      },
      triggerUpdate: !1
    },
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        e.engineRunning = !1;
      }
    },
    numDimensions: {
      default: 3,
      onChange: function(r, e) {
        var i = e.d3ForceLayout.force("charge");
        i && i.strength(r > 2 ? -60 : -30), r < 3 && n(e.graphData.nodes, "z"), r < 2 && n(e.graphData.nodes, "y");
        function n(s, a) {
          s.forEach(function(o) {
            delete o[a], delete o["v".concat(a)];
          });
        }
      }
    },
    dagMode: {
      onChange: function(r, e) {
        !r && e.forceEngine === "d3" && (e.graphData.nodes || []).forEach(function(i) {
          return i.fx = i.fy = i.fz = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function(r) {
        return !0;
      }
    },
    onDagError: {
      triggerUpdate: !1
    },
    nodeRelSize: {
      default: 4
    },
    // volume per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val"
    },
    nodeResolution: {
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeColor: {
      default: "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      default: 0.75
    },
    nodeVisibility: {
      default: !0
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      default: !1
    },
    nodePositionUpdate: {
      triggerUpdate: !1
    },
    // custom function to call for updating the node's position. Signature: (threeObj, { x, y, z}, node). If the function returns a truthy value, the regular node position update will not run.
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0
    },
    linkColor: {
      default: "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      default: 0.2
    },
    linkWidth: {},
    // Rounded to nearest decimal. For falsy values use dimensionless line with 1px regardless of distance.
    linkResolution: {
      default: 6
    },
    // how many radial segments in each line tube's geometry
    linkCurvature: {
      default: 0,
      triggerUpdate: !1
    },
    // line curvature radius (0: straight, 1: semi-circle)
    linkCurveRotation: {
      default: 0,
      triggerUpdate: !1
    },
    // line curve rotation along the line axis (0: interection with XY plane, PI: upside down)
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      default: !1
    },
    linkPositionUpdate: {
      triggerUpdate: !1
    },
    // custom function to call for updating the link's position. Signature: (threeObj, { start: { x, y, z},  end: { x, y, z }}, link). If the function returns a truthy value, the regular link position update will not run.
    linkDirectionalArrowLength: {
      default: 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      default: 0.5,
      triggerUpdate: !1
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01,
      triggerUpdate: !1
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    forceEngine: {
      default: "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      default: 0
    },
    d3AlphaDecay: {
      default: 0.0228,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.alphaDecay(r);
      }
    },
    d3AlphaTarget: {
      default: 0,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.alphaTarget(r);
      }
    },
    d3VelocityDecay: {
      default: 0.4,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.d3ForceLayout.velocityDecay(r);
      }
    },
    ngraphPhysics: {
      default: {
        // defaults from https://github.com/anvaka/ngraph.physics.simulator/blob/master/index.js
        timeStep: 20,
        gravity: -1.2,
        theta: 0.8,
        springLength: 30,
        springCoefficient: 8e-4,
        dragCoefficient: 0.02
      }
    },
    warmupTicks: {
      default: 0,
      triggerUpdate: !1
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      default: 1 / 0,
      triggerUpdate: !1
    },
    cooldownTime: {
      default: 15e3,
      triggerUpdate: !1
    },
    // ms
    onLoading: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishLoading: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineTick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineStop: {
      default: function() {
      },
      triggerUpdate: !1
    }
  },
  methods: {
    refresh: function(r) {
      return r._flushObjects = !0, r._rerender(), this;
    },
    // Expose d3 forces for external manipulation
    d3Force: function(r, e, i) {
      return i === void 0 ? r.d3ForceLayout.force(e) : (r.d3ForceLayout.force(e, i), this);
    },
    d3ReheatSimulation: function(r) {
      return r.d3ForceLayout.alpha(1), this.resetCountdown(), this;
    },
    // reset cooldown state
    resetCountdown: function(r) {
      return r.cntTicks = 0, r.startTickTime = /* @__PURE__ */ new Date(), r.engineRunning = !0, this;
    },
    tickFrame: function(r) {
      var e = r.forceEngine !== "ngraph";
      return r.engineRunning && i(), n(), s(), this;
      function i() {
        ++r.cntTicks > r.cooldownTicks || /* @__PURE__ */ new Date() - r.startTickTime > r.cooldownTime || e && r.d3AlphaMin > 0 && r.d3ForceLayout.alpha() < r.d3AlphaMin ? (r.engineRunning = !1, r.onEngineStop()) : (r.layout[e ? "tick" : "step"](), r.onEngineTick());
        var a = tt(r.nodeThreeObjectExtend);
        r.nodeDataMapper.entries().forEach(function(d) {
          var p = Qh(d, 2), f = p[0], m = p[1];
          if (m) {
            var y = e ? f : r.layout.getNodePosition(f[r.nodeId]), v = a(f);
            (!r.nodePositionUpdate || !r.nodePositionUpdate(v ? m.children[0] : m, {
              x: y.x,
              y: y.y,
              z: y.z
            }, f) || v) && (m.position.x = y.x, m.position.y = y.y || 0, m.position.z = y.z || 0);
          }
        });
        var o = tt(r.linkWidth), l = tt(r.linkCurvature), u = tt(r.linkCurveRotation), c = tt(r.linkThreeObjectExtend);
        r.linkDataMapper.entries().forEach(function(d) {
          var p = Qh(d, 2), f = p[0], m = p[1];
          if (m) {
            var y = e ? f : r.layout.getLinkPosition(r.layout.graph.getLink(f.source, f.target).id), v = y[e ? "source" : "from"], g = y[e ? "target" : "to"];
            if (!(!v || !g || !v.hasOwnProperty("x") || !g.hasOwnProperty("x"))) {
              h(f);
              var _ = c(f);
              if (!(r.linkPositionUpdate && r.linkPositionUpdate(
                _ ? m.children[1] : m,
                // pass child custom object if extending the default
                {
                  start: {
                    x: v.x,
                    y: v.y,
                    z: v.z
                  },
                  end: {
                    x: g.x,
                    y: g.y,
                    z: g.z
                  }
                },
                f
              ) && !_)) {
                var x = 30, b = f.__curve, T = m.children.length ? m.children[0] : m;
                if (T.type === "Line") {
                  if (b) {
                    var E = b.getPoints(x);
                    T.geometry.getAttribute("position").array.length !== E.length * 3 && T.geometry[h0]("position", new dt.BufferAttribute(new Float32Array(E.length * 3), 3)), T.geometry.setFromPoints(E);
                  } else {
                    var M = T.geometry.getAttribute("position");
                    (!M || !M.array || M.array.length !== 6) && T.geometry[h0]("position", M = new dt.BufferAttribute(new Float32Array(2 * 3), 3)), M.array[0] = v.x, M.array[1] = v.y || 0, M.array[2] = v.z || 0, M.array[3] = g.x, M.array[4] = g.y || 0, M.array[5] = g.z || 0, M.needsUpdate = !0;
                  }
                  T.geometry.computeBoundingSphere();
                } else if (T.type === "Mesh")
                  if (b) {
                    T.geometry.type.match(/^Tube(Buffer)?Geometry$/) || (T.position.set(0, 0, 0), T.rotation.set(0, 0, 0), T.scale.set(1, 1, 1));
                    var C = Math.ceil(o(f) * 10) / 10, S = C / 2, w = new dt.TubeGeometry(b, x, S, r.linkResolution, !1);
                    T.geometry.dispose(), T.geometry = w;
                  } else {
                    if (!T.geometry.type.match(/^Cylinder(Buffer)?Geometry$/)) {
                      var R = Math.ceil(o(f) * 10) / 10, O = R / 2, P = new dt.CylinderGeometry(O, O, 1, r.linkResolution, 1, !1);
                      P[Hp](new dt.Matrix4().makeTranslation(0, 1 / 2, 0)), P[Hp](new dt.Matrix4().makeRotationX(Math.PI / 2)), T.geometry.dispose(), T.geometry = P;
                    }
                    var A = new dt.Vector3(v.x, v.y || 0, v.z || 0), D = new dt.Vector3(g.x, g.y || 0, g.z || 0), L = A.distanceTo(D);
                    T.position.x = A.x, T.position.y = A.y, T.position.z = A.z, T.scale.z = L, T.parent.localToWorld(D), T.lookAt(D);
                  }
              }
            }
          }
        });
        function h(d) {
          var p = e ? d : r.layout.getLinkPosition(r.layout.graph.getLink(d.source, d.target).id), f = p[e ? "source" : "from"], m = p[e ? "target" : "to"];
          if (!(!f || !m || !f.hasOwnProperty("x") || !m.hasOwnProperty("x"))) {
            var y = l(d);
            if (!y)
              d.__curve = null;
            else {
              var v = new dt.Vector3(f.x, f.y || 0, f.z || 0), g = new dt.Vector3(m.x, m.y || 0, m.z || 0), _ = v.distanceTo(g), x, b = u(d);
              if (_ > 0) {
                var T = m.x - f.x, E = m.y - f.y || 0, M = new dt.Vector3().subVectors(g, v), C = M.clone().multiplyScalar(y).cross(T !== 0 || E !== 0 ? new dt.Vector3(0, 0, 1) : new dt.Vector3(0, 1, 0)).applyAxisAngle(M.normalize(), b).add(new dt.Vector3().addVectors(v, g).divideScalar(2));
                x = new dt.QuadraticBezierCurve3(v, C, g);
              } else {
                var S = y * 70, w = -b, R = w + Math.PI / 2;
                x = new dt.CubicBezierCurve3(v, new dt.Vector3(S * Math.cos(R), S * Math.sin(R), 0).add(v), new dt.Vector3(S * Math.cos(w), S * Math.sin(w), 0).add(v), g);
              }
              d.__curve = x;
            }
          }
        }
      }
      function n() {
        var a = tt(r.linkDirectionalArrowRelPos), o = tt(r.linkDirectionalArrowLength), l = tt(r.nodeVal);
        r.arrowDataMapper.entries().forEach(function(u) {
          var c = Qh(u, 2), h = c[0], d = c[1];
          if (d) {
            var p = e ? h : r.layout.getLinkPosition(r.layout.graph.getLink(h.source, h.target).id), f = p[e ? "source" : "from"], m = p[e ? "target" : "to"];
            if (!(!f || !m || !f.hasOwnProperty("x") || !m.hasOwnProperty("x"))) {
              var y = Math.cbrt(Math.max(0, l(f) || 1)) * r.nodeRelSize, v = Math.cbrt(Math.max(0, l(m) || 1)) * r.nodeRelSize, g = o(h), _ = a(h), x = h.__curve ? function(S) {
                return h.__curve.getPoint(S);
              } : function(S) {
                var w = function(R, O, P, A) {
                  return O[R] + (P[R] - O[R]) * A || 0;
                };
                return {
                  x: w("x", f, m, S),
                  y: w("y", f, m, S),
                  z: w("z", f, m, S)
                };
              }, b = h.__curve ? h.__curve.getLength() : Math.sqrt(["x", "y", "z"].map(function(S) {
                return Math.pow((m[S] || 0) - (f[S] || 0), 2);
              }).reduce(function(S, w) {
                return S + w;
              }, 0)), T = y + g + (b - y - v - g) * _, E = x(T / b), M = x((T - g) / b);
              ["x", "y", "z"].forEach(function(S) {
                return d.position[S] = M[S];
              });
              var C = MN(dt.Vector3, jn(["x", "y", "z"].map(function(S) {
                return E[S];
              })));
              d.parent.localToWorld(C), d.lookAt(C);
            }
          }
        });
      }
      function s() {
        var a = tt(r.linkDirectionalParticleSpeed);
        r.graphData.links.forEach(function(o) {
          var l = r.particlesDataMapper.getObj(o), u = l && l.children, c = o.__singleHopPhotonsObj && o.__singleHopPhotonsObj.children;
          if (!((!c || !c.length) && (!u || !u.length))) {
            var h = e ? o : r.layout.getLinkPosition(r.layout.graph.getLink(o.source, o.target).id), d = h[e ? "source" : "from"], p = h[e ? "target" : "to"];
            if (!(!d || !p || !d.hasOwnProperty("x") || !p.hasOwnProperty("x"))) {
              var f = a(o), m = o.__curve ? function(v) {
                return o.__curve.getPoint(v);
              } : function(v) {
                var g = function(_, x, b, T) {
                  return x[_] + (b[_] - x[_]) * T || 0;
                };
                return {
                  x: g("x", d, p, v),
                  y: g("y", d, p, v),
                  z: g("z", d, p, v)
                };
              }, y = [].concat(jn(u || []), jn(c || []));
              y.forEach(function(v, g) {
                var _ = v.parent.__linkThreeObjType === "singleHopPhotons";
                if (v.hasOwnProperty("__progressRatio") || (v.__progressRatio = _ ? 0 : g / u.length), v.__progressRatio += f, v.__progressRatio >= 1)
                  if (!_)
                    v.__progressRatio = v.__progressRatio % 1;
                  else {
                    v.parent.remove(v), Xb(v);
                    return;
                  }
                var x = v.__progressRatio, b = m(x);
                ["x", "y", "z"].forEach(function(T) {
                  return v.position[T] = b[T];
                });
              });
            }
          }
        });
      }
    },
    emitParticle: function(r, e) {
      if (e && r.graphData.links.includes(e)) {
        if (!e.__singleHopPhotonsObj) {
          var i = new dt.Group();
          i.__linkThreeObjType = "singleHopPhotons", e.__singleHopPhotonsObj = i, r.graphScene.add(i);
        }
        var n = tt(r.linkDirectionalParticleWidth), s = Math.ceil(n(e) * 10) / 10 / 2, a = r.linkDirectionalParticleResolution, o = new dt.SphereGeometry(s, a, a), l = tt(r.linkColor), u = tt(r.linkDirectionalParticleColor), c = u(e) || l(e) || "#f0f0f0", h = new dt.Color(mh(c)), d = r.linkOpacity * 3, p = new dt.MeshLambertMaterial({
          color: h,
          transparent: !0,
          opacity: d
        });
        e.__singleHopPhotonsObj.add(new dt.Mesh(o, p));
      }
      return this;
    },
    getGraphBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      };
      if (!r.initialised) return null;
      var i = function n(s) {
        var a = [];
        if (s.geometry) {
          s.geometry.computeBoundingBox();
          var o = new dt.Box3();
          o.copy(s.geometry.boundingBox).applyMatrix4(s.matrixWorld), a.push(o);
        }
        return a.concat.apply(a, jn((s.children || []).filter(
          function(l) {
            return !l.hasOwnProperty("__graphObjType") || l.__graphObjType === "node" && e(l.__data);
          }
          // exclude filtered out nodes
        ).map(n)));
      }(r.graphScene);
      return i.length ? Object.assign.apply(Object, jn(["x", "y", "z"].map(function(n) {
        return Cg({}, n, [Fb(i, function(s) {
          return s.min[n];
        }), Ub(i, function(s) {
          return s.max[n];
        })]);
      }))) : null;
    }
  },
  stateInit: function() {
    return {
      d3ForceLayout: GR().force("link", zR()).force("charge", HR()).force("center", OR()).force("dagRadial", null).stop(),
      engineRunning: !1
    };
  },
  init: function(r, e) {
    e.graphScene = r, e.nodeDataMapper = new fh(r, {
      objBindAttr: "__threeObj"
    }), e.linkDataMapper = new fh(r, {
      objBindAttr: "__lineObj"
    }), e.arrowDataMapper = new fh(r, {
      objBindAttr: "__arrowObj"
    }), e.particlesDataMapper = new fh(r, {
      objBindAttr: "__photonsObj"
    });
  },
  update: function(r, e) {
    var i = function(G) {
      return G.some(function(z) {
        return e.hasOwnProperty(z);
      });
    };
    if (r.engineRunning = !1, typeof r.onUpdate == "function" && r.onUpdate(), r.nodeAutoColorBy !== null && i(["nodeAutoColorBy", "graphData", "nodeColor"]) && TE(r.graphData.nodes, tt(r.nodeAutoColorBy), r.nodeColor), r.linkAutoColorBy !== null && i(["linkAutoColorBy", "graphData", "linkColor"]) && TE(r.graphData.links, tt(r.linkAutoColorBy), r.linkColor), r._flushObjects || i(["graphData", "nodeThreeObject", "nodeThreeObjectExtend", "nodeVal", "nodeColor", "nodeVisibility", "nodeRelSize", "nodeResolution", "nodeOpacity"])) {
      var n = tt(r.nodeThreeObject), s = tt(r.nodeThreeObjectExtend), a = tt(r.nodeVal), o = tt(r.nodeColor), l = tt(r.nodeVisibility), u = {}, c = {};
      (r._flushObjects || i([
        // recreate objects if any of these props have changed
        "nodeThreeObject",
        "nodeThreeObjectExtend"
      ])) && r.nodeDataMapper.clear(), r.nodeDataMapper.onCreateObj(function(G) {
        var z = n(G), K = s(G);
        z && r.nodeThreeObject === z && (z = z.clone());
        var ne;
        return z && !K ? ne = z : (ne = new dt.Mesh(), ne.__graphDefaultObj = !0, z && K && ne.add(z)), ne.__graphObjType = "node", ne;
      }).onUpdateObj(function(G, z) {
        if (G.__graphDefaultObj) {
          var K = a(z) || 1, ne = Math.cbrt(K) * r.nodeRelSize, oe = r.nodeResolution;
          (!G.geometry.type.match(/^Sphere(Buffer)?Geometry$/) || G.geometry.parameters.radius !== ne || G.geometry.parameters.widthSegments !== oe) && (u.hasOwnProperty(K) || (u[K] = new dt.SphereGeometry(ne, oe, oe)), G.geometry.dispose(), G.geometry = u[K]);
          var pe = o(z), xe = new dt.Color(mh(pe || "#ffffaa")), Re = r.nodeOpacity * c0(pe);
          (G.material.type !== "MeshLambertMaterial" || !G.material.color.equals(xe) || G.material.opacity !== Re) && (c.hasOwnProperty(pe) || (c[pe] = new dt.MeshLambertMaterial({
            color: xe,
            transparent: !0,
            opacity: Re
          })), G.material.dispose(), G.material = c[pe]);
        }
      }).digest(r.graphData.nodes.filter(l));
    }
    if (r._flushObjects || i(["graphData", "linkThreeObject", "linkThreeObjectExtend", "linkMaterial", "linkColor", "linkWidth", "linkVisibility", "linkResolution", "linkOpacity", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution"])) {
      var h = tt(r.linkThreeObject), d = tt(r.linkThreeObjectExtend), p = tt(r.linkMaterial), f = tt(r.linkVisibility), m = tt(r.linkColor), y = tt(r.linkWidth), v = {}, g = {}, _ = {}, x = r.graphData.links.filter(f);
      if ((r._flushObjects || i([
        // recreate objects if any of these props have changed
        "linkThreeObject",
        "linkThreeObjectExtend",
        "linkWidth"
      ])) && r.linkDataMapper.clear(), r.linkDataMapper.onRemoveObj(function(G) {
        var z = G.__data && G.__data.__singleHopPhotonsObj;
        z && (z.parent.remove(z), Xb(z), delete G.__data.__singleHopPhotonsObj);
      }).onCreateObj(function(G) {
        var z = h(G), K = d(G);
        z && r.linkThreeObject === z && (z = z.clone());
        var ne;
        if (!z || K) {
          var oe = !!y(G);
          if (oe)
            ne = new dt.Mesh();
          else {
            var pe = new dt.BufferGeometry();
            pe[h0]("position", new dt.BufferAttribute(new Float32Array(2 * 3), 3)), ne = new dt.Line(pe);
          }
        }
        var xe;
        return z ? K ? (xe = new dt.Group(), xe.__graphDefaultObj = !0, xe.add(ne), xe.add(z)) : xe = z : (xe = ne, xe.__graphDefaultObj = !0), xe.renderOrder = 10, xe.__graphObjType = "link", xe;
      }).onUpdateObj(function(G, z) {
        if (G.__graphDefaultObj) {
          var K = G.children.length ? G.children[0] : G, ne = Math.ceil(y(z) * 10) / 10, oe = !!ne;
          if (oe) {
            var pe = ne / 2, xe = r.linkResolution;
            if (!K.geometry.type.match(/^Cylinder(Buffer)?Geometry$/) || K.geometry.parameters.radiusTop !== pe || K.geometry.parameters.radialSegments !== xe) {
              if (!v.hasOwnProperty(ne)) {
                var Re = new dt.CylinderGeometry(pe, pe, 1, xe, 1, !1);
                Re[Hp](new dt.Matrix4().makeTranslation(0, 1 / 2, 0)), Re[Hp](new dt.Matrix4().makeRotationX(Math.PI / 2)), v[ne] = Re;
              }
              K.geometry.dispose(), K.geometry = v[ne];
            }
          }
          var nt = p(z);
          if (nt)
            K.material = nt;
          else {
            var fe = m(z), gt = new dt.Color(mh(fe || "#f0f0f0")), Q = r.linkOpacity * c0(fe), Gt = oe ? "MeshLambertMaterial" : "LineBasicMaterial";
            if (K.material.type !== Gt || !K.material.color.equals(gt) || K.material.opacity !== Q) {
              var Qe = oe ? g : _;
              Qe.hasOwnProperty(fe) || (Qe[fe] = new dt[Gt]({
                color: gt,
                transparent: Q < 1,
                opacity: Q,
                depthWrite: Q >= 1
                // Prevent transparency issues
              })), K.material.dispose(), K.material = Qe[fe];
            }
          }
        }
      }).digest(x), r.linkDirectionalArrowLength || e.hasOwnProperty("linkDirectionalArrowLength")) {
        var b = tt(r.linkDirectionalArrowLength), T = tt(r.linkDirectionalArrowColor);
        r.arrowDataMapper.onCreateObj(function() {
          var G = new dt.Mesh(void 0, new dt.MeshLambertMaterial({
            transparent: !0
          }));
          return G.__linkThreeObjType = "arrow", G;
        }).onUpdateObj(function(G, z) {
          var K = b(z), ne = r.linkDirectionalArrowResolution;
          if (!G.geometry.type.match(/^Cone(Buffer)?Geometry$/) || G.geometry.parameters.height !== K || G.geometry.parameters.radialSegments !== ne) {
            var oe = new dt.ConeGeometry(K * 0.25, K, ne);
            oe.translate(0, K / 2, 0), oe.rotateX(Math.PI / 2), G.geometry.dispose(), G.geometry = oe;
          }
          var pe = T(z) || m(z) || "#f0f0f0";
          G.material.color = new dt.Color(mh(pe)), G.material.opacity = r.linkOpacity * 3 * c0(pe);
        }).digest(x.filter(b));
      }
      if (r.linkDirectionalParticles || e.hasOwnProperty("linkDirectionalParticles")) {
        var E = tt(r.linkDirectionalParticles), M = tt(r.linkDirectionalParticleWidth), C = tt(r.linkDirectionalParticleColor), S = {}, w = {};
        r.particlesDataMapper.onCreateObj(function() {
          var G = new dt.Group();
          return G.__linkThreeObjType = "photons", G.__photonDataMapper = new fh(G), G;
        }).onUpdateObj(function(G, z) {
          var K = Math.round(Math.abs(E(z))), ne = !!G.children.length && G.children[0], oe = Math.ceil(M(z) * 10) / 10 / 2, pe = r.linkDirectionalParticleResolution, xe;
          ne && ne.geometry.parameters.radius === oe && ne.geometry.parameters.widthSegments === pe ? xe = ne.geometry : (w.hasOwnProperty(oe) || (w[oe] = new dt.SphereGeometry(oe, pe, pe)), xe = w[oe], ne && ne.geometry.dispose());
          var Re = C(z) || m(z) || "#f0f0f0", nt = new dt.Color(mh(Re)), fe = r.linkOpacity * 3, gt;
          ne && ne.material.color.equals(nt) && ne.material.opacity === fe ? gt = ne.material : (S.hasOwnProperty(Re) || (S[Re] = new dt.MeshLambertMaterial({
            color: nt,
            transparent: !0,
            opacity: fe
          })), gt = S[Re], ne && ne.material.dispose()), G.__photonDataMapper.id(function(Q) {
            return Q.idx;
          }).onCreateObj(function() {
            return new dt.Mesh(xe, gt);
          }).onUpdateObj(function(Q) {
            Q.geometry = xe, Q.material = gt;
          }).digest(jn(new Array(K)).map(function(Q, Gt) {
            return {
              idx: Gt
            };
          }));
        }).digest(x.filter(E));
      }
    }
    if (r._flushObjects = !1, i(["graphData", "nodeId", "linkSource", "linkTarget", "numDimensions", "forceEngine", "dagMode", "dagNodeFilter", "dagLevelDistance"])) {
      r.engineRunning = !1, r.graphData.links.forEach(function(G) {
        G.source = G[r.linkSource], G.target = G[r.linkTarget];
      });
      var R = r.forceEngine !== "ngraph", O;
      if (R) {
        (O = r.d3ForceLayout).stop().alpha(1).numDimensions(r.numDimensions).nodes(r.graphData.nodes);
        var P = r.d3ForceLayout.force("link");
        P && P.id(function(G) {
          return G[r.nodeId];
        }).links(r.graphData.links);
        var A = r.dagMode && hH(r.graphData, function(G) {
          return G[r.nodeId];
        }, {
          nodeFilter: r.dagNodeFilter,
          onLoopError: r.onDagError || void 0
        }), D = Math.max.apply(Math, jn(Object.values(A || []))), L = r.dagLevelDistance || r.graphData.nodes.length / (D || 1) * dH * (["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? 0.7 : 1);
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(e.dagMode)) {
          var H = ["lr", "rl"].includes(e.dagMode) ? "fx" : ["td", "bu"].includes(e.dagMode) ? "fy" : "fz";
          r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(G) {
            return delete G[H];
          });
        }
        if (["lr", "rl", "td", "bu", "zin", "zout"].includes(r.dagMode)) {
          var V = ["rl", "td", "zout"].includes(r.dagMode), X = function(G) {
            return (A[G[r.nodeId]] - D / 2) * L * (V ? -1 : 1);
          }, F = ["lr", "rl"].includes(r.dagMode) ? "fx" : ["td", "bu"].includes(r.dagMode) ? "fy" : "fz";
          r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(G) {
            return G[F] = X(G);
          });
        }
        r.d3ForceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? WR(function(G) {
          var z = A[G[r.nodeId]] || -1;
          return (r.dagMode === "radialin" ? D - z : z) * L;
        }).strength(function(G) {
          return r.dagNodeFilter(G) ? 1 : 0;
        }) : null);
      } else {
        var B = wE.graph();
        r.graphData.nodes.forEach(function(G) {
          B.addNode(G[r.nodeId]);
        }), r.graphData.links.forEach(function(G) {
          B.addLink(G.source, G.target);
        }), O = wE.forcelayout(B, aH({
          dimensions: r.numDimensions
        }, r.ngraphPhysics)), O.graph = B;
      }
      for (var W = 0; W < r.warmupTicks && !(R && r.d3AlphaMin > 0 && r.d3ForceLayout.alpha() < r.d3AlphaMin); W++)
        O[R ? "tick" : "step"]();
      r.layout = O, this.resetCountdown();
    }
    r.engineRunning = !0, r.onFinishUpdate();
  }
});
function fH(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = /* @__PURE__ */ function(s) {
    function a() {
      var o;
      EN(this, a);
      for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
        u[c] = arguments[c];
      return o = SN(this, a, [].concat(u)), o.__kapsuleInstance = MN(r, [].concat(jn(i ? [o] : []), u)), o;
    }
    return CN(a, s), AN(a);
  }(e);
  return Object.keys(r()).forEach(function(s) {
    return n.prototype[s] = function() {
      var a, o = (a = this.__kapsuleInstance)[s].apply(a, arguments);
      return o === this.__kapsuleInstance ? this : o;
    };
  }), n;
}
var mH = window.THREE ? window.THREE : {
  Group: nl
}, Ou = fH(pH, mH.Group, !0);
if (typeof AFRAME > "u")
  throw new Error("Component attempted to register before AFRAME was available.");
var d0 = function(r) {
  return typeof r == "string" ? JSON.parse(r) : r;
}, kn = function(r) {
  if (typeof r == "function") return r;
  var e = eval;
  try {
    var i = e("(" + r + ")");
    return i;
  } catch {
  }
  return null;
}, _i = function(r) {
  return isNaN(parseFloat(r)) ? kn(r) ? kn(r) : r : parseFloat(r);
};
AFRAME.components.hasOwnProperty("forcegraph") || AFRAME.registerComponent("forcegraph", {
  schema: {
    jsonUrl: {
      type: "string",
      default: ""
    },
    nodes: {
      parse: d0,
      default: []
    },
    links: {
      parse: d0,
      default: []
    },
    numDimensions: {
      type: "number",
      default: 3
    },
    dagMode: {
      type: "string",
      default: ""
    },
    dagLevelDistance: {
      type: "number",
      default: 0
    },
    dagNodeFilter: {
      parse: kn,
      default: function() {
        return !0;
      }
    },
    onDagError: {
      parse: kn,
      default: void 0
    },
    nodeRelSize: {
      type: "number",
      default: 4
    },
    // volume per val unit
    nodeId: {
      type: "string",
      default: "id"
    },
    nodeVal: {
      parse: _i,
      default: "val"
    },
    nodeResolution: {
      type: "number",
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeVisibility: {
      parse: _i,
      default: !0
    },
    nodeColor: {
      parse: _i,
      default: "color"
    },
    nodeAutoColorBy: {
      parse: _i,
      default: ""
    },
    // color nodes with the same field equally
    nodeOpacity: {
      type: "number",
      default: 0.75
    },
    nodeThreeObject: {
      parse: _i,
      default: null
    },
    nodeThreeObjectExtend: {
      parse: _i,
      default: !1
    },
    linkSource: {
      type: "string",
      default: "source"
    },
    linkTarget: {
      type: "string",
      default: "target"
    },
    linkVisibility: {
      parse: _i,
      default: !0
    },
    linkColor: {
      parse: _i,
      default: "color"
    },
    linkAutoColorBy: {
      parse: _i,
      default: ""
    },
    // color links with the same field equally
    linkOpacity: {
      type: "number",
      default: 0.2
    },
    linkWidth: {
      parse: _i,
      default: 0
    },
    linkResolution: {
      type: "number",
      default: 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      parse: _i,
      default: 0
    },
    linkCurveRotation: {
      parse: _i,
      default: 0
    },
    linkMaterial: {
      parse: _i,
      default: null
    },
    linkThreeObject: {
      parse: _i,
      default: null
    },
    linkThreeObjectExtend: {
      parse: _i,
      default: !1
    },
    linkPositionUpdate: {
      parse: kn,
      default: null
    },
    linkDirectionalArrowLength: {
      parse: _i,
      default: 0
    },
    linkDirectionalArrowColor: {
      parse: _i,
      default: null
    },
    linkDirectionalArrowRelPos: {
      parse: _i,
      default: 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      type: "number",
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      parse: _i,
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      parse: _i,
      default: 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      parse: _i,
      default: 0.5
    },
    linkDirectionalParticleColor: {
      parse: _i,
      default: null
    },
    linkDirectionalParticleResolution: {
      type: "number",
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    onNodeHover: {
      parse: kn,
      default: function() {
      }
    },
    onLinkHover: {
      parse: kn,
      default: function() {
      }
    },
    onNodeClick: {
      parse: kn,
      default: function() {
      }
    },
    onLinkClick: {
      parse: kn,
      default: function() {
      }
    },
    forceEngine: {
      type: "string",
      default: "d3"
    },
    // 'd3' or 'ngraph'
    d3AlphaMin: {
      type: "number",
      default: 0
    },
    d3AlphaDecay: {
      type: "number",
      default: 0.0228
    },
    d3VelocityDecay: {
      type: "number",
      default: 0.4
    },
    ngraphPhysics: {
      parse: d0,
      default: null
    },
    warmupTicks: {
      type: "int",
      default: 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      type: "int",
      default: 1e18
    },
    // Simulate infinity (int parser doesn't accept Infinity object)
    cooldownTime: {
      type: "int",
      default: 15e3
    },
    // ms
    onEngineTick: {
      parse: kn,
      default: function() {
      }
    },
    onEngineStop: {
      parse: kn,
      default: function() {
      }
    }
  },
  // Bind component methods
  getGraphBbox: function(r) {
    return this.forceGraph || (this.forceGraph = new Ou()), this.forceGraph.getGraphBbox(r);
  },
  emitParticle: function() {
    this.forceGraph || (this.forceGraph = new Ou());
    var r = this.forceGraph, e = r.emitParticle.apply(r, arguments);
    return e === r ? this : e;
  },
  d3Force: function() {
    this.forceGraph || (this.forceGraph = new Ou());
    var r = this.forceGraph, e = r.d3Force.apply(r, arguments);
    return e === r ? this : e;
  },
  d3ReheatSimulation: function() {
    return this.forceGraph && this.forceGraph.d3ReheatSimulation(), this;
  },
  refresh: function() {
    return this.forceGraph && this.forceGraph.refresh(), this;
  },
  init: function() {
    var r = this, e = this.state = {};
    e.infoEl = document.createElement("a-text"), e.infoEl.setAttribute("position", "0 -0.1 -1"), e.infoEl.setAttribute("width", 1), e.infoEl.setAttribute("align", "center"), e.infoEl.setAttribute("color", "lavender");
    var i = document.querySelector("a-entity[camera], a-camera");
    i.appendChild(e.infoEl), e.cameraObj = i.object3D.children.filter(function(n) {
      return n.type === "PerspectiveCamera";
    })[0], this.el.sceneEl.addEventListener("camera-set-active", function(n) {
      e.cameraObj = n.detail.cameraEl.components.camera.camera;
    }), this.forceGraph || (this.forceGraph = new Ou()), this.forceGraph.onFinishUpdate(function() {
      return r.el.setObject3D("forcegraphGroup", r.forceGraph);
    }).onLoading(function() {
      return e.infoEl.setAttribute("value", "Loading...");
    }).onFinishLoading(function() {
      return e.infoEl.setAttribute("value", "");
    }), this.el.addEventListener("raycaster-intersected", function(n) {
      return e.hoverDetail = n.detail;
    }), this.el.addEventListener("raycaster-intersected-cleared", function(n) {
      return e.hoverDetail = n.detail;
    }), this.el.addEventListener("click", function() {
      return e.hoverObj && r.data["on" + (e.hoverObj.__graphObjType === "node" ? "Node" : "Link") + "Click"](e.hoverObj.__data);
    });
  },
  remove: function() {
    this.state.infoEl.remove(), this.el.removeObject3D("forcegraphGroup");
  },
  update: function(r) {
    var e = this, i = this.data, n = AFRAME.utils.diff(i, r), s = ["jsonUrl", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeVisibility", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "forceEngine", "d3AlphaMin", "d3AphaDecay", "d3VelocityDecay", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"];
    s.filter(function(a) {
      return a in n;
    }).forEach(function(a) {
      e.forceGraph[a](i[a] !== "" ? i[a] : null);
    }), ("nodes" in n || "links" in n) && e.forceGraph.graphData({
      nodes: i.nodes,
      links: i.links
    });
  },
  tick: function(r, e) {
    for (var i = this.state, n = this.data, s = i.hoverDetail ? i.hoverDetail.getIntersection ? i.hoverDetail.getIntersection(this.el) : i.hoverDetail.intersection || void 0 : void 0, a = s ? s.object : void 0; a && !a.hasOwnProperty("__graphObjType"); ) a = a.parent;
    if (a !== i.hoverObj) {
      var o = i.hoverObj ? i.hoverObj.__graphObjType : null, l = i.hoverObj ? i.hoverObj.__data : null, u = a ? a.__graphObjType : null, c = a ? a.__data : null;
      o && o !== u && n["on" + (o === "node" ? "Node" : "Link") + "Hover"](null, l), u && n["on" + (u === "node" ? "Node" : "Link") + "Hover"](c, o === u ? l : null), i.hoverObj = a;
    }
    this.forceGraph.tickFrame();
  }
});
function Yb(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function gH(r) {
  if (Array.isArray(r)) return r;
}
function yH(r) {
  if (Array.isArray(r)) return Yb(r);
}
function Jf(r, e, i) {
  return (e = wH(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function vH(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function bH(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function xH() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _H() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function SE(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function EE(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? SE(Object(i), !0).forEach(function(n) {
      Jf(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : SE(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function Wp(r, e) {
  return gH(r) || bH(r, e) || ON(r, e) || xH();
}
function qp(r) {
  return yH(r) || vH(r) || ON(r) || _H();
}
function TH(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function wH(r) {
  var e = TH(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function ON(r, e) {
  if (r) {
    if (typeof r == "string") return Yb(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Yb(r, e) : void 0;
  }
}
var SH = Pl({
  props: {
    width: {},
    height: {},
    yOffset: {
      default: 1.5
    },
    // marker size units
    glScale: {
      default: 200
    },
    // gl units per marker width
    jsonUrl: {},
    graphData: {
      default: {
        nodes: [],
        links: []
      }
    },
    numDimensions: {
      default: 3
    },
    dagMode: {},
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function() {
        return !0;
      }
    },
    onDagError: {
      default: void 0
    },
    nodeRelSize: {
      default: 4
    },
    // volume per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val"
    },
    nodeResolution: {
      default: 8
    },
    // how many slice segments in the sphere's circumference
    nodeVisibility: {
      default: !0
    },
    nodeColor: {
      default: "color"
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      default: 0.75
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      default: !1
    },
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0
    },
    linkColor: {
      default: "color"
    },
    linkAutoColorBy: {},
    linkOpacity: {
      default: 0.2
    },
    linkWidth: {
      default: 0
    },
    linkResolution: {
      default: 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      default: 0
    },
    linkCurveRotation: {
      default: 0
    },
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      default: !1
    },
    linkPositionUpdate: {},
    linkDirectionalArrowLength: {
      default: 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      default: 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      default: 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      default: 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      default: 4
    },
    // how many slice segments in the particle sphere's circumference
    onNodeHover: {},
    onNodeClick: {},
    onLinkHover: {},
    onLinkClick: {},
    forceEngine: {
      default: "d3"
    },
    // d3 or ngraph
    d3AlphaMin: {
      default: 0
    },
    d3AlphaDecay: {
      default: 0.0228
    },
    d3VelocityDecay: {
      default: 0.4
    },
    ngraphPhysics: {},
    warmupTicks: {
      default: 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {},
    cooldownTime: {
      default: 15e3
    },
    // ms
    onEngineTick: {},
    onEngineStop: {}
  },
  methods: EE(EE({}, Object.assign.apply(Object, [{}].concat(qp(["getGraphBbox", "emitParticle", "d3Force", "d3ReheatSimulation", "refresh"].map(function(r) {
    return Jf({}, r, function(e) {
      for (var i = e.forcegraph.components.forcegraph, n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
        s[a - 1] = arguments[a];
      var o = i[r].apply(i, s);
      return o === i ? this : o;
    });
  }))))), {}, {
    _destructor: function() {
      this.graphData({
        nodes: [],
        links: []
      });
    }
  }),
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.markerAttrs, s = n === void 0 ? {
      preset: "hiro"
    } : n;
    r.innerHTML = "", e.container = document.createElement("div"), r.appendChild(e.container);
    var a = document.createElement("a-scene");
    a.setAttribute("embedded", ""), a.setAttribute("vr-mode-ui", "enabled: false"), a.setAttribute("arjs", "debugUIEnabled: false;");
    var o = document.createElement("a-marker");
    Object.entries(s).forEach(function(c) {
      var h = Wp(c, 2), d = h[0], p = h[1];
      return o.setAttribute(d, p);
    }), a.appendChild(o);
    var l;
    a.appendChild(l = document.createElement("a-entity")), l.setAttribute(
      "cursor"
      /*, 'rayOrigin: mouse'*/
    ), l.setAttribute("raycaster", "objects: [forcegraph]"), e.forcegraph = document.createElement("a-entity"), e.forcegraph.setAttribute("forcegraph", null), o.appendChild(e.forcegraph);
    var u = document.createElement("a-entity");
    u.setAttribute("camera", ""), a.appendChild(u), e.container.appendChild(a);
  },
  update: function(r, e) {
    e.hasOwnProperty("width") && r.width && (r.container.style.width = "".concat(r.width, "px")), e.hasOwnProperty("height") && r.height && (r.container.style.height = "".concat(r.height, "px")), e.hasOwnProperty("glScale") && r.forcegraph.setAttribute("scale", qp(new Array(3)).map(function() {
      return 1 / r.glScale;
    }).join(" ")), e.hasOwnProperty("yOffset") && r.forcegraph.setAttribute("position", "0 ".concat(r.yOffset, " 0"));
    var i = ["jsonUrl", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeVisibility", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "onNodeHover", "onNodeClick", "onLinkHover", "onLinkClick", "forceEngine", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"], n = Object.assign.apply(Object, [{}].concat(qp(Object.entries(r).filter(function(s) {
      var a = Wp(s, 2), o = a[0], l = a[1];
      return e.hasOwnProperty(o) && i.indexOf(o) !== -1 && l !== void 0 && l !== null;
    }).map(function(s) {
      var a = Wp(s, 2), o = a[0], l = a[1];
      return Jf({}, o, l);
    })), qp(Object.entries(r.graphData).map(function(s) {
      var a = Wp(s, 2), o = a[0], l = a[1];
      return Jf({}, o, l);
    }))));
    r.forcegraph.setAttribute("forcegraph", n);
  }
});
const Xu = new qs(), $s = new ke(), DN = new Y(), p0 = new ke(), em = new ke(), Nm = new Y(), Kb = new Y(), LN = new ui(), kN = new Y(), UN = new Y();
let Lr = null, ns = null;
const Js = [], lo = {
  NONE: -1,
  PAN: 0,
  ROTATE: 1
};
class EH extends Eg {
  constructor(e, i, n = null) {
    super(i, n), this.objects = e, this.recursive = !0, this.transformGroup = !1, this.rotateSpeed = 1, this.raycaster = new IR(), this.mouseButtons = { LEFT: ir.PAN, MIDDLE: ir.PAN, RIGHT: ir.ROTATE }, this.touches = { ONE: ia.PAN }, this._onPointerMove = MH.bind(this), this._onPointerDown = AH.bind(this), this._onPointerCancel = CH.bind(this), this._onContextMenu = RH.bind(this), n !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointerup", this._onPointerCancel), this.domElement.addEventListener("pointerleave", this._onPointerCancel), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointerup", this._onPointerCancel), this.domElement.removeEventListener("pointerleave", this._onPointerCancel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "auto", this.domElement.style.cursor = "";
  }
  dispose() {
    this.disconnect();
  }
  _updatePointer(e) {
    const i = this.domElement.getBoundingClientRect();
    $s.x = (e.clientX - i.left) / i.width * 2 - 1, $s.y = -(e.clientY - i.top) / i.height * 2 + 1;
  }
  _updateState(e) {
    let i;
    if (e.pointerType === "touch")
      i = this.touches.ONE;
    else
      switch (e.button) {
        case 0:
          i = this.mouseButtons.LEFT;
          break;
        case 1:
          i = this.mouseButtons.MIDDLE;
          break;
        case 2:
          i = this.mouseButtons.RIGHT;
          break;
        default:
          i = null;
      }
    switch (i) {
      case ir.PAN:
      case ia.PAN:
        this.state = lo.PAN;
        break;
      case ir.ROTATE:
      case ia.ROTATE:
        this.state = lo.ROTATE;
        break;
      default:
        this.state = lo.NONE;
    }
  }
  getRaycaster() {
    return console.warn("THREE.DragControls: getRaycaster() has been deprecated. Use controls.raycaster instead."), this.raycaster;
  }
  setObjects(e) {
    console.warn("THREE.DragControls: setObjects() has been deprecated. Use controls.objects instead."), this.objects = e;
  }
  getObjects() {
    return console.warn("THREE.DragControls: getObjects() has been deprecated. Use controls.objects instead."), this.objects;
  }
  activate() {
    console.warn("THREE.DragControls: activate() has been renamed to connect()."), this.connect();
  }
  deactivate() {
    console.warn("THREE.DragControls: deactivate() has been renamed to disconnect()."), this.disconnect();
  }
  set mode(e) {
    console.warn("THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.");
  }
  get mode() {
    console.warn("THREE.DragControls: The .mode property has been removed. Define the type of transformation via the .mouseButtons or .touches properties.");
  }
}
function MH(r) {
  const e = this.object, i = this.domElement, n = this.raycaster;
  if (this.enabled !== !1) {
    if (this._updatePointer(r), n.setFromCamera($s, e), Lr)
      this.state === lo.PAN ? n.ray.intersectPlane(Xu, Nm) && Lr.position.copy(Nm.sub(DN).applyMatrix4(LN)) : this.state === lo.ROTATE && (p0.subVectors($s, em).multiplyScalar(this.rotateSpeed), Lr.rotateOnWorldAxis(kN, p0.x), Lr.rotateOnWorldAxis(UN.normalize(), -p0.y)), this.dispatchEvent({ type: "drag", object: Lr }), em.copy($s);
    else if (r.pointerType === "mouse" || r.pointerType === "pen")
      if (Js.length = 0, n.setFromCamera($s, e), n.intersectObjects(this.objects, this.recursive, Js), Js.length > 0) {
        const s = Js[0].object;
        Xu.setFromNormalAndCoplanarPoint(e.getWorldDirection(Xu.normal), Kb.setFromMatrixPosition(s.matrixWorld)), ns !== s && ns !== null && (this.dispatchEvent({ type: "hoveroff", object: ns }), i.style.cursor = "auto", ns = null), ns !== s && (this.dispatchEvent({ type: "hoveron", object: s }), i.style.cursor = "pointer", ns = s);
      } else
        ns !== null && (this.dispatchEvent({ type: "hoveroff", object: ns }), i.style.cursor = "auto", ns = null);
    em.copy($s);
  }
}
function AH(r) {
  const e = this.object, i = this.domElement, n = this.raycaster;
  this.enabled !== !1 && (this._updatePointer(r), this._updateState(r), Js.length = 0, n.setFromCamera($s, e), n.intersectObjects(this.objects, this.recursive, Js), Js.length > 0 && (this.transformGroup === !0 ? Lr = FN(Js[0].object) : Lr = Js[0].object, Xu.setFromNormalAndCoplanarPoint(e.getWorldDirection(Xu.normal), Kb.setFromMatrixPosition(Lr.matrixWorld)), n.ray.intersectPlane(Xu, Nm) && (this.state === lo.PAN ? (LN.copy(Lr.parent.matrixWorld).invert(), DN.copy(Nm).sub(Kb.setFromMatrixPosition(Lr.matrixWorld))) : this.state === lo.ROTATE && (kN.set(0, 1, 0).applyQuaternion(e.quaternion).normalize(), UN.set(1, 0, 0).applyQuaternion(e.quaternion).normalize())), i.style.cursor = "move", this.dispatchEvent({ type: "dragstart", object: Lr })), em.copy($s));
}
function CH() {
  this.enabled !== !1 && (Lr && (this.dispatchEvent({ type: "dragend", object: Lr }), Lr = null), this.domElement.style.cursor = ns ? "pointer" : "auto", this.state = lo.NONE);
}
function RH(r) {
  this.enabled !== !1 && r.preventDefault();
}
function FN(r, e = null) {
  return r.isGroup && (e = r), r.parent === null ? e : FN(r.parent, e);
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Rg = "170", NH = 0, PH = 1, IH = 2, OH = 1, Xp = 3, bc = 0, Qn = 1, Yu = 2, xc = 0, uo = 1, Pm = 2, Im = 3, Om = 4, BN = 5, Ja = 100, zN = 101, jN = 102, DH = 103, LH = 104, VN = 200, GN = 201, HN = 202, WN = 203, Dm = 204, Lm = 205, qN = 206, XN = 207, YN = 208, KN = 209, ZN = 210, QN = 0, $N = 1, JN = 2, km = 3, e3 = 4, t3 = 5, i3 = 6, r3 = 7, Ng = 0, kH = 1, UH = 2, Ku = 0, FH = 1, BH = 2, zH = 3, jH = 4, VH = 6, GH = 7, r1 = 300, Tl = 301, _c = 302, Xd = 303, Yd = 304, Zb = 306, Um = 1e3, Du = 1001, Fm = 1002, yr = 1003, Qb = 1004, Zu = 1005, ln = 1006, $b = 1007, da = 1008, co = 1009, $h = 1010, Jh = 1011, Lu = 1012, wr = 1013, er = 1014, on = 1015, pa = 1016, HH = 1017, WH = 1018, Kd = 1020, n3 = 35902, qH = 1021, n1 = 1022, Bc = 1023, XH = 1024, YH = 1025, gl = 1026, Tc = 1027, s1 = 1028, a1 = 1029, gd = 1030, o1 = 1031, KH = 1032, l1 = 1033, f0 = 33776, tm = 33777, im = 33778, rm = 33779, ME = 35840, AE = 35841, CE = 35842, RE = 35843, NE = 36196, Jb = 37492, ex = 37496, tx = 37808, ix = 37809, rx = 37810, nx = 37811, sx = 37812, ax = 37813, ox = 37814, lx = 37815, ux = 37816, cx = 37817, hx = 37818, dx = 37819, px = 37820, fx = 37821, m0 = 36492, ZH = 36283, PE = 36284, IE = 36285, OE = 36286, yo = 0, QH = 1, wl = "", ct = "srgb", ho = "srgb-linear", s3 = "linear", yd = "srgb", $H = 0, Vo = 7680, JH = 7681, e7 = 7682, t7 = 7683, i7 = 34055, r7 = 34056, n7 = 5386, s7 = 512, a7 = 513, o7 = 514, l7 = 515, u7 = 516, c7 = 517, h7 = 518, mx = 519, a3 = 512, u1 = 513, o3 = 514, l3 = 515, u3 = 516, c3 = 517, h3 = 518, d3 = 519, Bm = 35044, ku = 35048, Kn = 2e3, Sl = 2001;
class zc {
  addEventListener(e, i) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(i) === -1 && n[e].push(i);
  }
  hasEventListener(e, i) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(i) !== -1;
  }
  removeEventListener(e, i) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e];
    if (n !== void 0) {
      const s = n.indexOf(i);
      s !== -1 && n.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const n = i.slice(0);
      for (let s = 0, a = n.length; s < a; s++)
        n[s].call(this, e);
      e.target = null;
    }
  }
}
const hr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let DE = 1234567;
const ed = Math.PI / 180, vd = 180 / Math.PI;
function fa() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (hr[r & 255] + hr[r >> 8 & 255] + hr[r >> 16 & 255] + hr[r >> 24 & 255] + "-" + hr[e & 255] + hr[e >> 8 & 255] + "-" + hr[e >> 16 & 15 | 64] + hr[e >> 24 & 255] + "-" + hr[i & 63 | 128] + hr[i >> 8 & 255] + "-" + hr[i >> 16 & 255] + hr[i >> 24 & 255] + hr[n & 255] + hr[n >> 8 & 255] + hr[n >> 16 & 255] + hr[n >> 24 & 255]).toLowerCase();
}
function tr(r, e, i) {
  return Math.max(e, Math.min(i, r));
}
function c1(r, e) {
  return (r % e + e) % e;
}
function d7(r, e, i, n, s) {
  return n + (r - e) * (s - n) / (i - e);
}
function p7(r, e, i) {
  return r !== e ? (i - r) / (e - r) : 0;
}
function td(r, e, i) {
  return (1 - i) * r + i * e;
}
function f7(r, e, i, n) {
  return td(r, e, 1 - Math.exp(-i * n));
}
function m7(r, e = 1) {
  return e - Math.abs(c1(r, e * 2) - e);
}
function g7(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * (3 - 2 * r));
}
function y7(r, e, i) {
  return r <= e ? 0 : r >= i ? 1 : (r = (r - e) / (i - e), r * r * r * (r * (r * 6 - 15) + 10));
}
function v7(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function b7(r, e) {
  return r + Math.random() * (e - r);
}
function x7(r) {
  return r * (0.5 - Math.random());
}
function _7(r) {
  r !== void 0 && (DE = r);
  let e = DE += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function T7(r) {
  return r * ed;
}
function w7(r) {
  return r * vd;
}
function S7(r) {
  return (r & r - 1) === 0 && r !== 0;
}
function E7(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function M7(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function A7(r, e, i, n, s) {
  const a = Math.cos, o = Math.sin, l = a(i / 2), u = o(i / 2), c = a((e + n) / 2), h = o((e + n) / 2), d = a((e - n) / 2), p = o((e - n) / 2), f = a((n - e) / 2), m = o((n - e) / 2);
  switch (s) {
    case "XYX":
      r.set(l * h, u * d, u * p, l * c);
      break;
    case "YZY":
      r.set(u * p, l * h, u * d, l * c);
      break;
    case "ZXZ":
      r.set(u * d, u * p, l * h, l * c);
      break;
    case "XZX":
      r.set(l * h, u * m, u * f, l * c);
      break;
    case "YXY":
      r.set(u * f, l * h, u * m, l * c);
      break;
    case "ZYZ":
      r.set(u * m, u * f, l * h, l * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function Mr(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function St(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const C7 = {
  DEG2RAD: ed,
  RAD2DEG: vd,
  generateUUID: fa,
  clamp: tr,
  euclideanModulo: c1,
  mapLinear: d7,
  inverseLerp: p7,
  lerp: td,
  damp: f7,
  pingpong: m7,
  smoothstep: g7,
  smootherstep: y7,
  randInt: v7,
  randFloat: b7,
  randFloatSpread: x7,
  seededRandom: _7,
  degToRad: T7,
  radToDeg: w7,
  isPowerOfTwo: S7,
  ceilPowerOfTwo: E7,
  floorPowerOfTwo: M7,
  setQuaternionFromProperEuler: A7,
  normalize: St,
  denormalize: Mr
};
class Vt {
  constructor(e = 0, i = 0) {
    Vt.prototype.isVector2 = !0, this.x = e, this.y = i;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, i) {
    return this.x = e, this.y = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * i + s[3] * n + s[6], this.y = s[1] * i + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(tr(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y;
    return i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this;
  }
  rotateAround(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = this.x - e.x, o = this.y - e.y;
    return this.x = a * n - o * s + e.x, this.y = a * s + o * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Xr {
  constructor(e, i, n, s, a, o, l, u, c) {
    Xr.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c);
  }
  set(e, i, n, s, a, o, l, u, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = l, h[3] = i, h[4] = a, h[5] = u, h[6] = n, h[7] = o, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrix3Column(this, 0), i.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[4],
      i[8],
      i[1],
      i[5],
      i[9],
      i[2],
      i[6],
      i[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[3], u = n[6], c = n[1], h = n[4], d = n[7], p = n[2], f = n[5], m = n[8], y = s[0], v = s[3], g = s[6], _ = s[1], x = s[4], b = s[7], T = s[2], E = s[5], M = s[8];
    return a[0] = o * y + l * _ + u * T, a[3] = o * v + l * x + u * E, a[6] = o * g + l * b + u * M, a[1] = c * y + h * _ + d * T, a[4] = c * v + h * x + d * E, a[7] = c * g + h * b + d * M, a[2] = p * y + f * _ + m * T, a[5] = p * v + f * x + m * E, a[8] = p * g + f * b + m * M, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= e, i[4] *= e, i[7] *= e, i[2] *= e, i[5] *= e, i[8] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8];
    return i * o * h - i * l * c - n * a * h + n * l * u + s * a * c - s * o * u;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = h * o - l * c, p = l * u - h * a, f = c * a - o * u, m = i * d + n * p + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const y = 1 / m;
    return e[0] = d * y, e[1] = (s * c - h * n) * y, e[2] = (l * n - s * o) * y, e[3] = p * y, e[4] = (h * i - s * u) * y, e[5] = (s * a - l * i) * y, e[6] = f * y, e[7] = (n * u - c * i) * y, e[8] = (o * i - n * a) * y, this;
  }
  transpose() {
    let e;
    const i = this.elements;
    return e = i[1], i[1] = i[3], i[3] = e, e = i[2], i[2] = i[6], i[6] = e, e = i[5], i[5] = i[7], i[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const i = this.elements;
    return e[0] = i[0], e[1] = i[3], e[2] = i[6], e[3] = i[1], e[4] = i[4], e[5] = i[7], e[6] = i[2], e[7] = i[5], e[8] = i[8], this;
  }
  setUvTransform(e, i, n, s, a, o, l) {
    const u = Math.cos(a), c = Math.sin(a);
    return this.set(
      n * u,
      n * c,
      -n * (u * o + c * l) + o + e,
      -s * c,
      s * u,
      -s * (-c * o + u * l) + l + i,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, i) {
    return this.premultiply(g0.makeScale(e, i)), this;
  }
  rotate(e) {
    return this.premultiply(g0.makeRotation(-e)), this;
  }
  translate(e, i) {
    return this.premultiply(g0.makeTranslation(e, i)), this;
  }
  // for 2D Transforms
  makeTranslation(e, i) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      i,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      n,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i) {
    return this.set(
      e,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const g0 = /* @__PURE__ */ new Xr();
function R7(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function gx(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function N7() {
  const r = gx("canvas");
  return r.style.display = "block", r;
}
const LE = {};
function P7(r) {
  r in LE || (LE[r] = !0, console.warn(r));
}
const Li = {
  enabled: !0,
  workingColorSpace: ho,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(r, e, i) {
    return this.enabled === !1 || e === i || !e || !i || (this.spaces[e].transfer === yd && (r.r = ma(r.r), r.g = ma(r.g), r.b = ma(r.b)), this.spaces[e].primaries !== this.spaces[i].primaries && (r.applyMatrix3(this.spaces[e].toXYZ), r.applyMatrix3(this.spaces[i].fromXYZ)), this.spaces[i].transfer === yd && (r.r = Qu(r.r), r.g = Qu(r.g), r.b = Qu(r.b))), r;
  },
  fromWorkingColorSpace: function(r, e) {
    return this.convert(r, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(r, e) {
    return this.convert(r, e, this.workingColorSpace);
  },
  getPrimaries: function(r) {
    return this.spaces[r].primaries;
  },
  getTransfer: function(r) {
    return r === wl ? s3 : this.spaces[r].transfer;
  },
  getLuminanceCoefficients: function(r, e = this.workingColorSpace) {
    return r.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(r) {
    Object.assign(this.spaces, r);
  },
  // Internal APIs
  _getMatrix: function(r, e, i) {
    return r.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(r) {
    return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(r = this.workingColorSpace) {
    return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
  }
};
function ma(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Qu(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const kE = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], UE = [0.2126, 0.7152, 0.0722], FE = [0.3127, 0.329], BE = /* @__PURE__ */ new Xr().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), zE = /* @__PURE__ */ new Xr().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
Li.define({
  [ho]: {
    primaries: kE,
    whitePoint: FE,
    transfer: s3,
    toXYZ: BE,
    fromXYZ: zE,
    luminanceCoefficients: UE,
    workingColorSpaceConfig: { unpackColorSpace: ct },
    outputColorSpaceConfig: { drawingBufferColorSpace: ct }
  },
  [ct]: {
    primaries: kE,
    whitePoint: FE,
    transfer: yd,
    toXYZ: BE,
    fromXYZ: zE,
    luminanceCoefficients: UE,
    outputColorSpaceConfig: { drawingBufferColorSpace: ct }
  }
});
let ou;
class I7 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let i;
    if (e instanceof HTMLCanvasElement)
      i = e;
    else {
      ou === void 0 && (ou = gx("canvas")), ou.width = e.width, ou.height = e.height;
      const n = ou.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), i = ou;
    }
    return i.width > 2048 || i.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), i.toDataURL("image/jpeg", 0.6)) : i.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const i = gx("canvas");
      i.width = e.width, i.height = e.height;
      const n = i.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const s = n.getImageData(0, 0, e.width, e.height), a = s.data;
      for (let o = 0; o < a.length; o++)
        a[o] = ma(a[o] / 255) * 255;
      return n.putImageData(s, 0, 0), i;
    } else if (e.data) {
      const i = e.data.slice(0);
      for (let n = 0; n < i.length; n++)
        i instanceof Uint8Array || i instanceof Uint8ClampedArray ? i[n] = Math.floor(ma(i[n] / 255) * 255) : i[n] = ma(i[n]);
      return {
        data: i,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let O7 = 0;
class p3 {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: O7++ }), this.uuid = fa(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, s = this.data;
    if (s !== null) {
      let a;
      if (Array.isArray(s)) {
        a = [];
        for (let o = 0, l = s.length; o < l; o++)
          s[o].isDataTexture ? a.push(y0(s[o].image)) : a.push(y0(s[o]));
      } else
        a = y0(s);
      n.url = a;
    }
    return i || (e.images[this.uuid] = n), n;
  }
}
function y0(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? I7.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let D7 = 0;
class Cr extends zc {
  constructor(e = Cr.DEFAULT_IMAGE, i = Cr.DEFAULT_MAPPING, n = Du, s = Du, a = ln, o = da, l = Bc, u = co, c = Cr.DEFAULT_ANISOTROPY, h = wl) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: D7++ }), this.uuid = fa(), this.name = "", this.source = new p3(e), this.mipmaps = [], this.mapping = i, this.channel = 0, this.wrapS = n, this.wrapT = s, this.magFilter = a, this.minFilter = o, this.anisotropy = c, this.format = l, this.internalFormat = null, this.type = u, this.offset = new Vt(0, 0), this.repeat = new Vt(1, 1), this.center = new Vt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Xr(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), i || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== r1) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Um:
          e.x = e.x - Math.floor(e.x);
          break;
        case Du:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Fm:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Um:
          e.y = e.y - Math.floor(e.y);
          break;
        case Du:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Fm:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Cr.DEFAULT_IMAGE = null;
Cr.DEFAULT_MAPPING = r1;
Cr.DEFAULT_ANISOTROPY = 1;
class Kt {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    Kt.prototype.isVector4 = !0, this.x = e, this.y = i, this.z = n, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, i, n, s) {
    return this.x = e, this.y = i, this.z = n, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      case 3:
        this.w = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this.w = e.w + i.w, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this.w += e.w * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this.w = e.w - i.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = this.w, o = e.elements;
    return this.x = o[0] * i + o[4] * n + o[8] * s + o[12] * a, this.y = o[1] * i + o[5] * n + o[9] * s + o[13] * a, this.z = o[2] * i + o[6] * n + o[10] * s + o[14] * a, this.w = o[3] * i + o[7] * n + o[11] * s + o[15] * a, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const i = Math.sqrt(1 - e.w * e.w);
    return i < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / i, this.y = e.y / i, this.z = e.z / i), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let i, n, s, a;
    const o = e.elements, l = o[0], u = o[4], c = o[8], h = o[1], d = o[5], p = o[9], f = o[2], m = o[6], y = o[10];
    if (Math.abs(u - h) < 0.01 && Math.abs(c - f) < 0.01 && Math.abs(p - m) < 0.01) {
      if (Math.abs(u + h) < 0.1 && Math.abs(c + f) < 0.1 && Math.abs(p + m) < 0.1 && Math.abs(l + d + y - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      i = Math.PI;
      const g = (l + 1) / 2, _ = (d + 1) / 2, x = (y + 1) / 2, b = (u + h) / 4, T = (c + f) / 4, E = (p + m) / 4;
      return g > _ && g > x ? g < 0.01 ? (n = 0, s = 0.707106781, a = 0.707106781) : (n = Math.sqrt(g), s = b / n, a = T / n) : _ > x ? _ < 0.01 ? (n = 0.707106781, s = 0, a = 0.707106781) : (s = Math.sqrt(_), n = b / s, a = E / s) : x < 0.01 ? (n = 0.707106781, s = 0.707106781, a = 0) : (a = Math.sqrt(x), n = T / a, s = E / a), this.set(n, s, a, i), this;
    }
    let v = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (h - u) * (h - u));
    return Math.abs(v) < 1e-3 && (v = 1), this.x = (m - p) / v, this.y = (c - f) / v, this.z = (h - u) / v, this.w = Math.acos((l + d + y - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this.w = i[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this.w = Math.max(e.w, Math.min(i.w, this.w)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this.w = Math.max(e, Math.min(i, this.w)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this.w += (e.w - this.w) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this.w = e.w + (i.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this.w = e[i + 3], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e[i + 3] = this.w, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this.w = e.getW(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class jc extends zc {
  constructor(e = 1, i = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = i, this.depth = 1, this.scissor = new Kt(0, 0, e, i), this.scissorTest = !1, this.viewport = new Kt(0, 0, e, i);
    const s = { width: e, height: i, depth: 1 };
    n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: ln,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, n);
    const a = new Cr(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
    a.flipY = !1, a.generateMipmaps = n.generateMipmaps, a.internalFormat = n.internalFormat, this.textures = [];
    const o = n.count;
    for (let l = 0; l < o; l++)
      this.textures[l] = a.clone(), this.textures[l].isRenderTargetTexture = !0;
    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, i, n = 1) {
    if (this.width !== e || this.height !== i || this.depth !== n) {
      this.width = e, this.height = i, this.depth = n;
      for (let s = 0, a = this.textures.length; s < a; s++)
        this.textures[s].image.width = e, this.textures[s].image.height = i, this.textures[s].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, i), this.scissor.set(0, 0, e, i);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let n = 0, s = e.textures.length; n < s; n++)
      this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
    const i = Object.assign({}, e.texture.image);
    return this.texture.source = new p3(i), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class L7 extends jc {
  constructor(e = 1, i = 1, n = {}) {
    super(e, i, n), this.isWebGLRenderTarget = !0;
  }
}
class k7 extends Cr {
  constructor(e = null, i = 1, n = 1, s = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: i, height: n, depth: s }, this.magFilter = yr, this.minFilter = yr, this.wrapR = Du, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Zd {
  constructor(e = 0, i = 0, n = 0, s = 1) {
    this.isQuaternion = !0, this._x = e, this._y = i, this._z = n, this._w = s;
  }
  static slerpFlat(e, i, n, s, a, o, l) {
    let u = n[s + 0], c = n[s + 1], h = n[s + 2], d = n[s + 3];
    const p = a[o + 0], f = a[o + 1], m = a[o + 2], y = a[o + 3];
    if (l === 0) {
      e[i + 0] = u, e[i + 1] = c, e[i + 2] = h, e[i + 3] = d;
      return;
    }
    if (l === 1) {
      e[i + 0] = p, e[i + 1] = f, e[i + 2] = m, e[i + 3] = y;
      return;
    }
    if (d !== y || u !== p || c !== f || h !== m) {
      let v = 1 - l;
      const g = u * p + c * f + h * m + d * y, _ = g >= 0 ? 1 : -1, x = 1 - g * g;
      if (x > Number.EPSILON) {
        const T = Math.sqrt(x), E = Math.atan2(T, g * _);
        v = Math.sin(v * E) / T, l = Math.sin(l * E) / T;
      }
      const b = l * _;
      if (u = u * v + p * b, c = c * v + f * b, h = h * v + m * b, d = d * v + y * b, v === 1 - l) {
        const T = 1 / Math.sqrt(u * u + c * c + h * h + d * d);
        u *= T, c *= T, h *= T, d *= T;
      }
    }
    e[i] = u, e[i + 1] = c, e[i + 2] = h, e[i + 3] = d;
  }
  static multiplyQuaternionsFlat(e, i, n, s, a, o) {
    const l = n[s], u = n[s + 1], c = n[s + 2], h = n[s + 3], d = a[o], p = a[o + 1], f = a[o + 2], m = a[o + 3];
    return e[i] = l * m + h * d + u * f - c * p, e[i + 1] = u * m + h * p + c * d - l * f, e[i + 2] = c * m + h * f + l * p - u * d, e[i + 3] = h * m - l * d - u * p - c * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, i, n, s) {
    return this._x = e, this._y = i, this._z = n, this._w = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, i = !0) {
    const n = e._x, s = e._y, a = e._z, o = e._order, l = Math.cos, u = Math.sin, c = l(n / 2), h = l(s / 2), d = l(a / 2), p = u(n / 2), f = u(s / 2), m = u(a / 2);
    switch (o) {
      case "XYZ":
        this._x = p * h * d + c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "YXZ":
        this._x = p * h * d + c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d + p * f * m;
        break;
      case "ZXY":
        this._x = p * h * d - c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "ZYX":
        this._x = p * h * d - c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d + p * f * m;
        break;
      case "YZX":
        this._x = p * h * d + c * f * m, this._y = c * f * d + p * h * m, this._z = c * h * m - p * f * d, this._w = c * h * d - p * f * m;
        break;
      case "XZY":
        this._x = p * h * d - c * f * m, this._y = c * f * d - p * h * m, this._z = c * h * m + p * f * d, this._w = c * h * d + p * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return i === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, i) {
    const n = i / 2, s = Math.sin(n);
    return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const i = e.elements, n = i[0], s = i[4], a = i[8], o = i[1], l = i[5], u = i[9], c = i[2], h = i[6], d = i[10], p = n + l + d;
    if (p > 0) {
      const f = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / f, this._x = (h - u) * f, this._y = (a - c) * f, this._z = (o - s) * f;
    } else if (n > l && n > d) {
      const f = 2 * Math.sqrt(1 + n - l - d);
      this._w = (h - u) / f, this._x = 0.25 * f, this._y = (s + o) / f, this._z = (a + c) / f;
    } else if (l > d) {
      const f = 2 * Math.sqrt(1 + l - n - d);
      this._w = (a - c) / f, this._x = (s + o) / f, this._y = 0.25 * f, this._z = (u + h) / f;
    } else {
      const f = 2 * Math.sqrt(1 + d - n - l);
      this._w = (o - s) / f, this._x = (a + c) / f, this._y = (u + h) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, i) {
    let n = e.dot(i) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * i.z - e.z * i.y, this._y = e.z * i.x - e.x * i.z, this._z = e.x * i.y - e.y * i.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(tr(this.dot(e), -1, 1)));
  }
  rotateTowards(e, i) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const s = Math.min(1, i / n);
    return this.slerp(e, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, i) {
    const n = e._x, s = e._y, a = e._z, o = e._w, l = i._x, u = i._y, c = i._z, h = i._w;
    return this._x = n * h + o * l + s * c - a * u, this._y = s * h + o * u + a * l - n * c, this._z = a * h + o * c + n * u - s * l, this._w = o * h - n * l - s * u - a * c, this._onChangeCallback(), this;
  }
  slerp(e, i) {
    if (i === 0) return this;
    if (i === 1) return this.copy(e);
    const n = this._x, s = this._y, a = this._z, o = this._w;
    let l = o * e._w + n * e._x + s * e._y + a * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = o, this._x = n, this._y = s, this._z = a, this;
    const u = 1 - l * l;
    if (u <= Number.EPSILON) {
      const f = 1 - i;
      return this._w = f * o + i * this._w, this._x = f * n + i * this._x, this._y = f * s + i * this._y, this._z = f * a + i * this._z, this.normalize(), this;
    }
    const c = Math.sqrt(u), h = Math.atan2(c, l), d = Math.sin((1 - i) * h) / c, p = Math.sin(i * h) / c;
    return this._w = o * d + this._w * p, this._x = n * d + this._x * p, this._y = s * d + this._y * p, this._z = a * d + this._z * p, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, i, n) {
    return this.copy(e).slerp(i, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), i = 2 * Math.PI * Math.random(), n = Math.random(), s = Math.sqrt(1 - n), a = Math.sqrt(n);
    return this.set(
      s * Math.sin(e),
      s * Math.cos(e),
      a * Math.sin(i),
      a * Math.cos(i)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, i = 0) {
    return this._x = e[i], this._y = e[i + 1], this._z = e[i + 2], this._w = e[i + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._w, e;
  }
  fromBufferAttribute(e, i) {
    return this._x = e.getX(i), this._y = e.getY(i), this._z = e.getZ(i), this._w = e.getW(i), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class ue {
  constructor(e = 0, i = 0, n = 0) {
    ue.prototype.isVector3 = !0, this.x = e, this.y = i, this.z = n;
  }
  set(e, i, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = i, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, i) {
    return this.x = e.x + i.x, this.y = e.y + i.y, this.z = e.z + i.z, this;
  }
  addScaledVector(e, i) {
    return this.x += e.x * i, this.y += e.y * i, this.z += e.z * i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, i) {
    return this.x = e.x - i.x, this.y = e.y - i.y, this.z = e.z - i.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, i) {
    return this.x = e.x * i.x, this.y = e.y * i.y, this.z = e.z * i.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(jE.setFromEuler(e));
  }
  applyAxisAngle(e, i) {
    return this.applyQuaternion(jE.setFromAxisAngle(e, i));
  }
  applyMatrix3(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[3] * n + a[6] * s, this.y = a[1] * i + a[4] * n + a[7] * s, this.z = a[2] * i + a[5] * n + a[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements, o = 1 / (a[3] * i + a[7] * n + a[11] * s + a[15]);
    return this.x = (a[0] * i + a[4] * n + a[8] * s + a[12]) * o, this.y = (a[1] * i + a[5] * n + a[9] * s + a[13]) * o, this.z = (a[2] * i + a[6] * n + a[10] * s + a[14]) * o, this;
  }
  applyQuaternion(e) {
    const i = this.x, n = this.y, s = this.z, a = e.x, o = e.y, l = e.z, u = e.w, c = 2 * (o * s - l * n), h = 2 * (l * i - a * s), d = 2 * (a * n - o * i);
    return this.x = i + u * c + o * d - l * h, this.y = n + u * h + l * c - a * d, this.z = s + u * d + a * h - o * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const i = this.x, n = this.y, s = this.z, a = e.elements;
    return this.x = a[0] * i + a[4] * n + a[8] * s, this.y = a[1] * i + a[5] * n + a[9] * s, this.z = a[2] * i + a[6] * n + a[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, i) {
    return this.x = Math.max(e.x, Math.min(i.x, this.x)), this.y = Math.max(e.y, Math.min(i.y, this.y)), this.z = Math.max(e.z, Math.min(i.z, this.z)), this;
  }
  clampScalar(e, i) {
    return this.x = Math.max(e, Math.min(i, this.x)), this.y = Math.max(e, Math.min(i, this.y)), this.z = Math.max(e, Math.min(i, this.z)), this;
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(i, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return this.x += (e.x - this.x) * i, this.y += (e.y - this.y) * i, this.z += (e.z - this.z) * i, this;
  }
  lerpVectors(e, i, n) {
    return this.x = e.x + (i.x - e.x) * n, this.y = e.y + (i.y - e.y) * n, this.z = e.z + (i.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, i) {
    const n = e.x, s = e.y, a = e.z, o = i.x, l = i.y, u = i.z;
    return this.x = s * u - a * l, this.y = a * o - n * u, this.z = n * l - s * o, this;
  }
  projectOnVector(e) {
    const i = e.lengthSq();
    if (i === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / i;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return v0.copy(this).projectOnVector(e), this.sub(v0);
  }
  reflect(e) {
    return this.sub(v0.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(tr(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x, n = this.y - e.y, s = this.z - e.z;
    return i * i + n * n + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, i, n) {
    const s = Math.sin(i) * e;
    return this.x = s * Math.sin(n), this.y = Math.cos(i) * e, this.z = s * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, i, n) {
    return this.x = e * Math.sin(i), this.y = n, this.z = e * Math.cos(i), this;
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return this.x = i[12], this.y = i[13], this.z = i[14], this;
  }
  setFromMatrixScale(e) {
    const i = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = i, this.y = n, this.z = s, this;
  }
  setFromMatrixColumn(e, i) {
    return this.fromArray(e.elements, i * 4);
  }
  setFromMatrix3Column(e, i) {
    return this.fromArray(e.elements, i * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e;
  }
  fromBufferAttribute(e, i) {
    return this.x = e.getX(i), this.y = e.getY(i), this.z = e.getZ(i), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, i = Math.random() * 2 - 1, n = Math.sqrt(1 - i * i);
    return this.x = n * Math.cos(e), this.y = i, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const v0 = /* @__PURE__ */ new ue(), jE = /* @__PURE__ */ new Zd();
class Qd {
  constructor(e = new ue(1 / 0, 1 / 0, 1 / 0), i = new ue(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = i;
  }
  set(e, i) {
    return this.min.copy(e), this.max.copy(i), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let i = 0, n = e.length; i < n; i += 3)
      this.expandByPoint(In.fromArray(e, i));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let i = 0, n = e.count; i < n; i++)
      this.expandByPoint(In.fromBufferAttribute(e, i));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let i = 0, n = e.length; i < n; i++)
      this.expandByPoint(e[i]);
    return this;
  }
  setFromCenterAndSize(e, i) {
    const n = In.copy(i).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, i = !1) {
    return this.makeEmpty(), this.expandByObject(e, i);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, i = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const a = n.getAttribute("position");
      if (i === !0 && a !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, l = a.count; o < l; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, In) : In.fromBufferAttribute(a, o), In.applyMatrix4(e.matrixWorld), this.expandByPoint(In);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Yp.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Yp.copy(n.boundingBox)), Yp.applyMatrix4(e.matrixWorld), this.union(Yp);
    }
    const s = e.children;
    for (let a = 0, o = s.length; a < o; a++)
      this.expandByObject(s[a], i);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, i) {
    return i.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, In), In.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let i, n;
    return e.normal.x > 0 ? (i = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (i = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (i += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (i += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (i += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (i += e.normal.z * this.max.z, n += e.normal.z * this.min.z), i <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(gh), Kp.subVectors(this.max, gh), lu.subVectors(e.a, gh), uu.subVectors(e.b, gh), cu.subVectors(e.c, gh), Ua.subVectors(uu, lu), Fa.subVectors(cu, uu), Do.subVectors(lu, cu);
    let i = [
      0,
      -Ua.z,
      Ua.y,
      0,
      -Fa.z,
      Fa.y,
      0,
      -Do.z,
      Do.y,
      Ua.z,
      0,
      -Ua.x,
      Fa.z,
      0,
      -Fa.x,
      Do.z,
      0,
      -Do.x,
      -Ua.y,
      Ua.x,
      0,
      -Fa.y,
      Fa.x,
      0,
      -Do.y,
      Do.x,
      0
    ];
    return !b0(i, lu, uu, cu, Kp) || (i = [1, 0, 0, 0, 1, 0, 0, 0, 1], !b0(i, lu, uu, cu, Kp)) ? !1 : (Zp.crossVectors(Ua, Fa), i = [Zp.x, Zp.y, Zp.z], b0(i, lu, uu, cu, Kp));
  }
  clampPoint(e, i) {
    return i.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, In).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(In).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Os[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Os[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Os[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Os[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Os[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Os[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Os[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Os[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Os), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Os = [
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue(),
  /* @__PURE__ */ new ue()
], In = /* @__PURE__ */ new ue(), Yp = /* @__PURE__ */ new Qd(), lu = /* @__PURE__ */ new ue(), uu = /* @__PURE__ */ new ue(), cu = /* @__PURE__ */ new ue(), Ua = /* @__PURE__ */ new ue(), Fa = /* @__PURE__ */ new ue(), Do = /* @__PURE__ */ new ue(), gh = /* @__PURE__ */ new ue(), Kp = /* @__PURE__ */ new ue(), Zp = /* @__PURE__ */ new ue(), Lo = /* @__PURE__ */ new ue();
function b0(r, e, i, n, s) {
  for (let a = 0, o = r.length - 3; a <= o; a += 3) {
    Lo.fromArray(r, a);
    const l = s.x * Math.abs(Lo.x) + s.y * Math.abs(Lo.y) + s.z * Math.abs(Lo.z), u = e.dot(Lo), c = i.dot(Lo), h = n.dot(Lo);
    if (Math.max(-Math.max(u, c, h), Math.min(u, c, h)) > l)
      return !1;
  }
  return !0;
}
const U7 = /* @__PURE__ */ new Qd(), yh = /* @__PURE__ */ new ue(), x0 = /* @__PURE__ */ new ue();
class h1 {
  constructor(e = new ue(), i = -1) {
    this.isSphere = !0, this.center = e, this.radius = i;
  }
  set(e, i) {
    return this.center.copy(e), this.radius = i, this;
  }
  setFromPoints(e, i) {
    const n = this.center;
    i !== void 0 ? n.copy(i) : U7.setFromPoints(e).getCenter(n);
    let s = 0;
    for (let a = 0, o = e.length; a < o; a++)
      s = Math.max(s, n.distanceToSquared(e[a]));
    return this.radius = Math.sqrt(s), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const i = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= i * i;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, i) {
    const n = this.center.distanceToSquared(e);
    return i.copy(e), n > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)), i;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    yh.subVectors(e, this.center);
    const i = yh.lengthSq();
    if (i > this.radius * this.radius) {
      const n = Math.sqrt(i), s = (n - this.radius) * 0.5;
      this.center.addScaledVector(yh, s / n), this.radius += s;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (x0.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(yh.copy(e.center).add(x0)), this.expandByPoint(yh.copy(e.center).sub(x0))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ds = /* @__PURE__ */ new ue(), _0 = /* @__PURE__ */ new ue(), Qp = /* @__PURE__ */ new ue(), Ba = /* @__PURE__ */ new ue(), T0 = /* @__PURE__ */ new ue(), $p = /* @__PURE__ */ new ue(), w0 = /* @__PURE__ */ new ue();
class F7 {
  constructor(e = new ue(), i = new ue(0, 0, -1)) {
    this.origin = e, this.direction = i;
  }
  set(e, i) {
    return this.origin.copy(e), this.direction.copy(i), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, i) {
    return i.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ds)), this;
  }
  closestPointToPoint(e, i) {
    i.subVectors(e, this.origin);
    const n = i.dot(this.direction);
    return n < 0 ? i.copy(this.origin) : i.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const i = Ds.subVectors(e, this.origin).dot(this.direction);
    return i < 0 ? this.origin.distanceToSquared(e) : (Ds.copy(this.origin).addScaledVector(this.direction, i), Ds.distanceToSquared(e));
  }
  distanceSqToSegment(e, i, n, s) {
    _0.copy(e).add(i).multiplyScalar(0.5), Qp.copy(i).sub(e).normalize(), Ba.copy(this.origin).sub(_0);
    const a = e.distanceTo(i) * 0.5, o = -this.direction.dot(Qp), l = Ba.dot(this.direction), u = -Ba.dot(Qp), c = Ba.lengthSq(), h = Math.abs(1 - o * o);
    let d, p, f, m;
    if (h > 0)
      if (d = o * u - l, p = o * l - u, m = a * h, d >= 0)
        if (p >= -m)
          if (p <= m) {
            const y = 1 / h;
            d *= y, p *= y, f = d * (d + o * p + 2 * l) + p * (o * d + p + 2 * u) + c;
          } else
            p = a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
        else
          p = -a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
      else
        p <= -m ? (d = Math.max(0, -(-o * a + l)), p = d > 0 ? -a : Math.min(Math.max(-a, -u), a), f = -d * d + p * (p + 2 * u) + c) : p <= m ? (d = 0, p = Math.min(Math.max(-a, -u), a), f = p * (p + 2 * u) + c) : (d = Math.max(0, -(o * a + l)), p = d > 0 ? a : Math.min(Math.max(-a, -u), a), f = -d * d + p * (p + 2 * u) + c);
    else
      p = o > 0 ? -a : a, d = Math.max(0, -(o * p + l)), f = -d * d + p * (p + 2 * u) + c;
    return n && n.copy(this.origin).addScaledVector(this.direction, d), s && s.copy(_0).addScaledVector(Qp, p), f;
  }
  intersectSphere(e, i) {
    Ds.subVectors(e.center, this.origin);
    const n = Ds.dot(this.direction), s = Ds.dot(Ds) - n * n, a = e.radius * e.radius;
    if (s > a) return null;
    const o = Math.sqrt(a - s), l = n - o, u = n + o;
    return u < 0 ? null : l < 0 ? this.at(u, i) : this.at(l, i);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const i = e.normal.dot(this.direction);
    if (i === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / i;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, i) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, i);
  }
  intersectsPlane(e) {
    const i = e.distanceToPoint(this.origin);
    return i === 0 || e.normal.dot(this.direction) * i < 0;
  }
  intersectBox(e, i) {
    let n, s, a, o, l, u;
    const c = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin;
    return c >= 0 ? (n = (e.min.x - p.x) * c, s = (e.max.x - p.x) * c) : (n = (e.max.x - p.x) * c, s = (e.min.x - p.x) * c), h >= 0 ? (a = (e.min.y - p.y) * h, o = (e.max.y - p.y) * h) : (a = (e.max.y - p.y) * h, o = (e.min.y - p.y) * h), n > o || a > s || ((a > n || isNaN(n)) && (n = a), (o < s || isNaN(s)) && (s = o), d >= 0 ? (l = (e.min.z - p.z) * d, u = (e.max.z - p.z) * d) : (l = (e.max.z - p.z) * d, u = (e.min.z - p.z) * d), n > u || l > s) || ((l > n || n !== n) && (n = l), (u < s || s !== s) && (s = u), s < 0) ? null : this.at(n >= 0 ? n : s, i);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Ds) !== null;
  }
  intersectTriangle(e, i, n, s, a) {
    T0.subVectors(i, e), $p.subVectors(n, e), w0.crossVectors(T0, $p);
    let o = this.direction.dot(w0), l;
    if (o > 0) {
      if (s) return null;
      l = 1;
    } else if (o < 0)
      l = -1, o = -o;
    else
      return null;
    Ba.subVectors(this.origin, e);
    const u = l * this.direction.dot($p.crossVectors(Ba, $p));
    if (u < 0)
      return null;
    const c = l * this.direction.dot(T0.cross(Ba));
    if (c < 0 || u + c > o)
      return null;
    const h = -l * Ba.dot(w0);
    return h < 0 ? null : this.at(h / o, a);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class gi {
  constructor(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v) {
    gi.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v);
  }
  set(e, i, n, s, a, o, l, u, c, h, d, p, f, m, y, v) {
    const g = this.elements;
    return g[0] = e, g[4] = i, g[8] = n, g[12] = s, g[1] = a, g[5] = o, g[9] = l, g[13] = u, g[2] = c, g[6] = h, g[10] = d, g[14] = p, g[3] = f, g[7] = m, g[11] = y, g[15] = v, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new gi().fromArray(this.elements);
  }
  copy(e) {
    const i = this.elements, n = e.elements;
    return i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], i[9] = n[9], i[10] = n[10], i[11] = n[11], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15], this;
  }
  copyPosition(e) {
    const i = this.elements, n = e.elements;
    return i[12] = n[12], i[13] = n[13], i[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const i = e.elements;
    return this.set(
      i[0],
      i[3],
      i[6],
      0,
      i[1],
      i[4],
      i[7],
      0,
      i[2],
      i[5],
      i[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, i, n) {
    return e.setFromMatrixColumn(this, 0), i.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, i, n) {
    return this.set(
      e.x,
      i.x,
      n.x,
      0,
      e.y,
      i.y,
      n.y,
      0,
      e.z,
      i.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const i = this.elements, n = e.elements, s = 1 / hu.setFromMatrixColumn(e, 0).length(), a = 1 / hu.setFromMatrixColumn(e, 1).length(), o = 1 / hu.setFromMatrixColumn(e, 2).length();
    return i[0] = n[0] * s, i[1] = n[1] * s, i[2] = n[2] * s, i[3] = 0, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[7] = 0, i[8] = n[8] * o, i[9] = n[9] * o, i[10] = n[10] * o, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z, o = Math.cos(n), l = Math.sin(n), u = Math.cos(s), c = Math.sin(s), h = Math.cos(a), d = Math.sin(a);
    if (e.order === "XYZ") {
      const p = o * h, f = o * d, m = l * h, y = l * d;
      i[0] = u * h, i[4] = -u * d, i[8] = c, i[1] = f + m * c, i[5] = p - y * c, i[9] = -l * u, i[2] = y - p * c, i[6] = m + f * c, i[10] = o * u;
    } else if (e.order === "YXZ") {
      const p = u * h, f = u * d, m = c * h, y = c * d;
      i[0] = p + y * l, i[4] = m * l - f, i[8] = o * c, i[1] = o * d, i[5] = o * h, i[9] = -l, i[2] = f * l - m, i[6] = y + p * l, i[10] = o * u;
    } else if (e.order === "ZXY") {
      const p = u * h, f = u * d, m = c * h, y = c * d;
      i[0] = p - y * l, i[4] = -o * d, i[8] = m + f * l, i[1] = f + m * l, i[5] = o * h, i[9] = y - p * l, i[2] = -o * c, i[6] = l, i[10] = o * u;
    } else if (e.order === "ZYX") {
      const p = o * h, f = o * d, m = l * h, y = l * d;
      i[0] = u * h, i[4] = m * c - f, i[8] = p * c + y, i[1] = u * d, i[5] = y * c + p, i[9] = f * c - m, i[2] = -c, i[6] = l * u, i[10] = o * u;
    } else if (e.order === "YZX") {
      const p = o * u, f = o * c, m = l * u, y = l * c;
      i[0] = u * h, i[4] = y - p * d, i[8] = m * d + f, i[1] = d, i[5] = o * h, i[9] = -l * h, i[2] = -c * h, i[6] = f * d + m, i[10] = p - y * d;
    } else if (e.order === "XZY") {
      const p = o * u, f = o * c, m = l * u, y = l * c;
      i[0] = u * h, i[4] = -d, i[8] = c * h, i[1] = p * d + y, i[5] = o * h, i[9] = f * d - m, i[2] = m * d - f, i[6] = l * h, i[10] = y * d + p;
    }
    return i[3] = 0, i[7] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(B7, e, z7);
  }
  lookAt(e, i, n) {
    const s = this.elements;
    return $r.subVectors(e, i), $r.lengthSq() === 0 && ($r.z = 1), $r.normalize(), za.crossVectors(n, $r), za.lengthSq() === 0 && (Math.abs(n.z) === 1 ? $r.x += 1e-4 : $r.z += 1e-4, $r.normalize(), za.crossVectors(n, $r)), za.normalize(), Jp.crossVectors($r, za), s[0] = za.x, s[4] = Jp.x, s[8] = $r.x, s[1] = za.y, s[5] = Jp.y, s[9] = $r.y, s[2] = za.z, s[6] = Jp.z, s[10] = $r.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements, s = i.elements, a = this.elements, o = n[0], l = n[4], u = n[8], c = n[12], h = n[1], d = n[5], p = n[9], f = n[13], m = n[2], y = n[6], v = n[10], g = n[14], _ = n[3], x = n[7], b = n[11], T = n[15], E = s[0], M = s[4], C = s[8], S = s[12], w = s[1], R = s[5], O = s[9], P = s[13], A = s[2], D = s[6], L = s[10], H = s[14], V = s[3], X = s[7], F = s[11], B = s[15];
    return a[0] = o * E + l * w + u * A + c * V, a[4] = o * M + l * R + u * D + c * X, a[8] = o * C + l * O + u * L + c * F, a[12] = o * S + l * P + u * H + c * B, a[1] = h * E + d * w + p * A + f * V, a[5] = h * M + d * R + p * D + f * X, a[9] = h * C + d * O + p * L + f * F, a[13] = h * S + d * P + p * H + f * B, a[2] = m * E + y * w + v * A + g * V, a[6] = m * M + y * R + v * D + g * X, a[10] = m * C + y * O + v * L + g * F, a[14] = m * S + y * P + v * H + g * B, a[3] = _ * E + x * w + b * A + T * V, a[7] = _ * M + x * R + b * D + T * X, a[11] = _ * C + x * O + b * L + T * F, a[15] = _ * S + x * P + b * H + T * B, this;
  }
  multiplyScalar(e) {
    const i = this.elements;
    return i[0] *= e, i[4] *= e, i[8] *= e, i[12] *= e, i[1] *= e, i[5] *= e, i[9] *= e, i[13] *= e, i[2] *= e, i[6] *= e, i[10] *= e, i[14] *= e, i[3] *= e, i[7] *= e, i[11] *= e, i[15] *= e, this;
  }
  determinant() {
    const e = this.elements, i = e[0], n = e[4], s = e[8], a = e[12], o = e[1], l = e[5], u = e[9], c = e[13], h = e[2], d = e[6], p = e[10], f = e[14], m = e[3], y = e[7], v = e[11], g = e[15];
    return m * (+a * u * d - s * c * d - a * l * p + n * c * p + s * l * f - n * u * f) + y * (+i * u * f - i * c * p + a * o * p - s * o * f + s * c * h - a * u * h) + v * (+i * c * d - i * l * f - a * o * d + n * o * f + a * l * h - n * c * h) + g * (-s * l * h - i * u * d + i * l * p + s * o * d - n * o * p + n * u * h);
  }
  transpose() {
    const e = this.elements;
    let i;
    return i = e[1], e[1] = e[4], e[4] = i, i = e[2], e[2] = e[8], e[8] = i, i = e[6], e[6] = e[9], e[9] = i, i = e[3], e[3] = e[12], e[12] = i, i = e[7], e[7] = e[13], e[13] = i, i = e[11], e[11] = e[14], e[14] = i, this;
  }
  setPosition(e, i, n) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = i, s[14] = n), this;
  }
  invert() {
    const e = this.elements, i = e[0], n = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], d = e[9], p = e[10], f = e[11], m = e[12], y = e[13], v = e[14], g = e[15], _ = d * v * c - y * p * c + y * u * f - l * v * f - d * u * g + l * p * g, x = m * p * c - h * v * c - m * u * f + o * v * f + h * u * g - o * p * g, b = h * y * c - m * d * c + m * l * f - o * y * f - h * l * g + o * d * g, T = m * d * u - h * y * u - m * l * p + o * y * p + h * l * v - o * d * v, E = i * _ + n * x + s * b + a * T;
    if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const M = 1 / E;
    return e[0] = _ * M, e[1] = (y * p * a - d * v * a - y * s * f + n * v * f + d * s * g - n * p * g) * M, e[2] = (l * v * a - y * u * a + y * s * c - n * v * c - l * s * g + n * u * g) * M, e[3] = (d * u * a - l * p * a - d * s * c + n * p * c + l * s * f - n * u * f) * M, e[4] = x * M, e[5] = (h * v * a - m * p * a + m * s * f - i * v * f - h * s * g + i * p * g) * M, e[6] = (m * u * a - o * v * a - m * s * c + i * v * c + o * s * g - i * u * g) * M, e[7] = (o * p * a - h * u * a + h * s * c - i * p * c - o * s * f + i * u * f) * M, e[8] = b * M, e[9] = (m * d * a - h * y * a - m * n * f + i * y * f + h * n * g - i * d * g) * M, e[10] = (o * y * a - m * l * a + m * n * c - i * y * c - o * n * g + i * l * g) * M, e[11] = (h * l * a - o * d * a - h * n * c + i * d * c + o * n * f - i * l * f) * M, e[12] = T * M, e[13] = (h * y * s - m * d * s + m * n * p - i * y * p - h * n * v + i * d * v) * M, e[14] = (m * l * s - o * y * s - m * n * u + i * y * u + o * n * v - i * l * v) * M, e[15] = (o * d * s - h * l * s + h * n * u - i * d * u - o * n * p + i * l * p) * M, this;
  }
  scale(e) {
    const i = this.elements, n = e.x, s = e.y, a = e.z;
    return i[0] *= n, i[4] *= s, i[8] *= a, i[1] *= n, i[5] *= s, i[9] *= a, i[2] *= n, i[6] *= s, i[10] *= a, i[3] *= n, i[7] *= s, i[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(i, n, s));
  }
  makeTranslation(e, i, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      i,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const i = Math.cos(e), n = Math.sin(e);
    return this.set(
      i,
      -n,
      0,
      0,
      n,
      i,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, i) {
    const n = Math.cos(i), s = Math.sin(i), a = 1 - n, o = e.x, l = e.y, u = e.z, c = a * o, h = a * l;
    return this.set(
      c * o + n,
      c * l - s * u,
      c * u + s * l,
      0,
      c * l + s * u,
      h * l + n,
      h * u - s * o,
      0,
      c * u - s * l,
      h * u + s * o,
      a * u * u + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, i, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, i, n, s, a, o) {
    return this.set(
      1,
      n,
      a,
      0,
      e,
      1,
      o,
      0,
      i,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, i, n) {
    const s = this.elements, a = i._x, o = i._y, l = i._z, u = i._w, c = a + a, h = o + o, d = l + l, p = a * c, f = a * h, m = a * d, y = o * h, v = o * d, g = l * d, _ = u * c, x = u * h, b = u * d, T = n.x, E = n.y, M = n.z;
    return s[0] = (1 - (y + g)) * T, s[1] = (f + b) * T, s[2] = (m - x) * T, s[3] = 0, s[4] = (f - b) * E, s[5] = (1 - (p + g)) * E, s[6] = (v + _) * E, s[7] = 0, s[8] = (m + x) * M, s[9] = (v - _) * M, s[10] = (1 - (p + y)) * M, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, i, n) {
    const s = this.elements;
    let a = hu.set(s[0], s[1], s[2]).length();
    const o = hu.set(s[4], s[5], s[6]).length(), l = hu.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (a = -a), e.x = s[12], e.y = s[13], e.z = s[14], On.copy(this);
    const u = 1 / a, c = 1 / o, h = 1 / l;
    return On.elements[0] *= u, On.elements[1] *= u, On.elements[2] *= u, On.elements[4] *= c, On.elements[5] *= c, On.elements[6] *= c, On.elements[8] *= h, On.elements[9] *= h, On.elements[10] *= h, i.setFromRotationMatrix(On), n.x = a, n.y = o, n.z = l, this;
  }
  makePerspective(e, i, n, s, a, o, l = Kn) {
    const u = this.elements, c = 2 * a / (i - e), h = 2 * a / (n - s), d = (i + e) / (i - e), p = (n + s) / (n - s);
    let f, m;
    if (l === Kn)
      f = -(o + a) / (o - a), m = -2 * o * a / (o - a);
    else if (l === Sl)
      f = -o / (o - a), m = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return u[0] = c, u[4] = 0, u[8] = d, u[12] = 0, u[1] = 0, u[5] = h, u[9] = p, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = f, u[14] = m, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this;
  }
  makeOrthographic(e, i, n, s, a, o, l = Kn) {
    const u = this.elements, c = 1 / (i - e), h = 1 / (n - s), d = 1 / (o - a), p = (i + e) * c, f = (n + s) * h;
    let m, y;
    if (l === Kn)
      m = (o + a) * d, y = -2 * d;
    else if (l === Sl)
      m = a * d, y = -1 * d;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return u[0] = 2 * c, u[4] = 0, u[8] = 0, u[12] = -p, u[1] = 0, u[5] = 2 * h, u[9] = 0, u[13] = -f, u[2] = 0, u[6] = 0, u[10] = y, u[14] = -m, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this;
  }
  equals(e) {
    const i = this.elements, n = e.elements;
    for (let s = 0; s < 16; s++)
      if (i[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return e[i] = n[0], e[i + 1] = n[1], e[i + 2] = n[2], e[i + 3] = n[3], e[i + 4] = n[4], e[i + 5] = n[5], e[i + 6] = n[6], e[i + 7] = n[7], e[i + 8] = n[8], e[i + 9] = n[9], e[i + 10] = n[10], e[i + 11] = n[11], e[i + 12] = n[12], e[i + 13] = n[13], e[i + 14] = n[14], e[i + 15] = n[15], e;
  }
}
const hu = /* @__PURE__ */ new ue(), On = /* @__PURE__ */ new gi(), B7 = /* @__PURE__ */ new ue(0, 0, 0), z7 = /* @__PURE__ */ new ue(1, 1, 1), za = /* @__PURE__ */ new ue(), Jp = /* @__PURE__ */ new ue(), $r = /* @__PURE__ */ new ue(), VE = /* @__PURE__ */ new gi(), GE = /* @__PURE__ */ new Zd();
class $n {
  constructor(e = 0, i = 0, n = 0, s = $n.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = i, this._z = n, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, i, n, s = this._order) {
    return this._x = e, this._y = i, this._z = n, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, i = this._order, n = !0) {
    const s = e.elements, a = s[0], o = s[4], l = s[8], u = s[1], c = s[5], h = s[9], d = s[2], p = s[6], f = s[10];
    switch (i) {
      case "XYZ":
        this._y = Math.asin(tr(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(p, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-tr(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(u, c)) : (this._y = Math.atan2(-d, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(tr(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(u, a));
        break;
      case "ZYX":
        this._y = Math.asin(-tr(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(u, a)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin(tr(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-d, a)) : (this._x = 0, this._y = Math.atan2(l, f));
        break;
      case "XZY":
        this._z = Math.asin(-tr(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + i);
    }
    return this._order = i, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, i, n) {
    return VE.makeRotationFromQuaternion(e), this.setFromRotationMatrix(VE, i, n);
  }
  setFromVector3(e, i = this._order) {
    return this.set(e.x, e.y, e.z, i);
  }
  reorder(e) {
    return GE.setFromEuler(this), this.setFromQuaternion(GE, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this._x, e[i + 1] = this._y, e[i + 2] = this._z, e[i + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
$n.DEFAULT_ORDER = "XYZ";
class j7 {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let V7 = 0;
const HE = /* @__PURE__ */ new ue(), du = /* @__PURE__ */ new Zd(), Ls = /* @__PURE__ */ new gi(), ef = /* @__PURE__ */ new ue(), vh = /* @__PURE__ */ new ue(), G7 = /* @__PURE__ */ new ue(), H7 = /* @__PURE__ */ new Zd(), WE = /* @__PURE__ */ new ue(1, 0, 0), qE = /* @__PURE__ */ new ue(0, 1, 0), XE = /* @__PURE__ */ new ue(0, 0, 1), YE = { type: "added" }, W7 = { type: "removed" }, pu = { type: "childadded", child: null }, S0 = { type: "childremoved", child: null };
class Qi extends zc {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: V7++ }), this.uuid = fa(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Qi.DEFAULT_UP.clone();
    const e = new ue(), i = new $n(), n = new Zd(), s = new ue(1, 1, 1);
    function a() {
      n.setFromEuler(i, !1);
    }
    function o() {
      i.setFromQuaternion(n, void 0, !1);
    }
    i._onChange(a), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      modelViewMatrix: {
        value: new gi()
      },
      normalMatrix: {
        value: new Xr()
      }
    }), this.matrix = new gi(), this.matrixWorld = new gi(), this.matrixAutoUpdate = Qi.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Qi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new j7(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, i) {
    this.quaternion.setFromAxisAngle(e, i);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, i) {
    return du.setFromAxisAngle(e, i), this.quaternion.multiply(du), this;
  }
  rotateOnWorldAxis(e, i) {
    return du.setFromAxisAngle(e, i), this.quaternion.premultiply(du), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(WE, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(qE, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(XE, e);
  }
  translateOnAxis(e, i) {
    return HE.copy(e).applyQuaternion(this.quaternion), this.position.add(HE.multiplyScalar(i)), this;
  }
  translateX(e) {
    return this.translateOnAxis(WE, e);
  }
  translateY(e) {
    return this.translateOnAxis(qE, e);
  }
  translateZ(e) {
    return this.translateOnAxis(XE, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Ls.copy(this.matrixWorld).invert());
  }
  lookAt(e, i, n) {
    e.isVector3 ? ef.copy(e) : ef.set(e, i, n);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), vh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ls.lookAt(vh, ef, this.up) : Ls.lookAt(ef, vh, this.up), this.quaternion.setFromRotationMatrix(Ls), s && (Ls.extractRotation(s.matrixWorld), du.setFromRotationMatrix(Ls), this.quaternion.premultiply(du.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.add(arguments[i]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(YE), pu.child = e, this.dispatchEvent(pu), pu.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const i = this.children.indexOf(e);
    return i !== -1 && (e.parent = null, this.children.splice(i, 1), e.dispatchEvent(W7), S0.child = e, this.dispatchEvent(S0), S0.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Ls.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Ls.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ls), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(YE), pu.child = e, this.dispatchEvent(pu), pu.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, i) {
    if (this[e] === i) return this;
    for (let n = 0, s = this.children.length; n < s; n++) {
      const a = this.children[n].getObjectByProperty(e, i);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, i, n = []) {
    this[e] === i && n.push(this);
    const s = this.children;
    for (let a = 0, o = s.length; a < o; a++)
      s[a].getObjectsByProperty(e, i, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(vh, e, G7), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(vh, H7, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const i = this.matrixWorld.elements;
    return e.set(i[8], i[9], i[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const i = this.parent;
    i !== null && (e(i), i.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const i = this.children;
    for (let n = 0, s = i.length; n < s; n++)
      i[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, i) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), i === !0) {
      const s = this.children;
      for (let a = 0, o = s.length; a < o; a++)
        s[a].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string", n = {};
    i && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
      center: s.boundingSphere.center.toArray(),
      radius: s.boundingSphere.radius
    }), this.boundingBox !== null && (s.boundingBox = {
      min: s.boundingBox.min.toArray(),
      max: s.boundingBox.max.toArray()
    }));
    function a(l, u) {
      return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = a(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const u = l.shapes;
        if (Array.isArray(u))
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c];
            a(e.shapes, d);
          }
        else
          a(e.shapes, u);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let u = 0, c = this.material.length; u < c; u++)
          l.push(a(e.materials, this.material[u]));
        s.material = l;
      } else
        s.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let l = 0; l < this.children.length; l++)
        s.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const u = this.animations[l];
        s.animations.push(a(e.animations, u));
      }
    }
    if (i) {
      const l = o(e.geometries), u = o(e.materials), c = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), f = o(e.animations), m = o(e.nodes);
      l.length > 0 && (n.geometries = l), u.length > 0 && (n.materials = u), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), d.length > 0 && (n.shapes = d), p.length > 0 && (n.skeletons = p), f.length > 0 && (n.animations = f), m.length > 0 && (n.nodes = m);
    }
    return n.object = s, n;
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, i = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), i === !0)
      for (let n = 0; n < e.children.length; n++) {
        const s = e.children[n];
        this.add(s.clone());
      }
    return this;
  }
}
Qi.DEFAULT_UP = /* @__PURE__ */ new ue(0, 1, 0);
Qi.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Qi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Dn = /* @__PURE__ */ new ue(), ks = /* @__PURE__ */ new ue(), E0 = /* @__PURE__ */ new ue(), Us = /* @__PURE__ */ new ue(), fu = /* @__PURE__ */ new ue(), mu = /* @__PURE__ */ new ue(), KE = /* @__PURE__ */ new ue(), M0 = /* @__PURE__ */ new ue(), A0 = /* @__PURE__ */ new ue(), C0 = /* @__PURE__ */ new ue(), R0 = /* @__PURE__ */ new Kt(), N0 = /* @__PURE__ */ new Kt(), P0 = /* @__PURE__ */ new Kt();
class qn {
  constructor(e = new ue(), i = new ue(), n = new ue()) {
    this.a = e, this.b = i, this.c = n;
  }
  static getNormal(e, i, n, s) {
    s.subVectors(n, i), Dn.subVectors(e, i), s.cross(Dn);
    const a = s.lengthSq();
    return a > 0 ? s.multiplyScalar(1 / Math.sqrt(a)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, i, n, s, a) {
    Dn.subVectors(s, i), ks.subVectors(n, i), E0.subVectors(e, i);
    const o = Dn.dot(Dn), l = Dn.dot(ks), u = Dn.dot(E0), c = ks.dot(ks), h = ks.dot(E0), d = o * c - l * l;
    if (d === 0)
      return a.set(0, 0, 0), null;
    const p = 1 / d, f = (c * u - l * h) * p, m = (o * h - l * u) * p;
    return a.set(1 - f - m, m, f);
  }
  static containsPoint(e, i, n, s) {
    return this.getBarycoord(e, i, n, s, Us) === null ? !1 : Us.x >= 0 && Us.y >= 0 && Us.x + Us.y <= 1;
  }
  static getInterpolation(e, i, n, s, a, o, l, u) {
    return this.getBarycoord(e, i, n, s, Us) === null ? (u.x = 0, u.y = 0, "z" in u && (u.z = 0), "w" in u && (u.w = 0), null) : (u.setScalar(0), u.addScaledVector(a, Us.x), u.addScaledVector(o, Us.y), u.addScaledVector(l, Us.z), u);
  }
  static getInterpolatedAttribute(e, i, n, s, a, o) {
    return R0.setScalar(0), N0.setScalar(0), P0.setScalar(0), R0.fromBufferAttribute(e, i), N0.fromBufferAttribute(e, n), P0.fromBufferAttribute(e, s), o.setScalar(0), o.addScaledVector(R0, a.x), o.addScaledVector(N0, a.y), o.addScaledVector(P0, a.z), o;
  }
  static isFrontFacing(e, i, n, s) {
    return Dn.subVectors(n, i), ks.subVectors(e, i), Dn.cross(ks).dot(s) < 0;
  }
  set(e, i, n) {
    return this.a.copy(e), this.b.copy(i), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, i, n, s) {
    return this.a.copy(e[i]), this.b.copy(e[n]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, i, n, s) {
    return this.a.fromBufferAttribute(e, i), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Dn.subVectors(this.c, this.b), ks.subVectors(this.a, this.b), Dn.cross(ks).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return qn.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, i) {
    return qn.getBarycoord(e, this.a, this.b, this.c, i);
  }
  getInterpolation(e, i, n, s, a) {
    return qn.getInterpolation(e, this.a, this.b, this.c, i, n, s, a);
  }
  containsPoint(e) {
    return qn.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return qn.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, i) {
    const n = this.a, s = this.b, a = this.c;
    let o, l;
    fu.subVectors(s, n), mu.subVectors(a, n), M0.subVectors(e, n);
    const u = fu.dot(M0), c = mu.dot(M0);
    if (u <= 0 && c <= 0)
      return i.copy(n);
    A0.subVectors(e, s);
    const h = fu.dot(A0), d = mu.dot(A0);
    if (h >= 0 && d <= h)
      return i.copy(s);
    const p = u * d - h * c;
    if (p <= 0 && u >= 0 && h <= 0)
      return o = u / (u - h), i.copy(n).addScaledVector(fu, o);
    C0.subVectors(e, a);
    const f = fu.dot(C0), m = mu.dot(C0);
    if (m >= 0 && f <= m)
      return i.copy(a);
    const y = f * c - u * m;
    if (y <= 0 && c >= 0 && m <= 0)
      return l = c / (c - m), i.copy(n).addScaledVector(mu, l);
    const v = h * m - f * d;
    if (v <= 0 && d - h >= 0 && f - m >= 0)
      return KE.subVectors(a, s), l = (d - h) / (d - h + (f - m)), i.copy(s).addScaledVector(KE, l);
    const g = 1 / (v + y + p);
    return o = y * g, l = p * g, i.copy(n).addScaledVector(fu, o).addScaledVector(mu, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const f3 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, ja = { h: 0, s: 0, l: 0 }, tf = { h: 0, s: 0, l: 0 };
function I0(r, e, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? r + (e - r) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - i) : r;
}
class Zt {
  constructor(e, i, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, i, n);
  }
  set(e, i, n) {
    if (i === void 0 && n === void 0) {
      const s = e;
      s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
    } else
      this.setRGB(e, i, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, i = ct) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Li.toWorkingColorSpace(this, i), this;
  }
  setRGB(e, i, n, s = Li.workingColorSpace) {
    return this.r = e, this.g = i, this.b = n, Li.toWorkingColorSpace(this, s), this;
  }
  setHSL(e, i, n, s = Li.workingColorSpace) {
    if (e = c1(e, 1), i = tr(i, 0, 1), n = tr(n, 0, 1), i === 0)
      this.r = this.g = this.b = n;
    else {
      const a = n <= 0.5 ? n * (1 + i) : n + i - n * i, o = 2 * n - a;
      this.r = I0(o, a, e + 1 / 3), this.g = I0(o, a, e), this.b = I0(o, a, e - 1 / 3);
    }
    return Li.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, i = ct) {
    function n(a) {
      a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let a;
      const o = s[1], l = s[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setRGB(
              Math.min(255, parseInt(a[1], 10)) / 255,
              Math.min(255, parseInt(a[2], 10)) / 255,
              Math.min(255, parseInt(a[3], 10)) / 255,
              i
            );
          if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setRGB(
              Math.min(100, parseInt(a[1], 10)) / 100,
              Math.min(100, parseInt(a[2], 10)) / 100,
              Math.min(100, parseInt(a[3], 10)) / 100,
              i
            );
          break;
        case "hsl":
        case "hsla":
          if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return n(a[4]), this.setHSL(
              parseFloat(a[1]) / 360,
              parseFloat(a[2]) / 100,
              parseFloat(a[3]) / 100,
              i
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const a = s[1], o = a.length;
      if (o === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          i
        );
      if (o === 6)
        return this.setHex(parseInt(a, 16), i);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, i);
    return this;
  }
  setColorName(e, i = ct) {
    const n = f3[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, i) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = ma(e.r), this.g = ma(e.g), this.b = ma(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Qu(e.r), this.g = Qu(e.g), this.b = Qu(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = ct) {
    return Li.fromWorkingColorSpace(dr.copy(this), e), Math.round(tr(dr.r * 255, 0, 255)) * 65536 + Math.round(tr(dr.g * 255, 0, 255)) * 256 + Math.round(tr(dr.b * 255, 0, 255));
  }
  getHexString(e = ct) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, i = Li.workingColorSpace) {
    Li.fromWorkingColorSpace(dr.copy(this), i);
    const n = dr.r, s = dr.g, a = dr.b, o = Math.max(n, s, a), l = Math.min(n, s, a);
    let u, c;
    const h = (l + o) / 2;
    if (l === o)
      u = 0, c = 0;
    else {
      const d = o - l;
      switch (c = h <= 0.5 ? d / (o + l) : d / (2 - o - l), o) {
        case n:
          u = (s - a) / d + (s < a ? 6 : 0);
          break;
        case s:
          u = (a - n) / d + 2;
          break;
        case a:
          u = (n - s) / d + 4;
          break;
      }
      u /= 6;
    }
    return e.h = u, e.s = c, e.l = h, e;
  }
  getRGB(e, i = Li.workingColorSpace) {
    return Li.fromWorkingColorSpace(dr.copy(this), i), e.r = dr.r, e.g = dr.g, e.b = dr.b, e;
  }
  getStyle(e = ct) {
    Li.fromWorkingColorSpace(dr.copy(this), e);
    const i = dr.r, n = dr.g, s = dr.b;
    return e !== ct ? `color(${e} ${i.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(i * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
  }
  offsetHSL(e, i, n) {
    return this.getHSL(ja), this.setHSL(ja.h + e, ja.s + i, ja.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, i) {
    return this.r = e.r + i.r, this.g = e.g + i.g, this.b = e.b + i.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, i) {
    return this.r += (e.r - this.r) * i, this.g += (e.g - this.g) * i, this.b += (e.b - this.b) * i, this;
  }
  lerpColors(e, i, n) {
    return this.r = e.r + (i.r - e.r) * n, this.g = e.g + (i.g - e.g) * n, this.b = e.b + (i.b - e.b) * n, this;
  }
  lerpHSL(e, i) {
    this.getHSL(ja), e.getHSL(tf);
    const n = td(ja.h, tf.h, i), s = td(ja.s, tf.s, i), a = td(ja.l, tf.l, i);
    return this.setHSL(n, s, a), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const i = this.r, n = this.g, s = this.b, a = e.elements;
    return this.r = a[0] * i + a[3] * n + a[6] * s, this.g = a[1] * i + a[4] * n + a[7] * s, this.b = a[2] * i + a[5] * n + a[8] * s, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, i = 0) {
    return this.r = e[i], this.g = e[i + 1], this.b = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.r, e[i + 1] = this.g, e[i + 2] = this.b, e;
  }
  fromBufferAttribute(e, i) {
    return this.r = e.getX(i), this.g = e.getY(i), this.b = e.getZ(i), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const dr = /* @__PURE__ */ new Zt();
Zt.NAMES = f3;
let q7 = 0;
class Hr extends zc {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(e) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: q7++ }), this.uuid = fa(), this.name = "", this.blending = uo, this.side = bc, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Dm, this.blendDst = Lm, this.blendEquation = Ja, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Zt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = km, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = mx, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Vo, this.stencilZFail = Vo, this.stencilZPass = Vo, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const i in e) {
        const n = e[i];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${i}' has value of undefined.`);
          continue;
        }
        const s = this[i];
        if (s === void 0) {
          console.warn(`THREE.Material: '${i}' is not a property of THREE.${this.type}.`);
          continue;
        }
        s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : this[i] = n;
      }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    i && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== uo && (n.blending = this.blending), this.side !== bc && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Dm && (n.blendSrc = this.blendSrc), this.blendDst !== Lm && (n.blendDst = this.blendDst), this.blendEquation !== Ja && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== km && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== mx && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Vo && (n.stencilFail = this.stencilFail), this.stencilZFail !== Vo && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Vo && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function s(a) {
      const o = [];
      for (const l in a) {
        const u = a[l];
        delete u.metadata, o.push(u);
      }
      return o;
    }
    if (i) {
      const a = s(e.textures), o = s(e.images);
      a.length > 0 && (n.textures = a), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const i = e.clippingPlanes;
    let n = null;
    if (i !== null) {
      const s = i.length;
      n = new Array(s);
      for (let a = 0; a !== s; ++a)
        n[a] = i[a].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class Pg extends Hr {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Zt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $n(), this.combine = Ng, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const ea = /* @__PURE__ */ X7();
function X7() {
  const r = new ArrayBuffer(4), e = new Float32Array(r), i = new Uint32Array(r), n = new Uint32Array(512), s = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    const c = u - 127;
    c < -27 ? (n[u] = 0, n[u | 256] = 32768, s[u] = 24, s[u | 256] = 24) : c < -14 ? (n[u] = 1024 >> -c - 14, n[u | 256] = 1024 >> -c - 14 | 32768, s[u] = -c - 1, s[u | 256] = -c - 1) : c <= 15 ? (n[u] = c + 15 << 10, n[u | 256] = c + 15 << 10 | 32768, s[u] = 13, s[u | 256] = 13) : c < 128 ? (n[u] = 31744, n[u | 256] = 64512, s[u] = 24, s[u | 256] = 24) : (n[u] = 31744, n[u | 256] = 64512, s[u] = 13, s[u | 256] = 13);
  }
  const a = new Uint32Array(2048), o = new Uint32Array(64), l = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let c = u << 13, h = 0;
    for (; !(c & 8388608); )
      c <<= 1, h -= 8388608;
    c &= -8388609, h += 947912704, a[u] = c | h;
  }
  for (let u = 1024; u < 2048; ++u)
    a[u] = 939524096 + (u - 1024 << 13);
  for (let u = 1; u < 31; ++u)
    o[u] = u << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let u = 33; u < 63; ++u)
    o[u] = 2147483648 + (u - 32 << 23);
  o[63] = 3347054592;
  for (let u = 1; u < 64; ++u)
    u !== 32 && (l[u] = 1024);
  return {
    floatView: e,
    uint32View: i,
    baseTable: n,
    shiftTable: s,
    mantissaTable: a,
    exponentTable: o,
    offsetTable: l
  };
}
function Jr(r) {
  Math.abs(r) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), r = tr(r, -65504, 65504), ea.floatView[0] = r;
  const e = ea.uint32View[0], i = e >> 23 & 511;
  return ea.baseTable[i] + ((e & 8388607) >> ea.shiftTable[i]);
}
function rf(r) {
  const e = r >> 10;
  return ea.uint32View[0] = ea.mantissaTable[ea.offsetTable[e] + (r & 1023)] + ea.exponentTable[e], ea.floatView[0];
}
const Ii = /* @__PURE__ */ new ue(), nf = /* @__PURE__ */ new Vt();
class Tn {
  constructor(e, i, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = i, this.count = e !== void 0 ? e.length / i : 0, this.normalized = n, this.usage = Bm, this.updateRanges = [], this.gpuType = on, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, i) {
    this.updateRanges.push({ start: e, count: i });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, i, n) {
    e *= this.itemSize, n *= i.itemSize;
    for (let s = 0, a = this.itemSize; s < a; s++)
      this.array[e + s] = i.array[n + s];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let i = 0, n = this.count; i < n; i++)
        nf.fromBufferAttribute(this, i), nf.applyMatrix3(e), this.setXY(i, nf.x, nf.y);
    else if (this.itemSize === 3)
      for (let i = 0, n = this.count; i < n; i++)
        Ii.fromBufferAttribute(this, i), Ii.applyMatrix3(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Ii.fromBufferAttribute(this, i), Ii.applyMatrix4(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Ii.fromBufferAttribute(this, i), Ii.applyNormalMatrix(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      Ii.fromBufferAttribute(this, i), Ii.transformDirection(e), this.setXYZ(i, Ii.x, Ii.y, Ii.z);
    return this;
  }
  set(e, i = 0) {
    return this.array.set(e, i), this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.itemSize + i];
    return this.normalized && (n = Mr(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = St(n, this.array)), this.array[e * this.itemSize + i] = n, this;
  }
  getX(e) {
    let i = this.array[e * this.itemSize];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setX(e, i) {
    return this.normalized && (i = St(i, this.array)), this.array[e * this.itemSize] = i, this;
  }
  getY(e) {
    let i = this.array[e * this.itemSize + 1];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setY(e, i) {
    return this.normalized && (i = St(i, this.array)), this.array[e * this.itemSize + 1] = i, this;
  }
  getZ(e) {
    let i = this.array[e * this.itemSize + 2];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setZ(e, i) {
    return this.normalized && (i = St(i, this.array)), this.array[e * this.itemSize + 2] = i, this;
  }
  getW(e) {
    let i = this.array[e * this.itemSize + 3];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setW(e, i) {
    return this.normalized && (i = St(i, this.array)), this.array[e * this.itemSize + 3] = i, this;
  }
  setXY(e, i, n) {
    return e *= this.itemSize, this.normalized && (i = St(i, this.array), n = St(n, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e *= this.itemSize, this.normalized && (i = St(i, this.array), n = St(n, this.array), s = St(s, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e *= this.itemSize, this.normalized && (i = St(i, this.array), n = St(n, this.array), s = St(s, this.array), a = St(a, this.array)), this.array[e + 0] = i, this.array[e + 1] = n, this.array[e + 2] = s, this.array[e + 3] = a, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Bm && (e.usage = this.usage), e;
  }
}
class m3 extends Tn {
  constructor(e, i, n) {
    super(new Uint16Array(e), i, n);
  }
}
class g3 extends Tn {
  constructor(e, i, n) {
    super(new Uint32Array(e), i, n);
  }
}
class y3 extends Tn {
  constructor(e, i, n) {
    super(new Uint16Array(e), i, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let i = rf(this.array[e * this.itemSize]);
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setX(e, i) {
    return this.normalized && (i = St(i, this.array)), this.array[e * this.itemSize] = Jr(i), this;
  }
  getY(e) {
    let i = rf(this.array[e * this.itemSize + 1]);
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setY(e, i) {
    return this.normalized && (i = St(i, this.array)), this.array[e * this.itemSize + 1] = Jr(i), this;
  }
  getZ(e) {
    let i = rf(this.array[e * this.itemSize + 2]);
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setZ(e, i) {
    return this.normalized && (i = St(i, this.array)), this.array[e * this.itemSize + 2] = Jr(i), this;
  }
  getW(e) {
    let i = rf(this.array[e * this.itemSize + 3]);
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setW(e, i) {
    return this.normalized && (i = St(i, this.array)), this.array[e * this.itemSize + 3] = Jr(i), this;
  }
  setXY(e, i, n) {
    return e *= this.itemSize, this.normalized && (i = St(i, this.array), n = St(n, this.array)), this.array[e + 0] = Jr(i), this.array[e + 1] = Jr(n), this;
  }
  setXYZ(e, i, n, s) {
    return e *= this.itemSize, this.normalized && (i = St(i, this.array), n = St(n, this.array), s = St(s, this.array)), this.array[e + 0] = Jr(i), this.array[e + 1] = Jr(n), this.array[e + 2] = Jr(s), this;
  }
  setXYZW(e, i, n, s, a) {
    return e *= this.itemSize, this.normalized && (i = St(i, this.array), n = St(n, this.array), s = St(s, this.array), a = St(a, this.array)), this.array[e + 0] = Jr(i), this.array[e + 1] = Jr(n), this.array[e + 2] = Jr(s), this.array[e + 3] = Jr(a), this;
  }
}
class ga extends Tn {
  constructor(e, i, n) {
    super(new Float32Array(e), i, n);
  }
}
let Y7 = 0;
const pn = /* @__PURE__ */ new gi(), O0 = /* @__PURE__ */ new Qi(), gu = /* @__PURE__ */ new ue(), en = /* @__PURE__ */ new Qd(), bh = /* @__PURE__ */ new Qd(), Xi = /* @__PURE__ */ new ue();
class Il extends zc {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Y7++ }), this.uuid = fa(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (R7(e) ? g3 : m3)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, i) {
    return this.attributes[e] = i, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, i, n = 0) {
    this.groups.push({
      start: e,
      count: i,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, i) {
    this.drawRange.start = e, this.drawRange.count = i;
  }
  applyMatrix4(e) {
    const i = this.attributes.position;
    i !== void 0 && (i.applyMatrix4(e), i.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const a = new Xr().getNormalMatrix(e);
      n.applyNormalMatrix(a), n.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return pn.makeRotationFromQuaternion(e), this.applyMatrix4(pn), this;
  }
  rotateX(e) {
    return pn.makeRotationX(e), this.applyMatrix4(pn), this;
  }
  rotateY(e) {
    return pn.makeRotationY(e), this.applyMatrix4(pn), this;
  }
  rotateZ(e) {
    return pn.makeRotationZ(e), this.applyMatrix4(pn), this;
  }
  translate(e, i, n) {
    return pn.makeTranslation(e, i, n), this.applyMatrix4(pn), this;
  }
  scale(e, i, n) {
    return pn.makeScale(e, i, n), this.applyMatrix4(pn), this;
  }
  lookAt(e) {
    return O0.lookAt(e), O0.updateMatrix(), this.applyMatrix4(O0.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(gu).negate(), this.translate(gu.x, gu.y, gu.z), this;
  }
  setFromPoints(e) {
    const i = this.getAttribute("position");
    if (i === void 0) {
      const n = [];
      for (let s = 0, a = e.length; s < a; s++) {
        const o = e[s];
        n.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new ga(n, 3));
    } else {
      for (let n = 0, s = i.count; n < s; n++) {
        const a = e[n];
        i.setXYZ(n, a.x, a.y, a.z || 0);
      }
      e.length > i.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), i.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Qd());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new ue(-1 / 0, -1 / 0, -1 / 0),
        new ue(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), i)
        for (let n = 0, s = i.length; n < s; n++) {
          const a = i[n];
          en.setFromBufferAttribute(a), this.morphTargetsRelative ? (Xi.addVectors(this.boundingBox.min, en.min), this.boundingBox.expandByPoint(Xi), Xi.addVectors(this.boundingBox.max, en.max), this.boundingBox.expandByPoint(Xi)) : (this.boundingBox.expandByPoint(en.min), this.boundingBox.expandByPoint(en.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new h1());
    const e = this.attributes.position, i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new ue(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (en.setFromBufferAttribute(e), i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a];
          bh.setFromBufferAttribute(l), this.morphTargetsRelative ? (Xi.addVectors(en.min, bh.min), en.expandByPoint(Xi), Xi.addVectors(en.max, bh.max), en.expandByPoint(Xi)) : (en.expandByPoint(bh.min), en.expandByPoint(bh.max));
        }
      en.getCenter(n);
      let s = 0;
      for (let a = 0, o = e.count; a < o; a++)
        Xi.fromBufferAttribute(e, a), s = Math.max(s, n.distanceToSquared(Xi));
      if (i)
        for (let a = 0, o = i.length; a < o; a++) {
          const l = i[a], u = this.morphTargetsRelative;
          for (let c = 0, h = l.count; c < h; c++)
            Xi.fromBufferAttribute(l, c), u && (gu.fromBufferAttribute(e, c), Xi.add(gu)), s = Math.max(s, n.distanceToSquared(Xi));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, i = this.attributes;
    if (e === null || i.position === void 0 || i.normal === void 0 || i.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = i.position, s = i.normal, a = i.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Tn(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"), l = [], u = [];
    for (let C = 0; C < n.count; C++)
      l[C] = new ue(), u[C] = new ue();
    const c = new ue(), h = new ue(), d = new ue(), p = new Vt(), f = new Vt(), m = new Vt(), y = new ue(), v = new ue();
    function g(C, S, w) {
      c.fromBufferAttribute(n, C), h.fromBufferAttribute(n, S), d.fromBufferAttribute(n, w), p.fromBufferAttribute(a, C), f.fromBufferAttribute(a, S), m.fromBufferAttribute(a, w), h.sub(c), d.sub(c), f.sub(p), m.sub(p);
      const R = 1 / (f.x * m.y - m.x * f.y);
      isFinite(R) && (y.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(R), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(R), l[C].add(y), l[S].add(y), l[w].add(y), u[C].add(v), u[S].add(v), u[w].add(v));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{
      start: 0,
      count: e.count
    }]);
    for (let C = 0, S = _.length; C < S; ++C) {
      const w = _[C], R = w.start, O = w.count;
      for (let P = R, A = R + O; P < A; P += 3)
        g(
          e.getX(P + 0),
          e.getX(P + 1),
          e.getX(P + 2)
        );
    }
    const x = new ue(), b = new ue(), T = new ue(), E = new ue();
    function M(C) {
      T.fromBufferAttribute(s, C), E.copy(T);
      const S = l[C];
      x.copy(S), x.sub(T.multiplyScalar(T.dot(S))).normalize(), b.crossVectors(E, S);
      const w = b.dot(u[C]) < 0 ? -1 : 1;
      o.setXYZW(C, x.x, x.y, x.z, w);
    }
    for (let C = 0, S = _.length; C < S; ++C) {
      const w = _[C], R = w.start, O = w.count;
      for (let P = R, A = R + O; P < A; P += 3)
        M(e.getX(P + 0)), M(e.getX(P + 1)), M(e.getX(P + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, i = this.getAttribute("position");
    if (i !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Tn(new Float32Array(i.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let p = 0, f = n.count; p < f; p++)
          n.setXYZ(p, 0, 0, 0);
      const s = new ue(), a = new ue(), o = new ue(), l = new ue(), u = new ue(), c = new ue(), h = new ue(), d = new ue();
      if (e)
        for (let p = 0, f = e.count; p < f; p += 3) {
          const m = e.getX(p + 0), y = e.getX(p + 1), v = e.getX(p + 2);
          s.fromBufferAttribute(i, m), a.fromBufferAttribute(i, y), o.fromBufferAttribute(i, v), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, y), c.fromBufferAttribute(n, v), l.add(h), u.add(h), c.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(y, u.x, u.y, u.z), n.setXYZ(v, c.x, c.y, c.z);
        }
      else
        for (let p = 0, f = i.count; p < f; p += 3)
          s.fromBufferAttribute(i, p + 0), a.fromBufferAttribute(i, p + 1), o.fromBufferAttribute(i, p + 2), h.subVectors(o, a), d.subVectors(s, a), h.cross(d), n.setXYZ(p + 0, h.x, h.y, h.z), n.setXYZ(p + 1, h.x, h.y, h.z), n.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let i = 0, n = e.count; i < n; i++)
      Xi.fromBufferAttribute(e, i), Xi.normalize(), e.setXYZ(i, Xi.x, Xi.y, Xi.z);
  }
  toNonIndexed() {
    function e(l, u) {
      const c = l.array, h = l.itemSize, d = l.normalized, p = new c.constructor(u.length * h);
      let f = 0, m = 0;
      for (let y = 0, v = u.length; y < v; y++) {
        l.isInterleavedBufferAttribute ? f = u[y] * l.data.stride + l.offset : f = u[y] * h;
        for (let g = 0; g < h; g++)
          p[m++] = c[f++];
      }
      return new Tn(p, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const i = new Il(), n = this.index.array, s = this.attributes;
    for (const l in s) {
      const u = s[l], c = e(u, n);
      i.setAttribute(l, c);
    }
    const a = this.morphAttributes;
    for (const l in a) {
      const u = [], c = a[l];
      for (let h = 0, d = c.length; h < d; h++) {
        const p = c[h], f = e(p, n);
        u.push(f);
      }
      i.morphAttributes[l] = u;
    }
    i.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const c = o[l];
      i.addGroup(c.start, c.count, c.materialIndex);
    }
    return i;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const u = this.parameters;
      for (const c in u)
        u[c] !== void 0 && (e[c] = u[c]);
      return e;
    }
    e.data = { attributes: {} };
    const i = this.index;
    i !== null && (e.data.index = {
      type: i.array.constructor.name,
      array: Array.prototype.slice.call(i.array)
    });
    const n = this.attributes;
    for (const u in n) {
      const c = n[u];
      e.data.attributes[u] = c.toJSON(e.data);
    }
    const s = {};
    let a = !1;
    for (const u in this.morphAttributes) {
      const c = this.morphAttributes[u], h = [];
      for (let d = 0, p = c.length; d < p; d++) {
        const f = c[d];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (s[u] = h, a = !0);
    }
    a && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const i = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(i));
    const s = e.attributes;
    for (const c in s) {
      const h = s[c];
      this.setAttribute(c, h.clone(i));
    }
    const a = e.morphAttributes;
    for (const c in a) {
      const h = [], d = a[c];
      for (let p = 0, f = d.length; p < f; p++)
        h.push(d[p].clone(i));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = e.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const ZE = /* @__PURE__ */ new gi(), ko = /* @__PURE__ */ new F7(), sf = /* @__PURE__ */ new h1(), QE = /* @__PURE__ */ new ue(), af = /* @__PURE__ */ new ue(), of = /* @__PURE__ */ new ue(), lf = /* @__PURE__ */ new ue(), D0 = /* @__PURE__ */ new ue(), uf = /* @__PURE__ */ new ue(), $E = /* @__PURE__ */ new ue(), cf = /* @__PURE__ */ new ue();
class El extends Qi {
  constructor(e = new Il(), i = new Pg()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = i, this.updateMorphTargets();
  }
  copy(e, i) {
    return super.copy(e, i), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, i = Object.keys(e);
    if (i.length > 0) {
      const n = e[i[0]];
      if (n !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
        }
      }
    }
  }
  getVertexPosition(e, i) {
    const n = this.geometry, s = n.attributes.position, a = n.morphAttributes.position, o = n.morphTargetsRelative;
    i.fromBufferAttribute(s, e);
    const l = this.morphTargetInfluences;
    if (a && l) {
      uf.set(0, 0, 0);
      for (let u = 0, c = a.length; u < c; u++) {
        const h = l[u], d = a[u];
        h !== 0 && (D0.fromBufferAttribute(d, e), o ? uf.addScaledVector(D0, h) : uf.addScaledVector(D0.sub(i), h));
      }
      i.add(uf);
    }
    return i;
  }
  raycast(e, i) {
    const n = this.geometry, s = this.material, a = this.matrixWorld;
    s !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), sf.copy(n.boundingSphere), sf.applyMatrix4(a), ko.copy(e.ray).recast(e.near), !(sf.containsPoint(ko.origin) === !1 && (ko.intersectSphere(sf, QE) === null || ko.origin.distanceToSquared(QE) > (e.far - e.near) ** 2)) && (ZE.copy(a).invert(), ko.copy(e.ray).applyMatrix4(ZE), !(n.boundingBox !== null && ko.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, i, ko)));
  }
  _computeIntersections(e, i, n) {
    let s;
    const a = this.geometry, o = this.material, l = a.index, u = a.attributes.position, c = a.attributes.uv, h = a.attributes.uv1, d = a.attributes.normal, p = a.groups, f = a.drawRange;
    if (l !== null)
      if (Array.isArray(o))
        for (let m = 0, y = p.length; m < y; m++) {
          const v = p[m], g = o[v.materialIndex], _ = Math.max(v.start, f.start), x = Math.min(l.count, Math.min(v.start + v.count, f.start + f.count));
          for (let b = _, T = x; b < T; b += 3) {
            const E = l.getX(b), M = l.getX(b + 1), C = l.getX(b + 2);
            s = hf(this, g, e, n, c, h, d, E, M, C), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = v.materialIndex, i.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), y = Math.min(l.count, f.start + f.count);
        for (let v = m, g = y; v < g; v += 3) {
          const _ = l.getX(v), x = l.getX(v + 1), b = l.getX(v + 2);
          s = hf(this, o, e, n, c, h, d, _, x, b), s && (s.faceIndex = Math.floor(v / 3), i.push(s));
        }
      }
    else if (u !== void 0)
      if (Array.isArray(o))
        for (let m = 0, y = p.length; m < y; m++) {
          const v = p[m], g = o[v.materialIndex], _ = Math.max(v.start, f.start), x = Math.min(u.count, Math.min(v.start + v.count, f.start + f.count));
          for (let b = _, T = x; b < T; b += 3) {
            const E = b, M = b + 1, C = b + 2;
            s = hf(this, g, e, n, c, h, d, E, M, C), s && (s.faceIndex = Math.floor(b / 3), s.face.materialIndex = v.materialIndex, i.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), y = Math.min(u.count, f.start + f.count);
        for (let v = m, g = y; v < g; v += 3) {
          const _ = v, x = v + 1, b = v + 2;
          s = hf(this, o, e, n, c, h, d, _, x, b), s && (s.faceIndex = Math.floor(v / 3), i.push(s));
        }
      }
  }
}
function K7(r, e, i, n, s, a, o, l) {
  let u;
  if (e.side === Qn ? u = n.intersectTriangle(o, a, s, !0, l) : u = n.intersectTriangle(s, a, o, e.side === bc, l), u === null) return null;
  cf.copy(l), cf.applyMatrix4(r.matrixWorld);
  const c = i.ray.origin.distanceTo(cf);
  return c < i.near || c > i.far ? null : {
    distance: c,
    point: cf.clone(),
    object: r
  };
}
function hf(r, e, i, n, s, a, o, l, u, c) {
  r.getVertexPosition(l, af), r.getVertexPosition(u, of), r.getVertexPosition(c, lf);
  const h = K7(r, e, i, n, af, of, lf, $E);
  if (h) {
    const d = new ue();
    qn.getBarycoord($E, af, of, lf, d), s && (h.uv = qn.getInterpolatedAttribute(s, l, u, c, d, new Vt())), a && (h.uv1 = qn.getInterpolatedAttribute(a, l, u, c, d, new Vt())), o && (h.normal = qn.getInterpolatedAttribute(o, l, u, c, d, new ue()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const p = {
      a: l,
      b: u,
      c,
      normal: new ue(),
      materialIndex: 0
    };
    qn.getNormal(af, of, lf, p.normal), h.face = p, h.barycoord = d;
  }
  return h;
}
class $d extends Il {
  constructor(e = 1, i = 1, n = 1, s = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: i,
      depth: n,
      widthSegments: s,
      heightSegments: a,
      depthSegments: o
    };
    const l = this;
    s = Math.floor(s), a = Math.floor(a), o = Math.floor(o);
    const u = [], c = [], h = [], d = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, n, i, e, o, a, 0), m("z", "y", "x", 1, -1, n, i, -e, o, a, 1), m("x", "z", "y", 1, 1, e, n, i, s, o, 2), m("x", "z", "y", 1, -1, e, n, -i, s, o, 3), m("x", "y", "z", 1, -1, e, i, n, s, a, 4), m("x", "y", "z", -1, -1, e, i, -n, s, a, 5), this.setIndex(u), this.setAttribute("position", new ga(c, 3)), this.setAttribute("normal", new ga(h, 3)), this.setAttribute("uv", new ga(d, 2));
    function m(y, v, g, _, x, b, T, E, M, C, S) {
      const w = b / M, R = T / C, O = b / 2, P = T / 2, A = E / 2, D = M + 1, L = C + 1;
      let H = 0, V = 0;
      const X = new ue();
      for (let F = 0; F < L; F++) {
        const B = F * R - P;
        for (let W = 0; W < D; W++) {
          const G = W * w - O;
          X[y] = G * _, X[v] = B * x, X[g] = A, c.push(X.x, X.y, X.z), X[y] = 0, X[v] = 0, X[g] = E > 0 ? 1 : -1, h.push(X.x, X.y, X.z), d.push(W / M), d.push(1 - F / C), H += 1;
        }
      }
      for (let F = 0; F < C; F++)
        for (let B = 0; B < M; B++) {
          const W = p + B + D * F, G = p + B + D * (F + 1), z = p + (B + 1) + D * (F + 1), K = p + (B + 1) + D * F;
          u.push(W, G, K), u.push(G, z, K), V += 6;
        }
      l.addGroup(f, V, S), f += V, p += H;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new $d(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function v3(r) {
  const e = {};
  for (const i in r) {
    e[i] = {};
    for (const n in r[i]) {
      const s = r[i][n];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][n] = null) : e[i][n] = s.clone() : Array.isArray(s) ? e[i][n] = s.slice() : e[i][n] = s;
    }
  }
  return e;
}
function Z7(r) {
  const e = [];
  for (let i = 0; i < r.length; i++)
    e.push(r[i].clone());
  return e;
}
var Q7 = (
  /* glsl */
  `
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`
), $7 = (
  /* glsl */
  `
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`
);
class J7 extends Hr {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Q7, this.fragmentShader = $7, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = v3(e.uniforms), this.uniformsGroups = Z7(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    i.glslVersion = this.glslVersion, i.uniforms = {};
    for (const s in this.uniforms) {
      const a = this.uniforms[s].value;
      a && a.isTexture ? i.uniforms[s] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? i.uniforms[s] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? i.uniforms[s] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? i.uniforms[s] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? i.uniforms[s] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? i.uniforms[s] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? i.uniforms[s] = {
        type: "m4",
        value: a.toArray()
      } : i.uniforms[s] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (i.defines = this.defines), i.vertexShader = this.vertexShader, i.fragmentShader = this.fragmentShader, i.lights = this.lights, i.clipping = this.clipping;
    const n = {};
    for (const s in this.extensions)
      this.extensions[s] === !0 && (n[s] = !0);
    return Object.keys(n).length > 0 && (i.extensions = n), i;
  }
}
class b3 extends Qi {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new gi(), this.projectionMatrix = new gi(), this.projectionMatrixInverse = new gi(), this.coordinateSystem = Kn;
  }
  copy(e, i) {
    return super.copy(e, i), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, i) {
    super.updateWorldMatrix(e, i), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Va = /* @__PURE__ */ new ue(), JE = /* @__PURE__ */ new Vt(), e2 = /* @__PURE__ */ new Vt();
class Ys extends b3 {
  constructor(e = 50, i = 1, n = 0.1, s = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = s, this.focus = 10, this.aspect = i, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, i) {
    return super.copy(e, i), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const i = 0.5 * this.getFilmHeight() / e;
    this.fov = vd * 2 * Math.atan(i), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(ed * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return vd * 2 * Math.atan(
      Math.tan(ed * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, i, n) {
    Va.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Va.x, Va.y).multiplyScalar(-e / Va.z), Va.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Va.x, Va.y).multiplyScalar(-e / Va.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, i) {
    return this.getViewBounds(e, JE, e2), i.subVectors(e2, JE);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, i, n, s, a, o) {
    this.aspect = e / i, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = i, this.view.offsetX = n, this.view.offsetY = s, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let i = e * Math.tan(ed * 0.5 * this.fov) / this.zoom, n = 2 * i, s = this.aspect * n, a = -0.5 * s;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = o.fullWidth, c = o.fullHeight;
      a += o.offsetX * s / u, i -= o.offsetY * n / c, s *= o.width / u, n *= o.height / c;
    }
    const l = this.filmOffset;
    l !== 0 && (a += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + s, i, i - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.fov = this.fov, i.object.zoom = this.zoom, i.object.near = this.near, i.object.far = this.far, i.object.focus = this.focus, i.object.aspect = this.aspect, this.view !== null && (i.object.view = Object.assign({}, this.view)), i.object.filmGauge = this.filmGauge, i.object.filmOffset = this.filmOffset, i;
  }
}
const yu = -90, vu = 1;
class x3 extends Qi {
  constructor(e, i, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const s = new Ys(yu, vu, e, i);
    s.layers = this.layers, this.add(s);
    const a = new Ys(yu, vu, e, i);
    a.layers = this.layers, this.add(a);
    const o = new Ys(yu, vu, e, i);
    o.layers = this.layers, this.add(o);
    const l = new Ys(yu, vu, e, i);
    l.layers = this.layers, this.add(l);
    const u = new Ys(yu, vu, e, i);
    u.layers = this.layers, this.add(u);
    const c = new Ys(yu, vu, e, i);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, i = this.children.concat(), [n, s, a, o, l, u] = i;
    for (const c of i) this.remove(c);
    if (e === Kn)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), a.up.set(0, 0, -1), a.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), u.up.set(0, 1, 0), u.lookAt(0, 0, -1);
    else if (e === Sl)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), a.up.set(0, 0, 1), a.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), u.up.set(0, -1, 0), u.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const c of i)
      this.add(c), c.updateMatrixWorld();
  }
  update(e, i) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: s } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [a, o, l, u, c, h] = this.children, d = e.getRenderTarget(), p = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = !1;
    const y = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, s), e.render(i, a), e.setRenderTarget(n, 1, s), e.render(i, o), e.setRenderTarget(n, 2, s), e.render(i, l), e.setRenderTarget(n, 3, s), e.render(i, u), e.setRenderTarget(n, 4, s), e.render(i, c), n.texture.generateMipmaps = y, e.setRenderTarget(n, 5, s), e.render(i, h), e.setRenderTarget(d, p, f), e.xr.enabled = m, n.texture.needsPMREMUpdate = !0;
  }
}
class d1 extends Cr {
  constructor(e, i, n, s, a, o, l, u, c, h) {
    e = e !== void 0 ? e : [], i = i !== void 0 ? i : Tl, super(e, i, n, s, a, o, l, u, c, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class eW extends L7 {
  constructor(e = 1, i = {}) {
    super(e, e, i), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, s = [n, n, n, n, n, n];
    this.texture = new d1(s, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : ln;
  }
  fromEquirectangularTexture(e, i) {
    this.texture.type = i.type, this.texture.colorSpace = i.colorSpace, this.texture.generateMipmaps = i.generateMipmaps, this.texture.minFilter = i.minFilter, this.texture.magFilter = i.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, s = new $d(5, 5, 5), a = new J7({
      name: "CubemapFromEquirect",
      uniforms: v3(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: Qn,
      blending: xc
    });
    a.uniforms.tEquirect.value = i;
    const o = new El(s, a), l = i.minFilter;
    return i.minFilter === da && (i.minFilter = ln), new x3(1, 10, this).update(e, o), i.minFilter = l, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, i, n, s) {
    const a = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(i, n, s);
    e.setRenderTarget(a);
  }
}
class _3 extends Qi {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new $n(), this.environmentIntensity = 1, this.environmentRotation = new $n(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, i) {
    return super.copy(e, i), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return this.fog !== null && (i.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (i.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (i.object.backgroundIntensity = this.backgroundIntensity), i.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (i.object.environmentIntensity = this.environmentIntensity), i.object.environmentRotation = this.environmentRotation.toArray(), i;
  }
}
class T3 {
  constructor(e, i) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = i, this.count = e !== void 0 ? e.length / i : 0, this.usage = Bm, this.updateRanges = [], this.version = 0, this.uuid = fa();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, i) {
    this.updateRanges.push({ start: e, count: i });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, i, n) {
    e *= this.stride, n *= i.stride;
    for (let s = 0, a = this.stride; s < a; s++)
      this.array[e + s] = i.array[n + s];
    return this;
  }
  set(e, i = 0) {
    return this.array.set(e, i), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fa()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const i = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(i, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fa()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const xr = /* @__PURE__ */ new ue();
class p1 {
  constructor(e, i, n, s = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = i, this.offset = n, this.normalized = s;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.data.count; i < n; i++)
      xr.fromBufferAttribute(this, i), xr.applyMatrix4(e), this.setXYZ(i, xr.x, xr.y, xr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      xr.fromBufferAttribute(this, i), xr.applyNormalMatrix(e), this.setXYZ(i, xr.x, xr.y, xr.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      xr.fromBufferAttribute(this, i), xr.transformDirection(e), this.setXYZ(i, xr.x, xr.y, xr.z);
    return this;
  }
  getComponent(e, i) {
    let n = this.array[e * this.data.stride + this.offset + i];
    return this.normalized && (n = Mr(n, this.array)), n;
  }
  setComponent(e, i, n) {
    return this.normalized && (n = St(n, this.array)), this.data.array[e * this.data.stride + this.offset + i] = n, this;
  }
  setX(e, i) {
    return this.normalized && (i = St(i, this.array)), this.data.array[e * this.data.stride + this.offset] = i, this;
  }
  setY(e, i) {
    return this.normalized && (i = St(i, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = i, this;
  }
  setZ(e, i) {
    return this.normalized && (i = St(i, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = i, this;
  }
  setW(e, i) {
    return this.normalized && (i = St(i, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = i, this;
  }
  getX(e) {
    let i = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  getY(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  getZ(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  getW(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (i = Mr(i, this.array)), i;
  }
  setXY(e, i, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = St(i, this.array), n = St(n, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, i, n, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = St(i, this.array), n = St(n, this.array), s = St(s, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this;
  }
  setXYZW(e, i, n, s, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (i = St(i, this.array), n = St(n, this.array), s = St(s, this.array), a = St(a, this.array)), this.data.array[e + 0] = i, this.data.array[e + 1] = n, this.data.array[e + 2] = s, this.data.array[e + 3] = a, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return new Tn(new this.array.constructor(i), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new p1(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const s = n * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          i.push(this.data.array[s + a]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: i,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class w3 extends Hr {
  static get type() {
    return "SpriteMaterial";
  }
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.color = new Zt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
class tW extends Cr {
  constructor(e = null, i = 1, n = 1, s, a, o, l, u, c = yr, h = yr, d, p) {
    super(null, o, l, u, c, h, s, a, d, p), this.isDataTexture = !0, this.image = { data: e, width: i, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class iW extends Tn {
  constructor(e, i, n, s = 1) {
    super(e, i, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const L0 = /* @__PURE__ */ new ue(), rW = /* @__PURE__ */ new ue(), nW = /* @__PURE__ */ new Xr();
class Za {
  constructor(e = new ue(1, 0, 0), i = 0) {
    this.isPlane = !0, this.normal = e, this.constant = i;
  }
  set(e, i) {
    return this.normal.copy(e), this.constant = i, this;
  }
  setComponents(e, i, n, s) {
    return this.normal.set(e, i, n), this.constant = s, this;
  }
  setFromNormalAndCoplanarPoint(e, i) {
    return this.normal.copy(e), this.constant = -i.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, i, n) {
    const s = L0.subVectors(n, i).cross(rW.subVectors(e, i)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, i) {
    return i.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, i) {
    const n = e.delta(L0), s = this.normal.dot(n);
    if (s === 0)
      return this.distanceToPoint(e.start) === 0 ? i.copy(e.start) : null;
    const a = -(e.start.dot(this.normal) + this.constant) / s;
    return a < 0 || a > 1 ? null : i.copy(e.start).addScaledVector(n, a);
  }
  intersectsLine(e) {
    const i = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return i < 0 && n > 0 || n < 0 && i > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, i) {
    const n = i || nW.getNormalMatrix(e), s = this.coplanarPoint(L0).applyMatrix4(e), a = this.normal.applyMatrix3(n).normalize();
    return this.constant = -s.dot(a), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Uo = /* @__PURE__ */ new h1(), df = /* @__PURE__ */ new ue();
class S3 {
  constructor(e = new Za(), i = new Za(), n = new Za(), s = new Za(), a = new Za(), o = new Za()) {
    this.planes = [e, i, n, s, a, o];
  }
  set(e, i, n, s, a, o) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(i), l[2].copy(n), l[3].copy(s), l[4].copy(a), l[5].copy(o), this;
  }
  copy(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++)
      i[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, i = Kn) {
    const n = this.planes, s = e.elements, a = s[0], o = s[1], l = s[2], u = s[3], c = s[4], h = s[5], d = s[6], p = s[7], f = s[8], m = s[9], y = s[10], v = s[11], g = s[12], _ = s[13], x = s[14], b = s[15];
    if (n[0].setComponents(u - a, p - c, v - f, b - g).normalize(), n[1].setComponents(u + a, p + c, v + f, b + g).normalize(), n[2].setComponents(u + o, p + h, v + m, b + _).normalize(), n[3].setComponents(u - o, p - h, v - m, b - _).normalize(), n[4].setComponents(u - l, p - d, v - y, b - x).normalize(), i === Kn)
      n[5].setComponents(u + l, p + d, v + y, b + x).normalize();
    else if (i === Sl)
      n[5].setComponents(l, d, y, x).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + i);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Uo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const i = e.geometry;
      i.boundingSphere === null && i.computeBoundingSphere(), Uo.copy(i.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Uo);
  }
  intersectsSprite(e) {
    return Uo.center.set(0, 0, 0), Uo.radius = 0.7071067811865476, Uo.applyMatrix4(e.matrixWorld), this.intersectsSphere(Uo);
  }
  intersectsSphere(e) {
    const i = this.planes, n = e.center, s = -e.radius;
    for (let a = 0; a < 6; a++)
      if (i[a].distanceToPoint(n) < s)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++) {
      const s = i[n];
      if (df.x = s.normal.x > 0 ? e.max.x : e.min.x, df.y = s.normal.y > 0 ? e.max.y : e.min.y, df.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(df) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++)
      if (i[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class f1 extends Hr {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.color = new Zt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
class E3 extends Hr {
  static get type() {
    return "PointsMaterial";
  }
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.color = new Zt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
class sW extends Cr {
  constructor(e, i) {
    super({ width: e, height: i }), this.isFramebufferTexture = !0, this.magFilter = yr, this.minFilter = yr, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class Vc extends Cr {
  constructor(e, i, n, s, a, o, l, u, c, h = gl) {
    if (h !== gl && h !== Tc)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && h === gl && (n = er), n === void 0 && h === Tc && (n = Kd), super(null, s, a, o, l, u, h, n, c), this.isDepthTexture = !0, this.image = { width: e, height: i }, this.magFilter = l !== void 0 ? l : yr, this.minFilter = u !== void 0 ? u : yr, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return this.compareFunction !== null && (i.compareFunction = this.compareFunction), i;
  }
}
class m1 extends Il {
  constructor(e = 1, i = 32, n = 16, s = 0, a = Math.PI * 2, o = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: i,
      heightSegments: n,
      phiStart: s,
      phiLength: a,
      thetaStart: o,
      thetaLength: l
    }, i = Math.max(3, Math.floor(i)), n = Math.max(2, Math.floor(n));
    const u = Math.min(o + l, Math.PI);
    let c = 0;
    const h = [], d = new ue(), p = new ue(), f = [], m = [], y = [], v = [];
    for (let g = 0; g <= n; g++) {
      const _ = [], x = g / n;
      let b = 0;
      g === 0 && o === 0 ? b = 0.5 / i : g === n && u === Math.PI && (b = -0.5 / i);
      for (let T = 0; T <= i; T++) {
        const E = T / i;
        d.x = -e * Math.cos(s + E * a) * Math.sin(o + x * l), d.y = e * Math.cos(o + x * l), d.z = e * Math.sin(s + E * a) * Math.sin(o + x * l), m.push(d.x, d.y, d.z), p.copy(d).normalize(), y.push(p.x, p.y, p.z), v.push(E + b, 1 - x), _.push(c++);
      }
      h.push(_);
    }
    for (let g = 0; g < n; g++)
      for (let _ = 0; _ < i; _++) {
        const x = h[g][_ + 1], b = h[g][_], T = h[g + 1][_], E = h[g + 1][_ + 1];
        (g !== 0 || o > 0) && f.push(x, b, E), (g !== n - 1 || u < Math.PI) && f.push(b, T, E);
      }
    this.setIndex(f), this.setAttribute("position", new ga(m, 3)), this.setAttribute("normal", new ga(y, 3)), this.setAttribute("uv", new ga(v, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new m1(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class M3 extends Hr {
  static get type() {
    return "ShadowMaterial";
  }
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.color = new Zt(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class g1 extends Hr {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.color = new Zt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $n(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class A3 extends g1 {
  static get type() {
    return "MeshPhysicalMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return tr(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(i) {
        this.ior = (1 + 0.4 * i) / (1 - 0.4 * i);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Zt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Zt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Zt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class C3 extends Hr {
  static get type() {
    return "MeshPhongMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.color = new Zt(16777215), this.specular = new Zt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $n(), this.combine = Ng, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class R3 extends Hr {
  static get type() {
    return "MeshToonMaterial";
  }
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.color = new Zt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class N3 extends Hr {
  static get type() {
    return "MeshNormalMaterial";
  }
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class P3 extends Hr {
  static get type() {
    return "MeshLambertMaterial";
  }
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.color = new Zt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $n(), this.combine = Ng, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class I3 extends Hr {
  static get type() {
    return "MeshMatcapMaterial";
  }
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.color = new Zt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yo, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class O3 extends f1 {
  static get type() {
    return "LineDashedMaterial";
  }
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
class Ol extends Qi {
  constructor(e, i = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Zt(e), this.intensity = i;
  }
  dispose() {
  }
  copy(e, i) {
    return super.copy(e, i), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.color = this.color.getHex(), i.object.intensity = this.intensity, this.groundColor !== void 0 && (i.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (i.object.distance = this.distance), this.angle !== void 0 && (i.object.angle = this.angle), this.decay !== void 0 && (i.object.decay = this.decay), this.penumbra !== void 0 && (i.object.penumbra = this.penumbra), this.shadow !== void 0 && (i.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (i.object.target = this.target.uuid), i;
  }
}
class aW extends Ol {
  constructor(e, i, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Qi.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Zt(i);
  }
  copy(e, i) {
    return super.copy(e, i), this.groundColor.copy(e.groundColor), this;
  }
}
const k0 = /* @__PURE__ */ new gi(), t2 = /* @__PURE__ */ new ue(), i2 = /* @__PURE__ */ new ue();
class y1 {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vt(512, 512), this.map = null, this.mapPass = null, this.matrix = new gi(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new S3(), this._frameExtents = new Vt(1, 1), this._viewportCount = 1, this._viewports = [
      new Kt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const i = this.camera, n = this.matrix;
    t2.setFromMatrixPosition(e.matrixWorld), i.position.copy(t2), i2.setFromMatrixPosition(e.target.matrixWorld), i.lookAt(i2), i.updateMatrixWorld(), k0.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(k0), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(k0);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class oW extends y1 {
  constructor() {
    super(new Ys(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const i = this.camera, n = vd * 2 * e.angle * this.focus, s = this.mapSize.width / this.mapSize.height, a = e.distance || i.far;
    (n !== i.fov || s !== i.aspect || a !== i.far) && (i.fov = n, i.aspect = s, i.far = a, i.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class D3 extends Ol {
  constructor(e, i, n = 0, s = Math.PI / 3, a = 0, o = 2) {
    super(e, i), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Qi.DEFAULT_UP), this.updateMatrix(), this.target = new Qi(), this.distance = n, this.angle = s, this.penumbra = a, this.decay = o, this.map = null, this.shadow = new oW();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, i) {
    return super.copy(e, i), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const r2 = /* @__PURE__ */ new gi(), xh = /* @__PURE__ */ new ue(), U0 = /* @__PURE__ */ new ue();
class lW extends y1 {
  constructor() {
    super(new Ys(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Vt(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Kt(2, 1, 1, 1),
      // negative X
      new Kt(0, 1, 1, 1),
      // positive Z
      new Kt(3, 1, 1, 1),
      // negative Z
      new Kt(1, 1, 1, 1),
      // positive Y
      new Kt(3, 0, 1, 1),
      // negative Y
      new Kt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new ue(1, 0, 0),
      new ue(-1, 0, 0),
      new ue(0, 0, 1),
      new ue(0, 0, -1),
      new ue(0, 1, 0),
      new ue(0, -1, 0)
    ], this._cubeUps = [
      new ue(0, 1, 0),
      new ue(0, 1, 0),
      new ue(0, 1, 0),
      new ue(0, 1, 0),
      new ue(0, 0, 1),
      new ue(0, 0, -1)
    ];
  }
  updateMatrices(e, i = 0) {
    const n = this.camera, s = this.matrix, a = e.distance || n.far;
    a !== n.far && (n.far = a, n.updateProjectionMatrix()), xh.setFromMatrixPosition(e.matrixWorld), n.position.copy(xh), U0.copy(n.position), U0.add(this._cubeDirections[i]), n.up.copy(this._cubeUps[i]), n.lookAt(U0), n.updateMatrixWorld(), s.makeTranslation(-xh.x, -xh.y, -xh.z), r2.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(r2);
  }
}
class uW extends Ol {
  constructor(e, i, n = 0, s = 2) {
    super(e, i), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = s, this.shadow = new lW();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, i) {
    return super.copy(e, i), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class v1 extends b3 {
  constructor(e = -1, i = 1, n = 1, s = -1, a = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = i, this.top = n, this.bottom = s, this.near = a, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, i) {
    return super.copy(e, i), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, i, n, s, a, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = i, this.view.offsetX = n, this.view.offsetY = s, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), i = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
    let a = n - e, o = n + e, l = s + i, u = s - i;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      a += c * this.view.offsetX, o = a + c * this.view.width, l -= h * this.view.offsetY, u = l - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(a, o, l, u, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.zoom = this.zoom, i.object.left = this.left, i.object.right = this.right, i.object.top = this.top, i.object.bottom = this.bottom, i.object.near = this.near, i.object.far = this.far, this.view !== null && (i.object.view = Object.assign({}, this.view)), i;
  }
}
class cW extends y1 {
  constructor() {
    super(new v1(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class hW extends Ol {
  constructor(e, i) {
    super(e, i), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Qi.DEFAULT_UP), this.updateMatrix(), this.target = new Qi(), this.shadow = new cW();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class dW extends Ol {
  constructor(e, i) {
    super(e, i), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class pW extends Ol {
  constructor(e, i, n = 10, s = 10) {
    super(e, i), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = s;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.width = this.width, i.object.height = this.height, i;
  }
}
class fW {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new ue());
  }
  set(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].copy(e[i]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, i) {
    const n = e.x, s = e.y, a = e.z, o = this.coefficients;
    return i.copy(o[0]).multiplyScalar(0.282095), i.addScaledVector(o[1], 0.488603 * s), i.addScaledVector(o[2], 0.488603 * a), i.addScaledVector(o[3], 0.488603 * n), i.addScaledVector(o[4], 1.092548 * (n * s)), i.addScaledVector(o[5], 1.092548 * (s * a)), i.addScaledVector(o[6], 0.315392 * (3 * a * a - 1)), i.addScaledVector(o[7], 1.092548 * (n * a)), i.addScaledVector(o[8], 0.546274 * (n * n - s * s)), i;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, i) {
    const n = e.x, s = e.y, a = e.z, o = this.coefficients;
    return i.copy(o[0]).multiplyScalar(0.886227), i.addScaledVector(o[1], 2 * 0.511664 * s), i.addScaledVector(o[2], 2 * 0.511664 * a), i.addScaledVector(o[3], 2 * 0.511664 * n), i.addScaledVector(o[4], 2 * 0.429043 * n * s), i.addScaledVector(o[5], 2 * 0.429043 * s * a), i.addScaledVector(o[6], 0.743125 * a * a - 0.247708), i.addScaledVector(o[7], 2 * 0.429043 * n * a), i.addScaledVector(o[8], 0.429043 * (n * n - s * s)), i;
  }
  add(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].add(e.coefficients[i]);
    return this;
  }
  addScaledSH(e, i) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], i);
    return this;
  }
  scale(e) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].multiplyScalar(e);
    return this;
  }
  lerp(e, i) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], i);
    return this;
  }
  equals(e) {
    for (let i = 0; i < 9; i++)
      if (!this.coefficients[i].equals(e.coefficients[i]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, i = 0) {
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].fromArray(e, i + s * 3);
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.coefficients;
    for (let s = 0; s < 9; s++)
      n[s].toArray(e, i + s * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, i) {
    const n = e.x, s = e.y, a = e.z;
    i[0] = 0.282095, i[1] = 0.488603 * s, i[2] = 0.488603 * a, i[3] = 0.488603 * n, i[4] = 1.092548 * n * s, i[5] = 1.092548 * s * a, i[6] = 0.315392 * (3 * a * a - 1), i[7] = 1.092548 * n * a, i[8] = 0.546274 * (n * n - s * s);
  }
}
class mW extends Ol {
  constructor(e = new fW(), i = 1) {
    super(void 0, i), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.object.sh = this.sh.toArray(), i;
  }
}
class gW extends T3 {
  constructor(e, i, n = 1) {
    super(e, i), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const i = super.clone(e);
    return i.meshPerAttribute = this.meshPerAttribute, i;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return i.isInstancedInterleavedBuffer = !0, i.meshPerAttribute = this.meshPerAttribute, i;
  }
}
const yW = [
  "alphaMap",
  "alphaTest",
  "anisotropy",
  "anisotropyMap",
  "anisotropyRotation",
  "aoMap",
  "attenuationColor",
  "attenuationDistance",
  "bumpMap",
  "clearcoat",
  "clearcoatMap",
  "clearcoatNormalMap",
  "clearcoatNormalScale",
  "clearcoatRoughness",
  "color",
  "dispersion",
  "displacementMap",
  "emissive",
  "emissiveMap",
  "envMap",
  "gradientMap",
  "ior",
  "iridescence",
  "iridescenceIOR",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "lightMap",
  "map",
  "matcap",
  "metalness",
  "metalnessMap",
  "normalMap",
  "normalScale",
  "opacity",
  "roughness",
  "roughnessMap",
  "sheen",
  "sheenColor",
  "sheenColorMap",
  "sheenRoughnessMap",
  "shininess",
  "specular",
  "specularColor",
  "specularColorMap",
  "specularIntensity",
  "specularIntensityMap",
  "specularMap",
  "thickness",
  "transmission",
  "transmissionMap"
];
class vW {
  constructor(e) {
    this.renderObjects = /* @__PURE__ */ new WeakMap(), this.hasNode = this.containsNode(e), this.hasAnimation = e.object.isSkinnedMesh === !0, this.refreshUniforms = yW, this.renderId = 0;
  }
  firstInitialization(e) {
    return this.renderObjects.has(e) === !1 ? (this.getRenderObjectData(e), !0) : !1;
  }
  getRenderObjectData(e) {
    let i = this.renderObjects.get(e);
    if (i === void 0) {
      const { geometry: n, material: s } = e;
      if (i = {
        material: this.getMaterialData(s),
        geometry: {
          attributes: this.getAttributesData(n.attributes),
          indexVersion: n.index ? n.index.version : null,
          drawRange: { start: n.drawRange.start, count: n.drawRange.count }
        },
        worldMatrix: e.object.matrixWorld.clone()
      }, e.object.center && (i.center = e.object.center.clone()), e.object.morphTargetInfluences && (i.morphTargetInfluences = e.object.morphTargetInfluences.slice()), e.bundle !== null && (i.version = e.bundle.version), i.material.transmission > 0) {
        const { width: a, height: o } = e.context;
        i.bufferWidth = a, i.bufferHeight = o;
      }
      this.renderObjects.set(e, i);
    }
    return i;
  }
  getAttributesData(e) {
    const i = {};
    for (const n in e) {
      const s = e[n];
      i[n] = {
        version: s.version
      };
    }
    return i;
  }
  containsNode(e) {
    const i = e.material;
    for (const n in i)
      if (i[n] && i[n].isNode)
        return !0;
    return e.renderer.nodes.modelViewMatrix !== null || e.renderer.nodes.modelNormalViewMatrix !== null;
  }
  getMaterialData(e) {
    const i = {};
    for (const n of this.refreshUniforms) {
      const s = e[n];
      s != null && (typeof s == "object" && s.clone !== void 0 ? s.isTexture === !0 ? i[n] = { id: s.id, version: s.version } : i[n] = s.clone() : i[n] = s);
    }
    return i;
  }
  equals(e) {
    const { object: i, material: n, geometry: s } = e, a = this.getRenderObjectData(e);
    if (a.worldMatrix.equals(i.matrixWorld) !== !0)
      return a.worldMatrix.copy(i.matrixWorld), !1;
    const o = a.material;
    for (const y in o) {
      const v = o[y], g = n[y];
      if (v.equals !== void 0) {
        if (v.equals(g) === !1)
          return v.copy(g), !1;
      } else if (g.isTexture === !0) {
        if (v.id !== g.id || v.version !== g.version)
          return v.id = g.id, v.version = g.version, !1;
      } else if (v !== g)
        return o[y] = g, !1;
    }
    if (o.transmission > 0) {
      const { width: y, height: v } = e.context;
      if (a.bufferWidth !== y || a.bufferHeight !== v)
        return a.bufferWidth = y, a.bufferHeight = v, !1;
    }
    const l = a.geometry, u = s.attributes, c = l.attributes, h = Object.keys(c), d = Object.keys(u);
    if (h.length !== d.length)
      return a.geometry.attributes = this.getAttributesData(u), !1;
    for (const y of h) {
      const v = c[y], g = u[y];
      if (g === void 0)
        return delete c[y], !1;
      if (v.version !== g.version)
        return v.version = g.version, !1;
    }
    const p = s.index, f = l.indexVersion, m = p ? p.version : null;
    if (f !== m)
      return l.indexVersion = m, !1;
    if (l.drawRange.start !== s.drawRange.start || l.drawRange.count !== s.drawRange.count)
      return l.drawRange.start = s.drawRange.start, l.drawRange.count = s.drawRange.count, !1;
    if (a.morphTargetInfluences) {
      let y = !1;
      for (let v = 0; v < a.morphTargetInfluences.length; v++)
        a.morphTargetInfluences[v] !== i.morphTargetInfluences[v] && (y = !0);
      if (y) return !0;
    }
    return a.center && a.center.equals(i.center) === !1 ? (a.center.copy(i.center), !0) : (e.bundle !== null && (a.version = e.bundle.version), !0);
  }
  needsRefresh(e, i) {
    if (this.hasNode || this.hasAnimation || this.firstInitialization(e))
      return !0;
    const { renderId: n } = i;
    if (this.renderId !== n)
      return this.renderId = n, !0;
    const s = e.object.static === !0, a = e.bundle !== null && e.bundle.static === !0 && this.getRenderObjectData(e).version === e.bundle.version;
    return s || a ? !1 : this.equals(e) !== !0;
  }
}
function bd(r, e = 0) {
  let i = 3735928559 ^ e, n = 1103547991 ^ e;
  if (r instanceof Array)
    for (let s = 0, a; s < r.length; s++)
      a = r[s], i = Math.imul(i ^ a, 2654435761), n = Math.imul(n ^ a, 1597334677);
  else
    for (let s = 0, a; s < r.length; s++)
      a = r.charCodeAt(s), i = Math.imul(i ^ a, 2654435761), n = Math.imul(n ^ a, 1597334677);
  return i = Math.imul(i ^ i >>> 16, 2246822507), i ^= Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507), n ^= Math.imul(i ^ i >>> 13, 3266489909), 4294967296 * (2097151 & n) + (i >>> 0);
}
const bW = (r) => bd(r), L3 = (r) => bd(r), zm = (...r) => bd(r);
function k3(r, e = !1) {
  const i = [];
  r.isNode === !0 && (i.push(r.id), r = r.getSelf());
  for (const { property: n, childNode: s } of jm(r))
    i.push(i, bd(n.slice(0, -4)), s.getCacheKey(e));
  return bd(i);
}
function* jm(r, e = !1) {
  for (const i in r) {
    if (i.startsWith("_") === !0) continue;
    const n = r[i];
    if (Array.isArray(n) === !0)
      for (let s = 0; s < n.length; s++) {
        const a = n[s];
        a && (a.isNode === !0 || e && typeof a.toJSON == "function") && (yield { property: i, index: s, childNode: a });
      }
    else if (n && n.isNode === !0)
      yield { property: i, childNode: n };
    else if (typeof n == "object")
      for (const s in n) {
        const a = n[s];
        a && (a.isNode === !0 || e && typeof a.toJSON == "function") && (yield { property: i, index: s, childNode: a });
      }
  }
}
function Vm(r) {
  if (r == null) return null;
  const e = typeof r;
  return r.isNode === !0 ? "node" : e === "number" ? "float" : e === "boolean" ? "bool" : e === "string" ? "string" : e === "function" ? "shader" : r.isVector2 === !0 ? "vec2" : r.isVector3 === !0 ? "vec3" : r.isVector4 === !0 ? "vec4" : r.isMatrix3 === !0 ? "mat3" : r.isMatrix4 === !0 ? "mat4" : r.isColor === !0 ? "color" : r instanceof ArrayBuffer ? "ArrayBuffer" : null;
}
function U3(r, ...e) {
  const i = r ? r.slice(-4) : void 0;
  return e.length === 1 && (i === "vec2" ? e = [e[0], e[0]] : i === "vec3" ? e = [e[0], e[0], e[0]] : i === "vec4" && (e = [e[0], e[0], e[0], e[0]])), r === "color" ? new Zt(...e) : i === "vec2" ? new Vt(...e) : i === "vec3" ? new ue(...e) : i === "vec4" ? new Kt(...e) : i === "mat3" ? new Xr(...e) : i === "mat4" ? new gi(...e) : r === "bool" ? e[0] || !1 : r === "float" || r === "int" || r === "uint" ? e[0] || 0 : r === "string" ? e[0] || "" : r === "ArrayBuffer" ? _W(e[0]) : null;
}
function xW(r) {
  let e = "";
  const i = new Uint8Array(r);
  for (let n = 0; n < i.length; n++)
    e += String.fromCharCode(i[n]);
  return btoa(e);
}
function _W(r) {
  return Uint8Array.from(atob(r), (e) => e.charCodeAt(0)).buffer;
}
const n2 = {
  VERTEX: "vertex"
}, Nt = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
}, TW = ["fragment", "vertex"], s2 = ["setup", "analyze", "generate"], a2 = [...TW, "compute"], Gc = ["x", "y", "z", "w"];
let wW = 0;
class Mt extends zc {
  static get type() {
    return "Node";
  }
  constructor(e = null) {
    super(), this.nodeType = e, this.updateType = Nt.NONE, this.updateBeforeType = Nt.NONE, this.updateAfterType = Nt.NONE, this.uuid = C7.generateUUID(), this.version = 0, this._cacheKey = null, this._cacheKeyVersion = 0, this.global = !1, this.isNode = !0, Object.defineProperty(this, "id", { value: wW++ });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get type() {
    return this.constructor.type;
  }
  onUpdate(e, i) {
    return this.updateType = i, this.update = e.bind(this.getSelf()), this;
  }
  onFrameUpdate(e) {
    return this.onUpdate(e, Nt.FRAME);
  }
  onRenderUpdate(e) {
    return this.onUpdate(e, Nt.RENDER);
  }
  onObjectUpdate(e) {
    return this.onUpdate(e, Nt.OBJECT);
  }
  onReference(e) {
    return this.updateReference = e.bind(this.getSelf()), this;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return this.global;
  }
  *getChildren() {
    for (const { childNode: e } of jm(this))
      yield e;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(e) {
    e(this);
    for (const i of this.getChildren())
      i.traverse(e);
  }
  getCacheKey(e = !1) {
    return e = e || this.version !== this._cacheKeyVersion, (e === !0 || this._cacheKey === null) && (this._cacheKey = k3(this, e), this._cacheKeyVersion = this.version), this._cacheKey;
  }
  getScope() {
    return this;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  getElementType(e) {
    const i = this.getNodeType(e);
    return e.getElementType(i);
  }
  getNodeType(e) {
    const i = e.getNodeProperties(this);
    return i.outputNode ? i.outputNode.getNodeType(e) : this.nodeType;
  }
  getShared(e) {
    const i = this.getHash(e);
    return e.getNodeFromHash(i) || this;
  }
  setup(e) {
    const i = e.getNodeProperties(this);
    let n = 0;
    for (const s of this.getChildren())
      i["node" + n++] = s;
    return null;
  }
  analyze(e) {
    if (e.increaseUsage(this) === 1) {
      const i = e.getNodeProperties(this);
      for (const n of Object.values(i))
        n && n.isNode === !0 && n.build(e);
    }
  }
  generate(e, i) {
    const { outputNode: n } = e.getNodeProperties(this);
    if (n && n.isNode === !0)
      return n.build(e, i);
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  updateAfter() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(e, i = null) {
    const n = this.getShared(e);
    if (this !== n)
      return n.build(e, i);
    e.addNode(this), e.addChain(this);
    let s = null;
    const a = e.getBuildStage();
    if (a === "setup") {
      this.updateReference(e);
      const o = e.getNodeProperties(this);
      if (o.initialized !== !0) {
        e.stack.nodes.length, o.initialized = !0, o.outputNode = this.setup(e), o.outputNode !== null && e.stack.nodes.length;
        for (const l of Object.values(o))
          l && l.isNode === !0 && l.build(e);
      }
    } else if (a === "analyze")
      this.analyze(e);
    else if (a === "generate")
      if (this.generate.length === 1) {
        const o = this.getNodeType(e), l = e.getDataFromNode(this);
        s = l.snippet, s === void 0 ? (s = this.generate(e) || "", l.snippet = s) : l.flowCodes !== void 0 && e.context.nodeBlock !== void 0 && e.addFlowCodeHierarchy(this, e.context.nodeBlock), s = e.format(s, o, i);
      } else
        s = this.generate(e, i) || "";
    return e.removeChain(this), e.addSequentialNode(this), s;
  }
  getSerializeChildren() {
    return jm(this);
  }
  serialize(e) {
    const i = this.getSerializeChildren(), n = {};
    for (const { property: s, index: a, childNode: o } of i)
      a !== void 0 ? (n[s] === void 0 && (n[s] = Number.isInteger(a) ? [] : {}), n[s][a] = o.toJSON(e.meta).uuid) : n[s] = o.toJSON(e.meta).uuid;
    Object.keys(n).length > 0 && (e.inputNodes = n);
  }
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const i = e.meta.nodes;
      for (const n in e.inputNodes)
        if (Array.isArray(e.inputNodes[n])) {
          const s = [];
          for (const a of e.inputNodes[n])
            s.push(i[a]);
          this[n] = s;
        } else if (typeof e.inputNodes[n] == "object") {
          const s = {};
          for (const a in e.inputNodes[n]) {
            const o = e.inputNodes[n][a];
            s[a] = i[o];
          }
          this[n] = s;
        } else {
          const s = e.inputNodes[n];
          this[n] = i[s];
        }
    }
  }
  toJSON(e) {
    const { uuid: i, type: n } = this, s = e === void 0 || typeof e == "string";
    s && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    let a = e.nodes[i];
    a === void 0 && (a = {
      uuid: i,
      type: n,
      meta: e,
      metadata: {
        version: 4.6,
        type: "Node",
        generator: "Node.toJSON"
      }
    }, s !== !0 && (e.nodes[a.uuid] = a), this.serialize(a), delete a.meta);
    function o(l) {
      const u = [];
      for (const c in l) {
        const h = l[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
    if (s) {
      const l = o(e.textures), u = o(e.images), c = o(e.nodes);
      l.length > 0 && (a.textures = l), u.length > 0 && (a.images = u), c.length > 0 && (a.nodes = c);
    }
    return a;
  }
}
class Jd extends Mt {
  static get type() {
    return "ArrayElementNode";
  }
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(e, i) {
    super(), this.node = e, this.indexNode = i, this.isArrayElementNode = !0;
  }
  getNodeType(e) {
    return this.node.getElementType(e);
  }
  generate(e) {
    const i = this.node.build(e), n = this.indexNode.build(e, "uint");
    return `${i}[ ${n} ]`;
  }
}
class F3 extends Mt {
  static get type() {
    return "ConvertNode";
  }
  constructor(e, i) {
    super(), this.node = e, this.convertTo = i;
  }
  getNodeType(e) {
    const i = this.node.getNodeType(e);
    let n = null;
    for (const s of this.convertTo.split("|"))
      (n === null || e.getTypeLength(i) === e.getTypeLength(s)) && (n = s);
    return n;
  }
  serialize(e) {
    super.serialize(e), e.convertTo = this.convertTo;
  }
  deserialize(e) {
    super.deserialize(e), this.convertTo = e.convertTo;
  }
  generate(e, i) {
    const n = this.node, s = this.getNodeType(e), a = n.build(e, s);
    return e.format(a, s, i);
  }
}
class zi extends Mt {
  static get type() {
    return "TempNode";
  }
  constructor(e) {
    super(e), this.isTempNode = !0;
  }
  hasDependencies(e) {
    return e.getDataFromNode(this).usageCount > 1;
  }
  build(e, i) {
    if (e.getBuildStage() === "generate") {
      const n = e.getVectorType(this.getNodeType(e, i)), s = e.getDataFromNode(this);
      if (s.propertyName !== void 0)
        return e.format(s.propertyName, n, i);
      if (n !== "void" && i !== "void" && this.hasDependencies(e)) {
        const a = super.build(e, n), o = e.getVarFromNode(this, null, n), l = e.getPropertyName(o);
        return e.addLineFlowCode(`${l} = ${a}`, this), s.snippet = a, s.propertyName = l, e.format(s.propertyName, n, i);
      }
    }
    return super.build(e, i);
  }
}
class SW extends zi {
  static get type() {
    return "JoinNode";
  }
  constructor(e = [], i = null) {
    super(i), this.nodes = e;
  }
  getNodeType(e) {
    return this.nodeType !== null ? e.getVectorType(this.nodeType) : e.getTypeFromLength(this.nodes.reduce((i, n) => i + e.getTypeLength(n.getNodeType(e)), 0));
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.nodes, a = e.getComponentType(n), o = [];
    for (const u of s) {
      let c = u.build(e);
      const h = e.getComponentType(u.getNodeType(e));
      h !== a && (c = e.format(c, h, a)), o.push(c);
    }
    const l = `${e.getType(n)}( ${o.join(", ")} )`;
    return e.format(l, n, i);
  }
}
const EW = Gc.join("");
class o2 extends Mt {
  static get type() {
    return "SplitNode";
  }
  constructor(e, i = "x") {
    super(), this.node = e, this.components = i, this.isSplitNode = !0;
  }
  getVectorLength() {
    let e = this.components.length;
    for (const i of this.components)
      e = Math.max(Gc.indexOf(i) + 1, e);
    return e;
  }
  getComponentType(e) {
    return e.getComponentType(this.node.getNodeType(e));
  }
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length, this.getComponentType(e));
  }
  generate(e, i) {
    const n = this.node, s = e.getTypeLength(n.getNodeType(e));
    let a = null;
    if (s > 1) {
      let o = null;
      this.getVectorLength() >= s && (o = e.getTypeFromLength(this.getVectorLength(), this.getComponentType(e)));
      const l = n.build(e, o);
      this.components.length === s && this.components === EW.slice(0, this.components.length) ? a = e.format(l, o, i) : a = e.format(`${l}.${this.components}`, this.getNodeType(e), i);
    } else
      a = n.build(e, i);
    return a;
  }
  serialize(e) {
    super.serialize(e), e.components = this.components;
  }
  deserialize(e) {
    super.deserialize(e), this.components = e.components;
  }
}
class MW extends zi {
  static get type() {
    return "SetNode";
  }
  constructor(e, i, n) {
    super(), this.sourceNode = e, this.components = i, this.targetNode = n;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { sourceNode: i, components: n, targetNode: s } = this, a = this.getNodeType(e), o = e.getTypeFromLength(n.length, s.getNodeType(e)), l = s.build(e, o), u = i.build(e, a), c = e.getTypeLength(a), h = [];
    for (let d = 0; d < c; d++) {
      const p = Gc[d];
      p === n[0] ? (h.push(l), d += n.length - 1) : h.push(u + "." + p);
    }
    return `${e.getType(a)}( ${h.join(", ")} )`;
  }
}
class AW extends zi {
  static get type() {
    return "FlipNode";
  }
  constructor(e, i) {
    super(), this.sourceNode = e, this.components = i;
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { components: i, sourceNode: n } = this, s = this.getNodeType(e), a = n.build(e), o = e.getVarFromNode(this), l = e.getPropertyName(o);
    e.addLineFlowCode(l + " = " + a, this);
    const u = e.getTypeLength(s), c = [];
    let h = 0;
    for (let d = 0; d < u; d++) {
      const p = Gc[d];
      p === i[h] ? (c.push("1.0 - " + (l + "." + p)), h++) : c.push(l + "." + p);
    }
    return `${e.getType(s)}( ${c.join(", ")} )`;
  }
}
class b1 extends Mt {
  static get type() {
    return "InputNode";
  }
  constructor(e, i = null) {
    super(i), this.isInputNode = !0, this.value = e, this.precision = null;
  }
  getNodeType() {
    return this.nodeType === null ? Vm(this.value) : this.nodeType;
  }
  getInputType(e) {
    return this.getNodeType(e);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  serialize(e) {
    super.serialize(e), e.value = this.value, this.value && this.value.toArray && (e.value = this.value.toArray()), e.valueType = Vm(this.value), e.nodeType = this.nodeType, e.valueType === "ArrayBuffer" && (e.value = xW(e.value)), e.precision = this.precision;
  }
  deserialize(e) {
    super.deserialize(e), this.nodeType = e.nodeType, this.value = Array.isArray(e.value) ? U3(e.valueType, ...e.value) : e.value, this.precision = e.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
class Sa extends b1 {
  static get type() {
    return "ConstNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isConstNode = !0;
  }
  generateConst(e) {
    return e.generateConst(this.getNodeType(e), this.value);
  }
  generate(e, i) {
    const n = this.getNodeType(e);
    return e.format(this.generateConst(e), n, i);
  }
}
let wc = null;
const Uu = /* @__PURE__ */ new Map();
function ve(r, e) {
  if (Uu.has(r)) {
    console.warn(`Redefinition of method chaining ${r}`);
    return;
  }
  if (typeof e != "function") throw new Error(`Node element ${r} is not a function`);
  Uu.set(r, e);
}
const B3 = (r) => r.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), l2 = (r) => B3(r).split("").sort().join(""), z3 = {
  setup(r, e) {
    const i = e.shift();
    return r(Dg(i), ...e);
  },
  get(r, e, i) {
    if (typeof e == "string" && r[e] === void 0) {
      if (r.isStackNode !== !0 && e === "assign")
        return (...n) => (wc.assign(i, ...n), i);
      if (Uu.has(e)) {
        const n = Uu.get(e);
        return r.isStackNode ? (...s) => i.add(n(...s)) : (...s) => n(i, ...s);
      } else {
        if (e === "self")
          return r;
        if (e.endsWith("Assign") && Uu.has(e.slice(0, e.length - 6))) {
          const n = Uu.get(e.slice(0, e.length - 6));
          return r.isStackNode ? (...s) => i.assign(s[0], n(...s)) : (...s) => i.assign(n(i, ...s));
        } else {
          if (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0)
            return e = B3(e), De(new o2(i, e));
          if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = l2(e.slice(3).toLowerCase()), (n) => De(new MW(r, e, n));
          if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = l2(e.slice(4).toLowerCase()), () => De(new AW(De(r), e));
          if (e === "width" || e === "height" || e === "depth")
            return e === "width" ? e = "x" : e === "height" ? e = "y" : e === "depth" && (e = "z"), De(new o2(r, e));
          if (/^\d+$/.test(e) === !0)
            return De(new Jd(i, new Sa(Number(e), "uint")));
        }
      }
    }
    return Reflect.get(r, e, i);
  },
  set(r, e, i, n) {
    return typeof e == "string" && r[e] === void 0 && (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0 || e === "width" || e === "height" || e === "depth" || /^\d+$/.test(e) === !0) ? (n[e].assign(i), !0) : Reflect.set(r, e, i, n);
  }
}, F0 = /* @__PURE__ */ new WeakMap(), u2 = /* @__PURE__ */ new WeakMap(), CW = function(r, e = null) {
  const i = Vm(r);
  if (i === "node") {
    let n = F0.get(r);
    return n === void 0 && (n = new Proxy(r, z3), F0.set(r, n), F0.set(n, n)), n;
  } else {
    if (e === null && (i === "float" || i === "boolean") || i && i !== "shader" && i !== "string")
      return De(yx(r, e));
    if (i === "shader")
      return Fe(r);
  }
  return r;
}, RW = function(r, e = null) {
  for (const i in r)
    r[i] = De(r[i], e);
  return r;
}, NW = function(r, e = null) {
  const i = r.length;
  for (let n = 0; n < i; n++)
    r[n] = De(r[n], e);
  return r;
}, PW = function(r, e = null, i = null, n = null) {
  const s = (a) => De(n !== null ? Object.assign(a, n) : a);
  return e === null ? (...a) => s(new r(...$u(a))) : i !== null ? (i = De(i), (...a) => s(new r(e, ...$u(a), i))) : (...a) => s(new r(e, ...$u(a)));
}, IW = function(r, ...e) {
  return De(new r(...$u(e)));
};
class OW extends Mt {
  constructor(e, i) {
    super(), this.shaderNode = e, this.inputNodes = i;
  }
  getNodeType(e) {
    return this.shaderNode.nodeType || this.getOutputNode(e).getNodeType(e);
  }
  call(e) {
    const { shaderNode: i, inputNodes: n } = this, s = e.getNodeProperties(i);
    if (s.onceOutput) return s.onceOutput;
    let a = null;
    if (i.layout) {
      let o = u2.get(e.constructor);
      o === void 0 && (o = /* @__PURE__ */ new WeakMap(), u2.set(e.constructor, o));
      let l = o.get(i);
      l === void 0 && (l = De(e.buildFunctionNode(i)), o.set(i, l)), e.currentFunctionNode !== null && e.currentFunctionNode.includes.push(l), a = De(l.call(n));
    } else {
      const o = i.jsFunc, l = n !== null ? o(n, e) : o(e);
      a = De(l);
    }
    return i.once && (s.onceOutput = a), a;
  }
  getOutputNode(e) {
    const i = e.getNodeProperties(this);
    return i.outputNode === null && (i.outputNode = this.setupOutput(e)), i.outputNode;
  }
  setup(e) {
    return this.getOutputNode(e);
  }
  setupOutput(e) {
    return e.addStack(), e.stack.outputNode = this.call(e), e.removeStack();
  }
  generate(e, i) {
    return this.getOutputNode(e).build(e, i);
  }
}
class DW extends Mt {
  constructor(e, i) {
    super(i), this.jsFunc = e, this.layout = null, this.global = !0, this.once = !1;
  }
  setLayout(e) {
    return this.layout = e, this;
  }
  call(e = null) {
    return Dg(e), De(new OW(this, e));
  }
  setup() {
    return this.call();
  }
}
const LW = [!1, !0], kW = [0, 1, 2, 3], UW = [-1, -2], j3 = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2], x1 = /* @__PURE__ */ new Map();
for (const r of LW) x1.set(r, new Sa(r));
const _1 = /* @__PURE__ */ new Map();
for (const r of kW) _1.set(r, new Sa(r, "uint"));
const T1 = new Map([..._1].map((r) => new Sa(r.value, "int")));
for (const r of UW) T1.set(r, new Sa(r, "int"));
const Ig = new Map([...T1].map((r) => new Sa(r.value)));
for (const r of j3) Ig.set(r, new Sa(r));
for (const r of j3) Ig.set(-r, new Sa(-r));
const Og = { bool: x1, uint: _1, ints: T1, float: Ig }, c2 = new Map([...x1, ...Ig]), yx = (r, e) => c2.has(r) ? c2.get(r) : r.isNode === !0 ? r : new Sa(r, e), FW = (r) => {
  try {
    return r.getNodeType();
  } catch {
    return;
  }
}, ji = function(r, e = null) {
  return (...i) => {
    if ((i.length === 0 || !["bool", "float", "int", "uint"].includes(r) && i.every((s) => typeof s != "object")) && (i = [U3(r, ...i)]), i.length === 1 && e !== null && e.has(i[0]))
      return De(e.get(i[0]));
    if (i.length === 1) {
      const s = yx(i[0], r);
      return FW(s) === r ? De(s) : De(new F3(s, r));
    }
    const n = i.map((s) => yx(s));
    return De(new SW(n, r));
  };
}, h2 = (r) => typeof r == "object" && r !== null ? r.value : r, BW = (r) => r != null ? r.nodeType || r.convertTo || (typeof r == "string" ? r : null) : null;
function nm(r, e) {
  return new Proxy(new DW(r, e), z3);
}
const De = (r, e = null) => (
  /* new */
  CW(r, e)
), Dg = (r, e = null) => new RW(r, e), $u = (r, e = null) => new NW(r, e), Ae = (...r) => new PW(...r), Ge = (...r) => new IW(...r), Fe = (r, e) => {
  const i = new nm(r, e), n = (...s) => {
    let a;
    return Dg(s), s[0] && s[0].isNode ? a = [...s] : a = s[0], i.call(a);
  };
  return n.shaderNode = i, n.setLayout = (s) => (i.setLayout(s), n), n.once = () => (i.once = !0, n), n;
};
ve("toGlobal", (r) => (r.global = !0, r));
const Gm = (r) => {
  wc = r;
}, V3 = () => wc, nr = (...r) => wc.If(...r);
function zW(r) {
  return wc && wc.add(r), r;
}
ve("append", zW);
const jW = new ji("color"), _e = new ji("float", Og.float), Ei = new ji("int", Og.ints), VW = new ji("uint", Og.uint), GW = new ji("bool", Og.bool), We = new ji("vec2"), Ks = new ji("ivec2"), HW = new ji("uvec2"), WW = new ji("bvec2"), be = new ji("vec3"), qW = new ji("ivec3"), XW = new ji("uvec3"), YW = new ji("bvec3"), _t = new ji("vec4"), KW = new ji("ivec4"), ZW = new ji("uvec4"), QW = new ji("bvec4"), w1 = new ji("mat2"), Rr = new ji("mat3"), Ju = new ji("mat4");
ve("toColor", jW);
ve("toFloat", _e);
ve("toInt", Ei);
ve("toUint", VW);
ve("toBool", GW);
ve("toVec2", We);
ve("toIVec2", Ks);
ve("toUVec2", HW);
ve("toBVec2", WW);
ve("toVec3", be);
ve("toIVec3", qW);
ve("toUVec3", XW);
ve("toBVec3", YW);
ve("toVec4", _t);
ve("toIVec4", KW);
ve("toUVec4", ZW);
ve("toBVec4", QW);
ve("toMat2", w1);
ve("toMat3", Rr);
ve("toMat4", Ju);
const $W = /* @__PURE__ */ Ae(Jd), JW = (r, e) => De(new F3(De(r), e));
ve("element", $W);
ve("convert", JW);
class G3 extends Mt {
  static get type() {
    return "UniformGroupNode";
  }
  constructor(e, i = !1, n = 1) {
    super("string"), this.name = e, this.version = 0, this.shared = i, this.order = n, this.isUniformGroup = !0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  serialize(e) {
    super.serialize(e), e.name = this.name, e.version = this.version, e.shared = this.shared;
  }
  deserialize(e) {
    super.deserialize(e), this.name = e.name, this.version = e.version, this.shared = e.shared;
  }
}
const eq = (r) => new G3(r), H3 = (r, e = 0) => new G3(r, !0, e), tq = /* @__PURE__ */ H3("frame"), kt = /* @__PURE__ */ H3("render"), W3 = /* @__PURE__ */ eq("object");
class ep extends b1 {
  static get type() {
    return "UniformNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isUniformNode = !0, this.name = "", this.groupNode = W3;
  }
  label(e) {
    return this.name = e, this;
  }
  setGroup(e) {
    return this.groupNode = e, this;
  }
  getGroup() {
    return this.groupNode;
  }
  getUniformHash(e) {
    return this.getHash(e);
  }
  onUpdate(e, i) {
    const n = this.getSelf();
    return e = e.bind(n), super.onUpdate((s) => {
      const a = e(s, n);
      a !== void 0 && (this.value = a);
    }, i);
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.getUniformHash(e);
    let a = e.getNodeFromHash(s);
    a === void 0 && (e.setHashNode(this, s), a = this);
    const o = a.getInputType(e), l = e.getUniformFromNode(a, o, e.shaderStage, this.name || e.context.label), u = e.getPropertyName(l);
    return e.context.label !== void 0 && delete e.context.label, e.format(u, n, i);
  }
}
const Tt = (r, e) => {
  const i = BW(e || r), n = r && r.isNode === !0 ? r.node && r.node.value || r.value : r;
  return De(new ep(n, i));
};
class Qt extends Mt {
  static get type() {
    return "PropertyNode";
  }
  constructor(e, i = null, n = !1) {
    super(e), this.name = i, this.varying = n, this.isPropertyNode = !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  isGlobal() {
    return !0;
  }
  generate(e) {
    let i;
    return this.varying === !0 ? (i = e.getVaryingFromNode(this, this.name), i.needsInterpolation = !0) : i = e.getVarFromNode(this, this.name), e.getPropertyName(i);
  }
}
const Ru = (r, e) => De(new Qt(r, e)), Hm = (r, e) => De(new Qt(r, e, !0)), qt = /* @__PURE__ */ Ge(Qt, "vec4", "DiffuseColor"), d2 = /* @__PURE__ */ Ge(Qt, "vec3", "EmissiveColor"), ta = /* @__PURE__ */ Ge(Qt, "float", "Roughness"), Wm = /* @__PURE__ */ Ge(Qt, "float", "Metalness"), vx = /* @__PURE__ */ Ge(Qt, "float", "Clearcoat"), qm = /* @__PURE__ */ Ge(Qt, "float", "ClearcoatRoughness"), Fu = /* @__PURE__ */ Ge(Qt, "vec3", "Sheen"), S1 = /* @__PURE__ */ Ge(Qt, "float", "SheenRoughness"), E1 = /* @__PURE__ */ Ge(Qt, "float", "Iridescence"), q3 = /* @__PURE__ */ Ge(Qt, "float", "IridescenceIOR"), X3 = /* @__PURE__ */ Ge(Qt, "float", "IridescenceThickness"), bx = /* @__PURE__ */ Ge(Qt, "float", "AlphaT"), Go = /* @__PURE__ */ Ge(Qt, "float", "Anisotropy"), sm = /* @__PURE__ */ Ge(Qt, "vec3", "AnisotropyT"), ec = /* @__PURE__ */ Ge(Qt, "vec3", "AnisotropyB"), nn = /* @__PURE__ */ Ge(Qt, "color", "SpecularColor"), Xm = /* @__PURE__ */ Ge(Qt, "float", "SpecularF90"), xx = /* @__PURE__ */ Ge(Qt, "float", "Shininess"), iq = /* @__PURE__ */ Ge(Qt, "vec4", "Output"), B0 = /* @__PURE__ */ Ge(Qt, "float", "dashSize"), p2 = /* @__PURE__ */ Ge(Qt, "float", "gapSize"), am = /* @__PURE__ */ Ge(Qt, "float", "IOR"), _x = /* @__PURE__ */ Ge(Qt, "float", "Transmission"), Y3 = /* @__PURE__ */ Ge(Qt, "float", "Thickness"), K3 = /* @__PURE__ */ Ge(Qt, "float", "AttenuationDistance"), Z3 = /* @__PURE__ */ Ge(Qt, "color", "AttenuationColor"), Q3 = /* @__PURE__ */ Ge(Qt, "float", "Dispersion");
class rq extends zi {
  static get type() {
    return "AssignNode";
  }
  constructor(e, i) {
    super(), this.targetNode = e, this.sourceNode = i;
  }
  hasDependencies() {
    return !1;
  }
  getNodeType(e, i) {
    return i !== "void" ? this.targetNode.getNodeType(e) : "void";
  }
  needsSplitAssign(e) {
    const { targetNode: i } = this;
    if (e.isAvailable("swizzleAssign") === !1 && i.isSplitNode && i.components.length > 1) {
      const n = e.getTypeLength(i.node.getNodeType(e));
      return Gc.join("").slice(0, n) !== i.components;
    }
    return !1;
  }
  generate(e, i) {
    const { targetNode: n, sourceNode: s } = this, a = this.needsSplitAssign(e), o = n.getNodeType(e), l = n.context({ assign: !0 }).build(e), u = s.build(e, o), c = s.getNodeType(e), h = e.getDataFromNode(this);
    let d;
    if (h.initialized === !0)
      i !== "void" && (d = l);
    else if (a) {
      const p = e.getVarFromNode(this, null, o), f = e.getPropertyName(p);
      e.addLineFlowCode(`${f} = ${u}`, this);
      const m = n.node.context({ assign: !0 }).build(e);
      for (let y = 0; y < n.components.length; y++) {
        const v = n.components[y];
        e.addLineFlowCode(`${m}.${v} = ${f}[ ${y} ]`, this);
      }
      i !== "void" && (d = l);
    } else
      d = `${l} = ${u}`, (i === "void" || c === "void") && (e.addLineFlowCode(d, this), i !== "void" && (d = l));
    return h.initialized = !0, e.format(d, o, i);
  }
}
const nq = /* @__PURE__ */ Ae(rq);
ve("assign", nq);
class sq extends zi {
  static get type() {
    return "FunctionCallNode";
  }
  constructor(e = null, i = {}) {
    super(), this.functionNode = e, this.parameters = i;
  }
  setParameters(e) {
    return this.parameters = e, this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(e) {
    return this.functionNode.getNodeType(e);
  }
  generate(e) {
    const i = [], n = this.functionNode, s = n.getInputs(e), a = this.parameters, o = (l, u) => {
      const c = u.type, h = c === "pointer";
      let d;
      return h ? d = "&" + l.build(e) : d = l.build(e, c), d;
    };
    if (Array.isArray(a))
      for (let l = 0; l < a.length; l++)
        i.push(o(a[l], s[l]));
    else
      for (const l of s) {
        const u = a[l.name];
        if (u !== void 0)
          i.push(o(u, l));
        else
          throw new Error(`FunctionCallNode: Input '${l.name}' not found in FunctionNode.`);
      }
    return `${n.build(e, "property")}( ${i.join(", ")} )`;
  }
}
const aq = (r, ...e) => (e = e.length > 1 || e[0] && e[0].isNode === !0 ? $u(e) : Dg(e[0]), De(new sq(De(r), e)));
ve("call", aq);
class yi extends zi {
  static get type() {
    return "OperatorNode";
  }
  constructor(e, i, n, ...s) {
    if (super(), s.length > 0) {
      let a = new yi(e, i, n);
      for (let o = 0; o < s.length - 1; o++)
        a = new yi(e, a, s[o]);
      i = a, n = s[s.length - 1];
    }
    this.op = e, this.aNode = i, this.bNode = n;
  }
  getNodeType(e, i) {
    const n = this.op, s = this.aNode, a = this.bNode, o = s.getNodeType(e), l = typeof a < "u" ? a.getNodeType(e) : null;
    if (o === "void" || l === "void")
      return "void";
    if (n === "%")
      return o;
    if (n === "~" || n === "&" || n === "|" || n === "^" || n === ">>" || n === "<<")
      return e.getIntegerType(o);
    if (n === "!" || n === "==" || n === "&&" || n === "||" || n === "^^")
      return "bool";
    if (n === "<" || n === ">" || n === "<=" || n === ">=") {
      const u = i ? e.getTypeLength(i) : Math.max(e.getTypeLength(o), e.getTypeLength(l));
      return u > 1 ? `bvec${u}` : "bool";
    } else
      return o === "float" && e.isMatrix(l) ? l : e.isMatrix(o) && e.isVector(l) ? e.getVectorFromMatrix(o) : e.isVector(o) && e.isMatrix(l) ? e.getVectorFromMatrix(l) : e.getTypeLength(l) > e.getTypeLength(o) ? l : o;
  }
  generate(e, i) {
    const n = this.op, s = this.aNode, a = this.bNode, o = this.getNodeType(e, i);
    let l = null, u = null;
    o !== "void" ? (l = s.getNodeType(e), u = typeof a < "u" ? a.getNodeType(e) : null, n === "<" || n === ">" || n === "<=" || n === ">=" || n === "==" ? e.isVector(l) ? u = l : l !== u && (l = u = "float") : n === ">>" || n === "<<" ? (l = o, u = e.changeComponentType(u, "uint")) : e.isMatrix(l) && e.isVector(u) ? u = e.getVectorFromMatrix(l) : e.isVector(l) && e.isMatrix(u) ? l = e.getVectorFromMatrix(u) : l = u = o) : l = u = o;
    const c = s.build(e, l), h = typeof a < "u" ? a.build(e, u) : null, d = e.getTypeLength(i), p = e.getFunctionOperator(n);
    if (i !== "void")
      return n === "<" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("lessThan", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} < ${h} )`, o, i) : n === "<=" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("lessThanEqual", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} <= ${h} )`, o, i) : n === ">" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("greaterThan", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} > ${h} )`, o, i) : n === ">=" && d > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("greaterThanEqual", i)}( ${c}, ${h} )`, o, i) : e.format(`( ${c} >= ${h} )`, o, i) : n === "!" || n === "~" ? e.format(`(${n}${c})`, l, i) : p ? e.format(`${p}( ${c}, ${h} )`, o, i) : e.format(`( ${c} ${n} ${h} )`, o, i);
    if (l !== "void")
      return p ? e.format(`${p}( ${c}, ${h} )`, o, i) : e.format(`${c} ${n} ${h}`, o, i);
  }
  serialize(e) {
    super.serialize(e), e.op = this.op;
  }
  deserialize(e) {
    super.deserialize(e), this.op = e.op;
  }
}
const Nr = /* @__PURE__ */ Ae(yi, "+"), an = /* @__PURE__ */ Ae(yi, "-"), Dt = /* @__PURE__ */ Ae(yi, "*"), vo = /* @__PURE__ */ Ae(yi, "/"), $3 = /* @__PURE__ */ Ae(yi, "%"), oq = /* @__PURE__ */ Ae(yi, "=="), lq = /* @__PURE__ */ Ae(yi, "!="), uq = /* @__PURE__ */ Ae(yi, "<"), cq = /* @__PURE__ */ Ae(yi, ">"), hq = /* @__PURE__ */ Ae(yi, "<="), dq = /* @__PURE__ */ Ae(yi, ">="), pq = /* @__PURE__ */ Ae(yi, "&&"), fq = /* @__PURE__ */ Ae(yi, "||"), mq = /* @__PURE__ */ Ae(yi, "!"), gq = /* @__PURE__ */ Ae(yi, "^^"), yq = /* @__PURE__ */ Ae(yi, "&"), vq = /* @__PURE__ */ Ae(yi, "~"), bq = /* @__PURE__ */ Ae(yi, "|"), xq = /* @__PURE__ */ Ae(yi, "^"), _q = /* @__PURE__ */ Ae(yi, "<<"), Tq = /* @__PURE__ */ Ae(yi, ">>");
ve("add", Nr);
ve("sub", an);
ve("mul", Dt);
ve("div", vo);
ve("modInt", $3);
ve("equal", oq);
ve("notEqual", lq);
ve("lessThan", uq);
ve("greaterThan", cq);
ve("lessThanEqual", hq);
ve("greaterThanEqual", dq);
ve("and", pq);
ve("or", fq);
ve("not", mq);
ve("xor", gq);
ve("bitAnd", yq);
ve("bitNot", vq);
ve("bitOr", bq);
ve("bitXor", xq);
ve("shiftLeft", _q);
ve("shiftRight", Tq);
const wq = (...r) => (console.warn("TSL.OperatorNode: .remainder() has been renamed to .modInt()."), $3(...r));
ve("remainder", wq);
class re extends zi {
  static get type() {
    return "MathNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.method = e, this.aNode = i, this.bNode = n, this.cNode = s;
  }
  getInputType(e) {
    const i = this.aNode.getNodeType(e), n = this.bNode ? this.bNode.getNodeType(e) : null, s = this.cNode ? this.cNode.getNodeType(e) : null, a = e.isMatrix(i) ? 0 : e.getTypeLength(i), o = e.isMatrix(n) ? 0 : e.getTypeLength(n), l = e.isMatrix(s) ? 0 : e.getTypeLength(s);
    return a > o && a > l ? i : o > l ? n : l > a ? s : i;
  }
  getNodeType(e) {
    const i = this.method;
    return i === re.LENGTH || i === re.DISTANCE || i === re.DOT ? "float" : i === re.CROSS ? "vec3" : i === re.ALL ? "bool" : i === re.EQUALS ? e.changeComponentType(this.aNode.getNodeType(e), "bool") : i === re.MOD ? this.aNode.getNodeType(e) : this.getInputType(e);
  }
  generate(e, i) {
    const n = this.method, s = this.getNodeType(e), a = this.getInputType(e), o = this.aNode, l = this.bNode, u = this.cNode, c = e.renderer.isWebGLRenderer === !0;
    if (n === re.TRANSFORM_DIRECTION) {
      let h = o, d = l;
      e.isMatrix(h.getNodeType(e)) ? d = _t(be(d), 0) : h = _t(be(h), 0);
      const p = Dt(h, d).xyz;
      return _d(p).build(e, i);
    } else {
      if (n === re.NEGATE)
        return e.format("( - " + o.build(e, a) + " )", s, i);
      if (n === re.ONE_MINUS)
        return an(1, o).build(e, i);
      if (n === re.RECIPROCAL)
        return vo(1, o).build(e, i);
      if (n === re.DIFFERENCE)
        return Gn(an(o, l)).build(e, i);
      {
        const h = [];
        return n === re.CROSS || n === re.MOD ? h.push(
          o.build(e, s),
          l.build(e, s)
        ) : c && n === re.STEP ? h.push(
          o.build(e, e.getTypeLength(o.getNodeType(e)) === 1 ? "float" : a),
          l.build(e, a)
        ) : c && (n === re.MIN || n === re.MAX) || n === re.MOD ? h.push(
          o.build(e, a),
          l.build(e, e.getTypeLength(l.getNodeType(e)) === 1 ? "float" : a)
        ) : n === re.REFRACT ? h.push(
          o.build(e, a),
          l.build(e, a),
          u.build(e, "float")
        ) : n === re.MIX ? h.push(
          o.build(e, a),
          l.build(e, a),
          u.build(e, e.getTypeLength(u.getNodeType(e)) === 1 ? "float" : a)
        ) : (h.push(o.build(e, a)), l !== null && h.push(l.build(e, a)), u !== null && h.push(u.build(e, a))), e.format(`${e.getMethod(n, s)}( ${h.join(", ")} )`, s, i);
      }
    }
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
re.ALL = "all";
re.ANY = "any";
re.EQUALS = "equals";
re.RADIANS = "radians";
re.DEGREES = "degrees";
re.EXP = "exp";
re.EXP2 = "exp2";
re.LOG = "log";
re.LOG2 = "log2";
re.SQRT = "sqrt";
re.INVERSE_SQRT = "inversesqrt";
re.FLOOR = "floor";
re.CEIL = "ceil";
re.NORMALIZE = "normalize";
re.FRACT = "fract";
re.SIN = "sin";
re.COS = "cos";
re.TAN = "tan";
re.ASIN = "asin";
re.ACOS = "acos";
re.ATAN = "atan";
re.ABS = "abs";
re.SIGN = "sign";
re.LENGTH = "length";
re.NEGATE = "negate";
re.ONE_MINUS = "oneMinus";
re.DFDX = "dFdx";
re.DFDY = "dFdy";
re.ROUND = "round";
re.RECIPROCAL = "reciprocal";
re.TRUNC = "trunc";
re.FWIDTH = "fwidth";
re.BITCAST = "bitcast";
re.TRANSPOSE = "transpose";
re.ATAN2 = "atan2";
re.MIN = "min";
re.MAX = "max";
re.MOD = "mod";
re.STEP = "step";
re.REFLECT = "reflect";
re.DISTANCE = "distance";
re.DIFFERENCE = "difference";
re.DOT = "dot";
re.CROSS = "cross";
re.POW = "pow";
re.TRANSFORM_DIRECTION = "transformDirection";
re.MIX = "mix";
re.CLAMP = "clamp";
re.REFRACT = "refract";
re.SMOOTHSTEP = "smoothstep";
re.FACEFORWARD = "faceforward";
const Sq = /* @__PURE__ */ _e(1e-6), Eq = /* @__PURE__ */ _e(Math.PI), J3 = /* @__PURE__ */ Ae(re, re.ALL), Mq = /* @__PURE__ */ Ae(re, re.ANY), Aq = /* @__PURE__ */ Ae(re, re.EQUALS), Cq = /* @__PURE__ */ Ae(re, re.RADIANS), Rq = /* @__PURE__ */ Ae(re, re.DEGREES), eP = /* @__PURE__ */ Ae(re, re.EXP), xd = /* @__PURE__ */ Ae(re, re.EXP2), tP = /* @__PURE__ */ Ae(re, re.LOG), ya = /* @__PURE__ */ Ae(re, re.LOG2), M1 = /* @__PURE__ */ Ae(re, re.SQRT), Nq = /* @__PURE__ */ Ae(re, re.INVERSE_SQRT), yl = /* @__PURE__ */ Ae(re, re.FLOOR), A1 = /* @__PURE__ */ Ae(re, re.CEIL), _d = /* @__PURE__ */ Ae(re, re.NORMALIZE), _o = /* @__PURE__ */ Ae(re, re.FRACT), Vn = /* @__PURE__ */ Ae(re, re.SIN), Qa = /* @__PURE__ */ Ae(re, re.COS), Pq = /* @__PURE__ */ Ae(re, re.TAN), Iq = /* @__PURE__ */ Ae(re, re.ASIN), Oq = /* @__PURE__ */ Ae(re, re.ACOS), Dq = /* @__PURE__ */ Ae(re, re.ATAN), Gn = /* @__PURE__ */ Ae(re, re.ABS), iP = /* @__PURE__ */ Ae(re, re.SIGN), po = /* @__PURE__ */ Ae(re, re.LENGTH), Lq = /* @__PURE__ */ Ae(re, re.NEGATE), kq = /* @__PURE__ */ Ae(re, re.ONE_MINUS), rP = /* @__PURE__ */ Ae(re, re.DFDX), nP = /* @__PURE__ */ Ae(re, re.DFDY), Uq = /* @__PURE__ */ Ae(re, re.ROUND), Fq = /* @__PURE__ */ Ae(re, re.RECIPROCAL), Bq = /* @__PURE__ */ Ae(re, re.TRUNC), zq = /* @__PURE__ */ Ae(re, re.FWIDTH);
re.BITCAST;
const jq = /* @__PURE__ */ Ae(re, re.TRANSPOSE), Vq = /* @__PURE__ */ Ae(re, re.ATAN2), Td = /* @__PURE__ */ Ae(re, re.MIN), Sn = /* @__PURE__ */ Ae(re, re.MAX), sP = /* @__PURE__ */ Ae(re, re.MOD), aP = /* @__PURE__ */ Ae(re, re.STEP), Gq = /* @__PURE__ */ Ae(re, re.REFLECT), Hq = /* @__PURE__ */ Ae(re, re.DISTANCE), Wq = /* @__PURE__ */ Ae(re, re.DIFFERENCE), C1 = /* @__PURE__ */ Ae(re, re.DOT), oP = /* @__PURE__ */ Ae(re, re.CROSS), Lg = /* @__PURE__ */ Ae(re, re.POW), lP = /* @__PURE__ */ Ae(re, re.POW, 2), qq = /* @__PURE__ */ Ae(re, re.POW, 3), Xq = /* @__PURE__ */ Ae(re, re.POW, 4), Yq = /* @__PURE__ */ Ae(re, re.TRANSFORM_DIRECTION), Kq = (r) => Dt(iP(r), Lg(Gn(r), 1 / 3)), Zq = (r) => C1(r, r), li = /* @__PURE__ */ Ae(re, re.MIX), xa = (r, e = 0, i = 1) => De(new re(re.CLAMP, De(r), De(e), De(i))), Qq = (r) => xa(r), uP = /* @__PURE__ */ Ae(re, re.REFRACT), Ml = /* @__PURE__ */ Ae(re, re.SMOOTHSTEP), $q = /* @__PURE__ */ Ae(re, re.FACEFORWARD), Jq = /* @__PURE__ */ Fe(([r]) => {
  const e = 43758.5453, i = C1(r.xy, We(12.9898, 78.233)), n = sP(i, Eq);
  return _o(Vn(n).mul(e));
}), eX = (r, e, i) => li(e, i, r), tX = (r, e, i) => Ml(e, i, r);
ve("all", J3);
ve("any", Mq);
ve("equals", Aq);
ve("radians", Cq);
ve("degrees", Rq);
ve("exp", eP);
ve("exp2", xd);
ve("log", tP);
ve("log2", ya);
ve("sqrt", M1);
ve("inverseSqrt", Nq);
ve("floor", yl);
ve("ceil", A1);
ve("normalize", _d);
ve("fract", _o);
ve("sin", Vn);
ve("cos", Qa);
ve("tan", Pq);
ve("asin", Iq);
ve("acos", Oq);
ve("atan", Dq);
ve("abs", Gn);
ve("sign", iP);
ve("length", po);
ve("lengthSq", Zq);
ve("negate", Lq);
ve("oneMinus", kq);
ve("dFdx", rP);
ve("dFdy", nP);
ve("round", Uq);
ve("reciprocal", Fq);
ve("trunc", Bq);
ve("fwidth", zq);
ve("atan2", Vq);
ve("min", Td);
ve("max", Sn);
ve("mod", sP);
ve("step", aP);
ve("reflect", Gq);
ve("distance", Hq);
ve("dot", C1);
ve("cross", oP);
ve("pow", Lg);
ve("pow2", lP);
ve("pow3", qq);
ve("pow4", Xq);
ve("transformDirection", Yq);
ve("mix", eX);
ve("clamp", xa);
ve("refract", uP);
ve("smoothstep", tX);
ve("faceForward", $q);
ve("difference", Wq);
ve("saturate", Qq);
ve("cbrt", Kq);
ve("transpose", jq);
ve("rand", Jq);
class iX extends Mt {
  static get type() {
    return "ConditionalNode";
  }
  constructor(e, i, n = null) {
    super(), this.condNode = e, this.ifNode = i, this.elseNode = n;
  }
  getNodeType(e) {
    const i = this.ifNode.getNodeType(e);
    if (this.elseNode !== null) {
      const n = this.elseNode.getNodeType(e);
      if (e.getTypeLength(n) > e.getTypeLength(i))
        return n;
    }
    return i;
  }
  setup(e) {
    const i = this.condNode.cache(), n = this.ifNode.cache(), s = this.elseNode ? this.elseNode.cache() : null, a = e.context.nodeBlock;
    e.getDataFromNode(n).parentNodeBlock = a, s !== null && (e.getDataFromNode(s).parentNodeBlock = a);
    const o = e.getNodeProperties(this);
    o.condNode = i, o.ifNode = n.context({ nodeBlock: n }), o.elseNode = s ? s.context({ nodeBlock: s }) : null;
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = e.getDataFromNode(this);
    if (s.nodeProperty !== void 0)
      return s.nodeProperty;
    const { condNode: a, ifNode: o, elseNode: l } = e.getNodeProperties(this), u = i !== "void", c = u ? Ru(n).build(e) : "";
    s.nodeProperty = c;
    const h = a.build(e, "bool");
    e.addFlowCode(`
${e.tab}if ( ${h} ) {

`).addFlowTab();
    let d = o.build(e, n);
    if (d && (u ? d = c + " = " + d + ";" : d = "return " + d + ";"), e.removeFlowTab().addFlowCode(e.tab + "	" + d + `

` + e.tab + "}"), l !== null) {
      e.addFlowCode(` else {

`).addFlowTab();
      let p = l.build(e, n);
      p && (u ? p = c + " = " + p + ";" : p = "return " + p + ";"), e.removeFlowTab().addFlowCode(e.tab + "	" + p + `

` + e.tab + `}

`);
    } else
      e.addFlowCode(`

`);
    return e.format(c, n, i);
  }
}
const Fr = /* @__PURE__ */ Ae(iX);
ve("select", Fr);
const rX = (...r) => (console.warn("TSL.ConditionalNode: cond() has been renamed to select()."), Fr(...r));
ve("cond", rX);
class cP extends Mt {
  static get type() {
    return "ContextNode";
  }
  constructor(e, i = {}) {
    super(), this.isContextNode = !0, this.node = e, this.value = i;
  }
  getScope() {
    return this.node.getScope();
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  analyze(e) {
    this.node.build(e);
  }
  setup(e) {
    const i = e.getContext();
    e.setContext({ ...e.context, ...this.value });
    const n = this.node.build(e);
    return e.setContext(i), n;
  }
  generate(e, i) {
    const n = e.getContext();
    e.setContext({ ...e.context, ...this.value });
    const s = this.node.build(e, i);
    return e.setContext(n), s;
  }
}
const R1 = /* @__PURE__ */ Ae(cP), nX = (r, e) => R1(r, { label: e });
ve("context", R1);
ve("label", nX);
class sX extends Mt {
  static get type() {
    return "VarNode";
  }
  constructor(e, i = null) {
    super(), this.node = e, this.name = i, this.global = !0, this.isVarNode = !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { node: i, name: n } = this, s = e.getVarFromNode(this, n, e.getVectorType(this.getNodeType(e))), a = e.getPropertyName(s), o = i.build(e, s.type);
    return e.addLineFlowCode(`${a} = ${o}`, this), a;
  }
}
const hP = /* @__PURE__ */ Ae(sX);
ve("toVar", (...r) => hP(...r).append());
const aX = (r) => (console.warn('TSL: "temp" is deprecated. Use ".toVar()" instead.'), hP(r));
ve("temp", aX);
class oX extends Mt {
  static get type() {
    return "VaryingNode";
  }
  constructor(e, i = null) {
    super(), this.node = e, this.name = i, this.isVaryingNode = !0;
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setupVarying(e) {
    const i = e.getNodeProperties(this);
    let n = i.varying;
    if (n === void 0) {
      const s = this.name, a = this.getNodeType(e);
      i.varying = n = e.getVaryingFromNode(this, s, a), i.node = this.node;
    }
    return n.needsInterpolation || (n.needsInterpolation = e.shaderStage === "fragment"), n;
  }
  setup(e) {
    this.setupVarying(e);
  }
  analyze(e) {
    return this.setupVarying(e), this.node.analyze(e);
  }
  generate(e) {
    const i = e.getNodeProperties(this), n = this.setupVarying(e);
    if (i.propertyName === void 0) {
      const s = this.getNodeType(e), a = e.getPropertyName(n, n2.VERTEX);
      e.flowNodeFromShaderStage(n2.VERTEX, this.node, s, a), i.propertyName = a;
    }
    return e.getPropertyName(n);
  }
}
const Ea = /* @__PURE__ */ Ae(oX);
ve("varying", Ea);
const lX = /* @__PURE__ */ Fe(([r]) => {
  const e = r.mul(0.9478672986).add(0.0521327014).pow(2.4), i = r.mul(0.0773993808), n = r.lessThanEqual(0.04045);
  return li(e, i, n);
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), uX = /* @__PURE__ */ Fe(([r]) => {
  const e = r.pow(0.41666).mul(1.055).sub(0.055), i = r.mul(12.92), n = r.lessThanEqual(31308e-7);
  return li(e, i, n);
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), tp = "WorkingColorSpace", N1 = "OutputColorSpace";
class kg extends zi {
  static get type() {
    return "ColorSpaceNode";
  }
  constructor(e, i, n) {
    super("vec4"), this.colorNode = e, this.source = i, this.target = n;
  }
  resolveColorSpace(e, i) {
    return i === tp ? Li.workingColorSpace : i === N1 ? e.context.outputColorSpace || e.renderer.outputColorSpace : i;
  }
  setup(e) {
    const { colorNode: i } = this, n = this.resolveColorSpace(e, this.source), s = this.resolveColorSpace(e, this.target);
    let a = i;
    return Li.enabled === !1 || n === s || !n || !s || (Li.getTransfer(n) === yd && (a = _t(lX(a.rgb), a.a)), Li.getPrimaries(n) !== Li.getPrimaries(s) && (a = _t(
      Rr(Li._getMatrix(new Xr(), n, s)).mul(a.rgb),
      a.a
    )), Li.getTransfer(s) === yd && (a = _t(uX(a.rgb), a.a))), a;
  }
}
const cX = (r) => De(new kg(De(r), tp, N1)), hX = (r) => De(new kg(De(r), N1, tp)), dX = (r, e) => De(new kg(De(r), tp, e)), dP = (r, e) => De(new kg(De(r), e, tp));
ve("toOutputColorSpace", cX);
ve("toWorkingColorSpace", hX);
ve("workingToColorSpace", dX);
ve("colorSpaceToWorking", dP);
let pX = class extends Jd {
  static get type() {
    return "ReferenceElementNode";
  }
  constructor(r, e) {
    super(r, e), this.referenceNode = r, this.isReferenceElementNode = !0;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(r) {
    const e = super.generate(r), i = this.referenceNode.getNodeType(), n = this.getNodeType();
    return r.format(e, i, n);
  }
};
class pP extends Mt {
  static get type() {
    return "ReferenceBaseNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.property = e, this.uniformType = i, this.object = n, this.count = s, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.updateType = Nt.OBJECT;
  }
  setGroup(e) {
    return this.group = e, this;
  }
  element(e) {
    return De(new pX(this, De(e)));
  }
  setNodeType(e) {
    const i = Tt(null, e).getSelf();
    this.group !== null && i.setGroup(this.group), this.node = i;
  }
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  getValueFromReference(e = this.reference) {
    const { properties: i } = this;
    let n = e[i[0]];
    for (let s = 1; s < i.length; s++)
      n = n[i[s]];
    return n;
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setup() {
    return this.updateValue(), this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const fX = (r, e, i) => De(new pP(r, e, i));
class mX extends pP {
  static get type() {
    return "RendererReferenceNode";
  }
  constructor(e, i, n = null) {
    super(e, i, n), this.renderer = n, this.setGroup(kt);
  }
  updateReference(e) {
    return this.reference = this.renderer !== null ? this.renderer : e.renderer, this.reference;
  }
}
const gX = (r, e, i) => De(new mX(r, e, i));
class yX extends zi {
  static get type() {
    return "ToneMappingNode";
  }
  constructor(e, i = bX, n = null) {
    super("vec3"), this.toneMapping = e, this.exposureNode = i, this.colorNode = n;
  }
  getCacheKey() {
    return zm(super.getCacheKey(), this.toneMapping);
  }
  setup(e) {
    const i = this.colorNode || e.context.color, n = this.toneMapping;
    if (n === Ku) return i;
    let s = null;
    const a = e.renderer.library.getToneMappingFunction(n);
    return a !== null ? s = _t(a(i.rgb, this.exposureNode), i.a) : (console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", n), s = i), s;
  }
}
const vX = (r, e, i) => De(new yX(r, De(e), De(i))), bX = /* @__PURE__ */ gX("toneMappingExposure", "float");
ve("toneMapping", (r, e, i) => vX(e, i, r));
class xX extends b1 {
  static get type() {
    return "BufferAttributeNode";
  }
  constructor(e, i = null, n = 0, s = 0) {
    super(e, i), this.isBufferNode = !0, this.bufferType = i, this.bufferStride = n, this.bufferOffset = s, this.usage = Bm, this.instanced = !1, this.attribute = null, this.global = !0, e && e.isBufferAttribute === !0 && (this.attribute = e, this.usage = e.usage, this.instanced = e.isInstancedBufferAttribute);
  }
  getHash(e) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let i = e.globalCache.getData(this.value);
      return i === void 0 && (i = {
        node: this
      }, e.globalCache.setData(this.value, i)), i.node.uuid;
    }
    return this.uuid;
  }
  getNodeType(e) {
    return this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)), this.bufferType;
  }
  setup(e) {
    if (this.attribute !== null) return;
    const i = this.getNodeType(e), n = this.value, s = e.getTypeLength(i), a = this.bufferStride || s, o = this.bufferOffset, l = n.isInterleavedBuffer === !0 ? n : new T3(n, a), u = new p1(l, s, o);
    l.setUsage(this.usage), this.attribute = u, this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(e) {
    const i = this.getNodeType(e), n = e.getBufferAttributeFromNode(this, i), s = e.getPropertyName(n);
    let a = null;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? (this.name = s, a = s) : a = Ea(this).build(e, i), a;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(e) {
    return this.usage = e, this.attribute && this.attribute.isBufferAttribute === !0 && (this.attribute.usage = e), this;
  }
  setInstanced(e) {
    return this.instanced = e, this;
  }
}
const P1 = (r, e, i, n) => De(new xX(r, e, i, n)), _X = (r, e, i, n) => P1(r, e, i, n).setUsage(ku), f2 = (r, e, i, n) => P1(r, e, i, n).setInstanced(!0), m2 = (r, e, i, n) => _X(r, e, i, n).setInstanced(!0);
ve("toAttribute", (r) => P1(r.value));
class TX extends Mt {
  static get type() {
    return "ComputeNode";
  }
  constructor(e, i, n = [64]) {
    super("void"), this.isComputeNode = !0, this.computeNode = e, this.count = i, this.workgroupSize = n, this.dispatchCount = 0, this.version = 1, this.updateBeforeType = Nt.OBJECT, this.onInitFunction = null, this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  updateDispatchCount() {
    const { count: e, workgroupSize: i } = this;
    let n = i[0];
    for (let s = 1; s < i.length; s++)
      n *= i[s];
    this.dispatchCount = Math.ceil(e / n);
  }
  onInit(e) {
    return this.onInitFunction = e, this;
  }
  updateBefore({ renderer: e }) {
    e.compute(this);
  }
  generate(e) {
    const { shaderStage: i } = e;
    if (i === "compute") {
      const n = this.computeNode.build(e, "void");
      n !== "" && e.addLineFlowCode(n, this);
    }
  }
}
const wX = (r, e, i) => De(new TX(De(r), e, i));
ve("compute", wX);
class SX extends Mt {
  static get type() {
    return "CacheNode";
  }
  constructor(e, i = !0) {
    super(), this.node = e, this.parent = i, this.isCacheNode = !0;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  build(e, ...i) {
    const n = e.getCache(), s = e.getCacheFromNode(this, this.parent);
    e.setCache(s);
    const a = this.node.build(e, ...i);
    return e.setCache(n), a;
  }
}
const om = (r, ...e) => De(new SX(De(r), ...e));
ve("cache", om);
class EX extends Mt {
  static get type() {
    return "BypassNode";
  }
  constructor(e, i) {
    super(), this.isBypassNode = !0, this.outputNode = e, this.callNode = i;
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const i = this.callNode.build(e, "void");
    return i !== "" && e.addLineFlowCode(i, this), this.outputNode.build(e);
  }
}
const MX = /* @__PURE__ */ Ae(EX);
ve("bypass", MX);
class fP extends Mt {
  static get type() {
    return "RemapNode";
  }
  constructor(e, i, n, s = _e(0), a = _e(1)) {
    super(), this.node = e, this.inLowNode = i, this.inHighNode = n, this.outLowNode = s, this.outHighNode = a, this.doClamp = !0;
  }
  setup() {
    const { node: e, inLowNode: i, inHighNode: n, outLowNode: s, outHighNode: a, doClamp: o } = this;
    let l = e.sub(i).div(n.sub(i));
    return o === !0 && (l = l.clamp()), l.mul(a.sub(s)).add(s);
  }
}
const AX = /* @__PURE__ */ Ae(fP, null, null, { doClamp: !1 }), CX = /* @__PURE__ */ Ae(fP);
ve("remap", AX);
ve("remapClamp", CX);
class RX extends Mt {
  static get type() {
    return "ExpressionNode";
  }
  constructor(e = "", i = "void") {
    super(i), this.snippet = e;
  }
  generate(e, i) {
    const n = this.getNodeType(e), s = this.snippet;
    if (n === "void")
      e.addLineFlowCode(s, this);
    else
      return e.format(`( ${s} )`, n, i);
  }
}
const wd = /* @__PURE__ */ Ae(RX), NX = (r) => (r ? Fr(r, wd("discard")) : wd("discard")).append();
ve("discard", NX);
class PX extends zi {
  static get type() {
    return "RenderOutputNode";
  }
  constructor(e, i, n) {
    super("vec4"), this.colorNode = e, this.toneMapping = i, this.outputColorSpace = n, this.isRenderOutput = !0;
  }
  setup({ context: e }) {
    let i = this.colorNode || e.color;
    const n = (this.toneMapping !== null ? this.toneMapping : e.toneMapping) || Ku, s = (this.outputColorSpace !== null ? this.outputColorSpace : e.outputColorSpace) || wl;
    return n !== Ku && (i = i.toneMapping(n)), s !== wl && s !== Li.workingColorSpace && (i = i.workingToColorSpace(s)), i;
  }
}
const IX = (r, e = null, i = null) => De(new PX(De(r), e, i));
ve("renderOutput", IX);
class OX extends Mt {
  static get type() {
    return "AttributeNode";
  }
  constructor(e, i = null) {
    super(i), this.global = !0, this._attributeName = e;
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let i = this.nodeType;
    if (i === null) {
      const n = this.getAttributeName(e);
      if (e.hasGeometryAttribute(n)) {
        const s = e.geometry.getAttribute(n);
        i = e.getTypeFromAttribute(s);
      } else
        i = "float";
    }
    return i;
  }
  setAttributeName(e) {
    return this._attributeName = e, this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const i = this.getAttributeName(e), n = this.getNodeType(e);
    if (e.hasGeometryAttribute(i) === !0) {
      const s = e.geometry.getAttribute(i), a = e.getTypeFromAttribute(s), o = e.getAttribute(i, a);
      return e.shaderStage === "vertex" ? e.format(o.name, a, n) : Ea(this).build(e, n);
    } else
      return console.warn(`AttributeNode: Vertex attribute "${i}" not found on geometry.`), e.generateConst(n);
  }
  serialize(e) {
    super.serialize(e), e.global = this.global, e._attributeName = this._attributeName;
  }
  deserialize(e) {
    super.deserialize(e), this.global = e.global, this._attributeName = e._attributeName;
  }
}
const _a = (r, e) => De(new OX(r, e)), Ug = (r) => _a("uv" + (r > 0 ? r : ""), "vec2");
class DX extends Mt {
  static get type() {
    return "TextureSizeNode";
  }
  constructor(e, i = null) {
    super("uvec2"), this.isTextureSizeNode = !0, this.textureNode = e, this.levelNode = i;
  }
  generate(e, i) {
    const n = this.textureNode.build(e, "property"), s = this.levelNode === null ? "0" : this.levelNode.build(e, "int");
    return e.format(`${e.getMethod("textureDimensions")}( ${n}, ${s} )`, this.getNodeType(e), i);
  }
}
const id = /* @__PURE__ */ Ae(DX);
class LX extends ep {
  static get type() {
    return "MaxMipLevelNode";
  }
  constructor(e) {
    super(0), this._textureNode = e, this.updateType = Nt.FRAME;
  }
  get textureNode() {
    return this._textureNode;
  }
  get texture() {
    return this._textureNode.value;
  }
  update() {
    const e = this.texture, i = e.images, n = i && i.length > 0 ? i[0] && i[0].image || i[0] : e.image;
    if (n && n.width !== void 0) {
      const { width: s, height: a } = n;
      this.value = Math.log2(Math.max(s, a));
    }
  }
}
const kX = /* @__PURE__ */ Ae(LX);
class ip extends ep {
  static get type() {
    return "TextureNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e), this.isTextureNode = !0, this.uvNode = i, this.levelNode = n, this.biasNode = s, this.compareNode = null, this.depthNode = null, this.gradNode = null, this.sampler = !0, this.updateMatrix = !1, this.updateType = Nt.NONE, this.referenceNode = null, this._value = e, this._matrixUniform = null, this.setUpdateMatrix(i === null);
  }
  set value(e) {
    this.referenceNode ? this.referenceNode.value = e : this._value = e;
  }
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : this.value.type === er ? "uvec4" : this.value.type === wr ? "ivec4" : "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return Ug(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(e) {
    return this._matrixUniform === null && (this._matrixUniform = Tt(this.value.matrix)), this._matrixUniform.mul(be(e, 1)).xy;
  }
  setUpdateMatrix(e) {
    return this.updateMatrix = e, this.updateType = e ? Nt.FRAME : Nt.NONE, this;
  }
  setupUV(e, i) {
    const n = this.value;
    return e.isFlipY() && (n.isRenderTargetTexture === !0 || n.isFramebufferTexture === !0 || n.isDepthTexture === !0) && (this.sampler ? i = i.flipY() : i = i.setY(Ei(id(this, this.levelNode).y).sub(i.y).sub(1))), i;
  }
  setup(e) {
    const i = e.getNodeProperties(this);
    i.referenceNode = this.referenceNode;
    let n = this.uvNode;
    (n === null || e.context.forceUVContext === !0) && e.context.getUV && (n = e.context.getUV(this)), n || (n = this.getDefaultUV()), this.updateMatrix === !0 && (n = this.getTransformedUV(n)), n = this.setupUV(e, n);
    let s = this.levelNode;
    s === null && e.context.getTextureLevel && (s = e.context.getTextureLevel(this)), i.uvNode = n, i.levelNode = s, i.biasNode = this.biasNode, i.compareNode = this.compareNode, i.gradNode = this.gradNode, i.depthNode = this.depthNode;
  }
  generateUV(e, i) {
    return i.build(e, this.sampler === !0 ? "vec2" : "ivec2");
  }
  generateSnippet(e, i, n, s, a, o, l, u) {
    const c = this.value;
    let h;
    return s ? h = e.generateTextureLevel(c, i, n, s, o) : a ? h = e.generateTextureBias(c, i, n, a, o) : u ? h = e.generateTextureGrad(c, i, n, u, o) : l ? h = e.generateTextureCompare(c, i, n, l, o) : this.sampler === !1 ? h = e.generateTextureLoad(c, i, n, o) : h = e.generateTexture(c, i, n, o), h;
  }
  generate(e, i) {
    const n = e.getNodeProperties(this), s = this.value;
    if (!s || s.isTexture !== !0)
      throw new Error("TextureNode: Need a three.js texture.");
    const a = super.generate(e, "property");
    if (i === "sampler")
      return a + "_sampler";
    if (e.isReference(i))
      return a;
    {
      const o = e.getDataFromNode(this);
      let l = o.propertyName;
      if (l === void 0) {
        const { uvNode: h, levelNode: d, biasNode: p, compareNode: f, depthNode: m, gradNode: y } = n, v = this.generateUV(e, h), g = d ? d.build(e, "float") : null, _ = p ? p.build(e, "float") : null, x = m ? m.build(e, "int") : null, b = f ? f.build(e, "float") : null, T = y ? [y[0].build(e, "vec2"), y[1].build(e, "vec2")] : null, E = e.getVarFromNode(this);
        l = e.getPropertyName(E);
        const M = this.generateSnippet(e, a, v, g, _, x, b, T);
        e.addLineFlowCode(`${l} = ${M}`, this), o.snippet = M, o.propertyName = l;
      }
      let u = l;
      const c = this.getNodeType(e);
      return e.needsToWorkingColorSpace(s) && (u = dP(wd(u, c), s.colorSpace).setup(e).build(e, c)), e.format(u, c, i);
    }
  }
  setSampler(e) {
    return this.sampler = e, this;
  }
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  uv(e) {
    const i = this.clone();
    return i.uvNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  blur(e) {
    const i = this.clone();
    return i.biasNode = De(e).mul(kX(i)), i.referenceNode = this.getSelf(), De(i);
  }
  level(e) {
    const i = this.clone();
    return i.levelNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  size(e) {
    return id(this, e);
  }
  bias(e) {
    const i = this.clone();
    return i.biasNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  compare(e) {
    const i = this.clone();
    return i.compareNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  grad(e, i) {
    const n = this.clone();
    return n.gradNode = [De(e), De(i)], n.referenceNode = this.getSelf(), De(n);
  }
  depth(e) {
    const i = this.clone();
    return i.depthNode = De(e), i.referenceNode = this.getSelf(), De(i);
  }
  // --
  serialize(e) {
    super.serialize(e), e.value = this.value.toJSON(e.meta).uuid, e.sampler = this.sampler, e.updateMatrix = this.updateMatrix, e.updateType = this.updateType;
  }
  deserialize(e) {
    super.deserialize(e), this.value = e.meta.textures[e.value], this.sampler = e.sampler, this.updateMatrix = e.updateMatrix, this.updateType = e.updateType;
  }
  update() {
    const e = this.value, i = this._matrixUniform;
    i !== null && (i.value = e.matrix), e.matrixAutoUpdate === !0 && e.updateMatrix();
  }
  clone() {
    const e = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
    return e.sampler = this.sampler, e;
  }
}
const Ai = /* @__PURE__ */ Ae(ip), Un = (...r) => Ai(...r).setSampler(!1), Ko = /* @__PURE__ */ Tt("float").label("cameraNear").setGroup(kt).onRenderUpdate(({ camera: r }) => r.near), Zo = /* @__PURE__ */ Tt("float").label("cameraFar").setGroup(kt).onRenderUpdate(({ camera: r }) => r.far), Ym = /* @__PURE__ */ Tt("mat4").label("cameraProjectionMatrix").setGroup(kt).onRenderUpdate(({ camera: r }) => r.projectionMatrix), Ma = /* @__PURE__ */ Tt("mat4").label("cameraViewMatrix").setGroup(kt).onRenderUpdate(({ camera: r }) => r.matrixWorldInverse), UX = /* @__PURE__ */ Tt(new ue()).label("cameraPosition").setGroup(kt).onRenderUpdate(({ camera: r }, e) => e.value.setFromMatrixPosition(r.matrixWorld));
class wi extends Mt {
  static get type() {
    return "Object3DNode";
  }
  constructor(e, i = null) {
    super(), this.scope = e, this.object3d = i, this.updateType = Nt.OBJECT, this._uniformNode = new ep(null);
  }
  getNodeType() {
    const e = this.scope;
    if (e === wi.WORLD_MATRIX)
      return "mat4";
    if (e === wi.POSITION || e === wi.VIEW_POSITION || e === wi.DIRECTION || e === wi.SCALE)
      return "vec3";
  }
  update(e) {
    const i = this.object3d, n = this._uniformNode, s = this.scope;
    if (s === wi.WORLD_MATRIX)
      n.value = i.matrixWorld;
    else if (s === wi.POSITION)
      n.value = n.value || new ue(), n.value.setFromMatrixPosition(i.matrixWorld);
    else if (s === wi.SCALE)
      n.value = n.value || new ue(), n.value.setFromMatrixScale(i.matrixWorld);
    else if (s === wi.DIRECTION)
      n.value = n.value || new ue(), i.getWorldDirection(n.value);
    else if (s === wi.VIEW_POSITION) {
      const a = e.camera;
      n.value = n.value || new ue(), n.value.setFromMatrixPosition(i.matrixWorld), n.value.applyMatrix4(a.matrixWorldInverse);
    }
  }
  generate(e) {
    const i = this.scope;
    return i === wi.WORLD_MATRIX ? this._uniformNode.nodeType = "mat4" : (i === wi.POSITION || i === wi.VIEW_POSITION || i === wi.DIRECTION || i === wi.SCALE) && (this._uniformNode.nodeType = "vec3"), this._uniformNode.build(e);
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
wi.WORLD_MATRIX = "worldMatrix";
wi.POSITION = "position";
wi.SCALE = "scale";
wi.VIEW_POSITION = "viewPosition";
wi.DIRECTION = "direction";
class Sc extends wi {
  static get type() {
    return "ModelNode";
  }
  constructor(e) {
    super(e);
  }
  update(e) {
    this.object3d = e.object, super.update(e);
  }
}
Sc.DIRECTION;
const Al = /* @__PURE__ */ Ge(Sc, Sc.WORLD_MATRIX);
Sc.POSITION;
Sc.SCALE;
Sc.VIEW_POSITION;
const FX = /* @__PURE__ */ Tt(new Xr()).onObjectUpdate(({ object: r }, e) => e.value.getNormalMatrix(r.matrixWorld)), Fg = /* @__PURE__ */ Ma.mul(Al).toVar("modelViewMatrix"), mP = /* @__PURE__ */ _a("position", "vec3"), sr = /* @__PURE__ */ mP.varying("positionLocal"), g2 = /* @__PURE__ */ mP.varying("positionPrevious"), Tx = /* @__PURE__ */ Al.mul(sr).xyz.varying("v_positionWorld"), gP = /* @__PURE__ */ sr.transformDirection(Al).varying("v_positionWorldDirection").normalize().toVar("positionWorldDirection"), rr = /* @__PURE__ */ Fg.mul(sr).xyz.varying("v_positionView"), vi = /* @__PURE__ */ rr.negate().varying("v_positionViewDirection").normalize().toVar("positionViewDirection");
class BX extends Mt {
  static get type() {
    return "FrontFacingNode";
  }
  constructor() {
    super("bool"), this.isFrontFacingNode = !0;
  }
  generate(e) {
    const { renderer: i, material: n } = e;
    return i.coordinateSystem === Kn && n.side === Qn ? "false" : e.getFrontFacing();
  }
}
const zX = /* @__PURE__ */ Ge(BX), Bg = /* @__PURE__ */ _e(zX).mul(2).sub(1), yP = /* @__PURE__ */ _a("normal", "vec3"), _s = /* @__PURE__ */ Fe((r) => r.geometry.hasAttribute("normal") === !1 ? (console.warn('TSL.NormalNode: Vertex attribute "normal" not found on geometry.'), be(0, 1, 0)) : yP, "vec3").once()().toVar("normalLocal"), jX = /* @__PURE__ */ rr.dFdx().cross(rr.dFdy()).normalize().toVar("normalFlat"), Jn = /* @__PURE__ */ Fe((r) => {
  let e;
  return r.material.flatShading === !0 ? e = jX : e = Ea(bP(_s), "v_normalView").normalize(), e;
}, "vec3").once()().toVar("normalView"), vP = /* @__PURE__ */ Ea(Jn.transformDirection(Ma), "v_normalWorld").normalize().toVar("normalWorld"), Ui = /* @__PURE__ */ Fe((r) => r.context.setupNormal(), "vec3").once()().mul(Bg).toVar("transformedNormalView"), I1 = /* @__PURE__ */ Ui.transformDirection(Ma).toVar("transformedNormalWorld"), Vh = /* @__PURE__ */ Fe((r) => r.context.setupClearcoatNormal(), "vec3").once()().mul(Bg).toVar("transformedClearcoatNormalView"), VX = /* @__PURE__ */ Fe(([r, e = Al]) => {
  const i = Rr(e), n = r.div(be(i[0].dot(i[0]), i[1].dot(i[1]), i[2].dot(i[2])));
  return i.mul(n).xyz;
}), bP = /* @__PURE__ */ Fe(([r], e) => {
  const i = e.renderer.nodes.modelNormalViewMatrix;
  if (i !== null)
    return i.transformDirection(r);
  const n = FX.mul(r);
  return Ma.transformDirection(n);
}), GX = /* @__PURE__ */ Tt(0).onReference(({ material: r }) => r).onRenderUpdate(({ material: r }) => r.refractionRatio), HX = /* @__PURE__ */ vi.negate().reflect(Ui), WX = /* @__PURE__ */ vi.negate().refract(Ui, GX), qX = /* @__PURE__ */ HX.transformDirection(Ma).toVar("reflectVector"), XX = /* @__PURE__ */ WX.transformDirection(Ma).toVar("reflectVector");
class YX extends ip {
  static get type() {
    return "CubeTextureNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e, i, n, s), this.isCubeTextureNode = !0;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    const e = this.value;
    return e.mapping === Tl ? qX : e.mapping === _c ? XX : (console.error('THREE.CubeTextureNode: Mapping "%s" not supported.', e.mapping), be(0, 0, 0));
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  setupUV(e, i) {
    const n = this.value;
    return e.renderer.coordinateSystem === Sl || !n.isRenderTargetTexture ? be(i.x.negate(), i.yz) : i;
  }
  generateUV(e, i) {
    return i.build(e, "vec3");
  }
}
const Sd = /* @__PURE__ */ Ae(YX);
class xP extends ep {
  static get type() {
    return "BufferNode";
  }
  constructor(e, i, n = 0) {
    super(e, i), this.isBufferNode = !0, this.bufferType = i, this.bufferCount = n;
  }
  getElementType(e) {
    return this.getNodeType(e);
  }
  getInputType() {
    return "buffer";
  }
}
const O1 = (r, e, i) => De(new xP(r, e, i));
class KX extends Jd {
  static get type() {
    return "UniformArrayElementNode";
  }
  constructor(e, i) {
    super(e, i), this.isArrayBufferElementNode = !0;
  }
  generate(e) {
    const i = super.generate(e), n = this.getNodeType();
    return e.format(i, "vec4", n);
  }
}
class ZX extends xP {
  static get type() {
    return "UniformArrayNode";
  }
  constructor(e, i = null) {
    super(null, "vec4"), this.array = e, this.elementType = i, this._elementType = null, this._elementLength = 0, this.updateType = Nt.RENDER, this.isArrayBufferNode = !0;
  }
  getElementType() {
    return this.elementType || this._elementType;
  }
  getElementLength() {
    return this._elementLength;
  }
  update() {
    const { array: e, value: i } = this, n = this.getElementLength(), s = this.getElementType();
    if (n === 1)
      for (let a = 0; a < e.length; a++) {
        const o = a * 4;
        i[o] = e[a];
      }
    else if (s === "color")
      for (let a = 0; a < e.length; a++) {
        const o = a * 4, l = e[a];
        i[o] = l.r, i[o + 1] = l.g, i[o + 2] = l.b || 0;
      }
    else
      for (let a = 0; a < e.length; a++) {
        const o = a * 4, l = e[a];
        i[o] = l.x, i[o + 1] = l.y, i[o + 2] = l.z || 0, i[o + 3] = l.w || 0;
      }
  }
  setup(e) {
    const i = this.array.length;
    this._elementType = this.elementType === null ? Vm(this.array[0]) : this.elementType, this._elementLength = e.getTypeLength(this._elementType);
    let n = Float32Array;
    return this._elementType.charAt(0) === "i" ? n = Int32Array : this._elementType.charAt(0) === "u" && (n = Uint32Array), this.value = new n(i * 4), this.bufferCount = i, this.bufferType = e.changeComponentType("vec4", e.getComponentType(this._elementType)), super.setup(e);
  }
  element(e) {
    return De(new KX(this, De(e)));
  }
}
const Ed = (r, e) => De(new ZX(r, e));
class QX extends Jd {
  static get type() {
    return "ReferenceElementNode";
  }
  constructor(e, i) {
    super(e, i), this.referenceNode = e, this.isReferenceElementNode = !0;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(e) {
    const i = super.generate(e), n = this.referenceNode.getNodeType(), s = this.getNodeType();
    return e.format(i, n, s);
  }
}
class D1 extends Mt {
  static get type() {
    return "ReferenceNode";
  }
  constructor(e, i, n = null, s = null) {
    super(), this.property = e, this.uniformType = i, this.object = n, this.count = s, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.name = null, this.updateType = Nt.OBJECT;
  }
  element(e) {
    return De(new QX(this, De(e)));
  }
  setGroup(e) {
    return this.group = e, this;
  }
  label(e) {
    return this.name = e, this;
  }
  setNodeType(e) {
    let i = null;
    this.count !== null ? i = O1(null, e, this.count) : Array.isArray(this.getValueFromReference()) ? i = Ed(null, e) : e === "texture" ? i = Ai(null) : e === "cubeTexture" ? i = Sd(null) : i = Tt(null, e), this.group !== null && i.setGroup(this.group), this.name !== null && i.label(this.name), this.node = i.getSelf();
  }
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  getValueFromReference(e = this.reference) {
    const { properties: i } = this;
    let n = e[i[0]];
    for (let s = 1; s < i.length; s++)
      n = n[i[s]];
    return n;
  }
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  setup() {
    return this.updateValue(), this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const bi = (r, e, i) => De(new D1(r, e, i)), y2 = (r, e, i, n) => De(new D1(r, e, n, i));
class $X extends D1 {
  static get type() {
    return "MaterialReferenceNode";
  }
  constructor(e, i, n = null) {
    super(e, i, n), this.material = n, this.isMaterialReferenceNode = !0;
  }
  /*setNodeType( node ) {
  
  		super.setNodeType( node );
  
  		this.node.groupNode = renderGroup;
  
  	}*/
  updateReference(e) {
    return this.reference = this.material !== null ? this.material : e.material, this.reference;
  }
}
const eo = (r, e, i) => De(new $X(r, e, i)), _P = /* @__PURE__ */ Fe((r) => (r.geometry.hasAttribute("tangent") === !1 && r.geometry.computeTangents(), _a("tangent", "vec4")))(), L1 = /* @__PURE__ */ _P.xyz.toVar("tangentLocal"), TP = /* @__PURE__ */ Fg.mul(_t(L1, 0)).xyz.varying("v_tangentView").normalize().toVar("tangentView"), JX = (r) => r.mul(_P.w).xyz, eY = /* @__PURE__ */ Ea(JX(Jn.cross(TP)), "v_bitangentView").normalize().toVar("bitangentView"), Gh = /* @__PURE__ */ Rr(TP, eY, Jn), tY = /* @__PURE__ */ (() => {
  let r = ec.cross(vi);
  return r = r.cross(ec).normalize(), r = li(r, Ui, Go.mul(ta.oneMinus()).oneMinus().pow2().pow2()).normalize(), r;
})(), iY = /* @__PURE__ */ Fe((r) => {
  const { eye_pos: e, surf_norm: i, mapN: n, uv: s } = r, a = e.dFdx(), o = e.dFdy(), l = s.dFdx(), u = s.dFdy(), c = i, h = o.cross(c), d = c.cross(a), p = h.mul(l.x).add(d.mul(u.x)), f = h.mul(l.y).add(d.mul(u.y)), m = p.dot(p).max(f.dot(f)), y = Bg.mul(m.inverseSqrt());
  return Nr(p.mul(n.x, y), f.mul(n.y, y), c.mul(n.z)).normalize();
});
class rY extends zi {
  static get type() {
    return "NormalMapNode";
  }
  constructor(e, i = null) {
    super("vec3"), this.node = e, this.scaleNode = i, this.normalMapType = yo;
  }
  setup(e) {
    const { normalMapType: i, scaleNode: n } = this;
    let s = this.node.mul(2).sub(1);
    n !== null && (s = be(s.xy.mul(n), s.z));
    let a = null;
    return i === QH ? a = bP(s) : i === yo && (e.hasGeometryAttribute("tangent") === !0 ? a = Gh.mul(s).normalize() : a = iY({
      eye_pos: rr,
      surf_norm: Jn,
      mapN: s,
      uv: Ug()
    })), a;
  }
}
const v2 = /* @__PURE__ */ Ae(rY), nY = Fe(({ textureNode: r, bumpScale: e }) => {
  const i = (s) => r.cache().context({ getUV: (a) => s(a.uvNode || Ug()), forceUVContext: !0 }), n = _e(i((s) => s));
  return We(
    _e(i((s) => s.add(s.dFdx()))).sub(n),
    _e(i((s) => s.add(s.dFdy()))).sub(n)
  ).mul(e);
}), sY = Fe((r) => {
  const { surf_pos: e, surf_norm: i, dHdxy: n } = r, s = e.dFdx().normalize(), a = e.dFdy().normalize(), o = i, l = a.cross(o), u = o.cross(s), c = s.dot(l).mul(Bg), h = c.sign().mul(n.x.mul(l).add(n.y.mul(u)));
  return c.abs().mul(i).sub(h).normalize();
});
class aY extends zi {
  static get type() {
    return "BumpMapNode";
  }
  constructor(e, i = null) {
    super("vec3"), this.textureNode = e, this.scaleNode = i;
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1, i = nY({ textureNode: this.textureNode, bumpScale: e });
    return sY({
      surf_pos: rr,
      surf_norm: Jn,
      dHdxy: i
    });
  }
}
const oY = /* @__PURE__ */ Ae(aY), b2 = /* @__PURE__ */ new Map();
class me extends Mt {
  static get type() {
    return "MaterialNode";
  }
  constructor(e) {
    super(), this.scope = e;
  }
  getCache(e, i) {
    let n = b2.get(e);
    return n === void 0 && (n = eo(e, i), b2.set(e, n)), n;
  }
  getFloat(e) {
    return this.getCache(e, "float");
  }
  getColor(e) {
    return this.getCache(e, "color");
  }
  getTexture(e) {
    return this.getCache(e === "map" ? "map" : e + "Map", "texture");
  }
  setup(e) {
    const i = e.context.material, n = this.scope;
    let s = null;
    if (n === me.COLOR) {
      const a = i.color !== void 0 ? this.getColor(n) : be();
      i.map && i.map.isTexture === !0 ? s = a.mul(this.getTexture("map")) : s = a;
    } else if (n === me.OPACITY) {
      const a = this.getFloat(n);
      i.alphaMap && i.alphaMap.isTexture === !0 ? s = a.mul(this.getTexture("alpha")) : s = a;
    } else if (n === me.SPECULAR_STRENGTH)
      i.specularMap && i.specularMap.isTexture === !0 ? s = this.getTexture("specular").r : s = _e(1);
    else if (n === me.SPECULAR_INTENSITY) {
      const a = this.getFloat(n);
      i.specularMap ? s = a.mul(this.getTexture(n).a) : s = a;
    } else if (n === me.SPECULAR_COLOR) {
      const a = this.getColor(n);
      i.specularColorMap && i.specularColorMap.isTexture === !0 ? s = a.mul(this.getTexture(n).rgb) : s = a;
    } else if (n === me.ROUGHNESS) {
      const a = this.getFloat(n);
      i.roughnessMap && i.roughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).g) : s = a;
    } else if (n === me.METALNESS) {
      const a = this.getFloat(n);
      i.metalnessMap && i.metalnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).b) : s = a;
    } else if (n === me.EMISSIVE) {
      const a = this.getFloat("emissiveIntensity"), o = this.getColor(n).mul(a);
      i.emissiveMap && i.emissiveMap.isTexture === !0 ? s = o.mul(this.getTexture(n)) : s = o;
    } else if (n === me.NORMAL)
      i.normalMap ? (s = v2(this.getTexture("normal"), this.getCache("normalScale", "vec2")), s.normalMapType = i.normalMapType) : i.bumpMap ? s = oY(this.getTexture("bump").r, this.getFloat("bumpScale")) : s = Jn;
    else if (n === me.CLEARCOAT) {
      const a = this.getFloat(n);
      i.clearcoatMap && i.clearcoatMap.isTexture === !0 ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === me.CLEARCOAT_ROUGHNESS) {
      const a = this.getFloat(n);
      i.clearcoatRoughnessMap && i.clearcoatRoughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === me.CLEARCOAT_NORMAL)
      i.clearcoatNormalMap ? s = v2(this.getTexture(n), this.getCache(n + "Scale", "vec2")) : s = Jn;
    else if (n === me.SHEEN) {
      const a = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      i.sheenColorMap && i.sheenColorMap.isTexture === !0 ? s = a.mul(this.getTexture("sheenColor").rgb) : s = a;
    } else if (n === me.SHEEN_ROUGHNESS) {
      const a = this.getFloat(n);
      i.sheenRoughnessMap && i.sheenRoughnessMap.isTexture === !0 ? s = a.mul(this.getTexture(n).a) : s = a, s = s.clamp(0.07, 1);
    } else if (n === me.ANISOTROPY)
      if (i.anisotropyMap && i.anisotropyMap.isTexture === !0) {
        const a = this.getTexture(n);
        s = w1(_h.x, _h.y, _h.y.negate(), _h.x).mul(a.rg.mul(2).sub(We(1)).normalize().mul(a.b));
      } else
        s = _h;
    else if (n === me.IRIDESCENCE_THICKNESS) {
      const a = bi("1", "float", i.iridescenceThicknessRange);
      if (i.iridescenceThicknessMap) {
        const o = bi("0", "float", i.iridescenceThicknessRange);
        s = a.sub(o).mul(this.getTexture(n).g).add(o);
      } else
        s = a;
    } else if (n === me.TRANSMISSION) {
      const a = this.getFloat(n);
      i.transmissionMap ? s = a.mul(this.getTexture(n).r) : s = a;
    } else if (n === me.THICKNESS) {
      const a = this.getFloat(n);
      i.thicknessMap ? s = a.mul(this.getTexture(n).g) : s = a;
    } else if (n === me.IOR)
      s = this.getFloat(n);
    else if (n === me.LIGHT_MAP)
      s = this.getTexture(n).rgb.mul(this.getFloat("lightMapIntensity"));
    else if (n === me.AO_MAP)
      s = this.getTexture(n).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
    else {
      const a = this.getNodeType(e);
      s = this.getCache(n, a);
    }
    return s;
  }
}
me.ALPHA_TEST = "alphaTest";
me.COLOR = "color";
me.OPACITY = "opacity";
me.SHININESS = "shininess";
me.SPECULAR = "specular";
me.SPECULAR_STRENGTH = "specularStrength";
me.SPECULAR_INTENSITY = "specularIntensity";
me.SPECULAR_COLOR = "specularColor";
me.REFLECTIVITY = "reflectivity";
me.ROUGHNESS = "roughness";
me.METALNESS = "metalness";
me.NORMAL = "normal";
me.CLEARCOAT = "clearcoat";
me.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
me.CLEARCOAT_NORMAL = "clearcoatNormal";
me.EMISSIVE = "emissive";
me.ROTATION = "rotation";
me.SHEEN = "sheen";
me.SHEEN_ROUGHNESS = "sheenRoughness";
me.ANISOTROPY = "anisotropy";
me.IRIDESCENCE = "iridescence";
me.IRIDESCENCE_IOR = "iridescenceIOR";
me.IRIDESCENCE_THICKNESS = "iridescenceThickness";
me.IOR = "ior";
me.TRANSMISSION = "transmission";
me.THICKNESS = "thickness";
me.ATTENUATION_DISTANCE = "attenuationDistance";
me.ATTENUATION_COLOR = "attenuationColor";
me.LINE_SCALE = "scale";
me.LINE_DASH_SIZE = "dashSize";
me.LINE_GAP_SIZE = "gapSize";
me.LINE_WIDTH = "linewidth";
me.LINE_DASH_OFFSET = "dashOffset";
me.POINT_WIDTH = "pointWidth";
me.DISPERSION = "dispersion";
me.LIGHT_MAP = "light";
me.AO_MAP = "ao";
const lY = /* @__PURE__ */ Ge(me, me.ALPHA_TEST), uY = /* @__PURE__ */ Ge(me, me.COLOR), cY = /* @__PURE__ */ Ge(me, me.SHININESS), hY = /* @__PURE__ */ Ge(me, me.EMISSIVE), wP = /* @__PURE__ */ Ge(me, me.OPACITY), dY = /* @__PURE__ */ Ge(me, me.SPECULAR), x2 = /* @__PURE__ */ Ge(me, me.SPECULAR_INTENSITY), pY = /* @__PURE__ */ Ge(me, me.SPECULAR_COLOR), lm = /* @__PURE__ */ Ge(me, me.SPECULAR_STRENGTH), z0 = /* @__PURE__ */ Ge(me, me.REFLECTIVITY), fY = /* @__PURE__ */ Ge(me, me.ROUGHNESS), mY = /* @__PURE__ */ Ge(me, me.METALNESS), gY = /* @__PURE__ */ Ge(me, me.NORMAL).context({ getUV: null }), yY = /* @__PURE__ */ Ge(me, me.CLEARCOAT), vY = /* @__PURE__ */ Ge(me, me.CLEARCOAT_ROUGHNESS), bY = /* @__PURE__ */ Ge(me, me.CLEARCOAT_NORMAL).context({ getUV: null }), xY = /* @__PURE__ */ Ge(me, me.ROTATION), _Y = /* @__PURE__ */ Ge(me, me.SHEEN), TY = /* @__PURE__ */ Ge(me, me.SHEEN_ROUGHNESS), wY = /* @__PURE__ */ Ge(me, me.ANISOTROPY), SY = /* @__PURE__ */ Ge(me, me.IRIDESCENCE), EY = /* @__PURE__ */ Ge(me, me.IRIDESCENCE_IOR), MY = /* @__PURE__ */ Ge(me, me.IRIDESCENCE_THICKNESS), AY = /* @__PURE__ */ Ge(me, me.TRANSMISSION), CY = /* @__PURE__ */ Ge(me, me.THICKNESS), RY = /* @__PURE__ */ Ge(me, me.IOR), NY = /* @__PURE__ */ Ge(me, me.ATTENUATION_DISTANCE), PY = /* @__PURE__ */ Ge(me, me.ATTENUATION_COLOR), IY = /* @__PURE__ */ Ge(me, me.LINE_SCALE), OY = /* @__PURE__ */ Ge(me, me.LINE_DASH_SIZE), DY = /* @__PURE__ */ Ge(me, me.LINE_GAP_SIZE);
me.LINE_WIDTH;
me.LINE_DASH_OFFSET;
me.POINT_WIDTH;
const LY = /* @__PURE__ */ Ge(me, me.DISPERSION), SP = /* @__PURE__ */ Ge(me, me.LIGHT_MAP), kY = /* @__PURE__ */ Ge(me, me.AO_MAP), _h = /* @__PURE__ */ Tt(new Vt()).onReference(function(r) {
  return r.material;
}).onRenderUpdate(function({ material: r }) {
  this.value.set(r.anisotropy * Math.cos(r.anisotropyRotation), r.anisotropy * Math.sin(r.anisotropyRotation));
});
class UY extends zi {
  static get type() {
    return "ModelViewProjectionNode";
  }
  constructor(e = null) {
    super("vec4"), this.positionNode = e;
  }
  setup(e) {
    if (e.shaderStage === "fragment")
      return Ea(e.context.mvp);
    const i = this.positionNode || sr, n = e.renderer.nodes.modelViewMatrix || Fg;
    return Ym.mul(n).mul(i);
  }
}
const wx = /* @__PURE__ */ Ae(UY);
class Mi extends Mt {
  static get type() {
    return "IndexNode";
  }
  constructor(e) {
    super("uint"), this.scope = e, this.isInstanceIndexNode = !0;
  }
  generate(e) {
    const i = this.getNodeType(e), n = this.scope;
    let s;
    if (n === Mi.VERTEX)
      s = e.getVertexIndex();
    else if (n === Mi.INSTANCE)
      s = e.getInstanceIndex();
    else if (n === Mi.DRAW)
      s = e.getDrawIndex();
    else if (n === Mi.INVOCATION_LOCAL)
      s = e.getInvocationLocalIndex();
    else if (n === Mi.INVOCATION_SUBGROUP)
      s = e.getInvocationSubgroupIndex();
    else if (n === Mi.SUBGROUP)
      s = e.getSubgroupIndex();
    else
      throw new Error("THREE.IndexNode: Unknown scope: " + n);
    let a;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? a = s : a = Ea(this).build(e, i), a;
  }
}
Mi.VERTEX = "vertex";
Mi.INSTANCE = "instance";
Mi.SUBGROUP = "subgroup";
Mi.INVOCATION_LOCAL = "invocationLocal";
Mi.INVOCATION_SUBGROUP = "invocationSubgroup";
Mi.DRAW = "draw";
const FY = /* @__PURE__ */ Ge(Mi, Mi.VERTEX), k1 = /* @__PURE__ */ Ge(Mi, Mi.INSTANCE);
Mi.SUBGROUP;
Mi.INVOCATION_SUBGROUP;
Mi.INVOCATION_LOCAL;
const BY = /* @__PURE__ */ Ge(Mi, Mi.DRAW);
class zY extends Mt {
  static get type() {
    return "InstanceNode";
  }
  constructor(e) {
    super("void"), this.instanceMesh = e, this.instanceMatrixNode = null, this.instanceColorNode = null, this.updateType = Nt.FRAME, this.buffer = null, this.bufferColor = null;
  }
  setup(e) {
    let i = this.instanceMatrixNode, n = this.instanceColorNode;
    const s = this.instanceMesh;
    if (i === null) {
      const l = s.instanceMatrix;
      if (s.count <= 1e3)
        i = O1(l.array, "mat4", Math.max(s.count, 1)).element(k1);
      else {
        const u = new gW(l.array, 16, 1);
        this.buffer = u;
        const c = l.usage === ku ? m2 : f2, h = [
          // F.Signature -> bufferAttribute( array, type, stride, offset )
          c(u, "vec4", 16, 0),
          c(u, "vec4", 16, 4),
          c(u, "vec4", 16, 8),
          c(u, "vec4", 16, 12)
        ];
        i = Ju(...h);
      }
      this.instanceMatrixNode = i;
    }
    const a = s.instanceColor;
    if (a && n === null) {
      const l = new iW(a.array, 3), u = a.usage === ku ? m2 : f2;
      this.bufferColor = l, n = be(u(l, "vec3", 3, 0)), this.instanceColorNode = n;
    }
    const o = i.mul(sr).xyz;
    if (sr.assign(o), e.hasGeometryAttribute("normal")) {
      const l = VX(_s, i);
      _s.assign(l);
    }
    this.instanceColorNode !== null && Hm("vec3", "vInstanceColor").assign(this.instanceColorNode);
  }
  update() {
    this.instanceMesh.instanceMatrix.usage !== ku && this.buffer != null && this.instanceMesh.instanceMatrix.version !== this.buffer.version && (this.buffer.version = this.instanceMesh.instanceMatrix.version), this.instanceMesh.instanceColor && this.instanceMesh.instanceColor.usage !== ku && this.bufferColor != null && this.instanceMesh.instanceColor.version !== this.bufferColor.version && (this.bufferColor.version = this.instanceMesh.instanceColor.version);
  }
}
const jY = /* @__PURE__ */ Ae(zY);
class VY extends Mt {
  static get type() {
    return "BatchNode";
  }
  constructor(e) {
    super("void"), this.batchMesh = e, this.batchingIdNode = null;
  }
  setup(e) {
    this.batchingIdNode === null && (e.getDrawIndex() === null ? this.batchingIdNode = k1 : this.batchingIdNode = BY);
    const i = Fe(([f]) => {
      const m = id(Un(this.batchMesh._indirectTexture), 0), y = Ei(f).modInt(Ei(m)), v = Ei(f).div(Ei(m));
      return Un(this.batchMesh._indirectTexture, Ks(y, v)).x;
    }).setLayout({
      name: "getIndirectIndex",
      type: "uint",
      inputs: [
        { name: "id", type: "int" }
      ]
    })(Ei(this.batchingIdNode)), n = this.batchMesh._matricesTexture, s = id(Un(n), 0), a = _e(i).mul(4).toInt().toVar(), o = a.modInt(s), l = a.div(Ei(s)), u = Ju(
      Un(n, Ks(o, l)),
      Un(n, Ks(o.add(1), l)),
      Un(n, Ks(o.add(2), l)),
      Un(n, Ks(o.add(3), l))
    ), c = this.batchMesh._colorsTexture;
    if (c !== null) {
      const f = Fe(([m]) => {
        const y = id(Un(c), 0).x, v = m, g = v.modInt(y), _ = v.div(y);
        return Un(c, Ks(g, _)).rgb;
      }).setLayout({
        name: "getBatchingColor",
        type: "vec3",
        inputs: [
          { name: "id", type: "int" }
        ]
      })(i);
      Hm("vec3", "vBatchColor").assign(f);
    }
    const h = Rr(u);
    sr.assign(u.mul(sr));
    const d = _s.div(be(h[0].dot(h[0]), h[1].dot(h[1]), h[2].dot(h[2]))), p = h.mul(d).xyz;
    _s.assign(p), e.hasGeometryAttribute("tangent") && L1.mulAssign(h);
  }
}
const GY = /* @__PURE__ */ Ae(VY), _2 = /* @__PURE__ */ new WeakMap();
class HY extends Mt {
  static get type() {
    return "SkinningNode";
  }
  constructor(e, i = !1) {
    super("void"), this.skinnedMesh = e, this.useReference = i, this.updateType = Nt.OBJECT, this.skinIndexNode = _a("skinIndex", "uvec4"), this.skinWeightNode = _a("skinWeight", "vec4");
    let n, s, a;
    i ? (n = bi("bindMatrix", "mat4"), s = bi("bindMatrixInverse", "mat4"), a = y2("skeleton.boneMatrices", "mat4", e.skeleton.bones.length)) : (n = Tt(e.bindMatrix, "mat4"), s = Tt(e.bindMatrixInverse, "mat4"), a = O1(e.skeleton.boneMatrices, "mat4", e.skeleton.bones.length)), this.bindMatrixNode = n, this.bindMatrixInverseNode = s, this.boneMatricesNode = a, this.previousBoneMatricesNode = null;
  }
  getSkinnedPosition(e = this.boneMatricesNode, i = sr) {
    const { skinIndexNode: n, skinWeightNode: s, bindMatrixNode: a, bindMatrixInverseNode: o } = this, l = e.element(n.x), u = e.element(n.y), c = e.element(n.z), h = e.element(n.w), d = a.mul(i), p = Nr(
      l.mul(s.x).mul(d),
      u.mul(s.y).mul(d),
      c.mul(s.z).mul(d),
      h.mul(s.w).mul(d)
    );
    return o.mul(p).xyz;
  }
  getSkinnedNormal(e = this.boneMatricesNode, i = _s) {
    const { skinIndexNode: n, skinWeightNode: s, bindMatrixNode: a, bindMatrixInverseNode: o } = this, l = e.element(n.x), u = e.element(n.y), c = e.element(n.z), h = e.element(n.w);
    let d = Nr(
      s.x.mul(l),
      s.y.mul(u),
      s.z.mul(c),
      s.w.mul(h)
    );
    return d = o.mul(d).mul(a), d.transformDirection(i).xyz;
  }
  getPreviousSkinnedPosition(e) {
    const i = e.object;
    return this.previousBoneMatricesNode === null && (i.skeleton.previousBoneMatrices = new Float32Array(i.skeleton.boneMatrices), this.previousBoneMatricesNode = y2("skeleton.previousBoneMatrices", "mat4", i.skeleton.bones.length)), this.getSkinnedPosition(this.previousBoneMatricesNode, g2);
  }
  needsPreviousBoneMatrices(e) {
    const i = e.renderer.getMRT();
    return i && i.has("velocity");
  }
  setup(e) {
    this.needsPreviousBoneMatrices(e) && g2.assign(this.getPreviousSkinnedPosition(e));
    const i = this.getSkinnedPosition();
    if (sr.assign(i), e.hasGeometryAttribute("normal")) {
      const n = this.getSkinnedNormal();
      _s.assign(n), e.hasGeometryAttribute("tangent") && L1.assign(n);
    }
  }
  generate(e, i) {
    if (i !== "void")
      return sr.build(e, i);
  }
  update(e) {
    const i = (this.useReference ? e.object : this.skinnedMesh).skeleton;
    _2.get(i) !== e.frameId && (_2.set(i, e.frameId), this.previousBoneMatricesNode !== null && i.previousBoneMatrices.set(i.boneMatrices), i.update());
  }
}
const WY = (r) => De(new HY(r, !0));
class qY extends Mt {
  static get type() {
    return "LoopNode";
  }
  constructor(e = []) {
    super(), this.params = e;
  }
  getVarName(e) {
    return String.fromCharCode(105 + e);
  }
  getProperties(e) {
    const i = e.getNodeProperties(this);
    if (i.stackNode !== void 0) return i;
    const n = {};
    for (let a = 0, o = this.params.length - 1; a < o; a++) {
      const l = this.params[a], u = l.isNode !== !0 && l.name || this.getVarName(a), c = l.isNode !== !0 && l.type || "int";
      n[u] = wd(u, c);
    }
    const s = e.addStack();
    return i.returnsNode = this.params[this.params.length - 1](n, s, e), i.stackNode = s, e.removeStack(), i;
  }
  getNodeType(e) {
    const { returnsNode: i } = this.getProperties(e);
    return i ? i.getNodeType(e) : "void";
  }
  setup(e) {
    this.getProperties(e);
  }
  generate(e) {
    const i = this.getProperties(e), n = this.params, s = i.stackNode;
    for (let l = 0, u = n.length - 1; l < u; l++) {
      const c = n[l];
      let h = null, d = null, p = null, f = null, m = null, y = null;
      c.isNode ? (f = "int", p = this.getVarName(l), h = "0", d = c.build(e, f), m = "<") : (f = c.type || "int", p = c.name || this.getVarName(l), h = c.start, d = c.end, m = c.condition, y = c.update, typeof h == "number" ? h = e.generateConst(f, h) : h && h.isNode && (h = h.build(e, f)), typeof d == "number" ? d = e.generateConst(f, d) : d && d.isNode && (d = d.build(e, f)), h !== void 0 && d === void 0 ? (h = h + " - 1", d = "0", m = ">=") : d !== void 0 && h === void 0 && (h = "0", m = "<"), m === void 0 && (Number(h) > Number(d) ? m = ">=" : m = "<"));
      const v = { start: h, end: d }, g = v.start, _ = v.end;
      let x = "", b = "", T = "";
      y || (f === "int" || f === "uint" ? m.includes("<") ? y = "++" : y = "--" : m.includes("<") ? y = "+= 1." : y = "-= 1."), x += e.getVar(f, p) + " = " + g, b += p + " " + m + " " + _, T += p + " " + y;
      const E = `for ( ${x}; ${b}; ${T} )`;
      e.addFlowCode((l === 0 ? `
` : "") + e.tab + E + ` {

`).addFlowTab();
    }
    const a = s.build(e, "void"), o = i.returnsNode ? i.returnsNode.build(e) : "";
    e.removeFlowTab().addFlowCode(`
` + e.tab + a);
    for (let l = 0, u = this.params.length - 1; l < u; l++)
      e.addFlowCode((l === 0 ? "" : e.tab) + `}

`).removeFlowTab();
    return e.addFlowTab(), o;
  }
}
const ps = (...r) => De(new qY($u(r, "int"))).append(), XY = () => wd("break").append(), j0 = /* @__PURE__ */ new WeakMap(), tn = /* @__PURE__ */ new Kt(), T2 = /* @__PURE__ */ Fe(({ bufferMap: r, influence: e, stride: i, width: n, depth: s, offset: a }) => {
  const o = Ei(FY).mul(i).add(a), l = o.div(n), u = o.sub(l.mul(n));
  return Un(r, Ks(u, l)).depth(s).mul(e);
});
function YY(r) {
  const e = r.morphAttributes.position !== void 0, i = r.morphAttributes.normal !== void 0, n = r.morphAttributes.color !== void 0, s = r.morphAttributes.position || r.morphAttributes.normal || r.morphAttributes.color, a = s !== void 0 ? s.length : 0;
  let o = j0.get(r);
  if (o === void 0 || o.count !== a) {
    let l = function() {
      v.dispose(), j0.delete(r), r.removeEventListener("dispose", l);
    };
    o !== void 0 && o.texture.dispose();
    const u = r.morphAttributes.position || [], c = r.morphAttributes.normal || [], h = r.morphAttributes.color || [];
    let d = 0;
    e === !0 && (d = 1), i === !0 && (d = 2), n === !0 && (d = 3);
    let p = r.attributes.position.count * d, f = 1;
    const m = 4096;
    p > m && (f = Math.ceil(p / m), p = m);
    const y = new Float32Array(p * f * 4 * a), v = new k7(y, p, f, a);
    v.type = on, v.needsUpdate = !0;
    const g = d * 4;
    for (let _ = 0; _ < a; _++) {
      const x = u[_], b = c[_], T = h[_], E = p * f * 4 * _;
      for (let M = 0; M < x.count; M++) {
        const C = M * g;
        e === !0 && (tn.fromBufferAttribute(x, M), y[E + C + 0] = tn.x, y[E + C + 1] = tn.y, y[E + C + 2] = tn.z, y[E + C + 3] = 0), i === !0 && (tn.fromBufferAttribute(b, M), y[E + C + 4] = tn.x, y[E + C + 5] = tn.y, y[E + C + 6] = tn.z, y[E + C + 7] = 0), n === !0 && (tn.fromBufferAttribute(T, M), y[E + C + 8] = tn.x, y[E + C + 9] = tn.y, y[E + C + 10] = tn.z, y[E + C + 11] = T.itemSize === 4 ? tn.w : 1);
      }
    }
    o = {
      count: a,
      texture: v,
      stride: d,
      size: new Vt(p, f)
    }, j0.set(r, o), r.addEventListener("dispose", l);
  }
  return o;
}
class KY extends Mt {
  static get type() {
    return "MorphNode";
  }
  constructor(e) {
    super("void"), this.mesh = e, this.morphBaseInfluence = Tt(1), this.updateType = Nt.OBJECT;
  }
  setup(e) {
    const { geometry: i } = e, n = i.morphAttributes.position !== void 0, s = i.hasAttribute("normal") && i.morphAttributes.normal !== void 0, a = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color, o = a !== void 0 ? a.length : 0, { texture: l, stride: u, size: c } = YY(i);
    n === !0 && sr.mulAssign(this.morphBaseInfluence), s === !0 && _s.mulAssign(this.morphBaseInfluence);
    const h = Ei(c.width);
    ps(o, ({ i: d }) => {
      const p = _e(0).toVar();
      this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0 ? p.assign(Un(this.mesh.morphTexture, Ks(Ei(d).add(1), Ei(k1))).r) : p.assign(bi("morphTargetInfluences", "float").element(d).toVar()), n === !0 && sr.addAssign(T2({
        bufferMap: l,
        influence: p,
        stride: u,
        width: h,
        depth: d,
        offset: Ei(0)
      })), s === !0 && _s.addAssign(T2({
        bufferMap: l,
        influence: p,
        stride: u,
        width: h,
        depth: d,
        offset: Ei(1)
      }));
    });
  }
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative ? e.value = 1 : e.value = 1 - this.mesh.morphTargetInfluences.reduce((i, n) => i + n, 0);
  }
}
const ZY = /* @__PURE__ */ Ae(KY);
class Hc extends Mt {
  static get type() {
    return "LightingNode";
  }
  constructor() {
    super("vec3"), this.isLightingNode = !0;
  }
  generate() {
    console.warn("Abstract function.");
  }
}
class QY extends Hc {
  static get type() {
    return "AONode";
  }
  constructor(e = null) {
    super(), this.aoNode = e;
  }
  setup(e) {
    e.context.ambientOcclusion.mulAssign(this.aoNode);
  }
}
class $Y extends cP {
  static get type() {
    return "LightingContextNode";
  }
  constructor(e, i = null, n = null, s = null) {
    super(e), this.lightingModel = i, this.backdropNode = n, this.backdropAlphaNode = s, this._value = null;
  }
  getContext() {
    const { backdropNode: e, backdropAlphaNode: i } = this, n = be().toVar("directDiffuse"), s = be().toVar("directSpecular"), a = be().toVar("indirectDiffuse"), o = be().toVar("indirectSpecular"), l = {
      directDiffuse: n,
      directSpecular: s,
      indirectDiffuse: a,
      indirectSpecular: o
    };
    return {
      radiance: be().toVar("radiance"),
      irradiance: be().toVar("irradiance"),
      iblIrradiance: be().toVar("iblIrradiance"),
      ambientOcclusion: _e(1).toVar("ambientOcclusion"),
      reflectedLight: l,
      backdrop: e,
      backdropAlpha: i
    };
  }
  setup(e) {
    return this.value = this._value || (this._value = this.getContext()), this.value.lightingModel = this.lightingModel || e.context.lightingModel, super.setup(e);
  }
}
const JY = /* @__PURE__ */ Ae($Y);
class eK extends Hc {
  static get type() {
    return "IrradianceNode";
  }
  constructor(e) {
    super(), this.node = e;
  }
  setup(e) {
    e.context.irradiance.addAssign(this.node);
  }
}
let Th, wh;
class ki extends Mt {
  static get type() {
    return "ScreenNode";
  }
  constructor(e) {
    super(), this.scope = e, this.isViewportNode = !0;
  }
  getNodeType() {
    return this.scope === ki.VIEWPORT ? "vec4" : "vec2";
  }
  getUpdateType() {
    let e = Nt.NONE;
    return (this.scope === ki.SIZE || this.scope === ki.VIEWPORT) && (e = Nt.RENDER), this.updateType = e, e;
  }
  update({ renderer: e }) {
    const i = e.getRenderTarget();
    this.scope === ki.VIEWPORT ? i !== null ? wh.copy(i.viewport) : (e.getViewport(wh), wh.multiplyScalar(e.getPixelRatio())) : i !== null ? (Th.width = i.width, Th.height = i.height) : e.getDrawingBufferSize(Th);
  }
  setup() {
    const e = this.scope;
    let i = null;
    return e === ki.SIZE ? i = Tt(Th || (Th = new Vt())) : e === ki.VIEWPORT ? i = Tt(wh || (wh = new Kt())) : i = We(U1.div(Sx)), i;
  }
  generate(e) {
    if (this.scope === ki.COORDINATE) {
      let i = e.getFragCoord();
      if (e.isFlipY()) {
        const n = e.getNodeProperties(Sx).outputNode.build(e);
        i = `${e.getType("vec2")}( ${i}.x, ${n}.y - ${i}.y )`;
      }
      return i;
    }
    return super.generate(e);
  }
}
ki.COORDINATE = "coordinate";
ki.VIEWPORT = "viewport";
ki.SIZE = "size";
ki.UV = "uv";
const Md = /* @__PURE__ */ Ge(ki, ki.UV), Sx = /* @__PURE__ */ Ge(ki, ki.SIZE), U1 = /* @__PURE__ */ Ge(ki, ki.COORDINATE), EP = /* @__PURE__ */ Ge(ki, ki.VIEWPORT);
EP.zw;
EP.xy;
const Sh = /* @__PURE__ */ new Vt();
class MP extends ip {
  static get type() {
    return "ViewportTextureNode";
  }
  constructor(e = Md, i = null, n = null) {
    n === null && (n = new sW(), n.minFilter = da), super(n, e, i), this.generateMipmaps = !1, this.isOutputTextureNode = !0, this.updateBeforeType = Nt.FRAME;
  }
  updateBefore(e) {
    const i = e.renderer;
    i.getDrawingBufferSize(Sh);
    const n = this.value;
    (n.image.width !== Sh.width || n.image.height !== Sh.height) && (n.image.width = Sh.width, n.image.height = Sh.height, n.needsUpdate = !0);
    const s = n.generateMipmaps;
    n.generateMipmaps = this.generateMipmaps, i.copyFramebufferToTexture(n), n.generateMipmaps = s;
  }
  clone() {
    const e = new this.constructor(this.uvNode, this.levelNode, this.value);
    return e.generateMipmaps = this.generateMipmaps, e;
  }
}
const AP = /* @__PURE__ */ Ae(MP, null, null, { generateMipmaps: !0 });
let V0 = null;
class tK extends MP {
  static get type() {
    return "ViewportDepthTextureNode";
  }
  constructor(e = Md, i = null) {
    V0 === null && (V0 = new Vc()), super(e, i, V0);
  }
}
const iK = /* @__PURE__ */ Ae(tK);
class Br extends Mt {
  static get type() {
    return "ViewportDepthNode";
  }
  constructor(e, i = null) {
    super("float"), this.scope = e, this.valueNode = i, this.isViewportDepthNode = !0;
  }
  generate(e) {
    const { scope: i } = this;
    return i === Br.DEPTH_BASE ? e.getFragDepth() : super.generate(e);
  }
  setup({ camera: e }) {
    const { scope: i } = this, n = this.valueNode;
    let s = null;
    if (i === Br.DEPTH_BASE)
      n !== null && (s = NP().assign(n));
    else if (i === Br.DEPTH)
      e.isPerspectiveCamera ? s = rK(rr.z, Ko, Zo) : s = rd(rr.z, Ko, Zo);
    else if (i === Br.LINEAR_DEPTH)
      if (n !== null)
        if (e.isPerspectiveCamera) {
          const a = CP(n, Ko, Zo);
          s = rd(a, Ko, Zo);
        } else
          s = n;
      else
        s = rd(rr.z, Ko, Zo);
    return s;
  }
}
Br.DEPTH_BASE = "depthBase";
Br.DEPTH = "depth";
Br.LINEAR_DEPTH = "linearDepth";
const rd = (r, e, i) => r.add(e).div(e.sub(i)), rK = (r, e, i) => e.add(r).mul(i).div(i.sub(e).mul(r)), CP = (r, e, i) => e.mul(i).div(i.sub(e).mul(r).sub(i)), RP = (r, e, i) => {
  e = e.max(1e-6).toVar();
  const n = ya(r.div(e).add(1)), s = ya(i.div(e).add(1));
  return n.div(s);
}, NP = /* @__PURE__ */ Ae(Br, Br.DEPTH_BASE), PP = /* @__PURE__ */ Ge(Br, Br.DEPTH);
Br.LINEAR_DEPTH;
iK();
PP.assign = (r) => NP(r);
class bo extends Mt {
  static get type() {
    return "ClippingNode";
  }
  constructor(e = bo.DEFAULT) {
    super(), this.scope = e;
  }
  setup(e) {
    super.setup(e);
    const i = e.clippingContext, { localClipIntersection: n, localClippingCount: s, globalClippingCount: a } = i, o = a + s, l = n ? o - s : o;
    return this.scope === bo.ALPHA_TO_COVERAGE ? this.setupAlphaToCoverage(i.planes, o, l) : this.setupDefault(i.planes, o, l);
  }
  setupAlphaToCoverage(e, i, n) {
    return Fe(() => {
      const s = Ed(e), a = Ru("float", "distanceToPlane"), o = Ru("float", "distanceToGradient"), l = Ru("float", "clipOpacity");
      l.assign(1);
      let u;
      if (ps(n, ({ i: c }) => {
        u = s.element(c), a.assign(rr.dot(u.xyz).negate().add(u.w)), o.assign(a.fwidth().div(2)), l.mulAssign(Ml(o.negate(), o, a)), l.equal(0).discard();
      }), n < i) {
        const c = Ru("float", "unionclipOpacity");
        c.assign(1), ps({ start: n, end: i }, ({ i: h }) => {
          u = s.element(h), a.assign(rr.dot(u.xyz).negate().add(u.w)), o.assign(a.fwidth().div(2)), c.mulAssign(Ml(o.negate(), o, a).oneMinus());
        }), l.mulAssign(c.oneMinus());
      }
      qt.a.mulAssign(l), qt.a.equal(0).discard();
    })();
  }
  setupDefault(e, i, n) {
    return Fe(() => {
      const s = Ed(e);
      let a;
      if (ps(n, ({ i: o }) => {
        a = s.element(o), rr.dot(a.xyz).greaterThan(a.w).discard();
      }), n < i) {
        const o = Ru("bool", "clipped");
        o.assign(!0), ps({ start: n, end: i }, ({ i: l }) => {
          a = s.element(l), o.assign(rr.dot(a.xyz).greaterThan(a.w).and(o));
        }), o.discard();
      }
    })();
  }
}
bo.ALPHA_TO_COVERAGE = "alphaToCoverage";
bo.DEFAULT = "default";
const nK = () => De(new bo()), sK = () => De(new bo(bo.ALPHA_TO_COVERAGE)), aK = 0.05, w2 = /* @__PURE__ */ Fe(([r]) => _o(Dt(1e4, Vn(Dt(17, r.x).add(Dt(0.1, r.y)))).mul(Nr(0.1, Gn(Vn(Dt(13, r.y).add(r.x))))))), S2 = /* @__PURE__ */ Fe(([r]) => w2(We(w2(r.xy), r.z))), oK = /* @__PURE__ */ Fe(([r]) => {
  const e = Sn(
    po(rP(r.xyz)),
    po(nP(r.xyz))
  ).toVar("maxDeriv"), i = _e(1).div(_e(aK).mul(e)).toVar("pixScale"), n = We(
    xd(yl(ya(i))),
    xd(A1(ya(i)))
  ).toVar("pixScales"), s = We(
    S2(yl(n.x.mul(r.xyz))),
    S2(yl(n.y.mul(r.xyz)))
  ).toVar("alpha"), a = _o(ya(i)).toVar("lerpFactor"), o = Nr(Dt(a.oneMinus(), s.x), Dt(a, s.y)).toVar("x"), l = Td(a, a.oneMinus()).toVar("a"), u = be(
    o.mul(o).div(Dt(2, l).mul(an(1, l))),
    o.sub(Dt(0.5, l)).div(an(1, l)),
    an(1, an(1, o).mul(an(1, o)).div(Dt(2, l).mul(an(1, l))))
  ).toVar("cases"), c = o.lessThan(l.oneMinus()).select(o.lessThan(l).select(u.x, u.y), u.z);
  return xa(c, 1e-6, 1);
});
class Bi extends Hr {
  static get type() {
    return "NodeMaterial";
  }
  constructor() {
    super(), this.isNodeMaterial = !0, this.type = this.constructor.type, this.forceSinglePass = !1, this.fog = !0, this.lights = !1, this.lightsNode = null, this.envNode = null, this.aoNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.positionNode = null, this.geometryNode = null, this.depthNode = null, this.shadowNode = null, this.shadowPositionNode = null, this.outputNode = null, this.mrtNode = null, this.fragmentNode = null, this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + k3(this);
  }
  build(e) {
    this.setup(e);
  }
  setupObserver(e) {
    return new vW(e);
  }
  setup(e) {
    e.context.setupNormal = () => this.setupNormal(e), e.addStack(), e.stack.outputNode = this.vertexNode || this.setupPosition(e), this.geometryNode !== null && (e.stack.outputNode = e.stack.outputNode.bypass(this.geometryNode)), e.addFlow("vertex", e.removeStack()), e.addStack();
    let i;
    const n = this.setupClipping(e);
    if (this.depthWrite === !0 && this.setupDepth(e), this.fragmentNode === null) {
      this.setupDiffuseColor(e), this.setupVariants(e);
      const s = this.setupLighting(e);
      n !== null && e.stack.add(n);
      const a = _t(s, qt.a).max(0);
      if (i = this.setupOutput(e, a), iq.assign(i), this.outputNode !== null && (i = this.outputNode), e.renderer.getRenderTarget() !== null) {
        const o = e.renderer.getMRT(), l = this.mrtNode;
        o !== null ? (i = o, l !== null && (i = o.merge(l))) : l !== null && (i = l);
      }
    } else {
      let s = this.fragmentNode;
      s.isOutputStructNode !== !0 && (s = _t(s)), i = this.setupOutput(e, s);
    }
    e.stack.outputNode = i, e.addFlow("fragment", e.removeStack()), e.monitor = this.setupObserver(e);
  }
  setupClipping(e) {
    if (e.clippingContext === null) return null;
    const { globalClippingCount: i, localClippingCount: n } = e.clippingContext;
    let s = null;
    if (i || n) {
      const a = e.renderer.samples;
      this.alphaToCoverage && a > 1 ? s = sK() : e.stack.add(nK());
    }
    return s;
  }
  setupDepth(e) {
    const { renderer: i, camera: n } = e;
    let s = this.depthNode;
    if (s === null) {
      const a = i.getMRT();
      a && a.has("depth") ? s = a.get("depth") : i.logarithmicDepthBuffer === !0 && (n.isPerspectiveCamera ? s = RP(wx().w, Ko, Zo) : s = rd(rr.z, Ko, Zo));
    }
    s !== null && PP.assign(s).append();
  }
  setupPosition(e) {
    const { object: i } = e, n = i.geometry;
    if (e.addStack(), (n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color) && ZY(i).append(), i.isSkinnedMesh === !0 && WY(i).append(), this.displacementMap) {
      const a = eo("displacementMap", "texture"), o = eo("displacementScale", "float"), l = eo("displacementBias", "float");
      sr.addAssign(_s.normalize().mul(a.x.mul(o).add(l)));
    }
    i.isBatchedMesh && GY(i).append(), i.instanceMatrix && i.instanceMatrix.isInstancedBufferAttribute === !0 && jY(i).append(), this.positionNode !== null && sr.assign(this.positionNode);
    const s = wx();
    return e.context.vertex = e.removeStack(), e.context.mvp = s, s;
  }
  setupDiffuseColor({ object: e, geometry: i }) {
    let n = this.colorNode ? _t(this.colorNode) : uY;
    this.vertexColors === !0 && i.hasAttribute("color") && (n = _t(n.xyz.mul(_a("color", "vec3")), n.a)), e.instanceColor && (n = Hm("vec3", "vInstanceColor").mul(n)), e.isBatchedMesh && e._colorsTexture && (n = Hm("vec3", "vBatchColor").mul(n)), qt.assign(n);
    const s = this.opacityNode ? _e(this.opacityNode) : wP;
    if (qt.a.assign(qt.a.mul(s)), this.alphaTestNode !== null || this.alphaTest > 0) {
      const a = this.alphaTestNode !== null ? _e(this.alphaTestNode) : lY;
      qt.a.lessThanEqual(a).discard();
    }
    this.alphaHash === !0 && qt.a.lessThan(oK(sr)).discard(), this.transparent === !1 && this.blending === uo && this.alphaToCoverage === !1 && qt.a.assign(1);
  }
  setupVariants() {
  }
  setupOutgoingLight() {
    return this.lights === !0 ? be(0) : qt.rgb;
  }
  setupNormal() {
    return this.normalNode ? be(this.normalNode) : gY;
  }
  setupEnvironment() {
    let e = null;
    return this.envNode ? e = this.envNode : this.envMap && (e = this.envMap.isCubeTexture ? eo("envMap", "cubeTexture") : eo("envMap", "texture")), e;
  }
  setupLightMap(e) {
    let i = null;
    return e.material.lightMap && (i = new eK(SP)), i;
  }
  setupLights(e) {
    const i = [], n = this.setupEnvironment(e);
    n && n.isLightingNode && i.push(n);
    const s = this.setupLightMap(e);
    if (s && s.isLightingNode && i.push(s), this.aoNode !== null || e.material.aoMap) {
      const o = this.aoNode !== null ? this.aoNode : kY;
      i.push(new QY(o));
    }
    let a = this.lightsNode || e.lightsNode;
    return i.length > 0 && (a = e.renderer.lighting.createNode([...a.getLights(), ...i])), a;
  }
  setupLightingModel() {
  }
  setupLighting(e) {
    const { material: i } = e, { backdropNode: n, backdropAlphaNode: s, emissiveNode: a } = this, o = this.lights === !0 || this.lightsNode !== null ? this.setupLights(e) : null;
    let l = this.setupOutgoingLight(e);
    if (o && o.getScope().hasLights) {
      const u = this.setupLightingModel(e);
      l = JY(o, u, n, s);
    } else n !== null && (l = be(s !== null ? li(l, n, s) : n));
    return (a && a.isNode === !0 || i.emissive && i.emissive.isColor === !0) && (d2.assign(be(a || hY)), l = l.add(d2)), l;
  }
  setupOutput(e, i) {
    if (this.fog === !0) {
      const n = e.fogNode;
      n && (i = _t(n.mix(i.rgb, n.colorNode), i.a));
    }
    return i;
  }
  setDefaultValues(e) {
    for (const n in e) {
      const s = e[n];
      this[n] === void 0 && (this[n] = s, s && s.clone && (this[n] = s.clone()));
    }
    const i = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const n in i)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, n) === void 0 && i[n].get !== void 0 && Object.defineProperty(this.constructor.prototype, n, i[n]);
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    i && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    const n = Hr.prototype.toJSON.call(this, e), s = jm(this);
    n.inputNodes = {};
    for (const { property: o, childNode: l } of s)
      n.inputNodes[o] = l.toJSON(e).uuid;
    function a(o) {
      const l = [];
      for (const u in o) {
        const c = o[u];
        delete c.metadata, l.push(c);
      }
      return l;
    }
    if (i) {
      const o = a(e.textures), l = a(e.images), u = a(e.nodes);
      o.length > 0 && (n.textures = o), l.length > 0 && (n.images = l), u.length > 0 && (n.nodes = u);
    }
    return n;
  }
  copy(e) {
    return this.lightsNode = e.lightsNode, this.envNode = e.envNode, this.colorNode = e.colorNode, this.normalNode = e.normalNode, this.opacityNode = e.opacityNode, this.backdropNode = e.backdropNode, this.backdropAlphaNode = e.backdropAlphaNode, this.alphaTestNode = e.alphaTestNode, this.positionNode = e.positionNode, this.geometryNode = e.geometryNode, this.depthNode = e.depthNode, this.shadowNode = e.shadowNode, this.shadowPositionNode = e.shadowPositionNode, this.outputNode = e.outputNode, this.mrtNode = e.mrtNode, this.fragmentNode = e.fragmentNode, this.vertexNode = e.vertexNode, super.copy(e);
  }
}
const lK = /* @__PURE__ */ new f1();
class uK extends Bi {
  static get type() {
    return "LineBasicNodeMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicNodeMaterial = !0, this.lights = !1, this.setDefaultValues(lK), this.setValues(e);
  }
}
const cK = /* @__PURE__ */ new O3();
class hK extends Bi {
  static get type() {
    return "LineDashedNodeMaterial";
  }
  constructor(e) {
    super(), this.isLineDashedNodeMaterial = !0, this.lights = !1, this.setDefaultValues(cK), this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setValues(e);
  }
  setupVariants() {
    const e = this.offsetNode, i = this.dashScaleNode ? _e(this.dashScaleNode) : IY, n = this.dashSizeNode ? _e(this.dashSizeNode) : OY, s = this.dashSizeNode ? _e(this.dashGapNode) : DY;
    B0.assign(n), p2.assign(s);
    const a = Ea(_a("lineDistance").mul(i));
    (e ? a.add(e) : a).mod(B0.add(p2)).greaterThan(B0).discard();
  }
}
const dK = (r) => De(r).mul(0.5).add(0.5), pK = /* @__PURE__ */ new N3();
class fK extends Bi {
  static get type() {
    return "MeshNormalNodeMaterial";
  }
  constructor(e) {
    super(), this.lights = !1, this.isMeshNormalNodeMaterial = !0, this.setDefaultValues(pK), this.setValues(e);
  }
  setupDiffuseColor() {
    const e = this.opacityNode ? _e(this.opacityNode) : wP;
    qt.assign(_t(dK(Ui), e));
  }
}
class mK extends zi {
  static get type() {
    return "EquirectUVNode";
  }
  constructor(e = gP) {
    super("vec2"), this.dirNode = e;
  }
  setup() {
    const e = this.dirNode, i = e.z.atan2(e.x).mul(1 / (Math.PI * 2)).add(0.5), n = e.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return We(i, n);
  }
}
const IP = /* @__PURE__ */ Ae(mK);
class OP extends eW {
  constructor(e = 1, i = {}) {
    super(e, i), this.isCubeRenderTarget = !0;
  }
  fromEquirectangularTexture(e, i) {
    const n = i.minFilter, s = i.generateMipmaps;
    i.generateMipmaps = !0, this.texture.type = i.type, this.texture.colorSpace = i.colorSpace, this.texture.generateMipmaps = i.generateMipmaps, this.texture.minFilter = i.minFilter, this.texture.magFilter = i.magFilter;
    const a = new $d(5, 5, 5), o = IP(gP), l = new Bi();
    l.colorNode = Ai(i, o, 0), l.side = Qn, l.blending = xc;
    const u = new El(a, l), c = new _3();
    c.add(u), i.minFilter === da && (i.minFilter = ln);
    const h = new x3(1, 10, this), d = e.getMRT();
    return e.setMRT(null), h.update(e, c), e.setMRT(d), i.minFilter = n, i.currentGenerateMipmaps = s, u.geometry.dispose(), u.material.dispose(), this;
  }
}
const nd = /* @__PURE__ */ new WeakMap();
class gK extends zi {
  static get type() {
    return "CubeMapNode";
  }
  constructor(e) {
    super("vec3"), this.envNode = e, this._cubeTexture = null, this._cubeTextureNode = Sd();
    const i = new d1();
    i.isRenderTargetTexture = !0, this._defaultTexture = i, this.updateBeforeType = Nt.RENDER;
  }
  updateBefore(e) {
    const { renderer: i, material: n } = e, s = this.envNode;
    if (s.isTextureNode || s.isMaterialReferenceNode) {
      const a = s.isTextureNode ? s.value : n[s.property];
      if (a && a.isTexture) {
        const o = a.mapping;
        if (o === Xd || o === Yd) {
          if (nd.has(a)) {
            const l = nd.get(a);
            E2(l, a.mapping), this._cubeTexture = l;
          } else {
            const l = a.image;
            if (yK(l)) {
              const u = new OP(l.height);
              u.fromEquirectangularTexture(i, a), E2(u.texture, a.mapping), this._cubeTexture = u.texture, nd.set(a, u.texture), a.addEventListener("dispose", DP);
            } else
              this._cubeTexture = this._defaultTexture;
          }
          this._cubeTextureNode.value = this._cubeTexture;
        } else
          this._cubeTextureNode = this.envNode;
      }
    }
  }
  setup(e) {
    return this.updateBefore(e), this._cubeTextureNode;
  }
}
function yK(r) {
  return r == null ? !1 : r.height > 0;
}
function DP(r) {
  const e = r.target;
  e.removeEventListener("dispose", DP);
  const i = nd.get(e);
  i !== void 0 && (nd.delete(e), i.dispose());
}
function E2(r, e) {
  e === Xd ? r.mapping = Tl : e === Yd && (r.mapping = _c);
}
const LP = /* @__PURE__ */ Ae(gK);
class F1 extends Hc {
  static get type() {
    return "BasicEnvironmentNode";
  }
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    e.context.environment = LP(this.envNode);
  }
}
class vK extends Hc {
  static get type() {
    return "BasicLightMapNode";
  }
  constructor(e = null) {
    super(), this.lightMapNode = e;
  }
  setup(e) {
    const i = _e(1 / Math.PI);
    e.context.irradianceLightMap = this.lightMapNode.mul(i);
  }
}
class zg {
  start() {
  }
  finish() {
  }
  direct() {
  }
  directRectArea() {
  }
  indirect() {
  }
  ambientOcclusion() {
  }
}
class kP extends zg {
  constructor() {
    super();
  }
  indirect(e, i, n) {
    const s = e.ambientOcclusion, a = e.reflectedLight, o = n.context.irradianceLightMap;
    a.indirectDiffuse.assign(_t(0)), o ? a.indirectDiffuse.addAssign(o) : a.indirectDiffuse.addAssign(_t(1, 1, 1, 0)), a.indirectDiffuse.mulAssign(s), a.indirectDiffuse.mulAssign(qt.rgb);
  }
  finish(e, i, n) {
    const s = n.material, a = e.outgoingLight, o = n.context.environment;
    if (o)
      switch (s.combine) {
        case Ng:
          a.rgb.assign(li(a.rgb, a.rgb.mul(o.rgb), lm.mul(z0)));
          break;
        case kH:
          a.rgb.assign(li(a.rgb, o.rgb, lm.mul(z0)));
          break;
        case UH:
          a.rgb.addAssign(o.rgb.mul(lm.mul(z0)));
          break;
        default:
          console.warn("THREE.BasicLightingModel: Unsupported .combine value:", s.combine);
          break;
      }
  }
}
const bK = /* @__PURE__ */ new Pg();
class xK extends Bi {
  static get type() {
    return "MeshBasicNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicNodeMaterial = !0, this.lights = !0, this.setDefaultValues(bK), this.setValues(e);
  }
  setupNormal() {
    return Jn;
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new F1(i) : null;
  }
  setupLightMap(e) {
    let i = null;
    return e.material.lightMap && (i = new vK(SP)), i;
  }
  setupOutgoingLight() {
    return qt.rgb;
  }
  setupLightingModel() {
    return new kP();
  }
}
const Ad = /* @__PURE__ */ Fe(({ f0: r, f90: e, dotVH: i }) => {
  const n = i.mul(-5.55473).sub(6.98316).mul(i).exp2();
  return r.mul(n.oneMinus()).add(e.mul(n));
}), Ec = /* @__PURE__ */ Fe((r) => r.diffuseColor.mul(1 / Math.PI)), _K = () => _e(0.25), TK = /* @__PURE__ */ Fe(({ dotNH: r }) => xx.mul(_e(0.5)).add(1).mul(_e(1 / Math.PI)).mul(r.pow(xx))), wK = /* @__PURE__ */ Fe(({ lightDirection: r }) => {
  const e = r.add(vi).normalize(), i = Ui.dot(e).clamp(), n = vi.dot(e).clamp(), s = Ad({ f0: nn, f90: 1, dotVH: n }), a = _K(), o = TK({ dotNH: i });
  return s.mul(a).mul(o);
});
class UP extends kP {
  constructor(e = !0) {
    super(), this.specular = e;
  }
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }) {
    const s = Ui.dot(e).clamp().mul(i);
    n.directDiffuse.addAssign(s.mul(Ec({ diffuseColor: qt.rgb }))), this.specular === !0 && n.directSpecular.addAssign(s.mul(wK({ lightDirection: e })).mul(lm));
  }
  indirect({ ambientOcclusion: e, irradiance: i, reflectedLight: n }) {
    n.indirectDiffuse.addAssign(i.mul(Ec({ diffuseColor: qt }))), n.indirectDiffuse.mulAssign(e);
  }
}
const SK = /* @__PURE__ */ new P3();
class EK extends Bi {
  static get type() {
    return "MeshLambertNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshLambertNodeMaterial = !0, this.lights = !0, this.setDefaultValues(SK), this.setValues(e);
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new F1(i) : null;
  }
  setupLightingModel() {
    return new UP(!1);
  }
}
const MK = /* @__PURE__ */ new C3();
class AK extends Bi {
  static get type() {
    return "MeshPhongNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhongNodeMaterial = !0, this.lights = !0, this.shininessNode = null, this.specularNode = null, this.setDefaultValues(MK), this.setValues(e);
  }
  setupEnvironment(e) {
    const i = super.setupEnvironment(e);
    return i ? new F1(i) : null;
  }
  setupLightingModel() {
    return new UP();
  }
  setupVariants() {
    const e = (this.shininessNode ? _e(this.shininessNode) : cY).max(1e-4);
    xx.assign(e);
    const i = this.specularNode || dY;
    nn.assign(i);
  }
  copy(e) {
    return this.shininessNode = e.shininessNode, this.specularNode = e.specularNode, super.copy(e);
  }
}
const CK = /* @__PURE__ */ Fe((r) => {
  if (r.geometry.hasAttribute("normal") === !1)
    return _e(0);
  const e = Jn.dFdx().abs().max(Jn.dFdy().abs());
  return e.x.max(e.y).max(e.z);
}), FP = /* @__PURE__ */ Fe((r) => {
  const { roughness: e } = r, i = CK();
  let n = e.max(0.0525);
  return n = n.add(i), n = n.min(1), n;
}), RK = /* @__PURE__ */ Fe(({ alpha: r, dotNL: e, dotNV: i }) => {
  const n = r.pow2(), s = e.mul(n.add(n.oneMinus().mul(i.pow2())).sqrt()), a = i.mul(n.add(n.oneMinus().mul(e.pow2())).sqrt());
  return vo(0.5, s.add(a).max(Sq));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
}), NK = /* @__PURE__ */ Fe(({ alphaT: r, alphaB: e, dotTV: i, dotBV: n, dotTL: s, dotBL: a, dotNV: o, dotNL: l }) => {
  const u = l.mul(be(r.mul(i), e.mul(n), o).length()), c = o.mul(be(r.mul(s), e.mul(a), l).length());
  return vo(0.5, u.add(c)).saturate();
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
}), PK = /* @__PURE__ */ Fe(({ alpha: r, dotNH: e }) => {
  const i = r.pow2(), n = e.pow2().mul(i.oneMinus()).oneMinus();
  return i.div(n.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), IK = /* @__PURE__ */ _e(1 / Math.PI), OK = /* @__PURE__ */ Fe(({ alphaT: r, alphaB: e, dotNH: i, dotTH: n, dotBH: s }) => {
  const a = r.mul(e), o = be(e.mul(n), r.mul(s), a.mul(i)), l = o.dot(o), u = a.div(l);
  return IK.mul(a.mul(u.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
}), M2 = /* @__PURE__ */ Fe((r) => {
  const { lightDirection: e, f0: i, f90: n, roughness: s, f: a, USE_IRIDESCENCE: o, USE_ANISOTROPY: l } = r, u = r.normalView || Ui, c = s.pow2(), h = e.add(vi).normalize(), d = u.dot(e).clamp(), p = u.dot(vi).clamp(), f = u.dot(h).clamp(), m = vi.dot(h).clamp();
  let y = Ad({ f0: i, f90: n, dotVH: m }), v, g;
  if (h2(o) && (y = E1.mix(y, a)), h2(l)) {
    const _ = sm.dot(e), x = sm.dot(vi), b = sm.dot(h), T = ec.dot(e), E = ec.dot(vi), M = ec.dot(h);
    v = NK({ alphaT: bx, alphaB: c, dotTV: x, dotBV: E, dotTL: _, dotBL: T, dotNV: p, dotNL: d }), g = OK({ alphaT: bx, alphaB: c, dotNH: f, dotTH: b, dotBH: M });
  } else
    v = RK({ alpha: c, dotNL: d, dotNV: p }), g = PK({ alpha: c, dotNH: f });
  return y.mul(v).mul(g);
}), BP = /* @__PURE__ */ Fe(({ roughness: r, dotNV: e }) => {
  const i = _t(-1, -0.0275, -0.572, 0.022), n = _t(1, 0.0425, 1.04, -0.04), s = r.mul(i).add(n), a = s.x.mul(s.x).min(e.mul(-9.28).exp2()).mul(s.x).add(s.y);
  return We(-1.04, 1.04).mul(a).add(s.zw);
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
}), zP = /* @__PURE__ */ Fe((r) => {
  const { dotNV: e, specularColor: i, specularF90: n, roughness: s } = r, a = BP({ dotNV: e, roughness: s });
  return i.mul(a.x).add(n.mul(a.y));
}), DK = /* @__PURE__ */ Fe(({ f: r, f90: e, dotVH: i }) => {
  const n = i.oneMinus().saturate(), s = n.mul(n), a = n.mul(s, s).clamp(0, 0.9999);
  return r.sub(be(e).mul(a)).div(a.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
}), LK = /* @__PURE__ */ Fe(({ roughness: r, dotNH: e }) => {
  const i = r.pow2(), n = _e(1).div(i), s = e.pow2().oneMinus().max(78125e-7);
  return _e(2).add(n).mul(s.pow(n.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), kK = /* @__PURE__ */ Fe(({ dotNV: r, dotNL: e }) => _e(1).div(_e(4).mul(e.add(r).sub(e.mul(r))))).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
}), UK = /* @__PURE__ */ Fe(({ lightDirection: r }) => {
  const e = r.add(vi).normalize(), i = Ui.dot(r).clamp(), n = Ui.dot(vi).clamp(), s = Ui.dot(e).clamp(), a = LK({ roughness: S1, dotNH: s }), o = kK({ dotNV: n, dotNL: i });
  return Fu.mul(a).mul(o);
}), FK = /* @__PURE__ */ Fe(({ N: r, V: e, roughness: i }) => {
  const n = 78125e-7, s = r.dot(e).saturate(), a = We(i, s.oneMinus().sqrt());
  return a.assign(a.mul(0.984375).add(n)), a;
}).setLayout({
  name: "LTC_Uv",
  type: "vec2",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "roughness", type: "float" }
  ]
}), BK = /* @__PURE__ */ Fe(({ f: r }) => {
  const e = r.length();
  return Sn(e.mul(e).add(r.z).div(e.add(1)), 0);
}).setLayout({
  name: "LTC_ClippedSphereFormFactor",
  type: "float",
  inputs: [
    { name: "f", type: "vec3" }
  ]
}), pf = /* @__PURE__ */ Fe(({ v1: r, v2: e }) => {
  const i = r.dot(e), n = i.abs().toVar(), s = n.mul(0.0145206).add(0.4965155).mul(n).add(0.8543985).toVar(), a = n.add(4.1616724).mul(n).add(3.417594).toVar(), o = s.div(a), l = i.greaterThan(0).select(o, Sn(i.mul(i).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(o));
  return r.cross(e).mul(l);
}).setLayout({
  name: "LTC_EdgeVectorFormFactor",
  type: "vec3",
  inputs: [
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" }
  ]
}), A2 = /* @__PURE__ */ Fe(({ N: r, V: e, P: i, mInv: n, p0: s, p1: a, p2: o, p3: l }) => {
  const u = a.sub(s).toVar(), c = l.sub(s).toVar(), h = u.cross(c), d = be().toVar();
  return nr(h.dot(i.sub(s)).greaterThanEqual(0), () => {
    const p = e.sub(r.mul(e.dot(r))).normalize(), f = r.cross(p).negate(), m = n.mul(Rr(p, f, r).transpose()).toVar(), y = m.mul(s.sub(i)).normalize().toVar(), v = m.mul(a.sub(i)).normalize().toVar(), g = m.mul(o.sub(i)).normalize().toVar(), _ = m.mul(l.sub(i)).normalize().toVar(), x = be(0).toVar();
    x.addAssign(pf({ v1: y, v2: v })), x.addAssign(pf({ v1: v, v2: g })), x.addAssign(pf({ v1: g, v2: _ })), x.addAssign(pf({ v1: _, v2: y })), d.assign(be(BK({ f: x })));
  }), d;
}).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "P", type: "vec3" },
    { name: "mInv", type: "mat3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" }
  ]
}), jg = 1 / 6, jP = (r) => Dt(jg, Dt(r, Dt(r, r.negate().add(3)).sub(3)).add(1)), Ex = (r) => Dt(jg, Dt(r, Dt(r, Dt(3, r).sub(6))).add(4)), VP = (r) => Dt(jg, Dt(r, Dt(r, Dt(-3, r).add(3)).add(3)).add(1)), Mx = (r) => Dt(jg, Lg(r, 3)), C2 = (r) => jP(r).add(Ex(r)), R2 = (r) => VP(r).add(Mx(r)), N2 = (r) => Nr(-1, Ex(r).div(jP(r).add(Ex(r)))), P2 = (r) => Nr(1, Mx(r).div(VP(r).add(Mx(r)))), I2 = (r, e, i) => {
  const n = r.uvNode, s = Dt(n, e.zw).add(0.5), a = yl(s), o = _o(s), l = C2(o.x), u = R2(o.x), c = N2(o.x), h = P2(o.x), d = N2(o.y), p = P2(o.y), f = We(a.x.add(c), a.y.add(d)).sub(0.5).mul(e.xy), m = We(a.x.add(h), a.y.add(d)).sub(0.5).mul(e.xy), y = We(a.x.add(c), a.y.add(p)).sub(0.5).mul(e.xy), v = We(a.x.add(h), a.y.add(p)).sub(0.5).mul(e.xy), g = C2(o.y).mul(Nr(l.mul(r.uv(f).level(i)), u.mul(r.uv(m).level(i)))), _ = R2(o.y).mul(Nr(l.mul(r.uv(y).level(i)), u.mul(r.uv(v).level(i))));
  return g.add(_);
}, zK = /* @__PURE__ */ Fe(([r, e = _e(3)]) => {
  const i = We(r.size(Ei(e))), n = We(r.size(Ei(e.add(1)))), s = vo(1, i), a = vo(1, n), o = I2(r, _t(s, i), yl(e)), l = I2(r, _t(a, n), A1(e));
  return _o(e).mix(o, l);
}), O2 = /* @__PURE__ */ Fe(([r, e, i, n, s]) => {
  const a = be(uP(e.negate(), _d(r), vo(1, n))), o = be(
    po(s[0].xyz),
    po(s[1].xyz),
    po(s[2].xyz)
  );
  return _d(a).mul(i.mul(o));
}).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" }
  ]
}), jK = /* @__PURE__ */ Fe(([r, e]) => r.mul(xa(e.mul(2).sub(2), 0, 1))).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" }
  ]
}), VK = /* @__PURE__ */ AP(), GK = /* @__PURE__ */ AP(), D2 = /* @__PURE__ */ Fe(([r, e, i], { material: n }) => {
  const s = (n.side == Qn ? VK : GK).uv(r), a = ya(Sx.x).mul(jK(e, i));
  return zK(s, a);
}), L2 = /* @__PURE__ */ Fe(([r, e, i]) => (nr(i.notEqual(0), () => {
  const n = tP(e).negate().div(i);
  return eP(n.negate().mul(r));
}), be(1))).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" }
  ]
}), HK = /* @__PURE__ */ Fe(([r, e, i, n, s, a, o, l, u, c, h, d, p, f, m]) => {
  let y, v;
  if (m) {
    y = _t().toVar(), v = be().toVar();
    const T = h.sub(1).mul(m.mul(0.025)), E = be(h.sub(T), h, h.add(T));
    ps({ start: 0, end: 3 }, ({ i: M }) => {
      const C = E.element(M), S = O2(r, e, d, C, l), w = o.add(S), R = c.mul(u.mul(_t(w, 1))), O = We(R.xy.div(R.w)).toVar();
      O.addAssign(1), O.divAssign(2), O.assign(We(O.x, O.y.oneMinus()));
      const P = D2(O, i, C);
      y.element(M).assign(P.element(M)), y.a.addAssign(P.a), v.element(M).assign(n.element(M).mul(L2(po(S), p, f).element(M)));
    }), y.a.divAssign(3);
  } else {
    const T = O2(r, e, d, h, l), E = o.add(T), M = c.mul(u.mul(_t(E, 1))), C = We(M.xy.div(M.w)).toVar();
    C.addAssign(1), C.divAssign(2), C.assign(We(C.x, C.y.oneMinus())), y = D2(C, i, h), v = n.mul(L2(po(T), p, f));
  }
  const g = v.rgb.mul(y.rgb), _ = r.dot(e).clamp(), x = be(zP({
    // n, v, specularColor, specularF90, roughness
    dotNV: _,
    specularColor: s,
    specularF90: a,
    roughness: i
  })), b = v.r.add(v.g, v.b).div(3);
  return _t(x.oneMinus().mul(g), y.a.oneMinus().mul(b).oneMinus());
}), WK = /* @__PURE__ */ Rr(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
), qK = (r) => {
  const e = r.sqrt();
  return be(1).add(e).div(be(1).sub(e));
}, k2 = (r, e) => r.sub(e).div(r.add(e)).pow2(), XK = (r, e) => {
  const i = r.mul(2 * Math.PI * 1e-9), n = be(54856e-17, 44201e-17, 52481e-17), s = be(1681e3, 1795300, 2208400), a = be(43278e5, 93046e5, 66121e5), o = _e(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(i.mul(2239900).add(e.x).cos()).mul(i.pow2().mul(-45282e5).exp());
  let l = n.mul(a.mul(2 * Math.PI).sqrt()).mul(s.mul(i).add(e).cos()).mul(i.pow2().negate().mul(a).exp());
  return l = be(l.x.add(o), l.y, l.z).div(10685e-11), WK.mul(l);
}, YK = /* @__PURE__ */ Fe(({ outsideIOR: r, eta2: e, cosTheta1: i, thinFilmThickness: n, baseF0: s }) => {
  const a = li(r, e, Ml(0, 0.03, n)), o = r.div(a).pow2().mul(i.pow2().oneMinus()).oneMinus();
  nr(o.lessThan(0), () => be(1));
  const l = o.sqrt(), u = k2(a, r), c = Ad({ f0: u, f90: 1, dotVH: i }), h = c.oneMinus(), d = a.lessThan(r).select(Math.PI, 0), p = _e(Math.PI).sub(d), f = qK(s.clamp(0, 0.9999)), m = k2(f, a.toVec3()), y = Ad({ f0: m, f90: 1, dotVH: l }), v = be(
    f.x.lessThan(a).select(Math.PI, 0),
    f.y.lessThan(a).select(Math.PI, 0),
    f.z.lessThan(a).select(Math.PI, 0)
  ), g = a.mul(n, l, 2), _ = be(p).add(v), x = c.mul(y).clamp(1e-5, 0.9999), b = x.sqrt(), T = h.pow2().mul(y).div(be(1).sub(x)), E = c.add(T).toVar(), M = T.sub(h).toVar();
  return ps({ start: 1, end: 2, condition: "<=", name: "m" }, ({ m: C }) => {
    M.mulAssign(b);
    const S = XK(_e(C).mul(g), _e(C).mul(_)).mul(2);
    E.addAssign(M.mul(S));
  }), E.max(be(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
}), KK = /* @__PURE__ */ Fe(({ normal: r, viewDir: e, roughness: i }) => {
  const n = r.dot(e).saturate(), s = i.pow2(), a = Fr(
    i.lessThan(0.25),
    _e(-339.2).mul(s).add(_e(161.4).mul(i)).sub(25.9),
    _e(-8.48).mul(s).add(_e(14.3).mul(i)).sub(9.95)
  ), o = Fr(
    i.lessThan(0.25),
    _e(44).mul(s).sub(_e(23.7).mul(i)).add(3.26),
    _e(1.97).mul(s).sub(_e(3.27).mul(i)).add(0.72)
  );
  return Fr(i.lessThan(0.25), 0, _e(0.1).mul(i).sub(0.025)).add(a.mul(n).add(o).exp()).mul(1 / Math.PI).saturate();
}), G0 = be(0.04), H0 = _e(1);
class GP extends zg {
  constructor(e = !1, i = !1, n = !1, s = !1, a = !1, o = !1) {
    super(), this.clearcoat = e, this.sheen = i, this.iridescence = n, this.anisotropy = s, this.transmission = a, this.dispersion = o, this.clearcoatRadiance = null, this.clearcoatSpecularDirect = null, this.clearcoatSpecularIndirect = null, this.sheenSpecularDirect = null, this.sheenSpecularIndirect = null, this.iridescenceFresnel = null, this.iridescenceF0 = null;
  }
  start(e) {
    if (this.clearcoat === !0 && (this.clearcoatRadiance = be().toVar("clearcoatRadiance"), this.clearcoatSpecularDirect = be().toVar("clearcoatSpecularDirect"), this.clearcoatSpecularIndirect = be().toVar("clearcoatSpecularIndirect")), this.sheen === !0 && (this.sheenSpecularDirect = be().toVar("sheenSpecularDirect"), this.sheenSpecularIndirect = be().toVar("sheenSpecularIndirect")), this.iridescence === !0) {
      const i = Ui.dot(vi).clamp();
      this.iridescenceFresnel = YK({
        outsideIOR: _e(1),
        eta2: q3,
        cosTheta1: i,
        thinFilmThickness: X3,
        baseF0: nn
      }), this.iridescenceF0 = DK({ f: this.iridescenceFresnel, f90: 1, dotVH: i });
    }
    if (this.transmission === !0) {
      const i = Tx, n = UX.sub(Tx).normalize(), s = I1;
      e.backdrop = HK(
        s,
        n,
        ta,
        qt,
        nn,
        Xm,
        // specularF90
        i,
        // positionWorld
        Al,
        // modelMatrix
        Ma,
        // viewMatrix
        Ym,
        // projMatrix
        am,
        Y3,
        Z3,
        K3,
        this.dispersion ? Q3 : null
      ), e.backdropAlpha = _x, qt.a.mulAssign(li(1, e.backdrop.a, _x));
    }
  }
  // Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(e, i, n) {
    const s = Ui.dot(vi).clamp(), a = BP({ roughness: ta, dotNV: s }), o = (this.iridescenceF0 ? E1.mix(nn, this.iridescenceF0) : nn).mul(a.x).add(n.mul(a.y)), l = a.x.add(a.y).oneMinus(), u = nn.add(nn.oneMinus().mul(0.047619)), c = o.mul(u).div(l.mul(u).oneMinus());
    e.addAssign(o), i.addAssign(c.mul(l));
  }
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }) {
    const s = Ui.dot(e).clamp().mul(i);
    if (this.sheen === !0 && this.sheenSpecularDirect.addAssign(s.mul(UK({ lightDirection: e }))), this.clearcoat === !0) {
      const a = Vh.dot(e).clamp().mul(i);
      this.clearcoatSpecularDirect.addAssign(a.mul(M2({ lightDirection: e, f0: G0, f90: H0, roughness: qm, normalView: Vh })));
    }
    n.directDiffuse.addAssign(s.mul(Ec({ diffuseColor: qt.rgb }))), n.directSpecular.addAssign(s.mul(M2({ lightDirection: e, f0: nn, f90: 1, roughness: ta, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy })));
  }
  directRectArea({ lightColor: e, lightPosition: i, halfWidth: n, halfHeight: s, reflectedLight: a, ltc_1: o, ltc_2: l }) {
    const u = i.add(n).sub(s), c = i.sub(n).sub(s), h = i.sub(n).add(s), d = i.add(n).add(s), p = Ui, f = vi, m = rr.toVar(), y = FK({ N: p, V: f, roughness: ta }), v = o.uv(y).toVar(), g = l.uv(y).toVar(), _ = Rr(
      be(v.x, 0, v.y),
      be(0, 1, 0),
      be(v.z, 0, v.w)
    ).toVar(), x = nn.mul(g.x).add(nn.oneMinus().mul(g.y)).toVar();
    a.directSpecular.addAssign(e.mul(x).mul(A2({ N: p, V: f, P: m, mInv: _, p0: u, p1: c, p2: h, p3: d }))), a.directDiffuse.addAssign(e.mul(qt).mul(A2({ N: p, V: f, P: m, mInv: Rr(1, 0, 0, 0, 1, 0, 0, 0, 1), p0: u, p1: c, p2: h, p3: d })));
  }
  indirect(e, i, n) {
    this.indirectDiffuse(e, i, n), this.indirectSpecular(e, i, n), this.ambientOcclusion(e, i, n);
  }
  indirectDiffuse({ irradiance: e, reflectedLight: i }) {
    i.indirectDiffuse.addAssign(e.mul(Ec({ diffuseColor: qt })));
  }
  indirectSpecular({ radiance: e, iblIrradiance: i, reflectedLight: n }) {
    if (this.sheen === !0 && this.sheenSpecularIndirect.addAssign(i.mul(
      Fu,
      KK({
        normal: Ui,
        viewDir: vi,
        roughness: S1
      })
    )), this.clearcoat === !0) {
      const c = Vh.dot(vi).clamp(), h = zP({
        dotNV: c,
        specularColor: G0,
        specularF90: H0,
        roughness: qm
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(h));
    }
    const s = be().toVar("singleScattering"), a = be().toVar("multiScattering"), o = i.mul(1 / Math.PI);
    this.computeMultiscattering(s, a, Xm);
    const l = s.add(a), u = qt.mul(l.r.max(l.g).max(l.b).oneMinus());
    n.indirectSpecular.addAssign(e.mul(s)), n.indirectSpecular.addAssign(a.mul(o)), n.indirectDiffuse.addAssign(u.mul(o));
  }
  ambientOcclusion({ ambientOcclusion: e, reflectedLight: i }) {
    const n = Ui.dot(vi).clamp().add(e), s = ta.mul(-16).oneMinus().negate().exp2(), a = e.sub(n.pow(s).oneMinus()).clamp();
    this.clearcoat === !0 && this.clearcoatSpecularIndirect.mulAssign(e), this.sheen === !0 && this.sheenSpecularIndirect.mulAssign(e), i.indirectDiffuse.mulAssign(e), i.indirectSpecular.mulAssign(a);
  }
  finish(e) {
    const { outgoingLight: i } = e;
    if (this.clearcoat === !0) {
      const n = Vh.dot(vi).clamp(), s = Ad({
        dotVH: n,
        f0: G0,
        f90: H0
      }), a = i.mul(vx.mul(s).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(vx));
      i.assign(a);
    }
    if (this.sheen === !0) {
      const n = Fu.r.max(Fu.g).max(Fu.b).mul(0.157).oneMinus(), s = i.mul(n).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      i.assign(s);
    }
  }
}
const U2 = /* @__PURE__ */ _e(1), Ax = /* @__PURE__ */ _e(-2), ff = /* @__PURE__ */ _e(0.8), W0 = /* @__PURE__ */ _e(-1), mf = /* @__PURE__ */ _e(0.4), q0 = /* @__PURE__ */ _e(2), gf = /* @__PURE__ */ _e(0.305), X0 = /* @__PURE__ */ _e(3), F2 = /* @__PURE__ */ _e(0.21), ZK = /* @__PURE__ */ _e(4), B2 = /* @__PURE__ */ _e(4), QK = /* @__PURE__ */ _e(16), $K = /* @__PURE__ */ Fe(([r]) => {
  const e = be(Gn(r)).toVar(), i = _e(-1).toVar();
  return nr(e.x.greaterThan(e.z), () => {
    nr(e.x.greaterThan(e.y), () => {
      i.assign(Fr(r.x.greaterThan(0), 0, 3));
    }).Else(() => {
      i.assign(Fr(r.y.greaterThan(0), 1, 4));
    });
  }).Else(() => {
    nr(e.z.greaterThan(e.y), () => {
      i.assign(Fr(r.z.greaterThan(0), 2, 5));
    }).Else(() => {
      i.assign(Fr(r.y.greaterThan(0), 1, 4));
    });
  }), i;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
}), JK = /* @__PURE__ */ Fe(([r, e]) => {
  const i = We().toVar();
  return nr(e.equal(0), () => {
    i.assign(We(r.z, r.y).div(Gn(r.x)));
  }).ElseIf(e.equal(1), () => {
    i.assign(We(r.x.negate(), r.z.negate()).div(Gn(r.y)));
  }).ElseIf(e.equal(2), () => {
    i.assign(We(r.x.negate(), r.y).div(Gn(r.z)));
  }).ElseIf(e.equal(3), () => {
    i.assign(We(r.z.negate(), r.y).div(Gn(r.x)));
  }).ElseIf(e.equal(4), () => {
    i.assign(We(r.x.negate(), r.z).div(Gn(r.y)));
  }).Else(() => {
    i.assign(We(r.x, r.y).div(Gn(r.z)));
  }), Dt(0.5, i.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
}), eZ = /* @__PURE__ */ Fe(([r]) => {
  const e = _e(0).toVar();
  return nr(r.greaterThanEqual(ff), () => {
    e.assign(U2.sub(r).mul(W0.sub(Ax)).div(U2.sub(ff)).add(Ax));
  }).ElseIf(r.greaterThanEqual(mf), () => {
    e.assign(ff.sub(r).mul(q0.sub(W0)).div(ff.sub(mf)).add(W0));
  }).ElseIf(r.greaterThanEqual(gf), () => {
    e.assign(mf.sub(r).mul(X0.sub(q0)).div(mf.sub(gf)).add(q0));
  }).ElseIf(r.greaterThanEqual(F2), () => {
    e.assign(gf.sub(r).mul(ZK.sub(X0)).div(gf.sub(F2)).add(X0));
  }).Else(() => {
    e.assign(_e(-2).mul(ya(Dt(1.16, r))));
  }), e;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
}), tZ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = r.toVar();
  i.assign(Dt(2, i).sub(1));
  const n = be(i, 1).toVar();
  return nr(e.equal(0), () => {
    n.assign(n.zyx);
  }).ElseIf(e.equal(1), () => {
    n.assign(n.xzy), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(2), () => {
    n.x.mulAssign(-1);
  }).ElseIf(e.equal(3), () => {
    n.assign(n.zyx), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(4), () => {
    n.assign(n.xzy), n.xy.mulAssign(-1);
  }).ElseIf(e.equal(5), () => {
    n.z.mulAssign(-1);
  }), n;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
}), iZ = /* @__PURE__ */ Fe(([r, e, i, n, s, a]) => {
  const o = _e(i), l = be(e), u = xa(eZ(o), Ax, a), c = _o(u), h = yl(u), d = be(Cx(r, l, h, n, s, a)).toVar();
  return nr(c.notEqual(0), () => {
    const p = be(Cx(r, l, h.add(1), n, s, a)).toVar();
    d.assign(li(d, p, c));
  }), d;
}), Cx = /* @__PURE__ */ Fe(([r, e, i, n, s, a]) => {
  const o = _e(i).toVar(), l = be(e), u = _e($K(l)).toVar(), c = _e(Sn(B2.sub(o), 0)).toVar();
  o.assign(Sn(o, B2));
  const h = _e(xd(o)).toVar(), d = We(JK(l, u).mul(h.sub(2)).add(1)).toVar();
  return nr(u.greaterThan(2), () => {
    d.y.addAssign(h), u.subAssign(3);
  }), d.x.addAssign(u.mul(h)), d.x.addAssign(c.mul(Dt(3, QK))), d.y.addAssign(Dt(4, xd(a).sub(h))), d.x.mulAssign(n), d.y.mulAssign(s), r.uv(d).grad(We(), We());
}), Y0 = /* @__PURE__ */ Fe(({ envMap: r, mipInt: e, outputDirection: i, theta: n, axis: s, CUBEUV_TEXEL_WIDTH: a, CUBEUV_TEXEL_HEIGHT: o, CUBEUV_MAX_MIP: l }) => {
  const u = Qa(n), c = i.mul(u).add(s.cross(i).mul(Vn(n))).add(s.mul(s.dot(i).mul(u.oneMinus())));
  return Cx(r, c, e, a, o, l);
}), rZ = /* @__PURE__ */ Fe(({ n: r, latitudinal: e, poleAxis: i, outputDirection: n, weights: s, samples: a, dTheta: o, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }) => {
  const p = be(Fr(e, i, oP(i, n))).toVar();
  nr(J3(p.equals(be(0))), () => {
    p.assign(be(n.z, 0, n.x.negate()));
  }), p.assign(_d(p));
  const f = be().toVar();
  return f.addAssign(s.element(Ei(0)).mul(Y0({ theta: 0, axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }))), ps({ start: Ei(1), end: r }, ({ i: m }) => {
    nr(m.greaterThanEqual(a), () => {
      XY();
    });
    const y = _e(o.mul(_e(m))).toVar();
    f.addAssign(s.element(m).mul(Y0({ theta: y.mul(-1), axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d }))), f.addAssign(s.element(m).mul(Y0({ theta: y, axis: p, outputDirection: n, mipInt: l, envMap: u, CUBEUV_TEXEL_WIDTH: c, CUBEUV_TEXEL_HEIGHT: h, CUBEUV_MAX_MIP: d })));
  }), _t(f, 1);
});
let Km = null;
const z2 = /* @__PURE__ */ new WeakMap();
function nZ(r) {
  const e = Math.log2(r) - 2, i = 1 / r;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: i, maxMip: e };
}
function sZ(r) {
  let e = z2.get(r);
  if ((e !== void 0 ? e.pmremVersion : -1) !== r.pmremVersion) {
    const i = r.image;
    if (r.isCubeTexture)
      if (oZ(i))
        e = Km.fromCubemap(r, e);
      else
        return null;
    else if (lZ(i))
      e = Km.fromEquirectangular(r, e);
    else
      return null;
    e.pmremVersion = r.pmremVersion, z2.set(r, e);
  }
  return e.texture;
}
class aZ extends zi {
  static get type() {
    return "PMREMNode";
  }
  constructor(e, i = null, n = null) {
    super("vec3"), this._value = e, this._pmrem = null, this.uvNode = i, this.levelNode = n, this._generator = null;
    const s = new Cr();
    s.isRenderTargetTexture = !0, this._texture = Ai(s), this._width = Tt(0), this._height = Tt(0), this._maxMip = Tt(0), this.updateBeforeType = Nt.RENDER;
  }
  set value(e) {
    this._value = e, this._pmrem = null;
  }
  get value() {
    return this._value;
  }
  updateFromTexture(e) {
    const i = nZ(e.image.height);
    this._texture.value = e, this._width.value = i.texelWidth, this._height.value = i.texelHeight, this._maxMip.value = i.maxMip;
  }
  updateBefore() {
    let e = this._pmrem;
    const i = e ? e.pmremVersion : -1, n = this._value;
    i !== n.pmremVersion && (n.isPMREMTexture === !0 ? e = n : e = sZ(n), e !== null && (this._pmrem = e, this.updateFromTexture(e)));
  }
  setup(e) {
    Km === null && (Km = e.createPMREMGenerator()), this.updateBefore(e);
    let i = this.uvNode;
    i === null && e.context.getUV && (i = e.context.getUV(this));
    const n = this.value;
    e.renderer.coordinateSystem === Kn && n.isPMREMTexture !== !0 && n.isRenderTargetTexture === !0 && (i = be(i.x.negate(), i.yz));
    let s = this.levelNode;
    return s === null && e.context.getTextureLevel && (s = e.context.getTextureLevel(this)), iZ(this._texture, i, s, this._width, this._height, this._maxMip);
  }
}
function oZ(r) {
  if (r == null) return !1;
  let e = 0;
  const i = 6;
  for (let n = 0; n < i; n++)
    r[n] !== void 0 && e++;
  return e === i;
}
function lZ(r) {
  return r == null ? !1 : r.height > 0;
}
const HP = /* @__PURE__ */ Ae(aZ), j2 = /* @__PURE__ */ new WeakMap();
class uZ extends Hc {
  static get type() {
    return "EnvironmentNode";
  }
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    const { material: i } = e;
    let n = this.envNode;
    if (n.isTextureNode || n.isMaterialReferenceNode) {
      const d = n.isTextureNode ? n.value : i[n.property];
      let p = j2.get(d);
      p === void 0 && (p = HP(d), j2.set(d, p)), n = p;
    }
    const s = i.envMap ? bi("envMapIntensity", "float", e.material) : bi("environmentIntensity", "float", e.scene), a = i.useAnisotropy === !0 || i.anisotropy > 0 ? tY : Ui, o = n.context(V2(ta, a)).mul(s), l = n.context(cZ(I1)).mul(Math.PI).mul(s), u = om(o), c = om(l);
    e.context.radiance.addAssign(u), e.context.iblIrradiance.addAssign(c);
    const h = e.context.lightingModel.clearcoatRadiance;
    if (h) {
      const d = n.context(V2(qm, Vh)).mul(s), p = om(d);
      h.addAssign(p);
    }
  }
}
const V2 = (r, e) => {
  let i = null;
  return {
    getUV: () => (i === null && (i = vi.negate().reflect(e), i = r.mul(r).mix(i, e).normalize(), i = i.transformDirection(Ma)), i),
    getTextureLevel: () => r
  };
}, cZ = (r) => ({
  getUV: () => r,
  getTextureLevel: () => _e(1)
}), hZ = /* @__PURE__ */ new g1();
class WP extends Bi {
  static get type() {
    return "MeshStandardNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardNodeMaterial = !0, this.lights = !0, this.emissiveNode = null, this.metalnessNode = null, this.roughnessNode = null, this.setDefaultValues(hZ), this.setValues(e);
  }
  setupEnvironment(e) {
    let i = super.setupEnvironment(e);
    return i === null && e.environmentNode && (i = e.environmentNode), i ? new uZ(i) : null;
  }
  setupLightingModel() {
    return new GP();
  }
  setupSpecular() {
    const e = li(be(0.04), qt.rgb, Wm);
    nn.assign(e), Xm.assign(1);
  }
  setupVariants() {
    const e = this.metalnessNode ? _e(this.metalnessNode) : mY;
    Wm.assign(e);
    let i = this.roughnessNode ? _e(this.roughnessNode) : fY;
    i = FP({ roughness: i }), ta.assign(i), this.setupSpecular(), qt.assign(_t(qt.rgb.mul(e.oneMinus()), qt.a));
  }
  copy(e) {
    return this.emissiveNode = e.emissiveNode, this.metalnessNode = e.metalnessNode, this.roughnessNode = e.roughnessNode, super.copy(e);
  }
}
const dZ = /* @__PURE__ */ new A3();
class pZ extends WP {
  static get type() {
    return "MeshPhysicalNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshPhysicalNodeMaterial = !0, this.clearcoatNode = null, this.clearcoatRoughnessNode = null, this.clearcoatNormalNode = null, this.sheenNode = null, this.sheenRoughnessNode = null, this.iridescenceNode = null, this.iridescenceIORNode = null, this.iridescenceThicknessNode = null, this.specularIntensityNode = null, this.specularColorNode = null, this.iorNode = null, this.transmissionNode = null, this.thicknessNode = null, this.attenuationDistanceNode = null, this.attenuationColorNode = null, this.dispersionNode = null, this.anisotropyNode = null, this.setDefaultValues(dZ), this.setValues(e);
  }
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  get useDispersion() {
    return this.dispersion > 0 || this.dispersionNode !== null;
  }
  setupSpecular() {
    const e = this.iorNode ? _e(this.iorNode) : RY;
    am.assign(e), nn.assign(li(Td(lP(am.sub(1).div(am.add(1))).mul(pY), be(1)).mul(x2), qt.rgb, Wm)), Xm.assign(li(x2, 1, Wm));
  }
  setupLightingModel() {
    return new GP(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
  }
  setupVariants(e) {
    if (super.setupVariants(e), this.useClearcoat) {
      const i = this.clearcoatNode ? _e(this.clearcoatNode) : yY, n = this.clearcoatRoughnessNode ? _e(this.clearcoatRoughnessNode) : vY;
      vx.assign(i), qm.assign(FP({ roughness: n }));
    }
    if (this.useSheen) {
      const i = this.sheenNode ? be(this.sheenNode) : _Y, n = this.sheenRoughnessNode ? _e(this.sheenRoughnessNode) : TY;
      Fu.assign(i), S1.assign(n);
    }
    if (this.useIridescence) {
      const i = this.iridescenceNode ? _e(this.iridescenceNode) : SY, n = this.iridescenceIORNode ? _e(this.iridescenceIORNode) : EY, s = this.iridescenceThicknessNode ? _e(this.iridescenceThicknessNode) : MY;
      E1.assign(i), q3.assign(n), X3.assign(s);
    }
    if (this.useAnisotropy) {
      const i = (this.anisotropyNode ? We(this.anisotropyNode) : wY).toVar();
      Go.assign(i.length()), nr(Go.equal(0), () => {
        i.assign(We(1, 0));
      }).Else(() => {
        i.divAssign(We(Go)), Go.assign(Go.saturate());
      }), bx.assign(Go.pow2().mix(ta.pow2(), 1)), sm.assign(Gh[0].mul(i.x).add(Gh[1].mul(i.y))), ec.assign(Gh[1].mul(i.x).sub(Gh[0].mul(i.y)));
    }
    if (this.useTransmission) {
      const i = this.transmissionNode ? _e(this.transmissionNode) : AY, n = this.thicknessNode ? _e(this.thicknessNode) : CY, s = this.attenuationDistanceNode ? _e(this.attenuationDistanceNode) : NY, a = this.attenuationColorNode ? be(this.attenuationColorNode) : PY;
      if (_x.assign(i), Y3.assign(n), K3.assign(s), Z3.assign(a), this.useDispersion) {
        const o = this.dispersionNode ? _e(this.dispersionNode) : LY;
        Q3.assign(o);
      }
    }
  }
  setupClearcoatNormal() {
    return this.clearcoatNormalNode ? be(this.clearcoatNormalNode) : bY;
  }
  setup(e) {
    e.context.setupClearcoatNormal = () => this.setupClearcoatNormal(e), super.setup(e);
  }
  copy(e) {
    return this.clearcoatNode = e.clearcoatNode, this.clearcoatRoughnessNode = e.clearcoatRoughnessNode, this.clearcoatNormalNode = e.clearcoatNormalNode, this.sheenNode = e.sheenNode, this.sheenRoughnessNode = e.sheenRoughnessNode, this.iridescenceNode = e.iridescenceNode, this.iridescenceIORNode = e.iridescenceIORNode, this.iridescenceThicknessNode = e.iridescenceThicknessNode, this.specularIntensityNode = e.specularIntensityNode, this.specularColorNode = e.specularColorNode, this.transmissionNode = e.transmissionNode, this.thicknessNode = e.thicknessNode, this.attenuationDistanceNode = e.attenuationDistanceNode, this.attenuationColorNode = e.attenuationColorNode, this.dispersionNode = e.dispersionNode, this.anisotropyNode = e.anisotropyNode, super.copy(e);
  }
}
const fZ = /* @__PURE__ */ Fe(({ normal: r, lightDirection: e, builder: i }) => {
  const n = r.dot(e), s = We(n.mul(0.5).add(0.5), 0);
  if (i.material.gradientMap) {
    const a = eo("gradientMap", "texture").context({ getUV: () => s });
    return be(a.r);
  } else {
    const a = s.fwidth().mul(0.5);
    return li(be(0.7), be(1), Ml(_e(0.7).sub(a.x), _e(0.7).add(a.x), s.x));
  }
});
class mZ extends zg {
  direct({ lightDirection: e, lightColor: i, reflectedLight: n }, s, a) {
    const o = fZ({ normal: yP, lightDirection: e, builder: a }).mul(i);
    n.directDiffuse.addAssign(o.mul(Ec({ diffuseColor: qt.rgb })));
  }
  indirect({ ambientOcclusion: e, irradiance: i, reflectedLight: n }) {
    n.indirectDiffuse.addAssign(i.mul(Ec({ diffuseColor: qt }))), n.indirectDiffuse.mulAssign(e);
  }
}
const gZ = /* @__PURE__ */ new R3();
class yZ extends Bi {
  static get type() {
    return "MeshToonNodeMaterial";
  }
  constructor(e) {
    super(), this.isMeshToonNodeMaterial = !0, this.lights = !0, this.setDefaultValues(gZ), this.setValues(e);
  }
  setupLightingModel() {
    return new mZ();
  }
}
class vZ extends zi {
  static get type() {
    return "MatcapUVNode";
  }
  constructor() {
    super("vec2");
  }
  setup() {
    const e = be(vi.z, 0, vi.x.negate()).normalize(), i = vi.cross(e);
    return We(e.dot(Ui), i.dot(Ui)).mul(0.495).add(0.5);
  }
}
const bZ = /* @__PURE__ */ Ge(vZ), xZ = /* @__PURE__ */ new I3();
class _Z extends Bi {
  static get type() {
    return "MeshMatcapNodeMaterial";
  }
  constructor(e) {
    super(), this.lights = !1, this.isMeshMatcapNodeMaterial = !0, this.setDefaultValues(xZ), this.setValues(e);
  }
  setupVariants(e) {
    const i = bZ;
    let n;
    e.material.matcap ? n = eo("matcap", "texture").context({ getUV: () => i }) : n = be(li(0.2, 0.8, i.y)), qt.rgb.mulAssign(n.rgb);
  }
}
const TZ = /* @__PURE__ */ new E3();
class wZ extends Bi {
  static get type() {
    return "PointsNodeMaterial";
  }
  constructor(e) {
    super(), this.isPointsNodeMaterial = !0, this.lights = !1, this.transparent = !0, this.sizeNode = null, this.setDefaultValues(TZ), this.setValues(e);
  }
  copy(e) {
    return this.sizeNode = e.sizeNode, super.copy(e);
  }
}
class SZ extends zi {
  static get type() {
    return "RotateNode";
  }
  constructor(e, i) {
    super(), this.positionNode = e, this.rotationNode = i;
  }
  getNodeType(e) {
    return this.positionNode.getNodeType(e);
  }
  setup(e) {
    const { rotationNode: i, positionNode: n } = this;
    if (this.getNodeType(e) === "vec2") {
      const s = i.cos(), a = i.sin();
      return w1(
        s,
        a,
        a.negate(),
        s
      ).mul(n);
    } else {
      const s = i, a = Ju(_t(1, 0, 0, 0), _t(0, Qa(s.x), Vn(s.x).negate(), 0), _t(0, Vn(s.x), Qa(s.x), 0), _t(0, 0, 0, 1)), o = Ju(_t(Qa(s.y), 0, Vn(s.y), 0), _t(0, 1, 0, 0), _t(Vn(s.y).negate(), 0, Qa(s.y), 0), _t(0, 0, 0, 1)), l = Ju(_t(Qa(s.z), Vn(s.z).negate(), 0, 0), _t(Vn(s.z), Qa(s.z), 0, 0), _t(0, 0, 1, 0), _t(0, 0, 0, 1));
      return a.mul(o).mul(l).mul(_t(n, 1)).xyz;
    }
  }
}
const EZ = /* @__PURE__ */ Ae(SZ), MZ = /* @__PURE__ */ new w3();
class AZ extends Bi {
  static get type() {
    return "SpriteNodeMaterial";
  }
  constructor(e) {
    super(), this.isSpriteNodeMaterial = !0, this.lights = !1, this._useSizeAttenuation = !0, this.positionNode = null, this.rotationNode = null, this.scaleNode = null, this.setDefaultValues(MZ), this.setValues(e);
  }
  setupPosition({ object: e, camera: i, context: n }) {
    const s = this.sizeAttenuation, { positionNode: a, rotationNode: o, scaleNode: l } = this, u = sr;
    let c = Fg.mul(be(a || 0)), h = We(Al[0].xyz.length(), Al[1].xyz.length());
    if (l !== null && (h = h.mul(l)), !s)
      if (i.isPerspectiveCamera)
        h = h.mul(c.z.negate());
      else {
        const y = _e(2).div(Ym.element(1).element(1));
        h = h.mul(y.mul(2));
      }
    let d = u.xy;
    if (e.center && e.center.isVector2 === !0) {
      const y = fX("center", "vec2");
      d = d.sub(y.sub(0.5));
    }
    d = d.mul(h);
    const p = _e(o || xY), f = EZ(d, p);
    c = _t(c.xy.add(f), c.zw);
    const m = Ym.mul(c);
    return n.vertex = u, m;
  }
  copy(e) {
    return this.positionNode = e.positionNode, this.rotationNode = e.rotationNode, this.scaleNode = e.scaleNode, super.copy(e);
  }
  get sizeAttenuation() {
    return this._useSizeAttenuation;
  }
  set sizeAttenuation(e) {
    this._useSizeAttenuation !== e && (this._useSizeAttenuation = e, this.needsUpdate = !0);
  }
}
class CZ extends zg {
  constructor() {
    super(), this.shadowNode = _e(1).toVar("shadowMask");
  }
  direct({ shadowMask: e }) {
    this.shadowNode.mulAssign(e);
  }
  finish(e) {
    qt.a.mulAssign(this.shadowNode.oneMinus()), e.outgoingLight.rgb.assign(qt.rgb);
  }
}
const RZ = /* @__PURE__ */ new M3();
class NZ extends Bi {
  static get type() {
    return "ShadowNodeMaterial";
  }
  constructor(e) {
    super(), this.isShadowNodeMaterial = !0, this.lights = !0, this.setDefaultValues(RZ), this.setValues(e);
  }
  setupLightingModel() {
    return new CZ();
  }
}
Fe(({ texture: r, uv: e }) => {
  const i = be().toVar();
  return nr(e.x.lessThan(1e-4), () => {
    i.assign(be(1, 0, 0));
  }).ElseIf(e.y.lessThan(1e-4), () => {
    i.assign(be(0, 1, 0));
  }).ElseIf(e.z.lessThan(1e-4), () => {
    i.assign(be(0, 0, 1));
  }).ElseIf(e.x.greaterThan(1 - 1e-4), () => {
    i.assign(be(-1, 0, 0));
  }).ElseIf(e.y.greaterThan(1 - 1e-4), () => {
    i.assign(be(0, -1, 0));
  }).ElseIf(e.z.greaterThan(1 - 1e-4), () => {
    i.assign(be(0, 0, -1));
  }).Else(() => {
    const n = r.uv(e.add(be(-0.01, 0, 0))).r.sub(r.uv(e.add(be(0.01, 0, 0))).r), s = r.uv(e.add(be(0, -0.01, 0))).r.sub(r.uv(e.add(be(0, 0.01, 0))).r), a = r.uv(e.add(be(0, 0, -0.01))).r.sub(r.uv(e.add(be(0, 0, 0.01))).r);
    i.assign(be(n, s, a));
  }), i.normalize();
});
class PZ {
  constructor(e, i) {
    this.nodes = e, this.info = i, this.animationLoop = null, this.requestId = null, this._init();
  }
  _init() {
    const e = (i, n) => {
      this.requestId = self.requestAnimationFrame(e), this.info.autoReset === !0 && this.info.reset(), this.nodes.nodeFrame.update(), this.info.frame = this.nodes.nodeFrame.frameId, this.animationLoop !== null && this.animationLoop(i, n);
    };
    e();
  }
  dispose() {
    self.cancelAnimationFrame(this.requestId), this.requestId = null;
  }
  setAnimationLoop(e) {
    this.animationLoop = e;
  }
}
class Ts {
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
  }
  get(e) {
    let i = this.weakMap;
    for (let n = 0; n < e.length; n++)
      if (i = i.get(e[n]), i === void 0) return;
    return i.get(e[e.length - 1]);
  }
  set(e, i) {
    let n = this.weakMap;
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      n.has(a) === !1 && n.set(a, /* @__PURE__ */ new WeakMap()), n = n.get(a);
    }
    return n.set(e[e.length - 1], i);
  }
  delete(e) {
    let i = this.weakMap;
    for (let n = 0; n < e.length; n++)
      if (i = i.get(e[n]), i === void 0) return !1;
    return i.delete(e[e.length - 1]);
  }
}
const K0 = /* @__PURE__ */ new Za();
class Rx {
  constructor() {
    this.version = 0, this.globalClippingCount = 0, this.localClippingCount = 0, this.localClippingEnabled = !1, this.localClipIntersection = !1, this.planes = [], this.parentVersion = 0, this.viewNormalMatrix = new Xr(), this.cacheKey = 0;
  }
  projectPlanes(e, i) {
    const n = e.length, s = this.planes;
    for (let a = 0; a < n; a++) {
      K0.copy(e[a]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
      const o = s[i + a], l = K0.normal;
      o.x = -l.x, o.y = -l.y, o.z = -l.z, o.w = K0.constant;
    }
  }
  updateGlobal(e, i) {
    const n = e.clippingPlanes;
    this.viewMatrix = i.matrixWorldInverse, this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
    let s = !1;
    if (Array.isArray(n) && n.length !== 0) {
      const a = n.length;
      if (a !== this.globalClippingCount) {
        const o = [];
        for (let l = 0; l < a; l++)
          o.push(new Kt());
        this.globalClippingCount = a, this.planes = o, s = !0;
      }
      this.projectPlanes(n, 0);
    } else this.globalClippingCount !== 0 && (this.globalClippingCount = 0, this.planes = [], s = !0);
    e.localClippingEnabled !== this.localClippingEnabled && (this.localClippingEnabled = e.localClippingEnabled, s = !0), s && (this.version++, this.cacheKey = zm(this.globalClippingCount, this.localClippingEnabled === !0 ? 1 : 0));
  }
  update(e, i) {
    let n = !1;
    if (this !== e && e.version !== this.parentVersion && (this.globalClippingCount = i.isShadowNodeMaterial ? 0 : e.globalClippingCount, this.localClippingEnabled = e.localClippingEnabled, this.planes = Array.from(e.planes), this.parentVersion = e.version, this.viewMatrix = e.viewMatrix, this.viewNormalMatrix = e.viewNormalMatrix, n = !0), this.localClippingEnabled) {
      const s = i.clippingPlanes;
      if (Array.isArray(s) && s.length !== 0) {
        const a = s.length, o = this.planes, l = this.globalClippingCount;
        if (n || a !== this.localClippingCount) {
          o.length = l + a;
          for (let u = 0; u < a; u++)
            o[l + u] = new Kt();
          this.localClippingCount = a, n = !0;
        }
        this.projectPlanes(s, l);
      } else this.localClippingCount !== 0 && (this.localClippingCount = 0, n = !0);
      this.localClipIntersection !== i.clipIntersection && (this.localClipIntersection = i.clipIntersection, n = !0);
    }
    n && (this.version += e.version, this.cacheKey = zm(e.cacheKey, this.localClippingCount, this.localClipIntersection === !0 ? 1 : 0));
  }
}
let IZ = 0;
function OZ(r) {
  const e = Object.keys(r);
  let i = Object.getPrototypeOf(r);
  for (; i; ) {
    const n = Object.getOwnPropertyDescriptors(i);
    for (const s in n)
      if (n[s] !== void 0) {
        const a = n[s];
        a && typeof a.get == "function" && e.push(s);
      }
    i = Object.getPrototypeOf(i);
  }
  return e;
}
class DZ {
  constructor(e, i, n, s, a, o, l, u, c) {
    this._nodes = e, this._geometries = i, this.id = IZ++, this.renderer = n, this.object = s, this.material = a, this.scene = o, this.camera = l, this.lightsNode = u, this.context = c, this.geometry = s.geometry, this.version = a.version, this.drawRange = null, this.attributes = null, this.pipeline = null, this.vertexBuffers = null, this.drawParams = null, this.bundle = null, this.updateClipping(c.clippingContext), this.clippingContextVersion = this.clippingContext.version, this.initialNodesCacheKey = this.getDynamicCacheKey(), this.initialCacheKey = this.getCacheKey(), this._nodeBuilderState = null, this._bindings = null, this._monitor = null, this.onDispose = null, this.isRenderObject = !0, this.onMaterialDispose = () => {
      this.dispose();
    }, this.material.addEventListener("dispose", this.onMaterialDispose);
  }
  updateClipping(e) {
    const i = this.material;
    let n = this.clippingContext;
    Array.isArray(i.clippingPlanes) ? ((n === e || !n) && (n = new Rx(), this.clippingContext = n), n.update(e, i)) : this.clippingContext !== e && (this.clippingContext = e);
  }
  get clippingNeedsUpdate() {
    return this.clippingContext.version === this.clippingContextVersion ? !1 : (this.clippingContextVersion = this.clippingContext.version, !0);
  }
  getNodeBuilderState() {
    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
  }
  getMonitor() {
    return this._monitor || (this._monitor = this.getNodeBuilderState().monitor);
  }
  getBindings() {
    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
  }
  getIndex() {
    return this._geometries.getIndex(this);
  }
  getIndirect() {
    return this._geometries.getIndirect(this);
  }
  getChainArray() {
    return [this.object, this.material, this.context, this.lightsNode];
  }
  getAttributes() {
    if (this.attributes !== null) return this.attributes;
    const e = this.getNodeBuilderState().nodeAttributes, i = this.geometry, n = [], s = /* @__PURE__ */ new Set();
    for (const a of e) {
      const o = a.node && a.node.attribute ? a.node.attribute : i.getAttribute(a.name);
      if (o === void 0) continue;
      n.push(o);
      const l = o.isInterleavedBufferAttribute ? o.data : o;
      s.add(l);
    }
    return this.attributes = n, this.vertexBuffers = Array.from(s.values()), n;
  }
  getVertexBuffers() {
    return this.vertexBuffers === null && this.getAttributes(), this.vertexBuffers;
  }
  getDrawParameters() {
    const { object: e, material: i, geometry: n, group: s, drawRange: a } = this, o = this.drawParams || (this.drawParams = {
      vertexCount: 0,
      firstVertex: 0,
      instanceCount: 0,
      firstInstance: 0
    }), l = this.getIndex(), u = l !== null, c = n.isInstancedBufferGeometry ? n.instanceCount : e.count > 1 ? e.count : 1;
    if (c === 0) return null;
    if (o.instanceCount = c, e.isBatchedMesh === !0) return o;
    let h = 1;
    i.wireframe === !0 && !e.isPoints && !e.isLineSegments && !e.isLine && !e.isLineLoop && (h = 2);
    let d = a.start * h, p = (a.start + a.count) * h;
    s !== null && (d = Math.max(d, s.start * h), p = Math.min(p, (s.start + s.count) * h));
    const f = n.attributes.position;
    let m = 1 / 0;
    u ? m = l.count : f != null && (m = f.count), d = Math.max(d, 0), p = Math.min(p, m);
    const y = p - d;
    return y < 0 || y === 1 / 0 ? null : (o.vertexCount = y, o.firstVertex = d, o);
  }
  getGeometryCacheKey() {
    const { geometry: e } = this;
    let i = "";
    for (const n of Object.keys(e.attributes).sort()) {
      const s = e.attributes[n];
      i += n + ",", s.data && (i += s.data.stride + ","), s.offset && (i += s.offset + ","), s.itemSize && (i += s.itemSize + ","), s.normalized && (i += "n,");
    }
    return e.index && (i += "index,"), i;
  }
  getMaterialCacheKey() {
    const { object: e, material: i } = this;
    let n = i.customProgramCacheKey();
    for (const s of OZ(i)) {
      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(s)) continue;
      const a = i[s];
      let o;
      if (a !== null) {
        const l = typeof a;
        l === "number" ? o = a !== 0 ? "1" : "0" : l === "object" ? (o = "{", a.isTexture && (o += a.mapping), o += "}") : o = String(a);
      } else
        o = String(a);
      n += /*property + ':' +*/
      o + ",";
    }
    return n += this.clippingContext.cacheKey + ",", e.geometry && (n += this.getGeometryCacheKey()), e.skeleton && (n += e.skeleton.bones.length + ","), e.morphTargetInfluences && (n += e.morphTargetInfluences.length + ","), e.isBatchedMesh && (n += e._matricesTexture.uuid + ",", e._colorsTexture !== null && (n += e._colorsTexture.uuid + ",")), e.count > 1 && (n += e.uuid + ","), bW(n);
  }
  get needsUpdate() {
    return (
      /*this.object.static !== true &&*/
      this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate
    );
  }
  getDynamicCacheKey() {
    let e = this._nodes.getCacheKey(this.scene, this.lightsNode);
    return this.object.receiveShadow && (e += 1), e;
  }
  getCacheKey() {
    return this.getMaterialCacheKey() + this.getDynamicCacheKey();
  }
  dispose() {
    this.material.removeEventListener("dispose", this.onMaterialDispose), this.onDispose();
  }
}
const bu = [];
class LZ {
  constructor(e, i, n, s, a, o) {
    this.renderer = e, this.nodes = i, this.geometries = n, this.pipelines = s, this.bindings = a, this.info = o, this.chainMaps = {};
  }
  get(e, i, n, s, a, o, l) {
    const u = this.getChainMap(l);
    bu[0] = e, bu[1] = i, bu[2] = o, bu[3] = a;
    let c = u.get(bu);
    return c === void 0 ? (c = this.createRenderObject(this.nodes, this.geometries, this.renderer, e, i, n, s, a, o, l), u.set(bu, c)) : (c.updateClipping(o.clippingContext), (c.version !== i.version || c.needsUpdate) && (c.initialCacheKey !== c.getCacheKey() ? (c.dispose(), c = this.get(e, i, n, s, a, o, l)) : c.version = i.version)), c;
  }
  getChainMap(e = "default") {
    return this.chainMaps[e] || (this.chainMaps[e] = new Ts());
  }
  dispose() {
    this.chainMaps = {};
  }
  createRenderObject(e, i, n, s, a, o, l, u, c, h) {
    const d = this.getChainMap(h), p = new DZ(e, i, n, s, a, o, l, u, c);
    return p.onDispose = () => {
      this.pipelines.delete(p), this.bindings.delete(p), this.nodes.delete(p), d.delete(p.getChainArray());
    }, p;
  }
}
class To {
  constructor() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
  get(e) {
    let i = this.data.get(e);
    return i === void 0 && (i = {}, this.data.set(e, i)), i;
  }
  delete(e) {
    let i;
    return this.data.has(e) && (i = this.data.get(e), this.data.delete(e)), i;
  }
  has(e) {
    return this.data.has(e);
  }
  dispose() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
}
const fs = {
  VERTEX: 1,
  INDEX: 2,
  STORAGE: 3,
  INDIRECT: 4
}, to = 16, kZ = 211, UZ = 212;
class FZ extends To {
  constructor(e) {
    super(), this.backend = e;
  }
  delete(e) {
    const i = super.delete(e);
    return i !== void 0 && this.backend.destroyAttribute(e), i;
  }
  update(e, i) {
    const n = this.get(e);
    if (n.version === void 0)
      i === fs.VERTEX ? this.backend.createAttribute(e) : i === fs.INDEX ? this.backend.createIndexAttribute(e) : i === fs.STORAGE ? this.backend.createStorageAttribute(e) : i === fs.INDIRECT && this.backend.createIndirectStorageAttribute(e), n.version = this._getBufferAttribute(e).version;
    else {
      const s = this._getBufferAttribute(e);
      (n.version < s.version || s.usage === ku) && (this.backend.updateAttribute(e), n.version = s.version);
    }
  }
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
function BZ(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function qP(r) {
  return r.index !== null ? r.index.version : r.attributes.position.version;
}
function G2(r) {
  const e = [], i = r.index, n = r.attributes.position;
  if (i !== null) {
    const a = i.array;
    for (let o = 0, l = a.length; o < l; o += 3) {
      const u = a[o + 0], c = a[o + 1], h = a[o + 2];
      e.push(u, c, c, h, h, u);
    }
  } else {
    const a = n.array;
    for (let o = 0, l = a.length / 3 - 1; o < l; o += 3) {
      const u = o + 0, c = o + 1, h = o + 2;
      e.push(u, c, c, h, h, u);
    }
  }
  const s = new (BZ(e) ? g3 : m3)(e, 1);
  return s.version = qP(r), s;
}
class zZ extends To {
  constructor(e, i) {
    super(), this.attributes = e, this.info = i, this.wireframes = /* @__PURE__ */ new WeakMap(), this.attributeCall = /* @__PURE__ */ new WeakMap();
  }
  has(e) {
    const i = e.geometry;
    return super.has(i) && this.get(i).initialized === !0;
  }
  updateForRender(e) {
    this.has(e) === !1 && this.initGeometry(e), this.updateAttributes(e);
  }
  initGeometry(e) {
    const i = e.geometry, n = this.get(i);
    n.initialized = !0, this.info.memory.geometries++;
    const s = () => {
      this.info.memory.geometries--;
      const a = i.index, o = e.getAttributes();
      a !== null && this.attributes.delete(a);
      for (const u of o)
        this.attributes.delete(u);
      const l = this.wireframes.get(i);
      l !== void 0 && this.attributes.delete(l), i.removeEventListener("dispose", s);
    };
    i.addEventListener("dispose", s);
  }
  updateAttributes(e) {
    const i = e.getAttributes();
    for (const a of i)
      a.isStorageBufferAttribute || a.isStorageInstancedBufferAttribute ? this.updateAttribute(a, fs.STORAGE) : this.updateAttribute(a, fs.VERTEX);
    const n = this.getIndex(e);
    n !== null && this.updateAttribute(n, fs.INDEX);
    const s = e.geometry.indirect;
    s !== null && this.updateAttribute(s, fs.INDIRECT);
  }
  updateAttribute(e, i) {
    const n = this.info.render.calls;
    e.isInterleavedBufferAttribute ? this.attributeCall.get(e) === void 0 ? (this.attributes.update(e, i), this.attributeCall.set(e, n)) : this.attributeCall.get(e.data) !== n && (this.attributes.update(e, i), this.attributeCall.set(e.data, n), this.attributeCall.set(e, n)) : this.attributeCall.get(e) !== n && (this.attributes.update(e, i), this.attributeCall.set(e, n));
  }
  getIndirect(e) {
    return e.geometry.indirect;
  }
  getIndex(e) {
    const { geometry: i, material: n } = e;
    let s = i.index;
    if (n.wireframe === !0) {
      const a = this.wireframes;
      let o = a.get(i);
      o === void 0 ? (o = G2(i), a.set(i, o)) : o.version !== qP(i) && (this.attributes.delete(o), o = G2(i), a.set(i, o)), s = o;
    }
    return s;
  }
}
class jZ {
  constructor() {
    this.autoReset = !0, this.frame = 0, this.calls = 0, this.render = {
      calls: 0,
      frameCalls: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
      timestamp: 0,
      previousFrameCalls: 0,
      timestampCalls: 0
    }, this.compute = {
      calls: 0,
      frameCalls: 0,
      timestamp: 0,
      previousFrameCalls: 0,
      timestampCalls: 0
    }, this.memory = {
      geometries: 0,
      textures: 0
    };
  }
  update(e, i, n) {
    this.render.drawCalls++, e.isMesh || e.isSprite ? this.render.triangles += n * (i / 3) : e.isPoints ? this.render.points += n * i : e.isLineSegments ? this.render.lines += n * (i / 2) : e.isLine ? this.render.lines += n * (i - 1) : console.error("THREE.WebGPUInfo: Unknown object type.");
  }
  updateTimestamp(e, i) {
    this[e].timestampCalls === 0 && (this[e].timestamp = 0), this[e].timestamp += i, this[e].timestampCalls++, this[e].timestampCalls >= this[e].previousFrameCalls && (this[e].timestampCalls = 0);
  }
  reset() {
    const e = this.render.frameCalls;
    this.render.previousFrameCalls = e;
    const i = this.compute.frameCalls;
    this.compute.previousFrameCalls = i, this.render.drawCalls = 0, this.render.frameCalls = 0, this.compute.frameCalls = 0, this.render.triangles = 0, this.render.points = 0, this.render.lines = 0;
  }
  dispose() {
    this.reset(), this.calls = 0, this.render.calls = 0, this.compute.calls = 0, this.render.timestamp = 0, this.compute.timestamp = 0, this.memory.geometries = 0, this.memory.textures = 0;
  }
}
class XP {
  constructor(e) {
    this.cacheKey = e, this.usedTimes = 0;
  }
}
class VZ extends XP {
  constructor(e, i, n) {
    super(e), this.vertexProgram = i, this.fragmentProgram = n;
  }
}
class GZ extends XP {
  constructor(e, i) {
    super(e), this.computeProgram = i, this.isComputePipeline = !0;
  }
}
let HZ = 0;
class Z0 {
  constructor(e, i, n = null, s = null) {
    this.id = HZ++, this.code = e, this.stage = i, this.transforms = n, this.attributes = s, this.usedTimes = 0;
  }
}
class WZ extends To {
  constructor(e, i) {
    super(), this.backend = e, this.nodes = i, this.bindings = null, this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  getForCompute(e, i) {
    const { backend: n } = this, s = this.get(e);
    if (this._needsComputeUpdate(e)) {
      const a = s.pipeline;
      a && (a.usedTimes--, a.computeProgram.usedTimes--);
      const o = this.nodes.getForCompute(e);
      let l = this.programs.compute.get(o.computeShader);
      l === void 0 && (a && a.computeProgram.usedTimes === 0 && this._releaseProgram(a.computeProgram), l = new Z0(o.computeShader, "compute", o.transforms, o.nodeAttributes), this.programs.compute.set(o.computeShader, l), n.createProgram(l));
      const u = this._getComputeCacheKey(e, l);
      let c = this.caches.get(u);
      c === void 0 && (a && a.usedTimes === 0 && this._releasePipeline(a), c = this._getComputePipeline(e, l, u, i)), c.usedTimes++, l.usedTimes++, s.version = e.version, s.pipeline = c;
    }
    return s.pipeline;
  }
  getForRender(e, i = null) {
    const { backend: n } = this, s = this.get(e);
    if (this._needsRenderUpdate(e)) {
      const a = s.pipeline;
      a && (a.usedTimes--, a.vertexProgram.usedTimes--, a.fragmentProgram.usedTimes--);
      const o = e.getNodeBuilderState();
      let l = this.programs.vertex.get(o.vertexShader);
      l === void 0 && (a && a.vertexProgram.usedTimes === 0 && this._releaseProgram(a.vertexProgram), l = new Z0(o.vertexShader, "vertex"), this.programs.vertex.set(o.vertexShader, l), n.createProgram(l));
      let u = this.programs.fragment.get(o.fragmentShader);
      u === void 0 && (a && a.fragmentProgram.usedTimes === 0 && this._releaseProgram(a.fragmentProgram), u = new Z0(o.fragmentShader, "fragment"), this.programs.fragment.set(o.fragmentShader, u), n.createProgram(u));
      const c = this._getRenderCacheKey(e, l, u);
      let h = this.caches.get(c);
      h === void 0 ? (a && a.usedTimes === 0 && this._releasePipeline(a), h = this._getRenderPipeline(e, l, u, c, i)) : e.pipeline = h, h.usedTimes++, l.usedTimes++, u.usedTimes++, s.pipeline = h;
    }
    return s.pipeline;
  }
  delete(e) {
    const i = this.get(e).pipeline;
    return i && (i.usedTimes--, i.usedTimes === 0 && this._releasePipeline(i), i.isComputePipeline ? (i.computeProgram.usedTimes--, i.computeProgram.usedTimes === 0 && this._releaseProgram(i.computeProgram)) : (i.fragmentProgram.usedTimes--, i.vertexProgram.usedTimes--, i.vertexProgram.usedTimes === 0 && this._releaseProgram(i.vertexProgram), i.fragmentProgram.usedTimes === 0 && this._releaseProgram(i.fragmentProgram))), super.delete(e);
  }
  dispose() {
    super.dispose(), this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  updateForRender(e) {
    this.getForRender(e);
  }
  _getComputePipeline(e, i, n, s) {
    n = n || this._getComputeCacheKey(e, i);
    let a = this.caches.get(n);
    return a === void 0 && (a = new GZ(n, i), this.caches.set(n, a), this.backend.createComputePipeline(a, s)), a;
  }
  _getRenderPipeline(e, i, n, s, a) {
    s = s || this._getRenderCacheKey(e, i, n);
    let o = this.caches.get(s);
    return o === void 0 && (o = new VZ(s, i, n), this.caches.set(s, o), e.pipeline = o, this.backend.createRenderPipeline(e, a)), o;
  }
  _getComputeCacheKey(e, i) {
    return e.id + "," + i.id;
  }
  _getRenderCacheKey(e, i, n) {
    return i.id + "," + n.id + "," + this.backend.getRenderCacheKey(e);
  }
  _releasePipeline(e) {
    this.caches.delete(e.cacheKey);
  }
  _releaseProgram(e) {
    const i = e.code, n = e.stage;
    this.programs[n].delete(i);
  }
  _needsComputeUpdate(e) {
    const i = this.get(e);
    return i.pipeline === void 0 || i.version !== e.version;
  }
  _needsRenderUpdate(e) {
    return this.get(e).pipeline === void 0 || this.backend.needsRenderUpdate(e);
  }
}
class qZ extends To {
  constructor(e, i, n, s, a, o) {
    super(), this.backend = e, this.textures = n, this.pipelines = a, this.attributes = s, this.nodes = i, this.info = o, this.pipelines.bindings = this;
  }
  getForRender(e) {
    const i = e.getBindings();
    for (const n of i) {
      const s = this.get(n);
      s.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, i), s.bindGroup = n);
    }
    return i;
  }
  getForCompute(e) {
    const i = this.nodes.getForCompute(e).bindings;
    for (const n of i) {
      const s = this.get(n);
      s.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, i), s.bindGroup = n);
    }
    return i;
  }
  updateForCompute(e) {
    this._updateBindings(this.getForCompute(e));
  }
  updateForRender(e) {
    this._updateBindings(this.getForRender(e));
  }
  _updateBindings(e) {
    for (const i of e)
      this._update(i, e);
  }
  _init(e) {
    for (const i of e.bindings)
      if (i.isSampledTexture)
        this.textures.updateTexture(i.texture);
      else if (i.isStorageBuffer) {
        const n = i.attribute, s = n.isIndirectStorageBufferAttribute ? fs.INDIRECT : fs.STORAGE;
        this.attributes.update(n, s);
      }
  }
  _update(e, i) {
    const { backend: n } = this;
    let s = !1;
    for (const a of e.bindings)
      if (!(a.isNodeUniformsGroup && !this.nodes.updateGroup(a))) {
        if (a.isUniformBuffer)
          a.update() && n.updateBinding(a);
        else if (a.isSampler)
          a.update();
        else if (a.isSampledTexture) {
          a.needsBindingsUpdate(this.textures.get(a.texture).generation) && (s = !0);
          const o = a.update(), l = a.texture;
          o && this.textures.updateTexture(l);
          const u = n.get(l);
          if (n.isWebGPUBackend === !0 && u.texture === void 0 && u.externalTexture === void 0 && (console.error("Bindings._update: binding should be available:", a, o, l, a.textureNode.value, s), this.textures.updateTexture(l), s = !0), l.isStorageTexture === !0) {
            const c = this.get(l);
            a.store === !0 ? c.needsMipmap = !0 : this.textures.needsMipmaps(l) && c.needsMipmap === !0 && (this.backend.generateMipmaps(l), c.needsMipmap = !1);
          }
        }
      }
    s === !0 && this.backend.updateBindings(e, i);
  }
}
function XZ(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
}
function H2(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
}
function W2(r) {
  return (r.transmission > 0 || r.transmissionNode) && r.side === Yu && r.forceSinglePass === !1;
}
class YZ {
  constructor(e, i, n) {
    this.renderItems = [], this.renderItemsIndex = 0, this.opaque = [], this.transparentDoublePass = [], this.transparent = [], this.bundles = [], this.lightsNode = e.getNode(i, n), this.lightsArray = [], this.scene = i, this.camera = n, this.occlusionQueryCount = 0;
  }
  begin() {
    return this.renderItemsIndex = 0, this.opaque.length = 0, this.transparentDoublePass.length = 0, this.transparent.length = 0, this.bundles.length = 0, this.lightsArray.length = 0, this.occlusionQueryCount = 0, this;
  }
  getNextRenderItem(e, i, n, s, a, o) {
    let l = this.renderItems[this.renderItemsIndex];
    return l === void 0 ? (l = {
      id: e.id,
      object: e,
      geometry: i,
      material: n,
      groupOrder: s,
      renderOrder: e.renderOrder,
      z: a,
      group: o
    }, this.renderItems[this.renderItemsIndex] = l) : (l.id = e.id, l.object = e, l.geometry = i, l.material = n, l.groupOrder = s, l.renderOrder = e.renderOrder, l.z = a, l.group = o), this.renderItemsIndex++, l;
  }
  push(e, i, n, s, a, o) {
    const l = this.getNextRenderItem(e, i, n, s, a, o);
    e.occlusionTest === !0 && this.occlusionQueryCount++, n.transparent === !0 || n.transmission > 0 ? (W2(n) && this.transparentDoublePass.push(l), this.transparent.push(l)) : this.opaque.push(l);
  }
  unshift(e, i, n, s, a, o) {
    const l = this.getNextRenderItem(e, i, n, s, a, o);
    n.transparent === !0 || n.transmission > 0 ? (W2(n) && this.transparentDoublePass.unshift(l), this.transparent.unshift(l)) : this.opaque.unshift(l);
  }
  pushBundle(e) {
    this.bundles.push(e);
  }
  pushLight(e) {
    this.lightsArray.push(e);
  }
  sort(e, i) {
    this.opaque.length > 1 && this.opaque.sort(e || XZ), this.transparentDoublePass.length > 1 && this.transparentDoublePass.sort(i || H2), this.transparent.length > 1 && this.transparent.sort(i || H2);
  }
  finish() {
    this.lightsNode.setLights(this.lightsArray);
    for (let e = this.renderItemsIndex, i = this.renderItems.length; e < i; e++) {
      const n = this.renderItems[e];
      if (n.id === null) break;
      n.id = null, n.object = null, n.geometry = null, n.material = null, n.groupOrder = null, n.renderOrder = null, n.z = null, n.group = null;
    }
  }
}
class KZ {
  constructor(e) {
    this.lighting = e, this.lists = new Ts();
  }
  get(e, i) {
    const n = this.lists, s = [e, i];
    let a = n.get(s);
    return a === void 0 && (a = new YZ(this.lighting, e, i), n.set(s, a)), a;
  }
  dispose() {
    this.lists = new Ts();
  }
}
let ZZ = 0;
class QZ {
  constructor() {
    this.id = ZZ++, this.color = !0, this.clearColor = !0, this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 }, this.depth = !0, this.clearDepth = !0, this.clearDepthValue = 1, this.stencil = !1, this.clearStencil = !0, this.clearStencilValue = 1, this.viewport = !1, this.viewportValue = new Kt(), this.scissor = !1, this.scissorValue = new Kt(), this.textures = null, this.depthTexture = null, this.activeCubeFace = 0, this.sampleCount = 1, this.width = 0, this.height = 0, this.isRenderContext = !0;
  }
  getCacheKey() {
    return YP(this);
  }
}
function YP(r) {
  const { textures: e, activeCubeFace: i } = r, n = [i];
  for (const s of e)
    n.push(s.id);
  return L3(n);
}
class $Z {
  constructor() {
    this.chainMaps = {};
  }
  get(e, i, n = null) {
    const s = [e, i];
    let a;
    if (n === null)
      a = "default";
    else {
      const u = n.texture.format;
      a = `${n.textures.length}:${u}:${n.samples}:${n.depthBuffer}:${n.stencilBuffer}`;
    }
    const o = this.getChainMap(a);
    let l = o.get(s);
    return l === void 0 && (l = new QZ(), o.set(s, l)), n !== null && (l.sampleCount = n.samples === 0 ? 1 : n.samples), l;
  }
  getChainMap(e) {
    return this.chainMaps[e] || (this.chainMaps[e] = new Ts());
  }
  dispose() {
    this.chainMaps = {};
  }
}
const JZ = /* @__PURE__ */ new ue();
class eQ extends To {
  constructor(e, i, n) {
    super(), this.renderer = e, this.backend = i, this.info = n;
  }
  updateRenderTarget(e, i = 0) {
    const n = this.get(e), s = e.samples === 0 ? 1 : e.samples, a = n.depthTextureMips || (n.depthTextureMips = {}), o = e.textures, l = this.getSize(o[0]), u = l.width >> i, c = l.height >> i;
    let h = e.depthTexture || a[i];
    const d = e.depthBuffer === !0 || e.stencilBuffer === !0;
    let p = !1;
    h === void 0 && d && (h = new Vc(), h.format = e.stencilBuffer ? Tc : gl, h.type = e.stencilBuffer ? Kd : er, h.image.width = u, h.image.height = c, a[i] = h), (n.width !== l.width || l.height !== n.height) && (p = !0, h && (h.needsUpdate = !0, h.image.width = u, h.image.height = c)), n.width = l.width, n.height = l.height, n.textures = o, n.depthTexture = h || null, n.depth = e.depthBuffer, n.stencil = e.stencilBuffer, n.renderTarget = e, n.sampleCount !== s && (p = !0, h && (h.needsUpdate = !0), n.sampleCount = s);
    const f = { sampleCount: s };
    for (let m = 0; m < o.length; m++) {
      const y = o[m];
      p && (y.needsUpdate = !0), this.updateTexture(y, f);
    }
    if (h && this.updateTexture(h, f), n.initialized !== !0) {
      n.initialized = !0;
      const m = () => {
        e.removeEventListener("dispose", m);
        for (let y = 0; y < o.length; y++)
          this._destroyTexture(o[y]);
        h && this._destroyTexture(h), this.delete(e);
      };
      e.addEventListener("dispose", m);
    }
  }
  updateTexture(e, i = {}) {
    const n = this.get(e);
    if (n.initialized === !0 && n.version === e.version) return;
    const s = e.isRenderTargetTexture || e.isDepthTexture || e.isFramebufferTexture, a = this.backend;
    if (s && n.initialized === !0 && (a.destroySampler(e), a.destroyTexture(e)), e.isFramebufferTexture) {
      const c = this.renderer.getRenderTarget();
      c ? e.type = c.texture.type : e.type = co;
    }
    const { width: o, height: l, depth: u } = this.getSize(e);
    if (i.width = o, i.height = l, i.depth = u, i.needsMipmaps = this.needsMipmaps(e), i.levels = i.needsMipmaps ? this.getMipLevels(e, o, l) : 1, s || e.isStorageTexture === !0)
      a.createSampler(e), a.createTexture(e, i), n.generation = e.version;
    else if (n.initialized !== !0 && a.createSampler(e), e.version > 0) {
      const c = e.image;
      if (c === void 0)
        console.warn("THREE.Renderer: Texture marked for update but image is undefined.");
      else if (c.complete === !1)
        console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");
      else {
        if (e.images) {
          const h = [];
          for (const d of e.images)
            h.push(d);
          i.images = h;
        } else
          i.image = c;
        (n.isDefaultTexture === void 0 || n.isDefaultTexture === !0) && (a.createTexture(e, i), n.isDefaultTexture = !1, n.generation = e.version), e.source.dataReady === !0 && a.updateTexture(e, i), i.needsMipmaps && e.mipmaps.length === 0 && a.generateMipmaps(e);
      }
    } else
      a.createDefaultTexture(e), n.isDefaultTexture = !0, n.generation = e.version;
    if (n.initialized !== !0) {
      n.initialized = !0, n.generation = e.version, this.info.memory.textures++;
      const c = () => {
        e.removeEventListener("dispose", c), this._destroyTexture(e), this.info.memory.textures--;
      };
      e.addEventListener("dispose", c);
    }
    n.version = e.version;
  }
  getSize(e, i = JZ) {
    let n = e.images ? e.images[0] : e.image;
    return n ? (n.image !== void 0 && (n = n.image), i.width = n.width, i.height = n.height, i.depth = e.isCubeTexture ? 6 : n.depth || 1) : i.width = i.height = i.depth = 1, i;
  }
  getMipLevels(e, i, n) {
    let s;
    return e.isCompressedTexture ? s = e.mipmaps.length : s = Math.floor(Math.log2(Math.max(i, n))) + 1, s;
  }
  needsMipmaps(e) {
    return this.isEnvironmentTexture(e) || e.isCompressedTexture === !0 || e.generateMipmaps;
  }
  isEnvironmentTexture(e) {
    const i = e.mapping;
    return i === Xd || i === Yd || i === Tl || i === _c;
  }
  _destroyTexture(e) {
    this.backend.destroySampler(e), this.backend.destroyTexture(e), this.delete(e);
  }
}
class B1 extends Zt {
  constructor(e, i, n, s = 1) {
    super(e, i, n), this.a = s;
  }
  set(e, i, n, s = 1) {
    return this.a = s, super.set(e, i, n);
  }
  copy(e) {
    return e.a !== void 0 && (this.a = e.a), super.copy(e);
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
}
class tQ extends Qt {
  static get type() {
    return "ParameterNode";
  }
  constructor(e, i = null) {
    super(e, i), this.isParameterNode = !0;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
class iQ extends Mt {
  static get type() {
    return "StackNode";
  }
  constructor(e = null) {
    super(), this.nodes = [], this.outputNode = null, this.parent = e, this._currentCond = null, this.isStackNode = !0;
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : "void";
  }
  add(e) {
    return this.nodes.push(e), this;
  }
  If(e, i) {
    const n = new nm(i);
    return this._currentCond = Fr(e, n), this.add(this._currentCond);
  }
  ElseIf(e, i) {
    const n = new nm(i), s = Fr(e, n);
    return this._currentCond.elseNode = s, this._currentCond = s, this;
  }
  Else(e) {
    return this._currentCond.elseNode = new nm(e), this;
  }
  build(e, ...i) {
    const n = V3();
    Gm(this);
    for (const s of this.nodes)
      s.build(e, "void");
    return Gm(n), this.outputNode ? this.outputNode.build(e, ...i) : super.build(e, ...i);
  }
  //
  else(...e) {
    return console.warn("TSL.StackNode: .else() has been renamed to .Else()."), this.Else(...e);
  }
  elseif(...e) {
    return console.warn("TSL.StackNode: .elseif() has been renamed to .ElseIf()."), this.ElseIf(...e);
  }
}
const Q0 = /* @__PURE__ */ Ae(iQ);
new Za();
new ue();
new ue();
new ue();
new gi();
new ue(0, 0, -1);
new Kt();
new ue();
new ue();
new Kt();
new Vt();
const rQ = new jc();
Md.flipX();
rQ.depthTexture = new Vc(1, 1);
const $0 = /* @__PURE__ */ new v1(-1, 1, 1, -1, 0, 1);
class nQ extends Il {
  constructor(e = !1) {
    super();
    const i = e === !1 ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new ga([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new ga(i, 2));
  }
}
const sQ = /* @__PURE__ */ new nQ();
class KP extends El {
  constructor(e = null) {
    super(sQ, e), this.camera = $0, this.isQuadMesh = !0;
  }
  renderAsync(e) {
    return e.renderAsync(this, $0);
  }
  render(e) {
    e.render(this, $0);
  }
}
const Eh = /* @__PURE__ */ new $n(), J0 = /* @__PURE__ */ new gi();
class zr extends Mt {
  static get type() {
    return "SceneNode";
  }
  constructor(e = zr.BACKGROUND_BLURRINESS, i = null) {
    super(), this.scope = e, this.scene = i;
  }
  setup(e) {
    const i = this.scope, n = this.scene !== null ? this.scene : e.scene;
    let s;
    return i === zr.BACKGROUND_BLURRINESS ? s = bi("backgroundBlurriness", "float", n) : i === zr.BACKGROUND_INTENSITY ? s = bi("backgroundIntensity", "float", n) : i === zr.BACKGROUND_ROTATION ? s = Tt("mat4").label("backgroundRotation").setGroup(kt).onRenderUpdate(() => {
      const a = n.background;
      return a !== null && a.isTexture && a.mapping !== r1 ? (Eh.copy(n.backgroundRotation), Eh.x *= -1, Eh.y *= -1, Eh.z *= -1, J0.makeRotationFromEuler(Eh)) : J0.identity(), J0;
    }) : console.error("THREE.SceneNode: Unknown scope:", i), s;
  }
}
zr.BACKGROUND_BLURRINESS = "backgroundBlurriness";
zr.BACKGROUND_INTENSITY = "backgroundIntensity";
zr.BACKGROUND_ROTATION = "backgroundRotation";
const aQ = /* @__PURE__ */ Ge(zr, zr.BACKGROUND_BLURRINESS), q2 = /* @__PURE__ */ Ge(zr, zr.BACKGROUND_INTENSITY), oQ = /* @__PURE__ */ Ge(zr, zr.BACKGROUND_ROTATION), Bu = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
}, $i = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
}, Ji = {
  Store: "store"
}, Oi = {
  Load: "load",
  Clear: "clear"
}, ev = {
  CCW: "ccw"
}, tv = {
  None: "none",
  Front: "front",
  Back: "back"
}, Mc = {
  Uint16: "uint16",
  Uint32: "uint32"
}, Z = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
}, iv = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
}, Qo = {
  Linear: "linear",
  Nearest: "nearest"
}, vt = {
  Zero: "zero",
  One: "one",
  Src: "src",
  OneMinusSrc: "one-minus-src",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  Dst: "dst",
  OneMinusDstColor: "one-minus-dst",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  Constant: "constant",
  OneMinusConstant: "one-minus-constant"
}, Fo = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
}, X2 = {
  None: 0,
  All: 15
}, Ga = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
}, Nx = {
  Storage: "storage",
  ReadOnlyStorage: "read-only-storage"
}, Y2 = {
  WriteOnly: "write-only",
  ReadOnly: "read-only"
}, Mh = {
  Float: "float",
  UnfilterableFloat: "unfilterable-float",
  Depth: "depth",
  SInt: "sint",
  UInt: "uint"
}, K2 = {
  TwoD: "2d",
  ThreeD: "3d"
}, yn = {
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  ThreeD: "3d"
}, lQ = {
  All: "all"
}, yf = {
  Vertex: "vertex",
  Instance: "instance"
}, Px = {
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable",
  ClipDistances: "clip-distances",
  DualSourceBlending: "dual-source-blending",
  Subgroups: "subgroups"
}, uQ = /* @__PURE__ */ new Vt();
class cQ extends ip {
  static get type() {
    return "PassTextureNode";
  }
  constructor(e, i) {
    super(i), this.passNode = e, this.setUpdateMatrix(!1);
  }
  setup(e) {
    return e.object.isQuadMesh && this.passNode.build(e), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
}
class Z2 extends cQ {
  static get type() {
    return "PassMultipleTextureNode";
  }
  constructor(e, i, n = !1) {
    super(e, null), this.textureName = i, this.previousTexture = n;
  }
  updateTexture() {
    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
  }
  setup(e) {
    return this.updateTexture(), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.textureName, this.previousTexture);
  }
}
class Vg extends zi {
  static get type() {
    return "PassNode";
  }
  constructor(e, i, n, s = {}) {
    super("vec4"), this.scope = e, this.scene = i, this.camera = n, this.options = s, this._pixelRatio = 1, this._width = 1, this._height = 1;
    const a = new Vc();
    a.isRenderTargetTexture = !0, a.name = "depth";
    const o = new jc(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: pa, ...s });
    o.texture.name = "output", o.depthTexture = a, this.renderTarget = o, this.updateBeforeType = Nt.FRAME, this._textures = {
      output: o.texture,
      depth: a
    }, this._textureNodes = {}, this._linearDepthNodes = {}, this._viewZNodes = {}, this._previousTextures = {}, this._previousTextureNodes = {}, this._cameraNear = Tt(0), this._cameraFar = Tt(0), this._mrt = null, this.isPassNode = !0;
  }
  setMRT(e) {
    return this._mrt = e, this;
  }
  getMRT() {
    return this._mrt;
  }
  isGlobal() {
    return !0;
  }
  getTexture(e) {
    let i = this._textures[e];
    return i === void 0 && (i = this.renderTarget.texture.clone(), i.isRenderTargetTexture = !0, i.name = e, this._textures[e] = i, this.renderTarget.textures.push(i)), i;
  }
  getPreviousTexture(e) {
    let i = this._previousTextures[e];
    return i === void 0 && (i = this.getTexture(e).clone(), i.isRenderTargetTexture = !0, this._previousTextures[e] = i), i;
  }
  toggleTexture(e) {
    const i = this._previousTextures[e];
    if (i !== void 0) {
      const n = this._textures[e], s = this.renderTarget.textures.indexOf(n);
      this.renderTarget.textures[s] = i, this._textures[e] = i, this._previousTextures[e] = n, this._textureNodes[e].updateTexture(), this._previousTextureNodes[e].updateTexture();
    }
  }
  getTextureNode(e = "output") {
    let i = this._textureNodes[e];
    return i === void 0 && (i = De(new Z2(this, e)), i.updateTexture(), this._textureNodes[e] = i), i;
  }
  getPreviousTextureNode(e = "output") {
    let i = this._previousTextureNodes[e];
    return i === void 0 && (this._textureNodes[e] === void 0 && this.getTextureNode(e), i = De(new Z2(this, e, !0)), i.updateTexture(), this._previousTextureNodes[e] = i), i;
  }
  getViewZNode(e = "depth") {
    let i = this._viewZNodes[e];
    if (i === void 0) {
      const n = this._cameraNear, s = this._cameraFar;
      this._viewZNodes[e] = i = CP(this.getTextureNode(e), n, s);
    }
    return i;
  }
  getLinearDepthNode(e = "depth") {
    let i = this._linearDepthNodes[e];
    if (i === void 0) {
      const n = this._cameraNear, s = this._cameraFar, a = this.getViewZNode(e);
      this._linearDepthNodes[e] = i = rd(a, n, s);
    }
    return i;
  }
  setup({ renderer: e }) {
    return this.renderTarget.samples = this.options.samples === void 0 ? e.samples : this.options.samples, e.backend.isWebGLBackend === !0 && (this.renderTarget.samples = 0), this.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1, this.scope === Vg.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
  }
  updateBefore(e) {
    const { renderer: i } = e, { scene: n, camera: s } = this;
    this._pixelRatio = i.getPixelRatio();
    const a = i.getSize(uQ);
    this.setSize(a.width, a.height);
    const o = i.getRenderTarget(), l = i.getMRT();
    this._cameraNear.value = s.near, this._cameraFar.value = s.far;
    for (const u in this._previousTextures)
      this.toggleTexture(u);
    i.setRenderTarget(this.renderTarget), i.setMRT(this._mrt), i.render(n, s), i.setRenderTarget(o), i.setMRT(l);
  }
  setSize(e, i) {
    this._width = e, this._height = i;
    const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget.setSize(n, s);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget.dispose();
  }
}
Vg.COLOR = "color";
Vg.DEPTH = "depth";
const hQ = /* @__PURE__ */ Fe(([r, e]) => r.mul(e).clamp()).setLayout({
  name: "linearToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), dQ = /* @__PURE__ */ Fe(([r, e]) => (r = r.mul(e), r.div(r.add(1)).clamp())).setLayout({
  name: "reinhardToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), pQ = /* @__PURE__ */ Fe(([r, e]) => {
  r = r.mul(e), r = r.sub(4e-3).max(0);
  const i = r.mul(r.mul(6.2).add(0.5)), n = r.mul(r.mul(6.2).add(1.7)).add(0.06);
  return i.div(n).pow(2.2);
}).setLayout({
  name: "cineonToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), fQ = /* @__PURE__ */ Fe(([r]) => {
  const e = r.mul(r.add(0.0245786)).sub(90537e-9), i = r.mul(r.add(0.432951).mul(0.983729)).add(0.238081);
  return e.div(i);
}), mQ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = Rr(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  ), n = Rr(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  return r = r.mul(e).div(0.6), r = i.mul(r), r = fQ(r), r = n.mul(r), r.clamp();
}).setLayout({
  name: "acesFilmicToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), gQ = /* @__PURE__ */ Rr(be(1.6605, -0.1246, -0.0182), be(-0.5876, 1.1329, -0.1006), be(-0.0728, -83e-4, 1.1187)), yQ = /* @__PURE__ */ Rr(be(0.6274, 0.0691, 0.0164), be(0.3293, 0.9195, 0.088), be(0.0433, 0.0113, 0.8956)), vQ = /* @__PURE__ */ Fe(([r]) => {
  const e = be(r).toVar(), i = be(e.mul(e)).toVar(), n = be(i.mul(i)).toVar();
  return _e(15.5).mul(n.mul(i)).sub(Dt(40.14, n.mul(e))).add(Dt(31.96, n).sub(Dt(6.868, i.mul(e))).add(Dt(0.4298, i).add(Dt(0.1191, e).sub(232e-5))));
}), bQ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = be(r).toVar(), n = Rr(be(0.856627153315983, 0.137318972929847, 0.11189821299995), be(0.0951212405381588, 0.761241990602591, 0.0767994186031903), be(0.0482516061458583, 0.101439036467562, 0.811302368396859)), s = Rr(be(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), be(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), be(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405)), a = _e(-12.47393), o = _e(4.026069);
  return i.mulAssign(e), i.assign(yQ.mul(i)), i.assign(n.mul(i)), i.assign(Sn(i, 1e-10)), i.assign(ya(i)), i.assign(i.sub(a).div(o.sub(a))), i.assign(xa(i, 0, 1)), i.assign(vQ(i)), i.assign(s.mul(i)), i.assign(Lg(Sn(be(0), i), be(2.2))), i.assign(gQ.mul(i)), i.assign(xa(i, 0, 1)), i;
}).setLayout({
  name: "agxToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), xQ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = _e(0.76), n = _e(0.15);
  r = r.mul(e);
  const s = Td(r.r, Td(r.g, r.b)), a = Fr(s.lessThan(0.08), s.sub(Dt(6.25, s.mul(s))), 0.04);
  r.subAssign(a);
  const o = Sn(r.r, Sn(r.g, r.b));
  nr(o.lessThan(i), () => r);
  const l = an(1, i), u = an(1, l.mul(l).div(o.add(l.sub(i))));
  r.mulAssign(u.div(o));
  const c = an(1, vo(1, n.mul(o.sub(u)).add(1)));
  return li(r, be(u), c);
}).setLayout({
  name: "neutralToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
class fr extends Mt {
  static get type() {
    return "CodeNode";
  }
  constructor(e = "", i = [], n = "") {
    super("code"), this.isCodeNode = !0, this.code = e, this.language = n, this.includes = i;
  }
  isGlobal() {
    return !0;
  }
  setIncludes(e) {
    return this.includes = e, this;
  }
  getIncludes() {
    return this.includes;
  }
  generate(e) {
    const i = this.getIncludes(e);
    for (const s of i)
      s.build(e);
    const n = e.getCodeFromNode(this, this.getNodeType(e));
    return n.code = this.code, n.code;
  }
  serialize(e) {
    super.serialize(e), e.code = this.code, e.language = this.language;
  }
  deserialize(e) {
    super.deserialize(e), this.code = e.code, this.language = e.language;
  }
}
class _Q extends fr {
  static get type() {
    return "FunctionNode";
  }
  constructor(e = "", i = [], n = "") {
    super(e, i, n);
  }
  getNodeType(e) {
    return this.getNodeFunction(e).type;
  }
  getInputs(e) {
    return this.getNodeFunction(e).inputs;
  }
  getNodeFunction(e) {
    const i = e.getDataFromNode(this);
    let n = i.nodeFunction;
    return n === void 0 && (n = e.parser.parseFunction(this.code), i.nodeFunction = n), n;
  }
  generate(e, i) {
    super.generate(e);
    const n = this.getNodeFunction(e), s = n.name, a = n.type, o = e.getCodeFromNode(this, a);
    s !== "" && (o.name = s);
    const l = e.getPropertyName(o), u = this.getNodeFunction(e).getCode(l);
    return o.code = u + `
`, i === "property" ? l : e.format(`${l}()`, a, i);
  }
}
class ZP extends Mt {
  static get type() {
    return "FogNode";
  }
  constructor(e, i) {
    super("float"), this.isFogNode = !0, this.colorNode = e, this.factorNode = i;
  }
  getViewZNode(e) {
    let i;
    const n = e.context.getViewZ;
    return n !== void 0 && (i = n(this)), (i || rr.z).negate();
  }
  setup() {
    return this.factorNode;
  }
}
class TQ extends ZP {
  static get type() {
    return "FogRangeNode";
  }
  constructor(e, i, n) {
    super(e), this.isFogRangeNode = !0, this.nearNode = i, this.farNode = n;
  }
  setup(e) {
    const i = this.getViewZNode(e);
    return Ml(this.nearNode, this.farNode, i);
  }
}
const wQ = /* @__PURE__ */ Ae(TQ);
class SQ extends ZP {
  static get type() {
    return "FogExp2Node";
  }
  constructor(e, i) {
    super(e), this.isFogExp2Node = !0, this.densityNode = i;
  }
  setup(e) {
    const i = this.getViewZNode(e), n = this.densityNode;
    return n.mul(n, i, i).negate().exp().oneMinus();
  }
}
const EQ = /* @__PURE__ */ Ae(SQ);
class MQ extends Mt {
  constructor(e) {
    super(), this.scope = e;
  }
  generate(e) {
    const { scope: i } = this, { renderer: n } = e;
    n.backend.isWebGLBackend === !0 ? e.addFlowCode(`	// ${i}Barrier 
`) : e.addLineFlowCode(`${i}Barrier()`, this);
  }
}
Ae(MQ);
class Ss extends zi {
  static get type() {
    return "AtomicFunctionNode";
  }
  constructor(e, i, n, s = null) {
    super("uint"), this.method = e, this.pointerNode = i, this.valueNode = n, this.storeNode = s;
  }
  getInputType(e) {
    return this.pointerNode.getNodeType(e);
  }
  getNodeType(e) {
    return this.getInputType(e);
  }
  generate(e) {
    const i = this.method, n = this.getNodeType(e), s = this.getInputType(e), a = this.pointerNode, o = this.valueNode, l = [];
    l.push(`&${a.build(e, s)}`), l.push(o.build(e, s));
    const u = `${e.getMethod(i, n)}( ${l.join(", ")} )`;
    if (this.storeNode !== null) {
      const c = this.storeNode.build(e, s);
      e.addLineFlowCode(`${c} = ${u}`, this);
    } else
      e.addLineFlowCode(u, this);
  }
}
Ss.ATOMIC_LOAD = "atomicLoad";
Ss.ATOMIC_STORE = "atomicStore";
Ss.ATOMIC_ADD = "atomicAdd";
Ss.ATOMIC_SUB = "atomicSub";
Ss.ATOMIC_MAX = "atomicMax";
Ss.ATOMIC_MIN = "atomicMin";
Ss.ATOMIC_AND = "atomicAnd";
Ss.ATOMIC_OR = "atomicOr";
Ss.ATOMIC_XOR = "atomicXor";
Ae(Ss);
let vf;
function z1(r) {
  vf = vf || /* @__PURE__ */ new WeakMap();
  let e = vf.get(r);
  return e === void 0 && vf.set(r, e = {}), e;
}
function QP(r) {
  const e = z1(r);
  return e.position || (e.position = Tt(new ue()).setGroup(kt).onRenderUpdate((i, n) => n.value.setFromMatrixPosition(r.matrixWorld)));
}
function AQ(r) {
  const e = z1(r);
  return e.targetPosition || (e.targetPosition = Tt(new ue()).setGroup(kt).onRenderUpdate((i, n) => n.value.setFromMatrixPosition(r.target.matrixWorld)));
}
function j1(r) {
  const e = z1(r);
  return e.viewPosition || (e.viewPosition = Tt(new ue()).setGroup(kt).onRenderUpdate(({ camera: i }, n) => {
    n.value = n.value || new ue(), n.value.setFromMatrixPosition(r.matrixWorld), n.value.applyMatrix4(i.matrixWorldInverse);
  }));
}
const $P = (r) => Ma.transformDirection(QP(r).sub(AQ(r))), CQ = (r) => r.sort((e, i) => e.id - i.id), RQ = (r, e) => {
  for (const i of e)
    if (i.isAnalyticLightNode && i.light.id === r)
      return i;
  return null;
}, rv = /* @__PURE__ */ new WeakMap();
class JP extends Mt {
  static get type() {
    return "LightsNode";
  }
  constructor() {
    super("vec3"), this.totalDiffuseNode = be().toVar("totalDiffuse"), this.totalSpecularNode = be().toVar("totalSpecular"), this.outgoingLightNode = be().toVar("outgoingLight"), this._lights = [], this._lightNodes = null, this._lightNodesHash = null, this.global = !0;
  }
  getHash(e) {
    if (this._lightNodesHash === null) {
      this._lightNodes === null && this.setupLightsNode(e);
      const i = [];
      for (const n of this._lightNodes)
        i.push(n.getSelf().getHash());
      this._lightNodesHash = "lights-" + i.join(",");
    }
    return this._lightNodesHash;
  }
  analyze(e) {
    const i = e.getDataFromNode(this);
    for (const n of i.nodes)
      n.build(e);
  }
  setupLightsNode(e) {
    const i = [], n = this._lightNodes, s = CQ(this._lights), a = e.renderer.library;
    for (const o of s)
      if (o.isNode)
        i.push(De(o));
      else {
        let l = null;
        if (n !== null && (l = RQ(o.id, n)), l === null) {
          const u = a.getLightNodeClass(o.constructor);
          if (u === null) {
            console.warn(`LightsNode.setupNodeLights: Light node not found for ${o.constructor.name}`);
            continue;
          }
          let c = null;
          rv.has(o) ? c = rv.get(o) : (c = De(new u(o)), rv.set(o, c)), i.push(c);
        }
      }
    this._lightNodes = i;
  }
  setupLights(e, i) {
    for (const n of i)
      n.build(e);
  }
  setup(e) {
    this._lightNodes === null && this.setupLightsNode(e);
    const i = e.context, n = i.lightingModel;
    let s = this.outgoingLightNode;
    if (n) {
      const { _lightNodes: a, totalDiffuseNode: o, totalSpecularNode: l } = this;
      i.outgoingLight = s;
      const u = e.addStack(), c = e.getDataFromNode(this);
      c.nodes = u.nodes, n.start(i, u, e), this.setupLights(e, a), n.indirect(i, u, e);
      const { backdrop: h, backdropAlpha: d } = i, { directDiffuse: p, directSpecular: f, indirectDiffuse: m, indirectSpecular: y } = i.reflectedLight;
      let v = p.add(m);
      h !== null && (d !== null ? v = be(d.mix(v, h)) : v = be(h), i.material.transparent = !0), o.assign(v), l.assign(f.add(y)), s.assign(o.add(l)), n.finish(i, u, e), s = s.bypass(e.removeStack());
    }
    return s;
  }
  setLights(e) {
    return this._lights = e, this._lightNodes = null, this._lightNodesHash = null, this;
  }
  getLights() {
    return this._lights;
  }
  get hasLights() {
    return this._lights.length > 0;
  }
}
const NQ = Fe(({ depthTexture: r, shadowCoord: e }) => Ai(r, e.xy).compare(e.z)), PQ = Fe(({ depthTexture: r, shadowCoord: e, shadow: i }) => {
  const n = (y, v) => Ai(r, y).compare(v), s = bi("mapSize", "vec2", i).setGroup(kt), a = bi("radius", "float", i).setGroup(kt), o = We(1).div(s), l = o.x.negate().mul(a), u = o.y.negate().mul(a), c = o.x.mul(a), h = o.y.mul(a), d = l.div(2), p = u.div(2), f = c.div(2), m = h.div(2);
  return Nr(
    n(e.xy.add(We(l, u)), e.z),
    n(e.xy.add(We(0, u)), e.z),
    n(e.xy.add(We(c, u)), e.z),
    n(e.xy.add(We(d, p)), e.z),
    n(e.xy.add(We(0, p)), e.z),
    n(e.xy.add(We(f, p)), e.z),
    n(e.xy.add(We(l, 0)), e.z),
    n(e.xy.add(We(d, 0)), e.z),
    n(e.xy, e.z),
    n(e.xy.add(We(f, 0)), e.z),
    n(e.xy.add(We(c, 0)), e.z),
    n(e.xy.add(We(d, m)), e.z),
    n(e.xy.add(We(0, m)), e.z),
    n(e.xy.add(We(f, m)), e.z),
    n(e.xy.add(We(l, h)), e.z),
    n(e.xy.add(We(0, h)), e.z),
    n(e.xy.add(We(c, h)), e.z)
  ).mul(1 / 17);
}), IQ = Fe(({ depthTexture: r, shadowCoord: e, shadow: i }) => {
  const n = (h, d) => Ai(r, h).compare(d), s = bi("mapSize", "vec2", i).setGroup(kt), a = We(1).div(s), o = a.x, l = a.y, u = e.xy, c = _o(u.mul(s).add(0.5));
  return u.subAssign(c.mul(a)), Nr(
    n(u, e.z),
    n(u.add(We(o, 0)), e.z),
    n(u.add(We(0, l)), e.z),
    n(u.add(a), e.z),
    li(
      n(u.add(We(o.negate(), 0)), e.z),
      n(u.add(We(o.mul(2), 0)), e.z),
      c.x
    ),
    li(
      n(u.add(We(o.negate(), l)), e.z),
      n(u.add(We(o.mul(2), l)), e.z),
      c.x
    ),
    li(
      n(u.add(We(0, l.negate())), e.z),
      n(u.add(We(0, l.mul(2))), e.z),
      c.y
    ),
    li(
      n(u.add(We(o, l.negate())), e.z),
      n(u.add(We(o, l.mul(2))), e.z),
      c.y
    ),
    li(
      li(
        n(u.add(We(o.negate(), l.negate())), e.z),
        n(u.add(We(o.mul(2), l.negate())), e.z),
        c.x
      ),
      li(
        n(u.add(We(o.negate(), l.mul(2))), e.z),
        n(u.add(We(o.mul(2), l.mul(2))), e.z),
        c.x
      ),
      c.y
    )
  ).mul(1 / 9);
}), OQ = Fe(({ depthTexture: r, shadowCoord: e }) => {
  const i = _e(1).toVar(), n = Ai(r).uv(e.xy).rg, s = aP(e.z, n.x);
  return nr(s.notEqual(_e(1)), () => {
    const a = e.z.sub(n.x), o = Sn(0, n.y.mul(n.y));
    let l = o.div(o.add(a.mul(a)));
    l = xa(an(l, 0.3).div(0.95 - 0.3)), i.assign(xa(Sn(s, l)));
  }), i;
}), DQ = Fe(({ samples: r, radius: e, size: i, shadowPass: n }) => {
  const s = _e(0).toVar(), a = _e(0).toVar(), o = r.lessThanEqual(_e(1)).select(_e(0), _e(2).div(r.sub(1))), l = r.lessThanEqual(_e(1)).select(_e(0), _e(-1));
  ps({ start: Ei(0), end: Ei(r), type: "int", condition: "<" }, ({ i: c }) => {
    const h = l.add(_e(c).mul(o)), d = n.uv(Nr(U1.xy, We(0, h).mul(e)).div(i)).x;
    s.addAssign(d), a.addAssign(d.mul(d));
  }), s.divAssign(r), a.divAssign(r);
  const u = M1(a.sub(s.mul(s)));
  return We(s, u);
}), LQ = Fe(({ samples: r, radius: e, size: i, shadowPass: n }) => {
  const s = _e(0).toVar(), a = _e(0).toVar(), o = r.lessThanEqual(_e(1)).select(_e(0), _e(2).div(r.sub(1))), l = r.lessThanEqual(_e(1)).select(_e(0), _e(-1));
  ps({ start: Ei(0), end: Ei(r), type: "int", condition: "<" }, ({ i: c }) => {
    const h = l.add(_e(c).mul(o)), d = n.uv(Nr(U1.xy, We(h, 0).mul(e)).div(i));
    s.addAssign(d.x), a.addAssign(Nr(d.y.mul(d.y), d.x.mul(d.x)));
  }), s.divAssign(r), a.divAssign(r);
  const u = M1(a.sub(s.mul(s)));
  return We(s, u);
}), kQ = [NQ, PQ, IQ, OQ];
let xu = null;
const bf = /* @__PURE__ */ new KP();
class UQ extends Mt {
  static get type() {
    return "ShadowNode";
  }
  constructor(e, i = null) {
    super(), this.light = e, this.shadow = i || e.shadow, this.shadowMap = null, this.vsmShadowMapVertical = null, this.vsmShadowMapHorizontal = null, this.vsmMaterialVertical = null, this.vsmMaterialHorizontal = null, this.updateBeforeType = Nt.RENDER, this._node = null, this.isShadowNode = !0;
  }
  setupShadow(e) {
    const { object: i, renderer: n } = e;
    xu === null && (xu = new Bi(), xu.fragmentNode = _t(0, 0, 0, 1), xu.isShadowNodeMaterial = !0, xu.name = "ShadowMaterial");
    const s = this.shadow, a = n.shadowMap.type, o = new Vc(s.mapSize.width, s.mapSize.height);
    o.compareFunction = u1;
    const l = e.createRenderTarget(s.mapSize.width, s.mapSize.height);
    if (l.depthTexture = o, s.camera.updateProjectionMatrix(), a === Xp) {
      o.compareFunction = null, this.vsmShadowMapVertical = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: gd, type: pa }), this.vsmShadowMapHorizontal = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: gd, type: pa });
      const _ = Ai(o), x = Ai(this.vsmShadowMapVertical.texture), b = bi("blurSamples", "float", s).setGroup(kt), T = bi("radius", "float", s).setGroup(kt), E = bi("mapSize", "vec2", s).setGroup(kt);
      let M = this.vsmMaterialVertical || (this.vsmMaterialVertical = new Bi());
      M.fragmentNode = DQ({ samples: b, radius: T, size: E, shadowPass: _ }).context(e.getSharedContext()), M.name = "VSMVertical", M = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new Bi()), M.fragmentNode = LQ({ samples: b, radius: T, size: E, shadowPass: x }).context(e.getSharedContext()), M.name = "VSMHorizontal";
    }
    const u = bi("intensity", "float", s).setGroup(kt), c = bi("bias", "float", s).setGroup(kt), h = bi("normalBias", "float", s).setGroup(kt), d = i.material.shadowPositionNode || Tx;
    let p = Tt(s.matrix).setGroup(kt).mul(d.add(I1.mul(h))), f;
    if (s.camera.isOrthographicCamera || n.logarithmicDepthBuffer !== !0)
      p = p.xyz.div(p.w), f = p.z, n.coordinateSystem === Sl && (f = f.mul(2).sub(1));
    else {
      const _ = p.w;
      p = p.xy.div(_);
      const x = Tt("float").onRenderUpdate(() => s.camera.near), b = Tt("float").onRenderUpdate(() => s.camera.far);
      f = RP(_, x, b);
    }
    p = be(
      p.x,
      p.y.oneMinus(),
      // follow webgpu standards
      f.add(c)
    );
    const m = p.x.greaterThanEqual(0).and(p.x.lessThanEqual(1)).and(p.y.greaterThanEqual(0)).and(p.y.lessThanEqual(1)).and(p.z.lessThanEqual(1)), y = s.filterNode || kQ[n.shadowMap.type] || null;
    if (y === null)
      throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
    const v = Ai(l.texture, p), g = m.select(y({ depthTexture: a === Xp ? this.vsmShadowMapHorizontal.texture : o, shadowCoord: p, shadow: s }), _e(1));
    return this.shadowMap = l, this.shadow.map = l, li(1, g.rgb.mix(v, 1), u.mul(v.a));
  }
  setup(e) {
    if (e.renderer.shadowMap.enabled !== !1)
      return this._node !== null ? this._node : this._node = this.setupShadow(e);
  }
  updateShadow(e) {
    const { shadowMap: i, light: n, shadow: s } = this, { renderer: a, scene: o, camera: l } = e, u = a.shadowMap.type, c = i.depthTexture.version;
    this._depthVersionCached = c;
    const h = o.overrideMaterial;
    o.overrideMaterial = xu, i.setSize(s.mapSize.width, s.mapSize.height), s.updateMatrices(n), s.camera.layers.mask = l.layers.mask;
    const d = a.getRenderTarget(), p = a.getRenderObjectFunction();
    a.setRenderObjectFunction((f, ...m) => {
      (f.castShadow === !0 || f.receiveShadow && u === Xp) && a.renderObject(f, ...m);
    }), a.setRenderTarget(i), a.render(o, s.camera), a.setRenderObjectFunction(p), n.isPointLight !== !0 && u === Xp && this.vsmPass(a), a.setRenderTarget(d), o.overrideMaterial = h;
  }
  vsmPass(e) {
    const { shadow: i } = this;
    this.vsmShadowMapVertical.setSize(i.mapSize.width, i.mapSize.height), this.vsmShadowMapHorizontal.setSize(i.mapSize.width, i.mapSize.height), e.setRenderTarget(this.vsmShadowMapVertical), bf.material = this.vsmMaterialVertical, bf.render(e), e.setRenderTarget(this.vsmShadowMapHorizontal), bf.material = this.vsmMaterialHorizontal, bf.render(e);
  }
  dispose() {
    this.shadowMap.dispose(), this.shadowMap = null, this.vsmShadowMapVertical !== null && (this.vsmShadowMapVertical.dispose(), this.vsmShadowMapVertical = null, this.vsmMaterialVertical.dispose(), this.vsmMaterialVertical = null), this.vsmShadowMapHorizontal !== null && (this.vsmShadowMapHorizontal.dispose(), this.vsmShadowMapHorizontal = null, this.vsmMaterialHorizontal.dispose(), this.vsmMaterialHorizontal = null), this.updateBeforeType = Nt.NONE;
  }
  updateBefore(e) {
    const { shadow: i } = this;
    (i.needsUpdate || i.autoUpdate) && (this.updateShadow(e), this.shadowMap.depthTexture.version === this._depthVersionCached && (i.needsUpdate = !1));
  }
}
const FQ = (r, e) => De(new UQ(r, e));
class Dl extends Hc {
  static get type() {
    return "AnalyticLightNode";
  }
  constructor(e = null) {
    super(), this.updateType = Nt.FRAME, this.light = e, this.color = new Zt(), this.colorNode = Tt(this.color).setGroup(kt), this.baseColorNode = null, this.shadowNode = null, this.shadowColorNode = null, this.isAnalyticLightNode = !0;
  }
  getCacheKey() {
    return zm(super.getCacheKey(), this.light.id, this.light.castShadow ? 1 : 0);
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(e) {
    const { renderer: i } = e;
    if (i.shadowMap.enabled === !1) return;
    let n = this.shadowColorNode;
    if (n === null) {
      const s = this.light.shadow.shadowNode;
      let a;
      s !== void 0 ? a = De(s) : a = FQ(this.light), this.shadowNode = a, this.shadowColorNode = n = this.colorNode.mul(a), this.baseColorNode = this.colorNode;
    }
    this.colorNode = n;
  }
  setup(e) {
    this.colorNode = this.baseColorNode || this.colorNode, this.light.castShadow ? e.object.receiveShadow && this.setupShadow(e) : this.shadowNode !== null && this.shadowNode.dispose();
  }
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
const eI = /* @__PURE__ */ Fe((r) => {
  const { lightDistance: e, cutoffDistance: i, decayExponent: n } = r, s = e.pow(n).max(0.01).reciprocal();
  return i.greaterThan(0).select(
    s.mul(e.div(i).pow4().oneMinus().clamp().pow2()),
    s
  );
}), BQ = Fe(({ color: r, lightViewPosition: e, cutoffDistance: i, decayExponent: n }, s) => {
  const a = s.context.lightingModel, o = e.sub(rr), l = o.normalize(), u = o.length(), c = eI({
    lightDistance: u,
    cutoffDistance: i,
    decayExponent: n
  }), h = r.mul(c), d = s.context.reflectedLight;
  a.direct({
    lightDirection: l,
    lightColor: h,
    reflectedLight: d
  }, s.stack, s);
});
class zQ extends Dl {
  static get type() {
    return "PointLightNode";
  }
  constructor(e = null) {
    super(e), this.cutoffDistanceNode = Tt(0).setGroup(kt), this.decayExponentNode = Tt(0).setGroup(kt);
  }
  update(e) {
    const { light: i } = this;
    super.update(e), this.cutoffDistanceNode.value = i.distance, this.decayExponentNode.value = i.decay;
  }
  setup() {
    BQ({
      color: this.colorNode,
      lightViewPosition: j1(this.light),
      cutoffDistance: this.cutoffDistanceNode,
      decayExponent: this.decayExponentNode
    }).append();
  }
}
const jQ = /* @__PURE__ */ Fe(([r, e]) => {
  const i = r.x, n = r.y, s = r.z;
  let a = e.element(0).mul(0.886227);
  return a = a.add(e.element(1).mul(2 * 0.511664).mul(n)), a = a.add(e.element(2).mul(2 * 0.511664).mul(s)), a = a.add(e.element(3).mul(2 * 0.511664).mul(i)), a = a.add(e.element(4).mul(2 * 0.429043).mul(i).mul(n)), a = a.add(e.element(5).mul(2 * 0.429043).mul(n).mul(s)), a = a.add(e.element(6).mul(s.mul(s).mul(0.743125).sub(0.247708))), a = a.add(e.element(7).mul(2 * 0.429043).mul(i).mul(s)), a = a.add(e.element(8).mul(0.429043).mul(Dt(i, i).sub(Dt(n, n)))), a;
}), Fs = /* @__PURE__ */ new B1();
class VQ extends To {
  constructor(e, i) {
    super(), this.renderer = e, this.nodes = i;
  }
  update(e, i, n) {
    const s = this.renderer, a = this.nodes.getBackgroundNode(e) || e.background;
    let o = !1;
    if (a === null)
      s._clearColor.getRGB(Fs, ho), Fs.a = s._clearColor.a;
    else if (a.isColor === !0)
      a.getRGB(Fs, ho), Fs.a = 1, o = !0;
    else if (a.isNode === !0) {
      const l = this.get(e), u = a;
      Fs.copy(s._clearColor);
      let c = l.backgroundMesh;
      if (c === void 0) {
        const d = R1(_t(u).mul(q2), {
          // @TODO: Add Texture2D support using node context
          getUV: () => oQ.mul(vP),
          getTextureLevel: () => aQ
        });
        let p = wx();
        p = p.setZ(p.w);
        const f = new Bi();
        f.name = "Background.material", f.side = Qn, f.depthTest = !1, f.depthWrite = !1, f.fog = !1, f.lights = !1, f.vertexNode = p, f.colorNode = d, l.backgroundMeshNode = d, l.backgroundMesh = c = new El(new m1(1, 32, 32), f), c.frustumCulled = !1, c.name = "Background.mesh", c.onBeforeRender = function(m, y, v) {
          this.matrixWorld.copyPosition(v.matrixWorld);
        };
      }
      const h = u.getCacheKey();
      l.backgroundCacheKey !== h && (l.backgroundMeshNode.node = _t(u).mul(q2), l.backgroundMeshNode.needsUpdate = !0, c.material.needsUpdate = !0, l.backgroundCacheKey = h), i.unshift(c, c.geometry, c.material, 0, 0, null);
    } else
      console.error("THREE.Renderer: Unsupported background configuration.", a);
    if (s.autoClear === !0 || o === !0) {
      const l = n.clearColorValue;
      l.r = Fs.r, l.g = Fs.g, l.b = Fs.b, l.a = Fs.a, (s.backend.isWebGLBackend === !0 || s.alpha === !0) && (l.r *= l.a, l.g *= l.a, l.b *= l.a), n.depthClearValue = s._clearDepth, n.stencilClearValue = s._clearStencil, n.clearColor = s.autoClearColor === !0, n.clearDepth = s.autoClearDepth === !0, n.clearStencil = s.autoClearStencil === !0;
    } else
      n.clearColor = !1, n.clearDepth = !1, n.clearStencil = !1;
  }
}
let GQ = 0;
class Ix {
  constructor(e = "", i = [], n = 0, s = []) {
    this.name = e, this.bindings = i, this.index = n, this.bindingsReference = s, this.id = GQ++;
  }
}
class HQ {
  constructor(e, i, n, s, a, o, l, u, c, h = []) {
    this.vertexShader = e, this.fragmentShader = i, this.computeShader = n, this.transforms = h, this.nodeAttributes = s, this.bindings = a, this.updateNodes = o, this.updateBeforeNodes = l, this.updateAfterNodes = u, this.monitor = c, this.usedTimes = 0;
  }
  createBindings() {
    const e = [];
    for (const i of this.bindings)
      if (i.bindings[0].groupNode.shared !== !0) {
        const n = new Ix(i.name, [], i.index, i);
        e.push(n);
        for (const s of i.bindings)
          n.bindings.push(s.clone());
      } else
        e.push(i);
    return e;
  }
}
class Q2 {
  constructor(e, i, n = null) {
    this.isNodeAttribute = !0, this.name = e, this.type = i, this.node = n;
  }
}
class WQ {
  constructor(e, i, n) {
    this.isNodeUniform = !0, this.name = e, this.type = i, this.node = n.getSelf();
  }
  get value() {
    return this.node.value;
  }
  set value(e) {
    this.node.value = e;
  }
  get id() {
    return this.node.id;
  }
  get groupNode() {
    return this.node.groupNode;
  }
}
class tI {
  constructor(e, i) {
    this.isNodeVar = !0, this.name = e, this.type = i;
  }
}
class qQ extends tI {
  constructor(e, i) {
    super(e, i), this.needsInterpolation = !1, this.isNodeVarying = !0;
  }
}
class XQ {
  constructor(e, i, n = "") {
    this.name = e, this.type = i, this.code = n, Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
}
let YQ = 0;
class nv {
  constructor(e = null) {
    this.id = YQ++, this.nodesData = /* @__PURE__ */ new WeakMap(), this.parent = e;
  }
  getData(e) {
    let i = this.nodesData.get(e);
    return i === void 0 && this.parent !== null && (i = this.parent.getData(e)), i;
  }
  setData(e, i) {
    this.nodesData.set(e, i);
  }
}
class Ll {
  constructor(e, i) {
    this.name = e, this.value = i, this.boundary = 0, this.itemSize = 0, this.offset = 0;
  }
  setValue(e) {
    this.value = e;
  }
  getValue() {
    return this.value;
  }
}
class KQ extends Ll {
  constructor(e, i = 0) {
    super(e, i), this.isNumberUniform = !0, this.boundary = 4, this.itemSize = 1;
  }
}
class ZQ extends Ll {
  constructor(e, i = new Vt()) {
    super(e, i), this.isVector2Uniform = !0, this.boundary = 8, this.itemSize = 2;
  }
}
class QQ extends Ll {
  constructor(e, i = new ue()) {
    super(e, i), this.isVector3Uniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class $Q extends Ll {
  constructor(e, i = new Kt()) {
    super(e, i), this.isVector4Uniform = !0, this.boundary = 16, this.itemSize = 4;
  }
}
class JQ extends Ll {
  constructor(e, i = new Zt()) {
    super(e, i), this.isColorUniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class e$ extends Ll {
  constructor(e, i = new Xr()) {
    super(e, i), this.isMatrix3Uniform = !0, this.boundary = 48, this.itemSize = 12;
  }
}
class t$ extends Ll {
  constructor(e, i = new gi()) {
    super(e, i), this.isMatrix4Uniform = !0, this.boundary = 64, this.itemSize = 16;
  }
}
class i$ extends KQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class r$ extends ZQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class n$ extends QQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class s$ extends $Q {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class a$ extends JQ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class o$ extends e$ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class l$ extends t$ {
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
const zu = 4, $2 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], $o = 20, sv = /* @__PURE__ */ new v1(-1, 1, 1, -1, 0, 1), u$ = /* @__PURE__ */ new Ys(90, 1), J2 = /* @__PURE__ */ new Zt();
let av = null, ov = 0, lv = 0;
const Ho = (1 + Math.sqrt(5)) / 2, _u = 1 / Ho, eM = [
  /* @__PURE__ */ new ue(-Ho, _u, 0),
  /* @__PURE__ */ new ue(Ho, _u, 0),
  /* @__PURE__ */ new ue(-_u, 0, Ho),
  /* @__PURE__ */ new ue(_u, 0, Ho),
  /* @__PURE__ */ new ue(0, Ho, -_u),
  /* @__PURE__ */ new ue(0, Ho, _u),
  /* @__PURE__ */ new ue(-1, 1, -1),
  /* @__PURE__ */ new ue(1, 1, -1),
  /* @__PURE__ */ new ue(-1, 1, 1),
  /* @__PURE__ */ new ue(1, 1, 1)
], c$ = [
  3,
  1,
  5,
  0,
  4,
  2
], uv = tZ(Ug(), _a("faceIndex")).normalize(), V1 = be(uv.x, uv.y.negate(), uv.z);
class h$ {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._lodMeshes = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._backgroundBox = null;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, i = 0, n = 0.1, s = 100) {
    av = this._renderer.getRenderTarget(), ov = this._renderer.getActiveCubeFace(), lv = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const a = this._allocateTargets();
    return a.depthBuffer = !0, this._sceneToCubeUV(e, n, s, a), i > 0 && this._blur(a, 0, 0, i), this._applyPMREM(a), this._cleanup(a), a;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, i = null) {
    return this._fromTexture(e, i);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, i = null) {
    return this._fromTexture(e, i);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  async compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = iM(), await this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  async compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = rM(), await this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose(), this._backgroundBox !== null && (this._backgroundBox.geometry.dispose(), this._backgroundBox.material.dispose());
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(av, ov, lv), e.scissorTest = !1, xf(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, i) {
    e.mapping === Tl || e.mapping === _c ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), av = this._renderer.getRenderTarget(), ov = this._renderer.getActiveCubeFace(), lv = this._renderer.getActiveMipmapLevel();
    const n = i || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), i = 4 * this._cubeSize, n = {
      magFilter: ln,
      minFilter: ln,
      generateMipmaps: !1,
      type: pa,
      format: Bc,
      colorSpace: ho
      //depthBuffer: false
    }, s = tM(e, i, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== i) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = tM(e, i, n);
      const { _lodMax: a } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = d$(a)), this._blurMaterial = p$(a, e, i);
    }
    return s;
  }
  async _compileMaterial(e) {
    const i = new El(this._lodPlanes[0], e);
    await this._renderer.compile(i, sv);
  }
  _sceneToCubeUV(e, i, n, s) {
    const a = u$;
    a.near = i, a.far = n;
    const o = [-1, 1, -1, -1, -1, -1], l = [1, 1, 1, -1, -1, -1], u = this._renderer, c = u.autoClear;
    u.getClearColor(J2), u.autoClear = !1;
    let h = this._backgroundBox;
    if (h === null) {
      const f = new Pg({
        name: "PMREM.Background",
        side: Qn,
        depthWrite: !1,
        depthTest: !1
      });
      h = new El(new $d(), f);
    }
    let d = !1;
    const p = e.background;
    p ? p.isColor && (h.material.color.copy(p), e.background = null, d = !0) : (h.material.color.copy(J2), d = !0), u.setRenderTarget(s), u.clear(), d && u.render(h, a);
    for (let f = 0; f < 6; f++) {
      const m = f % 3;
      m === 0 ? (a.up.set(0, o[f], 0), a.lookAt(l[f], 0, 0)) : m === 1 ? (a.up.set(0, 0, o[f]), a.lookAt(0, l[f], 0)) : (a.up.set(0, o[f], 0), a.lookAt(0, 0, l[f]));
      const y = this._cubeSize;
      xf(s, m * y, f > 2 ? y : 0, y, y), u.render(e, a);
    }
    u.autoClear = c, e.background = p;
  }
  _textureToCubeUV(e, i) {
    const n = this._renderer, s = e.mapping === Tl || e.mapping === _c;
    s ? this._cubemapMaterial === null && (this._cubemapMaterial = iM(e)) : this._equirectMaterial === null && (this._equirectMaterial = rM(e));
    const a = s ? this._cubemapMaterial : this._equirectMaterial;
    a.fragmentNode.value = e;
    const o = this._lodMeshes[0];
    o.material = a;
    const l = this._cubeSize;
    xf(i, 0, 0, 3 * l, 2 * l), n.setRenderTarget(i), n.render(o, sv);
  }
  _applyPMREM(e) {
    const i = this._renderer, n = i.autoClear;
    i.autoClear = !1;
    const s = this._lodPlanes.length;
    for (let a = 1; a < s; a++) {
      const o = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1]), l = eM[(s - a - 1) % eM.length];
      this._blur(e, a - 1, a, o, l);
    }
    i.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, i, n, s, a) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      i,
      n,
      s,
      "latitudinal",
      a
    ), this._halfBlur(
      o,
      e,
      n,
      n,
      s,
      "longitudinal",
      a
    );
  }
  _halfBlur(e, i, n, s, a, o, l) {
    const u = this._renderer, c = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const h = 3, d = this._lodMeshes[s];
    d.material = c;
    const p = c.uniforms, f = this._sizeLods[n] - 1, m = isFinite(a) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * $o - 1), y = a / m, v = isFinite(a) ? 1 + Math.floor(h * y) : $o;
    v > $o && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${$o}`);
    const g = [];
    let _ = 0;
    for (let M = 0; M < $o; ++M) {
      const C = M / y, S = Math.exp(-C * C / 2);
      g.push(S), M === 0 ? _ += S : M < v && (_ += 2 * S);
    }
    for (let M = 0; M < g.length; M++)
      g[M] = g[M] / _;
    e.texture.frame = (e.texture.frame || 0) + 1, p.envMap.value = e.texture, p.samples.value = v, p.weights.array = g, p.latitudinal.value = o === "latitudinal" ? 1 : 0, l && (p.poleAxis.value = l);
    const { _lodMax: x } = this;
    p.dTheta.value = m, p.mipInt.value = x - n;
    const b = this._sizeLods[s], T = 3 * b * (s > x - zu ? s - x + zu : 0), E = 4 * (this._cubeSize - b);
    xf(i, T, E, 3 * b, 2 * b), u.setRenderTarget(i), u.render(d, sv);
  }
}
function d$(r) {
  const e = [], i = [], n = [], s = [];
  let a = r;
  const o = r - zu + 1 + $2.length;
  for (let l = 0; l < o; l++) {
    const u = Math.pow(2, a);
    i.push(u);
    let c = 1 / u;
    l > r - zu ? c = $2[l - r + zu - 1] : l === 0 && (c = 0), n.push(c);
    const h = 1 / (u - 2), d = -h, p = 1 + h, f = [d, d, p, d, p, p, d, d, p, p, d, p], m = 6, y = 6, v = 3, g = 2, _ = 1, x = new Float32Array(v * y * m), b = new Float32Array(g * y * m), T = new Float32Array(_ * y * m);
    for (let M = 0; M < m; M++) {
      const C = M % 3 * 2 / 3 - 1, S = M > 2 ? 0 : -1, w = [
        C,
        S,
        0,
        C + 2 / 3,
        S,
        0,
        C + 2 / 3,
        S + 1,
        0,
        C,
        S,
        0,
        C + 2 / 3,
        S + 1,
        0,
        C,
        S + 1,
        0
      ], R = c$[M];
      x.set(w, v * y * R), b.set(f, g * y * R);
      const O = [R, R, R, R, R, R];
      T.set(O, _ * y * R);
    }
    const E = new Il();
    E.setAttribute("position", new Tn(x, v)), E.setAttribute("uv", new Tn(b, g)), E.setAttribute("faceIndex", new Tn(T, _)), e.push(E), s.push(new El(E, null)), a > zu && a--;
  }
  return { lodPlanes: e, sizeLods: i, sigmas: n, lodMeshes: s };
}
function tM(r, e, i) {
  const n = new jc(r, e, i);
  return n.texture.mapping = Zb, n.texture.name = "PMREM.cubeUv", n.texture.isPMREMTexture = !0, n.scissorTest = !0, n;
}
function xf(r, e, i, n, s) {
  r.viewport.set(e, i, n, s), r.scissor.set(e, i, n, s);
}
function G1(r) {
  const e = new Bi();
  return e.depthTest = !1, e.depthWrite = !1, e.blending = xc, e.name = `PMREM_${r}`, e;
}
function p$(r, e, i) {
  const n = Ed(new Array($o).fill(0)), s = Tt(new ue(0, 1, 0)), a = Tt(0), o = _e($o), l = Tt(0), u = Tt(1), c = Ai(null), h = Tt(0), d = _e(1 / e), p = _e(1 / i), f = _e(r), m = {
    n: o,
    latitudinal: l,
    weights: n,
    poleAxis: s,
    outputDirection: V1,
    dTheta: a,
    samples: u,
    envMap: c,
    mipInt: h,
    CUBEUV_TEXEL_WIDTH: d,
    CUBEUV_TEXEL_HEIGHT: p,
    CUBEUV_MAX_MIP: f
  }, y = G1("blur");
  return y.uniforms = m, y.fragmentNode = rZ({ ...m, latitudinal: l.equal(1) }), y;
}
function iM(r) {
  const e = G1("cubemap");
  return e.fragmentNode = Sd(r, V1), e;
}
function rM(r) {
  const e = G1("equirect");
  return e.fragmentNode = Ai(r, IP(V1), 0), e;
}
const nM = /* @__PURE__ */ new WeakMap(), f$ = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]), m$ = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]), _f = (r) => /e/g.test(r) ? String(r).replace(/\+/g, "") : (r = Number(r), r + (r % 1 ? "" : ".0"));
class iI {
  constructor(e, i, n) {
    this.object = e, this.material = e && e.material || null, this.geometry = e && e.geometry || null, this.renderer = i, this.parser = n, this.scene = null, this.camera = null, this.nodes = [], this.sequentialNodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.updateAfterNodes = [], this.hashNodes = {}, this.monitor = null, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.clippingContext = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = { vertex: [], fragment: [], compute: [] }, this.flowCode = { vertex: "", fragment: "", compute: "" }, this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }, this.structs = { vertex: [], fragment: [], compute: [], index: 0 }, this.bindings = { vertex: {}, fragment: {}, compute: {} }, this.bindingsIndexes = {}, this.bindGroups = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.codes = {}, this.vars = {}, this.flow = { code: "" }, this.chaining = [], this.stack = Q0(), this.stacks = [], this.tab = "	", this.currentFunctionNode = null, this.context = {
      material: this.material
    }, this.cache = new nv(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null, this.useComparisonMethod = !1;
  }
  getBindGroupsCache() {
    let e = nM.get(this.renderer);
    return e === void 0 && (e = new Ts(), nM.set(this.renderer, e)), e;
  }
  createRenderTarget(e, i, n) {
    return new jc(e, i, n);
  }
  createCubeRenderTarget(e, i) {
    return new OP(e, i);
  }
  createPMREMGenerator() {
    return new h$(this.renderer);
  }
  includes(e) {
    return this.nodes.includes(e);
  }
  _getBindGroup(e, i) {
    const n = this.getBindGroupsCache(), s = [];
    let a = !0;
    for (const l of i)
      s.push(l), a = a && l.groupNode.shared !== !0;
    let o;
    return a ? (o = n.get(s), o === void 0 && (o = new Ix(e, s, this.bindingsIndexes[e].group, s), n.set(s, o))) : o = new Ix(e, s, this.bindingsIndexes[e].group, s), o;
  }
  getBindGroupArray(e, i) {
    const n = this.bindings[i];
    let s = n[e];
    return s === void 0 && (this.bindingsIndexes[e] === void 0 && (this.bindingsIndexes[e] = { binding: 0, group: Object.keys(this.bindingsIndexes).length }), n[e] = s = []), s;
  }
  getBindings() {
    let e = this.bindGroups;
    if (e === null) {
      const i = {}, n = this.bindings;
      for (const s of a2)
        for (const a in n[s]) {
          const o = n[s][a];
          (i[a] || (i[a] = [])).push(...o);
        }
      e = [];
      for (const s in i) {
        const a = i[s], o = this._getBindGroup(s, a);
        e.push(o);
      }
      this.bindGroups = e;
    }
    return e;
  }
  sortBindingGroups() {
    const e = this.getBindings();
    e.sort((i, n) => i.bindings[0].groupNode.order - n.bindings[0].groupNode.order);
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      this.bindingsIndexes[n.name].group = i, n.index = i;
    }
  }
  setHashNode(e, i) {
    this.hashNodes[i] = e;
  }
  addNode(e) {
    this.nodes.includes(e) === !1 && (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
  }
  addSequentialNode(e) {
    this.sequentialNodes.includes(e) === !1 && this.sequentialNodes.push(e);
  }
  buildUpdateNodes() {
    for (const e of this.nodes)
      e.getUpdateType() !== Nt.NONE && this.updateNodes.push(e.getSelf());
    for (const e of this.sequentialNodes) {
      const i = e.getUpdateBeforeType(), n = e.getUpdateAfterType();
      i !== Nt.NONE && this.updateBeforeNodes.push(e.getSelf()), n !== Nt.NONE && this.updateAfterNodes.push(e.getSelf());
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  isFilteredTexture(e) {
    return e.magFilter === ln || e.magFilter === $b || e.magFilter === Zu || e.magFilter === da || e.minFilter === ln || e.minFilter === $b || e.minFilter === Zu || e.minFilter === da;
  }
  addChain(e) {
    this.chaining.push(e);
  }
  removeChain(e) {
    if (this.chaining.pop() !== e)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  getMethod(e) {
    return e;
  }
  getNodeFromHash(e) {
    return this.hashNodes[e];
  }
  addFlow(e, i) {
    return this.flowNodes[e].push(i), i;
  }
  setContext(e) {
    this.context = e;
  }
  getContext() {
    return this.context;
  }
  getSharedContext() {
    return { ...this.context }, this.context;
  }
  setCache(e) {
    this.cache = e;
  }
  getCache() {
    return this.cache;
  }
  getCacheFromNode(e, i = !0) {
    const n = this.getDataFromNode(e);
    return n.cache === void 0 && (n.cache = new nv(i ? this.getCache() : null)), n.cache;
  }
  isAvailable() {
    return !1;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getDrawIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return !1;
  }
  increaseUsage(e) {
    const i = this.getDataFromNode(e);
    return i.usageCount = i.usageCount === void 0 ? 1 : i.usageCount + 1, i.usageCount;
  }
  generateTexture() {
    console.warn("Abstract function.");
  }
  generateTextureLod() {
    console.warn("Abstract function.");
  }
  generateConst(e, i = null) {
    if (i === null && (e === "float" || e === "int" || e === "uint" ? i = 0 : e === "bool" ? i = !1 : e === "color" ? i = new Zt() : e === "vec2" ? i = new Vt() : e === "vec3" ? i = new ue() : e === "vec4" && (i = new Kt())), e === "float") return _f(i);
    if (e === "int") return `${Math.round(i)}`;
    if (e === "uint") return i >= 0 ? `${Math.round(i)}u` : "0u";
    if (e === "bool") return i ? "true" : "false";
    if (e === "color") return `${this.getType("vec3")}( ${_f(i.r)}, ${_f(i.g)}, ${_f(i.b)} )`;
    const n = this.getTypeLength(e), s = this.getComponentType(e), a = (o) => this.generateConst(s, o);
    if (n === 2)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)} )`;
    if (n === 3)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)}, ${a(i.z)} )`;
    if (n === 4)
      return `${this.getType(e)}( ${a(i.x)}, ${a(i.y)}, ${a(i.z)}, ${a(i.w)} )`;
    if (n > 4 && i && (i.isMatrix3 || i.isMatrix4))
      return `${this.getType(e)}( ${i.elements.map(a).join(", ")} )`;
    if (n > 4)
      return `${this.getType(e)}()`;
    throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`);
  }
  getType(e) {
    return e === "color" ? "vec3" : e;
  }
  hasGeometryAttribute(e) {
    return this.geometry && this.geometry.getAttribute(e) !== void 0;
  }
  getAttribute(e, i) {
    const n = this.attributes;
    for (const a of n)
      if (a.name === e)
        return a;
    const s = new Q2(e, i);
    return n.push(s), s;
  }
  getPropertyName(e) {
    return e.name;
  }
  isVector(e) {
    return /vec\d/.test(e);
  }
  isMatrix(e) {
    return /mat\d/.test(e);
  }
  isReference(e) {
    return e === "void" || e === "property" || e === "sampler" || e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "depthTexture" || e === "texture3D";
  }
  needsToWorkingColorSpace() {
    return !1;
  }
  getComponentTypeFromTexture(e) {
    const i = e.type;
    if (e.isDataTexture) {
      if (i === wr) return "int";
      if (i === er) return "uint";
    }
    return "float";
  }
  getElementType(e) {
    return e === "mat2" ? "vec2" : e === "mat3" ? "vec3" : e === "mat4" ? "vec4" : this.getComponentType(e);
  }
  getComponentType(e) {
    if (e = this.getVectorType(e), e === "float" || e === "bool" || e === "int" || e === "uint") return e;
    const i = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
    return i === null ? null : i[1] === "b" ? "bool" : i[1] === "i" ? "int" : i[1] === "u" ? "uint" : "float";
  }
  getVectorType(e) {
    return e === "color" ? "vec3" : e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "texture3D" ? "vec4" : e;
  }
  getTypeFromLength(e, i = "float") {
    if (e === 1) return i;
    const n = f$.get(e);
    return (i === "float" ? "" : i[0]) + n;
  }
  getTypeFromArray(e) {
    return m$.get(e.constructor);
  }
  getTypeFromAttribute(e) {
    let i = e;
    e.isInterleavedBufferAttribute && (i = e.data);
    const n = i.array, s = e.itemSize, a = e.normalized;
    let o;
    return !(e instanceof y3) && a !== !0 && (o = this.getTypeFromArray(n)), this.getTypeFromLength(s, o);
  }
  getTypeLength(e) {
    const i = this.getVectorType(e), n = /vec([2-4])/.exec(i);
    return n !== null ? Number(n[1]) : i === "float" || i === "bool" || i === "int" || i === "uint" ? 1 : /mat2/.test(e) === !0 ? 4 : /mat3/.test(e) === !0 ? 9 : /mat4/.test(e) === !0 ? 16 : 0;
  }
  getVectorFromMatrix(e) {
    return e.replace("mat", "vec");
  }
  changeComponentType(e, i) {
    return this.getTypeFromLength(this.getTypeLength(e), i);
  }
  getIntegerType(e) {
    const i = this.getComponentType(e);
    return i === "int" || i === "uint" ? e : this.changeComponentType(e, "int");
  }
  addStack() {
    return this.stack = Q0(this.stack), this.stacks.push(V3() || this.stack), Gm(this.stack), this.stack;
  }
  removeStack() {
    const e = this.stack;
    return this.stack = e.parent, Gm(this.stacks.pop()), e;
  }
  getDataFromNode(e, i = this.shaderStage, n = null) {
    n = n === null ? e.isGlobal(this) ? this.globalCache : this.cache : n;
    let s = n.getData(e);
    return s === void 0 && (s = {}, n.setData(e, s)), s[i] === void 0 && (s[i] = {}), s[i];
  }
  getNodeProperties(e, i = "any") {
    const n = this.getDataFromNode(e, i);
    return n.properties || (n.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(e, i) {
    const n = this.getDataFromNode(e);
    let s = n.bufferAttribute;
    if (s === void 0) {
      const a = this.uniforms.index++;
      s = new Q2("nodeAttribute" + a, i, e), this.bufferAttributes.push(s), n.bufferAttribute = s;
    }
    return s;
  }
  getStructTypeFromNode(e, i = this.shaderStage) {
    const n = this.getDataFromNode(e, i);
    if (n.structType === void 0) {
      const s = this.structs.index++;
      e.name = `StructType${s}`, this.structs[i].push(e), n.structType = e;
    }
    return e;
  }
  getUniformFromNode(e, i, n = this.shaderStage, s = null) {
    const a = this.getDataFromNode(e, n, this.globalCache);
    let o = a.uniform;
    if (o === void 0) {
      const l = this.uniforms.index++;
      o = new WQ(s || "nodeUniform" + l, i, e), this.uniforms[n].push(o), a.uniform = o;
    }
    return o;
  }
  getVarFromNode(e, i = null, n = e.getNodeType(this), s = this.shaderStage) {
    const a = this.getDataFromNode(e, s);
    let o = a.variable;
    if (o === void 0) {
      const l = this.vars[s] || (this.vars[s] = []);
      i === null && (i = "nodeVar" + l.length), o = new tI(i, n), l.push(o), a.variable = o;
    }
    return o;
  }
  getVaryingFromNode(e, i = null, n = e.getNodeType(this)) {
    const s = this.getDataFromNode(e, "any");
    let a = s.varying;
    if (a === void 0) {
      const o = this.varyings, l = o.length;
      i === null && (i = "nodeVarying" + l), a = new qQ(i, n), o.push(a), s.varying = a;
    }
    return a;
  }
  getCodeFromNode(e, i, n = this.shaderStage) {
    const s = this.getDataFromNode(e);
    let a = s.code;
    if (a === void 0) {
      const o = this.codes[n] || (this.codes[n] = []), l = o.length;
      a = new XQ("nodeCode" + l, i), o.push(a), s.code = a;
    }
    return a;
  }
  addFlowCodeHierarchy(e, i) {
    const { flowCodes: n, flowCodeBlock: s } = this.getDataFromNode(e);
    let a = !0, o = i;
    for (; o; ) {
      if (s.get(o) === !0) {
        a = !1;
        break;
      }
      o = this.getDataFromNode(o).parentNodeBlock;
    }
    if (a)
      for (const l of n)
        this.addLineFlowCode(l);
  }
  addLineFlowCodeBlock(e, i, n) {
    const s = this.getDataFromNode(e), a = s.flowCodes || (s.flowCodes = []), o = s.flowCodeBlock || (s.flowCodeBlock = /* @__PURE__ */ new WeakMap());
    a.push(i), o.set(n, !0);
  }
  addLineFlowCode(e, i = null) {
    return e === "" ? this : (i !== null && this.context.nodeBlock && this.addLineFlowCodeBlock(i, e, this.context.nodeBlock), e = this.tab + e, /;\s*$/.test(e) || (e = e + `;
`), this.flow.code += e, this);
  }
  addFlowCode(e) {
    return this.flow.code += e, this;
  }
  addFlowTab() {
    return this.tab += "	", this;
  }
  removeFlowTab() {
    return this.tab = this.tab.slice(0, -1), this;
  }
  getFlowData(e) {
    return this.flowsData.get(e);
  }
  flowNode(e) {
    const i = e.getNodeType(this), n = this.flowChildNode(e, i);
    return this.flowsData.set(e, n), n;
  }
  buildFunctionNode(e) {
    const i = new _Q(), n = this.currentFunctionNode;
    return this.currentFunctionNode = i, i.code = this.buildFunctionCode(e), this.currentFunctionNode = n, i;
  }
  flowShaderNode(e) {
    const i = e.layout, n = {
      [Symbol.iterator]() {
        let o = 0;
        const l = Object.values(this);
        return {
          next: () => ({
            value: l[o],
            done: o++ >= l.length
          })
        };
      }
    };
    for (const o of i.inputs)
      n[o.name] = new tQ(o.type, o.name);
    e.layout = null;
    const s = e.call(n), a = this.flowStagesNode(s, i.type);
    return e.layout = i, a;
  }
  flowStagesNode(e, i = null) {
    const n = this.flow, s = this.vars, a = this.cache, o = this.buildStage, l = this.stack, u = {
      code: ""
    };
    this.flow = u, this.vars = {}, this.cache = new nv(), this.stack = Q0();
    for (const c of s2)
      this.setBuildStage(c), u.result = e.build(this, i);
    return u.vars = this.getVars(this.shaderStage), this.flow = n, this.vars = s, this.cache = a, this.stack = l, this.setBuildStage(o), u;
  }
  getFunctionOperator() {
    return null;
  }
  flowChildNode(e, i = null) {
    const n = this.flow, s = {
      code: ""
    };
    return this.flow = s, s.result = e.build(this, i), this.flow = n, s;
  }
  flowNodeFromShaderStage(e, i, n = null, s = null) {
    const a = this.shaderStage;
    this.setShaderStage(e);
    const o = this.flowChildNode(i, n);
    return s !== null && (o.code += `${this.tab + s} = ${o.result};
`), this.flowCode[e] = this.flowCode[e] + o.code, this.setShaderStage(a), o;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(e, i) {
    return `${this.getType(e)} ${i}`;
  }
  getVars(e) {
    let i = "";
    const n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i += `${this.getVar(s.type, s.name)}; `;
    return i;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(e) {
    const i = this.codes[e];
    let n = "";
    if (i !== void 0)
      for (const s of i)
        n += s.code + `
`;
    return n;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(e) {
    this.shaderStage = e;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(e) {
    this.buildStage = e;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    const { object: e, material: i, renderer: n } = this;
    if (i !== null) {
      let s = n.library.fromMaterial(i);
      s === null && (console.error(`NodeMaterial: Material "${i.type}" is not compatible.`), s = new Bi()), s.build(this);
    } else
      this.addFlow("compute", e);
    for (const s of s2) {
      this.setBuildStage(s), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const a of a2) {
        this.setShaderStage(a);
        const o = this.flowNodes[a];
        for (const l of o)
          s === "generate" ? this.flowNode(l) : l.build(this);
      }
    }
    return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
  }
  getNodeUniform(e, i) {
    if (i === "float" || i === "int" || i === "uint") return new i$(e);
    if (i === "vec2" || i === "ivec2" || i === "uvec2") return new r$(e);
    if (i === "vec3" || i === "ivec3" || i === "uvec3") return new n$(e);
    if (i === "vec4" || i === "ivec4" || i === "uvec4") return new s$(e);
    if (i === "color") return new a$(e);
    if (i === "mat3") return new o$(e);
    if (i === "mat4") return new l$(e);
    throw new Error(`Uniform "${i}" not declared.`);
  }
  createNodeMaterial(e = "NodeMaterial") {
    throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${e}() instead.`);
  }
  format(e, i, n) {
    if (i = this.getVectorType(i), n = this.getVectorType(n), i === n || n === null || this.isReference(n))
      return e;
    const s = this.getTypeLength(i), a = this.getTypeLength(n);
    return s === 16 && a === 9 ? `${this.getType(n)}(${e}[0].xyz, ${e}[1].xyz, ${e}[2].xyz)` : s === 9 && a === 4 ? `${this.getType(n)}(${e}[0].xy, ${e}[1].xy)` : s > 4 || a > 4 || a === 0 ? e : s === a ? `${this.getType(n)}( ${e} )` : s > a ? this.format(`${e}.${"xyz".slice(0, a)}`, this.getTypeFromLength(a, this.getComponentType(i)), n) : a === 4 && s > 1 ? `${this.getType(n)}( ${this.format(e, i, "vec3")}, 1.0 )` : s === 2 ? `${this.getType(n)}( ${this.format(e, i, "vec2")}, 0.0 )` : (s === 1 && a > 1 && i !== this.getComponentType(n) && (e = `${this.getType(this.getComponentType(n))}( ${e} )`), `${this.getType(n)}( ${e} )`);
  }
  getSignature() {
    return `// Three.js r${Rg} - Node System
`;
  }
}
class sM {
  constructor() {
    this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.startTime = null, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.updateAfterMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
  }
  _getMaps(e, i) {
    let n = e.get(i);
    return n === void 0 && (n = {
      renderMap: /* @__PURE__ */ new WeakMap(),
      frameMap: /* @__PURE__ */ new WeakMap()
    }, e.set(i, n)), n;
  }
  updateBeforeNode(e) {
    const i = e.getUpdateBeforeType(), n = e.updateReference(this);
    if (i === Nt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateBeforeMap, n);
      s.get(n) !== this.frameId && e.updateBefore(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Nt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateBeforeMap, n);
      s.get(n) !== this.renderId && e.updateBefore(this) !== !1 && s.set(n, this.renderId);
    } else i === Nt.OBJECT && e.updateBefore(this);
  }
  updateAfterNode(e) {
    const i = e.getUpdateAfterType(), n = e.updateReference(this);
    if (i === Nt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateAfterMap, n);
      s.get(n) !== this.frameId && e.updateAfter(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Nt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateAfterMap, n);
      s.get(n) !== this.renderId && e.updateAfter(this) !== !1 && s.set(n, this.renderId);
    } else i === Nt.OBJECT && e.updateAfter(this);
  }
  updateNode(e) {
    const i = e.getUpdateType(), n = e.updateReference(this);
    if (i === Nt.FRAME) {
      const { frameMap: s } = this._getMaps(this.updateMap, n);
      s.get(n) !== this.frameId && e.update(this) !== !1 && s.set(n, this.frameId);
    } else if (i === Nt.RENDER) {
      const { renderMap: s } = this._getMaps(this.updateMap, n);
      s.get(n) !== this.renderId && e.update(this) !== !1 && s.set(n, this.renderId);
    } else i === Nt.OBJECT && e.update(this);
  }
  update() {
    this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
  }
}
class H1 {
  constructor(e, i, n = null, s = "", a = !1) {
    this.type = e, this.name = i, this.count = n, this.qualifier = s, this.isConst = a;
  }
}
H1.isNodeFunctionInput = !0;
class g$ extends Dl {
  static get type() {
    return "DirectionalLightNode";
  }
  constructor(e = null) {
    super(e);
  }
  setup(e) {
    super.setup(e);
    const i = e.context.lightingModel, n = this.colorNode, s = $P(this.light), a = e.context.reflectedLight;
    i.direct({
      lightDirection: s,
      lightColor: n,
      reflectedLight: a
    }, e.stack, e);
  }
}
const cv = /* @__PURE__ */ new gi(), Tf = /* @__PURE__ */ new gi();
let Ah = null;
class y$ extends Dl {
  static get type() {
    return "RectAreaLightNode";
  }
  constructor(e = null) {
    super(e), this.halfHeight = Tt(new ue()).setGroup(kt), this.halfWidth = Tt(new ue()).setGroup(kt), this.updateType = Nt.RENDER;
  }
  update(e) {
    super.update(e);
    const { light: i } = this, n = e.camera.matrixWorldInverse;
    Tf.identity(), cv.copy(i.matrixWorld), cv.premultiply(n), Tf.extractRotation(cv), this.halfWidth.value.set(i.width * 0.5, 0, 0), this.halfHeight.value.set(0, i.height * 0.5, 0), this.halfWidth.value.applyMatrix4(Tf), this.halfHeight.value.applyMatrix4(Tf);
  }
  setup(e) {
    super.setup(e);
    let i, n;
    e.isAvailable("float32Filterable") ? (i = Ai(Ah.LTC_FLOAT_1), n = Ai(Ah.LTC_FLOAT_2)) : (i = Ai(Ah.LTC_HALF_1), n = Ai(Ah.LTC_HALF_2));
    const { colorNode: s, light: a } = this, o = e.context.lightingModel, l = j1(a), u = e.context.reflectedLight;
    o.directRectArea({
      lightColor: s,
      lightPosition: l,
      halfWidth: this.halfWidth,
      halfHeight: this.halfHeight,
      reflectedLight: u,
      ltc_1: i,
      ltc_2: n
    }, e.stack, e);
  }
  static setLTC(e) {
    Ah = e;
  }
}
class rI extends Dl {
  static get type() {
    return "SpotLightNode";
  }
  constructor(e = null) {
    super(e), this.coneCosNode = Tt(0).setGroup(kt), this.penumbraCosNode = Tt(0).setGroup(kt), this.cutoffDistanceNode = Tt(0).setGroup(kt), this.decayExponentNode = Tt(0).setGroup(kt);
  }
  update(e) {
    super.update(e);
    const { light: i } = this;
    this.coneCosNode.value = Math.cos(i.angle), this.penumbraCosNode.value = Math.cos(i.angle * (1 - i.penumbra)), this.cutoffDistanceNode.value = i.distance, this.decayExponentNode.value = i.decay;
  }
  getSpotAttenuation(e) {
    const { coneCosNode: i, penumbraCosNode: n } = this;
    return Ml(i, n, e);
  }
  setup(e) {
    super.setup(e);
    const i = e.context.lightingModel, { colorNode: n, cutoffDistanceNode: s, decayExponentNode: a, light: o } = this, l = j1(o).sub(rr), u = l.normalize(), c = u.dot($P(o)), h = this.getSpotAttenuation(c), d = l.length(), p = eI({
      lightDistance: d,
      cutoffDistance: s,
      decayExponent: a
    }), f = n.mul(h).mul(p), m = e.context.reflectedLight;
    i.direct({
      lightDirection: u,
      lightColor: f,
      reflectedLight: m
    }, e.stack, e);
  }
}
class v$ extends rI {
  static get type() {
    return "IESSpotLightNode";
  }
  getSpotAttenuation(e) {
    const i = this.light.iesMap;
    let n = null;
    if (i && i.isTexture === !0) {
      const s = e.acos().mul(1 / Math.PI);
      n = Ai(i, We(s, 0), 0).r;
    } else
      n = super.getSpotAttenuation(e);
    return n;
  }
}
class b$ extends Dl {
  static get type() {
    return "AmbientLightNode";
  }
  constructor(e = null) {
    super(e);
  }
  setup({ context: e }) {
    e.irradiance.addAssign(this.colorNode);
  }
}
class x$ extends Dl {
  static get type() {
    return "HemisphereLightNode";
  }
  constructor(e = null) {
    super(e), this.lightPositionNode = QP(e), this.lightDirectionNode = this.lightPositionNode.normalize(), this.groundColorNode = Tt(new Zt()).setGroup(kt);
  }
  update(e) {
    const { light: i } = this;
    super.update(e), this.lightPositionNode.object3d = i, this.groundColorNode.value.copy(i.groundColor).multiplyScalar(i.intensity);
  }
  setup(e) {
    const { colorNode: i, groundColorNode: n, lightDirectionNode: s } = this, a = Jn.dot(s).mul(0.5).add(0.5), o = li(n, i, a);
    e.context.irradiance.addAssign(o);
  }
}
class _$ extends Dl {
  static get type() {
    return "LightProbeNode";
  }
  constructor(e = null) {
    super(e);
    const i = [];
    for (let n = 0; n < 9; n++) i.push(new ue());
    this.lightProbe = Ed(i);
  }
  update(e) {
    const { light: i } = this;
    super.update(e);
    for (let n = 0; n < 9; n++)
      this.lightProbe.array[n].copy(i.sh.coefficients[n]).multiplyScalar(i.intensity);
  }
  setup(e) {
    const i = jQ(vP, this.lightProbe);
    e.context.irradiance.addAssign(i);
  }
}
class nI {
  parseFunction() {
    console.warn("Abstract function.");
  }
}
class W1 {
  constructor(e, i, n = "", s = "") {
    this.type = e, this.inputs = i, this.name = n, this.precision = s;
  }
  getCode() {
    console.warn("Abstract function.");
  }
}
W1.isNodeFunction = !0;
const T$ = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, w$ = /[a-z_0-9]+/ig, aM = "#pragma main", S$ = (r) => {
  r = r.trim();
  const e = r.indexOf(aM), i = e !== -1 ? r.slice(e + aM.length) : r, n = i.match(T$);
  if (n !== null && n.length === 5) {
    const s = n[4], a = [];
    let o = null;
    for (; (o = w$.exec(s)) !== null; )
      a.push(o);
    const l = [];
    let u = 0;
    for (; u < a.length; ) {
      const m = a[u][0] === "const";
      m === !0 && u++;
      let y = a[u][0];
      y === "in" || y === "out" || y === "inout" ? u++ : y = "";
      const v = a[u++][0];
      let g = Number.parseInt(a[u][0]);
      Number.isNaN(g) === !1 ? u++ : g = null;
      const _ = a[u++][0];
      l.push(new H1(v, _, g, y, m));
    }
    const c = i.substring(n[0].length), h = n[3] !== void 0 ? n[3] : "", d = n[2], p = n[1] !== void 0 ? n[1] : "", f = e !== -1 ? r.slice(0, e) : "";
    return {
      type: d,
      inputs: l,
      name: h,
      precision: p,
      inputsCode: s,
      blockCode: c,
      headerCode: f
    };
  } else
    throw new Error("FunctionNode: Function is not a GLSL code.");
};
class E$ extends W1 {
  constructor(e) {
    const { type: i, inputs: n, name: s, precision: a, inputsCode: o, blockCode: l, headerCode: u } = S$(e);
    super(i, n, s, a), this.inputsCode = o, this.blockCode = l, this.headerCode = u;
  }
  getCode(e = this.name) {
    let i;
    const n = this.blockCode;
    if (n !== "") {
      const { type: s, inputsCode: a, headerCode: o, precision: l } = this;
      let u = `${s} ${e} ( ${a.trim()} )`;
      l !== "" && (u = `${l} ${u}`), i = o + u + n;
    } else
      i = "";
    return i;
  }
}
class M$ extends nI {
  parseFunction(e) {
    return new E$(e);
  }
}
const oM = /* @__PURE__ */ new WeakMap();
class A$ extends To {
  constructor(e, i) {
    super(), this.renderer = e, this.backend = i, this.nodeFrame = new sM(), this.nodeBuilderCache = /* @__PURE__ */ new Map(), this.callHashCache = new Ts(), this.groupsData = new Ts();
  }
  updateGroup(e) {
    const i = e.groupNode, n = i.name;
    if (n === W3.name) return !0;
    if (n === kt.name) {
      const o = this.get(e), l = this.nodeFrame.renderId;
      return o.renderId !== l ? (o.renderId = l, !0) : !1;
    }
    if (n === tq.name) {
      const o = this.get(e), l = this.nodeFrame.frameId;
      return o.frameId !== l ? (o.frameId = l, !0) : !1;
    }
    const s = [i, e];
    let a = this.groupsData.get(s);
    return a === void 0 && this.groupsData.set(s, a = {}), a.version !== i.version ? (a.version = i.version, !0) : !1;
  }
  getForRenderCacheKey(e) {
    return e.initialCacheKey;
  }
  getForRender(e) {
    const i = this.get(e);
    let n = i.nodeBuilderState;
    if (n === void 0) {
      const { nodeBuilderCache: s } = this, a = this.getForRenderCacheKey(e);
      if (n = s.get(a), n === void 0) {
        const o = this.backend.createNodeBuilder(e.object, this.renderer);
        o.scene = e.scene, o.material = e.material, o.camera = e.camera, o.context.material = e.material, o.lightsNode = e.lightsNode, o.environmentNode = this.getEnvironmentNode(e.scene), o.fogNode = this.getFogNode(e.scene), o.clippingContext = e.clippingContext, o.build(), n = this._createNodeBuilderState(o), s.set(a, n);
      }
      n.usedTimes++, i.nodeBuilderState = n;
    }
    return n;
  }
  delete(e) {
    if (e.isRenderObject) {
      const i = this.get(e).nodeBuilderState;
      i.usedTimes--, i.usedTimes === 0 && this.nodeBuilderCache.delete(this.getForRenderCacheKey(e));
    }
    return super.delete(e);
  }
  getForCompute(e) {
    const i = this.get(e);
    let n = i.nodeBuilderState;
    if (n === void 0) {
      const s = this.backend.createNodeBuilder(e, this.renderer);
      s.build(), n = this._createNodeBuilderState(s), i.nodeBuilderState = n;
    }
    return n;
  }
  _createNodeBuilderState(e) {
    return new HQ(
      e.vertexShader,
      e.fragmentShader,
      e.computeShader,
      e.getAttributesArray(),
      e.getBindings(),
      e.updateNodes,
      e.updateBeforeNodes,
      e.updateAfterNodes,
      e.monitor,
      e.transforms
    );
  }
  getEnvironmentNode(e) {
    return e.environmentNode || this.get(e).environmentNode || null;
  }
  getBackgroundNode(e) {
    return e.backgroundNode || this.get(e).backgroundNode || null;
  }
  getFogNode(e) {
    return e.fogNode || this.get(e).fogNode || null;
  }
  getCacheKey(e, i) {
    const n = [e, i], s = this.renderer.info.calls;
    let a = this.callHashCache.get(n);
    if (a === void 0 || a.callId !== s) {
      const o = this.getEnvironmentNode(e), l = this.getFogNode(e), u = [];
      i && u.push(i.getCacheKey(!0)), o && u.push(o.getCacheKey()), l && u.push(l.getCacheKey()), u.push(this.renderer.shadowMap.enabled ? 1 : 0), a = {
        callId: s,
        cacheKey: L3(u)
      }, this.callHashCache.set(n, a);
    }
    return a.cacheKey;
  }
  updateScene(e) {
    this.updateEnvironment(e), this.updateFog(e), this.updateBackground(e);
  }
  get isToneMappingState() {
    return !this.renderer.getRenderTarget();
  }
  updateBackground(e) {
    const i = this.get(e), n = e.background;
    if (n) {
      const s = e.backgroundBlurriness === 0 && i.backgroundBlurriness > 0 || e.backgroundBlurriness > 0 && i.backgroundBlurriness === 0;
      if (i.background !== n || s) {
        let a = null;
        if (n.isCubeTexture === !0 || n.mapping === Xd || n.mapping === Yd || n.mapping === Zb)
          if (e.backgroundBlurriness > 0 || n.mapping === Zb)
            a = HP(n);
          else {
            let o;
            n.isCubeTexture === !0 ? o = Sd(n) : o = Ai(n), a = LP(o);
          }
        else n.isTexture === !0 ? a = Ai(n, Md.flipY()).setUpdateMatrix(!0) : n.isColor !== !0 && console.error("WebGPUNodes: Unsupported background configuration.", n);
        i.backgroundNode = a, i.background = n, i.backgroundBlurriness = e.backgroundBlurriness;
      }
    } else i.backgroundNode && (delete i.backgroundNode, delete i.background);
  }
  updateFog(e) {
    const i = this.get(e), n = e.fog;
    if (n) {
      if (i.fog !== n) {
        let s = null;
        if (n.isFogExp2) {
          const a = bi("color", "color", n).setGroup(kt), o = bi("density", "float", n).setGroup(kt);
          s = EQ(a, o);
        } else if (n.isFog) {
          const a = bi("color", "color", n).setGroup(kt), o = bi("near", "float", n).setGroup(kt), l = bi("far", "float", n).setGroup(kt);
          s = wQ(a, o, l);
        } else
          console.error("WebGPUNodes: Unsupported fog configuration.", n);
        i.fogNode = s, i.fog = n;
      }
    } else
      delete i.fogNode, delete i.fog;
  }
  updateEnvironment(e) {
    const i = this.get(e), n = e.environment;
    if (n) {
      if (i.environment !== n) {
        let s = null;
        n.isCubeTexture === !0 ? s = Sd(n) : n.isTexture === !0 ? s = Ai(n) : console.error("Nodes: Unsupported environment configuration.", n), i.environmentNode = s, i.environment = n;
      }
    } else i.environmentNode && (delete i.environmentNode, delete i.environment);
  }
  getNodeFrame(e = this.renderer, i = null, n = null, s = null, a = null) {
    const o = this.nodeFrame;
    return o.renderer = e, o.scene = i, o.object = n, o.camera = s, o.material = a, o;
  }
  getNodeFrameForRender(e) {
    return this.getNodeFrame(e.renderer, e.scene, e.object, e.camera, e.material);
  }
  getOutputCacheKey() {
    const e = this.renderer;
    return e.toneMapping + "," + e.currentColorSpace;
  }
  hasOutputChange(e) {
    return oM.get(e) !== this.getOutputCacheKey();
  }
  getOutputNode(e) {
    const i = this.renderer, n = this.getOutputCacheKey(), s = Ai(e, Md).renderOutput(i.toneMapping, i.currentColorSpace);
    return oM.set(e, n), s;
  }
  updateBefore(e) {
    const i = e.getNodeBuilderState();
    for (const n of i.updateBeforeNodes)
      this.getNodeFrameForRender(e).updateBeforeNode(n);
  }
  updateAfter(e) {
    const i = e.getNodeBuilderState();
    for (const n of i.updateAfterNodes)
      this.getNodeFrameForRender(e).updateAfterNode(n);
  }
  updateForCompute(e) {
    const i = this.getNodeFrame(), n = this.getForCompute(e);
    for (const s of n.updateNodes)
      i.updateNode(s);
  }
  updateForRender(e) {
    const i = this.getNodeFrameForRender(e), n = e.getNodeBuilderState();
    for (const s of n.updateNodes)
      i.updateNode(s);
  }
  needsRefresh(e) {
    const i = this.getNodeFrameForRender(e);
    return e.getMonitor().needsRefresh(e, i);
  }
  dispose() {
    super.dispose(), this.nodeFrame = new sM(), this.nodeBuilderCache = /* @__PURE__ */ new Map();
  }
}
class C$ {
  constructor(e, i) {
    this.scene = e, this.camera = i;
  }
  clone() {
    return Object.assign(new this.constructor(), this);
  }
}
class R$ {
  constructor() {
    this.lists = new Ts();
  }
  get(e, i) {
    const n = this.lists, s = [e, i];
    let a = n.get(s);
    return a === void 0 && (a = new C$(e, i), n.set(s, a)), a;
  }
  dispose() {
    this.lists = new Ts();
  }
}
class sI {
  constructor() {
    this.lightNodes = /* @__PURE__ */ new WeakMap(), this.materialNodes = /* @__PURE__ */ new Map(), this.toneMappingNodes = /* @__PURE__ */ new Map();
  }
  fromMaterial(e) {
    if (e.isNodeMaterial) return e;
    let i = null;
    const n = this.getMaterialNodeClass(e.type);
    if (n !== null) {
      i = new n();
      for (const s in e)
        i[s] = e[s];
    }
    return i;
  }
  addToneMapping(e, i) {
    this.addType(e, i, this.toneMappingNodes);
  }
  getToneMappingFunction(e) {
    return this.toneMappingNodes.get(e) || null;
  }
  getMaterialNodeClass(e) {
    return this.materialNodes.get(e) || null;
  }
  addMaterial(e, i) {
    this.addType(e, i.type, this.materialNodes);
  }
  getLightNodeClass(e) {
    return this.lightNodes.get(e) || null;
  }
  addLight(e, i) {
    this.addClass(e, i, this.lightNodes);
  }
  addType(e, i, n) {
    if (n.has(i)) {
      console.warn(`Redefinition of node ${i}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof i == "function" || typeof i == "object") throw new Error(`Base class ${i} is not a class.`);
    n.set(i, e);
  }
  addClass(e, i, n) {
    if (n.has(i)) {
      console.warn(`Redefinition of node ${i.name}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof i != "function") throw new Error(`Base class ${i.name} is not a class.`);
    n.set(i, e);
  }
}
const N$ = /* @__PURE__ */ new JP();
class P$ extends Ts {
  constructor() {
    super();
  }
  createNode(e = []) {
    return new JP().setLights(e);
  }
  getNode(e, i) {
    if (e.isQuadMesh) return N$;
    const n = [e, i];
    let s = this.get(n);
    return s === void 0 && (s = this.createNode(), this.set(n, s)), s;
  }
}
const lM = /* @__PURE__ */ new _3(), wf = /* @__PURE__ */ new Vt(), hv = /* @__PURE__ */ new Kt(), dv = /* @__PURE__ */ new S3(), Sf = /* @__PURE__ */ new gi(), Ha = /* @__PURE__ */ new Kt();
class I$ {
  constructor(e, i = {}) {
    this.isRenderer = !0;
    const {
      logarithmicDepthBuffer: n = !1,
      alpha: s = !0,
      depth: a = !0,
      stencil: o = !1,
      antialias: l = !1,
      samples: u = 0,
      getFallback: c = null
    } = i;
    this.domElement = e.getDomElement(), this.backend = e, this.samples = u || l === !0 ? 4 : 0, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.alpha = s, this.logarithmicDepthBuffer = n, this.outputColorSpace = ct, this.toneMapping = Ku, this.toneMappingExposure = 1, this.sortObjects = !0, this.depth = a, this.stencil = o, this.clippingPlanes = [], this.info = new jZ(), this.nodes = {
      modelViewMatrix: null,
      modelNormalViewMatrix: null
    }, this.library = new sI(), this.lighting = new P$(), this._getFallback = c, this._pixelRatio = 1, this._width = this.domElement.width, this._height = this.domElement.height, this._viewport = new Kt(0, 0, this._width, this._height), this._scissor = new Kt(0, 0, this._width, this._height), this._scissorTest = !1, this._attributes = null, this._geometries = null, this._nodes = null, this._animation = null, this._bindings = null, this._objects = null, this._pipelines = null, this._bundles = null, this._renderLists = null, this._renderContexts = null, this._textures = null, this._background = null, this._quad = new KP(new Bi()), this._quad.material.type = "Renderer_output", this._currentRenderContext = null, this._opaqueSort = null, this._transparentSort = null, this._frameBufferTarget = null;
    const h = this.alpha === !0 ? 0 : 1;
    this._clearColor = new B1(0, 0, 0, h), this._clearDepth = 1, this._clearStencil = 0, this._renderTarget = null, this._activeCubeFace = 0, this._activeMipmapLevel = 0, this._mrt = null, this._renderObjectFunction = null, this._currentRenderObjectFunction = null, this._currentRenderBundle = null, this._handleObjectFunction = this._renderObjectDirect, this._isDeviceLost = !1, this.onDeviceLost = this._onDeviceLost, this._initialized = !1, this._initPromise = null, this._compilationPromises = null, this.transparent = !0, this.opaque = !0, this.shadowMap = {
      enabled: !1,
      type: OH
    }, this.xr = {
      enabled: !1
    }, this.debug = {
      checkShaderErrors: !0,
      onShaderError: null,
      getShaderAsync: async (d, p, f) => {
        await this.compileAsync(d, p);
        const m = this._renderLists.get(d, p), y = this._renderContexts.get(d, p, this._renderTarget), v = d.overrideMaterial || f.material, g = this._objects.get(f, v, d, p, m.lightsNode, y), { fragmentShader: _, vertexShader: x } = g.getNodeBuilderState();
        return { fragmentShader: _, vertexShader: x };
      }
    };
  }
  async init() {
    if (this._initialized)
      throw new Error("Renderer: Backend has already been initialized.");
    return this._initPromise !== null ? this._initPromise : (this._initPromise = new Promise(async (e, i) => {
      let n = this.backend;
      try {
        await n.init(this);
      } catch (s) {
        if (this._getFallback !== null)
          try {
            this.backend = n = this._getFallback(s), await n.init(this);
          } catch (a) {
            i(a);
            return;
          }
        else {
          i(s);
          return;
        }
      }
      this._nodes = new A$(this, n), this._animation = new PZ(this._nodes, this.info), this._attributes = new FZ(n), this._background = new VQ(this, this._nodes), this._geometries = new zZ(this._attributes, this.info), this._textures = new eQ(this, n, this.info), this._pipelines = new WZ(n, this._nodes), this._bindings = new qZ(n, this._nodes, this._textures, this._attributes, this._pipelines, this.info), this._objects = new LZ(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info), this._renderLists = new KZ(this.lighting), this._bundles = new R$(), this._renderContexts = new $Z(), this._initialized = !0, e();
    }), this._initPromise);
  }
  get coordinateSystem() {
    return this.backend.coordinateSystem;
  }
  async compileAsync(e, i, n = null) {
    if (this._isDeviceLost === !0) return;
    this._initialized === !1 && await this.init();
    const s = this._nodes.nodeFrame, a = s.renderId, o = this._currentRenderContext, l = this._currentRenderObjectFunction, u = this._compilationPromises, c = e.isScene === !0 ? e : lM;
    n === null && (n = e);
    const h = this._renderTarget, d = this._renderContexts.get(n, i, h), p = this._activeMipmapLevel, f = [];
    this._currentRenderContext = d, this._currentRenderObjectFunction = this.renderObject, this._handleObjectFunction = this._createObjectPipeline, this._compilationPromises = f, s.renderId++, s.update(), d.depth = this.depth, d.stencil = this.stencil, d.clippingContext || (d.clippingContext = new Rx()), d.clippingContext.updateGlobal(this, i), c.onBeforeRender(this, e, i, h);
    const m = this._renderLists.get(e, i);
    if (m.begin(), this._projectObject(e, i, 0, m), n !== e && n.traverseVisible(function(_) {
      _.isLight && _.layers.test(i.layers) && m.pushLight(_);
    }), m.finish(), h !== null) {
      this._textures.updateRenderTarget(h, p);
      const _ = this._textures.get(h);
      d.textures = _.textures, d.depthTexture = _.depthTexture;
    } else
      d.textures = null, d.depthTexture = null;
    this._nodes.updateScene(c), this._background.update(c, m, d);
    const y = m.opaque, v = m.transparent, g = m.lightsNode;
    this.opaque === !0 && y.length > 0 && this._renderObjects(y, i, c, g), this.transparent === !0 && v.length > 0 && this._renderTransparents(v, i, c, g), s.renderId = a, this._currentRenderContext = o, this._currentRenderObjectFunction = l, this._compilationPromises = u, this._handleObjectFunction = this._renderObjectDirect, await Promise.all(f);
  }
  async renderAsync(e, i) {
    this._initialized === !1 && await this.init();
    const n = this._renderScene(e, i);
    await this.backend.resolveTimestampAsync(n, "render");
  }
  async waitForGPU() {
    await this.backend.waitForGPU();
  }
  setMRT(e) {
    return this._mrt = e, this;
  }
  getMRT() {
    return this._mrt;
  }
  _onDeviceLost(e) {
    let i = `THREE.WebGPURenderer: ${e.api} Device Lost:

Message: ${e.message}`;
    e.reason && (i += `
Reason: ${e.reason}`), console.error(i), this._isDeviceLost = !0;
  }
  _renderBundle(e, i, n) {
    const { bundleGroup: s, camera: a, renderList: o } = e, l = this._currentRenderContext, u = this._bundles.get(s, a), c = this.backend.get(u);
    c.renderContexts === void 0 && (c.renderContexts = /* @__PURE__ */ new Set());
    const h = s.version !== c.version, d = c.renderContexts.has(l) === !1 || h;
    if (c.renderContexts.add(l), d) {
      this.backend.beginBundle(l), (c.renderObjects === void 0 || h) && (c.renderObjects = []), this._currentRenderBundle = u;
      const p = o.opaque;
      this.opaque === !0 && p.length > 0 && this._renderObjects(p, a, i, n), this._currentRenderBundle = null, this.backend.finishBundle(l, u), c.version = s.version;
    } else {
      const { renderObjects: p } = c;
      for (let f = 0, m = p.length; f < m; f++) {
        const y = p[f];
        this._nodes.needsRefresh(y) && (this._nodes.updateBefore(y), this._nodes.updateForRender(y), this._bindings.updateForRender(y), this._nodes.updateAfter(y));
      }
    }
    this.backend.addBundle(l, u);
  }
  render(e, i) {
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."), this.renderAsync(e, i);
    this._renderScene(e, i);
  }
  _getFrameBufferTarget() {
    const { currentToneMapping: e, currentColorSpace: i } = this;
    if (e === Ku && i === ho) return null;
    const { width: n, height: s } = this.getDrawingBufferSize(wf), { depth: a, stencil: o } = this;
    let l = this._frameBufferTarget;
    return l === null && (l = new jc(n, s, {
      depthBuffer: a,
      stencilBuffer: o,
      type: pa,
      // FloatType
      format: Bc,
      colorSpace: ho,
      generateMipmaps: !1,
      minFilter: ln,
      magFilter: ln,
      samples: this.samples
    }), l.isPostProcessingRenderTarget = !0, this._frameBufferTarget = l), l.depthBuffer = a, l.stencilBuffer = o, l.setSize(n, s), l.viewport.copy(this._viewport), l.scissor.copy(this._scissor), l.viewport.multiplyScalar(this._pixelRatio), l.scissor.multiplyScalar(this._pixelRatio), l.scissorTest = this._scissorTest, l;
  }
  _renderScene(e, i, n = !0) {
    if (this._isDeviceLost === !0) return;
    const s = n ? this._getFrameBufferTarget() : null, a = this._nodes.nodeFrame, o = a.renderId, l = this._currentRenderContext, u = this._currentRenderObjectFunction, c = e.isScene === !0 ? e : lM, h = this._renderTarget, d = this._activeCubeFace, p = this._activeMipmapLevel;
    let f;
    s !== null ? (f = s, this.setRenderTarget(f)) : f = h;
    const m = this._renderContexts.get(e, i, f);
    this._currentRenderContext = m, this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject, this.info.calls++, this.info.render.calls++, this.info.render.frameCalls++, a.renderId = this.info.calls;
    const y = this.coordinateSystem;
    i.coordinateSystem !== y && (i.coordinateSystem = y, i.updateProjectionMatrix()), e.matrixWorldAutoUpdate === !0 && e.updateMatrixWorld(), i.parent === null && i.matrixWorldAutoUpdate === !0 && i.updateMatrixWorld();
    let v = this._viewport, g = this._scissor, _ = this._pixelRatio;
    f !== null && (v = f.viewport, g = f.scissor, _ = 1), this.getDrawingBufferSize(wf), hv.set(0, 0, wf.width, wf.height);
    const x = v.minDepth === void 0 ? 0 : v.minDepth, b = v.maxDepth === void 0 ? 1 : v.maxDepth;
    m.viewportValue.copy(v).multiplyScalar(_).floor(), m.viewportValue.width >>= p, m.viewportValue.height >>= p, m.viewportValue.minDepth = x, m.viewportValue.maxDepth = b, m.viewport = m.viewportValue.equals(hv) === !1, m.scissorValue.copy(g).multiplyScalar(_).floor(), m.scissor = this._scissorTest && m.scissorValue.equals(hv) === !1, m.scissorValue.width >>= p, m.scissorValue.height >>= p, m.clippingContext || (m.clippingContext = new Rx()), m.clippingContext.updateGlobal(this, i), c.onBeforeRender(this, e, i, f), Sf.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), dv.setFromProjectionMatrix(Sf, y);
    const T = this._renderLists.get(e, i);
    if (T.begin(), this._projectObject(e, i, 0, T), T.finish(), this.sortObjects === !0 && T.sort(this._opaqueSort, this._transparentSort), f !== null) {
      this._textures.updateRenderTarget(f, p);
      const R = this._textures.get(f);
      m.textures = R.textures, m.depthTexture = R.depthTexture, m.width = R.width, m.height = R.height, m.renderTarget = f, m.depth = f.depthBuffer, m.stencil = f.stencilBuffer;
    } else
      m.textures = null, m.depthTexture = null, m.width = this.domElement.width, m.height = this.domElement.height, m.depth = this.depth, m.stencil = this.stencil;
    m.width >>= p, m.height >>= p, m.activeCubeFace = d, m.activeMipmapLevel = p, m.occlusionQueryCount = T.occlusionQueryCount, this._nodes.updateScene(c), this._background.update(c, T, m), this.backend.beginRender(m);
    const {
      bundles: E,
      lightsNode: M,
      transparentDoublePass: C,
      transparent: S,
      opaque: w
    } = T;
    if (E.length > 0 && this._renderBundles(E, c, M), this.opaque === !0 && w.length > 0 && this._renderObjects(w, i, c, M), this.transparent === !0 && S.length > 0 && this._renderTransparents(S, C, i, c, M), this.backend.finishRender(m), a.renderId = o, this._currentRenderContext = l, this._currentRenderObjectFunction = u, s !== null) {
      this.setRenderTarget(h, d, p);
      const R = this._quad;
      this._nodes.hasOutputChange(f.texture) && (R.material.fragmentNode = this._nodes.getOutputNode(f.texture), R.material.needsUpdate = !0), this._renderScene(R, R.camera, !1);
    }
    return c.onAfterRender(this, e, i, f), m;
  }
  getMaxAnisotropy() {
    return this.backend.getMaxAnisotropy();
  }
  getActiveCubeFace() {
    return this._activeCubeFace;
  }
  getActiveMipmapLevel() {
    return this._activeMipmapLevel;
  }
  async setAnimationLoop(e) {
    this._initialized === !1 && await this.init(), this._animation.setAnimationLoop(e);
  }
  async getArrayBufferAsync(e) {
    return await this.backend.getArrayBufferAsync(e);
  }
  getContext() {
    return this.backend.getContext();
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  getDrawingBufferSize(e) {
    return e.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
  }
  getSize(e) {
    return e.set(this._width, this._height);
  }
  setPixelRatio(e = 1) {
    this._pixelRatio !== e && (this._pixelRatio = e, this.setSize(this._width, this._height, !1));
  }
  setDrawingBufferSize(e, i, n) {
    this._width = e, this._height = i, this._pixelRatio = n, this.domElement.width = Math.floor(e * n), this.domElement.height = Math.floor(i * n), this.setViewport(0, 0, e, i), this._initialized && this.backend.updateSize();
  }
  setSize(e, i, n = !0) {
    this._width = e, this._height = i, this.domElement.width = Math.floor(e * this._pixelRatio), this.domElement.height = Math.floor(i * this._pixelRatio), n === !0 && (this.domElement.style.width = e + "px", this.domElement.style.height = i + "px"), this.setViewport(0, 0, e, i), this._initialized && this.backend.updateSize();
  }
  setOpaqueSort(e) {
    this._opaqueSort = e;
  }
  setTransparentSort(e) {
    this._transparentSort = e;
  }
  getScissor(e) {
    const i = this._scissor;
    return e.x = i.x, e.y = i.y, e.width = i.width, e.height = i.height, e;
  }
  setScissor(e, i, n, s) {
    const a = this._scissor;
    e.isVector4 ? a.copy(e) : a.set(e, i, n, s);
  }
  getScissorTest() {
    return this._scissorTest;
  }
  setScissorTest(e) {
    this._scissorTest = e, this.backend.setScissorTest(e);
  }
  getViewport(e) {
    return e.copy(this._viewport);
  }
  setViewport(e, i, n, s, a = 0, o = 1) {
    const l = this._viewport;
    e.isVector4 ? l.copy(e) : l.set(e, i, n, s), l.minDepth = a, l.maxDepth = o;
  }
  getClearColor(e) {
    return e.copy(this._clearColor);
  }
  setClearColor(e, i = 1) {
    this._clearColor.set(e), this._clearColor.a = i;
  }
  getClearAlpha() {
    return this._clearColor.a;
  }
  setClearAlpha(e) {
    this._clearColor.a = e;
  }
  getClearDepth() {
    return this._clearDepth;
  }
  setClearDepth(e) {
    this._clearDepth = e;
  }
  getClearStencil() {
    return this._clearStencil;
  }
  setClearStencil(e) {
    this._clearStencil = e;
  }
  isOccluded(e) {
    const i = this._currentRenderContext;
    return i && this.backend.isOccluded(i, e);
  }
  clear(e = !0, i = !0, n = !0) {
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."), this.clearAsync(e, i, n);
    const s = this._renderTarget || this._getFrameBufferTarget();
    let a = null;
    if (s !== null && (this._textures.updateRenderTarget(s), a = this._textures.get(s)), this.backend.clear(e, i, n, a), s !== null && this._renderTarget === null) {
      const o = this._quad;
      this._nodes.hasOutputChange(s.texture) && (o.material.fragmentNode = this._nodes.getOutputNode(s.texture), o.material.needsUpdate = !0), this._renderScene(o, o.camera, !1);
    }
  }
  clearColor() {
    return this.clear(!0, !1, !1);
  }
  clearDepth() {
    return this.clear(!1, !0, !1);
  }
  clearStencil() {
    return this.clear(!1, !1, !0);
  }
  async clearAsync(e = !0, i = !0, n = !0) {
    this._initialized === !1 && await this.init(), this.clear(e, i, n);
  }
  clearColorAsync() {
    return this.clearAsync(!0, !1, !1);
  }
  clearDepthAsync() {
    return this.clearAsync(!1, !0, !1);
  }
  clearStencilAsync() {
    return this.clearAsync(!1, !1, !0);
  }
  get currentToneMapping() {
    return this._renderTarget !== null ? Ku : this.toneMapping;
  }
  get currentColorSpace() {
    return this._renderTarget !== null ? ho : this.outputColorSpace;
  }
  dispose() {
    this.info.dispose(), this.backend.dispose(), this._animation.dispose(), this._objects.dispose(), this._pipelines.dispose(), this._nodes.dispose(), this._bindings.dispose(), this._renderLists.dispose(), this._renderContexts.dispose(), this._textures.dispose(), this.setRenderTarget(null), this.setAnimationLoop(null);
  }
  setRenderTarget(e, i = 0, n = 0) {
    this._renderTarget = e, this._activeCubeFace = i, this._activeMipmapLevel = n;
  }
  getRenderTarget() {
    return this._renderTarget;
  }
  setRenderObjectFunction(e) {
    this._renderObjectFunction = e;
  }
  getRenderObjectFunction() {
    return this._renderObjectFunction;
  }
  compute(e) {
    if (this.isDeviceLost === !0) return;
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."), this.computeAsync(e);
    const i = this._nodes.nodeFrame, n = i.renderId;
    this.info.calls++, this.info.compute.calls++, this.info.compute.frameCalls++, i.renderId = this.info.calls;
    const s = this.backend, a = this._pipelines, o = this._bindings, l = this._nodes, u = Array.isArray(e) ? e : [e];
    if (u[0] === void 0 || u[0].isComputeNode !== !0)
      throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
    s.beginCompute(e);
    for (const c of u) {
      if (a.has(c) === !1) {
        const p = () => {
          c.removeEventListener("dispose", p), a.delete(c), o.delete(c), l.delete(c);
        };
        c.addEventListener("dispose", p);
        const f = c.onInitFunction;
        f !== null && f.call(c, { renderer: this });
      }
      l.updateForCompute(c), o.updateForCompute(c);
      const h = o.getForCompute(c), d = a.getForCompute(c, h);
      s.compute(e, c, h, d);
    }
    s.finishCompute(e), i.renderId = n;
  }
  async computeAsync(e) {
    this._initialized === !1 && await this.init(), this.compute(e), await this.backend.resolveTimestampAsync(e, "compute");
  }
  async hasFeatureAsync(e) {
    return this._initialized === !1 && await this.init(), this.backend.hasFeature(e);
  }
  hasFeature(e) {
    return this._initialized === !1 ? (console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."), !1) : this.backend.hasFeature(e);
  }
  copyFramebufferToTexture(e, i = null) {
    if (i !== null)
      if (i.isVector2)
        i = Ha.set(i.x, i.y, e.image.width, e.image.height).floor();
      else if (i.isVector4)
        i = Ha.copy(i).floor();
      else {
        console.error("THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.");
        return;
      }
    else
      i = Ha.set(0, 0, e.image.width, e.image.height);
    let n = this._currentRenderContext, s;
    n !== null ? s = n.renderTarget : (s = this._renderTarget || this._getFrameBufferTarget(), s !== null && (this._textures.updateRenderTarget(s), n = this._textures.get(s))), this._textures.updateTexture(e, { renderTarget: s }), this.backend.copyFramebufferToTexture(e, n, i);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    this._textures.updateTexture(e), this._textures.updateTexture(i), this.backend.copyTextureToTexture(e, i, n, s, a);
  }
  readRenderTargetPixelsAsync(e, i, n, s, a, o = 0, l = 0) {
    return this.backend.copyTextureToBuffer(e.textures[o], i, n, s, a, l);
  }
  _projectObject(e, i, n, s) {
    if (e.visible === !1) return;
    if (e.layers.test(i.layers)) {
      if (e.isGroup)
        n = e.renderOrder;
      else if (e.isLOD)
        e.autoUpdate === !0 && e.update(i);
      else if (e.isLight)
        s.pushLight(e);
      else if (e.isSprite) {
        if (!e.frustumCulled || dv.intersectsSprite(e)) {
          this.sortObjects === !0 && Ha.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Sf);
          const { geometry: o, material: l } = e;
          l.visible && s.push(e, o, l, n, Ha.z, null);
        }
      } else if (e.isLineLoop)
        console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
      else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || dv.intersectsObject(e))) {
        const { geometry: o, material: l } = e;
        if (this.sortObjects === !0 && (o.boundingSphere === null && o.computeBoundingSphere(), Ha.copy(o.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(Sf)), Array.isArray(l)) {
          const u = o.groups;
          for (let c = 0, h = u.length; c < h; c++) {
            const d = u[c], p = l[d.materialIndex];
            p && p.visible && s.push(e, o, p, n, Ha.z, d);
          }
        } else l.visible && s.push(e, o, l, n, Ha.z, null);
      }
    }
    if (e.isBundleGroup === !0 && this.backend.beginBundle !== void 0) {
      const o = s;
      s = this._renderLists.get(e, i), s.begin(), o.pushBundle({
        bundleGroup: e,
        camera: i,
        renderList: s
      }), s.finish();
    }
    const a = e.children;
    for (let o = 0, l = a.length; o < l; o++)
      this._projectObject(a[o], i, n, s);
  }
  _renderBundles(e, i, n) {
    for (const s of e)
      this._renderBundle(s, i, n);
  }
  _renderTransparents(e, i, n, s, a) {
    if (i.length > 0) {
      for (const { material: o } of i)
        o.side = Qn;
      this._renderObjects(i, n, s, a, "backSide");
      for (const { material: o } of i)
        o.side = bc;
      this._renderObjects(e, n, s, a);
      for (const { material: o } of i)
        o.side = Yu;
    } else
      this._renderObjects(e, n, s, a);
  }
  _renderObjects(e, i, n, s, a = null) {
    for (let o = 0, l = e.length; o < l; o++) {
      const u = e[o], { object: c, geometry: h, material: d, group: p } = u;
      if (i.isArrayCamera) {
        const f = i.cameras;
        for (let m = 0, y = f.length; m < y; m++) {
          const v = f[m];
          if (c.layers.test(v.layers)) {
            const g = v.viewport, _ = g.minDepth === void 0 ? 0 : g.minDepth, x = g.maxDepth === void 0 ? 1 : g.maxDepth, b = this._currentRenderContext.viewportValue;
            b.copy(g).multiplyScalar(this._pixelRatio).floor(), b.minDepth = _, b.maxDepth = x, this.backend.updateViewport(this._currentRenderContext), this._currentRenderObjectFunction(c, n, v, h, d, p, s, a);
          }
        }
      } else
        this._currentRenderObjectFunction(c, n, i, h, d, p, s, a);
    }
  }
  renderObject(e, i, n, s, a, o, l, u = null) {
    let c, h, d;
    if (e.onBeforeRender(this, i, n, s, a, o), i.overrideMaterial !== null) {
      const p = i.overrideMaterial;
      a.positionNode && a.positionNode.isNode && (c = p.positionNode, p.positionNode = a.positionNode), p.isShadowNodeMaterial && (p.side = a.shadowSide === null ? a.side : a.shadowSide, a.depthNode && a.depthNode.isNode && (d = p.depthNode, p.depthNode = a.depthNode), a.shadowNode && a.shadowNode.isNode && (h = p.fragmentNode, p.fragmentNode = a.shadowNode), this.localClippingEnabled && (a.clipShadows ? (p.clippingPlanes !== a.clippingPlanes && (p.clippingPlanes = a.clippingPlanes, p.needsUpdate = !0), p.clipIntersection !== a.clipIntersection && (p.clipIntersection = a.clipIntersection)) : Array.isArray(p.clippingPlanes) && (p.clippingPlanes = null, p.needsUpdate = !0))), a = p;
    }
    a.transparent === !0 && a.side === Yu && a.forceSinglePass === !1 ? (a.side = Qn, this._handleObjectFunction(e, a, i, n, l, o, "backSide"), a.side = bc, this._handleObjectFunction(e, a, i, n, l, o, u), a.side = Yu) : this._handleObjectFunction(e, a, i, n, l, o, u), c !== void 0 && (i.overrideMaterial.positionNode = c), d !== void 0 && (i.overrideMaterial.depthNode = d), h !== void 0 && (i.overrideMaterial.fragmentNode = h), e.onAfterRender(this, i, n, s, a, o);
  }
  _renderObjectDirect(e, i, n, s, a, o, l) {
    const u = this._objects.get(e, i, n, s, a, this._currentRenderContext, l);
    u.drawRange = e.geometry.drawRange, u.group = o;
    const c = this._nodes.needsRefresh(u);
    c && (this._nodes.updateBefore(u), this._geometries.updateForRender(u), this._nodes.updateForRender(u), this._bindings.updateForRender(u)), this._pipelines.updateForRender(u), this._currentRenderBundle !== null && (this.backend.get(this._currentRenderBundle).renderObjects.push(u), u.bundle = this._currentRenderBundle.scene), this.backend.draw(u, this.info), c && this._nodes.updateAfter(u);
  }
  _createObjectPipeline(e, i, n, s, a, o) {
    const l = this._objects.get(e, i, n, s, a, this._currentRenderContext, o);
    this._nodes.updateBefore(l), this._geometries.updateForRender(l), this._nodes.updateForRender(l), this._bindings.updateForRender(l), this._pipelines.getForRender(l, this._compilationPromises), this._nodes.updateAfter(l);
  }
  get compile() {
    return this.compileAsync;
  }
}
class q1 {
  constructor(e = "") {
    this.name = e, this.visibility = 0;
  }
  setVisibility(e) {
    this.visibility |= e;
  }
  clone() {
    return Object.assign(new this.constructor(), this);
  }
}
function O$(r) {
  return r + (to - r % to) % to;
}
class aI extends q1 {
  constructor(e, i = null) {
    super(e), this.isBuffer = !0, this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT, this._buffer = i;
  }
  get byteLength() {
    return O$(this._buffer.byteLength);
  }
  get buffer() {
    return this._buffer;
  }
  update() {
    return !0;
  }
}
class oI extends aI {
  constructor(e, i = null) {
    super(e, i), this.isUniformBuffer = !0;
  }
}
let D$ = 0;
class lI extends oI {
  constructor(e, i) {
    super("UniformBuffer_" + D$++, e ? e.value : null), this.nodeUniform = e, this.groupNode = i;
  }
  get buffer() {
    return this.nodeUniform.value;
  }
}
class L$ extends oI {
  constructor(e) {
    super(e), this.isUniformsGroup = !0, this._values = null, this.uniforms = [];
  }
  addUniform(e) {
    return this.uniforms.push(e), this;
  }
  removeUniform(e) {
    const i = this.uniforms.indexOf(e);
    return i !== -1 && this.uniforms.splice(i, 1), this;
  }
  get values() {
    return this._values === null && (this._values = Array.from(this.buffer)), this._values;
  }
  get buffer() {
    let e = this._buffer;
    if (e === null) {
      const i = this.byteLength;
      e = new Float32Array(new ArrayBuffer(i)), this._buffer = e;
    }
    return e;
  }
  get byteLength() {
    let e = 0;
    for (let i = 0, n = this.uniforms.length; i < n; i++) {
      const s = this.uniforms[i], { boundary: a, itemSize: o } = s, l = e % to, u = to - l;
      l !== 0 && u - a < 0 ? e += to - l : l % a !== 0 && (e += l % a), s.offset = e / this.bytesPerElement, e += o * this.bytesPerElement;
    }
    return Math.ceil(e / to) * to;
  }
  update() {
    let e = !1;
    for (const i of this.uniforms)
      this.updateByType(i) === !0 && (e = !0);
    return e;
  }
  updateByType(e) {
    if (e.isNumberUniform) return this.updateNumber(e);
    if (e.isVector2Uniform) return this.updateVector2(e);
    if (e.isVector3Uniform) return this.updateVector3(e);
    if (e.isVector4Uniform) return this.updateVector4(e);
    if (e.isColorUniform) return this.updateColor(e);
    if (e.isMatrix3Uniform) return this.updateMatrix3(e);
    if (e.isMatrix4Uniform) return this.updateMatrix4(e);
    console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.", e);
  }
  updateNumber(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a] !== s) {
      const o = this.buffer;
      o[a] = n[a] = s, i = !0;
    }
    return i;
  }
  updateVector2(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, i = !0;
    }
    return i;
  }
  updateVector3(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y || n[a + 2] !== s.z) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, o[a + 2] = n[a + 2] = s.z, i = !0;
    }
    return i;
  }
  updateVector4(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.x || n[a + 1] !== s.y || n[a + 2] !== s.z || n[a + 4] !== s.w) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.x, o[a + 1] = n[a + 1] = s.y, o[a + 2] = n[a + 2] = s.z, o[a + 3] = n[a + 3] = s.w, i = !0;
    }
    return i;
  }
  updateColor(e) {
    let i = !1;
    const n = this.values, s = e.getValue(), a = e.offset;
    if (n[a + 0] !== s.r || n[a + 1] !== s.g || n[a + 2] !== s.b) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s.r, o[a + 1] = n[a + 1] = s.g, o[a + 2] = n[a + 2] = s.b, i = !0;
    }
    return i;
  }
  updateMatrix3(e) {
    let i = !1;
    const n = this.values, s = e.getValue().elements, a = e.offset;
    if (n[a + 0] !== s[0] || n[a + 1] !== s[1] || n[a + 2] !== s[2] || n[a + 4] !== s[3] || n[a + 5] !== s[4] || n[a + 6] !== s[5] || n[a + 8] !== s[6] || n[a + 9] !== s[7] || n[a + 10] !== s[8]) {
      const o = this.buffer;
      o[a + 0] = n[a + 0] = s[0], o[a + 1] = n[a + 1] = s[1], o[a + 2] = n[a + 2] = s[2], o[a + 4] = n[a + 4] = s[3], o[a + 5] = n[a + 5] = s[4], o[a + 6] = n[a + 6] = s[5], o[a + 8] = n[a + 8] = s[6], o[a + 9] = n[a + 9] = s[7], o[a + 10] = n[a + 10] = s[8], i = !0;
    }
    return i;
  }
  updateMatrix4(e) {
    let i = !1;
    const n = this.values, s = e.getValue().elements, a = e.offset;
    return U$(n, s, a) === !1 && (this.buffer.set(s, a), k$(n, s, a), i = !0), i;
  }
}
function k$(r, e, i) {
  for (let n = 0, s = e.length; n < s; n++)
    r[i + n] = e[n];
}
function U$(r, e, i) {
  for (let n = 0, s = e.length; n < s; n++)
    if (r[i + n] !== e[n]) return !1;
  return !0;
}
let F$ = 0;
class uI extends L$ {
  constructor(e, i) {
    super(e), this.id = F$++, this.groupNode = i, this.isNodeUniformsGroup = !0;
  }
  getNodes() {
    const e = [];
    for (const i of this.uniforms) {
      const n = i.nodeUniform.node;
      if (!n) throw new Error("NodeUniformsGroup: Uniform has no node.");
      e.push(n);
    }
    return e;
  }
}
let B$ = 0;
class z$ extends q1 {
  constructor(e, i) {
    super(e), this.id = B$++, this.texture = i, this.version = i ? i.version : 0, this.store = !1, this.generation = null, this.isSampledTexture = !0;
  }
  needsBindingsUpdate(e) {
    const { texture: i } = this;
    return e !== this.generation ? (this.generation = e, !0) : i.isVideoTexture;
  }
  update() {
    const { texture: e, version: i } = this;
    return i !== e.version ? (this.version = e.version, !0) : !1;
  }
}
class Gg extends z$ {
  constructor(e, i, n, s = null) {
    super(e, i ? i.value : null), this.textureNode = i, this.groupNode = n, this.access = s;
  }
  needsBindingsUpdate(e) {
    return this.textureNode.value !== this.texture || super.needsBindingsUpdate(e);
  }
  update() {
    const { textureNode: e } = this;
    return this.texture !== e.value ? (this.texture = e.value, !0) : super.update();
  }
}
class cI extends Gg {
  constructor(e, i, n, s) {
    super(e, i, n, s), this.isSampledCubeTexture = !0;
  }
}
class hI extends Gg {
  constructor(e, i, n, s) {
    super(e, i, n, s), this.isSampledTexture3D = !0;
  }
}
const j$ = {
  atan2: "atan",
  textureDimensions: "textureSize",
  equals: "equal"
}, V$ = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
}, uM = {
  swizzleAssign: !0,
  storageBuffer: !1
}, cM = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;
class G$ extends iI {
  constructor(e, i) {
    super(e, i, new M$()), this.uniformGroups = {}, this.transforms = [], this.extensions = {}, this.useComparisonMethod = !0;
  }
  needsColorSpaceToLinearSRGB(e) {
    return e.isVideoTexture === !0 && e.colorSpace !== wl;
  }
  getMethod(e) {
    return j$[e] || e;
  }
  getOutputStructName() {
    return "";
  }
  buildFunctionCode(e) {
    const i = e.layout, n = this.flowShaderNode(e), s = [];
    for (const a of i.inputs)
      s.push(this.getType(a.type) + " " + a.name);
    return `${this.getType(i.type)} ${i.name}( ${s.join(", ")} ) {

	${n.vars}

${n.code}
	return ${n.result};

}`;
  }
  setupPBO(e) {
    const i = e.value;
    if (i.pbo === void 0) {
      const n = i.array, s = i.count * i.itemSize, { itemSize: a } = i, o = i.array.constructor.name.toLowerCase().includes("int");
      let l = o ? a1 : s1;
      a === 2 ? l = o ? o1 : gd : a === 3 ? l = o ? KH : n1 : a === 4 && (l = o ? l1 : Bc);
      const u = {
        Float32Array: on,
        Uint8Array: co,
        Uint16Array: Lu,
        Uint32Array: er,
        Int8Array: $h,
        Int16Array: Jh,
        Int32Array: wr,
        Uint8ClampedArray: co
      }, c = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(s / a))));
      let h = Math.ceil(s / a / c);
      c * h * a < s && h++;
      const d = c * h * a, p = new n.constructor(d);
      p.set(n, 0), i.array = p;
      const f = new tW(i.array, c, h, l, u[i.array.constructor.name] || on);
      f.needsUpdate = !0, f.isPBOTexture = !0;
      const m = new ip(f, null, null);
      m.setPrecision("high"), i.pboNode = m, i.pbo = m.value, this.getUniformFromNode(i.pboNode, "texture", this.shaderStage, this.context.label);
    }
  }
  getPropertyName(e, i = this.shaderStage) {
    return e.isNodeUniform && e.node.isTextureNode !== !0 && e.node.isBufferNode !== !0 ? i.charAt(0) + "_" + e.name : super.getPropertyName(e, i);
  }
  generatePBO(e) {
    const { node: i, indexNode: n } = e, s = i.value;
    if (this.renderer.backend.has(s)) {
      const h = this.renderer.backend.get(s);
      h.pbo = s.pbo;
    }
    const a = this.getUniformFromNode(s.pboNode, "texture", this.shaderStage, this.context.label), o = this.getPropertyName(a);
    this.increaseUsage(n);
    const l = n.build(this, "uint"), u = this.getDataFromNode(e);
    let c = u.propertyName;
    if (c === void 0) {
      const h = this.getVarFromNode(e);
      c = this.getPropertyName(h);
      const d = this.getDataFromNode(i);
      let p = d.propertySizeName;
      p === void 0 && (p = c + "Size", this.getVarFromNode(i, p, "uint"), this.addLineFlowCode(`${p} = uint( textureSize( ${o}, 0 ).x )`, e), d.propertySizeName = p);
      const { itemSize: f } = s, m = "." + Gc.join("").slice(0, f), y = `ivec2(${l} % ${p}, ${l} / ${p})`, v = this.generateTextureLoad(null, o, y, null, "0");
      let g = "vec4";
      s.pbo.type === er ? g = "uvec4" : s.pbo.type === wr && (g = "ivec4"), this.addLineFlowCode(`${c} = ${g}(${v})${m}`, e), u.propertyName = c;
    }
    return c;
  }
  generateTextureLoad(e, i, n, s, a = "0") {
    return s ? `texelFetch( ${i}, ivec3( ${n}, ${s} ), ${a} )` : `texelFetch( ${i}, ${n}, ${a} )`;
  }
  generateTexture(e, i, n, s) {
    return e.isDepthTexture ? `texture( ${i}, ${n} ).x` : (s && (n = `vec3( ${n}, ${s} )`), `texture( ${i}, ${n} )`);
  }
  generateTextureLevel(e, i, n, s) {
    return `textureLod( ${i}, ${n}, ${s} )`;
  }
  generateTextureBias(e, i, n, s) {
    return `texture( ${i}, ${n}, ${s} )`;
  }
  generateTextureGrad(e, i, n, s) {
    return `textureGrad( ${i}, ${n}, ${s[0]}, ${s[1]} )`;
  }
  generateTextureCompare(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `texture( ${i}, vec3( ${n}, ${s} ) )`;
    console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${o} shader.`);
  }
  getVars(e) {
    const i = [], n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`${this.getVar(s.type, s.name)};`);
    return i.join(`
	`);
  }
  getUniforms(e) {
    const i = this.uniforms[e], n = [], s = {};
    for (const o of i) {
      let l = null, u = !1;
      if (o.type === "texture") {
        const h = o.node.value;
        let d = "";
        h.isDataTexture === !0 && (h.type === er ? d = "u" : h.type === wr && (d = "i")), h.compareFunction ? l = `sampler2DShadow ${o.name};` : h.isDataArrayTexture === !0 || h.isCompressedArrayTexture === !0 ? l = `${d}sampler2DArray ${o.name};` : l = `${d}sampler2D ${o.name};`;
      } else if (o.type === "cubeTexture")
        l = `samplerCube ${o.name};`;
      else if (o.type === "texture3D")
        l = `sampler3D ${o.name};`;
      else if (o.type === "buffer") {
        const h = o.node, d = this.getType(h.bufferType), p = h.bufferCount, f = p > 0 ? p : "";
        l = `${h.name} {
	${d} ${o.name}[${f}];
};
`;
      } else
        l = `${this.getVectorType(o.type)} ${this.getPropertyName(o, e)};`, u = !0;
      const c = o.node.precision;
      if (c !== null && (l = V$[c] + " " + l), u) {
        l = "	" + l;
        const h = o.groupNode.name;
        (s[h] || (s[h] = [])).push(l);
      } else
        l = "uniform " + l, n.push(l);
    }
    let a = "";
    for (const o in s) {
      const l = s[o];
      a += this._getGLSLUniformStruct(e + "_" + o, l.join(`
`)) + `
`;
    }
    return a += n.join(`
`), a;
  }
  getTypeFromAttribute(e) {
    let i = super.getTypeFromAttribute(e);
    if (/^[iu]/.test(i) && e.gpuType !== wr) {
      let n = e;
      e.isInterleavedBufferAttribute && (n = e.data);
      const s = n.array;
      s instanceof Uint32Array || s instanceof Int32Array || (i = i.slice(1));
    }
    return i;
  }
  getAttributes(e) {
    let i = "";
    if (e === "vertex" || e === "compute") {
      const n = this.getAttributesArray();
      let s = 0;
      for (const a of n)
        i += `layout( location = ${s++} ) in ${a.type} ${a.name};
`;
    }
    return i;
  }
  getStructMembers(e) {
    const i = [], n = e.getMemberTypes();
    for (let s = 0; s < n.length; s++) {
      const a = n[s];
      i.push(`layout( location = ${s} ) out ${a} m${s};`);
    }
    return i.join(`
`);
  }
  getStructs(e) {
    const i = [], n = this.structs[e];
    if (n.length === 0)
      return `layout( location = 0 ) out vec4 fragColor;
`;
    for (let s = 0, a = n.length; s < a; s++) {
      const o = n[s];
      let l = `
`;
      l += this.getStructMembers(o), l += `
`, i.push(l);
    }
    return i.join(`

`);
  }
  getVaryings(e) {
    let i = "";
    const n = this.varyings;
    if (e === "vertex" || e === "compute")
      for (const s of n) {
        e === "compute" && (s.needsInterpolation = !0);
        const a = s.type, o = a.includes("int") || a.includes("uv") || a.includes("iv") ? "flat " : "";
        i += `${o}${s.needsInterpolation ? "out" : "/*out*/"} ${a} ${s.name};
`;
      }
    else if (e === "fragment") {
      for (const s of n)
        if (s.needsInterpolation) {
          const a = s.type, o = a.includes("int") || a.includes("uv") || a.includes("iv") ? "flat " : "";
          i += `${o}in ${a} ${s.name};
`;
        }
    }
    return i;
  }
  getVertexIndex() {
    return "uint( gl_VertexID )";
  }
  getInstanceIndex() {
    return "uint( gl_InstanceID )";
  }
  getInvocationLocalIndex() {
    return `uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce((e, i) => e * i, 1)}u`;
  }
  getDrawIndex() {
    return this.renderer.backend.extensions.has("WEBGL_multi_draw") ? "uint( gl_DrawID )" : null;
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord.xy";
  }
  getFragDepth() {
    return "gl_FragDepth";
  }
  enableExtension(e, i, n = this.shaderStage) {
    const s = this.extensions[n] || (this.extensions[n] = /* @__PURE__ */ new Map());
    s.has(e) === !1 && s.set(e, {
      name: e,
      behavior: i
    });
  }
  getExtensions(e) {
    const i = [];
    if (e === "vertex") {
      const s = this.renderer.backend.extensions;
      this.object.isBatchedMesh && s.has("WEBGL_multi_draw") && this.enableExtension("GL_ANGLE_multi_draw", "require", e);
    }
    const n = this.extensions[e];
    if (n !== void 0)
      for (const { name: s, behavior: a } of n.values())
        i.push(`#extension ${s} : ${a}`);
    return i.join(`
`);
  }
  isAvailable(e) {
    let i = uM[e];
    if (i === void 0) {
      if (e === "float32Filterable") {
        const n = this.renderer.backend.extensions;
        n.has("OES_texture_float_linear") ? (n.get("OES_texture_float_linear"), i = !0) : i = !1;
      }
      uM[e] = i;
    }
    return i;
  }
  isFlipY() {
    return !0;
  }
  registerTransform(e, i) {
    this.transforms.push({ varyingName: e, attributeNode: i });
  }
  getTransforms() {
    const e = this.transforms;
    let i = "";
    for (let n = 0; n < e.length; n++) {
      const s = e[n], a = this.getPropertyName(s.attributeNode);
      i += `${s.varyingName} = ${a};
	`;
    }
    return i;
  }
  _getGLSLUniformStruct(e, i) {
    return `
layout( std140 ) uniform ${e} {
${i}
};`;
  }
  _getGLSLVertexCode(e) {
    return `#version 300 es

${this.getSignature()}

// extensions 
${e.extensions}

// precision
${cM}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// attributes
${e.attributes}

// codes
${e.codes}

void main() {

	// vars
	${e.vars}

	// transforms
	${e.transforms}

	// flow
	${e.flow}

	gl_PointSize = 1.0;

}
`;
  }
  _getGLSLFragmentCode(e) {
    return `#version 300 es

${this.getSignature()}

// precision
${cM}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// codes
${e.codes}

${e.structs}

void main() {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const i in e) {
      let n = `// code

`;
      n += this.flowCode[i];
      const s = this.flowNodes[i], a = s[s.length - 1];
      for (const l of s) {
        const u = this.getFlowData(
          l
          /*, shaderStage*/
        ), c = l.name;
        c && (n.length > 0 && (n += `
`), n += `	// flow -> ${c}
	`), n += `${u.code}
	`, l === a && i !== "compute" && (n += `// result
	`, i === "vertex" ? (n += "gl_Position = ", n += `${u.result};`) : i === "fragment" && (l.outputNode.isOutputStructNode || (n += "fragColor = ", n += `${u.result};`)));
      }
      const o = e[i];
      o.extensions = this.getExtensions(i), o.uniforms = this.getUniforms(i), o.attributes = this.getAttributes(i), o.varyings = this.getVaryings(i), o.vars = this.getVars(i), o.structs = this.getStructs(i), o.codes = this.getCodes(i), o.transforms = this.getTransforms(i), o.flow = n;
    }
    this.material !== null ? (this.vertexShader = this._getGLSLVertexCode(e.vertex), this.fragmentShader = this._getGLSLFragmentCode(e.fragment)) : this.computeShader = this._getGLSLVertexCode(e.compute);
  }
  getUniformFromNode(e, i, n, s = null) {
    const a = super.getUniformFromNode(e, i, n, s), o = this.getDataFromNode(e, n, this.globalCache);
    let l = o.uniformGPU;
    if (l === void 0) {
      const u = e.groupNode, c = u.name, h = this.getBindGroupArray(c, n);
      if (i === "texture")
        l = new Gg(a.name, a.node, u), h.push(l);
      else if (i === "cubeTexture")
        l = new cI(a.name, a.node, u), h.push(l);
      else if (i === "texture3D")
        l = new hI(a.name, a.node, u), h.push(l);
      else if (i === "buffer") {
        e.name = `NodeBuffer_${e.id}`, a.name = `buffer${e.id}`;
        const d = new lI(e, u);
        d.name = e.name, h.push(d), l = d;
      } else {
        const d = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let p = d[c];
        p === void 0 && (p = new uI(n + "_" + c, u), d[c] = p, h.push(p)), l = this.getNodeUniform(a, i), p.addUniform(l);
      }
      o.uniformGPU = l;
    }
    return a;
  }
}
let pv = null, fv = null, Tu = null;
class dI {
  constructor(e = {}) {
    this.parameters = Object.assign({}, e), this.data = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.domElement = null;
  }
  async init(e) {
    this.renderer = e;
  }
  // render context
  begin() {
  }
  finish() {
  }
  // render object
  draw() {
  }
  // program
  createProgram() {
  }
  destroyProgram() {
  }
  // bindings
  createBindings() {
  }
  updateBindings() {
  }
  // pipeline
  createRenderPipeline() {
  }
  createComputePipeline() {
  }
  destroyPipeline() {
  }
  // cache key
  needsRenderUpdate() {
  }
  // return Boolean ( fast test )
  getRenderCacheKey() {
  }
  // return String
  // node builder
  createNodeBuilder() {
  }
  // return NodeBuilder (ADD IT)
  // textures
  createSampler() {
  }
  createDefaultTexture() {
  }
  createTexture() {
  }
  copyTextureToBuffer() {
  }
  // attributes
  createAttribute() {
  }
  createIndexAttribute() {
  }
  updateAttribute() {
  }
  destroyAttribute() {
  }
  // canvas
  getContext() {
  }
  updateSize() {
  }
  // utils
  resolveTimestampAsync() {
  }
  hasFeatureAsync() {
  }
  // return Boolean
  hasFeature() {
  }
  // return Boolean
  getInstanceCount(e) {
    const { object: i, geometry: n } = e;
    return n.isInstancedBufferGeometry ? n.instanceCount : i.count > 1 ? i.count : 1;
  }
  getDrawingBufferSize() {
    return pv = pv || new Vt(), this.renderer.getDrawingBufferSize(pv);
  }
  getScissor() {
    return fv = fv || new Kt(), this.renderer.getScissor(fv);
  }
  setScissorTest() {
  }
  getClearColor() {
    const e = this.renderer;
    return Tu = Tu || new B1(), e.getClearColor(Tu), Tu.getRGB(Tu, this.renderer.currentColorSpace), Tu;
  }
  getDomElement() {
    let e = this.domElement;
    return e === null && (e = this.parameters.canvas !== void 0 ? this.parameters.canvas : N7(), "setAttribute" in e && e.setAttribute("data-engine", `three.js r${Rg} webgpu`), this.domElement = e), e;
  }
  // resource properties
  set(e, i) {
    this.data.set(e, i);
  }
  get(e) {
    let i = this.data.get(e);
    return i === void 0 && (i = {}, this.data.set(e, i)), i;
  }
  has(e) {
    return this.data.has(e);
  }
  delete(e) {
    this.data.delete(e);
  }
  dispose() {
  }
}
let H$ = 0;
class W$ {
  constructor(e, i) {
    this.buffers = [e.bufferGPU, i], this.type = e.type, this.bufferType = e.bufferType, this.pbo = e.pbo, this.byteLength = e.byteLength, this.bytesPerElement = e.BYTES_PER_ELEMENT, this.version = e.version, this.isInteger = e.isInteger, this.activeBufferIndex = 0, this.baseId = e.id;
  }
  get id() {
    return `${this.baseId}|${this.activeBufferIndex}`;
  }
  get bufferGPU() {
    return this.buffers[this.activeBufferIndex];
  }
  get transformBuffer() {
    return this.buffers[this.activeBufferIndex ^ 1];
  }
  switchBuffers() {
    this.activeBufferIndex ^= 1;
  }
}
class q$ {
  constructor(e) {
    this.backend = e;
  }
  createAttribute(e, i) {
    const n = this.backend, { gl: s } = n, a = e.array, o = e.usage || s.STATIC_DRAW, l = e.isInterleavedBufferAttribute ? e.data : e, u = n.get(l);
    let c = u.bufferGPU;
    c === void 0 && (c = this._createBuffer(s, i, a, o), u.bufferGPU = c, u.bufferType = i, u.version = l.version);
    let h;
    if (a instanceof Float32Array)
      h = s.FLOAT;
    else if (a instanceof Uint16Array)
      e.isFloat16BufferAttribute ? h = s.HALF_FLOAT : h = s.UNSIGNED_SHORT;
    else if (a instanceof Int16Array)
      h = s.SHORT;
    else if (a instanceof Uint32Array)
      h = s.UNSIGNED_INT;
    else if (a instanceof Int32Array)
      h = s.INT;
    else if (a instanceof Int8Array)
      h = s.BYTE;
    else if (a instanceof Uint8Array)
      h = s.UNSIGNED_BYTE;
    else if (a instanceof Uint8ClampedArray)
      h = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + a);
    let d = {
      bufferGPU: c,
      bufferType: i,
      type: h,
      byteLength: a.byteLength,
      bytesPerElement: a.BYTES_PER_ELEMENT,
      version: e.version,
      pbo: e.pbo,
      isInteger: h === s.INT || h === s.UNSIGNED_INT || e.gpuType === wr,
      id: H$++
    };
    if (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute) {
      const p = this._createBuffer(s, i, a, o);
      d = new W$(d, p);
    }
    n.set(e, d);
  }
  updateAttribute(e) {
    const i = this.backend, { gl: n } = i, s = e.array, a = e.isInterleavedBufferAttribute ? e.data : e, o = i.get(a), l = o.bufferType, u = e.isInterleavedBufferAttribute ? e.data.updateRanges : e.updateRanges;
    if (n.bindBuffer(l, o.bufferGPU), u.length === 0)
      n.bufferSubData(l, 0, s);
    else {
      for (let c = 0, h = u.length; c < h; c++) {
        const d = u[c];
        n.bufferSubData(
          l,
          d.start * s.BYTES_PER_ELEMENT,
          s,
          d.start,
          d.count
        );
      }
      a.clearUpdateRanges();
    }
    n.bindBuffer(l, null), o.version = a.version;
  }
  destroyAttribute(e) {
    const i = this.backend, { gl: n } = i;
    e.isInterleavedBufferAttribute && i.delete(e.data);
    const s = i.get(e);
    n.deleteBuffer(s.bufferGPU), i.delete(e);
  }
  async getArrayBufferAsync(e) {
    const i = this.backend, { gl: n } = i, s = e.isInterleavedBufferAttribute ? e.data : e, { bufferGPU: a } = i.get(s), o = e.array, l = o.byteLength;
    n.bindBuffer(n.COPY_READ_BUFFER, a);
    const u = n.createBuffer();
    n.bindBuffer(n.COPY_WRITE_BUFFER, u), n.bufferData(n.COPY_WRITE_BUFFER, l, n.STREAM_READ), n.copyBufferSubData(n.COPY_READ_BUFFER, n.COPY_WRITE_BUFFER, 0, 0, l), await i.utils._clientWaitAsync();
    const c = new e.array.constructor(o.length);
    return n.bindBuffer(n.COPY_WRITE_BUFFER, u), n.getBufferSubData(n.COPY_WRITE_BUFFER, 0, c), n.deleteBuffer(u), n.bindBuffer(n.COPY_READ_BUFFER, null), n.bindBuffer(n.COPY_WRITE_BUFFER, null), c.buffer;
  }
  _createBuffer(e, i, n, s) {
    const a = e.createBuffer();
    return e.bindBuffer(i, a), e.bufferData(i, n, s), e.bindBuffer(i, null), a;
  }
}
let hM = !1, mv, Ch;
class X$ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.enabled = {}, this.currentFlipSided = null, this.currentCullFace = null, this.currentProgram = null, this.currentBlendingEnabled = !1, this.currentBlending = null, this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentPremultipledAlpha = null, this.currentPolygonOffsetFactor = null, this.currentPolygonOffsetUnits = null, this.currentColorMask = null, this.currentDepthFunc = null, this.currentDepthMask = null, this.currentStencilFunc = null, this.currentStencilRef = null, this.currentStencilFuncMask = null, this.currentStencilFail = null, this.currentStencilZFail = null, this.currentStencilZPass = null, this.currentStencilMask = null, this.currentLineWidth = null, this.currentBoundFramebuffers = {}, this.currentDrawbuffers = /* @__PURE__ */ new WeakMap(), this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), this.currentTextureSlot = null, this.currentBoundTextures = {}, this.currentBoundBufferBases = {}, hM === !1 && (this._init(this.gl), hM = !0);
  }
  _init(e) {
    mv = {
      [Ja]: e.FUNC_ADD,
      [zN]: e.FUNC_SUBTRACT,
      [jN]: e.FUNC_REVERSE_SUBTRACT
    }, Ch = {
      [VN]: e.ZERO,
      [GN]: e.ONE,
      [HN]: e.SRC_COLOR,
      [Dm]: e.SRC_ALPHA,
      [ZN]: e.SRC_ALPHA_SATURATE,
      [YN]: e.DST_COLOR,
      [qN]: e.DST_ALPHA,
      [WN]: e.ONE_MINUS_SRC_COLOR,
      [Lm]: e.ONE_MINUS_SRC_ALPHA,
      [KN]: e.ONE_MINUS_DST_COLOR,
      [XN]: e.ONE_MINUS_DST_ALPHA
    };
  }
  enable(e) {
    const { enabled: i } = this;
    i[e] !== !0 && (this.gl.enable(e), i[e] = !0);
  }
  disable(e) {
    const { enabled: i } = this;
    i[e] !== !1 && (this.gl.disable(e), i[e] = !1);
  }
  setFlipSided(e) {
    if (this.currentFlipSided !== e) {
      const { gl: i } = this;
      e ? i.frontFace(i.CW) : i.frontFace(i.CCW), this.currentFlipSided = e;
    }
  }
  setCullFace(e) {
    const { gl: i } = this;
    e !== NH ? (this.enable(i.CULL_FACE), e !== this.currentCullFace && (e === PH ? i.cullFace(i.BACK) : e === IH ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : this.disable(i.CULL_FACE), this.currentCullFace = e;
  }
  setLineWidth(e) {
    const { currentLineWidth: i, gl: n } = this;
    e !== i && (n.lineWidth(e), this.currentLineWidth = e);
  }
  setBlending(e, i, n, s, a, o, l, u) {
    const { gl: c } = this;
    if (e === xc) {
      this.currentBlendingEnabled === !0 && (this.disable(c.BLEND), this.currentBlendingEnabled = !1);
      return;
    }
    if (this.currentBlendingEnabled === !1 && (this.enable(c.BLEND), this.currentBlendingEnabled = !0), e !== BN) {
      if (e !== this.currentBlending || u !== this.currentPremultipledAlpha) {
        if ((this.currentBlendEquation !== Ja || this.currentBlendEquationAlpha !== Ja) && (c.blendEquation(c.FUNC_ADD), this.currentBlendEquation = Ja, this.currentBlendEquationAlpha = Ja), u)
          switch (e) {
            case uo:
              c.blendFuncSeparate(c.ONE, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA);
              break;
            case Pm:
              c.blendFunc(c.ONE, c.ONE);
              break;
            case Im:
              c.blendFuncSeparate(c.ZERO, c.ONE_MINUS_SRC_COLOR, c.ZERO, c.ONE);
              break;
            case Om:
              c.blendFuncSeparate(c.ZERO, c.SRC_COLOR, c.ZERO, c.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
              break;
          }
        else
          switch (e) {
            case uo:
              c.blendFuncSeparate(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA);
              break;
            case Pm:
              c.blendFunc(c.SRC_ALPHA, c.ONE);
              break;
            case Im:
              c.blendFuncSeparate(c.ZERO, c.ONE_MINUS_SRC_COLOR, c.ZERO, c.ONE);
              break;
            case Om:
              c.blendFunc(c.ZERO, c.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
              break;
          }
        this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentBlending = e, this.currentPremultipledAlpha = u;
      }
      return;
    }
    a = a || i, o = o || n, l = l || s, (i !== this.currentBlendEquation || a !== this.currentBlendEquationAlpha) && (c.blendEquationSeparate(mv[i], mv[a]), this.currentBlendEquation = i, this.currentBlendEquationAlpha = a), (n !== this.currentBlendSrc || s !== this.currentBlendDst || o !== this.currentBlendSrcAlpha || l !== this.currentBlendDstAlpha) && (c.blendFuncSeparate(Ch[n], Ch[s], Ch[o], Ch[l]), this.currentBlendSrc = n, this.currentBlendDst = s, this.currentBlendSrcAlpha = o, this.currentBlendDstAlpha = l), this.currentBlending = e, this.currentPremultipledAlpha = !1;
  }
  setColorMask(e) {
    this.currentColorMask !== e && (this.gl.colorMask(e, e, e, e), this.currentColorMask = e);
  }
  setDepthTest(e) {
    const { gl: i } = this;
    e ? this.enable(i.DEPTH_TEST) : this.disable(i.DEPTH_TEST);
  }
  setDepthMask(e) {
    this.currentDepthMask !== e && (this.gl.depthMask(e), this.currentDepthMask = e);
  }
  setDepthFunc(e) {
    if (this.currentDepthFunc !== e) {
      const { gl: i } = this;
      switch (e) {
        case QN:
          i.depthFunc(i.NEVER);
          break;
        case $N:
          i.depthFunc(i.ALWAYS);
          break;
        case JN:
          i.depthFunc(i.LESS);
          break;
        case km:
          i.depthFunc(i.LEQUAL);
          break;
        case e3:
          i.depthFunc(i.EQUAL);
          break;
        case t3:
          i.depthFunc(i.GEQUAL);
          break;
        case i3:
          i.depthFunc(i.GREATER);
          break;
        case r3:
          i.depthFunc(i.NOTEQUAL);
          break;
        default:
          i.depthFunc(i.LEQUAL);
      }
      this.currentDepthFunc = e;
    }
  }
  setStencilTest(e) {
    const { gl: i } = this;
    e ? this.enable(i.STENCIL_TEST) : this.disable(i.STENCIL_TEST);
  }
  setStencilMask(e) {
    this.currentStencilMask !== e && (this.gl.stencilMask(e), this.currentStencilMask = e);
  }
  setStencilFunc(e, i, n) {
    (this.currentStencilFunc !== e || this.currentStencilRef !== i || this.currentStencilFuncMask !== n) && (this.gl.stencilFunc(e, i, n), this.currentStencilFunc = e, this.currentStencilRef = i, this.currentStencilFuncMask = n);
  }
  setStencilOp(e, i, n) {
    (this.currentStencilFail !== e || this.currentStencilZFail !== i || this.currentStencilZPass !== n) && (this.gl.stencilOp(e, i, n), this.currentStencilFail = e, this.currentStencilZFail = i, this.currentStencilZPass = n);
  }
  setMaterial(e, i) {
    const { gl: n } = this;
    e.side === Yu ? this.disable(n.CULL_FACE) : this.enable(n.CULL_FACE);
    let s = e.side === Qn;
    i && (s = !s), this.setFlipSided(s), e.blending === uo && e.transparent === !1 ? this.setBlending(xc) : this.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), this.setDepthFunc(e.depthFunc), this.setDepthTest(e.depthTest), this.setDepthMask(e.depthWrite), this.setColorMask(e.colorWrite);
    const a = e.stencilWrite;
    this.setStencilTest(a), a && (this.setStencilMask(e.stencilWriteMask), this.setStencilFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), this.setStencilOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), this.setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), e.alphaToCoverage === !0 && this.backend.renderer.samples > 1 ? this.enable(n.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  setPolygonOffset(e, i, n) {
    const { gl: s } = this;
    e ? (this.enable(s.POLYGON_OFFSET_FILL), (this.currentPolygonOffsetFactor !== i || this.currentPolygonOffsetUnits !== n) && (s.polygonOffset(i, n), this.currentPolygonOffsetFactor = i, this.currentPolygonOffsetUnits = n)) : this.disable(s.POLYGON_OFFSET_FILL);
  }
  useProgram(e) {
    return this.currentProgram !== e ? (this.gl.useProgram(e), this.currentProgram = e, !0) : !1;
  }
  // framebuffer
  bindFramebuffer(e, i) {
    const { gl: n, currentBoundFramebuffers: s } = this;
    return s[e] !== i ? (n.bindFramebuffer(e, i), s[e] = i, e === n.DRAW_FRAMEBUFFER && (s[n.FRAMEBUFFER] = i), e === n.FRAMEBUFFER && (s[n.DRAW_FRAMEBUFFER] = i), !0) : !1;
  }
  drawBuffers(e, i) {
    const { gl: n } = this;
    let s = [], a = !1;
    if (e.textures !== null) {
      s = this.currentDrawbuffers.get(i), s === void 0 && (s = [], this.currentDrawbuffers.set(i, s));
      const o = e.textures;
      if (s.length !== o.length || s[0] !== n.COLOR_ATTACHMENT0) {
        for (let l = 0, u = o.length; l < u; l++)
          s[l] = n.COLOR_ATTACHMENT0 + l;
        s.length = o.length, a = !0;
      }
    } else
      s[0] !== n.BACK && (s[0] = n.BACK, a = !0);
    a && n.drawBuffers(s);
  }
  // texture
  activeTexture(e) {
    const { gl: i, currentTextureSlot: n, maxTextures: s } = this;
    e === void 0 && (e = i.TEXTURE0 + s - 1), n !== e && (i.activeTexture(e), this.currentTextureSlot = e);
  }
  bindTexture(e, i, n) {
    const { gl: s, currentTextureSlot: a, currentBoundTextures: o, maxTextures: l } = this;
    n === void 0 && (a === null ? n = s.TEXTURE0 + l - 1 : n = a);
    let u = o[n];
    u === void 0 && (u = { type: void 0, texture: void 0 }, o[n] = u), (u.type !== e || u.texture !== i) && (a !== n && (s.activeTexture(n), this.currentTextureSlot = n), s.bindTexture(e, i), u.type = e, u.texture = i);
  }
  bindBufferBase(e, i, n) {
    const { gl: s } = this, a = `${e}-${i}`;
    return this.currentBoundBufferBases[a] !== n ? (s.bindBufferBase(e, i, n), this.currentBoundBufferBases[a] = n, !0) : !1;
  }
  unbindTexture() {
    const { gl: e, currentTextureSlot: i, currentBoundTextures: n } = this, s = n[i];
    s !== void 0 && s.type !== void 0 && (e.bindTexture(s.type, null), s.type = void 0, s.texture = void 0);
  }
}
class Y$ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.extensions = e.extensions;
  }
  convert(e, i = wl) {
    const { gl: n, extensions: s } = this;
    let a;
    if (e === co) return n.UNSIGNED_BYTE;
    if (e === HH) return n.UNSIGNED_SHORT_4_4_4_4;
    if (e === WH) return n.UNSIGNED_SHORT_5_5_5_1;
    if (e === n3) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (e === $h) return n.BYTE;
    if (e === Jh) return n.SHORT;
    if (e === Lu) return n.UNSIGNED_SHORT;
    if (e === wr) return n.INT;
    if (e === er) return n.UNSIGNED_INT;
    if (e === on) return n.FLOAT;
    if (e === pa)
      return n.HALF_FLOAT;
    if (e === qH) return n.ALPHA;
    if (e === n1) return n.RGB;
    if (e === Bc) return n.RGBA;
    if (e === XH) return n.LUMINANCE;
    if (e === YH) return n.LUMINANCE_ALPHA;
    if (e === gl) return n.DEPTH_COMPONENT;
    if (e === Tc) return n.DEPTH_STENCIL;
    if (e === s1) return n.RED;
    if (e === a1) return n.RED_INTEGER;
    if (e === gd) return n.RG;
    if (e === o1) return n.RG_INTEGER;
    if (e === l1) return n.RGBA_INTEGER;
    if (e === f0 || e === tm || e === im || e === rm)
      if (i === ct)
        if (a = s.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (e === f0) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (e === tm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (e === im) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (e === rm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = s.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (e === f0) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (e === tm) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (e === im) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (e === rm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (e === ME || e === AE || e === CE || e === RE)
      if (a = s.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (e === ME) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (e === AE) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (e === CE) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (e === RE) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (e === NE || e === Jb || e === ex)
      if (a = s.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (e === NE || e === Jb) return i === ct ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (e === ex) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (e === tx || e === ix || e === rx || e === nx || e === sx || e === ax || e === ox || e === lx || e === ux || e === cx || e === hx || e === dx || e === px || e === fx)
      if (a = s.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (e === tx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (e === ix) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (e === rx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (e === nx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (e === sx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (e === ax) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (e === ox) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (e === lx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (e === ux) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (e === cx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (e === hx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (e === dx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (e === px) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (e === fx) return i === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (e === m0)
      if (a = s.get("EXT_texture_compression_bptc"), a !== null) {
        if (e === m0) return i === ct ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    if (e === ZH || e === PE || e === IE || e === OE)
      if (a = s.get("EXT_texture_compression_rgtc"), a !== null) {
        if (e === m0) return a.COMPRESSED_RED_RGTC1_EXT;
        if (e === PE) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (e === IE) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (e === OE) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return e === Kd ? n.UNSIGNED_INT_24_8 : n[e] !== void 0 ? n[e] : null;
  }
  _clientWaitAsync() {
    const { gl: e } = this, i = e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE, 0);
    return e.flush(), new Promise((n, s) => {
      function a() {
        const o = e.clientWaitSync(i, e.SYNC_FLUSH_COMMANDS_BIT, 0);
        if (o === e.WAIT_FAILED) {
          e.deleteSync(i), s();
          return;
        }
        if (o === e.TIMEOUT_EXPIRED) {
          requestAnimationFrame(a);
          return;
        }
        e.deleteSync(i), n();
      }
      a();
    });
  }
}
let dM = !1, Ef, gv, pM;
class K$ {
  constructor(e) {
    this.backend = e, this.gl = e.gl, this.extensions = e.extensions, this.defaultTextures = {}, dM === !1 && (this._init(this.gl), dM = !0);
  }
  _init(e) {
    Ef = {
      [Um]: e.REPEAT,
      [Du]: e.CLAMP_TO_EDGE,
      [Fm]: e.MIRRORED_REPEAT
    }, gv = {
      [yr]: e.NEAREST,
      [Qb]: e.NEAREST_MIPMAP_NEAREST,
      [Zu]: e.NEAREST_MIPMAP_LINEAR,
      [ln]: e.LINEAR,
      [$b]: e.LINEAR_MIPMAP_NEAREST,
      [da]: e.LINEAR_MIPMAP_LINEAR
    }, pM = {
      [a3]: e.NEVER,
      [d3]: e.ALWAYS,
      [u1]: e.LESS,
      [l3]: e.LEQUAL,
      [o3]: e.EQUAL,
      [h3]: e.GEQUAL,
      [u3]: e.GREATER,
      [c3]: e.NOTEQUAL
    };
  }
  filterFallback(e) {
    const { gl: i } = this;
    return e === yr || e === Qb || e === Zu ? i.NEAREST : i.LINEAR;
  }
  getGLTextureType(e) {
    const { gl: i } = this;
    let n;
    return e.isCubeTexture === !0 ? n = i.TEXTURE_CUBE_MAP : e.isDataArrayTexture === !0 || e.isCompressedArrayTexture === !0 ? n = i.TEXTURE_2D_ARRAY : e.isData3DTexture === !0 ? n = i.TEXTURE_3D : n = i.TEXTURE_2D, n;
  }
  getInternalFormat(e, i, n, s, a = !1) {
    const { gl: o, extensions: l } = this;
    if (e !== null) {
      if (o[e] !== void 0) return o[e];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e + "'");
    }
    let u = i;
    return i === o.RED && (n === o.FLOAT && (u = o.R32F), n === o.HALF_FLOAT && (u = o.R16F), n === o.UNSIGNED_BYTE && (u = o.R8), n === o.UNSIGNED_SHORT && (u = o.R16), n === o.UNSIGNED_INT && (u = o.R32UI), n === o.BYTE && (u = o.R8I), n === o.SHORT && (u = o.R16I), n === o.INT && (u = o.R32I)), i === o.RED_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.R8UI), n === o.UNSIGNED_SHORT && (u = o.R16UI), n === o.UNSIGNED_INT && (u = o.R32UI), n === o.BYTE && (u = o.R8I), n === o.SHORT && (u = o.R16I), n === o.INT && (u = o.R32I)), i === o.RG && (n === o.FLOAT && (u = o.RG32F), n === o.HALF_FLOAT && (u = o.RG16F), n === o.UNSIGNED_BYTE && (u = o.RG8), n === o.UNSIGNED_SHORT && (u = o.RG16), n === o.UNSIGNED_INT && (u = o.RG32UI), n === o.BYTE && (u = o.RG8I), n === o.SHORT && (u = o.RG16I), n === o.INT && (u = o.RG32I)), i === o.RG_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RG8UI), n === o.UNSIGNED_SHORT && (u = o.RG16UI), n === o.UNSIGNED_INT && (u = o.RG32UI), n === o.BYTE && (u = o.RG8I), n === o.SHORT && (u = o.RG16I), n === o.INT && (u = o.RG32I)), i === o.RGB && (n === o.FLOAT && (u = o.RGB32F), n === o.HALF_FLOAT && (u = o.RGB16F), n === o.UNSIGNED_BYTE && (u = o.RGB8), n === o.UNSIGNED_SHORT && (u = o.RGB16), n === o.UNSIGNED_INT && (u = o.RGB32UI), n === o.BYTE && (u = o.RGB8I), n === o.SHORT && (u = o.RGB16I), n === o.INT && (u = o.RGB32I), n === o.UNSIGNED_BYTE && (u = s === ct && a === !1 ? o.SRGB8 : o.RGB8), n === o.UNSIGNED_SHORT_5_6_5 && (u = o.RGB565), n === o.UNSIGNED_SHORT_5_5_5_1 && (u = o.RGB5_A1), n === o.UNSIGNED_SHORT_4_4_4_4 && (u = o.RGB4), n === o.UNSIGNED_INT_5_9_9_9_REV && (u = o.RGB9_E5)), i === o.RGB_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RGB8UI), n === o.UNSIGNED_SHORT && (u = o.RGB16UI), n === o.UNSIGNED_INT && (u = o.RGB32UI), n === o.BYTE && (u = o.RGB8I), n === o.SHORT && (u = o.RGB16I), n === o.INT && (u = o.RGB32I)), i === o.RGBA && (n === o.FLOAT && (u = o.RGBA32F), n === o.HALF_FLOAT && (u = o.RGBA16F), n === o.UNSIGNED_BYTE && (u = o.RGBA8), n === o.UNSIGNED_SHORT && (u = o.RGBA16), n === o.UNSIGNED_INT && (u = o.RGBA32UI), n === o.BYTE && (u = o.RGBA8I), n === o.SHORT && (u = o.RGBA16I), n === o.INT && (u = o.RGBA32I), n === o.UNSIGNED_BYTE && (u = s === ct && a === !1 ? o.SRGB8_ALPHA8 : o.RGBA8), n === o.UNSIGNED_SHORT_4_4_4_4 && (u = o.RGBA4), n === o.UNSIGNED_SHORT_5_5_5_1 && (u = o.RGB5_A1)), i === o.RGBA_INTEGER && (n === o.UNSIGNED_BYTE && (u = o.RGBA8UI), n === o.UNSIGNED_SHORT && (u = o.RGBA16UI), n === o.UNSIGNED_INT && (u = o.RGBA32UI), n === o.BYTE && (u = o.RGBA8I), n === o.SHORT && (u = o.RGBA16I), n === o.INT && (u = o.RGBA32I)), i === o.DEPTH_COMPONENT && (n === o.UNSIGNED_INT && (u = o.DEPTH24_STENCIL8), n === o.FLOAT && (u = o.DEPTH_COMPONENT32F)), i === o.DEPTH_STENCIL && n === o.UNSIGNED_INT_24_8 && (u = o.DEPTH24_STENCIL8), (u === o.R16F || u === o.R32F || u === o.RG16F || u === o.RG32F || u === o.RGBA16F || u === o.RGBA32F) && l.get("EXT_color_buffer_float"), u;
  }
  setTextureParameters(e, i) {
    const { gl: n, extensions: s, backend: a } = this;
    n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, i.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, i.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE), n.texParameteri(e, n.TEXTURE_WRAP_S, Ef[i.wrapS]), n.texParameteri(e, n.TEXTURE_WRAP_T, Ef[i.wrapT]), (e === n.TEXTURE_3D || e === n.TEXTURE_2D_ARRAY) && n.texParameteri(e, n.TEXTURE_WRAP_R, Ef[i.wrapR]), n.texParameteri(e, n.TEXTURE_MAG_FILTER, gv[i.magFilter]);
    const o = i.mipmaps !== void 0 && i.mipmaps.length > 0, l = i.minFilter === ln && o ? da : i.minFilter;
    if (n.texParameteri(e, n.TEXTURE_MIN_FILTER, gv[l]), i.compareFunction && (n.texParameteri(e, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(e, n.TEXTURE_COMPARE_FUNC, pM[i.compareFunction])), s.has("EXT_texture_filter_anisotropic") === !0) {
      if (i.magFilter === yr || i.minFilter !== Zu && i.minFilter !== da || i.type === on && s.has("OES_texture_float_linear") === !1) return;
      if (i.anisotropy > 1) {
        const u = s.get("EXT_texture_filter_anisotropic");
        n.texParameterf(e, u.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i.anisotropy, a.getMaxAnisotropy()));
      }
    }
  }
  createDefaultTexture(e) {
    const { gl: i, backend: n, defaultTextures: s } = this, a = this.getGLTextureType(e);
    let o = s[a];
    o === void 0 && (o = i.createTexture(), n.state.bindTexture(a, o), i.texParameteri(a, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(a, i.TEXTURE_MAG_FILTER, i.NEAREST), s[a] = o), n.set(e, {
      textureGPU: o,
      glTextureType: a,
      isDefault: !0
    });
  }
  createTexture(e, i) {
    const { gl: n, backend: s } = this, { levels: a, width: o, height: l, depth: u } = i, c = s.utils.convert(e.format, e.colorSpace), h = s.utils.convert(e.type), d = this.getInternalFormat(e.internalFormat, c, h, e.colorSpace, e.isVideoTexture), p = n.createTexture(), f = this.getGLTextureType(e);
    s.state.bindTexture(f, p), this.setTextureParameters(f, e), e.isDataArrayTexture || e.isCompressedArrayTexture ? n.texStorage3D(n.TEXTURE_2D_ARRAY, a, d, o, l, u) : e.isData3DTexture ? n.texStorage3D(n.TEXTURE_3D, a, d, o, l, u) : e.isVideoTexture || n.texStorage2D(f, a, d, o, l), s.set(e, {
      textureGPU: p,
      glTextureType: f,
      glFormat: c,
      glType: h,
      glInternalFormat: d
    });
  }
  copyBufferToTexture(e, i) {
    const { gl: n, backend: s } = this, { textureGPU: a, glTextureType: o, glFormat: l, glType: u } = s.get(i), { width: c, height: h } = i.source.data;
    n.bindBuffer(n.PIXEL_UNPACK_BUFFER, e), s.state.bindTexture(o, a), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), n.texSubImage2D(o, 0, 0, 0, c, h, l, u, 0), n.bindBuffer(n.PIXEL_UNPACK_BUFFER, null), s.state.unbindTexture();
  }
  updateTexture(e, i) {
    const { gl: n } = this, { width: s, height: a } = i, { textureGPU: o, glTextureType: l, glFormat: u, glType: c, glInternalFormat: h } = this.backend.get(e);
    if (e.isRenderTargetTexture || o === void 0)
      return;
    const d = (p) => p.isDataTexture ? p.image.data : p instanceof ImageBitmap || p instanceof OffscreenCanvas || p instanceof HTMLImageElement || p instanceof HTMLCanvasElement ? p : p.data;
    if (this.backend.state.bindTexture(l, o), this.setTextureParameters(l, e), e.isCompressedTexture) {
      const p = e.mipmaps, f = i.image;
      for (let m = 0; m < p.length; m++) {
        const y = p[m];
        e.isCompressedArrayTexture ? e.format !== n.RGBA ? u !== null ? n.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, m, 0, 0, 0, y.width, y.height, f.depth, u, y.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texSubImage3D(n.TEXTURE_2D_ARRAY, m, 0, 0, 0, y.width, y.height, f.depth, u, c, y.data) : u !== null ? n.compressedTexSubImage2D(n.TEXTURE_2D, m, 0, 0, y.width, y.height, u, y.data) : console.warn("Unsupported compressed texture format");
      }
    } else if (e.isCubeTexture) {
      const p = i.images;
      for (let f = 0; f < 6; f++) {
        const m = d(p[f]);
        n.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, 0, 0, s, a, u, c, m);
      }
    } else if (e.isDataArrayTexture) {
      const p = i.image;
      n.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, u, c, p.data);
    } else if (e.isData3DTexture) {
      const p = i.image;
      n.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, u, c, p.data);
    } else if (e.isVideoTexture)
      e.update(), n.texImage2D(l, 0, h, u, c, i.image);
    else {
      const p = d(i.image);
      n.texSubImage2D(l, 0, 0, 0, s, a, u, c, p);
    }
  }
  generateMipmaps(e) {
    const { gl: i, backend: n } = this, { textureGPU: s, glTextureType: a } = n.get(e);
    n.state.bindTexture(a, s), i.generateMipmap(a);
  }
  deallocateRenderBuffers(e) {
    const { gl: i, backend: n } = this;
    if (e) {
      const s = n.get(e);
      if (s.renderBufferStorageSetup = void 0, s.framebuffers) {
        for (const a in s.framebuffers)
          i.deleteFramebuffer(s.framebuffers[a]);
        delete s.framebuffers;
      }
      if (s.depthRenderbuffer && (i.deleteRenderbuffer(s.depthRenderbuffer), delete s.depthRenderbuffer), s.stencilRenderbuffer && (i.deleteRenderbuffer(s.stencilRenderbuffer), delete s.stencilRenderbuffer), s.msaaFrameBuffer && (i.deleteFramebuffer(s.msaaFrameBuffer), delete s.msaaFrameBuffer), s.msaaRenderbuffers) {
        for (let a = 0; a < s.msaaRenderbuffers.length; a++)
          i.deleteRenderbuffer(s.msaaRenderbuffers[a]);
        delete s.msaaRenderbuffers;
      }
    }
  }
  destroyTexture(e) {
    const { gl: i, backend: n } = this, { textureGPU: s, renderTarget: a } = n.get(e);
    this.deallocateRenderBuffers(a), i.deleteTexture(s), n.delete(e);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    const { gl: o, backend: l } = this, { state: u } = this.backend, { textureGPU: c, glTextureType: h, glType: d, glFormat: p } = l.get(i);
    let f, m, y, v, g, _;
    n !== null ? (f = n.max.x - n.min.x, m = n.max.y - n.min.y, y = n.min.x, v = n.min.y) : (f = e.image.width, m = e.image.height, y = 0, v = 0), s !== null ? (g = s.x, _ = s.y) : (g = 0, _ = 0), u.bindTexture(h, c), o.pixelStorei(o.UNPACK_ALIGNMENT, i.unpackAlignment), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, i.flipY), o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), o.pixelStorei(o.UNPACK_ALIGNMENT, i.unpackAlignment);
    const x = o.getParameter(o.UNPACK_ROW_LENGTH), b = o.getParameter(o.UNPACK_IMAGE_HEIGHT), T = o.getParameter(o.UNPACK_SKIP_PIXELS), E = o.getParameter(o.UNPACK_SKIP_ROWS), M = o.getParameter(o.UNPACK_SKIP_IMAGES), C = e.isCompressedTexture ? e.mipmaps[a] : e.image;
    if (o.pixelStorei(o.UNPACK_ROW_LENGTH, C.width), o.pixelStorei(o.UNPACK_IMAGE_HEIGHT, C.height), o.pixelStorei(o.UNPACK_SKIP_PIXELS, y), o.pixelStorei(o.UNPACK_SKIP_ROWS, v), e.isRenderTargetTexture || e.isDepthTexture) {
      const S = l.get(e), w = l.get(i), R = l.get(S.renderTarget), O = l.get(w.renderTarget), P = R.framebuffers[S.cacheKey], A = O.framebuffers[w.cacheKey];
      u.bindFramebuffer(o.READ_FRAMEBUFFER, P), u.bindFramebuffer(o.DRAW_FRAMEBUFFER, A);
      let D = o.COLOR_BUFFER_BIT;
      e.isDepthTexture && (D = o.DEPTH_BUFFER_BIT), o.blitFramebuffer(y, v, f, m, g, _, f, m, D, o.NEAREST), u.bindFramebuffer(o.READ_FRAMEBUFFER, null), u.bindFramebuffer(o.DRAW_FRAMEBUFFER, null);
    } else
      e.isDataTexture ? o.texSubImage2D(o.TEXTURE_2D, a, g, _, f, m, p, d, C.data) : e.isCompressedTexture ? o.compressedTexSubImage2D(o.TEXTURE_2D, a, g, _, C.width, C.height, p, C.data) : o.texSubImage2D(o.TEXTURE_2D, a, g, _, f, m, p, d, C);
    o.pixelStorei(o.UNPACK_ROW_LENGTH, x), o.pixelStorei(o.UNPACK_IMAGE_HEIGHT, b), o.pixelStorei(o.UNPACK_SKIP_PIXELS, T), o.pixelStorei(o.UNPACK_SKIP_ROWS, E), o.pixelStorei(o.UNPACK_SKIP_IMAGES, M), a === 0 && i.generateMipmaps && o.generateMipmap(o.TEXTURE_2D), u.unbindTexture();
  }
  copyFramebufferToTexture(e, i, n) {
    const { gl: s } = this, { state: a } = this.backend, { textureGPU: o } = this.backend.get(e), { x: l, y: u, z: c, w: h } = n, d = e.isDepthTexture === !0 || i.renderTarget && i.renderTarget.samples > 0, p = i.renderTarget ? i.renderTarget.height : this.backend.gerDrawingBufferSize().y;
    if (d) {
      const f = l !== 0 || u !== 0;
      let m, y;
      if (e.isDepthTexture === !0 ? (m = s.DEPTH_BUFFER_BIT, y = s.DEPTH_ATTACHMENT, i.stencil && (m |= s.STENCIL_BUFFER_BIT)) : (m = s.COLOR_BUFFER_BIT, y = s.COLOR_ATTACHMENT0), f) {
        const v = this.backend.get(i.renderTarget), g = v.framebuffers[i.getCacheKey()], _ = v.msaaFrameBuffer;
        a.bindFramebuffer(s.DRAW_FRAMEBUFFER, g), a.bindFramebuffer(s.READ_FRAMEBUFFER, _);
        const x = p - u - h;
        s.blitFramebuffer(l, x, l + c, x + h, l, x, l + c, x + h, m, s.NEAREST), a.bindFramebuffer(s.READ_FRAMEBUFFER, g), a.bindTexture(s.TEXTURE_2D, o), s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, l, x, c, h), a.unbindTexture();
      } else {
        const v = s.createFramebuffer();
        a.bindFramebuffer(s.DRAW_FRAMEBUFFER, v), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, y, s.TEXTURE_2D, o, 0), s.blitFramebuffer(0, 0, c, h, 0, 0, c, h, m, s.NEAREST), s.deleteFramebuffer(v);
      }
    } else
      a.bindTexture(s.TEXTURE_2D, o), s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, l, p - h - u, c, h), a.unbindTexture();
    e.generateMipmaps && this.generateMipmaps(e), this.backend._setFramebuffer(i);
  }
  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  setupRenderBufferStorage(e, i) {
    const { gl: n } = this, s = i.renderTarget, { samples: a, depthTexture: o, depthBuffer: l, stencilBuffer: u, width: c, height: h } = s;
    if (n.bindRenderbuffer(n.RENDERBUFFER, e), l && !u) {
      let d = n.DEPTH_COMPONENT24;
      a > 0 ? (o && o.isDepthTexture && o.type === n.FLOAT && (d = n.DEPTH_COMPONENT32F), n.renderbufferStorageMultisample(n.RENDERBUFFER, a, d, c, h)) : n.renderbufferStorage(n.RENDERBUFFER, d, c, h), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, e);
    } else l && u && (a > 0 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, a, n.DEPTH24_STENCIL8, c, h) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, c, h), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, e));
  }
  async copyTextureToBuffer(e, i, n, s, a, o) {
    const { backend: l, gl: u } = this, { textureGPU: c, glFormat: h, glType: d } = this.backend.get(e), p = u.createFramebuffer();
    u.bindFramebuffer(u.READ_FRAMEBUFFER, p);
    const f = e.isCubeTexture ? u.TEXTURE_CUBE_MAP_POSITIVE_X + o : u.TEXTURE_2D;
    u.framebufferTexture2D(u.READ_FRAMEBUFFER, u.COLOR_ATTACHMENT0, f, c, 0);
    const m = this._getTypedArrayType(d), y = this._getBytesPerTexel(d, h), v = s * a * y, g = u.createBuffer();
    u.bindBuffer(u.PIXEL_PACK_BUFFER, g), u.bufferData(u.PIXEL_PACK_BUFFER, v, u.STREAM_READ), u.readPixels(i, n, s, a, h, d, 0), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), await l.utils._clientWaitAsync();
    const _ = new m(v / m.BYTES_PER_ELEMENT);
    return u.bindBuffer(u.PIXEL_PACK_BUFFER, g), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, _), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), u.deleteFramebuffer(p), _;
  }
  _getTypedArrayType(e) {
    const { gl: i } = this;
    if (e === i.UNSIGNED_BYTE) return Uint8Array;
    if (e === i.UNSIGNED_SHORT_4_4_4_4 || e === i.UNSIGNED_SHORT_5_5_5_1 || e === i.UNSIGNED_SHORT_5_6_5 || e === i.UNSIGNED_SHORT) return Uint16Array;
    if (e === i.UNSIGNED_INT) return Uint32Array;
    if (e === i.HALF_FLOAT) return Uint16Array;
    if (e === i.FLOAT) return Float32Array;
    throw new Error(`Unsupported WebGL type: ${e}`);
  }
  _getBytesPerTexel(e, i) {
    const { gl: n } = this;
    let s = 0;
    if (e === n.UNSIGNED_BYTE && (s = 1), (e === n.UNSIGNED_SHORT_4_4_4_4 || e === n.UNSIGNED_SHORT_5_5_5_1 || e === n.UNSIGNED_SHORT_5_6_5 || e === n.UNSIGNED_SHORT || e === n.HALF_FLOAT) && (s = 2), (e === n.UNSIGNED_INT || e === n.FLOAT) && (s = 4), i === n.RGBA) return s * 4;
    if (i === n.RGB) return s * 3;
    if (i === n.ALPHA) return s;
  }
}
class Z$ {
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.availableExtensions = this.gl.getSupportedExtensions(), this.extensions = {};
  }
  get(e) {
    let i = this.extensions[e];
    return i === void 0 && (i = this.gl.getExtension(e), this.extensions[e] = i), i;
  }
  has(e) {
    return this.availableExtensions.includes(e);
  }
}
class Q$ {
  constructor(e) {
    this.backend = e, this.maxAnisotropy = null;
  }
  getMaxAnisotropy() {
    if (this.maxAnisotropy !== null) return this.maxAnisotropy;
    const e = this.backend.gl, i = this.backend.extensions;
    if (i.has("EXT_texture_filter_anisotropic") === !0) {
      const n = i.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      this.maxAnisotropy = 0;
    return this.maxAnisotropy;
  }
}
const fM = {
  WEBGL_multi_draw: "WEBGL_multi_draw",
  WEBGL_compressed_texture_astc: "texture-compression-astc",
  WEBGL_compressed_texture_etc: "texture-compression-etc2",
  WEBGL_compressed_texture_etc1: "texture-compression-etc1",
  WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBKIT_WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBGL_compressed_texture_s3tc: "texture-compression-bc",
  EXT_texture_compression_bptc: "texture-compression-bptc",
  EXT_disjoint_timer_query_webgl2: "timestamp-query"
};
class $$ {
  constructor(e) {
    this.gl = e.gl, this.extensions = e.extensions, this.info = e.renderer.info, this.mode = null, this.index = 0, this.type = null, this.object = null;
  }
  render(e, i) {
    const { gl: n, mode: s, object: a, type: o, info: l, index: u } = this;
    u !== 0 ? n.drawElements(s, i, o, e) : n.drawArrays(s, e, i), l.update(a, i, s, 1);
  }
  renderInstances(e, i, n) {
    const { gl: s, mode: a, type: o, index: l, object: u, info: c } = this;
    n !== 0 && (l !== 0 ? s.drawElementsInstanced(a, i, o, e, n) : s.drawArraysInstanced(a, e, i, n), c.update(u, i, a, n));
  }
  renderMultiDraw(e, i, n) {
    const { extensions: s, mode: a, object: o, info: l } = this;
    if (n === 0) return;
    const u = s.get("WEBGL_multi_draw");
    if (u === null)
      for (let c = 0; c < n; c++)
        this.render(e[c], i[c]);
    else {
      this.index !== 0 ? u.multiDrawElementsWEBGL(a, i, 0, this.type, e, 0, n) : u.multiDrawArraysWEBGL(a, e, 0, i, 0, n);
      let c = 0;
      for (let h = 0; h < n; h++)
        c += i[h];
      l.update(o, c, a, 1);
    }
  }
  renderMultiDrawInstances(e, i, n, s) {
    const { extensions: a, mode: o, object: l, info: u } = this;
    if (n === 0) return;
    const c = a.get("WEBGL_multi_draw");
    if (c === null)
      for (let h = 0; h < n; h++)
        this.renderInstances(e[h], i[h], s[h]);
    else {
      this.index !== 0 ? c.multiDrawElementsInstancedWEBGL(o, i, 0, this.type, e, 0, s, 0, n) : c.multiDrawArraysInstancedWEBGL(o, e, 0, i, 0, s, 0, n);
      let h = 0;
      for (let d = 0; d < n; d++)
        h += i[d] * s[d];
      u.update(l, h, o, 1);
    }
  }
  //
}
class mM extends dI {
  constructor(e = {}) {
    super(e), this.isWebGLBackend = !0;
  }
  init(e) {
    super.init(e);
    const i = this.parameters, n = i.context !== void 0 ? i.context : e.domElement.getContext("webgl2");
    function s(a) {
      a.preventDefault();
      const o = {
        api: "WebGL",
        message: a.statusMessage || "Unknown reason",
        reason: null,
        originalEvent: a
      };
      e.onDeviceLost(o);
    }
    this._onContextLost = s, e.domElement.addEventListener("webglcontextlost", s, !1), this.gl = n, this.extensions = new Z$(this), this.capabilities = new Q$(this), this.attributeUtils = new q$(this), this.textureUtils = new K$(this), this.bufferRenderer = new $$(this), this.state = new X$(this), this.utils = new Y$(this), this.vaoCache = {}, this.transformFeedbackCache = {}, this.discard = !1, this.trackTimestamp = i.trackTimestamp === !0, this.extensions.get("EXT_color_buffer_float"), this.extensions.get("WEBGL_clip_cull_distance"), this.extensions.get("OES_texture_float_linear"), this.extensions.get("EXT_color_buffer_half_float"), this.extensions.get("WEBGL_multisampled_render_to_texture"), this.extensions.get("WEBGL_render_shared_exponent"), this.extensions.get("WEBGL_multi_draw"), this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2"), this.parallel = this.extensions.get("KHR_parallel_shader_compile"), this._knownBindings = /* @__PURE__ */ new WeakSet(), this._currentContext = null;
  }
  get coordinateSystem() {
    return Kn;
  }
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  async waitForGPU() {
    await this.utils._clientWaitAsync();
  }
  initTimestampQuery(e) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const i = this.get(e);
    if (this.queryRunning) {
      i.queryQueue || (i.queryQueue = []), i.queryQueue.push(e);
      return;
    }
    i.activeQuery && (this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT), i.activeQuery = null), i.activeQuery = this.gl.createQuery(), i.activeQuery !== null && (this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT, i.activeQuery), this.queryRunning = !0);
  }
  // timestamp utils
  prepareTimestampBuffer(e) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const i = this.get(e);
    if (i.activeQuery && (this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT), i.gpuQueries || (i.gpuQueries = []), i.gpuQueries.push({ query: i.activeQuery }), i.activeQuery = null, this.queryRunning = !1, i.queryQueue && i.queryQueue.length > 0)) {
      const n = i.queryQueue.shift();
      this.initTimestampQuery(n);
    }
  }
  async resolveTimestampAsync(e, i = "render") {
    if (!this.disjoint || !this.trackTimestamp) return;
    const n = this.get(e);
    n.gpuQueries || (n.gpuQueries = []);
    for (let s = 0; s < n.gpuQueries.length; s++) {
      const a = n.gpuQueries[s], o = this.gl.getQueryParameter(a.query, this.gl.QUERY_RESULT_AVAILABLE), l = this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);
      if (o && !l) {
        const u = this.gl.getQueryParameter(a.query, this.gl.QUERY_RESULT), c = Number(u) / 1e6;
        this.gl.deleteQuery(a.query), n.gpuQueries.splice(s, 1), s--, this.renderer.info.updateTimestamp(i, c);
      }
    }
  }
  getContext() {
    return this.gl;
  }
  beginRender(e) {
    const { gl: i } = this, n = this.get(e);
    if (this.initTimestampQuery(e), n.previousContext = this._currentContext, this._currentContext = e, this._setFramebuffer(e), this.clear(e.clearColor, e.clearDepth, e.clearStencil, e, !1), e.viewport ? this.updateViewport(e) : i.viewport(0, 0, i.drawingBufferWidth, i.drawingBufferHeight), e.scissor) {
      const { x: a, y: o, width: l, height: u } = e.scissorValue;
      i.scissor(a, e.height - u - o, l, u);
    }
    const s = e.occlusionQueryCount;
    s > 0 && (n.currentOcclusionQueries = n.occlusionQueries, n.currentOcclusionQueryObjects = n.occlusionQueryObjects, n.lastOcclusionObject = null, n.occlusionQueries = new Array(s), n.occlusionQueryObjects = new Array(s), n.occlusionQueryIndex = 0);
  }
  finishRender(e) {
    const { gl: i, state: n } = this, s = this.get(e), a = s.previousContext, o = e.occlusionQueryCount;
    o > 0 && (o > s.occlusionQueryIndex && i.endQuery(i.ANY_SAMPLES_PASSED), this.resolveOccludedAsync(e));
    const l = e.textures;
    if (l !== null)
      for (let u = 0; u < l.length; u++) {
        const c = l[u];
        c.generateMipmaps && this.generateMipmaps(c);
      }
    if (this._currentContext = a, e.textures !== null && e.renderTarget) {
      const u = this.get(e.renderTarget), { samples: c } = e.renderTarget;
      if (c > 0) {
        const h = u.framebuffers[e.getCacheKey()], d = i.COLOR_BUFFER_BIT, p = u.msaaFrameBuffer, f = e.textures;
        n.bindFramebuffer(i.READ_FRAMEBUFFER, p), n.bindFramebuffer(i.DRAW_FRAMEBUFFER, h);
        for (let m = 0; m < f.length; m++)
          if (e.scissor) {
            const { x: y, y: v, width: g, height: _ } = e.scissorValue, x = e.height - _ - v;
            i.blitFramebuffer(y, x, y + g, x + _, y, x, y + g, x + _, d, i.NEAREST), i.invalidateSubFramebuffer(i.READ_FRAMEBUFFER, u.invalidationArray, y, x, g, _);
          } else
            i.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, d, i.NEAREST), i.invalidateFramebuffer(i.READ_FRAMEBUFFER, u.invalidationArray);
      }
    }
    a !== null && (this._setFramebuffer(a), a.viewport ? this.updateViewport(a) : i.viewport(0, 0, i.drawingBufferWidth, i.drawingBufferHeight)), this.prepareTimestampBuffer(e);
  }
  resolveOccludedAsync(e) {
    const i = this.get(e), { currentOcclusionQueries: n, currentOcclusionQueryObjects: s } = i;
    if (n && s) {
      const a = /* @__PURE__ */ new WeakSet(), { gl: o } = this;
      i.currentOcclusionQueryObjects = null, i.currentOcclusionQueries = null;
      const l = () => {
        let u = 0;
        for (let c = 0; c < n.length; c++) {
          const h = n[c];
          h !== null && o.getQueryParameter(h, o.QUERY_RESULT_AVAILABLE) && (o.getQueryParameter(h, o.QUERY_RESULT) > 0 && a.add(s[c]), n[c] = null, o.deleteQuery(h), u++);
        }
        u < n.length ? requestAnimationFrame(l) : i.occluded = a;
      };
      l();
    }
  }
  isOccluded(e, i) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(i);
  }
  updateViewport(e) {
    const i = this.gl, { x: n, y: s, width: a, height: o } = e.viewportValue;
    i.viewport(n, e.height - o - s, a, o);
  }
  setScissorTest(e) {
    const i = this.gl;
    e ? i.enable(i.SCISSOR_TEST) : i.disable(i.SCISSOR_TEST);
  }
  clear(e, i, n, s = null, a = !0) {
    const { gl: o } = this;
    if (s === null) {
      const u = this.getClearColor();
      u.r *= u.a, u.g *= u.a, u.b *= u.a, s = {
        textures: null,
        clearColorValue: u
      };
    }
    let l = 0;
    if (e && (l |= o.COLOR_BUFFER_BIT), i && (l |= o.DEPTH_BUFFER_BIT), n && (l |= o.STENCIL_BUFFER_BIT), l !== 0) {
      let u;
      if (s.clearColorValue ? u = s.clearColorValue : (u = this.getClearColor(), u.r *= u.a, u.g *= u.a, u.b *= u.a), i && this.state.setDepthMask(!0), s.textures === null)
        o.clearColor(u.r, u.g, u.b, u.a), o.clear(l);
      else {
        if (a && this._setFramebuffer(s), e)
          for (let c = 0; c < s.textures.length; c++)
            o.clearBufferfv(o.COLOR, c, [u.r, u.g, u.b, u.a]);
        i && n ? o.clearBufferfi(o.DEPTH_STENCIL, 0, 1, 0) : i ? o.clearBufferfv(o.DEPTH, 0, [1]) : n && o.clearBufferiv(o.STENCIL, 0, [0]);
      }
    }
  }
  beginCompute(e) {
    const { state: i, gl: n } = this;
    i.bindFramebuffer(n.FRAMEBUFFER, null), this.initTimestampQuery(e);
  }
  compute(e, i, n, s) {
    const { state: a, gl: o } = this;
    this.discard || (o.enable(o.RASTERIZER_DISCARD), this.discard = !0);
    const { programGPU: l, transformBuffers: u, attributes: c } = this.get(s), h = this._getVaoKey(null, c), d = this.vaoCache[h];
    d === void 0 ? this._createVao(null, c) : o.bindVertexArray(d), a.useProgram(l), this._bindUniforms(n);
    const p = this._getTransformFeedback(u);
    o.bindTransformFeedback(o.TRANSFORM_FEEDBACK, p), o.beginTransformFeedback(o.POINTS), c[0].isStorageInstancedBufferAttribute ? o.drawArraysInstanced(o.POINTS, 0, 1, i.count) : o.drawArrays(o.POINTS, 0, i.count), o.endTransformFeedback(), o.bindTransformFeedback(o.TRANSFORM_FEEDBACK, null);
    for (let f = 0; f < u.length; f++) {
      const m = u[f];
      m.pbo && this.textureUtils.copyBufferToTexture(m.transformBuffer, m.pbo), m.switchBuffers();
    }
  }
  finishCompute(e) {
    const i = this.gl;
    this.discard = !1, i.disable(i.RASTERIZER_DISCARD), this.prepareTimestampBuffer(e), this._currentContext && this._setFramebuffer(this._currentContext);
  }
  draw(e) {
    const { object: i, pipeline: n, material: s, context: a } = e, { programGPU: o } = this.get(n), { gl: l, state: u } = this, c = this.get(a), h = e.getDrawParameters();
    if (h === null) return;
    this._bindUniforms(e.getBindings());
    const d = i.isMesh && i.matrixWorld.determinant() < 0;
    u.setMaterial(s, d), u.useProgram(o);
    let p = e.staticVao;
    if (p === void 0) {
      const x = this._getVaoKey(e.getIndex(), e.getAttributes());
      if (p = this.vaoCache[x], p === void 0) {
        let b;
        ({ vaoGPU: p, staticVao: b } = this._createVao(e.getIndex(), e.getAttributes())), b && (e.staticVao = p);
      }
    }
    l.bindVertexArray(p);
    const f = e.getIndex(), m = c.lastOcclusionObject;
    if (m !== i && m !== void 0) {
      if (m !== null && m.occlusionTest === !0 && (l.endQuery(l.ANY_SAMPLES_PASSED), c.occlusionQueryIndex++), i.occlusionTest === !0) {
        const x = l.createQuery();
        l.beginQuery(l.ANY_SAMPLES_PASSED, x), c.occlusionQueries[c.occlusionQueryIndex] = x, c.occlusionQueryObjects[c.occlusionQueryIndex] = i;
      }
      c.lastOcclusionObject = i;
    }
    const y = this.bufferRenderer;
    i.isPoints ? y.mode = l.POINTS : i.isLineSegments ? y.mode = l.LINES : i.isLine ? y.mode = l.LINE_STRIP : i.isLineLoop ? y.mode = l.LINE_LOOP : s.wireframe === !0 ? (u.setLineWidth(s.wireframeLinewidth * this.renderer.getPixelRatio()), y.mode = l.LINES) : y.mode = l.TRIANGLES;
    const { vertexCount: v, instanceCount: g } = h;
    let { firstVertex: _ } = h;
    if (y.object = i, f !== null) {
      _ *= f.array.BYTES_PER_ELEMENT;
      const x = this.get(f);
      y.index = f.count, y.type = x.type;
    } else
      y.index = 0;
    i.isBatchedMesh ? i._multiDrawInstances !== null ? y.renderMultiDrawInstances(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount, i._multiDrawInstances) : this.hasFeature("WEBGL_multi_draw") ? y.renderMultiDraw(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount) : P7("THREE.WebGLRenderer: WEBGL_multi_draw not supported.") : g > 1 ? y.renderInstances(_, v, g) : y.render(_, v), l.bindVertexArray(null);
  }
  needsRenderUpdate() {
    return !1;
  }
  getRenderCacheKey() {
    return "";
  }
  // textures
  createDefaultTexture(e) {
    this.textureUtils.createDefaultTexture(e);
  }
  createTexture(e, i) {
    this.textureUtils.createTexture(e, i);
  }
  updateTexture(e, i) {
    this.textureUtils.updateTexture(e, i);
  }
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  destroyTexture(e) {
    this.textureUtils.destroyTexture(e);
  }
  copyTextureToBuffer(e, i, n, s, a, o) {
    return this.textureUtils.copyTextureToBuffer(e, i, n, s, a, o);
  }
  createSampler() {
  }
  destroySampler() {
  }
  // node builder
  createNodeBuilder(e, i) {
    return new G$(e, i);
  }
  // program
  createProgram(e) {
    const i = this.gl, { stage: n, code: s } = e, a = n === "fragment" ? i.createShader(i.FRAGMENT_SHADER) : i.createShader(i.VERTEX_SHADER);
    i.shaderSource(a, s), i.compileShader(a), this.set(e, {
      shaderGPU: a
    });
  }
  destroyProgram() {
    console.warn("Abstract class.");
  }
  createRenderPipeline(e, i) {
    const n = this.gl, s = e.pipeline, { fragmentProgram: a, vertexProgram: o } = s, l = n.createProgram(), u = this.get(a).shaderGPU, c = this.get(o).shaderGPU;
    if (n.attachShader(l, u), n.attachShader(l, c), n.linkProgram(l), this.set(s, {
      programGPU: l,
      fragmentShader: u,
      vertexShader: c
    }), i !== null && this.parallel) {
      const h = new Promise((d) => {
        const p = this.parallel, f = () => {
          n.getProgramParameter(l, p.COMPLETION_STATUS_KHR) ? (this._completeCompile(e, s), d()) : requestAnimationFrame(f);
        };
        f();
      });
      i.push(h);
      return;
    }
    this._completeCompile(e, s);
  }
  _handleSource(e, i) {
    const n = e.split(`
`), s = [], a = Math.max(i - 6, 0), o = Math.min(i + 6, n.length);
    for (let l = a; l < o; l++) {
      const u = l + 1;
      s.push(`${u === i ? ">" : " "} ${u}: ${n[l]}`);
    }
    return s.join(`
`);
  }
  _getShaderErrors(e, i, n) {
    const s = e.getShaderParameter(i, e.COMPILE_STATUS), a = e.getShaderInfoLog(i).trim();
    if (s && a === "") return "";
    const o = /ERROR: 0:(\d+)/.exec(a);
    if (o) {
      const l = parseInt(o[1]);
      return n.toUpperCase() + `

` + a + `

` + this._handleSource(e.getShaderSource(i), l);
    } else
      return a;
  }
  _logProgramError(e, i, n) {
    if (this.renderer.debug.checkShaderErrors) {
      const s = this.gl, a = s.getProgramInfoLog(e).trim();
      if (s.getProgramParameter(e, s.LINK_STATUS) === !1)
        if (typeof this.renderer.debug.onShaderError == "function")
          this.renderer.debug.onShaderError(s, e, n, i);
        else {
          const o = this._getShaderErrors(s, n, "vertex"), l = this._getShaderErrors(s, i, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(e, s.VALIDATE_STATUS) + `

Program Info Log: ` + a + `
` + o + `
` + l
          );
        }
      else a !== "" && console.warn("THREE.WebGLProgram: Program Info Log:", a);
    }
  }
  _completeCompile(e, i) {
    const { state: n, gl: s } = this, a = this.get(i), { programGPU: o, fragmentShader: l, vertexShader: u } = a;
    s.getProgramParameter(o, s.LINK_STATUS) === !1 && this._logProgramError(o, l, u), n.useProgram(o);
    const c = e.getBindings();
    this._setupBindings(c, o), this.set(i, {
      programGPU: o
    });
  }
  createComputePipeline(e, i) {
    const { state: n, gl: s } = this, a = {
      stage: "fragment",
      code: `#version 300 es
precision highp float;
void main() {}`
    };
    this.createProgram(a);
    const { computeProgram: o } = e, l = s.createProgram(), u = this.get(a).shaderGPU, c = this.get(o).shaderGPU, h = o.transforms, d = [], p = [];
    for (let v = 0; v < h.length; v++) {
      const g = h[v];
      d.push(g.varyingName), p.push(g.attributeNode);
    }
    s.attachShader(l, u), s.attachShader(l, c), s.transformFeedbackVaryings(
      l,
      d,
      s.SEPARATE_ATTRIBS
    ), s.linkProgram(l), s.getProgramParameter(l, s.LINK_STATUS) === !1 && this._logProgramError(l, u, c), n.useProgram(l), this._setupBindings(i, l);
    const f = o.attributes, m = [], y = [];
    for (let v = 0; v < f.length; v++) {
      const g = f[v].node.attribute;
      m.push(g), this.has(g) || this.attributeUtils.createAttribute(g, s.ARRAY_BUFFER);
    }
    for (let v = 0; v < p.length; v++) {
      const g = p[v].attribute;
      this.has(g) || this.attributeUtils.createAttribute(g, s.ARRAY_BUFFER);
      const _ = this.get(g);
      y.push(_);
    }
    this.set(e, {
      programGPU: l,
      transformBuffers: y,
      attributes: m
    });
  }
  createBindings(e, i) {
    if (this._knownBindings.has(i) === !1) {
      this._knownBindings.add(i);
      let n = 0, s = 0;
      for (const a of i) {
        this.set(a, {
          textures: s,
          uniformBuffers: n
        });
        for (const o of a.bindings)
          o.isUniformBuffer && n++, o.isSampledTexture && s++;
      }
    }
    this.updateBindings(e, i);
  }
  updateBindings(e) {
    const { gl: i } = this, n = this.get(e);
    let s = n.uniformBuffers, a = n.textures;
    for (const o of e.bindings)
      if (o.isUniformsGroup || o.isUniformBuffer) {
        const l = o.buffer, u = i.createBuffer();
        i.bindBuffer(i.UNIFORM_BUFFER, u), i.bufferData(i.UNIFORM_BUFFER, l, i.DYNAMIC_DRAW), this.set(o, {
          index: s++,
          bufferGPU: u
        });
      } else if (o.isSampledTexture) {
        const { textureGPU: l, glTextureType: u } = this.get(o.texture);
        this.set(o, {
          index: a++,
          textureGPU: l,
          glTextureType: u
        });
      }
  }
  updateBinding(e) {
    const i = this.gl;
    if (e.isUniformsGroup || e.isUniformBuffer) {
      const n = this.get(e).bufferGPU, s = e.buffer;
      i.bindBuffer(i.UNIFORM_BUFFER, n), i.bufferData(i.UNIFORM_BUFFER, s, i.DYNAMIC_DRAW);
    }
  }
  // attributes
  createIndexAttribute(e) {
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ELEMENT_ARRAY_BUFFER);
  }
  createAttribute(e) {
    if (this.has(e)) return;
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ARRAY_BUFFER);
  }
  createStorageAttribute(e) {
    if (this.has(e)) return;
    const i = this.gl;
    this.attributeUtils.createAttribute(e, i.ARRAY_BUFFER);
  }
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  updateSize() {
  }
  hasFeature(e) {
    const i = Object.keys(fM).filter((s) => fM[s] === e), n = this.extensions;
    for (let s = 0; s < i.length; s++)
      if (n.has(i[s])) return !0;
    return !1;
  }
  getMaxAnisotropy() {
    return this.capabilities.getMaxAnisotropy();
  }
  copyTextureToTexture(e, i, n, s, a) {
    this.textureUtils.copyTextureToTexture(e, i, n, s, a);
  }
  copyFramebufferToTexture(e, i, n) {
    this.textureUtils.copyFramebufferToTexture(e, i, n);
  }
  _setFramebuffer(e) {
    const { gl: i, state: n } = this;
    let s = null;
    if (e.textures !== null) {
      const a = e.renderTarget, o = this.get(a), { samples: l, depthBuffer: u, stencilBuffer: c } = a, h = a.isWebGLCubeRenderTarget === !0;
      let d = o.msaaFrameBuffer, p = o.depthRenderbuffer;
      const f = YP(e);
      let m;
      if (h ? (o.cubeFramebuffers || (o.cubeFramebuffers = {}), m = o.cubeFramebuffers[f]) : (o.framebuffers || (o.framebuffers = {}), m = o.framebuffers[f]), m === void 0) {
        m = i.createFramebuffer(), n.bindFramebuffer(i.FRAMEBUFFER, m);
        const y = e.textures;
        if (h) {
          o.cubeFramebuffers[f] = m;
          const { textureGPU: v } = this.get(y[0]), g = this.renderer._activeCubeFace;
          i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + g, v, 0);
        } else {
          o.framebuffers[f] = m;
          for (let v = 0; v < y.length; v++) {
            const g = y[v], _ = this.get(g);
            _.renderTarget = e.renderTarget, _.cacheKey = f;
            const x = i.COLOR_ATTACHMENT0 + v;
            i.framebufferTexture2D(i.FRAMEBUFFER, x, i.TEXTURE_2D, _.textureGPU, 0);
          }
          n.drawBuffers(e, m);
        }
        if (e.depthTexture !== null) {
          const v = this.get(e.depthTexture), g = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
          v.renderTarget = e.renderTarget, v.cacheKey = f, i.framebufferTexture2D(i.FRAMEBUFFER, g, i.TEXTURE_2D, v.textureGPU, 0);
        }
      }
      if (l > 0) {
        if (d === void 0) {
          const y = [];
          d = i.createFramebuffer(), n.bindFramebuffer(i.FRAMEBUFFER, d);
          const v = [], g = e.textures;
          for (let _ = 0; _ < g.length; _++) {
            if (v[_] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, v[_]), y.push(i.COLOR_ATTACHMENT0 + _), u) {
              const T = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
              y.push(T);
            }
            const x = e.textures[_], b = this.get(x);
            i.renderbufferStorageMultisample(i.RENDERBUFFER, l, b.glInternalFormat, e.width, e.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + _, i.RENDERBUFFER, v[_]);
          }
          if (o.msaaFrameBuffer = d, o.msaaRenderbuffers = v, p === void 0) {
            p = i.createRenderbuffer(), this.textureUtils.setupRenderBufferStorage(p, e), o.depthRenderbuffer = p;
            const _ = c ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
            y.push(_);
          }
          o.invalidationArray = y;
        }
        s = o.msaaFrameBuffer;
      } else
        s = m;
    }
    n.bindFramebuffer(i.FRAMEBUFFER, s);
  }
  _getVaoKey(e, i) {
    let n = [];
    if (e !== null) {
      const s = this.get(e);
      n += ":" + s.id;
    }
    for (let s = 0; s < i.length; s++) {
      const a = this.get(i[s]);
      n += ":" + a.id;
    }
    return n;
  }
  _createVao(e, i) {
    const { gl: n } = this, s = n.createVertexArray();
    let a = "", o = !0;
    if (n.bindVertexArray(s), e !== null) {
      const l = this.get(e);
      n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, l.bufferGPU), a += ":" + l.id;
    }
    for (let l = 0; l < i.length; l++) {
      const u = i[l], c = this.get(u);
      a += ":" + c.id, n.bindBuffer(n.ARRAY_BUFFER, c.bufferGPU), n.enableVertexAttribArray(l), (u.isStorageBufferAttribute || u.isStorageInstancedBufferAttribute) && (o = !1);
      let h, d;
      u.isInterleavedBufferAttribute === !0 ? (h = u.data.stride * c.bytesPerElement, d = u.offset * c.bytesPerElement) : (h = 0, d = 0), c.isInteger ? n.vertexAttribIPointer(l, u.itemSize, c.type, h, d) : n.vertexAttribPointer(l, u.itemSize, c.type, u.normalized, h, d), u.isInstancedBufferAttribute && !u.isInterleavedBufferAttribute ? n.vertexAttribDivisor(l, u.meshPerAttribute) : u.isInterleavedBufferAttribute && u.data.isInstancedInterleavedBuffer && n.vertexAttribDivisor(l, u.data.meshPerAttribute);
    }
    return n.bindBuffer(n.ARRAY_BUFFER, null), this.vaoCache[a] = s, { vaoGPU: s, staticVao: o };
  }
  _getTransformFeedback(e) {
    let i = "";
    for (let a = 0; a < e.length; a++)
      i += ":" + e[a].id;
    let n = this.transformFeedbackCache[i];
    if (n !== void 0)
      return n;
    const { gl: s } = this;
    n = s.createTransformFeedback(), s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, n);
    for (let a = 0; a < e.length; a++) {
      const o = e[a];
      s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER, a, o.transformBuffer);
    }
    return s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, null), this.transformFeedbackCache[i] = n, n;
  }
  _setupBindings(e, i) {
    const n = this.gl;
    for (const s of e)
      for (const a of s.bindings) {
        const o = this.get(a).index;
        if (a.isUniformsGroup || a.isUniformBuffer) {
          const l = n.getUniformBlockIndex(i, a.name);
          n.uniformBlockBinding(i, l, o);
        } else if (a.isSampledTexture) {
          const l = n.getUniformLocation(i, a.name);
          n.uniform1i(l, o);
        }
      }
  }
  _bindUniforms(e) {
    const { gl: i, state: n } = this;
    for (const s of e)
      for (const a of s.bindings) {
        const o = this.get(a), l = o.index;
        a.isUniformsGroup || a.isUniformBuffer ? n.bindBufferBase(i.UNIFORM_BUFFER, l, o.bufferGPU) : a.isSampledTexture && n.bindTexture(o.glTextureType, o.textureGPU, i.TEXTURE0 + l);
      }
  }
  dispose() {
    this.renderer.domElement.removeEventListener("webglcontextlost", this._onContextLost);
  }
}
class J$ extends q1 {
  constructor(e, i) {
    super(e), this.texture = i, this.version = i ? i.version : 0, this.isSampler = !0;
  }
}
class eJ extends J$ {
  constructor(e, i, n) {
    super(e, i ? i.value : null), this.textureNode = i, this.groupNode = n;
  }
  update() {
    this.texture = this.textureNode.value;
  }
}
class tJ extends aI {
  constructor(e, i) {
    super(e, i ? i.array : null), this.attribute = i, this.isStorageBuffer = !0;
  }
}
let iJ = 0;
class rJ extends tJ {
  constructor(e, i) {
    super("StorageBuffer_" + iJ++, e ? e.value : null), this.nodeUniform = e, this.access = e ? e.access : Nx.Storage, this.groupNode = i;
  }
  get buffer() {
    return this.nodeUniform.value;
  }
}
class nJ extends To {
  constructor(e) {
    super(), this.device = e;
    const i = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`, n = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`, s = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
    this.mipmapSampler = e.createSampler({ minFilter: Qo.Linear }), this.flipYSampler = e.createSampler({ minFilter: Qo.Nearest }), this.transferPipelines = {}, this.flipYPipelines = {}, this.mipmapVertexShaderModule = e.createShaderModule({
      label: "mipmapVertex",
      code: i
    }), this.mipmapFragmentShaderModule = e.createShaderModule({
      label: "mipmapFragment",
      code: n
    }), this.flipYFragmentShaderModule = e.createShaderModule({
      label: "flipYFragment",
      code: s
    });
  }
  getTransferPipeline(e) {
    let i = this.transferPipelines[e];
    return i === void 0 && (i = this.device.createRenderPipeline({
      label: `mipmap-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.mipmapFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: Bu.TriangleStrip,
        stripIndexFormat: Mc.Uint32
      },
      layout: "auto"
    }), this.transferPipelines[e] = i), i;
  }
  getFlipYPipeline(e) {
    let i = this.flipYPipelines[e];
    return i === void 0 && (i = this.device.createRenderPipeline({
      label: `flipY-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.flipYFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: Bu.TriangleStrip,
        stripIndexFormat: Mc.Uint32
      },
      layout: "auto"
    }), this.flipYPipelines[e] = i), i;
  }
  flipY(e, i, n = 0) {
    const s = i.format, { width: a, height: o } = i.size, l = this.getTransferPipeline(s), u = this.getFlipYPipeline(s), c = this.device.createTexture({
      size: { width: a, height: o, depthOrArrayLayers: 1 },
      format: s,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    }), h = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: yn.TwoD,
      baseArrayLayer: n
    }), d = c.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: yn.TwoD,
      baseArrayLayer: 0
    }), p = this.device.createCommandEncoder({}), f = (m, y, v) => {
      const g = m.getBindGroupLayout(0), _ = this.device.createBindGroup({
        layout: g,
        entries: [{
          binding: 0,
          resource: this.flipYSampler
        }, {
          binding: 1,
          resource: y
        }]
      }), x = p.beginRenderPass({
        colorAttachments: [{
          view: v,
          loadOp: Oi.Clear,
          storeOp: Ji.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      x.setPipeline(m), x.setBindGroup(0, _), x.draw(4, 1, 0, 0), x.end();
    };
    f(l, h, d), f(u, d, h), this.device.queue.submit([p.finish()]), c.destroy();
  }
  generateMipmaps(e, i, n = 0) {
    const s = this.get(e);
    s.useCount === void 0 && (s.useCount = 0, s.layers = []);
    const a = s.layers[n] || this._mipmapCreateBundles(e, i, n), o = this.device.createCommandEncoder({});
    this._mipmapRunBundles(o, a), this.device.queue.submit([o.finish()]), s.useCount !== 0 && (s.layers[n] = a), s.useCount++;
  }
  _mipmapCreateBundles(e, i, n) {
    const s = this.getTransferPipeline(i.format), a = s.getBindGroupLayout(0);
    let o = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: yn.TwoD,
      baseArrayLayer: n
    });
    const l = [];
    for (let u = 1; u < i.mipLevelCount; u++) {
      const c = this.device.createBindGroup({
        layout: a,
        entries: [{
          binding: 0,
          resource: this.mipmapSampler
        }, {
          binding: 1,
          resource: o
        }]
      }), h = e.createView({
        baseMipLevel: u,
        mipLevelCount: 1,
        dimension: yn.TwoD,
        baseArrayLayer: n
      }), d = {
        colorAttachments: [{
          view: h,
          loadOp: Oi.Clear,
          storeOp: Ji.Store,
          clearValue: [0, 0, 0, 0]
        }]
      }, p = this.device.createRenderBundleEncoder({
        colorFormats: [i.format]
      });
      p.setPipeline(s), p.setBindGroup(0, c), p.draw(4, 1, 0, 0), l.push({
        renderBundles: [p.finish()],
        passDescriptor: d
      }), o = h;
    }
    return l;
  }
  _mipmapRunBundles(e, i) {
    const n = i.length;
    for (let s = 0; s < n; s++) {
      const a = i[s], o = e.beginRenderPass(a.passDescriptor);
      o.executeBundles(a.renderBundles), o.end();
    }
  }
}
const sJ = {
  [a3]: "never",
  [u1]: "less",
  [o3]: "equal",
  [l3]: "less-equal",
  [u3]: "greater",
  [h3]: "greater-equal",
  [d3]: "always",
  [c3]: "not-equal"
}, aJ = [0, 1, 3, 2, 4, 5];
class oJ {
  constructor(e) {
    this.backend = e, this._passUtils = null, this.defaultTexture = {}, this.defaultCubeTexture = {}, this.defaultVideoFrame = null, this.colorBuffer = null, this.depthTexture = new Vc(), this.depthTexture.name = "depthBuffer";
  }
  createSampler(e) {
    const i = this.backend, n = i.device, s = i.get(e), a = {
      addressModeU: this._convertAddressMode(e.wrapS),
      addressModeV: this._convertAddressMode(e.wrapT),
      addressModeW: this._convertAddressMode(e.wrapR),
      magFilter: this._convertFilterMode(e.magFilter),
      minFilter: this._convertFilterMode(e.minFilter),
      mipmapFilter: this._convertFilterMode(e.minFilter),
      maxAnisotropy: 1
    };
    a.magFilter === Qo.Linear && a.minFilter === Qo.Linear && a.mipmapFilter === Qo.Linear && (a.maxAnisotropy = e.anisotropy), e.isDepthTexture && e.compareFunction !== null && (a.compare = sJ[e.compareFunction]), s.sampler = n.createSampler(a);
  }
  createDefaultTexture(e) {
    let i;
    const n = Ox(e);
    e.isCubeTexture ? i = this._getDefaultCubeTextureGPU(n) : e.isVideoTexture ? this.backend.get(e).externalTexture = this._getDefaultVideoFrame() : i = this._getDefaultTextureGPU(n), this.backend.get(e).texture = i;
  }
  createTexture(e, i = {}) {
    const n = this.backend, s = n.get(e);
    if (s.initialized)
      throw new Error("WebGPUTextureUtils: Texture already initialized.");
    i.needsMipmaps === void 0 && (i.needsMipmaps = !1), i.levels === void 0 && (i.levels = 1), i.depth === void 0 && (i.depth = 1);
    const { width: a, height: o, depth: l, levels: u } = i;
    e.isFramebufferTexture && (i.renderTarget ? i.format = this.backend.utils.getCurrentColorFormat(i.renderTarget) : i.format = this.backend.utils.getPreferredCanvasFormat());
    const c = this._getDimension(e), h = e.internalFormat || i.format || Ox(e, n.device);
    s.format = h;
    let d = i.sampleCount !== void 0 ? i.sampleCount : 1;
    d = n.utils.getSampleCount(d);
    const p = e.isRenderTargetTexture && !e.isMultisampleRenderTargetTexture ? 1 : d;
    let f = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
    e.isStorageTexture === !0 && (f |= GPUTextureUsage.STORAGE_BINDING), e.isCompressedTexture !== !0 && e.isCompressedArrayTexture !== !0 && (f |= GPUTextureUsage.RENDER_ATTACHMENT);
    const m = {
      label: e.name,
      size: {
        width: a,
        height: o,
        depthOrArrayLayers: l
      },
      mipLevelCount: u,
      sampleCount: p,
      dimension: c,
      format: h,
      usage: f
    };
    if (e.isVideoTexture) {
      const y = e.source.data, v = new VideoFrame(y);
      m.size.width = v.displayWidth, m.size.height = v.displayHeight, v.close(), s.externalTexture = y;
    } else {
      if (h === void 0)
        return console.warn("WebGPURenderer: Texture format not supported."), this.createDefaultTexture(e);
      s.texture = n.device.createTexture(m);
    }
    if (e.isRenderTargetTexture && d > 1 && !e.isMultisampleRenderTargetTexture) {
      const y = Object.assign({}, m);
      y.label = y.label + "-msaa", y.sampleCount = d, s.msaaTexture = n.device.createTexture(y);
    }
    s.initialized = !0, s.textureDescriptorGPU = m;
  }
  destroyTexture(e) {
    const i = this.backend, n = i.get(e);
    n.texture.destroy(), n.msaaTexture !== void 0 && n.msaaTexture.destroy(), i.delete(e);
  }
  destroySampler(e) {
    const i = this.backend.get(e);
    delete i.sampler;
  }
  generateMipmaps(e) {
    const i = this.backend.get(e);
    if (e.isCubeTexture)
      for (let n = 0; n < 6; n++)
        this._generateMipmaps(i.texture, i.textureDescriptorGPU, n);
    else {
      const n = e.image.depth || 1;
      for (let s = 0; s < n; s++)
        this._generateMipmaps(i.texture, i.textureDescriptorGPU, s);
    }
  }
  getColorBuffer() {
    this.colorBuffer && this.colorBuffer.destroy();
    const e = this.backend, { width: i, height: n } = e.getDrawingBufferSize();
    return this.colorBuffer = e.device.createTexture({
      label: "colorBuffer",
      size: {
        width: i,
        height: n,
        depthOrArrayLayers: 1
      },
      sampleCount: e.utils.getSampleCount(e.renderer.samples),
      format: e.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
    }), this.colorBuffer;
  }
  getDepthBuffer(e = !0, i = !1) {
    const n = this.backend, { width: s, height: a } = n.getDrawingBufferSize(), o = this.depthTexture, l = n.get(o).texture;
    let u, c;
    if (i ? (u = Tc, c = Kd) : e && (u = gl, c = er), l !== void 0) {
      if (o.image.width === s && o.image.height === a && o.format === u && o.type === c)
        return l;
      this.destroyTexture(o);
    }
    return o.name = "depthBuffer", o.format = u, o.type = c, o.image.width = s, o.image.height = a, this.createTexture(o, { sampleCount: n.utils.getSampleCount(n.renderer.samples), width: s, height: a }), n.get(o).texture;
  }
  updateTexture(e, i) {
    const n = this.backend.get(e), { textureDescriptorGPU: s } = n;
    if (!(e.isRenderTargetTexture || s === void 0)) {
      if (e.isDataTexture)
        this._copyBufferToTexture(i.image, n.texture, s, 0, e.flipY);
      else if (e.isDataArrayTexture || e.isData3DTexture)
        for (let a = 0; a < i.image.depth; a++)
          this._copyBufferToTexture(i.image, n.texture, s, a, e.flipY, a);
      else if (e.isCompressedTexture || e.isCompressedArrayTexture)
        this._copyCompressedBufferToTexture(e.mipmaps, n.texture, s);
      else if (e.isCubeTexture)
        this._copyCubeMapToTexture(i.images, n.texture, s, e.flipY);
      else if (e.isVideoTexture) {
        const a = e.source.data;
        n.externalTexture = a;
      } else
        this._copyImageToTexture(i.image, n.texture, s, 0, e.flipY);
      n.version = e.version, e.onUpdate && e.onUpdate(e);
    }
  }
  async copyTextureToBuffer(e, i, n, s, a, o) {
    const l = this.backend.device, u = this.backend.get(e), c = u.texture, h = u.textureDescriptorGPU.format, d = this._getBytesPerTexel(h);
    let p = s * d;
    p = Math.ceil(p / 256) * 256;
    const f = l.createBuffer(
      {
        size: s * a * d,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }
    ), m = l.createCommandEncoder();
    m.copyTextureToBuffer(
      {
        texture: c,
        origin: { x: i, y: n, z: o }
      },
      {
        buffer: f,
        bytesPerRow: p
      },
      {
        width: s,
        height: a
      }
    );
    const y = this._getTypedArrayType(h);
    l.queue.submit([m.finish()]), await f.mapAsync(GPUMapMode.READ);
    const v = f.getMappedRange();
    return new y(v);
  }
  _isEnvironmentTexture(e) {
    const i = e.mapping;
    return i === Xd || i === Yd || i === Tl || i === _c;
  }
  _getDefaultTextureGPU(e) {
    let i = this.defaultTexture[e];
    if (i === void 0) {
      const n = new Cr();
      n.minFilter = yr, n.magFilter = yr, this.createTexture(n, { width: 1, height: 1, format: e }), this.defaultTexture[e] = i = n;
    }
    return this.backend.get(i).texture;
  }
  _getDefaultCubeTextureGPU(e) {
    let i = this.defaultTexture[e];
    if (i === void 0) {
      const n = new d1();
      n.minFilter = yr, n.magFilter = yr, this.createTexture(n, { width: 1, height: 1, depth: 6 }), this.defaultCubeTexture[e] = i = n;
    }
    return this.backend.get(i).texture;
  }
  _getDefaultVideoFrame() {
    let e = this.defaultVideoFrame;
    if (e === null) {
      const i = {
        timestamp: 0,
        codedWidth: 1,
        codedHeight: 1,
        format: "RGBA"
      };
      this.defaultVideoFrame = e = new VideoFrame(new Uint8Array([0, 0, 0, 255]), i);
    }
    return e;
  }
  _copyCubeMapToTexture(e, i, n, s) {
    for (let a = 0; a < 6; a++) {
      const o = e[a], l = s === !0 ? aJ[a] : a;
      o.isDataTexture ? this._copyBufferToTexture(o.image, i, n, l, s) : this._copyImageToTexture(o, i, n, l, s);
    }
  }
  _copyImageToTexture(e, i, n, s, a) {
    this.backend.device.queue.copyExternalImageToTexture(
      {
        source: e
      },
      {
        texture: i,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: s }
      },
      {
        width: e.width,
        height: e.height,
        depthOrArrayLayers: 1
      }
    ), a === !0 && this._flipY(i, n, s);
  }
  _getPassUtils() {
    let e = this._passUtils;
    return e === null && (this._passUtils = e = new nJ(this.backend.device)), e;
  }
  _generateMipmaps(e, i, n = 0) {
    this._getPassUtils().generateMipmaps(e, i, n);
  }
  _flipY(e, i, n = 0) {
    this._getPassUtils().flipY(e, i, n);
  }
  _copyBufferToTexture(e, i, n, s, a, o = 0) {
    const l = this.backend.device, u = e.data, c = this._getBytesPerTexel(n.format), h = e.width * c;
    l.queue.writeTexture(
      {
        texture: i,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: s }
      },
      u,
      {
        offset: e.width * e.height * c * o,
        bytesPerRow: h
      },
      {
        width: e.width,
        height: e.height,
        depthOrArrayLayers: 1
      }
    ), a === !0 && this._flipY(i, n, s);
  }
  _copyCompressedBufferToTexture(e, i, n) {
    const s = this.backend.device, a = this._getBlockData(n.format), o = n.size.depthOrArrayLayers > 1;
    for (let l = 0; l < e.length; l++) {
      const u = e[l], c = u.width, h = u.height, d = o ? n.size.depthOrArrayLayers : 1, p = Math.ceil(c / a.width) * a.byteLength, f = p * Math.ceil(h / a.height);
      for (let m = 0; m < d; m++)
        s.queue.writeTexture(
          {
            texture: i,
            mipLevel: l,
            origin: { x: 0, y: 0, z: m }
          },
          u.data,
          {
            offset: m * f,
            bytesPerRow: p,
            rowsPerImage: Math.ceil(h / a.height)
          },
          {
            width: Math.ceil(c / a.width) * a.width,
            height: Math.ceil(h / a.height) * a.height,
            depthOrArrayLayers: 1
          }
        );
    }
  }
  _getBlockData(e) {
    if (e === Z.BC1RGBAUnorm || e === Z.BC1RGBAUnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === Z.BC2RGBAUnorm || e === Z.BC2RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === Z.BC3RGBAUnorm || e === Z.BC3RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === Z.BC4RUnorm || e === Z.BC4RSNorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === Z.BC5RGUnorm || e === Z.BC5RGSnorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === Z.BC6HRGBUFloat || e === Z.BC6HRGBFloat) return { byteLength: 16, width: 4, height: 4 };
    if (e === Z.BC7RGBAUnorm || e === Z.BC7RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === Z.ETC2RGB8Unorm || e === Z.ETC2RGB8UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === Z.ETC2RGB8A1Unorm || e === Z.ETC2RGB8A1UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === Z.ETC2RGBA8Unorm || e === Z.ETC2RGBA8UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === Z.EACR11Unorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === Z.EACR11Snorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === Z.EACRG11Unorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === Z.EACRG11Snorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === Z.ASTC4x4Unorm || e === Z.ASTC4x4UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === Z.ASTC5x4Unorm || e === Z.ASTC5x4UnormSRGB) return { byteLength: 16, width: 5, height: 4 };
    if (e === Z.ASTC5x5Unorm || e === Z.ASTC5x5UnormSRGB) return { byteLength: 16, width: 5, height: 5 };
    if (e === Z.ASTC6x5Unorm || e === Z.ASTC6x5UnormSRGB) return { byteLength: 16, width: 6, height: 5 };
    if (e === Z.ASTC6x6Unorm || e === Z.ASTC6x6UnormSRGB) return { byteLength: 16, width: 6, height: 6 };
    if (e === Z.ASTC8x5Unorm || e === Z.ASTC8x5UnormSRGB) return { byteLength: 16, width: 8, height: 5 };
    if (e === Z.ASTC8x6Unorm || e === Z.ASTC8x6UnormSRGB) return { byteLength: 16, width: 8, height: 6 };
    if (e === Z.ASTC8x8Unorm || e === Z.ASTC8x8UnormSRGB) return { byteLength: 16, width: 8, height: 8 };
    if (e === Z.ASTC10x5Unorm || e === Z.ASTC10x5UnormSRGB) return { byteLength: 16, width: 10, height: 5 };
    if (e === Z.ASTC10x6Unorm || e === Z.ASTC10x6UnormSRGB) return { byteLength: 16, width: 10, height: 6 };
    if (e === Z.ASTC10x8Unorm || e === Z.ASTC10x8UnormSRGB) return { byteLength: 16, width: 10, height: 8 };
    if (e === Z.ASTC10x10Unorm || e === Z.ASTC10x10UnormSRGB) return { byteLength: 16, width: 10, height: 10 };
    if (e === Z.ASTC12x10Unorm || e === Z.ASTC12x10UnormSRGB) return { byteLength: 16, width: 12, height: 10 };
    if (e === Z.ASTC12x12Unorm || e === Z.ASTC12x12UnormSRGB) return { byteLength: 16, width: 12, height: 12 };
  }
  _convertAddressMode(e) {
    let i = iv.ClampToEdge;
    return e === Um ? i = iv.Repeat : e === Fm && (i = iv.MirrorRepeat), i;
  }
  _convertFilterMode(e) {
    let i = Qo.Linear;
    return (e === yr || e === Qb || e === Zu) && (i = Qo.Nearest), i;
  }
  _getBytesPerTexel(e) {
    if (e === Z.R8Unorm || e === Z.R8Snorm || e === Z.R8Uint || e === Z.R8Sint) return 1;
    if (e === Z.R16Uint || e === Z.R16Sint || e === Z.R16Float || e === Z.RG8Unorm || e === Z.RG8Snorm || e === Z.RG8Uint || e === Z.RG8Sint) return 2;
    if (e === Z.R32Uint || e === Z.R32Sint || e === Z.R32Float || e === Z.RG16Uint || e === Z.RG16Sint || e === Z.RG16Float || e === Z.RGBA8Unorm || e === Z.RGBA8UnormSRGB || e === Z.RGBA8Snorm || e === Z.RGBA8Uint || e === Z.RGBA8Sint || e === Z.BGRA8Unorm || e === Z.BGRA8UnormSRGB || // Packed 32-bit formats
    e === Z.RGB9E5UFloat || e === Z.RGB10A2Unorm || e === Z.RG11B10UFloat || e === Z.Depth32Float || e === Z.Depth24Plus || e === Z.Depth24PlusStencil8 || e === Z.Depth32FloatStencil8) return 4;
    if (e === Z.RG32Uint || e === Z.RG32Sint || e === Z.RG32Float || e === Z.RGBA16Uint || e === Z.RGBA16Sint || e === Z.RGBA16Float) return 8;
    if (e === Z.RGBA32Uint || e === Z.RGBA32Sint || e === Z.RGBA32Float) return 16;
  }
  _getTypedArrayType(e) {
    if (e === Z.R8Uint) return Uint8Array;
    if (e === Z.R8Sint) return Int8Array;
    if (e === Z.R8Unorm) return Uint8Array;
    if (e === Z.R8Snorm) return Int8Array;
    if (e === Z.RG8Uint) return Uint8Array;
    if (e === Z.RG8Sint) return Int8Array;
    if (e === Z.RG8Unorm) return Uint8Array;
    if (e === Z.RG8Snorm) return Int8Array;
    if (e === Z.RGBA8Uint) return Uint8Array;
    if (e === Z.RGBA8Sint) return Int8Array;
    if (e === Z.RGBA8Unorm) return Uint8Array;
    if (e === Z.RGBA8Snorm) return Int8Array;
    if (e === Z.R16Uint) return Uint16Array;
    if (e === Z.R16Sint) return Int16Array;
    if (e === Z.RG16Uint) return Uint16Array;
    if (e === Z.RG16Sint) return Int16Array;
    if (e === Z.RGBA16Uint) return Uint16Array;
    if (e === Z.RGBA16Sint) return Int16Array;
    if (e === Z.R16Float || e === Z.RG16Float || e === Z.RGBA16Float) return Uint16Array;
    if (e === Z.R32Uint) return Uint32Array;
    if (e === Z.R32Sint) return Int32Array;
    if (e === Z.R32Float) return Float32Array;
    if (e === Z.RG32Uint) return Uint32Array;
    if (e === Z.RG32Sint) return Int32Array;
    if (e === Z.RG32Float) return Float32Array;
    if (e === Z.RGBA32Uint) return Uint32Array;
    if (e === Z.RGBA32Sint) return Int32Array;
    if (e === Z.RGBA32Float) return Float32Array;
    if (e === Z.BGRA8Unorm || e === Z.BGRA8UnormSRGB) return Uint8Array;
    if (e === Z.RGB10A2Unorm || e === Z.RGB9E5UFloat || e === Z.RG11B10UFloat) return Uint32Array;
    if (e === Z.Depth32Float) return Float32Array;
    if (e === Z.Depth24Plus || e === Z.Depth24PlusStencil8) return Uint32Array;
    if (e === Z.Depth32FloatStencil8) return Float32Array;
  }
  _getDimension(e) {
    let i;
    return e.isData3DTexture ? i = K2.ThreeD : i = K2.TwoD, i;
  }
}
function Ox(r, e = null) {
  const i = r.format, n = r.type, s = r.colorSpace;
  let a;
  if (r.isCompressedTexture === !0 || r.isCompressedArrayTexture === !0)
    switch (i) {
      case tm:
        a = s === ct ? Z.BC1RGBAUnormSRGB : Z.BC1RGBAUnorm;
        break;
      case im:
        a = s === ct ? Z.BC2RGBAUnormSRGB : Z.BC2RGBAUnorm;
        break;
      case rm:
        a = s === ct ? Z.BC3RGBAUnormSRGB : Z.BC3RGBAUnorm;
        break;
      case Jb:
        a = s === ct ? Z.ETC2RGB8UnormSRGB : Z.ETC2RGB8Unorm;
        break;
      case ex:
        a = s === ct ? Z.ETC2RGBA8UnormSRGB : Z.ETC2RGBA8Unorm;
        break;
      case tx:
        a = s === ct ? Z.ASTC4x4UnormSRGB : Z.ASTC4x4Unorm;
        break;
      case ix:
        a = s === ct ? Z.ASTC5x4UnormSRGB : Z.ASTC5x4Unorm;
        break;
      case rx:
        a = s === ct ? Z.ASTC5x5UnormSRGB : Z.ASTC5x5Unorm;
        break;
      case nx:
        a = s === ct ? Z.ASTC6x5UnormSRGB : Z.ASTC6x5Unorm;
        break;
      case sx:
        a = s === ct ? Z.ASTC6x6UnormSRGB : Z.ASTC6x6Unorm;
        break;
      case ax:
        a = s === ct ? Z.ASTC8x5UnormSRGB : Z.ASTC8x5Unorm;
        break;
      case ox:
        a = s === ct ? Z.ASTC8x6UnormSRGB : Z.ASTC8x6Unorm;
        break;
      case lx:
        a = s === ct ? Z.ASTC8x8UnormSRGB : Z.ASTC8x8Unorm;
        break;
      case ux:
        a = s === ct ? Z.ASTC10x5UnormSRGB : Z.ASTC10x5Unorm;
        break;
      case cx:
        a = s === ct ? Z.ASTC10x6UnormSRGB : Z.ASTC10x6Unorm;
        break;
      case hx:
        a = s === ct ? Z.ASTC10x8UnormSRGB : Z.ASTC10x8Unorm;
        break;
      case dx:
        a = s === ct ? Z.ASTC10x10UnormSRGB : Z.ASTC10x10Unorm;
        break;
      case px:
        a = s === ct ? Z.ASTC12x10UnormSRGB : Z.ASTC12x10Unorm;
        break;
      case fx:
        a = s === ct ? Z.ASTC12x12UnormSRGB : Z.ASTC12x12Unorm;
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", i);
    }
  else
    switch (i) {
      case Bc:
        switch (n) {
          case $h:
            a = Z.RGBA8Snorm;
            break;
          case Jh:
            a = Z.RGBA16Sint;
            break;
          case Lu:
            a = Z.RGBA16Uint;
            break;
          case er:
            a = Z.RGBA32Uint;
            break;
          case wr:
            a = Z.RGBA32Sint;
            break;
          case co:
            a = s === ct ? Z.RGBA8UnormSRGB : Z.RGBA8Unorm;
            break;
          case pa:
            a = Z.RGBA16Float;
            break;
          case on:
            a = Z.RGBA32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.", n);
        }
        break;
      case n1:
        switch (n) {
          case n3:
            a = Z.RGB9E5UFloat;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBFormat.", n);
        }
        break;
      case s1:
        switch (n) {
          case $h:
            a = Z.R8Snorm;
            break;
          case Jh:
            a = Z.R16Sint;
            break;
          case Lu:
            a = Z.R16Uint;
            break;
          case er:
            a = Z.R32Uint;
            break;
          case wr:
            a = Z.R32Sint;
            break;
          case co:
            a = Z.R8Unorm;
            break;
          case pa:
            a = Z.R16Float;
            break;
          case on:
            a = Z.R32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedFormat.", n);
        }
        break;
      case gd:
        switch (n) {
          case $h:
            a = Z.RG8Snorm;
            break;
          case Jh:
            a = Z.RG16Sint;
            break;
          case Lu:
            a = Z.RG16Uint;
            break;
          case er:
            a = Z.RG32Uint;
            break;
          case wr:
            a = Z.RG32Sint;
            break;
          case co:
            a = Z.RG8Unorm;
            break;
          case pa:
            a = Z.RG16Float;
            break;
          case on:
            a = Z.RG32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGFormat.", n);
        }
        break;
      case gl:
        switch (n) {
          case Lu:
            a = Z.Depth16Unorm;
            break;
          case er:
            a = Z.Depth24Plus;
            break;
          case on:
            a = Z.Depth32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthFormat.", n);
        }
        break;
      case Tc:
        switch (n) {
          case Kd:
            a = Z.Depth24PlusStencil8;
            break;
          case on:
            e && e.features.has(Px.Depth32FloatStencil8) === !1 && console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'), a = Z.Depth32FloatStencil8;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", n);
        }
        break;
      case a1:
        switch (n) {
          case wr:
            a = Z.R32Sint;
            break;
          case er:
            a = Z.R32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.", n);
        }
        break;
      case o1:
        switch (n) {
          case wr:
            a = Z.RG32Sint;
            break;
          case er:
            a = Z.RG32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.", n);
        }
        break;
      case l1:
        switch (n) {
          case wr:
            a = Z.RGBA32Sint;
            break;
          case er:
            a = Z.RGBA32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.", n);
        }
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", i);
    }
  return a;
}
const lJ = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i, uJ = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig, gM = {
  f32: "float",
  i32: "int",
  u32: "uint",
  bool: "bool",
  "vec2<f32>": "vec2",
  "vec2<i32>": "ivec2",
  "vec2<u32>": "uvec2",
  "vec2<bool>": "bvec2",
  vec2f: "vec2",
  vec2i: "ivec2",
  vec2u: "uvec2",
  vec2b: "bvec2",
  "vec3<f32>": "vec3",
  "vec3<i32>": "ivec3",
  "vec3<u32>": "uvec3",
  "vec3<bool>": "bvec3",
  vec3f: "vec3",
  vec3i: "ivec3",
  vec3u: "uvec3",
  vec3b: "bvec3",
  "vec4<f32>": "vec4",
  "vec4<i32>": "ivec4",
  "vec4<u32>": "uvec4",
  "vec4<bool>": "bvec4",
  vec4f: "vec4",
  vec4i: "ivec4",
  vec4u: "uvec4",
  vec4b: "bvec4",
  "mat2x2<f32>": "mat2",
  mat2x2f: "mat2",
  "mat3x3<f32>": "mat3",
  mat3x3f: "mat3",
  "mat4x4<f32>": "mat4",
  mat4x4f: "mat4",
  sampler: "sampler",
  texture_1d: "texture",
  texture_2d: "texture",
  texture_2d_array: "texture",
  texture_multisampled_2d: "cubeTexture",
  texture_depth_2d: "depthTexture",
  texture_3d: "texture3D",
  texture_cube: "cubeTexture",
  texture_cube_array: "cubeTexture",
  texture_storage_1d: "storageTexture",
  texture_storage_2d: "storageTexture",
  texture_storage_2d_array: "storageTexture",
  texture_storage_3d: "storageTexture"
}, cJ = (r) => {
  r = r.trim();
  const e = r.match(lJ);
  if (e !== null && e.length === 4) {
    const i = e[2], n = [];
    let s = null;
    for (; (s = uJ.exec(i)) !== null; )
      n.push({ name: s[1], type: s[2] });
    const a = [];
    for (let c = 0; c < n.length; c++) {
      const { name: h, type: d } = n[c];
      let p = d;
      p.startsWith("ptr") ? p = "pointer" : (p.startsWith("texture") && (p = d.split("<")[0]), p = gM[p]), a.push(new H1(p, h));
    }
    const o = r.substring(e[0].length), l = e[3] || "void", u = e[1] !== void 0 ? e[1] : "";
    return {
      type: gM[l] || l,
      inputs: a,
      name: u,
      inputsCode: i,
      blockCode: o,
      outputType: l
    };
  } else
    throw new Error("FunctionNode: Function is not a WGSL code.");
};
class hJ extends W1 {
  constructor(e) {
    const { type: i, inputs: n, name: s, inputsCode: a, blockCode: o, outputType: l } = cJ(e);
    super(i, n, s), this.inputsCode = a, this.blockCode = o, this.outputType = l;
  }
  getCode(e = this.name) {
    const i = this.outputType !== "void" ? "-> " + this.outputType : "";
    return `fn ${e} ( ${this.inputsCode.trim()} ) ${i}` + this.blockCode;
  }
}
class dJ extends nI {
  parseFunction(e) {
    return new hJ(e);
  }
}
const wu = self.GPUShaderStage, Mf = {
  vertex: wu ? wu.VERTEX : 1,
  fragment: wu ? wu.FRAGMENT : 2,
  compute: wu ? wu.COMPUTE : 4
}, yM = {
  instance: !0,
  swizzleAssign: !1,
  storageBuffer: !0
}, pJ = {
  "^^": "tsl_xor"
}, fJ = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat2: "mat2x2<f32>",
  mat3: "mat3x3<f32>",
  mat4: "mat4x4<f32>"
}, Ws = {
  tsl_xor: new fr("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
  mod_float: new fr("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
  mod_vec2: new fr("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
  mod_vec3: new fr("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
  mod_vec4: new fr("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
  equals_bool: new fr("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
  equals_bvec2: new fr("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
  equals_bvec3: new fr("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
  equals_bvec4: new fr("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
  repeatWrapping: new fr(
    /* wgsl */
    `
fn tsl_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {

	let uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );

	return ( ( uvScaled % dimension ) + dimension ) % dimension;

}
`
  ),
  biquadraticTexture: new fr(
    /* wgsl */
    `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, level : i32 ) -> vec4f {

	let iRes = vec2i( textureDimensions( map, level ) );
	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2i( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2i( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2i( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2i( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`
  )
}, Hh = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod_float: "tsl_mod_float",
  mod_vec2: "tsl_mod_vec2",
  mod_vec3: "tsl_mod_vec3",
  mod_vec4: "tsl_mod_vec4",
  equals_bool: "tsl_equals_bool",
  equals_bvec2: "tsl_equals_bvec2",
  equals_bvec3: "tsl_equals_bvec3",
  equals_bvec4: "tsl_equals_bvec4",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>"
};
/Windows/g.test(navigator.userAgent) && (Ws.pow_float = new fr("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"), Ws.pow_vec2 = new fr("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }", [Ws.pow_float]), Ws.pow_vec3 = new fr("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }", [Ws.pow_float]), Ws.pow_vec4 = new fr("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }", [Ws.pow_float]), Hh.pow_float = "tsl_pow_float", Hh.pow_vec2 = "tsl_pow_vec2", Hh.pow_vec3 = "tsl_pow_vec3", Hh.pow_vec4 = "tsl_pow_vec4");
let pI = "";
/Firefox|Deno/g.test(navigator.userAgent) !== !0 && (pI += `diagnostic( off, derivative_uniformity );
`);
class mJ extends iI {
  constructor(e, i) {
    super(e, i, new dJ()), this.uniformGroups = {}, this.builtins = {}, this.directives = {}, this.scopedArrays = /* @__PURE__ */ new Map();
  }
  needsToWorkingColorSpace(e) {
    return e.isVideoTexture === !0 && e.colorSpace !== wl;
  }
  _generateTextureSample(e, i, n, s, a = this.shaderStage) {
    return a === "fragment" ? s ? `textureSample( ${i}, ${i}_sampler, ${n}, ${s} )` : `textureSample( ${i}, ${i}_sampler, ${n} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, i, n) : this.generateTextureLod(e, i, n, "0");
  }
  _generateVideoSample(e, i, n = this.shaderStage) {
    if (n === "fragment")
      return `textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${i}.x, 1.0 - ${i}.y ) )`;
    console.error(`WebGPURenderer: THREE.VideoTexture does not support ${n} shader.`);
  }
  _generateTextureSampleLevel(e, i, n, s, a, o = this.shaderStage) {
    return o === "fragment" && this.isUnfilterable(e) === !1 ? `textureSampleLevel( ${i}, ${i}_sampler, ${n}, ${s} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, i, n, s) : this.generateTextureLod(e, i, n, s);
  }
  generateFilteredTexture(e, i, n, s = "0") {
    return this._include("biquadraticTexture"), `tsl_biquadraticTexture( ${i}, ${n}, i32( ${s} ) )`;
  }
  generateTextureLod(e, i, n, s = "0") {
    this._include("repeatWrapping");
    const a = e.isMultisampleRenderTargetTexture === !0 ? `textureDimensions( ${i} )` : `textureDimensions( ${i}, 0 )`;
    return `textureLoad( ${i}, tsl_repeatWrapping( ${n}, ${a} ), i32( ${s} ) )`;
  }
  generateTextureLoad(e, i, n, s, a = "0u") {
    return s ? `textureLoad( ${i}, ${n}, ${s}, ${a} )` : `textureLoad( ${i}, ${n}, ${a} )`;
  }
  generateTextureStore(e, i, n, s) {
    return `textureStore( ${i}, ${n}, ${s} )`;
  }
  isUnfilterable(e) {
    return this.getComponentTypeFromTexture(e) !== "float" || !this.isAvailable("float32Filterable") && e.isDataTexture === !0 && e.type === on || e.isMultisampleRenderTargetTexture === !0;
  }
  generateTexture(e, i, n, s, a = this.shaderStage) {
    let o = null;
    return e.isVideoTexture === !0 ? o = this._generateVideoSample(i, n, a) : this.isUnfilterable(e) ? o = this.generateTextureLod(e, i, n, "0", s, a) : o = this._generateTextureSample(e, i, n, s, a), o;
  }
  generateTextureGrad(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleGrad( ${i}, ${i}_sampler, ${n},  ${s[0]}, ${s[1]} )`;
    console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${o} shader.`);
  }
  generateTextureCompare(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleCompare( ${i}, ${i}_sampler, ${n}, ${s} )`;
    console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${o} shader.`);
  }
  generateTextureLevel(e, i, n, s, a, o = this.shaderStage) {
    let l = null;
    return e.isVideoTexture === !0 ? l = this._generateVideoSample(i, n, o) : l = this._generateTextureSampleLevel(e, i, n, s, a, o), l;
  }
  generateTextureBias(e, i, n, s, a, o = this.shaderStage) {
    if (o === "fragment")
      return `textureSampleBias( ${i}, ${i}_sampler, ${n}, ${s} )`;
    console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${o} shader.`);
  }
  getPropertyName(e, i = this.shaderStage) {
    if (e.isNodeVarying === !0 && e.needsInterpolation === !0) {
      if (i === "vertex")
        return `varyings.${e.name}`;
    } else if (e.isNodeUniform === !0) {
      const n = e.name, s = e.type;
      return s === "texture" || s === "cubeTexture" || s === "storageTexture" || s === "texture3D" ? n : s === "buffer" || s === "storageBuffer" || s === "indirectStorageBuffer" ? `NodeBuffer_${e.id}.${n}` : e.groupNode.name + "." + n;
    }
    return super.getPropertyName(e);
  }
  getOutputStructName() {
    return "output";
  }
  _getUniformGroupCount(e) {
    return Object.keys(this.uniforms[e]).length;
  }
  getFunctionOperator(e) {
    const i = pJ[e];
    return i !== void 0 ? (this._include(i), i) : null;
  }
  getStorageAccess(e) {
    if (e.isStorageTextureNode)
      switch (e.access) {
        case Y2.ReadOnly:
          return "read";
        case Y2.WriteOnly:
          return "write";
        default:
          return "read_write";
      }
    else
      switch (e.access) {
        case Nx.Storage:
          return "read_write";
        case Nx.ReadOnlyStorage:
          return "read";
        default:
          return "write";
      }
  }
  getUniformFromNode(e, i, n, s = null) {
    const a = super.getUniformFromNode(e, i, n, s), o = this.getDataFromNode(e, n, this.globalCache);
    if (o.uniformGPU === void 0) {
      let l;
      const u = e.groupNode, c = u.name, h = this.getBindGroupArray(c, n);
      if (i === "texture" || i === "cubeTexture" || i === "storageTexture" || i === "texture3D") {
        let d = null;
        if (i === "texture" || i === "storageTexture" ? d = new Gg(a.name, a.node, u, e.access ? e.access : null) : i === "cubeTexture" ? d = new cI(a.name, a.node, u, e.access ? e.access : null) : i === "texture3D" && (d = new hI(a.name, a.node, u, e.access ? e.access : null)), d.store = e.isStorageTextureNode === !0, d.setVisibility(Mf[n]), n === "fragment" && this.isUnfilterable(e.value) === !1 && d.store === !1) {
          const p = new eJ(`${a.name}_sampler`, a.node, u);
          p.setVisibility(Mf[n]), h.push(p, d), l = [p, d];
        } else
          h.push(d), l = [d];
      } else if (i === "buffer" || i === "storageBuffer" || i === "indirectStorageBuffer") {
        const d = i === "buffer" ? lI : rJ, p = new d(e, u);
        p.setVisibility(Mf[n]), h.push(p), l = p;
      } else {
        const d = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let p = d[c];
        p === void 0 && (p = new uI(c, u), p.setVisibility(Mf[n]), d[c] = p, h.push(p)), l = this.getNodeUniform(a, i), p.addUniform(l);
      }
      o.uniformGPU = l;
    }
    return a;
  }
  getBuiltin(e, i, n, s = this.shaderStage) {
    const a = this.builtins[s] || (this.builtins[s] = /* @__PURE__ */ new Map());
    return a.has(e) === !1 && a.set(e, {
      name: e,
      property: i,
      type: n
    }), i;
  }
  hasBuiltin(e, i = this.shaderStage) {
    return this.builtins[i] !== void 0 && this.builtins[i].has(e);
  }
  getVertexIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute") : "vertexIndex";
  }
  buildFunctionCode(e) {
    const i = e.layout, n = this.flowShaderNode(e), s = [];
    for (const o of i.inputs)
      s.push(o.name + " : " + this.getType(o.type));
    let a = `fn ${i.name}( ${s.join(", ")} ) -> ${this.getType(i.type)} {
${n.vars}
${n.code}
`;
    return n.result && (a += `	return ${n.result};
`), a += `
}
`, a;
  }
  getInstanceIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute") : "instanceIndex";
  }
  getInvocationLocalIndex() {
    return this.getBuiltin("local_invocation_index", "invocationLocalIndex", "u32", "attribute");
  }
  getSubgroupSize() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
  }
  getInvocationSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_invocation_id", "invocationSubgroupIndex", "u32", "attribute");
  }
  getSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute");
  }
  getDrawIndex() {
    return null;
  }
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
  }
  getFragDepth() {
    return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
  }
  isFlipY() {
    return !1;
  }
  enableDirective(e, i = this.shaderStage) {
    (this.directives[i] || (this.directives[i] = /* @__PURE__ */ new Set())).add(e);
  }
  getDirectives(e) {
    const i = [], n = this.directives[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`enable ${s};`);
    return i.join(`
`);
  }
  enableSubGroups() {
    this.enableDirective("subgroups");
  }
  enableSubgroupsF16() {
    this.enableDirective("subgroups-f16");
  }
  enableClipDistances() {
    this.enableDirective("clip_distances");
  }
  enableShaderF16() {
    this.enableDirective("f16");
  }
  enableDualSourceBlending() {
    this.enableDirective("dual_source_blending");
  }
  getBuiltins(e) {
    const i = [], n = this.builtins[e];
    if (n !== void 0)
      for (const { name: s, property: a, type: o } of n.values())
        i.push(`@builtin( ${s} ) ${a} : ${o}`);
    return i.join(`,
	`);
  }
  getScopedArray(e, i, n, s) {
    return this.scopedArrays.has(e) === !1 && this.scopedArrays.set(e, {
      name: e,
      scope: i,
      bufferType: n,
      bufferCount: s
    }), e;
  }
  getScopedArrays(e) {
    if (e !== "compute")
      return;
    const i = [];
    for (const { name: n, scope: s, bufferType: a, bufferCount: o } of this.scopedArrays.values()) {
      const l = this.getType(a);
      i.push(`var<${s}> ${n}: array< ${l}, ${o} >;`);
    }
    return i.join(`
`);
  }
  getAttributes(e) {
    const i = [];
    if (e === "compute" && (this.getBuiltin("global_invocation_id", "id", "vec3<u32>", "attribute"), this.getBuiltin("workgroup_id", "workgroupId", "vec3<u32>", "attribute"), this.getBuiltin("local_invocation_id", "localId", "vec3<u32>", "attribute"), this.getBuiltin("num_workgroups", "numWorkgroups", "vec3<u32>", "attribute"), this.renderer.hasFeature("subgroups") && (this.enableDirective("subgroups", e), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute"))), e === "vertex" || e === "compute") {
      const n = this.getBuiltins("attribute");
      n && i.push(n);
      const s = this.getAttributesArray();
      for (let a = 0, o = s.length; a < o; a++) {
        const l = s[a], u = l.name, c = this.getType(l.type);
        i.push(`@location( ${a} ) ${u} : ${c}`);
      }
    }
    return i.join(`,
	`);
  }
  getStructMembers(e) {
    const i = [], n = e.getMemberTypes();
    for (let a = 0; a < n.length; a++) {
      const o = n[a];
      i.push(`	@location( ${a} ) m${a} : ${o}<f32>`);
    }
    const s = this.getBuiltins("output");
    return s && i.push("	" + s), i.join(`,
`);
  }
  getStructs(e) {
    const i = [], n = this.structs[e];
    for (let s = 0, a = n.length; s < a; s++) {
      const o = n[s], l = o.name;
      let u = `struct ${l} {
`;
      u += this.getStructMembers(o), u += `
}`, i.push(u), i.push(`
var<private> output : ${l};

`);
    }
    return i.join(`

`);
  }
  getVar(e, i) {
    return `var ${i} : ${this.getType(e)}`;
  }
  getVars(e) {
    const i = [], n = this.vars[e];
    if (n !== void 0)
      for (const s of n)
        i.push(`	${this.getVar(s.type, s.name)};`);
    return `
${i.join(`
`)}
`;
  }
  getVaryings(e) {
    const i = [];
    if (e === "vertex" && this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex"), e === "vertex" || e === "fragment") {
      const a = this.varyings, o = this.vars[e];
      for (let l = 0; l < a.length; l++) {
        const u = a[l];
        if (u.needsInterpolation) {
          let c = `@location( ${l} )`;
          /^(int|uint|ivec|uvec)/.test(u.type) && (c += " @interpolate( flat )"), i.push(`${c} ${u.name} : ${this.getType(u.type)}`);
        } else e === "vertex" && o.includes(u) === !1 && o.push(u);
      }
    }
    const n = this.getBuiltins(e);
    n && i.push(n);
    const s = i.join(`,
	`);
    return e === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + s) : s;
  }
  getUniforms(e) {
    const i = this.uniforms[e], n = [], s = [], a = [], o = {};
    for (const u of i) {
      const c = u.groupNode.name, h = this.bindingsIndexes[c];
      if (u.type === "texture" || u.type === "cubeTexture" || u.type === "storageTexture" || u.type === "texture3D") {
        const d = u.node.value;
        e === "fragment" && this.isUnfilterable(d) === !1 && u.node.isStorageTextureNode !== !0 && (d.isDepthTexture === !0 && d.compareFunction !== null ? n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name}_sampler : sampler_comparison;`) : n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name}_sampler : sampler;`));
        let p, f = "";
        if (d.isMultisampleRenderTargetTexture === !0 && (f = "_multisampled"), d.isCubeTexture === !0)
          p = "texture_cube<f32>";
        else if (d.isDataArrayTexture === !0 || d.isCompressedArrayTexture === !0)
          p = "texture_2d_array<f32>";
        else if (d.isDepthTexture === !0)
          p = `texture_depth${f}_2d`;
        else if (d.isVideoTexture === !0)
          p = "texture_external";
        else if (d.isData3DTexture === !0)
          p = "texture_3d<f32>";
        else if (u.node.isStorageTextureNode === !0) {
          const m = Ox(d), y = this.getStorageAccess(u.node);
          p = `texture_storage_2d<${m}, ${y}>`;
        } else {
          const m = this.getComponentTypeFromTexture(d).charAt(0);
          p = `texture${f}_2d<${m}32>`;
        }
        n.push(`@binding( ${h.binding++} ) @group( ${h.group} ) var ${u.name} : ${p};`);
      } else if (u.type === "buffer" || u.type === "storageBuffer" || u.type === "indirectStorageBuffer") {
        const d = u.node, p = this.getType(d.bufferType), f = d.bufferCount, m = f > 0 && u.type === "buffer" ? ", " + f : "", y = d.isAtomic ? `atomic<${p}>` : `${p}`, v = `	${u.name} : array< ${y}${m} >
`, g = d.isStorageBufferNode ? `storage, ${this.getStorageAccess(d)}` : "uniform";
        s.push(this._getWGSLStructBinding("NodeBuffer_" + d.id, v, g, h.binding++, h.group));
      } else {
        const d = this.getType(this.getVectorType(u.type)), p = u.groupNode.name;
        (o[p] || (o[p] = {
          index: h.binding++,
          id: h.group,
          snippets: []
        })).snippets.push(`	${u.name} : ${d}`);
      }
    }
    for (const u in o) {
      const c = o[u];
      a.push(this._getWGSLStructBinding(u, c.snippets.join(`,
`), "uniform", c.index, c.id));
    }
    let l = n.join(`
`);
    return l += s.join(`
`), l += a.join(`
`), l;
  }
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const i in e) {
      const n = e[i];
      n.uniforms = this.getUniforms(i), n.attributes = this.getAttributes(i), n.varyings = this.getVaryings(i), n.structs = this.getStructs(i), n.vars = this.getVars(i), n.codes = this.getCodes(i), n.directives = this.getDirectives(i), n.scopedArrays = this.getScopedArrays(i);
      let s = `// code

`;
      s += this.flowCode[i];
      const a = this.flowNodes[i], o = a[a.length - 1], l = o.outputNode, u = l !== void 0 && l.isOutputStructNode === !0;
      for (const c of a) {
        const h = this.getFlowData(
          c
          /*, shaderStage*/
        ), d = c.name;
        if (d && (s.length > 0 && (s += `
`), s += `	// flow -> ${d}
	`), s += `${h.code}
	`, c === o && i !== "compute") {
          if (s += `// result

	`, i === "vertex")
            s += `varyings.Vertex = ${h.result};`;
          else if (i === "fragment")
            if (u)
              n.returnType = l.nodeType, s += `return ${h.result};`;
            else {
              let p = "	@location(0) color: vec4<f32>";
              const f = this.getBuiltins("output");
              f && (p += `,
	` + f), n.returnType = "OutputStruct", n.structs += this._getWGSLStruct("OutputStruct", p), n.structs += `
var<private> output : OutputStruct;

`, s += `output.color = ${h.result};

	return output;`;
            }
        }
      }
      n.flow = s;
    }
    this.material !== null ? (this.vertexShader = this._getWGSLVertexCode(e.vertex), this.fragmentShader = this._getWGSLFragmentCode(e.fragment)) : this.computeShader = this._getWGSLComputeCode(e.compute, (this.object.workgroupSize || [64]).join(", "));
  }
  getMethod(e, i = null) {
    let n;
    return i !== null && (n = this._getWGSLMethod(e + "_" + i)), n === void 0 && (n = this._getWGSLMethod(e)), n || e;
  }
  getType(e) {
    return fJ[e] || e;
  }
  isAvailable(e) {
    let i = yM[e];
    return i === void 0 && (e === "float32Filterable" && (i = this.renderer.hasFeature("float32-filterable")), yM[e] = i), i;
  }
  _getWGSLMethod(e) {
    return Ws[e] !== void 0 && this._include(e), Hh[e];
  }
  _include(e) {
    const i = Ws[e];
    return i.build(this), this.currentFunctionNode !== null && this.currentFunctionNode.includes.push(i), i;
  }
  _getWGSLVertexCode(e) {
    return `${this.getSignature()}
// directives
${e.directives}

// uniforms
${e.uniforms}

// varyings
${e.varyings}
var<private> varyings : VaryingsStruct;

// codes
${e.codes}

@vertex
fn main( ${e.attributes} ) -> VaryingsStruct {

	// vars
	${e.vars}

	// flow
	${e.flow}

	return varyings;

}
`;
  }
  _getWGSLFragmentCode(e) {
    return `${this.getSignature()}
// global
${pI}

// uniforms
${e.uniforms}

// structs
${e.structs}

// codes
${e.codes}

@fragment
fn main( ${e.varyings} ) -> ${e.returnType} {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  _getWGSLComputeCode(e, i) {
    return `${this.getSignature()}
// directives
${e.directives}

// system
var<private> instanceIndex : u32;

// locals
${e.scopedArrays}

// uniforms
${e.uniforms}

// codes
${e.codes}

@compute @workgroup_size( ${i} )
fn main( ${e.attributes} ) {

	// system
	instanceIndex = id.x + id.y * numWorkgroups.x * u32(${i}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${i});

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  _getWGSLStruct(e, i) {
    return `
struct ${e} {
${i}
};`;
  }
  _getWGSLStructBinding(e, i, n, s = 0, a = 0) {
    const o = e + "Struct";
    return `${this._getWGSLStruct(o, i)}
@binding( ${s} ) @group( ${a} )
var<${n}> ${e} : ${o};`;
  }
}
class gJ {
  constructor(e) {
    this.backend = e;
  }
  getCurrentDepthStencilFormat(e) {
    let i;
    return e.depthTexture !== null ? i = this.getTextureFormatGPU(e.depthTexture) : e.depth && e.stencil ? i = Z.Depth24PlusStencil8 : e.depth && (i = Z.Depth24Plus), i;
  }
  getTextureFormatGPU(e) {
    return this.backend.get(e).format;
  }
  getCurrentColorFormat(e) {
    let i;
    return e.textures !== null ? i = this.getTextureFormatGPU(e.textures[0]) : i = this.getPreferredCanvasFormat(), i;
  }
  getCurrentColorSpace(e) {
    return e.textures !== null ? e.textures[0].colorSpace : this.backend.renderer.outputColorSpace;
  }
  getPrimitiveTopology(e, i) {
    if (e.isPoints) return Bu.PointList;
    if (e.isLineSegments || e.isMesh && i.wireframe === !0) return Bu.LineList;
    if (e.isLine) return Bu.LineStrip;
    if (e.isMesh) return Bu.TriangleList;
  }
  getSampleCount(e) {
    let i = 1;
    return e > 1 && (i = Math.pow(2, Math.floor(Math.log2(e))), i === 2 && (i = 4)), i;
  }
  getSampleCountRenderContext(e) {
    return e.textures !== null ? this.getSampleCount(e.sampleCount) : this.getSampleCount(this.backend.renderer.samples);
  }
  getPreferredCanvasFormat() {
    return navigator.userAgent.includes("Quest") ? Z.BGRA8Unorm : navigator.gpu.getPreferredCanvasFormat();
  }
}
const yJ = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]), vJ = /* @__PURE__ */ new Map([
  [y3, ["float16"]]
]), bJ = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Int16Array, "sint32"],
  // patch for INT16
  [Uint32Array, "uint32"],
  [Uint16Array, "uint32"],
  // patch for UINT16
  [Float32Array, "float32"]
]);
class xJ {
  constructor(e) {
    this.backend = e;
  }
  createAttribute(e, i) {
    const n = this._getBufferAttribute(e), s = this.backend, a = s.get(n);
    let o = a.buffer;
    if (o === void 0) {
      const l = s.device;
      let u = n.array;
      if (e.normalized === !1 && (u.constructor === Int16Array || u.constructor === Uint16Array)) {
        const h = new Uint32Array(u.length);
        for (let d = 0; d < u.length; d++)
          h[d] = u[d];
        u = h;
      }
      if (n.array = u, (n.isStorageBufferAttribute || n.isStorageInstancedBufferAttribute) && n.itemSize === 3) {
        u = new u.constructor(n.count * 4);
        for (let h = 0; h < n.count; h++)
          u.set(n.array.subarray(h * 3, h * 3 + 3), h * 4);
        n.itemSize = 4, n.array = u;
      }
      const c = u.byteLength + (4 - u.byteLength % 4) % 4;
      o = l.createBuffer({
        label: n.name,
        size: c,
        usage: i,
        mappedAtCreation: !0
      }), new u.constructor(o.getMappedRange()).set(u), o.unmap(), a.buffer = o;
    }
  }
  updateAttribute(e) {
    const i = this._getBufferAttribute(e), n = this.backend, s = n.device, a = n.get(i).buffer, o = i.array, l = i.updateRanges;
    if (l.length === 0)
      s.queue.writeBuffer(
        a,
        0,
        o,
        0
      );
    else {
      for (let u = 0, c = l.length; u < c; u++) {
        const h = l[u];
        s.queue.writeBuffer(
          a,
          0,
          o,
          h.start * o.BYTES_PER_ELEMENT,
          h.count * o.BYTES_PER_ELEMENT
        );
      }
      i.clearUpdateRanges();
    }
  }
  createShaderVertexBuffers(e) {
    const i = e.getAttributes(), n = /* @__PURE__ */ new Map();
    for (let s = 0; s < i.length; s++) {
      const a = i[s], o = a.array.BYTES_PER_ELEMENT, l = this._getBufferAttribute(a);
      let u = n.get(l);
      if (u === void 0) {
        let d, p;
        a.isInterleavedBufferAttribute === !0 ? (d = a.data.stride * o, p = a.data.isInstancedInterleavedBuffer ? yf.Instance : yf.Vertex) : (d = a.itemSize * o, p = a.isInstancedBufferAttribute ? yf.Instance : yf.Vertex), a.normalized === !1 && (a.array.constructor === Int16Array || a.array.constructor === Uint16Array) && (d = 4), u = {
          arrayStride: d,
          attributes: [],
          stepMode: p
        }, n.set(l, u);
      }
      const c = this._getVertexFormat(a), h = a.isInterleavedBufferAttribute === !0 ? a.offset * o : 0;
      u.attributes.push({
        shaderLocation: s,
        offset: h,
        format: c
      });
    }
    return Array.from(n.values());
  }
  destroyAttribute(e) {
    const i = this.backend;
    i.get(this._getBufferAttribute(e)).buffer.destroy(), i.delete(e);
  }
  async getArrayBufferAsync(e) {
    const i = this.backend, n = i.device, s = i.get(this._getBufferAttribute(e)).buffer, a = s.size, o = n.createBuffer({
      label: e.name,
      size: a,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    }), l = n.createCommandEncoder({});
    l.copyBufferToBuffer(
      s,
      0,
      o,
      0,
      a
    ), o.unmap();
    const u = l.finish();
    return n.queue.submit([u]), await o.mapAsync(GPUMapMode.READ), o.getMappedRange();
  }
  _getVertexFormat(e) {
    const { itemSize: i, normalized: n } = e, s = e.array.constructor, a = e.constructor;
    let o;
    if (i == 1)
      o = bJ.get(s);
    else {
      const l = (vJ.get(a) || yJ.get(s))[n ? 1 : 0];
      if (l) {
        const u = s.BYTES_PER_ELEMENT * i, c = Math.floor((u + 3) / 4) * 4 / s.BYTES_PER_ELEMENT;
        if (c % 1)
          throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
        o = `${l}x${c}`;
      }
    }
    return o || console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet."), o;
  }
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
class _J {
  constructor(e) {
    this.backend = e, this.bindGroupLayoutCache = /* @__PURE__ */ new WeakMap();
  }
  createBindingsLayout(e) {
    const i = this.backend.device, n = [];
    let s = 0;
    for (const a of e.bindings) {
      const o = {
        binding: s++,
        visibility: a.visibility
      };
      if (a.isUniformBuffer || a.isStorageBuffer) {
        const l = {};
        a.isStorageBuffer && (l.type = a.access), o.buffer = l;
      } else if (a.isSampler) {
        const l = {};
        a.texture.isDepthTexture && a.texture.compareFunction !== null && (l.type = "comparison"), o.sampler = l;
      } else if (a.isSampledTexture && a.texture.isVideoTexture)
        o.externalTexture = {};
      else if (a.isSampledTexture && a.store) {
        const l = this.backend.get(a.texture).texture.format, u = a.access;
        o.storageTexture = { format: l, access: u };
      } else if (a.isSampledTexture) {
        const l = {};
        if (a.texture.isMultisampleRenderTargetTexture === !0 && (l.multisampled = !0), a.texture.isDepthTexture)
          l.sampleType = Mh.Depth;
        else if (a.texture.isDataTexture || a.texture.isDataArrayTexture || a.texture.isData3DTexture) {
          const u = a.texture.type;
          u === wr ? l.sampleType = Mh.SInt : u === er ? l.sampleType = Mh.UInt : u === on && (this.backend.hasFeature("float32-filterable") ? l.sampleType = Mh.Float : l.sampleType = Mh.UnfilterableFloat);
        }
        a.isSampledCubeTexture ? l.viewDimension = yn.Cube : a.texture.isDataArrayTexture || a.texture.isCompressedArrayTexture ? l.viewDimension = yn.TwoDArray : a.isSampledTexture3D && (l.viewDimension = yn.ThreeD), o.texture = l;
      } else
        console.error(`WebGPUBindingUtils: Unsupported binding "${a}".`);
      n.push(o);
    }
    return i.createBindGroupLayout({ entries: n });
  }
  createBindings(e) {
    const { backend: i, bindGroupLayoutCache: n } = this, s = i.get(e);
    let a = n.get(e.bindingsReference);
    a === void 0 && (a = this.createBindingsLayout(e), n.set(e.bindingsReference, a));
    const o = this.createBindGroup(e, a);
    s.layout = a, s.group = o;
  }
  updateBinding(e) {
    const i = this.backend, n = i.device, s = e.buffer, a = i.get(e).buffer;
    n.queue.writeBuffer(a, 0, s, 0);
  }
  createBindGroup(e, i) {
    const n = this.backend, s = n.device;
    let a = 0;
    const o = [];
    for (const l of e.bindings) {
      if (l.isUniformBuffer) {
        const u = n.get(l);
        if (u.buffer === void 0) {
          const c = l.byteLength, h = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, d = s.createBuffer({
            label: "bindingBuffer_" + l.name,
            size: c,
            usage: h
          });
          u.buffer = d;
        }
        o.push({ binding: a, resource: { buffer: u.buffer } });
      } else if (l.isStorageBuffer) {
        const u = n.get(l);
        if (u.buffer === void 0) {
          const c = l.attribute;
          u.buffer = n.get(c).buffer;
        }
        o.push({ binding: a, resource: { buffer: u.buffer } });
      } else if (l.isSampler) {
        const u = n.get(l.texture);
        o.push({ binding: a, resource: u.sampler });
      } else if (l.isSampledTexture) {
        const u = n.get(l.texture);
        let c;
        if (u.externalTexture !== void 0)
          c = s.importExternalTexture({ source: u.externalTexture });
        else {
          const h = l.store ? 1 : u.texture.mipLevelCount, d = `view-${u.texture.width}-${u.texture.height}-${h}`;
          if (c = u[d], c === void 0) {
            const p = lQ.All;
            let f;
            l.isSampledCubeTexture ? f = yn.Cube : l.isSampledTexture3D ? f = yn.ThreeD : l.texture.isDataArrayTexture || l.texture.isCompressedArrayTexture ? f = yn.TwoDArray : f = yn.TwoD, c = u[d] = u.texture.createView({ aspect: p, dimension: f, mipLevelCount: h });
          }
        }
        o.push({ binding: a, resource: c });
      }
      a++;
    }
    return s.createBindGroup({
      label: "bindGroup_" + e.name,
      layout: i,
      entries: o
    });
  }
}
class TJ {
  constructor(e) {
    this.backend = e;
  }
  _getSampleCount(e) {
    return this.backend.utils.getSampleCountRenderContext(e);
  }
  createRenderPipeline(e, i) {
    const { object: n, material: s, geometry: a, pipeline: o } = e, { vertexProgram: l, fragmentProgram: u } = o, c = this.backend, h = c.device, d = c.utils, p = c.get(o), f = [];
    for (const P of e.getBindings()) {
      const A = c.get(P);
      f.push(A.layout);
    }
    const m = c.attributeUtils.createShaderVertexBuffers(e);
    let y;
    s.transparent === !0 && s.blending !== xc && (y = this._getBlending(s));
    let v = {};
    s.stencilWrite === !0 && (v = {
      compare: this._getStencilCompare(s),
      failOp: this._getStencilOperation(s.stencilFail),
      depthFailOp: this._getStencilOperation(s.stencilZFail),
      passOp: this._getStencilOperation(s.stencilZPass)
    });
    const g = this._getColorWriteMask(s), _ = [];
    if (e.context.textures !== null) {
      const P = e.context.textures;
      for (let A = 0; A < P.length; A++) {
        const D = d.getTextureFormatGPU(P[A]);
        _.push({
          format: D,
          blend: y,
          writeMask: g
        });
      }
    } else {
      const P = d.getCurrentColorFormat(e.context);
      _.push({
        format: P,
        blend: y,
        writeMask: g
      });
    }
    const x = c.get(l).module, b = c.get(u).module, T = this._getPrimitiveState(n, a, s), E = this._getDepthCompare(s), M = d.getCurrentDepthStencilFormat(e.context), C = this._getSampleCount(e.context), S = {
      label: `renderPipeline_${s.name || s.type}_${s.id}`,
      vertex: Object.assign({}, x, { buffers: m }),
      fragment: Object.assign({}, b, { targets: _ }),
      primitive: T,
      multisample: {
        count: C,
        alphaToCoverageEnabled: s.alphaToCoverage && C > 1
      },
      layout: h.createPipelineLayout({
        bindGroupLayouts: f
      })
    }, w = {}, R = e.context.depth, O = e.context.stencil;
    if ((R === !0 || O === !0) && (R === !0 && (w.format = M, w.depthWriteEnabled = s.depthWrite, w.depthCompare = E), O === !0 && (w.stencilFront = v, w.stencilBack = {}, w.stencilReadMask = s.stencilFuncMask, w.stencilWriteMask = s.stencilWriteMask), S.depthStencil = w), i === null)
      p.pipeline = h.createRenderPipeline(S);
    else {
      const P = new Promise((A) => {
        h.createRenderPipelineAsync(S).then((D) => {
          p.pipeline = D, A();
        });
      });
      i.push(P);
    }
  }
  createBundleEncoder(e) {
    const i = this.backend, { utils: n, device: s } = i, a = n.getCurrentDepthStencilFormat(e), o = n.getCurrentColorFormat(e), l = this._getSampleCount(e), u = {
      label: "renderBundleEncoder",
      colorFormats: [o],
      depthStencilFormat: a,
      sampleCount: l
    };
    return s.createRenderBundleEncoder(u);
  }
  createComputePipeline(e, i) {
    const n = this.backend, s = n.device, a = n.get(e.computeProgram).module, o = n.get(e), l = [];
    for (const u of i) {
      const c = n.get(u);
      l.push(c.layout);
    }
    o.pipeline = s.createComputePipeline({
      compute: a,
      layout: s.createPipelineLayout({
        bindGroupLayouts: l
      })
    });
  }
  _getBlending(e) {
    let i, n;
    const s = e.blending, a = e.blendSrc, o = e.blendDst, l = e.blendEquation;
    if (s === BN) {
      const u = e.blendSrcAlpha !== null ? e.blendSrcAlpha : a, c = e.blendDstAlpha !== null ? e.blendDstAlpha : o, h = e.blendEquationAlpha !== null ? e.blendEquationAlpha : l;
      i = {
        srcFactor: this._getBlendFactor(a),
        dstFactor: this._getBlendFactor(o),
        operation: this._getBlendOperation(l)
      }, n = {
        srcFactor: this._getBlendFactor(u),
        dstFactor: this._getBlendFactor(c),
        operation: this._getBlendOperation(h)
      };
    } else {
      const u = e.premultipliedAlpha, c = (h, d, p, f) => {
        i = {
          srcFactor: h,
          dstFactor: d,
          operation: Fo.Add
        }, n = {
          srcFactor: p,
          dstFactor: f,
          operation: Fo.Add
        };
      };
      if (u)
        switch (s) {
          case uo:
            c(vt.One, vt.OneMinusSrcAlpha, vt.One, vt.OneMinusSrcAlpha);
            break;
          case Pm:
            c(vt.One, vt.One, vt.One, vt.One);
            break;
          case Im:
            c(vt.Zero, vt.OneMinusSrc, vt.Zero, vt.One);
            break;
          case Om:
            c(vt.Zero, vt.Src, vt.Zero, vt.SrcAlpha);
            break;
        }
      else
        switch (s) {
          case uo:
            c(vt.SrcAlpha, vt.OneMinusSrcAlpha, vt.One, vt.OneMinusSrcAlpha);
            break;
          case Pm:
            c(vt.SrcAlpha, vt.One, vt.SrcAlpha, vt.One);
            break;
          case Im:
            c(vt.Zero, vt.OneMinusSrc, vt.Zero, vt.One);
            break;
          case Om:
            c(vt.Zero, vt.Src, vt.Zero, vt.Src);
            break;
        }
    }
    if (i !== void 0 && n !== void 0)
      return { color: i, alpha: n };
    console.error("THREE.WebGPURenderer: Invalid blending: ", s);
  }
  _getBlendFactor(e) {
    let i;
    switch (e) {
      case VN:
        i = vt.Zero;
        break;
      case GN:
        i = vt.One;
        break;
      case HN:
        i = vt.Src;
        break;
      case WN:
        i = vt.OneMinusSrc;
        break;
      case Dm:
        i = vt.SrcAlpha;
        break;
      case Lm:
        i = vt.OneMinusSrcAlpha;
        break;
      case YN:
        i = vt.Dst;
        break;
      case KN:
        i = vt.OneMinusDstColor;
        break;
      case qN:
        i = vt.DstAlpha;
        break;
      case XN:
        i = vt.OneMinusDstAlpha;
        break;
      case ZN:
        i = vt.SrcAlphaSaturated;
        break;
      case kZ:
        i = vt.Constant;
        break;
      case UZ:
        i = vt.OneMinusConstant;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend factor not supported.", e);
    }
    return i;
  }
  _getStencilCompare(e) {
    let i;
    const n = e.stencilFunc;
    switch (n) {
      case s7:
        i = $i.Never;
        break;
      case mx:
        i = $i.Always;
        break;
      case a7:
        i = $i.Less;
        break;
      case l7:
        i = $i.LessEqual;
        break;
      case o7:
        i = $i.Equal;
        break;
      case h7:
        i = $i.GreaterEqual;
        break;
      case u7:
        i = $i.Greater;
        break;
      case c7:
        i = $i.NotEqual;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil function.", n);
    }
    return i;
  }
  _getStencilOperation(e) {
    let i;
    switch (e) {
      case Vo:
        i = Ga.Keep;
        break;
      case $H:
        i = Ga.Zero;
        break;
      case JH:
        i = Ga.Replace;
        break;
      case n7:
        i = Ga.Invert;
        break;
      case e7:
        i = Ga.IncrementClamp;
        break;
      case t7:
        i = Ga.DecrementClamp;
        break;
      case i7:
        i = Ga.IncrementWrap;
        break;
      case r7:
        i = Ga.DecrementWrap;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil operation.", i);
    }
    return i;
  }
  _getBlendOperation(e) {
    let i;
    switch (e) {
      case Ja:
        i = Fo.Add;
        break;
      case zN:
        i = Fo.Subtract;
        break;
      case jN:
        i = Fo.ReverseSubtract;
        break;
      case DH:
        i = Fo.Min;
        break;
      case LH:
        i = Fo.Max;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.", e);
    }
    return i;
  }
  _getPrimitiveState(e, i, n) {
    const s = {}, a = this.backend.utils;
    switch (s.topology = a.getPrimitiveTopology(e, n), i.index !== null && e.isLine === !0 && e.isLineSegments !== !0 && (s.stripIndexFormat = i.index.array instanceof Uint16Array ? Mc.Uint16 : Mc.Uint32), n.side) {
      case bc:
        s.frontFace = ev.CCW, s.cullMode = tv.Back;
        break;
      case Qn:
        s.frontFace = ev.CCW, s.cullMode = tv.Front;
        break;
      case Yu:
        s.frontFace = ev.CCW, s.cullMode = tv.None;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.", n.side);
        break;
    }
    return s;
  }
  _getColorWriteMask(e) {
    return e.colorWrite === !0 ? X2.All : X2.None;
  }
  _getDepthCompare(e) {
    let i;
    if (e.depthTest === !1)
      i = $i.Always;
    else {
      const n = e.depthFunc;
      switch (n) {
        case QN:
          i = $i.Never;
          break;
        case $N:
          i = $i.Always;
          break;
        case JN:
          i = $i.Less;
          break;
        case km:
          i = $i.LessEqual;
          break;
        case e3:
          i = $i.Equal;
          break;
        case t3:
          i = $i.GreaterEqual;
          break;
        case i3:
          i = $i.Greater;
          break;
        case r3:
          i = $i.NotEqual;
          break;
        default:
          console.error("THREE.WebGPUPipelineUtils: Invalid depth function.", n);
      }
    }
    return i;
  }
}
class wJ extends dI {
  constructor(e = {}) {
    super(e), this.isWebGPUBackend = !0, this.parameters.alpha = e.alpha === void 0 ? !0 : e.alpha, this.parameters.requiredLimits = e.requiredLimits === void 0 ? {} : e.requiredLimits, this.trackTimestamp = e.trackTimestamp === !0, this.device = null, this.context = null, this.colorBuffer = null, this.defaultRenderPassdescriptor = null, this.utils = new gJ(this), this.attributeUtils = new xJ(this), this.bindingUtils = new _J(this), this.pipelineUtils = new TJ(this), this.textureUtils = new oJ(this), this.occludedResolveCache = /* @__PURE__ */ new Map();
  }
  async init(e) {
    await super.init(e);
    const i = this.parameters;
    let n;
    if (i.device === void 0) {
      const o = {
        powerPreference: i.powerPreference
      }, l = await navigator.gpu.requestAdapter(o);
      if (l === null)
        throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
      const u = Object.values(Px), c = [];
      for (const d of u)
        l.features.has(d) && c.push(d);
      const h = {
        requiredFeatures: c,
        requiredLimits: i.requiredLimits
      };
      n = await l.requestDevice(h);
    } else
      n = i.device;
    n.lost.then((o) => {
      const l = {
        api: "WebGPU",
        message: o.message || "Unknown reason",
        reason: o.reason || null,
        originalEvent: o
      };
      e.onDeviceLost(l);
    });
    const s = i.context !== void 0 ? i.context : e.domElement.getContext("webgpu");
    this.device = n, this.context = s;
    const a = i.alpha ? "premultiplied" : "opaque";
    this.trackTimestamp = this.trackTimestamp && this.hasFeature(Px.TimestampQuery), this.context.configure({
      device: this.device,
      format: this.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
      alphaMode: a
    }), this.updateSize();
  }
  get coordinateSystem() {
    return Sl;
  }
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  getContext() {
    return this.context;
  }
  _getDefaultRenderPassDescriptor() {
    let e = this.defaultRenderPassdescriptor;
    if (e === null) {
      const n = this.renderer;
      e = {
        colorAttachments: [{
          view: null
        }]
      }, (this.renderer.depth === !0 || this.renderer.stencil === !0) && (e.depthStencilAttachment = {
        view: this.textureUtils.getDepthBuffer(n.depth, n.stencil).createView()
      });
      const s = e.colorAttachments[0];
      this.renderer.samples > 0 ? s.view = this.colorBuffer.createView() : s.resolveTarget = void 0, this.defaultRenderPassdescriptor = e;
    }
    const i = e.colorAttachments[0];
    return this.renderer.samples > 0 ? i.resolveTarget = this.context.getCurrentTexture().createView() : i.view = this.context.getCurrentTexture().createView(), e;
  }
  _getRenderPassDescriptor(e) {
    const i = e.renderTarget, n = this.get(i);
    let s = n.descriptors;
    if (s === void 0 || n.width !== i.width || n.height !== i.height || n.activeMipmapLevel !== i.activeMipmapLevel || n.samples !== i.samples) {
      s = {}, n.descriptors = s;
      const l = () => {
        i.removeEventListener("dispose", l), this.delete(i);
      };
      i.addEventListener("dispose", l);
    }
    const a = e.getCacheKey();
    let o = s[a];
    if (o === void 0) {
      const l = e.textures, u = [];
      for (let c = 0; c < l.length; c++) {
        const h = this.get(l[c]), d = h.texture.createView({
          baseMipLevel: e.activeMipmapLevel,
          mipLevelCount: 1,
          baseArrayLayer: e.activeCubeFace,
          dimension: yn.TwoD
        });
        let p, f;
        h.msaaTexture !== void 0 ? (p = h.msaaTexture.createView(), f = d) : (p = d, f = void 0), u.push({
          view: p,
          resolveTarget: f,
          loadOp: Oi.Load,
          storeOp: Ji.Store
        });
      }
      if (o = {
        colorAttachments: u
      }, e.depth) {
        const c = {
          view: this.get(e.depthTexture).texture.createView()
        };
        o.depthStencilAttachment = c;
      }
      s[a] = o, n.width = i.width, n.height = i.height, n.samples = i.samples, n.activeMipmapLevel = i.activeMipmapLevel;
    }
    return o;
  }
  beginRender(e) {
    const i = this.get(e), n = this.device, s = e.occlusionQueryCount;
    let a;
    s > 0 && (i.currentOcclusionQuerySet && i.currentOcclusionQuerySet.destroy(), i.currentOcclusionQueryBuffer && i.currentOcclusionQueryBuffer.destroy(), i.currentOcclusionQuerySet = i.occlusionQuerySet, i.currentOcclusionQueryBuffer = i.occlusionQueryBuffer, i.currentOcclusionQueryObjects = i.occlusionQueryObjects, a = n.createQuerySet({ type: "occlusion", count: s }), i.occlusionQuerySet = a, i.occlusionQueryIndex = 0, i.occlusionQueryObjects = new Array(s), i.lastOcclusionObject = null);
    let o;
    e.textures === null ? o = this._getDefaultRenderPassDescriptor() : o = this._getRenderPassDescriptor(e), this.initTimestampQuery(e, o), o.occlusionQuerySet = a;
    const l = o.depthStencilAttachment;
    if (e.textures !== null) {
      const h = o.colorAttachments;
      for (let d = 0; d < h.length; d++) {
        const p = h[d];
        e.clearColor ? (p.clearValue = d === 0 ? e.clearColorValue : { r: 0, g: 0, b: 0, a: 1 }, p.loadOp = Oi.Clear, p.storeOp = Ji.Store) : (p.loadOp = Oi.Load, p.storeOp = Ji.Store);
      }
    } else {
      const h = o.colorAttachments[0];
      e.clearColor ? (h.clearValue = e.clearColorValue, h.loadOp = Oi.Clear, h.storeOp = Ji.Store) : (h.loadOp = Oi.Load, h.storeOp = Ji.Store);
    }
    e.depth && (e.clearDepth ? (l.depthClearValue = e.clearDepthValue, l.depthLoadOp = Oi.Clear, l.depthStoreOp = Ji.Store) : (l.depthLoadOp = Oi.Load, l.depthStoreOp = Ji.Store)), e.stencil && (e.clearStencil ? (l.stencilClearValue = e.clearStencilValue, l.stencilLoadOp = Oi.Clear, l.stencilStoreOp = Ji.Store) : (l.stencilLoadOp = Oi.Load, l.stencilStoreOp = Ji.Store));
    const u = n.createCommandEncoder({ label: "renderContext_" + e.id }), c = u.beginRenderPass(o);
    if (i.descriptor = o, i.encoder = u, i.currentPass = c, i.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, i.renderBundles = [], e.viewport && this.updateViewport(e), e.scissor) {
      const { x: h, y: d, width: p, height: f } = e.scissorValue;
      c.setScissorRect(h, d, p, f);
    }
  }
  finishRender(e) {
    const i = this.get(e), n = e.occlusionQueryCount;
    if (i.renderBundles.length > 0 && i.currentPass.executeBundles(i.renderBundles), n > i.occlusionQueryIndex && i.currentPass.endOcclusionQuery(), i.currentPass.end(), n > 0) {
      const s = n * 8;
      let a = this.occludedResolveCache.get(s);
      a === void 0 && (a = this.device.createBuffer(
        {
          size: s,
          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
        }
      ), this.occludedResolveCache.set(s, a));
      const o = this.device.createBuffer(
        {
          size: s,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        }
      );
      i.encoder.resolveQuerySet(i.occlusionQuerySet, 0, n, a, 0), i.encoder.copyBufferToBuffer(a, 0, o, 0, s), i.occlusionQueryBuffer = o, this.resolveOccludedAsync(e);
    }
    if (this.prepareTimestampBuffer(e, i.encoder), this.device.queue.submit([i.encoder.finish()]), e.textures !== null) {
      const s = e.textures;
      for (let a = 0; a < s.length; a++) {
        const o = s[a];
        o.generateMipmaps === !0 && this.textureUtils.generateMipmaps(o);
      }
    }
  }
  isOccluded(e, i) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(i);
  }
  async resolveOccludedAsync(e) {
    const i = this.get(e), { currentOcclusionQueryBuffer: n, currentOcclusionQueryObjects: s } = i;
    if (n && s) {
      const a = /* @__PURE__ */ new WeakSet();
      i.currentOcclusionQueryObjects = null, i.currentOcclusionQueryBuffer = null, await n.mapAsync(GPUMapMode.READ);
      const o = n.getMappedRange(), l = new BigUint64Array(o);
      for (let u = 0; u < s.length; u++)
        l[u] !== BigInt(0) && a.add(s[u]);
      n.destroy(), i.occluded = a;
    }
  }
  updateViewport(e) {
    const { currentPass: i } = this.get(e), { x: n, y: s, width: a, height: o, minDepth: l, maxDepth: u } = e.viewportValue;
    i.setViewport(n, s, a, o, l, u);
  }
  clear(e, i, n, s = null) {
    const a = this.device, o = this.renderer;
    let l = [], u, c, h, d;
    if (e) {
      const f = this.getClearColor();
      if (this.renderer.alpha === !0) {
        const m = f.a;
        c = { r: f.r * m, g: f.g * m, b: f.b * m, a: m };
      } else
        c = { r: f.r, g: f.g, b: f.b, a: f.a };
    }
    if (s === null) {
      h = o.depth, d = o.stencil;
      const f = this._getDefaultRenderPassDescriptor();
      if (e) {
        l = f.colorAttachments;
        const m = l[0];
        m.clearValue = c, m.loadOp = Oi.Clear, m.storeOp = Ji.Store;
      }
      (h || d) && (u = f.depthStencilAttachment);
    } else {
      if (h = s.depth, d = s.stencil, e)
        for (const f of s.textures) {
          const m = this.get(f), y = m.texture.createView();
          let v, g;
          m.msaaTexture !== void 0 ? (v = m.msaaTexture.createView(), g = y) : (v = y, g = void 0), l.push({
            view: v,
            resolveTarget: g,
            clearValue: c,
            loadOp: Oi.Clear,
            storeOp: Ji.Store
          });
        }
      (h || d) && (u = {
        view: this.get(s.depthTexture).texture.createView()
      });
    }
    h && (i ? (u.depthLoadOp = Oi.Clear, u.depthClearValue = o.getClearDepth(), u.depthStoreOp = Ji.Store) : (u.depthLoadOp = Oi.Load, u.depthStoreOp = Ji.Store)), d && (n ? (u.stencilLoadOp = Oi.Clear, u.stencilClearValue = o.getClearStencil(), u.stencilStoreOp = Ji.Store) : (u.stencilLoadOp = Oi.Load, u.stencilStoreOp = Ji.Store));
    const p = a.createCommandEncoder({});
    p.beginRenderPass({
      colorAttachments: l,
      depthStencilAttachment: u
    }).end(), a.queue.submit([p.finish()]);
  }
  // compute
  beginCompute(e) {
    const i = this.get(e), n = {};
    this.initTimestampQuery(e, n), i.cmdEncoderGPU = this.device.createCommandEncoder(), i.passEncoderGPU = i.cmdEncoderGPU.beginComputePass(n);
  }
  compute(e, i, n, s) {
    const { passEncoderGPU: a } = this.get(e), o = this.get(s).pipeline;
    a.setPipeline(o);
    for (let h = 0, d = n.length; h < d; h++) {
      const p = n[h], f = this.get(p);
      a.setBindGroup(h, f.group);
    }
    const l = this.device.limits.maxComputeWorkgroupsPerDimension, u = this.get(i);
    u.dispatchSize === void 0 && (u.dispatchSize = { x: 0, y: 1, z: 1 });
    const { dispatchSize: c } = u;
    i.dispatchCount > l ? (c.x = Math.min(i.dispatchCount, l), c.y = Math.ceil(i.dispatchCount / l)) : c.x = i.dispatchCount, a.dispatchWorkgroups(
      c.x,
      c.y,
      c.z
    );
  }
  finishCompute(e) {
    const i = this.get(e);
    i.passEncoderGPU.end(), this.prepareTimestampBuffer(e, i.cmdEncoderGPU), this.device.queue.submit([i.cmdEncoderGPU.finish()]);
  }
  async waitForGPU() {
    await this.device.queue.onSubmittedWorkDone();
  }
  // render object
  draw(e, i) {
    const { object: n, context: s, pipeline: a } = e, o = e.getBindings(), l = this.get(s), u = this.get(a).pipeline, c = l.currentSets, h = l.currentPass, d = e.getDrawParameters();
    if (d === null) return;
    c.pipeline !== u && (h.setPipeline(u), c.pipeline = u);
    const p = c.bindingGroups;
    for (let v = 0, g = o.length; v < g; v++) {
      const _ = o[v], x = this.get(_);
      p[_.index] !== _.id && (h.setBindGroup(_.index, x.group), p[_.index] = _.id);
    }
    const f = e.getIndex(), m = f !== null;
    if (m === !0 && c.index !== f) {
      const v = this.get(f).buffer, g = f.array instanceof Uint16Array ? Mc.Uint16 : Mc.Uint32;
      h.setIndexBuffer(v, g), c.index = f;
    }
    const y = e.getVertexBuffers();
    for (let v = 0, g = y.length; v < g; v++) {
      const _ = y[v];
      if (c.attributes[v] !== _) {
        const x = this.get(_).buffer;
        h.setVertexBuffer(v, x), c.attributes[v] = _;
      }
    }
    if (l.occlusionQuerySet !== void 0) {
      const v = l.lastOcclusionObject;
      v !== n && (v !== null && v.occlusionTest === !0 && (h.endOcclusionQuery(), l.occlusionQueryIndex++), n.occlusionTest === !0 && (h.beginOcclusionQuery(l.occlusionQueryIndex), l.occlusionQueryObjects[l.occlusionQueryIndex] = n), l.lastOcclusionObject = n);
    }
    if (n.isBatchedMesh === !0) {
      const v = n._multiDrawStarts, g = n._multiDrawCounts, _ = n._multiDrawCount, x = n._multiDrawInstances, b = m ? f.array.BYTES_PER_ELEMENT : 1;
      for (let T = 0; T < _; T++) {
        const E = x ? x[T] : 1, M = E > 1 ? 0 : T;
        h.drawIndexed(g[T], E, v[T] / b, 0, M);
      }
    } else if (m === !0) {
      const { vertexCount: v, instanceCount: g, firstVertex: _ } = d, x = e.getIndirect();
      if (x !== null) {
        const b = this.get(x).buffer;
        h.drawIndexedIndirect(b, 0);
      } else
        h.drawIndexed(v, g, _, 0, 0);
      i.update(n, v, g);
    } else {
      const { vertexCount: v, instanceCount: g, firstVertex: _ } = d, x = e.getIndirect();
      if (x !== null) {
        const b = this.get(x).buffer;
        h.drawIndirect(b, 0);
      } else
        h.draw(v, g, _, 0);
      i.update(n, v, g);
    }
  }
  // cache key
  needsRenderUpdate(e) {
    const i = this.get(e), { object: n, material: s } = e, a = this.utils, o = a.getSampleCountRenderContext(e.context), l = a.getCurrentColorSpace(e.context), u = a.getCurrentColorFormat(e.context), c = a.getCurrentDepthStencilFormat(e.context), h = a.getPrimitiveTopology(n, s);
    let d = !1;
    return (i.material !== s || i.materialVersion !== s.version || i.transparent !== s.transparent || i.blending !== s.blending || i.premultipliedAlpha !== s.premultipliedAlpha || i.blendSrc !== s.blendSrc || i.blendDst !== s.blendDst || i.blendEquation !== s.blendEquation || i.blendSrcAlpha !== s.blendSrcAlpha || i.blendDstAlpha !== s.blendDstAlpha || i.blendEquationAlpha !== s.blendEquationAlpha || i.colorWrite !== s.colorWrite || i.depthWrite !== s.depthWrite || i.depthTest !== s.depthTest || i.depthFunc !== s.depthFunc || i.stencilWrite !== s.stencilWrite || i.stencilFunc !== s.stencilFunc || i.stencilFail !== s.stencilFail || i.stencilZFail !== s.stencilZFail || i.stencilZPass !== s.stencilZPass || i.stencilFuncMask !== s.stencilFuncMask || i.stencilWriteMask !== s.stencilWriteMask || i.side !== s.side || i.alphaToCoverage !== s.alphaToCoverage || i.sampleCount !== o || i.colorSpace !== l || i.colorFormat !== u || i.depthStencilFormat !== c || i.primitiveTopology !== h || i.clippingContextCacheKey !== e.clippingContext.cacheKey) && (i.material = s, i.materialVersion = s.version, i.transparent = s.transparent, i.blending = s.blending, i.premultipliedAlpha = s.premultipliedAlpha, i.blendSrc = s.blendSrc, i.blendDst = s.blendDst, i.blendEquation = s.blendEquation, i.blendSrcAlpha = s.blendSrcAlpha, i.blendDstAlpha = s.blendDstAlpha, i.blendEquationAlpha = s.blendEquationAlpha, i.colorWrite = s.colorWrite, i.depthWrite = s.depthWrite, i.depthTest = s.depthTest, i.depthFunc = s.depthFunc, i.stencilWrite = s.stencilWrite, i.stencilFunc = s.stencilFunc, i.stencilFail = s.stencilFail, i.stencilZFail = s.stencilZFail, i.stencilZPass = s.stencilZPass, i.stencilFuncMask = s.stencilFuncMask, i.stencilWriteMask = s.stencilWriteMask, i.side = s.side, i.alphaToCoverage = s.alphaToCoverage, i.sampleCount = o, i.colorSpace = l, i.colorFormat = u, i.depthStencilFormat = c, i.primitiveTopology = h, i.clippingContextCacheKey = e.clippingContext.cacheKey, d = !0), d;
  }
  getRenderCacheKey(e) {
    const { object: i, material: n } = e, s = this.utils, a = e.context;
    return [
      n.transparent,
      n.blending,
      n.premultipliedAlpha,
      n.blendSrc,
      n.blendDst,
      n.blendEquation,
      n.blendSrcAlpha,
      n.blendDstAlpha,
      n.blendEquationAlpha,
      n.colorWrite,
      n.depthWrite,
      n.depthTest,
      n.depthFunc,
      n.stencilWrite,
      n.stencilFunc,
      n.stencilFail,
      n.stencilZFail,
      n.stencilZPass,
      n.stencilFuncMask,
      n.stencilWriteMask,
      n.side,
      s.getSampleCountRenderContext(a),
      s.getCurrentColorSpace(a),
      s.getCurrentColorFormat(a),
      s.getCurrentDepthStencilFormat(a),
      s.getPrimitiveTopology(i, n),
      e.getGeometryCacheKey(),
      e.clippingContext.cacheKey
    ].join();
  }
  // textures
  createSampler(e) {
    this.textureUtils.createSampler(e);
  }
  destroySampler(e) {
    this.textureUtils.destroySampler(e);
  }
  createDefaultTexture(e) {
    this.textureUtils.createDefaultTexture(e);
  }
  createTexture(e, i) {
    this.textureUtils.createTexture(e, i);
  }
  updateTexture(e, i) {
    this.textureUtils.updateTexture(e, i);
  }
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  destroyTexture(e) {
    this.textureUtils.destroyTexture(e);
  }
  copyTextureToBuffer(e, i, n, s, a, o) {
    return this.textureUtils.copyTextureToBuffer(e, i, n, s, a, o);
  }
  initTimestampQuery(e, i) {
    if (!this.trackTimestamp) return;
    const n = this.get(e);
    if (!n.timeStampQuerySet) {
      const s = this.device.createQuerySet({ type: "timestamp", count: 2 });
      Object.assign(i, {
        timestampWrites: {
          querySet: s,
          beginningOfPassWriteIndex: 0,
          // Write timestamp in index 0 when pass begins.
          endOfPassWriteIndex: 1
          // Write timestamp in index 1 when pass ends.
        }
      }), n.timeStampQuerySet = s;
    }
  }
  // timestamp utils
  prepareTimestampBuffer(e, i) {
    if (!this.trackTimestamp) return;
    const n = this.get(e), s = 2 * BigInt64Array.BYTES_PER_ELEMENT;
    n.currentTimestampQueryBuffers === void 0 && (n.currentTimestampQueryBuffers = {
      resolveBuffer: this.device.createBuffer({
        label: "timestamp resolve buffer",
        size: s,
        usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
      }),
      resultBuffer: this.device.createBuffer({
        label: "timestamp result buffer",
        size: s,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }),
      isMappingPending: !1
    });
    const { resolveBuffer: a, resultBuffer: o, isMappingPending: l } = n.currentTimestampQueryBuffers;
    l !== !0 && (i.resolveQuerySet(n.timeStampQuerySet, 0, 2, a, 0), i.copyBufferToBuffer(a, 0, o, 0, s));
  }
  async resolveTimestampAsync(e, i = "render") {
    if (!this.trackTimestamp) return;
    const n = this.get(e);
    if (n.currentTimestampQueryBuffers === void 0) return;
    const { resultBuffer: s, isMappingPending: a } = n.currentTimestampQueryBuffers;
    a !== !0 && (n.currentTimestampQueryBuffers.isMappingPending = !0, s.mapAsync(GPUMapMode.READ).then(() => {
      const o = new BigUint64Array(s.getMappedRange()), l = Number(o[1] - o[0]) / 1e6;
      this.renderer.info.updateTimestamp(i, l), s.unmap(), n.currentTimestampQueryBuffers.isMappingPending = !1;
    }));
  }
  // node builder
  createNodeBuilder(e, i) {
    return new mJ(e, i);
  }
  // program
  createProgram(e) {
    const i = this.get(e);
    i.module = {
      module: this.device.createShaderModule({ code: e.code, label: e.stage }),
      entryPoint: "main"
    };
  }
  destroyProgram(e) {
    this.delete(e);
  }
  // pipelines
  createRenderPipeline(e, i) {
    this.pipelineUtils.createRenderPipeline(e, i);
  }
  createComputePipeline(e, i) {
    this.pipelineUtils.createComputePipeline(e, i);
  }
  beginBundle(e) {
    const i = this.get(e);
    i._currentPass = i.currentPass, i._currentSets = i.currentSets, i.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, i.currentPass = this.pipelineUtils.createBundleEncoder(e);
  }
  finishBundle(e, i) {
    const n = this.get(e), s = n.currentPass.finish();
    this.get(i).bundleGPU = s, n.currentSets = n._currentSets, n.currentPass = n._currentPass;
  }
  addBundle(e, i) {
    this.get(e).renderBundles.push(this.get(i).bundleGPU);
  }
  // bindings
  createBindings(e) {
    this.bindingUtils.createBindings(e);
  }
  updateBindings(e) {
    this.bindingUtils.createBindings(e);
  }
  updateBinding(e) {
    this.bindingUtils.updateBinding(e);
  }
  // attributes
  createIndexAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createIndirectStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  // canvas
  updateSize() {
    this.colorBuffer = this.textureUtils.getColorBuffer(), this.defaultRenderPassdescriptor = null;
  }
  // utils public
  getMaxAnisotropy() {
    return 16;
  }
  hasFeature(e) {
    return this.device.features.has(e);
  }
  copyTextureToTexture(e, i, n = null, s = null, a = 0) {
    let o = 0, l = 0, u = 0, c = 0, h = 0, d = 0, p = e.image.width, f = e.image.height;
    n !== null && (c = n.x, h = n.y, d = n.z || 0, p = n.width, f = n.height), s !== null && (o = s.x, l = s.y, u = s.z || 0);
    const m = this.device.createCommandEncoder({ label: "copyTextureToTexture_" + e.id + "_" + i.id }), y = this.get(e).texture, v = this.get(i).texture;
    m.copyTextureToTexture(
      {
        texture: y,
        mipLevel: a,
        origin: { x: c, y: h, z: d }
      },
      {
        texture: v,
        mipLevel: a,
        origin: { x: o, y: l, z: u }
      },
      [
        p,
        f,
        1
      ]
    ), this.device.queue.submit([m.finish()]);
  }
  copyFramebufferToTexture(e, i, n) {
    const s = this.get(i);
    let a = null;
    i.renderTarget ? e.isDepthTexture ? a = this.get(i.depthTexture).texture : a = this.get(i.textures[0]).texture : e.isDepthTexture ? a = this.textureUtils.getDepthBuffer(i.depth, i.stencil) : a = this.context.getCurrentTexture();
    const o = this.get(e).texture;
    if (a.format !== o.format) {
      console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.", a.format, o.format);
      return;
    }
    let l;
    if (s.currentPass ? (s.currentPass.end(), l = s.encoder) : l = this.device.createCommandEncoder({ label: "copyFramebufferToTexture_" + e.id }), l.copyTextureToTexture(
      {
        texture: a,
        origin: { x: n.x, y: n.y, z: 0 }
      },
      {
        texture: o
      },
      [
        n.z,
        n.w
      ]
    ), e.generateMipmaps && this.textureUtils.generateMipmaps(e), s.currentPass) {
      const { descriptor: u } = s;
      for (let c = 0; c < u.colorAttachments.length; c++)
        u.colorAttachments[c].loadOp = Oi.Load;
      i.depth && (u.depthStencilAttachment.depthLoadOp = Oi.Load), i.stencil && (u.depthStencilAttachment.stencilLoadOp = Oi.Load), s.currentPass = l.beginRenderPass(u), s.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
    } else
      this.device.queue.submit([l.finish()]);
  }
}
class SJ extends D3 {
  constructor(e, i, n, s, a, o) {
    super(e, i, n, s, a, o), this.iesMap = null;
  }
  copy(e, i) {
    return super.copy(e, i), this.iesMap = e.iesMap, this;
  }
}
class EJ extends sI {
  constructor() {
    super(), this.addMaterial(AK, C3), this.addMaterial(WP, g1), this.addMaterial(pZ, A3), this.addMaterial(yZ, R3), this.addMaterial(xK, Pg), this.addMaterial(EK, P3), this.addMaterial(fK, N3), this.addMaterial(_Z, I3), this.addMaterial(uK, f1), this.addMaterial(hK, O3), this.addMaterial(wZ, E3), this.addMaterial(AZ, w3), this.addMaterial(NZ, M3), this.addLight(zQ, uW), this.addLight(g$, hW), this.addLight(y$, pW), this.addLight(rI, D3), this.addLight(b$, dW), this.addLight(x$, aW), this.addLight(_$, mW), this.addLight(v$, SJ), this.addToneMapping(hQ, FH), this.addToneMapping(dQ, BH), this.addToneMapping(pQ, zH), this.addToneMapping(mQ, jH), this.addToneMapping(bQ, VH), this.addToneMapping(xQ, GH);
  }
}
class MJ extends I$ {
  constructor(e = {}) {
    let i;
    e.forceWebGL ? i = mM : (i = wJ, e.getFallback = () => (console.warn("THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend."), new mM(e)));
    const n = new i(e);
    super(n, e), this.library = new EJ(), this.isWebGPURenderer = !0;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Rg
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Rg);
const yv = { type: "change" }, X1 = { type: "start" }, Y1 = { type: "end" }, vM = 1e-6, Xt = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 }, Af = new ke(), Wa = new ke(), AJ = new Y(), Cf = new Y(), vv = new Y(), Su = new bs(), bM = new Y(), Rf = new Y(), bv = new Y(), Nf = new Y();
class CJ extends Eg {
  constructor(e, i = null) {
    super(e, i), this.enabled = !0, this.screen = { left: 0, top: 0, width: 0, height: 0 }, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = 0.3, this.noRotate = !1, this.noZoom = !1, this.noPan = !1, this.staticMoving = !1, this.dynamicDampingFactor = 0.2, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.keys = [
      "KeyA",
      "KeyS",
      "KeyD"
      /*D*/
    ], this.mouseButtons = { LEFT: ir.ROTATE, MIDDLE: ir.DOLLY, RIGHT: ir.PAN }, this.state = Xt.NONE, this.keyState = Xt.NONE, this.target = new Y(), this._lastPosition = new Y(), this._lastZoom = 1, this._touchZoomDistanceStart = 0, this._touchZoomDistanceEnd = 0, this._lastAngle = 0, this._eye = new Y(), this._movePrev = new ke(), this._moveCurr = new ke(), this._lastAxis = new Y(), this._zoomStart = new ke(), this._zoomEnd = new ke(), this._panStart = new ke(), this._panEnd = new ke(), this._pointers = [], this._pointerPositions = {}, this._onPointerMove = NJ.bind(this), this._onPointerDown = RJ.bind(this), this._onPointerUp = PJ.bind(this), this._onPointerCancel = IJ.bind(this), this._onContextMenu = BJ.bind(this), this._onMouseWheel = FJ.bind(this), this._onKeyDown = DJ.bind(this), this._onKeyUp = OJ.bind(this), this._onTouchStart = zJ.bind(this), this._onTouchMove = jJ.bind(this), this._onTouchEnd = VJ.bind(this), this._onMouseDown = LJ.bind(this), this._onMouseMove = kJ.bind(this), this._onMouseUp = UJ.bind(this), this._target0 = this.target.clone(), this._position0 = this.object.position.clone(), this._up0 = this.object.up.clone(), this._zoom0 = this.object.zoom, i !== null && (this.connect(), this.handleResize()), this.update();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown), window.addEventListener("keyup", this._onKeyUp), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  handleResize() {
    const e = this.domElement.getBoundingClientRect(), i = this.domElement.ownerDocument.documentElement;
    this.screen.left = e.left + window.pageXOffset - i.clientLeft, this.screen.top = e.top + window.pageYOffset - i.clientTop, this.screen.width = e.width, this.screen.height = e.height;
  }
  update() {
    this._eye.subVectors(this.object.position, this.target), this.noRotate || this._rotateCamera(), this.noZoom || this._zoomCamera(), this.noPan || this._panCamera(), this.object.position.addVectors(this.target, this._eye), this.object.isPerspectiveCamera ? (this._checkDistances(), this.object.lookAt(this.target), this._lastPosition.distanceToSquared(this.object.position) > vM && (this.dispatchEvent(yv), this._lastPosition.copy(this.object.position))) : this.object.isOrthographicCamera ? (this.object.lookAt(this.target), (this._lastPosition.distanceToSquared(this.object.position) > vM || this._lastZoom !== this.object.zoom) && (this.dispatchEvent(yv), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type.");
  }
  reset() {
    this.state = Xt.NONE, this.keyState = Xt.NONE, this.target.copy(this._target0), this.object.position.copy(this._position0), this.object.up.copy(this._up0), this.object.zoom = this._zoom0, this.object.updateProjectionMatrix(), this._eye.subVectors(this.object.position, this.target), this.object.lookAt(this.target), this.dispatchEvent(yv), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom;
  }
  _panCamera() {
    if (Wa.copy(this._panEnd).sub(this._panStart), Wa.lengthSq()) {
      if (this.object.isOrthographicCamera) {
        const e = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth, i = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;
        Wa.x *= e, Wa.y *= i;
      }
      Wa.multiplyScalar(this._eye.length() * this.panSpeed), Cf.copy(this._eye).cross(this.object.up).setLength(Wa.x), Cf.add(AJ.copy(this.object.up).setLength(Wa.y)), this.object.position.add(Cf), this.target.add(Cf), this.staticMoving ? this._panStart.copy(this._panEnd) : this._panStart.add(Wa.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
    }
  }
  _rotateCamera() {
    Nf.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
    let e = Nf.length();
    e ? (this._eye.copy(this.object.position).sub(this.target), bM.copy(this._eye).normalize(), Rf.copy(this.object.up).normalize(), bv.crossVectors(Rf, bM).normalize(), Rf.setLength(this._moveCurr.y - this._movePrev.y), bv.setLength(this._moveCurr.x - this._movePrev.x), Nf.copy(Rf.add(bv)), vv.crossVectors(Nf, this._eye).normalize(), e *= this.rotateSpeed, Su.setFromAxisAngle(vv, e), this._eye.applyQuaternion(Su), this.object.up.applyQuaternion(Su), this._lastAxis.copy(vv), this._lastAngle = e) : !this.staticMoving && this._lastAngle && (this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor), this._eye.copy(this.object.position).sub(this.target), Su.setFromAxisAngle(this._lastAxis, this._lastAngle), this._eye.applyQuaternion(Su), this.object.up.applyQuaternion(Su)), this._movePrev.copy(this._moveCurr);
  }
  _zoomCamera() {
    let e;
    this.state === Xt.TOUCH_ZOOM_PAN ? (e = this._touchZoomDistanceStart / this._touchZoomDistanceEnd, this._touchZoomDistanceStart = this._touchZoomDistanceEnd, this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = Ib.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (e = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed, e !== 1 && e > 0 && (this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = Ib.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")), this.staticMoving ? this._zoomStart.copy(this._zoomEnd) : this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor);
  }
  _getMouseOnScreen(e, i) {
    return Af.set(
      (e - this.screen.left) / this.screen.width,
      (i - this.screen.top) / this.screen.height
    ), Af;
  }
  _getMouseOnCircle(e, i) {
    return Af.set(
      (e - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5),
      (this.screen.height + 2 * (this.screen.top - i)) / this.screen.width
      // screen.width intentional
    ), Af;
  }
  _addPointer(e) {
    this._pointers.push(e);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i].pointerId == e.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
  }
  _trackPointer(e) {
    let i = this._pointerPositions[e.pointerId];
    i === void 0 && (i = new ke(), this._pointerPositions[e.pointerId] = i), i.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const i = e.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[i.pointerId];
  }
  _checkDistances() {
    (!this.noZoom || !this.noPan) && (this._eye.lengthSq() > this.maxDistance * this.maxDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance)), this._zoomStart.copy(this._zoomEnd)), this._eye.lengthSq() < this.minDistance * this.minDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance)), this._zoomStart.copy(this._zoomEnd)));
  }
}
function RJ(r) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(r.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), this._addPointer(r), r.pointerType === "touch" ? this._onTouchStart(r) : this._onMouseDown(r));
}
function NJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchMove(r) : this._onMouseMove(r));
}
function PJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchEnd(r) : this._onMouseUp(), this._removePointer(r), this._pointers.length === 0 && (this.domElement.releasePointerCapture(r.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp)));
}
function IJ(r) {
  this._removePointer(r);
}
function OJ() {
  this.enabled !== !1 && (this.keyState = Xt.NONE, window.addEventListener("keydown", this._onKeyDown));
}
function DJ(r) {
  this.enabled !== !1 && (window.removeEventListener("keydown", this._onKeyDown), this.keyState === Xt.NONE && (r.code === this.keys[Xt.ROTATE] && !this.noRotate ? this.keyState = Xt.ROTATE : r.code === this.keys[Xt.ZOOM] && !this.noZoom ? this.keyState = Xt.ZOOM : r.code === this.keys[Xt.PAN] && !this.noPan && (this.keyState = Xt.PAN)));
}
function LJ(r) {
  let e;
  switch (r.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case ir.DOLLY:
      this.state = Xt.ZOOM;
      break;
    case ir.ROTATE:
      this.state = Xt.ROTATE;
      break;
    case ir.PAN:
      this.state = Xt.PAN;
      break;
    default:
      this.state = Xt.NONE;
  }
  const i = this.keyState !== Xt.NONE ? this.keyState : this.state;
  i === Xt.ROTATE && !this.noRotate ? (this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY)), this._movePrev.copy(this._moveCurr)) : i === Xt.ZOOM && !this.noZoom ? (this._zoomStart.copy(this._getMouseOnScreen(r.pageX, r.pageY)), this._zoomEnd.copy(this._zoomStart)) : i === Xt.PAN && !this.noPan && (this._panStart.copy(this._getMouseOnScreen(r.pageX, r.pageY)), this._panEnd.copy(this._panStart)), this.dispatchEvent(X1);
}
function kJ(r) {
  const e = this.keyState !== Xt.NONE ? this.keyState : this.state;
  e === Xt.ROTATE && !this.noRotate ? (this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY))) : e === Xt.ZOOM && !this.noZoom ? this._zoomEnd.copy(this._getMouseOnScreen(r.pageX, r.pageY)) : e === Xt.PAN && !this.noPan && this._panEnd.copy(this._getMouseOnScreen(r.pageX, r.pageY));
}
function UJ() {
  this.state = Xt.NONE, this.dispatchEvent(Y1);
}
function FJ(r) {
  if (this.enabled !== !1 && this.noZoom !== !0) {
    switch (r.preventDefault(), r.deltaMode) {
      case 2:
        this._zoomStart.y -= r.deltaY * 0.025;
        break;
      case 1:
        this._zoomStart.y -= r.deltaY * 0.01;
        break;
      default:
        this._zoomStart.y -= r.deltaY * 25e-5;
        break;
    }
    this.dispatchEvent(X1), this.dispatchEvent(Y1);
  }
}
function BJ(r) {
  this.enabled !== !1 && r.preventDefault();
}
function zJ(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      this.state = Xt.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY)), this._movePrev.copy(this._moveCurr);
      break;
    default:
      this.state = Xt.TOUCH_ZOOM_PAN;
      const e = this._pointers[0].pageX - this._pointers[1].pageX, i = this._pointers[0].pageY - this._pointers[1].pageY;
      this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(e * e + i * i);
      const n = (this._pointers[0].pageX + this._pointers[1].pageX) / 2, s = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;
      this._panStart.copy(this._getMouseOnScreen(n, s)), this._panEnd.copy(this._panStart);
      break;
  }
  this.dispatchEvent(X1);
}
function jJ(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY));
      break;
    default:
      const e = this._getSecondPointerPosition(r), i = r.pageX - e.x, n = r.pageY - e.y;
      this._touchZoomDistanceEnd = Math.sqrt(i * i + n * n);
      const s = (r.pageX + e.x) / 2, a = (r.pageY + e.y) / 2;
      this._panEnd.copy(this._getMouseOnScreen(s, a));
      break;
  }
}
function VJ(r) {
  switch (this._pointers.length) {
    case 0:
      this.state = Xt.NONE;
      break;
    case 1:
      this.state = Xt.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(r.pageX, r.pageY)), this._movePrev.copy(this._moveCurr);
      break;
    case 2:
      this.state = Xt.TOUCH_ZOOM_PAN;
      for (let e = 0; e < this._pointers.length; e++)
        if (this._pointers[e].pointerId !== r.pointerId) {
          const i = this._pointerPositions[this._pointers[e].pointerId];
          this._moveCurr.copy(this._getMouseOnCircle(i.x, i.y)), this._movePrev.copy(this._moveCurr);
          break;
        }
      break;
  }
  this.dispatchEvent(Y1);
}
const xM = { type: "change" }, K1 = { type: "start" }, fI = { type: "end" }, Pf = new _g(), _M = new qs(), GJ = Math.cos(70 * Ib.DEG2RAD), Vi = new Y(), Dr = 2 * Math.PI, ti = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
}, xv = 1e-6;
class HJ extends Eg {
  constructor(e, i = null) {
    super(e, i), this.state = ti.NONE, this.enabled = !0, this.target = new Y(), this.cursor = new Y(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: ir.ROTATE, MIDDLE: ir.DOLLY, RIGHT: ir.PAN }, this.touches = { ONE: ia.ROTATE, TWO: ia.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new Y(), this._lastQuaternion = new bs(), this._lastTargetPosition = new Y(), this._quat = new bs().setFromUnitVectors(e.up, new Y(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new IS(), this._sphericalDelta = new IS(), this._scale = 1, this._panOffset = new Y(), this._rotateStart = new ke(), this._rotateEnd = new ke(), this._rotateDelta = new ke(), this._panStart = new ke(), this._panEnd = new ke(), this._panDelta = new ke(), this._dollyStart = new ke(), this._dollyEnd = new ke(), this._dollyDelta = new ke(), this._dollyDirection = new Y(), this._mouse = new ke(), this._performCursorZoom = !1, this._pointers = [], this._pointerPositions = {}, this._controlActive = !1, this._onPointerMove = qJ.bind(this), this._onPointerDown = WJ.bind(this), this._onPointerUp = XJ.bind(this), this._onContextMenu = eee.bind(this), this._onMouseWheel = ZJ.bind(this), this._onKeyDown = QJ.bind(this), this._onTouchStart = $J.bind(this), this._onTouchMove = JJ.bind(this), this._onMouseDown = YJ.bind(this), this._onMouseMove = KJ.bind(this), this._interceptControlDown = tee.bind(this), this._interceptControlUp = iee.bind(this), this.domElement !== null && this.connect(), this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, { passive: !0, capture: !0 }), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, { capture: !0 }), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
  }
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
  }
  saveState() {
    this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(xM), this.update(), this.state = ti.NONE;
  }
  update(e = null) {
    const i = this.object.position;
    Vi.copy(i).sub(this.target), Vi.applyQuaternion(this._quat), this._spherical.setFromVector3(Vi), this.autoRotate && this.state === ti.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
    let n = this.minAzimuthAngle, s = this.maxAzimuthAngle;
    isFinite(n) && isFinite(s) && (n < -Math.PI ? n += Dr : n > Math.PI && (n -= Dr), s < -Math.PI ? s += Dr : s > Math.PI && (s -= Dr), n <= s ? this._spherical.theta = Math.max(n, Math.min(s, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (n + s) / 2 ? Math.max(n, this._spherical.theta) : Math.min(s, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
    let a = !1;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const o = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), a = o != this._spherical.radius;
    }
    if (Vi.setFromSpherical(this._spherical), Vi.applyQuaternion(this._quatInverse), i.copy(this.target).add(Vi), this.object.lookAt(this.target), this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
      let o = null;
      if (this.object.isPerspectiveCamera) {
        const l = Vi.length();
        o = this._clampDistance(l * this._scale);
        const u = l - o;
        this.object.position.addScaledVector(this._dollyDirection, u), this.object.updateMatrixWorld(), a = !!u;
      } else if (this.object.isOrthographicCamera) {
        const l = new Y(this._mouse.x, this._mouse.y, 0);
        l.unproject(this.object);
        const u = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), a = u !== this.object.zoom;
        const c = new Y(this._mouse.x, this._mouse.y, 0);
        c.unproject(this.object), this.object.position.sub(c).add(l), this.object.updateMatrixWorld(), o = Vi.length();
      } else
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = !1;
      o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : (Pf.origin.copy(this.object.position), Pf.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(Pf.direction)) < GJ ? this.object.lookAt(this.target) : (_M.setFromNormalAndCoplanarPoint(this.object.up, this.target), Pf.intersectPlane(_M, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const o = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), o !== this.object.zoom && (this.object.updateProjectionMatrix(), a = !0);
    }
    return this._scale = 1, this._performCursorZoom = !1, a || this._lastPosition.distanceToSquared(this.object.position) > xv || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > xv || this._lastTargetPosition.distanceToSquared(this.target) > xv ? (this.dispatchEvent(xM), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), !0) : !1;
  }
  _getAutoRotationAngle(e) {
    return e !== null ? Dr / 60 * this.autoRotateSpeed * e : Dr / 60 / 60 * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const i = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * i);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, i) {
    Vi.setFromMatrixColumn(i, 0), Vi.multiplyScalar(-e), this._panOffset.add(Vi);
  }
  _panUp(e, i) {
    this.screenSpacePanning === !0 ? Vi.setFromMatrixColumn(i, 1) : (Vi.setFromMatrixColumn(i, 0), Vi.crossVectors(this.object.up, Vi)), Vi.multiplyScalar(e), this._panOffset.add(Vi);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(e, i) {
    const n = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const s = this.object.position;
      Vi.copy(s).sub(this.target);
      let a = Vi.length();
      a *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * a / n.clientHeight, this.object.matrix), this._panUp(2 * i * a / n.clientHeight, this.object.matrix);
    } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / n.clientWidth, this.object.matrix), this._panUp(i * (this.object.top - this.object.bottom) / this.object.zoom / n.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = !1);
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _updateZoomParameters(e, i) {
    if (!this.zoomToCursor)
      return;
    this._performCursorZoom = !0;
    const n = this.domElement.getBoundingClientRect(), s = e - n.left, a = i - n.top, o = n.width, l = n.height;
    this._mouse.x = s / o * 2 - 1, this._mouse.y = -(a / l) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const i = this.domElement;
    this._rotateLeft(Dr * this._rotateDelta.x / i.clientHeight), this._rotateUp(Dr * this._rotateDelta.y / i.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
  }
  _handleKeyDown(e) {
    let i = !1;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(Dr * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, this.keyPanSpeed), i = !0;
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(-Dr * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, -this.keyPanSpeed), i = !0;
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(Dr * this.rotateSpeed / this.domElement.clientHeight) : this._pan(this.keyPanSpeed, 0), i = !0;
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(-Dr * this.rotateSpeed / this.domElement.clientHeight) : this._pan(-this.keyPanSpeed, 0), i = !0;
        break;
    }
    i && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1)
      this._rotateStart.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._rotateStart.set(n, s);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1)
      this._panStart.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._panStart.set(n, s);
    }
  }
  _handleTouchStartDolly(e) {
    const i = this._getSecondPointerPosition(e), n = e.pageX - i.x, s = e.pageY - i.y, a = Math.sqrt(n * n + s * s);
    this._dollyStart.set(0, a);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1)
      this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const n = this._getSecondPointerPosition(e), s = 0.5 * (e.pageX + n.x), a = 0.5 * (e.pageY + n.y);
      this._rotateEnd.set(s, a);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const i = this.domElement;
    this._rotateLeft(Dr * this._rotateDelta.x / i.clientHeight), this._rotateUp(Dr * this._rotateDelta.y / i.clientHeight), this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1)
      this._panEnd.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), s = 0.5 * (e.pageY + i.y);
      this._panEnd.set(n, s);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const i = this._getSecondPointerPosition(e), n = e.pageX - i.x, s = e.pageY - i.y, a = Math.sqrt(n * n + s * s);
    this._dollyEnd.set(0, a), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
    const o = (e.pageX + i.x) * 0.5, l = (e.pageY + i.y) * 0.5;
    this._updateZoomParameters(o, l);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
  }
  // pointers
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i] == e.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
  }
  _isTrackingPointer(e) {
    for (let i = 0; i < this._pointers.length; i++)
      if (this._pointers[i] == e.pointerId) return !0;
    return !1;
  }
  _trackPointer(e) {
    let i = this._pointerPositions[e.pointerId];
    i === void 0 && (i = new ke(), this._pointerPositions[e.pointerId] = i), i.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const i = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[i];
  }
  //
  _customWheelEvent(e) {
    const i = e.deltaMode, n = {
      clientX: e.clientX,
      clientY: e.clientY,
      deltaY: e.deltaY
    };
    switch (i) {
      case 1:
        n.deltaY *= 16;
        break;
      case 2:
        n.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (n.deltaY *= 10), n;
  }
}
function WJ(r) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(r.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(r) && (this._addPointer(r), r.pointerType === "touch" ? this._onTouchStart(r) : this._onMouseDown(r)));
}
function qJ(r) {
  this.enabled !== !1 && (r.pointerType === "touch" ? this._onTouchMove(r) : this._onMouseMove(r));
}
function XJ(r) {
  switch (this._removePointer(r), this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(r.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(fI), this.state = ti.NONE;
      break;
    case 1:
      const e = this._pointers[0], i = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: i.x, pageY: i.y });
      break;
  }
}
function YJ(r) {
  let e;
  switch (r.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case ir.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseDownDolly(r), this.state = ti.DOLLY;
      break;
    case ir.ROTATE:
      if (r.ctrlKey || r.metaKey || r.shiftKey) {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(r), this.state = ti.PAN;
      } else {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(r), this.state = ti.ROTATE;
      }
      break;
    case ir.PAN:
      if (r.ctrlKey || r.metaKey || r.shiftKey) {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(r), this.state = ti.ROTATE;
      } else {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(r), this.state = ti.PAN;
      }
      break;
    default:
      this.state = ti.NONE;
  }
  this.state !== ti.NONE && this.dispatchEvent(K1);
}
function KJ(r) {
  switch (this.state) {
    case ti.ROTATE:
      if (this.enableRotate === !1) return;
      this._handleMouseMoveRotate(r);
      break;
    case ti.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseMoveDolly(r);
      break;
    case ti.PAN:
      if (this.enablePan === !1) return;
      this._handleMouseMovePan(r);
      break;
  }
}
function ZJ(r) {
  this.enabled === !1 || this.enableZoom === !1 || this.state !== ti.NONE || (r.preventDefault(), this.dispatchEvent(K1), this._handleMouseWheel(this._customWheelEvent(r)), this.dispatchEvent(fI));
}
function QJ(r) {
  this.enabled === !1 || this.enablePan === !1 || this._handleKeyDown(r);
}
function $J(r) {
  switch (this._trackPointer(r), this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case ia.ROTATE:
          if (this.enableRotate === !1) return;
          this._handleTouchStartRotate(r), this.state = ti.TOUCH_ROTATE;
          break;
        case ia.PAN:
          if (this.enablePan === !1) return;
          this._handleTouchStartPan(r), this.state = ti.TOUCH_PAN;
          break;
        default:
          this.state = ti.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case ia.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1) return;
          this._handleTouchStartDollyPan(r), this.state = ti.TOUCH_DOLLY_PAN;
          break;
        case ia.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1) return;
          this._handleTouchStartDollyRotate(r), this.state = ti.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = ti.NONE;
      }
      break;
    default:
      this.state = ti.NONE;
  }
  this.state !== ti.NONE && this.dispatchEvent(K1);
}
function JJ(r) {
  switch (this._trackPointer(r), this.state) {
    case ti.TOUCH_ROTATE:
      if (this.enableRotate === !1) return;
      this._handleTouchMoveRotate(r), this.update();
      break;
    case ti.TOUCH_PAN:
      if (this.enablePan === !1) return;
      this._handleTouchMovePan(r), this.update();
      break;
    case ti.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1) return;
      this._handleTouchMoveDollyPan(r), this.update();
      break;
    case ti.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1) return;
      this._handleTouchMoveDollyRotate(r), this.update();
      break;
    default:
      this.state = ti.NONE;
  }
}
function eee(r) {
  this.enabled !== !1 && r.preventDefault();
}
function tee(r) {
  r.key === "Control" && (this._controlActive = !0, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
function iee(r) {
  r.key === "Control" && (this._controlActive = !1, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
const ree = { type: "change" }, TM = 1e-6, wM = new bs();
class nee extends Eg {
  constructor(e, i = null) {
    super(e, i), this.movementSpeed = 1, this.rollSpeed = 5e-3, this.dragToLook = !1, this.autoForward = !1, this._moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 }, this._moveVector = new Y(0, 0, 0), this._rotationVector = new Y(0, 0, 0), this._lastQuaternion = new bs(), this._lastPosition = new Y(), this._status = 0, this._onKeyDown = see.bind(this), this._onKeyUp = aee.bind(this), this._onPointerMove = lee.bind(this), this._onPointerDown = oee.bind(this), this._onPointerUp = uee.bind(this), this._onPointerCancel = cee.bind(this), this._onContextMenu = hee.bind(this), i !== null && this.connect();
  }
  connect() {
    window.addEventListener("keydown", this._onKeyDown), window.addEventListener("keyup", this._onKeyUp), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("contextmenu", this._onContextMenu);
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("contextmenu", this._onContextMenu);
  }
  dispose() {
    this.disconnect();
  }
  update(e) {
    if (this.enabled === !1) return;
    const i = this.object, n = e * this.movementSpeed, s = e * this.rollSpeed;
    i.translateX(this._moveVector.x * n), i.translateY(this._moveVector.y * n), i.translateZ(this._moveVector.z * n), wM.set(this._rotationVector.x * s, this._rotationVector.y * s, this._rotationVector.z * s, 1).normalize(), i.quaternion.multiply(wM), (this._lastPosition.distanceToSquared(i.position) > TM || 8 * (1 - this._lastQuaternion.dot(i.quaternion)) > TM) && (this.dispatchEvent(ree), this._lastQuaternion.copy(i.quaternion), this._lastPosition.copy(i.position));
  }
  // private
  _updateMovementVector() {
    const e = this._moveState.forward || this.autoForward && !this._moveState.back ? 1 : 0;
    this._moveVector.x = -this._moveState.left + this._moveState.right, this._moveVector.y = -this._moveState.down + this._moveState.up, this._moveVector.z = -e + this._moveState.back;
  }
  _updateRotationVector() {
    this._rotationVector.x = -this._moveState.pitchDown + this._moveState.pitchUp, this._rotationVector.y = -this._moveState.yawRight + this._moveState.yawLeft, this._rotationVector.z = -this._moveState.rollRight + this._moveState.rollLeft;
  }
  _getContainerDimensions() {
    return this.domElement != document ? {
      size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
      offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
    } : {
      size: [window.innerWidth, window.innerHeight],
      offset: [0, 0]
    };
  }
}
function see(r) {
  if (!(r.altKey || this.enabled === !1)) {
    switch (r.code) {
      case "ShiftLeft":
      case "ShiftRight":
        this.movementSpeedMultiplier = 0.1;
        break;
      case "KeyW":
        this._moveState.forward = 1;
        break;
      case "KeyS":
        this._moveState.back = 1;
        break;
      case "KeyA":
        this._moveState.left = 1;
        break;
      case "KeyD":
        this._moveState.right = 1;
        break;
      case "KeyR":
        this._moveState.up = 1;
        break;
      case "KeyF":
        this._moveState.down = 1;
        break;
      case "ArrowUp":
        this._moveState.pitchUp = 1;
        break;
      case "ArrowDown":
        this._moveState.pitchDown = 1;
        break;
      case "ArrowLeft":
        this._moveState.yawLeft = 1;
        break;
      case "ArrowRight":
        this._moveState.yawRight = 1;
        break;
      case "KeyQ":
        this._moveState.rollLeft = 1;
        break;
      case "KeyE":
        this._moveState.rollRight = 1;
        break;
    }
    this._updateMovementVector(), this._updateRotationVector();
  }
}
function aee(r) {
  if (this.enabled !== !1) {
    switch (r.code) {
      case "ShiftLeft":
      case "ShiftRight":
        this.movementSpeedMultiplier = 1;
        break;
      case "KeyW":
        this._moveState.forward = 0;
        break;
      case "KeyS":
        this._moveState.back = 0;
        break;
      case "KeyA":
        this._moveState.left = 0;
        break;
      case "KeyD":
        this._moveState.right = 0;
        break;
      case "KeyR":
        this._moveState.up = 0;
        break;
      case "KeyF":
        this._moveState.down = 0;
        break;
      case "ArrowUp":
        this._moveState.pitchUp = 0;
        break;
      case "ArrowDown":
        this._moveState.pitchDown = 0;
        break;
      case "ArrowLeft":
        this._moveState.yawLeft = 0;
        break;
      case "ArrowRight":
        this._moveState.yawRight = 0;
        break;
      case "KeyQ":
        this._moveState.rollLeft = 0;
        break;
      case "KeyE":
        this._moveState.rollRight = 0;
        break;
    }
    this._updateMovementVector(), this._updateRotationVector();
  }
}
function oee(r) {
  if (this.enabled !== !1)
    if (this.dragToLook)
      this._status++;
    else {
      switch (r.button) {
        case 0:
          this._moveState.forward = 1;
          break;
        case 2:
          this._moveState.back = 1;
          break;
      }
      this._updateMovementVector();
    }
}
function lee(r) {
  if (this.enabled !== !1 && (!this.dragToLook || this._status > 0)) {
    const e = this._getContainerDimensions(), i = e.size[0] / 2, n = e.size[1] / 2;
    this._moveState.yawLeft = -(r.pageX - e.offset[0] - i) / i, this._moveState.pitchDown = (r.pageY - e.offset[1] - n) / n, this._updateRotationVector();
  }
}
function uee(r) {
  if (this.enabled !== !1) {
    if (this.dragToLook)
      this._status--, this._moveState.yawLeft = this._moveState.pitchDown = 0;
    else {
      switch (r.button) {
        case 0:
          this._moveState.forward = 0;
          break;
        case 2:
          this._moveState.back = 0;
          break;
      }
      this._updateMovementVector();
    }
    this._updateRotationVector();
  }
}
function cee() {
  this.enabled !== !1 && (this.dragToLook ? (this._status = 0, this._moveState.yawLeft = this._moveState.pitchDown = 0) : (this._moveState.forward = 0, this._moveState.back = 0, this._updateMovementVector()), this._updateRotationVector());
}
function hee(r) {
  this.enabled !== !1 && r.preventDefault();
}
const dee = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class Hg {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const pee = new D_(-1, 1, 1, -1, 0, 1);
class fee extends cn {
  constructor() {
    super(), this.setAttribute("position", new Ci([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Ci([0, 2, 0, 0, 2, 0], 2));
  }
}
const mee = new fee();
class gee {
  constructor(e) {
    this._mesh = new kr(mee, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, pee);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class yee extends Hg {
  constructor(e, i) {
    super(), this.textureID = i !== void 0 ? i : "tDiffuse", e instanceof xs ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = fR.clone(e.uniforms), this.material = new xs({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new gee(this.material);
  }
  render(e, i, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(i), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class SM extends Hg {
  constructor(e, i) {
    super(), this.scene = e, this.camera = i, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, i, n) {
    const s = e.getContext(), a = e.state;
    a.buffers.color.setMask(!1), a.buffers.depth.setMask(!1), a.buffers.color.setLocked(!0), a.buffers.depth.setLocked(!0);
    let o, l;
    this.inverse ? (o = 0, l = 1) : (o = 1, l = 0), a.buffers.stencil.setTest(!0), a.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), a.buffers.stencil.setFunc(s.ALWAYS, o, 4294967295), a.buffers.stencil.setClear(l), a.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), a.buffers.color.setLocked(!1), a.buffers.depth.setLocked(!1), a.buffers.color.setMask(!0), a.buffers.depth.setMask(!0), a.buffers.stencil.setLocked(!1), a.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), a.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), a.buffers.stencil.setLocked(!0);
  }
}
class vee extends Hg {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class bee {
  constructor(e, i) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), i === void 0) {
      const n = e.getSize(new ke());
      this._width = n.width, this._height = n.height, i = new mo(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: Lc }), i.texture.name = "EffectComposer.rt1";
    } else
      this._width = i.width, this._height = i.height;
    this.renderTarget1 = i, this.renderTarget2 = i.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new yee(dee), this.copyPass.material.blending = la, this.clock = new PR();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, i) {
    this.passes.splice(i, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const i = this.passes.indexOf(e);
    i !== -1 && this.passes.splice(i, 1);
  }
  isLastEnabledPass(e) {
    for (let i = e + 1; i < this.passes.length; i++)
      if (this.passes[i].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const i = this.renderer.getRenderTarget();
    let n = !1;
    for (let s = 0, a = this.passes.length; s < a; s++) {
      const o = this.passes[s];
      if (o.enabled !== !1) {
        if (o.renderToScreen = this.renderToScreen && this.isLastEnabledPass(s), o.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), o.needsSwap) {
          if (n) {
            const l = this.renderer.getContext(), u = this.renderer.state.buffers.stencil;
            u.setFunc(l.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), u.setFunc(l.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        SM !== void 0 && (o instanceof SM ? n = !0 : o instanceof vee && (n = !1));
      }
    }
    this.renderer.setRenderTarget(i);
  }
  reset(e) {
    if (e === void 0) {
      const i = this.renderer.getSize(new ke());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = i.width, this._height = i.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, i) {
    this._width = e, this._height = i;
    const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, s), this.renderTarget2.setSize(n, s);
    for (let a = 0; a < this.passes.length; a++)
      this.passes[a].setSize(n, s);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class xee extends Hg {
  constructor(e, i, n = null, s = null, a = null) {
    super(), this.scene = e, this.camera = i, this.overrideMaterial = n, this.clearColor = s, this.clearAlpha = a, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Ut();
  }
  render(e, i, n) {
    const s = e.autoClear;
    e.autoClear = !1;
    let a, o;
    this.overrideMaterial !== null && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (a = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(a), this.overrideMaterial !== null && (this.scene.overrideMaterial = o), e.autoClear = s;
  }
}
function Wr() {
  return Wr = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i) ({}).hasOwnProperty.call(i, n) && (r[n] = i[n]);
    }
    return r;
  }, Wr.apply(null, arguments);
}
function _ee(r) {
  if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function Cd(r, e) {
  return Cd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, Cd(r, e);
}
function Tee(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r, Cd(r, e);
}
function Dx(r) {
  return Dx = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Dx(r);
}
function wee(r) {
  try {
    return Function.toString.call(r).indexOf("[native code]") !== -1;
  } catch {
    return typeof r == "function";
  }
}
function mI() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (mI = function() {
    return !!r;
  })();
}
function See(r, e, i) {
  if (mI()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return i && Cd(s, i.prototype), s;
}
function Lx(r) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Lx = function(i) {
    if (i === null || !wee(i)) return i;
    if (typeof i != "function") throw new TypeError("Super expression must either be null or a function");
    if (e !== void 0) {
      if (e.has(i)) return e.get(i);
      e.set(i, n);
    }
    function n() {
      return See(i, arguments, Dx(this).constructor);
    }
    return n.prototype = Object.create(i.prototype, {
      constructor: {
        value: n,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Cd(n, i);
  }, Lx(r);
}
var Eee = {
  1: `Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).

`,
  2: `Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).

`,
  3: `Passed an incorrect argument to a color function, please pass a string representation of a color.

`,
  4: `Couldn't generate valid rgb string from %s, it returned %s.

`,
  5: `Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.

`,
  6: `Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).

`,
  7: `Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).

`,
  8: `Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.

`,
  9: `Please provide a number of steps to the modularScale helper.

`,
  10: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
  11: `Invalid value passed as base to modularScale, expected number or em string but got "%s"

`,
  12: `Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.

`,
  13: `Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.

`,
  14: `Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.

`,
  15: `Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.

`,
  16: `You must provide a template to this method.

`,
  17: `You passed an unsupported selector state to this method.

`,
  18: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
  19: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
  20: `expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
  21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  23: `fontFace expects a name of a font-family.

`,
  24: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
  25: `fontFace expects localFonts to be an array.

`,
  26: `fontFace expects fileFormats to be an array.

`,
  27: `radialGradient requries at least 2 color-stops to properly render.

`,
  28: `Please supply a filename to retinaImage() as the first argument.

`,
  29: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
  30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  31: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation

`,
  32: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])
To pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')

`,
  33: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation

`,
  34: `borderRadius expects a radius value as a string or number as the second argument.

`,
  35: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
  36: `Property must be a string value.

`,
  37: `Syntax Error at %s.

`,
  38: `Formula contains a function that needs parentheses at %s.

`,
  39: `Formula is missing closing parenthesis at %s.

`,
  40: `Formula has too many closing parentheses at %s.

`,
  41: `All values in a formula must have the same unit or be unitless.

`,
  42: `Please provide a number of steps to the modularScale helper.

`,
  43: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
  44: `Invalid value passed as base to modularScale, expected number or em/rem string but got %s.

`,
  45: `Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.

`,
  46: `Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.

`,
  47: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
  48: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
  49: `Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
  50: `Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.

`,
  51: `Expects the first argument object to have the properties prop, fromSize, and toSize.

`,
  52: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
  53: `fontFace expects localFonts to be an array.

`,
  54: `fontFace expects fileFormats to be an array.

`,
  55: `fontFace expects a name of a font-family.

`,
  56: `linearGradient requries at least 2 color-stops to properly render.

`,
  57: `radialGradient requries at least 2 color-stops to properly render.

`,
  58: `Please supply a filename to retinaImage() as the first argument.

`,
  59: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
  60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  61: `Property must be a string value.

`,
  62: `borderRadius expects a radius value as a string or number as the second argument.

`,
  63: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
  64: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.

`,
  65: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').

`,
  66: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.

`,
  67: `You must provide a template to this method.

`,
  68: `You passed an unsupported selector state to this method.

`,
  69: `Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.

`,
  70: `Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.

`,
  71: `Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.

`,
  72: `Passed invalid base value %s to %s(), please pass a value like "12px" or 12.

`,
  73: `Please provide a valid CSS variable.

`,
  74: `CSS variable not found and no default was provided.

`,
  75: `important requires a valid style object, got a %s instead.

`,
  76: `fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.

`,
  77: `remToPx expects a value in "rem" but you provided it in "%s".

`,
  78: `base must be set in "px" or "%" but you set it in "%s".
`
};
function Mee() {
  for (var r = arguments.length, e = new Array(r), i = 0; i < r; i++)
    e[i] = arguments[i];
  var n = e[0], s = [], a;
  for (a = 1; a < e.length; a += 1)
    s.push(e[a]);
  return s.forEach(function(o) {
    n = n.replace(/%[a-z]/, o);
  }), n;
}
var ms = /* @__PURE__ */ function(r) {
  Tee(e, r);
  function e(i) {
    var n;
    if (process.env.NODE_ENV === "production")
      n = r.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + i + " for more information.") || this;
    else {
      for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), o = 1; o < s; o++)
        a[o - 1] = arguments[o];
      n = r.call(this, Mee.apply(void 0, [Eee[i]].concat(a))) || this;
    }
    return _ee(n);
  }
  return e;
}(/* @__PURE__ */ Lx(Error));
function _v(r) {
  return Math.round(r * 255);
}
function Aee(r, e, i) {
  return _v(r) + "," + _v(e) + "," + _v(i);
}
function Zm(r, e, i, n) {
  if (n === void 0 && (n = Aee), e === 0)
    return n(i, i, i);
  var s = (r % 360 + 360) % 360 / 60, a = (1 - Math.abs(2 * i - 1)) * e, o = a * (1 - Math.abs(s % 2 - 1)), l = 0, u = 0, c = 0;
  s >= 0 && s < 1 ? (l = a, u = o) : s >= 1 && s < 2 ? (l = o, u = a) : s >= 2 && s < 3 ? (u = a, c = o) : s >= 3 && s < 4 ? (u = o, c = a) : s >= 4 && s < 5 ? (l = o, c = a) : s >= 5 && s < 6 && (l = a, c = o);
  var h = i - a / 2, d = l + h, p = u + h, f = c + h;
  return n(d, p, f);
}
var EM = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function Cee(r) {
  if (typeof r != "string") return r;
  var e = r.toLowerCase();
  return EM[e] ? "#" + EM[e] : r;
}
var Ree = /^#[a-fA-F0-9]{6}$/, Nee = /^#[a-fA-F0-9]{8}$/, Pee = /^#[a-fA-F0-9]{3}$/, Iee = /^#[a-fA-F0-9]{4}$/, Tv = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i, Oee = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i, Dee = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, Lee = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function Ac(r) {
  if (typeof r != "string")
    throw new ms(3);
  var e = Cee(r);
  if (e.match(Ree))
    return {
      red: parseInt("" + e[1] + e[2], 16),
      green: parseInt("" + e[3] + e[4], 16),
      blue: parseInt("" + e[5] + e[6], 16)
    };
  if (e.match(Nee)) {
    var i = parseFloat((parseInt("" + e[7] + e[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + e[1] + e[2], 16),
      green: parseInt("" + e[3] + e[4], 16),
      blue: parseInt("" + e[5] + e[6], 16),
      alpha: i
    };
  }
  if (e.match(Pee))
    return {
      red: parseInt("" + e[1] + e[1], 16),
      green: parseInt("" + e[2] + e[2], 16),
      blue: parseInt("" + e[3] + e[3], 16)
    };
  if (e.match(Iee)) {
    var n = parseFloat((parseInt("" + e[4] + e[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + e[1] + e[1], 16),
      green: parseInt("" + e[2] + e[2], 16),
      blue: parseInt("" + e[3] + e[3], 16),
      alpha: n
    };
  }
  var s = Tv.exec(e);
  if (s)
    return {
      red: parseInt("" + s[1], 10),
      green: parseInt("" + s[2], 10),
      blue: parseInt("" + s[3], 10)
    };
  var a = Oee.exec(e.substring(0, 50));
  if (a)
    return {
      red: parseInt("" + a[1], 10),
      green: parseInt("" + a[2], 10),
      blue: parseInt("" + a[3], 10),
      alpha: parseFloat("" + a[4]) > 1 ? parseFloat("" + a[4]) / 100 : parseFloat("" + a[4])
    };
  var o = Dee.exec(e);
  if (o) {
    var l = parseInt("" + o[1], 10), u = parseInt("" + o[2], 10) / 100, c = parseInt("" + o[3], 10) / 100, h = "rgb(" + Zm(l, u, c) + ")", d = Tv.exec(h);
    if (!d)
      throw new ms(4, e, h);
    return {
      red: parseInt("" + d[1], 10),
      green: parseInt("" + d[2], 10),
      blue: parseInt("" + d[3], 10)
    };
  }
  var p = Lee.exec(e.substring(0, 50));
  if (p) {
    var f = parseInt("" + p[1], 10), m = parseInt("" + p[2], 10) / 100, y = parseInt("" + p[3], 10) / 100, v = "rgb(" + Zm(f, m, y) + ")", g = Tv.exec(v);
    if (!g)
      throw new ms(4, e, v);
    return {
      red: parseInt("" + g[1], 10),
      green: parseInt("" + g[2], 10),
      blue: parseInt("" + g[3], 10),
      alpha: parseFloat("" + p[4]) > 1 ? parseFloat("" + p[4]) / 100 : parseFloat("" + p[4])
    };
  }
  throw new ms(5);
}
function kee(r) {
  var e = r.red / 255, i = r.green / 255, n = r.blue / 255, s = Math.max(e, i, n), a = Math.min(e, i, n), o = (s + a) / 2;
  if (s === a)
    return r.alpha !== void 0 ? {
      hue: 0,
      saturation: 0,
      lightness: o,
      alpha: r.alpha
    } : {
      hue: 0,
      saturation: 0,
      lightness: o
    };
  var l, u = s - a, c = o > 0.5 ? u / (2 - s - a) : u / (s + a);
  switch (s) {
    case e:
      l = (i - n) / u + (i < n ? 6 : 0);
      break;
    case i:
      l = (n - e) / u + 2;
      break;
    default:
      l = (e - i) / u + 4;
      break;
  }
  return l *= 60, r.alpha !== void 0 ? {
    hue: l,
    saturation: c,
    lightness: o,
    alpha: r.alpha
  } : {
    hue: l,
    saturation: c,
    lightness: o
  };
}
function wo(r) {
  return kee(Ac(r));
}
var Uee = function(r) {
  return r.length === 7 && r[1] === r[2] && r[3] === r[4] && r[5] === r[6] ? "#" + r[1] + r[3] + r[5] : r;
}, kx = Uee;
function Wo(r) {
  var e = r.toString(16);
  return e.length === 1 ? "0" + e : e;
}
function wv(r) {
  return Wo(Math.round(r * 255));
}
function Fee(r, e, i) {
  return kx("#" + wv(r) + wv(e) + wv(i));
}
function gI(r, e, i) {
  return Zm(r, e, i, Fee);
}
function Bee(r, e, i) {
  if (typeof r == "object" && e === void 0 && i === void 0)
    return gI(r.hue, r.saturation, r.lightness);
  throw new ms(1);
}
function zee(r, e, i, n) {
  if (typeof r == "object" && e === void 0 && i === void 0 && n === void 0)
    return r.alpha >= 1 ? gI(r.hue, r.saturation, r.lightness) : "rgba(" + Zm(r.hue, r.saturation, r.lightness) + "," + r.alpha + ")";
  throw new ms(2);
}
function yI(r, e, i) {
  if (typeof r == "number" && typeof e == "number" && typeof i == "number")
    return kx("#" + Wo(r) + Wo(e) + Wo(i));
  if (typeof r == "object" && e === void 0 && i === void 0)
    return kx("#" + Wo(r.red) + Wo(r.green) + Wo(r.blue));
  throw new ms(6);
}
function Wg(r, e, i, n) {
  if (typeof r == "object" && e === void 0 && i === void 0 && n === void 0)
    return r.alpha >= 1 ? yI(r.red, r.green, r.blue) : "rgba(" + r.red + "," + r.green + "," + r.blue + "," + r.alpha + ")";
  throw new ms(7);
}
var jee = function(r) {
  return typeof r.red == "number" && typeof r.green == "number" && typeof r.blue == "number" && (typeof r.alpha != "number" || typeof r.alpha > "u");
}, Vee = function(r) {
  return typeof r.red == "number" && typeof r.green == "number" && typeof r.blue == "number" && typeof r.alpha == "number";
}, Gee = function(r) {
  return typeof r.hue == "number" && typeof r.saturation == "number" && typeof r.lightness == "number" && (typeof r.alpha != "number" || typeof r.alpha > "u");
}, Hee = function(r) {
  return typeof r.hue == "number" && typeof r.saturation == "number" && typeof r.lightness == "number" && typeof r.alpha == "number";
};
function So(r) {
  if (typeof r != "object") throw new ms(8);
  if (Vee(r)) return Wg(r);
  if (jee(r)) return yI(r);
  if (Hee(r)) return zee(r);
  if (Gee(r)) return Bee(r);
  throw new ms(8);
}
function vI(r, e, i) {
  return function() {
    var n = i.concat(Array.prototype.slice.call(arguments));
    return n.length >= e ? r.apply(this, n) : vI(r, e, n);
  };
}
function hn(r) {
  return vI(r, r.length, []);
}
function Wee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return So(Wr({}, i, {
    hue: i.hue + parseFloat(r)
  }));
}
hn(Wee);
function Wc(r, e, i) {
  return Math.max(r, Math.min(e, i));
}
function qee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return So(Wr({}, i, {
    lightness: Wc(0, 1, i.lightness - parseFloat(r))
  }));
}
hn(qee);
function Xee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return So(Wr({}, i, {
    saturation: Wc(0, 1, i.saturation - parseFloat(r))
  }));
}
hn(Xee);
function Yee(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return So(Wr({}, i, {
    lightness: Wc(0, 1, i.lightness + parseFloat(r))
  }));
}
hn(Yee);
function Kee(r, e, i) {
  if (e === "transparent") return i;
  if (i === "transparent") return e;
  if (r === 0) return i;
  var n = Ac(e), s = Wr({}, n, {
    alpha: typeof n.alpha == "number" ? n.alpha : 1
  }), a = Ac(i), o = Wr({}, a, {
    alpha: typeof a.alpha == "number" ? a.alpha : 1
  }), l = s.alpha - o.alpha, u = parseFloat(r) * 2 - 1, c = u * l === -1 ? u : u + l, h = 1 + u * l, d = (c / h + 1) / 2, p = 1 - d, f = {
    red: Math.floor(s.red * d + o.red * p),
    green: Math.floor(s.green * d + o.green * p),
    blue: Math.floor(s.blue * d + o.blue * p),
    alpha: s.alpha * parseFloat(r) + o.alpha * (1 - parseFloat(r))
  };
  return Wg(f);
}
var Zee = hn(Kee), bI = Zee;
function Qee(r, e) {
  if (e === "transparent") return e;
  var i = Ac(e), n = typeof i.alpha == "number" ? i.alpha : 1, s = Wr({}, i, {
    alpha: Wc(0, 1, (n * 100 + parseFloat(r) * 100) / 100)
  });
  return Wg(s);
}
var $ee = hn(Qee), Jee = $ee;
function ete(r, e) {
  if (e === "transparent") return e;
  var i = wo(e);
  return So(Wr({}, i, {
    saturation: Wc(0, 1, i.saturation + parseFloat(r))
  }));
}
hn(ete);
function tte(r, e) {
  return e === "transparent" ? e : So(Wr({}, wo(e), {
    hue: parseFloat(r)
  }));
}
hn(tte);
function ite(r, e) {
  return e === "transparent" ? e : So(Wr({}, wo(e), {
    lightness: parseFloat(r)
  }));
}
hn(ite);
function rte(r, e) {
  return e === "transparent" ? e : So(Wr({}, wo(e), {
    saturation: parseFloat(r)
  }));
}
hn(rte);
function nte(r, e) {
  return e === "transparent" ? e : bI(parseFloat(r), "rgb(0, 0, 0)", e);
}
hn(nte);
function ste(r, e) {
  return e === "transparent" ? e : bI(parseFloat(r), "rgb(255, 255, 255)", e);
}
hn(ste);
function ate(r, e) {
  if (e === "transparent") return e;
  var i = Ac(e), n = typeof i.alpha == "number" ? i.alpha : 1, s = Wr({}, i, {
    alpha: Wc(0, 1, +(n * 100 - parseFloat(r) * 100).toFixed(2) / 100)
  });
  return Wg(s);
}
hn(ate);
var va = Object.freeze({
  Linear: Object.freeze({
    None: function(r) {
      return r;
    },
    In: function(r) {
      return r;
    },
    Out: function(r) {
      return r;
    },
    InOut: function(r) {
      return r;
    }
  }),
  Quadratic: Object.freeze({
    In: function(r) {
      return r * r;
    },
    Out: function(r) {
      return r * (2 - r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(r) {
      return r * r * r;
    },
    Out: function(r) {
      return --r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(r) {
      return r * r * r * r;
    },
    Out: function(r) {
      return 1 - --r * r * r * r;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(r) {
      return r * r * r * r * r;
    },
    Out: function(r) {
      return --r * r * r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(r) {
      return 1 - Math.sin((1 - r) * Math.PI / 2);
    },
    Out: function(r) {
      return Math.sin(r * Math.PI / 2);
    },
    InOut: function(r) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - r)));
    }
  }),
  Exponential: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : Math.pow(1024, r - 1);
    },
    Out: function(r) {
      return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(r) {
      return 1 - Math.sqrt(1 - r * r);
    },
    Out: function(r) {
      return Math.sqrt(1 - --r * r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : -Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI);
    },
    Out: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : Math.pow(2, -10 * r) * Math.sin((r - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2, r < 1 ? -0.5 * Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In: function(r) {
      var e = 1.70158;
      return r === 1 ? 1 : r * r * ((e + 1) * r - e);
    },
    Out: function(r) {
      var e = 1.70158;
      return r === 0 ? 0 : --r * r * ((e + 1) * r + e) + 1;
    },
    InOut: function(r) {
      var e = 2.5949095;
      return (r *= 2) < 1 ? 0.5 * (r * r * ((e + 1) * r - e)) : 0.5 * ((r -= 2) * r * ((e + 1) * r + e) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(r) {
      return 1 - va.Bounce.Out(1 - r);
    },
    Out: function(r) {
      return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
    },
    InOut: function(r) {
      return r < 0.5 ? va.Bounce.In(r * 2) * 0.5 : va.Bounce.Out(r * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(r) {
    return r === void 0 && (r = 4), r = r < Number.EPSILON ? Number.EPSILON : r, r = r > 1e4 ? 1e4 : r, {
      In: function(e) {
        return Math.pow(e, r);
      },
      Out: function(e) {
        return 1 - Math.pow(1 - e, r);
      },
      InOut: function(e) {
        return e < 0.5 ? Math.pow(e * 2, r) / 2 : (1 - Math.pow(2 - e * 2, r)) / 2 + 0.5;
      }
    };
  }
}), Wh = function() {
  return performance.now();
}, Z1 = (
  /** @class */
  function() {
    function r() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      this._tweens = {}, this._tweensAddedDuringUpdate = {}, this.add.apply(this, e);
    }
    return r.prototype.getAll = function() {
      var e = this;
      return Object.keys(this._tweens).map(function(i) {
        return e._tweens[i];
      });
    }, r.prototype.removeAll = function() {
      this._tweens = {};
    }, r.prototype.add = function() {
      for (var e, i = [], n = 0; n < arguments.length; n++)
        i[n] = arguments[n];
      for (var s = 0, a = i; s < a.length; s++) {
        var o = a[s];
        (e = o._group) === null || e === void 0 || e.remove(o), o._group = this, this._tweens[o.getId()] = o, this._tweensAddedDuringUpdate[o.getId()] = o;
      }
    }, r.prototype.remove = function() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      for (var n = 0, s = e; n < s.length; n++) {
        var a = s[n];
        a._group = void 0, delete this._tweens[a.getId()], delete this._tweensAddedDuringUpdate[a.getId()];
      }
    }, r.prototype.allStopped = function() {
      return this.getAll().every(function(e) {
        return !e.isPlaying();
      });
    }, r.prototype.update = function(e, i) {
      e === void 0 && (e = Wh()), i === void 0 && (i = !0);
      var n = Object.keys(this._tweens);
      if (n.length !== 0)
        for (; n.length > 0; ) {
          this._tweensAddedDuringUpdate = {};
          for (var s = 0; s < n.length; s++) {
            var a = this._tweens[n[s]], o = !i;
            a && a.update(e, o) === !1 && !i && this.remove(a);
          }
          n = Object.keys(this._tweensAddedDuringUpdate);
        }
    }, r;
  }()
), Ux = {
  Linear: function(r, e) {
    var i = r.length - 1, n = i * e, s = Math.floor(n), a = Ux.Utils.Linear;
    return e < 0 ? a(r[0], r[1], n) : e > 1 ? a(r[i], r[i - 1], i - n) : a(r[s], r[s + 1 > i ? i : s + 1], n - s);
  },
  Utils: {
    Linear: function(r, e, i) {
      return (e - r) * i + r;
    }
  }
}, xI = (
  /** @class */
  function() {
    function r() {
    }
    return r.nextId = function() {
      return r._nextId++;
    }, r._nextId = 0, r;
  }()
), Fx = new Z1(), Qm = (
  /** @class */
  function() {
    function r(e, i) {
      this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = va.Linear.None, this._interpolationFunction = Ux.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = xI.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1, this._object = e, typeof i == "object" ? (this._group = i, i.add(this)) : i === !0 && (this._group = Fx, Fx.add(this));
    }
    return r.prototype.getId = function() {
      return this._id;
    }, r.prototype.isPlaying = function() {
      return this._isPlaying;
    }, r.prototype.isPaused = function() {
      return this._isPaused;
    }, r.prototype.getDuration = function() {
      return this._duration;
    }, r.prototype.to = function(e, i) {
      if (i === void 0 && (i = 1e3), this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      return this._valuesEnd = e, this._propertiesAreSetUp = !1, this._duration = i < 0 ? 0 : i, this;
    }, r.prototype.duration = function(e) {
      return e === void 0 && (e = 1e3), this._duration = e < 0 ? 0 : e, this;
    }, r.prototype.dynamic = function(e) {
      return e === void 0 && (e = !1), this._isDynamic = e, this;
    }, r.prototype.start = function(e, i) {
      if (e === void 0 && (e = Wh()), i === void 0 && (i = !1), this._isPlaying)
        return this;
      if (this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var n in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n];
      }
      if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = e, this._startTime += this._delayTime, !this._propertiesAreSetUp || i) {
        if (this._propertiesAreSetUp = !0, !this._isDynamic) {
          var s = {};
          for (var a in this._valuesEnd)
            s[a] = this._valuesEnd[a];
          this._valuesEnd = s;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, i);
      }
      return this;
    }, r.prototype.startFromCurrentValues = function(e) {
      return this.start(e, !0);
    }, r.prototype._setupProperties = function(e, i, n, s, a) {
      for (var o in n) {
        var l = e[o], u = Array.isArray(l), c = u ? "array" : typeof l, h = !u && Array.isArray(n[o]);
        if (!(c === "undefined" || c === "function")) {
          if (h) {
            var d = n[o];
            if (d.length === 0)
              continue;
            for (var p = [l], f = 0, m = d.length; f < m; f += 1) {
              var y = this._handleRelativeValue(l, d[f]);
              if (isNaN(y)) {
                h = !1, console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              p.push(y);
            }
            h && (n[o] = p);
          }
          if ((c === "object" || u) && l && !h) {
            i[o] = u ? [] : {};
            var v = l;
            for (var g in v)
              i[o][g] = v[g];
            s[o] = u ? [] : {};
            var d = n[o];
            if (!this._isDynamic) {
              var _ = {};
              for (var g in d)
                _[g] = d[g];
              n[o] = d = _;
            }
            this._setupProperties(v, i[o], d, s[o], a);
          } else
            (typeof i[o] > "u" || a) && (i[o] = l), u || (i[o] *= 1), h ? s[o] = n[o].slice().reverse() : s[o] = i[o] || 0;
        }
      }
    }, r.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, r.prototype.end = function() {
      return this._goToEnd = !0, this.update(this._startTime + this._duration), this;
    }, r.prototype.pause = function(e) {
      return e === void 0 && (e = Wh()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = e, this);
    }, r.prototype.resume = function(e) {
      return e === void 0 && (e = Wh()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += e - this._pauseStart, this._pauseStart = 0, this);
    }, r.prototype.stopChainedTweens = function() {
      for (var e = 0, i = this._chainedTweens.length; e < i; e++)
        this._chainedTweens[e].stop();
      return this;
    }, r.prototype.group = function(e) {
      return e ? (e.add(this), this) : (console.warn("tween.group() without args has been removed, use group.add(tween) instead."), this);
    }, r.prototype.remove = function() {
      var e;
      return (e = this._group) === null || e === void 0 || e.remove(this), this;
    }, r.prototype.delay = function(e) {
      return e === void 0 && (e = 0), this._delayTime = e, this;
    }, r.prototype.repeat = function(e) {
      return e === void 0 && (e = 0), this._initialRepeat = e, this._repeat = e, this;
    }, r.prototype.repeatDelay = function(e) {
      return this._repeatDelayTime = e, this;
    }, r.prototype.yoyo = function(e) {
      return e === void 0 && (e = !1), this._yoyo = e, this;
    }, r.prototype.easing = function(e) {
      return e === void 0 && (e = va.Linear.None), this._easingFunction = e, this;
    }, r.prototype.interpolation = function(e) {
      return e === void 0 && (e = Ux.Linear), this._interpolationFunction = e, this;
    }, r.prototype.chain = function() {
      for (var e = [], i = 0; i < arguments.length; i++)
        e[i] = arguments[i];
      return this._chainedTweens = e, this;
    }, r.prototype.onStart = function(e) {
      return this._onStartCallback = e, this;
    }, r.prototype.onEveryStart = function(e) {
      return this._onEveryStartCallback = e, this;
    }, r.prototype.onUpdate = function(e) {
      return this._onUpdateCallback = e, this;
    }, r.prototype.onRepeat = function(e) {
      return this._onRepeatCallback = e, this;
    }, r.prototype.onComplete = function(e) {
      return this._onCompleteCallback = e, this;
    }, r.prototype.onStop = function(e) {
      return this._onStopCallback = e, this;
    }, r.prototype.update = function(e, i) {
      var n = this, s;
      if (e === void 0 && (e = Wh()), i === void 0 && (i = r.autoStartOnUpdate), this._isPaused)
        return !0;
      var a;
      if (!this._goToEnd && !this._isPlaying)
        if (i)
          this.start(e, !0);
        else
          return !1;
      if (this._goToEnd = !1, e < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0);
      var o = e - this._startTime, l = this._duration + ((s = this._repeatDelayTime) !== null && s !== void 0 ? s : this._delayTime), u = this._duration + this._repeat * l, c = function() {
        if (n._duration === 0 || o > u)
          return 1;
        var y = Math.trunc(o / l), v = o - y * l, g = Math.min(v / n._duration, 1);
        return g === 0 && o === n._duration ? 1 : g;
      }, h = c(), d = this._easingFunction(h);
      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, d), this._onUpdateCallback && this._onUpdateCallback(this._object, h), this._duration === 0 || o >= this._duration)
        if (this._repeat > 0) {
          var p = Math.min(Math.trunc((o - this._duration) / l) + 1, this._repeat);
          isFinite(this._repeat) && (this._repeat -= p);
          for (a in this._valuesStartRepeat)
            !this._yoyo && typeof this._valuesEnd[a] == "string" && (this._valuesStartRepeat[a] = // eslint-disable-next-line
            // @ts-ignore FIXME?
            this._valuesStartRepeat[a] + parseFloat(this._valuesEnd[a])), this._yoyo && this._swapEndStartRepeatValues(a), this._valuesStart[a] = this._valuesStartRepeat[a];
          return this._yoyo && (this._reversed = !this._reversed), this._startTime += l * p, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;
        } else {
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var f = 0, m = this._chainedTweens.length; f < m; f++)
            this._chainedTweens[f].start(this._startTime + this._duration, !1);
          return this._isPlaying = !1, !1;
        }
      return !0;
    }, r.prototype._updateProperties = function(e, i, n, s) {
      for (var a in n)
        if (i[a] !== void 0) {
          var o = i[a] || 0, l = n[a], u = Array.isArray(e[a]), c = Array.isArray(l), h = !u && c;
          h ? e[a] = this._interpolationFunction(l, s) : typeof l == "object" && l ? this._updateProperties(e[a], o, l, s) : (l = this._handleRelativeValue(o, l), typeof l == "number" && (e[a] = o + (l - o) * s));
        }
    }, r.prototype._handleRelativeValue = function(e, i) {
      return typeof i != "string" ? i : i.charAt(0) === "+" || i.charAt(0) === "-" ? e + parseFloat(i) : parseFloat(i);
    }, r.prototype._swapEndStartRepeatValues = function(e) {
      var i = this._valuesStartRepeat[e], n = this._valuesEnd[e];
      typeof n == "string" ? this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(n) : this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = i;
    }, r.autoStartOnUpdate = !1, r;
  }()
);
xI.nextId;
var ws = Fx;
ws.getAll.bind(ws);
ws.removeAll.bind(ws);
ws.add.bind(ws);
ws.remove.bind(ws);
ws.update.bind(ws);
var Bx = "http://www.w3.org/1999/xhtml";
const MM = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Bx,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function qg(r) {
  var e = r += "", i = e.indexOf(":");
  return i >= 0 && (e = r.slice(0, i)) !== "xmlns" && (r = r.slice(i + 1)), MM.hasOwnProperty(e) ? { space: MM[e], local: r } : r;
}
function ote(r) {
  return function() {
    var e = this.ownerDocument, i = this.namespaceURI;
    return i === Bx && e.documentElement.namespaceURI === Bx ? e.createElement(r) : e.createElementNS(i, r);
  };
}
function lte(r) {
  return function() {
    return this.ownerDocument.createElementNS(r.space, r.local);
  };
}
function _I(r) {
  var e = qg(r);
  return (e.local ? lte : ote)(e);
}
function ute() {
}
function Q1(r) {
  return r == null ? ute : function() {
    return this.querySelector(r);
  };
}
function cte(r) {
  typeof r != "function" && (r = Q1(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = new Array(o), u, c, h = 0; h < o; ++h)
      (u = a[h]) && (c = r.call(u, u.__data__, h, a)) && ("__data__" in u && (c.__data__ = u.__data__), l[h] = c);
  return new un(n, this._parents);
}
function hte(r) {
  return r == null ? [] : Array.isArray(r) ? r : Array.from(r);
}
function dte() {
  return [];
}
function TI(r) {
  return r == null ? dte : function() {
    return this.querySelectorAll(r);
  };
}
function pte(r) {
  return function() {
    return hte(r.apply(this, arguments));
  };
}
function fte(r) {
  typeof r == "function" ? r = pte(r) : r = TI(r);
  for (var e = this._groups, i = e.length, n = [], s = [], a = 0; a < i; ++a)
    for (var o = e[a], l = o.length, u, c = 0; c < l; ++c)
      (u = o[c]) && (n.push(r.call(u, u.__data__, c, o)), s.push(u));
  return new un(n, s);
}
function wI(r) {
  return function() {
    return this.matches(r);
  };
}
function SI(r) {
  return function(e) {
    return e.matches(r);
  };
}
var mte = Array.prototype.find;
function gte(r) {
  return function() {
    return mte.call(this.children, r);
  };
}
function yte() {
  return this.firstElementChild;
}
function vte(r) {
  return this.select(r == null ? yte : gte(typeof r == "function" ? r : SI(r)));
}
var bte = Array.prototype.filter;
function xte() {
  return Array.from(this.children);
}
function _te(r) {
  return function() {
    return bte.call(this.children, r);
  };
}
function Tte(r) {
  return this.selectAll(r == null ? xte : _te(typeof r == "function" ? r : SI(r)));
}
function wte(r) {
  typeof r != "function" && (r = wI(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = [], u, c = 0; c < o; ++c)
      (u = a[c]) && r.call(u, u.__data__, c, a) && l.push(u);
  return new un(n, this._parents);
}
function EI(r) {
  return new Array(r.length);
}
function Ste() {
  return new un(this._enter || this._groups.map(EI), this._parents);
}
function $m(r, e) {
  this.ownerDocument = r.ownerDocument, this.namespaceURI = r.namespaceURI, this._next = null, this._parent = r, this.__data__ = e;
}
$m.prototype = {
  constructor: $m,
  appendChild: function(r) {
    return this._parent.insertBefore(r, this._next);
  },
  insertBefore: function(r, e) {
    return this._parent.insertBefore(r, e);
  },
  querySelector: function(r) {
    return this._parent.querySelector(r);
  },
  querySelectorAll: function(r) {
    return this._parent.querySelectorAll(r);
  }
};
function Ete(r) {
  return function() {
    return r;
  };
}
function Mte(r, e, i, n, s, a) {
  for (var o = 0, l, u = e.length, c = a.length; o < c; ++o)
    (l = e[o]) ? (l.__data__ = a[o], n[o] = l) : i[o] = new $m(r, a[o]);
  for (; o < u; ++o)
    (l = e[o]) && (s[o] = l);
}
function Ate(r, e, i, n, s, a, o) {
  var l, u, c = /* @__PURE__ */ new Map(), h = e.length, d = a.length, p = new Array(h), f;
  for (l = 0; l < h; ++l)
    (u = e[l]) && (p[l] = f = o.call(u, u.__data__, l, e) + "", c.has(f) ? s[l] = u : c.set(f, u));
  for (l = 0; l < d; ++l)
    f = o.call(r, a[l], l, a) + "", (u = c.get(f)) ? (n[l] = u, u.__data__ = a[l], c.delete(f)) : i[l] = new $m(r, a[l]);
  for (l = 0; l < h; ++l)
    (u = e[l]) && c.get(p[l]) === u && (s[l] = u);
}
function Cte(r) {
  return r.__data__;
}
function Rte(r, e) {
  if (!arguments.length) return Array.from(this, Cte);
  var i = e ? Ate : Mte, n = this._parents, s = this._groups;
  typeof r != "function" && (r = Ete(r));
  for (var a = s.length, o = new Array(a), l = new Array(a), u = new Array(a), c = 0; c < a; ++c) {
    var h = n[c], d = s[c], p = d.length, f = Nte(r.call(h, h && h.__data__, c, n)), m = f.length, y = l[c] = new Array(m), v = o[c] = new Array(m), g = u[c] = new Array(p);
    i(h, d, y, v, g, f, e);
    for (var _ = 0, x = 0, b, T; _ < m; ++_)
      if (b = y[_]) {
        for (_ >= x && (x = _ + 1); !(T = v[x]) && ++x < m; ) ;
        b._next = T || null;
      }
  }
  return o = new un(o, n), o._enter = l, o._exit = u, o;
}
function Nte(r) {
  return typeof r == "object" && "length" in r ? r : Array.from(r);
}
function Pte() {
  return new un(this._exit || this._groups.map(EI), this._parents);
}
function Ite(r, e, i) {
  var n = this.enter(), s = this, a = this.exit();
  return typeof r == "function" ? (n = r(n), n && (n = n.selection())) : n = n.append(r + ""), e != null && (s = e(s), s && (s = s.selection())), i == null ? a.remove() : i(a), n && s ? n.merge(s).order() : s;
}
function Ote(r) {
  for (var e = r.selection ? r.selection() : r, i = this._groups, n = e._groups, s = i.length, a = n.length, o = Math.min(s, a), l = new Array(s), u = 0; u < o; ++u)
    for (var c = i[u], h = n[u], d = c.length, p = l[u] = new Array(d), f, m = 0; m < d; ++m)
      (f = c[m] || h[m]) && (p[m] = f);
  for (; u < s; ++u)
    l[u] = i[u];
  return new un(l, this._parents);
}
function Dte() {
  for (var r = this._groups, e = -1, i = r.length; ++e < i; )
    for (var n = r[e], s = n.length - 1, a = n[s], o; --s >= 0; )
      (o = n[s]) && (a && o.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(o, a), a = o);
  return this;
}
function Lte(r) {
  r || (r = kte);
  function e(d, p) {
    return d && p ? r(d.__data__, p.__data__) : !d - !p;
  }
  for (var i = this._groups, n = i.length, s = new Array(n), a = 0; a < n; ++a) {
    for (var o = i[a], l = o.length, u = s[a] = new Array(l), c, h = 0; h < l; ++h)
      (c = o[h]) && (u[h] = c);
    u.sort(e);
  }
  return new un(s, this._parents).order();
}
function kte(r, e) {
  return r < e ? -1 : r > e ? 1 : r >= e ? 0 : NaN;
}
function Ute() {
  var r = arguments[0];
  return arguments[0] = this, r.apply(null, arguments), this;
}
function Fte() {
  return Array.from(this);
}
function Bte() {
  for (var r = this._groups, e = 0, i = r.length; e < i; ++e)
    for (var n = r[e], s = 0, a = n.length; s < a; ++s) {
      var o = n[s];
      if (o) return o;
    }
  return null;
}
function zte() {
  let r = 0;
  for (const e of this) ++r;
  return r;
}
function jte() {
  return !this.node();
}
function Vte(r) {
  for (var e = this._groups, i = 0, n = e.length; i < n; ++i)
    for (var s = e[i], a = 0, o = s.length, l; a < o; ++a)
      (l = s[a]) && r.call(l, l.__data__, a, s);
  return this;
}
function Gte(r) {
  return function() {
    this.removeAttribute(r);
  };
}
function Hte(r) {
  return function() {
    this.removeAttributeNS(r.space, r.local);
  };
}
function Wte(r, e) {
  return function() {
    this.setAttribute(r, e);
  };
}
function qte(r, e) {
  return function() {
    this.setAttributeNS(r.space, r.local, e);
  };
}
function Xte(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? this.removeAttribute(r) : this.setAttribute(r, i);
  };
}
function Yte(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? this.removeAttributeNS(r.space, r.local) : this.setAttributeNS(r.space, r.local, i);
  };
}
function Kte(r, e) {
  var i = qg(r);
  if (arguments.length < 2) {
    var n = this.node();
    return i.local ? n.getAttributeNS(i.space, i.local) : n.getAttribute(i);
  }
  return this.each((e == null ? i.local ? Hte : Gte : typeof e == "function" ? i.local ? Yte : Xte : i.local ? qte : Wte)(i, e));
}
function MI(r) {
  return r.ownerDocument && r.ownerDocument.defaultView || r.document && r || r.defaultView;
}
function Zte(r) {
  return function() {
    this.style.removeProperty(r);
  };
}
function Qte(r, e, i) {
  return function() {
    this.style.setProperty(r, e, i);
  };
}
function $te(r, e, i) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(r) : this.style.setProperty(r, n, i);
  };
}
function Jte(r, e, i) {
  return arguments.length > 1 ? this.each((e == null ? Zte : typeof e == "function" ? $te : Qte)(r, e, i ?? "")) : Cc(this.node(), r);
}
function Cc(r, e) {
  return r.style.getPropertyValue(e) || MI(r).getComputedStyle(r, null).getPropertyValue(e);
}
function eie(r) {
  return function() {
    delete this[r];
  };
}
function tie(r, e) {
  return function() {
    this[r] = e;
  };
}
function iie(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    i == null ? delete this[r] : this[r] = i;
  };
}
function rie(r, e) {
  return arguments.length > 1 ? this.each((e == null ? eie : typeof e == "function" ? iie : tie)(r, e)) : this.node()[r];
}
function AI(r) {
  return r.trim().split(/^|\s+/);
}
function $1(r) {
  return r.classList || new CI(r);
}
function CI(r) {
  this._node = r, this._names = AI(r.getAttribute("class") || "");
}
CI.prototype = {
  add: function(r) {
    var e = this._names.indexOf(r);
    e < 0 && (this._names.push(r), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(r) {
    var e = this._names.indexOf(r);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(r) {
    return this._names.indexOf(r) >= 0;
  }
};
function RI(r, e) {
  for (var i = $1(r), n = -1, s = e.length; ++n < s; ) i.add(e[n]);
}
function NI(r, e) {
  for (var i = $1(r), n = -1, s = e.length; ++n < s; ) i.remove(e[n]);
}
function nie(r) {
  return function() {
    RI(this, r);
  };
}
function sie(r) {
  return function() {
    NI(this, r);
  };
}
function aie(r, e) {
  return function() {
    (e.apply(this, arguments) ? RI : NI)(this, r);
  };
}
function oie(r, e) {
  var i = AI(r + "");
  if (arguments.length < 2) {
    for (var n = $1(this.node()), s = -1, a = i.length; ++s < a; ) if (!n.contains(i[s])) return !1;
    return !0;
  }
  return this.each((typeof e == "function" ? aie : e ? nie : sie)(i, e));
}
function lie() {
  this.textContent = "";
}
function uie(r) {
  return function() {
    this.textContent = r;
  };
}
function cie(r) {
  return function() {
    var e = r.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function hie(r) {
  return arguments.length ? this.each(r == null ? lie : (typeof r == "function" ? cie : uie)(r)) : this.node().textContent;
}
function die() {
  this.innerHTML = "";
}
function pie(r) {
  return function() {
    this.innerHTML = r;
  };
}
function fie(r) {
  return function() {
    var e = r.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function mie(r) {
  return arguments.length ? this.each(r == null ? die : (typeof r == "function" ? fie : pie)(r)) : this.node().innerHTML;
}
function gie() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function yie() {
  return this.each(gie);
}
function vie() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function bie() {
  return this.each(vie);
}
function xie(r) {
  var e = typeof r == "function" ? r : _I(r);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function _ie() {
  return null;
}
function Tie(r, e) {
  var i = typeof r == "function" ? r : _I(r), n = e == null ? _ie : typeof e == "function" ? e : Q1(e);
  return this.select(function() {
    return this.insertBefore(i.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function wie() {
  var r = this.parentNode;
  r && r.removeChild(this);
}
function Sie() {
  return this.each(wie);
}
function Eie() {
  var r = this.cloneNode(!1), e = this.parentNode;
  return e ? e.insertBefore(r, this.nextSibling) : r;
}
function Mie() {
  var r = this.cloneNode(!0), e = this.parentNode;
  return e ? e.insertBefore(r, this.nextSibling) : r;
}
function Aie(r) {
  return this.select(r ? Mie : Eie);
}
function Cie(r) {
  return arguments.length ? this.property("__data__", r) : this.node().__data__;
}
function Rie(r) {
  return function(e) {
    r.call(this, e, this.__data__);
  };
}
function Nie(r) {
  return r.trim().split(/^|\s+/).map(function(e) {
    var i = "", n = e.indexOf(".");
    return n >= 0 && (i = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: i };
  });
}
function Pie(r) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var i = 0, n = -1, s = e.length, a; i < s; ++i)
        a = e[i], (!r.type || a.type === r.type) && a.name === r.name ? this.removeEventListener(a.type, a.listener, a.options) : e[++n] = a;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function Iie(r, e, i) {
  return function() {
    var n = this.__on, s, a = Rie(e);
    if (n) {
      for (var o = 0, l = n.length; o < l; ++o)
        if ((s = n[o]).type === r.type && s.name === r.name) {
          this.removeEventListener(s.type, s.listener, s.options), this.addEventListener(s.type, s.listener = a, s.options = i), s.value = e;
          return;
        }
    }
    this.addEventListener(r.type, a, i), s = { type: r.type, name: r.name, value: e, listener: a, options: i }, n ? n.push(s) : this.__on = [s];
  };
}
function Oie(r, e, i) {
  var n = Nie(r + ""), s, a = n.length, o;
  if (arguments.length < 2) {
    var l = this.node().__on;
    if (l) {
      for (var u = 0, c = l.length, h; u < c; ++u)
        for (s = 0, h = l[u]; s < a; ++s)
          if ((o = n[s]).type === h.type && o.name === h.name)
            return h.value;
    }
    return;
  }
  for (l = e ? Iie : Pie, s = 0; s < a; ++s) this.each(l(n[s], e, i));
  return this;
}
function PI(r, e, i) {
  var n = MI(r), s = n.CustomEvent;
  typeof s == "function" ? s = new s(e, i) : (s = n.document.createEvent("Event"), i ? (s.initEvent(e, i.bubbles, i.cancelable), s.detail = i.detail) : s.initEvent(e, !1, !1)), r.dispatchEvent(s);
}
function Die(r, e) {
  return function() {
    return PI(this, r, e);
  };
}
function Lie(r, e) {
  return function() {
    return PI(this, r, e.apply(this, arguments));
  };
}
function kie(r, e) {
  return this.each((typeof e == "function" ? Lie : Die)(r, e));
}
function* Uie() {
  for (var r = this._groups, e = 0, i = r.length; e < i; ++e)
    for (var n = r[e], s = 0, a = n.length, o; s < a; ++s)
      (o = n[s]) && (yield o);
}
var II = [null];
function un(r, e) {
  this._groups = r, this._parents = e;
}
function rp() {
  return new un([[document.documentElement]], II);
}
function Fie() {
  return this;
}
un.prototype = rp.prototype = {
  constructor: un,
  select: cte,
  selectAll: fte,
  selectChild: vte,
  selectChildren: Tte,
  filter: wte,
  data: Rte,
  enter: Ste,
  exit: Pte,
  join: Ite,
  merge: Ote,
  selection: Fie,
  order: Dte,
  sort: Lte,
  call: Ute,
  nodes: Fte,
  node: Bte,
  size: zte,
  empty: jte,
  each: Vte,
  attr: Kte,
  style: Jte,
  property: rie,
  classed: oie,
  text: hie,
  html: mie,
  raise: yie,
  lower: bie,
  append: xie,
  insert: Tie,
  remove: Sie,
  clone: Aie,
  datum: Cie,
  on: Oie,
  dispatch: kie,
  [Symbol.iterator]: Uie
};
function bn(r) {
  return typeof r == "string" ? new un([[document.querySelector(r)]], [document.documentElement]) : new un([[r]], II);
}
function Bie(r) {
  let e;
  for (; e = r.sourceEvent; ) r = e;
  return r;
}
function as(r, e) {
  if (r = Bie(r), e === void 0 && (e = r.currentTarget), e) {
    var i = e.ownerSVGElement || e;
    if (i.createSVGPoint) {
      var n = i.createSVGPoint();
      return n.x = r.clientX, n.y = r.clientY, n = n.matrixTransform(e.getScreenCTM().inverse()), [n.x, n.y];
    }
    if (e.getBoundingClientRect) {
      var s = e.getBoundingClientRect();
      return [r.clientX - s.left - e.clientLeft, r.clientY - s.top - e.clientTop];
    }
  }
  return [r.pageX, r.pageY];
}
var np, mi, OI, DI, Jo, AM, LI, kI, UI, J1, zx, jx, Rd = {}, FI = [], zie = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Xg = Array.isArray;
function gs(r, e) {
  for (var i in e) r[i] = e[i];
  return r;
}
function eT(r) {
  r && r.parentNode && r.parentNode.removeChild(r);
}
function jie(r, e, i) {
  var n, s, a, o = {};
  for (a in e) a == "key" ? n = e[a] : a == "ref" ? s = e[a] : o[a] = e[a];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? np.call(arguments, 2) : i), typeof r == "function" && r.defaultProps != null) for (a in r.defaultProps) o[a] === void 0 && (o[a] = r.defaultProps[a]);
  return sd(r, o, n, s, null);
}
function sd(r, e, i, n, s) {
  var a = { type: r, props: e, key: i, ref: n, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: s ?? ++OI, __i: -1, __u: 0 };
  return s == null && mi.vnode != null && mi.vnode(a), a;
}
function Yg(r) {
  return r.children;
}
function um(r, e) {
  this.props = r, this.context = e;
}
function Rc(r, e) {
  if (e == null) return r.__ ? Rc(r.__, r.__i + 1) : null;
  for (var i; e < r.__k.length; e++) if ((i = r.__k[e]) != null && i.__e != null) return i.__e;
  return typeof r.type == "function" ? Rc(r) : null;
}
function BI(r) {
  var e, i;
  if ((r = r.__) != null && r.__c != null) {
    for (r.__e = r.__c.base = null, e = 0; e < r.__k.length; e++) if ((i = r.__k[e]) != null && i.__e != null) {
      r.__e = r.__c.base = i.__e;
      break;
    }
    return BI(r);
  }
}
function CM(r) {
  (!r.__d && (r.__d = !0) && Jo.push(r) && !Jm.__r++ || AM !== mi.debounceRendering) && ((AM = mi.debounceRendering) || LI)(Jm);
}
function Jm() {
  for (var r, e, i, n, s, a, o, l = 1; Jo.length; ) Jo.length > l && Jo.sort(kI), r = Jo.shift(), l = Jo.length, r.__d && (i = void 0, s = (n = (e = r).__v).__e, a = [], o = [], e.__P && ((i = gs({}, n)).__v = n.__v + 1, mi.vnode && mi.vnode(i), tT(e.__P, i, n, e.__n, e.__P.namespaceURI, 32 & n.__u ? [s] : null, a, s ?? Rc(n), !!(32 & n.__u), o), i.__v = n.__v, i.__.__k[i.__i] = i, VI(a, i, o), i.__e != s && BI(i)));
  Jm.__r = 0;
}
function zI(r, e, i, n, s, a, o, l, u, c, h) {
  var d, p, f, m, y, v, g = n && n.__k || FI, _ = e.length;
  for (u = Vie(i, e, g, u, _), d = 0; d < _; d++) (f = i.__k[d]) != null && (p = f.__i === -1 ? Rd : g[f.__i] || Rd, f.__i = d, v = tT(r, f, p, s, a, o, l, u, c, h), m = f.__e, f.ref && p.ref != f.ref && (p.ref && iT(p.ref, null, f), h.push(f.ref, f.__c || m, f)), y == null && m != null && (y = m), 4 & f.__u || p.__k === f.__k ? u = jI(f, u, r) : typeof f.type == "function" && v !== void 0 ? u = v : m && (u = m.nextSibling), f.__u &= -7);
  return i.__e = y, u;
}
function Vie(r, e, i, n, s) {
  var a, o, l, u, c, h = i.length, d = h, p = 0;
  for (r.__k = new Array(s), a = 0; a < s; a++) (o = e[a]) != null && typeof o != "boolean" && typeof o != "function" ? (u = a + p, (o = r.__k[a] = typeof o == "string" || typeof o == "number" || typeof o == "bigint" || o.constructor == String ? sd(null, o, null, null, null) : Xg(o) ? sd(Yg, { children: o }, null, null, null) : o.constructor === void 0 && o.__b > 0 ? sd(o.type, o.props, o.key, o.ref ? o.ref : null, o.__v) : o).__ = r, o.__b = r.__b + 1, l = null, (c = o.__i = Gie(o, i, u, d)) !== -1 && (d--, (l = i[c]) && (l.__u |= 2)), l == null || l.__v === null ? (c == -1 && (s > h ? p-- : s < h && p++), typeof o.type != "function" && (o.__u |= 4)) : c != u && (c == u - 1 ? p-- : c == u + 1 ? p++ : (c > u ? p-- : p++, o.__u |= 4))) : r.__k[a] = null;
  if (d) for (a = 0; a < h; a++) (l = i[a]) != null && !(2 & l.__u) && (l.__e == n && (n = Rc(l)), HI(l, l));
  return n;
}
function jI(r, e, i) {
  var n, s;
  if (typeof r.type == "function") {
    for (n = r.__k, s = 0; n && s < n.length; s++) n[s] && (n[s].__ = r, e = jI(n[s], e, i));
    return e;
  }
  r.__e != e && (e && r.type && !i.contains(e) && (e = Rc(r)), i.insertBefore(r.__e, e || null), e = r.__e);
  do
    e = e && e.nextSibling;
  while (e != null && e.nodeType == 8);
  return e;
}
function Gie(r, e, i, n) {
  var s, a, o = r.key, l = r.type, u = e[i];
  if (u === null && r.key == null || u && o == u.key && l === u.type && !(2 & u.__u)) return i;
  if (n > (u != null && !(2 & u.__u) ? 1 : 0)) for (s = i - 1, a = i + 1; s >= 0 || a < e.length; ) {
    if (s >= 0) {
      if ((u = e[s]) && !(2 & u.__u) && o == u.key && l === u.type) return s;
      s--;
    }
    if (a < e.length) {
      if ((u = e[a]) && !(2 & u.__u) && o == u.key && l === u.type) return a;
      a++;
    }
  }
  return -1;
}
function RM(r, e, i) {
  e[0] == "-" ? r.setProperty(e, i ?? "") : r[e] = i == null ? "" : typeof i != "number" || zie.test(e) ? i : i + "px";
}
function If(r, e, i, n, s) {
  var a;
  e: if (e == "style") if (typeof i == "string") r.style.cssText = i;
  else {
    if (typeof n == "string" && (r.style.cssText = n = ""), n) for (e in n) i && e in i || RM(r.style, e, "");
    if (i) for (e in i) n && i[e] === n[e] || RM(r.style, e, i[e]);
  }
  else if (e[0] == "o" && e[1] == "n") a = e != (e = e.replace(UI, "$1")), e = e.toLowerCase() in r || e == "onFocusOut" || e == "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), r.l || (r.l = {}), r.l[e + a] = i, i ? n ? i.t = n.t : (i.t = J1, r.addEventListener(e, a ? jx : zx, a)) : r.removeEventListener(e, a ? jx : zx, a);
  else {
    if (s == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in r) try {
      r[e] = i ?? "";
      break e;
    } catch {
    }
    typeof i == "function" || (i == null || i === !1 && e[4] != "-" ? r.removeAttribute(e) : r.setAttribute(e, e == "popover" && i == 1 ? "" : i));
  }
}
function NM(r) {
  return function(e) {
    if (this.l) {
      var i = this.l[e.type + r];
      if (e.u == null) e.u = J1++;
      else if (e.u < i.t) return;
      return i(mi.event ? mi.event(e) : e);
    }
  };
}
function tT(r, e, i, n, s, a, o, l, u, c) {
  var h, d, p, f, m, y, v, g, _, x, b, T, E, M, C, S, w, R = e.type;
  if (e.constructor !== void 0) return null;
  128 & i.__u && (u = !!(32 & i.__u), a = [l = e.__e = i.__e]), (h = mi.__b) && h(e);
  e: if (typeof R == "function") try {
    if (g = e.props, _ = "prototype" in R && R.prototype.render, x = (h = R.contextType) && n[h.__c], b = h ? x ? x.props.value : h.__ : n, i.__c ? v = (d = e.__c = i.__c).__ = d.__E : (_ ? e.__c = d = new R(g, b) : (e.__c = d = new um(g, b), d.constructor = R, d.render = Wie), x && x.sub(d), d.props = g, d.state || (d.state = {}), d.context = b, d.__n = n, p = d.__d = !0, d.__h = [], d._sb = []), _ && d.__s == null && (d.__s = d.state), _ && R.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = gs({}, d.__s)), gs(d.__s, R.getDerivedStateFromProps(g, d.__s))), f = d.props, m = d.state, d.__v = e, p) _ && R.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(), _ && d.componentDidMount != null && d.__h.push(d.componentDidMount);
    else {
      if (_ && R.getDerivedStateFromProps == null && g !== f && d.componentWillReceiveProps != null && d.componentWillReceiveProps(g, b), !d.__e && (d.shouldComponentUpdate != null && d.shouldComponentUpdate(g, d.__s, b) === !1 || e.__v == i.__v)) {
        for (e.__v != i.__v && (d.props = g, d.state = d.__s, d.__d = !1), e.__e = i.__e, e.__k = i.__k, e.__k.some(function(O) {
          O && (O.__ = e);
        }), T = 0; T < d._sb.length; T++) d.__h.push(d._sb[T]);
        d._sb = [], d.__h.length && o.push(d);
        break e;
      }
      d.componentWillUpdate != null && d.componentWillUpdate(g, d.__s, b), _ && d.componentDidUpdate != null && d.__h.push(function() {
        d.componentDidUpdate(f, m, y);
      });
    }
    if (d.context = b, d.props = g, d.__P = r, d.__e = !1, E = mi.__r, M = 0, _) {
      for (d.state = d.__s, d.__d = !1, E && E(e), h = d.render(d.props, d.state, d.context), C = 0; C < d._sb.length; C++) d.__h.push(d._sb[C]);
      d._sb = [];
    } else do
      d.__d = !1, E && E(e), h = d.render(d.props, d.state, d.context), d.state = d.__s;
    while (d.__d && ++M < 25);
    d.state = d.__s, d.getChildContext != null && (n = gs(gs({}, n), d.getChildContext())), _ && !p && d.getSnapshotBeforeUpdate != null && (y = d.getSnapshotBeforeUpdate(f, m)), S = h, h != null && h.type === Yg && h.key == null && (S = GI(h.props.children)), l = zI(r, Xg(S) ? S : [S], e, i, n, s, a, o, l, u, c), d.base = e.__e, e.__u &= -161, d.__h.length && o.push(d), v && (d.__E = d.__ = null);
  } catch (O) {
    if (e.__v = null, u || a != null) if (O.then) {
      for (e.__u |= u ? 160 : 128; l && l.nodeType == 8 && l.nextSibling; ) l = l.nextSibling;
      a[a.indexOf(l)] = null, e.__e = l;
    } else for (w = a.length; w--; ) eT(a[w]);
    else e.__e = i.__e, e.__k = i.__k;
    mi.__e(O, e, i);
  }
  else a == null && e.__v == i.__v ? (e.__k = i.__k, e.__e = i.__e) : l = e.__e = Hie(i.__e, e, i, n, s, a, o, u, c);
  return (h = mi.diffed) && h(e), 128 & e.__u ? void 0 : l;
}
function VI(r, e, i) {
  for (var n = 0; n < i.length; n++) iT(i[n], i[++n], i[++n]);
  mi.__c && mi.__c(e, r), r.some(function(s) {
    try {
      r = s.__h, s.__h = [], r.some(function(a) {
        a.call(s);
      });
    } catch (a) {
      mi.__e(a, s.__v);
    }
  });
}
function GI(r) {
  return typeof r != "object" || r == null ? r : Xg(r) ? r.map(GI) : gs({}, r);
}
function Hie(r, e, i, n, s, a, o, l, u) {
  var c, h, d, p, f, m, y, v = i.props, g = e.props, _ = e.type;
  if (_ == "svg" ? s = "http://www.w3.org/2000/svg" : _ == "math" ? s = "http://www.w3.org/1998/Math/MathML" : s || (s = "http://www.w3.org/1999/xhtml"), a != null) {
    for (c = 0; c < a.length; c++) if ((f = a[c]) && "setAttribute" in f == !!_ && (_ ? f.localName == _ : f.nodeType == 3)) {
      r = f, a[c] = null;
      break;
    }
  }
  if (r == null) {
    if (_ == null) return document.createTextNode(g);
    r = document.createElementNS(s, _, g.is && g), l && (mi.__m && mi.__m(e, a), l = !1), a = null;
  }
  if (_ === null) v === g || l && r.data === g || (r.data = g);
  else {
    if (a = a && np.call(r.childNodes), v = i.props || Rd, !l && a != null) for (v = {}, c = 0; c < r.attributes.length; c++) v[(f = r.attributes[c]).name] = f.value;
    for (c in v) if (f = v[c], c != "children") {
      if (c == "dangerouslySetInnerHTML") d = f;
      else if (!(c in g)) {
        if (c == "value" && "defaultValue" in g || c == "checked" && "defaultChecked" in g) continue;
        If(r, c, null, f, s);
      }
    }
    for (c in g) f = g[c], c == "children" ? p = f : c == "dangerouslySetInnerHTML" ? h = f : c == "value" ? m = f : c == "checked" ? y = f : l && typeof f != "function" || v[c] === f || If(r, c, f, v[c], s);
    if (h) l || d && (h.__html === d.__html || h.__html === r.innerHTML) || (r.innerHTML = h.__html), e.__k = [];
    else if (d && (r.innerHTML = ""), zI(e.type === "template" ? r.content : r, Xg(p) ? p : [p], e, i, n, _ == "foreignObject" ? "http://www.w3.org/1999/xhtml" : s, a, o, a ? a[0] : i.__k && Rc(i, 0), l, u), a != null) for (c = a.length; c--; ) eT(a[c]);
    l || (c = "value", _ == "progress" && m == null ? r.removeAttribute("value") : m !== void 0 && (m !== r[c] || _ == "progress" && !m || _ == "option" && m !== v[c]) && If(r, c, m, v[c], s), c = "checked", y !== void 0 && y !== r[c] && If(r, c, y, v[c], s));
  }
  return r;
}
function iT(r, e, i) {
  try {
    if (typeof r == "function") {
      var n = typeof r.__u == "function";
      n && r.__u(), n && e == null || (r.__u = r(e));
    } else r.current = e;
  } catch (s) {
    mi.__e(s, i);
  }
}
function HI(r, e, i) {
  var n, s;
  if (mi.unmount && mi.unmount(r), (n = r.ref) && (n.current && n.current !== r.__e || iT(n, null, e)), (n = r.__c) != null) {
    if (n.componentWillUnmount) try {
      n.componentWillUnmount();
    } catch (a) {
      mi.__e(a, e);
    }
    n.base = n.__P = null;
  }
  if (n = r.__k) for (s = 0; s < n.length; s++) n[s] && HI(n[s], e, i || typeof r.type != "function");
  i || eT(r.__e), r.__c = r.__ = r.__e = void 0;
}
function Wie(r, e, i) {
  return this.constructor(r, i);
}
function qie(r, e, i) {
  var n, s, a, o;
  e == document && (e = document.documentElement), mi.__ && mi.__(r, e), s = (n = !1) ? null : e.__k, a = [], o = [], tT(e, r = e.__k = jie(Yg, null, [r]), s || Rd, Rd, e.namespaceURI, s ? null : e.firstChild ? np.call(e.childNodes) : null, a, s ? s.__e : e.firstChild, n, o), VI(a, r, o);
}
function WI(r, e, i) {
  var n, s, a, o, l = gs({}, r.props);
  for (a in r.type && r.type.defaultProps && (o = r.type.defaultProps), e) a == "key" ? n = e[a] : a == "ref" ? s = e[a] : l[a] = e[a] === void 0 && o !== void 0 ? o[a] : e[a];
  return arguments.length > 2 && (l.children = arguments.length > 3 ? np.call(arguments, 2) : i), sd(r.type, l, n || r.key, s || r.ref, null);
}
np = FI.slice, mi = { __e: function(r, e, i, n) {
  for (var s, a, o; e = e.__; ) if ((s = e.__c) && !s.__) try {
    if ((a = s.constructor) && a.getDerivedStateFromError != null && (s.setState(a.getDerivedStateFromError(r)), o = s.__d), s.componentDidCatch != null && (s.componentDidCatch(r, n || {}), o = s.__d), o) return s.__E = s;
  } catch (l) {
    r = l;
  }
  throw r;
} }, OI = 0, DI = function(r) {
  return r != null && r.constructor == null;
}, um.prototype.setState = function(r, e) {
  var i;
  i = this.__s != null && this.__s !== this.state ? this.__s : this.__s = gs({}, this.state), typeof r == "function" && (r = r(gs({}, i), this.props)), r && gs(i, r), r != null && this.__v && (e && this._sb.push(e), CM(this));
}, um.prototype.forceUpdate = function(r) {
  this.__v && (this.__e = !0, r && this.__h.push(r), CM(this));
}, um.prototype.render = Yg, Jo = [], LI = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, kI = function(r, e) {
  return r.__v.__b - e.__v.__b;
}, Jm.__r = 0, UI = /(PointerCapture)$|Capture$/i, J1 = 0, zx = NM(!1), jx = NM(!0);
function PM(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Xie(r) {
  if (Array.isArray(r)) return r;
}
function Yie(r, e, i) {
  return (e = ere(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function Kie(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function Zie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function IM(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function Qie(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? IM(Object(i), !0).forEach(function(n) {
      Yie(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : IM(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function $ie(r, e) {
  return Xie(r) || Kie(r, e) || tre(r, e) || Zie();
}
function Jie(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function ere(r) {
  var e = Jie(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function eg(r) {
  "@babel/helpers - typeof";
  return eg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, eg(r);
}
function tre(r, e) {
  if (r) {
    if (typeof r == "string") return PM(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? PM(r, e) : void 0;
  }
}
var Vx = function(r) {
  if (eg(r) !== "object") return r;
  var e = WI(r);
  if (e.props) {
    var i;
    e.props = Qie({}, e.props), e != null && (i = e.props) !== null && i !== void 0 && i.children && (e.props.children = Array.isArray(e.props.children) ? e.props.children.map(Vx) : Vx(e.props.children));
  }
  return e;
}, ire = function(r) {
  return DI(WI(r));
}, rre = function(r, e) {
  delete e.__k, qie(Vx(r), e);
};
function nre(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var sre = `.float-tooltip-kap {
  position: absolute;
  width: max-content; /* prevent shrinking near right edge */
  max-width: max(50%, 150px);
  padding: 3px 5px;
  border-radius: 3px;
  font: 12px sans-serif;
  color: #eee;
  background: rgba(0,0,0,0.6);
  pointer-events: none;
}
`;
nre(sre);
var qI = Pl({
  props: {
    content: {
      default: !1
    },
    offsetX: {
      triggerUpdate: !1
    },
    // null or number
    offsetY: {
      triggerUpdate: !1
    }
    // null or number
  },
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.style, s = n === void 0 ? {} : n, a = !!r && eg(r) === "object" && !!r.node && typeof r.node == "function", o = bn(a ? r.node() : r);
    o.style("position") === "static" && o.style("position", "relative"), e.tooltipEl = o.append("div").attr("class", "float-tooltip-kap"), Object.entries(s).forEach(function(u) {
      var c = $ie(u, 2), h = c[0], d = c[1];
      return e.tooltipEl.style(h, d);
    }), e.tooltipEl.style("left", "-10000px").style("display", "none");
    var l = "tooltip-".concat(Math.round(Math.random() * 1e12));
    e.mouseInside = !1, o.on("mousemove.".concat(l), function(u) {
      e.mouseInside = !0;
      var c = as(u), h = o.node(), d = h.offsetWidth, p = h.offsetHeight, f = [e.offsetX === null || e.offsetX === void 0 ? "-".concat(c[0] / d * 100, "%") : typeof e.offsetX == "number" ? "calc(-50% + ".concat(e.offsetX, "px)") : e.offsetX, e.offsetY === null || e.offsetY === void 0 ? p > 130 && p - c[1] < 100 ? "calc(-100% - 6px)" : "21px" : typeof e.offsetY == "number" ? e.offsetY < 0 ? "calc(-100% - ".concat(Math.abs(e.offsetY), "px)") : "".concat(e.offsetY, "px") : e.offsetY];
      e.tooltipEl.style("left", c[0] + "px").style("top", c[1] + "px").style("transform", "translate(".concat(f.join(","), ")")), e.content && e.tooltipEl.style("display", "inline");
    }), o.on("mouseover.".concat(l), function() {
      e.mouseInside = !0, e.content && e.tooltipEl.style("display", "inline");
    }), o.on("mouseout.".concat(l), function() {
      e.mouseInside = !1, e.tooltipEl.style("display", "none");
    });
  },
  update: function(r) {
    r.tooltipEl.style("display", r.content && r.mouseInside ? "inline" : "none"), r.content ? r.content instanceof HTMLElement ? (r.tooltipEl.text(""), r.tooltipEl.append(function() {
      return r.content;
    })) : typeof r.content == "string" ? r.tooltipEl.html(r.content) : ire(r.content) ? (r.tooltipEl.text(""), rre(r.content, r.tooltipEl.node())) : (r.tooltipEl.style("display", "none"), console.warn("Tooltip content is invalid, skipping.", r.content, r.content.toString())) : r.tooltipEl.text("");
  }
});
function are(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var ore = `.scene-nav-info {
  position: absolute;
  bottom: 5px;
  width: 100%;
  text-align: center;
  color: slategrey;
  opacity: 0.7;
  font-size: 10px;
  font-family: sans-serif;
  pointer-events: none;
  user-select: none;
}

.scene-container canvas:focus {
  outline: none;
}`;
are(ore);
function Gx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function lre(r) {
  if (Array.isArray(r)) return r;
}
function ure(r) {
  if (Array.isArray(r)) return Gx(r);
}
function cre(r, e, i) {
  return (e = yre(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function hre(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function dre(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function pre() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function fre() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function mre(r, e) {
  return lre(r) || dre(r, e) || XI(r, e) || pre();
}
function Bo(r) {
  return ure(r) || hre(r) || XI(r) || fre();
}
function gre(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function yre(r) {
  var e = gre(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function XI(r, e) {
  if (r) {
    if (typeof r == "string") return Gx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Gx(r, e) : void 0;
  }
}
var pi = window.THREE ? window.THREE : {
  WebGLRenderer: Aj,
  Scene: Cj,
  PerspectiveCamera: vn,
  Raycaster: IR,
  SRGBColorSpace: sn,
  TextureLoader: $j,
  Vector2: ke,
  Vector3: Y,
  Box3: Rl,
  Color: Ut,
  Mesh: kr,
  SphereGeometry: CR,
  MeshBasicMaterial: Tg,
  BackSide: Ar,
  Clock: PR
}, YI = Pl({
  props: {
    width: {
      default: window.innerWidth,
      onChange: function(r, e, i) {
        isNaN(r) && (e.width = i);
      }
    },
    height: {
      default: window.innerHeight,
      onChange: function(r, e, i) {
        isNaN(r) && (e.height = i);
      }
    },
    viewOffset: {
      default: [0, 0]
    },
    backgroundColor: {
      default: "#000011"
    },
    backgroundImageUrl: {},
    onBackgroundImageLoaded: {},
    showNavInfo: {
      default: !0
    },
    skyRadius: {
      default: 5e4
    },
    objects: {
      default: []
    },
    lights: {
      default: []
    },
    enablePointerInteraction: {
      default: !0,
      onChange: function(r, e) {
        e.hoverObj = null, e.tooltip && e.tooltip.content(null);
      },
      triggerUpdate: !1
    },
    lineHoverPrecision: {
      default: 1,
      triggerUpdate: !1
    },
    pointsHoverPrecision: {
      default: 1,
      triggerUpdate: !1
    },
    hoverOrderComparator: {
      triggerUpdate: !1
    },
    // keep existing order by default
    hoverFilter: {
      default: function() {
        return !0;
      },
      triggerUpdate: !1
    },
    // exclude objects from interaction
    tooltipContent: {
      triggerUpdate: !1
    },
    hoverDuringDrag: {
      default: !1,
      triggerUpdate: !1
    },
    clickAfterDrag: {
      default: !1,
      triggerUpdate: !1
    },
    onHover: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onClick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onRightClick: {
      triggerUpdate: !1
    }
  },
  methods: {
    tick: function(r) {
      if (r.initialised) {
        if (r.controls.update && r.controls.update(Math.min(1, r.clock.getDelta())), r.postProcessingComposer ? r.postProcessingComposer.render() : r.renderer.render(r.scene, r.camera), r.extraRenderers.forEach(function(s) {
          return s.render(r.scene, r.camera);
        }), r.enablePointerInteraction) {
          var e = null;
          if (r.hoverDuringDrag || !r.isPointerDragging) {
            var i = this.intersectingObjects(r.pointerPos.x, r.pointerPos.y);
            r.hoverOrderComparator && i.sort(function(s, a) {
              return r.hoverOrderComparator(s.object, a.object);
            });
            var n = i.find(function(s) {
              return r.hoverFilter(s.object);
            }) || null;
            e = n ? n.object : null, r.intersection = n || null;
          }
          e !== r.hoverObj && (r.onHover(e, r.hoverObj, r.intersection), r.tooltip.content(e && tt(r.tooltipContent)(e, r.intersection) || null), r.hoverObj = e);
        }
        r.tweenGroup.update();
      }
      return this;
    },
    getPointerPos: function(r) {
      var e = r.pointerPos, i = e.x, n = e.y;
      return {
        x: i,
        y: n
      };
    },
    cameraPosition: function(r, e, i, n) {
      var s = r.camera;
      if (e && r.initialised) {
        var a = e, o = i || {
          x: 0,
          y: 0,
          z: 0
        };
        if (!n)
          c(a), h(o);
        else {
          var l = Object.assign({}, s.position), u = d();
          r.tweenGroup.add(new Qm(l).to(a, n).easing(va.Quadratic.Out).onUpdate(c).start()), r.tweenGroup.add(new Qm(u).to(o, n / 3).easing(va.Quadratic.Out).onUpdate(h).start());
        }
        return this;
      }
      return Object.assign({}, s.position, {
        lookAt: d()
      });
      function c(p) {
        var f = p.x, m = p.y, y = p.z;
        f !== void 0 && (s.position.x = f), m !== void 0 && (s.position.y = m), y !== void 0 && (s.position.z = y);
      }
      function h(p) {
        var f = new pi.Vector3(p.x, p.y, p.z);
        r.controls.target ? r.controls.target = f : s.lookAt(f);
      }
      function d() {
        return Object.assign(new pi.Vector3(0, 0, -1e3).applyQuaternion(s.quaternion).add(s.position));
      }
    },
    zoomToFit: function(r) {
      for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, n = arguments.length, s = new Array(n > 3 ? n - 3 : 0), a = 3; a < n; a++)
        s[a - 3] = arguments[a];
      return this.fitToBbox(this.getBbox.apply(this, s), e, i);
    },
    fitToBbox: function(r, e) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10, s = r.camera;
      if (e) {
        var a = new pi.Vector3(0, 0, 0), o = Math.max.apply(Math, Bo(Object.entries(e).map(function(p) {
          var f = mre(p, 2), m = f[0], y = f[1];
          return Math.max.apply(Math, Bo(y.map(function(v) {
            return Math.abs(a[m] - v);
          })));
        }))) * 2, l = (1 - n * 2 / r.height) * s.fov, u = o / Math.atan(l * Math.PI / 180), c = u / s.aspect, h = Math.max(u, c);
        if (h > 0) {
          var d = a.clone().sub(s.position).normalize().multiplyScalar(-h);
          this.cameraPosition(d, a, i);
        }
      }
      return this;
    },
    getBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      }, i = new pi.Box3(new pi.Vector3(0, 0, 0), new pi.Vector3(0, 0, 0)), n = r.objects.filter(e);
      return n.length ? (n.forEach(function(s) {
        return i.expandByObject(s);
      }), Object.assign.apply(Object, Bo(["x", "y", "z"].map(function(s) {
        return cre({}, s, [i.min[s], i.max[s]]);
      })))) : null;
    },
    getScreenCoords: function(r, e, i, n) {
      var s = new pi.Vector3(e, i, n);
      return s.project(this.camera()), {
        // align relative pos to canvas dimensions
        x: (s.x + 1) * r.width / 2,
        y: -(s.y - 1) * r.height / 2
      };
    },
    getSceneCoords: function(r, e, i) {
      var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s = new pi.Vector2(e / r.width * 2 - 1, -(i / r.height) * 2 + 1), a = new pi.Raycaster();
      return a.setFromCamera(s, r.camera), Object.assign({}, a.ray.at(n, new pi.Vector3()));
    },
    intersectingObjects: function(r, e, i) {
      var n = new pi.Vector2(e / r.width * 2 - 1, -(i / r.height) * 2 + 1), s = new pi.Raycaster();
      return s.params.Line.threshold = r.lineHoverPrecision, s.params.Points.threshold = r.pointsHoverPrecision, s.setFromCamera(n, r.camera), s.intersectObjects(r.objects, !0);
    },
    renderer: function(r) {
      return r.renderer;
    },
    scene: function(r) {
      return r.scene;
    },
    camera: function(r) {
      return r.camera;
    },
    postProcessingComposer: function(r) {
      return r.postProcessingComposer;
    },
    controls: function(r) {
      return r.controls;
    },
    tbControls: function(r) {
      return r.controls;
    }
    // to be deprecated
  },
  stateInit: function() {
    return {
      scene: new pi.Scene(),
      camera: new pi.PerspectiveCamera(),
      clock: new pi.Clock(),
      tweenGroup: new Z1()
    };
  },
  init: function(r, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = i.controlType, s = n === void 0 ? "trackball" : n, a = i.useWebGPU, o = a === void 0 ? !1 : a, l = i.rendererConfig, u = l === void 0 ? {} : l, c = i.extraRenderers, h = c === void 0 ? [] : c, d = i.waitForLoadComplete, p = d === void 0 ? !0 : d;
    r.innerHTML = "", r.appendChild(e.container = document.createElement("div")), e.container.className = "scene-container", e.container.style.position = "relative", e.container.appendChild(e.navInfo = document.createElement("div")), e.navInfo.className = "scene-nav-info", e.navInfo.textContent = {
      orbit: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      trackball: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      fly: "WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw"
    }[s] || "", e.navInfo.style.display = e.showNavInfo ? null : "none", e.tooltip = new qI(e.container), e.pointerPos = new pi.Vector2(), e.pointerPos.x = -2, e.pointerPos.y = -2, ["pointermove", "pointerdown"].forEach(function(f) {
      return e.container.addEventListener(f, function(m) {
        if (f === "pointerdown" && (e.isPointerPressed = !0), !e.isPointerDragging && m.type === "pointermove" && (m.pressure > 0 || e.isPointerPressed) && (m.pointerType !== "touch" || m.movementX === void 0 || [m.movementX, m.movementY].some(function(g) {
          return Math.abs(g) > 1;
        })) && (e.isPointerDragging = !0), e.enablePointerInteraction) {
          var y = v(e.container);
          e.pointerPos.x = m.pageX - y.left, e.pointerPos.y = m.pageY - y.top;
        }
        function v(g) {
          var _ = g.getBoundingClientRect(), x = window.pageXOffset || document.documentElement.scrollLeft, b = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: _.top + b,
            left: _.left + x
          };
        }
      }, {
        passive: !0
      });
    }), e.container.addEventListener("pointerup", function(f) {
      e.isPointerPressed = !1, !(e.isPointerDragging && (e.isPointerDragging = !1, !e.clickAfterDrag)) && requestAnimationFrame(function() {
        f.button === 0 && e.onClick(e.hoverObj || null, f, e.intersection), f.button === 2 && e.onRightClick && e.onRightClick(e.hoverObj || null, f, e.intersection);
      });
    }, {
      passive: !0,
      capture: !0
    }), e.container.addEventListener("contextmenu", function(f) {
      e.onRightClick && f.preventDefault();
    }), e.renderer = new (o ? MJ : pi.WebGLRenderer)(Object.assign({
      antialias: !0,
      alpha: !0
    }, u)), e.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio)), e.container.appendChild(e.renderer.domElement), e.extraRenderers = h, e.extraRenderers.forEach(function(f) {
      f.domElement.style.position = "absolute", f.domElement.style.top = "0px", f.domElement.style.pointerEvents = "none", e.container.appendChild(f.domElement);
    }), e.postProcessingComposer = new bee(e.renderer), e.postProcessingComposer.addPass(new xee(e.scene, e.camera)), e.controls = new {
      trackball: CJ,
      orbit: HJ,
      fly: nee
    }[s](e.camera, e.renderer.domElement), s === "fly" && (e.controls.movementSpeed = 300, e.controls.rollSpeed = Math.PI / 6, e.controls.dragToLook = !0), (s === "trackball" || s === "orbit") && (e.controls.minDistance = 0.1, e.controls.maxDistance = e.skyRadius, e.controls.addEventListener("start", function() {
      e.controlsEngaged = !0;
    }), e.controls.addEventListener("change", function() {
      e.controlsEngaged && (e.controlsDragging = !0);
    }), e.controls.addEventListener("end", function() {
      e.controlsEngaged = !1, e.controlsDragging = !1;
    })), [e.renderer, e.postProcessingComposer].concat(Bo(e.extraRenderers)).forEach(function(f) {
      return f.setSize(e.width, e.height);
    }), e.camera.aspect = e.width / e.height, e.camera.updateProjectionMatrix(), e.camera.position.z = 1e3, e.scene.add(e.skysphere = new pi.Mesh()), e.skysphere.visible = !1, e.loadComplete = e.scene.visible = !p, window.scene = e.scene;
  },
  update: function(r, e) {
    if (r.width && r.height && (e.hasOwnProperty("width") || e.hasOwnProperty("height"))) {
      var i, n = r.width, s = r.height;
      r.container.style.width = "".concat(n, "px"), r.container.style.height = "".concat(s, "px"), [r.renderer, r.postProcessingComposer].concat(Bo(r.extraRenderers)).forEach(function(p) {
        return p.setSize(n, s);
      }), r.camera.aspect = n / s;
      var a = r.viewOffset.slice(0, 2);
      a.some(function(p) {
        return p;
      }) && (i = r.camera).setViewOffset.apply(i, [n, s].concat(Bo(a), [n, s])), r.camera.updateProjectionMatrix();
    }
    if (e.hasOwnProperty("viewOffset")) {
      var o, l = r.width, u = r.height, c = r.viewOffset.slice(0, 2);
      c.some(function(p) {
        return p;
      }) ? (o = r.camera).setViewOffset.apply(o, [l, u].concat(Bo(c), [l, u])) : r.camera.clearViewOffset();
    }
    if (e.hasOwnProperty("skyRadius") && r.skyRadius && (r.controls.hasOwnProperty("maxDistance") && e.skyRadius && (r.controls.maxDistance = Math.min(r.controls.maxDistance, r.skyRadius)), r.camera.far = r.skyRadius * 2.5, r.camera.updateProjectionMatrix(), r.skysphere.geometry = new pi.SphereGeometry(r.skyRadius)), e.hasOwnProperty("backgroundColor")) {
      var h = Ac(r.backgroundColor).alpha;
      h === void 0 && (h = 1), r.renderer.setClearColor(new pi.Color(Jee(1, r.backgroundColor)), h);
    }
    e.hasOwnProperty("backgroundImageUrl") && (r.backgroundImageUrl ? new pi.TextureLoader().load(r.backgroundImageUrl, function(p) {
      p.colorSpace = pi.SRGBColorSpace, r.skysphere.material = new pi.MeshBasicMaterial({
        map: p,
        side: pi.BackSide
      }), r.skysphere.visible = !0, r.onBackgroundImageLoaded && setTimeout(r.onBackgroundImageLoaded), !r.loadComplete && d();
    }) : (r.skysphere.visible = !1, r.skysphere.material.map = null, !r.loadComplete && d())), e.hasOwnProperty("showNavInfo") && (r.navInfo.style.display = r.showNavInfo ? null : "none"), e.hasOwnProperty("lights") && ((e.lights || []).forEach(function(p) {
      return r.scene.remove(p);
    }), r.lights.forEach(function(p) {
      return r.scene.add(p);
    })), e.hasOwnProperty("objects") && ((e.objects || []).forEach(function(p) {
      return r.scene.remove(p);
    }), r.objects.forEach(function(p) {
      return r.scene.add(p);
    }));
    function d() {
      r.loadComplete = r.scene.visible = !0;
    }
  }
});
function vre(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var bre = `.graph-info-msg {
  top: 50%;
  width: 100%;
  text-align: center;
  color: lavender;
  opacity: 0.7;
  font-size: 22px;
  position: absolute;
  font-family: Sans-serif;
}

.scene-container .clickable {
  cursor: pointer;
}

.scene-container .grabbable {
  cursor: move;
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

.scene-container .grabbable:active {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
}`;
vre(bre);
function Hx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function xre(r) {
  if (Array.isArray(r)) return Hx(r);
}
function sp(r, e, i) {
  return (e = Sre(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function _re(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function Tre() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function OM(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function Of(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? OM(Object(i), !0).forEach(function(n) {
      sp(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : OM(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function Kg(r) {
  return xre(r) || _re(r) || Ere(r) || Tre();
}
function wre(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Sre(r) {
  var e = wre(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Ere(r, e) {
  if (r) {
    if (typeof r == "string") return Hx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Hx(r, e) : void 0;
  }
}
function KI(r, e) {
  var i = new e();
  return i._destructor && i._destructor(), {
    linkProp: function(n) {
      return {
        default: i[n](),
        onChange: function(s, a) {
          a[r][n](s);
        },
        triggerUpdate: !1
      };
    },
    linkMethod: function(n) {
      return function(s) {
        for (var a = s[r], o = arguments.length, l = new Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)
          l[u - 1] = arguments[u];
        var c = a[n].apply(a, l);
        return c === a ? this : c;
      };
    }
  };
}
var Sv = window.THREE ? window.THREE : {
  AmbientLight: i8,
  DirectionalLight: t8,
  REVISION: yg
}, Mre = 170, ZI = KI("forceGraph", Ou), Are = Object.assign.apply(Object, Kg(["jsonUrl", "graphData", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeVisibility", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "forceEngine", "d3AlphaDecay", "d3VelocityDecay", "d3AlphaMin", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(r) {
  return sp({}, r, ZI.linkProp(r));
}))), Cre = Object.assign.apply(Object, Kg(["refresh", "getGraphBbox", "d3Force", "d3ReheatSimulation", "emitParticle"].map(function(r) {
  return sp({}, r, ZI.linkMethod(r));
}))), cm = KI("renderObjs", YI), Rre = Object.assign.apply(Object, Kg(["width", "height", "backgroundColor", "showNavInfo", "enablePointerInteraction"].map(function(r) {
  return sp({}, r, cm.linkProp(r));
}))), Nre = Object.assign.apply(Object, Kg(["lights", "cameraPosition", "postProcessingComposer"].map(function(r) {
  return sp({}, r, cm.linkMethod(r));
})).concat([{
  graph2ScreenCoords: cm.linkMethod("getScreenCoords"),
  screen2GraphCoords: cm.linkMethod("getSceneCoords")
}])), Pre = Pl({
  props: Of(Of({
    nodeLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkHoverPrecision: {
      default: 1,
      onChange: function(r, e) {
        return e.renderObjs.lineHoverPrecision(r);
      },
      triggerUpdate: !1
    },
    enableNavigationControls: {
      default: !0,
      onChange: function(r, e) {
        var i = e.renderObjs.controls();
        i && (i.enabled = r, r && i.domElement && i.domElement.dispatchEvent(new PointerEvent("pointerup")));
      },
      triggerUpdate: !1
    },
    enableNodeDrag: {
      default: !0,
      triggerUpdate: !1
    },
    onNodeDrag: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeDragEnd: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeClick: {
      triggerUpdate: !1
    },
    onNodeRightClick: {
      triggerUpdate: !1
    },
    onNodeHover: {
      triggerUpdate: !1
    },
    onLinkClick: {
      triggerUpdate: !1
    },
    onLinkRightClick: {
      triggerUpdate: !1
    },
    onLinkHover: {
      triggerUpdate: !1
    },
    onBackgroundClick: {
      triggerUpdate: !1
    },
    onBackgroundRightClick: {
      triggerUpdate: !1
    }
  }, Are), Rre),
  methods: Of(Of({
    zoomToFit: function(r, e, i) {
      for (var n, s = arguments.length, a = new Array(s > 3 ? s - 3 : 0), o = 3; o < s; o++)
        a[o - 3] = arguments[o];
      return r.renderObjs.fitToBbox((n = r.forceGraph).getGraphBbox.apply(n, a), e, i), this;
    },
    pauseAnimation: function(r) {
      return r.animationFrameRequestId !== null && (cancelAnimationFrame(r.animationFrameRequestId), r.animationFrameRequestId = null), this;
    },
    resumeAnimation: function(r) {
      return r.animationFrameRequestId === null && this._animationCycle(), this;
    },
    _animationCycle: function(r) {
      r.enablePointerInteraction && (this.renderer().domElement.style.cursor = null), r.forceGraph.tickFrame(), r.renderObjs.tick(), r.animationFrameRequestId = requestAnimationFrame(this._animationCycle);
    },
    scene: function(r) {
      return r.renderObjs.scene();
    },
    // Expose scene
    camera: function(r) {
      return r.renderObjs.camera();
    },
    // Expose camera
    renderer: function(r) {
      return r.renderObjs.renderer();
    },
    // Expose renderer
    controls: function(r) {
      return r.renderObjs.controls();
    },
    // Expose controls
    tbControls: function(r) {
      return r.renderObjs.tbControls();
    },
    // To be deprecated
    _destructor: function() {
      this.pauseAnimation(), this.graphData({
        nodes: [],
        links: []
      });
    }
  }, Cre), Nre),
  stateInit: function(r) {
    var e = r.controlType, i = r.rendererConfig, n = r.extraRenderers, s = new Ou();
    return {
      forceGraph: s,
      renderObjs: YI({
        controlType: e,
        rendererConfig: i,
        extraRenderers: n
      }).objects([s]).lights([new Sv.AmbientLight(13421772, Math.PI), new Sv.DirectionalLight(16777215, 0.6 * Math.PI)])
    };
  },
  init: function(r, e) {
    r.innerHTML = "", r.appendChild(e.container = document.createElement("div")), e.container.style.position = "relative";
    var i = document.createElement("div");
    e.container.appendChild(i), e.renderObjs(i);
    var n = e.renderObjs.camera(), s = e.renderObjs.renderer(), a = e.renderObjs.controls();
    a.enabled = !!e.enableNavigationControls, e.lastSetCameraZ = n.position.z;
    var o;
    e.container.appendChild(o = document.createElement("div")), o.className = "graph-info-msg", o.textContent = "", e.forceGraph.onLoading(function() {
      o.textContent = "Loading...";
    }).onFinishLoading(function() {
      o.textContent = "";
    }).onUpdate(function() {
      e.graphData = e.forceGraph.graphData(), n.position.x === 0 && n.position.y === 0 && n.position.z === e.lastSetCameraZ && e.graphData.nodes.length && (n.lookAt(e.forceGraph.position), e.lastSetCameraZ = n.position.z = Math.cbrt(e.graphData.nodes.length) * Mre);
    }).onFinishUpdate(function() {
      if (e._dragControls) {
        var l = e.graphData.nodes.find(function(c) {
          return c.__initialFixedPos && !c.__disposeControlsAfterDrag;
        });
        l ? l.__disposeControlsAfterDrag = !0 : e._dragControls.dispose(), e._dragControls = void 0;
      }
      if (e.enableNodeDrag && e.enablePointerInteraction && e.forceEngine === "d3") {
        var u = e._dragControls = new EH(e.graphData.nodes.map(function(c) {
          return c.__threeObj;
        }).filter(function(c) {
          return c;
        }), n, s.domElement);
        u.addEventListener("dragstart", function(c) {
          var h = Bs(c.object);
          if (h) {
            a.enabled = !1, c.object.__initialPos = c.object.position.clone(), c.object.__prevPos = c.object.position.clone();
            var d = h.__data;
            !d.__initialFixedPos && (d.__initialFixedPos = {
              fx: d.fx,
              fy: d.fy,
              fz: d.fz
            }), !d.__initialPos && (d.__initialPos = {
              x: d.x,
              y: d.y,
              z: d.z
            }), ["x", "y", "z"].forEach(function(p) {
              return d["f".concat(p)] = d[p];
            }), s.domElement.classList.add("grabbable");
          }
        }), u.addEventListener("drag", function(c) {
          var h = Bs(c.object);
          if (h) {
            if (!c.object.hasOwnProperty("__graphObjType")) {
              var d = c.object.__initialPos, p = c.object.__prevPos, f = c.object.position;
              h.position.add(f.clone().sub(p)), p.copy(f), f.copy(d);
            }
            var m = h.__data, y = h.position, v = {
              x: y.x - m.x,
              y: y.y - m.y,
              z: y.z - m.z
            };
            ["x", "y", "z"].forEach(function(g) {
              return m["f".concat(g)] = m[g] = y[g];
            }), e.forceGraph.d3AlphaTarget(0.3).resetCountdown(), m.__dragged = !0, e.onNodeDrag(m, v);
          }
        }), u.addEventListener("dragend", function(c) {
          var h = Bs(c.object);
          if (h) {
            delete c.object.__initialPos, delete c.object.__prevPos;
            var d = h.__data;
            d.__disposeControlsAfterDrag && (u.dispose(), delete d.__disposeControlsAfterDrag);
            var p = d.__initialFixedPos, f = d.__initialPos, m = {
              x: f.x - d.x,
              y: f.y - d.y,
              z: f.z - d.z
            };
            p && (["x", "y", "z"].forEach(function(y) {
              var v = "f".concat(y);
              p[v] === void 0 && delete d[v];
            }), delete d.__initialFixedPos, delete d.__initialPos, d.__dragged && (delete d.__dragged, e.onNodeDragEnd(d, m))), e.forceGraph.d3AlphaTarget(0).resetCountdown(), e.enableNavigationControls && (a.enabled = !0, a.domElement && a.domElement.ownerDocument && a.domElement.ownerDocument.dispatchEvent(
              // simulate mouseup to ensure the controls don't take over after dragend
              new PointerEvent("pointerup", {
                pointerType: "touch"
              })
            )), s.domElement.classList.remove("grabbable");
          }
        });
      }
    }), Sv.REVISION < 155 && (e.renderObjs.renderer().useLegacyLights = !1), e.renderObjs.hoverOrderComparator(function(l, u) {
      var c = Bs(l);
      if (!c) return 1;
      var h = Bs(u);
      if (!h) return -1;
      var d = function(p) {
        return p.__graphObjType === "node";
      };
      return d(h) - d(c);
    }).tooltipContent(function(l) {
      var u = Bs(l);
      return u && tt(e["".concat(u.__graphObjType, "Label")])(u.__data) || "";
    }).hoverDuringDrag(!1).onHover(function(l) {
      var u = Bs(l);
      if (u !== e.hoverObj) {
        var c = e.hoverObj ? e.hoverObj.__graphObjType : null, h = e.hoverObj ? e.hoverObj.__data : null, d = u ? u.__graphObjType : null, p = u ? u.__data : null;
        if (c && c !== d) {
          var f = e["on".concat(c === "node" ? "Node" : "Link", "Hover")];
          f && f(null, h);
        }
        if (d) {
          var m = e["on".concat(d === "node" ? "Node" : "Link", "Hover")];
          m && m(p, c === d ? h : null);
        }
        s.domElement.classList[u && e["on".concat(d === "node" ? "Node" : "Link", "Click")] || !u && e.onBackgroundClick ? "add" : "remove"]("clickable"), e.hoverObj = u;
      }
    }).clickAfterDrag(!1).onClick(function(l, u) {
      var c = Bs(l);
      if (c) {
        var h = e["on".concat(c.__graphObjType === "node" ? "Node" : "Link", "Click")];
        h && h(c.__data, u);
      } else
        e.onBackgroundClick && e.onBackgroundClick(u);
    }).onRightClick(function(l, u) {
      var c = Bs(l);
      if (c) {
        var h = e["on".concat(c.__graphObjType === "node" ? "Node" : "Link", "RightClick")];
        h && h(c.__data, u);
      } else
        e.onBackgroundRightClick && e.onBackgroundRightClick(u);
    }), this._animationCycle();
  }
});
function Bs(r) {
  for (var e = r; e && !e.hasOwnProperty("__graphObjType"); )
    e = e.parent;
  return e;
}
const Ire = { passive: !1 }, Nd = { capture: !0, passive: !1 };
function Ev(r) {
  r.stopImmediatePropagation();
}
function tc(r) {
  r.preventDefault(), r.stopImmediatePropagation();
}
function QI(r) {
  var e = r.document.documentElement, i = bn(r).on("dragstart.drag", tc, Nd);
  "onselectstart" in e ? i.on("selectstart.drag", tc, Nd) : (e.__noselect = e.style.MozUserSelect, e.style.MozUserSelect = "none");
}
function $I(r, e) {
  var i = r.document.documentElement, n = bn(r).on("dragstart.drag", null);
  e && (n.on("click.drag", tc, Nd), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in i ? n.on("selectstart.drag", null) : (i.style.MozUserSelect = i.__noselect, delete i.__noselect);
}
const Df = (r) => () => r;
function Wx(r, {
  sourceEvent: e,
  subject: i,
  target: n,
  identifier: s,
  active: a,
  x: o,
  y: l,
  dx: u,
  dy: c,
  dispatch: h
}) {
  Object.defineProperties(this, {
    type: { value: r, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    subject: { value: i, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    identifier: { value: s, enumerable: !0, configurable: !0 },
    active: { value: a, enumerable: !0, configurable: !0 },
    x: { value: o, enumerable: !0, configurable: !0 },
    y: { value: l, enumerable: !0, configurable: !0 },
    dx: { value: u, enumerable: !0, configurable: !0 },
    dy: { value: c, enumerable: !0, configurable: !0 },
    _: { value: h }
  });
}
Wx.prototype.on = function() {
  var r = this._.on.apply(this._, arguments);
  return r === this._ ? this : r;
};
function Ore(r) {
  return !r.ctrlKey && !r.button;
}
function Dre() {
  return this.parentNode;
}
function Lre(r, e) {
  return e ?? { x: r.x, y: r.y };
}
function kre() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Ure() {
  var r = Ore, e = Dre, i = Lre, n = kre, s = {}, a = Hd("start", "drag", "end"), o = 0, l, u, c, h, d = 0;
  function p(b) {
    b.on("mousedown.drag", f).filter(n).on("touchstart.drag", v).on("touchmove.drag", g, Ire).on("touchend.drag touchcancel.drag", _).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function f(b, T) {
    if (!(h || !r.call(this, b, T))) {
      var E = x(this, e.call(this, b, T), b, T, "mouse");
      E && (bn(b.view).on("mousemove.drag", m, Nd).on("mouseup.drag", y, Nd), QI(b.view), Ev(b), c = !1, l = b.clientX, u = b.clientY, E("start", b));
    }
  }
  function m(b) {
    if (tc(b), !c) {
      var T = b.clientX - l, E = b.clientY - u;
      c = T * T + E * E > d;
    }
    s.mouse("drag", b);
  }
  function y(b) {
    bn(b.view).on("mousemove.drag mouseup.drag", null), $I(b.view, c), tc(b), s.mouse("end", b);
  }
  function v(b, T) {
    if (r.call(this, b, T)) {
      var E = b.changedTouches, M = e.call(this, b, T), C = E.length, S, w;
      for (S = 0; S < C; ++S)
        (w = x(this, M, b, T, E[S].identifier, E[S])) && (Ev(b), w("start", b, E[S]));
    }
  }
  function g(b) {
    var T = b.changedTouches, E = T.length, M, C;
    for (M = 0; M < E; ++M)
      (C = s[T[M].identifier]) && (tc(b), C("drag", b, T[M]));
  }
  function _(b) {
    var T = b.changedTouches, E = T.length, M, C;
    for (h && clearTimeout(h), h = setTimeout(function() {
      h = null;
    }, 500), M = 0; M < E; ++M)
      (C = s[T[M].identifier]) && (Ev(b), C("end", b, T[M]));
  }
  function x(b, T, E, M, C, S) {
    var w = a.copy(), R = as(S || E, T), O, P, A;
    if ((A = i.call(b, new Wx("beforestart", {
      sourceEvent: E,
      target: p,
      identifier: C,
      active: o,
      x: R[0],
      y: R[1],
      dx: 0,
      dy: 0,
      dispatch: w
    }), M)) != null)
      return O = A.x - R[0] || 0, P = A.y - R[1] || 0, function D(L, H, V) {
        var X = R, F;
        switch (L) {
          case "start":
            s[C] = D, F = o++;
            break;
          case "end":
            delete s[C], --o;
          case "drag":
            R = as(V || H, T), F = o;
            break;
        }
        w.call(
          L,
          b,
          new Wx(L, {
            sourceEvent: H,
            subject: A,
            target: p,
            identifier: C,
            active: F,
            x: R[0] + O,
            y: R[1] + P,
            dx: R[0] - X[0],
            dy: R[1] - X[1],
            dispatch: w
          }),
          M
        );
      };
  }
  return p.filter = function(b) {
    return arguments.length ? (r = typeof b == "function" ? b : Df(!!b), p) : r;
  }, p.container = function(b) {
    return arguments.length ? (e = typeof b == "function" ? b : Df(b), p) : e;
  }, p.subject = function(b) {
    return arguments.length ? (i = typeof b == "function" ? b : Df(b), p) : i;
  }, p.touchable = function(b) {
    return arguments.length ? (n = typeof b == "function" ? b : Df(!!b), p) : n;
  }, p.on = function() {
    var b = a.on.apply(a, arguments);
    return b === a ? p : b;
  }, p.clickDistance = function(b) {
    return arguments.length ? (d = (b = +b) * b, p) : Math.sqrt(d);
  }, p;
}
var Fre = Hd("start", "end", "cancel", "interrupt"), Bre = [], JI = 0, DM = 1, qx = 2, hm = 3, LM = 4, Xx = 5, dm = 6;
function Zg(r, e, i, n, s, a) {
  var o = r.__transition;
  if (!o) r.__transition = {};
  else if (i in o) return;
  zre(r, i, {
    name: e,
    index: n,
    // For context during callback.
    group: s,
    // For context during callback.
    on: Fre,
    tween: Bre,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: JI
  });
}
function rT(r, e) {
  var i = ts(r, e);
  if (i.state > JI) throw new Error("too late; already scheduled");
  return i;
}
function Es(r, e) {
  var i = ts(r, e);
  if (i.state > hm) throw new Error("too late; already running");
  return i;
}
function ts(r, e) {
  var i = r.__transition;
  if (!i || !(i = i[e])) throw new Error("transition not found");
  return i;
}
function zre(r, e, i) {
  var n = r.__transition, s;
  n[e] = i, i.timer = q_(a, 0, i.time);
  function a(c) {
    i.state = DM, i.timer.restart(o, i.delay, i.time), i.delay <= c && o(c - i.delay);
  }
  function o(c) {
    var h, d, p, f;
    if (i.state !== DM) return u();
    for (h in n)
      if (f = n[h], f.name === i.name) {
        if (f.state === hm) return BS(o);
        f.state === LM ? (f.state = dm, f.timer.stop(), f.on.call("interrupt", r, r.__data__, f.index, f.group), delete n[h]) : +h < e && (f.state = dm, f.timer.stop(), f.on.call("cancel", r, r.__data__, f.index, f.group), delete n[h]);
      }
    if (BS(function() {
      i.state === hm && (i.state = LM, i.timer.restart(l, i.delay, i.time), l(c));
    }), i.state = qx, i.on.call("start", r, r.__data__, i.index, i.group), i.state === qx) {
      for (i.state = hm, s = new Array(p = i.tween.length), h = 0, d = -1; h < p; ++h)
        (f = i.tween[h].value.call(r, r.__data__, i.index, i.group)) && (s[++d] = f);
      s.length = d + 1;
    }
  }
  function l(c) {
    for (var h = c < i.duration ? i.ease.call(null, c / i.duration) : (i.timer.restart(u), i.state = Xx, 1), d = -1, p = s.length; ++d < p; )
      s[d].call(r, h);
    i.state === Xx && (i.on.call("end", r, r.__data__, i.index, i.group), u());
  }
  function u() {
    i.state = dm, i.timer.stop(), delete n[e];
    for (var c in n) return;
    delete r.__transition;
  }
}
function pm(r, e) {
  var i = r.__transition, n, s, a = !0, o;
  if (i) {
    e = e == null ? null : e + "";
    for (o in i) {
      if ((n = i[o]).name !== e) {
        a = !1;
        continue;
      }
      s = n.state > qx && n.state < Xx, n.state = dm, n.timer.stop(), n.on.call(s ? "interrupt" : "cancel", r, r.__data__, n.index, n.group), delete i[o];
    }
    a && delete r.__transition;
  }
}
function jre(r) {
  return this.each(function() {
    pm(this, r);
  });
}
function Vre(r, e) {
  var i, n;
  return function() {
    var s = Es(this, r), a = s.tween;
    if (a !== i) {
      n = i = a;
      for (var o = 0, l = n.length; o < l; ++o)
        if (n[o].name === e) {
          n = n.slice(), n.splice(o, 1);
          break;
        }
    }
    s.tween = n;
  };
}
function Gre(r, e, i) {
  var n, s;
  if (typeof i != "function") throw new Error();
  return function() {
    var a = Es(this, r), o = a.tween;
    if (o !== n) {
      s = (n = o).slice();
      for (var l = { name: e, value: i }, u = 0, c = s.length; u < c; ++u)
        if (s[u].name === e) {
          s[u] = l;
          break;
        }
      u === c && s.push(l);
    }
    a.tween = s;
  };
}
function Hre(r, e) {
  var i = this._id;
  if (r += "", arguments.length < 2) {
    for (var n = ts(this.node(), i).tween, s = 0, a = n.length, o; s < a; ++s)
      if ((o = n[s]).name === r)
        return o.value;
    return null;
  }
  return this.each((e == null ? Vre : Gre)(i, r, e));
}
function nT(r, e, i) {
  var n = r._id;
  return r.each(function() {
    var s = Es(this, n);
    (s.value || (s.value = {}))[e] = i.apply(this, arguments);
  }), function(s) {
    return ts(s, n).value[e];
  };
}
function eO(r, e) {
  var i;
  return (typeof e == "number" ? Ka : e instanceof md ? cE : (i = md(e)) ? (e = i, cE) : y9)(r, e);
}
function Wre(r) {
  return function() {
    this.removeAttribute(r);
  };
}
function qre(r) {
  return function() {
    this.removeAttributeNS(r.space, r.local);
  };
}
function Xre(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = this.getAttribute(r);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function Yre(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = this.getAttributeNS(r.space, r.local);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function Kre(r, e, i) {
  var n, s, a;
  return function() {
    var o, l = i(this), u;
    return l == null ? void this.removeAttribute(r) : (o = this.getAttribute(r), u = l + "", o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l)));
  };
}
function Zre(r, e, i) {
  var n, s, a;
  return function() {
    var o, l = i(this), u;
    return l == null ? void this.removeAttributeNS(r.space, r.local) : (o = this.getAttributeNS(r.space, r.local), u = l + "", o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l)));
  };
}
function Qre(r, e) {
  var i = qg(r), n = i === "transform" ? _9 : eO;
  return this.attrTween(r, typeof e == "function" ? (i.local ? Zre : Kre)(i, n, nT(this, "attr." + r, e)) : e == null ? (i.local ? qre : Wre)(i) : (i.local ? Yre : Xre)(i, n, e));
}
function $re(r, e) {
  return function(i) {
    this.setAttribute(r, e.call(this, i));
  };
}
function Jre(r, e) {
  return function(i) {
    this.setAttributeNS(r.space, r.local, e.call(this, i));
  };
}
function ene(r, e) {
  var i, n;
  function s() {
    var a = e.apply(this, arguments);
    return a !== n && (i = (n = a) && Jre(r, a)), i;
  }
  return s._value = e, s;
}
function tne(r, e) {
  var i, n;
  function s() {
    var a = e.apply(this, arguments);
    return a !== n && (i = (n = a) && $re(r, a)), i;
  }
  return s._value = e, s;
}
function ine(r, e) {
  var i = "attr." + r;
  if (arguments.length < 2) return (i = this.tween(i)) && i._value;
  if (e == null) return this.tween(i, null);
  if (typeof e != "function") throw new Error();
  var n = qg(r);
  return this.tween(i, (n.local ? ene : tne)(n, e));
}
function rne(r, e) {
  return function() {
    rT(this, r).delay = +e.apply(this, arguments);
  };
}
function nne(r, e) {
  return e = +e, function() {
    rT(this, r).delay = e;
  };
}
function sne(r) {
  var e = this._id;
  return arguments.length ? this.each((typeof r == "function" ? rne : nne)(e, r)) : ts(this.node(), e).delay;
}
function ane(r, e) {
  return function() {
    Es(this, r).duration = +e.apply(this, arguments);
  };
}
function one(r, e) {
  return e = +e, function() {
    Es(this, r).duration = e;
  };
}
function lne(r) {
  var e = this._id;
  return arguments.length ? this.each((typeof r == "function" ? ane : one)(e, r)) : ts(this.node(), e).duration;
}
function une(r, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    Es(this, r).ease = e;
  };
}
function cne(r) {
  var e = this._id;
  return arguments.length ? this.each(une(e, r)) : ts(this.node(), e).ease;
}
function hne(r, e) {
  return function() {
    var i = e.apply(this, arguments);
    if (typeof i != "function") throw new Error();
    Es(this, r).ease = i;
  };
}
function dne(r) {
  if (typeof r != "function") throw new Error();
  return this.each(hne(this._id, r));
}
function pne(r) {
  typeof r != "function" && (r = wI(r));
  for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s)
    for (var a = e[s], o = a.length, l = n[s] = [], u, c = 0; c < o; ++c)
      (u = a[c]) && r.call(u, u.__data__, c, a) && l.push(u);
  return new Ta(n, this._parents, this._name, this._id);
}
function fne(r) {
  if (r._id !== this._id) throw new Error();
  for (var e = this._groups, i = r._groups, n = e.length, s = i.length, a = Math.min(n, s), o = new Array(n), l = 0; l < a; ++l)
    for (var u = e[l], c = i[l], h = u.length, d = o[l] = new Array(h), p, f = 0; f < h; ++f)
      (p = u[f] || c[f]) && (d[f] = p);
  for (; l < n; ++l)
    o[l] = e[l];
  return new Ta(o, this._parents, this._name, this._id);
}
function mne(r) {
  return (r + "").trim().split(/^|\s+/).every(function(e) {
    var i = e.indexOf(".");
    return i >= 0 && (e = e.slice(0, i)), !e || e === "start";
  });
}
function gne(r, e, i) {
  var n, s, a = mne(e) ? rT : Es;
  return function() {
    var o = a(this, r), l = o.on;
    l !== n && (s = (n = l).copy()).on(e, i), o.on = s;
  };
}
function yne(r, e) {
  var i = this._id;
  return arguments.length < 2 ? ts(this.node(), i).on.on(r) : this.each(gne(i, r, e));
}
function vne(r) {
  return function() {
    var e = this.parentNode;
    for (var i in this.__transition) if (+i !== r) return;
    e && e.removeChild(this);
  };
}
function bne() {
  return this.on("end.remove", vne(this._id));
}
function xne(r) {
  var e = this._name, i = this._id;
  typeof r != "function" && (r = Q1(r));
  for (var n = this._groups, s = n.length, a = new Array(s), o = 0; o < s; ++o)
    for (var l = n[o], u = l.length, c = a[o] = new Array(u), h, d, p = 0; p < u; ++p)
      (h = l[p]) && (d = r.call(h, h.__data__, p, l)) && ("__data__" in h && (d.__data__ = h.__data__), c[p] = d, Zg(c[p], e, i, p, c, ts(h, i)));
  return new Ta(a, this._parents, e, i);
}
function _ne(r) {
  var e = this._name, i = this._id;
  typeof r != "function" && (r = TI(r));
  for (var n = this._groups, s = n.length, a = [], o = [], l = 0; l < s; ++l)
    for (var u = n[l], c = u.length, h, d = 0; d < c; ++d)
      if (h = u[d]) {
        for (var p = r.call(h, h.__data__, d, u), f, m = ts(h, i), y = 0, v = p.length; y < v; ++y)
          (f = p[y]) && Zg(f, e, i, y, p, m);
        a.push(p), o.push(h);
      }
  return new Ta(a, o, e, i);
}
var Tne = rp.prototype.constructor;
function wne() {
  return new Tne(this._groups, this._parents);
}
function Sne(r, e) {
  var i, n, s;
  return function() {
    var a = Cc(this, r), o = (this.style.removeProperty(r), Cc(this, r));
    return a === o ? null : a === i && o === n ? s : s = e(i = a, n = o);
  };
}
function tO(r) {
  return function() {
    this.style.removeProperty(r);
  };
}
function Ene(r, e, i) {
  var n, s = i + "", a;
  return function() {
    var o = Cc(this, r);
    return o === s ? null : o === n ? a : a = e(n = o, i);
  };
}
function Mne(r, e, i) {
  var n, s, a;
  return function() {
    var o = Cc(this, r), l = i(this), u = l + "";
    return l == null && (u = l = (this.style.removeProperty(r), Cc(this, r))), o === u ? null : o === n && u === s ? a : (s = u, a = e(n = o, l));
  };
}
function Ane(r, e) {
  var i, n, s, a = "style." + e, o = "end." + a, l;
  return function() {
    var u = Es(this, r), c = u.on, h = u.value[a] == null ? l || (l = tO(e)) : void 0;
    (c !== i || s !== h) && (n = (i = c).copy()).on(o, s = h), u.on = n;
  };
}
function Cne(r, e, i) {
  var n = (r += "") == "transform" ? x9 : eO;
  return e == null ? this.styleTween(r, Sne(r, n)).on("end.style." + r, tO(r)) : typeof e == "function" ? this.styleTween(r, Mne(r, n, nT(this, "style." + r, e))).each(Ane(this._id, r)) : this.styleTween(r, Ene(r, n, e), i).on("end.style." + r, null);
}
function Rne(r, e, i) {
  return function(n) {
    this.style.setProperty(r, e.call(this, n), i);
  };
}
function Nne(r, e, i) {
  var n, s;
  function a() {
    var o = e.apply(this, arguments);
    return o !== s && (n = (s = o) && Rne(r, o, i)), n;
  }
  return a._value = e, a;
}
function Pne(r, e, i) {
  var n = "style." + (r += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  return this.tween(n, Nne(r, e, i ?? ""));
}
function Ine(r) {
  return function() {
    this.textContent = r;
  };
}
function One(r) {
  return function() {
    var e = r(this);
    this.textContent = e ?? "";
  };
}
function Dne(r) {
  return this.tween("text", typeof r == "function" ? One(nT(this, "text", r)) : Ine(r == null ? "" : r + ""));
}
function Lne(r) {
  return function(e) {
    this.textContent = r.call(this, e);
  };
}
function kne(r) {
  var e, i;
  function n() {
    var s = r.apply(this, arguments);
    return s !== i && (e = (i = s) && Lne(s)), e;
  }
  return n._value = r, n;
}
function Une(r) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (r == null) return this.tween(e, null);
  if (typeof r != "function") throw new Error();
  return this.tween(e, kne(r));
}
function Fne() {
  for (var r = this._name, e = this._id, i = iO(), n = this._groups, s = n.length, a = 0; a < s; ++a)
    for (var o = n[a], l = o.length, u, c = 0; c < l; ++c)
      if (u = o[c]) {
        var h = ts(u, e);
        Zg(u, r, i, c, o, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new Ta(n, this._parents, r, i);
}
function Bne() {
  var r, e, i = this, n = i._id, s = i.size();
  return new Promise(function(a, o) {
    var l = { value: o }, u = { value: function() {
      --s === 0 && a();
    } };
    i.each(function() {
      var c = Es(this, n), h = c.on;
      h !== r && (e = (r = h).copy(), e._.cancel.push(l), e._.interrupt.push(l), e._.end.push(u)), c.on = e;
    }), s === 0 && a();
  });
}
var zne = 0;
function Ta(r, e, i, n) {
  this._groups = r, this._parents = e, this._name = i, this._id = n;
}
function iO() {
  return ++zne;
}
var zs = rp.prototype;
Ta.prototype = {
  constructor: Ta,
  select: xne,
  selectAll: _ne,
  selectChild: zs.selectChild,
  selectChildren: zs.selectChildren,
  filter: pne,
  merge: fne,
  selection: wne,
  transition: Fne,
  call: zs.call,
  nodes: zs.nodes,
  node: zs.node,
  size: zs.size,
  empty: zs.empty,
  each: zs.each,
  on: yne,
  attr: Qre,
  attrTween: ine,
  style: Cne,
  styleTween: Pne,
  text: Dne,
  textTween: Une,
  remove: bne,
  tween: Hre,
  delay: sne,
  duration: lne,
  ease: cne,
  easeVarying: dne,
  end: Bne,
  [Symbol.iterator]: zs[Symbol.iterator]
};
function jne(r) {
  return ((r *= 2) <= 1 ? r * r * r : (r -= 2) * r * r + 2) / 2;
}
var Vne = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: jne
};
function Gne(r, e) {
  for (var i; !(i = r.__transition) || !(i = i[e]); )
    if (!(r = r.parentNode))
      throw new Error(`transition ${e} not found`);
  return i;
}
function Hne(r) {
  var e, i;
  r instanceof Ta ? (e = r._id, r = r._name) : (e = iO(), (i = Vne).time = W_(), r = r == null ? null : r + "");
  for (var n = this._groups, s = n.length, a = 0; a < s; ++a)
    for (var o = n[a], l = o.length, u, c = 0; c < l; ++c)
      (u = o[c]) && Zg(u, r, e, c, o, i || Gne(u, e));
  return new Ta(n, this._parents, r, e);
}
rp.prototype.interrupt = jre;
rp.prototype.transition = Hne;
const Lf = (r) => () => r;
function Wne(r, {
  sourceEvent: e,
  target: i,
  transform: n,
  dispatch: s
}) {
  Object.defineProperties(this, {
    type: { value: r, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    target: { value: i, enumerable: !0, configurable: !0 },
    transform: { value: n, enumerable: !0, configurable: !0 },
    _: { value: s }
  });
}
function aa(r, e, i) {
  this.k = r, this.x = e, this.y = i;
}
aa.prototype = {
  constructor: aa,
  scale: function(r) {
    return r === 1 ? this : new aa(this.k * r, this.x, this.y);
  },
  translate: function(r, e) {
    return r === 0 & e === 0 ? this : new aa(this.k, this.x + this.k * r, this.y + this.k * e);
  },
  apply: function(r) {
    return [r[0] * this.k + this.x, r[1] * this.k + this.y];
  },
  applyX: function(r) {
    return r * this.k + this.x;
  },
  applyY: function(r) {
    return r * this.k + this.y;
  },
  invert: function(r) {
    return [(r[0] - this.x) / this.k, (r[1] - this.y) / this.k];
  },
  invertX: function(r) {
    return (r - this.x) / this.k;
  },
  invertY: function(r) {
    return (r - this.y) / this.k;
  },
  rescaleX: function(r) {
    return r.copy().domain(r.range().map(this.invertX, this).map(r.invert, r));
  },
  rescaleY: function(r) {
    return r.copy().domain(r.range().map(this.invertY, this).map(r.invert, r));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var sT = new aa(1, 0, 0);
ss.prototype = aa.prototype;
function ss(r) {
  for (; !r.__zoom; ) if (!(r = r.parentNode)) return sT;
  return r.__zoom;
}
function Mv(r) {
  r.stopImmediatePropagation();
}
function Rh(r) {
  r.preventDefault(), r.stopImmediatePropagation();
}
function qne(r) {
  return (!r.ctrlKey || r.type === "wheel") && !r.button;
}
function Xne() {
  var r = this;
  return r instanceof SVGElement ? (r = r.ownerSVGElement || r, r.hasAttribute("viewBox") ? (r = r.viewBox.baseVal, [[r.x, r.y], [r.x + r.width, r.y + r.height]]) : [[0, 0], [r.width.baseVal.value, r.height.baseVal.value]]) : [[0, 0], [r.clientWidth, r.clientHeight]];
}
function kM() {
  return this.__zoom || sT;
}
function Yne(r) {
  return -r.deltaY * (r.deltaMode === 1 ? 0.05 : r.deltaMode ? 1 : 2e-3) * (r.ctrlKey ? 10 : 1);
}
function Kne() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Zne(r, e, i) {
  var n = r.invertX(e[0][0]) - i[0][0], s = r.invertX(e[1][0]) - i[1][0], a = r.invertY(e[0][1]) - i[0][1], o = r.invertY(e[1][1]) - i[1][1];
  return r.translate(
    s > n ? (n + s) / 2 : Math.min(0, n) || Math.max(0, s),
    o > a ? (a + o) / 2 : Math.min(0, a) || Math.max(0, o)
  );
}
function Qne() {
  var r = qne, e = Xne, i = Zne, n = Yne, s = Kne, a = [0, 1 / 0], o = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], l = 250, u = E9, c = Hd("start", "zoom", "end"), h, d, p, f = 500, m = 150, y = 0, v = 10;
  function g(A) {
    A.property("__zoom", kM).on("wheel.zoom", C, { passive: !1 }).on("mousedown.zoom", S).on("dblclick.zoom", w).filter(s).on("touchstart.zoom", R).on("touchmove.zoom", O).on("touchend.zoom touchcancel.zoom", P).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  g.transform = function(A, D, L, H) {
    var V = A.selection ? A.selection() : A;
    V.property("__zoom", kM), A !== V ? T(A, D, L, H) : V.interrupt().each(function() {
      E(this, arguments).event(H).start().zoom(null, typeof D == "function" ? D.apply(this, arguments) : D).end();
    });
  }, g.scaleBy = function(A, D, L, H) {
    g.scaleTo(A, function() {
      var V = this.__zoom.k, X = typeof D == "function" ? D.apply(this, arguments) : D;
      return V * X;
    }, L, H);
  }, g.scaleTo = function(A, D, L, H) {
    g.transform(A, function() {
      var V = e.apply(this, arguments), X = this.__zoom, F = L == null ? b(V) : typeof L == "function" ? L.apply(this, arguments) : L, B = X.invert(F), W = typeof D == "function" ? D.apply(this, arguments) : D;
      return i(x(_(X, W), F, B), V, o);
    }, L, H);
  }, g.translateBy = function(A, D, L, H) {
    g.transform(A, function() {
      return i(this.__zoom.translate(
        typeof D == "function" ? D.apply(this, arguments) : D,
        typeof L == "function" ? L.apply(this, arguments) : L
      ), e.apply(this, arguments), o);
    }, null, H);
  }, g.translateTo = function(A, D, L, H, V) {
    g.transform(A, function() {
      var X = e.apply(this, arguments), F = this.__zoom, B = H == null ? b(X) : typeof H == "function" ? H.apply(this, arguments) : H;
      return i(sT.translate(B[0], B[1]).scale(F.k).translate(
        typeof D == "function" ? -D.apply(this, arguments) : -D,
        typeof L == "function" ? -L.apply(this, arguments) : -L
      ), X, o);
    }, H, V);
  };
  function _(A, D) {
    return D = Math.max(a[0], Math.min(a[1], D)), D === A.k ? A : new aa(D, A.x, A.y);
  }
  function x(A, D, L) {
    var H = D[0] - L[0] * A.k, V = D[1] - L[1] * A.k;
    return H === A.x && V === A.y ? A : new aa(A.k, H, V);
  }
  function b(A) {
    return [(+A[0][0] + +A[1][0]) / 2, (+A[0][1] + +A[1][1]) / 2];
  }
  function T(A, D, L, H) {
    A.on("start.zoom", function() {
      E(this, arguments).event(H).start();
    }).on("interrupt.zoom end.zoom", function() {
      E(this, arguments).event(H).end();
    }).tween("zoom", function() {
      var V = this, X = arguments, F = E(V, X).event(H), B = e.apply(V, X), W = L == null ? b(B) : typeof L == "function" ? L.apply(V, X) : L, G = Math.max(B[1][0] - B[0][0], B[1][1] - B[0][1]), z = V.__zoom, K = typeof D == "function" ? D.apply(V, X) : D, ne = u(z.invert(W).concat(G / z.k), K.invert(W).concat(G / K.k));
      return function(oe) {
        if (oe === 1) oe = K;
        else {
          var pe = ne(oe), xe = G / pe[2];
          oe = new aa(xe, W[0] - pe[0] * xe, W[1] - pe[1] * xe);
        }
        F.zoom(null, oe);
      };
    });
  }
  function E(A, D, L) {
    return !L && A.__zooming || new M(A, D);
  }
  function M(A, D) {
    this.that = A, this.args = D, this.active = 0, this.sourceEvent = null, this.extent = e.apply(A, D), this.taps = 0;
  }
  M.prototype = {
    event: function(A) {
      return A && (this.sourceEvent = A), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(A, D) {
      return this.mouse && A !== "mouse" && (this.mouse[1] = D.invert(this.mouse[0])), this.touch0 && A !== "touch" && (this.touch0[1] = D.invert(this.touch0[0])), this.touch1 && A !== "touch" && (this.touch1[1] = D.invert(this.touch1[0])), this.that.__zoom = D, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(A) {
      var D = bn(this.that).datum();
      c.call(
        A,
        this.that,
        new Wne(A, {
          sourceEvent: this.sourceEvent,
          target: g,
          transform: this.that.__zoom,
          dispatch: c
        }),
        D
      );
    }
  };
  function C(A, ...D) {
    if (!r.apply(this, arguments)) return;
    var L = E(this, D).event(A), H = this.__zoom, V = Math.max(a[0], Math.min(a[1], H.k * Math.pow(2, n.apply(this, arguments)))), X = as(A);
    if (L.wheel)
      (L.mouse[0][0] !== X[0] || L.mouse[0][1] !== X[1]) && (L.mouse[1] = H.invert(L.mouse[0] = X)), clearTimeout(L.wheel);
    else {
      if (H.k === V) return;
      L.mouse = [X, H.invert(X)], pm(this), L.start();
    }
    Rh(A), L.wheel = setTimeout(F, m), L.zoom("mouse", i(x(_(H, V), L.mouse[0], L.mouse[1]), L.extent, o));
    function F() {
      L.wheel = null, L.end();
    }
  }
  function S(A, ...D) {
    if (p || !r.apply(this, arguments)) return;
    var L = A.currentTarget, H = E(this, D, !0).event(A), V = bn(A.view).on("mousemove.zoom", W, !0).on("mouseup.zoom", G, !0), X = as(A, L), F = A.clientX, B = A.clientY;
    QI(A.view), Mv(A), H.mouse = [X, this.__zoom.invert(X)], pm(this), H.start();
    function W(z) {
      if (Rh(z), !H.moved) {
        var K = z.clientX - F, ne = z.clientY - B;
        H.moved = K * K + ne * ne > y;
      }
      H.event(z).zoom("mouse", i(x(H.that.__zoom, H.mouse[0] = as(z, L), H.mouse[1]), H.extent, o));
    }
    function G(z) {
      V.on("mousemove.zoom mouseup.zoom", null), $I(z.view, H.moved), Rh(z), H.event(z).end();
    }
  }
  function w(A, ...D) {
    if (r.apply(this, arguments)) {
      var L = this.__zoom, H = as(A.changedTouches ? A.changedTouches[0] : A, this), V = L.invert(H), X = L.k * (A.shiftKey ? 0.5 : 2), F = i(x(_(L, X), H, V), e.apply(this, D), o);
      Rh(A), l > 0 ? bn(this).transition().duration(l).call(T, F, H, A) : bn(this).call(g.transform, F, H, A);
    }
  }
  function R(A, ...D) {
    if (r.apply(this, arguments)) {
      var L = A.touches, H = L.length, V = E(this, D, A.changedTouches.length === H).event(A), X, F, B, W;
      for (Mv(A), F = 0; F < H; ++F)
        B = L[F], W = as(B, this), W = [W, this.__zoom.invert(W), B.identifier], V.touch0 ? !V.touch1 && V.touch0[2] !== W[2] && (V.touch1 = W, V.taps = 0) : (V.touch0 = W, X = !0, V.taps = 1 + !!h);
      h && (h = clearTimeout(h)), X && (V.taps < 2 && (d = W[0], h = setTimeout(function() {
        h = null;
      }, f)), pm(this), V.start());
    }
  }
  function O(A, ...D) {
    if (this.__zooming) {
      var L = E(this, D).event(A), H = A.changedTouches, V = H.length, X, F, B, W;
      for (Rh(A), X = 0; X < V; ++X)
        F = H[X], B = as(F, this), L.touch0 && L.touch0[2] === F.identifier ? L.touch0[0] = B : L.touch1 && L.touch1[2] === F.identifier && (L.touch1[0] = B);
      if (F = L.that.__zoom, L.touch1) {
        var G = L.touch0[0], z = L.touch0[1], K = L.touch1[0], ne = L.touch1[1], oe = (oe = K[0] - G[0]) * oe + (oe = K[1] - G[1]) * oe, pe = (pe = ne[0] - z[0]) * pe + (pe = ne[1] - z[1]) * pe;
        F = _(F, Math.sqrt(oe / pe)), B = [(G[0] + K[0]) / 2, (G[1] + K[1]) / 2], W = [(z[0] + ne[0]) / 2, (z[1] + ne[1]) / 2];
      } else if (L.touch0) B = L.touch0[0], W = L.touch0[1];
      else return;
      L.zoom("touch", i(x(F, B, W), L.extent, o));
    }
  }
  function P(A, ...D) {
    if (this.__zooming) {
      var L = E(this, D).event(A), H = A.changedTouches, V = H.length, X, F;
      for (Mv(A), p && clearTimeout(p), p = setTimeout(function() {
        p = null;
      }, f), X = 0; X < V; ++X)
        F = H[X], L.touch0 && L.touch0[2] === F.identifier ? delete L.touch0 : L.touch1 && L.touch1[2] === F.identifier && delete L.touch1;
      if (L.touch1 && !L.touch0 && (L.touch0 = L.touch1, delete L.touch1), L.touch0) L.touch0[1] = this.__zoom.invert(L.touch0[0]);
      else if (L.end(), L.taps === 2 && (F = as(F, this), Math.hypot(d[0] - F[0], d[1] - F[1]) < v)) {
        var B = bn(this).on("dblclick.zoom");
        B && B.apply(this, arguments);
      }
    }
  }
  return g.wheelDelta = function(A) {
    return arguments.length ? (n = typeof A == "function" ? A : Lf(+A), g) : n;
  }, g.filter = function(A) {
    return arguments.length ? (r = typeof A == "function" ? A : Lf(!!A), g) : r;
  }, g.touchable = function(A) {
    return arguments.length ? (s = typeof A == "function" ? A : Lf(!!A), g) : s;
  }, g.extent = function(A) {
    return arguments.length ? (e = typeof A == "function" ? A : Lf([[+A[0][0], +A[0][1]], [+A[1][0], +A[1][1]]]), g) : e;
  }, g.scaleExtent = function(A) {
    return arguments.length ? (a[0] = +A[0], a[1] = +A[1], g) : [a[0], a[1]];
  }, g.translateExtent = function(A) {
    return arguments.length ? (o[0][0] = +A[0][0], o[1][0] = +A[1][0], o[0][1] = +A[0][1], o[1][1] = +A[1][1], g) : [[o[0][0], o[0][1]], [o[1][0], o[1][1]]];
  }, g.constrain = function(A) {
    return arguments.length ? (i = A, g) : i;
  }, g.duration = function(A) {
    return arguments.length ? (l = +A, g) : l;
  }, g.interpolate = function(A) {
    return arguments.length ? (u = A, g) : u;
  }, g.on = function() {
    var A = c.on.apply(c, arguments);
    return A === c ? g : A;
  }, g.clickDistance = function(A) {
    return arguments.length ? (y = (A = +A) * A, g) : Math.sqrt(y);
  }, g.tapDistance = function(A) {
    return arguments.length ? (v = +A, g) : v;
  }, g;
}
var $ne = "Expected a function";
function Jne(r, e, i) {
  var n = !0, s = !0;
  if (typeof r != "function")
    throw new TypeError($ne);
  return Em(i) && (n = "leading" in i ? !!i.leading : n, s = "trailing" in i ? !!i.trailing : s), cN(r, e, {
    leading: n,
    maxWait: e,
    trailing: s
  });
}
function Yx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function ese(r) {
  if (Array.isArray(r)) return Yx(r);
}
function rO(r, e, i) {
  if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : i;
  throw new TypeError("Private element is not present on this object");
}
function tse(r, e) {
  if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function ise(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function fn(r, e) {
  return r.get(rO(r, e));
}
function UM(r, e, i) {
  tse(r, e), e.set(r, i);
}
function FM(r, e, i) {
  return r.set(rO(r, e), i), i;
}
function rse(r, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, use(n.key), n);
  }
}
function nse(r, e, i) {
  return e && rse(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function sse(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function ase() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ose(r) {
  return ese(r) || sse(r) || cse(r) || ase();
}
function lse(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function use(r) {
  var e = lse(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function cse(r, e) {
  if (r) {
    if (typeof r == "string") return Yx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Yx(r, e) : void 0;
  }
}
var hse = 123, dse = function(r) {
  return "#".concat(Math.min(r, Math.pow(2, 24)).toString(16).padStart(6, "0"));
}, nO = function(r, e, i) {
  return (r << 16) + (e << 8) + i;
}, pse = function(r) {
  var e = rt(r).toRgb(), i = e.r, n = e.g, s = e.b;
  return nO(i, n, s);
}, BM = function(r, e) {
  return r * hse % Math.pow(2, e);
}, zo = /* @__PURE__ */ new WeakMap(), js = /* @__PURE__ */ new WeakMap(), fse = /* @__PURE__ */ function() {
  function r() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6;
    ise(this, r), UM(this, zo, void 0), UM(this, js, void 0), FM(js, this, e), this.reset();
  }
  return nse(r, [{
    key: "reset",
    value: function() {
      FM(zo, this, ["__reserved for background__"]);
    }
  }, {
    key: "register",
    value: function(e) {
      if (fn(zo, this).length >= Math.pow(2, 24 - fn(js, this)))
        return null;
      var i = fn(zo, this).length, n = BM(i, fn(js, this)), s = dse(i + (n << 24 - fn(js, this)));
      return fn(zo, this).push(e), s;
    }
  }, {
    key: "lookup",
    value: function(e) {
      if (!e) return null;
      var i = typeof e == "string" ? pse(e) : nO.apply(void 0, ose(e));
      if (!i) return null;
      var n = i & Math.pow(2, 24 - fn(js, this)) - 1, s = i >> 24 - fn(js, this) & Math.pow(2, fn(js, this)) - 1;
      return BM(n, fn(js, this)) !== s || n >= fn(zo, this).length ? null : fn(zo, this)[n];
    }
    // How many bits to reserve for checksum. Will eat away into the usable size of the registry.
  }]);
}();
const { abs: Nh, cos: Vs, sin: Eu, acos: mse, atan2: Ph, sqrt: qa, pow: mn } = Math;
function Ih(r) {
  return r < 0 ? -mn(-r, 1 / 3) : mn(r, 1 / 3);
}
const sO = Math.PI, kf = 2 * sO, Xa = sO / 2, gse = 1e-6, Av = Number.MAX_SAFE_INTEGER || 9007199254740991, Cv = Number.MIN_SAFE_INTEGER || -9007199254740991, yse = { x: 0, y: 0, z: 0 }, Oe = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(r, e) {
    const i = e(r);
    let n = i.x * i.x + i.y * i.y;
    return typeof i.z < "u" && (n += i.z * i.z), qa(n);
  },
  compute: function(r, e, i) {
    if (r === 0)
      return e[0].t = 0, e[0];
    const n = e.length - 1;
    if (r === 1)
      return e[n].t = 1, e[n];
    const s = 1 - r;
    let a = e;
    if (n === 0)
      return e[0].t = r, e[0];
    if (n === 1) {
      const l = {
        x: s * a[0].x + r * a[1].x,
        y: s * a[0].y + r * a[1].y,
        t: r
      };
      return i && (l.z = s * a[0].z + r * a[1].z), l;
    }
    if (n < 4) {
      let l = s * s, u = r * r, c, h, d, p = 0;
      n === 2 ? (a = [a[0], a[1], a[2], yse], c = l, h = s * r * 2, d = u) : n === 3 && (c = l * s, h = l * r * 3, d = s * u * 3, p = r * u);
      const f = {
        x: c * a[0].x + h * a[1].x + d * a[2].x + p * a[3].x,
        y: c * a[0].y + h * a[1].y + d * a[2].y + p * a[3].y,
        t: r
      };
      return i && (f.z = c * a[0].z + h * a[1].z + d * a[2].z + p * a[3].z), f;
    }
    const o = JSON.parse(JSON.stringify(e));
    for (; o.length > 1; ) {
      for (let l = 0; l < o.length - 1; l++)
        o[l] = {
          x: o[l].x + (o[l + 1].x - o[l].x) * r,
          y: o[l].y + (o[l + 1].y - o[l].y) * r
        }, typeof o[l].z < "u" && (o[l].z = o[l].z + (o[l + 1].z - o[l].z) * r);
      o.splice(o.length - 1, 1);
    }
    return o[0].t = r, o[0];
  },
  computeWithRatios: function(r, e, i, n) {
    const s = 1 - r, a = i, o = e;
    let l = a[0], u = a[1], c = a[2], h = a[3], d;
    if (l *= s, u *= r, o.length === 2)
      return d = l + u, {
        x: (l * o[0].x + u * o[1].x) / d,
        y: (l * o[0].y + u * o[1].y) / d,
        z: n ? (l * o[0].z + u * o[1].z) / d : !1,
        t: r
      };
    if (l *= s, u *= 2 * s, c *= r * r, o.length === 3)
      return d = l + u + c, {
        x: (l * o[0].x + u * o[1].x + c * o[2].x) / d,
        y: (l * o[0].y + u * o[1].y + c * o[2].y) / d,
        z: n ? (l * o[0].z + u * o[1].z + c * o[2].z) / d : !1,
        t: r
      };
    if (l *= s, u *= 1.5 * s, c *= 3 * s, h *= r * r * r, o.length === 4)
      return d = l + u + c + h, {
        x: (l * o[0].x + u * o[1].x + c * o[2].x + h * o[3].x) / d,
        y: (l * o[0].y + u * o[1].y + c * o[2].y + h * o[3].y) / d,
        z: n ? (l * o[0].z + u * o[1].z + c * o[2].z + h * o[3].z) / d : !1,
        t: r
      };
  },
  derive: function(r, e) {
    const i = [];
    for (let n = r, s = n.length, a = s - 1; s > 1; s--, a--) {
      const o = [];
      for (let l = 0, u; l < a; l++)
        u = {
          x: a * (n[l + 1].x - n[l].x),
          y: a * (n[l + 1].y - n[l].y)
        }, e && (u.z = a * (n[l + 1].z - n[l].z)), o.push(u);
      i.push(o), n = o;
    }
    return i;
  },
  between: function(r, e, i) {
    return e <= r && r <= i || Oe.approximately(r, e) || Oe.approximately(r, i);
  },
  approximately: function(r, e, i) {
    return Nh(r - e) <= (i || gse);
  },
  length: function(r) {
    const e = Oe.Tvalues.length;
    let i = 0;
    for (let n = 0, s; n < e; n++)
      s = 0.5 * Oe.Tvalues[n] + 0.5, i += Oe.Cvalues[n] * Oe.arcfn(s, r);
    return 0.5 * i;
  },
  map: function(r, e, i, n, s) {
    const a = i - e, o = s - n, l = r - e, u = l / a;
    return n + o * u;
  },
  lerp: function(r, e, i) {
    const n = {
      x: e.x + r * (i.x - e.x),
      y: e.y + r * (i.y - e.y)
    };
    return e.z !== void 0 && i.z !== void 0 && (n.z = e.z + r * (i.z - e.z)), n;
  },
  pointToString: function(r) {
    let e = r.x + "/" + r.y;
    return typeof r.z < "u" && (e += "/" + r.z), e;
  },
  pointsToString: function(r) {
    return "[" + r.map(Oe.pointToString).join(", ") + "]";
  },
  copy: function(r) {
    return JSON.parse(JSON.stringify(r));
  },
  angle: function(r, e, i) {
    const n = e.x - r.x, s = e.y - r.y, a = i.x - r.x, o = i.y - r.y, l = n * o - s * a, u = n * a + s * o;
    return Ph(l, u);
  },
  // round as string, to avoid rounding errors
  round: function(r, e) {
    const i = "" + r, n = i.indexOf(".");
    return parseFloat(i.substring(0, n + 1 + e));
  },
  dist: function(r, e) {
    const i = r.x - e.x, n = r.y - e.y;
    return qa(i * i + n * n);
  },
  closest: function(r, e) {
    let i = mn(2, 63), n, s;
    return r.forEach(function(a, o) {
      s = Oe.dist(e, a), s < i && (i = s, n = o);
    }), { mdist: i, mpos: n };
  },
  abcratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const i = mn(r, e) + mn(1 - r, e), n = i - 1;
    return Nh(n / i);
  },
  projectionratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const i = mn(1 - r, e), n = mn(r, e) + i;
    return i / n;
  },
  lli8: function(r, e, i, n, s, a, o, l) {
    const u = (r * n - e * i) * (s - o) - (r - i) * (s * l - a * o), c = (r * n - e * i) * (a - l) - (e - n) * (s * l - a * o), h = (r - i) * (a - l) - (e - n) * (s - o);
    return h == 0 ? !1 : { x: u / h, y: c / h };
  },
  lli4: function(r, e, i, n) {
    const s = r.x, a = r.y, o = e.x, l = e.y, u = i.x, c = i.y, h = n.x, d = n.y;
    return Oe.lli8(s, a, o, l, u, c, h, d);
  },
  lli: function(r, e) {
    return Oe.lli4(r, r.c, e, e.c);
  },
  makeline: function(r, e) {
    return new oi(
      r.x,
      r.y,
      (r.x + e.x) / 2,
      (r.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(r) {
    let e = Av, i = Av, n = Cv, s = Cv;
    return r.forEach(function(a) {
      const o = a.bbox();
      e > o.x.min && (e = o.x.min), i > o.y.min && (i = o.y.min), n < o.x.max && (n = o.x.max), s < o.y.max && (s = o.y.max);
    }), {
      x: { min: e, mid: (e + n) / 2, max: n, size: n - e },
      y: { min: i, mid: (i + s) / 2, max: s, size: s - i }
    };
  },
  shapeintersections: function(r, e, i, n, s) {
    if (!Oe.bboxoverlap(e, n)) return [];
    const a = [], o = [r.startcap, r.forward, r.back, r.endcap], l = [i.startcap, i.forward, i.back, i.endcap];
    return o.forEach(function(u) {
      u.virtual || l.forEach(function(c) {
        if (c.virtual) return;
        const h = u.intersects(c, s);
        h.length > 0 && (h.c1 = u, h.c2 = c, h.s1 = r, h.s2 = i, a.push(h));
      });
    }), a;
  },
  makeshape: function(r, e, i) {
    const n = e.points.length, s = r.points.length, a = Oe.makeline(e.points[n - 1], r.points[0]), o = Oe.makeline(r.points[s - 1], e.points[0]), l = {
      startcap: a,
      forward: r,
      back: e,
      endcap: o,
      bbox: Oe.findbbox([a, r, e, o])
    };
    return l.intersections = function(u) {
      return Oe.shapeintersections(
        l,
        l.bbox,
        u,
        u.bbox,
        i
      );
    }, l;
  },
  getminmax: function(r, e, i) {
    if (!i) return { min: 0, max: 0 };
    let n = Av, s = Cv, a, o;
    i.indexOf(0) === -1 && (i = [0].concat(i)), i.indexOf(1) === -1 && i.push(1);
    for (let l = 0, u = i.length; l < u; l++)
      a = i[l], o = r.get(a), o[e] < n && (n = o[e]), o[e] > s && (s = o[e]);
    return { min: n, mid: (n + s) / 2, max: s, size: s - n };
  },
  align: function(r, e) {
    const i = e.p1.x, n = e.p1.y, s = -Ph(e.p2.y - n, e.p2.x - i), a = function(o) {
      return {
        x: (o.x - i) * Vs(s) - (o.y - n) * Eu(s),
        y: (o.x - i) * Eu(s) + (o.y - n) * Vs(s)
      };
    };
    return r.map(a);
  },
  roots: function(r, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const i = r.length - 1, n = Oe.align(r, e), s = function(M) {
      return 0 <= M && M <= 1;
    };
    if (i === 2) {
      const M = n[0].y, C = n[1].y, S = n[2].y, w = M - 2 * C + S;
      if (w !== 0) {
        const R = -qa(C * C - M * S), O = -M + C, P = -(R + O) / w, A = -(-R + O) / w;
        return [P, A].filter(s);
      } else if (C !== S && w === 0)
        return [(2 * C - S) / (2 * C - 2 * S)].filter(s);
      return [];
    }
    const a = n[0].y, o = n[1].y, l = n[2].y, u = n[3].y;
    let c = -a + 3 * o - 3 * l + u, h = 3 * a - 6 * o + 3 * l, d = -3 * a + 3 * o, p = a;
    if (Oe.approximately(c, 0)) {
      if (Oe.approximately(h, 0))
        return Oe.approximately(d, 0) ? [] : [-p / d].filter(s);
      const M = qa(d * d - 4 * h * p), C = 2 * h;
      return [(M - d) / C, (-d - M) / C].filter(s);
    }
    h /= c, d /= c, p /= c;
    const f = (3 * d - h * h) / 3, m = f / 3, y = (2 * h * h * h - 9 * h * d + 27 * p) / 27, v = y / 2, g = v * v + m * m * m;
    let _, x, b, T, E;
    if (g < 0) {
      const M = -f / 3, C = M * M * M, S = qa(C), w = -y / (2 * S), R = w < -1 ? -1 : w > 1 ? 1 : w, O = mse(R), P = Ih(S), A = 2 * P;
      return b = A * Vs(O / 3) - h / 3, T = A * Vs((O + kf) / 3) - h / 3, E = A * Vs((O + 2 * kf) / 3) - h / 3, [b, T, E].filter(s);
    } else {
      if (g === 0)
        return _ = v < 0 ? Ih(-v) : -Ih(v), b = 2 * _ - h / 3, T = -_ - h / 3, [b, T].filter(s);
      {
        const M = qa(g);
        return _ = Ih(-v + M), x = Ih(v + M), [_ - x - h / 3].filter(s);
      }
    }
  },
  droots: function(r) {
    if (r.length === 3) {
      const e = r[0], i = r[1], n = r[2], s = e - 2 * i + n;
      if (s !== 0) {
        const a = -qa(i * i - e * n), o = -e + i, l = -(a + o) / s, u = -(-a + o) / s;
        return [l, u];
      } else if (i !== n && s === 0)
        return [(2 * i - n) / (2 * (i - n))];
      return [];
    }
    if (r.length === 2) {
      const e = r[0], i = r[1];
      return e !== i ? [e / (e - i)] : [];
    }
    return [];
  },
  curvature: function(r, e, i, n, s) {
    let a, o, l, u, c = 0, h = 0;
    const d = Oe.compute(r, e), p = Oe.compute(r, i), f = d.x * d.x + d.y * d.y;
    if (n ? (a = qa(
      mn(d.y * p.z - p.y * d.z, 2) + mn(d.z * p.x - p.z * d.x, 2) + mn(d.x * p.y - p.x * d.y, 2)
    ), o = mn(f + d.z * d.z, 3 / 2)) : (a = d.x * p.y - d.y * p.x, o = mn(f, 3 / 2)), a === 0 || o === 0)
      return { k: 0, r: 0 };
    if (c = a / o, h = o / a, !s) {
      const m = Oe.curvature(r - 1e-3, e, i, n, !0).k, y = Oe.curvature(r + 1e-3, e, i, n, !0).k;
      u = (y - c + (c - m)) / 2, l = (Nh(y - c) + Nh(c - m)) / 2;
    }
    return { k: c, r: h, dk: u, adk: l };
  },
  inflections: function(r) {
    if (r.length < 4) return [];
    const e = Oe.align(r, { p1: r[0], p2: r.slice(-1)[0] }), i = e[2].x * e[1].y, n = e[3].x * e[1].y, s = e[1].x * e[2].y, a = e[3].x * e[2].y, o = 18 * (-3 * i + 2 * n + 3 * s - a), l = 18 * (3 * i - n - 3 * s), u = 18 * (s - i);
    if (Oe.approximately(o, 0)) {
      if (!Oe.approximately(l, 0)) {
        let p = -u / l;
        if (0 <= p && p <= 1) return [p];
      }
      return [];
    }
    const c = 2 * o;
    if (Oe.approximately(c, 0)) return [];
    const h = l * l - 4 * o * u;
    if (h < 0) return [];
    const d = Math.sqrt(h);
    return [(d - l) / c, -(l + d) / c].filter(function(p) {
      return 0 <= p && p <= 1;
    });
  },
  bboxoverlap: function(r, e) {
    const i = ["x", "y"], n = i.length;
    for (let s = 0, a, o, l, u; s < n; s++)
      if (a = i[s], o = r[a].mid, l = e[a].mid, u = (r[a].size + e[a].size) / 2, Nh(o - l) >= u) return !1;
    return !0;
  },
  expandbox: function(r, e) {
    e.x.min < r.x.min && (r.x.min = e.x.min), e.y.min < r.y.min && (r.y.min = e.y.min), e.z && e.z.min < r.z.min && (r.z.min = e.z.min), e.x.max > r.x.max && (r.x.max = e.x.max), e.y.max > r.y.max && (r.y.max = e.y.max), e.z && e.z.max > r.z.max && (r.z.max = e.z.max), r.x.mid = (r.x.min + r.x.max) / 2, r.y.mid = (r.y.min + r.y.max) / 2, r.z && (r.z.mid = (r.z.min + r.z.max) / 2), r.x.size = r.x.max - r.x.min, r.y.size = r.y.max - r.y.min, r.z && (r.z.size = r.z.max - r.z.min);
  },
  pairiteration: function(r, e, i) {
    const n = r.bbox(), s = e.bbox(), a = 1e5, o = i || 0.5;
    if (n.x.size + n.y.size < o && s.x.size + s.y.size < o)
      return [
        (a * (r._t1 + r._t2) / 2 | 0) / a + "/" + (a * (e._t1 + e._t2) / 2 | 0) / a
      ];
    let l = r.split(0.5), u = e.split(0.5), c = [
      { left: l.left, right: u.left },
      { left: l.left, right: u.right },
      { left: l.right, right: u.right },
      { left: l.right, right: u.left }
    ];
    c = c.filter(function(d) {
      return Oe.bboxoverlap(d.left.bbox(), d.right.bbox());
    });
    let h = [];
    return c.length === 0 || (c.forEach(function(d) {
      h = h.concat(
        Oe.pairiteration(d.left, d.right, o)
      );
    }), h = h.filter(function(d, p) {
      return h.indexOf(d) === p;
    })), h;
  },
  getccenter: function(r, e, i) {
    const n = e.x - r.x, s = e.y - r.y, a = i.x - e.x, o = i.y - e.y, l = n * Vs(Xa) - s * Eu(Xa), u = n * Eu(Xa) + s * Vs(Xa), c = a * Vs(Xa) - o * Eu(Xa), h = a * Eu(Xa) + o * Vs(Xa), d = (r.x + e.x) / 2, p = (r.y + e.y) / 2, f = (e.x + i.x) / 2, m = (e.y + i.y) / 2, y = d + l, v = p + u, g = f + c, _ = m + h, x = Oe.lli8(d, p, y, v, f, m, g, _), b = Oe.dist(x, r);
    let T = Ph(r.y - x.y, r.x - x.x), E = Ph(e.y - x.y, e.x - x.x), M = Ph(i.y - x.y, i.x - x.x), C;
    return T < M ? ((T > E || E > M) && (T += kf), T > M && (C = M, M = T, T = C)) : M < E && E < T ? (C = M, M = T, T = C) : M += kf, x.s = T, x.e = M, x.r = b, x;
  },
  numberSort: function(r, e) {
    return r - e;
  }
};
class ad {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return Oe.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, i) {
      return e + i;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var i = e[0].bbox(), n = 1; n < e.length; n++)
      Oe.expandbox(i, e[n].bbox());
    return i;
  }
  offset(e) {
    const i = [];
    return this.curves.forEach(function(n) {
      i.push(...n.offset(e));
    }), new ad(i);
  }
}
const { abs: Oh, min: zM, max: jM, cos: vse, sin: bse, acos: xse, sqrt: Dh } = Math, _se = Math.PI;
class oi {
  constructor(e) {
    let i = e && e.forEach ? e : Array.from(arguments).slice(), n = !1;
    if (typeof i[0] == "object") {
      n = i.length;
      const f = [];
      i.forEach(function(m) {
        ["x", "y", "z"].forEach(function(y) {
          typeof m[y] < "u" && f.push(m[y]);
        });
      }), i = f;
    }
    let s = !1;
    const a = i.length;
    if (n) {
      if (n > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        s = !0;
      }
    } else if (a !== 6 && a !== 8 && a !== 9 && a !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const o = this._3d = !s && (a === 9 || a === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let f = 0, m = o ? 3 : 2; f < a; f += m) {
      var u = {
        x: i[f],
        y: i[f + 1]
      };
      o && (u.z = i[f + 2]), l.push(u);
    }
    const c = this.order = l.length - 1, h = this.dims = ["x", "y"];
    o && h.push("z"), this.dimlen = h.length;
    const d = Oe.align(l, { p1: l[0], p2: l[c] }), p = Oe.dist(l[0], l[c]);
    this._linear = d.reduce((f, m) => f + Oh(m.y), 0) < p / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, i, n, s) {
    if (typeof s > "u" && (s = 0.5), s === 0)
      return new oi(i, i, n);
    if (s === 1)
      return new oi(e, i, i);
    const a = oi.getABC(2, e, i, n, s);
    return new oi(e, a.A, n);
  }
  static cubicFromPoints(e, i, n, s, a) {
    typeof s > "u" && (s = 0.5);
    const o = oi.getABC(3, e, i, n, s);
    typeof a > "u" && (a = Oe.dist(i, o.C));
    const l = a * (1 - s) / s, u = Oe.dist(e, n), c = (n.x - e.x) / u, h = (n.y - e.y) / u, d = a * c, p = a * h, f = l * c, m = l * h, y = { x: i.x - d, y: i.y - p }, v = { x: i.x + f, y: i.y + m }, g = o.A, _ = { x: g.x + (y.x - g.x) / (1 - s), y: g.y + (y.y - g.y) / (1 - s) }, x = { x: g.x + (v.x - g.x) / s, y: g.y + (v.y - g.y) / s }, b = { x: e.x + (_.x - e.x) / s, y: e.y + (_.y - e.y) / s }, T = {
      x: n.x + (x.x - n.x) / (1 - s),
      y: n.y + (x.y - n.y) / (1 - s)
    };
    return new oi(e, b, T, n);
  }
  static getUtils() {
    return Oe;
  }
  getUtils() {
    return oi.getUtils();
  }
  static get PolyBezier() {
    return ad;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return Oe.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, i = e[0].x, n = e[0].y, s = ["M", i, n, this.order === 2 ? "Q" : "C"];
    for (let a = 1, o = e.length; a < o; a++)
      s.push(e[a].x), s.push(e[a].y);
    return s.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, i) {
      return "" + i + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = Oe.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, i = Oe.angle(e[0], e[this.order], e[1]);
    this.clockwise = i > 0;
  }
  length() {
    return Oe.length(this.derivative.bind(this));
  }
  static getABC(e = 2, i, n, s, a = 0.5) {
    const o = Oe.projectionratio(a, e), l = 1 - o, u = {
      x: o * i.x + l * s.x,
      y: o * i.y + l * s.y
    }, c = Oe.abcratio(a, e);
    return { A: {
      x: n.x + (n.x - u.x) / c,
      y: n.y + (n.y - u.y) / c
    }, B: n, C: u, S: i, E: s };
  }
  getABC(e, i) {
    i = i || this.get(e);
    let n = this.points[0], s = this.points[this.order];
    return oi.getABC(this.order, n, i, s, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let i = 0, n, s; i < e; i++)
      s = i / (e - 1), n = this.compute(s), n.t = s, this._lut.push(n);
    return this._lut;
  }
  on(e, i) {
    i = i || 5;
    const n = this.getLUT(), s = [];
    for (let a = 0, o, l = 0; a < n.length; a++)
      o = n[a], Oe.dist(o, e) < i && (s.push(o), l += a / n.length);
    return s.length ? t /= s.length : !1;
  }
  project(e) {
    const i = this.getLUT(), n = i.length - 1, s = Oe.closest(i, e), a = s.mpos, o = (a - 1) / n, l = (a + 1) / n, u = 0.1 / n;
    let c = s.mdist, h = o, d = h, p;
    c += 1;
    for (let f; h < l + u; h += u)
      p = this.compute(h), f = Oe.dist(e, p), f < c && (c = f, d = h);
    return d = d < 0 ? 0 : d > 1 ? 1 : d, p = this.compute(d), p.t = d, p.d = c, p;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? Oe.computeWithRatios(e, this.points, this.ratios, this._3d) : Oe.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, i = [e[0]], n = e.length;
    for (let s = 1, a, o; s < n; s++)
      a = e[s], o = e[s - 1], i[s] = {
        x: (n - s) / n * a.x + s / n * o.x,
        y: (n - s) / n * a.y + s / n * o.y
      };
    return i[n] = e[n - 1], new oi(i);
  }
  derivative(e) {
    return Oe.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return Oe.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new oi(Oe.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return Oe.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return Oe.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const i = this.derivative(e), n = Dh(i.x * i.x + i.y * i.y);
    return { t: e, x: -i.y / n, y: i.x / n };
  }
  __normal3(e) {
    const i = this.derivative(e), n = this.derivative(e + 0.01), s = Dh(i.x * i.x + i.y * i.y + i.z * i.z), a = Dh(n.x * n.x + n.y * n.y + n.z * n.z);
    i.x /= s, i.y /= s, i.z /= s, n.x /= a, n.y /= a, n.z /= a;
    const o = {
      x: n.y * i.z - n.z * i.y,
      y: n.z * i.x - n.x * i.z,
      z: n.x * i.y - n.y * i.x
    }, l = Dh(o.x * o.x + o.y * o.y + o.z * o.z);
    o.x /= l, o.y /= l, o.z /= l;
    const u = [
      o.x * o.x,
      o.x * o.y - o.z,
      o.x * o.z + o.y,
      o.x * o.y + o.z,
      o.y * o.y,
      o.y * o.z - o.x,
      o.x * o.z - o.y,
      o.y * o.z + o.x,
      o.z * o.z
    ];
    return {
      t: e,
      x: u[0] * i.x + u[1] * i.y + u[2] * i.z,
      y: u[3] * i.x + u[4] * i.y + u[5] * i.z,
      z: u[6] * i.x + u[7] * i.y + u[8] * i.z
    };
  }
  hull(e) {
    let i = this.points, n = [], s = [], a = 0;
    for (s[a++] = i[0], s[a++] = i[1], s[a++] = i[2], this.order === 3 && (s[a++] = i[3]); i.length > 1; ) {
      n = [];
      for (let o = 0, l, u = i.length - 1; o < u; o++)
        l = Oe.lerp(e, i[o], i[o + 1]), s[a++] = l, n.push(l);
      i = n;
    }
    return s;
  }
  split(e, i) {
    if (e === 0 && i)
      return this.split(i).left;
    if (i === 1)
      return this.split(e).right;
    const n = this.hull(e), s = {
      left: this.order === 2 ? new oi([n[0], n[3], n[5]]) : new oi([n[0], n[4], n[7], n[9]]),
      right: this.order === 2 ? new oi([n[5], n[4], n[2]]) : new oi([n[9], n[8], n[6], n[3]]),
      span: n
    };
    return s.left._t1 = Oe.map(0, 0, 1, this._t1, this._t2), s.left._t2 = Oe.map(e, 0, 1, this._t1, this._t2), s.right._t1 = Oe.map(e, 0, 1, this._t1, this._t2), s.right._t2 = Oe.map(1, 0, 1, this._t1, this._t2), i ? (i = Oe.map(i, e, 1, 0, 1), s.right.split(i).left) : s;
  }
  extrema() {
    const e = {};
    let i = [];
    return this.dims.forEach(
      (function(n) {
        let s = function(o) {
          return o[n];
        }, a = this.dpoints[0].map(s);
        e[n] = Oe.droots(a), this.order === 3 && (a = this.dpoints[1].map(s), e[n] = e[n].concat(Oe.droots(a))), e[n] = e[n].filter(function(o) {
          return o >= 0 && o <= 1;
        }), i = i.concat(e[n].sort(Oe.numberSort));
      }).bind(this)
    ), e.values = i.sort(Oe.numberSort).filter(function(n, s) {
      return i.indexOf(n) === s;
    }), e;
  }
  bbox() {
    const e = this.extrema(), i = {};
    return this.dims.forEach(
      (function(n) {
        i[n] = Oe.getminmax(this, n, e[n]);
      }).bind(this)
    ), i;
  }
  overlaps(e) {
    const i = this.bbox(), n = e.bbox();
    return Oe.bboxoverlap(i, n);
  }
  offset(e, i) {
    if (typeof i < "u") {
      const n = this.get(e), s = this.normal(e), a = {
        c: n,
        n: s,
        x: n.x + s.x * i,
        y: n.y + s.y * i
      };
      return this._3d && (a.z = n.z + s.z * i), a;
    }
    if (this._linear) {
      const n = this.normal(0), s = this.points.map(function(a) {
        const o = {
          x: a.x + e * n.x,
          y: a.y + e * n.y
        };
        return a.z && n.z && (o.z = a.z + e * n.z), o;
      });
      return [new oi(s)];
    }
    return this.reduce().map(function(n) {
      return n._linear ? n.offset(e)[0] : n.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const s = Oe.angle(this.points[0], this.points[3], this.points[1]), a = Oe.angle(this.points[0], this.points[3], this.points[2]);
      if (s > 0 && a < 0 || s < 0 && a > 0) return !1;
    }
    const e = this.normal(0), i = this.normal(1);
    let n = e.x * i.x + e.y * i.y;
    return this._3d && (n += e.z * i.z), Oh(xse(n)) < _se / 3;
  }
  reduce() {
    let e, i = 0, n = 0, s = 0.01, a, o = [], l = [], u = this.extrema().values;
    for (u.indexOf(0) === -1 && (u = [0].concat(u)), u.indexOf(1) === -1 && u.push(1), i = u[0], e = 1; e < u.length; e++)
      n = u[e], a = this.split(i, n), a._t1 = i, a._t2 = n, o.push(a), i = n;
    return o.forEach(function(c) {
      for (i = 0, n = 0; n <= 1; )
        for (n = i + s; n <= 1 + s; n += s)
          if (a = c.split(i, n), !a.simple()) {
            if (n -= s, Oh(i - n) < s)
              return [];
            a = c.split(i, n), a._t1 = Oe.map(i, 0, 1, c._t1, c._t2), a._t2 = Oe.map(n, 0, 1, c._t1, c._t2), l.push(a), i = n;
            break;
          }
      i < 1 && (a = c.split(i, 1), a._t1 = Oe.map(i, 0, 1, c._t1, c._t2), a._t2 = c._t2, l.push(a));
    }), l;
  }
  translate(e, i, n) {
    n = typeof n == "number" ? n : i;
    const s = this.order;
    let a = this.points.map((o, l) => (1 - l / s) * i + l / s * n);
    return new oi(
      this.points.map((o, l) => ({
        x: o.x + e.x * a[l],
        y: o.y + e.y * a[l]
      }))
    );
  }
  scale(e) {
    const i = this.order;
    let n = !1;
    if (typeof e == "function" && (n = e), n && i === 2)
      return this.raise().scale(n);
    const s = this.clockwise, a = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        n ? n(0) : e,
        n ? n(1) : e
      );
    const o = n ? n(0) : e, l = n ? n(1) : e, u = [this.offset(0, 10), this.offset(1, 10)], c = [], h = Oe.lli4(u[0], u[0].c, u[1], u[1].c);
    if (!h)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(d) {
      const p = c[d * i] = Oe.copy(a[d * i]);
      p.x += (d ? l : o) * u[d].n.x, p.y += (d ? l : o) * u[d].n.y;
    }), n ? ([0, 1].forEach(function(d) {
      if (!(i === 2 && d)) {
        var p = a[d + 1], f = {
          x: p.x - h.x,
          y: p.y - h.y
        }, m = n ? n((d + 1) / i) : e;
        n && !s && (m = -m);
        var y = Dh(f.x * f.x + f.y * f.y);
        f.x /= y, f.y /= y, c[d + 1] = {
          x: p.x + m * f.x,
          y: p.y + m * f.y
        };
      }
    }), new oi(c)) : ([0, 1].forEach((d) => {
      if (i === 2 && d) return;
      const p = c[d * i], f = this.derivative(d), m = { x: p.x + f.x, y: p.y + f.y };
      c[d + 1] = Oe.lli4(p, m, h, a[d + 1]);
    }), new oi(c));
  }
  outline(e, i, n, s) {
    if (i = i === void 0 ? e : i, this._linear) {
      const T = this.normal(0), E = this.points[0], M = this.points[this.points.length - 1];
      let C, S, w;
      n === void 0 && (n = e, s = i), C = { x: E.x + T.x * e, y: E.y + T.y * e }, w = { x: M.x + T.x * n, y: M.y + T.y * n }, S = { x: (C.x + w.x) / 2, y: (C.y + w.y) / 2 };
      const R = [C, S, w];
      C = { x: E.x - T.x * i, y: E.y - T.y * i }, w = { x: M.x - T.x * s, y: M.y - T.y * s }, S = { x: (C.x + w.x) / 2, y: (C.y + w.y) / 2 };
      const O = [w, S, C], P = Oe.makeline(O[2], R[0]), A = Oe.makeline(R[2], O[0]), D = [P, new oi(R), A, new oi(O)];
      return new ad(D);
    }
    const a = this.reduce(), o = a.length, l = [];
    let u = [], c, h = 0, d = this.length();
    const p = typeof n < "u" && typeof s < "u";
    function f(T, E, M, C, S) {
      return function(w) {
        const R = C / M, O = (C + S) / M, P = E - T;
        return Oe.map(w, 0, 1, T + R * P, T + O * P);
      };
    }
    a.forEach(function(T) {
      const E = T.length();
      p ? (l.push(
        T.scale(f(e, n, d, h, E))
      ), u.push(
        T.scale(f(-i, -s, d, h, E))
      )) : (l.push(T.scale(e)), u.push(T.scale(-i))), h += E;
    }), u = u.map(function(T) {
      return c = T.points, c[3] ? T.points = [c[3], c[2], c[1], c[0]] : T.points = [c[2], c[1], c[0]], T;
    }).reverse();
    const m = l[0].points[0], y = l[o - 1].points[l[o - 1].points.length - 1], v = u[o - 1].points[u[o - 1].points.length - 1], g = u[0].points[0], _ = Oe.makeline(v, m), x = Oe.makeline(y, g), b = [_].concat(l).concat([x]).concat(u);
    return new ad(b);
  }
  outlineshapes(e, i, n) {
    i = i || e;
    const s = this.outline(e, i).curves, a = [];
    for (let o = 1, l = s.length; o < l / 2; o++) {
      const u = Oe.makeshape(
        s[o],
        s[l - o],
        n
      );
      u.startcap.virtual = o > 1, u.endcap.virtual = o < l / 2 - 1, a.push(u);
    }
    return a;
  }
  intersects(e, i) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof oi && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      i
    )) : this.selfintersects(i);
  }
  lineIntersects(e) {
    const i = zM(e.p1.x, e.p2.x), n = zM(e.p1.y, e.p2.y), s = jM(e.p1.x, e.p2.x), a = jM(e.p1.y, e.p2.y);
    return Oe.roots(this.points, e).filter((o) => {
      var l = this.get(o);
      return Oe.between(l.x, i, s) && Oe.between(l.y, n, a);
    });
  }
  selfintersects(e) {
    const i = this.reduce(), n = i.length - 2, s = [];
    for (let a = 0, o, l, u; a < n; a++)
      l = i.slice(a, a + 1), u = i.slice(a + 2), o = this.curveintersects(l, u, e), s.push(...o);
    return s;
  }
  curveintersects(e, i, n) {
    const s = [];
    e.forEach(function(o) {
      i.forEach(function(l) {
        o.overlaps(l) && s.push({ left: o, right: l });
      });
    });
    let a = [];
    return s.forEach(function(o) {
      const l = Oe.pairiteration(
        o.left,
        o.right,
        n
      );
      l.length > 0 && (a = a.concat(l));
    }), a;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, i, n, s) {
    const a = (s - n) / 4, o = this.get(n + a), l = this.get(s - a), u = Oe.dist(e, i), c = Oe.dist(e, o), h = Oe.dist(e, l);
    return Oh(c - u) + Oh(h - u);
  }
  _iterate(e, i) {
    let n = 0, s = 1, a;
    do {
      a = 0, s = 1;
      let o = this.get(n), l, u, c, h, d = !1, p = !1, f, m = s, y = 1;
      do
        if (p = d, h = c, m = (n + s) / 2, l = this.get(m), u = this.get(s), c = Oe.getccenter(o, l, u), c.interval = {
          start: n,
          end: s
        }, d = this._error(c, o, n, s) <= e, f = p && !d, f || (y = s), d) {
          if (s >= 1) {
            if (c.interval.end = y = 1, h = c, s > 1) {
              let v = {
                x: c.x + c.r * vse(c.e),
                y: c.y + c.r * bse(c.e)
              };
              c.e += Oe.angle({ x: c.x, y: c.y }, v, this.get(1));
            }
            break;
          }
          s = s + (s - n) / 2;
        } else
          s = m;
      while (!f && a++ < 100);
      if (a >= 100)
        break;
      h = h || c, i.push(h), n = y;
    } while (s < 1);
    return i;
  }
}
function Kx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Tse(r) {
  if (Array.isArray(r)) return r;
}
function wse(r) {
  if (Array.isArray(r)) return Kx(r);
}
function Sse(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function Ese(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function Mse() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ase() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Cse(r, e) {
  if (r == null) return {};
  var i, n, s = Rse(r, e);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(r);
    for (n = 0; n < a.length; n++) i = a[n], e.includes(i) || {}.propertyIsEnumerable.call(r, i) && (s[i] = r[i]);
  }
  return s;
}
function Rse(r, e) {
  if (r == null) return {};
  var i = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    i[n] = r[n];
  }
  return i;
}
function Nse(r, e) {
  return Tse(r) || Ese(r, e) || aO(r, e) || Mse();
}
function Pse(r) {
  return wse(r) || Sse(r) || aO(r) || Ase();
}
function Ise(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function Ose(r) {
  var e = Ise(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function aO(r, e) {
  if (r) {
    if (typeof r == "string") return Kx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Kx(r, e) : void 0;
  }
}
var Dse = function() {
  var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = (e instanceof Array ? e.length ? e : [void 0] : [e]).map(function(l) {
    return {
      keyAccessor: l,
      isProp: !(l instanceof Function)
    };
  }), a = r.reduce(function(l, u) {
    var c = l, h = u;
    return s.forEach(function(d, p) {
      var f = d.keyAccessor, m = d.isProp, y;
      if (m) {
        var v = h, g = v[f], _ = Cse(v, [f].map(Ose));
        y = g, h = _;
      } else
        y = f(h, p);
      p + 1 < s.length ? (c.hasOwnProperty(y) || (c[y] = {}), c = c[y]) : i ? (c.hasOwnProperty(y) || (c[y] = []), c[y].push(h)) : c[y] = h;
    }), l;
  }, {});
  i instanceof Function && function l(u) {
    var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    c === s.length ? Object.keys(u).forEach(function(h) {
      return u[h] = i(u[h]);
    }) : Object.values(u).forEach(function(h) {
      return l(h, c + 1);
    });
  }(a);
  var o = a;
  return n && (o = [], function l(u) {
    var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    c.length === s.length ? o.push({
      keys: c,
      vals: u
    }) : Object.entries(u).forEach(function(h) {
      var d = Nse(h, 2), p = d[0], f = d[1];
      return l(f, [].concat(Pse(c), [p]));
    });
  }(a), e instanceof Array && e.length === 0 && o.length === 1 && (o[0].keys = [])), o;
};
function Lse(r, e) {
  e === void 0 && (e = {});
  var i = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", i === "top" && n.firstChild ? n.insertBefore(s, n.firstChild) : n.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r));
  }
}
var kse = `.force-graph-container canvas {
  display: block;
  user-select: none;
  outline: none;
  -webkit-tap-highlight-color: transparent;
}

.force-graph-container .clickable {
  cursor: pointer;
}

.force-graph-container .grabbable {
  cursor: move;
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

.force-graph-container .grabbable:active {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
}
`;
Lse(kse);
function Zx(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var i = 0, n = Array(e); i < e; i++) n[i] = r[i];
  return n;
}
function Use(r) {
  if (Array.isArray(r)) return r;
}
function Fse(r) {
  if (Array.isArray(r)) return Zx(r);
}
function VM(r, e, i) {
  if (oO()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var s = new (r.bind.apply(r, n))();
  return s;
}
function Pd(r, e, i) {
  return (e = Hse(e)) in r ? Object.defineProperty(r, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = i, r;
}
function oO() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (oO = function() {
    return !!r;
  })();
}
function Bse(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function zse(r, e) {
  var i = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (i != null) {
    var n, s, a, o, l = [], u = !0, c = !1;
    try {
      if (a = (i = i.call(r)).next, e !== 0) for (; !(u = (n = a.call(i)).done) && (l.push(n.value), l.length !== e); u = !0) ;
    } catch (h) {
      c = !0, s = h;
    } finally {
      try {
        if (!u && i.return != null && (o = i.return(), Object(o) !== o)) return;
      } finally {
        if (c) throw s;
      }
    }
    return l;
  }
}
function jse() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Vse() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function GM(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function Mu(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? GM(Object(i), !0).forEach(function(n) {
      Pd(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : GM(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function od(r, e) {
  return Use(r) || zse(r, e) || lO(r, e) || jse();
}
function xn(r) {
  return Fse(r) || Bse(r) || lO(r) || Vse();
}
function Gse(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function Hse(r) {
  var e = Gse(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Qx(r) {
  "@babel/helpers - typeof";
  return Qx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Qx(r);
}
function lO(r, e) {
  if (r) {
    if (typeof r == "string") return Zx(r, e);
    var i = {}.toString.call(r).slice(8, -1);
    return i === "Object" && r.constructor && (i = r.constructor.name), i === "Map" || i === "Set" ? Array.from(r) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Zx(r, e) : void 0;
  }
}
var Wse = e1(xN);
function HM(r, e, i) {
  !e || typeof i != "string" || r.filter(function(n) {
    return !n[i];
  }).forEach(function(n) {
    n[i] = Wse(e(n));
  });
}
function qse(r, e) {
  var i = r.nodes, n = r.links, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = s.nodeFilter, o = a === void 0 ? function() {
    return !0;
  } : a, l = s.onLoopError, u = l === void 0 ? function(f) {
    throw "Invalid DAG structure! Found cycle in node path: ".concat(f.join(" -> "), ".");
  } : l, c = {};
  i.forEach(function(f) {
    return c[e(f)] = {
      data: f,
      out: [],
      depth: -1,
      skip: !o(f)
    };
  }), n.forEach(function(f) {
    var m = f.source, y = f.target, v = b(m), g = b(y);
    if (!c.hasOwnProperty(v)) throw "Missing source node with id: ".concat(v);
    if (!c.hasOwnProperty(g)) throw "Missing target node with id: ".concat(g);
    var _ = c[v], x = c[g];
    _.out.push(x);
    function b(T) {
      return Qx(T) === "object" ? e(T) : T;
    }
  });
  var h = [];
  p(Object.values(c));
  var d = Object.assign.apply(Object, [{}].concat(xn(Object.entries(c).filter(function(f) {
    var m = od(f, 2), y = m[1];
    return !y.skip;
  }).map(function(f) {
    var m = od(f, 2), y = m[0], v = m[1];
    return Pd({}, y, v.depth);
  }))));
  return d;
  function p(f) {
    for (var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, v = function() {
      var x = f[g];
      if (m.indexOf(x) !== -1) {
        var b = [].concat(xn(m.slice(m.indexOf(x))), [x]).map(function(T) {
          return e(T.data);
        });
        return h.some(function(T) {
          return T.length === b.length && T.every(function(E, M) {
            return E === b[M];
          });
        }) || (h.push(b), u(b)), 1;
      }
      y > x.depth && (x.depth = y, p(x.out, [].concat(xn(m), [x]), y + (x.skip ? 0 : 1)));
    }, g = 0, _ = f.length; g < _; g++)
      v();
  }
}
var Xse = 2, pr = function(r, e) {
  return e.onNeedsRedraw && e.onNeedsRedraw();
}, WM = function(r, e) {
  if (!e.isShadow) {
    var i = tt(e.linkDirectionalParticles);
    e.graphData.links.forEach(function(n) {
      var s = Math.round(Math.abs(i(n)));
      s ? n.__photons = xn(Array(s)).map(function() {
        return {};
      }) : delete n.__photons;
    });
  }
}, tg = Pl({
  props: {
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        e.engineRunning = !1, WM(r, e);
      }
    },
    dagMode: {
      onChange: function(r, e) {
        !r && (e.graphData.nodes || []).forEach(function(i) {
          return i.fx = i.fy = void 0;
        });
      }
    },
    dagLevelDistance: {},
    dagNodeFilter: {
      default: function(r) {
        return !0;
      }
    },
    onDagError: {
      triggerUpdate: !1
    },
    nodeRelSize: {
      default: 4,
      triggerUpdate: !1,
      onChange: pr
    },
    // area per val unit
    nodeId: {
      default: "id"
    },
    nodeVal: {
      default: "val",
      triggerUpdate: !1,
      onChange: pr
    },
    nodeColor: {
      default: "color",
      triggerUpdate: !1,
      onChange: pr
    },
    nodeAutoColorBy: {},
    nodeCanvasObject: {
      triggerUpdate: !1,
      onChange: pr
    },
    nodeCanvasObjectMode: {
      default: function() {
        return "replace";
      },
      triggerUpdate: !1,
      onChange: pr
    },
    nodeVisibility: {
      default: !0,
      triggerUpdate: !1,
      onChange: pr
    },
    linkSource: {
      default: "source"
    },
    linkTarget: {
      default: "target"
    },
    linkVisibility: {
      default: !0,
      triggerUpdate: !1,
      onChange: pr
    },
    linkColor: {
      default: "color",
      triggerUpdate: !1,
      onChange: pr
    },
    linkAutoColorBy: {},
    linkLineDash: {
      triggerUpdate: !1,
      onChange: pr
    },
    linkWidth: {
      default: 1,
      triggerUpdate: !1,
      onChange: pr
    },
    linkCurvature: {
      default: 0,
      triggerUpdate: !1,
      onChange: pr
    },
    linkCanvasObject: {
      triggerUpdate: !1,
      onChange: pr
    },
    linkCanvasObjectMode: {
      default: function() {
        return "replace";
      },
      triggerUpdate: !1,
      onChange: pr
    },
    linkDirectionalArrowLength: {
      default: 0,
      triggerUpdate: !1,
      onChange: pr
    },
    linkDirectionalArrowColor: {
      triggerUpdate: !1,
      onChange: pr
    },
    linkDirectionalArrowRelPos: {
      default: 0.5,
      triggerUpdate: !1,
      onChange: pr
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalParticles: {
      default: 0,
      triggerUpdate: !1,
      onChange: WM
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      default: 0.01,
      triggerUpdate: !1
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      default: 4,
      triggerUpdate: !1
    },
    linkDirectionalParticleColor: {
      triggerUpdate: !1
    },
    globalScale: {
      default: 1,
      triggerUpdate: !1
    },
    d3AlphaMin: {
      default: 0,
      triggerUpdate: !1
    },
    d3AlphaDecay: {
      default: 0.0228,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.alphaDecay(r);
      }
    },
    d3AlphaTarget: {
      default: 0,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.alphaTarget(r);
      }
    },
    d3VelocityDecay: {
      default: 0.4,
      triggerUpdate: !1,
      onChange: function(r, e) {
        e.forceLayout.velocityDecay(r);
      }
    },
    warmupTicks: {
      default: 0,
      triggerUpdate: !1
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {
      default: 1 / 0,
      triggerUpdate: !1
    },
    cooldownTime: {
      default: 15e3,
      triggerUpdate: !1
    },
    // ms
    onUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onFinishUpdate: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineTick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onEngineStop: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNeedsRedraw: {
      triggerUpdate: !1
    },
    isShadow: {
      default: !1,
      triggerUpdate: !1
    }
  },
  methods: {
    // Expose d3 forces for external manipulation
    d3Force: function(r, e, i) {
      return i === void 0 ? r.forceLayout.force(e) : (r.forceLayout.force(e, i), this);
    },
    d3ReheatSimulation: function(r) {
      return r.forceLayout.alpha(1), this.resetCountdown(), this;
    },
    // reset cooldown state
    resetCountdown: function(r) {
      return r.cntTicks = 0, r.startTickTime = /* @__PURE__ */ new Date(), r.engineRunning = !0, this;
    },
    isEngineRunning: function(r) {
      return !!r.engineRunning;
    },
    tickFrame: function(r) {
      return !r.isShadow && e(), n(), !r.isShadow && s(), !r.isShadow && a(), i(), this;
      function e() {
        r.engineRunning && (++r.cntTicks > r.cooldownTicks || /* @__PURE__ */ new Date() - r.startTickTime > r.cooldownTime || r.d3AlphaMin > 0 && r.forceLayout.alpha() < r.d3AlphaMin ? (r.engineRunning = !1, r.onEngineStop()) : (r.forceLayout.tick(), r.onEngineTick()));
      }
      function i() {
        var o = tt(r.nodeVisibility), l = tt(r.nodeVal), u = tt(r.nodeColor), c = tt(r.nodeCanvasObjectMode), h = r.ctx, d = r.isShadow / r.globalScale, p = r.graphData.nodes.filter(o);
        h.save(), p.forEach(function(f) {
          var m = c(f);
          if (r.nodeCanvasObject && (m === "before" || m === "replace") && (r.nodeCanvasObject(f, h, r.globalScale), m === "replace")) {
            h.restore();
            return;
          }
          var y = Math.sqrt(Math.max(0, l(f) || 1)) * r.nodeRelSize + d;
          h.beginPath(), h.arc(f.x, f.y, y, 0, 2 * Math.PI, !1), h.fillStyle = u(f) || "rgba(31, 120, 180, 0.92)", h.fill(), r.nodeCanvasObject && m === "after" && r.nodeCanvasObject(f, r.ctx, r.globalScale);
        }), h.restore();
      }
      function n() {
        var o = tt(r.linkVisibility), l = tt(r.linkColor), u = tt(r.linkWidth), c = tt(r.linkLineDash), h = tt(r.linkCurvature), d = tt(r.linkCanvasObjectMode), p = r.ctx, f = r.isShadow * 2, m = r.graphData.links.filter(o);
        m.forEach(T);
        var y = [], v = [], g = m;
        if (r.linkCanvasObject) {
          var _ = [], x = [];
          m.forEach(function(E) {
            return ({
              before: y,
              after: v,
              replace: _
            }[d(E)] || x).push(E);
          }), g = [].concat(xn(y), v, x), y = y.concat(_);
        }
        p.save(), y.forEach(function(E) {
          return r.linkCanvasObject(E, p, r.globalScale);
        }), p.restore();
        var b = Dse(g, [l, u, c]);
        p.save(), Object.entries(b).forEach(function(E) {
          var M = od(E, 2), C = M[0], S = M[1], w = !C || C === "undefined" ? "rgba(0,0,0,0.15)" : C;
          Object.entries(S).forEach(function(R) {
            var O = od(R, 2), P = O[0], A = O[1], D = (P || 1) / r.globalScale + f;
            Object.entries(A).forEach(function(L) {
              var H = od(L, 2);
              H[0];
              var V = H[1], X = c(V[0]);
              p.beginPath(), V.forEach(function(F) {
                var B = F.source, W = F.target;
                if (!(!B || !W || !B.hasOwnProperty("x") || !W.hasOwnProperty("x"))) {
                  p.moveTo(B.x, B.y);
                  var G = F.__controlPoints;
                  G ? p[G.length === 2 ? "quadraticCurveTo" : "bezierCurveTo"].apply(p, xn(G).concat([W.x, W.y])) : p.lineTo(W.x, W.y);
                }
              }), p.strokeStyle = w, p.lineWidth = D, p.setLineDash(X || []), p.stroke();
            });
          });
        }), p.restore(), p.save(), v.forEach(function(E) {
          return r.linkCanvasObject(E, p, r.globalScale);
        }), p.restore();
        function T(E) {
          var M = h(E);
          if (!M) {
            E.__controlPoints = null;
            return;
          }
          var C = E.source, S = E.target;
          if (!(!C || !S || !C.hasOwnProperty("x") || !S.hasOwnProperty("x"))) {
            var w = Math.sqrt(Math.pow(S.x - C.x, 2) + Math.pow(S.y - C.y, 2));
            if (w > 0) {
              var R = Math.atan2(S.y - C.y, S.x - C.x), O = w * M, P = {
                // control point
                x: (C.x + S.x) / 2 + O * Math.cos(R - Math.PI / 2),
                y: (C.y + S.y) / 2 + O * Math.sin(R - Math.PI / 2)
              };
              E.__controlPoints = [P.x, P.y];
            } else {
              var A = M * 70;
              E.__controlPoints = [S.x, S.y - A, S.x + A, S.y];
            }
          }
        }
      }
      function s() {
        var o = 1.6, l = 0.2, u = tt(r.linkDirectionalArrowLength), c = tt(r.linkDirectionalArrowRelPos), h = tt(r.linkVisibility), d = tt(r.linkDirectionalArrowColor || r.linkColor), p = tt(r.nodeVal), f = r.ctx;
        f.save(), r.graphData.links.filter(h).forEach(function(m) {
          var y = u(m);
          if (!(!y || y < 0)) {
            var v = m.source, g = m.target;
            if (!(!v || !g || !v.hasOwnProperty("x") || !g.hasOwnProperty("x"))) {
              var _ = Math.sqrt(Math.max(0, p(v) || 1)) * r.nodeRelSize, x = Math.sqrt(Math.max(0, p(g) || 1)) * r.nodeRelSize, b = Math.min(1, Math.max(0, c(m))), T = d(m) || "rgba(0,0,0,0.28)", E = y / o / 2, M = m.__controlPoints && VM(oi, [v.x, v.y].concat(xn(m.__controlPoints), [g.x, g.y])), C = M ? function(D) {
                return M.get(D);
              } : function(D) {
                return {
                  // straight line: interpolate linearly
                  x: v.x + (g.x - v.x) * D || 0,
                  y: v.y + (g.y - v.y) * D || 0
                };
              }, S = M ? M.length() : Math.sqrt(Math.pow(g.x - v.x, 2) + Math.pow(g.y - v.y, 2)), w = _ + y + (S - _ - x - y) * b, R = C(w / S), O = C((w - y) / S), P = C((w - y * (1 - l)) / S), A = Math.atan2(R.y - O.y, R.x - O.x) - Math.PI / 2;
              f.beginPath(), f.moveTo(R.x, R.y), f.lineTo(O.x + E * Math.cos(A), O.y + E * Math.sin(A)), f.lineTo(P.x, P.y), f.lineTo(O.x - E * Math.cos(A), O.y - E * Math.sin(A)), f.fillStyle = T, f.fill();
            }
          }
        }), f.restore();
      }
      function a() {
        var o = tt(r.linkDirectionalParticles), l = tt(r.linkDirectionalParticleSpeed), u = tt(r.linkDirectionalParticleWidth), c = tt(r.linkVisibility), h = tt(r.linkDirectionalParticleColor || r.linkColor), d = r.ctx;
        d.save(), r.graphData.links.filter(c).forEach(function(p) {
          var f = o(p);
          if (!(!p.hasOwnProperty("__photons") || !p.__photons.length)) {
            var m = p.source, y = p.target;
            if (!(!m || !y || !m.hasOwnProperty("x") || !y.hasOwnProperty("x"))) {
              var v = l(p), g = p.__photons || [], _ = Math.max(0, u(p) / 2) / Math.sqrt(r.globalScale), x = h(p) || "rgba(0,0,0,0.28)";
              d.fillStyle = x;
              var b = p.__controlPoints ? VM(oi, [m.x, m.y].concat(xn(p.__controlPoints), [y.x, y.y])) : null, T = 0, E = !1;
              g.forEach(function(M) {
                var C = !!M.__singleHop;
                if (M.hasOwnProperty("__progressRatio") || (M.__progressRatio = C ? 0 : T / f), !C && T++, M.__progressRatio += v, M.__progressRatio >= 1)
                  if (!C)
                    M.__progressRatio = M.__progressRatio % 1;
                  else {
                    E = !0;
                    return;
                  }
                var S = M.__progressRatio, w = b ? b.get(S) : {
                  // straight line: interpolate linearly
                  x: m.x + (y.x - m.x) * S || 0,
                  y: m.y + (y.y - m.y) * S || 0
                };
                d.beginPath(), d.arc(w.x, w.y, _, 0, 2 * Math.PI, !1), d.fill();
              }), E && (p.__photons = p.__photons.filter(function(M) {
                return !M.__singleHop || M.__progressRatio <= 1;
              }));
            }
          }
        }), d.restore();
      }
    },
    emitParticle: function(r, e) {
      return e && (!e.__photons && (e.__photons = []), e.__photons.push({
        __singleHop: !0
      })), this;
    }
  },
  stateInit: function() {
    return {
      forceLayout: GR().force("link", zR()).force("charge", HR()).force("center", OR()).force("dagRadial", null).stop(),
      engineRunning: !1
    };
  },
  init: function(r, e) {
    e.ctx = r;
  },
  update: function(r, e) {
    r.engineRunning = !1, r.onUpdate(), r.nodeAutoColorBy !== null && HM(r.graphData.nodes, tt(r.nodeAutoColorBy), r.nodeColor), r.linkAutoColorBy !== null && HM(r.graphData.links, tt(r.linkAutoColorBy), r.linkColor), r.graphData.links.forEach(function(d) {
      d.source = d[r.linkSource], d.target = d[r.linkTarget];
    }), r.forceLayout.stop().alpha(1).nodes(r.graphData.nodes);
    var i = r.forceLayout.force("link");
    i && i.id(function(d) {
      return d[r.nodeId];
    }).links(r.graphData.links);
    var n = r.dagMode && qse(r.graphData, function(d) {
      return d[r.nodeId];
    }, {
      nodeFilter: r.dagNodeFilter,
      onLoopError: r.onDagError || void 0
    }), s = Math.max.apply(Math, xn(Object.values(n || []))), a = r.dagLevelDistance || r.graphData.nodes.length / (s || 1) * Xse * (["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? 0.7 : 1);
    if (["lr", "rl", "td", "bu"].includes(e.dagMode)) {
      var o = ["lr", "rl"].includes(e.dagMode) ? "fx" : "fy";
      r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(d) {
        return delete d[o];
      });
    }
    if (["lr", "rl", "td", "bu"].includes(r.dagMode)) {
      var l = ["rl", "bu"].includes(r.dagMode), u = function(d) {
        return (n[d[r.nodeId]] - s / 2) * a * (l ? -1 : 1);
      }, c = ["lr", "rl"].includes(r.dagMode) ? "fx" : "fy";
      r.graphData.nodes.filter(r.dagNodeFilter).forEach(function(d) {
        return d[c] = u(d);
      });
    }
    r.forceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(r.dagMode) !== -1 ? WR(function(d) {
      var p = n[d[r.nodeId]] || -1;
      return (r.dagMode === "radialin" ? s - p : p) * a;
    }).strength(function(d) {
      return r.dagNodeFilter(d) ? 1 : 0;
    }) : null);
    for (var h = 0; h < r.warmupTicks && !(r.d3AlphaMin > 0 && r.forceLayout.alpha() < r.d3AlphaMin); h++)
      r.forceLayout.tick();
    this.resetCountdown(), r.onFinishUpdate();
  }
});
function uO(r, e) {
  var i = r instanceof Array ? r : [r], n = new e();
  return n._destructor && n._destructor(), {
    linkProp: function(s) {
      return {
        default: n[s](),
        onChange: function(a, o) {
          i.forEach(function(l) {
            return o[l][s](a);
          });
        },
        triggerUpdate: !1
      };
    },
    linkMethod: function(s) {
      return function(a) {
        for (var o = arguments.length, l = new Array(o > 1 ? o - 1 : 0), u = 1; u < o; u++)
          l[u - 1] = arguments[u];
        var c = [];
        return i.forEach(function(h) {
          var d = a[h], p = d[s].apply(d, l);
          p !== d && c.push(p);
        }), c.length ? c[0] : this;
      };
    }
  };
}
var Yse = 800, Kse = 4, Zse = 5, cO = uO("forceGraph", tg), Qse = uO(["forceGraph", "shadowGraph"], tg), $se = Object.assign.apply(Object, xn(["nodeColor", "nodeAutoColorBy", "nodeCanvasObject", "nodeCanvasObjectMode", "linkColor", "linkAutoColorBy", "linkLineDash", "linkWidth", "linkCanvasObject", "linkCanvasObjectMode", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(r) {
  return Pd({}, r, cO.linkProp(r));
})).concat(xn(["nodeRelSize", "nodeId", "nodeVal", "nodeVisibility", "linkSource", "linkTarget", "linkVisibility", "linkCurvature"].map(function(r) {
  return Pd({}, r, Qse.linkProp(r));
})))), Jse = Object.assign.apply(Object, xn(["d3Force", "d3ReheatSimulation", "emitParticle"].map(function(r) {
  return Pd({}, r, cO.linkMethod(r));
})));
function Rv(r) {
  if (r.canvas) {
    var e = r.canvas.width, i = r.canvas.height;
    e === 300 && i === 150 && (e = i = 0);
    var n = window.devicePixelRatio;
    e /= n, i /= n, [r.canvas, r.shadowCanvas].forEach(function(a) {
      a.style.width = "".concat(r.width, "px"), a.style.height = "".concat(r.height, "px"), a.width = r.width * n, a.height = r.height * n, !e && !i && a.getContext("2d").scale(n, n);
    });
    var s = ss(r.canvas).k;
    r.zoom.translateBy(r.zoom.__baseElem, (r.width - e) / 2 / s, (r.height - i) / 2 / s), r.needsRedraw = !0;
  }
}
function hO(r) {
  var e = window.devicePixelRatio;
  r.setTransform(e, 0, 0, e, 0, 0);
}
function qM(r, e, i) {
  r.save(), hO(r), r.clearRect(0, 0, e, i), r.restore();
}
var eae = Pl({
  props: Mu({
    width: {
      default: window.innerWidth,
      onChange: function(r, e) {
        return Rv(e);
      },
      triggerUpdate: !1
    },
    height: {
      default: window.innerHeight,
      onChange: function(r, e) {
        return Rv(e);
      },
      triggerUpdate: !1
    },
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function(r, e) {
        [r.nodes, r.links].every(function(n) {
          return (n || []).every(function(s) {
            return !s.hasOwnProperty("__indexColor");
          });
        }) && e.colorTracker.reset(), [{
          type: "Node",
          objs: r.nodes
        }, {
          type: "Link",
          objs: r.links
        }].forEach(i), e.forceGraph.graphData(r), e.shadowGraph.graphData(r);
        function i(n) {
          var s = n.type, a = n.objs;
          a.filter(function(o) {
            if (!o.hasOwnProperty("__indexColor")) return !0;
            var l = e.colorTracker.lookup(o.__indexColor);
            return !l || !l.hasOwnProperty("d") || l.d !== o;
          }).forEach(function(o) {
            o.__indexColor = e.colorTracker.register({
              type: s,
              d: o
            });
          });
        }
      },
      triggerUpdate: !1
    },
    backgroundColor: {
      onChange: function(r, e) {
        e.canvas && r && (e.canvas.style.background = r);
      },
      triggerUpdate: !1
    },
    nodeLabel: {
      default: "name",
      triggerUpdate: !1
    },
    nodePointerAreaPaint: {
      onChange: function(r, e) {
        e.shadowGraph.nodeCanvasObject(r ? function(i, n, s) {
          return r(i, i.__indexColor, n, s);
        } : null), e.flushShadowCanvas && e.flushShadowCanvas();
      },
      triggerUpdate: !1
    },
    linkPointerAreaPaint: {
      onChange: function(r, e) {
        e.shadowGraph.linkCanvasObject(r ? function(i, n, s) {
          return r(i, i.__indexColor, n, s);
        } : null), e.flushShadowCanvas && e.flushShadowCanvas();
      },
      triggerUpdate: !1
    },
    linkLabel: {
      default: "name",
      triggerUpdate: !1
    },
    linkHoverPrecision: {
      default: 4,
      triggerUpdate: !1
    },
    minZoom: {
      default: 0.01,
      onChange: function(r, e) {
        e.zoom.scaleExtent([r, e.zoom.scaleExtent()[1]]);
      },
      triggerUpdate: !1
    },
    maxZoom: {
      default: 1e3,
      onChange: function(r, e) {
        e.zoom.scaleExtent([e.zoom.scaleExtent()[0], r]);
      },
      triggerUpdate: !1
    },
    enableNodeDrag: {
      default: !0,
      triggerUpdate: !1
    },
    enableZoomInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    enablePanInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    enableZoomPanInteraction: {
      default: !0,
      triggerUpdate: !1
    },
    // to be deprecated
    enablePointerInteraction: {
      default: !0,
      onChange: function(r, e) {
        e.hoverObj = null;
      },
      triggerUpdate: !1
    },
    autoPauseRedraw: {
      default: !0,
      triggerUpdate: !1
    },
    onNodeDrag: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeDragEnd: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onNodeClick: {
      triggerUpdate: !1
    },
    onNodeRightClick: {
      triggerUpdate: !1
    },
    onNodeHover: {
      triggerUpdate: !1
    },
    onLinkClick: {
      triggerUpdate: !1
    },
    onLinkRightClick: {
      triggerUpdate: !1
    },
    onLinkHover: {
      triggerUpdate: !1
    },
    onBackgroundClick: {
      triggerUpdate: !1
    },
    onBackgroundRightClick: {
      triggerUpdate: !1
    },
    onZoom: {
      triggerUpdate: !1
    },
    onZoomEnd: {
      triggerUpdate: !1
    },
    onRenderFramePre: {
      triggerUpdate: !1
    },
    onRenderFramePost: {
      triggerUpdate: !1
    }
  }, $se),
  aliases: {
    // Prop names supported for backwards compatibility
    stopAnimation: "pauseAnimation"
  },
  methods: Mu({
    graph2ScreenCoords: function(r, e, i) {
      var n = ss(r.canvas);
      return {
        x: e * n.k + n.x,
        y: i * n.k + n.y
      };
    },
    screen2GraphCoords: function(r, e, i) {
      var n = ss(r.canvas);
      return {
        x: (e - n.x) / n.k,
        y: (i - n.y) / n.k
      };
    },
    centerAt: function(r, e, i, n) {
      if (!r.canvas) return null;
      if (e !== void 0 || i !== void 0) {
        var s = Object.assign({}, e !== void 0 ? {
          x: e
        } : {}, i !== void 0 ? {
          y: i
        } : {});
        return n ? r.tweenGroup.add(new Qm(a()).to(s, n).easing(va.Quadratic.Out).onUpdate(o).start()) : o(s), this;
      }
      return a();
      function a() {
        var l = ss(r.canvas);
        return {
          x: (r.width / 2 - l.x) / l.k,
          y: (r.height / 2 - l.y) / l.k
        };
      }
      function o(l) {
        var u = l.x, c = l.y;
        r.zoom.translateTo(r.zoom.__baseElem, u === void 0 ? a().x : u, c === void 0 ? a().y : c), r.needsRedraw = !0;
      }
    },
    zoom: function(r, e, i) {
      if (!r.canvas) return null;
      if (e !== void 0)
        return i ? r.tweenGroup.add(new Qm({
          k: n()
        }).to({
          k: e
        }, i).easing(va.Quadratic.Out).onUpdate(function(a) {
          var o = a.k;
          return s(o);
        }).start()) : s(e), this;
      return n();
      function n() {
        return ss(r.canvas).k;
      }
      function s(a) {
        r.zoom.scaleTo(r.zoom.__baseElem, a), r.needsRedraw = !0;
      }
    },
    zoomToFit: function(r) {
      for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, n = arguments.length, s = new Array(n > 3 ? n - 3 : 0), a = 3; a < n; a++)
        s[a - 3] = arguments[a];
      var o = this.getGraphBbox.apply(this, s);
      if (o) {
        var l = {
          x: (o.x[0] + o.x[1]) / 2,
          y: (o.y[0] + o.y[1]) / 2
        }, u = Math.max(1e-12, Math.min(1e12, (r.width - i * 2) / (o.x[1] - o.x[0]), (r.height - i * 2) / (o.y[1] - o.y[0])));
        this.centerAt(l.x, l.y, e), this.zoom(u, e);
      }
      return this;
    },
    getGraphBbox: function(r) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      }, i = tt(r.nodeVal), n = function(a) {
        return Math.sqrt(Math.max(0, i(a) || 1)) * r.nodeRelSize;
      }, s = r.graphData.nodes.filter(e).map(function(a) {
        return {
          x: a.x,
          y: a.y,
          r: n(a)
        };
      });
      return s.length ? {
        x: [Fb(s, function(a) {
          return a.x - a.r;
        }), Ub(s, function(a) {
          return a.x + a.r;
        })],
        y: [Fb(s, function(a) {
          return a.y - a.r;
        }), Ub(s, function(a) {
          return a.y + a.r;
        })]
      } : null;
    },
    pauseAnimation: function(r) {
      return r.animationFrameRequestId && (cancelAnimationFrame(r.animationFrameRequestId), r.animationFrameRequestId = null), this;
    },
    resumeAnimation: function(r) {
      return r.animationFrameRequestId || this._animationCycle(), this;
    },
    _destructor: function() {
      this.pauseAnimation(), this.graphData({
        nodes: [],
        links: []
      });
    }
  }, Jse),
  stateInit: function() {
    return {
      lastSetZoom: 1,
      zoom: Qne(),
      forceGraph: new tg(),
      shadowGraph: new tg().cooldownTicks(0).nodeColor("__indexColor").linkColor("__indexColor").isShadow(!0),
      colorTracker: new fse(),
      // indexed objects for rgb lookup
      tweenGroup: new Z1()
    };
  },
  init: function(r, e) {
    var i = this;
    r.innerHTML = "";
    var n = document.createElement("div");
    n.classList.add("force-graph-container"), n.style.position = "relative", r.appendChild(n), e.canvas = document.createElement("canvas"), e.backgroundColor && (e.canvas.style.background = e.backgroundColor), n.appendChild(e.canvas), e.shadowCanvas = document.createElement("canvas");
    var s = e.canvas.getContext("2d"), a = e.shadowCanvas.getContext("2d", {
      willReadFrequently: !0
    }), o = {
      x: -1e12,
      y: -1e12
    }, l = function() {
      var c = null, h = window.devicePixelRatio, d = o.x > 0 && o.y > 0 ? a.getImageData(o.x * h, o.y * h, 1, 1) : null;
      return d && (c = e.colorTracker.lookup(d.data)), c;
    };
    bn(e.canvas).call(Ure().subject(function() {
      if (!e.enableNodeDrag)
        return null;
      var c = l();
      return c && c.type === "Node" ? c.d : null;
    }).on("start", function(c) {
      var h = c.subject;
      h.__initialDragPos = {
        x: h.x,
        y: h.y,
        fx: h.fx,
        fy: h.fy
      }, c.active || (h.fx = h.x, h.fy = h.y), e.canvas.classList.add("grabbable");
    }).on("drag", function(c) {
      var h = c.subject, d = h.__initialDragPos, p = c, f = ss(e.canvas).k, m = {
        x: d.x + (p.x - d.x) / f - h.x,
        y: d.y + (p.y - d.y) / f - h.y
      };
      ["x", "y"].forEach(function(y) {
        return h["f".concat(y)] = h[y] = d[y] + (p[y] - d[y]) / f;
      }), !(!h.__dragged && Zse >= Math.sqrt(UG(["x", "y"].map(function(y) {
        return Math.pow(c[y] - d[y], 2);
      })))) && (e.forceGraph.d3AlphaTarget(0.3).resetCountdown(), e.isPointerDragging = !0, h.__dragged = !0, e.onNodeDrag(h, m));
    }).on("end", function(c) {
      var h = c.subject, d = h.__initialDragPos, p = {
        x: h.x - d.x,
        y: h.y - d.y
      };
      d.fx === void 0 && (h.fx = void 0), d.fy === void 0 && (h.fy = void 0), delete h.__initialDragPos, e.forceGraph.d3AlphaTarget() && e.forceGraph.d3AlphaTarget(0).resetCountdown(), e.canvas.classList.remove("grabbable"), e.isPointerDragging = !1, h.__dragged && (delete h.__dragged, e.onNodeDragEnd(h, p));
    })), e.zoom(e.zoom.__baseElem = bn(e.canvas)), e.zoom.__baseElem.on("dblclick.zoom", null), e.zoom.filter(function(c) {
      return (
        // disable zoom interaction
        !c.button && e.enableZoomPanInteraction && (c.type !== "wheel" || tt(e.enableZoomInteraction)(c)) && (c.type === "wheel" || tt(e.enablePanInteraction)(c))
      );
    }).on("zoom", function(c) {
      var h = c.transform;
      [s, a].forEach(function(d) {
        hO(d), d.translate(h.x, h.y), d.scale(h.k, h.k);
      }), e.onZoom && e.onZoom(Mu(Mu({}, h), i.centerAt())), e.needsRedraw = !0;
    }).on("end", function(c) {
      return e.onZoomEnd && e.onZoomEnd(Mu(Mu({}, c.transform), i.centerAt()));
    }), Rv(e), e.forceGraph.onNeedsRedraw(function() {
      return e.needsRedraw = !0;
    }).onFinishUpdate(function() {
      ss(e.canvas).k === e.lastSetZoom && e.graphData.nodes.length && (e.zoom.scaleTo(e.zoom.__baseElem, e.lastSetZoom = Kse / Math.cbrt(e.graphData.nodes.length)), e.needsRedraw = !0);
    }), e.tooltip = new qI(n), ["pointermove", "pointerdown"].forEach(function(c) {
      return n.addEventListener(c, function(h) {
        c === "pointerdown" && (e.isPointerPressed = !0, e.pointerDownEvent = h), !e.isPointerDragging && h.type === "pointermove" && e.onBackgroundClick && (h.pressure > 0 || e.isPointerPressed) && (h.pointerType !== "touch" || h.movementX === void 0 || [h.movementX, h.movementY].some(function(f) {
          return Math.abs(f) > 1;
        })) && (e.isPointerDragging = !0);
        var d = p(n);
        o.x = h.pageX - d.left, o.y = h.pageY - d.top;
        function p(f) {
          var m = f.getBoundingClientRect(), y = window.pageXOffset || document.documentElement.scrollLeft, v = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: m.top + v,
            left: m.left + y
          };
        }
      }, {
        passive: !0
      });
    }), n.addEventListener("pointerup", function(c) {
      if (e.isPointerPressed = !1, e.isPointerDragging) {
        e.isPointerDragging = !1;
        return;
      }
      var h = [c, e.pointerDownEvent];
      requestAnimationFrame(function() {
        if (c.button === 0)
          if (e.hoverObj) {
            var d = e["on".concat(e.hoverObj.type, "Click")];
            d && d.apply(void 0, [e.hoverObj.d].concat(h));
          } else
            e.onBackgroundClick && e.onBackgroundClick.apply(e, h);
        if (c.button === 2)
          if (e.hoverObj) {
            var p = e["on".concat(e.hoverObj.type, "RightClick")];
            p && p.apply(void 0, [e.hoverObj.d].concat(h));
          } else
            e.onBackgroundRightClick && e.onBackgroundRightClick.apply(e, h);
      });
    }, {
      passive: !0
    }), n.addEventListener("contextmenu", function(c) {
      return !e.onBackgroundRightClick && !e.onNodeRightClick && !e.onLinkRightClick ? !0 : (c.preventDefault(), !1);
    }), e.forceGraph(s), e.shadowGraph(a);
    var u = Jne(function() {
      qM(a, e.width, e.height), e.shadowGraph.linkWidth(function(h) {
        return tt(e.linkWidth)(h) + e.linkHoverPrecision;
      });
      var c = ss(e.canvas);
      e.shadowGraph.globalScale(c.k).tickFrame();
    }, Yse);
    e.flushShadowCanvas = u.flush, (this._animationCycle = function c() {
      var h = !e.autoPauseRedraw || !!e.needsRedraw || e.forceGraph.isEngineRunning() || e.graphData.links.some(function(_) {
        return _.__photons && _.__photons.length;
      });
      if (e.needsRedraw = !1, e.enablePointerInteraction) {
        var d = e.isPointerDragging ? null : l();
        if (d !== e.hoverObj) {
          var p = e.hoverObj, f = p ? p.type : null, m = d ? d.type : null;
          if (f && f !== m) {
            var y = e["on".concat(f, "Hover")];
            y && y(null, p.d);
          }
          if (m) {
            var v = e["on".concat(m, "Hover")];
            v && v(d.d, f === m ? p.d : null);
          }
          e.tooltip.content(d && tt(e["".concat(d.type.toLowerCase(), "Label")])(d.d) || null), e.canvas.classList[d && e["on".concat(m, "Click")] || !d && e.onBackgroundClick ? "add" : "remove"]("clickable"), e.hoverObj = d;
        }
        h && u();
      }
      if (h) {
        qM(s, e.width, e.height);
        var g = ss(e.canvas).k;
        e.onRenderFramePre && e.onRenderFramePre(s, g), e.forceGraph.globalScale(g).tickFrame(), e.onRenderFramePost && e.onRenderFramePost(s, g);
      }
      e.tweenGroup.update(), e.animationFrameRequestId = requestAnimationFrame(c);
    })();
  },
  update: function(r) {
  }
}), Qg = {
  width: ie.number,
  height: ie.number,
  graphData: ie.shape({
    nodes: ie.arrayOf(ie.object).isRequired,
    links: ie.arrayOf(ie.object).isRequired
  }),
  backgroundColor: ie.string,
  nodeRelSize: ie.number,
  nodeId: ie.string,
  nodeLabel: ie.oneOfType([ie.string, ie.func]),
  nodeVal: ie.oneOfType([ie.number, ie.string, ie.func]),
  nodeVisibility: ie.oneOfType([ie.bool, ie.string, ie.func]),
  nodeColor: ie.oneOfType([ie.string, ie.func]),
  nodeAutoColorBy: ie.oneOfType([ie.string, ie.func]),
  onNodeHover: ie.func,
  onNodeClick: ie.func,
  linkSource: ie.string,
  linkTarget: ie.string,
  linkLabel: ie.oneOfType([ie.string, ie.func]),
  linkVisibility: ie.oneOfType([ie.bool, ie.string, ie.func]),
  linkColor: ie.oneOfType([ie.string, ie.func]),
  linkAutoColorBy: ie.oneOfType([ie.string, ie.func]),
  linkWidth: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkCurvature: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalArrowLength: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalArrowColor: ie.oneOfType([ie.string, ie.func]),
  linkDirectionalArrowRelPos: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticles: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticleSpeed: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticleWidth: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkDirectionalParticleColor: ie.oneOfType([ie.string, ie.func]),
  onLinkHover: ie.func,
  onLinkClick: ie.func,
  dagMode: ie.oneOf(["td", "bu", "lr", "rl", "zin", "zout", "radialin", "radialout"]),
  dagLevelDistance: ie.number,
  dagNodeFilter: ie.func,
  onDagError: ie.func,
  d3AlphaMin: ie.number,
  d3AlphaDecay: ie.number,
  d3VelocityDecay: ie.number,
  warmupTicks: ie.number,
  cooldownTicks: ie.number,
  cooldownTime: ie.number,
  onEngineTick: ie.func,
  onEngineStop: ie.func,
  getGraphBbox: ie.func
}, dO = {
  zoomToFit: ie.func,
  onNodeRightClick: ie.func,
  onNodeDrag: ie.func,
  onNodeDragEnd: ie.func,
  onLinkRightClick: ie.func,
  linkHoverPrecision: ie.number,
  onBackgroundClick: ie.func,
  onBackgroundRightClick: ie.func,
  enablePointerInteraction: ie.bool,
  enableNodeDrag: ie.bool
}, aT = {
  showNavInfo: ie.bool,
  nodeOpacity: ie.number,
  nodeResolution: ie.number,
  nodeThreeObject: ie.oneOfType([ie.object, ie.string, ie.func]),
  nodeThreeObjectExtend: ie.oneOfType([ie.bool, ie.string, ie.func]),
  linkOpacity: ie.number,
  linkResolution: ie.number,
  linkCurveRotation: ie.oneOfType([ie.number, ie.string, ie.func]),
  linkMaterial: ie.oneOfType([ie.object, ie.string, ie.func]),
  linkThreeObject: ie.oneOfType([ie.object, ie.string, ie.func]),
  linkThreeObjectExtend: ie.oneOfType([ie.bool, ie.string, ie.func]),
  linkPositionUpdate: ie.func,
  linkDirectionalArrowResolution: ie.number,
  linkDirectionalParticleResolution: ie.number,
  forceEngine: ie.oneOf(["d3", "ngraph"]),
  ngraphPhysics: ie.object,
  numDimensions: ie.oneOf([1, 2, 3])
}, tae = Object.assign({}, Qg, dO, {
  linkLineDash: ie.oneOfType([ie.arrayOf(ie.number), ie.string, ie.func]),
  nodeCanvasObjectMode: ie.oneOfType([ie.string, ie.func]),
  nodeCanvasObject: ie.func,
  nodePointerAreaPaint: ie.func,
  linkCanvasObjectMode: ie.oneOfType([ie.string, ie.func]),
  linkCanvasObject: ie.func,
  linkPointerAreaPaint: ie.func,
  autoPauseRedraw: ie.bool,
  minZoom: ie.number,
  maxZoom: ie.number,
  enableZoomInteraction: ie.oneOfType([ie.bool, ie.func]),
  enablePanInteraction: ie.oneOfType([ie.bool, ie.func]),
  onZoom: ie.func,
  onZoomEnd: ie.func,
  onRenderFramePre: ie.func,
  onRenderFramePost: ie.func
}), iae = Object.assign({}, Qg, dO, aT, {
  enableNavigationControls: ie.bool,
  controlType: ie.oneOf(["trackball", "orbit", "fly"]),
  rendererConfig: ie.object,
  extraRenderers: ie.arrayOf(ie.shape({
    render: ie.func.isRequired
  }))
}), rae = Object.assign({}, Qg, aT, {
  nodeDesc: ie.oneOfType([ie.string, ie.func]),
  linkDesc: ie.oneOfType([ie.string, ie.func])
}), nae = Object.assign({}, Qg, aT, {
  markerAttrs: ie.object,
  yOffset: ie.number,
  glScale: ie.number
});
const pO = gg(bA, {
  methodNames: [
    // bind methods
    "getGraphBbox",
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "refresh"
  ]
});
pO.displayName = "ForceGraphVR";
pO.propTypes = rae;
const fO = gg(SH, {
  methodNames: [
    // bind methods
    "getGraphBbox",
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "refresh"
  ],
  initPropNames: ["markerAttrs"]
});
fO.displayName = "ForceGraphAR";
fO.propTypes = nae;
const oT = gg(Pre, {
  methodNames: [
    // bind methods
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "stopAnimation",
    "pauseAnimation",
    "resumeAnimation",
    "cameraPosition",
    "zoomToFit",
    "getGraphBbox",
    "screen2GraphCoords",
    "graph2ScreenCoords",
    "postProcessingComposer",
    "lights",
    "scene",
    "camera",
    "renderer",
    "controls",
    "refresh"
  ],
  initPropNames: ["controlType", "rendererConfig", "extraRenderers"]
});
oT.displayName = "ForceGraph3D";
oT.propTypes = iae;
const lT = gg(eae, {
  methodNames: [
    // bind methods
    "emitParticle",
    "d3Force",
    "d3ReheatSimulation",
    "stopAnimation",
    "pauseAnimation",
    "resumeAnimation",
    "centerAt",
    "zoom",
    "zoomToFit",
    "getGraphBbox",
    "screen2GraphCoords",
    "graph2ScreenCoords"
  ]
});
lT.displayName = "ForceGraph2D";
lT.propTypes = tae;
const sae = {
  position: "absolute",
  pointerEvents: "none",
  background: Si.PREDICATE,
  color: "#fff",
  border: `2px solid ${Si.PREDICATE}`,
  borderRadius: 8,
  padding: "6px 14px",
  fontSize: 15,
  fontWeight: "bold",
  zIndex: 1e3,
  boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
  whiteSpace: "nowrap",
  maxWidth: 260,
  overflow: "hidden",
  textOverflow: "ellipsis"
}, aae = 16, XM = 32, oae = ({
  graphData: r,
  onNodeClick: e,
  onEngineStop: i,
  fgRef: n,
  children: s,
  selectedTriple: a,
  endpoint: o,
  disableNodeDetailsSidebar: l = !1
}) => {
  const u = Gi(), [c, h] = ye(null), [d, p] = ye(null), [f, m] = ye({ x: 0, y: 0 }), [y, v] = ye({ width: 100, height: 100 }), [g, _] = ye(/* @__PURE__ */ new Map());
  Ft(() => {
    const S = () => {
      u.current && v({
        width: u.current.clientWidth,
        height: u.current.clientHeight
      });
    };
    return S(), window.addEventListener("resize", S), () => window.removeEventListener("resize", S);
  }, []), Ft(() => {
    r.nodes.forEach((S) => {
      if (S.image && !g.has(S.image)) {
        const w = new Image();
        w.crossOrigin = "anonymous", w.src = S.image, w.onload = () => {
          _((R) => new Map(R).set(S.image, w)), n.current && typeof n.current.emit == "function" && n.current.emit("redraw");
        };
      }
    });
  }, [r.nodes]);
  const x = mr(() => {
    requestAnimationFrame(() => {
      h(null), p(null);
    });
  }, []), b = mr((S) => {
    requestAnimationFrame(() => {
      p(S);
    });
  }, []), T = mr((S) => {
    requestAnimationFrame(() => {
      h(S);
    });
  }, []), E = mr((S) => {
    if (u.current) {
      const w = u.current.getBoundingClientRect();
      m({
        x: S.clientX - w.left,
        y: S.clientY - w.top
      });
    }
  }, []), M = mr(() => {
    requestAnimationFrame(() => {
      h(null), p(null);
    });
  }, []), C = () => {
    if (!u.current) return { left: f.x, top: f.y };
    const S = u.current.getBoundingClientRect(), w = 180, R = 36;
    let O = f.x + aae, P = f.y - XM;
    return O + w > S.width && (O = S.width - w - 8), O < 0 && (O = 8), P < 0 && (P = f.y + XM), P + R > S.height && (P = S.height - R - 8), { left: O, top: P };
  };
  return /* @__PURE__ */ se.jsxs(
    "div",
    {
      ref: u,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      onMouseMove: E,
      children: [
        /* @__PURE__ */ se.jsx(
          lT,
          {
            ref: n,
            graphData: r,
            width: y.width,
            height: y.height,
            nodeCanvasObject: (S, w, R) => {
              const O = 44 / R * Math.pow(R, 0.15);
              if (S.type === "object")
                if (S.image) {
                  if (w.save(), w.beginPath(), w.rect(S.x - O / 2, S.y - O / 2, O, O), w.closePath(), w.strokeStyle = S.color, w.lineWidth = 3 / R, w.stroke(), w.clip(), !S.__img) {
                    const P = new window.Image();
                    P.crossOrigin = "anonymous", P.src = S.image, P.onload = () => {
                      S.__imgLoaded = !0, n && n.current && typeof n.current.emit == "function" && n.current.emit("redraw");
                    }, S.__img = P, S.__imgLoaded = !1;
                  }
                  S.__imgLoaded ? w.drawImage(
                    S.__img,
                    S.x - O / 2,
                    S.y - O / 2,
                    O,
                    O
                  ) : (w.fillStyle = S.color || "#888", w.fillRect(S.x - O / 2, S.y - O / 2, O, O)), w.restore();
                } else {
                  w.save(), w.beginPath(), w.rect(S.x - O / 2, S.y - O / 2, O, O), w.closePath(), w.fillStyle = S.color + "CC", w.fill(), w.strokeStyle = S.color, w.lineWidth = 3 / R, w.stroke();
                  const P = (S.label || "?").substring(0, 3), A = 20 / R;
                  w.font = `bold ${A}px Sans-Serif`, w.fillStyle = "#fff", w.textAlign = "center", w.textBaseline = "middle", w.fillText(P, S.x, S.y + O * 0.04), w.restore();
                }
              else if (S.image) {
                if (!S.__img) {
                  const P = new window.Image();
                  P.src = S.image, P.onload = () => {
                    S.__imgLoaded = !0, n && n.current && typeof n.current.emit == "function" && n.current.emit("redraw");
                  }, S.__img = P, S.__imgLoaded = !1;
                }
                w.save(), w.beginPath(), w.arc(S.x, S.y, O / 2, 0, 2 * Math.PI, !1), w.closePath(), w.lineWidth = 3 / R, w.strokeStyle = S.color, w.stroke(), w.clip(), S.__imgLoaded ? w.drawImage(
                  S.__img,
                  S.x - O / 2,
                  S.y - O / 2,
                  O,
                  O
                ) : (w.fillStyle = S.color || "#888", w.fill()), w.restore();
              } else {
                w.save(), w.beginPath(), w.arc(S.x, S.y, O / 2, 0, 2 * Math.PI, !1), w.closePath(), w.fillStyle = S.color + "CC", w.fill(), w.strokeStyle = S.color, w.lineWidth = 3 / R, w.stroke();
                const P = (S.label || "?").substring(0, 3), A = 20 / R;
                w.font = `bold ${A}px Sans-Serif`, w.fillStyle = "#fff", w.textAlign = "center", w.textBaseline = "middle", w.fillText(P, S.x, S.y + O * 0.04), w.restore();
              }
            },
            nodePointerAreaPaint: (S, w, R, O) => {
              const P = 44 / O * Math.pow(O, 0.15);
              R.fillStyle = w, S.type === "object" ? (R.beginPath(), R.rect(S.x - P / 2, S.y - P / 2, P, P), R.closePath(), R.fill()) : (R.beginPath(), R.arc(S.x, S.y, P / 2, 0, 2 * Math.PI, !1), R.closePath(), R.fill());
            },
            linkColor: () => "rgba(255, 211, 42, 0.15)",
            linkDirectionalParticles: 1,
            linkDirectionalParticleSpeed: 0.01,
            linkDirectionalParticleColor: () => "rgba(255,255,255,0.5)",
            nodeAutoColorBy: "type",
            onNodeClick: e,
            onEngineStop: i,
            onNodeHover: b,
            onLinkHover: T,
            onBackgroundClick: M,
            onZoom: x
          }
        ),
        c && c.label ? /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              ...sae,
              ...C(),
              pointerEvents: "none"
            },
            children: c.label
          }
        ) : d && d.label ? /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: f.x + 18,
              top: f.y - 10,
              background: "#232326",
              color: "#fff",
              border: "1.5px solid #ffd32a",
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 1e3,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: d.label
          }
        ) : null,
        a && !l && /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: 80,
              right: 30,
              width: 350,
              zIndex: 9999,
              maxHeight: "80vh",
              background: "#18181b",
              borderRadius: "10px",
              border: "3px solid #ffd32a",
              boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
              overflowY: "auto"
            },
            children: /* @__PURE__ */ se.jsx(
              __,
              {
                triple: a,
                endpoint: o,
                onClose: () => e(null)
              }
            )
          }
        ),
        /* @__PURE__ */ se.jsx("div", { style: { position: "relative", zIndex: 2e3 }, children: s })
      ]
    }
  );
};
var lae = typeof window < "u" && window.THREE ? window.THREE : {
  Sprite: Pj
};
lae.Sprite;
const uae = ({
  graphData: r,
  onNodeClick: e,
  onEngineStop: i,
  fgRef: n,
  children: s,
  selectedTriple: a,
  endpoint: o,
  disableNodeDetailsSidebar: l = !1
}) => {
  const u = Gi(), [c, h] = ye({ width: 100, height: 100 }), [d, p] = ye(null), [f, m] = ye(null), [y, v] = ye({ x: 0, y: 0 }), g = Gi(/* @__PURE__ */ new Map());
  Ft(() => {
    const x = () => {
      u.current && h({
        width: u.current.clientWidth,
        height: u.current.clientHeight
      });
    };
    return x(), window.addEventListener("resize", x), () => window.removeEventListener("resize", x);
  }, []);
  const _ = (x) => {
    if (g.current.has(x.id))
      return g.current.get(x.id);
    const b = 128, T = document.createElement("canvas");
    T.width = T.height = b;
    const E = T.getContext("2d");
    if (E.clearRect(0, 0, b, b), x.image) {
      const S = new window.Image();
      S.crossOrigin = "anonymous", S.src = x.image, S.onload = () => {
        if (E.clearRect(0, 0, b, b), x.type === "object") {
          E.fillStyle = Nu(x.type) + "CC", E.fillRect(0, 0, b, b);
          const w = Math.max(b / S.width, b / S.height), R = S.width * w, O = S.height * w;
          E.drawImage(S, b / 2 - R / 2, b / 2 - O / 2, R, O);
        } else {
          E.save(), E.beginPath(), E.arc(b / 2, b / 2, b / 2, 0, 2 * Math.PI), E.closePath(), E.clip(), E.fillStyle = Nu(x.type) + "CC", E.fillRect(0, 0, b, b);
          const w = Math.max(b / S.width, b / S.height), R = S.width * w, O = S.height * w;
          E.drawImage(S, b / 2 - R / 2, b / 2 - O / 2, R, O), E.restore();
        }
        M.needsUpdate = !0, n.current && n.current.emit("redraw");
      };
    } else {
      x.type === "object" ? (E.fillStyle = Nu(x.type) + "CC", E.fillRect(0, 0, b, b)) : (E.save(), E.beginPath(), E.arc(b / 2, b / 2, b / 2, 0, 2 * Math.PI), E.closePath(), E.clip(), E.fillStyle = Nu(x.type) + "CC", E.fillRect(0, 0, b, b), E.restore());
      const S = (x.label || "?").substring(0, 3);
      E.font = "bold 48px Sans-Serif", E.fillStyle = "#fff", E.textAlign = "center", E.textBaseline = "middle", E.fillText(S, b / 2, b / 2 + 6);
    }
    const M = new En(T);
    M.needsUpdate = !0;
    const C = new Tg({
      map: M,
      transparent: !0
    });
    return g.current.set(x.id, C), C;
  };
  return /* @__PURE__ */ se.jsxs(
    "div",
    {
      ref: u,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      onMouseMove: (x) => {
        if (u.current) {
          const b = u.current.getBoundingClientRect();
          v({
            x: x.clientX - b.left,
            y: x.clientY - b.top
          });
        }
      },
      children: [
        /* @__PURE__ */ se.jsx(
          oT,
          {
            ref: n,
            graphData: r,
            width: c.width,
            height: c.height,
            controlType: "fly",
            backgroundColor: "rgba(0,0,0,0)",
            nodeLabel: "",
            onNodeClick: e,
            linkColor: () => "rgba(255, 211, 42, 0.15)",
            linkDirectionalParticles: 2,
            linkDirectionalParticleSpeed: 25e-4,
            linkDirectionalParticleColor: () => "rgba(255,255,255,0.5)",
            nodeAutoColorBy: "type",
            nodeThreeObject: (x) => {
              const b = new nl(), T = _(x);
              let E;
              return x.type === "object" ? E = new kr(
                new Gd(16, 16),
                T
              ) : E = new kr(
                new F_(16 / 2, 48),
                T
              ), b.add(E), b;
            },
            onEngineStop: i,
            onNodeHover: (x) => {
              requestAnimationFrame(() => p(x));
            },
            onLinkHover: (x) => {
              requestAnimationFrame(() => m(x));
            },
            onBackgroundClick: () => {
              requestAnimationFrame(() => {
                m(null), p(null);
              });
            },
            onZoom: () => {
              requestAnimationFrame(() => {
                m(null), p(null);
              });
            }
          }
        ),
        a && !l && /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: 80,
              right: 30,
              width: 350,
              zIndex: 9999,
              maxHeight: "80vh",
              background: "#18181b",
              borderRadius: "10px",
              border: "3px solid #ffd32a",
              boxShadow: "0 8px 30px rgba(0, 0, 0, 0.5)",
              overflowY: "auto"
            },
            children: /* @__PURE__ */ se.jsx(
              __,
              {
                triple: a,
                endpoint: o,
                onClose: () => e(null)
              }
            )
          }
        ),
        /* @__PURE__ */ se.jsx("div", { style: { position: "relative", zIndex: 2e3 }, children: s }),
        f && f.label ? /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: y.x + 18,
              top: y.y - 10,
              background: Si.PREDICATE,
              color: "#fff",
              border: `1.5px solid ${Si.PREDICATE}`,
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 1e3,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: f.label
          }
        ) : d && d.label ? /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              position: "absolute",
              left: y.x + 18,
              top: y.y - 10,
              background: "#232326",
              color: "#fff",
              border: "1.5px solid #ffd32a",
              borderRadius: 8,
              padding: "6px 14px",
              fontSize: 15,
              fontWeight: "bold",
              zIndex: 1e3,
              boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
              pointerEvents: "none",
              whiteSpace: "nowrap",
              maxWidth: 260,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            children: d.label
          }
        ) : null
      ]
    }
  );
}, cae = "data:image/svg+xml,%3csvg%20width='32'%20height='30'%20viewBox='0%200%2032%2030'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M26.9436%2019.5778C25.8567%2019.5772%2024.8057%2019.9695%2023.9819%2020.6833L20.0907%2017.6358C20.4028%2017.004%2020.565%2016.3078%2020.5646%2015.6021C20.5642%2015.4181%2020.5531%2015.2343%2020.5312%2015.0517L22.9947%2014.2259C23.5462%2015.1905%2024.4272%2015.9203%2025.4735%2016.2794C26.5199%2016.6384%2027.6602%2016.6023%2028.682%2016.1777C29.7039%2015.753%2030.5375%2014.9689%2031.0276%2013.9713C31.5178%2012.9738%2031.631%2011.8308%2031.3461%2010.7554C31.0613%209.68008%2030.3979%208.74564%2029.4794%208.12623C28.561%207.50683%2027.4502%207.2447%2026.354%207.38869C25.2579%207.53269%2024.2511%208.07298%2023.5213%208.90891C22.7914%209.74483%2022.3884%2010.8194%2022.3871%2011.9323C22.3875%2012.1163%2022.3986%2012.3001%2022.4206%2012.4828L19.957%2013.3085C19.475%2012.4631%2018.7374%2011.7948%2017.8516%2011.4012C16.9658%2011.0076%2015.9783%2010.9092%2015.0331%2011.1204L13.7967%208.32213C14.7159%207.66222%2015.359%206.68228%2015.6014%205.57222C15.8438%204.46216%2015.6682%203.30103%2015.1087%202.31386C14.5492%201.32668%2013.6457%200.583768%2012.5731%200.229086C11.5006%20-0.125597%2010.3354%20-0.0667882%209.30348%200.394115C8.27155%200.855018%207.44631%201.68519%206.9877%202.72375C6.52908%203.76231%206.46976%204.9353%206.82122%206.01538C7.17267%207.09547%207.90989%208.00574%208.88998%208.56979C9.87008%209.13384%2011.0233%209.31149%2012.1261%209.06833L13.3624%2011.8666C12.4386%2012.528%2011.7937%2013.5131%2011.5543%2014.6286C11.3149%2015.7441%2011.4982%2016.9094%2012.0683%2017.8958L7.80656%2021.7185C6.90029%2021.0354%205.77439%2020.7154%204.64711%2020.8206C3.51984%2020.9257%202.4715%2021.4485%201.7053%2022.2876C0.939107%2023.1267%200.509642%2024.2222%200.50016%2025.362C0.490678%2026.5017%200.901855%2027.6044%201.65398%2028.4562C2.40611%2029.3081%203.44561%2029.8485%204.57097%2029.9726C5.69634%2030.0968%206.8274%2029.7958%207.74491%2029.1281C8.66242%2028.4604%209.30101%2027.4736%209.53689%2026.3588C9.77278%2025.2441%209.58915%2024.0809%209.02161%2023.0947L13.2743%2019.2719C14.1021%2019.8983%2015.1177%2020.2212%2016.1527%2020.187C17.1877%2020.1528%2018.18%2019.7636%2018.9653%2019.0839L22.8564%2022.1313C22.4174%2023.0251%2022.2795%2024.0385%2022.4637%2025.0182C22.6479%2025.9978%2023.1441%2026.8904%2023.8772%2027.5608C24.6104%2028.2311%2025.5405%2028.6428%2026.5267%2028.7333C27.513%2028.8239%2028.5017%2028.5885%2029.3432%2028.0627C30.1847%2027.537%2030.8332%2026.7495%2031.1904%2025.8196C31.5476%2024.8896%2031.5941%2023.8678%2031.3229%2022.9088C31.0517%2021.9499%2030.4775%2021.106%2029.6873%2020.5049C28.8971%2019.9039%2027.9339%2019.5784%2026.9436%2019.5778Z'%20fill='%2318181B'/%3e%3c/svg%3e";
var mO = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, YM = si.createContext && /* @__PURE__ */ si.createContext(mO), hae = ["attr", "size", "title"];
function dae(r, e) {
  if (r == null) return {};
  var i = pae(r, e), n, s;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(r);
    for (s = 0; s < a.length; s++)
      n = a[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (i[n] = r[n]);
  }
  return i;
}
function pae(r, e) {
  if (r == null) return {};
  var i = {};
  for (var n in r)
    if (Object.prototype.hasOwnProperty.call(r, n)) {
      if (e.indexOf(n) >= 0) continue;
      i[n] = r[n];
    }
  return i;
}
function ig() {
  return ig = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n]);
    }
    return r;
  }, ig.apply(this, arguments);
}
function KM(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function rg(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? KM(Object(i), !0).forEach(function(n) {
      fae(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : KM(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function fae(r, e, i) {
  return e = mae(e), e in r ? Object.defineProperty(r, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = i, r;
}
function mae(r) {
  var e = gae(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function gae(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function gO(r) {
  return r && r.map((e, i) => /* @__PURE__ */ si.createElement(e.tag, rg({
    key: i
  }, e.attr), gO(e.child)));
}
function yO(r) {
  return (e) => /* @__PURE__ */ si.createElement(yae, ig({
    attr: rg({}, r.attr)
  }, e), gO(r.child));
}
function yae(r) {
  var e = (i) => {
    var {
      attr: n,
      size: s,
      title: a
    } = r, o = dae(r, hae), l = s || i.size || "1em", u;
    return i.className && (u = i.className), r.className && (u = (u ? u + " " : "") + r.className), /* @__PURE__ */ si.createElement("svg", ig({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, i.attr, n, o, {
      className: u,
      style: rg(rg({
        color: r.color || i.color
      }, i.style), r.style),
      height: l,
      width: l,
      xmlns: "http://www.w3.org/2000/svg"
    }), a && /* @__PURE__ */ si.createElement("title", null, a), r.children);
  };
  return YM !== void 0 ? /* @__PURE__ */ si.createElement(YM.Consumer, null, (i) => e(i)) : e(mO);
}
function vae(r) {
  return yO({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z" }, child: [] }] })(r);
}
function bae(r) {
  return yO({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z" }, child: [] }] })(r);
}
const ZM = {
  background: "#ffd32a",
  color: "#18181b",
  border: "none",
  borderRadius: 12,
  width: 54,
  height: 54,
  fontSize: 22,
  fontWeight: "bold",
  boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
  cursor: "pointer",
  marginBottom: 0,
  marginTop: 0,
  textTransform: "uppercase",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: 0,
  transition: "background 0.2s, color 0.2s, transform 0.1s"
}, xae = {
  background: "#ffe066",
  color: "#18181b",
  transform: "translateY(-2px) scale(1.03)"
}, _ae = ({
  onReset: r,
  onBack: e,
  onForward: i,
  canGoBack: n,
  canGoForward: s
}) => {
  const [a, o] = si.useState(""), l = (u) => a === u ? { ...ZM, ...xae } : ZM;
  return /* @__PURE__ */ se.jsxs(
    "div",
    {
      style: {
        position: "absolute",
        top: "5px",
        left: "8px",
        zIndex: 50,
        display: "flex",
        flexDirection: "row",
        gap: "16px",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              width: 54,
              height: 54
              // Espace vide pour maintenir l'alignement
            }
          }
        ),
        /* @__PURE__ */ se.jsx(
          "button",
          {
            style: { ...l("graph"), width: 54 },
            onClick: r,
            "aria-label": "Return to graph",
            onMouseEnter: () => o("graph"),
            onMouseLeave: () => o(""),
            children: /* @__PURE__ */ se.jsx("img", { src: cae, alt: "PI Graph", style: { width: 28, height: 28 } })
          }
        ),
        /* @__PURE__ */ se.jsx(
          "button",
          {
            style: { ...l("prev"), opacity: n ? 1 : 0.5 },
            onClick: e,
            disabled: !n,
            "aria-label": "Previous",
            onMouseEnter: () => o("prev"),
            onMouseLeave: () => o(""),
            children: /* @__PURE__ */ se.jsx(vae, {})
          }
        ),
        /* @__PURE__ */ se.jsx(
          "button",
          {
            style: { ...l("next"), opacity: s ? 1 : 0.5 },
            onClick: i,
            disabled: !s,
            "aria-label": "Next",
            onMouseEnter: () => o("next"),
            onMouseLeave: () => o(""),
            children: /* @__PURE__ */ se.jsx(bae, {})
          }
        )
      ]
    }
  );
}, Tae = ({ viewMode: r, onViewModeChange: e }) => /* @__PURE__ */ se.jsxs(
  "div",
  {
    className: "agent-navbar",
    style: {
      display: "flex",
      flexDirection: "column",
      alignItems: "left",
      gap: "10px"
    },
    children: [
      /* @__PURE__ */ se.jsx("label", { htmlFor: "viewMode", style: { color: "#ffd32a" }, children: "View Mode:" }),
      /* @__PURE__ */ se.jsxs(
        "select",
        {
          id: "viewMode",
          value: r,
          onChange: (i) => e(i.target.value),
          style: {
            background: "#ffd32a",
            color: "rgb(24, 24, 27)",
            borderRadius: "12px",
            height: "42px",
            padding: "6px 12px",
            fontWeight: "bold",
            fontSize: 15,
            outline: "none",
            cursor: "pointer"
          },
          children: [
            /* @__PURE__ */ se.jsx("option", { value: "2D", children: "2D" }),
            /* @__PURE__ */ se.jsx("option", { value: "3D", children: "3D" }),
            /* @__PURE__ */ se.jsx("option", { value: "VR", children: "VR" })
          ]
        }
      )
    ]
  }
), fm = (r) => {
  const e = [], i = [], n = /* @__PURE__ */ new Map();
  return r.forEach(({ subject: s, predicate: a, object: o }) => {
    if (!n.has(s.id)) {
      const l = {
        id: s.id,
        label: s.label,
        image: s.image,
        isTriple: !1,
        color: Nu("subject"),
        type: "subject"
      };
      n.set(s.id, l), e.push(l);
    }
    if (!n.has(o.id)) {
      const l = {
        id: o.id,
        label: o.label,
        image: o.image,
        isTriple: !1,
        color: Nu("object"),
        type: "object"
      };
      n.set(o.id, l), e.push(l);
    }
    i.push({
      source: s.id,
      target: o.id,
      type: "subject-to-object",
      label: a.label,
      predicateId: a.id
    });
  }), { nodes: e, links: i };
}, wae = "0x5dc0a2335c12343d8e0f71b62a73fbf70d06fcbaf647f57d82a189873ad90da3", Sae = (r, e = "base", i, n) => {
  const s = i || wae, [a, o] = ye({ nodes: [], links: [] }), [l, u] = ye(null), [c, h] = ye(!0), [d, p] = ye(null), [f, m] = ye(!1), [y, v] = ye([]), [g, _] = ye(0), x = Gi(null), [b, T] = ye(""), [E, M] = ye(""), [C, S] = ye(""), [w, R] = ye(!1), [O, P] = ye(!1), A = mr(async () => {
    m(!0);
    try {
      let B;
      e === "agent" ? B = await U5(s, r) : B = await x_(r);
      const W = fm(B);
      o(W), u(W);
    } catch (B) {
      console.error("Error loading graph data:", B);
    } finally {
      m(!1);
    }
  }, [r, e]), D = mr(() => {
    o(l), p(null), T(""), M(""), S(""), P(!1);
  }, [l]), L = mr(
    async (B, W, G) => {
      if (B === null) {
        p(null);
        return;
      }
      if (p(B), n && n(B), W && W.current)
        try {
          const z = {
            x: B.x,
            y: B.y,
            z: B.z || 0
          }, K = await L5(B.id, r), ne = fm(K), oe = ne.nodes.find((pe) => pe.id === B.id);
          oe && (oe.x = z.x, oe.y = z.y, G === "3D" && (oe.z = z.z), oe.fx = z.x, oe.fy = z.y, G === "3D" && (oe.fz = z.z)), v((pe) => {
            const xe = pe.slice(
              0,
              g + 1
            );
            return xe.push({ graphData: a, selectedTriple: B }), xe;
          }), _((pe) => pe + 1), o(ne);
        } catch (z) {
          console.error("Error fetching triples:", z);
        }
    },
    [r, a, g]
  ), H = mr((B, W) => {
    switch (x.current && clearTimeout(x.current), B) {
      case "subject":
        T(W);
        break;
      case "predicate":
        M(W);
        break;
      case "object":
        S(W);
        break;
    }
    x.current = setTimeout(() => {
      P(!0);
    }, 500);
  }, []), V = mr(async () => {
    if (O) {
      if (!b && !E && !C) {
        D();
        return;
      }
      R(!0);
      try {
        const B = await Pu({
          subject: b,
          predicate: E,
          object: C
        }, r);
        if (!B || B.length === 0) {
          o({ nodes: [], links: [] });
          return;
        }
        const W = fm(B);
        o(W), v((G) => {
          const z = G.slice(0, g + 1);
          return z.push({ graphData: W, selectedTriple: null }), z;
        }), _((G) => G + 1);
      } catch (B) {
        console.error("Error searching triples:", B);
      } finally {
        R(!1), P(!1);
      }
    }
  }, [
    b,
    E,
    C,
    r,
    D,
    g,
    O
  ]), X = mr(() => {
    if (g > 0) {
      const { graphData: B, selectedTriple: W } = y[g - 1];
      o(B), p(W), _((G) => G - 1);
    }
  }, [g, y]), F = mr(() => {
    if (g < y.length - 1) {
      const { graphData: B, selectedTriple: W } = y[g + 1];
      o(B), p(W), _((G) => G + 1);
    }
  }, [g, y]);
  return {
    graphData: a,
    initialGraphData: l,
    isInitialLoad: c,
    selectedTriple: d,
    isLoading: f,
    isSearching: w,
    subjectFilter: b,
    predicateFilter: E,
    objectFilter: C,
    shouldSearch: O,
    canGoBack: g > 0,
    canGoForward: g < y.length - 1,
    setSelectedTriple: p,
    setIsInitialLoad: h,
    loadInitialData: A,
    resetGraph: D,
    handleNodeClick: L,
    handleFilterChange: H,
    applyFilters: V,
    goBack: X,
    goForward: F,
    setGraphData: o,
    graphHistory: y,
    setGraphHistory: v,
    currentHistoryIndex: g,
    setCurrentHistoryIndex: _
  };
};
let Lh = {
  endpoint: null,
  data: null,
  timestamp: null
};
const Eae = 15 * 60 * 1e3, Mae = async (r) => {
  const e = Date.now();
  if (Lh.data && Lh.endpoint === r && e - Lh.timestamp < Eae)
    return Lh.data;
  const i = await x_(r);
  return Lh = {
    endpoint: r,
    data: i,
    timestamp: e
  }, i;
}, Aae = async (r, e = "base", i = 10) => {
  if (!r || r.length < 1)
    return { subjects: [], predicates: [], objects: [], triples: [] };
  const n = r.toLowerCase().trim();
  if (["is", "of", "in", "at", "by", "to"].includes(n))
    try {
      const s = await Pu({ predicate: n }, e);
      if (s && s.length > 0)
        return {
          subjects: [...new Set(s.map((a) => a.subject.label))].slice(0, i),
          predicates: [n],
          objects: [...new Set(s.map((a) => a.object.label))].slice(0, i),
          triples: s.map((a) => ({
            subject: a.subject.label,
            predicate: a.predicate.label,
            object: a.object.label
          })).slice(0, i)
        };
    } catch {
    }
  try {
    const s = (await Mae(e)).filter((f) => n.length <= 3 ? f.subject && f.subject.label && f.subject.label.toLowerCase().indexOf(n) !== -1 || f.predicate && f.predicate.label && f.predicate.label.toLowerCase().indexOf(n) !== -1 || f.object && f.object.label && f.object.label.toLowerCase().indexOf(n) !== -1 : f.subject && f.subject.label && f.subject.label.toLowerCase().includes(n) || f.predicate && f.predicate.label && f.predicate.label.toLowerCase().includes(n) || f.object && f.object.label && f.object.label.toLowerCase().includes(n));
    if (s.length > 0) {
      const f = (x) => {
        if (!x) return 0;
        const b = x.toLowerCase();
        let T = 100 - Math.min(x.length, 50);
        return b.startsWith(n) && (T += 200), b === n && (T += 300), !/^0x[0-9a-f]{8,}$/i.test(b) && !/[0-9a-f]{30,}/i.test(b) && (T += 150), /^[A-Za-z0-9]+ - [A-Za-z0-9 ]+$/.test(x) && (T += 100), T;
      }, m = [...new Set(
        s.filter((x) => x.subject && x.subject.label && x.subject.label.toLowerCase().indexOf(n) !== -1).map((x) => x.subject.label)
      )].sort((x, b) => f(b) - f(x));
      let y = [...new Set(
        s.filter((x) => x.predicate && x.predicate.label && x.predicate.label.toLowerCase().indexOf(n) !== -1).map((x) => x.predicate.label)
      )].sort((x, b) => x.toLowerCase() === n ? -1 : b.toLowerCase() === n ? 1 : f(b) - f(x));
      const v = [...new Set(
        s.filter((x) => x.object && x.object.label && x.object.label.toLowerCase().indexOf(n) !== -1).map((x) => x.object.label)
      )].sort((x, b) => f(b) - f(x)), g = (x) => {
        if (!x) return 0;
        const b = x.subject ? f(x.subject) : 0, T = x.predicate ? f(x.predicate) : 0, E = x.object ? f(x.object) : 0;
        return Math.max(b, T, E);
      }, _ = s.map((x) => ({
        subject: x.subject.label,
        predicate: x.predicate.label,
        object: x.object.label
      })).sort((x, b) => g(b) - g(x)).slice(0, i);
      return {
        subjects: m.slice(0, i),
        predicates: y.slice(0, i),
        objects: v.slice(0, i),
        triples: _
      };
    }
    const a = await Pu({ subject: r }, e), o = await Pu({ predicate: r }, e), l = await Pu({ object: r }, e);
    let u = [...a || []];
    o && o.length > 0 && (u = [...u, ...o.filter(
      (f) => !u.some((m) => m.id === f.id)
    )]), l && l.length > 0 && (u = [...u, ...l.filter(
      (f) => !u.some((m) => m.id === f.id)
    )]);
    const c = [...new Set(
      u.filter((f) => f.subject && f.subject.label).map((f) => f.subject.label).filter((f) => f.toLowerCase().includes(n))
    )], h = [...new Set(
      u.filter((f) => f.predicate && f.predicate.label).map((f) => f.predicate.label).filter((f) => f.toLowerCase().includes(n))
    )], d = [...new Set(
      u.filter((f) => f.object && f.object.label).map((f) => f.object.label).filter((f) => f.toLowerCase().includes(n))
    )], p = u.map((f) => ({
      subject: f.subject.label,
      predicate: f.predicate.label,
      object: f.object.label
    })).slice(0, i);
    return {
      subjects: c.slice(0, i),
      predicates: h.slice(0, i),
      objects: d.slice(0, i),
      triples: p
    };
  } catch {
    return { subjects: [], predicates: [], objects: [], triples: [] };
  }
}, Cae = ({
  endpoint: r,
  onSearch: e,
  isSearching: i,
  onSearchStart: n
}) => {
  const [s, a] = ye(""), [o, l] = ye({
    subjects: [],
    predicates: [],
    objects: [],
    triples: []
  }), [u, c] = ye({
    subject: "",
    predicate: "",
    object: ""
  }), [h, d] = ye(!1), [p, f] = ye(!1), m = Gi(null), y = Gi(null);
  Ft(() => {
    const P = (A) => {
      y.current && !y.current.contains(A.target) && d(!1);
    };
    return document.addEventListener("mousedown", P), () => {
      document.removeEventListener("mousedown", P);
    };
  }, []), Ft(() => (s.length >= 2 ? (clearTimeout(m.current), f(!0), d(!0), m.current = setTimeout(async () => {
    try {
      const P = await Aae(s, r);
      l(P), d(!0), f(!1);
    } catch (P) {
      console.error("Error retrieving suggestions:", P), f(!1);
    }
  }, 300)) : (l({
    subjects: [],
    predicates: [],
    objects: [],
    triples: []
  }), d(!1), f(!1)), () => {
    clearTimeout(m.current);
  }), [s, r]);
  const v = (P, A) => {
    c((D) => ({
      ...D,
      [P]: D[P] === A ? "" : A
    }));
  }, g = async () => {
    typeof n == "function" && n();
    try {
      const P = {
        subject: u.subject || "",
        predicate: u.predicate || "",
        object: u.object || ""
      };
      typeof e == "function" && await e(s, P);
    } catch {
    }
  }, _ = u.subject || u.predicate || u.object, x = o.subjects.length > 0 || o.predicates.length > 0 || o.objects.length > 0 || o.triples && o.triples.length > 0, b = {
    container: {
      width: "100%",
      maxWidth: "550px",
      margin: "0 auto",
      position: "relative",
      zIndex: 1e3
    },
    inputWrapper: {
      display: "flex",
      width: "100%",
      boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
      borderRadius: "12px",
      overflow: "hidden",
      backgroundColor: "rgba(30, 30, 40, 0.6)",
      backdropFilter: "blur(5px)",
      border: "1px solid rgba(255, 255, 255, 0.2)"
    },
    input: {
      flex: 1,
      padding: "10px 15px",
      fontSize: "15px",
      border: "none",
      backgroundColor: "transparent",
      color: "white",
      outline: "none",
      fontWeight: "400",
      height: "40px"
    },
    button: {
      padding: "0 22px",
      border: "none",
      cursor: "pointer",
      fontWeight: "bold",
      fontSize: "15px",
      textTransform: "uppercase"
    },
    activeFilters: {
      display: "flex",
      flexWrap: "wrap",
      alignItems: "center",
      marginTop: "12px",
      padding: "8px 12px",
      backgroundColor: "rgba(30, 30, 40, 0.7)",
      borderRadius: "6px",
      border: "1px solid rgba(255, 255, 255, 0.1)",
      backdropFilter: "blur(5px)"
    },
    filtersLabel: {
      fontWeight: "600",
      marginRight: "12px",
      color: "rgba(255, 255, 255, 0.9)",
      fontSize: "13px"
    },
    filtersChips: {
      display: "flex",
      flexWrap: "wrap",
      gap: "6px",
      flex: 1
    },
    filterChip: {
      display: "flex",
      alignItems: "center",
      padding: "3px 8px",
      borderRadius: "16px",
      fontSize: "12px",
      color: "white",
      boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
    },
    subjectChip: {
      backgroundColor: `${Si.SUBJECT}cc`
    },
    predicateChip: {
      backgroundColor: `${Si.PREDICATE}cc`
    },
    objectChip: {
      backgroundColor: `${Si.OBJECT}cc`
    },
    chipButton: {
      background: "none",
      border: "none",
      color: "white",
      marginLeft: "4px",
      cursor: "pointer",
      fontSize: "14px",
      lineHeight: 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "16px",
      height: "16px",
      borderRadius: "50%",
      transition: "background-color 0.2s ease"
    },
    chipButtonHover: {
      backgroundColor: "rgba(255, 255, 255, 0.2)"
    },
    clearButton: {
      padding: "4px 10px",
      backgroundColor: "rgba(255, 70, 70, 0.8)",
      color: "white",
      border: "none",
      borderRadius: "16px",
      cursor: "pointer",
      fontSize: "12px",
      fontWeight: "500",
      boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)",
      transition: "background-color 0.2s ease",
      marginLeft: "auto"
    },
    clearButtonHover: {
      backgroundColor: "rgba(255, 70, 70, 1)"
    },
    suggestionsContainer: {
      position: "absolute",
      top: "calc(100% + 8px)",
      left: 0,
      right: 0,
      backgroundColor: "rgba(25, 25, 35, 0.9)",
      backdropFilter: "blur(10px)",
      border: "1px solid rgba(255, 255, 255, 0.1)",
      borderRadius: "8px",
      maxHeight: "400px",
      overflowY: "auto",
      zIndex: 1001,
      boxShadow: "0 8px 16px rgba(0, 0, 0, 0.3)",
      color: "white"
    },
    suggestionCategory: {
      padding: "14px",
      borderBottom: "1px solid rgba(255, 255, 255, 0.1)"
    },
    categoryHeader: {
      fontWeight: "600",
      marginBottom: "10px",
      color: "rgba(255, 255, 255, 0.8)",
      fontSize: "14px",
      textTransform: "uppercase",
      letterSpacing: "0.5px"
    },
    suggestionList: {
      display: "flex",
      flexWrap: "wrap",
      gap: "8px"
    },
    suggestionItem: {
      padding: "3px 8px",
      borderRadius: "16px",
      backgroundColor: "rgba(255, 255, 255, 0.15)",
      fontSize: "12px",
      cursor: "pointer",
      transition: "all 0.2s ease",
      color: "rgba(255, 255, 255, 0.9)"
    },
    suggestionItemHover: {
      backgroundColor: "rgba(255, 255, 255, 0.25)"
    },
    selectedSuggestion: {
      backgroundColor: "#4A66E8",
      color: "white"
    },
    loadingContainer: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: "25px"
    },
    loader: {
      width: "30px",
      height: "30px",
      border: "3px solid rgba(255,255,255,0.2)",
      borderRadius: "50%",
      borderTop: "3px solid #ffd32a",
      animation: "spin 1s linear infinite"
    },
    noResults: {
      padding: "25px",
      textAlign: "center",
      fontSize: "14px",
      color: "rgba(255,255,255,0.7)"
    },
    tripleSuggestion: {
      padding: "8px 12px",
      borderRadius: "12px",
      fontSize: "13px",
      cursor: "pointer",
      transition: "all 0.2s ease",
      backgroundColor: "rgba(30, 30, 40, 0.55)",
      backdropFilter: "blur(5px)",
      border: "1px solid rgba(255, 255, 255, 0.15)",
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      gap: "6px",
      alignItems: "center",
      justifyContent: "center"
    },
    tripleSuggestionHover: {
      backgroundColor: "rgba(50, 50, 60, 0.65)"
    },
    tripleSubjectPart: {
      color: Si.SUBJECT,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Si.SUBJECT}33`
    },
    triplePredicatePart: {
      color: Si.PREDICATE,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Si.PREDICATE}33`
    },
    tripleObjectPart: {
      color: Si.OBJECT,
      fontWeight: "500",
      padding: "2px 6px",
      borderRadius: "4px",
      backgroundColor: `${Si.OBJECT}33`
    },
    subjectSuggestion: {
      backgroundColor: Si.SUBJECT,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    },
    predicateSuggestion: {
      backgroundColor: Si.PREDICATE,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    },
    objectSuggestion: {
      backgroundColor: Si.OBJECT,
      color: "#fff",
      fontWeight: "500",
      border: "none"
    }
  }, [T, E] = ye(!1), [M, C] = ye(!1), [S, w] = ye(null), [R, O] = ye(null);
  return /* @__PURE__ */ se.jsxs("div", { style: b.container, children: [
    /* @__PURE__ */ se.jsx("style", { children: `
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        ` }),
    /* @__PURE__ */ se.jsxs("div", { style: b.inputWrapper, children: [
      /* @__PURE__ */ se.jsx(
        "input",
        {
          type: "text",
          value: s,
          onChange: (P) => a(P.target.value),
          placeholder: "Search for triples...",
          style: b.input,
          onFocus: () => {
            s.length >= 2 && d(!0);
          }
        }
      ),
      /* @__PURE__ */ se.jsx(
        "button",
        {
          onClick: g,
          disabled: i,
          style: {
            ...b.button,
            backgroundColor: "#ffd32a",
            color: "#18181b",
            height: "40px",
            borderRadius: "0 12px 12px 0",
            boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
            transition: "background 0.2s, color 0.2s, transform 0.1s"
          },
          onMouseEnter: (P) => P.currentTarget.style.backgroundColor = "#ffe066",
          onMouseLeave: (P) => P.currentTarget.style.backgroundColor = "#ffd32a",
          children: i ? "Searching..." : "Search"
        }
      )
    ] }),
    _ && /* @__PURE__ */ se.jsxs("div", { style: b.activeFilters, children: [
      /* @__PURE__ */ se.jsx("div", { style: b.filtersLabel, children: "Active filters:" }),
      /* @__PURE__ */ se.jsxs("div", { style: b.filtersChips, children: [
        u.subject && /* @__PURE__ */ se.jsxs("div", { style: { ...b.filterChip, ...b.subjectChip }, children: [
          /* @__PURE__ */ se.jsxs("span", { children: [
            "Subject: ",
            u.subject
          ] }),
          /* @__PURE__ */ se.jsx(
            "button",
            {
              onClick: () => v("subject", u.subject),
              style: {
                ...b.chipButton,
                ...S === "subject" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => w("subject"),
              onMouseLeave: () => w(null),
              children: "×"
            }
          )
        ] }),
        u.predicate && /* @__PURE__ */ se.jsxs("div", { style: { ...b.filterChip, ...b.predicateChip }, children: [
          /* @__PURE__ */ se.jsxs("span", { children: [
            "Predicate: ",
            u.predicate
          ] }),
          /* @__PURE__ */ se.jsx(
            "button",
            {
              onClick: () => v("predicate", u.predicate),
              style: {
                ...b.chipButton,
                ...S === "predicate" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => w("predicate"),
              onMouseLeave: () => w(null),
              children: "×"
            }
          )
        ] }),
        u.object && /* @__PURE__ */ se.jsxs("div", { style: { ...b.filterChip, ...b.objectChip }, children: [
          /* @__PURE__ */ se.jsxs("span", { children: [
            "Object: ",
            u.object
          ] }),
          /* @__PURE__ */ se.jsx(
            "button",
            {
              onClick: () => v("object", u.object),
              style: {
                ...b.chipButton,
                ...S === "object" ? b.chipButtonHover : {}
              },
              onMouseEnter: () => w("object"),
              onMouseLeave: () => w(null),
              children: "×"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ se.jsx(
        "button",
        {
          onClick: () => c({ subject: "", predicate: "", object: "" }),
          style: {
            ...b.clearButton,
            ...M ? b.clearButtonHover : {}
          },
          onMouseEnter: () => C(!0),
          onMouseLeave: () => C(!1),
          children: "Clear all filters"
        }
      )
    ] }),
    h && /* @__PURE__ */ se.jsxs("div", { style: b.suggestionsContainer, ref: y, children: [
      p && /* @__PURE__ */ se.jsx("div", { style: b.loadingContainer, children: /* @__PURE__ */ se.jsx("div", { style: b.loader }) }),
      !p && !x && s.length >= 2 && /* @__PURE__ */ se.jsxs("div", { style: b.noResults, children: [
        'Aucune suggestion trouvée pour "',
        s,
        '"'
      ] }),
      !p && o.subjects.length > 0 && /* @__PURE__ */ se.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ se.jsx("div", { style: b.categoryHeader, children: "Suggested Subjects" }),
        /* @__PURE__ */ se.jsx("div", { style: b.suggestionList, children: o.subjects.map((P, A) => /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.subjectSuggestion,
              ...R === `subject-${A}` ? b.suggestionItemHover : {},
              ...u.subject === P ? b.selectedSuggestion : {}
            },
            onClick: () => v("subject", P),
            onMouseEnter: () => O(`subject-${A}`),
            onMouseLeave: () => O(null),
            children: P
          },
          `subject-${A}`
        )) })
      ] }),
      !p && o.predicates.length > 0 && /* @__PURE__ */ se.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ se.jsx("div", { style: b.categoryHeader, children: "Suggested Predicates" }),
        /* @__PURE__ */ se.jsx("div", { style: b.suggestionList, children: o.predicates.map((P, A) => /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.predicateSuggestion,
              ...R === `predicate-${A}` ? b.suggestionItemHover : {},
              ...u.predicate === P ? b.selectedSuggestion : {}
            },
            onClick: () => v("predicate", P),
            onMouseEnter: () => O(`predicate-${A}`),
            onMouseLeave: () => O(null),
            children: P
          },
          `predicate-${A}`
        )) })
      ] }),
      !p && o.objects.length > 0 && /* @__PURE__ */ se.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ se.jsx("div", { style: b.categoryHeader, children: "Suggested Objects" }),
        /* @__PURE__ */ se.jsx("div", { style: b.suggestionList, children: o.objects.map((P, A) => /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              ...b.suggestionItem,
              ...b.objectSuggestion,
              ...R === `object-${A}` ? b.suggestionItemHover : {},
              ...u.object === P ? b.selectedSuggestion : {}
            },
            onClick: () => v("object", P),
            onMouseEnter: () => O(`object-${A}`),
            onMouseLeave: () => O(null),
            children: P
          },
          `object-${A}`
        )) })
      ] }),
      !p && o.triples && o.triples.length > 0 && /* @__PURE__ */ se.jsxs("div", { style: b.suggestionCategory, children: [
        /* @__PURE__ */ se.jsx("div", { style: b.categoryHeader, children: "Suggested Triples" }),
        /* @__PURE__ */ se.jsx("div", { style: b.suggestionList, children: o.triples.map((P, A) => /* @__PURE__ */ se.jsxs(
          "div",
          {
            style: {
              ...b.tripleSuggestion,
              ...R === `triple-${A}` ? b.tripleSuggestionHover : {}
            },
            onClick: () => {
              c({
                subject: P.subject,
                predicate: P.predicate,
                object: P.object
              });
            },
            onMouseEnter: () => O(`triple-${A}`),
            onMouseLeave: () => O(null),
            children: [
              /* @__PURE__ */ se.jsx("span", { style: b.tripleSubjectPart, children: P.subject }),
              /* @__PURE__ */ se.jsx("span", { style: b.triplePredicatePart, children: P.predicate }),
              /* @__PURE__ */ se.jsx("span", { style: b.tripleObjectPart, children: P.object })
            ]
          },
          `triple-${A}`
        )) })
      ] })
    ] })
  ] });
}, Rae = ({ endpoint: r, walletAddress: e, onNodeSelect: i, onLoadingChange: n, gamesId: s, disableNodeDetailsSidebar: a = !1 }) => {
  const o = Gi(), l = Gi(), [u, c] = si.useState("2D"), [h, d] = si.useState(!1), [p, f] = ye(!1), [m, y] = ye(!1), [v, g] = ye(!1), [_, x] = ye(null), [b, T] = si.useState("agent"), {
    graphData: E,
    isInitialLoad: M,
    selectedTriple: C,
    isLoading: S,
    isSearching: w,
    subjectFilter: R,
    predicateFilter: O,
    objectFilter: P,
    shouldSearch: A,
    canGoBack: D,
    canGoForward: L,
    setIsInitialLoad: H,
    loadInitialData: V,
    resetGraph: X,
    handleNodeClick: F,
    handleFilterChange: B,
    applyFilters: W,
    goBack: G,
    goForward: z,
    setGraphData: K,
    setGraphHistory: ne,
    currentHistoryIndex: oe,
    setCurrentHistoryIndex: pe
  } = Sae(r, b, s, i), xe = v && _ ? _ : E, Re = m || w;
  Ft(() => {
    V();
  }, [V, b]), Ft(() => {
    A && (g(!1), W());
  }, [A, W]);
  const nt = () => {
    M && o.current && H(!1);
  }, fe = async (Be, At) => {
    try {
      y(!0);
      const st = {
        subject: At.subject || "",
        predicate: At.predicate || "",
        object: At.object || ""
      }, j = await Pu(st, r);
      if (j && j.length > 0) {
        const k = fm(j);
        g(!1), K(k), ne((le) => {
          const we = le.slice(0, oe + 1);
          return we.push({
            graphData: k,
            selectedTriple: null,
            filters: st
          }), we;
        }), pe((le) => le + 1);
      } else
        K({ nodes: [], links: [] });
    } catch {
      K({ nodes: [], links: [] });
    } finally {
      y(!1);
    }
  }, gt = () => {
    y(!0);
  }, Q = () => {
    g(!1), X();
  }, Gt = (Be, At) => {
    g(!1), B(Be, At);
  }, Qe = () => {
    v && g(!1);
  }, bt = () => /* @__PURE__ */ se.jsxs(
    "div",
    {
      style: {
        display: "none",
        alignItems: "center",
        backgroundColor: "#27272a",
        padding: "8px 12px",
        borderRadius: 8,
        marginLeft: 12,
        boxShadow: "0 2px 8px rgba(0,0,0,0.2)"
      },
      children: [
        /* @__PURE__ */ se.jsx("span", { style: { color: "white", marginRight: 10, fontSize: 14 }, children: "Graph Type:" }),
        /* @__PURE__ */ se.jsxs(
          "select",
          {
            value: b,
            onChange: (Be) => T(Be.target.value),
            style: {
              backgroundColor: "#3f3f46",
              color: "white",
              border: "none",
              padding: "4px 8px",
              borderRadius: 4,
              cursor: "pointer"
            },
            children: [
              /* @__PURE__ */ se.jsx("option", { value: "base", children: "Base" }),
              /* @__PURE__ */ se.jsx("option", { value: "agent", children: "Agent" })
            ]
          }
        )
      ]
    }
  );
  return /* @__PURE__ */ se.jsxs(
    "div",
    {
      ref: l,
      className: "graph-visualization-container",
      style: {
        position: "relative",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        width: "100%",
        height: "100%",
        overflow: "hidden"
      },
      children: [
        (S || Re || p) && /* @__PURE__ */ se.jsx(LC, {}),
        /* @__PURE__ */ se.jsx(
          _ae,
          {
            onReset: Q,
            onBack: () => {
              Qe(), G();
            },
            onForward: () => {
              Qe(), z();
            },
            canGoBack: D,
            canGoForward: L
          }
        ),
        /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "80px",
              left: "5px",
              zIndex: 50
            },
            children: /* @__PURE__ */ se.jsx(Tae, { viewMode: u, onViewModeChange: c })
          }
        ),
        /* @__PURE__ */ se.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "10px",
              left: "50%",
              transform: "translateX(-50%)",
              zIndex: 1e3,
              width: "550px",
              maxWidth: "calc(100% - 350px)"
            },
            children: /* @__PURE__ */ se.jsx(
              Cae,
              {
                endpoint: r,
                onSearch: fe,
                isSearching: Re,
                onSearchStart: gt
              }
            )
          }
        ),
        /* @__PURE__ */ se.jsxs(
          "div",
          {
            className: "agent-navbar",
            style: {
              position: "absolute",
              top: "5px",
              right: "5px",
              zIndex: 10,
              display: "flex",
              flexDirection: "row",
              alignItems: "center",
              gap: "16px"
            },
            children: [
              /* @__PURE__ */ se.jsx(bt, {}),
              !h && /* @__PURE__ */ se.jsx(
                "button",
                {
                  style: {
                    background: "#ffd32a",
                    color: "#18181b",
                    border: "none",
                    borderRadius: 12,
                    top: 5,
                    width: 120,
                    height: 54,
                    fontSize: 18,
                    fontWeight: "bold",
                    boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
                    cursor: "pointer",
                    textTransform: "uppercase",
                    transition: "background 0.2s, color 0.2s, transform 0.1s"
                  },
                  onMouseEnter: (Be) => Be.currentTarget.style.background = "#ffe066",
                  onMouseLeave: (Be) => Be.currentTarget.style.background = "#ffd32a",
                  onClick: () => d((Be) => !Be),
                  children: "Filters"
                }
              ),
              h && /* @__PURE__ */ se.jsx(
                "div",
                {
                  style: {
                    marginLeft: 12,
                    display: "flex",
                    alignItems: "center",
                    gap: 16,
                    position: "relative"
                  },
                  children: /* @__PURE__ */ se.jsx(
                    "div",
                    {
                      style: {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "flex-end",
                        position: "relative"
                      },
                      children: /* @__PURE__ */ se.jsx(
                        B5,
                        {
                          subjectFilter: R,
                          predicateFilter: O,
                          objectFilter: P,
                          onFilterChange: Gt,
                          onReset: Q,
                          onClose: () => d(!1)
                        }
                      )
                    }
                  )
                }
              )
            ]
          }
        ),
        u === "2D" && /* @__PURE__ */ se.jsx(
          oae,
          {
            graphData: xe,
            onNodeClick: (Be) => {
              Qe(), F(Be, o, u);
            },
            onEngineStop: nt,
            fgRef: o,
            selectedTriple: C,
            endpoint: r,
            disableNodeDetailsSidebar: a,
            children: /* @__PURE__ */ se.jsx(YT, {})
          }
        ),
        u === "3D" && /* @__PURE__ */ se.jsx(
          uae,
          {
            graphData: xe,
            onNodeClick: (Be) => {
              Qe(), F(Be, o, u);
            },
            onEngineStop: nt,
            fgRef: o,
            selectedTriple: C,
            endpoint: r,
            disableNodeDetailsSidebar: a,
            children: /* @__PURE__ */ se.jsx(YT, {})
          }
        ),
        u === "VR" && /* @__PURE__ */ se.jsx(
          F5,
          {
            graphData: xe,
            onNodeClick: (Be) => {
              Qe(), F(Be, o, u);
            },
            onBack: () => {
              Qe(), G();
            },
            onForward: () => {
              Qe(), z();
            },
            selectedTriple: C,
            endpoint: r,
            disableNodeDetailsSidebar: a
          }
        )
      ]
    }
  );
};
function Nae({
  open: r,
  onClose: e,
  children: i
}) {
  return /* @__PURE__ */ I.jsx(
    "div",
    {
      style: {
        position: "absolute",
        top: "25%",
        left: "5px",
        height: "70%",
        width: r ? "28.67vw" : 0,
        minWidth: r ? "350px" : 0,
        backgroundColor: "rgba(0, 0, 0, 0.85)",
        borderRadius: 18,
        transition: "width 0.35s cubic-bezier(0.4, 1.3, 0.5, 1)",
        zIndex: 1300,
        boxShadow: "2px 0 16px rgba(0, 0, 0, 0.18)",
        border: r ? "1px solid rgba(255,255,255,0.1)" : "none",
        overflow: "hidden"
      },
      children: r && /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
        /* @__PURE__ */ I.jsx(
          "button",
          {
            style: {
              background: "none",
              border: "none",
              color: "#ffd32a",
              fontSize: 32,
              position: "absolute",
              top: 10,
              right: 18,
              cursor: "pointer",
              zIndex: 1302,
              transition: "color 0.2s"
            },
            onClick: e,
            children: "×"
          }
        ),
        /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              padding: "24px",
              overflowY: "auto",
              height: "100%"
            },
            children: i
          }
        )
      ] })
    }
  );
}
const Pae = ({ activity: r }) => {
  var d;
  Number(r.shares || 0);
  const e = r.term, i = r.vault_type, n = r.activity_type, s = i === "Triple" || i === "Atom", o = !(e != null && e.triple) || s ? e : (d = e == null ? void 0 : e.triple) == null ? void 0 : d.counter_term, l = () => {
    var p, f, m, y, v, g, _;
    return (f = (p = o == null ? void 0 : o.triple) == null ? void 0 : p.subject) != null && f.label && ((y = (m = o == null ? void 0 : o.triple) == null ? void 0 : m.predicate) != null && y.label) && ((g = (v = o == null ? void 0 : o.triple) == null ? void 0 : v.object) != null && g.label) ? {
      type: "triple",
      subject: o.triple.subject.label,
      predicate: o.triple.predicate.label,
      object: o.triple.object.label
    } : (_ = o == null ? void 0 : o.atom) != null && _.label ? {
      type: "atom",
      label: o.atom.label
    } : { type: "unknown" };
  }, u = () => n === "deposit" ? "Deposit" : "Redeem", c = n === "redemption", h = () => i || "Unknown";
  return /* @__PURE__ */ I.jsx(
    "div",
    {
      style: {
        background: "#232326",
        borderRadius: 14,
        padding: "18px 24px",
        marginBottom: 18,
        boxShadow: "0 2px 12px rgba(0,0,0,0.13)",
        borderLeft: `6px solid ${c ? "#F44336" : s ? "#006FE8" : "#FF9500"}`,
        position: "relative",
        display: "flex",
        flexDirection: "column",
        gap: 2
      },
      className: "activity-card",
      children: /* @__PURE__ */ I.jsx("div", { style: { display: "flex", alignItems: "center" }, children: /* @__PURE__ */ I.jsxs("div", { children: [
        /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8, marginBottom: 4 }, children: [
          /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: 700, minWidth: 110 }, children: "Position:" }),
          (() => {
            const p = l();
            return p.type === "triple" ? /* @__PURE__ */ I.jsx(
              ey,
              {
                subject: p.subject,
                predicate: p.predicate,
                object: p.object,
                fontSize: "13px"
              }
            ) : p.type === "atom" ? /* @__PURE__ */ I.jsx(
              SO,
              {
                label: p.label,
                fontSize: "13px"
              }
            ) : /* @__PURE__ */ I.jsx("span", { style: { color: "#fff", fontSize: "13px" }, children: "Unknown Position" });
          })()
        ] }),
        /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8, marginBottom: 4 }, children: [
          /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontWeight: 700, minWidth: 110 }, children: "Action:" }),
          /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
            /* @__PURE__ */ I.jsxs("span", { style: { color: "#fff", fontSize: "13px" }, children: [
              u(),
              " ",
              h()
            ] }),
            /* @__PURE__ */ I.jsx("span", { style: { color: "rgba(255, 255, 255, 0.6)" }, children: "-" }),
            /* @__PURE__ */ I.jsx(Nc, { isFor: s, fontSize: "12px" })
          ] })
        ] })
      ] }) })
    }
  );
}, Iae = (r, e) => {
  if (!r || !e || e === 0)
    return "0.00%";
  const i = Number(r), n = Number(e), s = i / n * 100;
  if (s < 0.01 && s > 0) {
    const a = i.toString(), l = n.toString().length - a.length;
    if (l > 5) {
      const u = Math.pow(10, l), h = i * u / n * 100;
      if (h >= 0.01 && h <= 100)
        return `${h.toFixed(2)}%`;
    }
  }
  return s > 100 ? `${s.toFixed(2)}% ⚠️` : s > 0 && s < 0.01 ? "< 0.01%" : `${s.toFixed(2)}%`;
}, Oae = ({
  positionId: r,
  shares: e,
  redeemAmount: i,
  onAmountChange: n
}) => /* @__PURE__ */ I.jsx("div", { style: {
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-end",
  gap: "6px",
  minWidth: "200px"
}, children: /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "6px", width: "100%" }, children: [
  /* @__PURE__ */ I.jsx(
    "input",
    {
      type: "number",
      value: i || e,
      onChange: (s) => n(r, parseFloat(s.target.value) || 0),
      max: e,
      min: 0,
      step: "0.000001",
      style: {
        width: "100%",
        padding: "4px 8px",
        borderRadius: "4px",
        border: "1px solid #374151",
        backgroundColor: "#232326",
        color: "#fff",
        fontSize: "12px"
      }
    }
  ),
  /* @__PURE__ */ I.jsxs("p", { style: { color: "#9ca3af", fontSize: "10px" }, children: [
    "Max: ",
    e
  ] }),
  /* @__PURE__ */ I.jsx("div", { style: { display: "flex", gap: "4px", flexWrap: "wrap" }, children: [
    { label: "25%", multiplier: 0.25 },
    { label: "50%", multiplier: 0.5 },
    { label: "75%", multiplier: 0.75 },
    { label: "Max", multiplier: 1 }
  ].map(({ label: s, multiplier: a }) => /* @__PURE__ */ I.jsx(
    "button",
    {
      onClick: () => n(r, e * a),
      style: {
        padding: "0px 4px",
        borderRadius: "4px",
        border: "1px solid #374151",
        backgroundColor: "#232326",
        color: "#fff",
        fontSize: "12px",
        cursor: "pointer",
        minWidth: "32px",
        textAlign: "center",
        height: "20px",
        lineHeight: "20px"
      },
      children: s
    },
    s
  )) })
] }) }), Dae = ({
  isSelected: r,
  onSelect: e,
  positionId: i
}) => /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "12px" }, children: [
  r && /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontSize: "12px", fontWeight: "bold" }, children: "Amount to Redeem" }),
  /* @__PURE__ */ I.jsxs("label", { style: { display: "flex", alignItems: "center", gap: "6px", cursor: "pointer" }, children: [
    /* @__PURE__ */ I.jsx(
      "input",
      {
        type: "checkbox",
        checked: r,
        onChange: (n) => e(i, n.target.checked),
        style: {
          width: "16px",
          height: "16px",
          accentColor: "#ffd32a"
        }
      }
    ),
    /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd32a", fontSize: "12px", fontWeight: "bold" }, children: "Redeem" })
  ] })
] }), QM = ({ label: r, value: e }) => /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", gap: 8, marginBottom: 4 }, children: [
  /* @__PURE__ */ I.jsxs("span", { style: { color: "#ffd429", fontWeight: 700, minWidth: 110 }, children: [
    r,
    ":"
  ] }),
  /* @__PURE__ */ I.jsx("span", { style: { color: "#fff" }, children: e || "N/A" })
] }), Lae = ({ src: r, alt: e }) => r ? /* @__PURE__ */ I.jsx(
  "img",
  {
    src: r,
    alt: e,
    style: {
      width: 48,
      height: 48,
      borderRadius: "50%",
      objectFit: "cover",
      boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
      marginRight: 10
    }
  }
) : null, kae = ({ position: r, isSelected: e = !1, onSelect: i, onAmountChange: n, redeemAmount: s = 0 }) => {
  var b, T, E, M, C, S, w, R, O, P, A, D;
  const a = Number(r.shares || 0), o = r.term, l = ((b = r.vault) == null ? void 0 : b.deposits) && r.vault.deposits.length > 0, u = ((T = r.vault) == null ? void 0 : T.redemptions) && r.vault.redemptions.length > 0, c = (C = (M = (E = r.vault) == null ? void 0 : E.deposits) == null ? void 0 : M[0]) == null ? void 0 : C.vault_type, h = (R = (w = (S = r.vault) == null ? void 0 : S.redemptions) == null ? void 0 : w[0]) == null ? void 0 : R.vault_type, d = a > 0 && (c === "Triple" || c === "Atom" || h === "Triple" || h === "Atom"), p = !(o != null && o.triple), f = p || d ? o : (O = o == null ? void 0 : o.triple) == null ? void 0 : O.counter_term, m = () => {
    var L, H, V, X, F, B, W;
    return (H = (L = f == null ? void 0 : f.triple) == null ? void 0 : L.subject) != null && H.label && ((X = (V = f == null ? void 0 : f.triple) == null ? void 0 : V.predicate) != null && X.label) && ((B = (F = f == null ? void 0 : f.triple) == null ? void 0 : F.object) != null && B.label) ? {
      type: "triple",
      subject: f.triple.subject.label,
      predicate: f.triple.predicate.label,
      object: f.triple.object.label
    } : (W = f == null ? void 0 : f.atom) != null && W.label ? {
      type: "atom",
      label: f.atom.label
    } : { type: "unknown" };
  }, y = p || d ? o : (P = o == null ? void 0 : o.triple) == null ? void 0 : P.counter_term, v = Iae(a, Number((y == null ? void 0 : y.total_assets) || 0)), g = Number((y == null ? void 0 : y.total_assets) || 0), x = (l && u ? a > 0 ? "Deposit" : "Redeem" : l ? "Deposit" : u ? "Redeem" : "Unknown") === "Redeem";
  return /* @__PURE__ */ I.jsx(
    "div",
    {
      style: {
        background: "#232326",
        borderRadius: 14,
        padding: "18px 24px",
        marginBottom: 4,
        boxShadow: "0 2px 12px rgba(0,0,0,0.13)",
        borderLeft: `6px solid ${x ? "#FFD700" : d ? "#006FE8" : "#FF9500"}`,
        position: "relative",
        display: "flex",
        flexDirection: "column",
        gap: 2
      },
      className: "position-card",
      children: /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "flex-start" }, children: [
        /* @__PURE__ */ I.jsx(Lae, { src: (A = r.account) == null ? void 0 : A.image, alt: (D = r.account) == null ? void 0 : D.label }),
        /* @__PURE__ */ I.jsxs("div", { style: { flex: 1 }, children: [
          /* @__PURE__ */ I.jsx("div", { style: { display: "flex", alignItems: "center", gap: 8, marginBottom: 4 }, children: (() => {
            const L = m();
            return L.type === "triple" ? /* @__PURE__ */ I.jsx(
              ey,
              {
                subject: L.subject,
                predicate: L.predicate,
                object: L.object,
                fontSize: "14px"
              }
            ) : L.type === "atom" ? /* @__PURE__ */ I.jsx(
              SO,
              {
                label: L.label,
                fontSize: "14px"
              }
            ) : /* @__PURE__ */ I.jsx("span", { style: { color: "#fff", fontSize: "14px" }, children: "Unknown Position" });
          })() }),
          /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8, marginBottom: 4 }, children: [
            /* @__PURE__ */ I.jsx("span", { style: { color: "#ffd429", fontWeight: 700, minWidth: 110 }, children: "Direction:" }),
            /* @__PURE__ */ I.jsx(Nc, { isFor: d, fontSize: "12px" })
          ] }),
          /* @__PURE__ */ I.jsx(QM, { label: "Shares", value: v }),
          /* @__PURE__ */ I.jsx(QM, { label: "Term Shares", value: g })
        ] }),
        /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", flexDirection: "column", alignItems: "flex-end", gap: "8px" }, children: [
          /* @__PURE__ */ I.jsx(
            Dae,
            {
              isSelected: e,
              onSelect: i || (() => {
              }),
              positionId: r.id
            }
          ),
          e && n && /* @__PURE__ */ I.jsx(
            Oae,
            {
              positionId: r.id,
              shares: a,
              redeemAmount: s,
              onAmountChange: n
            }
          )
        ] })
      ] })
    }
  );
}, Uae = ({
  atomDetails: r,
  connections: e,
  walletAddress: i
}) => {
  var a, o, l, u, c, h, d, p;
  if (!r) return null;
  const n = r.image, s = n ? p_(n) ? pC(n) : n : void 0;
  return /* @__PURE__ */ I.jsx(I.Fragment, { children: /* @__PURE__ */ I.jsxs("div", { className: "flex flex-wrap items-center gap-4", children: [
    /* @__PURE__ */ I.jsx("div", { className: "w-1/6 h-20", children: s ? /* @__PURE__ */ I.jsx(
      "img",
      {
        src: s,
        alt: r.label || "Atom image",
        className: "w-full h-20 object-contain rounded-2xl"
      }
    ) : /* @__PURE__ */ I.jsx("div", { className: "w-full h-auto object-contain rounded-2xl", children: "No image" }) }),
    /* @__PURE__ */ I.jsxs("div", { className: "flex-col w-4/6 gap-2 text-primary", children: [
      /* @__PURE__ */ I.jsx("p", { className: "bold text-2xl capitalize", children: /* @__PURE__ */ I.jsx("strong", { children: String(r.label ?? "Not defined") }) }),
      /* @__PURE__ */ I.jsxs("p", { className: "text-sm", children: [
        "Following: ",
        e.followers.length,
        " - Followers: ",
        e.follows.length
      ] })
    ] }),
    /* @__PURE__ */ I.jsx("div", { className: "flex-col w-full h-[70px] gap-2 text-[#D9D9D9] border-b-1 border-[#D9D9D9] overflow-y-auto", children: /* @__PURE__ */ I.jsxs("p", { children: [
      /* @__PURE__ */ I.jsx("strong", { children: "UID / Description :" }),
      " ",
      /* @__PURE__ */ I.jsx("br", {}),
      ((o = (a = r.value) == null ? void 0 : a.person) == null ? void 0 : o.description) || ((u = (l = r.value) == null ? void 0 : l.organization) == null ? void 0 : u.description) || ((h = (c = r.value) == null ? void 0 : c.thing) == null ? void 0 : h.description) || ((p = (d = r.value) == null ? void 0 : d.book) == null ? void 0 : p.description) || "No description available"
    ] }) })
  ] }) });
}, uT = ({ isOpen: r, onClose: e, title: i, children: n }) => (Ft(() => {
  const s = (a) => {
    a.key === "Escape" && e();
  };
  return r && (document.addEventListener("keydown", s), document.body.style.overflow = "hidden"), () => {
    document.removeEventListener("keydown", s), document.body.style.overflow = "unset";
  };
}, [r, e]), r ? /* @__PURE__ */ I.jsx(
  "div",
  {
    style: {
      position: "fixed",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: "rgba(0, 0, 0, 0)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      zIndex: 9999,
      padding: "20px"
    },
    onClick: e,
    children: /* @__PURE__ */ I.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#1a1a1a",
          borderRadius: "16px",
          border: "1px solid rgba(255, 255, 255, 0.1)",
          maxWidth: "700px",
          width: "100%",
          maxHeight: "85vh",
          minHeight: "400px",
          display: "flex",
          flexDirection: "column",
          overflow: "hidden",
          boxShadow: "0 20px 40px rgba(0, 0, 0, 0.5)"
        },
        onClick: (s) => s.stopPropagation(),
        children: [
          /* @__PURE__ */ I.jsxs(
            "div",
            {
              style: {
                padding: "20px 24px",
                borderBottom: "1px solid rgba(255, 255, 255, 0.1)",
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between"
              },
              children: [
                /* @__PURE__ */ I.jsx(
                  "h2",
                  {
                    style: {
                      margin: 0,
                      fontSize: "18px",
                      fontWeight: "600",
                      color: "#fff"
                    },
                    children: i
                  }
                ),
                /* @__PURE__ */ I.jsx(
                  "button",
                  {
                    onClick: e,
                    style: {
                      background: "none",
                      border: "none",
                      color: "rgba(255, 255, 255, 0.6)",
                      fontSize: "24px",
                      cursor: "pointer",
                      padding: "4px",
                      borderRadius: "4px",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      width: "32px",
                      height: "32px",
                      transition: "all 0.2s"
                    },
                    onMouseEnter: (s) => {
                      s.currentTarget.style.color = "#fff", s.currentTarget.style.backgroundColor = "rgba(255, 255, 255, 0.1)";
                    },
                    onMouseLeave: (s) => {
                      s.currentTarget.style.color = "rgba(255, 255, 255, 0.6)", s.currentTarget.style.backgroundColor = "transparent";
                    },
                    children: "×"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ I.jsx(
            "div",
            {
              style: {
                padding: "0",
                overflowY: "auto",
                flex: 1,
                display: "flex",
                flexDirection: "column"
              },
              children: n
            }
          )
        ]
      }
    )
  }
) : null), cT = ({
  currentPage: r,
  totalPages: e,
  onPageChange: i,
  itemsPerPage: n,
  totalItems: s
}) => e <= 1 ? null : /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
  /* @__PURE__ */ I.jsx(
    "button",
    {
      onClick: () => i(r - 1),
      disabled: r === 1,
      style: {
        background: r === 1 ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 255, 255, 0.2)",
        border: "1px solid rgba(255, 255, 255, 0.2)",
        borderRadius: "6px",
        color: r === 1 ? "rgba(255, 255, 255, 0.4)" : "#fff",
        padding: "6px 12px",
        fontSize: "12px",
        cursor: r === 1 ? "not-allowed" : "pointer",
        transition: "all 0.2s"
      },
      onMouseEnter: (a) => {
        r > 1 && (a.currentTarget.style.background = "rgba(255, 255, 255, 0.3)");
      },
      onMouseLeave: (a) => {
        r > 1 && (a.currentTarget.style.background = "rgba(255, 255, 255, 0.2)");
      },
      children: "←"
    }
  ),
  /* @__PURE__ */ I.jsx("div", { style: { display: "flex", gap: "4px" }, children: (() => {
    const l = [];
    l.push(1), r > 3 && l.push("...");
    const u = Math.max(2, r - 1), c = Math.min(e - 1, r + 1);
    for (let h = u; h <= c; h++)
      h !== 1 && h !== e && l.push(h);
    return r < e - 2 && l.push("..."), e > 1 && l.push(e), l;
  })().map((l, u) => l === "..." ? /* @__PURE__ */ I.jsx(
    "span",
    {
      style: {
        color: "rgba(255, 255, 255, 0.6)",
        padding: "6px 4px",
        fontSize: "12px"
      },
      children: "..."
    },
    `ellipsis-${u}`
  ) : /* @__PURE__ */ I.jsx(
    "button",
    {
      onClick: () => i(l),
      style: {
        background: l === r ? "#ffd32a" : "rgba(255, 255, 255, 0.1)",
        border: "1px solid rgba(255, 255, 255, 0.2)",
        borderRadius: "6px",
        color: l === r ? "#18181b" : "#fff",
        padding: "6px 10px",
        fontSize: "12px",
        cursor: "pointer",
        minWidth: "32px",
        transition: "all 0.2s",
        fontWeight: l === r ? "600" : "400"
      },
      onMouseEnter: (c) => {
        l !== r && (c.currentTarget.style.background = "rgba(255, 255, 255, 0.2)");
      },
      onMouseLeave: (c) => {
        l !== r && (c.currentTarget.style.background = "rgba(255, 255, 255, 0.1)");
      },
      children: l
    },
    l
  )) }),
  /* @__PURE__ */ I.jsx(
    "button",
    {
      onClick: () => i(r + 1),
      disabled: r === e,
      style: {
        background: r === e ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 255, 255, 0.2)",
        border: "1px solid rgba(255, 255, 255, 0.2)",
        borderRadius: "6px",
        color: r === e ? "rgba(255, 255, 255, 0.4)" : "#fff",
        padding: "6px 12px",
        fontSize: "12px",
        cursor: r === e ? "not-allowed" : "pointer",
        transition: "all 0.2s"
      },
      onMouseEnter: (a) => {
        r < e && (a.currentTarget.style.background = "rgba(255, 255, 255, 0.3)");
      },
      onMouseLeave: (a) => {
        r < e && (a.currentTarget.style.background = "rgba(255, 255, 255, 0.2)");
      },
      children: "→"
    }
  )
] }), hT = ({
  currentPage: r,
  itemsPerPage: e,
  totalItems: i
}) => {
  const n = (r - 1) * e + 1, s = Math.min(r * e, i);
  return /* @__PURE__ */ I.jsxs("div", { style: { fontSize: "12px", color: "rgba(255, 255, 255, 0.6)" }, children: [
    "Showing ",
    n,
    "-",
    s,
    " of ",
    i
  ] });
};
var $g = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(r) {
    return this.listeners.add(r), this.onSubscribe(), () => {
      this.listeners.delete(r), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, Fae = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (r, e) => setTimeout(r, e),
  clearTimeout: (r) => clearTimeout(r),
  setInterval: (r, e) => setInterval(r, e),
  clearInterval: (r) => clearInterval(r)
}, os, al, uA, Bae = (uA = class {
  constructor() {
    // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
    // type at app boot; and if we leave that type, then any new timer provider
    // would need to support ReturnType<typeof setTimeout>, which is infeasible.
    //
    // We settle for type safety for the TimeoutProvider type, and accept that
    // this class is unsafe internally to allow for extension.
    zt(this, os, Fae);
    zt(this, al, !1);
  }
  setTimeoutProvider(r) {
    process.env.NODE_ENV !== "production" && ge(this, al) && r !== ge(this, os) && console.error(
      "[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.",
      { previous: ge(this, os), provider: r }
    ), mt(this, os, r), process.env.NODE_ENV !== "production" && mt(this, al, !1);
  }
  setTimeout(r, e) {
    return process.env.NODE_ENV !== "production" && mt(this, al, !0), ge(this, os).setTimeout(r, e);
  }
  clearTimeout(r) {
    ge(this, os).clearTimeout(r);
  }
  setInterval(r, e) {
    return process.env.NODE_ENV !== "production" && mt(this, al, !0), ge(this, os).setInterval(r, e);
  }
  clearInterval(r) {
    ge(this, os).clearInterval(r);
  }
}, os = new WeakMap(), al = new WeakMap(), uA), $x = new Bae();
function zae(r) {
  setTimeout(r, 0);
}
var Jg = typeof window > "u" || "Deno" in globalThis;
function Fn() {
}
function jae(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function Vae(r) {
  return typeof r == "number" && r >= 0 && r !== 1 / 0;
}
function Gae(r, e) {
  return Math.max(r + (e || 0) - Date.now(), 0);
}
function Jx(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function Hae(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function $M(r, e) {
  const {
    type: i = "all",
    exact: n,
    fetchStatus: s,
    predicate: a,
    queryKey: o,
    stale: l
  } = r;
  if (o) {
    if (n) {
      if (e.queryHash !== dT(o, e.options))
        return !1;
    } else if (!Od(e.queryKey, o))
      return !1;
  }
  if (i !== "all") {
    const u = e.isActive();
    if (i === "active" && !u || i === "inactive" && u)
      return !1;
  }
  return !(typeof l == "boolean" && e.isStale() !== l || s && s !== e.state.fetchStatus || a && !a(e));
}
function JM(r, e) {
  const { exact: i, status: n, predicate: s, mutationKey: a } = r;
  if (a) {
    if (!e.options.mutationKey)
      return !1;
    if (i) {
      if (Id(e.options.mutationKey) !== Id(a))
        return !1;
    } else if (!Od(e.options.mutationKey, a))
      return !1;
  }
  return !(n && e.state.status !== n || s && !s(e));
}
function dT(r, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || Id)(r);
}
function Id(r) {
  return JSON.stringify(
    r,
    (e, i) => t_(i) ? Object.keys(i).sort().reduce((n, s) => (n[s] = i[s], n), {}) : i
  );
}
function Od(r, e) {
  return r === e ? !0 : typeof r != typeof e ? !1 : r && e && typeof r == "object" && typeof e == "object" ? Object.keys(e).every((i) => Od(r[i], e[i])) : !1;
}
var Wae = Object.prototype.hasOwnProperty;
function e_(r, e) {
  if (r === e)
    return r;
  const i = eA(r) && eA(e);
  if (!i && !(t_(r) && t_(e))) return e;
  const s = (i ? r : Object.keys(r)).length, a = i ? e : Object.keys(e), o = a.length, l = i ? new Array(o) : {};
  let u = 0;
  for (let c = 0; c < o; c++) {
    const h = i ? c : a[c], d = r[h], p = e[h];
    if (d === p) {
      l[h] = d, (i ? c < s : Wae.call(r, h)) && u++;
      continue;
    }
    if (d === null || p === null || typeof d != "object" || typeof p != "object") {
      l[h] = p;
      continue;
    }
    const f = e_(d, p);
    l[h] = f, f === d && u++;
  }
  return s === o && u === s ? r : l;
}
function eA(r) {
  return Array.isArray(r) && r.length === Object.keys(r).length;
}
function t_(r) {
  if (!tA(r))
    return !1;
  const e = r.constructor;
  if (e === void 0)
    return !0;
  const i = e.prototype;
  return !(!tA(i) || !i.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(r) !== Object.prototype);
}
function tA(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
function qae(r) {
  return new Promise((e) => {
    $x.setTimeout(e, r);
  });
}
function Xae(r, e, i) {
  if (typeof i.structuralSharing == "function")
    return i.structuralSharing(r, e);
  if (i.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return e_(r, e);
      } catch (n) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${i.queryHash}]: ${n}`
        ), n;
      }
    return e_(r, e);
  }
  return e;
}
function Yae(r, e, i = 0) {
  const n = [...r, e];
  return i && n.length > i ? n.slice(1) : n;
}
function Kae(r, e, i = 0) {
  const n = [e, ...r];
  return i && n.length > i ? n.slice(0, -1) : n;
}
var ng = Symbol();
function vO(r, e) {
  return process.env.NODE_ENV !== "production" && r.queryFn === ng && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${r.queryHash}'`
  ), !r.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !r.queryFn || r.queryFn === ng ? () => Promise.reject(new Error(`Missing queryFn: '${r.queryHash}'`)) : r.queryFn;
}
var ol, io, ic, cA, Zae = (cA = class extends $g {
  constructor() {
    super();
    zt(this, ol);
    zt(this, io);
    zt(this, ic);
    mt(this, ic, (e) => {
      if (!Jg && window.addEventListener) {
        const i = () => e();
        return window.addEventListener("visibilitychange", i, !1), () => {
          window.removeEventListener("visibilitychange", i);
        };
      }
    });
  }
  onSubscribe() {
    ge(this, io) || this.setEventListener(ge(this, ic));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = ge(this, io)) == null || e.call(this), mt(this, io, void 0));
  }
  setEventListener(e) {
    var i;
    mt(this, ic, e), (i = ge(this, io)) == null || i.call(this), mt(this, io, e((n) => {
      typeof n == "boolean" ? this.setFocused(n) : this.onFocus();
    }));
  }
  setFocused(e) {
    ge(this, ol) !== e && (mt(this, ol, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((i) => {
      i(e);
    });
  }
  isFocused() {
    var e;
    return typeof ge(this, ol) == "boolean" ? ge(this, ol) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden";
  }
}, ol = new WeakMap(), io = new WeakMap(), ic = new WeakMap(), cA), bO = new Zae();
function Qae() {
  let r, e;
  const i = new Promise((s, a) => {
    r = s, e = a;
  });
  i.status = "pending", i.catch(() => {
  });
  function n(s) {
    Object.assign(i, s), delete i.resolve, delete i.reject;
  }
  return i.resolve = (s) => {
    n({
      status: "fulfilled",
      value: s
    }), r(s);
  }, i.reject = (s) => {
    n({
      status: "rejected",
      reason: s
    }), e(s);
  }, i;
}
var $ae = zae;
function Jae() {
  let r = [], e = 0, i = (l) => {
    l();
  }, n = (l) => {
    l();
  }, s = $ae;
  const a = (l) => {
    e ? r.push(l) : s(() => {
      i(l);
    });
  }, o = () => {
    const l = r;
    r = [], l.length && s(() => {
      n(() => {
        l.forEach((u) => {
          i(u);
        });
      });
    });
  };
  return {
    batch: (l) => {
      let u;
      e++;
      try {
        u = l();
      } finally {
        e--, e || o();
      }
      return u;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (l) => (...u) => {
      a(() => {
        l(...u);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (l) => {
      i = l;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (l) => {
      n = l;
    },
    setScheduler: (l) => {
      s = l;
    }
  };
}
var Sr = Jae(), rc, ro, nc, hA, eoe = (hA = class extends $g {
  constructor() {
    super();
    zt(this, rc, !0);
    zt(this, ro);
    zt(this, nc);
    mt(this, nc, (e) => {
      if (!Jg && window.addEventListener) {
        const i = () => e(!0), n = () => e(!1);
        return window.addEventListener("online", i, !1), window.addEventListener("offline", n, !1), () => {
          window.removeEventListener("online", i), window.removeEventListener("offline", n);
        };
      }
    });
  }
  onSubscribe() {
    ge(this, ro) || this.setEventListener(ge(this, nc));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = ge(this, ro)) == null || e.call(this), mt(this, ro, void 0));
  }
  setEventListener(e) {
    var i;
    mt(this, nc, e), (i = ge(this, ro)) == null || i.call(this), mt(this, ro, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    ge(this, rc) !== e && (mt(this, rc, e), this.listeners.forEach((n) => {
      n(e);
    }));
  }
  isOnline() {
    return ge(this, rc);
  }
}, rc = new WeakMap(), ro = new WeakMap(), nc = new WeakMap(), hA), sg = new eoe();
function toe(r) {
  return Math.min(1e3 * 2 ** r, 3e4);
}
function xO(r) {
  return (r ?? "online") === "online" ? sg.isOnline() : !0;
}
var i_ = class extends Error {
  constructor(r) {
    super("CancelledError"), this.revert = r == null ? void 0 : r.revert, this.silent = r == null ? void 0 : r.silent;
  }
};
function _O(r) {
  let e = !1, i = 0, n;
  const s = Qae(), a = () => s.status !== "pending", o = (y) => {
    var v;
    if (!a()) {
      const g = new i_(y);
      p(g), (v = r.onCancel) == null || v.call(r, g);
    }
  }, l = () => {
    e = !0;
  }, u = () => {
    e = !1;
  }, c = () => bO.isFocused() && (r.networkMode === "always" || sg.isOnline()) && r.canRun(), h = () => xO(r.networkMode) && r.canRun(), d = (y) => {
    a() || (n == null || n(), s.resolve(y));
  }, p = (y) => {
    a() || (n == null || n(), s.reject(y));
  }, f = () => new Promise((y) => {
    var v;
    n = (g) => {
      (a() || c()) && y(g);
    }, (v = r.onPause) == null || v.call(r);
  }).then(() => {
    var y;
    n = void 0, a() || (y = r.onContinue) == null || y.call(r);
  }), m = () => {
    if (a())
      return;
    let y;
    const v = i === 0 ? r.initialPromise : void 0;
    try {
      y = v ?? r.fn();
    } catch (g) {
      y = Promise.reject(g);
    }
    Promise.resolve(y).then(d).catch((g) => {
      var E;
      if (a())
        return;
      const _ = r.retry ?? (Jg ? 0 : 3), x = r.retryDelay ?? toe, b = typeof x == "function" ? x(i, g) : x, T = _ === !0 || typeof _ == "number" && i < _ || typeof _ == "function" && _(i, g);
      if (e || !T) {
        p(g);
        return;
      }
      i++, (E = r.onFail) == null || E.call(r, i, g), qae(b).then(() => c() ? void 0 : f()).then(() => {
        e ? p(g) : m();
      });
    });
  };
  return {
    promise: s,
    status: () => s.status,
    cancel: o,
    continue: () => (n == null || n(), s),
    cancelRetry: l,
    continueRetry: u,
    canStart: h,
    start: () => (h() ? m() : f().then(m), s)
  };
}
var ll, dA, TO = (dA = class {
  constructor() {
    zt(this, ll);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Vae(this.gcTime) && mt(this, ll, $x.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(r) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      r ?? (Jg ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    ge(this, ll) && ($x.clearTimeout(ge(this, ll)), mt(this, ll, void 0));
  }
}, ll = new WeakMap(), dA), ul, sc, gn, cl, Yi, Dd, hl, Bn, Hs, pA, ioe = (pA = class extends TO {
  constructor(e) {
    super();
    zt(this, Bn);
    zt(this, ul);
    zt(this, sc);
    zt(this, gn);
    zt(this, cl);
    zt(this, Yi);
    zt(this, Dd);
    zt(this, hl);
    mt(this, hl, !1), mt(this, Dd, e.defaultOptions), this.setOptions(e.options), this.observers = [], mt(this, cl, e.client), mt(this, gn, ge(this, cl).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, mt(this, ul, iA(this.options)), this.state = e.state ?? ge(this, ul), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = ge(this, Yi)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    if (this.options = { ...ge(this, Dd), ...e }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const i = iA(this.options);
      i.data !== void 0 && (this.setData(i.data, {
        updatedAt: i.dataUpdatedAt,
        manual: !0
      }), mt(this, ul, i));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && ge(this, gn).remove(this);
  }
  setData(e, i) {
    const n = Xae(this.state.data, e, this.options);
    return or(this, Bn, Hs).call(this, {
      data: n,
      type: "success",
      dataUpdatedAt: i == null ? void 0 : i.updatedAt,
      manual: i == null ? void 0 : i.manual
    }), n;
  }
  setState(e, i) {
    or(this, Bn, Hs).call(this, { type: "setState", state: e, setStateOptions: i });
  }
  cancel(e) {
    var n, s;
    const i = (n = ge(this, Yi)) == null ? void 0 : n.promise;
    return (s = ge(this, Yi)) == null || s.cancel(e), i ? i.then(Fn).catch(Fn) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(ge(this, ul));
  }
  isActive() {
    return this.observers.some(
      (e) => Hae(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === ng || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => Jx(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !Gae(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var i;
    const e = this.observers.find((n) => n.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (i = ge(this, Yi)) == null || i.continue();
  }
  onOnline() {
    var i;
    const e = this.observers.find((n) => n.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (i = ge(this, Yi)) == null || i.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), ge(this, gn).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((i) => i !== e), this.observers.length || (ge(this, Yi) && (ge(this, hl) ? ge(this, Yi).cancel({ revert: !0 }) : ge(this, Yi).cancelRetry()), this.scheduleGc()), ge(this, gn).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || or(this, Bn, Hs).call(this, { type: "invalidate" });
  }
  async fetch(e, i) {
    var u, c, h, d, p, f, m, y, v, g, _, x;
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    ((u = ge(this, Yi)) == null ? void 0 : u.status()) !== "rejected") {
      if (this.state.data !== void 0 && (i != null && i.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (ge(this, Yi))
        return ge(this, Yi).continueRetry(), ge(this, Yi).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const b = this.observers.find((T) => T.options.queryFn);
      b && this.setOptions(b.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const n = new AbortController(), s = (b) => {
      Object.defineProperty(b, "signal", {
        enumerable: !0,
        get: () => (mt(this, hl, !0), n.signal)
      });
    }, a = () => {
      const b = vO(this.options, i), E = (() => {
        const M = {
          client: ge(this, cl),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(M), M;
      })();
      return mt(this, hl, !1), this.options.persister ? this.options.persister(
        b,
        E,
        this
      ) : b(E);
    }, l = (() => {
      const b = {
        fetchOptions: i,
        options: this.options,
        queryKey: this.queryKey,
        client: ge(this, cl),
        state: this.state,
        fetchFn: a
      };
      return s(b), b;
    })();
    (c = this.options.behavior) == null || c.onFetch(l, this), mt(this, sc, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((h = l.fetchOptions) == null ? void 0 : h.meta)) && or(this, Bn, Hs).call(this, { type: "fetch", meta: (d = l.fetchOptions) == null ? void 0 : d.meta }), mt(this, Yi, _O({
      initialPromise: i == null ? void 0 : i.initialPromise,
      fn: l.fetchFn,
      onCancel: (b) => {
        b instanceof i_ && b.revert && this.setState({
          ...ge(this, sc),
          fetchStatus: "idle"
        }), n.abort();
      },
      onFail: (b, T) => {
        or(this, Bn, Hs).call(this, { type: "failed", failureCount: b, error: T });
      },
      onPause: () => {
        or(this, Bn, Hs).call(this, { type: "pause" });
      },
      onContinue: () => {
        or(this, Bn, Hs).call(this, { type: "continue" });
      },
      retry: l.options.retry,
      retryDelay: l.options.retryDelay,
      networkMode: l.options.networkMode,
      canRun: () => !0
    }));
    try {
      const b = await ge(this, Yi).start();
      if (b === void 0)
        throw process.env.NODE_ENV !== "production" && console.error(
          `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
        ), new Error(`${this.queryHash} data is undefined`);
      return this.setData(b), (f = (p = ge(this, gn).config).onSuccess) == null || f.call(p, b, this), (y = (m = ge(this, gn).config).onSettled) == null || y.call(
        m,
        b,
        this.state.error,
        this
      ), b;
    } catch (b) {
      if (b instanceof i_) {
        if (b.silent)
          return ge(this, Yi).promise;
        if (b.revert) {
          if (this.state.data === void 0)
            throw b;
          return this.state.data;
        }
      }
      throw or(this, Bn, Hs).call(this, {
        type: "error",
        error: b
      }), (g = (v = ge(this, gn).config).onError) == null || g.call(
        v,
        b,
        this
      ), (x = (_ = ge(this, gn).config).onSettled) == null || x.call(
        _,
        this.state.data,
        b,
        this
      ), b;
    } finally {
      this.scheduleGc();
    }
  }
}, ul = new WeakMap(), sc = new WeakMap(), gn = new WeakMap(), cl = new WeakMap(), Yi = new WeakMap(), Dd = new WeakMap(), hl = new WeakMap(), Bn = new WeakSet(), Hs = function(e) {
  const i = (n) => {
    switch (e.type) {
      case "failed":
        return {
          ...n,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...n,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...n,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...n,
          ...roe(n.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        const s = {
          ...n,
          data: e.data,
          dataUpdateCount: n.dataUpdateCount + 1,
          dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        return mt(this, sc, e.manual ? s : void 0), s;
      case "error":
        const a = e.error;
        return {
          ...n,
          error: a,
          errorUpdateCount: n.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: n.fetchFailureCount + 1,
          fetchFailureReason: a,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...n,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...n,
          ...e.state
        };
    }
  };
  this.state = i(this.state), Sr.batch(() => {
    this.observers.forEach((n) => {
      n.onQueryUpdate();
    }), ge(this, gn).notify({ query: this, type: "updated", action: e });
  });
}, pA);
function roe(r, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: xO(e.networkMode) ? "fetching" : "paused",
    ...r === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function iA(r) {
  const e = typeof r.initialData == "function" ? r.initialData() : r.initialData, i = e !== void 0, n = i ? typeof r.initialDataUpdatedAt == "function" ? r.initialDataUpdatedAt() : r.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: i ? n ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: i ? "success" : "pending",
    fetchStatus: "idle"
  };
}
function rA(r) {
  return {
    onFetch: (e, i) => {
      var h, d, p, f, m;
      const n = e.options, s = (p = (d = (h = e.fetchOptions) == null ? void 0 : h.meta) == null ? void 0 : d.fetchMore) == null ? void 0 : p.direction, a = ((f = e.state.data) == null ? void 0 : f.pages) || [], o = ((m = e.state.data) == null ? void 0 : m.pageParams) || [];
      let l = { pages: [], pageParams: [] }, u = 0;
      const c = async () => {
        let y = !1;
        const v = (x) => {
          Object.defineProperty(x, "signal", {
            enumerable: !0,
            get: () => (e.signal.aborted ? y = !0 : e.signal.addEventListener("abort", () => {
              y = !0;
            }), e.signal)
          });
        }, g = vO(e.options, e.fetchOptions), _ = async (x, b, T) => {
          if (y)
            return Promise.reject();
          if (b == null && x.pages.length)
            return Promise.resolve(x);
          const M = (() => {
            const R = {
              client: e.client,
              queryKey: e.queryKey,
              pageParam: b,
              direction: T ? "backward" : "forward",
              meta: e.options.meta
            };
            return v(R), R;
          })(), C = await g(M), { maxPages: S } = e.options, w = T ? Kae : Yae;
          return {
            pages: w(x.pages, C, S),
            pageParams: w(x.pageParams, b, S)
          };
        };
        if (s && a.length) {
          const x = s === "backward", b = x ? noe : nA, T = {
            pages: a,
            pageParams: o
          }, E = b(n, T);
          l = await _(T, E, x);
        } else {
          const x = r ?? a.length;
          do {
            const b = u === 0 ? o[0] ?? n.initialPageParam : nA(n, l);
            if (u > 0 && b == null)
              break;
            l = await _(l, b), u++;
          } while (u < x);
        }
        return l;
      };
      e.options.persister ? e.fetchFn = () => {
        var y, v;
        return (v = (y = e.options).persister) == null ? void 0 : v.call(
          y,
          c,
          {
            client: e.client,
            queryKey: e.queryKey,
            meta: e.options.meta,
            signal: e.signal
          },
          i
        );
      } : e.fetchFn = c;
    }
  };
}
function nA(r, { pages: e, pageParams: i }) {
  const n = e.length - 1;
  return e.length > 0 ? r.getNextPageParam(
    e[n],
    e,
    i[n],
    i
  ) : void 0;
}
function noe(r, { pages: e, pageParams: i }) {
  var n;
  return e.length > 0 ? (n = r.getPreviousPageParam) == null ? void 0 : n.call(r, e[0], e, i[0], i) : void 0;
}
var Ld, ls, Tr, dl, us, Ya, fA, soe = (fA = class extends TO {
  constructor(e) {
    super();
    zt(this, us);
    zt(this, Ld);
    zt(this, ls);
    zt(this, Tr);
    zt(this, dl);
    mt(this, Ld, e.client), this.mutationId = e.mutationId, mt(this, Tr, e.mutationCache), mt(this, ls, []), this.state = e.state || aoe(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    ge(this, ls).includes(e) || (ge(this, ls).push(e), this.clearGcTimeout(), ge(this, Tr).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    mt(this, ls, ge(this, ls).filter((i) => i !== e)), this.scheduleGc(), ge(this, Tr).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    ge(this, ls).length || (this.state.status === "pending" ? this.scheduleGc() : ge(this, Tr).remove(this));
  }
  continue() {
    var e;
    return ((e = ge(this, dl)) == null ? void 0 : e.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    var o, l, u, c, h, d, p, f, m, y, v, g, _, x, b, T, E, M, C, S;
    const i = () => {
      or(this, us, Ya).call(this, { type: "continue" });
    }, n = {
      client: ge(this, Ld),
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    mt(this, dl, _O({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e, n) : Promise.reject(new Error("No mutationFn found")),
      onFail: (w, R) => {
        or(this, us, Ya).call(this, { type: "failed", failureCount: w, error: R });
      },
      onPause: () => {
        or(this, us, Ya).call(this, { type: "pause" });
      },
      onContinue: i,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => ge(this, Tr).canRun(this)
    }));
    const s = this.state.status === "pending", a = !ge(this, dl).canStart();
    try {
      if (s)
        i();
      else {
        or(this, us, Ya).call(this, { type: "pending", variables: e, isPaused: a }), await ((l = (o = ge(this, Tr).config).onMutate) == null ? void 0 : l.call(
          o,
          e,
          this,
          n
        ));
        const R = await ((c = (u = this.options).onMutate) == null ? void 0 : c.call(
          u,
          e,
          n
        ));
        R !== this.state.context && or(this, us, Ya).call(this, {
          type: "pending",
          context: R,
          variables: e,
          isPaused: a
        });
      }
      const w = await ge(this, dl).start();
      return await ((d = (h = ge(this, Tr).config).onSuccess) == null ? void 0 : d.call(
        h,
        w,
        e,
        this.state.context,
        this,
        n
      )), await ((f = (p = this.options).onSuccess) == null ? void 0 : f.call(
        p,
        w,
        e,
        this.state.context,
        n
      )), await ((y = (m = ge(this, Tr).config).onSettled) == null ? void 0 : y.call(
        m,
        w,
        null,
        this.state.variables,
        this.state.context,
        this,
        n
      )), await ((g = (v = this.options).onSettled) == null ? void 0 : g.call(
        v,
        w,
        null,
        e,
        this.state.context,
        n
      )), or(this, us, Ya).call(this, { type: "success", data: w }), w;
    } catch (w) {
      try {
        throw await ((x = (_ = ge(this, Tr).config).onError) == null ? void 0 : x.call(
          _,
          w,
          e,
          this.state.context,
          this,
          n
        )), await ((T = (b = this.options).onError) == null ? void 0 : T.call(
          b,
          w,
          e,
          this.state.context,
          n
        )), await ((M = (E = ge(this, Tr).config).onSettled) == null ? void 0 : M.call(
          E,
          void 0,
          w,
          this.state.variables,
          this.state.context,
          this,
          n
        )), await ((S = (C = this.options).onSettled) == null ? void 0 : S.call(
          C,
          void 0,
          w,
          e,
          this.state.context,
          n
        )), w;
      } finally {
        or(this, us, Ya).call(this, { type: "error", error: w });
      }
    } finally {
      ge(this, Tr).runNext(this);
    }
  }
}, Ld = new WeakMap(), ls = new WeakMap(), Tr = new WeakMap(), dl = new WeakMap(), us = new WeakSet(), Ya = function(e) {
  const i = (n) => {
    switch (e.type) {
      case "failed":
        return {
          ...n,
          failureCount: e.failureCount,
          failureReason: e.error
        };
      case "pause":
        return {
          ...n,
          isPaused: !0
        };
      case "continue":
        return {
          ...n,
          isPaused: !1
        };
      case "pending":
        return {
          ...n,
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...n,
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...n,
          data: void 0,
          error: e.error,
          failureCount: n.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = i(this.state), Sr.batch(() => {
    ge(this, ls).forEach((n) => {
      n.onMutationUpdate(e);
    }), ge(this, Tr).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, fA);
function aoe() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var Zs, zn, kd, mA, ooe = (mA = class extends $g {
  constructor(e = {}) {
    super();
    zt(this, Zs);
    zt(this, zn);
    zt(this, kd);
    this.config = e, mt(this, Zs, /* @__PURE__ */ new Set()), mt(this, zn, /* @__PURE__ */ new Map()), mt(this, kd, 0);
  }
  build(e, i, n) {
    const s = new soe({
      client: e,
      mutationCache: this,
      mutationId: ++ap(this, kd)._,
      options: e.defaultMutationOptions(i),
      state: n
    });
    return this.add(s), s;
  }
  add(e) {
    ge(this, Zs).add(e);
    const i = Uf(e);
    if (typeof i == "string") {
      const n = ge(this, zn).get(i);
      n ? n.push(e) : ge(this, zn).set(i, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (ge(this, Zs).delete(e)) {
      const i = Uf(e);
      if (typeof i == "string") {
        const n = ge(this, zn).get(i);
        if (n)
          if (n.length > 1) {
            const s = n.indexOf(e);
            s !== -1 && n.splice(s, 1);
          } else n[0] === e && ge(this, zn).delete(i);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const i = Uf(e);
    if (typeof i == "string") {
      const n = ge(this, zn).get(i), s = n == null ? void 0 : n.find(
        (a) => a.state.status === "pending"
      );
      return !s || s === e;
    } else
      return !0;
  }
  runNext(e) {
    var n;
    const i = Uf(e);
    if (typeof i == "string") {
      const s = (n = ge(this, zn).get(i)) == null ? void 0 : n.find((a) => a !== e && a.state.isPaused);
      return (s == null ? void 0 : s.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    Sr.batch(() => {
      ge(this, Zs).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), ge(this, Zs).clear(), ge(this, zn).clear();
    });
  }
  getAll() {
    return Array.from(ge(this, Zs));
  }
  find(e) {
    const i = { exact: !0, ...e };
    return this.getAll().find(
      (n) => JM(i, n)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((i) => JM(e, i));
  }
  notify(e) {
    Sr.batch(() => {
      this.listeners.forEach((i) => {
        i(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((i) => i.state.isPaused);
    return Sr.batch(
      () => Promise.all(
        e.map((i) => i.continue().catch(Fn))
      )
    );
  }
}, Zs = new WeakMap(), zn = new WeakMap(), kd = new WeakMap(), mA);
function Uf(r) {
  var e;
  return (e = r.options.scope) == null ? void 0 : e.id;
}
var cs, gA, loe = (gA = class extends $g {
  constructor(e = {}) {
    super();
    zt(this, cs);
    this.config = e, mt(this, cs, /* @__PURE__ */ new Map());
  }
  build(e, i, n) {
    const s = i.queryKey, a = i.queryHash ?? dT(s, i);
    let o = this.get(a);
    return o || (o = new ioe({
      client: e,
      queryKey: s,
      queryHash: a,
      options: e.defaultQueryOptions(i),
      state: n,
      defaultOptions: e.getQueryDefaults(s)
    }), this.add(o)), o;
  }
  add(e) {
    ge(this, cs).has(e.queryHash) || (ge(this, cs).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const i = ge(this, cs).get(e.queryHash);
    i && (e.destroy(), i === e && ge(this, cs).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    Sr.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return ge(this, cs).get(e);
  }
  getAll() {
    return [...ge(this, cs).values()];
  }
  find(e) {
    const i = { exact: !0, ...e };
    return this.getAll().find(
      (n) => $M(i, n)
    );
  }
  findAll(e = {}) {
    const i = this.getAll();
    return Object.keys(e).length > 0 ? i.filter((n) => $M(e, n)) : i;
  }
  notify(e) {
    Sr.batch(() => {
      this.listeners.forEach((i) => {
        i(e);
      });
    });
  }
  onFocus() {
    Sr.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    Sr.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, cs = new WeakMap(), gA), Ti, no, so, ac, oc, ao, lc, uc, yA, uoe = (yA = class {
  constructor(r = {}) {
    zt(this, Ti);
    zt(this, no);
    zt(this, so);
    zt(this, ac);
    zt(this, oc);
    zt(this, ao);
    zt(this, lc);
    zt(this, uc);
    mt(this, Ti, r.queryCache || new loe()), mt(this, no, r.mutationCache || new ooe()), mt(this, so, r.defaultOptions || {}), mt(this, ac, /* @__PURE__ */ new Map()), mt(this, oc, /* @__PURE__ */ new Map()), mt(this, ao, 0);
  }
  mount() {
    ap(this, ao)._++, ge(this, ao) === 1 && (mt(this, lc, bO.subscribe(async (r) => {
      r && (await this.resumePausedMutations(), ge(this, Ti).onFocus());
    })), mt(this, uc, sg.subscribe(async (r) => {
      r && (await this.resumePausedMutations(), ge(this, Ti).onOnline());
    })));
  }
  unmount() {
    var r, e;
    ap(this, ao)._--, ge(this, ao) === 0 && ((r = ge(this, lc)) == null || r.call(this), mt(this, lc, void 0), (e = ge(this, uc)) == null || e.call(this), mt(this, uc, void 0));
  }
  isFetching(r) {
    return ge(this, Ti).findAll({ ...r, fetchStatus: "fetching" }).length;
  }
  isMutating(r) {
    return ge(this, no).findAll({ ...r, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(r) {
    var i;
    const e = this.defaultQueryOptions({ queryKey: r });
    return (i = ge(this, Ti).get(e.queryHash)) == null ? void 0 : i.state.data;
  }
  ensureQueryData(r) {
    const e = this.defaultQueryOptions(r), i = ge(this, Ti).build(this, e), n = i.state.data;
    return n === void 0 ? this.fetchQuery(r) : (r.revalidateIfStale && i.isStaleByTime(Jx(e.staleTime, i)) && this.prefetchQuery(e), Promise.resolve(n));
  }
  getQueriesData(r) {
    return ge(this, Ti).findAll(r).map(({ queryKey: e, state: i }) => {
      const n = i.data;
      return [e, n];
    });
  }
  setQueryData(r, e, i) {
    const n = this.defaultQueryOptions({ queryKey: r }), s = ge(this, Ti).get(
      n.queryHash
    ), a = s == null ? void 0 : s.state.data, o = jae(e, a);
    if (o !== void 0)
      return ge(this, Ti).build(this, n).setData(o, { ...i, manual: !0 });
  }
  setQueriesData(r, e, i) {
    return Sr.batch(
      () => ge(this, Ti).findAll(r).map(({ queryKey: n }) => [
        n,
        this.setQueryData(n, e, i)
      ])
    );
  }
  getQueryState(r) {
    var i;
    const e = this.defaultQueryOptions({ queryKey: r });
    return (i = ge(this, Ti).get(
      e.queryHash
    )) == null ? void 0 : i.state;
  }
  removeQueries(r) {
    const e = ge(this, Ti);
    Sr.batch(() => {
      e.findAll(r).forEach((i) => {
        e.remove(i);
      });
    });
  }
  resetQueries(r, e) {
    const i = ge(this, Ti);
    return Sr.batch(() => (i.findAll(r).forEach((n) => {
      n.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...r
      },
      e
    )));
  }
  cancelQueries(r, e = {}) {
    const i = { revert: !0, ...e }, n = Sr.batch(
      () => ge(this, Ti).findAll(r).map((s) => s.cancel(i))
    );
    return Promise.all(n).then(Fn).catch(Fn);
  }
  invalidateQueries(r, e = {}) {
    return Sr.batch(() => (ge(this, Ti).findAll(r).forEach((i) => {
      i.invalidate();
    }), (r == null ? void 0 : r.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...r,
        type: (r == null ? void 0 : r.refetchType) ?? (r == null ? void 0 : r.type) ?? "active"
      },
      e
    )));
  }
  refetchQueries(r, e = {}) {
    const i = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, n = Sr.batch(
      () => ge(this, Ti).findAll(r).filter((s) => !s.isDisabled() && !s.isStatic()).map((s) => {
        let a = s.fetch(void 0, i);
        return i.throwOnError || (a = a.catch(Fn)), s.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(n).then(Fn);
  }
  fetchQuery(r) {
    const e = this.defaultQueryOptions(r);
    e.retry === void 0 && (e.retry = !1);
    const i = ge(this, Ti).build(this, e);
    return i.isStaleByTime(
      Jx(e.staleTime, i)
    ) ? i.fetch(e) : Promise.resolve(i.state.data);
  }
  prefetchQuery(r) {
    return this.fetchQuery(r).then(Fn).catch(Fn);
  }
  fetchInfiniteQuery(r) {
    return r.behavior = rA(r.pages), this.fetchQuery(r);
  }
  prefetchInfiniteQuery(r) {
    return this.fetchInfiniteQuery(r).then(Fn).catch(Fn);
  }
  ensureInfiniteQueryData(r) {
    return r.behavior = rA(r.pages), this.ensureQueryData(r);
  }
  resumePausedMutations() {
    return sg.isOnline() ? ge(this, no).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return ge(this, Ti);
  }
  getMutationCache() {
    return ge(this, no);
  }
  getDefaultOptions() {
    return ge(this, so);
  }
  setDefaultOptions(r) {
    mt(this, so, r);
  }
  setQueryDefaults(r, e) {
    ge(this, ac).set(Id(r), {
      queryKey: r,
      defaultOptions: e
    });
  }
  getQueryDefaults(r) {
    const e = [...ge(this, ac).values()], i = {};
    return e.forEach((n) => {
      Od(r, n.queryKey) && Object.assign(i, n.defaultOptions);
    }), i;
  }
  setMutationDefaults(r, e) {
    ge(this, oc).set(Id(r), {
      mutationKey: r,
      defaultOptions: e
    });
  }
  getMutationDefaults(r) {
    const e = [...ge(this, oc).values()], i = {};
    return e.forEach((n) => {
      Od(r, n.mutationKey) && Object.assign(i, n.defaultOptions);
    }), i;
  }
  defaultQueryOptions(r) {
    if (r._defaulted)
      return r;
    const e = {
      ...ge(this, so).queries,
      ...this.getQueryDefaults(r.queryKey),
      ...r,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = dT(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === ng && (e.enabled = !1), e;
  }
  defaultMutationOptions(r) {
    return r != null && r._defaulted ? r : {
      ...ge(this, so).mutations,
      ...(r == null ? void 0 : r.mutationKey) && this.getMutationDefaults(r.mutationKey),
      ...r,
      _defaulted: !0
    };
  }
  clear() {
    ge(this, Ti).clear(), ge(this, no).clear();
  }
}, Ti = new WeakMap(), no = new WeakMap(), so = new WeakMap(), ac = new WeakMap(), oc = new WeakMap(), ao = new WeakMap(), lc = new WeakMap(), uc = new WeakMap(), yA), coe = vA.createContext(
  void 0
), hoe = ({
  client: r,
  children: e
}) => (vA.useEffect(() => (r.mount(), () => {
  r.unmount();
}), [r]), /* @__PURE__ */ I.jsx(coe.Provider, { value: r, children: e })), doe = "https://prod.base-sepolia.intuition-api.com/v1/graphql", poe = "https://prod.base-mainnet-v-1-0.intuition.sh/v1/graphql", foe = poe, sA = {
  apiUrl: foe
};
function moe(r) {
  sA = { ...sA, ...r };
}
var ri = /* @__PURE__ */ ((r) => (r.MAINNET = "mainnet", r.TESTNET = "testnet", r))(ri || {});
const Pr = {
  mainnet: "https://testnet.intuition.sh/v1/graphql",
  testnet: doe
  // TODO: change to mainnet
}, pT = async (r, e = ri.MAINNET) => {
  var i, n;
  try {
    const s = Pr[e], a = [], o = 100;
    let l = 0, u = !0;
    for (; u; ) {
      const h = await (await fetch(s, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: `query GetActivePositions($accountId: String!, $limit: Int!, $offset: Int!) {
  positions(where: { account_id: { _eq: $accountId }, shares: { _gt: 0 } }, limit: $limit, offset: $offset) {
    id
    shares
    curve_id
    account {
      id
      label
      image
      atom_id
      type
    }
    term {
      id
      total_market_cap
      total_assets
      atom {
        label
      }
      triple {
        subject {
          label
        }
        predicate {
          label
        }
        object {
          label
        }
        counter_term {
          id
          total_market_cap
          total_assets
          atom {
            label
          }
          triple {
            subject {
              label
            }
            predicate {
              label
            }
            object {
              label
            }
          }
        }
      }
    }
    vault {
      deposits {
        vault_type
      }
      redemptions {
        vault_type
      }
    }
  }
}`,
          variables: { accountId: r, limit: o, offset: l }
        })
      })).json();
      if (h.errors)
        throw console.error("GraphQL errors:", h.errors), new Error(((i = h.errors[0]) == null ? void 0 : i.message) || "GraphQL error");
      const d = ((n = h.data) == null ? void 0 : n.positions) || [];
      d.length === 0 ? u = !1 : (a.push(...d), d.length < o ? u = !1 : l += o), l > 1e5 && (u = !1);
    }
    return a;
  } catch (s) {
    return console.error("Error fetching active positions:", s), [];
  }
}, goe = ({
  claim: r,
  walletAddress: e,
  onSelectionChange: i
}) => {
  var m;
  const [n, s] = ye("neutral"), [a, o] = ye(0), [l, u] = ye([]), [c, h] = ye(null);
  Ft(() => {
    (async () => {
      if (e)
        try {
          const g = (await pT(e, ri.MAINNET)).filter((b) => {
            var M, C, S;
            const T = ((M = b.term) == null ? void 0 : M.id) === r.term_id, E = ((C = b.term) == null ? void 0 : C.id) === ((S = r.counter_term) == null ? void 0 : S.id);
            return T || E;
          });
          u(g);
          const _ = g.find(
            (b) => {
              var T;
              return ((T = b.term) == null ? void 0 : T.id) === r.term_id && b.shares > 0;
            }
          ), x = g.find(
            (b) => {
              var T, E;
              return ((T = b.term) == null ? void 0 : T.id) === ((E = r.counter_term) == null ? void 0 : E.id) && b.shares > 0;
            }
          );
          s(_ ? "for" : x ? "against" : "neutral");
        } catch (v) {
          console.error("Error fetching user positions:", v);
        }
    })();
  }, [e, r.term_id, (m = r.counter_term) == null ? void 0 : m.id]);
  const d = (y) => y === "for" ? !l.some(
    (g) => {
      var _, x;
      return ((_ = g.term) == null ? void 0 : _.id) === ((x = r.counter_term) == null ? void 0 : x.id) && g.shares > 0;
    }
  ) : y === "against" ? !l.some(
    (g) => {
      var _;
      return ((_ = g.term) == null ? void 0 : _.id) === r.term_id && g.shares > 0;
    }
  ) : y === "neutral" ? !l.some(
    (g) => {
      var _, x, b;
      return (((_ = g.term) == null ? void 0 : _.id) === r.term_id || ((x = g.term) == null ? void 0 : x.id) === ((b = r.counter_term) == null ? void 0 : b.id)) && g.shares > 0;
    }
  ) : !0, p = (y) => {
    if ((y === "for" || y === "against") && !d(y)) {
      h(`You already have a ${y === "for" ? "Against" : "For"} position on this claim`);
      return;
    }
    h(null), s(y), y === "neutral" && o(0), i && i(a, y);
  }, f = (y) => {
    const v = parseFloat(y);
    if (isNaN(v) || v < 0) {
      o(0), i && i(0, n);
      return;
    }
    const g = v;
    o(g), i && i(g, n);
  };
  return /* @__PURE__ */ I.jsxs("div", { style: {
    display: "flex",
    alignItems: "center",
    gap: "8px",
    marginTop: "4px",
    justifyContent: "flex-end"
    // Aligner à droite
  }, children: [
    c && /* @__PURE__ */ I.jsx("div", { style: {
      color: "#ff6b6b",
      fontSize: "10px",
      marginRight: "8px",
      padding: "2px 6px",
      backgroundColor: "rgba(255, 107, 107, 0.1)",
      borderRadius: "3px",
      border: "1px solid rgba(255, 107, 107, 0.3)"
    }, children: c }),
    /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px" }, children: [
      /* @__PURE__ */ I.jsx(
        "input",
        {
          type: "number",
          value: a,
          onChange: (y) => f(y.target.value),
          step: "0.001",
          min: "0",
          placeholder: "0.000",
          style: {
            width: "65px",
            padding: "2px",
            backgroundColor: "rgba(255, 255, 255, 0.05)",
            border: "1px solid rgba(255, 255, 255, 0.1)",
            borderRadius: "6px",
            color: "#fff",
            fontSize: "12px",
            textAlign: "left",
            marginBottom: "2px"
          },
          disabled: n === "neutral"
        }
      ),
      /* @__PURE__ */ I.jsx("span", { style: {
        fontSize: "12px",
        color: "rgba(255, 255, 255, 0.6)",
        fontWeight: "500"
      }, children: "TRUST" })
    ] }),
    /* @__PURE__ */ I.jsx(
      "div",
      {
        style: {
          position: "relative",
          width: "60px",
          height: "20px",
          backgroundColor: "rgba(255, 255, 255, 0.1)",
          borderRadius: "10px",
          cursor: "pointer",
          opacity: d("for") && d("against") && d("neutral") ? 1 : 0.5
        },
        onClick: () => {
          n === "neutral" && d("for") ? p("for") : n === "for" && d("against") ? p("against") : (n === "against" && d("neutral") || n === "for" && !d("against") && d("neutral") || n === "against" && !d("for") && d("neutral")) && p("neutral");
        },
        title: !d("for") || !d("against") || !d("neutral") ? "You already have an active position on this claim" : `Current: ${n.toUpperCase()} - Click to change`,
        children: /* @__PURE__ */ I.jsx("div", { style: {
          position: "absolute",
          top: "2px",
          left: n === "for" ? "2px" : n === "against" ? "42px" : "20px",
          width: "16px",
          height: "16px",
          backgroundColor: n === "for" ? "rgb(0, 111, 232)" : n === "against" ? "rgb(255, 149, 0)" : "rgba(255, 255, 255, 0.3)",
          borderRadius: "50%",
          transition: "all 0.2s ease",
          boxShadow: "0 1px 3px rgba(0, 0, 0, 0.3)"
        } })
      }
    )
  ] });
};
var lt = /* @__PURE__ */ ((r) => (r.For = "FOR", r.Against = "AGAINST", r.None = "NONE", r))(lt || {});
const qo = {
  GAMES_ID: "0x5dc0a2335c12343d8e0f71b62a73fbf70d06fcbaf647f57d82a189873ad90da3",
  FOLLOWS: "0x8f9b5dc2e7b8bd12f6762c839830672f1d13c08e72b5f09f194cafc153f2df8a",
  // prédicat --> follows
  IS: "0x2af261bce70c2fc3a1abf882e3e89b23066fcd150bfda27fab69f9f55ed2d9d0",
  // prédicat --> is
  IS_PLAYER_OF: "0x05f1707d8cb50571d01021f09a664826aa1be2ff43504c0cca55eef87142f84f"
  // prédicat --> is player of
}, yoe = {
  PLAYER_GAME: {
    predicateId: qo.IS_PLAYER_OF,
    // predicat --> is player of !!!
    objectId: qo.GAMES_ID
    // object --> games (BossFighters)
  },
  PLAYER_QUALITY_1: {
    predicateId: qo.IS,
    // predicat --> is 
    objectId: "0xc9559c712c264e5f94ce450ed9473c451b6fd01ab6a436a726fbae767cd67b9c"
    // object --> fairplay !!!
  },
  PLAYER_QUALITY_2: {
    predicateId: qo.IS,
    // predicat --> is 
    objectId: "0x56d28a901a7f2617247f1663b0c25c77ba6403a8141bac43b1e94eb32a2de941"
    // object --> strong boss !!!
  },
  PLAYER_QUALITY_3: {
    predicateId: qo.IS,
    // predicat --> is 
    objectId: "0xc8433466cda62c0e8bb4fc5433f3faa51949072d6c7b0df50a595c95fb97f1bb"
    // object --> strong fighter !!!
  },
  PLAYER_GUILD: {
    predicateId: qo.IS_PLAYER_OF,
    // predicat --> is player of !!!
    objectId: null
    // Sera défini dynamiquement en fonction du choix de guilde
  }
}, voe = [
  { id: "0x4320ae619f6a9c9b79ee8e2a9415585aff1c287f0b72b08c049cf7a5780eb08d", name: "The Alchemists" },
  // id --> The Alchemists !!!
  { id: "0x12d4b4425dcfeaf46af6543e8de0133f22f768a69d56a3aa28662ecb06aa9ca1", name: "Big Time Warriors" },
  // id --> Big Time Warriors !!!
  { id: "0xd9e1d54c0cb904c23e04caea94f9d0dae00874ec18849ca74a832e94c6de01fa", name: "The NEST" },
  // id --> The NEST !!!
  { id: "0xd473ceacf850609ff8881c398e85e59aadbc315588ca78182313cc1af05a2800", name: "Clock Work Gamers" },
  // id --> Clock Work Gamers !!!
  { id: "0x14511bc4065a1e7d67ba7d50d4706a8899a148a2e68b55213794c14e347acaa", name: "Vast Impact Gaming" }
  // id --> Vast Impact Gaming !!!
  // { id: "0x93815368a0d207e11be12da396d51dea4e3f8e637fe49f696648feb451f6f9c7", name: "Kraken Gaming" }, // id --> Kraken Gaming !!!
  // { id: "0x508dee963f045411bd0bf4ab9433f40b72ca4270eb0f31222f299211cffbb0bc", name: "FAM" } // id --> FAM
], r_ = 10000000000000000n, boe = [
  "0x27191de92fe0308355319ec8f2359e5ce85123bd243bf7ffa6eb8028347b3eab",
  // toxic - is map of - bossfights
  "0x561a2c3e4359c8ed1c468aef27691e8e48b4424344a38c7693b9127b1911efc9",
  // toxic - is - fun
  "0x6d7e52c5e80bf6c2873a21cb7013ba0655dc0458c77f2c0e7446c49efdbd0033"
  // toxic - is - immersive
  // "0x9df847b39391899840d7973d9718d8caef5c5467dde9374a96d1f71727bae7c4" // toxic - is - balanced
], xoe = {
  COMMON_IDS: qo,
  PLAYER_TRIPLE_TYPES: yoe,
  OFFICIAL_GUILDS: voe,
  PREDEFINED_CLAIM_IDS: boe
}, wO = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  network: n = ri.MAINNET
}) => {
  const [s, a] = ye(!1), o = async (u) => {
    var c;
    try {
      const h = Pr[n], d = await fetch(h, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: `
            query Triple($tripleId: String!) {
              triple(term_id: $tripleId) {
                term_id
                counter_term_id
              }
            }
          `,
          variables: { tripleId: String(u) }
        })
      });
      if (!d.ok)
        return null;
      const p = await d.json();
      return p.errors ? (console.error("❌ GraphQL errors:", p.errors), null) : (c = p.data) != null && c.triple ? {
        id: String(u),
        ...p.data.triple
      } : (console.error("❌ No triple data found"), null);
    } catch (h) {
      return console.error("❌ fetchTripleDetails error:", h), null;
    }
  };
  return {
    depositTriple: async (u) => {
      if (!r || !e)
        return {
          success: !1,
          error: "Wallet not connected"
        };
      if (u.length === 0)
        return {
          success: !1,
          error: "No votes provided"
        };
      for (const c of u)
        if (c.units <= 0)
          return {
            success: !1,
            error: "Units must be greater than 0"
          };
      a(!0);
      try {
        const c = [], h = [], d = [], p = [];
        for (const y of u) {
          const v = await o(y.claimId);
          if (!v)
            return a(!1), {
              success: !1,
              error: `Failed to fetch triple details for claim ${y.claimId}`
            };
          let g;
          if (y.direction === lt.For) {
            if (!v.term_id)
              return console.error("❌ term_id is undefined for FOR vote"), { success: !1, error: "term_id not found" };
            g = v.term_id;
          } else {
            if (!v.counter_term_id)
              return console.error("❌ counter_term_id is undefined for AGAINST vote"), { success: !1, error: "counter_term_id not found" };
            g = v.counter_term_id;
          }
          if (!g)
            return console.error("❌ targetId is undefined"), { success: !1, error: "targetId not found" };
          const _ = Number(r_) * y.units, x = Math.round(_), b = BigInt(x);
          c.push(g), h.push(1n), d.push(b), p.push(0n);
        }
        const f = await r.writeContract({
          address: pl,
          abi: ju,
          functionName: "depositBatch",
          args: [
            e,
            // receiver
            c,
            // termIds array
            h,
            // curveIds array
            d,
            // assets array
            p
            // minShares array
          ],
          value: d.reduce((y, v) => y + v, 0n),
          // Total value
          gas: 500000n * BigInt(u.length)
          // Gas based on number of votes
        });
        let m;
        return r.waitForTransactionReceipt ? m = await r.waitForTransactionReceipt({ hash: f }) : f.wait ? m = await f.wait() : await new Promise((y) => setTimeout(y, 5e3)), a(!1), {
          success: !0,
          hash: typeof f == "string" ? f : f.hash
        };
      } catch (c) {
        return a(!1), {
          success: !1,
          error: c instanceof Error ? c.message : String(c)
        };
      }
    },
    isLoading: s
  };
}, _oe = ({
  isOpen: r,
  onClose: e,
  activities: i,
  walletAddress: n,
  walletConnected: s,
  publicClient: a
}) => {
  const [o, l] = ye(1), [u, c] = ye({}), [h, d] = ye(!1), p = 10, { depositTriple: f } = wO({
    walletConnected: s,
    walletAddress: n,
    publicClient: a
  }), m = Math.ceil(i.length / p), y = (o - 1) * p, v = y + p, g = i.slice(y, v), _ = () => {
    e(), l(1), c({});
  }, x = (E, M, C) => {
    if (C === "neutral" || M === 0) {
      const S = { ...u };
      delete S[E], c(S);
    } else
      c((S) => ({
        ...S,
        [E]: { trust: M, direction: C }
      }));
  }, b = async () => {
    if (Object.keys(u).length !== 0) {
      d(!0);
      try {
        const M = Object.entries(u).map(([S, w]) => ({
          claimId: S,
          units: w.trust * 100,
          direction: w.direction === "for" ? lt.For : lt.Against
        })), C = await f(M);
        C.success ? c({}) : console.error("❌ Deposit failed:", C.error);
      } catch (M) {
        console.error("❌ Deposit error:", M);
      } finally {
        d(!1);
      }
    }
  }, T = Object.keys(u).length;
  return /* @__PURE__ */ I.jsx(
    uT,
    {
      isOpen: r,
      onClose: _,
      title: `All Claims (${i.length})`,
      children: /* @__PURE__ */ I.jsxs("div", { style: { padding: "0" }, children: [
        /* @__PURE__ */ I.jsx("div", { style: { padding: "16px 24px 16px" }, children: g.map((E) => {
          var M, C, S, w, R, O;
          return /* @__PURE__ */ I.jsxs(
            "div",
            {
              style: {
                width: "100%",
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                border: "1px solid rgba(255, 255, 255, 0.1)",
                borderRadius: "12px",
                overflow: "hidden",
                marginBottom: "2px",
                backgroundColor: "rgba(255, 255, 255, 0.05)"
              },
              children: [
                /* @__PURE__ */ I.jsxs(
                  "div",
                  {
                    style: {
                      width: "100%",
                      display: "flex",
                      flexDirection: "row",
                      justifyContent: "space-between",
                      alignItems: "center",
                      padding: "16px 16px 10px 16px",
                      gap: "12px"
                    },
                    children: [
                      /* @__PURE__ */ I.jsx("div", { style: { display: "flex", flex: 1, alignItems: "center", gap: "8px" }, children: /* @__PURE__ */ I.jsx(
                        ey,
                        {
                          subject: "",
                          predicate: E.predicate.label,
                          object: E.object.label,
                          fontSize: "12px",
                          showArrows: !1
                        }
                      ) }),
                      /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                        /* @__PURE__ */ I.jsx(
                          Nc,
                          {
                            isFor: !0,
                            count: ((S = (C = (M = E.term) == null ? void 0 : M.positions_aggregate) == null ? void 0 : C.aggregate) == null ? void 0 : S.count) || 0,
                            fontSize: "12px",
                            showCount: !0
                          }
                        ),
                        /* @__PURE__ */ I.jsx(
                          Nc,
                          {
                            isFor: !1,
                            count: ((O = (R = (w = E.counter_term) == null ? void 0 : w.positions_aggregate) == null ? void 0 : R.aggregate) == null ? void 0 : O.count) || 0,
                            fontSize: "12px",
                            showCount: !0
                          }
                        )
                      ] })
                    ]
                  }
                ),
                /* @__PURE__ */ I.jsx("div", { style: { width: "100%", display: "flex", justifyContent: "flex-end", marginBottom: "5px", marginRight: "16px" }, children: /* @__PURE__ */ I.jsx(
                  goe,
                  {
                    claim: E,
                    walletAddress: n,
                    walletConnected: s,
                    publicClient: a,
                    onSelectionChange: (P, A) => x(E.term_id, P, A)
                  }
                ) })
              ]
            },
            E.term_id
          );
        }) }),
        /* @__PURE__ */ I.jsxs("div", { style: {
          borderTop: "1px solid #374151",
          padding: "16px 24px",
          backgroundColor: "#18181b",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          position: "sticky",
          bottom: 0,
          zIndex: 10
        }, children: [
          /* @__PURE__ */ I.jsx("div", { children: /* @__PURE__ */ I.jsx(
            hT,
            {
              currentPage: o,
              itemsPerPage: p,
              totalItems: i.length
            }
          ) }),
          T > 0 && /* @__PURE__ */ I.jsx("div", { style: { display: "flex", justifyContent: "center", flex: 1 }, children: /* @__PURE__ */ I.jsx(
            "button",
            {
              onClick: b,
              disabled: h,
              style: {
                backgroundColor: "#ffd32a",
                color: "#000",
                border: "none",
                borderRadius: "8px",
                padding: "12px 24px",
                fontSize: "14px",
                fontWeight: "600",
                cursor: h ? "not-allowed" : "pointer",
                opacity: h ? 0.7 : 1,
                transition: "all 0.2s",
                minWidth: "200px"
              },
              onMouseEnter: (E) => {
                h || (E.currentTarget.style.backgroundColor = "#ffed4e");
              },
              onMouseLeave: (E) => {
                h || (E.currentTarget.style.backgroundColor = "#ffd32a");
              },
              children: h ? "Processing..." : `Deposit All Selected (${T})`
            }
          ) }),
          /* @__PURE__ */ I.jsx("div", { children: /* @__PURE__ */ I.jsx(
            cT,
            {
              currentPage: o,
              totalPages: m,
              onPageChange: l,
              itemsPerPage: p,
              totalItems: i.length
            }
          ) })
        ] })
      ] })
    }
  );
}, Toe = ({
  activities: r,
  title: e = "My Claims",
  walletAddress: i,
  walletConnected: n,
  publicClient: s
}) => {
  const [a, o] = ye(!1);
  return /* @__PURE__ */ I.jsxs("div", { style: { marginTop: "10px" }, children: [
    /* @__PURE__ */ I.jsxs("h3", { children: [
      e,
      " (",
      r.length,
      ")"
    ] }),
    r.length > 0 ? /* @__PURE__ */ I.jsxs("div", { style: { maxHeight: "300px", overflowY: "auto" }, children: [
      r.slice(0, 3).map((l) => {
        var u, c, h, d, p, f, m, y;
        return /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              width: "100%",
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              border: "1px solid rgba(255, 255, 255, 0.1)",
              borderRadius: "12px",
              overflow: "hidden",
              marginBottom: "2px",
              backgroundColor: "rgba(255, 255, 255, 0.05)"
            },
            children: /* @__PURE__ */ I.jsxs(
              "div",
              {
                style: {
                  width: "100%",
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "space-between",
                  alignItems: "center",
                  padding: "16px",
                  gap: "12px"
                },
                children: [
                  /* @__PURE__ */ I.jsx("div", { style: { display: "flex", flex: 1, alignItems: "center", gap: "8px" }, children: /* @__PURE__ */ I.jsx(
                    ey,
                    {
                      subject: "",
                      predicate: String(((u = l.predicate) == null ? void 0 : u.label) ?? ""),
                      object: String(((c = l.object) == null ? void 0 : c.label) ?? ""),
                      fontSize: "12px",
                      showArrows: !1
                    }
                  ) }),
                  /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                    /* @__PURE__ */ I.jsx(
                      Nc,
                      {
                        isFor: !0,
                        count: ((p = (d = (h = l.term) == null ? void 0 : h.positions_aggregate) == null ? void 0 : d.aggregate) == null ? void 0 : p.count) || 0,
                        fontSize: "12px",
                        showCount: !0
                      }
                    ),
                    /* @__PURE__ */ I.jsx(
                      Nc,
                      {
                        isFor: !1,
                        count: ((y = (m = (f = l.counter_term) == null ? void 0 : f.positions_aggregate) == null ? void 0 : m.aggregate) == null ? void 0 : y.count) || 0,
                        fontSize: "12px",
                        showCount: !0
                      }
                    )
                  ] })
                ]
              }
            )
          },
          l.term_id
        );
      }),
      r.length > 3 && /* @__PURE__ */ I.jsxs(
        "div",
        {
          style: {
            padding: "12px",
            textAlign: "center",
            fontSize: "12px",
            color: "rgba(255, 255, 255, 0.6)",
            fontStyle: "italic",
            cursor: "pointer",
            transition: "color 0.2s"
          },
          onClick: () => o(!0),
          onMouseEnter: (l) => {
            l.currentTarget.style.color = "#fff";
          },
          onMouseLeave: (l) => {
            l.currentTarget.style.color = "rgba(255, 255, 255, 0.6)";
          },
          children: [
            "Show all ",
            r.length,
            " claims"
          ]
        }
      )
    ] }) : /* @__PURE__ */ I.jsx("p", { style: { color: "rgba(255, 255, 255, 0.6)", fontStyle: "italic" }, children: "No claim found" }),
    /* @__PURE__ */ I.jsx(
      _oe,
      {
        isOpen: a,
        onClose: () => o(!1),
        activities: r,
        walletAddress: i,
        walletConnected: n,
        publicClient: s
      }
    )
  ] });
}, woe = () => {
  const [r, e] = ye(/* @__PURE__ */ new Set()), [i, n] = ye({});
  return {
    selectedPositions: r,
    redeemAmounts: i,
    handlePositionSelect: (l, u) => {
      e((c) => {
        const h = new Set(c);
        return u ? h.add(l) : (h.delete(l), n((d) => {
          const p = { ...d };
          return delete p[l], p;
        })), h;
      });
    },
    handleAmountChange: (l, u) => {
      n((c) => ({
        ...c,
        [l]: u
      }));
    },
    clearSelection: () => {
      e(/* @__PURE__ */ new Set()), n({});
    }
  };
}, Soe = ({
  walletConnected: r,
  walletAddress: e
}) => {
  const [i, n] = ye(!1);
  return {
    redeemBatch: async (a) => {
      if (!r || !e)
        throw new Error("Wallet not connected");
      n(!0);
      try {
        const o = await r.writeContract({
          address: pl,
          abi: ju,
          functionName: "redeemBatch",
          args: [
            a.receiver,
            // receiver
            a.termIds,
            // termIds array
            a.curveIds,
            // curveIds array
            a.shares,
            // shares array
            a.minAssets
            // minAssets array
          ],
          gas: 500000n * BigInt(a.termIds.length)
          // Gas based on number of redemptions
        });
        let l;
        return r.waitForTransactionReceipt ? l = await r.waitForTransactionReceipt({ hash: o }) : o.wait ? l = await o.wait() : await new Promise((u) => setTimeout(u, 5e3)), n(!1), {
          success: !0,
          hash: typeof o == "string" ? o : o.hash
        };
      } catch (o) {
        throw n(!1), o;
      }
    },
    isLoading: i
  };
}, Eoe = ({ walletConnected: r, walletAddress: e }) => {
  const { redeemBatch: i, isLoading: n } = Soe({
    walletConnected: r,
    walletAddress: e
  });
  return {
    handleRedeemAllSelected: async (a, o, l, u) => {
      if (o.size === 0) return;
      const c = a.filter((h) => o.has(h.id));
      try {
        const h = [], d = [], p = [], f = [];
        for (const m of c) {
          const y = l[m.id] || m.shares, v = m.curve_id;
          h.push(m.term.id), d.push(BigInt(v)), p.push(BigInt(y)), f.push(BigInt(0));
        }
        return await i({
          receiver: u,
          termIds: h,
          curveIds: d,
          shares: p,
          minAssets: f
        }), { success: !0 };
      } catch (h) {
        return console.error("Error redeeming selected positions:", h), { success: !1, error: h };
      }
    },
    isLoading: n
  };
}, Moe = ({ accountId: r, walletConnected: e, walletAddress: i }) => {
  const [n, s] = ye([]), [a, o] = ye(!0), [l, u] = ye(!1), [c, h] = ye(1), d = 7, { selectedPositions: p, redeemAmounts: f, handlePositionSelect: m, handleAmountChange: y, clearSelection: v } = woe(), { handleRedeemAllSelected: g, isLoading: _ } = Eoe({ walletConnected: e, walletAddress: i });
  Ft(() => {
    (async () => {
      if (r) {
        o(!0);
        try {
          const T = await pT(r);
          s(T);
        } catch (T) {
          console.error("Error loading positions:", T), s([]);
        } finally {
          o(!1);
        }
      }
    })();
  }, [r]);
  const x = async () => {
    const b = await g(n, p, f, r);
    b != null && b.success && v();
  };
  return a ? /* @__PURE__ */ I.jsxs("div", { style: { marginTop: "10px", marginBottom: "10px" }, children: [
    /* @__PURE__ */ I.jsx("h3", { children: "My Positions" }),
    /* @__PURE__ */ I.jsx("p", { children: "Loading positions..." })
  ] }) : /* @__PURE__ */ I.jsxs("div", { style: { marginTop: "10px", marginBottom: "10px" }, children: [
    /* @__PURE__ */ I.jsxs(
      "button",
      {
        onClick: () => u(!0),
        style: {
          background: "#ffd32a",
          color: "#000",
          border: "none",
          borderRadius: "8px",
          padding: "12px 24px",
          fontSize: "14px",
          fontWeight: "bold",
          cursor: "pointer",
          transition: "all 0.2s",
          width: "100%"
        },
        onMouseEnter: (b) => {
          b.currentTarget.style.background = "#ffed4e", b.currentTarget.style.transform = "translateY(-1px)";
        },
        onMouseLeave: (b) => {
          b.currentTarget.style.background = "#ffd32a", b.currentTarget.style.transform = "translateY(0)";
        },
        children: [
          "My Positions (",
          n.length,
          ")"
        ]
      }
    ),
    /* @__PURE__ */ I.jsx(
      uT,
      {
        isOpen: l,
        onClose: () => {
          u(!1), h(1);
        },
        title: `My Positions (${n.length})`,
        children: /* @__PURE__ */ I.jsxs("div", { style: { padding: "0" }, children: [
          (() => {
            const b = (c - 1) * d, T = b + d;
            return n.slice(b, T).map((M, C) => /* @__PURE__ */ I.jsx("div", { style: { padding: "8px 24px 8px" }, children: /* @__PURE__ */ I.jsx(
              kae,
              {
                position: M,
                isSelected: p.has(M.id),
                onSelect: m,
                onAmountChange: y,
                redeemAmount: f[M.id]
              },
              M.id || C
            ) }, M.id || C));
          })(),
          /* @__PURE__ */ I.jsxs("div", { style: {
            borderTop: "1px solid #374151",
            padding: "16px 24px",
            backgroundColor: "#18181b",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            position: "sticky",
            bottom: 0,
            zIndex: 10
          }, children: [
            /* @__PURE__ */ I.jsx("div", { children: /* @__PURE__ */ I.jsx(
              hT,
              {
                currentPage: c,
                itemsPerPage: d,
                totalItems: n.length
              }
            ) }),
            /* @__PURE__ */ I.jsx("div", { children: /* @__PURE__ */ I.jsx(
              Roe,
              {
                selectedCount: p.size,
                onRedeemAll: x,
                isLoading: _
              }
            ) }),
            /* @__PURE__ */ I.jsx("div", { children: /* @__PURE__ */ I.jsx(
              cT,
              {
                currentPage: c,
                totalPages: Math.ceil(n.length / d),
                onPageChange: h,
                itemsPerPage: d,
                totalItems: n.length
              }
            ) })
          ] })
        ] })
      }
    )
  ] });
}, aA = async (r, e, i, n, s = 100) => {
  var u, c;
  const a = [];
  let o = 0, l = !0;
  for (; l; ) {
    const d = await (await fetch(r, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: e,
        variables: { ...i, limit: s, offset: o }
      })
    })).json();
    if (d.errors)
      throw console.error("GraphQL errors:", d.errors), new Error(((u = d.errors[0]) == null ? void 0 : u.message) || "GraphQL error");
    const p = ((c = d.data) == null ? void 0 : c[n]) || [];
    p.length === 0 ? l = !1 : (a.push(...p), p.length < s ? l = !1 : o += s);
  }
  return a;
}, Aoe = async (r, e = ri.MAINNET) => {
  try {
    const i = Pr[e], n = 100, s = `
      query GetDeposits($accountId: String!, $limit: Int!, $offset: Int!) {
        deposits(
          limit: $limit,
          offset: $offset,
          where: { sender_id: { _eq: $accountId } }
        ) {
          id
          shares
          assets_after_fees
          created_at
          vault_type
          term {
            id
            total_market_cap
            total_assets
            atom {
              label
            }
            triple {
              subject {
                label
              }
              predicate {
                label
              }
              object {
                label
              }
              counter_term {
                id
                total_market_cap
                total_assets
                atom {
                  label
                }
                triple {
                  subject {
                    label
                  }
                  predicate {
                    label
                  }
                  object {
                    label
                  }
                }
              }
            }
          }
        }
      }
    `, a = `
      query GetRedemptions($accountId: String!, $limit: Int!, $offset: Int!) {
        redemptions(
          limit: $limit,
          offset: $offset,
          where: { sender_id: { _eq: $accountId } }
        ) {
          id
          shares
          assets
          created_at
          vault_type
          term {
            id
            total_market_cap
            total_assets
            atom {
              label
            }
            triple {
              subject {
                label
              }
              predicate {
                label
              }
              object {
                label
              }
              counter_term {
                id
                total_market_cap
                total_assets
                atom {
                  label
                }
                triple {
                  subject {
                    label
                  }
                  predicate {
                    label
                  }
                  object {
                    label
                  }
                }
              }
            }
          }
        }
      }
    `, [o, l] = await Promise.all([
      aA(i, s, { accountId: r }, "deposits", n),
      aA(i, a, { accountId: r }, "redemptions", n)
    ]);
    return [
      ...o.map((c) => ({ ...c, activity_type: "deposit" })),
      ...l.map((c) => ({ ...c, activity_type: "redemption" }))
    ].sort((c, h) => new Date(h.created_at).getTime() - new Date(c.created_at).getTime());
  } catch (i) {
    return console.error("Error fetching activity history:", i), [];
  }
}, Coe = ({ accountId: r }) => {
  const [e, i] = ye([]), [n, s] = ye(!0), [a, o] = ye(!1), [l, u] = ye(1), c = 10;
  return Ft(() => {
    (async () => {
      if (r) {
        s(!0);
        try {
          const d = await Aoe(r);
          i(d);
        } catch (d) {
          console.error("Error loading activity history:", d), i([]);
        } finally {
          s(!1);
        }
      }
    })();
  }, [r]), n ? /* @__PURE__ */ I.jsxs("div", { style: { marginTop: "10px" }, children: [
    /* @__PURE__ */ I.jsx("h3", { children: "Activity History" }),
    /* @__PURE__ */ I.jsx("p", { children: "Loading activities..." })
  ] }) : /* @__PURE__ */ I.jsxs("div", { style: { marginTop: "20px" }, children: [
    /* @__PURE__ */ I.jsxs(
      "button",
      {
        onClick: () => o(!0),
        style: {
          background: "#ffd429",
          color: "#000",
          border: "none",
          borderRadius: "8px",
          padding: "12px 24px",
          fontSize: "14px",
          fontWeight: "bold",
          cursor: "pointer",
          transition: "all 0.2s",
          width: "100%"
        },
        onMouseEnter: (h) => {
          h.currentTarget.style.background = "#ffed4e", h.currentTarget.style.transform = "translateY(-1px)";
        },
        onMouseLeave: (h) => {
          h.currentTarget.style.background = "#ffd32a", h.currentTarget.style.transform = "translateY(0)";
        },
        children: [
          "Activity History (",
          e.length,
          ")"
        ]
      }
    ),
    /* @__PURE__ */ I.jsx(
      uT,
      {
        isOpen: a,
        onClose: () => {
          o(!1), u(1);
        },
        title: `Activity History (${e.length})`,
        children: /* @__PURE__ */ I.jsx("div", { style: { padding: "0" }, children: (() => {
          const h = Math.ceil(e.length / c), d = (l - 1) * c, p = d + c, f = e.slice(d, p);
          return /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
            /* @__PURE__ */ I.jsx("div", { style: { padding: "16px 24px 16px" }, children: f.map((m, y) => /* @__PURE__ */ I.jsx(Pae, { activity: m }, m.id || y)) }),
            /* @__PURE__ */ I.jsxs("div", { style: {
              borderTop: "1px solid #374151",
              padding: "16px 24px",
              backgroundColor: "#18181b",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              position: "sticky",
              bottom: 0,
              zIndex: 10
            }, children: [
              /* @__PURE__ */ I.jsx("div", { children: /* @__PURE__ */ I.jsx(
                hT,
                {
                  currentPage: l,
                  itemsPerPage: c,
                  totalItems: e.length
                }
              ) }),
              /* @__PURE__ */ I.jsx("div", { children: /* @__PURE__ */ I.jsx(
                cT,
                {
                  currentPage: l,
                  totalPages: h,
                  onPageChange: u,
                  itemsPerPage: c,
                  totalItems: e.length
                }
              ) })
            ] })
          ] });
        })() })
      }
    )
  ] });
}, Roe = ({
  selectedCount: r,
  onRedeemAll: e,
  isLoading: i
}) => r === 0 ? null : /* @__PURE__ */ I.jsx(
  "button",
  {
    onClick: e,
    disabled: i,
    style: {
      padding: "8px 16px",
      borderRadius: "6px",
      border: "none",
      backgroundColor: i ? "#374151" : "#ffd32a",
      color: i ? "#9ca3af" : "#000",
      fontSize: "14px",
      fontWeight: "bold",
      cursor: i ? "not-allowed" : "pointer"
    },
    children: i ? "Redeeming..." : `Redeem All Selected (${r})`
  }
), mm = ({
  text: r,
  maxLength: e,
  className: i,
  style: n
}) => {
  const s = r.length <= e ? r : r.slice(0, e) + "...";
  return /* @__PURE__ */ I.jsx("span", { className: i, style: n, children: s });
}, ey = ({
  subject: r,
  predicate: e,
  object: i,
  fontSize: n = "13px",
  showArrows: s = !0
}) => /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", flexWrap: "wrap" }, children: [
  r && /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
    /* @__PURE__ */ I.jsxs("div", { style: {
      padding: "4px 8px",
      borderRadius: "12px",
      border: "1px solid rgba(255, 255, 255, 0.2)",
      backgroundColor: "rgba(255, 255, 255, 0.05)",
      fontSize: n,
      color: "#fff",
      display: "flex",
      alignItems: "center",
      gap: "4px"
    }, children: [
      /* @__PURE__ */ I.jsx("div", { style: {
        width: "4px",
        height: "4px",
        borderRadius: "50%",
        backgroundColor: "#FF9500"
      } }),
      /* @__PURE__ */ I.jsx(mm, { text: r, maxLength: 10 })
    ] }),
    s && /* @__PURE__ */ I.jsx("div", { style: { color: "rgba(255, 255, 255, 0.6)", fontSize: "12px" }, children: "→" })
  ] }),
  /* @__PURE__ */ I.jsxs("div", { style: {
    padding: "4px 8px",
    borderRadius: "12px",
    border: "1px solid rgba(255, 255, 255, 0.2)",
    backgroundColor: "rgba(255, 255, 255, 0.05)",
    fontSize: n,
    color: "#fff",
    display: "flex",
    alignItems: "center",
    gap: "4px"
  }, children: [
    /* @__PURE__ */ I.jsx("div", { style: {
      width: "4px",
      height: "4px",
      borderRadius: "50%",
      backgroundColor: "#006FE8"
    } }),
    /* @__PURE__ */ I.jsx(mm, { text: e, maxLength: 8 })
  ] }),
  s && /* @__PURE__ */ I.jsx("div", { style: { color: "rgba(255, 255, 255, 0.6)", fontSize: "12px" }, children: "→" }),
  /* @__PURE__ */ I.jsxs("div", { style: {
    padding: "4px 8px",
    borderRadius: "12px",
    border: "1px solid rgba(255, 255, 255, 0.2)",
    backgroundColor: "rgba(255, 255, 255, 0.05)",
    fontSize: n,
    color: "#fff",
    display: "flex",
    alignItems: "center",
    gap: "4px"
  }, children: [
    /* @__PURE__ */ I.jsx("div", { style: {
      width: "4px",
      height: "4px",
      borderRadius: "50%",
      backgroundColor: "#4CAF50"
    } }),
    /* @__PURE__ */ I.jsx(mm, { text: i, maxLength: 12 })
  ] })
] }), SO = ({ label: r, fontSize: e = "13px", maxLength: i = 15 }) => /* @__PURE__ */ I.jsxs("div", { style: {
  padding: "4px 8px",
  borderRadius: "12px",
  border: "1px solid rgba(255, 255, 255, 0.2)",
  backgroundColor: "rgba(255, 255, 255, 0.05)",
  fontSize: e,
  color: "#fff",
  display: "inline-flex",
  alignItems: "center",
  gap: "4px"
}, children: [
  /* @__PURE__ */ I.jsx("div", { style: {
    width: "4px",
    height: "4px",
    borderRadius: "50%",
    backgroundColor: "#9C27B0"
  } }),
  /* @__PURE__ */ I.jsx(mm, { text: r, maxLength: i })
] }), Nc = ({
  isFor: r,
  count: e,
  fontSize: i = "12px",
  showCount: n = !1
}) => /* @__PURE__ */ I.jsxs("div", { style: {
  display: "flex",
  alignItems: "center",
  gap: "4px",
  padding: "4px 8px",
  borderRadius: "6px",
  backgroundColor: r ? "rgba(0, 111, 232, 0.2)" : "rgba(255, 149, 0, 0.2)",
  border: `1px solid ${r ? "rgba(0, 111, 232, 0.3)" : "rgba(255, 149, 0, 0.3)"}`
}, children: [
  /* @__PURE__ */ I.jsx("div", { style: {
    width: "0",
    height: "0",
    borderLeft: "4px solid transparent",
    borderRight: "4px solid transparent",
    borderBottom: r ? "6px solid #006FE8" : "none",
    borderTop: r ? "none" : "6px solid #FF9500"
  } }),
  /* @__PURE__ */ I.jsx("span", { style: {
    fontSize: i,
    color: r ? "#006FE8" : "#FF9500",
    fontWeight: "600"
  }, children: n && e !== void 0 ? e : r ? "For" : "Against" })
] });
var EO = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, oA = si.createContext && /* @__PURE__ */ si.createContext(EO), Noe = ["attr", "size", "title"];
function Poe(r, e) {
  if (r == null) return {};
  var i = Ioe(r, e), n, s;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(r);
    for (s = 0; s < a.length; s++)
      n = a[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (i[n] = r[n]);
  }
  return i;
}
function Ioe(r, e) {
  if (r == null) return {};
  var i = {};
  for (var n in r)
    if (Object.prototype.hasOwnProperty.call(r, n)) {
      if (e.indexOf(n) >= 0) continue;
      i[n] = r[n];
    }
  return i;
}
function ag() {
  return ag = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n]);
    }
    return r;
  }, ag.apply(this, arguments);
}
function lA(r, e) {
  var i = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function og(r) {
  for (var e = 1; e < arguments.length; e++) {
    var i = arguments[e] != null ? arguments[e] : {};
    e % 2 ? lA(Object(i), !0).forEach(function(n) {
      Ooe(r, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(i)) : lA(Object(i)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return r;
}
function Ooe(r, e, i) {
  return e = Doe(e), e in r ? Object.defineProperty(r, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = i, r;
}
function Doe(r) {
  var e = Loe(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Loe(r, e) {
  if (typeof r != "object" || !r) return r;
  var i = r[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function MO(r) {
  return r && r.map((e, i) => /* @__PURE__ */ si.createElement(e.tag, og({
    key: i
  }, e.attr), MO(e.child)));
}
function koe(r) {
  return (e) => /* @__PURE__ */ si.createElement(Uoe, ag({
    attr: og({}, r.attr)
  }, e), MO(r.child));
}
function Uoe(r) {
  var e = (i) => {
    var {
      attr: n,
      size: s,
      title: a
    } = r, o = Poe(r, Noe), l = s || i.size || "1em", u;
    return i.className && (u = i.className), r.className && (u = (u ? u + " " : "") + r.className), /* @__PURE__ */ si.createElement("svg", ag({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, i.attr, n, o, {
      className: u,
      style: og(og({
        color: r.color || i.color
      }, i.style), r.style),
      height: l,
      width: l,
      xmlns: "http://www.w3.org/2000/svg"
    }), a && /* @__PURE__ */ si.createElement("title", null, a), r.children);
  };
  return oA !== void 0 ? /* @__PURE__ */ si.createElement(oA.Consumer, null, (i) => e(i)) : e(EO);
}
function Foe(r) {
  return koe({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z" }, child: [] }] })(r);
}
const Boe = "data:image/svg+xml,%3csvg%20width='300'%20height='50'%20viewBox='0%200%20500%2084'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20width='500'%20height='84'%20fill='url(%23pattern0_10_2)'/%3e%3cdefs%3e%3cpattern%20id='pattern0_10_2'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_10_2'%20transform='scale(0.002%200.0119048)'/%3e%3c/pattern%3e%3cimage%20id='image0_10_2'%20width='500'%20height='84'%20preserveAspectRatio='none'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAABUCAYAAAB0vcXQAAAAAXNSR0IArs4c6QAAIABJREFUeF7tXQeYJFW5vfdWro4zw2wgioCoJEUMwDOsGEAFFR/6RFEREAH1IUpQQaIEFcWEiiAGVIKib0URFFBEfQbQJ+CCgODCssvuhE5VXfm+PjVVQ01vz0x3T/eE3arvQ2S6wr3/Def+6fyULPC1YcOGjKZpewiC8JwgCPZkjD07CIIVlNICISRPCMG/JUJImVJa4ZzXov//YBAED3iet0bTtPtVVX2MUore8AXuUvr5VAKpBFIJpBJYaAkADjpGg64eWuieTn4/RMD5vsrl8m6CILyRc/56wsl/EEoEQkhXbclms8S2beL7/oZ6vf6rTCbzy2q1euuyZcs2RO/seEh7Io+lPS96IoIt9SWLeWgXc9u21PmwNPqVzoylMU5za2VXINrNJyuVyrMppScSQt5KCFk+zTtcQsjDhJDHCSElQgg08rLImOdzDk09RwjJEkKWEUKeTQgZEASBQDN3HIcwxggAvlarBZIk/da27Svuv//+H++///4WpXRhgL0bYaXPpBJIJZBKIJVAKoEOJdBXQOecy4Zh/GcQBO8jhLxcEAROOKEBD2LT+AOc819QSv9IKV2TyWTWUEoB6m1d1Wp1med5z1UUZR/XdV8tCMIrGGMZ3/eJ53kEYC8IwngQBN+2bfvr22yzDb5HU3BvS7zpTakEUgmkEghNp6k2tDQmQl8AnXPODMN4G2PsfELILgBYzAhBFIDkd/i+f4PnebcMDAw81ksxcc4Vy7IO9DzvMELIkZIkDQdBwD3PA4jjoHC14zjnDw0NPbFVA3u6Qns57dJ3TfFttTe52rsrFW1/JJBKvz9yXfi39hzQa7XaqznnFxPC9+WchOZwTdVGOeFXm6Z5RaFQeKhVtzdt2pTLZDLPIYQ8k3P+TELIDoQQJTKzi5xzh1I6TiktE0I2BEHwD8YYAuIeb6VxP/TQQ8qKFSveFATBcYyxgxhjOGTSIAjqlmV9yXXdc1euXFlPtfWFn4RpCxa/BBYvBCzels06qku46bP2Lb1hQSTQM0Avl8uDjLEvEkLeEVloKOd8I6X0vGw2eyUhBIA8abnZuHFjVtO0QxhjLyOEHEgI2ZsQwjoNjvN9v+L7/p2MsdsEQbgtm83e26x912q1vSilnyKEHCpJEszx9+i6/oI77rhDXLVqlTdXyafrcq4STJ9PJZBKIJVAKoG5SqAngF6r1V7LOb8qCILt0CDGWKWhWV+azWY/Rwg3KA21YwKfer1eP6yRavY2SunrCCE6Atmmv0KletqfgyD0xYe+crwn8p0/LEkSDhDf13X98SS4V6vVV8iyfKrrul/MZrO3wDVAKZ14SXqlEkglsMQkkB6ll9iApc3tswTmBOgAaNu2P+e67kmKohDDMACs/2NZ1vHLli2Ddh4C+djYWIEx9n7G2AcppTHo96RrUe755Ls47PwTl885/7nv+58qFAp/BLAzSjlv2gOq1eqwIAhfC4IAloT/26p96z0ZkS3kJYsSKxa4UQvw+QX45BYygdNubI0S6BrQOecF0zSv9X3/YKSMqapq+L5/WqFQuDwGRZDGKIpyKmX0I5TQDCLTAMAza+WdDcNmgB7AcT/lHdDAb23cd46u6yGwxwcNBNHZtn1BEAQfJYSMEkJO0nX9ulRz72wM0rtTCcwsgRSW0xmSSmA+JNAVoI+Pjz+DMXaTJEl7oJGyJP/JcZ0jdF1fi/8GaG7cuPFwxtjndF3fMdmRGTTqrvrb7vtgWuecX+O67smFQqEEUOecC7Ztn8A5/1Kk2duO45xXLBYvxG+UUr+rRs36ULrBzSqi9IYF5UXa8sW/BNbgEmjilj9PllYP2wP0xMSqVqugab0d5C6+73NBEG7UNO2dlFIbWL5hw4Zl+Xz+SsbYoa7rclEUN/tGwiwO8J9RYhGoIvCtEGnOUzT8DgA9/A6ldF2DrObDuq7fEGvrlmW9LgiC6wkhGdd1EST3tUKh8MFegXq6LpfWokhbm0oglUAqgaUogfYAPepZvV7fyfO83wmCAD84kPhyTdM+FAeWIWXN87zvSpIEJrfQvN58wdwOf3u1WiW5XA6sbrgFh4E/U0p/Rwj5P9/3/8UYezSXy21MPj86OpoXBGFIFMXdGWNIcXs+53wVIWT7yIwOtXvGcdA0jZTLZV/TtKtWr1594hFHHAEbfLBx48bnZbPZnzRy1XdCRH6Dhe4Luq6f1itQX4qTI21zswTSo1k6J1IJpBJYvBJoG9BHRka203X9TkrpMwOwtXB+Rjab/UxsYq9Wqx9paLifCdngpglNjwEeLG6O4xiiKK5uAPN1uVzuFkqp1Y2YoGU7jrN7EARv5py/mxCye5w2F78vBnlExeP/4x+krzmO8wdZlo/QNO1JHAg2bNiwcz6f/xVy4aM0u0s1Tft4CurdjEz6TCqBVAKpBFIJzKcE2gJ05Jjruv5by7KeyzkPBEH4VCaT+WQE5uKGDRs+VywWEcHOgyCY7Z3ws3++Xq9/c2hoqNpLVkGAe71eP4Axdirn/I0T7vwwrn3StA8gB7BblkWgrQtUeNxyrNcjfx33VSqV3ZHPTgjZjlJaJ4Scoev6F1NQn2ZapkrrfK7X9FupBFIJpBKYVgKzgS+AkNm2/UPHcd4MwBYE4Yu6rp8cgaRcq9WuURTlCPjLZyGFGSGEfELX9asIIUG/Gdocx3keUtE454fiEIJ+oM2u64bsdbIsh8Cuqiqqta13HOcNxWLxHtyDOAEQ1QRBsFwQhDHP896Yz+fv6k30e6cIGN3f6WPppE8lMC8SSCfmvIg5ZVSfHzEv8a/MCOjQbqvV6oc555dCyaWM3pjP5f8TfQbL2gEHHHBlEAQwc4eacNJ/DV85gNO2bT+fz39t7dq1Z+24445hdPl8yQxtMk3zjZTSLxNCto0APfTtx4CONkeuAJRbfaOu63/CfeVy+SXw6cuyjAPNg47jvHCbbbYxQjnMYx/mS1bpd7ZGCfQKjHv1nq1xDNI+b7kSmP91MSOgR6D2W865SAh5NAiCfQcGBkrQVGu12qWe552squqkZh4DOv4d5Zo/6TjOewuFAljZFqzKWalUGpAk6TJK6btgHYgoZjebR5zzfzuO8woUjYGJ3TTNoxtEON/ww+oy5Ke5XA5+epFSOme62C13Eqc9SyWQSiCVwGYSCNENezFjDKWv4drcidKQnwRlsaEQViilcMM+Rjh/SNW0+yilYdR0erUngWkBnXOeaZQ+vS8IgmegoIkkSQdmMpm/ApgrlcpJmqZ9SZIkblnWlHfAhA2zdr1e/61hGIevXLlydDFotADoer2OeuyXRaLZjHMWB5Eg8P9qGOZLV6xYYYBvXlXVy2VZPooQUmtYG84qFAqXzbc/vdNzHudcN03zlYj+B2Ne5AoJXxMVtMEhbU60t/fdd5+84447vkiW5X0453bDvcFAwYsrNNdQqvi+/0Qmk/lJ94e5mXsev9c0zR0YY6+PDl7hQ4IgiEEQoJDPbyMK4Fn7G7+vUqlgwwE1MZ4X4n61t6R6ehcOy4wxhnKBd6mq+uBs43bOOeewc845JxgdHd1eUZSXc87zeD6ymIXvqtfrvykUCg/P9q5OehLLrlarreCcv5wxNgQPVyKZXhIE4Zeqqj7U5XfDcUX/zjjjjNfatr1rIzDXUlUVQAAXXoYx9ntZlv88e7spmXgk5KLI1uv1VzPGtvN9H9k2s7ohZ39/d3f4vo9GyaIoPqiq6u/aDRSO5Wnb9uGc822xHqPOId5JHR0d/eOKFSvu6R+vRuv+xnOxVqs9jzH2XyhxTSndBwuqVQZU01swNmD7vJtzfhvn/Lv5fP6B7iTb/VOJef0aSukzpnsTCodpmnZjv2UMZlPG2JswT5P7EmLCKKU/bDl50YlarXYeIeTMaHP+YC6X+wo6MzIy8iJFUe4KgkDM5XIUL8KFAUL0OnLTGWM/yuVy72wuyNK9WHv3pGVZr25YGlaDD6dZU58A9AB9+Vk2m30DvooNShTFO0VB3K1m1NbWarV9t9tuu/HFaHpPbqqMse8TQpDSB0CfQNqJcbpC07TjQdtLKUV6XkdX/A0ARaVSuViWZRDzuJxzKcEAGFptMMkrlcopy5Yt+9Zf/vIXab/99tus1n2nh5VkY+ODlWVZB3POb/Y8zxcEgWEOSpLEgiBYyxh7n6qqsBDNalmJi/VUKpVjRFG8EhtjVPEvdst0JKse3Bxbv1AV8ERN074FOUelgFu+Pu5nuVx+ra7rV3qeh0NdXK+Acc7rmqYdSyn9/nRj0k27E7I7kFJ6FWMM2SaYezg4A6iEIAiOymaz17QzFhO4+rR3Lp53aPNuu+22WlXVgz3P83Bwi9JM5Qbz40Wapn3i6TPl9O69GATr9fozOOc3CIKwH+ZPEARCksmyDeDpRlyTzzS5KXFwE13Xva7BXIk9d1M7h+F4LVuWdTeldN84Zgjr0nVdKZvNXvjkk09esMMOO9Tbed+cOjQhfHbDDTeIr3zlK4+UZRnxVnvLskxh6OxEnvF+HGctNep//Mn3/cvy+fwPZ1oDc21/qz2mWq3eyBhDHFkr7pTY6ntoJpO5aWKj7WW499MtMgzjhZyQ/6UTB/1QnpATlGjP8/ZpCejlcnk3Qsh9jYkgG4bxx3w+/xK8EuYSURTv4ZyDKW4SyOPPAfwJId/KZDLvnY+JM+1paRZZ1uv1l4LnHcVhpgF1qwF2H89ms5/H0NRqtYMymcwvy+WyA6DM5/NHt7cp9XJqzf6uhQD0fD5/Qr1edz3Pk0RRTC7YcJIHQfBX0zTfMDw8/GSXmtm0HY8BfXR09OBMJnOz67q+KIoMAZqqquLfay3Let/Q0FBHgF6v148RBAFgOAnos0u/L3fMCdBxKGn0Y3ts8FHrmOd59SAIji0UCn0F9Gw2u3u9XofRBBtPoOu6UKlUjioUCm0C+lR5JgF9r732Wi3L8sGWZXlQLHAw1TRNrlarF+Xz+Y4B3XXdGxob8X6I9/F9fzNA79PeHHYwCeiiKIaAXq/XrzNN84MrV67sCNBN07y7kQocAjrk7vu+m81mpWq1emG5XO47oCcOSdj/z0EJ7BiUY/DpdJUkQD0Ul67riIt6pGFN+ditt95641vf+tY+sXlOtDTeYwDogiC8eYb2Y61uaGjpe1NKEQDelwuATgDolIYAHAM6Dkuu624O6BgU0zRvcl33kIaGDl/x/sVi8S9YUIZhXNXwMx8dmW6nHAaik9f/aJoWdnoxmNlnkqhpmijZ+uvoLDWpwSYmEEhtXpHL5dagVjui83VdPyIIgk2lUumNQ0NDf+gYoPq5M0SUu5A7rArTaegNk9wVmUymJxp6uVy+uFAonGCaZgjoSAlsxdzXcNt8K5vN4hA0o3bZ6QpIAno2m70ZG3IUxMgzeobZjt01oEuidKXjOimgtzkosYY+NjZ2oCRJV80HoNfrdS86WHcN6KCxFgThhmw2u59lWf6E0j+5HXSkUbYpqim3NQO6wATRsq3rqtVqx4BuGMbdqqzs6wV+4HleCOi5XK7vgB7vgxs2bNgTAdBROezJAwusnq0UwHbk1QToRNd1YppmkM1m2fj4+K0o+lUsFh9t513d3BPvMZVK5UZRFGcDdPhwrlqzZs0JrayRU77fJRZ0DOgjIyMHybL8K1mWkVP+ZV3XP4SG1Ov1lwVB8Jtm0pbEBv47TdPgt3UXO5jHgjVNExH7NyTN0skFFgTBXblc7qW4v1qtPldTtb+7novVfqemaS/vpcmym8nW/Eyzhk4pXQU/VNLk3ktAh8kdGjoAHaY9ZA40AXqoYQqCMMI5P1lRlO/10rKRBPRcLnczNmRFUZhlWRwL3rKsmQG9aVHFoNSJhh6fkKcxxU07rLGcZmE2XHIa+qICdEZ5wmrfDKRhTEUM6Llcbj9YFJoBvbmQVKvxwj2Rq64llXUrM3Pze/DfgiAg1kF0HGcaQG+NArHJvVqt3q3r+r6e54WA7nmem8/n+wro8RrctGnTkaqqfqmR1jyYFHRzPzsxuTdbMPDfiqyQag1xc4TDtaYoSo1zflQ+n4cbtedXM6DPss4RswC31iGqqv6i540hBBVNO9PQy+XyzfBP+b5fdhxn52KxOI4JY5omcrTDYizJK+rgJvhudF1/oh+d6Nc7oTFalgUSmk9NgDoVnrZOhl81HMc5aWBg4Nucc81xnNNQtc3zvBHHcd5WLBZv71hL71dnWmjojLFVQRAsJKAD4AP4s13XvbtUKr1uxYoVG3slszkDetNYJAGdMXZlFCSlzDRkmP/YzKHVxUyE7WxaKaB3linSyuTeCw0dPvTY5I4DIUzuSQ29HUDH/YgfSgI7TKDxe2YD9Bj0ouDH0Ideq9U61tA7A/QuVcTEYogP57Va7dOiKJ6M/bTVQaUZL6JgyTWEkH8QQtYhsj0IAsT0aBGh13M8z3suBgJyTI4BfMUIvMZag8yjIDSBc35cLpf7ZkxD3qtttkNADy3TjuMAB59XKBTGetWO+D0dAXqtVtuLMfZ3xhg0g0sbJVEBdmBfOwkVyaZpHMxeh2az2b6cSHotkBZabb5er/+UEPKyViltvu8/cPPNN+8JXw247CmliDTGxF2t6zrS2HpqRp5Lf5sijb8vy/JmgB4EQc9M7m1o6OFJmjEWchRwzq/UNO24bmXWvAX1GtDj9zXiRg4RBOEizvmTQRBI041JvNFgY1EUBUE/iPZHENreyX0vChAE6+CaRnAbXDl4ZxjxhY1phgvZAogIRkzHF9sJ7ksGxS2ED31Raegz8EXEh0q4pxqgcJYois/zPK+GbA2MRzy2Sd9vkkI6jiKnlO4niuKAbdsIxAQNNZixmSiKjzLGUJMCAzzpnmw2IcdjH5mlfUTr+77/C9d1vzw4OFhuJxYp1tDL5fLd2Wx2XjT0eJ4ZhoFg6eNjK+A0h9l4kv8MMVaapv0ySk/bbOonMk1Qs+OVnPNjRVE8yLbt8KDVrCFH6ydWWj6QzWa/1stI81aAPuOCnZgkmB5fVVUVdU56muLcDOhxW1r60E3TvIYQ8o4G3SlC13eDxo2a4fV6HSku2Kg2w0Pf96/O5/PHTJ14cz/9zQXY2n92op22bT/H9/2/hZOSEiE200FIQRDYkiR9Utf1T8OXLsvyhaqqfoBzDiKaV0SpRH3PsW9HoklAD4Lg+6qqropSuSadggsA6CGoR3mmALMPRTXnZ406n20cew3os31vloUc9qdaraJs8I8ScZlh6hmlFBv88aqq/rKXbocWB9SwHYhyTwG9PyRWEZ00DlqeaZq3y5K8yqybcPcInuc5uq7LlmVd8Mgjj5y/5557Ou2A8hznXpixUiqV7s7lcn0H9Hj+joyMnK9p2qlxJgj60AToMZD/oHGw+aSqqv/qpJ+x3EZHR587MDBwvmEYb2SMPR3gMPVAHIP6W3O5HNyoPbm6APTwnB6t+YM0TUNl0p5dk4DOKEu6k1oCumEYb2qkGv13o8jJo3Gkummax4BcZZoWbWyYh56Tz+fH5+43bweyeiaXKS/CBK3X6x9tTMyLmtO8wPduGMZD2Wz2WXhobGxsb0VR/k8URQsap6qqKLM6Z3DqRc+aAV3X9FWu504xufcS0Gu12sXZbLalDz3BwBfB+cQkD4LgT4899tghe+yxx9hspvfZZsRSAXSEeWNNpYDe2yj3uZjc57LemgEdB+darearqhoCOiLuOwH02eb5bG2NNfTx8fG7G77kvgJ6vObK5TJKZn+ZUlqILLqhFSIC9DiN65+NctXHNWKr7pytD7MclsN4B6Sn+r7/1YaWP10+eBjxTik9UNf1P7b7zZnk3yWgx/mW/7Zt+/kgY2u3LbPd15GGHr8s7kRExoJk/l1bfAj86CdmMpmv9/sEOlsne/F7tVpdJgjCXyIylnBe4H8cx4E51ajVascODw9fi9Q9ALksy4cLgvCIqqoguEgBfSIoboIOkPN/c87/jzF2WOKAFGrpCJyrVqtfKxaLJ4CcBhpMt+O3KAA92g3iOZDU0CfCF2iYE+/7/qOc8+Oz2WyqoXexXnrtQ+92zuG5dgDdNM0LHn300XnV0PsN6EnSIkmSfpPL5Z5pmuaUGh6xT9v3/Rsx3/P5fE9SuCKZY+8YFEXxes45ArCbr7A4mCAID3ie99K5fzskIIIlxo+j3BMWiNjq+GtUIEWKHhZ7HByZCB7/gqZpH+mVG6ArQI+lVK1WXyEIwh0RiUpzzvq/VVXdZT4Krcxl8bX7LCbr6aef/i7O+dVRup6Y9Jl5nvebgYGBVyCyfeedd37z4ODgda7rbqpWq+8cGhq6dTZts912zOW+djR0PwiuyPYoba2Fhh5omsYQk+D7/scFQbg38iHBTIb5EyA/3LKsDZZlIdgQi77rw9CiAPRowFoBekSkgUhcBAWmgN7jPPRuNPS5asPNgN7I/rk91tA1VRNcz3VUVZUrlcoFjz/++BYF6HHsi2EYq4MgOLQ5YBCHd/ANVKvVq2zb/vDw8HC118oe1jzGoFwug4sAbI5TLrgYZVlGMN1n1q1bd9Zuu+2G1NOOr3iezKChx5U8f8YYu5wQ8kPf9xHUl7xAqISYjP/Qdf134Q9znICtAD2Oy2iZhx63BgNhmuY3KKXHhO2gU/AcDf1vVVW/3OsB61jyPXwgotX7Kwq5RBGrYaejwIuNkiT9B6grx8bGdmwUpXlUEAQwn10xMDDwobkA0/Rd6Gz02wH0zk3urRm7wBTXAtB9TdMEwzRvzWYyrzVN8zMNLma4MqCFg5kvFCdA3ff9Pzz66KMH77rrrtVzzz2Xgq6006FsBnTbsny5k7S1Tj84w/3x+I+Pjx8uy3LoQ4+icLmu6cyyLeTKphp6D4llugH0Xgx5UkOfAuiKJniB5yiKssUBerzWTNMEvSxcsEhPS2rnoWvP9/0fB0FwTJQd1ZfYIrQFe8Zpp52GNOoDmscUwfFIP6xWq3utWLHivrmM+WyAzjn/RaOg1+vq9fqXfd9/f0TVPAmjEW7+U9O0/XrBSz8zoE/DFIfWRHzg6yml+WZAB6WnoiioXgbO4HmrnjaXgZl4dmaAhAl4l112Oc0PgvMFxkIayERUJWgTP5nNZj+L+vCEkG/m8/k3mqa5JpPJoE78gke79wfQp0o9Sf3aDOiiJPkZXQdn/h26rr8SZWglSfpOwPm+NKKgrdfrXNO0kIfY87yv6Lr+gVlN79MMWysNHcQyjuOEeeiGYax1HKdtprju51domtssKA4aOo7xuVwOZE1LEtDbPVIuNWKZ7sd6qsl9Og29XKlc8MQWpKEntHNUo0Qu9BRNFEDGOX/IcZxXDQ4Oru2noheb30dGRlZkMhn4ymHuDpXOaL8OMw0459fCVYq6HN2O90yAjk+6rvvz0dHRt3iex1esWHE/YwxW68krwkcso4s1TTuzG9N7cg1OZ3KHlm7b9gRTXLVaBWe7Aw7zXC53P/5mGMbr8N8JHt3JUwch5GpN05oi27sV2eJ6zrKsXV3XfUiSJM/3fWzSk2QRKJCh6zpoYxXXdY8SBOEbrus+ZVkWaqmDTW/WAiD97O1CA7okSaHJDZucrusHoa+QDeccaYFIbwxN70jlgaxc133Stu33DQ8P/6wbC8fiAfRwk587oLeLnm1YCtIo9/5Vd5xWQ99CTe4J7fwIzvnXCSEDMS7g0CpJEiyVkm3brykWi7/s5x4Xv/v6668XolRiMFCiPDZovAnop23bRtqhp+u6uH79+uduu+22yHnv6moH0HO53OGUUrtWq72qkcYILvdJ7oqmIMGXtBWsN8M+0Bagl8vl9YSQFZIkfVfXdfiR6fj4+CW6riMPfYogOAh6PP+gXC4Hc8cWd3HOC9VqdbWiKC9DTimYfxKHmg3j4+N7bbvttiOVSmV3RVEesG27ZNv2GcPDwwgODAMoFkoorQDdcZ2+EcvEGnqtVnMFQZDgv8pms+Dsvq1QKLwKIPfYY4+JQ0NDZ+dyuTMqlQoOjTK0c1EUA4EJMEX/Znx8/JDtt98+rPLTicWnHUAPguB9Ufnern317Yxn66C4AO4ans/nQw09DYrrbZQ7uNw9zxMFQeiY+rWdMZ3unukAHSlVMa/8YvGhg/q1VqvNics9jqI3TRNVz6YEo6GgDdL1KKXfrtVqHxoaGqr0UztPjkm85iqVyl2NSn4HxnnqcHXBnw8OB8/zPpfL5T7WTSEqvCTeY0ql0o2SJIXFWaIrdDd4nvdzlNWO31+pVL4my/Jx8J0joLqJRvh+VVVfRCk1u51/MaAna5DEhEahhl4qlXaRZflhfMBxnBOLxeJXoT1VKpU/KoqyXzOge543msvltmlv0HqgcnTb8y6fwySpVCof1DTtc7Ztx9Wcwrdxzsu+778zn8/fZBgGXA5/C4JgIAiCbxQKhRPxLKPUmzgCzX/fJ8aE8VqtugJ56EhbmxHQGXWmo8acaTOLyk5O+tCTgA4N3XXd21RVfdWTTz6pb7vttmalUnmWIAjX6rr+fNM0w4WGVJcoIh7z7rP5fP7UWU3vTY1KAX3zUZqWWGbC29n34iybEct4PmNC/4qzpIAe7kthHnqrKPe5AnpsdYzWMHKqt4sVnCi2yBVFUWpUsNwX5bW73Ha7eixuW7lcfp0kSdcxxrIRgVW4XUf/bNQ07TmU0VKne12ngI72rF+/Xi0UCn8XRTE0vcOCkTwANIrmnJfNZs+dYLTrHCOSgB4HMDQD+ltkWf5hBOgvKBaLqKaWN02zFEUxTomGa5wCflwsFhEY0ZeAh65GtscPjY+PPz+Tydxj23Y4WROvBw3UZzKZzJmVSmXI87zv5XP517qeCx77/+gUkHrc7DCdJi7O0hagz7F8arOGjtN6LpeDyf02XdehoatxnAUWnaqqcOGEpnekl8D0HuVow+fWdpnTyRUSWURQbS3mckeKGPxZ8KHXarW1862hR0FDk8QyqPxWKBRSDb1P1dYWG6BDLwKxzJaiocdZq3WfAAAgAElEQVQHxFKpdFqj+BIqqGmxXxjWSKxlz/MQ9f6efgbCTbdXxvU0fNe/16ibe4rilMI6UNVF3/dflc1mb+tmv51NQ4cPPZ/Phxp6vP9Wq9VXMsZ+LoqikgD08HwA/nnf918MF2037Wmloce005Zl7QNa1zMdxzkf0cf5fD4Hc4BpmjAL/DEqh5oEdG7b9n8PDAx8qW1A7/wQ0k0/e/JMYkCWaar2QN2qF0RRRA8mSBMYJb7n35LJZA4Ga1yj3vAnBgcGT3c9d+0ll1yy89lnnw3zPDTQBQkUXMyA/uijj6rDw8PnqIp6uh/4DrJL4OuC6T2TySCV7XZN0+IKfziZzCrDVhp6CugTvvytwYe+GE3uWyCgxyx0N0uSdHBTthPKSaPOx9sHBwev7ckm3OFL4j2gWq2eBUXLtm05YVUOrYG2bV9aKBQ+3o3ZvRNAjzT6MI6qVCp9nVJ6LPajZJcAvo7j/K1UKh2A+vQddneyOEvS5D4F0CuVyncIIQjwAjvcMwEKhmG8UxTF77TgmQZbz8sHBwfv6rQhS+n+0dHRPOhJKaUHJ/jdQwtHEAQP6rr+bJi5KpXKEblc7hrHcdY7jrMqn88/GJMvLER/FwugW5Z1m6ZpoYYOHvLYNGZZ1rMopZDr81AFDoUwoopJ4EHHYfHTxWLxjHYtHSmgd2Byn7h1/k3ufa6Hnmro/TO5x7EC5557bvChD33oHwMDA7ujkmHCn4hUU8+27T2KxeIjbSt5Pdwc429GDJ6/EUWxmDRz43dFVv53vDT+GuTFd/rp2QCdc/5z1PRIHhZi0/vAwMDfBUHYBQVlEKxnWVaY9YK6Dw1r5lnZbPbCTovJzKqhVyqVOwRBeAWlNEw1igD9U6IofiyuHpUQQuD7/rJcLjfWjgbVqfAWy/2PP/64tnLlys+g0hpjLA4qiwF93U033bQTIiwty3qVLMu/bMQebISpdXBw8HcLGem+WAE9OrmG7oBKpXKoIAiroUVGla3w95Aq0vf9xzzPQw7r7XEa1ExzIgX0RQzomezudauOQxu8KgFiKyo9JpZJNfSJ8e+XDz3ey0ql0n6SJP2PKIqIG8JJHBbL0NzeIE35VRAER+ZyuU0LAehR/8OUYcMwHmOMoYDWZNEj3/c9TdUFs24M5/P50U4xpktAD/e6Uqn0almWf0opVSRRIo47ESQXFfJBsa8XDA4O/r2TNs0K6MijJoQ8mxDyA13Xj8QgVqvVb8qy/O4WgD6WyWSGFmrgOun4lHs7NPvDb7Rx48b/Hh4e/qzjOKEfJllgxLbtA3AiXbdu3fNXrlx5j+M4I6ihPTAwsDpOp+i6rW0+2KpLSwHQYXpfuXLlOYqinO44Tmh6b0rt+KWqqjC9h0EtMx0cU0DvDNA5Dk2eVw+C4NhCofD92P/Y5pSb8bZZ89A1XahUt/wo98Vucg84p6wNd1YElGHWjmmab3Uc56uodS6KYlxNDLEwKPV6SS6XQ5BXx+bjXsy7qJ2hm6lULv1YkZU3xeVs8Zvv+66malLdqu+Ry+VQrrWjqxtAj9oUmt4bwdNX+L5/LA5BoL2O0+oa8QgA9r888cQTB3ZCfz0roBuGsYkQgqj1L2SzWdS0RTDRjyRJelMzoKN0aGRu3gIC4mZG+dHR0bcV8oVrPT/MgQgBHYDJGButVquv32abbRBj8AwU3bAsa9y27Y8ODAx8cyFT1xYzoCcnOUzvhBBEpYamdxD4JOI1YAW6MJfLnTWb6T0F9M4APTW5d7SXT3vzTGlrMaCXKpUL1i0CYpm5RLnHAXGWZaGi2jmSJOkIOPU8D/ugSylFqupxuq5f1RuLbYeaVzRCCdC9RBCEU2RZDmm7gV8TGromVqqVwwYHB8GH0dHVLaDH+93dd9+t7rrrrv+QZXknpNOhTYqiEATLwvQuMvFUJrJL25VfO4BeI4RkGtScF2YymU9EgH6bJEmvaOFD/5Ou6y9echp6R0M4cXO5XH490tOQupYEdLDkua77ZuThm6a5g+/7axljtcYJ7Nx8Pv/ZdkzF0zenuwkdv2+xA3o0ycPD4NjY2KGZTGY1fHAA9JjrPTLz/ct13ffk8/nfznRA6j2gdy//ePNLo9zHDpQk6apsNrt7vZ6a3OezfGqv09ZidjjTNC/mnJ8C8hhkPgGYkPuPgDjP8w7OZrO3dLHFTvtIp6sw3gfK5fJJoih+VhRFFdgVFUoJq+CBMS6Xy13dqc96joAe7nXIwpEkCdzzSO9L9pvDSskY2wfxV+3IcFZAr1arYPmBBnoOTCeRyf1/ZVl+YQtAj9ORtgANfWbxlUqlgwqFwq+QuoaJDA0dqVacc5TCOzKTydxsmub2vu8/EqViXZDP5y/qhvGsnYFs556lBOiIDWlUajq7kdb2McZYyPWOU7VpmsHQ0BCsRLdeeumlh5x9Nm5pbXrvJaB3uok0j0cK6HeIq1at8jbLQ0996PNWD71fgG4YxhcJISdFNb6hXcJ0bGuapjTW6QH5fP4P7exP/bonkY/+TlmWEV2ux9gFl0EE6B/KZrOXd0r8NRdAb7JKXmnb9nslSZqSNYYsKtd1f7dmzZpV++23H7BmxmtWQK9UKsdFdJx/ymazf4s09DslSTqwBaDfqev6y7cGDX18fPzlxWLx10lAR7+DIAC5zLsadYdXxxo6IaTWOPmB5/3zc9PQZxvOmX9fCoDeNMl355zfEATBXgg+hKaOaHdMelhGcrncBYIgnDud6X1isTF/dHSkZR56tVZby+eZKS7V0FMNHXnoi4XLfS4m93jdwQ9MCAFOhFzpAHRJkkJAL5VK+w4MDPx1ITEhBnTTNN8CxjpYnIFdsCYAwMFkZxjGGZlMBqbtkEau3WuugB5bJR988MHstttue68oijslvw0XBkDd9/3/zmazX2plem/F5T5t2loLTSPUjiRJOqgFoP9Z1/UXLeTgtTsQc72vUqm8IZfL/bTZ5B4EwXgQBG/J5XJ3mKa5o+/7/4aF3vf9j0UsewtG/7pUAD1pejcMAzXTEUEbRr1H/smwIlsjffLhRsGHdxQKhT+1Mr33UkOf63xJNfQeaugtzCXx3EYg35577bVakeWD0yj3iVnbxyj3OHocXOknxCACk3sM6JVK5SWFQgEFUhbsigG9Xq+/g3OOw0fI6w6LX6yhV6vVk/P5/JfnW0NP7nVPPfXUa3K5HLjeJ8nKIl8/r9frKLs7q+l9Vg29eRSQR33qqaf+BPVu8VuSi5YQ8kAjP/s5WwGg03K5fGQ+n7+mGdBd1x21bfvg4eHhv4yPj+9ULBYfq9Vq457npUFxEVNccx56q5UezyHOuVatVs/XNf0jjuvAPBmWWVVVNfA8j9m2vRpV7aIUGZTtnSScSfjODs7omZuRJgUiB2j5uq6nTHGieKUgCNs3qgTGjrulmYdO4e+aYEEEoO+1117wRy4AoE+cNNoJitsSmOISPvRPN1yNJwdBEAIRQEiSpNCH7rpu1yxsvToBxPuAYRjHU0o/TynVYgrYIAh81KmvGbXjCoXCN+fTh57sX7zfGYaBAMKjGUMQ/EThr8jXj9vvUFX1NTNZEToGdHy4XC5fpSjK0fHgJRpm6LoOvtwt2ocOs/n+++9/kqIolzUDuiAIm+r1+oGFQuEhy7LCAi2NogRjrut+YHBw8AdbXZR7JnNCzTCmFGdpB9CjuRWmdlSr1eeKongd53zPOL8VmzcmPefcbvC+n60oyiXNpvctD9Dn6sl/uupbkiku4DwI38w5Djt9TVurVCoHUko3C4rTNA31qY8q9LAeeqqh91dDj9Maa7Uaipuc5fs+gDJcl6iwhih3UL5qmgYz94JdCUA/v5E+dzraFbPFxVHu1Vr1LQMDAzd22shemNzjbwI3YXpfsWLFvbqu7xQxZU7+HBGXnaDrOuIAWjJldgXotVrtzAYbxHlg3EHeXOJCStHKbDa7qd0w+04FuBjuh9ZYqVQ+qygKCq6E9IFxHnq9Xn8SBW123nlna3R09DWDg4O31Gq1jZ7nvXVgYOA3cyOWmduGvhAm90wmc4LRJaAnzVEjIyOH5/P5HzHKPNux4bagoIUVRRFVi9ZUKpV3LFu2DL66SZfGlgfoc5/9yeIsjLErZVkONfTIfbYggC4IAlwobQD69PM/aXJfOA19EkDRUMxDL1kPHdXWFnseeifKWBwPVKvV3hEEwZcFQSiiemAjroUKghBn/5wry/JFKB8699nb3RviOV+r1b7PGPuvuOgT3pYA9OcPDAz8rdMvzAbolNKfq6o6hSluum/Esi+Xy4dQSuFmhEtjsjx3hDEmpXRPTdMea/UeAHoQBP8Ltqb49ynUr7VaDb5yfCCXy+WOj5jiQDBzDZLfm/zoMIO+AulEnQpmKd0/NjZWyGazNzDKXu16Lsy8k8LjnD+A6j2gNa3VakcjctI0zXX1ev3FQ0NDT6KfC3XYgSI2UW2t1l61tR4UZ9F1/QTTNEMNHYcfaGK2bU+hfp1p7ONJjspsy5cvP58xdoplWa7neWGKDMBAURSQHd2Yz+ffkjS9p4C+uWRnAnQcNoMg6LuGLoriVZqmTaatRWOI1KEJDT3gImUdByctApP71gXoMUkWrC6SJN2gKMpKwzBiQA8ZNBljq+v1+nvBwtbJYaGXeJBwDSD1C/TSkyCJ+rq6pot1qw6GU3CudHT1EtCTCsy6deu+OTg4+J7IfTOlTZzzW3Vdf10rf/+sgF6pVD4my/KF9Xqdj4yMFHfbbbfK6OjoSzRN+wOS35vD7B3HOb1YLH5moQZvsudzU2ZbDmrcp2q1Oqyp2n1+4G+DVLW4OEs0IDfpun4oKtI1ZHa27/unMMYey2QyO8cTq60ZM5f2T/NsJxp6wLnM5gjotm1fLAriCXWr3jWgRzINTe+2bT8XXO9BEOzpum4Y9Q5mKpj4CCF1zvmZuq5/Lja9twJ0aPQLXW2NEDKl2hrqodfr9UcZY8erqvrLfqY2JgGdUnqlqqrbQz3HPAZblWEYnq7rx+bz+W93NF+bJnXzFEzUg18lSdKViqI807Ks8LsYW1mSBcu2jspms9d00//pNHTXdcN66GFkebl8UbFY/ERMAtWvg/VmPnRFXVUzauC4ndTQt4Qo96if9KmnntIYY38dHh7eDTiBAYVsAZyU0hHDMF40MDDw2EJgQgyI9Xp9B0opyrcORntKyASG+aer+t9LldJLUau9rb05cVO8x1QqlRtFUZxSDz3q7+Ya+ix7e2x632677e4jhOyYULbDpkd4c0zDLI+8+Smm9xjQ4wDFSOkJFe+w2trY2NjrFEX5Gf5gmuaBy5cv/z3nXK9UKuMSVPSo0ljcR9/3f4KC7gsxeJ0ORrf3G4YB7uI/gzYwGZFICHE555fpun5auVwelCTpakVRDjNN8w+5XO6A2ZjNum1Pu891AuhxZGy7747vSwSz5QHojLETkNoHDR0WLqSIOI7Ttobe/F6kfTHGftQAbxyuoQGEZVajCXw/TGqKotwXaephFGu5XJ4MiltUgE4JcR2XLwSg12q1VwVBAEDfKQZ0RCdnMhlqWdaJmUzmq3MB9OZ5E4M0uPobmtzXBSasdFwniOdLNC5H6rqOOJOQqrOtuRdtjosa0FV1Va2WAHRNlyvVygWPd8QU1/0Jv19R7hifhx56SNltt91szvntKEAVB5tFYO4ITJAN0zikUCj8oq3x7OVNE8GSoQvO9/2TbNv+LKVUTVRbC8szW5Z1eaFQOKUbt0BXgD5LHxOm99cSQn4mJmu+RkYgQojR2Af3aja9zwroIyMj2ymK8kRUJP3EXC6HhQ4T512SJO0fCicx13zfH8lmsytQhaxfJ+Bejnmn78JmU6/XTxZF8TPwv0SbT/gaznm5QfX67kwm8z+GYayklP5JUZRtDdO4Jp/Lv7uX3Nidtjtpztnc5I4YgImDHtI6MpkMXCthWcTZvzN1o+k3oOMwaRjGBaIofrhRnjZ5oApPro3KTjcUi8W3YlzQ9qhU6OIEdJwA3XkH9HCDq1QqL+WcX5nRM8/yA9/H4QjzGeZHyujHBEG4uJcH0PhwALO6JEmXB0GA4NmQ0Rc+V/AMeJ73Nl3XcVhrH9CjCbqkAH3e6qFPRt2Ha7nXxDLRfhGmrm3cuPF8SZJO0zQNWSjhWmSMxfXGr6xWqx9etmxZbb4VvXjPrVQqqLT2stjcjnmH9iEUp16vHz4wMPDj2fe6KVAX75fxempfQ2/jQ7GcKpXKtymlR8WKc1Jb55zflMlkDkvibLlcfmGjCuj/xm7gzTR0fBt87r7vb0MI+XY+nw/t+q7rfsbzvI80t822bZiWXl8oFLqj++v+INqGmOZ+C+e8UK/X/0dgwssDHkDDgDk4Lkiw3jTN5wwODpYNw3g+pfQe3/dLnPPT8/n8FQsZ4T4zoBOYArsE9KkybQZ0SukJjuOEGjqARBIlwfXcjjX0qP2TUe/gepckaU/45eGrwyYCDukgCIxGyszHdV3/YlyeddFq6AsI6JifnucB0PeNAT0IAheBOJzzr+i6/gHM7dkK4LS7ouIDYr1eP7MRRHo+rAJRVS4uyzLjnCO188hsNvuLbsiXthRAb739zW1T7KeGHgf5btq0ab9MJvNTxhiUuRjQQ6u27/uB67rPLRQK4I3oLgOqCxHEpao3bdq0r6Iot6uqWoAVKtpL0EZY9mxd13eklHZcaS16T18APd6vCSGFWq12LyFke/wtAeihuwCV7AqFwg/iddgWoJdKJQQ8/CfnfKOu68vx8FNPPfVqTdNuFQQhtumH70SUIyHkqlwud1zXg9fuLrEA99m2/Rzf9/+B012sBcbNoJT+TlXV/0AUfBAE76OUXua67nrUiEca20LLYyFM7r0E9OShZHx8/HBoc0EQYIWGXO+R6ZiJongvY+ytSBnEM7Va7WBRFG+Oa3V25UPvYkNJTs8kscwC+9DDQxFoiV3XBaC/1g+gHHsiNHRFUUTTNG8qFovHUEo3zi0rY/KQmIz6/gal9FhYV5C3jDFBhLtt22sEQXhPI9inJUnQbEt9SwH02frZze/9BHS0JxGz8kfLsl6U8POGFrIgCGAtu1jTNFRds7rpQzfPJNw8P5Jl+fCwbKrvT5RpjCOEOf8WAne7bVc/TO4J5WqypLQkST9GzFDMcBdjre/7Y6g3v3z58qfwtxjQYx86ItynRLnjpvHx8aNVVUWlMOI4zguKxeI9mCRI0eKcDzULm1JaMgxjx2222QaUpy3z5boZoIV+BhN3l112Oa0xiMhnjDXDuFmYqOc16A4vgv9cFMVv6rr+xtHR0Xu32WabvbvxR84RQzYT15YE6DC927Z9QWMOTzG9J6qyXavr+tt7BuhznHyLCNAnNaRSqXRlNpM9xg/8MGsAByJBEJC6tk6SJKz5ngToxZveyMjIszOZzNWEkJcgngIHMdd1QzO/WTdvFkXx/bqur+3mELFVAXqHG0O/AT2e2yMjIydkMplPE0KyCVDHksRYwwoDLf6vSRftHJfVtI/HcwhZWqIoIgi1EGdkRQxxobmdc/5iHCK7bUc/AT2pwNTr9e8EQfBOaOVJLd11XZrP528477zz/uucc84J2gL0arW6TBTF9RBSo/73mcVi8VNYQJZlXYHayc3CQJCS4zgfKRQKly20VtrtQLV6DnJolI0Fnz3MSriSRPo4Ib1Y07R/m6a5neM4DzHGRFSW0jTthG78gt20faa1viUAejTJJ03vjLEbGGPPjQEiAejVRs4vTO9fRiCWLMur56ShdzMYiWcWC6BH8gv9nqVS6YxsJnsRNHTf98WoSpYnorKGbX8in89f2It5Gx9mK5XKsZIkgSZUiTd813WdTCYjG4ZxaT6f/2hyE+tE5FsVoHcimD5SvyY1SRzObrjhBn7ooYf+nRCC9Zi03MbKz69d1z0in8+PdIILHZ5fwmYBaO+//35h1113vYcQskccrBeB+UT+Lue3GYbx5uHhYewVXV39BvR4PTz22GOF7bff/l7HcULTe3xBYQbXO2PsCFEUf1gqlfZjjIFqN0ylbqmh44d6vf5nnLAIIX/XdX0f/K1arb6SMXZb0+CFdn7XdR/J5XK7bynBcRi4SqXyflmWsSHFpAlJ2f5S07TXQIvfYYcd3pbP57/DOR91HOe9qqqujnM2u5o1PXpoSwH05KZvmuZbGWOonR6WWY3SCMOod0rpfVbdeqkkSy8QRfFXSxLQu9nNZpkvidS1gxtpa1dyzreDdg4qXUEQfEVWBLNu/r4RDHusoihr5hL7EfsxEc9g2zZS0t6SWD/cdd2QVKZer7+rUCh8t9sDRAro0w96vzX0aD2GgYzIkGi4HC+Blt5gcMT5GmyOuCXcMymln1EU5ewGY1t98xb3ZrLHc2j9+vXXDgwMvC2Oao//jXZG7tKX6rp+11y21/kA9Lh9hmEcQghBzfYw5im2OAC0HccZFUVxD8/zdmgL0E3TRGT35z3Pw2YJQSB9DXzYf2WM7Z04McT/F/edrOv6lzo5jc1FuP18tlarLaeU/rmRuxufkELtXNM0UiqVEIh1Qjab/W6lUhmilF6fzWZfOT4+/uDg4OCzu92ket2fLRHQN2zYkCkWixdJkvRBFyHjnMeFDeJAxUtN0/xJoVD4rWGavhTloWeyWWbUamsR64AAzn6P0SLT0EMLR6lUGtAA6IQcHsUihJkBYPmCT73BAnmOoigomdx1QaFYOx8bGztBUZQvwmqVUADCNEbbtv/i+/4x2Wz2791+a94AvQ3MQVvaY4p74vw999xj3sqnjo2P313I5/fFHo7Dm+d57lyqrTXvT3FEuWEYd+m6HlbjdJynE2UApDBz+76PaPjLYCXqwx4XztVyufxlRVHej3FIpKmFOBiZ/7+naRrinMy5tGG+AD2e36Zp4tD7jtg63ETs9r0gCLDGfh+Dfssod3T40UcfLW6zzTbrwNfLGEO0+9GR2f3oIAiuagHo+NOm9evX7/bMZz6zspR96diUIrrbTzb7zmGm9DwvBG50eGx8bK+B4sDfDcMwfN//fKFQOCsJFm3sB3OZXzM+uyUB+oRWEDBKGQhn9ooIZ8DQNxn1Hk36hx3HuUfTtNc3MjMy0Bq6Coqb06iAmSoINRjk0S9kUFzcjRhoLcuCO+jyUJWi4RkV/xPn9YPd67iGRe7H3Rx4EsQ+LwTNbCaT2RtZMPFmg1QqSqncCKQ9W9O08yIg7IpJcd4AvY150D6gP37+nnvuOW+A3o+0taQ4Yr+14zgvNE1ztaqqKxIusLC0ahwk1zhQnJfNZkEJ27MguWi+cZRzdRznPcjfnqBKmaysNpEnScg4IWS/6ehT2xjiyVvmC9CjPtBSqVQQRfE+xth2SS090ebzG8kzIE8KTe7TAjp+rFQq3yGEHKUoirFhw4Yddtppp3FEdNdqtX9F6QrhoCUubBJX4iTUfy29f1BZrVb3IIQgchq87VPI60VRBFXmqaqqfgXaoizLZw0MDJxeq9UQcwAa3H920/d+9GZLA/R4kuOwWK1W3yYIwrURIUkY9R4v5KhgRPgvzE9oKNlsdsGqrS0SQJ+MdscaJYSAxCLpSgqB13Gch3VdP0aSpDs7SSeLXUylUmlnWZavliUZaZ7wesQpkuH7KaVrGkyK75Fluavo9sQBpSX166Jgimsmlpm3PPQJ6cyHyT0xDuHBtVKpfLxxuD5LlmU1tshEgA5Tcch7EATBTz3PO3FoaOiJTkC0+d54X1u/fv0zMpnMtzzPezksp7Ish7XZE1fMG3KYqqowXc/5mk9AjxtbqVQOEwQBhWTCqPemKz6Mh3+eDdAPlGX5rojeL6RRhDBN0zyGEPINvKAJ0DGZfNu23zQ4OIg6r0vuAm87AqoopS+L4gEmedvRGUmS/vmpT33qOYgwtCxrV8dx7ofWkc1mb6WUvrab6PZ+CWlLBnQcpvL5PE78H0R6N4Ym4TObKEHIWIjyKaBPzLBEtayjKKXfEARBSWpUmO9RkYcNlUrlw8PDw9e2E4Eeb3Ku677M87zLVVXdA77ySqXCsNFGBZ1Csz6l9COg623nvVPWRdOJN9XQp9815hPQowNECOqGYXybMfau+GAdAzrWJaxkWJOc8zFVVc99/PHHrwDjXKd7H+bNr3/9a3nPPfc8qVGs6ZOKouTjXPNcLkdQsSy6QqroRq2C0zOZzOfaZiKcpUHtAzpzYvKuTvuYvD+e55VK5buCIISm9xagPvnIjICOu0ql0q9lWX657/s1y7KeNTw8DE1Usizr7iAI9trsuBAEGLwnZVneT9f1DUvJ9A5aw+XLl58jCMIZcRR104HFqFarxy9fvvx7GzduzEqSdGGxWPygZVkjoigeIUnSrzveqOYy2rNPvlCLma/iLKB+7XUeeqsuJlJU9hIE4XpCCNwfoQYYRbVO1hRuR0Pvk3VkUZnco012wsY+YeH4vKIoJyMXHcFLsZwTAA9T5Q8aVqqzVFX9VyurUzwOqHXQMKWeQSmFjzKZwoTqVkRRlPDA1eB0QEnck6LCHaHFoNvpv7QAXZMrlWqH1K/dSmZ+NfTEvArHs16v39SwvrwOwBqnW8U1vjEXMPfAFOi67kOCIFzNGPuOruvrZuptPNaWZe3SKIb1X5xz1DnfYZq9Afjjy7Ii+L73JdBy98HMD+bFnjLFzdZ/RL0PDQ3d1ziIh6b36a5ZAX18fPxliqL8BoQylNIvyLL8YbwMpUJ1Xb8lIpaZtLvjhZIoEddz/zIyMvKy7bff3poJ1PuxmXa7FEZHR5EKcL0oikm/3+TrfN+/JZfLHRz1fw/4NmRZhqZ+88DAwBsWmuq1ud/NGrqqqqsw2WOfZrQYO6R+nfqV+BsoTjMF0EVBomRuTHEzTvKAU8ooN03zbZTSayPzMQAdh5jNAD2TyTDDMBY8KA6aSi6Xm7fiLC3mRLjx4pAniuIVhBAUFpoE9URAURxk6HPOUWbyds75w0EQlKHJc7Bb0nwAABCXSURBVM5znPNnSJIESlnkmYem1lD40RUdrnwBYbmE/M3zvPciL7nbQLhWmgvWXLJ8ampynwrouWwOzIBhUBxqUWSzWcQHXVguly/YYYcdUOCoOya3pokVxRGwc889lx9//PHXDwwMvEUUROBAeCfmAgAdU6F5jhFC/kEIgQsG1dE2MMYQuIZEjFwEYLtSSl/aYC7dOXatTU6zKTRnIbWyr2u6UK1VL4VFuRu+9lnANcEUJ7054XGOwlLaL5+62XdmAcNKpfJGzvmNyVKpze8A/ka07bBW7DPFIR4NBMjsb/I8DyH0lmVZzxseHn4QA1gul78uSdJxyTS2BKAjze3Hy5YtO7xXk6ZboG7nuVKp9BpBEG5GEFUS8BL70yZBEHC4eQDaeaFQ+IrjOO+SJGnj2NjYIdtuuy3Id+akdbTTzk7uSQI65/z7jYPZvAA6omkppSh36ouCKDiuc1sjXeRVMTVrJ32Y7t7EQSJbr9dhev9AVCwnrCkcmtwngnLCnaERhLWoAN2yrEcppX2vtjaNFhNuSrC4BUEAJje4l8KDXiy32NKRLD0Zb8RJk19TZagpLjgcHJD/6/v+Y/Cba5r2m16AebQvbeZDt23bcxxn4autLSIf+nwBeuIQF84tWIBEUTwpWcyqOZ2sk33g6X14etTDdxs0w4JhGB8dHBz8Qq/M7E0Hyb5Rv85ykAjne7VaRY33t89kdoeLC7+3BHR8BNy4siz/WZIkZtv2XcViEaT3OJHkGlG8IBZ4RrIxSF1AgIKu6wisu64RKHZkrziiO5kE7d6LwhWCINzCGINPEcmUk49GEwk5lGdEfOEoVPP6XC63GnW/GyQn12ua9s62o4Ln0STRDOiyLK9ClFK/NHTXdS/mnJ8wH4AeHzajMqt7+b4/aXrHom4GdFVVmWma/dHQW4zpdGlrvu9zWAts254fQJ9mvsWHz3q9vhMh5GuEEFieQr9jrElNKNZP57+2A+gA+Oi+cJ4pinJ/rVZ7b6FQmFMQXAtLw6IEdMuybsfBOa62hsh+FDCpVDqtttbu7rX5fUkfeiaT2Re0p9DQwd0PDb1cLl9YrVZ7qqE/vWE+XfHM87y3eJ6HGgvbxvMoeUCM/9Z8KGzV8+ZYraZ7Yj19bePw+J5cLndH99Kb+cn2fejtFLrqrJXYz6vV6iD4NhprNiY72+wlWLdYw67rbq6hx6fher2O0pinVatVrmnaKdls9jL8BjCklN4RBAHL6BnquE54So9P+AhYkCTpJw3CirdBg1psPnWYMQRBuA4aZcQmNEVAUYWo67LZbEgrCk5smIdEUVzped6/gyB4SSaTCXl1p+vbPGJ4c9snfejQ0AHoiDiNS41Gbb5C07QOqq1NnT/NJncAOni7EWcB0pJ+aegJjSA+uU5GvUf9S1qbUH+b1a16fwC9xbpsBeiRL5Hrug4GxvkB9Bn2jMTYabZtgyXuZByEkN4PP6eiKOHGkNQGmjWD5s0Y2oFpmr6macg3v85xnFOGh4dBGd1T61XSh/6sZz1rNVxh0NAjAhEkQ6MK2EWaps1rPXTP9W4nhKyyncl0vbA2e6lUumDdunXzmraGOCfG2PwCejTf4pREQkjRtu1PEUKOBZd/xE4Y3oWIdIDPxBxqsp3PgnUJgEccBv65zDCM8+bCAtcOvC4koMftq1arSIW9IU5VizA6/BlyiU3u0wJ69AC4tP8qy/KzKpVKzXXdFwwPD4cpWtVq9RhZlr8hSRJ3HGdqHtvT2u6fG7z+/wnu5nYE1+97MDD1ev0E3/e/BOBJaq3Jb7uu+7exsbH9d955Zwum9lwu93XG2JEonep53knZbPZ7vTIj9rrPzRq6JEmoXzwF0JHD2Qh07Amg12q1UEMXRXHeAR1jgzxXQRA+0KJufYD627ZtLzigY+dSZIW5nrvggJ44FMUpbQcSQj7ted4BiJkBqEeRyZNTcxZABwsc5PwAKg42tMPV0YM9P9P2B9C7a2YyDx2A7npueHBmjOFQ4xQKBbnhCrjgoYcemhbQu/ty6x0j1tA3btx4d6FQ2BeABw0dGKqqqmQYRs996NPtXYmAtmc1SpEj2PjtnuepOCjOrJnPDPCR8mRTSr/FOb+oJa70UqhPH1QWxOTeLF+Y3iHLxBqeBPQY4D3Pa62hxw+Zpnmg7/u/1VSN2o695sknn3zJbrvtVonqpV8ERiBVVaeMRBNrz8YgCN6Nkon98au3N4KIymWMXS4Iwn/Cv5o86TQJ7hFN0w6ilP4boF2tVt8ty/JVoB31PO+HKAbStqm912idfN/0ZtVQe0Uqnqqqx4ADPaopjsUdHrwcx7mzUChc00nOcfLT8Tg+/vjj2rJly94siuJrXdc1okNOIDIx53jO3bquf74XKX2tuhprf+VyeVfG2IdEUZzkDo/XoSAIsud5T/m+f00ul7u/1xpj8/DG70fZUsYYGKzCtB1ciqLIqMrHGPueoij/6Hdb2p168Vi6rnug67of9DwPZvhCssJiC0CP1zvcUncJgvDFhx9++NZ+E6jEbUX++2GHHXZSvV5/kaqq1Qi4EOQ3wDm/Pp/P/6Rfh4qEXOF/xFpD2dBTXNeFVlxF4ZswSEvX85s2bbp+zZo1P1+1atVEPc8+XvFaLpVKn9A0bXfOuRmVrsUhIxsEwY26rv+sH8xtswF7pVJBWW7sE9g794+CKTuRhkEIATPatbZj/2hwYBBBmvN2JTI73i+K4vOjfTQs6BbRT9+rKMpX++G/T3YSckRZ4hC7OD7OJzb0hIbemH/nbRYU17x5VyqVcxog+Mkw+E2SVqPCGO7BJDrggAOu9n3/nTPZT+BDlGX5GhRzyWazI52a4NuD7NbjC57p00477U0wzzRKvu4giii+M8E93LxRcc6fCILgtblcDhGYKFP3WkrpL2BSbORa/qvBjLTvwMAASP6xkreYCnPztjLm40MdTJYObp2Pli/oN5KHtEKhgOIP+zcyCZAauDwIgoGocVWUVxYE4Z9Icbdt5/eDgwPl/hzUF1Qc6cf7JIE77rhDffGLX7xfI3Ib1SkRyQ53ZoEQko+yVqAYlBhjj3POH6GU/p+qaXcz2nv/dJ+6uOCvnRHQ0bqoAhvK070JKWtBEFyYyWTOjH4TTNNEgM2xEcht9r6EqWUUJwxN05A6M2NqWy+kAk2pkSP7Wc75K+P0mmSIf1ydB9+CJsc5P7RQKMBNgPrazwuC4E5CSE4QhDFK6WG6rv9usWhWvZBP+o5UAqkEUgm0JYH09NuWmBbDTbMCegTcecuyfh8EwR4wWTfyWM8Ea1cM6rVa7XMwfTbnpUa/N/dzQ6PW9aeDIPguyuz1UggAXMuykKp1KmMMVJeT7oA4cC8iO5gMzmgQ4T/kuu5h+Xz+gUgz3xU5uBGRQVUURXBdX7cYqqn1Ulbpu1IJTCeBdP9O50YqgaUpgbYAHV0rlUq7MMZ+SwhZGUUZop7yxRFogx72+IYfC7mAYMufQjbRLJrI3G03yrWCLvZ7vu/fMTAwUOpYhDR0VFLX9fYG4UgQBEcIggC/KmeMTelbHCUZR/GiDb7v/8nzvEOXL1++CRaG9evX75HJZH5GCEFqj9Uo1XlusVhE4FfX1ag67lP6wAwS6DHU9Ph16dDNXQKLYUgWQxvmLsn0DVujBNoGdAinUqkg4OI38K0xxhDxc04ul4OjPrzK5fJLGqVWbxQEATlz4bubguTC+2L/deI3BI78JQiCuxhjawgha1zXBaF/eWhoqBK9R/7nP/+ZX7Zs2XaCIIBBCCQZCLI4UBAEBL1NUCBF/vHpCDDANW2apjc2Nvb1crl8yh577BGm1o2MjLxoYGDgZ4ZhIIgDZQC/ksvlTl4yYJ7uQlvj+k373BcJpIupL2JNX9p3CXQE6GhNtVpFCUsk8i8HXsuy/JMHH3zwqH322QfRiPh9mSAIl9m2/XYEoTVrytNo69N2NCa7iG+Ahp0Mq49z8JooBiff10xQ4Pv+esuy3jc8PHxTHNBTLpdfLEnS7b7v65qqOa7nXqJp2ieXDJj3fZosxQ8stk15sbVnKY5p2uZUAqkEZpJAx4CeAHUA4jOhEbuue3cmk3mTruuTZfJc1z2oXq9/DSbwuQxBi+puHb0u8Ty07m+WSqUzV6xYEfru42j1Rm72tg061z8ODQ0NBUHwcZDopGDekZh7cHMKeD0QYvqKVAKpBLZiCXQF6JBXqVQaUBTle5ZlHZLJZBApPo5SiZqmXZ1gpNINwziRUvrRSKPfTNSzUPzNOjStTPrJhwDalNJbkDOfzWbvbZVmg7+Zpvk83/dfkM/nr0yj2WcV+ww3pMA8F+kttWfT0V5qI7ZE25tOtLYGrmtAx9tBHFKtVi+WZfkU0EY2ctZRC/mnpmm+H/SPcQsaUe0A9hMopScTQpB7OHFxQujU2LW2Gp28KU6Liw8GCYB3KaPX8YB/Lqr4FLnYuWqa5qt93/9DFGWfTpWOpb40HkgHdmmM05bSynS+bSkjuXT7MSdAj7sdcc1eHgTBchRp4ZyPNwpeXfLII498ee+99zZj0zbM2IZhHEQIOZpSCoIaNVl+cVoxTrNSwBMMAIcfHQQwEQ/7Pb7v/wBlUXVdB0HBZLlAwzBe6Ps+ige8WJblr2madmJqWl+6kzdteSqBVAKpBFIJPC2BngA6XgcTvCRJn6WUvtdxnDAYznXdjYqiXJzJZC4H62iSYY1znjFNE1XcXtWgkMQ/e0zHrz7TgPm+/ySi40VRvLPBSX1roVB4qNmsDqKYBuif4/s+6suGbHGSJD1Uq9X2HR4eRi3elP1tK1wVqUa1dAe9p2PX05ctXZmmLV/6EugZoMeisCzr9ZzzS0BCI0kSMQyDaJoGJrarbdu+slgsPtJKbA3CfcUwjN0ZY8+JCtsPUErBz1yMABfpa14QBBsZY/8mhPyLc/6viKR/syUZuQMOkSQJhUhQ2x0XtHWHc/7VtWvXnrX77rvXUhrXpT+J0x6kEtgaJJCeO5b4KM/DAPYc0CHyiC72yIZJ/BxCyC4om4cLVc4YY0h5Q/nSW3tdiQ2ad71eh1n9aM75mwVBWI5CEw2CGGpZliOK4reDILi4WCziMDBpiu94mszDwHTcpj49sBV1tU8STF+bSiCVQFsSSDebtsQ00019AfT4gyjrZ1nW213XfR/n/ACUW03UzUU6+T8opTejjq8kSfdls9kH2q1ag/esXbu26HlesMsuu4QVeFABLJ/Pf1UUxXfj7yihGQRBSVEUpKt9ddmyZQ/PCcjnLO70BakEUgmkEkglsPVIYH5PKX0F9OSgVavVPRhjJzRA/K2EkOHI/h0WaMcF9rhGDrjDGHuYUrqRcz5KCEFBl1KjIIxMKdUJIVIjqG2wkU++oyiKuzqOgzq7nxwcHAQ9a/iier3+X5RS1I69pUGCc10QBNcvX758MjBv65lIaU9TCaQSSCWwdUpgfmG0lYwXpgXzBugJrZ0ahrE3pfQNCIjzff+lbOIKA96RhjbbFfGwE9Ri55xfq2nakXG0esN/r61bt25o++23B8nNwkh1tg6kv6cSSCWQSiCVwFYlgafBqH+wNO+A3jyCyFE3TXMPx3H2lCRpz6gO8yDnHJr4UKPgC4LjUCcXjviaKIp1z/PWIijOdd1/EULuKRaLv5rRlN4/+W1VEzLtbCqBVAKpBFIJLF4J/D/xclRhztyp5QAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", zoe = async (r, e = ri.MAINNET) => {
  var i, n;
  try {
    const s = Pr[e], l = (n = (i = (await (await fetch(s, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetAtom($atomId: String!) {
            atoms(where: { term_id: { _eq: $atomId } }) {
              term_id
              image
              label
              emoji
              type
              creator_id
              value {
                person {
                  description
                }
                organization {
                  description
                }
                thing {
                  description
                }
                book {
                  description
                }
              }
              term {
                total_market_cap
              }
            }
          }
        `,
        variables: { atomId: r }
      })
    })).json()).data) == null ? void 0 : i.atoms) == null ? void 0 : n[0];
    return l || null;
  } catch (s) {
    return console.error("Error fetching atom details:", s), null;
  }
}, joe = async (r, e = ri.MAINNET, i = 1e3) => {
  var n;
  try {
    const s = Pr[e];
    return ((n = (await (await fetch(s, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query Triples_for_Agent($objectId: String!, $batchSize: Int!) {
            triples(limit: $batchSize, where: { object_id: { _eq: $objectId } }) {
              term_id
              subject {
                term_id
                label
                type
                image
              }
              predicate {
                term_id
                label
                type
                image
              }
              object {
                term_id
                label
                type
                image
              }
              term {
                total_market_cap
                total_assets
                positions_aggregate {
                  aggregate {
                    count
                  }
                }
              }
              counter_term {
                total_market_cap
                total_assets
                positions_aggregate {
                  aggregate {
                    count
                  }
                }
              }
            }
          }
        `,
        variables: { objectId: r, batchSize: i }
      })
    })).json()).data) == null ? void 0 : n.triples) || [];
  } catch (s) {
    return console.error("Error fetching triples for agent:", s), [];
  }
}, Voe = async (r, e, i = ri.MAINNET) => {
  var n, s, a, o;
  try {
    const l = Pr[i], u = "0x4b5ec64b82fae56c71a469fc902df2096b0dc7c930dd61032e817d583575fe47", h = await (await fetch(l, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetFollowsAndFollowers($predicateId: String!, $userAtomId: String!) {
            follows: triples(
              where: {
                _and: [
                  { predicate_id: { _eq: $predicateId } },
                  { subject_id: { _eq: $userAtomId } }
                ]
              }
            ) {
              term_id
              object {
                term_id
                label
                image
                creator_id
              }
            }
            followers: triples(
              where: {
                _and: [
                  { predicate_id: { _eq: $predicateId } },
                  { object_id: { _eq: $userAtomId } }
                ]
              }
            ) {
              term_id
              creator_id
              subject {
                term_id
                label
                image
              }
            }
          }
        `,
        variables: { predicateId: r, userAtomId: u }
      })
    })).json();
    return {
      follows: ((s = (n = h.data) == null ? void 0 : n.follows) == null ? void 0 : s.map((d) => ({
        ...d,
        object: { ...d.object, id: d.object.term_id }
      }))) || [],
      followers: ((o = (a = h.data) == null ? void 0 : a.followers) == null ? void 0 : o.map((d) => ({
        ...d,
        subject: { ...d.subject, id: d.subject.term_id }
      }))) || []
    };
  } catch (l) {
    return console.error("Error fetching follows and followers:", l), { follows: [], followers: [] };
  }
}, AO = async (r, e = ri.MAINNET) => {
  var i, n;
  try {
    const s = Pr[e], a = [], o = 100;
    let l = 0, u = !0;
    for (; u; ) {
      const h = await (await fetch(s, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: `
            query ClaimsBySubject($subjectId: String!, $limit: Int!, $offset: Int!) {
              triples(
                limit: $limit,
                offset: $offset,
                where: { subject_id: { _eq: $subjectId } }
              ) {
                term_id
                subject {
                  term_id
                  label
                  type
                  image
                }
                predicate {
                  term_id
                  label
                  type
                }
                object {
                  term_id
                  label
                  type
                  image
                }
                term {
                  total_market_cap
                  positions_aggregate(where: { shares: { _gt: 0 } }) {
                    aggregate { count }
                  }
                }
                counter_term {
                  id
                  total_market_cap
                  positions_aggregate(where: { shares: { _gt: 0 } }) {
                    aggregate { count }
                  }
                }
              }
            }
          `,
          variables: { subjectId: r, limit: o, offset: l }
        })
      })).json();
      if (h.errors)
        throw console.error("GraphQL errors:", h.errors), new Error(((i = h.errors[0]) == null ? void 0 : i.message) || "GraphQL error");
      const d = ((n = h.data) == null ? void 0 : n.triples) || [];
      d.length === 0 ? u = !1 : (a.push(...d), d.length < o ? u = !1 : l += o);
    }
    return a;
  } catch (s) {
    return console.error("Error fetching claims by subject:", s), [];
  }
}, Goe = async (r, e, i, n = ri.MAINNET) => {
  var l;
  const s = Pr[n], a = {
    where: {
      subject: {
        creator_id: { _eq: r }
      },
      predicate_id: {
        _eq: e
      },
      object_id: {
        _eq: i
      }
    }
  }, o = `
    query GetTriples($where: triples_bool_exp) {
      triples(where: $where) {
        term_id
        subject_id
        predicate_id
        object_id
        subject {
          term_id
          label
          type
          creator_id
          value {
            person {
              description
            }
            organization {
              description
            }
            thing {
              description
            }
            book {
              description
            }
          }
        }
        predicate {
          term_id
          label
          type
        }
        object {
          term_id
          label
          type
        }
        block_number
        created_at
        transaction_hash
      }
    }
  `;
  try {
    const c = await (await fetch(s, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify({
        query: o,
        // ← Utiliser la requête directe
        variables: a
      })
    })).json();
    if (c.errors)
      throw console.error("la Erreurs GraphQL:", c.errors), new Error(((l = c.errors[0]) == null ? void 0 : l.message) || "Erreur GraphQL inconnue");
    return c.data;
  } catch (u) {
    throw console.error(
      `[fetchTriplesByCreator] Erreur lors de la requête directe vers ${s}:`,
      u
    ), u;
  }
}, fT = (r, e, i, n = ri.MAINNET, s) => {
  const { PLAYER_TRIPLE_TYPES: a } = s || { PLAYER_TRIPLE_TYPES: { PLAYER_GAME: { predicateId: "", objectId: "" } } }, o = e || a.PLAYER_GAME.predicateId, l = i || a.PLAYER_GAME.objectId, [u, c] = ye(null), [h, d] = ye(!0), [p, f] = ye(null);
  Ft(() => {
    (async () => {
      if (!r) {
        d(!1);
        return;
      }
      try {
        const v = await Goe(
          r,
          o,
          l,
          n
        );
        c(v);
      } catch (v) {
        console.error(
          `[${n}] Erreur lors de la récupération des triples:`,
          v
        ), f(v instanceof Error ? v : new Error(String(v)));
      } finally {
        d(!1);
      }
    })();
  }, [r, e, i, n]);
  const m = (u == null ? void 0 : u.triples) || [];
  return {
    loading: h,
    error: p,
    triples: m,
    network: n,
    rawData: u
  };
}, Hoe = (r, e = ri.MAINNET, i) => {
  const [n, s] = ye([]), [a, o] = ye([]), [l, u] = ye([]), [c, h] = ye({
    follows: [],
    followers: []
  }), [d, p] = ye(!1), [f, m] = ye(null), { COMMON_IDS: y } = i, { triples: v, loading: g, error: _ } = fT(
    r || "",
    i.PLAYER_TRIPLE_TYPES.PLAYER_GAME.predicateId,
    i.PLAYER_TRIPLE_TYPES.PLAYER_GAME.objectId,
    e
  ), x = v.length > 0 ? v[0].subject : null;
  return Ft(() => {
    if (!r) {
      s([]), o([]), u([]);
      return;
    }
    (async () => {
      p(!0), m(null);
      try {
        const [T, E, M] = await Promise.all([
          joe(r, e),
          pT(r, e),
          Voe(y.FOLLOWS, r, e)
          // Ajouter les connections
        ]);
        s(T), o(E), h(M);
      } catch (T) {
        console.error("Error loading sidebar data:", T), m(T instanceof Error ? T.message : "Unknown error");
      } finally {
        p(!1);
      }
    })();
  }, [r, e]), Ft(() => {
    if (!x) {
      u([]);
      return;
    }
    (async () => {
      try {
        const T = await AO(x.term_id, e);
        u(T);
      } catch (T) {
        console.error("Error loading claims:", T), u([]);
      }
    })();
  }, [x, e]), {
    atomDetails: x,
    triples: n,
    positions: a,
    activities: l,
    connections: c,
    loading: d || g,
    error: f || (_ ? _.message : null)
  };
}, Woe = (r, e = ri.MAINNET) => {
  const [i, n] = ye(null), [s, a] = ye(!1), [o, l] = ye(null);
  return Ft(() => {
    if (!(r != null && r.id)) {
      n(null), l(null);
      return;
    }
    (async () => {
      a(!0), l(null);
      try {
        const c = await zoe(r.id, e);
        n(c);
      } catch (c) {
        console.error("Error loading selected atom details:", c), l(c instanceof Error ? c.message : "Unknown error"), n(null);
      } finally {
        a(!1);
      }
    })();
  }, [r == null ? void 0 : r.id, e]), {
    atomDetails: i,
    loading: s,
    error: o
  };
}, qoe = (r, e = ri.MAINNET) => {
  const [i, n] = ye([]), [s, a] = ye(!1), [o, l] = ye(null);
  return Ft(() => {
    if (!(r != null && r.id)) {
      n([]), l(null);
      return;
    }
    (async () => {
      a(!0), l(null);
      try {
        const c = await AO(r.id, e);
        n(c);
      } catch (c) {
        console.error("Error loading selected atom claims:", c), l(c instanceof Error ? c.message : "Unknown error"), n([]);
      } finally {
        a(!1);
      }
    })();
  }, [r == null ? void 0 : r.id, e]), {
    claims: i,
    loading: s,
    error: o
  };
}, Xoe = ({ walletAddress: r, walletConnected: e, walletHooks: i, onOpenVoting: n, constants: s, gamesId: a, wagmiConfig: o }) => {
  const [l, u] = ye(null), [c, h] = ye(!1), d = (X) => {
    u(X);
  }, [p, f] = ye("base"), [m, y] = ye(!1), [v, g] = ye(!1), [_, x] = ye(""), b = () => {
    n ? n() : console.warn("onOpenVoting not provided to PlayerMapGraph");
  }, { atomDetails: T, activities: E, connections: M, loading: C, error: S } = Hoe(r, ri.MAINNET, s), { atomDetails: w, loading: R, error: O } = Woe(l, ri.MAINNET), { claims: P, loading: A, error: D } = qoe(l, ri.MAINNET);
  Ft(() => {
    l && T && ((l == null ? void 0 : l.id) === (T == null ? void 0 : T.id) || (l == null ? void 0 : l.id) === (T == null ? void 0 : T.term_id) ? (h(!0), g(!0)) : (h(!1), g(!0)));
  }, [l, T]);
  const L = {
    background: "#ffd32a",
    color: "#18181b",
    border: "none",
    borderRadius: 12,
    width: 54,
    height: 54,
    fontSize: 22,
    fontWeight: "bold",
    boxShadow: "0 2px 8px rgba(0,0,0,0.18)",
    cursor: "pointer",
    marginBottom: 0,
    marginTop: 0,
    textTransform: "uppercase",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: 0,
    transition: "background 0.2s, color 0.2s, transform 0.1s"
  }, H = {
    background: "#ffe066",
    color: "#18181b",
    transform: "translateY(-2px) scale(1.03)"
  }, V = (X) => _ === X ? { ...L, ...H } : L;
  return /* @__PURE__ */ I.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        height: "100%",
        width: "100%",
        position: "relative",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "relative",
              flex: 1,
              width: "100%",
              height: "100%",
              overflow: "hidden"
            },
            children: /* @__PURE__ */ I.jsx(
              Rae,
              {
                endpoint: p,
                onNodeSelect: d,
                onLoadingChange: y,
                walletAddress: r,
                gamesId: a,
                disableNodeDetailsSidebar: !0
              }
            )
          }
        ),
        m && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              zIndex: 2
            },
            children: /* @__PURE__ */ I.jsx(LC, {})
          }
        ),
        /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              top: "5px",
              left: "5px",
              zIndex: 50,
              display: "flex",
              flexDirection: "row",
              gap: "12px",
              alignItems: "center"
            },
            children: /* @__PURE__ */ I.jsx(
              "button",
              {
                style: V("profile"),
                onClick: () => {
                  h(!0), g(!0);
                },
                "aria-label": "Profile",
                onMouseEnter: () => x("profile"),
                onMouseLeave: () => x(""),
                children: /* @__PURE__ */ I.jsx(Foe, {})
              }
            )
          }
        ),
        /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              bottom: "50%",
              right: "5px",
              zIndex: 50
            },
            children: /* @__PURE__ */ I.jsxs(
              "button",
              {
                style: {
                  ...V("vote"),
                  fontSize: "18px",
                  fontWeight: "bolder",
                  width: "auto",
                  minWidth: "160px",
                  padding: "0 12px",
                  display: "flex",
                  alignItems: "center",
                  gap: "8px"
                },
                onClick: b,
                "aria-label": "Vote",
                onMouseEnter: () => x("vote"),
                onMouseLeave: () => x(""),
                children: [
                  /* @__PURE__ */ I.jsx("img", { src: _A, alt: "Atom", style: { width: "44px" } }),
                  "SPEAK UP"
                ]
              }
            )
          }
        ),
        /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              bottom: "5px",
              left: "5px",
              opacity: 0.4,
              zIndex: 50
            },
            children: /* @__PURE__ */ I.jsx(
              "a",
              {
                href: "https://portal.intuition.systems/",
                target: "_blank",
                rel: "noopener noreferrer",
                style: {
                  display: "block",
                  textDecoration: "none",
                  transition: "opacity 0.2s, transform 0.2s"
                },
                onMouseEnter: (X) => {
                  X.currentTarget.style.opacity = "0.8", X.currentTarget.style.transform = "scale(1.05)";
                },
                onMouseLeave: (X) => {
                  X.currentTarget.style.opacity = "1", X.currentTarget.style.transform = "scale(1)";
                },
                children: /* @__PURE__ */ I.jsx(
                  "img",
                  {
                    src: Boe,
                    alt: "Intuition Systems",
                    style: {
                      height: "30px",
                      width: "auto",
                      cursor: "pointer"
                    }
                  }
                )
              }
            )
          }
        ),
        v && /* @__PURE__ */ I.jsx(
          "div",
          {
            style: {
              position: "absolute",
              inset: 0,
              zIndex: 1200,
              pointerEvents: "auto"
            },
            onClick: () => g(!1)
          }
        ),
        /* @__PURE__ */ I.jsxs(
          Nae,
          {
            open: v,
            onClose: () => g(!1),
            children: [
              (C || R || A) && /* @__PURE__ */ I.jsx("p", { children: "Loading data..." }),
              (S || O || D) && /* @__PURE__ */ I.jsxs("p", { style: { color: "red" }, children: [
                "Error : ",
                S || O || D
              ] }),
              !C && !S && !R && !O && !A && !D && /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
                /* @__PURE__ */ I.jsx(
                  Uae,
                  {
                    atomDetails: c ? T : w,
                    connections: c ? M : { follows: [], followers: [] },
                    walletAddress: r
                  }
                ),
                /* @__PURE__ */ I.jsx(
                  Toe,
                  {
                    activities: c ? E : P,
                    title: c ? "My Claims" : "Claims",
                    walletAddress: r,
                    walletConnected: e,
                    publicClient: o == null ? void 0 : o.publicClient
                  }
                ),
                c && /* @__PURE__ */ I.jsxs(I.Fragment, { children: [
                  /* @__PURE__ */ I.jsx(
                    Moe,
                    {
                      accountId: r || "",
                      walletConnected: e,
                      walletAddress: r
                    }
                  ),
                  /* @__PURE__ */ I.jsx(Coe, { accountId: r || "" })
                ] })
              ] })
            ]
          }
        )
      ]
    }
  );
}, CO = ({
  isOpen: r,
  onConnectWallet: e
}) => r ? /* @__PURE__ */ I.jsx(
  "div",
  {
    style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "rgba(0, 0, 0, 0.7)",
      backdropFilter: "blur(5px)",
      zIndex: 1e3,
      width: "100%",
      height: "100%"
    },
    children: /* @__PURE__ */ I.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#1a1a2e",
          padding: "30px",
          borderRadius: "10px",
          textAlign: "center",
          maxWidth: "500px",
          boxShadow: "0 0 15px rgba(108, 92, 231, 0.5)"
        },
        children: [
          /* @__PURE__ */ I.jsx("h2", { style: { color: "#6c5ce7", marginBottom: "20px" }, children: "Wallet Required" }),
          /* @__PURE__ */ I.jsx("p", { style: { fontSize: "18px", marginBottom: "25px", color: "#fff" }, children: "Please connect your wallet to access this feature" }),
          /* @__PURE__ */ I.jsx(
            "button",
            {
              onClick: e,
              style: {
                padding: "12px 24px",
                backgroundColor: "#6c5ce7",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
                fontSize: "16px"
              },
              children: "Connect Wallet"
            }
          )
        ]
      }
    )
  }
) : null, Yoe = ({
  isOpen: r,
  onCreatePlayer: e,
  onClose: i
}) => r ? /* @__PURE__ */ I.jsx(
  "div",
  {
    style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "rgba(0, 0, 0, 1)",
      backdropFilter: "blur(1px)",
      zIndex: 1e3,
      width: "100%",
      height: "100%"
    },
    children: /* @__PURE__ */ I.jsxs(
      "div",
      {
        style: {
          backgroundColor: "#1a1a2e",
          padding: "30px",
          borderRadius: "10px",
          textAlign: "center",
          maxWidth: "500px",
          boxShadow: "0 0 15px rgba(0, 128, 255, 0.7)",
          position: "relative"
        },
        children: [
          i && /* @__PURE__ */ I.jsx(
            "button",
            {
              onClick: i,
              style: {
                position: "absolute",
                top: "10px",
                right: "10px",
                backgroundColor: "transparent",
                border: "none",
                fontSize: "20px",
                color: "#666",
                cursor: "pointer"
              },
              children: "×"
            }
          ),
          /* @__PURE__ */ I.jsx("h2", { style: { color: "#FFD32A", marginBottom: "20px" }, children: "Player Required" }),
          /* @__PURE__ */ I.jsx("p", { style: { fontSize: "18px", marginBottom: "25px", color: "#fff" }, children: "You need to create a player before you can vote on claims" }),
          /* @__PURE__ */ I.jsx(
            "button",
            {
              onClick: e,
              style: {
                padding: "12px 24px",
                backgroundColor: "#1976d2",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
                fontSize: "16px"
              },
              children: "Create Player"
            }
          )
        ]
      }
    )
  }
) : null, Koe = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  network: n = ri.MAINNET,
  onSuccess: s
}) => {
  const [a, o] = ye(!1), [l, u] = ye({
    status: "idle",
    message: ""
  }), { depositTriple: c, isLoading: h } = wO({
    walletConnected: r,
    walletAddress: e,
    publicClient: i,
    network: n
  });
  return {
    submitVotes: async (p) => {
      var m;
      if (!p.some((y) => y.units > 0))
        return u({
          status: "error",
          message: "Please place at least one vote."
        }), null;
      if (!r || !e)
        return u({
          status: "error",
          message: "Wallet not connected."
        }), null;
      try {
        o(!0), u({
          status: "pending",
          message: "Transaction in progress..."
        });
        const v = p.filter((_) => _.units > 0).map((_) => ({
          claimId: `0x${_.id.toString(16).padStart(64, "0")}`,
          units: _.units,
          direction: _.direction
        })), g = await c(v);
        if (g.success)
          return u({
            status: "success",
            message: `Transaction successful! Hash: ${(m = g.hash) == null ? void 0 : m.substring(0, 10)}...`
          }), s && s(), g;
        {
          let _ = g.error || "An error occurred.";
          return _.includes("user rejected") ? u({
            status: "error",
            message: "Transaction cancelled: User rejected the request."
          }) : u({
            status: "error",
            message: `Error: ${_}`
          }), null;
        }
      } catch (y) {
        return console.error("Error submitting votes:", y), u({
          status: "error",
          message: y instanceof Error ? y.message : "An error occurred."
        }), null;
      } finally {
        o(!1);
      }
    },
    isSubmitting: a,
    isDepositLoading: h,
    transactionStatus: l,
    setTransactionStatus: u
  };
}, Zoe = ({
  network: r = ri.MAINNET,
  onError: e
} = {}) => {
  const [i, n] = ye(!1);
  return {
    fetchTripleDetails: async (a) => {
      var o, l, u, c, h, d, p;
      n(!0);
      try {
        const f = Pr[r], m = await fetch(f, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: `
          query Triple($tripleId: String!) {
            triple(term_id: $tripleId) {
              term_id
              subject_id
              predicate_id
              object_id
              subject {
                term_id
                label
              }
              predicate {
                term_id
                label
              }
              object {
                term_id
                label
              }
              term_id
              term {
                total_market_cap
                total_assets
              }
              counter_term_id
              counter_term {
                total_market_cap
                total_assets
              }
            }
          }
        `,
            variables: { tripleId: a.toString() }
            // Convertir en string pour v2
          })
        });
        if (!m.ok)
          throw new Error(`GraphQL request failed with status ${m.status}`);
        const y = await m.json();
        if (y.errors)
          throw new Error(`GraphQL errors: ${JSON.stringify(y.errors)}`);
        if (!((o = y.data) != null && o.triple))
          return e && e(`Triple with ID ${a} not found`), n(!1), null;
        const v = ((c = (u = (l = y.data.triple.term) == null ? void 0 : l.positions_aggregate) == null ? void 0 : u.aggregate) == null ? void 0 : c.count) || 0, g = ((p = (d = (h = y.data.triple.counter_term) == null ? void 0 : h.positions_aggregate) == null ? void 0 : d.aggregate) == null ? void 0 : p.count) || 0;
        return n(!1), {
          id: String(a),
          subject: y.data.triple.subject,
          predicate: y.data.triple.predicate,
          object: y.data.triple.object,
          term_id: y.data.triple.term_id,
          counter_term_id: y.data.triple.counter_term_id,
          term_position_count: v,
          counter_term_position_count: g
        };
      } catch (f) {
        return e && e(`Error fetching details for triple ${a}: ${f instanceof Error ? f.message : String(f)}`), n(!1), null;
      }
    },
    isLoading: i
  };
}, Qoe = ({
  network: r = ri.MAINNET,
  walletAddress: e = "",
  onError: i,
  constants: n
}) => {
  const [s, a] = ye([]), [o, l] = ye(!0), { PREDEFINED_CLAIM_IDS: u } = n, [c, h] = ye(0), [d, p] = ye({}), [f, m] = ye(!1);
  Zoe({
    network: r,
    onError: i
  });
  const [y, v] = ye(null), [g, _] = ye(!0);
  Ft(() => {
    (async () => {
      var w;
      if (!e || !u || u.length === 0) {
        _(!1);
        return;
      }
      try {
        _(!0);
        const R = Pr[r], P = await fetch(R, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: `
          query BatchUserPositions($tripleIds: [String!]!, $walletAddress: String!) {
            triples(where: { term_id: { _in: $tripleIds } }) {
              term_id
              term {
                id
                positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}, shares: {_gt: 0}}) {
                  aggregate {
                    count
                  }
                  nodes {
                    id
                  }
                }
              }
              counter_term {
                id
                positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}, shares: {_gt: 0}}) {
                  aggregate {
                    count
                  }
                  nodes {
                    id
                  }
                }
              }
            }
          }
        `,
            variables: {
              tripleIds: u.map((L) => L.toString()),
              walletAddress: e.toLowerCase()
            }
          })
        });
        if (!P.ok)
          throw new Error(`GraphQL request failed with status ${P.status}`);
        const A = await P.json();
        if (A.errors)
          throw console.error("GraphQL Errors:", A.errors), new Error(A.errors[0].message);
        const D = { triples: [] };
        (((w = A.data) == null ? void 0 : w.triples) || []).forEach((L) => {
          var X, F, B, W, G, z, K, ne, oe, pe, xe, Re;
          const H = ((B = (F = (X = L.term) == null ? void 0 : X.positions_aggregate) == null ? void 0 : F.aggregate) == null ? void 0 : B.count) > 0 || ((z = (G = (W = L.term) == null ? void 0 : W.positions_aggregate) == null ? void 0 : G.nodes) == null ? void 0 : z.length) > 0, V = ((oe = (ne = (K = L.counter_term) == null ? void 0 : K.positions_aggregate) == null ? void 0 : ne.aggregate) == null ? void 0 : oe.count) > 0 || ((Re = (xe = (pe = L.counter_term) == null ? void 0 : pe.positions_aggregate) == null ? void 0 : xe.nodes) == null ? void 0 : Re.length) > 0;
          D.triples.push({
            term_id: L.term_id,
            id: L.term_id,
            hasTermPosition: H,
            hasCounterTermPosition: V,
            term: L.term,
            counter_term: L.counter_term
          });
        }), v(D);
      } catch (R) {
        console.error("Erreur lors de la récupération des positions utilisateur:", R), v(null);
      } finally {
        _(!1);
      }
    })();
  }, [e, u.join(","), r]), Ft(() => {
    if (y && !g && e) {
      const S = {};
      y.positions && Array.isArray(y.positions) && y.positions.forEach((w) => {
        if (!w.triple_id) return;
        const R = w.triple_id;
        if (w.is_for !== void 0) {
          const O = w.is_for ? lt.For : lt.Against;
          S[String(R)] = O;
        } else w.term_id && w.counter_term_id;
      }), y.triples && Array.isArray(y.triples) && y.triples.forEach((w) => {
        var O, P;
        const R = w.term_id || w.id;
        if (R && (w.hasTermPosition ? S[String(R)] = lt.For : w.hasCounterTermPosition && (S[String(R)] = lt.Against), !w.hasTermPosition && !w.hasCounterTermPosition)) {
          const A = ((O = w.term) == null ? void 0 : O.positions) || [], D = ((P = w.counter_term) == null ? void 0 : P.positions) || [], L = A.find((V) => {
            var X, F;
            return ((F = (X = V.account) == null ? void 0 : X.id) == null ? void 0 : F.toLowerCase()) === e.toLowerCase();
          }), H = D.find((V) => {
            var X, F;
            return ((F = (X = V.account) == null ? void 0 : X.id) == null ? void 0 : F.toLowerCase()) === e.toLowerCase();
          });
          L ? S[String(R)] = lt.For : H && (S[String(R)] = lt.Against);
        }
      }), y.position_triples && Array.isArray(y.position_triples) && y.position_triples.forEach((w) => {
        var O, P, A, D;
        if (!w.triple_id && !((O = w.triple) != null && O.id)) return;
        const R = w.triple_id || ((P = w.triple) == null ? void 0 : P.id);
        w.is_for !== void 0 ? S[String(R)] = w.is_for ? lt.For : lt.Against : w.term_id && ((A = w.triple) == null ? void 0 : A.term_id) === w.term_id ? S[String(R)] = lt.For : w.term_id && ((D = w.triple) == null ? void 0 : D.counter_term_id) === w.term_id && (S[String(R)] = lt.Against);
      }), p(S), a((w) => w.length === 0 ? w : w.map((R) => {
        const O = R.term_id || String(R.id), P = S[O] || S[String(R.id)] || lt.None, A = P !== lt.None;
        return {
          ...R,
          userHasPosition: A,
          userPositionDirection: P
        };
      })), f || b(S).then(() => {
        m(!0);
      }).catch((w) => {
        console.error("Error in loadTripleDetails:", w);
      });
    }
  }, [y, g, e, f]), Ft(() => {
    const S = s.reduce((w, R) => w + R.units, 0);
    h(S);
  }, [s]);
  const x = async (S) => {
    var w;
    if (S.length === 0)
      return /* @__PURE__ */ new Map();
    try {
      const R = Pr[r], O = await fetch(R, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: `
          query BatchTriples($tripleIds: [String!]!) {
            triples(where: { term_id: { _in: $tripleIds } }) {
              term_id
              subject_id
              predicate_id
              object_id
              subject {
                term_id
                label
              }
              predicate {
                term_id
                label
              }
              object {
                term_id
                label
              }
              term {
                total_market_cap
                total_assets
                positions_aggregate {
                  aggregate {
                    count
                  }
                }
              }
              counter_term_id
              counter_term {
                total_market_cap
                total_assets
                positions_aggregate {
                  aggregate {
                    count
                  }
                }
              }
            }
          }
        `,
          variables: { tripleIds: S.map((D) => D.toString()) }
        })
      });
      if (!O.ok)
        throw new Error(`GraphQL request failed with status ${O.status}`);
      const P = await O.json();
      if (P.errors)
        throw new Error(`GraphQL errors: ${JSON.stringify(P.errors)}`);
      const A = /* @__PURE__ */ new Map();
      return (((w = P.data) == null ? void 0 : w.triples) || []).forEach((D) => {
        var V, X, F, B, W, G;
        const L = ((F = (X = (V = D.term) == null ? void 0 : V.positions_aggregate) == null ? void 0 : X.aggregate) == null ? void 0 : F.count) || 0, H = ((G = (W = (B = D.counter_term) == null ? void 0 : B.positions_aggregate) == null ? void 0 : W.aggregate) == null ? void 0 : G.count) || 0;
        A.set(D.term_id, {
          id: D.term_id,
          subject: D.subject,
          predicate: D.predicate,
          object: D.object,
          term_id: D.term_id,
          counter_term_id: D.counter_term_id,
          term_position_count: L,
          counter_term_position_count: H
        });
      }), S.forEach((D) => {
        A.has(D) || A.set(D, null);
      }), A;
    } catch (R) {
      const O = /* @__PURE__ */ new Map();
      return S.forEach((P) => {
        O.set(P, null);
      }), i && i(`Error fetching batch triple details: ${R instanceof Error ? R.message : String(R)}`), O;
    }
  }, b = async (S) => {
    l(!0);
    try {
      const w = await x(u), R = S || d, O = u.map((A) => {
        var V, X, F;
        const D = w.get(A);
        if (!D)
          return {
            id: BigInt(A),
            subject: `Claim ${A}`,
            predicate: "is",
            object: "Unknown",
            units: 0,
            direction: lt.None,
            userHasPosition: !1,
            userPositionDirection: lt.None
          };
        const L = D.term_id || String(A), H = R[L] || R[String(A)] || lt.None;
        return H !== lt.None && console.log(`[loadTripleDetails] Triple ${L} a une position:`, H), L === "0x27191de92fe0308355319ec8f2359e5ce85123bd243bf7ffa6eb8028347b3eab" && (console.log(`[loadTripleDetails] Triple recherché: ${L}`), console.log("[loadTripleDetails] positionsToUse keys:", Object.keys(R)), console.log("[loadTripleDetails] Trouvé dans positionsToUse:", R[L])), {
          id: BigInt(D.id),
          subject: ((V = D.subject) == null ? void 0 : V.label) || `Subject ${A}`,
          predicate: ((X = D.predicate) == null ? void 0 : X.label) || "is",
          object: ((F = D.object) == null ? void 0 : F.label) || `Object ${A}`,
          units: 0,
          direction: lt.None,
          term_id: D.term_id,
          term_position_count: D.term_position_count || 0,
          counter_term_id: D.counter_term_id,
          counter_term_position_count: D.counter_term_position_count || 0,
          userHasPosition: H !== lt.None,
          userPositionDirection: H
        };
      });
      O.every((A) => A.object === "Unknown") && i && i("Error: Failed to fetch triple details. Please check your network connection or try again later."), a(O);
    } catch {
      i && i("Error: Failed to fetch triple details");
    } finally {
      l(!1);
    }
  }, T = (S, w, R) => {
    if (w !== lt.None && !C(S, w)) {
      const P = s.find((A) => A.id === S);
      if (P && P.userHasPosition && P.userPositionDirection !== lt.None) {
        i && i(`Cannot vote ${w === lt.For ? "for" : "against"} this claim as you already have an ${P.userPositionDirection === lt.For ? "affirmative" : "opposing"} position on it.`);
        return;
      }
    }
    a(
      (O) => O.map((P) => P.id === S ? P.userHasPosition && P.userPositionDirection !== lt.None && w !== lt.None && P.userPositionDirection !== w ? P : P.direction !== w && P.direction !== lt.None ? { ...P, units: R, direction: w } : R === 0 ? { ...P, units: 0, direction: lt.None } : { ...P, units: R, direction: w } : P)
    );
  }, E = () => {
    a(
      (S) => S.map((w) => ({
        ...w,
        units: 0,
        direction: lt.None
      }))
    );
  }, M = s.filter((S) => S.units > 0).length, C = (S, w) => {
    const R = s.find((P) => P.id === S);
    return !R || !R.userHasPosition ? !0 : R.userPositionDirection === lt.None || R.userPositionDirection === w;
  };
  return {
    voteItems: s,
    setVoteItems: a,
    isLoading: o || g,
    totalUnits: c,
    numberOfTransactions: M,
    handleChangeUnits: T,
    resetAllVotes: E,
    loadTripleDetails: b,
    isVoteDirectionAllowed: C,
    userPositions: d
  };
}, RO = (r) => (r * 0.01).toFixed(2), $oe = (r) => (r * 5e-5).toFixed(5), Joe = ({
  numberOfTransactions: r,
  totalUnits: e,
  onResetAll: i
}) => /* @__PURE__ */ I.jsxs(
  "div",
  {
    style: {
      backgroundColor: "rgba(0, 0, 0, 0.85)",
      padding: "10px",
      borderRadius: "8px",
      marginBottom: "25px",
      display: "flex",
      flexDirection: "column",
      border: "1px solid rgb(105, 105, 105)"
    },
    children: [
      /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", justifyContent: "space-between", marginBottom: "15px" }, children: [
        /* @__PURE__ */ I.jsxs("div", { children: [
          /* @__PURE__ */ I.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Unit value:" }),
          /* @__PURE__ */ I.jsxs("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: [
            RO(e),
            " tTRUST"
          ] })
        ] }),
        /* @__PURE__ */ I.jsxs("div", { children: [
          /* @__PURE__ */ I.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Number of transactions:" }),
          /* @__PURE__ */ I.jsx("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: r })
        ] }),
        /* @__PURE__ */ I.jsxs("div", { children: [
          /* @__PURE__ */ I.jsx("div", { style: { fontSize: "0.9em", color: "#6b7280" }, children: "Estimated gas cost:" }),
          /* @__PURE__ */ I.jsxs("div", { style: { fontSize: "1.1em", fontWeight: "bold", color: "#FFD32A" }, children: [
            "~",
            $oe(r),
            " tTRUST"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ I.jsxs("div", { style: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center"
      }, children: [
        /* @__PURE__ */ I.jsxs("div", { style: { fontSize: "1em", fontWeight: "bold" }, children: [
          "Total units selected:",
          /* @__PURE__ */ I.jsxs("span", { style: { fontSize: "1.6em", marginLeft: "10px", color: "#FFD32A" }, children: [
            e,
            " ",
            e === 1 ? "unit" : "units"
          ] })
        ] }),
        e > 0 && /* @__PURE__ */ I.jsx(
          "button",
          {
            onClick: i,
            style: {
              backgroundColor: "transparent",
              border: "1px solid #6b7280",
              color: "#FFF",
              padding: "6px 12px",
              borderRadius: "4px",
              cursor: "pointer",
              fontSize: "0.9em"
            },
            children: "Reset all"
          }
        )
      ] })
    ]
  }
), ele = ({ onClose: r }) => /* @__PURE__ */ I.jsxs(
  "div",
  {
    style: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      marginBottom: "25px",
      borderBottom: "1px solid rgb(105, 105, 105)"
    },
    children: [
      /* @__PURE__ */ I.jsx("h2", { style: { fontSize: "1.3em", color: "#FFD32A", margin: 0, fontWeight: "bold" }, children: "VOTE ON CLAIMS" }),
      r && /* @__PURE__ */ I.jsx(
        "button",
        {
          onClick: r,
          style: {
            backgroundColor: "transparent",
            border: "none",
            color: "#FFF",
            cursor: "pointer",
            fontSize: "1.5em"
          },
          children: "×"
        }
      )
    ]
  }
), tle = ({
  voteItem: r,
  onChangeUnits: e,
  isVoteDirectionAllowed: i = () => !0,
  walletAddress: n = "",
  network: s = ri.MAINNET,
  constants: a
}) => {
  const { UNIT_VALUE: o } = a, {
    id: l,
    subject: u,
    predicate: c,
    object: h,
    units: d,
    direction: p,
    term_position_count: f = 0,
    counter_term_position_count: m = 0,
    userHasPosition: y = !1,
    userPositionDirection: v = lt.None
  } = r, [g, _] = ye(0), [x, b] = ye(!1), [T, E] = ye(!1), M = y, C = v, S = f, w = m, R = 20;
  Ft(() => {
    p === lt.For ? _(d) : p === lt.Against ? _(-d) : _(0);
  }, [d, p]);
  const O = i ? i(l, lt.For) : !M || C === lt.For, P = i ? i(l, lt.Against) : !M || C === lt.Against, A = () => {
    if (!O)
      return;
    const z = Math.min(g + 1, R);
    _(z), e(l, lt.For, z);
  }, D = () => {
    if (!O || g <= 0)
      return;
    const z = g - 1;
    _(z), z === 0 ? e(l, lt.None, 0) : e(l, lt.For, z);
  }, L = () => {
    if (!P)
      return;
    const z = Math.max(g - 1, -R);
    _(z), e(l, lt.Against, Math.abs(z));
  }, H = () => {
    if (!P || g >= 0)
      return;
    const z = g + 1;
    _(z), z === 0 ? e(l, lt.None, 0) : e(l, lt.Against, Math.abs(z));
  }, V = p === lt.For && d > 0, X = p === lt.Against && d > 0, F = Number(o) / 10 ** 18 * d, B = M && C !== lt.None, W = B && C === lt.Against ? "You cannot vote FOR this claim because you already have an AGAINST position" : "", G = B && C === lt.For ? "You cannot vote AGAINST this claim because you already have a FOR position" : "";
  return /* @__PURE__ */ I.jsxs(
    "div",
    {
      style: {
        padding: "20px",
        marginBottom: "20px",
        borderRadius: "8px",
        backgroundColor: "rgba(0, 0, 0, 0.85)",
        position: "relative",
        borderBottom: B ? C === lt.For ? "12px solid #006FE8" : "12px solid #FF9500" : "1px solid rgb(105, 105, 105)",
        borderTop: "1px solid rgb(105, 105, 105)",
        borderLeft: "1px solid rgb(105, 105, 105)",
        borderRight: "1px solid rgb(105, 105, 105)",
        boxShadow: "0 4px 10px rgba(0, 0, 0, 0.3)"
      },
      children: [
        d > 0 && /* @__PURE__ */ I.jsxs(
          "div",
          {
            style: {
              position: "absolute",
              top: "5px",
              left: "5px",
              backgroundColor: "#FFD32A",
              color: "#000000",
              padding: "3px 6px",
              fontSize: "10px",
              fontWeight: "bold",
              borderRadius: "4px"
            },
            children: [
              F.toFixed(2),
              " tTRUST"
            ]
          }
        ),
        /* @__PURE__ */ I.jsxs(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center"
            },
            children: [
              /* @__PURE__ */ I.jsxs(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    position: "relative"
                  },
                  children: [
                    /* @__PURE__ */ I.jsx(
                      "div",
                      {
                        style: { fontSize: "0.9em", color: "#E1E1E1", marginRight: "10px" },
                        children: "For ▲:"
                      }
                    ),
                    C === lt.For || C === lt.None ? /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
                      /* @__PURE__ */ I.jsx(
                        "button",
                        {
                          onClick: O && g > 0 ? D : void 0,
                          disabled: !O || g <= 0,
                          style: {
                            width: "30px",
                            height: "30px",
                            backgroundColor: O && g > 0 ? "#1e2030" : "#606060",
                            border: "none",
                            borderRadius: "4px",
                            color: "#ffffff",
                            fontSize: "16px",
                            cursor: O && g > 0 ? "pointer" : "not-allowed",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            opacity: O && g > 0 ? 1 : 0.4,
                            pointerEvents: O && g > 0 ? "auto" : "none",
                            userSelect: "none"
                          },
                          children: "-"
                        }
                      ),
                      /* @__PURE__ */ I.jsx(
                        "span",
                        {
                          style: {
                            margin: "0 10px",
                            color: "#ffffff",
                            fontWeight: "bold"
                          },
                          children: V ? d : 0
                        }
                      ),
                      /* @__PURE__ */ I.jsxs(
                        "div",
                        {
                          style: { position: "relative" },
                          onMouseEnter: () => W && b(!0),
                          onMouseLeave: () => W && b(!1),
                          children: [
                            /* @__PURE__ */ I.jsx(
                              "button",
                              {
                                onClick: O ? A : void 0,
                                disabled: !O,
                                style: {
                                  width: "30px",
                                  height: "30px",
                                  backgroundColor: O ? "#1976d2" : "#606060",
                                  border: !O && B ? "2px solid #F44336" : "none",
                                  borderRadius: "4px",
                                  color: "#ffffff",
                                  fontSize: "16px",
                                  cursor: O ? "pointer" : "not-allowed",
                                  display: "flex",
                                  alignItems: "center",
                                  justifyContent: "center",
                                  opacity: O ? 1 : 0.4,
                                  pointerEvents: O ? "auto" : "none",
                                  userSelect: "none"
                                },
                                children: "+"
                              }
                            ),
                            (!O && B || x && W) && /* @__PURE__ */ I.jsx(
                              "div",
                              {
                                style: {
                                  position: "absolute",
                                  bottom: "100%",
                                  left: "50%",
                                  transform: "translateX(-50%)",
                                  backgroundColor: "#F44336",
                                  color: "white",
                                  padding: "5px 10px",
                                  borderRadius: "4px",
                                  fontSize: "12px",
                                  whiteSpace: "nowrap",
                                  zIndex: 10,
                                  marginBottom: "5px"
                                },
                                children: W
                              }
                            )
                          ]
                        }
                      )
                    ] }) : /* @__PURE__ */ I.jsx(
                      "div",
                      {
                        style: {
                          backgroundColor: "#606060",
                          borderRadius: "4px",
                          color: "#ffffff",
                          padding: "5px 10px",
                          fontSize: "12px",
                          marginLeft: "10px"
                        },
                        children: "You have voted AGAINST ▼"
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ I.jsxs(
                "div",
                {
                  style: {
                    display: "flex",
                    marginBottom: "20px",
                    gap: "5px",
                    marginTop: "20px"
                  },
                  children: [
                    /* @__PURE__ */ I.jsx(
                      "span",
                      {
                        style: {
                          backgroundColor: "#FFB300",
                          padding: "4px 8px",
                          borderRadius: "4px",
                          fontSize: "0.9em",
                          color: "#000000",
                          fontWeight: "bold"
                        },
                        children: u
                      }
                    ),
                    "-",
                    /* @__PURE__ */ I.jsx(
                      "span",
                      {
                        style: {
                          backgroundColor: "#ccd3d3",
                          padding: "4px 8px",
                          borderRadius: "4px",
                          fontSize: "0.9em",
                          color: "#000000",
                          fontWeight: "bold"
                        },
                        children: c
                      }
                    ),
                    "-",
                    /* @__PURE__ */ I.jsx(
                      "span",
                      {
                        style: {
                          backgroundColor: "#43A047",
                          padding: "4px 8px",
                          borderRadius: "4px",
                          fontSize: "0.9em",
                          color: "#000000",
                          fontWeight: "bold"
                        },
                        children: h
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
                /* @__PURE__ */ I.jsx(
                  "div",
                  {
                    style: { fontSize: "0.9em", color: "#E1E1E1", marginRight: "10px" },
                    children: "Against ▼:"
                  }
                ),
                C === lt.Against || C === lt.None ? /* @__PURE__ */ I.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
                  /* @__PURE__ */ I.jsx(
                    "button",
                    {
                      onClick: P && g < 0 ? H : void 0,
                      disabled: !P || g >= 0,
                      style: {
                        width: "30px",
                        height: "30px",
                        backgroundColor: P && g < 0 ? "#1e2030" : "#606060",
                        border: "none",
                        borderRadius: "4px",
                        color: "#ffffff",
                        fontSize: "16px",
                        cursor: P && g < 0 ? "pointer" : "not-allowed",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        opacity: P && g < 0 ? 1 : 0.4,
                        pointerEvents: P && g < 0 ? "auto" : "none",
                        userSelect: "none"
                      },
                      children: "-"
                    }
                  ),
                  /* @__PURE__ */ I.jsx(
                    "span",
                    {
                      style: {
                        margin: "0 10px",
                        color: "#ffffff",
                        fontWeight: "bold"
                      },
                      children: X ? d : 0
                    }
                  ),
                  /* @__PURE__ */ I.jsxs(
                    "div",
                    {
                      style: { position: "relative" },
                      onMouseEnter: () => G && E(!0),
                      onMouseLeave: () => G && E(!1),
                      children: [
                        /* @__PURE__ */ I.jsx(
                          "button",
                          {
                            onClick: P ? L : void 0,
                            disabled: !P,
                            style: {
                              width: "30px",
                              height: "30px",
                              backgroundColor: P ? "#dc3545" : "#606060",
                              border: !P && B ? "2px solid #4CAF50" : "none",
                              borderRadius: "4px",
                              color: "#ffffff",
                              fontSize: "16px",
                              cursor: P ? "pointer" : "not-allowed",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                              opacity: P ? 1 : 0.4,
                              pointerEvents: P ? "auto" : "none",
                              userSelect: "none"
                            },
                            children: "+"
                          }
                        ),
                        (!P && B || T && G) && /* @__PURE__ */ I.jsx(
                          "div",
                          {
                            style: {
                              position: "absolute",
                              bottom: "100%",
                              left: "50%",
                              transform: "translateX(-50%)",
                              backgroundColor: "#F44336",
                              color: "white",
                              padding: "5px 10px",
                              borderRadius: "4px",
                              fontSize: "12px",
                              whiteSpace: "nowrap",
                              zIndex: 10,
                              marginBottom: "5px"
                            },
                            children: G
                          }
                        )
                      ]
                    }
                  )
                ] }) : /* @__PURE__ */ I.jsx(
                  "div",
                  {
                    style: {
                      backgroundColor: "#606060",
                      borderRadius: "4px",
                      color: "#ffffff",
                      padding: "5px 10px",
                      fontSize: "12px",
                      marginLeft: "10px"
                    },
                    children: "You have voted FOR ▲"
                  }
                )
              ] })
            ]
          }
        ),
        /* @__PURE__ */ I.jsxs("div", { className: "flex flex-row justify-between", children: [
          /* @__PURE__ */ I.jsxs(
            "div",
            {
              style: {
                fontSize: "0.7em",
                color: "#4CAF50",
                marginBottom: "8px",
                backgroundColor: "rgba(76, 175, 80, 0.1)",
                padding: "2px 6px",
                borderRadius: "4px",
                fontWeight: "bold"
              },
              children: [
                S,
                " positions"
              ]
            }
          ),
          /* @__PURE__ */ I.jsxs(
            "div",
            {
              style: {
                fontSize: "0.7em",
                color: "#F44336",
                marginBottom: "8px",
                backgroundColor: "rgba(244, 67, 54, 0.1)",
                padding: "2px 6px",
                borderRadius: "4px",
                fontWeight: "bold"
              },
              children: [
                w,
                " positions"
              ]
            }
          )
        ] })
      ]
    }
  );
}, ile = ({
  isLoading: r,
  loadingProgress: e,
  voteItems: i,
  onChangeUnits: n,
  isVoteDirectionAllowed: s,
  walletAddress: a = "",
  network: o = ri.MAINNET,
  constants: l
}) => {
  if (r) {
    const u = e ? `Loading claims... ${e.loaded}/${e.total}` : "Loading claims...";
    return /* @__PURE__ */ I.jsxs(
      "div",
      {
        style: {
          textAlign: "center",
          padding: "30px",
          color: "#6b7280",
          fontSize: "1.1em"
        },
        children: [
          /* @__PURE__ */ I.jsx("div", { style: { marginBottom: "10px" }, children: u }),
          e && /* @__PURE__ */ I.jsx(
            "div",
            {
              style: {
                width: "100%",
                backgroundColor: "#374151",
                borderRadius: "4px",
                overflow: "hidden",
                marginTop: "10px"
              },
              children: /* @__PURE__ */ I.jsx(
                "div",
                {
                  style: {
                    width: `${e.loaded / e.total * 100}%`,
                    height: "8px",
                    backgroundColor: "#3b82f6",
                    transition: "width 0.3s ease"
                  }
                }
              )
            }
          )
        ]
      }
    );
  }
  return /* @__PURE__ */ I.jsx("div", { style: { marginBottom: "25px" }, children: i.map((u) => /* @__PURE__ */ I.jsx(
    tle,
    {
      voteItem: u,
      onChangeUnits: n,
      isVoteDirectionAllowed: s,
      walletAddress: a,
      network: o,
      constants: l
    },
    u.id.toString()
  )) });
}, rle = ({
  onSubmit: r,
  isSubmitting: e,
  isDepositLoading: i,
  totalUnits: n,
  numberOfTransactions: s
}) => /* @__PURE__ */ I.jsxs("div", { style: { textAlign: "center" }, children: [
  /* @__PURE__ */ I.jsx("div", { style: { marginBottom: "15px", fontSize: "0.9em", color: "#6b7280" }, children: s > 0 && `You will initiate ${s} transaction${s > 1 ? "s" : ""}` }),
  /* @__PURE__ */ I.jsx(
    "button",
    {
      onClick: r,
      disabled: e || i || n === 0,
      style: {
        backgroundColor: n > 0 && !e && !i ? "#1976d2" : "rgb(105, 105, 105)",
        color: "#FFF",
        padding: "12px 30px",
        border: "none",
        borderRadius: "8px",
        fontSize: "1.1em",
        fontWeight: "bold",
        cursor: n > 0 && !e && !i ? "pointer" : "not-allowed",
        width: "100%",
        maxWidth: "350px",
        boxShadow: "0 4px 10px rgba(0, 0, 0, 0.3)",
        transition: "background-color 0.2s ease"
      },
      children: e || i ? "Processing..." : n > 0 ? `Submit votes (${RO(n)} tTRUST)` : "Submit votes"
    }
  )
] }), nle = ({
  transactionStatus: r
}) => r.status === "idle" || r.status === "whitelist_error" ? null : /* @__PURE__ */ I.jsx(
  "div",
  {
    style: {
      marginTop: "25px",
      padding: "20px",
      borderRadius: "8px",
      backgroundColor: r.status === "pending" ? "#10172d" : r.status === "approval_pending" ? "rgba(255, 211, 42, 0.1)" : r.status === "success" ? "rgba(0, 128, 0, 0.1)" : "rgba(255, 0, 0, 0.1)",
      color: r.status === "success" ? "#4CAF50" : r.status === "error" ? "#F44336" : r.status === "approval_pending" ? "#FFD32A" : "#FFF",
      display: "flex",
      flexDirection: "column",
      gap: "10px",
      border: "1px solid #1e3b70"
    },
    children: /* @__PURE__ */ I.jsx("div", { children: r.message })
  }
), sle = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  onClose: n,
  network: s = ri.MAINNET,
  onConnectWallet: a,
  onCreatePlayer: o,
  wagmiConfig: l,
  walletHooks: u,
  constants: c
}) => {
  const [h, d] = ye(!1), [p, f] = ye(!1), [m, y] = ye(!1), { PLAYER_TRIPLE_TYPES: v } = c, {
    loading: g,
    triples: _
  } = fT(
    e || "",
    v.PLAYER_GAME.predicateId,
    v.PLAYER_GAME.objectId,
    s,
    c
    // Passer les constantes personnalisées !
  ), x = _.length > 0;
  Ft(() => {
    y(!!(e && e !== ""));
  }, [e]), Ft(() => {
    f(!!(m && !x && !g));
  }, [m, x, g]);
  const {
    voteItems: b,
    isLoading: T,
    totalUnits: E,
    numberOfTransactions: M,
    handleChangeUnits: C,
    resetAllVotes: S,
    isVoteDirectionAllowed: w
  } = Qoe({
    network: s,
    walletAddress: e,
    onError: (z) => {
      D({
        status: "error",
        message: z
      });
    },
    constants: c
    // Passer les constantes personnalisées !
  }), {
    submitVotes: R,
    isSubmitting: O,
    isDepositLoading: P,
    transactionStatus: A,
    setTransactionStatus: D
  } = Koe({
    walletConnected: r,
    walletAddress: e,
    publicClient: i,
    network: s,
    onSuccess: S
  }), L = async () => {
    await R(b);
  }, H = () => {
    f(!1), d(!0), o && o();
  }, V = () => {
    d(!1);
  }, X = () => {
    f(!1), n && n();
  }, { isCorrectNetwork: F, currentChainId: B, targetChainId: W, allowedChainIds: G } = fC({
    walletConnected: r,
    publicClient: i
  });
  return m ? m && !x && !g ? /* @__PURE__ */ I.jsxs(
    "div",
    {
      style: {
        backgroundColor: "rgba(0, 0, 0, 0.85)",
        minHeight: "100%",
        color: "#fff",
        padding: "15px",
        border: "1px solid rgb(105, 105, 105)",
        borderRadius: "8px",
        maxWidth: "100%",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: [
        /* @__PURE__ */ I.jsx(
          Yoe,
          {
            isOpen: !0,
            onCreatePlayer: H,
            onClose: X
          }
        ),
        /* @__PURE__ */ I.jsx(
          gC,
          {
            isOpen: h,
            onClose: V,
            walletConnected: r,
            walletAddress: e,
            wagmiConfig: l,
            walletHooks: u
          }
        )
      ]
    }
  ) : /* @__PURE__ */ I.jsxs(
    "div",
    {
      style: {
        backgroundColor: "rgba(0, 0, 0, 0.85)",
        minHeight: "100%",
        opacity: "0.9",
        color: "#fff",
        padding: "15px",
        border: "1px solid rgb(105, 105, 105)",
        borderRadius: "8px",
        maxWidth: "100%",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: [
        /* @__PURE__ */ I.jsx(ele, { onClose: n }),
        /* @__PURE__ */ I.jsx(
          Joe,
          {
            numberOfTransactions: M,
            totalUnits: E,
            onResetAll: S
          }
        ),
        /* @__PURE__ */ I.jsx(
          ile,
          {
            isLoading: T || g,
            voteItems: b,
            onChangeUnits: C,
            isVoteDirectionAllowed: w,
            walletAddress: e,
            network: s,
            constants: c
          }
        ),
        /* @__PURE__ */ I.jsx(
          rle,
          {
            onSubmit: L,
            isSubmitting: O,
            isDepositLoading: P,
            totalUnits: E,
            numberOfTransactions: M
          }
        ),
        /* @__PURE__ */ I.jsx(nle, { transactionStatus: A }),
        !F && /* @__PURE__ */ I.jsx(
          mC,
          {
            allowedChainIds: G,
            currentChainId: B,
            targetChainId: W
          }
        )
      ]
    }
  ) : /* @__PURE__ */ I.jsx(
    "div",
    {
      style: {
        backgroundColor: "rgba(0, 0, 0, 0.85)",
        minHeight: "100%",
        opacity: "0.9",
        color: "#fff",
        padding: "15px",
        border: "1px solid rgb(105, 105, 105)",
        borderRadius: "8px",
        maxWidth: "100%",
        margin: "0 auto",
        position: "relative",
        boxShadow: "0 4px 15px rgba(0, 0, 0, 0.3)"
      },
      children: /* @__PURE__ */ I.jsx(
        CO,
        {
          isOpen: !0,
          onConnectWallet: a || (() => {
          })
        }
      )
    }
  );
}, ale = ({
  walletConnected: r,
  walletAddress: e,
  publicClient: i,
  onClose: n,
  constants: s,
  wagmiConfig: a
}) => (Ft(() => (document.body.style.overflow = "hidden", () => {
  document.body.style.overflow = "auto";
}), []), /* @__PURE__ */ I.jsx(
  "div",
  {
    className: "fixed inset-0 flex items-center justify-center height-700px",
    style: {
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      zIndex: 1e3
    },
    children: /* @__PURE__ */ I.jsx(
      "div",
      {
        style: {
          backgroundColor: "#18181b",
          borderRadius: "12px",
          boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
          maxWidth: "1000px",
          width: "100%",
          maxHeight: "700px",
          height: "700px",
          display: "flex",
          flexDirection: "column",
          overflow: "hidden",
          opacity: 0.85
        },
        children: /* @__PURE__ */ I.jsx("div", { style: {
          flex: 1,
          overflow: "auto",
          padding: "0"
        }, children: /* @__PURE__ */ I.jsx(
          sle,
          {
            walletConnected: r,
            walletAddress: e,
            publicClient: i,
            onClose: n,
            network: "mainnet",
            wagmiConfig: a,
            constants: s
          }
        ) })
      }
    )
  }
)), NO = new uoe({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: !1
    }
  }
});
DO({
  queryClient: NO
});
const ole = ({
  children: r
}) => /* @__PURE__ */ I.jsx(hoe, { client: NO, children: r }), lle = (r) => gm(() => r != null && r.constants ? {
  ...r.constants,
  UNIT_VALUE: r_
  // Toujours depuis Player-map, jamais paramétrable
} : {
  ...xoe,
  UNIT_VALUE: r_
}, [r == null ? void 0 : r.constants]), ule = "https://testnet.intuition.sh/v1/graphql";
function cle() {
  moe({ apiUrl: ule });
}
const Lle = ({
  walletConnected: r = !1,
  walletAddress: e = "",
  wagmiConfig: i,
  walletHooks: n,
  onClose: s,
  onCreatePlayer: a,
  onConnectWallet: o,
  config: l
  // Configuration avec constantes personnalisées
}) => {
  Ft(() => {
    cle();
  }, []);
  const u = lle(l), [c, h] = ye(ri.MAINNET), [d, p] = ye(!1), [f, m] = ye(!1), [y, v] = ye(!1), [g, _] = ye([]), [x, b] = ye(!1), [T, E] = ye(null), M = Gi(0), C = Gi(0), S = Gi(!1), w = e || "";
  Ft(() => {
    v(!!(e && e !== ""));
  }, [e]);
  const {
    loading: R,
    error: O,
    triples: P
  } = fT(w, u.PLAYER_TRIPLE_TYPES.PLAYER_GAME.predicateId, u.PLAYER_TRIPLE_TYPES.PLAYER_GAME.objectId, c), A = gm(() => !P || P.length === 0 ? [] : [...P], [P]), D = gm(() => !A || A.length === 0 ? "" : A.filter(
    (K) => K.predicate_id === u.PLAYER_TRIPLE_TYPES.PLAYER_GAME.predicateId && K.object_id === u.PLAYER_TRIPLE_TYPES.PLAYER_GAME.objectId
  ).map((K) => K.term_id).sort().join(","), [A, u.PLAYER_TRIPLE_TYPES.PLAYER_GAME.predicateId, u.PLAYER_TRIPLE_TYPES.PLAYER_GAME.objectId]);
  Ft(() => {
    (async () => {
      var pe, xe, Re, nt;
      if (!y || !e) {
        _([]), E(null);
        return;
      }
      if (S.current)
        return;
      const K = Date.now();
      if (K - C.current < 3e4) {
        console.warn("[GraphComponent] Skip fetch: Too many requests recently (429 error)");
        return;
      }
      if (R || O)
        return;
      if (!A || A.length === 0) {
        _([]);
        return;
      }
      if (K - M.current < 1e3) {
        console.warn("[GraphComponent] Skip fetch: Too frequent requests");
        return;
      }
      M.current = K, S.current = !0, b(!0), E(null);
      try {
        const gt = A.filter(
          (Be) => Be.predicate_id === u.PLAYER_TRIPLE_TYPES.PLAYER_GAME.predicateId && Be.object_id === u.PLAYER_TRIPLE_TYPES.PLAYER_GAME.objectId
        ).map((Be) => Be.term_id);
        if (gt.length === 0) {
          _([]);
          return;
        }
        const Q = Pr[c], Qe = await (await fetch(Q, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: `
              query GetPlayerPositions($accountId: String!, $termIds: [String!]!) {
                positions(where: { 
                  account_id: { _eq: $accountId },
                  term_id: { _in: $termIds },
                  shares: { _gt: 0 }
                }) {
                  id
                  shares
                  curve_id
                  account {
                    id
                    label
                    image
                    atom_id
                    type
                  }
                  term {
                    id
                    total_market_cap
                    total_assets
                    atom {
                      label
                    }
                    triple {
                      subject {
                        label
                      }
                      predicate {
                        label
                      }
                      object {
                        label
                      }
                      counter_term {
                        id
                        total_market_cap
                        total_assets
                        atom {
                          label
                        }
                        triple {
                          subject {
                            label
                          }
                          predicate {
                            label
                          }
                          object {
                            label
                          }
                        }
                      }
                    }
                  }
                  vault {
                    deposits {
                      vault_type
                    }
                    redemptions {
                      vault_type
                    }
                  }
                }
              }
            `,
            variables: {
              accountId: e,
              termIds: gt
            }
          })
        })).json();
        if (Qe.errors)
          throw console.error("[GraphComponent] GraphQL errors:", Qe.errors), new Error(((pe = Qe.errors[0]) == null ? void 0 : pe.message) || "GraphQL error");
        const bt = ((xe = Qe.data) == null ? void 0 : xe.positions) || [];
        _(bt);
      } catch (fe) {
        console.error("Error fetching positions:", fe), ((Re = fe == null ? void 0 : fe.message) != null && Re.includes("429") || (fe == null ? void 0 : fe.status) === 429 || ((nt = fe == null ? void 0 : fe.response) == null ? void 0 : nt.status) === 429) && (C.current = Date.now(), console.warn("[GraphComponent] Rate limit hit (429), will retry after 30 seconds")), E(fe);
      } finally {
        S.current = !1, b(!1);
      }
    })();
  }, [y, e, c, D, R, O]);
  const L = A.length > 0, H = g.length > 0, V = L && H, X = R || x, F = O, B = mr(() => {
    a && a(), p(!0);
  }, [a]), W = mr(() => {
    p(!1), s && s();
  }, [s]), G = mr(() => {
    o && o();
  }, [o]);
  return F ? /* @__PURE__ */ I.jsxs("div", { style: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100%",
    flexDirection: "column",
    gap: "20px"
  }, children: [
    /* @__PURE__ */ I.jsx("h2", { style: { color: "red", textAlign: "center" }, children: "Erreur lors du chargement des données" }),
    /* @__PURE__ */ I.jsx("p", { style: { textAlign: "center", color: "#666" }, children: F.message || "Une erreur inattendue s'est produite" }),
    /* @__PURE__ */ I.jsx(
      "button",
      {
        onClick: () => window.location.reload(),
        style: {
          padding: "10px 20px",
          backgroundColor: "#FFD32A",
          color: "#000",
          border: "none",
          borderRadius: "5px",
          cursor: "pointer"
        },
        children: "Recharger la page"
      }
    )
  ] }) : X ? /* @__PURE__ */ I.jsxs("div", { style: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100%",
    flexDirection: "column",
    gap: "20px"
  }, children: [
    /* @__PURE__ */ I.jsx("div", { style: {
      width: "50px",
      height: "50px",
      border: "4px solid #FFD32A",
      borderTop: "4px solid transparent",
      borderRadius: "50%",
      animation: "spin 1s linear infinite"
    } }),
    /* @__PURE__ */ I.jsx("p", { style: { textAlign: "center", color: "#666" }, children: "Chargement des données du joueur..." })
  ] }) : /* @__PURE__ */ I.jsx(ole, { children: /* @__PURE__ */ I.jsxs("div", { style: { position: "relative", width: "100%", height: "100%" }, children: [
    /* @__PURE__ */ I.jsx(
      CO,
      {
        isOpen: !y,
        onConnectWallet: G
      }
    ),
    (!y || y && !V) && /* @__PURE__ */ I.jsx("div", { style: {
      filter: y ? "none" : "blur(3px)",
      opacity: y ? 1 : 0.7,
      position: "relative"
    }, children: /* @__PURE__ */ I.jsx(
      UO,
      {
        walletConnected: y,
        walletAddress: e,
        wagmiConfig: i,
        walletHooks: n,
        onCreatePlayer: B
      }
    ) }),
    y && V && /* @__PURE__ */ I.jsx(
      Xoe,
      {
        walletAddress: e,
        walletConnected: r,
        walletHooks: n,
        onOpenVoting: () => m(!0),
        constants: u,
        gamesId: u.COMMON_IDS.GAMES_ID,
        wagmiConfig: i
      }
    ),
    /* @__PURE__ */ I.jsx(
      gC,
      {
        isOpen: d,
        onClose: W,
        walletConnected: r,
        walletAddress: e,
        wagmiConfig: i,
        walletHooks: n,
        constants: u
      }
    ),
    f && y && V && /* @__PURE__ */ I.jsx(
      ale,
      {
        walletConnected: r,
        walletAddress: e,
        publicClient: i == null ? void 0 : i.publicClient,
        wagmiConfig: i,
        onClose: () => m(!1),
        constants: u
      }
    )
  ] }) });
}, kle = ({
  walletAddress: r,
  tripleId: e,
  network: i = ri.MAINNET
}) => {
  const [n, s] = ye(!1), [a, o] = ye(null), [l, u] = ye(!0), [c, h] = ye(null), [d, p] = ye(0), [f, m] = ye(0);
  return Ft(() => {
    (async () => {
      var v, g, _, x, b, T, E, M, C, S, w, R, O, P, A, D, L, H, V;
      if (!r || !e) {
        u(!1);
        return;
      }
      try {
        u(!0);
        const X = Pr[i], F = await fetch(X, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: `
              query GetTripleUserPosition($tripleId: String!, $walletAddress: String!) {
                # Get the triple with vault information
                triple(term_id: $tripleId) {
                  term_id
                  subject {
                    label
                  }
                  predicate {
                    label
                  }
                  object {
                    label
                  }
                  term_id
                  counter_term_id
                  
                  # Get vault positions (user only)
                  term {
                    id
                    positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}, shares: {_gt: 0}}) {
                      aggregate {
                        count
                      }
                      nodes {
                        id
                      }
                    }
                  }
                  
                  # Get counter vault positions (user only)
                  counter_term {
                    id
                    positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}, shares: {_gt: 0}}) {
                      aggregate {
                        count
                      }
                      nodes {
                        id
                      }
                    }
                  }
                }
              }
            `,
            variables: {
              tripleId: String(e),
              walletAddress: r.toLowerCase()
            }
          })
        });
        if (!F.ok)
          throw new Error(`GraphQL request failed with status ${F.status}`);
        const B = await F.json();
        if (B.errors)
          throw console.error("GraphQL errors:", B.errors), new Error(`GraphQL errors: ${JSON.stringify(B.errors)}`);
        const W = (v = B.data) == null ? void 0 : v.triple;
        if (!W) {
          s(!1), o(null), u(!1);
          return;
        }
        const G = ((x = (_ = (g = W.term) == null ? void 0 : g.positions_aggregate) == null ? void 0 : _.aggregate) == null ? void 0 : x.count) > 0 || ((E = (T = (b = W.term) == null ? void 0 : b.positions_aggregate) == null ? void 0 : T.nodes) == null ? void 0 : E.length) > 0, z = ((S = (C = (M = W.counter_term) == null ? void 0 : M.positions_aggregate) == null ? void 0 : C.aggregate) == null ? void 0 : S.count) > 0 || ((O = (R = (w = W.counter_term) == null ? void 0 : w.positions_aggregate) == null ? void 0 : R.nodes) == null ? void 0 : O.length) > 0;
        p(((D = (A = (P = W.term) == null ? void 0 : P.positions_aggregate) == null ? void 0 : A.aggregate) == null ? void 0 : D.count) || 0), m(((V = (H = (L = W.counter_term) == null ? void 0 : L.positions_aggregate) == null ? void 0 : H.aggregate) == null ? void 0 : V.count) || 0);
        const K = G || z;
        s(K), K && o(G), u(!1);
      } catch (X) {
        console.error("Error checking triple position:", X), h(X), u(!1);
      }
    })();
  }, [r, e, i]), { hasPosition: n, isFor: a, loading: l, error: c, termPositionCount: d, counterTermPositionCount: f };
}, Ule = (r) => {
  const [e, i] = ye(null), [n, s] = ye(!0), [a, o] = ye(null);
  return Ft(() => {
    (async () => {
      if (!r) {
        s(!1);
        return;
      }
      try {
        s(!0);
        const h = await (await fetch(Pr[ri.MAINNET], {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            query: `
          query GetTriplesWithPositions($accountId: String!) {
            triples {
              term_id
              counter_term_id
              subject_id
              predicate_id
              object_id
              positions(where: { account_id: { _eq: $accountId } }) {
                account_id
                term_id
                shares
                account {
                  id
                  label
                }
              }
              term {
                id
                total_market_cap
                total_assets
                positions(where: { account_id: { _eq: $accountId } }) {
                  account_id
                  shares
                }
              }
              counter_term {
                id
                total_market_cap
                total_assets
                positions(where: { account_id: { _eq: $accountId } }) {
                  account_id
                  shares
                }
              }
            }
          }
        `,
            variables: { accountId: r }
          })
        })).json();
        if (h.errors)
          throw console.error("GraphQL Errors:", h.errors), new Error(h.errors[0].message);
        const d = {
          triples: h.data.triples,
          positions: h.data.triples.flatMap((p) => {
            var f, m;
            return [
              ...p.positions || [],
              ...((f = p.term) == null ? void 0 : f.positions) || [],
              ...((m = p.counter_term) == null ? void 0 : m.positions) || []
            ];
          })
        };
        i(d), s(!1);
      } catch (u) {
        console.error("Erreur lors de la récupération des triples:", u), o(u), s(!1);
      }
    })();
  }, [r]), { data: e, loading: n, error: a };
}, Fle = async (r, e, i = ri.MAINNET) => {
  var n, s, a, o, l, u, c, h, d, p, f, m, y;
  if (!r)
    throw new Error("Wallet address is required");
  try {
    const v = Pr[i], g = await fetch(v, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `
          query GetTripleUserPosition($tripleId: numeric!, $walletAddress: String!) {
            # Get the triple with vault information
            triple(term_id: $tripleId) {
              id
              subject {
                label
              }
              predicate {
                label
              }
              object {
                label
              }
              term_id
              counter_term_id
              
              # Get vault positions
              term {
                id
                positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                  aggregate {
                    count
                  }
                  nodes {
                    id
                  }
                }
              }
              
              # Get counter vault positions
              counter_term {
                id
                positions_aggregate(where: {account: {id: {_ilike: $walletAddress}}}) {
                  aggregate {
                    count
                  }
                  nodes {
                    id
                  }
                }
              }
            }
          }
        `,
        variables: {
          tripleId: Number(e),
          walletAddress: r.toLowerCase()
        }
      })
    });
    if (!g.ok)
      throw new Error(`GraphQL request failed with status ${g.status}`);
    const _ = await g.json();
    if (_.errors)
      throw console.error("GraphQL errors:", _.errors), new Error(`GraphQL errors: ${JSON.stringify(_.errors)}`);
    const x = (n = _.data) == null ? void 0 : n.triple;
    if (!x)
      return {
        hasPosition: !1,
        isFor: null,
        result: _.data
      };
    const b = ((o = (a = (s = x.term) == null ? void 0 : s.positions_aggregate) == null ? void 0 : a.aggregate) == null ? void 0 : o.count) > 0 || ((c = (u = (l = x.term) == null ? void 0 : l.positions_aggregate) == null ? void 0 : u.nodes) == null ? void 0 : c.length) > 0, T = ((p = (d = (h = x.counter_term) == null ? void 0 : h.positions_aggregate) == null ? void 0 : d.aggregate) == null ? void 0 : p.count) > 0 || ((y = (m = (f = x.counter_term) == null ? void 0 : f.positions_aggregate) == null ? void 0 : m.nodes) == null ? void 0 : y.length) > 0, E = b || T;
    return {
      hasPosition: E,
      isFor: E ? b : null,
      result: _.data
      // Return raw data for debugging
    };
  } catch (v) {
    throw console.error("Error checking triple position:", v), v;
  }
};
let n_ = null;
const hle = () => {
  if (!n_)
    throw new Error(
      "Configuration Player-map non initialisée. Utilisez PlayerMapConfig.init() pour configurer la bibliothèque."
    );
  return { ...n_ };
}, dle = (r) => {
  if (!r.apiUrl)
    throw new Error("L'URL de l'API est requise pour initialiser Player-map");
  n_ = {
    apiUrl: r.apiUrl
  };
}, Ble = {
  /**
   * Initialise la configuration de la bibliothèque Player-map
   * @param config Configuration contenant l'URL de l'API (obligatoire)
   */
  init: (r) => {
    if (!r.apiUrl)
      throw new Error(
        "L'URL de l'API est obligatoire pour initialiser Player-map"
      );
    return dle(r), !0;
  },
  /**
   * Récupère la configuration actuelle
   * @throws Error si la configuration n'a pas été initialisée
   */
  get: hle
};
export {
  sle as ClaimVoting,
  Lle as GraphComponent,
  boe as PREDEFINED_CLAIM_IDS,
  Ble as PlayerMapConfig,
  Xoe as PlayerMapGraph,
  UO as PlayerMapHome,
  gC as RegistrationForm,
  r_ as UNIT_VALUE,
  lt as VoteDirection,
  ale as VotingModal,
  Fle as checkTriplePosition,
  UO as default,
  Dle as setPinataConstants,
  kle as useCheckSpecificTriplePosition,
  wO as useDepositTriple,
  Ule as useDisplayTriplesWithPosition
};
